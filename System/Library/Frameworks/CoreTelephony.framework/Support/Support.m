void qmi::MutableMessageBase::TlvWrapper<elqm::tlv::SubscriptionId>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<elqm::tlv::SubscriptionId>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

uint64_t qmi::MutableMessageBase::TlvWrapper<elqm::tlv::TrafficClassReport>::getSize(uint64_t a1)
{
  return tlv::size<vs::tlv::CallingNumber>((_QWORD *)(a1 + 16));
}

uint64_t tlv::size<wds::tlv::IPPref>()
{
  return 4;
}

uint64_t tlv::size<vs::tlv::CallingNumber>(_QWORD *a1)
{
  return a1[1] - *a1 + 3;
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<elqm::tlv::SubscriptionId>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

_BYTE **tlv::writeV<wds::tlv::LocalAbort>(_BYTE **result, _BYTE *a2)
{
  _BYTE *v2;

  v2 = *result;
  *v2 = *a2;
  *result = v2 + 1;
  return result;
}

void ___ZN27QMIEnhancedLQMCommandDriver24handleClientStarted_syncEv_block_invoke(capabilities::ct *a1, qmi::MessageBase *a2)
{
  uint64_t v3;
  uint64_t TlvValue;
  int v5;
  uint64_t v6;
  int v7;
  unsigned __int8 v8;
  uint64_t v9;
  NSObject *v10;
  char *v11;
  int v12;
  char *v13;
  int v14;
  char *v15;
  uint64_t v16;
  char *v17;
  int v18;
  char *v19;
  int v20;
  char *v21;
  uint64_t v22;
  char *v23;
  int v24;
  char *v25;
  int v26;
  char *v27;
  uint64_t v28;
  char *v29;
  int v30;
  char *v31;
  int v32;
  char *v33;
  uint64_t v34;
  char *v35;
  int v36;
  char *v37;
  int v38;
  char *v39;
  uint64_t v40;
  char *v41;
  int v42;
  char *v43;
  int v44;
  char *v45;
  uint64_t v46;
  char *v47;
  int v48;
  char *v49;
  int v50;
  char *v51;
  uint64_t v52;
  char *v53;
  int v54;
  char *v55;
  int v56;
  char *v57;
  uint64_t v58;
  char *v59;
  int v60;
  char *v61;
  int v62;
  char *v63;
  uint64_t v64;
  uint64_t v65;
  void *v66;
  _BYTE *v67;
  uint64_t v68;
  char *v69;
  __int128 __p;
  uint64_t v71;
  uint64_t v72;

  v72 = *MEMORY[0x24BDAC8D0];
  v3 = *((_QWORD *)a1 + 4);
  if (capabilities::ct::supportsGemini(a1))
  {
    TlvValue = qmi::MessageBase::findTlvValue(a2);
    if (!TlvValue)
      goto LABEL_6;
    v6 = TlvValue;
    v7 = v5;
    *(_QWORD *)&__p = TlvValue;
    v8 = tlv::parseV<elqm::tlv::SubscriptionId>((unint64_t *)&__p, v5);
    if ((_QWORD)__p)
    {
      v9 = subscriber::instanceAsSimSlot((subscriber *)v8);
      goto LABEL_9;
    }
    if ((((uint64_t (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 31, v6, v7) & 1) == 0)
    {
LABEL_6:
      v10 = *(NSObject **)(v3 + 40);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        v65 = subscriber::asString();
        LODWORD(__p) = 136315138;
        *(_QWORD *)((char *)&__p + 4) = v65;
        _os_log_error_impl(&dword_216897000, v10, OS_LOG_TYPE_ERROR, "Missing subscription ID TLV, assuming %s", (uint8_t *)&__p, 0xCu);
      }
    }
  }
  v9 = 1;
LABEL_9:
  v11 = (char *)qmi::MessageBase::findTlvValue(a2);
  v13 = v11;
  if (v11)
  {
    v14 = v12;
    v68 = 0;
    v69 = v11;
    v66 = 0;
    v67 = 0;
    tlv::parseV<elqm::tlv::LinkState>(&v69, v12, &v66);
    v15 = v69;
    if (v69)
    {
      v16 = *(_QWORD *)(v3 + 72);
      v71 = 0;
      __p = 0uLL;
      std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(&__p, v66, (uint64_t)v67, v67 - (_BYTE *)v66);
      (*(void (**)(uint64_t, uint64_t, uint64_t, __int128 *))(*(_QWORD *)v16 + 24))(v16, v9, 16, &__p);
      if ((_QWORD)__p)
      {
        *((_QWORD *)&__p + 1) = __p;
        operator delete((void *)__p);
      }
    }
    if (v66)
    {
      v67 = v66;
      operator delete(v66);
    }
    if (!v15)
      ((void (*)(_QWORD, uint64_t, char *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 16, v13, v14);
  }
  v17 = (char *)qmi::MessageBase::findTlvValue(a2);
  v19 = v17;
  if (v17)
  {
    v20 = v18;
    v68 = 0;
    v69 = v17;
    v66 = 0;
    v67 = 0;
    tlv::parseV<elqm::tlv::LinkQualityFingerPrint>(&v69, v18, &v66);
    v21 = v69;
    if (v69)
    {
      v22 = *(_QWORD *)(v3 + 72);
      v71 = 0;
      __p = 0uLL;
      std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(&__p, v66, (uint64_t)v67, v67 - (_BYTE *)v66);
      (*(void (**)(uint64_t, uint64_t, uint64_t, __int128 *))(*(_QWORD *)v22 + 24))(v22, v9, 17, &__p);
      if ((_QWORD)__p)
      {
        *((_QWORD *)&__p + 1) = __p;
        operator delete((void *)__p);
      }
    }
    if (v66)
    {
      v67 = v66;
      operator delete(v66);
    }
    if (!v21)
      ((void (*)(_QWORD, uint64_t, char *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 17, v19, v20);
  }
  v23 = (char *)qmi::MessageBase::findTlvValue(a2);
  v25 = v23;
  if (v23)
  {
    v26 = v24;
    v68 = 0;
    v69 = v23;
    v66 = 0;
    v67 = 0;
    tlv::parseV<elqm::tlv::TrafficClass>(&v69, v24, &v66);
    v27 = v69;
    if (v69)
    {
      v28 = *(_QWORD *)(v3 + 72);
      v71 = 0;
      __p = 0uLL;
      std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(&__p, v66, (uint64_t)v67, v67 - (_BYTE *)v66);
      (*(void (**)(uint64_t, uint64_t, uint64_t, __int128 *))(*(_QWORD *)v28 + 24))(v28, v9, 18, &__p);
      if ((_QWORD)__p)
      {
        *((_QWORD *)&__p + 1) = __p;
        operator delete((void *)__p);
      }
    }
    if (v66)
    {
      v67 = v66;
      operator delete(v66);
    }
    if (!v27)
      ((void (*)(_QWORD, uint64_t, char *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 18, v25, v26);
  }
  v29 = (char *)qmi::MessageBase::findTlvValue(a2);
  v31 = v29;
  if (v29)
  {
    v32 = v30;
    v68 = 0;
    v69 = v29;
    v66 = 0;
    v67 = 0;
    tlv::parseV<elqm::tlv::DataTransferTime>(&v69, v30, &v66);
    v33 = v69;
    if (v69)
    {
      v34 = *(_QWORD *)(v3 + 72);
      v71 = 0;
      __p = 0uLL;
      std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(&__p, v66, (uint64_t)v67, v67 - (_BYTE *)v66);
      (*(void (**)(uint64_t, uint64_t, uint64_t, __int128 *))(*(_QWORD *)v34 + 24))(v34, v9, 19, &__p);
      if ((_QWORD)__p)
      {
        *((_QWORD *)&__p + 1) = __p;
        operator delete((void *)__p);
      }
    }
    if (v66)
    {
      v67 = v66;
      operator delete(v66);
    }
    if (!v33)
      ((void (*)(_QWORD, uint64_t, char *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 19, v31, v32);
  }
  v35 = (char *)qmi::MessageBase::findTlvValue(a2);
  v37 = v35;
  if (v35)
  {
    v38 = v36;
    v68 = 0;
    v69 = v35;
    v66 = 0;
    v67 = 0;
    tlv::parseV<elqm::tlv::DataTransferTimeEnabled>(&v69, v36, &v66);
    v39 = v69;
    if (v69)
    {
      v40 = *(_QWORD *)(v3 + 72);
      v71 = 0;
      __p = 0uLL;
      std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(&__p, v66, (uint64_t)v67, v67 - (_BYTE *)v66);
      (*(void (**)(uint64_t, uint64_t, uint64_t, __int128 *))(*(_QWORD *)v40 + 24))(v40, v9, 20, &__p);
      if ((_QWORD)__p)
      {
        *((_QWORD *)&__p + 1) = __p;
        operator delete((void *)__p);
      }
    }
    if (v66)
    {
      v67 = v66;
      operator delete(v66);
    }
    if (!v39)
      ((void (*)(_QWORD, uint64_t, char *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 20, v37, v38);
  }
  v41 = (char *)qmi::MessageBase::findTlvValue(a2);
  v43 = v41;
  if (v41)
  {
    v44 = v42;
    v68 = 0;
    v69 = v41;
    v66 = 0;
    v67 = 0;
    tlv::parseV<elqm::tlv::LinkPowerCost>(&v69, v42, &v66);
    v45 = v69;
    if (v69)
    {
      v46 = *(_QWORD *)(v3 + 72);
      v71 = 0;
      __p = 0uLL;
      std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(&__p, v66, (uint64_t)v67, v67 - (_BYTE *)v66);
      (*(void (**)(uint64_t, uint64_t, uint64_t, __int128 *))(*(_QWORD *)v46 + 24))(v46, v9, 21, &__p);
      if ((_QWORD)__p)
      {
        *((_QWORD *)&__p + 1) = __p;
        operator delete((void *)__p);
      }
    }
    if (v66)
    {
      v67 = v66;
      operator delete(v66);
    }
    if (!v45)
      ((void (*)(_QWORD, uint64_t, char *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 21, v43, v44);
  }
  v47 = (char *)qmi::MessageBase::findTlvValue(a2);
  v49 = v47;
  if (v47)
  {
    v50 = v48;
    v68 = 0;
    v69 = v47;
    v66 = 0;
    v67 = 0;
    tlv::parseV<elqm::tlv::DataStallEnabled>(&v69, v48, &v66);
    v51 = v69;
    if (v69)
    {
      v52 = *(_QWORD *)(v3 + 72);
      v71 = 0;
      __p = 0uLL;
      std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(&__p, v66, (uint64_t)v67, v67 - (_BYTE *)v66);
      (*(void (**)(uint64_t, uint64_t, uint64_t, __int128 *))(*(_QWORD *)v52 + 24))(v52, v9, 22, &__p);
      if ((_QWORD)__p)
      {
        *((_QWORD *)&__p + 1) = __p;
        operator delete((void *)__p);
      }
    }
    v47 = (char *)v66;
    if (v66)
    {
      v67 = v66;
      operator delete(v66);
    }
    if (!v51)
      v47 = (char *)((uint64_t (*)(_QWORD, uint64_t, char *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 22, v49, v50);
  }
  if (capabilities::ct::supports5G((capabilities::ct *)v47))
  {
    v53 = (char *)qmi::MessageBase::findTlvValue(a2);
    v55 = v53;
    if (v53)
    {
      v56 = v54;
      v68 = 0;
      v69 = v53;
      v66 = 0;
      v67 = 0;
      tlv::parseV<elqm::tlv::HighThroughputEnabled>(&v69, v54, &v66);
      v57 = v69;
      if (v69)
      {
        v58 = *(_QWORD *)(v3 + 72);
        v71 = 0;
        __p = 0uLL;
        std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(&__p, v66, (uint64_t)v67, v67 - (_BYTE *)v66);
        (*(void (**)(uint64_t, uint64_t, uint64_t, __int128 *))(*(_QWORD *)v58 + 24))(v58, v9, 23, &__p);
        if ((_QWORD)__p)
        {
          *((_QWORD *)&__p + 1) = __p;
          operator delete((void *)__p);
        }
      }
      if (v66)
      {
        v67 = v66;
        operator delete(v66);
      }
      if (!v57)
        ((void (*)(_QWORD, uint64_t, char *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 23, v55, v56);
    }
    v59 = (char *)qmi::MessageBase::findTlvValue(a2);
    v61 = v59;
    if (v59)
    {
      v62 = v60;
      v68 = 0;
      v69 = v59;
      v66 = 0;
      v67 = 0;
      tlv::parseV<elqm::tlv::NRServingCellTypeEnabled>(&v69, v60, &v66);
      v63 = v69;
      if (v69)
      {
        v64 = *(_QWORD *)(v3 + 72);
        v71 = 0;
        __p = 0uLL;
        std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(&__p, v66, (uint64_t)v67, v67 - (_BYTE *)v66);
        (*(void (**)(uint64_t, uint64_t, uint64_t, __int128 *))(*(_QWORD *)v64 + 24))(v64, v9, 24, &__p);
        if ((_QWORD)__p)
        {
          *((_QWORD *)&__p + 1) = __p;
          operator delete((void *)__p);
        }
      }
      if (v66)
      {
        v67 = v66;
        operator delete(v66);
      }
      if (!v63)
        ((void (*)(_QWORD, uint64_t, char *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 24, v61, v62);
    }
  }
}

void sub_216899120(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14)
{
  if (__p)
    operator delete(__p);
  if (a9)
    operator delete(a9);
  _Unwind_Resume(exception_object);
}

uint64_t QMIDataCommandDriver::reportPdpStatistics(uint64_t a1, _QWORD **a2)
{
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  BOOL v19;
  uint64_t *v20;
  const void **v21;
  char *v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  char *v31;
  uint64_t *v32;
  char *v33;
  char *v34;
  uint64_t v35;
  uint64_t *v36;
  int v37;
  unint64_t *v38;
  unint64_t v39;
  void *v40;
  std::__shared_weak_count *v41;
  unint64_t *v42;
  unint64_t v43;
  _QWORD *v44;
  _QWORD *v45;
  BOOL v46;
  uint64_t v47;
  uint64_t *v48;
  _QWORD v49[6];
  std::__shared_weak_count *v50;
  int v51;
  uint64_t *v52;
  uint64_t v53;
  int v54;
  uint64_t v55;
  void *v56;
  _QWORD v57[2];
  double (*v58)(uint64_t, uint64_t);
  void *v59;
  uint64_t v60;
  char v61;
  std::string __p;
  char v63;
  __int128 v64;
  __int128 v65;
  uint64_t v66;
  char v67;
  _BYTE v68[39];
  uint64_t v69;
  std::__shared_weak_count *v70;
  _QWORD aBlock[7];

  v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (!v3)
    return 0;
  v5 = std::__shared_weak_count::lock(v3);
  v70 = v5;
  if (!v5)
    return 0;
  v6 = v5;
  v7 = *(_QWORD *)(a1 + 40);
  v69 = v7;
  if (!v7 || ((*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 496))(v7) & 1) != 0)
  {
    v8 = 0;
LABEL_6:
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v10 = __ldaxr(p_shared_owners);
    while (__stlxr(v10 - 1, p_shared_owners));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
    return v8;
  }
  v13 = (uint64_t)(*a2 + 1);
  v12 = (_QWORD *)**a2;
  v8 = 1;
  if (v12 == (_QWORD *)v13)
    goto LABEL_6;
  v48 = (uint64_t *)(a1 + 360);
  do
  {
    v14 = *((unsigned int *)v12 + 8);
    memset(v68, 0, sizeof(v68));
    v67 = *((_BYTE *)v12 + 48);
    v66 = v12[5];
    if (*((char *)v12 + 79) < 0)
    {
      std::string::__init_copy_ctor_external((std::string *)&v68[7], (const std::string::value_type *)v12[7], v12[8]);
    }
    else
    {
      *(_OWORD *)&v68[7] = *(_OWORD *)(v12 + 7);
      *(_QWORD *)&v68[23] = v12[9];
    }
    v68[31] = *((_BYTE *)v12 + 80);
    if (v67)
    {
      v15 = v69;
      if (((*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v69 + 920))(v69, v14) & 1) != 0)
      {
        v16 = *v48;
        if (*v48)
        {
          v17 = a1 + 360;
          do
          {
            v18 = *(_DWORD *)(v16 + 32);
            v19 = v18 < (int)v14;
            if (v18 >= (int)v14)
              v20 = (uint64_t *)v16;
            else
              v20 = (uint64_t *)(v16 + 8);
            if (!v19)
              v17 = v16;
            v16 = *v20;
          }
          while (*v20);
          if ((uint64_t *)v17 != v48 && (int)v14 >= *(_DWORD *)(v17 + 32))
          {
            v64 = 0u;
            v65 = 0u;
            qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)&v64);
            v57[0] = MEMORY[0x24BDAC760];
            v57[1] = 1174405120;
            v58 = ___ZNK20QMIDataCommandDriver19reportPdpStatisticsERKNSt3__110shared_ptrIKNS0_3mapIjN29PdpStatisticsServiceInterface9PdpStatusENS0_4lessIjEENS0_9allocatorINS0_4pairIKjS4_EEEEEEEE_block_invoke;
            v59 = &__block_descriptor_tmp_166_0;
            v60 = v66;
            v61 = v67;
            if ((v68[30] & 0x80000000) != 0)
              std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)&v68[7], *(std::string::size_type *)&v68[15]);
            else
              __p = *(std::string *)&v68[7];
            v63 = v68[31];
            v21 = (const void **)*((_QWORD *)&v64 + 1);
            if (*((_QWORD *)&v64 + 1) != (_QWORD)v65)
            {
              while (*((_BYTE *)*v21 + 8) != 1)
              {
                if (++v21 == (const void **)v65)
                  goto LABEL_39;
              }
            }
            if (v21 == (const void **)v65)
            {
LABEL_39:
              v24 = operator new();
              v25 = v24;
              *(_BYTE *)(v24 + 8) = 1;
              *(_DWORD *)(v24 + 12) = 0;
              v23 = (char *)(v24 + 12);
              *(_QWORD *)v24 = &off_24D5D0970;
              *(_QWORD *)(v24 + 16) = 0;
              v26 = v65;
              if ((unint64_t)v65 >= *((_QWORD *)&v65 + 1))
              {
                v47 = v24 + 12;
                v28 = (uint64_t)(v65 - *((_QWORD *)&v64 + 1)) >> 3;
                if ((unint64_t)(v28 + 1) >> 61)
                  std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
                v29 = (uint64_t)(*((_QWORD *)&v65 + 1) - *((_QWORD *)&v64 + 1)) >> 2;
                if (v29 <= v28 + 1)
                  v29 = v28 + 1;
                if (*((_QWORD *)&v65 + 1) - *((_QWORD *)&v64 + 1) >= 0x7FFFFFFFFFFFFFF8uLL)
                  v30 = 0x1FFFFFFFFFFFFFFFLL;
                else
                  v30 = v29;
                if (v30)
                  v31 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v65 + 8, v30);
                else
                  v31 = 0;
                v32 = (uint64_t *)&v31[8 * v28];
                *v32 = v25;
                v27 = v32 + 1;
                v34 = (char *)*((_QWORD *)&v64 + 1);
                v33 = (char *)v65;
                if ((_QWORD)v65 != *((_QWORD *)&v64 + 1))
                {
                  do
                  {
                    v35 = *((_QWORD *)v33 - 1);
                    v33 -= 8;
                    *--v32 = v35;
                  }
                  while (v33 != v34);
                  v33 = (char *)*((_QWORD *)&v64 + 1);
                }
                *((_QWORD *)&v64 + 1) = v32;
                *(_QWORD *)&v65 = v27;
                *((_QWORD *)&v65 + 1) = &v31[8 * v30];
                if (v33)
                  operator delete(v33);
                v23 = (char *)v47;
              }
              else
              {
                *(_QWORD *)v65 = v24;
                v27 = (_QWORD *)(v26 + 8);
              }
              *(_QWORD *)&v65 = v27;
            }
            else
            {
              if (!v22)
                __cxa_bad_cast();
              v23 = v22 + 12;
            }
            v58((uint64_t)v57, (uint64_t)v23);
            v36 = (uint64_t *)(a1 + 360);
LABEL_58:
            v36 = (uint64_t *)*v36;
            if (!v36)
LABEL_89:
              std::__throw_out_of_range[abi:ne180100]("map::at:  key not found");
            while (1)
            {
              v37 = *((_DWORD *)v36 + 8);
              if (v37 > (int)v14)
                goto LABEL_58;
              if (v37 >= (int)v14)
                break;
              v36 = (uint64_t *)v36[1];
              if (!v36)
                goto LABEL_89;
            }
            v52 = v36 + 5;
            v53 = QMIServiceMsg::create();
            v54 = 25000;
            v55 = 0;
            v56 = 0;
            v49[0] = MEMORY[0x24BDAC760];
            v49[1] = 1174405120;
            v49[2] = ___ZNK20QMIDataCommandDriver19reportPdpStatisticsERKNSt3__110shared_ptrIKNS0_3mapIjN29PdpStatisticsServiceInterface9PdpStatusENS0_4lessIjEENS0_9allocatorINS0_4pairIKjS4_EEEEEEEE_block_invoke_167;
            v49[3] = &__block_descriptor_tmp_168_0;
            v49[4] = a1;
            v49[5] = v15;
            v50 = v70;
            if (v70)
            {
              v38 = (unint64_t *)&v70->__shared_owners_;
              do
                v39 = __ldxr(v38);
              while (__stxr(v39 + 1, v38));
            }
            v51 = v14;
            aBlock[0] = MEMORY[0x24BDAC760];
            aBlock[1] = 0x40000000;
            aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_9;
            aBlock[3] = &unk_24D5CFD50;
            aBlock[4] = v49;
            v40 = _Block_copy(aBlock);
            v56 = v40;
            if (v53)
            {
              qmi::Client::send();
              v40 = v56;
            }
            if (v40)
              _Block_release(v40);
            v41 = v50;
            if (v50)
            {
              v42 = (unint64_t *)&v50->__shared_owners_;
              do
                v43 = __ldaxr(v42);
              while (__stlxr(v43 - 1, v42));
              if (!v43)
              {
                ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
                std::__shared_weak_count::__release_weak(v41);
              }
            }
            if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
              operator delete(__p.__r_.__value_.__l.__data_);
            qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&v64);
          }
        }
      }
    }
    if ((v68[30] & 0x80000000) != 0)
      operator delete(*(void **)&v68[7]);
    v44 = (_QWORD *)v12[1];
    if (v44)
    {
      do
      {
        v45 = v44;
        v44 = (_QWORD *)*v44;
      }
      while (v44);
    }
    else
    {
      do
      {
        v45 = (_QWORD *)v12[2];
        v46 = *v45 == (_QWORD)v12;
        v12 = v45;
      }
      while (!v46);
    }
    v12 = v45;
  }
  while (v45 != (_QWORD *)v13);
  v6 = v70;
  v8 = 1;
  if (v70)
    goto LABEL_6;
  return v8;
}

void sub_216899718(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,void *__p,uint64_t a38,int a39,__int16 a40,char a41,char a42,uint64_t a43,char a44)
{
  uint64_t v44;

  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a44);
  if (*(char *)(v44 - 177) < 0)
    operator delete(*(void **)(v44 - 200));
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v44 - 168);
  _Unwind_Resume(a1);
}

void ___ZNK3qmi6Client13setIndHandlerIRKN3awd19MetricSubmissionEnd10IndicationEEEvtU13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216899858(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void awd::QMIMav20AwdCommandDriver::handleMetricSubmissionEndInd_sync(uint64_t a1, qmi::MessageBase *this)
{
  uint64_t TlvValue;
  int v4;
  uint64_t v5;
  int v6;
  _QWORD v7[5];
  _QWORD v8[3];
  uint64_t v9;

  v7[0] = MEMORY[0x24BDAC760];
  v7[1] = 0x40000000;
  v7[2] = ___ZNK3awd24QMIMav20AwdCommandDriver33handleMetricSubmissionEndInd_syncERKNS_19MetricSubmissionEnd10IndicationE_block_invoke;
  v7[3] = &__block_descriptor_tmp_22_3;
  v7[4] = a1;
  TlvValue = qmi::MessageBase::findTlvValue(this);
  if (!TlvValue)
    goto LABEL_5;
  v5 = TlvValue;
  v6 = v4;
  v9 = TlvValue;
  memset(v8, 0, sizeof(v8));
  tlv::parseV<awd::tlv::MetricDataEndExt>((unint64_t *)&v9, v4, v8);
  if (v9)
  {
    ___ZNK3awd24QMIMav20AwdCommandDriver33handleMetricSubmissionEndInd_syncERKNS_19MetricSubmissionEnd10IndicationE_block_invoke((uint64_t)v7, v8);
    return;
  }
  if ((((uint64_t (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)this, 83, v5, v6) & 1) == 0)LABEL_5:__TUAssertTrigger();
}

void ___ZNK3awd24QMIMav20AwdCommandDriver33handleMetricSubmissionEndInd_syncERKNS_19MetricSubmissionEnd10IndicationE_block_invoke(uint64_t a1, _BYTE *a2)
{
  uint64_t v2;
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  unint64_t *v11;
  unint64_t v12;

  if (!*a2)
  {
    v2 = *(_QWORD *)(a1 + 32);
    v5 = *(_QWORD **)(v2 + 64);
    v3 = (_QWORD *)(v2 + 64);
    v4 = v5;
    if (v5)
    {
      do
      {
        v6 = v4;
        v4 = (_QWORD *)*v4;
      }
      while (v4);
      if (v6 != v3 && !*((_BYTE *)v6 + 32))
      {
        v7 = v6[5];
        v8 = (std::__shared_weak_count *)v6[6];
        if (v8)
        {
          p_shared_owners = (unint64_t *)&v8->__shared_owners_;
          do
            v10 = __ldxr(p_shared_owners);
          while (__stxr(v10 + 1, p_shared_owners));
        }
        if (v7)
          awd::AppContext::markMetricSubmissionComplete();
        if (v8)
        {
          v11 = (unint64_t *)&v8->__shared_owners_;
          do
            v12 = __ldaxr(v11);
          while (__stlxr(v12 - 1, v11));
          if (!v12)
          {
            ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
            std::__shared_weak_count::__release_weak(v8);
          }
        }
      }
    }
  }
}

void sub_216899A34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

unint64_t tlv::parseV<awd::tlv::MetricDataEndExt>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  unint64_t result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = awd::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), (uint64_t)a3);
  *a1 = result;
  return result;
}

void sub_216899A80(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
}

unint64_t awd::tlv::parseField(unint64_t a1, const unsigned __int8 *a2, uint64_t a3)
{
  tlv::throwIfNotEnoughBytes(a1, a2, 4uLL);
  *(_DWORD *)a3 = *(_DWORD *)a1;
  tlv::throwIfNotEnoughBytes(a1 + 4, a2, 4uLL);
  *(_DWORD *)(a3 + 4) = *(_DWORD *)(a1 + 4);
  tlv::throwIfNotEnoughBytes(a1 + 8, a2, 4uLL);
  *(_DWORD *)(a3 + 8) = *(_DWORD *)(a1 + 8);
  tlv::throwIfNotEnoughBytes(a1 + 12, a2, 4uLL);
  *(_DWORD *)(a3 + 12) = *(_DWORD *)(a1 + 12);
  tlv::throwIfNotEnoughBytes(a1 + 16, a2, 4uLL);
  *(_DWORD *)(a3 + 16) = *(_DWORD *)(a1 + 16);
  tlv::throwIfNotEnoughBytes(a1 + 20, a2, 2uLL);
  *(_WORD *)(a3 + 20) = *(_WORD *)(a1 + 20);
  return a1 + 22;
}

{
  tlv::throwIfNotEnoughBytes(a1, a2, 4uLL);
  *(_DWORD *)a3 = *(_DWORD *)a1;
  tlv::throwIfNotEnoughBytes(a1 + 4, a2, 4uLL);
  *(_DWORD *)(a3 + 4) = *(_DWORD *)(a1 + 4);
  tlv::throwIfNotEnoughBytes(a1 + 8, a2, 4uLL);
  *(_DWORD *)(a3 + 8) = *(_DWORD *)(a1 + 8);
  tlv::throwIfNotEnoughBytes(a1 + 12, a2, 4uLL);
  *(_DWORD *)(a3 + 12) = *(_DWORD *)(a1 + 12);
  tlv::throwIfNotEnoughBytes(a1 + 16, a2, 4uLL);
  *(_DWORD *)(a3 + 16) = *(_DWORD *)(a1 + 16);
  tlv::throwIfNotEnoughBytes(a1 + 20, a2, 8uLL);
  *(_QWORD *)(a3 + 24) = *(_QWORD *)(a1 + 20);
  return a1 + 28;
}

{
  tlv::throwIfNotEnoughBytes(a1, a2, 4uLL);
  *(_DWORD *)a3 = *(_DWORD *)a1;
  tlv::throwIfNotEnoughBytes(a1 + 4, a2, 4uLL);
  *(_DWORD *)(a3 + 4) = *(_DWORD *)(a1 + 4);
  tlv::throwIfNotEnoughBytes(a1 + 8, a2, 4uLL);
  *(_DWORD *)(a3 + 8) = *(_DWORD *)(a1 + 8);
  tlv::throwIfNotEnoughBytes(a1 + 12, a2, 4uLL);
  *(_DWORD *)(a3 + 12) = *(_DWORD *)(a1 + 12);
  tlv::throwIfNotEnoughBytes(a1 + 16, a2, 4uLL);
  *(_DWORD *)(a3 + 16) = *(_DWORD *)(a1 + 16);
  tlv::throwIfNotEnoughBytes(a1 + 20, a2, 1uLL);
  *(_BYTE *)(a3 + 20) = *(_BYTE *)(a1 + 20);
  tlv::throwIfNotEnoughBytes(a1 + 21, a2, 1uLL);
  *(_BYTE *)(a3 + 21) = *(_BYTE *)(a1 + 21);
  tlv::throwIfNotEnoughBytes(a1 + 22, a2, 1uLL);
  *(_BYTE *)(a3 + 22) = *(_BYTE *)(a1 + 22);
  tlv::throwIfNotEnoughBytes(a1 + 23, a2, 1uLL);
  *(_BYTE *)(a3 + 23) = *(_BYTE *)(a1 + 23);
  return a1 + 24;
}

{
  unint64_t v5;
  unint64_t v6;

  v5 = a1;
  tlv::throwIfNotEnoughBytes(a1, a2, 4uLL);
  *(_DWORD *)a3 = *(_DWORD *)v5;
  tlv::throwIfNotEnoughBytes(v5 + 4, a2, 4uLL);
  *(_DWORD *)(a3 + 4) = *(_DWORD *)(v5 + 4);
  tlv::throwIfNotEnoughBytes(v5 + 8, a2, 4uLL);
  *(_DWORD *)(a3 + 8) = *(_DWORD *)(v5 + 8);
  tlv::throwIfNotEnoughBytes(v5 + 12, a2, 4uLL);
  *(_DWORD *)(a3 + 12) = *(_DWORD *)(v5 + 12);
  tlv::throwIfNotEnoughBytes(v5 + 16, a2, 4uLL);
  *(_DWORD *)(a3 + 16) = *(_DWORD *)(v5 + 16);
  tlv::throwIfNotEnoughBytes(v5 + 20, a2, 4uLL);
  *(_DWORD *)(a3 + 20) = *(_DWORD *)(v5 + 20);
  tlv::throwIfNotEnoughBytes(v5 + 24, a2, 2uLL);
  *(_WORD *)(a3 + 24) = *(_WORD *)(v5 + 24);
  tlv::throwIfNotEnoughBytes(v5 + 26, a2, 2uLL);
  v6 = *(unsigned __int16 *)(v5 + 26);
  v5 += 28;
  tlv::throwIfNotEnoughBytes(v5, a2, v6);
  std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((_QWORD *)(a3 + 32), (char *)v5, (char *)(v5 + v6), v6);
  return v5 + v6;
}

{
  unint64_t v5;
  unint64_t v6;

  v5 = a1;
  tlv::throwIfNotEnoughBytes(a1, a2, 4uLL);
  *(_DWORD *)a3 = *(_DWORD *)v5;
  tlv::throwIfNotEnoughBytes(v5 + 4, a2, 4uLL);
  *(_DWORD *)(a3 + 4) = *(_DWORD *)(v5 + 4);
  tlv::throwIfNotEnoughBytes(v5 + 8, a2, 4uLL);
  *(_DWORD *)(a3 + 8) = *(_DWORD *)(v5 + 8);
  tlv::throwIfNotEnoughBytes(v5 + 12, a2, 4uLL);
  *(_DWORD *)(a3 + 12) = *(_DWORD *)(v5 + 12);
  tlv::throwIfNotEnoughBytes(v5 + 16, a2, 2uLL);
  *(_WORD *)(a3 + 16) = *(_WORD *)(v5 + 16);
  tlv::throwIfNotEnoughBytes(v5 + 18, a2, 2uLL);
  v6 = *(unsigned __int16 *)(v5 + 18);
  v5 += 20;
  tlv::throwIfNotEnoughBytes(v5, a2, v6);
  std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((_QWORD *)(a3 + 24), (char *)v5, (char *)(v5 + v6), v6);
  return v5 + v6;
}

{
  tlv::throwIfNotEnoughBytes(a1, a2, 4uLL);
  *(_DWORD *)a3 = *(_DWORD *)a1;
  tlv::throwIfNotEnoughBytes(a1 + 4, a2, 4uLL);
  *(_DWORD *)(a3 + 4) = *(_DWORD *)(a1 + 4);
  tlv::throwIfNotEnoughBytes(a1 + 8, a2, 4uLL);
  *(_DWORD *)(a3 + 8) = *(_DWORD *)(a1 + 8);
  tlv::throwIfNotEnoughBytes(a1 + 12, a2, 4uLL);
  *(_DWORD *)(a3 + 12) = *(_DWORD *)(a1 + 12);
  tlv::throwIfNotEnoughBytes(a1 + 16, a2, 2uLL);
  *(_WORD *)(a3 + 16) = *(_WORD *)(a1 + 16);
  return a1 + 18;
}

{
  tlv::throwIfNotEnoughBytes(a1, a2, 4uLL);
  *(_DWORD *)a3 = *(_DWORD *)a1;
  tlv::throwIfNotEnoughBytes(a1 + 4, a2, 4uLL);
  *(_DWORD *)(a3 + 4) = *(_DWORD *)(a1 + 4);
  tlv::throwIfNotEnoughBytes(a1 + 8, a2, 4uLL);
  *(_DWORD *)(a3 + 8) = *(_DWORD *)(a1 + 8);
  tlv::throwIfNotEnoughBytes(a1 + 12, a2, 4uLL);
  *(_DWORD *)(a3 + 12) = *(_DWORD *)(a1 + 12);
  tlv::throwIfNotEnoughBytes(a1 + 16, a2, 8uLL);
  *(_QWORD *)(a3 + 16) = *(_QWORD *)(a1 + 16);
  return a1 + 24;
}

{
  tlv::throwIfNotEnoughBytes(a1, a2, 4uLL);
  *(_DWORD *)a3 = *(_DWORD *)a1;
  tlv::throwIfNotEnoughBytes(a1 + 4, a2, 4uLL);
  *(_DWORD *)(a3 + 4) = *(_DWORD *)(a1 + 4);
  tlv::throwIfNotEnoughBytes(a1 + 8, a2, 4uLL);
  *(_DWORD *)(a3 + 8) = *(_DWORD *)(a1 + 8);
  tlv::throwIfNotEnoughBytes(a1 + 12, a2, 4uLL);
  *(_DWORD *)(a3 + 12) = *(_DWORD *)(a1 + 12);
  tlv::throwIfNotEnoughBytes(a1 + 16, a2, 1uLL);
  *(_BYTE *)(a3 + 16) = *(_BYTE *)(a1 + 16);
  tlv::throwIfNotEnoughBytes(a1 + 17, a2, 1uLL);
  *(_BYTE *)(a3 + 17) = *(_BYTE *)(a1 + 17);
  tlv::throwIfNotEnoughBytes(a1 + 18, a2, 1uLL);
  *(_BYTE *)(a3 + 18) = *(_BYTE *)(a1 + 18);
  tlv::throwIfNotEnoughBytes(a1 + 19, a2, 1uLL);
  *(_BYTE *)(a3 + 19) = *(_BYTE *)(a1 + 19);
  return a1 + 20;
}

void ___ZNK3qmi6Client13setIndHandlerIRKN3awd13SubmitTrigger10IndicationEEEvtU13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216899C08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void awd::QMIMav20AwdCommandDriver::handleTriggerSubmissionInd_sync(uint64_t a1, qmi::MessageBase *this)
{
  uint64_t TlvValue;
  int v4;
  uint64_t v5;
  int v6;
  _QWORD v7[5];
  _OWORD v8[2];
  uint64_t v9;

  v7[0] = MEMORY[0x24BDAC760];
  v7[1] = 0x40000000;
  v7[2] = ___ZNK3awd24QMIMav20AwdCommandDriver31handleTriggerSubmissionInd_syncERKNS_13SubmitTrigger10IndicationE_block_invoke;
  v7[3] = &__block_descriptor_tmp_12_6;
  v7[4] = a1;
  TlvValue = qmi::MessageBase::findTlvValue(this);
  if (!TlvValue)
    goto LABEL_5;
  v5 = TlvValue;
  v6 = v4;
  v9 = TlvValue;
  memset(v8, 0, sizeof(v8));
  tlv::parseV<awd::tlv::SubmitTriggerExt>((unint64_t *)&v9, v4, v8);
  if (v9)
  {
    ___ZNK3awd24QMIMav20AwdCommandDriver31handleTriggerSubmissionInd_syncERKNS_13SubmitTrigger10IndicationE_block_invoke((uint64_t)v7, v8);
    return;
  }
  if ((((uint64_t (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)this, 84, v5, v6) & 1) == 0)LABEL_5:__TUAssertTrigger();
}

void ___ZNK3awd24QMIMav20AwdCommandDriver31handleTriggerSubmissionInd_syncERKNS_13SubmitTrigger10IndicationE_block_invoke(uint64_t a1, _BYTE *a2)
{
  uint64_t v2;
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  unint64_t *v11;
  unint64_t v12;

  if (!*a2)
  {
    v2 = *(_QWORD *)(a1 + 32);
    v5 = *(_QWORD **)(v2 + 64);
    v3 = (_QWORD *)(v2 + 64);
    v4 = v5;
    if (v5)
    {
      do
      {
        v6 = v4;
        v4 = (_QWORD *)*v4;
      }
      while (v4);
      if (v6 != v3 && !*((_BYTE *)v6 + 32))
      {
        v7 = v6[5];
        v8 = (std::__shared_weak_count *)v6[6];
        if (v8)
        {
          p_shared_owners = (unint64_t *)&v8->__shared_owners_;
          do
            v10 = __ldxr(p_shared_owners);
          while (__stxr(v10 + 1, p_shared_owners));
        }
        if (v7)
          awd::AppContext::submitTrigger();
        if (v8)
        {
          v11 = (unint64_t *)&v8->__shared_owners_;
          do
            v12 = __ldaxr(v11);
          while (__stlxr(v12 - 1, v11));
          if (!v12)
          {
            ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
            std::__shared_weak_count::__release_weak(v8);
          }
        }
      }
    }
  }
}

void sub_216899DE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

unint64_t tlv::parseV<awd::tlv::SubmitTriggerExt>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  unint64_t result;

  *a3 = 0u;
  a3[1] = 0u;
  result = awd::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), (uint64_t)a3);
  *a1 = result;
  return result;
}

void sub_216899E30(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
}

void ___ZNK3qmi6Client13setIndHandlerIRKN3awd15PIILocationUsed10IndicationEEEvtU13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216899FB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void awd::QMIMav20AwdCommandDriver::handlePIILocationUsedInd_sync(uint64_t a1, qmi::MessageBase *this)
{
  uint64_t TlvValue;
  int v4;
  uint64_t v5;
  int v6;
  _QWORD v7[5];
  _QWORD v8[3];
  uint64_t v9;

  v7[0] = MEMORY[0x24BDAC760];
  v7[1] = 0x40000000;
  v7[2] = ___ZNK3awd24QMIMav20AwdCommandDriver29handlePIILocationUsedInd_syncERKNS_15PIILocationUsed10IndicationE_block_invoke;
  v7[3] = &__block_descriptor_tmp_16_5;
  v7[4] = a1;
  TlvValue = qmi::MessageBase::findTlvValue(this);
  if (!TlvValue)
    goto LABEL_5;
  v5 = TlvValue;
  v6 = v4;
  v9 = TlvValue;
  memset(v8, 0, sizeof(v8));
  tlv::parseV<awd::tlv::PIILocationUsedExt>((unint64_t *)&v9, v4, v8);
  if (v9)
  {
    ___ZNK3awd24QMIMav20AwdCommandDriver29handlePIILocationUsedInd_syncERKNS_15PIILocationUsed10IndicationE_block_invoke((uint64_t)v7, v8);
    return;
  }
  if ((((uint64_t (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)this, 85, v5, v6) & 1) == 0)LABEL_5:__TUAssertTrigger();
}

void ___ZNK3awd24QMIMav20AwdCommandDriver29handlePIILocationUsedInd_syncERKNS_15PIILocationUsed10IndicationE_block_invoke(uint64_t a1, _BYTE *a2)
{
  uint64_t v2;
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  unint64_t *v11;
  unint64_t v12;

  if (!*a2)
  {
    v2 = *(_QWORD *)(a1 + 32);
    v5 = *(_QWORD **)(v2 + 64);
    v3 = (_QWORD *)(v2 + 64);
    v4 = v5;
    if (v5)
    {
      do
      {
        v6 = v4;
        v4 = (_QWORD *)*v4;
      }
      while (v4);
      if (v6 != v3 && !*((_BYTE *)v6 + 32))
      {
        v7 = v6[5];
        v8 = (std::__shared_weak_count *)v6[6];
        if (v8)
        {
          p_shared_owners = (unint64_t *)&v8->__shared_owners_;
          do
            v10 = __ldxr(p_shared_owners);
          while (__stxr(v10 + 1, p_shared_owners));
        }
        if (v7)
          awd::AppContext::updateAppSettingsUsed();
        if (v8)
        {
          v11 = (unint64_t *)&v8->__shared_owners_;
          do
            v12 = __ldaxr(v11);
          while (__stlxr(v12 - 1, v11));
          if (!v12)
          {
            ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
            std::__shared_weak_count::__release_weak(v8);
          }
        }
      }
    }
  }
}

void sub_21689A1AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

unint64_t tlv::parseV<awd::tlv::PIILocationUsedExt>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  unint64_t result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = awd::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), (uint64_t)a3);
  *a1 = result;
  return result;
}

void sub_21689A1F8(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
}

void ___ZNK3qmi6Client13setIndHandlerIRKN3awd16MetricSubmission10IndicationEEEvtU13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_21689A3C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void awd::QMIMav20AwdCommandDriver::handleMetricSubmissionInd_sync(uint64_t a1, qmi::MessageBase *this)
{
  uint64_t TlvValue;
  int v4;
  uint64_t v5;
  int v6;
  unint64_t v7;
  _QWORD v8[5];
  _OWORD v9[2];
  void *__p[2];
  uint64_t v11;
  unint64_t v12;

  v8[0] = MEMORY[0x24BDAC760];
  v8[1] = 0x40000000;
  v8[2] = ___ZNK3awd24QMIMav20AwdCommandDriver30handleMetricSubmissionInd_syncERKNS_16MetricSubmission10IndicationE_block_invoke;
  v8[3] = &__block_descriptor_tmp_18_5;
  v8[4] = a1;
  TlvValue = qmi::MessageBase::findTlvValue(this);
  if (!TlvValue)
    goto LABEL_8;
  v5 = TlvValue;
  v6 = v4;
  v12 = TlvValue;
  v11 = 0;
  *(_OWORD *)__p = 0u;
  memset(v9, 0, sizeof(v9));
  tlv::parseV<awd::tlv::MetricDataExt>(&v12, v4, (uint64_t)v9);
  v7 = v12;
  if (v12)
    ___ZNK3awd24QMIMav20AwdCommandDriver30handleMetricSubmissionInd_syncERKNS_16MetricSubmission10IndicationE_block_invoke((uint64_t)v8, (uint64_t)v9);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (!v7
    && (((uint64_t (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)this, 82, v5, v6) & 1) == 0)
  {
LABEL_8:
    __TUAssertTrigger();
  }
}

void sub_21689A4F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void ___ZNK3awd24QMIMav20AwdCommandDriver30handleMetricSubmissionInd_syncERKNS_16MetricSubmission10IndicationE_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  void *__p;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  std::__shared_weak_count *v17;

  if (!*(_BYTE *)a2)
  {
    v2 = *(_QWORD *)(a1 + 32);
    v5 = *(_QWORD **)(v2 + 64);
    v3 = (_QWORD *)(v2 + 64);
    v4 = v5;
    if (v5)
    {
      do
      {
        v6 = v4;
        v4 = (_QWORD *)*v4;
      }
      while (v4);
      if (v6 != v3 && !*((_BYTE *)v6 + 32))
      {
        v8 = v6[5];
        v7 = (std::__shared_weak_count *)v6[6];
        v16 = v8;
        v17 = v7;
        if (v7)
        {
          p_shared_owners = (unint64_t *)&v7->__shared_owners_;
          do
            v10 = __ldxr(p_shared_owners);
          while (__stxr(v10 + 1, p_shared_owners));
        }
        if (v8)
        {
          v14 = 0;
          v15 = 0;
          __p = 0;
          std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(&__p, *(const void **)(a2 + 32), *(_QWORD *)(a2 + 40), *(_QWORD *)(a2 + 40) - *(_QWORD *)(a2 + 32));
          awd::AppContext::submitMetricPayload();
          if (__p)
          {
            v14 = __p;
            operator delete(__p);
          }
        }
        if (v7)
        {
          v11 = (unint64_t *)&v7->__shared_owners_;
          do
            v12 = __ldaxr(v11);
          while (__stlxr(v12 - 1, v11));
          if (!v12)
          {
            ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
            std::__shared_weak_count::__release_weak(v7);
          }
        }
      }
    }
  }
}

void sub_21689A620(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, char a13)
{
  if (__p)
    operator delete(__p);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  _Unwind_Resume(a1);
}

unint64_t tlv::parseV<awd::tlv::MetricDataExt>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  unint64_t result;

  *(_QWORD *)(a3 + 48) = 0;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)a3 = 0u;
  result = awd::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), a3);
  *a1 = result;
  return result;
}

void sub_21689A690(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x21689A684);
}

void sub_21689A6A0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)(v1 + 32);
  if (v3)
  {
    *(_QWORD *)(v1 + 40) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

unint64_t nas::tlv::parseField(unint64_t a1, const unsigned __int8 *a2, uint64_t a3)
{
  tlv::throwIfNotEnoughBytes(a1, a2, 2uLL);
  *(_WORD *)a3 = *(_WORD *)a1;
  tlv::throwIfNotEnoughBytes(a1 + 2, a2, 2uLL);
  *(_WORD *)(a3 + 2) = *(_WORD *)(a1 + 2);
  tlv::throwIfNotEnoughBytes(a1 + 4, a2, 2uLL);
  *(_WORD *)(a3 + 4) = *(_WORD *)(a1 + 4);
  tlv::throwIfNotEnoughBytes(a1 + 6, a2, 1uLL);
  *(_BYTE *)(a3 + 6) = *(_BYTE *)(a1 + 6);
  tlv::throwIfNotEnoughBytes(a1 + 7, a2, 4uLL);
  *(_DWORD *)(a3 + 8) = *(_DWORD *)(a1 + 7);
  tlv::throwIfNotEnoughBytes(a1 + 11, a2, 4uLL);
  *(_DWORD *)(a3 + 12) = *(_DWORD *)(a1 + 11);
  tlv::throwIfNotEnoughBytes(a1 + 15, a2, 4uLL);
  *(_DWORD *)(a3 + 16) = *(_DWORD *)(a1 + 15);
  tlv::throwIfNotEnoughBytes(a1 + 19, a2, 2uLL);
  *(_WORD *)(a3 + 20) = *(_WORD *)(a1 + 19);
  tlv::throwIfNotEnoughBytes(a1 + 21, a2, 4uLL);
  *(_DWORD *)(a3 + 24) = *(_DWORD *)(a1 + 21);
  tlv::throwIfNotEnoughBytes(a1 + 25, a2, 4uLL);
  *(_DWORD *)(a3 + 28) = *(_DWORD *)(a1 + 25);
  tlv::throwIfNotEnoughBytes(a1 + 29, a2, 1uLL);
  *(_BYTE *)(a3 + 32) = *(_BYTE *)(a1 + 29);
  tlv::throwIfNotEnoughBytes(a1 + 30, a2, 1uLL);
  *(_BYTE *)(a3 + 33) = *(_BYTE *)(a1 + 30);
  tlv::throwIfNotEnoughBytes(a1 + 31, a2, 4uLL);
  *(_DWORD *)(a3 + 36) = *(_DWORD *)(a1 + 31);
  tlv::throwIfNotEnoughBytes(a1 + 35, a2, 1uLL);
  *(_BYTE *)(a3 + 40) = *(_BYTE *)(a1 + 35);
  tlv::throwIfNotEnoughBytes(a1 + 36, a2, 4uLL);
  *(_DWORD *)(a3 + 44) = *(_DWORD *)(a1 + 36);
  tlv::throwIfNotEnoughBytes(a1 + 40, a2, 2uLL);
  *(_WORD *)(a3 + 48) = *(_WORD *)(a1 + 40);
  tlv::throwIfNotEnoughBytes(a1 + 42, a2, 4uLL);
  *(_DWORD *)(a3 + 52) = *(_DWORD *)(a1 + 42);
  tlv::throwIfNotEnoughBytes(a1 + 46, a2, 4uLL);
  *(_DWORD *)(a3 + 56) = *(_DWORD *)(a1 + 46);
  return a1 + 50;
}

{
  unint64_t result;

  tlv::throwIfNotEnoughBytes(a1, a2, 2uLL);
  *(_WORD *)a3 = *(_WORD *)a1;
  tlv::throwIfNotEnoughBytes(a1 + 2, a2, 2uLL);
  *(_WORD *)(a3 + 2) = *(_WORD *)(a1 + 2);
  tlv::throwIfNotEnoughBytes(a1 + 4, a2, 4uLL);
  *(_DWORD *)(a3 + 4) = *(_DWORD *)(a1 + 4);
  tlv::throwIfNotEnoughBytes(a1 + 8, a2, 8uLL);
  *(_QWORD *)(a3 + 8) = *(_QWORD *)(a1 + 8);
  tlv::throwIfNotEnoughBytes(a1 + 16, a2, 1uLL);
  result = a1 + 17;
  *(_DWORD *)(a3 + 16) = *(unsigned __int8 *)(a1 + 16);
  return result;
}

{
  __int16 v6;
  __int16 v7;

  tlv::throwIfNotEnoughBytes(a1, a2, 1uLL);
  *(_BYTE *)a3 = *(_BYTE *)a1 != 0;
  tlv::throwIfNotEnoughBytes(a1 + 1, a2, 1uLL);
  *(_BYTE *)(a3 + 1) = *(_BYTE *)(a1 + 1);
  tlv::throwIfNotEnoughBytes(a1 + 2, a2, 1uLL);
  *(_BYTE *)(a3 + 2) = *(_BYTE *)(a1 + 2) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 3, a2, 1uLL);
  *(_BYTE *)(a3 + 3) = *(_BYTE *)(a1 + 3);
  tlv::throwIfNotEnoughBytes(a1 + 4, a2, 1uLL);
  *(_BYTE *)(a3 + 4) = *(_BYTE *)(a1 + 4) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 5, a2, 1uLL);
  *(_BYTE *)(a3 + 5) = *(_BYTE *)(a1 + 5);
  tlv::throwIfNotEnoughBytes(a1 + 6, a2, 1uLL);
  *(_BYTE *)(a3 + 6) = *(_BYTE *)(a1 + 6) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 7, a2, 1uLL);
  *(_BYTE *)(a3 + 7) = *(_BYTE *)(a1 + 7) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 8, a2, 1uLL);
  *(_BYTE *)(a3 + 8) = *(_BYTE *)(a1 + 8) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 9, a2, 2uLL);
  *(_WORD *)(a3 + 10) = *(_WORD *)(a1 + 9);
  tlv::throwIfNotEnoughBytes(a1 + 11, a2, 1uLL);
  *(_BYTE *)(a3 + 12) = *(_BYTE *)(a1 + 11) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 12, a2, 4uLL);
  *(_DWORD *)(a3 + 16) = *(_DWORD *)(a1 + 12);
  tlv::throwIfNotEnoughBytes(a1 + 16, a2, 1uLL);
  *(_BYTE *)(a3 + 20) = *(_BYTE *)(a1 + 16) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 17, a2, 1uLL);
  *(_BYTE *)(a3 + 21) = *(_BYTE *)(a1 + 17);
  tlv::throwIfNotEnoughBytes(a1 + 18, a2, 1uLL);
  *(_BYTE *)(a3 + 22) = *(_BYTE *)(a1 + 18);
  tlv::throwIfNotEnoughBytes(a1 + 19, a2, 1uLL);
  *(_BYTE *)(a3 + 23) = *(_BYTE *)(a1 + 19) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 20, a2, 3uLL);
  v6 = *(_WORD *)(a1 + 20);
  *(_BYTE *)(a3 + 26) = *(_BYTE *)(a1 + 22);
  *(_WORD *)(a3 + 24) = v6;
  tlv::throwIfNotEnoughBytes(a1 + 23, a2, 3uLL);
  v7 = *(_WORD *)(a1 + 23);
  *(_BYTE *)(a3 + 29) = *(_BYTE *)(a1 + 25);
  *(_WORD *)(a3 + 27) = v7;
  tlv::throwIfNotEnoughBytes(a1 + 26, a2, 1uLL);
  *(_BYTE *)(a3 + 30) = *(_BYTE *)(a1 + 26) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 27, a2, 2uLL);
  *(_WORD *)(a3 + 32) = *(_WORD *)(a1 + 27);
  return a1 + 29;
}

{
  tlv::throwIfNotEnoughBytes(a1, a2, 2uLL);
  *(_WORD *)a3 = *(_WORD *)a1;
  tlv::throwIfNotEnoughBytes(a1 + 2, a2, 1uLL);
  *(_BYTE *)(a3 + 2) = *(_BYTE *)(a1 + 2);
  tlv::throwIfNotEnoughBytes(a1 + 3, a2, 2uLL);
  *(_WORD *)(a3 + 4) = *(_WORD *)(a1 + 3);
  tlv::throwIfNotEnoughBytes(a1 + 5, a2, 2uLL);
  *(_WORD *)(a3 + 6) = *(_WORD *)(a1 + 5);
  return a1 + 7;
}

{
  tlv::throwIfNotEnoughBytes(a1, a2, 2uLL);
  *(_WORD *)a3 = *(_WORD *)a1;
  tlv::throwIfNotEnoughBytes(a1 + 2, a2, 1uLL);
  *(_BYTE *)(a3 + 2) = *(_BYTE *)(a1 + 2);
  tlv::throwIfNotEnoughBytes(a1 + 3, a2, 2uLL);
  *(_WORD *)(a3 + 4) = *(_WORD *)(a1 + 3);
  tlv::throwIfNotEnoughBytes(a1 + 5, a2, 1uLL);
  *(_BYTE *)(a3 + 6) = *(_BYTE *)(a1 + 5);
  return a1 + 6;
}

{
  tlv::throwIfNotEnoughBytes(a1, a2, 2uLL);
  *(_WORD *)a3 = *(_WORD *)a1;
  tlv::throwIfNotEnoughBytes(a1 + 2, a2, 2uLL);
  *(_WORD *)(a3 + 2) = *(_WORD *)(a1 + 2);
  tlv::throwIfNotEnoughBytes(a1 + 4, a2, 2uLL);
  *(_WORD *)(a3 + 4) = *(_WORD *)(a1 + 4);
  tlv::throwIfNotEnoughBytes(a1 + 6, a2, 1uLL);
  *(_BYTE *)(a3 + 6) = *(_BYTE *)(a1 + 6);
  tlv::throwIfNotEnoughBytes(a1 + 7, a2, 2uLL);
  *(_WORD *)(a3 + 8) = *(_WORD *)(a1 + 7);
  tlv::throwIfNotEnoughBytes(a1 + 9, a2, 2uLL);
  *(_WORD *)(a3 + 10) = *(_WORD *)(a1 + 9);
  tlv::throwIfNotEnoughBytes(a1 + 11, a2, 2uLL);
  *(_WORD *)(a3 + 12) = *(_WORD *)(a1 + 11);
  tlv::throwIfNotEnoughBytes(a1 + 13, a2, 2uLL);
  *(_WORD *)(a3 + 14) = *(_WORD *)(a1 + 13);
  tlv::throwIfNotEnoughBytes(a1 + 15, a2, 4uLL);
  *(_DWORD *)(a3 + 16) = *(_DWORD *)(a1 + 15);
  tlv::throwIfNotEnoughBytes(a1 + 19, a2, 4uLL);
  *(_DWORD *)(a3 + 20) = *(_DWORD *)(a1 + 19);
  tlv::throwIfNotEnoughBytes(a1 + 23, a2, 2uLL);
  *(_WORD *)(a3 + 24) = *(_WORD *)(a1 + 23);
  tlv::throwIfNotEnoughBytes(a1 + 25, a2, 2uLL);
  *(_WORD *)(a3 + 26) = *(_WORD *)(a1 + 25);
  tlv::throwIfNotEnoughBytes(a1 + 27, a2, 1uLL);
  *(_BYTE *)(a3 + 28) = *(_BYTE *)(a1 + 27);
  tlv::throwIfNotEnoughBytes(a1 + 28, a2, 1uLL);
  *(_BYTE *)(a3 + 29) = *(_BYTE *)(a1 + 28);
  return a1 + 29;
}

{
  tlv::throwIfNotEnoughBytes(a1, a2, 2uLL);
  *(_WORD *)a3 = *(_WORD *)a1;
  tlv::throwIfNotEnoughBytes(a1 + 2, a2, 2uLL);
  *(_WORD *)(a3 + 2) = *(_WORD *)(a1 + 2);
  tlv::throwIfNotEnoughBytes(a1 + 4, a2, 1uLL);
  *(_BYTE *)(a3 + 4) = *(_BYTE *)(a1 + 4);
  tlv::throwIfNotEnoughBytes(a1 + 5, a2, 2uLL);
  *(_WORD *)(a3 + 6) = *(_WORD *)(a1 + 5);
  tlv::throwIfNotEnoughBytes(a1 + 7, a2, 0x10uLL);
  *(_OWORD *)(a3 + 8) = *(_OWORD *)(a1 + 7);
  tlv::throwIfNotEnoughBytes(a1 + 23, a2, 4uLL);
  *(_DWORD *)(a3 + 24) = *(_DWORD *)(a1 + 23);
  tlv::throwIfNotEnoughBytes(a1 + 27, a2, 4uLL);
  *(_DWORD *)(a3 + 28) = *(_DWORD *)(a1 + 27);
  tlv::throwIfNotEnoughBytes(a1 + 31, a2, 2uLL);
  *(_WORD *)(a3 + 32) = *(_WORD *)(a1 + 31);
  return a1 + 33;
}

{
  tlv::throwIfNotEnoughBytes(a1, a2, 2uLL);
  *(_WORD *)a3 = *(_WORD *)a1;
  tlv::throwIfNotEnoughBytes(a1 + 2, a2, 2uLL);
  *(_WORD *)(a3 + 2) = *(_WORD *)(a1 + 2);
  tlv::throwIfNotEnoughBytes(a1 + 4, a2, 2uLL);
  *(_WORD *)(a3 + 4) = *(_WORD *)(a1 + 4);
  tlv::throwIfNotEnoughBytes(a1 + 6, a2, 1uLL);
  *(_BYTE *)(a3 + 6) = *(_BYTE *)(a1 + 6);
  tlv::throwIfNotEnoughBytes(a1 + 7, a2, 2uLL);
  *(_WORD *)(a3 + 8) = *(_WORD *)(a1 + 7);
  tlv::throwIfNotEnoughBytes(a1 + 9, a2, 2uLL);
  *(_WORD *)(a3 + 10) = *(_WORD *)(a1 + 9);
  tlv::throwIfNotEnoughBytes(a1 + 11, a2, 2uLL);
  *(_WORD *)(a3 + 12) = *(_WORD *)(a1 + 11);
  tlv::throwIfNotEnoughBytes(a1 + 13, a2, 4uLL);
  *(_DWORD *)(a3 + 16) = *(_DWORD *)(a1 + 13);
  tlv::throwIfNotEnoughBytes(a1 + 17, a2, 4uLL);
  *(_DWORD *)(a3 + 20) = *(_DWORD *)(a1 + 17);
  return a1 + 21;
}

{
  tlv::throwIfNotEnoughBytes(a1, a2, 2uLL);
  *(_WORD *)a3 = *(_WORD *)a1;
  tlv::throwIfNotEnoughBytes(a1 + 2, a2, 2uLL);
  *(_WORD *)(a3 + 2) = *(_WORD *)(a1 + 2);
  tlv::throwIfNotEnoughBytes(a1 + 4, a2, 2uLL);
  *(_WORD *)(a3 + 4) = *(_WORD *)(a1 + 4);
  tlv::throwIfNotEnoughBytes(a1 + 6, a2, 1uLL);
  *(_BYTE *)(a3 + 6) = *(_BYTE *)(a1 + 6);
  tlv::throwIfNotEnoughBytes(a1 + 7, a2, 2uLL);
  *(_WORD *)(a3 + 8) = *(_WORD *)(a1 + 7);
  tlv::throwIfNotEnoughBytes(a1 + 9, a2, 4uLL);
  *(_DWORD *)(a3 + 12) = *(_DWORD *)(a1 + 9);
  tlv::throwIfNotEnoughBytes(a1 + 13, a2, 2uLL);
  *(_WORD *)(a3 + 16) = *(_WORD *)(a1 + 13);
  tlv::throwIfNotEnoughBytes(a1 + 15, a2, 2uLL);
  *(_WORD *)(a3 + 18) = *(_WORD *)(a1 + 15);
  tlv::throwIfNotEnoughBytes(a1 + 17, a2, 4uLL);
  *(_DWORD *)(a3 + 20) = *(_DWORD *)(a1 + 17);
  tlv::throwIfNotEnoughBytes(a1 + 21, a2, 4uLL);
  *(_DWORD *)(a3 + 24) = *(_DWORD *)(a1 + 21);
  return a1 + 25;
}

{
  tlv::throwIfNotEnoughBytes(a1, a2, 2uLL);
  *(_WORD *)a3 = *(_WORD *)a1;
  tlv::throwIfNotEnoughBytes(a1 + 2, a2, 2uLL);
  *(_WORD *)(a3 + 2) = *(_WORD *)(a1 + 2);
  tlv::throwIfNotEnoughBytes(a1 + 4, a2, 2uLL);
  *(_WORD *)(a3 + 4) = *(_WORD *)(a1 + 4);
  tlv::throwIfNotEnoughBytes(a1 + 6, a2, 1uLL);
  *(_BYTE *)(a3 + 6) = *(_BYTE *)(a1 + 6);
  tlv::throwIfNotEnoughBytes(a1 + 7, a2, 4uLL);
  *(_DWORD *)(a3 + 8) = *(_DWORD *)(a1 + 7);
  tlv::throwIfNotEnoughBytes(a1 + 11, a2, 4uLL);
  *(_DWORD *)(a3 + 12) = *(_DWORD *)(a1 + 11);
  tlv::throwIfNotEnoughBytes(a1 + 15, a2, 4uLL);
  *(_DWORD *)(a3 + 16) = *(_DWORD *)(a1 + 15);
  tlv::throwIfNotEnoughBytes(a1 + 19, a2, 2uLL);
  *(_WORD *)(a3 + 20) = *(_WORD *)(a1 + 19);
  tlv::throwIfNotEnoughBytes(a1 + 21, a2, 4uLL);
  *(_DWORD *)(a3 + 24) = *(_DWORD *)(a1 + 21);
  tlv::throwIfNotEnoughBytes(a1 + 25, a2, 4uLL);
  *(_DWORD *)(a3 + 28) = *(_DWORD *)(a1 + 25);
  tlv::throwIfNotEnoughBytes(a1 + 29, a2, 1uLL);
  *(_BYTE *)(a3 + 32) = *(_BYTE *)(a1 + 29);
  tlv::throwIfNotEnoughBytes(a1 + 30, a2, 1uLL);
  *(_BYTE *)(a3 + 33) = *(_BYTE *)(a1 + 30);
  return a1 + 31;
}

{
  tlv::throwIfNotEnoughBytes(a1, a2, 2uLL);
  *(_WORD *)a3 = *(_WORD *)a1;
  tlv::throwIfNotEnoughBytes(a1 + 2, a2, 2uLL);
  *(_WORD *)(a3 + 2) = *(_WORD *)(a1 + 2);
  tlv::throwIfNotEnoughBytes(a1 + 4, a2, 2uLL);
  *(_WORD *)(a3 + 4) = *(_WORD *)(a1 + 4);
  tlv::throwIfNotEnoughBytes(a1 + 6, a2, 2uLL);
  *(_WORD *)(a3 + 6) = *(_WORD *)(a1 + 6);
  tlv::throwIfNotEnoughBytes(a1 + 8, a2, 4uLL);
  *(_DWORD *)(a3 + 8) = *(_DWORD *)(a1 + 8);
  tlv::throwIfNotEnoughBytes(a1 + 12, a2, 8uLL);
  *(_QWORD *)(a3 + 16) = *(_QWORD *)(a1 + 12);
  tlv::throwIfNotEnoughBytes(a1 + 20, a2, 4uLL);
  *(_DWORD *)(a3 + 24) = *(_DWORD *)(a1 + 20);
  tlv::throwIfNotEnoughBytes(a1 + 24, a2, 2uLL);
  *(_WORD *)(a3 + 28) = *(_WORD *)(a1 + 24);
  tlv::throwIfNotEnoughBytes(a1 + 26, a2, 4uLL);
  *(_DWORD *)(a3 + 32) = *(_DWORD *)(a1 + 26);
  tlv::throwIfNotEnoughBytes(a1 + 30, a2, 4uLL);
  *(_DWORD *)(a3 + 36) = *(_DWORD *)(a1 + 30);
  tlv::throwIfNotEnoughBytes(a1 + 34, a2, 2uLL);
  *(_WORD *)(a3 + 40) = *(_WORD *)(a1 + 34);
  tlv::throwIfNotEnoughBytes(a1 + 36, a2, 1uLL);
  *(_BYTE *)(a3 + 42) = *(_BYTE *)(a1 + 36);
  tlv::throwIfNotEnoughBytes(a1 + 37, a2, 4uLL);
  *(_DWORD *)(a3 + 44) = *(_DWORD *)(a1 + 37);
  return a1 + 41;
}

{
  tlv::throwIfNotEnoughBytes(a1, a2, 2uLL);
  *(_WORD *)a3 = *(_WORD *)a1;
  tlv::throwIfNotEnoughBytes(a1 + 2, a2, 2uLL);
  *(_WORD *)(a3 + 2) = *(_WORD *)(a1 + 2);
  tlv::throwIfNotEnoughBytes(a1 + 4, a2, 2uLL);
  *(_WORD *)(a3 + 4) = *(_WORD *)(a1 + 4);
  tlv::throwIfNotEnoughBytes(a1 + 6, a2, 2uLL);
  *(_WORD *)(a3 + 6) = *(_WORD *)(a1 + 6);
  tlv::throwIfNotEnoughBytes(a1 + 8, a2, 4uLL);
  *(_DWORD *)(a3 + 8) = *(_DWORD *)(a1 + 8);
  tlv::throwIfNotEnoughBytes(a1 + 12, a2, 8uLL);
  *(_QWORD *)(a3 + 16) = *(_QWORD *)(a1 + 12);
  tlv::throwIfNotEnoughBytes(a1 + 20, a2, 4uLL);
  *(_DWORD *)(a3 + 24) = *(_DWORD *)(a1 + 20);
  tlv::throwIfNotEnoughBytes(a1 + 24, a2, 2uLL);
  *(_WORD *)(a3 + 28) = *(_WORD *)(a1 + 24);
  tlv::throwIfNotEnoughBytes(a1 + 26, a2, 4uLL);
  *(_DWORD *)(a3 + 32) = *(_DWORD *)(a1 + 26);
  tlv::throwIfNotEnoughBytes(a1 + 30, a2, 4uLL);
  *(_DWORD *)(a3 + 36) = *(_DWORD *)(a1 + 30);
  tlv::throwIfNotEnoughBytes(a1 + 34, a2, 2uLL);
  *(_WORD *)(a3 + 40) = *(_WORD *)(a1 + 34);
  tlv::throwIfNotEnoughBytes(a1 + 36, a2, 1uLL);
  *(_BYTE *)(a3 + 42) = *(_BYTE *)(a1 + 36);
  tlv::throwIfNotEnoughBytes(a1 + 37, a2, 4uLL);
  *(_DWORD *)(a3 + 44) = *(_DWORD *)(a1 + 37);
  tlv::throwIfNotEnoughBytes(a1 + 41, a2, 1uLL);
  *(_BYTE *)(a3 + 48) = *(_BYTE *)(a1 + 41);
  tlv::throwIfNotEnoughBytes(a1 + 42, a2, 4uLL);
  *(_DWORD *)(a3 + 52) = *(_DWORD *)(a1 + 42);
  tlv::throwIfNotEnoughBytes(a1 + 46, a2, 2uLL);
  *(_WORD *)(a3 + 56) = *(_WORD *)(a1 + 46);
  tlv::throwIfNotEnoughBytes(a1 + 48, a2, 4uLL);
  *(_DWORD *)(a3 + 60) = *(_DWORD *)(a1 + 48);
  tlv::throwIfNotEnoughBytes(a1 + 52, a2, 4uLL);
  *(_DWORD *)(a3 + 64) = *(_DWORD *)(a1 + 52);
  return a1 + 56;
}

{
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t result;

  tlv::throwIfNotEnoughBytes(a1, a2, 2uLL);
  *(_WORD *)a3 = *(_WORD *)a1;
  tlv::throwIfNotEnoughBytes(a1 + 2, a2, 1uLL);
  *(_BYTE *)(a3 + 2) = *(_BYTE *)(a1 + 2);
  tlv::throwIfNotEnoughBytes(a1 + 3, a2, 2uLL);
  *(_WORD *)(a3 + 4) = *(_WORD *)(a1 + 3);
  tlv::throwIfNotEnoughBytes(a1 + 5, a2, 1uLL);
  *(_BYTE *)(a3 + 6) = *(_BYTE *)(a1 + 5);
  tlv::throwIfNotEnoughBytes(a1 + 6, a2, 1uLL);
  v6 = *(unsigned __int8 *)(a1 + 6);
  v7 = a1 + 7;
  std::vector<nas::tlv::Cdma1xNeighborCell>::resize(a3 + 8, v6);
  v9 = *(_QWORD *)(a3 + 8);
  v8 = *(_QWORD *)(a3 + 16);
  while (1)
  {
    result = v7;
    if (v9 == v8)
      break;
    v7 = nas::tlv::parseField(v7, a2, v9);
    v9 += 8;
  }
  return result;
}

{
  int v6;

  tlv::throwIfNotEnoughBytes(a1, a2, 1uLL);
  *(_BYTE *)a3 = *(_BYTE *)a1;
  tlv::throwIfNotEnoughBytes(a1 + 1, a2, 1uLL);
  *(_BYTE *)(a3 + 1) = *(_BYTE *)(a1 + 1) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 2, a2, 1uLL);
  *(_BYTE *)(a3 + 2) = *(_BYTE *)(a1 + 2);
  tlv::throwIfNotEnoughBytes(a1 + 3, a2, 6uLL);
  v6 = *(_DWORD *)(a1 + 3);
  *(_WORD *)(a3 + 7) = *(_WORD *)(a1 + 7);
  *(_DWORD *)(a3 + 3) = v6;
  return a1 + 9;
}

{
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t result;

  tlv::throwIfNotEnoughBytes(a1, a2, 1uLL);
  *(_BYTE *)a3 = *(_BYTE *)a1;
  tlv::throwIfNotEnoughBytes(a1 + 1, a2, 4uLL);
  *(_DWORD *)(a3 + 4) = *(_DWORD *)(a1 + 1);
  tlv::throwIfNotEnoughBytes(a1 + 5, a2, 4uLL);
  *(_DWORD *)(a3 + 8) = *(_DWORD *)(a1 + 5);
  tlv::throwIfNotEnoughBytes(a1 + 9, a2, 1uLL);
  v6 = *(unsigned __int8 *)(a1 + 9);
  v7 = a1 + 10;
  std::vector<nas::tlv::EMBMSTMGIInfo>::resize(a3 + 16, v6);
  v8 = *(_QWORD *)(a3 + 16);
  v9 = *(_QWORD *)(a3 + 24);
  while (1)
  {
    result = v7;
    if (v8 == v9)
      break;
    v7 = nas::tlv::parseField(v7, a2, v8);
    v8 += 9;
  }
  return result;
}

{
  __int16 v6;
  __int16 v7;

  tlv::throwIfNotEnoughBytes(a1, a2, 1uLL);
  *(_BYTE *)a3 = *(_BYTE *)a1 != 0;
  tlv::throwIfNotEnoughBytes(a1 + 1, a2, 1uLL);
  *(_BYTE *)(a3 + 1) = *(_BYTE *)(a1 + 1);
  tlv::throwIfNotEnoughBytes(a1 + 2, a2, 1uLL);
  *(_BYTE *)(a3 + 2) = *(_BYTE *)(a1 + 2) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 3, a2, 1uLL);
  *(_BYTE *)(a3 + 3) = *(_BYTE *)(a1 + 3);
  tlv::throwIfNotEnoughBytes(a1 + 4, a2, 1uLL);
  *(_BYTE *)(a3 + 4) = *(_BYTE *)(a1 + 4) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 5, a2, 1uLL);
  *(_BYTE *)(a3 + 5) = *(_BYTE *)(a1 + 5);
  tlv::throwIfNotEnoughBytes(a1 + 6, a2, 1uLL);
  *(_BYTE *)(a3 + 6) = *(_BYTE *)(a1 + 6) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 7, a2, 1uLL);
  *(_BYTE *)(a3 + 7) = *(_BYTE *)(a1 + 7) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 8, a2, 1uLL);
  *(_BYTE *)(a3 + 8) = *(_BYTE *)(a1 + 8) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 9, a2, 1uLL);
  *(_BYTE *)(a3 + 9) = *(_BYTE *)(a1 + 9) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 10, a2, 1uLL);
  *(_BYTE *)(a3 + 10) = *(_BYTE *)(a1 + 10) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 11, a2, 1uLL);
  *(_BYTE *)(a3 + 11) = *(_BYTE *)(a1 + 11);
  tlv::throwIfNotEnoughBytes(a1 + 12, a2, 1uLL);
  *(_BYTE *)(a3 + 12) = *(_BYTE *)(a1 + 12) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 13, a2, 1uLL);
  *(_BYTE *)(a3 + 13) = *(_BYTE *)(a1 + 13);
  tlv::throwIfNotEnoughBytes(a1 + 14, a2, 1uLL);
  *(_BYTE *)(a3 + 14) = *(_BYTE *)(a1 + 14) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 15, a2, 1uLL);
  *(_BYTE *)(a3 + 15) = *(_BYTE *)(a1 + 15) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 16, a2, 1uLL);
  *(_BYTE *)(a3 + 16) = *(_BYTE *)(a1 + 16) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 17, a2, 2uLL);
  *(_WORD *)(a3 + 18) = *(_WORD *)(a1 + 17);
  tlv::throwIfNotEnoughBytes(a1 + 19, a2, 2uLL);
  *(_WORD *)(a3 + 20) = *(_WORD *)(a1 + 19);
  tlv::throwIfNotEnoughBytes(a1 + 21, a2, 1uLL);
  *(_BYTE *)(a3 + 22) = *(_BYTE *)(a1 + 21) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 22, a2, 2uLL);
  *(_WORD *)(a3 + 24) = *(_WORD *)(a1 + 22);
  tlv::throwIfNotEnoughBytes(a1 + 24, a2, 4uLL);
  *(_DWORD *)(a3 + 28) = *(_DWORD *)(a1 + 24);
  tlv::throwIfNotEnoughBytes(a1 + 28, a2, 4uLL);
  *(_DWORD *)(a3 + 32) = *(_DWORD *)(a1 + 28);
  tlv::throwIfNotEnoughBytes(a1 + 32, a2, 1uLL);
  *(_BYTE *)(a3 + 36) = *(_BYTE *)(a1 + 32) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 33, a2, 2uLL);
  *(_WORD *)(a3 + 38) = *(_WORD *)(a1 + 33);
  tlv::throwIfNotEnoughBytes(a1 + 35, a2, 1uLL);
  *(_BYTE *)(a3 + 40) = *(_BYTE *)(a1 + 35) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 36, a2, 3uLL);
  v6 = *(_WORD *)(a1 + 36);
  *(_BYTE *)(a3 + 43) = *(_BYTE *)(a1 + 38);
  *(_WORD *)(a3 + 41) = v6;
  tlv::throwIfNotEnoughBytes(a1 + 39, a2, 3uLL);
  v7 = *(_WORD *)(a1 + 39);
  *(_BYTE *)(a3 + 46) = *(_BYTE *)(a1 + 41);
  *(_WORD *)(a3 + 44) = v7;
  return a1 + 42;
}

{
  tlv::throwIfNotEnoughBytes(a1, a2, 1uLL);
  *(_BYTE *)a3 = *(_BYTE *)a1 != 0;
  tlv::throwIfNotEnoughBytes(a1 + 1, a2, 1uLL);
  *(_BYTE *)(a3 + 1) = *(_BYTE *)(a1 + 1);
  tlv::throwIfNotEnoughBytes(a1 + 2, a2, 1uLL);
  *(_BYTE *)(a3 + 2) = *(_BYTE *)(a1 + 2) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 3, a2, 1uLL);
  *(_BYTE *)(a3 + 3) = *(_BYTE *)(a1 + 3);
  tlv::throwIfNotEnoughBytes(a1 + 4, a2, 1uLL);
  *(_BYTE *)(a3 + 4) = *(_BYTE *)(a1 + 4) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 5, a2, 1uLL);
  *(_BYTE *)(a3 + 5) = *(_BYTE *)(a1 + 5);
  tlv::throwIfNotEnoughBytes(a1 + 6, a2, 1uLL);
  *(_BYTE *)(a3 + 6) = *(_BYTE *)(a1 + 6) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 7, a2, 1uLL);
  *(_BYTE *)(a3 + 7) = *(_BYTE *)(a1 + 7) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 8, a2, 1uLL);
  *(_BYTE *)(a3 + 8) = *(_BYTE *)(a1 + 8) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 9, a2, 1uLL);
  *(_BYTE *)(a3 + 9) = *(_BYTE *)(a1 + 9) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 10, a2, 1uLL);
  *(_BYTE *)(a3 + 10) = *(_BYTE *)(a1 + 10) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 11, a2, 1uLL);
  *(_BYTE *)(a3 + 11) = *(_BYTE *)(a1 + 11);
  tlv::throwIfNotEnoughBytes(a1 + 12, a2, 1uLL);
  *(_BYTE *)(a3 + 12) = *(_BYTE *)(a1 + 12) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 13, a2, 1uLL);
  *(_BYTE *)(a3 + 13) = *(_BYTE *)(a1 + 13);
  tlv::throwIfNotEnoughBytes(a1 + 14, a2, 1uLL);
  *(_BYTE *)(a3 + 14) = *(_BYTE *)(a1 + 14) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 15, a2, 0x10uLL);
  *(_OWORD *)(a3 + 15) = *(_OWORD *)(a1 + 15);
  return a1 + 31;
}

{
  __int16 v6;
  __int16 v7;
  unint64_t result;

  tlv::throwIfNotEnoughBytes(a1, a2, 1uLL);
  *(_BYTE *)a3 = *(_BYTE *)a1 != 0;
  tlv::throwIfNotEnoughBytes(a1 + 1, a2, 1uLL);
  *(_BYTE *)(a3 + 1) = *(_BYTE *)(a1 + 1);
  tlv::throwIfNotEnoughBytes(a1 + 2, a2, 1uLL);
  *(_BYTE *)(a3 + 2) = *(_BYTE *)(a1 + 2) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 3, a2, 1uLL);
  *(_BYTE *)(a3 + 3) = *(_BYTE *)(a1 + 3);
  tlv::throwIfNotEnoughBytes(a1 + 4, a2, 1uLL);
  *(_BYTE *)(a3 + 4) = *(_BYTE *)(a1 + 4) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 5, a2, 1uLL);
  *(_BYTE *)(a3 + 5) = *(_BYTE *)(a1 + 5);
  tlv::throwIfNotEnoughBytes(a1 + 6, a2, 1uLL);
  *(_BYTE *)(a3 + 6) = *(_BYTE *)(a1 + 6) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 7, a2, 1uLL);
  *(_BYTE *)(a3 + 7) = *(_BYTE *)(a1 + 7) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 8, a2, 1uLL);
  *(_BYTE *)(a3 + 8) = *(_BYTE *)(a1 + 8) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 9, a2, 2uLL);
  *(_WORD *)(a3 + 10) = *(_WORD *)(a1 + 9);
  tlv::throwIfNotEnoughBytes(a1 + 11, a2, 1uLL);
  *(_BYTE *)(a3 + 12) = *(_BYTE *)(a1 + 11) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 12, a2, 4uLL);
  *(_DWORD *)(a3 + 16) = *(_DWORD *)(a1 + 12);
  tlv::throwIfNotEnoughBytes(a1 + 16, a2, 1uLL);
  *(_BYTE *)(a3 + 20) = *(_BYTE *)(a1 + 16) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 17, a2, 1uLL);
  *(_BYTE *)(a3 + 21) = *(_BYTE *)(a1 + 17);
  tlv::throwIfNotEnoughBytes(a1 + 18, a2, 1uLL);
  *(_BYTE *)(a3 + 22) = *(_BYTE *)(a1 + 18);
  tlv::throwIfNotEnoughBytes(a1 + 19, a2, 1uLL);
  *(_BYTE *)(a3 + 23) = *(_BYTE *)(a1 + 19) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 20, a2, 3uLL);
  v6 = *(_WORD *)(a1 + 20);
  *(_BYTE *)(a3 + 26) = *(_BYTE *)(a1 + 22);
  *(_WORD *)(a3 + 24) = v6;
  tlv::throwIfNotEnoughBytes(a1 + 23, a2, 3uLL);
  v7 = *(_WORD *)(a1 + 23);
  *(_BYTE *)(a3 + 29) = *(_BYTE *)(a1 + 25);
  *(_WORD *)(a3 + 27) = v7;
  tlv::throwIfNotEnoughBytes(a1 + 26, a2, 1uLL);
  *(_BYTE *)(a3 + 30) = *(_BYTE *)(a1 + 26) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 27, a2, 1uLL);
  *(_BYTE *)(a3 + 31) = *(_BYTE *)(a1 + 27) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 28, a2, 1uLL);
  *(_BYTE *)(a3 + 32) = *(_BYTE *)(a1 + 28) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 29, a2, 1uLL);
  result = a1 + 30;
  *(_BYTE *)(a3 + 33) = *(_BYTE *)(a1 + 29) != 0;
  return result;
}

{
  __int16 v6;
  __int16 v7;

  tlv::throwIfNotEnoughBytes(a1, a2, 1uLL);
  *(_BYTE *)a3 = *(_BYTE *)a1 != 0;
  tlv::throwIfNotEnoughBytes(a1 + 1, a2, 1uLL);
  *(_BYTE *)(a3 + 1) = *(_BYTE *)(a1 + 1);
  tlv::throwIfNotEnoughBytes(a1 + 2, a2, 1uLL);
  *(_BYTE *)(a3 + 2) = *(_BYTE *)(a1 + 2) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 3, a2, 1uLL);
  *(_BYTE *)(a3 + 3) = *(_BYTE *)(a1 + 3);
  tlv::throwIfNotEnoughBytes(a1 + 4, a2, 1uLL);
  *(_BYTE *)(a3 + 4) = *(_BYTE *)(a1 + 4) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 5, a2, 1uLL);
  *(_BYTE *)(a3 + 5) = *(_BYTE *)(a1 + 5);
  tlv::throwIfNotEnoughBytes(a1 + 6, a2, 1uLL);
  *(_BYTE *)(a3 + 6) = *(_BYTE *)(a1 + 6) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 7, a2, 1uLL);
  *(_BYTE *)(a3 + 7) = *(_BYTE *)(a1 + 7) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 8, a2, 1uLL);
  *(_BYTE *)(a3 + 8) = *(_BYTE *)(a1 + 8) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 9, a2, 2uLL);
  *(_WORD *)(a3 + 10) = *(_WORD *)(a1 + 9);
  tlv::throwIfNotEnoughBytes(a1 + 11, a2, 1uLL);
  *(_BYTE *)(a3 + 12) = *(_BYTE *)(a1 + 11) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 12, a2, 4uLL);
  *(_DWORD *)(a3 + 16) = *(_DWORD *)(a1 + 12);
  tlv::throwIfNotEnoughBytes(a1 + 16, a2, 1uLL);
  *(_BYTE *)(a3 + 20) = *(_BYTE *)(a1 + 16) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 17, a2, 1uLL);
  *(_BYTE *)(a3 + 21) = *(_BYTE *)(a1 + 17);
  tlv::throwIfNotEnoughBytes(a1 + 18, a2, 1uLL);
  *(_BYTE *)(a3 + 22) = *(_BYTE *)(a1 + 18);
  tlv::throwIfNotEnoughBytes(a1 + 19, a2, 1uLL);
  *(_BYTE *)(a3 + 23) = *(_BYTE *)(a1 + 19) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 20, a2, 3uLL);
  v6 = *(_WORD *)(a1 + 20);
  *(_BYTE *)(a3 + 26) = *(_BYTE *)(a1 + 22);
  *(_WORD *)(a3 + 24) = v6;
  tlv::throwIfNotEnoughBytes(a1 + 23, a2, 3uLL);
  v7 = *(_WORD *)(a1 + 23);
  *(_BYTE *)(a3 + 29) = *(_BYTE *)(a1 + 25);
  *(_WORD *)(a3 + 27) = v7;
  tlv::throwIfNotEnoughBytes(a1 + 26, a2, 1uLL);
  *(_BYTE *)(a3 + 30) = *(_BYTE *)(a1 + 26) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 27, a2, 1uLL);
  *(_BYTE *)(a3 + 31) = *(_BYTE *)(a1 + 27);
  tlv::throwIfNotEnoughBytes(a1 + 28, a2, 1uLL);
  *(_BYTE *)(a3 + 32) = *(_BYTE *)(a1 + 28) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 29, a2, 1uLL);
  *(_BYTE *)(a3 + 33) = *(_BYTE *)(a1 + 29);
  tlv::throwIfNotEnoughBytes(a1 + 30, a2, 1uLL);
  *(_BYTE *)(a3 + 34) = *(_BYTE *)(a1 + 30) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 31, a2, 2uLL);
  *(_WORD *)(a3 + 36) = *(_WORD *)(a1 + 31);
  return a1 + 33;
}

{
  unint64_t v5;
  unint64_t v6;

  v5 = a1;
  tlv::throwIfNotEnoughBytes(a1, a2, 1uLL);
  *(_BYTE *)a3 = *(_BYTE *)v5;
  tlv::throwIfNotEnoughBytes(v5 + 1, a2, 1uLL);
  v6 = *(unsigned __int8 *)(v5 + 1);
  v5 += 2;
  tlv::throwIfNotEnoughBytes(v5, a2, v6);
  std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((_QWORD *)(a3 + 8), (char *)v5, (char *)(v5 + v6), v6);
  return v5 + v6;
}

{
  tlv::throwIfNotEnoughBytes(a1, a2, 2uLL);
  *(_WORD *)a3 = *(_WORD *)a1;
  tlv::throwIfNotEnoughBytes(a1 + 2, a2, 1uLL);
  *(_BYTE *)(a3 + 2) = *(_BYTE *)(a1 + 2);
  tlv::throwIfNotEnoughBytes(a1 + 3, a2, 1uLL);
  *(_BYTE *)(a3 + 3) = *(_BYTE *)(a1 + 3);
  tlv::throwIfNotEnoughBytes(a1 + 4, a2, 1uLL);
  *(_BYTE *)(a3 + 4) = *(_BYTE *)(a1 + 4);
  tlv::throwIfNotEnoughBytes(a1 + 5, a2, 1uLL);
  *(_BYTE *)(a3 + 5) = *(_BYTE *)(a1 + 5);
  tlv::throwIfNotEnoughBytes(a1 + 6, a2, 1uLL);
  *(_BYTE *)(a3 + 6) = *(_BYTE *)(a1 + 6);
  tlv::throwIfNotEnoughBytes(a1 + 7, a2, 1uLL);
  *(_BYTE *)(a3 + 7) = *(_BYTE *)(a1 + 7);
  return a1 + 8;
}

unint64_t tlv::throwIfNotEnoughBytes(unint64_t this, const unsigned __int8 *a2, unint64_t a3)
{
  std::logic_error *exception;
  unint64_t v4;

  if (this > (unint64_t)a2)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    tlv::TlvParseException::TlvParseException(exception);
    goto LABEL_7;
  }
  if ((a3 & 0x8000000000000000) != 0 || this + a3 > (unint64_t)a2)
  {
    v4 = this;
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    tlv::TlvParseException::TlvParseException((tlv::TlvParseException *)exception, a3, (unint64_t)&a2[-v4]);
LABEL_7:
  }
  return this;
}

void sub_21689AA30(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<elqm::tlv::TrafficClassReport>::~TlvWrapper(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24D5D4170;
  v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  JUMPOUT(0x2199FEAC4);
}

void *qmi::MutableMessageBase::TlvWrapper<elqm::tlv::TrafficClassReport>::write(uint64_t a1, void **a2)
{
  char v3;
  char *v4;
  uint64_t v5;
  void *result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (char *)*a2;
  v5 = (uint64_t)*a2 + 3;
  *a2 = (void *)v5;
  result = tlv::writeV<vs::tlv::CallingNumber>(a2, a1 + 16);
  v7 = (char *)*a2 - v5;
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

void *tlv::writeV<vs::tlv::CallingNumber>(void **a1, uint64_t a2)
{
  char *v4;
  void *result;

  v4 = (char *)*a1;
  result = memcpy(*a1, *(const void **)a2, *(_QWORD *)(a2 + 8) - *(_QWORD *)a2);
  *a1 = &v4[*(_QWORD *)(a2 + 8) - *(_QWORD *)a2];
  return result;
}

void QMICellMonitorCommandDriver::getCellInformation(uint64_t a1, uint64_t a2, uint64_t a3, NSObject **a4)
{
  _DWORD *v7;
  unsigned int v8;
  uint64_t v9;
  NSObject *v10;
  _DWORD *v11;
  _DWORD *v12;
  _DWORD *v13;
  uint64_t (*v14)(_QWORD);
  dispatch_group_t group;

  subscriber::makeSimSlotRange();
  v7 = v12;
  if (v12 != v13)
  {
    while ((v14(*v7) & 1) == 0)
    {
      if (++v7 == v13)
      {
        v7 = v13;
        break;
      }
    }
    while (v7 != v13)
    {
      v8 = *v7 == 1;
      if (*v7 == 2)
        v8 = 2;
      if (*v7 == 3)
        v9 = 3;
      else
        v9 = v8;
      v10 = *a4;
      group = v10;
      if (v10)
      {
        dispatch_retain(v10);
        dispatch_group_enter(v10);
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t, dispatch_group_t *))(*(_QWORD *)a1 + 64))(a1, v9, a3, &group);
      if (group)
      {
        dispatch_group_leave(group);
        if (group)
          dispatch_release(group);
      }
      v11 = v7 + 1;
      v7 = v13;
      if (v11 != v13)
      {
        v7 = v11;
        while ((v14(*v7) & 1) == 0)
        {
          if (++v7 == v13)
          {
            v7 = v13;
            break;
          }
        }
      }
    }
  }
}

void sub_21689AC7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, dispatch_group_t group)
{
  if (group)
  {
    dispatch_group_leave(group);
    dispatch_release(group);
  }
  _Unwind_Resume(exception_object);
}

void QMICellMonitorCommandDriver::getCellInformationForSlot(uint64_t a1, int a2, int a3, NSObject **a4)
{
  int v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  _QWORD *v12;
  unint64_t *v13;
  uint64_t v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *p_shared_owners;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _OWORD v24[2];
  _QWORD v25[5];
  std::__shared_weak_count *v26;
  int v27;
  char *v28;
  std::__shared_weak_count *v29;
  _QWORD aBlock[5];

  memset(v24, 0, sizeof(v24));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v24);
  if ((a2 - 1) >= 3)
    v8 = 0;
  else
    v8 = a2;
  v9 = qmi::ClientRouter::get();
  v10 = operator new();
  *(_QWORD *)v10 = v9;
  *(_QWORD *)(v10 + 8) = QMIServiceMsg::create();
  *(_DWORD *)(v10 + 16) = 25000;
  *(_QWORD *)(v10 + 24) = 0;
  *(_QWORD *)(v10 + 32) = 0;
  v23 = v10;
  v11 = *a4;
  if (v11)
  {
    dispatch_retain(v11);
    dispatch_group_enter(v11);
  }
  v12 = operator new(0x30uLL);
  v12[1] = 0;
  v13 = v12 + 1;
  v12[2] = 0;
  *v12 = &off_24D5D4BC0;
  v12[3] = a1;
  v12[4] = v11;
  *((_DWORD *)v12 + 10) = a3;
  v28 = (char *)(v12 + 3);
  v29 = (std::__shared_weak_count *)v12;
  v14 = MEMORY[0x24BDAC760];
  v25[0] = MEMORY[0x24BDAC760];
  v25[1] = 1174405120;
  v25[2] = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN27QMICellMonitorCommandDriver25getCellInformationForSlotEN10subscriber7SimSlotE14CellInfoSourceN8dispatch13group_sessionEE3__0EEOS1_OT__block_invoke;
  v25[3] = &__block_descriptor_tmp_71_2;
  v25[4] = v12 + 3;
  v26 = (std::__shared_weak_count *)v12;
  do
    v15 = __ldxr(v13);
  while (__stxr(v15 + 1, v13));
  v27 = v8;
  aBlock[0] = v14;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_13;
  aBlock[3] = &unk_24D5D4C08;
  aBlock[4] = v25;
  *(_QWORD *)(v10 + 32) = _Block_copy(aBlock);
  v16 = v26;
  if (v26)
  {
    p_shared_owners = (unint64_t *)&v26->__shared_owners_;
    do
      v18 = __ldaxr(p_shared_owners);
    while (__stlxr(v18 - 1, p_shared_owners));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
  v19 = v29;
  if (v29)
  {
    v20 = (unint64_t *)&v29->__shared_owners_;
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }
  v22 = v23;
  v23 = 0;
  if (v22)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v23, v22);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v24);
}

void sub_21689AEE0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;
  va_list va;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v7 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v3);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v4 - 120);
  QMICellMonitorCommandDriver::getCellInformationForSlot(subscriber::SimSlot,CellInfoSource,dispatch::group_session)::$_0::~$_0((uint64_t)va);
  v6 = v12;
  v12 = 0;
  if (v6)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v2, v6);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va1);
  _Unwind_Resume(a1);
}

uint64_t QMIEnhancedLQMCommandDriver::sendTrafficInfo(uint64_t a1, uint64_t a2, int a3, const void **a4)
{
  os_log_t *v7;
  os_log_t *v8;
  uint64_t (*v9)(uint64_t);
  capabilities::ct *v10;
  char *v11;
  const void **v12;
  unint64_t *v13;
  NSObject *v14;
  uint64_t v15;
  const char *v16;
  const void **v17;
  unint64_t *v18;
  NSObject *v19;
  const char *v20;
  char *v21;
  unint64_t *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  char *v30;
  uint64_t *v31;
  char *v32;
  char *v33;
  char *v34;
  uint64_t v35;
  _QWORD v37[4];
  const void *v38;
  _QWORD v39[2];
  CFIndex (*v40)(uint64_t, unint64_t *);
  void *v41;
  const void *v42;
  _QWORD v43[4];
  const void *v44;
  uint8_t buf[16];
  __int128 v46;
  uint8_t v47[4];
  const char *v48;
  __int16 v49;
  int v50;
  uint64_t v51;

  v51 = *MEMORY[0x24BDAC8D0];
  v7 = (os_log_t *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 88) + 16))(*(_QWORD *)(a1 + 88));
  v8 = v7;
  if (*a4)
    v9 = ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::get;
  else
    v9 = 0;
  if (v9)
  {
    if (*(_QWORD *)(a1 + 112))
    {
      *(_OWORD *)buf = 0u;
      v46 = 0u;
      v10 = (capabilities::ct *)qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)buf);
      if (capabilities::ct::supportsGemini(v10))
      {
        v11 = qmi::MutableMessageBase::getTLV<elqm::tlv::SubscriptionId>(buf);
        *v11 = subscriber::simSlotAsInstance();
      }
      switch(a3)
      {
        case 22:
          v37[0] = MEMORY[0x24BDAC760];
          v37[1] = 1174405120;
          v37[2] = ___ZN27QMIEnhancedLQMCommandDriver15sendTrafficInfoEN10subscriber7SimSlotEtN3ctu2cf11CFSharedRefIK8__CFDataEE_block_invoke_33;
          v37[3] = &__block_descriptor_tmp_34_6;
          v12 = &v38;
          ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::SharedRef(&v38, a4);
          v18 = (unint64_t *)qmi::MutableMessageBase::getTLV<elqm::tlv::TrafficClassReport>(buf);
          ___ZN27QMIEnhancedLQMCommandDriver15sendTrafficInfoEN10subscriber7SimSlotEtN3ctu2cf11CFSharedRefIK8__CFDataEE_block_invoke_33((uint64_t)v37, v18);
          break;
        case 19:
          v39[0] = MEMORY[0x24BDAC760];
          v39[1] = 1174405120;
          v40 = ___ZN27QMIEnhancedLQMCommandDriver15sendTrafficInfoEN10subscriber7SimSlotEtN3ctu2cf11CFSharedRefIK8__CFDataEE_block_invoke_31;
          v41 = &__block_descriptor_tmp_32_4;
          v12 = &v42;
          ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::SharedRef(&v42, a4);
          v17 = *(const void ***)&buf[8];
          if (*(_QWORD *)&buf[8] != (_QWORD)v46)
          {
            while (*((_BYTE *)*v17 + 8) != 19)
            {
              if (++v17 == (const void **)v46)
                goto LABEL_27;
            }
          }
          if (v17 == (const void **)v46)
          {
LABEL_27:
            v23 = operator new();
            v24 = v23;
            *(_BYTE *)(v23 + 8) = 19;
            *(_QWORD *)(v23 + 16) = 0;
            v22 = (unint64_t *)(v23 + 16);
            *(_QWORD *)v23 = &off_24D5D41C0;
            *(_QWORD *)(v23 + 24) = 0;
            *(_QWORD *)(v23 + 32) = 0;
            v25 = v46;
            if ((unint64_t)v46 >= *((_QWORD *)&v46 + 1))
            {
              v27 = (uint64_t)(v46 - *(_QWORD *)&buf[8]) >> 3;
              if ((unint64_t)(v27 + 1) >> 61)
                std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
              v28 = (uint64_t)(*((_QWORD *)&v46 + 1) - *(_QWORD *)&buf[8]) >> 2;
              if (v28 <= v27 + 1)
                v28 = v27 + 1;
              if (*((_QWORD *)&v46 + 1) - *(_QWORD *)&buf[8] >= 0x7FFFFFFFFFFFFFF8uLL)
                v29 = 0x1FFFFFFFFFFFFFFFLL;
              else
                v29 = v28;
              if (v29)
                v30 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v46 + 8, v29);
              else
                v30 = 0;
              v31 = (uint64_t *)&v30[8 * v27];
              v32 = &v30[8 * v29];
              *v31 = v24;
              v26 = v31 + 1;
              v34 = *(char **)&buf[8];
              v33 = (char *)v46;
              if ((_QWORD)v46 != *(_QWORD *)&buf[8])
              {
                do
                {
                  v35 = *((_QWORD *)v33 - 1);
                  v33 -= 8;
                  *--v31 = v35;
                }
                while (v33 != v34);
                v33 = *(char **)&buf[8];
              }
              *(_QWORD *)&buf[8] = v31;
              *(_QWORD *)&v46 = v26;
              *((_QWORD *)&v46 + 1) = v32;
              if (v33)
                operator delete(v33);
            }
            else
            {
              *(_QWORD *)v46 = v23;
              v26 = (_QWORD *)(v25 + 8);
            }
            *(_QWORD *)&v46 = v26;
          }
          else
          {
            if (!v21)
              __cxa_bad_cast();
            v22 = (unint64_t *)(v21 + 16);
          }
          v40((uint64_t)v39, v22);
          break;
        case 18:
          v43[0] = MEMORY[0x24BDAC760];
          v43[1] = 1174405120;
          v43[2] = ___ZN27QMIEnhancedLQMCommandDriver15sendTrafficInfoEN10subscriber7SimSlotEtN3ctu2cf11CFSharedRefIK8__CFDataEE_block_invoke;
          v43[3] = &__block_descriptor_tmp_30_4;
          v12 = &v44;
          ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::SharedRef(&v44, a4);
          v13 = (unint64_t *)qmi::MutableMessageBase::getTLV<elqm::tlv::TrafficClassReport>(buf);
          ___ZN27QMIEnhancedLQMCommandDriver15sendTrafficInfoEN10subscriber7SimSlotEtN3ctu2cf11CFSharedRefIK8__CFDataEE_block_invoke((uint64_t)v43, v13);
          break;
        default:
          v19 = *v8;
          v15 = 0;
          if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
          {
            v20 = elqm::asString(a3);
            *(_DWORD *)v47 = 136315394;
            v48 = v20;
            v49 = 1024;
            v50 = a3;
            _os_log_impl(&dword_216897000, v19, OS_LOG_TYPE_DEFAULT, "#N Unsupported traffic info payload type %s (%d)", v47, 0x12u);
            v15 = 0;
          }
          goto LABEL_48;
      }
      ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::~SharedRef(v12);
      if (QMIServiceMsg::create())
        qmi::Client::send();
      v15 = 1;
LABEL_48:
      qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)buf);
      return v15;
    }
    v14 = *v7;
    v15 = 0;
    if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      v16 = "#N Sending traffic info not yet ready";
      goto LABEL_16;
    }
  }
  else
  {
    v14 = *v7;
    v15 = 0;
    if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      v16 = "#N Invalid traffic info payload";
LABEL_16:
      _os_log_impl(&dword_216897000, v14, OS_LOG_TYPE_DEFAULT, v16, buf, 2u);
      return 0;
    }
  }
  return v15;
}

void sub_21689B3DC(_Unwind_Exception *a1)
{
  uint64_t v1;

  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)(v1 - 128));
  _Unwind_Resume(a1);
}

uint64_t SimInstanceLoggerDefault<ctu::OsLogLogger,subscriber::SimSlot,std::function<char const* const ()(subscriber::SimSlot)>>::getLoggerForSlot(uint64_t a1, int a2)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  BOOL v5;
  uint64_t *v6;

  v2 = *(_QWORD *)(a1 + 16);
  if (!v2)
    return a1 + 32;
  v3 = a1 + 16;
  do
  {
    v4 = *(_DWORD *)(v2 + 32);
    v5 = v4 < a2;
    if (v4 >= a2)
      v6 = (uint64_t *)v2;
    else
      v6 = (uint64_t *)(v2 + 8);
    if (!v5)
      v3 = v2;
    v2 = *v6;
  }
  while (*v6);
  if (v3 != a1 + 16 && *(_DWORD *)(v3 + 32) <= a2)
    return v3 + 40;
  else
    return a1 + 32;
}

char *qmi::MutableMessageBase::getTLV<elqm::tlv::TrafficClassReport>(_QWORD *a1)
{
  const void **v2;
  const void **v3;
  char **v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  v4 = (char **)(a1 + 1);
  if (v2 != v3)
  {
    while (*((_BYTE *)*v2 + 8) != 18)
    {
      if (++v2 == v3)
        goto LABEL_8;
    }
  }
  if (v2 == v3)
  {
LABEL_8:
    v7 = operator new();
    *(_BYTE *)(v7 + 8) = 18;
    *(_QWORD *)v7 = &off_24D5D4170;
    *(_QWORD *)(v7 + 16) = 0;
    v6 = v7 + 16;
    *(_QWORD *)(v7 + 24) = 0;
    *(_QWORD *)(v7 + 32) = 0;
    v8 = a1[3];
    v9 = (uint64_t *)a1[2];
    if ((unint64_t)v9 >= v8)
    {
      v11 = ((char *)v9 - *v4) >> 3;
      if ((unint64_t)(v11 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v12 = v8 - (_QWORD)*v4;
      v13 = v12 >> 2;
      if (v12 >> 2 <= (unint64_t)(v11 + 1))
        v13 = v11 + 1;
      if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
        v14 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v14 = v13;
      if (v14)
        v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v14);
      else
        v15 = 0;
      v16 = (uint64_t *)&v15[8 * v11];
      v17 = &v15[8 * v14];
      *v16 = v7;
      v10 = v16 + 1;
      v19 = (char *)a1[1];
      v18 = (char *)a1[2];
      if (v18 != v19)
      {
        do
        {
          v20 = *((_QWORD *)v18 - 1);
          v18 -= 8;
          *--v16 = v20;
        }
        while (v18 != v19);
        v18 = *v4;
      }
      a1[1] = v16;
      a1[2] = v10;
      a1[3] = v17;
      if (v18)
        operator delete(v18);
    }
    else
    {
      *v9 = v7;
      v10 = v9 + 1;
    }
    a1[2] = v10;
  }
  else
  {
    if (!v5)
      __cxa_bad_cast();
    return v5 + 16;
  }
  return (char *)v6;
}

CFIndex ___ZN27QMIEnhancedLQMCommandDriver15sendTrafficInfoEN10subscriber7SimSlotEtN3ctu2cf11CFSharedRefIK8__CFDataEE_block_invoke(uint64_t a1, unint64_t *a2)
{
  UInt8 *BytePtr;
  CFIndex result;
  CFIndex v6;
  unint64_t *v7;

  BytePtr = (UInt8 *)CFDataGetBytePtr(*(CFDataRef *)(a1 + 32));
  result = CFDataGetLength(*(CFDataRef *)(a1 + 32));
  v7 = a2;
  if (result)
  {
    v6 = result;
    do
    {
      result = (CFIndex)std::back_insert_iterator<std::vector<unsigned char>>::operator=[abi:ne180100](&v7, BytePtr++);
      --v6;
    }
    while (v6);
  }
  return result;
}

char *qmi::MutableMessageBase::getTLV<elqm::tlv::SubscriptionId>(_QWORD *a1)
{
  const void **v2;
  const void **v3;
  char **v4;
  char *v5;
  char *result;
  uint64_t v7;
  unint64_t v8;
  uint64_t *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  v4 = (char **)(a1 + 1);
  if (v2 != v3)
  {
    while (*((_BYTE *)*v2 + 8) != 31)
    {
      if (++v2 == v3)
        goto LABEL_8;
    }
  }
  if (v2 == v3)
  {
LABEL_8:
    v7 = operator new();
    *(_WORD *)(v7 + 8) = 31;
    *(_QWORD *)v7 = &off_24D5D3E78;
    v8 = a1[3];
    v9 = (uint64_t *)a1[2];
    if ((unint64_t)v9 >= v8)
    {
      v11 = ((char *)v9 - *v4) >> 3;
      if ((unint64_t)(v11 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v12 = v8 - (_QWORD)*v4;
      v13 = v12 >> 2;
      if (v12 >> 2 <= (unint64_t)(v11 + 1))
        v13 = v11 + 1;
      if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
        v14 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v14 = v13;
      if (v14)
        v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v14);
      else
        v15 = 0;
      v16 = (uint64_t *)&v15[8 * v11];
      v17 = &v15[8 * v14];
      *v16 = v7;
      v10 = v16 + 1;
      v19 = (char *)a1[1];
      v18 = (char *)a1[2];
      if (v18 != v19)
      {
        do
        {
          v20 = *((_QWORD *)v18 - 1);
          v18 -= 8;
          *--v16 = v20;
        }
        while (v18 != v19);
        v18 = *v4;
      }
      a1[1] = v16;
      a1[2] = v10;
      a1[3] = v17;
      if (v18)
        operator delete(v18);
    }
    else
    {
      *v9 = v7;
      v10 = v9 + 1;
    }
    result = (char *)(v7 + 9);
    a1[2] = v10;
  }
  else
  {
    if (!v5)
      __cxa_bad_cast();
    return v5 + 9;
  }
  return result;
}

const void **ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::~SharedRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

const void **ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::SharedRef(const void **a1, const void **a2)
{
  const void *v3;

  v3 = *a2;
  *a1 = *a2;
  if (v3)
    CFRetain(v3);
  return a1;
}

uint64_t `non-virtual thunk to'QMIDataCommandDriver::reportPdpStatistics(uint64_t a1, _QWORD **a2)
{
  return QMIDataCommandDriver::reportPdpStatistics(a1 - 32, a2);
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMICellMonitorCommandDriver::init_sync(void)::$_3>(unsigned short,QMICellMonitorCommandDriver::init_sync(void)::$_3 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMICellMonitorCommandDriver::init_sync(void)::$_3 &&,QMIServiceMsg const)>::operator()(uint64_t a1, unsigned int *a2, QMIServiceMsg *this)
{
  unsigned int v4;
  uint64_t v6;
  uint64_t v7;
  os_log_t *v8;
  uint64_t TlvValue;
  int v10;
  uint64_t v11;
  int v12;
  char v13;
  int v14;
  void *v15;
  int v16;
  void *v17;
  int v18;
  void *v19;
  NSObject *v20;
  uint64_t v21;
  const char *v22;
  unsigned __int8 *v23;
  int v24;
  unsigned __int8 *v25;
  int v26;
  unsigned __int8 *v27;
  char *v28;
  int64_t v29;
  uint64_t v30;
  int *v31;
  char *v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  int v37;
  os_log_t *v38;
  unsigned int v39;
  uint64_t v40;
  MCCAndMNC *v41;
  uint64_t v42;
  void **v43;
  const char *v44;
  void *v45;
  uint64_t v46;
  uint64_t v47;
  _WORD v48[12];
  void *__p[2];
  __int128 v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  _BYTE v55[32];
  unsigned __int8 *v56;
  void *v57;
  char v58;
  void *v59;
  char *v60;
  uint64_t v61;
  char v62;
  __int128 buf;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  uint64_t v67;

  v67 = *MEMORY[0x24BDAC8D0];
  v4 = *a2;
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    buf = 0uLL;
    *(_QWORD *)&v64 = 0;
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v48, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v48);
    if ((_QWORD)buf)
    {
      *((_QWORD *)&buf + 1) = buf;
      operator delete((void *)buf);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v48);
  }
  v6 = *(_QWORD *)(a1 + 8);
  if (v4 - 1 >= 3)
    v7 = 0;
  else
    v7 = v4;
  v8 = (os_log_t *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v6 + 88) + 16))(*(_QWORD *)(v6 + 88), v7);
  TlvValue = qmi::MessageBase::findTlvValue((qmi::MessageBase *)v48);
  v11 = TlvValue;
  if (TlvValue)
  {
    v12 = v10;
    *(_QWORD *)&buf = TlvValue;
    v13 = tlv::parseV<nas::tlv::Fetch>((unint64_t *)&buf, v10);
    if ((_QWORD)buf)
    {
      v14 = 1;
      switch(v13)
      {
        case 0:
          *(_OWORD *)__p = 0u;
          v50 = 0u;
          v15 = (void *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)v48);
          v17 = v15;
          if (v15)
          {
            v18 = v16;
            v59 = v15;
            buf = 0uLL;
            *(_QWORD *)&v64 = 0;
            tlv::parseV<nas::tlv::LAPSMCCInfo>((unint64_t *)&v59, v16, (uint64_t)&buf);
            v19 = v59;
            if (v59)
            {
              if (BYTE8(v50))
              {
                std::vector<unsigned short>::__assign_with_size[abi:ne180100]<unsigned short *,unsigned short *>((char *)__p, (char *)buf, *((uint64_t *)&buf + 1), (uint64_t)(*((_QWORD *)&buf + 1) - buf) >> 1);
              }
              else
              {
                __p[0] = 0;
                __p[1] = 0;
                *(_QWORD *)&v50 = 0;
                std::vector<unsigned short>::__init_with_size[abi:ne180100]<unsigned short *,unsigned short *>(__p, (const void *)buf, *((uint64_t *)&buf + 1), (uint64_t)(*((_QWORD *)&buf + 1) - buf) >> 1);
                BYTE8(v50) = 1;
              }
            }
            if ((_QWORD)buf)
            {
              *((_QWORD *)&buf + 1) = buf;
              operator delete((void *)buf);
            }
            if (!v19)
              ((void (*)(_QWORD, uint64_t, void *, _QWORD))*MEMORY[0x24BED8BD0])(v48[0], 177, v17, v18);
          }
          if (!BYTE8(v50))
            goto LABEL_25;
          v46 = *(_QWORD *)(v6 + 48);
          *(_QWORD *)&v64 = 0;
          buf = 0uLL;
          std::vector<unsigned short>::__init_with_size[abi:ne180100]<unsigned short *,unsigned short *>(&buf, __p[0], (uint64_t)__p[1], ((char *)__p[1] - (char *)__p[0]) >> 1);
          (*(void (**)(uint64_t, uint64_t, __int128 *))(*(_QWORD *)v46 + 32))(v46, v7, &buf);
          v45 = (void *)buf;
          if (!(_QWORD)buf)
            goto LABEL_22;
          *((_QWORD *)&buf + 1) = buf;
          goto LABEL_71;
        case 1:
          *(_OWORD *)__p = 0u;
          v50 = 0u;
          v23 = (unsigned __int8 *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)v48);
          v25 = v23;
          if (!v23)
            goto LABEL_22;
          v26 = v24;
          v56 = v23;
          v59 = 0;
          v60 = 0;
          v61 = 0;
          tlv::parseV<nas::tlv::LAPSPLMNInfo>(&v56, v24, &v59);
          v27 = v56;
          v28 = (char *)v59;
          if (v56)
          {
            *(_QWORD *)&v64 = 0;
            buf = 0uLL;
            v29 = v60 - (_BYTE *)v59;
            if (v60 == v59)
            {
              v31 = 0;
            }
            else
            {
              std::vector<unsigned int>::__vallocate[abi:ne180100](&buf, v29 >> 2);
              v30 = *((_QWORD *)&buf + 1);
              bzero(*((void **)&buf + 1), v29);
              v31 = (int *)(v30 + v29);
              v29 = buf;
              v28 = (char *)v59;
              v32 = v60;
              if (v59 != v60)
              {
                v33 = 0;
                do
                {
                  *(_DWORD *)(v29 + v33) = *(_DWORD *)&v28[v33];
                  v33 += 4;
                }
                while (&v28[v33] != v32);
              }
            }
          }
          else
          {
            v29 = 0;
            v31 = 0;
          }
          if (v28)
          {
            v60 = v28;
            operator delete(v28);
          }
          if (v27)
          {
            v47 = *(_QWORD *)(v6 + 48);
            *(_QWORD *)&v64 = 0;
            buf = 0uLL;
            std::vector<std::pair<unsigned short,unsigned short>>::__init_with_size[abi:ne180100]<std::pair<unsigned short,unsigned short>*,std::pair<unsigned short,unsigned short>*>((char *)&buf, (int *)v29, v31, ((uint64_t)v31 - v29) >> 2);
            (*(void (**)(uint64_t, uint64_t, __int128 *))(*(_QWORD *)v47 + 40))(v47, v7, &buf);
            if ((_QWORD)buf)
            {
              *((_QWORD *)&buf + 1) = buf;
              operator delete((void *)buf);
            }
            if (v29)
            {
              v45 = (void *)v29;
              goto LABEL_71;
            }
          }
          else
          {
            ((void (*)(_QWORD, uint64_t, unsigned __int8 *, _QWORD))*MEMORY[0x24BED8BD0])(v48[0], 178, v25, v26);
          }
          goto LABEL_22;
        case 2:
          goto LABEL_34;
        case 3:
          v14 = 0;
LABEL_34:
          *(_OWORD *)__p = 0u;
          v50 = 0u;
          v34 = qmi::MessageBase::findTlvValue((qmi::MessageBase *)v48);
          v36 = v34;
          if (!v34)
            goto LABEL_22;
          v37 = v35;
          v53 = 0;
          v54 = v34;
          v51 = 0;
          v52 = 0;
          tlv::parseV<nas::tlv::LAPSCellInfo_V2>((unint64_t *)&v54, v35, &v51);
          if (!v54)
          {
            ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(v48[0], 180, v36, v37);
            goto LABEL_22;
          }
          v38 = (os_log_t *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v6 + 88) + 16))(*(_QWORD *)(v6 + 88), v7);
          v39 = v53;
          if (v53 <= 4)
          {
            v40 = dword_216AAAEC4[(int)v53];
            v65 = 0u;
            v66 = 0u;
            buf = 0u;
            v64 = 0u;
            v41 = (MCCAndMNC *)MEMORY[0x2199FE398](&buf, (unsigned __int16)v51, WORD1(v51));
            v42 = *(_QWORD *)(v6 + 48);
            if (v14)
            {
              MCCAndMNC::getMcc(v41);
              MCCAndMNC::getMnc((MCCAndMNC *)&buf);
              (*(void (**)(uint64_t, uint64_t, uint64_t, void **, unsigned __int8 **, _QWORD, uint64_t))(*(_QWORD *)v42 + 56))(v42, v7, v40, &v59, &v56, HIDWORD(v51), v52);
              if (v58 < 0)
                operator delete(v57);
              if (v62 < 0)
              {
                v43 = &v59;
LABEL_50:
                operator delete(v43[1]);
              }
            }
            else
            {
              MCCAndMNC::getMcc(v41);
              MCCAndMNC::getMnc((MCCAndMNC *)&buf);
              (*(void (**)(uint64_t, uint64_t, uint64_t, _BYTE *, unsigned __int8 **, _QWORD, uint64_t))(*(_QWORD *)v42 + 48))(v42, v7, v40, v55, &v56, HIDWORD(v51), v52);
              if (v58 < 0)
                operator delete(v57);
              if ((v55[31] & 0x80000000) != 0)
              {
                v43 = (void **)v55;
                goto LABEL_50;
              }
            }
            if (SHIBYTE(v66) < 0)
              operator delete(*((void **)&v65 + 1));
            if (SHIBYTE(v64) < 0)
            {
              v45 = (void *)*((_QWORD *)&buf + 1);
LABEL_71:
              operator delete(v45);
            }
            goto LABEL_22;
          }
          v20 = *v38;
          if (!os_log_type_enabled(*v38, OS_LOG_TYPE_DEFAULT))
            goto LABEL_22;
          v44 = nas::asString(v39);
          LODWORD(buf) = 136315138;
          *(_QWORD *)((char *)&buf + 4) = v44;
          v22 = "#N Ignoring RAT %s";
          break;
        default:
          goto LABEL_19;
      }
      goto LABEL_21;
    }
    ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(v48[0], 161, v11, v12);
  }
LABEL_19:
  *(_OWORD *)__p = 0u;
  v50 = 0u;
  v20 = *v8;
  if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
  {
    v21 = asString();
    LODWORD(buf) = 136315138;
    *(_QWORD *)((char *)&buf + 4) = v21;
    v22 = "#N Unhandled fetch type (%s) from LAPS fetch indication";
LABEL_21:
    _os_log_impl(&dword_216897000, v20, OS_LOG_TYPE_DEFAULT, v22, (uint8_t *)&buf, 0xCu);
  }
LABEL_22:
  if (BYTE8(v50) && __p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
LABEL_25:
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v48);
}

void sub_21689BE88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34,void *a35,uint64_t a36,uint64_t a37,int a38,__int16 a39,char a40,char a41)
{
  uint64_t v41;

  if (a34 < 0)
    operator delete(__p);
  if (a27 < 0)
    operator delete(a22);
  MCCAndMNC::~MCCAndMNC((void **)(v41 - 160));
  if (a16)
  {
    if (a13)
    {
      a14 = (uint64_t)a13;
      operator delete(a13);
    }
  }
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a10);
  _Unwind_Resume(a1);
}

void ___ZN27QMICellMonitorCommandDriver32processLTECellV4Information_syncERKN3nas11GetCellInfo7RespIndER14CellInfoUpdate_block_invoke(uint64_t a1, uint64_t *a2)
{
  int64x2_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _WORD *v8;
  _WORD *v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  _QWORD v13[2];
  void *v14;
  char v15;
  uint64_t v16;
  void *v17;
  char v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  uint64_t v22;
  void *__p[2];
  __int128 v24;
  __int128 v25;
  __int128 v26;

  v13[0] = 0;
  v13[1] = 0;
  v14 = 0;
  std::optional<LteCellInformation>::operator=[abi:ne180100]<LteCellInformation,void>(*(_QWORD *)(a1 + 32) + 128, (uint64_t)v13);
  *(_QWORD *)&v25 = v13;
  std::vector<LteCell>::__destroy_vector::operator()[abi:ne180100]((void ***)&v25);
  v4 = *(int64x2_t **)(a1 + 32);
  if (!v4[9].i8[8]
    || (std::vector<LteCell>::resize(v4 + 8, 0xEEEEEEEEEEEEEEEFLL * ((a2[1] - *a2) >> 2)),
        v5 = *(_QWORD *)(a1 + 32),
        !*(_BYTE *)(v5 + 152)))
  {
    std::__throw_bad_optional_access[abi:ne180100]();
  }
  v6 = *a2;
  v7 = a2[1];
  if (*a2 != v7)
  {
    v8 = *(_WORD **)(v5 + 128);
    do
    {
      v25 = 0u;
      v26 = 0u;
      MEMORY[0x2199FDEAC](&v25, *(unsigned __int16 *)(v6 + 2));
      *(_OWORD *)__p = 0u;
      v24 = 0u;
      MEMORY[0x2199FDEE8](__p, *(unsigned __int16 *)(v6 + 4), &v25);
      LOWORD(v13[0]) = *(_WORD *)v6;
      MCC::MCC();
      MCC::MCC((MCC *)&v16, (const MCC *)__p);
      LOBYTE(v19) = *(_BYTE *)(v6 + 6) + 1;
      *(_QWORD *)((char *)&v19 + 4) = *(_QWORD *)(v6 + 8);
      HIDWORD(v19) = *(_DWORD *)(v6 + 16);
      LOWORD(v20) = *(_WORD *)(v6 + 20);
      *(_QWORD *)((char *)&v20 + 4) = *(_QWORD *)(v6 + 24);
      WORD6(v20) = *(_WORD *)(v6 + 32);
      BYTE14(v20) = 1;
      LODWORD(v21) = *(_DWORD *)(v6 + 36);
      BYTE4(v21) = *(_BYTE *)(v6 + 40);
      DWORD2(v21) = *(_DWORD *)(v6 + 44);
      WORD6(v21) = *(_WORD *)(v6 + 48);
      v22 = 0;
      if (SHIBYTE(v24) < 0)
        operator delete(__p[1]);
      if (SHIBYTE(v26) < 0)
        operator delete(*((void **)&v25 + 1));
      *v8 = v13[0];
      MCC::operator=();
      v9 = v8 + 20;
      MCC::operator=();
      v10 = v19;
      v11 = v20;
      v12 = v21;
      *((_QWORD *)v9 + 10) = v22;
      *((_OWORD *)v9 + 3) = v11;
      *((_OWORD *)v9 + 4) = v12;
      *((_OWORD *)v9 + 2) = v10;
      if (v18 < 0)
        operator delete(v17);
      if (v15 < 0)
        operator delete(v14);
      v6 += 60;
      v8 = v9 + 44;
    }
    while (v6 != v7);
  }
}

void sub_21689C1D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  uint64_t v34;

  if (a16 < 0)
    operator delete(__p);
  if (a34 < 0)
    operator delete(a29);
  if (*(char *)(v34 - 65) < 0)
    operator delete(*(void **)(v34 - 88));
  _Unwind_Resume(exception_object);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BYTE v3[24];

  v2 = *(_QWORD *)(a1 + 32);
  cast_message_type<qmi::ResponseBase const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_21689C278(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_0(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BYTE v3[24];

  v2 = *(_QWORD *)(a1 + 32);
  cast_message_type<qmi::ResponseBase const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_21689C2D4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_1(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BYTE v3[24];

  v2 = *(_QWORD *)(a1 + 32);
  cast_message_type<qmi::ResponseBase const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_21689C330(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BYTE v3[24];

  v2 = *(_QWORD *)(a1 + 32);
  cast_message_type<qmi::ResponseBase const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_21689C38C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_3(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BYTE v3[24];

  v2 = *(_QWORD *)(a1 + 32);
  cast_message_type<qmi::ResponseBase const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_21689C3E8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_4(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BYTE v3[24];

  v2 = *(_QWORD *)(a1 + 32);
  cast_message_type<qmi::ResponseBase const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_21689C444(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_5(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BYTE v3[24];

  v2 = *(_QWORD *)(a1 + 32);
  cast_message_type<qmi::ResponseBase const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_21689C4A0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_6(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BYTE v3[24];

  v2 = *(_QWORD *)(a1 + 32);
  cast_message_type<qmi::ResponseBase const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_21689C4FC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_7(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BYTE v3[24];

  v2 = *(_QWORD *)(a1 + 32);
  cast_message_type<qmi::ResponseBase const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_21689C558(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_8(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BYTE v3[24];

  v2 = *(_QWORD *)(a1 + 32);
  cast_message_type<qmi::ResponseBase const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_21689C5B4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_9(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BYTE v3[24];

  v2 = *(_QWORD *)(a1 + 32);
  cast_message_type<qmi::ResponseBase const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_21689C610(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_10(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BYTE v3[24];

  v2 = *(_QWORD *)(a1 + 32);
  cast_message_type<qmi::ResponseBase const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_21689C66C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_11(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BYTE v3[24];

  v2 = *(_QWORD *)(a1 + 32);
  cast_message_type<qmi::ResponseBase const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_21689C6C8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_12(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BYTE v3[24];

  v2 = *(_QWORD *)(a1 + 32);
  cast_message_type<qmi::ResponseBase const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_21689C724(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_13(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BYTE v3[24];

  v2 = *(_QWORD *)(a1 + 32);
  cast_message_type<qmi::ResponseBase const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_21689C780(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_14(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BYTE v3[24];

  v2 = *(_QWORD *)(a1 + 32);
  cast_message_type<qmi::ResponseBase const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_21689C7DC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_15(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BYTE v3[24];

  v2 = *(_QWORD *)(a1 + 32);
  cast_message_type<qmi::ResponseBase const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_21689C838(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_16(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BYTE v3[24];

  v2 = *(_QWORD *)(a1 + 32);
  cast_message_type<qmi::ResponseBase const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_21689C894(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_17(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BYTE v3[24];

  v2 = *(_QWORD *)(a1 + 32);
  cast_message_type<qmi::ResponseBase const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_21689C8F0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_18(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BYTE v3[24];

  v2 = *(_QWORD *)(a1 + 32);
  cast_message_type<qmi::ResponseBase const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_21689C94C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_19(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BYTE v3[24];

  v2 = *(_QWORD *)(a1 + 32);
  cast_message_type<qmi::ResponseBase const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_21689C9A8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_20(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BYTE v3[24];

  v2 = *(_QWORD *)(a1 + 32);
  cast_message_type<qmi::ResponseBase const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_21689CA04(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_21(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BYTE v3[24];

  v2 = *(_QWORD *)(a1 + 32);
  cast_message_type<qmi::ResponseBase const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_21689CA60(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_22(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BYTE v3[24];

  v2 = *(_QWORD *)(a1 + 32);
  cast_message_type<qmi::ResponseBase const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_21689CABC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_23(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BYTE v3[24];

  v2 = *(_QWORD *)(a1 + 32);
  cast_message_type<qmi::ResponseBase const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_21689CB18(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_24(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BYTE v3[24];

  v2 = *(_QWORD *)(a1 + 32);
  cast_message_type<qmi::ResponseBase const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_21689CB74(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_25(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BYTE v3[24];

  v2 = *(_QWORD *)(a1 + 32);
  cast_message_type<qmi::ResponseBase const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_21689CBD0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_26(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BYTE v3[24];

  v2 = *(_QWORD *)(a1 + 32);
  cast_message_type<qmi::ResponseBase const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_21689CC2C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_27(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BYTE v3[24];

  v2 = *(_QWORD *)(a1 + 32);
  cast_message_type<qmi::ResponseBase const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_21689CC88(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_28(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BYTE v3[24];

  v2 = *(_QWORD *)(a1 + 32);
  cast_message_type<qmi::ResponseBase const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_21689CCE4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_29(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BYTE v3[24];

  v2 = *(_QWORD *)(a1 + 32);
  cast_message_type<qmi::ResponseBase const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_21689CD40(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_30(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BYTE v3[24];

  v2 = *(_QWORD *)(a1 + 32);
  cast_message_type<qmi::ResponseBase const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_21689CD9C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_31(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BYTE v3[24];

  v2 = *(_QWORD *)(a1 + 32);
  cast_message_type<qmi::ResponseBase const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_21689CDF8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_32(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BYTE v3[24];

  v2 = *(_QWORD *)(a1 + 32);
  cast_message_type<qmi::ResponseBase const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_21689CE54(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void CellInfoUpdate::~CellInfoUpdate(CellInfoUpdate *this)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void **v10;

  if (*((_BYTE *)this + 488))
  {
    v2 = (void *)*((_QWORD *)this + 58);
    if (v2)
    {
      *((_QWORD *)this + 59) = v2;
      operator delete(v2);
    }
  }
  if (*((_BYTE *)this + 456))
  {
    v3 = (void *)*((_QWORD *)this + 54);
    if (v3)
    {
      *((_QWORD *)this + 55) = v3;
      operator delete(v3);
    }
  }
  if (*((_BYTE *)this + 424))
  {
    v4 = (void *)*((_QWORD *)this + 50);
    if (v4)
    {
      *((_QWORD *)this + 51) = v4;
      operator delete(v4);
    }
  }
  if (*((_BYTE *)this + 392))
  {
    v5 = (void *)*((_QWORD *)this + 46);
    if (v5)
    {
      *((_QWORD *)this + 47) = v5;
      operator delete(v5);
    }
  }
  if (*((_BYTE *)this + 352))
  {
    v6 = (void *)*((_QWORD *)this + 41);
    if (v6)
    {
      *((_QWORD *)this + 42) = v6;
      operator delete(v6);
    }
  }
  if (*((_BYTE *)this + 312))
  {
    v7 = (void *)*((_QWORD *)this + 36);
    if (v7)
    {
      *((_QWORD *)this + 37) = v7;
      operator delete(v7);
    }
  }
  if (*((_BYTE *)this + 280))
  {
    v8 = (void *)*((_QWORD *)this + 32);
    if (v8)
    {
      *((_QWORD *)this + 33) = v8;
      operator delete(v8);
    }
  }
  if (*((_BYTE *)this + 248))
  {
    v9 = (void *)*((_QWORD *)this + 28);
    if (v9)
    {
      *((_QWORD *)this + 29) = v9;
      operator delete(v9);
    }
  }
  if (*((_BYTE *)this + 216))
  {
    v10 = (void **)((char *)this + 192);
    std::vector<NrCell>::__destroy_vector::operator()[abi:ne180100](&v10);
  }
  if (*((_BYTE *)this + 184))
  {
    v10 = (void **)((char *)this + 160);
    std::vector<UmtsCell>::__destroy_vector::operator()[abi:ne180100](&v10);
  }
  if (*((_BYTE *)this + 152))
  {
    v10 = (void **)((char *)this + 128);
    std::vector<LteCell>::__destroy_vector::operator()[abi:ne180100](&v10);
  }
  if (*((_BYTE *)this + 120))
  {
    v10 = (void **)((char *)this + 96);
    std::vector<GsmCell>::__destroy_vector::operator()[abi:ne180100](&v10);
  }
  if (*((_BYTE *)this + 88))
  {
    v10 = (void **)((char *)this + 64);
    std::vector<UmtsCell>::__destroy_vector::operator()[abi:ne180100](&v10);
  }
  if (*((_BYTE *)this + 56))
  {
    v10 = (void **)((char *)this + 32);
    std::vector<CdmaEvdoCell>::__destroy_vector::operator()[abi:ne180100](&v10);
  }
  if (*((_BYTE *)this + 24))
  {
    v10 = (void **)this;
    std::vector<Cdma1xCell>::__destroy_vector::operator()[abi:ne180100](&v10);
  }
}

void cast_message_type<qmi::ResponseBase const&>::cast(uint64_t a1@<X0>, qmi::ResponseBase *a2@<X8>)
{
  if (*(_DWORD *)(a1 + 40) != 1 || *(_WORD *)(a1 + 44) == 3)
  {
    QMIServiceMsg::serialize((QMIServiceMsg *)a1);
    qmi::ResponseBase::ResponseBase(a2, 0);
  }
  else
  {
    QMIServiceMsg::getNewError((QMIServiceMsg *)a1);
    qmi::MessageBase::MessageBase();
  }
}

void sub_21689D080(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

qmi::MessageBase *qmi::RespInd<(unsigned short)21846,nas::GetCellInfo::RespIndTLVList>::RespInd(qmi::MessageBase *this, _QWORD *a2)
{
  uint64_t v3;
  unint64_t *v4;
  unint64_t v5;

  *(_QWORD *)this = *a2;
  v3 = a2[2];
  *((_QWORD *)this + 1) = a2[1];
  *((_QWORD *)this + 2) = v3;
  if (v3)
  {
    v4 = (unint64_t *)(v3 + 8);
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }
  qmi::MessageBase::validateMsgId(this);
  return this;
}

void sub_21689D0F0(_Unwind_Exception *a1)
{
  qmi::MessageBase *v1;

  qmi::MessageBase::~MessageBase(v1);
  _Unwind_Resume(a1);
}

void std::vector<LteCell>::resize(int64x2_t *a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  int64x2_t v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t v27;
  char *v28;
  char *v29;
  int64x2_t v30;
  char *v31;
  int64x2_t *v32;

  v4 = a1->i64[0];
  v5 = a1->i64[1];
  v6 = (v5 - a1->i64[0]) >> 7;
  if (a2 <= v6)
  {
    if (a2 < v6)
    {
      v25 = v4 + (a2 << 7);
      while (v5 != v25)
      {
        v5 -= 128;
        std::__destroy_at[abi:ne180100]<NrCell,0>(v5);
      }
      a1->i64[1] = v25;
    }
  }
  else
  {
    v7 = a1[1].i64[0];
    if (a2 - v6 <= (v7 - v5) >> 7)
    {
      v26 = v5 + ((a2 - v6) << 7);
      v27 = (a2 << 7) - (v6 << 7);
      do
      {
        _ZNSt3__112construct_atB8ne180100I7LteCellJEPS1_EEPT_S4_DpOT0_(v5);
        v5 += 128;
        v27 -= 128;
      }
      while (v27);
      a1->i64[1] = v26;
    }
    else
    {
      if (a2 >> 57)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v8 = v7 - v4;
      v9 = v8 >> 6;
      if (v8 >> 6 <= a2)
        v9 = a2;
      if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFF80)
        v10 = 0x1FFFFFFFFFFFFFFLL;
      else
        v10 = v9;
      v32 = a1 + 1;
      v11 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<LteCell>>(v10);
      v12 = (uint64_t)&v11[128 * v6];
      v29 = v11;
      v30.i64[0] = v12;
      v30.i64[1] = v12;
      v31 = &v11[128 * v13];
      v14 = &v11[128 * a2];
      v15 = (a2 << 7) - (v6 << 7);
      do
      {
        _ZNSt3__112construct_atB8ne180100I7LteCellJEPS1_EEPT_S4_DpOT0_(v12);
        v12 += 128;
        v15 -= 128;
      }
      while (v15);
      v30.i64[1] = (uint64_t)v14;
      v17 = a1->i64[0];
      v16 = a1->u64[1];
      v18 = v30.i64[0];
      if (v16 == a1->i64[0])
      {
        v24 = vdupq_n_s64(v16);
      }
      else
      {
        v19 = 0;
        do
        {
          *(_WORD *)(v18 + v19 - 128) = *(_WORD *)(v16 + v19 - 128);
          MCC::MCC();
          MCC::MCC((MCC *)(v18 + v19 - 88), (const MCC *)(v16 + v19 - 88));
          v20 = v18 + v19;
          v21 = *(_OWORD *)(v16 + v19 - 56);
          v22 = *(_OWORD *)(v16 + v19 - 40);
          v23 = *(_OWORD *)(v16 + v19 - 24);
          *(_QWORD *)(v20 - 8) = *(_QWORD *)(v16 + v19 - 8);
          *(_OWORD *)(v20 - 24) = v23;
          *(_OWORD *)(v20 - 40) = v22;
          *(_OWORD *)(v20 - 56) = v21;
          v19 -= 128;
        }
        while (v16 + v19 != v17);
        v24 = *a1;
        v14 = (char *)v30.i64[1];
        v18 += v19;
      }
      a1->i64[0] = v18;
      a1->i64[1] = (uint64_t)v14;
      v30 = v24;
      v28 = (char *)a1[1].i64[0];
      a1[1].i64[0] = (uint64_t)v31;
      v31 = v28;
      v29 = (char *)v24.i64[0];
      std::__split_buffer<LteCell>::~__split_buffer((uint64_t)&v29);
    }
  }
}

uint64_t std::__split_buffer<LteCell>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 128;
    std::__destroy_at[abi:ne180100]<NrCell,0>(i - 128);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void qmi::MessageBase::applyTlv<nas::tlv::LteCellInformation_V4,void({block_pointer}&)(nas::tlv::LteCellInformation_V4 const&)>(qmi::MessageBase *a1, uint64_t a2)
{
  unsigned __int8 *TlvValue;
  int v5;
  unsigned __int8 *v6;
  int v7;
  unsigned __int8 *v8;
  void *__p;
  void *v10;
  uint64_t v11;
  unsigned __int8 *v12;

  TlvValue = (unsigned __int8 *)qmi::MessageBase::findTlvValue(a1);
  if (TlvValue)
  {
    v6 = TlvValue;
    v7 = v5;
    v11 = 0;
    v12 = TlvValue;
    __p = 0;
    v10 = 0;
    tlv::parseV<nas::tlv::LteCellInformation_V4>(&v12, v5, (uint64_t *)&__p);
    v8 = v12;
    if (v12)
      (*(void (**)(void))(*(_QWORD *)a2 + 16))();
    if (__p)
    {
      v10 = __p;
      operator delete(__p);
    }
    if (!v8)
      ((void (*)(_QWORD, uint64_t, unsigned __int8 *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, 211, v6, v7);
  }
}

void sub_21689D440(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

unint64_t tlv::parseV<nas::tlv::LteCellInformation_V4>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  unint64_t result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = nas::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = (unsigned __int8 *)result;
  return result;
}

void sub_21689D498(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x21689D48CLL);
}

void sub_21689D4A8(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

unint64_t nas::tlv::parseField(unsigned __int8 *a1, const unsigned __int8 *a2, uint64_t *a3)
{
  unint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t result;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  v7 = *a1;
  v6 = (unint64_t)(a1 + 1);
  std::vector<nas::tlv::LteCell_V4>::resize((uint64_t)a3, v7);
  v8 = *a3;
  v9 = a3[1];
  while (1)
  {
    result = v6;
    if (v8 == v9)
      break;
    v6 = nas::tlv::parseField(v6, a2, v8);
    v8 += 60;
  }
  return result;
}

{
  unint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t result;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  v7 = *a1;
  v6 = (unint64_t)(a1 + 1);
  std::vector<nas::tlv::GsmCell>::resize((uint64_t)a3, v7);
  v8 = *a3;
  v9 = a3[1];
  while (1)
  {
    result = v6;
    if (v8 == v9)
      break;
    v6 = nas::tlv::parseField(v6, a2, v8);
    v8 += 24;
  }
  return result;
}

{
  unint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t result;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  v7 = *a1;
  v6 = (unint64_t)(a1 + 1);
  std::vector<nas::tlv::UmtsCell>::resize((uint64_t)a3, v7);
  v8 = *a3;
  v9 = a3[1];
  while (1)
  {
    result = v6;
    if (v8 == v9)
      break;
    v6 = nas::tlv::parseField(v6, a2, v8);
    v8 += 28;
  }
  return result;
}

{
  unint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t result;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  v7 = *a1;
  v6 = (unint64_t)(a1 + 1);
  std::vector<nas::tlv::LteCell_V3>::resize((uint64_t)a3, v7);
  v8 = *a3;
  v9 = a3[1];
  while (1)
  {
    result = v6;
    if (v8 == v9)
      break;
    v6 = nas::tlv::parseField(v6, a2, v8);
    v8 += 36;
  }
  return result;
}

{
  unint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t result;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  v7 = *a1;
  v6 = (unint64_t)(a1 + 1);
  std::vector<nas::tlv::NrCell_V2>::resize((uint64_t)a3, v7);
  v8 = *a3;
  v9 = a3[1];
  while (1)
  {
    result = v6;
    if (v8 == v9)
      break;
    v6 = nas::tlv::parseField(v6, a2, v8);
    v8 += 48;
  }
  return result;
}

{
  unint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t result;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  v7 = *a1;
  v6 = (unint64_t)(a1 + 1);
  std::vector<nas::tlv::NrCell_V3>::resize((uint64_t)a3, v7);
  v8 = *a3;
  v9 = a3[1];
  while (1)
  {
    result = v6;
    if (v8 == v9)
      break;
    v6 = nas::tlv::parseField(v6, a2, v8);
    v8 += 72;
  }
  return result;
}

{
  unint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t result;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  v7 = *a1;
  v6 = (unint64_t)(a1 + 1);
  std::vector<nas::tlv::Cdma1xCell>::resize((uint64_t)a3, v7);
  v8 = *a3;
  v9 = a3[1];
  while (1)
  {
    result = v6;
    if (v8 == v9)
      break;
    v6 = nas::tlv::parseField(v6, a2, v8);
    v8 += 32;
  }
  return result;
}

{
  unint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t result;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  v7 = *a1;
  v6 = (unint64_t)(a1 + 1);
  std::vector<nas::tlv::LteCell_V3>::resize((uint64_t)a3, v7);
  v8 = *a3;
  v9 = a3[1];
  while (1)
  {
    result = v6;
    if (v8 == v9)
      break;
    v6 = nas::tlv::parseField(v6, a2, v8);
    v8 += 36;
  }
  return result;
}

{
  unint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t result;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  v7 = *a1;
  v6 = (unint64_t)(a1 + 1);
  std::vector<wds::tlv::Ipv4AddrInfo>::resize((uint64_t)a3, v7);
  v8 = *a3;
  v9 = a3[1];
  while (1)
  {
    result = v6;
    if (v8 == v9)
      break;
    v6 = nas::tlv::parseField(v6, a2, v8);
    v8 += 8;
  }
  return result;
}

{
  unint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t result;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  v7 = *a1;
  v6 = (unint64_t)(a1 + 1);
  std::vector<nas::tlv::EMBMSSignalQualityAndTMGIInfo>::resize(a3, v7);
  v8 = *a3;
  v9 = a3[1];
  while (1)
  {
    result = v6;
    if (v8 == v9)
      break;
    v6 = nas::tlv::parseField(v6, a2, v8);
    v8 += 40;
  }
  return result;
}

{
  unint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  v7 = *a1;
  v6 = (unint64_t)(a1 + 1);
  std::vector<nas::tlv::BBFreqItem>::resize((uint64_t)a3, v7);
  v9 = *a3;
  v8 = a3[1];
  while (v9 != v8)
  {
    tlv::throwIfNotEnoughBytes(v6, a2, 8uLL);
    *(_QWORD *)v9 = *(_QWORD *)v6;
    tlv::throwIfNotEnoughBytes(v6 + 8, a2, 4uLL);
    *(_DWORD *)(v9 + 8) = *(_DWORD *)(v6 + 8);
    v6 += 12;
    v9 += 16;
  }
  return v6;
}

void std::vector<nas::tlv::LteCell_V4>::__append(void **a1, unint64_t a2)
{
  uint64_t v4;
  _BYTE *v5;
  _BYTE *v6;
  char *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  size_t v13;
  char *v14;
  char *v15;
  size_t v16;
  char *v17;
  char *v18;
  char *v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (0xEEEEEEEEEEEEEEEFLL * ((v6 - v7) >> 2) >= a2)
  {
    if (a2)
    {
      v13 = 60 * ((60 * a2 - 60) / 0x3C) + 60;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = 0xEEEEEEEEEEEEEEEFLL * ((v7 - (_BYTE *)*a1) >> 2);
    v9 = v8 + a2;
    if (v8 + a2 > 0x444444444444444)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = 0xEEEEEEEEEEEEEEEFLL * ((v5 - (_BYTE *)*a1) >> 2);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x222222222222222)
      v11 = 0x444444444444444;
    else
      v11 = v9;
    if (v11)
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<nas::tlv::LteCell_V4>>(v4, v11);
    else
      v12 = 0;
    v14 = &v12[60 * v8];
    v15 = &v12[60 * v11];
    v16 = 60 * ((60 * a2 - 60) / 0x3C) + 60;
    bzero(v14, v16);
    v17 = &v14[v16];
    v19 = (char *)*a1;
    v18 = (char *)a1[1];
    if (v18 != *a1)
    {
      do
      {
        v20 = *(_OWORD *)(v18 - 60);
        v21 = *(_OWORD *)(v18 - 44);
        v22 = *(_OWORD *)(v18 - 28);
        *((_OWORD *)v14 - 1) = *((_OWORD *)v18 - 1);
        *(_OWORD *)(v14 - 28) = v22;
        *(_OWORD *)(v14 - 44) = v21;
        *(_OWORD *)(v14 - 60) = v20;
        v14 -= 60;
        v18 -= 60;
      }
      while (v18 != v19);
      v18 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v17;
    a1[2] = v15;
    if (v18)
      operator delete(v18);
  }
}

void std::vector<nas::tlv::LteCell_V4>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;

  v2 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 2);
  v3 = a2 >= v2;
  v4 = a2 - v2;
  if (v4 != 0 && v3)
  {
    std::vector<nas::tlv::LteCell_V4>::__append((void **)a1, v4);
  }
  else if (!v3)
  {
    *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 60 * a2;
  }
}

void qmi::MessageBase::applyTlv<nas::tlv::NrCellInformation_V3,void({block_pointer}&)(nas::tlv::NrCellInformation_V3 const&)>(qmi::MessageBase *a1, uint64_t a2)
{
  unsigned __int8 *TlvValue;
  int v5;
  unsigned __int8 *v6;
  int v7;
  unsigned __int8 *v8;
  void *__p;
  void *v10;
  uint64_t v11;
  unsigned __int8 *v12;

  TlvValue = (unsigned __int8 *)qmi::MessageBase::findTlvValue(a1);
  if (TlvValue)
  {
    v6 = TlvValue;
    v7 = v5;
    v11 = 0;
    v12 = TlvValue;
    __p = 0;
    v10 = 0;
    tlv::parseV<nas::tlv::NrCellInformation_V3>(&v12, v5, (uint64_t *)&__p);
    v8 = v12;
    if (v12)
      (*(void (**)(void))(*(_QWORD *)a2 + 16))();
    if (__p)
    {
      v10 = __p;
      operator delete(__p);
    }
    if (!v8)
      ((void (*)(_QWORD, uint64_t, unsigned __int8 *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, 228, v6, v7);
  }
}

void sub_21689D7BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t QMICellMonitorCommandDriver::processCommonCellInformation_sync<nas::GetCellInfo::RespInd>(qmi::MessageBase *a1, uint64_t a2)
{
  uint64_t v4;
  unsigned __int8 *TlvValue;
  int v6;
  unsigned __int8 *v7;
  int v8;
  unsigned __int8 *v9;
  unsigned __int8 *v10;
  int v11;
  unsigned __int8 *v12;
  int v13;
  unsigned __int8 *v14;
  unsigned __int8 *v15;
  int v16;
  unsigned __int8 *v17;
  int v18;
  unsigned __int8 *v19;
  unsigned __int8 *v20;
  int v21;
  unsigned __int8 *v22;
  int v23;
  unsigned __int8 *v24;
  unsigned __int8 *v25;
  int v26;
  unsigned __int8 *v27;
  int v28;
  unsigned __int8 *v29;
  unsigned __int8 *v30;
  int v31;
  unsigned __int8 *v32;
  int v33;
  unsigned __int8 *v34;
  unsigned __int8 *v35;
  int v36;
  unsigned __int8 *v37;
  int v38;
  unsigned __int8 *v39;
  unsigned __int8 *v40;
  int v41;
  unsigned __int8 *v42;
  int v43;
  unsigned __int8 *v44;
  unsigned __int8 *v45;
  int v46;
  unsigned __int8 *v47;
  int v48;
  unsigned __int8 *v49;
  unsigned __int8 *v50;
  int v51;
  unsigned __int8 *v52;
  int v53;
  unsigned __int8 *v54;
  unsigned __int8 *v55;
  int v56;
  unsigned __int8 *v57;
  int v58;
  unsigned __int8 *v59;
  unsigned __int8 *v60;
  int v61;
  unsigned __int8 *v62;
  int v63;
  unsigned __int8 *v64;
  unsigned __int8 *v65;
  int v66;
  unsigned __int8 *v67;
  int v68;
  __n128 v69;
  unsigned __int8 *v70;
  unsigned __int8 *v71;
  int v72;
  unsigned __int8 *v73;
  int v74;
  unsigned __int8 *v75;
  uint64_t result;
  int v77;
  uint64_t v78;
  int v79;
  _QWORD v80[5];
  _QWORD v81[5];
  _QWORD v82[2];
  double (*v83)(uint64_t, uint64_t);
  void *v84;
  uint64_t v85;
  _QWORD v86[2];
  void (*v87)(uint64_t, uint64_t *);
  void *v88;
  uint64_t v89;
  _QWORD v90[2];
  void (*v91)(uint64_t, uint64_t *);
  void *v92;
  uint64_t v93;
  _QWORD v94[2];
  void (*v95)(uint64_t, uint64_t *);
  void *v96;
  uint64_t v97;
  _QWORD v98[2];
  void (*v99)(uint64_t, unsigned __int16 **);
  void *v100;
  uint64_t v101;
  _QWORD v102[2];
  void (*v103)(uint64_t, uint64_t **);
  void *v104;
  uint64_t v105;
  _QWORD v106[2];
  void (*v107)(uint64_t, int **);
  void *v108;
  uint64_t v109;
  _QWORD v110[2];
  void (*v111)(uint64_t, uint64_t *);
  void *v112;
  uint64_t v113;
  _QWORD v114[2];
  void (*v115)(uint64_t, uint64_t *);
  void *v116;
  uint64_t v117;
  _QWORD v118[2];
  void (*v119)(uint64_t, uint64_t *);
  void *v120;
  uint64_t v121;
  _QWORD v122[2];
  void (*v123)(uint64_t, uint64_t *);
  void *v124;
  uint64_t v125;
  _QWORD v126[2];
  void (*v127)(uint64_t, uint64_t *);
  void *v128;
  uint64_t v129;
  __int128 v130;
  __int128 v131;
  unsigned __int8 *v132;

  v4 = MEMORY[0x24BDAC760];
  v126[0] = MEMORY[0x24BDAC760];
  v126[1] = 0x40000000;
  v127 = ___ZN27QMICellMonitorCommandDriver33processCommonCellInformation_syncIN3nas11GetCellInfo7RespIndEEEvRKT_R14CellInfoUpdate_block_invoke;
  v128 = &__block_descriptor_tmp_51_3;
  v129 = a2;
  TlvValue = (unsigned __int8 *)qmi::MessageBase::findTlvValue(a1);
  if (TlvValue)
  {
    v7 = TlvValue;
    v8 = v6;
    v132 = TlvValue;
    v130 = 0uLL;
    *(_QWORD *)&v131 = 0;
    tlv::parseV<nas::tlv::Cdma1xCellInformation>(&v132, v6, (uint64_t *)&v130);
    v9 = v132;
    if (v132)
      v127((uint64_t)v126, (uint64_t *)&v130);
    if ((_QWORD)v130)
    {
      *((_QWORD *)&v130 + 1) = v130;
      operator delete((void *)v130);
    }
    if (!v9)
      ((void (*)(_QWORD, uint64_t, unsigned __int8 *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, 161, v7, v8);
  }
  v122[0] = v4;
  v122[1] = 0x40000000;
  v123 = ___ZN27QMICellMonitorCommandDriver33processCommonCellInformation_syncIN3nas11GetCellInfo7RespIndEEEvRKT_R14CellInfoUpdate_block_invoke_2;
  v124 = &__block_descriptor_tmp_52_1;
  v125 = a2;
  v10 = (unsigned __int8 *)qmi::MessageBase::findTlvValue(a1);
  if (v10)
  {
    v12 = v10;
    v13 = v11;
    v132 = v10;
    v130 = 0uLL;
    *(_QWORD *)&v131 = 0;
    tlv::parseV<nas::tlv::CdmaEvdoCellInformation>(&v132, v11, (uint64_t *)&v130);
    v14 = v132;
    if (v132)
      v123((uint64_t)v122, (uint64_t *)&v130);
    if ((_QWORD)v130)
    {
      *((_QWORD *)&v130 + 1) = v130;
      operator delete((void *)v130);
    }
    if (!v14)
      ((void (*)(_QWORD, uint64_t, unsigned __int8 *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, 162, v12, v13);
  }
  v118[0] = v4;
  v118[1] = 0x40000000;
  v119 = ___ZN27QMICellMonitorCommandDriver33processCommonCellInformation_syncIN3nas11GetCellInfo7RespIndEEEvRKT_R14CellInfoUpdate_block_invoke_3;
  v120 = &__block_descriptor_tmp_53_1;
  v121 = a2;
  v15 = (unsigned __int8 *)qmi::MessageBase::findTlvValue(a1);
  if (v15)
  {
    v17 = v15;
    v18 = v16;
    v132 = v15;
    v130 = 0uLL;
    *(_QWORD *)&v131 = 0;
    tlv::parseV<nas::tlv::UmtsCellInformation>(&v132, v16, (uint64_t *)&v130);
    v19 = v132;
    if (v132)
      v119((uint64_t)v118, (uint64_t *)&v130);
    if ((_QWORD)v130)
    {
      *((_QWORD *)&v130 + 1) = v130;
      operator delete((void *)v130);
    }
    if (!v19)
      ((void (*)(_QWORD, uint64_t, unsigned __int8 *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, 183, v17, v18);
  }
  v114[0] = v4;
  v114[1] = 0x40000000;
  v115 = ___ZN27QMICellMonitorCommandDriver33processCommonCellInformation_syncIN3nas11GetCellInfo7RespIndEEEvRKT_R14CellInfoUpdate_block_invoke_4;
  v116 = &__block_descriptor_tmp_54_1;
  v117 = a2;
  v20 = (unsigned __int8 *)qmi::MessageBase::findTlvValue(a1);
  if (v20)
  {
    v22 = v20;
    v23 = v21;
    v132 = v20;
    v130 = 0uLL;
    *(_QWORD *)&v131 = 0;
    tlv::parseV<nas::tlv::GsmCellInformation>(&v132, v21, (uint64_t *)&v130);
    v24 = v132;
    if (v132)
      v115((uint64_t)v114, (uint64_t *)&v130);
    if ((_QWORD)v130)
    {
      *((_QWORD *)&v130 + 1) = v130;
      operator delete((void *)v130);
    }
    if (!v24)
      ((void (*)(_QWORD, uint64_t, unsigned __int8 *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, 184, v22, v23);
  }
  v110[0] = v4;
  v110[1] = 0x40000000;
  v111 = ___ZN27QMICellMonitorCommandDriver33processCommonCellInformation_syncIN3nas11GetCellInfo7RespIndEEEvRKT_R14CellInfoUpdate_block_invoke_5;
  v112 = &__block_descriptor_tmp_55_2;
  v113 = a2;
  v25 = (unsigned __int8 *)qmi::MessageBase::findTlvValue(a1);
  if (v25)
  {
    v27 = v25;
    v28 = v26;
    v132 = v25;
    v130 = 0uLL;
    *(_QWORD *)&v131 = 0;
    tlv::parseV<nas::tlv::TDSCDMACellInformation>(&v132, v26, (uint64_t *)&v130);
    v29 = v132;
    if (v132)
      v111((uint64_t)v110, (uint64_t *)&v130);
    if ((_QWORD)v130)
    {
      *((_QWORD *)&v130 + 1) = v130;
      operator delete((void *)v130);
    }
    if (!v29)
      ((void (*)(_QWORD, uint64_t, unsigned __int8 *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, 208, v27, v28);
  }
  v106[0] = v4;
  v106[1] = 0x40000000;
  v107 = ___ZN27QMICellMonitorCommandDriver33processCommonCellInformation_syncIN3nas11GetCellInfo7RespIndEEEvRKT_R14CellInfoUpdate_block_invoke_6;
  v108 = &__block_descriptor_tmp_56_2;
  v109 = a2;
  v30 = (unsigned __int8 *)qmi::MessageBase::findTlvValue(a1);
  if (v30)
  {
    v32 = v30;
    v33 = v31;
    v132 = v30;
    v130 = 0uLL;
    *(_QWORD *)&v131 = 0;
    tlv::parseV<nas::tlv::GsmNeighborInformation>(&v132, v31, &v130);
    v34 = v132;
    if (v132)
      v107((uint64_t)v106, (int **)&v130);
    if ((_QWORD)v130)
    {
      *((_QWORD *)&v130 + 1) = v130;
      operator delete((void *)v130);
    }
    if (!v34)
      ((void (*)(_QWORD, uint64_t, unsigned __int8 *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, 190, v32, v33);
  }
  v102[0] = v4;
  v102[1] = 0x40000000;
  v103 = ___ZN27QMICellMonitorCommandDriver33processCommonCellInformation_syncIN3nas11GetCellInfo7RespIndEEEvRKT_R14CellInfoUpdate_block_invoke_7;
  v104 = &__block_descriptor_tmp_57_2;
  v105 = a2;
  v35 = (unsigned __int8 *)qmi::MessageBase::findTlvValue(a1);
  if (v35)
  {
    v37 = v35;
    v38 = v36;
    v132 = v35;
    v130 = 0uLL;
    *(_QWORD *)&v131 = 0;
    tlv::parseV<nas::tlv::UmtsNeighborInformation>(&v132, v36, &v130);
    v39 = v132;
    if (v132)
      v103((uint64_t)v102, (uint64_t **)&v130);
    if ((_QWORD)v130)
    {
      *((_QWORD *)&v130 + 1) = v130;
      operator delete((void *)v130);
    }
    if (!v39)
      ((void (*)(_QWORD, uint64_t, unsigned __int8 *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, 189, v37, v38);
  }
  v98[0] = v4;
  v98[1] = 0x40000000;
  v99 = ___ZN27QMICellMonitorCommandDriver33processCommonCellInformation_syncIN3nas11GetCellInfo7RespIndEEEvRKT_R14CellInfoUpdate_block_invoke_8;
  v100 = &__block_descriptor_tmp_58_1;
  v101 = a2;
  v40 = (unsigned __int8 *)qmi::MessageBase::findTlvValue(a1);
  if (v40)
  {
    v42 = v40;
    v43 = v41;
    v132 = v40;
    v130 = 0uLL;
    *(_QWORD *)&v131 = 0;
    tlv::parseV<nas::tlv::TDSCDMANeighborInformation>(&v132, v41, (uint64_t *)&v130);
    v44 = v132;
    if (v132)
      v99((uint64_t)v98, (unsigned __int16 **)&v130);
    if ((_QWORD)v130)
    {
      *((_QWORD *)&v130 + 1) = v130;
      operator delete((void *)v130);
    }
    if (!v44)
      ((void (*)(_QWORD, uint64_t, unsigned __int8 *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, 209, v42, v43);
  }
  v94[0] = v4;
  v94[1] = 0x40000000;
  v95 = ___ZN27QMICellMonitorCommandDriver33processCommonCellInformation_syncIN3nas11GetCellInfo7RespIndEEEvRKT_R14CellInfoUpdate_block_invoke_9;
  v96 = &__block_descriptor_tmp_59_2;
  v97 = a2;
  v45 = (unsigned __int8 *)qmi::MessageBase::findTlvValue(a1);
  if (v45)
  {
    v47 = v45;
    v48 = v46;
    v132 = v45;
    v130 = 0uLL;
    *(_QWORD *)&v131 = 0;
    tlv::parseV<nas::tlv::LteNeighborInformation_V3>(&v132, v46, (uint64_t *)&v130);
    v49 = v132;
    if (v132)
      v95((uint64_t)v94, (uint64_t *)&v130);
    v45 = (unsigned __int8 *)v130;
    if ((_QWORD)v130)
    {
      *((_QWORD *)&v130 + 1) = v130;
      operator delete((void *)v130);
    }
    if (!v49)
      v45 = (unsigned __int8 *)((uint64_t (*)(_QWORD, uint64_t, unsigned __int8 *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, 212, v47, v48);
  }
  if (capabilities::ct::supportsEnhanced5GCellularHarvesting((capabilities::ct *)v45))
  {
    v90[0] = v4;
    v90[1] = 0x40000000;
    v91 = ___ZN27QMICellMonitorCommandDriver33processCommonCellInformation_syncIN3nas11GetCellInfo7RespIndEEEvRKT_R14CellInfoUpdate_block_invoke_10;
    v92 = &__block_descriptor_tmp_60_1;
    v93 = a2;
    v50 = (unsigned __int8 *)qmi::MessageBase::findTlvValue(a1);
    if (v50)
    {
      v52 = v50;
      v53 = v51;
      v132 = v50;
      v130 = 0uLL;
      *(_QWORD *)&v131 = 0;
      tlv::parseV<nas::tlv::NrNeighborInformation_V3>(&v132, v51, (uint64_t *)&v130);
      v54 = v132;
      if (v132)
        v91((uint64_t)v90, (uint64_t *)&v130);
      if ((_QWORD)v130)
      {
        *((_QWORD *)&v130 + 1) = v130;
        operator delete((void *)v130);
      }
      if (!v54)
        ((void (*)(_QWORD, uint64_t, unsigned __int8 *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, 229, v52, v53);
    }
  }
  else
  {
    v86[0] = v4;
    v86[1] = 0x40000000;
    v87 = ___ZN27QMICellMonitorCommandDriver33processCommonCellInformation_syncIN3nas11GetCellInfo7RespIndEEEvRKT_R14CellInfoUpdate_block_invoke_11;
    v88 = &__block_descriptor_tmp_61_2;
    v89 = a2;
    v55 = (unsigned __int8 *)qmi::MessageBase::findTlvValue(a1);
    if (v55)
    {
      v57 = v55;
      v58 = v56;
      v132 = v55;
      v130 = 0uLL;
      *(_QWORD *)&v131 = 0;
      tlv::parseV<nas::tlv::NrNeighborInformation_V2>(&v132, v56, (uint64_t *)&v130);
      v59 = v132;
      if (v132)
        v87((uint64_t)v86, (uint64_t *)&v130);
      if ((_QWORD)v130)
      {
        *((_QWORD *)&v130 + 1) = v130;
        operator delete((void *)v130);
      }
      if (!v59)
        ((void (*)(_QWORD, uint64_t, unsigned __int8 *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, 227, v57, v58);
    }
  }
  v82[0] = v4;
  v82[1] = 0x40000000;
  v83 = ___ZN27QMICellMonitorCommandDriver33processCommonCellInformation_syncIN3nas11GetCellInfo7RespIndEEEvRKT_R14CellInfoUpdate_block_invoke_12;
  v84 = &__block_descriptor_tmp_62_2;
  v85 = a2;
  v60 = (unsigned __int8 *)qmi::MessageBase::findTlvValue(a1);
  if (v60)
  {
    v62 = v60;
    v63 = v61;
    v132 = v60;
    v130 = 0u;
    v131 = 0u;
    tlv::parseV<nas::tlv::Cdma1xNeighborInformation>((unint64_t *)&v132, v61, &v130);
    v64 = v132;
    if (v132)
      v83((uint64_t)v82, (uint64_t)&v130);
    if (*((_QWORD *)&v130 + 1))
    {
      *(_QWORD *)&v131 = *((_QWORD *)&v130 + 1);
      operator delete(*((void **)&v130 + 1));
    }
    if (!v64)
      ((void (*)(_QWORD, uint64_t, unsigned __int8 *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, 192, v62, v63);
  }
  v81[0] = v4;
  v81[1] = 0x40000000;
  v81[2] = ___ZN27QMICellMonitorCommandDriver33processCommonCellInformation_syncIN3nas11GetCellInfo7RespIndEEEvRKT_R14CellInfoUpdate_block_invoke_13;
  v81[3] = &__block_descriptor_tmp_63_0;
  v81[4] = a2;
  v65 = (unsigned __int8 *)qmi::MessageBase::findTlvValue(a1);
  if (v65)
  {
    v67 = v65;
    v68 = v66;
    v132 = v65;
    v130 = 0u;
    v131 = 0u;
    tlv::parseV<nas::tlv::CdmaEvdoNeighborInformation>((unint64_t *)&v132, v66, &v130);
    v70 = v132;
    if (v132)
      v69.n128_f64[0] = ___ZN27QMICellMonitorCommandDriver33processCommonCellInformation_syncIN3nas11GetCellInfo7RespIndEEEvRKT_R14CellInfoUpdate_block_invoke_13((uint64_t)v81, (uint64_t)&v130);
    if (*((_QWORD *)&v130 + 1))
    {
      *(_QWORD *)&v131 = *((_QWORD *)&v130 + 1);
      operator delete(*((void **)&v130 + 1));
    }
    if (!v70)
      ((void (*)(_QWORD, uint64_t, unsigned __int8 *, _QWORD, __n128))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, 193, v67, v68, v69);
  }
  v80[0] = v4;
  v80[1] = 0x40000000;
  v80[2] = ___ZN27QMICellMonitorCommandDriver33processCommonCellInformation_syncIN3nas11GetCellInfo7RespIndEEEvRKT_R14CellInfoUpdate_block_invoke_14;
  v80[3] = &__block_descriptor_tmp_64_2;
  v80[4] = a2;
  v71 = (unsigned __int8 *)qmi::MessageBase::findTlvValue(a1);
  if (v71)
  {
    v73 = v71;
    v74 = v72;
    v132 = v71;
    v130 = 0uLL;
    *(_QWORD *)&v131 = 0;
    tlv::parseV<nas::tlv::MccInformation>((unint64_t *)&v132, v72, (uint64_t)&v130);
    v75 = v132;
    if (v132)
      ___ZN27QMICellMonitorCommandDriver33processCommonCellInformation_syncIN3nas11GetCellInfo7RespIndEEEvRKT_R14CellInfoUpdate_block_invoke_14((uint64_t)v80, (uint64_t)&v130);
    if ((_QWORD)v130)
    {
      *((_QWORD *)&v130 + 1) = v130;
      operator delete((void *)v130);
    }
    if (!v75)
      ((void (*)(_QWORD, uint64_t, unsigned __int8 *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, 167, v73, v74);
  }
  result = qmi::MessageBase::findTlvValue(a1);
  if (result)
  {
    v78 = result;
    v79 = v77;
    *(_QWORD *)&v130 = result;
    result = tlv::parseV<nas::tlv::CsgIndicator>((unint64_t *)&v130, v77);
    if ((_QWORD)v130)
      *(_WORD *)(a2 + 496) = result | 0x100;
    else
      return ((uint64_t (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, 181, v78, v79);
  }
  return result;
}

void sub_21689E10C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)(v1 - 128);
  if (v3)
  {
    *(_QWORD *)(v1 - 120) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN27QMICellMonitorCommandDriver33processCommonCellInformation_syncIN3nas11GetCellInfo7RespIndEEEvRKT_R14CellInfoUpdate_block_invoke_11(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  __int16 v10;
  __int16 v11;
  int v12;
  void *__p[3];

  memset(__p, 0, sizeof(__p));
  std::optional<NrNeighborInformation>::operator=[abi:ne180100]<NrNeighborInformation,void>(*(_QWORD *)(a1 + 32) + 432, (uint64_t)__p);
  if (__p[0])
    operator delete(__p[0]);
  v4 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)(v4 + 456)
    || (std::vector<NrNeighborCell>::resize((char **)(v4 + 432), 0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 3)),
        v5 = *(_QWORD *)(a1 + 32),
        !*(_BYTE *)(v5 + 456)))
  {
    std::__throw_bad_optional_access[abi:ne180100]();
  }
  v7 = *a2;
  v6 = a2[1];
  if (*a2 != v6)
  {
    v8 = *(_QWORD *)(v5 + 432);
    do
    {
      v9 = *(_DWORD *)(v7 + 4);
      v10 = *(_WORD *)(v7 + 8);
      v11 = *(_WORD *)(v7 + 10);
      v12 = *(_DWORD *)(v7 + 12);
      *(_DWORD *)v8 = *(_DWORD *)v7;
      *(_DWORD *)(v8 + 4) = v9;
      *(_WORD *)(v8 + 8) = v10;
      *(_WORD *)(v8 + 10) = v11;
      *(_DWORD *)(v8 + 12) = v12;
      *(_WORD *)(v8 + 16) = 0;
      v7 += 24;
      *(_DWORD *)(v8 + 20) = 0;
      *(_DWORD *)(v8 + 24) = 0;
      v8 += 28;
    }
    while (v7 != v6);
  }
}

void std::vector<NrNeighborCell>::resize(char **a1, unint64_t a2)
{
  char *v3;
  char *v4;
  unint64_t v5;
  unint64_t v6;
  char *v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  char *v11;
  char *v12;
  uint64_t v13;
  char *v14;
  size_t v15;
  char *v16;
  char *v17;
  char *v18;
  __int128 v19;
  char *v20;
  size_t v21;

  v3 = *a1;
  v4 = a1[1];
  v5 = 0x6DB6DB6DB6DB6DB7 * ((v4 - *a1) >> 2);
  v6 = a2 - v5;
  if (a2 <= v5)
  {
    if (a2 >= v5)
      return;
    v20 = &v3[28 * a2];
    goto LABEL_17;
  }
  v7 = a1[2];
  if (0x6DB6DB6DB6DB6DB7 * ((v7 - v4) >> 2) >= v6)
  {
    v21 = 28 * ((28 * v6 - 28) / 0x1C) + 28;
    bzero(a1[1], v21);
    v20 = &v4[v21];
LABEL_17:
    a1[1] = v20;
    return;
  }
  if (a2 > 0x924924924924924)
    std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
  v8 = 0x6DB6DB6DB6DB6DB7 * ((v7 - v3) >> 2);
  v9 = 2 * v8;
  if (2 * v8 <= a2)
    v9 = a2;
  if (v8 >= 0x492492492492492)
    v10 = 0x924924924924924;
  else
    v10 = v9;
  v11 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NrNeighborCell>>(v10);
  v12 = &v11[28 * v5];
  v14 = &v11[28 * v13];
  v15 = 28 * ((28 * v6 - 28) / 0x1C) + 28;
  bzero(v12, v15);
  v16 = &v12[v15];
  v18 = *a1;
  v17 = a1[1];
  if (v17 != *a1)
  {
    do
    {
      v19 = *(_OWORD *)(v17 - 28);
      *((_OWORD *)v12 - 1) = *((_OWORD *)v17 - 1);
      *(_OWORD *)(v12 - 28) = v19;
      v12 -= 28;
      v17 -= 28;
    }
    while (v17 != v18);
    v17 = *a1;
  }
  *a1 = v12;
  a1[1] = v16;
  a1[2] = v14;
  if (v17)
    operator delete(v17);
}

unsigned __int8 *tlv::parseV<nas::tlv::NrNeighborInformation_V3>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  unsigned __int8 *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = (unsigned __int8 *)nas::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = result;
  return result;
}

void sub_21689E428(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x21689E41CLL);
}

void sub_21689E438(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_WORD *nas::tlv::parseField(unsigned __int8 *a1, const unsigned __int8 *a2, uint64_t *a3)
{
  _WORD *v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  _WORD *result;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  v7 = *a1;
  v6 = a1 + 1;
  std::vector<nas::tlv::UmtsCell>::resize((uint64_t)a3, v7);
  v8 = *a3;
  v9 = a3[1];
  while (1)
  {
    result = v6;
    if (v8 == v9)
      break;
    v6 = nas::tlv::parseField((unint64_t)v6, a2, v8);
    v8 += 28;
  }
  return result;
}

{
  _WORD *v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  _WORD *result;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  v7 = *a1;
  v6 = a1 + 1;
  std::vector<nas::tlv::GsmCell>::resize((uint64_t)a3, v7);
  v8 = *a3;
  v9 = a3[1];
  while (1)
  {
    result = v6;
    if (v8 == v9)
      break;
    v6 = nas::tlv::parseField((unint64_t)v6, a2, v8);
    v8 += 24;
  }
  return result;
}

void std::vector<nas::tlv::UmtsCell>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;

  v2 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 2);
  v3 = a2 >= v2;
  v4 = a2 - v2;
  if (v4 != 0 && v3)
  {
    std::vector<nas::tlv::UmtsCell>::__append((void **)a1, v4);
  }
  else if (!v3)
  {
    *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 28 * a2;
  }
}

void CellInfoUpdate::CellInfoUpdate(CellInfoUpdate *this, const CellInfoUpdate *a2)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  __int128 v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  __int128 v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  char *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  char *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  char *v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  char *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  char *v56;
  __int128 v57;
  uint64_t v58;
  uint64_t v59;
  unint64_t v60;
  char *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  char *v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  _BYTE *v69;
  _BYTE *v70;
  int64_t v71;
  char *v72;
  uint64_t v73;
  _BYTE *v74;
  _BYTE *v75;
  int64_t v76;
  char *v77;
  uint64_t v78;
  _BYTE *v79;
  _BYTE *v80;
  int64_t v81;
  char *v82;
  uint64_t v83;
  int v84;
  int v85;
  _BYTE *v86;
  _BYTE *v87;
  int64_t v88;
  char *v89;
  uint64_t v90;
  _BYTE *v91;
  _BYTE *v92;
  int64_t v93;
  char *v94;
  uint64_t v95;
  CellInfoUpdate *v96;
  char **v97;
  char **v98;
  uint64_t v99;
  char *v100;
  char *v101;

  *(_BYTE *)this = 0;
  *((_BYTE *)this + 24) = 0;
  if (*((_BYTE *)a2 + 24))
  {
    *(_QWORD *)this = 0;
    *((_QWORD *)this + 1) = 0;
    *((_QWORD *)this + 2) = 0;
    v4 = *(_QWORD *)a2;
    v5 = *((_QWORD *)a2 + 1);
    v96 = this;
    if (v5 != v4)
    {
      v6 = 0x4EC4EC4EC4EC4EC5 * ((v5 - v4) >> 3);
      v97 = 0;
      if (v6 >= 0x276276276276277)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v7 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Cdma1xCell>>(v6);
      v8 = 0;
      *(_QWORD *)this = v7;
      *((_QWORD *)this + 1) = v7;
      *((_QWORD *)this + 2) = &v7[104 * v9];
      do
      {
        v10 = v4 + v8;
        *(_WORD *)&v7[v8] = *(_WORD *)(v4 + v8);
        MCC::MCC();
        MCC::MCC((MCC *)&v7[v8 + 40], (const MCC *)(v4 + v8 + 40));
        v11 = &v7[v8];
        v12 = *(_OWORD *)(v4 + v8 + 72);
        *(_OWORD *)(v11 + 82) = *(_OWORD *)(v4 + v8 + 82);
        *(_OWORD *)(v11 + 72) = v12;
        v8 += 104;
      }
      while (v10 + 104 != v5);
      *((_QWORD *)this + 1) = &v7[v8];
    }
    *((_BYTE *)this + 24) = 1;
  }
  *((_BYTE *)this + 32) = 0;
  *((_BYTE *)this + 56) = 0;
  if (*((_BYTE *)a2 + 56))
  {
    *((_QWORD *)this + 4) = 0;
    *((_QWORD *)this + 5) = 0;
    *((_QWORD *)this + 6) = 0;
    v13 = *((_QWORD *)a2 + 4);
    v14 = *((_QWORD *)a2 + 5);
    if (v14 != v13)
    {
      v15 = 0x8E38E38E38E38E39 * ((v14 - v13) >> 3);
      if (v15 >= 0x38E38E38E38E38FLL)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CdmaEvdoCell>>(v15);
      *((_QWORD *)this + 6) = &v16[72 * v17];
      *((_QWORD *)this + 4) = v16;
      *((_QWORD *)this + 5) = v16;
      v100 = v16;
      v101 = v16;
      v96 = (CellInfoUpdate *)((char *)this + 48);
      v97 = &v100;
      v98 = &v101;
      v99 = 0;
      v18 = v13 + 8;
      v19 = v16;
      do
      {
        v20 = v18 - 8;
        *(_WORD *)v19 = *(_WORD *)(v18 - 8);
        MCC::MCC();
        v21 = *(_OWORD *)(v18 + 32);
        *(_OWORD *)(v19 + 54) = *(_OWORD *)(v18 + 46);
        *(_OWORD *)(v19 + 40) = v21;
        v19 = v101 + 72;
        v101 += 72;
        v18 += 72;
      }
      while (v20 + 72 != v14);
      LOBYTE(v99) = 1;
      std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CdmaEvdoCell>,CdmaEvdoCell*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)&v96);
      *((_QWORD *)this + 5) = v19;
    }
    *((_BYTE *)this + 56) = 1;
  }
  *((_BYTE *)this + 64) = 0;
  *((_BYTE *)this + 88) = 0;
  if (*((_BYTE *)a2 + 88))
  {
    *((_QWORD *)this + 8) = 0;
    *((_QWORD *)this + 9) = 0;
    *((_QWORD *)this + 10) = 0;
    v22 = *((_QWORD *)a2 + 8);
    v23 = *((_QWORD *)a2 + 9);
    v96 = (CellInfoUpdate *)((char *)this + 64);
    if (v23 != v22)
    {
      v24 = 0xAAAAAAAAAAAAAAABLL * ((v23 - v22) >> 5);
      v97 = 0;
      if (v24 > 0x2AAAAAAAAAAAAAALL)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v25 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<UmtsCell>>(v24);
      v26 = 0;
      *((_QWORD *)this + 8) = v25;
      *((_QWORD *)this + 9) = v25;
      *((_QWORD *)this + 10) = &v25[96 * v27];
      do
      {
        v28 = v22 + v26;
        *(_WORD *)&v25[v26] = *(_WORD *)(v22 + v26);
        MCC::MCC();
        MCC::MCC((MCC *)&v25[v26 + 40], (const MCC *)(v22 + v26 + 40));
        v29 = &v25[v26];
        v30 = *(_OWORD *)(v22 + v26 + 72);
        *((_DWORD *)v29 + 22) = *(_DWORD *)(v22 + v26 + 88);
        *(_OWORD *)(v29 + 72) = v30;
        v26 += 96;
      }
      while (v28 + 96 != v23);
      *((_QWORD *)this + 9) = &v25[v26];
    }
    *((_BYTE *)this + 88) = 1;
  }
  *((_BYTE *)this + 96) = 0;
  *((_BYTE *)this + 120) = 0;
  if (*((_BYTE *)a2 + 120))
  {
    *((_QWORD *)this + 12) = 0;
    *((_QWORD *)this + 13) = 0;
    *((_QWORD *)this + 14) = 0;
    v31 = *((_QWORD *)a2 + 12);
    v32 = *((_QWORD *)a2 + 13);
    v96 = (CellInfoUpdate *)((char *)this + 96);
    if (v32 != v31)
    {
      v33 = 0x2E8BA2E8BA2E8BA3 * ((v32 - v31) >> 3);
      v97 = 0;
      if (v33 >= 0x2E8BA2E8BA2E8BBLL)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<GsmCell>>(v33);
      v35 = 0;
      *((_QWORD *)this + 12) = v34;
      *((_QWORD *)this + 13) = v34;
      *((_QWORD *)this + 14) = &v34[88 * v36];
      do
      {
        v37 = v31 + v35;
        *(_WORD *)&v34[v35] = *(_WORD *)(v31 + v35);
        MCC::MCC();
        MCC::MCC((MCC *)&v34[v35 + 40], (const MCC *)(v31 + v35 + 40));
        *(_OWORD *)&v34[v35 + 72] = *(_OWORD *)(v31 + v35 + 72);
        v35 += 88;
      }
      while (v37 + 88 != v32);
      *((_QWORD *)this + 13) = &v34[v35];
    }
    *((_BYTE *)this + 120) = 1;
  }
  *((_BYTE *)this + 128) = 0;
  *((_BYTE *)this + 152) = 0;
  if (*((_BYTE *)a2 + 152))
  {
    *((_QWORD *)this + 16) = 0;
    *((_QWORD *)this + 17) = 0;
    *((_QWORD *)this + 18) = 0;
    v38 = *((_QWORD *)a2 + 16);
    v39 = *((_QWORD *)a2 + 17);
    v96 = (CellInfoUpdate *)((char *)this + 128);
    v40 = v39 - v38;
    if (v39 != v38)
    {
      v97 = 0;
      if (v40 < 0)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v41 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<LteCell>>(v40 >> 7);
      v42 = 0;
      *((_QWORD *)this + 16) = v41;
      *((_QWORD *)this + 17) = v41;
      *((_QWORD *)this + 18) = &v41[128 * v43];
      do
      {
        v44 = v38 + v42;
        *(_WORD *)&v41[v42] = *(_WORD *)(v38 + v42);
        MCC::MCC();
        MCC::MCC((MCC *)&v41[v42 + 40], (const MCC *)(v38 + v42 + 40));
        v45 = &v41[v42];
        v46 = *(_OWORD *)(v38 + v42 + 72);
        v47 = *(_OWORD *)(v38 + v42 + 88);
        v48 = *(_OWORD *)(v38 + v42 + 104);
        *((_QWORD *)v45 + 15) = *(_QWORD *)(v38 + v42 + 120);
        *(_OWORD *)(v45 + 104) = v48;
        *(_OWORD *)(v45 + 88) = v47;
        *(_OWORD *)(v45 + 72) = v46;
        v42 += 128;
      }
      while (v44 + 128 != v39);
      *((_QWORD *)this + 17) = &v41[v42];
    }
    *((_BYTE *)this + 152) = 1;
  }
  *((_BYTE *)this + 160) = 0;
  *((_BYTE *)this + 184) = 0;
  if (*((_BYTE *)a2 + 184))
  {
    *((_QWORD *)this + 20) = 0;
    *((_QWORD *)this + 21) = 0;
    *((_QWORD *)this + 22) = 0;
    v49 = *((_QWORD *)a2 + 20);
    v50 = *((_QWORD *)a2 + 21);
    v96 = (CellInfoUpdate *)((char *)this + 160);
    if (v50 != v49)
    {
      v51 = 0xAAAAAAAAAAAAAAABLL * ((v50 - v49) >> 5);
      v97 = 0;
      if (v51 > 0x2AAAAAAAAAAAAAALL)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v52 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<UmtsCell>>(v51);
      v53 = 0;
      *((_QWORD *)this + 20) = v52;
      *((_QWORD *)this + 21) = v52;
      *((_QWORD *)this + 22) = &v52[96 * v54];
      do
      {
        v55 = v49 + v53;
        *(_WORD *)&v52[v53] = *(_WORD *)(v49 + v53);
        MCC::MCC();
        MCC::MCC((MCC *)&v52[v53 + 40], (const MCC *)(v49 + v53 + 40));
        v56 = &v52[v53];
        v57 = *(_OWORD *)(v49 + v53 + 72);
        *((_DWORD *)v56 + 22) = *(_DWORD *)(v49 + v53 + 88);
        *(_OWORD *)(v56 + 72) = v57;
        v53 += 96;
      }
      while (v55 + 96 != v50);
      *((_QWORD *)this + 21) = &v52[v53];
    }
    *((_BYTE *)this + 184) = 1;
  }
  *((_BYTE *)this + 192) = 0;
  *((_BYTE *)this + 216) = 0;
  if (*((_BYTE *)a2 + 216))
  {
    *((_QWORD *)this + 24) = 0;
    *((_QWORD *)this + 25) = 0;
    *((_QWORD *)this + 26) = 0;
    v58 = *((_QWORD *)a2 + 24);
    v59 = *((_QWORD *)a2 + 25);
    v96 = (CellInfoUpdate *)((char *)this + 192);
    if (v59 != v58)
    {
      v60 = 0xF0F0F0F0F0F0F0F1 * ((v59 - v58) >> 3);
      v97 = 0;
      if (v60 >= 0x1E1E1E1E1E1E1E2)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v61 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NrCell>>(v60);
      v62 = 0;
      *((_QWORD *)this + 24) = v61;
      *((_QWORD *)this + 25) = v61;
      *((_QWORD *)this + 26) = &v61[136 * v63];
      do
      {
        v64 = v58 + v62;
        *(_WORD *)&v61[v62] = *(_WORD *)(v58 + v62);
        MCC::MCC();
        MCC::MCC((MCC *)&v61[v62 + 40], (const MCC *)(v58 + v62 + 40));
        v65 = &v61[v62];
        v66 = *(_OWORD *)(v58 + v62 + 72);
        v67 = *(_OWORD *)(v58 + v62 + 88);
        v68 = *(_OWORD *)(v58 + v62 + 104);
        *(_OWORD *)(v65 + 116) = *(_OWORD *)(v58 + v62 + 116);
        *(_OWORD *)(v65 + 104) = v68;
        *(_OWORD *)(v65 + 88) = v67;
        *(_OWORD *)(v65 + 72) = v66;
        v62 += 136;
      }
      while (v64 + 136 != v59);
      *((_QWORD *)this + 25) = &v61[v62];
    }
    *((_BYTE *)this + 216) = 1;
  }
  *((_BYTE *)this + 224) = 0;
  *((_BYTE *)this + 248) = 0;
  if (*((_BYTE *)a2 + 248))
  {
    *((_QWORD *)this + 28) = 0;
    *((_QWORD *)this + 29) = 0;
    *((_QWORD *)this + 30) = 0;
    v70 = (_BYTE *)*((_QWORD *)a2 + 28);
    v69 = (_BYTE *)*((_QWORD *)a2 + 29);
    v71 = v69 - v70;
    if (v69 != v70)
    {
      if (v71 < 0)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v72 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<embms::TMGIInfo>>(v71 >> 3);
      *((_QWORD *)this + 28) = v72;
      *((_QWORD *)this + 29) = v72;
      *((_QWORD *)this + 30) = &v72[8 * v73];
      memmove(v72, v70, v71);
      *((_QWORD *)this + 29) = &v72[8 * (v71 >> 3)];
    }
    *((_BYTE *)this + 248) = 1;
  }
  *((_BYTE *)this + 256) = 0;
  *((_BYTE *)this + 280) = 0;
  if (*((_BYTE *)a2 + 280))
  {
    *((_QWORD *)this + 32) = 0;
    *((_QWORD *)this + 33) = 0;
    *((_QWORD *)this + 34) = 0;
    v75 = (_BYTE *)*((_QWORD *)a2 + 32);
    v74 = (_BYTE *)*((_QWORD *)a2 + 33);
    v76 = v74 - v75;
    if (v74 != v75)
    {
      if (v76 < 0)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v77 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<subscriber::HardwareSimSlot>>(v76 >> 2);
      *((_QWORD *)this + 32) = v77;
      *((_QWORD *)this + 33) = v77;
      *((_QWORD *)this + 34) = &v77[4 * v78];
      memmove(v77, v75, v76);
      *((_QWORD *)this + 33) = &v77[4 * (v76 >> 2)];
    }
    *((_BYTE *)this + 280) = 1;
  }
  *((_BYTE *)this + 288) = 0;
  *((_BYTE *)this + 312) = 0;
  if (*((_BYTE *)a2 + 312))
  {
    *((_QWORD *)this + 36) = 0;
    *((_QWORD *)this + 37) = 0;
    *((_QWORD *)this + 38) = 0;
    v80 = (_BYTE *)*((_QWORD *)a2 + 36);
    v79 = (_BYTE *)*((_QWORD *)a2 + 37);
    v81 = v79 - v80;
    if (v79 != v80)
    {
      if (v81 < 0)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v82 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<LteNeighborCell>>(v81 >> 5);
      *((_QWORD *)this + 36) = v82;
      *((_QWORD *)this + 37) = v82;
      *((_QWORD *)this + 38) = &v82[32 * v83];
      memmove(v82, v80, v81);
      *((_QWORD *)this + 37) = &v82[32 * (v81 >> 5)];
    }
    *((_BYTE *)this + 312) = 1;
  }
  *((_BYTE *)this + 320) = 0;
  *((_BYTE *)this + 352) = 0;
  if (*((_BYTE *)a2 + 352))
  {
    v84 = *((_DWORD *)a2 + 80);
    *(_DWORD *)((char *)this + 323) = *(_DWORD *)((char *)a2 + 323);
    *((_DWORD *)this + 80) = v84;
    *((_QWORD *)this + 42) = 0;
    *((_QWORD *)this + 43) = 0;
    *((_QWORD *)this + 41) = 0;
    std::vector<Cdma1xNeighborCell>::__init_with_size[abi:ne180100]<Cdma1xNeighborCell*,Cdma1xNeighborCell*>((_QWORD *)this + 41, *((const void **)a2 + 41), *((_QWORD *)a2 + 42), (uint64_t)(*((_QWORD *)a2 + 42) - *((_QWORD *)a2 + 41)) >> 3);
    *((_BYTE *)this + 352) = 1;
  }
  *((_BYTE *)this + 360) = 0;
  *((_BYTE *)this + 392) = 0;
  if (*((_BYTE *)a2 + 392))
  {
    v85 = *((_DWORD *)a2 + 90);
    *(_DWORD *)((char *)this + 363) = *(_DWORD *)((char *)a2 + 363);
    *((_DWORD *)this + 90) = v85;
    *((_QWORD *)this + 47) = 0;
    *((_QWORD *)this + 48) = 0;
    *((_QWORD *)this + 46) = 0;
    std::vector<CdmaEvdoNeighborCell>::__init_with_size[abi:ne180100]<CdmaEvdoNeighborCell*,CdmaEvdoNeighborCell*>((_QWORD *)this + 46, *((const void **)a2 + 46), *((_QWORD *)a2 + 47), (uint64_t)(*((_QWORD *)a2 + 47) - *((_QWORD *)a2 + 46)) >> 3);
    *((_BYTE *)this + 392) = 1;
  }
  *((_BYTE *)this + 400) = 0;
  *((_BYTE *)this + 424) = 0;
  if (*((_BYTE *)a2 + 424))
  {
    *((_QWORD *)this + 50) = 0;
    *((_QWORD *)this + 51) = 0;
    *((_QWORD *)this + 52) = 0;
    v87 = (_BYTE *)*((_QWORD *)a2 + 50);
    v86 = (_BYTE *)*((_QWORD *)a2 + 51);
    v88 = v86 - v87;
    if (v86 != v87)
    {
      if (v88 < 0)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v89 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<embms::TMGIInfo>>(v88 >> 3);
      *((_QWORD *)this + 50) = v89;
      *((_QWORD *)this + 51) = v89;
      *((_QWORD *)this + 52) = &v89[8 * v90];
      memmove(v89, v87, v88);
      *((_QWORD *)this + 51) = &v89[8 * (v88 >> 3)];
    }
    *((_BYTE *)this + 424) = 1;
  }
  *((_BYTE *)this + 432) = 0;
  *((_BYTE *)this + 456) = 0;
  if (*((_BYTE *)a2 + 456))
  {
    *((_QWORD *)this + 54) = 0;
    *((_QWORD *)this + 55) = 0;
    *((_QWORD *)this + 56) = 0;
    v92 = (_BYTE *)*((_QWORD *)a2 + 54);
    v91 = (_BYTE *)*((_QWORD *)a2 + 55);
    v93 = v91 - v92;
    if (v91 != v92)
    {
      if ((unint64_t)(0x6DB6DB6DB6DB6DB7 * (v93 >> 2)) >= 0x924924924924925)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v94 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NrNeighborCell>>(0x6DB6DB6DB6DB6DB7 * (v93 >> 2));
      *((_QWORD *)this + 54) = v94;
      *((_QWORD *)this + 55) = v94;
      *((_QWORD *)this + 56) = &v94[28 * v95];
      memmove(v94, v92, v93);
      *((_QWORD *)this + 55) = &v94[4 * (v93 >> 2)];
    }
    *((_BYTE *)this + 456) = 1;
  }
  *((_BYTE *)this + 464) = 0;
  *((_BYTE *)this + 488) = 0;
  if (*((_BYTE *)a2 + 488))
  {
    *((_QWORD *)this + 58) = 0;
    *((_QWORD *)this + 59) = 0;
    *((_QWORD *)this + 60) = 0;
    std::vector<unsigned short>::__init_with_size[abi:ne180100]<unsigned short *,unsigned short *>((_QWORD *)this + 58, *((const void **)a2 + 58), *((_QWORD *)a2 + 59), (uint64_t)(*((_QWORD *)a2 + 59) - *((_QWORD *)a2 + 58)) >> 1);
    *((_BYTE *)this + 488) = 1;
  }
  *((_WORD *)this + 248) = *((_WORD *)a2 + 248);
}

void sub_21689EEB4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **a10, uint64_t a11, void **a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19)
{
  uint64_t v19;
  void **v20;
  void **v21;
  uint64_t v22;
  void **v23;
  void **v24;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;

  if (*(_BYTE *)(v19 + 488))
  {
    v26 = *v20;
    if (*v20)
    {
      *(_QWORD *)(v19 + 472) = v26;
      operator delete(v26);
    }
  }
  if (*(_BYTE *)(v19 + 456))
  {
    v27 = *v21;
    if (*v21)
    {
      *(_QWORD *)(v19 + 440) = v27;
      operator delete(v27);
    }
  }
  if (*(_BYTE *)(v19 + 424))
  {
    v28 = *v24;
    if (*v24)
    {
      *(_QWORD *)(v19 + 408) = v28;
      operator delete(v28);
    }
  }
  if (*(_BYTE *)(v19 + 392))
  {
    v29 = *(void **)(v19 + 368);
    if (v29)
    {
      *(_QWORD *)(v19 + 376) = v29;
      operator delete(v29);
    }
  }
  if (*(_BYTE *)(v19 + 352))
  {
    v30 = *(void **)(v19 + 328);
    if (v30)
    {
      *(_QWORD *)(v19 + 336) = v30;
      operator delete(v30);
    }
  }
  if (*(_BYTE *)(v19 + 312))
  {
    v31 = *a12;
    if (*a12)
    {
      *(_QWORD *)(v19 + 296) = v31;
      operator delete(v31);
    }
  }
  if (*(_BYTE *)(v19 + 280))
  {
    v32 = *a10;
    if (*a10)
    {
      *(_QWORD *)(v19 + 264) = v32;
      operator delete(v32);
    }
  }
  if (*(_BYTE *)(v19 + 248))
  {
    v33 = *v23;
    if (*v23)
    {
      *(_QWORD *)(v19 + 232) = v33;
      operator delete(v33);
    }
  }
  if (*(_BYTE *)(v19 + 216))
  {
    a19 = a13;
    std::vector<NrCell>::__destroy_vector::operator()[abi:ne180100]((void ***)&a19);
  }
  if (*(_BYTE *)(v19 + 184))
  {
    a19 = v22;
    std::vector<UmtsCell>::__destroy_vector::operator()[abi:ne180100]((void ***)&a19);
  }
  if (*(_BYTE *)(v19 + 152))
  {
    a19 = a14;
    std::vector<LteCell>::__destroy_vector::operator()[abi:ne180100]((void ***)&a19);
  }
  if (*(_BYTE *)(v19 + 120))
  {
    a19 = a15;
    std::vector<GsmCell>::__destroy_vector::operator()[abi:ne180100]((void ***)&a19);
  }
  if (*(_BYTE *)(v19 + 88))
  {
    a19 = a16;
    std::vector<UmtsCell>::__destroy_vector::operator()[abi:ne180100]((void ***)&a19);
  }
  if (*(_BYTE *)(v19 + 56))
  {
    a19 = a11;
    std::vector<CdmaEvdoCell>::__destroy_vector::operator()[abi:ne180100]((void ***)&a19);
  }
  if (*(_BYTE *)(v19 + 24))
  {
    a19 = v19;
    std::vector<Cdma1xCell>::__destroy_vector::operator()[abi:ne180100]((void ***)&a19);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN27QMICellMonitorCommandDriver33processCommonCellInformation_syncIN3nas11GetCellInfo7RespIndEEEvRKT_R14CellInfoUpdate_block_invoke_9(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  char *v17;
  char *v18;
  uint64_t v19;
  char *v20;
  char *v21;
  char *v22;
  char *v23;
  __int128 v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  __int16 v31;
  int v32;
  char v33;
  int v34;

  v4 = *(_QWORD *)(a1 + 32);
  v5 = v4 + 288;
  if (*(_BYTE *)(v4 + 312))
  {
    v6 = *(void **)v5;
    if (*(_QWORD *)v5)
    {
      *(_QWORD *)(v4 + 296) = v6;
      operator delete(v6);
    }
    *(_QWORD *)v5 = 0;
    *(_QWORD *)(v5 + 8) = 0;
    *(_QWORD *)(v5 + 16) = 0;
  }
  else
  {
    *(_QWORD *)v5 = 0;
    *(_QWORD *)(v4 + 296) = 0;
    *(_QWORD *)(v4 + 304) = 0;
    *(_BYTE *)(v4 + 312) = 1;
  }
  v7 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)(v7 + 312))
LABEL_29:
    std::__throw_bad_optional_access[abi:ne180100]();
  v8 = a2[1] - *a2;
  v9 = v8 >> 5;
  v10 = *(_QWORD *)(v7 + 288);
  v11 = *(_QWORD *)(v7 + 296);
  v12 = (v11 - v10) >> 5;
  if (v8 >> 5 <= v12)
  {
    if (v9 >= v12)
      goto LABEL_24;
    v25 = v10 + 32 * v9;
    goto LABEL_23;
  }
  v13 = v9 - v12;
  v14 = *(_QWORD *)(v7 + 304);
  if (v9 - v12 <= (v14 - v11) >> 5)
  {
    bzero(*(void **)(v7 + 296), 32 * v13);
    v25 = v11 + 32 * v13;
LABEL_23:
    *(_QWORD *)(v7 + 296) = v25;
    goto LABEL_24;
  }
  if (v8 < 0)
    std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
  v15 = v14 - v10;
  if (v15 >> 4 > v9)
    v9 = v15 >> 4;
  if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFE0)
    v16 = 0x7FFFFFFFFFFFFFFLL;
  else
    v16 = v9;
  v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<LteNeighborCell>>(v16);
  v18 = &v17[32 * v12];
  v20 = &v17[32 * v19];
  bzero(v18, 32 * v13);
  v21 = &v18[32 * v13];
  v23 = *(char **)(v7 + 288);
  v22 = *(char **)(v7 + 296);
  if (v22 != v23)
  {
    do
    {
      v24 = *((_OWORD *)v22 - 1);
      *((_OWORD *)v18 - 2) = *((_OWORD *)v22 - 2);
      *((_OWORD *)v18 - 1) = v24;
      v18 -= 32;
      v22 -= 32;
    }
    while (v22 != v23);
    v22 = *(char **)(v7 + 288);
  }
  *(_QWORD *)(v7 + 288) = v18;
  *(_QWORD *)(v7 + 296) = v21;
  *(_QWORD *)(v7 + 304) = v20;
  if (v22)
    operator delete(v22);
LABEL_24:
  v26 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)(v26 + 312))
    goto LABEL_29;
  v28 = *a2;
  v27 = a2[1];
  if (*a2 != v27)
  {
    v29 = *(_QWORD *)(v26 + 288);
    do
    {
      v30 = *(_DWORD *)(v28 + 4);
      v31 = *(_WORD *)(v28 + 8);
      v32 = *(_DWORD *)(v28 + 12);
      v33 = *(_BYTE *)(v28 + 16);
      v34 = *(_DWORD *)(v28 + 20);
      *(_DWORD *)v29 = *(_DWORD *)v28;
      *(_DWORD *)(v29 + 4) = v30;
      *(_WORD *)(v29 + 8) = v31;
      *(_DWORD *)(v29 + 12) = v32;
      *(_BYTE *)(v29 + 16) = v33;
      *(_QWORD *)(v29 + 24) = 0;
      v28 += 32;
      *(_DWORD *)(v29 + 20) = v34;
      v29 += 32;
    }
    while (v28 != v27);
  }
}

char *tlv::parseV<nas::tlv::LteNeighborInformation_V3>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  char *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = nas::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = (unsigned __int8 *)result;
  return result;
}

void sub_21689F510(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x21689F504);
}

void sub_21689F520(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *nas::tlv::parseField(unsigned __int8 *a1, const unsigned __int8 *a2, uint64_t *a3)
{
  char *v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  char *result;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  v7 = *a1;
  v6 = (char *)(a1 + 1);
  std::vector<nas::tlv::LteNeighborCell_V3>::resize((uint64_t)a3, v7);
  v8 = *a3;
  v9 = a3[1];
  while (1)
  {
    result = v6;
    if (v8 == v9)
      break;
    v6 = nas::tlv::parseField((unint64_t)v6, a2, v8);
    v8 += 32;
  }
  return result;
}

void std::vector<nas::tlv::LteNeighborCell_V3>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;

  v2 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 5;
  if (a2 <= v2)
  {
    if (a2 < v2)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 32 * a2;
  }
  else
  {
    std::vector<nas::tlv::LteNeighborCell_V3>::__append((void **)a1, a2 - v2);
  }
}

void ___ZNK3qmi6Client13setIndHandlerIRKN4elqm12BBIndication10IndicationEEEvtU13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_21689F690(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ___ZNK3qmi6Client13setIndHandlerIRKN3dsd22ThroughputEstimateInfo10IndicationEEEvtU13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_21689F78C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

uint64_t ___ZN33QMIDataSystemDeterminationManager27handleQMIClientStarted_syncEv_block_invoke_5(uint64_t result, qmi::MessageBase *this)
{
  uint64_t v2;
  int v4;
  uint64_t v5;
  int v6;
  _QWORD v7[3];
  uint64_t v8;

  v2 = *(_QWORD *)(result + 32);
  if (!*(_BYTE *)(v2 + 168))
  {
    result = qmi::MessageBase::findTlvValue(this);
    if (result)
    {
      v5 = result;
      v6 = v4;
      v8 = result;
      memset(v7, 0, sizeof(v7));
      tlv::parseV<dsd::tlv::GlobalUiInfo>((unint64_t *)&v8, v4, v7);
      if (v8)
        return QMIDataSystemDeterminationManager::handleUiMask_sync(v2, (uint64_t)v7);
      else
        return ((uint64_t (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)this, 16, v5, v6);
    }
  }
  return result;
}

void ___ZN27QMICellMonitorCommandDriver28sendRegistrationHintsForSlotEN10subscriber7SimSlotE9FetchTypebNSt3__16vectorI14SystemRecord1xNS3_9allocatorIS5_EEEENS4_I16SystemRecordEVDONS6_IS9_EEEENS4_I15SystemRecordGSMNS6_ISC_EEEESE_NS4_I15SystemRecordLTENS6_ISF_EEEESE_NS4_I14SystemRecordNRNS6_ISI_EEEE_block_invoke_3(uint64_t a1, char *a2)
{
  char v3;
  NSObject *v4;
  uint8_t v5[16];

  if (*(_QWORD *)(a1 + 32))
  {
    v3 = 0;
  }
  else
  {
    v4 = **(NSObject ***)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v5 = 0;
      _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#N No technology hints remaining, informing baseband of no hits", v5, 2u);
    }
    v3 = 1;
  }
  *a2 = v3;
}

uint64_t ___ZN27QMICellMonitorCommandDriver28sendRegistrationHintsForSlotEN10subscriber7SimSlotE9FetchTypebNSt3__16vectorI14SystemRecord1xNS3_9allocatorIS5_EEEENS4_I16SystemRecordEVDONS6_IS9_EEEENS4_I15SystemRecordGSMNS6_ISC_EEEESE_NS4_I15SystemRecordLTENS6_ISF_EEEESE_NS4_I14SystemRecordNRNS6_ISI_EEEE_block_invoke(uint64_t result, _BYTE *a2)
{
  unsigned int v2;

  v2 = *(unsigned __int8 *)(result + 40);
  if (v2 >= 4)
    LOBYTE(v2) = 4;
  *a2 = v2;
  return result;
}

void `non-virtual thunk to'QMIDataCommandDriver::handleBandwidthInfo(uint64_t a1)
{
  QMIDataCommandDriver::handleBandwidthInfo(a1 - 56);
}

void std::__tree<std::__value_type<RadioAccessTechnology,ServingSystem::GSMSystem>,std::__map_value_compare<RadioAccessTechnology,std::__value_type<RadioAccessTechnology,ServingSystem::GSMSystem>,std::less<RadioAccessTechnology>,true>,std::allocator<std::__value_type<RadioAccessTechnology,ServingSystem::GSMSystem>>>::destroy(_QWORD *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<RadioAccessTechnology,ServingSystem::GSMSystem>,std::__map_value_compare<RadioAccessTechnology,std::__value_type<RadioAccessTechnology,ServingSystem::GSMSystem>,std::less<RadioAccessTechnology>,true>,std::allocator<std::__value_type<RadioAccessTechnology,ServingSystem::GSMSystem>>>::destroy(*a1);
    std::__tree<std::__value_type<RadioAccessTechnology,ServingSystem::GSMSystem>,std::__map_value_compare<RadioAccessTechnology,std::__value_type<RadioAccessTechnology,ServingSystem::GSMSystem>,std::less<RadioAccessTechnology>,true>,std::allocator<std::__value_type<RadioAccessTechnology,ServingSystem::GSMSystem>>>::destroy(a1[1]);
    std::__destroy_at[abi:ne180100]<std::pair<RadioAccessTechnology const,ServingSystem::GSMSystem>,0>((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

uint64_t **std::__tree<std::__value_type<RadioAccessTechnology,ServingSystem::GSMSystem>,std::__map_value_compare<RadioAccessTechnology,std::__value_type<RadioAccessTechnology,ServingSystem::GSMSystem>,std::less<RadioAccessTechnology>,true>,std::allocator<std::__value_type<RadioAccessTechnology,ServingSystem::GSMSystem>>>::__emplace_unique_key_args<RadioAccessTechnology,std::piecewise_construct_t const&,std::tuple<RadioAccessTechnology const&>,std::tuple<>>(uint64_t **a1, int a2, _DWORD *a3)
{
  uint64_t *v5;
  uint64_t **v6;
  uint64_t **v7;
  uint64_t **v8;
  int v9;
  char *v10;
  _QWORD v12[3];

  v6 = a1 + 1;
  v5 = a1[1];
  v7 = a1 + 1;
  v8 = a1 + 1;
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v8 = (uint64_t **)v5;
        v9 = *((_DWORD *)v5 + 8);
        if (v9 <= a2)
          break;
        v5 = *v8;
        v7 = v8;
        if (!*v8)
          goto LABEL_8;
      }
      if (v9 >= a2)
        break;
      v5 = v8[1];
      if (!v5)
      {
        v7 = v8 + 1;
        goto LABEL_8;
      }
    }
  }
  else
  {
LABEL_8:
    v12[2] = 1;
    v10 = (char *)operator new(0x98uLL);
    v12[1] = v6;
    *((_DWORD *)v10 + 8) = *a3;
    *(_OWORD *)(v10 + 136) = 0u;
    *(_OWORD *)(v10 + 40) = 0u;
    *(_OWORD *)(v10 + 56) = 0u;
    *(_OWORD *)(v10 + 72) = 0u;
    *(_OWORD *)(v10 + 88) = 0u;
    *(_OWORD *)(v10 + 104) = 0u;
    *(_OWORD *)(v10 + 120) = 0u;
    *((_DWORD *)v10 + 36) = 11;
    std::__tree<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::less<unsigned short>,true>,std::allocator<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>>>::__insert_node_at(a1, (uint64_t)v8, v7, (uint64_t *)v10);
    v12[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<RadioAccessTechnology,ServingSystem::GSMSystem>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<RadioAccessTechnology,ServingSystem::GSMSystem>,void *>>>>::reset[abi:ne180100]((uint64_t)v12);
    return (uint64_t **)v10;
  }
  return v8;
}

uint64_t *std::__tree<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::less<unsigned short>,true>,std::allocator<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>>>::__insert_node_at(uint64_t **a1, uint64_t a2, uint64_t **a3, uint64_t *a4)
{
  uint64_t *v5;
  uint64_t *result;

  *a4 = 0;
  a4[1] = 0;
  a4[2] = a2;
  *a3 = a4;
  v5 = (uint64_t *)**a1;
  if (v5)
  {
    *a1 = v5;
    a4 = *a3;
  }
  result = std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], a4);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

void std::__tree<std::__value_type<RadioAccessTechnology,ServingSystem::System>,std::__map_value_compare<RadioAccessTechnology,std::__value_type<RadioAccessTechnology,ServingSystem::System>,std::less<RadioAccessTechnology>,true>,std::allocator<std::__value_type<RadioAccessTechnology,ServingSystem::System>>>::destroy(_QWORD *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<RadioAccessTechnology,ServingSystem::System>,std::__map_value_compare<RadioAccessTechnology,std::__value_type<RadioAccessTechnology,ServingSystem::System>,std::less<RadioAccessTechnology>,true>,std::allocator<std::__value_type<RadioAccessTechnology,ServingSystem::System>>>::destroy(*a1);
    std::__tree<std::__value_type<RadioAccessTechnology,ServingSystem::System>,std::__map_value_compare<RadioAccessTechnology,std::__value_type<RadioAccessTechnology,ServingSystem::System>,std::less<RadioAccessTechnology>,true>,std::allocator<std::__value_type<RadioAccessTechnology,ServingSystem::System>>>::destroy(a1[1]);
    std::__destroy_at[abi:ne180100]<std::pair<RadioAccessTechnology const,ServingSystem::System>,0>((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

uint64_t **std::__tree<std::__value_type<RadioAccessTechnology,ServingSystem::System>,std::__map_value_compare<RadioAccessTechnology,std::__value_type<RadioAccessTechnology,ServingSystem::System>,std::less<RadioAccessTechnology>,true>,std::allocator<std::__value_type<RadioAccessTechnology,ServingSystem::System>>>::__emplace_unique_key_args<RadioAccessTechnology,std::piecewise_construct_t const&,std::tuple<RadioAccessTechnology const&>,std::tuple<>>(uint64_t **a1, int a2, _DWORD *a3)
{
  uint64_t *v5;
  uint64_t **v6;
  uint64_t **v7;
  uint64_t **v8;
  int v9;
  char *v10;
  _QWORD v12[3];

  v6 = a1 + 1;
  v5 = a1[1];
  v7 = a1 + 1;
  v8 = a1 + 1;
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v8 = (uint64_t **)v5;
        v9 = *((_DWORD *)v5 + 8);
        if (v9 <= a2)
          break;
        v5 = *v8;
        v7 = v8;
        if (!*v8)
          goto LABEL_8;
      }
      if (v9 >= a2)
        break;
      v5 = v8[1];
      if (!v5)
      {
        v7 = v8 + 1;
        goto LABEL_8;
      }
    }
  }
  else
  {
LABEL_8:
    v12[2] = 1;
    v10 = (char *)operator new(0x98uLL);
    v12[1] = v6;
    *((_DWORD *)v10 + 8) = *a3;
    *(_OWORD *)(v10 + 136) = 0u;
    *(_OWORD *)(v10 + 40) = 0u;
    *(_OWORD *)(v10 + 56) = 0u;
    *(_OWORD *)(v10 + 72) = 0u;
    *(_OWORD *)(v10 + 88) = 0u;
    *(_OWORD *)(v10 + 104) = 0u;
    *(_OWORD *)(v10 + 120) = 0u;
    *((_DWORD *)v10 + 36) = 11;
    std::__tree<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::less<unsigned short>,true>,std::allocator<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>>>::__insert_node_at(a1, (uint64_t)v8, v7, (uint64_t *)v10);
    v12[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<RadioAccessTechnology,ServingSystem::System>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<RadioAccessTechnology,ServingSystem::System>,void *>>>>::reset[abi:ne180100]((uint64_t)v12);
    return (uint64_t **)v10;
  }
  return v8;
}

uint64_t std::function<void ()(ServingSystem::System &,nas::NasRegistrationState,MCC,MNC,BOOL)>::operator()(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, char a6)
{
  char v7;
  char v8;

  v8 = a3;
  v7 = a6;
  if (!a1)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, uint64_t, char *, uint64_t, uint64_t, char *))(*(_QWORD *)a1 + 48))(a1, a2, &v8, a4, a5, &v7);
}

unint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::UMTSHints>::getSize(uint64_t a1)
{
  return tlv::size<nas::tlv::GSMHints>((_QWORD *)(a1 + 16));
}

_BYTE *qmi::MutableMessageBase::TlvWrapper<nas::tlv::UMTSHints>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE *result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<nas::tlv::GSMHints>((_BYTE **)a2, (_DWORD *)(a1 + 16));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::HintType>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<nas::tlv::HintType>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

unint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::GSMHints>::getSize(uint64_t a1)
{
  return tlv::size<nas::tlv::GSMHints>((_QWORD *)(a1 + 16));
}

_BYTE *qmi::MutableMessageBase::TlvWrapper<nas::tlv::GSMHints>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE *result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<nas::tlv::GSMHints>((_BYTE **)a2, (_DWORD *)(a1 + 16));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

unint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::NRHints>::getSize(uint64_t a1)
{
  return tlv::size<nas::tlv::NRHints>((_QWORD *)(a1 + 16));
}

_BYTE *qmi::MutableMessageBase::TlvWrapper<nas::tlv::NRHints>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE *result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<nas::tlv::NRHints>((_BYTE **)a2, (_DWORD *)(a1 + 16));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::IsBootstrapDatabase>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<nas::tlv::IsBootstrapDatabase>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::MessageComplete>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<nas::tlv::MessageComplete>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

unint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::LTEHints_V3>::getSize(uint64_t a1)
{
  return tlv::size<nas::tlv::LTEHints_V3>((_QWORD *)(a1 + 16));
}

_BYTE *qmi::MutableMessageBase::TlvWrapper<nas::tlv::LTEHints_V3>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE *result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<nas::tlv::LTEHints_V3>((_BYTE **)a2, (_DWORD *)(a1 + 16));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::StatusType>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<nas::tlv::StatusType>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::BorderInfo>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<nas::tlv::BorderInfo>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MessageBase::tryTlv<nas::tlv::LteEmergencyBearerSupport>(qmi::MessageBase *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  unint64_t v5;
  unint64_t v6[2];

  result = qmi::MessageBase::findTlvValue(a1);
  v6[0] = result;
  v6[1] = v5;
  if (result)
  {
    result = tlv::parseV<nas::tlv::LteEmergencyBearerSupport>(v6, v5);
    if (!*(_BYTE *)a3)
      *(_BYTE *)a3 = 1;
    *(_DWORD *)(a3 + 4) = result;
    if (!v6[0])
      *(_BYTE *)a3 = 0;
  }
  return result;
}

uint64_t qmi::MessageBase::tryTlv<nas::tlv::LteEmergencyAccessBarred>(qmi::MessageBase *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  unint64_t v5;
  unint64_t v6[2];

  result = qmi::MessageBase::findTlvValue(a1);
  v6[0] = result;
  v6[1] = v5;
  if (result)
  {
    result = tlv::parseV<nas::tlv::LteEmergencyAccessBarred>(v6, v5);
    if (!*(_BYTE *)a3)
      *(_BYTE *)a3 = 1;
    *(_DWORD *)(a3 + 4) = result;
    if (!v6[0])
      *(_BYTE *)a3 = 0;
  }
  return result;
}

_BYTE *qmi::MessageBase::tryTlv<nas::tlv::WCDMAServiceStatus>(qmi::MessageBase *a1, unsigned __int8 *a2)
{
  _BYTE *result;
  _BYTE *v4;
  int v5;
  _BYTE *v6[2];

  result = (_BYTE *)qmi::MessageBase::findTlvValue(a1);
  v6[0] = result;
  v6[1] = v4;
  if (result)
  {
    result = (_BYTE *)tlv::parseV<nas::tlv::WCDMAServiceStatus>(v6, (int)v4);
    v5 = *a2;
    *(_WORD *)(a2 + 1) = (_WORD)result;
    a2[3] = BYTE2(result);
    if (!v5)
      *a2 = 1;
    if (!v6[0])
      *a2 = 0;
  }
  return result;
}

_BYTE *qmi::MessageBase::tryTlv<nas::tlv::NR5GServiceStatus>(qmi::MessageBase *a1, uint64_t a2, unsigned __int8 *a3)
{
  _BYTE *result;
  _BYTE *v5;
  int v6;
  _BYTE *v7[2];

  result = (_BYTE *)qmi::MessageBase::findTlvValue(a1);
  v7[0] = result;
  v7[1] = v5;
  if (result)
  {
    result = (_BYTE *)tlv::parseV<nas::tlv::NR5GServiceStatus>(v7, (int)v5);
    v6 = *a3;
    *(_WORD *)(a3 + 1) = (_WORD)result;
    a3[3] = BYTE2(result);
    if (!v6)
      *a3 = 1;
    if (!v7[0])
      *a3 = 0;
  }
  return result;
}

_BYTE *qmi::MessageBase::tryTlv<nas::tlv::LTEServiceStatus>(qmi::MessageBase *a1, unsigned __int8 *a2)
{
  _BYTE *result;
  _BYTE *v4;
  int v5;
  _BYTE *v6[2];

  result = (_BYTE *)qmi::MessageBase::findTlvValue(a1);
  v6[0] = result;
  v6[1] = v4;
  if (result)
  {
    result = (_BYTE *)tlv::parseV<nas::tlv::LTEServiceStatus>(v6, (int)v4);
    v5 = *a2;
    *(_WORD *)(a2 + 1) = (_WORD)result;
    a2[3] = BYTE2(result);
    if (!v5)
      *a2 = 1;
    if (!v6[0])
      *a2 = 0;
  }
  return result;
}

_BYTE *qmi::MessageBase::tryTlv<nas::tlv::GSMServiceStatus>(qmi::MessageBase *a1, unsigned __int8 *a2)
{
  _BYTE *result;
  _BYTE *v4;
  int v5;
  _BYTE *v6[2];

  result = (_BYTE *)qmi::MessageBase::findTlvValue(a1);
  v6[0] = result;
  v6[1] = v4;
  if (result)
  {
    result = (_BYTE *)tlv::parseV<nas::tlv::GSMServiceStatus>(v6, (int)v4);
    v5 = *a2;
    *(_WORD *)(a2 + 1) = (_WORD)result;
    a2[3] = BYTE2(result);
    if (!v5)
      *a2 = 1;
    if (!v6[0])
      *a2 = 0;
  }
  return result;
}

uint64_t qmi::MessageBase::tryTlv<nas::tlv::SimRejectInfo>(qmi::MessageBase *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  unint64_t v5;
  unint64_t v6[2];

  result = qmi::MessageBase::findTlvValue(a1);
  v6[0] = result;
  v6[1] = v5;
  if (result)
  {
    result = tlv::parseV<nas::tlv::SimRejectInfo>(v6, v5);
    if (!*(_BYTE *)a3)
      *(_BYTE *)a3 = 1;
    *(_DWORD *)(a3 + 4) = result;
    if (!v6[0])
      *(_BYTE *)a3 = 0;
  }
  return result;
}

uint64_t qmi::MessageBase::tryTlv<nas::tlv::LTESysInfoEx>(qmi::MessageBase *a1, uint64_t a2)
{
  uint64_t result;
  unint64_t v4;
  unint64_t v5[2];

  result = qmi::MessageBase::findTlvValue(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result)
  {
    result = tlv::parseV<nas::tlv::LTESysInfoEx>(v5, v4);
    if (!*(_BYTE *)a2)
      *(_BYTE *)a2 = 1;
    *(_WORD *)(a2 + 2) = result;
    if (!v5[0])
      *(_BYTE *)a2 = 0;
  }
  return result;
}

unint64_t qmi::MessageBase::tryTlv<nas::tlv::LTESysInfo>(qmi::MessageBase *a1, uint64_t a2)
{
  unint64_t result;
  unint64_t v4;
  _OWORD *v5;
  __int128 v6;
  _OWORD v7[2];
  int v8;
  unint64_t v9[2];

  result = qmi::MessageBase::findTlvValue(a1);
  v9[0] = result;
  v9[1] = v4;
  if (result)
  {
    result = tlv::parseV<nas::tlv::LTESysInfo>(v9, v4, (uint64_t)v7);
    v5 = (_OWORD *)(a2 + 4);
    v6 = v7[1];
    if (*(_BYTE *)a2)
    {
      *v5 = v7[0];
      *(_OWORD *)(a2 + 20) = v6;
      *(_WORD *)(a2 + 36) = v8;
    }
    else
    {
      *v5 = v7[0];
      *(_OWORD *)(a2 + 20) = v6;
      *(_DWORD *)(a2 + 36) = v8;
      *(_BYTE *)a2 = 1;
    }
    if (!v9[0])
      *(_BYTE *)a2 = 0;
  }
  return result;
}

_BYTE *tlv::writeV<nas::tlv::GSMHints>(_BYTE **a1, _DWORD *a2)
{
  _BYTE *result;

  result = nas::tlv::writeField(*a1, a2);
  *a1 = result;
  return result;
}

_BYTE *tlv::writeV<nas::tlv::NRHints>(_BYTE **a1, _DWORD *a2)
{
  _BYTE *result;

  result = nas::tlv::writeField(*a1, a2);
  *a1 = result;
  return result;
}

_BYTE *tlv::writeV<nas::tlv::LTEHints_V3>(_BYTE **a1, _DWORD *a2)
{
  _BYTE *result;

  result = nas::tlv::writeField(*a1, a2);
  *a1 = result;
  return result;
}

_QWORD *tlv::parseV<elqm::tlv::HighThroughputEnabled>@<X0>(char **a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  char *v4;
  _QWORD *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  v4 = &(*a1)[a2];
  result = std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(a3, *a1, v4, a2);
  *a1 = v4;
  return result;
}

void sub_2168A0394(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168A0384);
}

void sub_2168A03A4(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t tlv::parseV<elqm::tlv::SubscriptionId>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168A03F8(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168A03ECLL);
}

uint64_t tlv::parseV<nas::tlv::Fetch>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168A0444(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168A0438);
}

uint64_t tlv::parseV<nas::tlv::LteEmergencyBearerSupport>(unint64_t *a1, int a2)
{
  unsigned int *v3;
  uint64_t result;

  v3 = (unsigned int *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 4uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168A0490(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168A0484);
}

uint64_t tlv::parseV<nas::tlv::LteEmergencyAccessBarred>(unint64_t *a1, int a2)
{
  unsigned int *v3;
  uint64_t result;

  v3 = (unsigned int *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 4uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168A04DC(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168A04D0);
}

uint64_t tlv::parseV<nas::tlv::WCDMAServiceStatus>(_BYTE **a1, int a2)
{
  unsigned __int16 v3;
  unsigned __int8 v4;

  v4 = 0;
  v3 = 0;
  *a1 = nas::tlv::parseField(*a1, &(*a1)[a2], &v3);
  return v3 | (v4 << 16);
}

void sub_2168A053C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168A0520);
}

uint64_t tlv::parseV<nas::tlv::NR5GServiceStatus>(_BYTE **a1, int a2)
{
  unsigned __int16 v3;
  unsigned __int8 v4;

  v4 = 0;
  v3 = 0;
  *a1 = nas::tlv::parseField(*a1, &(*a1)[a2], &v3);
  return v3 | (v4 << 16);
}

void sub_2168A0598(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168A057CLL);
}

uint64_t tlv::parseV<nas::tlv::LTEServiceStatus>(_BYTE **a1, int a2)
{
  unsigned __int16 v3;
  unsigned __int8 v4;

  v4 = 0;
  v3 = 0;
  *a1 = nas::tlv::parseField(*a1, &(*a1)[a2], &v3);
  return v3 | (v4 << 16);
}

void sub_2168A05F4(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168A05D8);
}

uint64_t tlv::parseV<nas::tlv::GSMServiceStatus>(_BYTE **a1, int a2)
{
  unsigned __int16 v3;
  unsigned __int8 v4;

  v4 = 0;
  v3 = 0;
  *a1 = nas::tlv::parseField(*a1, &(*a1)[a2], &v3);
  return v3 | (v4 << 16);
}

void sub_2168A0650(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168A0634);
}

unint64_t tlv::parseV<nas::tlv::LAPSCellInfo_V2>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  unint64_t result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = nas::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), (uint64_t)a3);
  *a1 = result;
  return result;
}

void sub_2168A0698(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
}

uint64_t tlv::parseV<nas::tlv::SimRejectInfo>(unint64_t *a1, int a2)
{
  unsigned int *v3;
  uint64_t result;

  v3 = (unsigned int *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 4uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168A06E4(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168A06D8);
}

uint64_t tlv::parseV<nas::tlv::LTESysInfoEx>(unint64_t *a1, int a2)
{
  unsigned __int16 *v3;
  uint64_t result;

  v3 = (unsigned __int16 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 2uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168A0730(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168A0724);
}

unint64_t tlv::parseV<nas::tlv::LTESysInfo>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  unint64_t result;

  *(_DWORD *)(a3 + 32) = 0;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  result = nas::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), a3);
  *a1 = result;
  return result;
}

void sub_2168A0780(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
}

uint64_t tlv::parseV<dsd::tlv::Downlink>(unint64_t *a1, int a2)
{
  unsigned int *v3;
  uint64_t result;

  v3 = (unsigned int *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 4uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168A07CC(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168A07C0);
}

uint64_t tlv::parseV<dsd::tlv::Uplink>(unint64_t *a1, int a2)
{
  unsigned int *v3;
  uint64_t result;

  v3 = (unsigned int *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 4uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168A0818(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168A080CLL);
}

uint64_t tlv::parseV<dsd::tlv::RAT>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168A0864(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168A0858);
}

unint64_t tlv::size<nas::tlv::GSMHints>(_QWORD *a1)
{
  uint64_t v1;

  v1 = a1[1];
  if (*a1 == v1)
    return 4;
  else
    return 9 * ((v1 - *a1 - 10) / 0xAuLL) + 13;
}

unint64_t tlv::size<nas::tlv::NRHints>(_QWORD *a1)
{
  uint64_t v1;

  v1 = a1[1];
  if (*a1 == v1)
    return 4;
  else
    return 17 * ((v1 - *a1 - 20) / 0x14uLL) + 21;
}

unint64_t tlv::size<nas::tlv::LTEHints_V3>(_QWORD *a1)
{
  uint64_t v1;

  v1 = a1[1];
  if (*a1 == v1)
    return 4;
  else
    return 11 * ((unint64_t)(v1 - *a1 - 16) >> 4) + 15;
}

char *qmi::MutableMessageBase::getTLV<nas::tlv::MessageComplete>(_QWORD *a1)
{
  const void **v2;
  const void **v3;
  char **v4;
  char *v5;
  char *result;
  uint64_t v7;
  unint64_t v8;
  uint64_t *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  v4 = (char **)(a1 + 1);
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != 208)
    {
      if (++v2 == v3)
        goto LABEL_8;
    }
  }
  if (v2 == v3)
  {
LABEL_8:
    v7 = operator new();
    *(_WORD *)(v7 + 8) = 208;
    *(_QWORD *)v7 = &off_24D5D4508;
    v8 = a1[3];
    v9 = (uint64_t *)a1[2];
    if ((unint64_t)v9 >= v8)
    {
      v11 = ((char *)v9 - *v4) >> 3;
      if ((unint64_t)(v11 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v12 = v8 - (_QWORD)*v4;
      v13 = v12 >> 2;
      if (v12 >> 2 <= (unint64_t)(v11 + 1))
        v13 = v11 + 1;
      if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
        v14 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v14 = v13;
      if (v14)
        v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v14);
      else
        v15 = 0;
      v16 = (uint64_t *)&v15[8 * v11];
      v17 = &v15[8 * v14];
      *v16 = v7;
      v10 = v16 + 1;
      v19 = (char *)a1[1];
      v18 = (char *)a1[2];
      if (v18 != v19)
      {
        do
        {
          v20 = *((_QWORD *)v18 - 1);
          v18 -= 8;
          *--v16 = v20;
        }
        while (v18 != v19);
        v18 = *v4;
      }
      a1[1] = v16;
      a1[2] = v10;
      a1[3] = v17;
      if (v18)
        operator delete(v18);
    }
    else
    {
      *v9 = v7;
      v10 = v9 + 1;
    }
    result = (char *)(v7 + 9);
    a1[2] = v10;
  }
  else
  {
    if (!v5)
      __cxa_bad_cast();
    return v5 + 9;
  }
  return result;
}

char *qmi::MutableMessageBase::getTLV<nas::tlv::StatusType>(_QWORD *a1)
{
  const void **v2;
  const void **v3;
  char **v4;
  char *v5;
  char *result;
  uint64_t v7;
  unint64_t v8;
  uint64_t *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  v4 = (char **)(a1 + 1);
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != 194)
    {
      if (++v2 == v3)
        goto LABEL_8;
    }
  }
  if (v2 == v3)
  {
LABEL_8:
    v7 = operator new();
    *(_WORD *)(v7 + 8) = 194;
    *(_QWORD *)v7 = &off_24D5D4CF0;
    v8 = a1[3];
    v9 = (uint64_t *)a1[2];
    if ((unint64_t)v9 >= v8)
    {
      v11 = ((char *)v9 - *v4) >> 3;
      if ((unint64_t)(v11 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v12 = v8 - (_QWORD)*v4;
      v13 = v12 >> 2;
      if (v12 >> 2 <= (unint64_t)(v11 + 1))
        v13 = v11 + 1;
      if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
        v14 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v14 = v13;
      if (v14)
        v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v14);
      else
        v15 = 0;
      v16 = (uint64_t *)&v15[8 * v11];
      v17 = &v15[8 * v14];
      *v16 = v7;
      v10 = v16 + 1;
      v19 = (char *)a1[1];
      v18 = (char *)a1[2];
      if (v18 != v19)
      {
        do
        {
          v20 = *((_QWORD *)v18 - 1);
          v18 -= 8;
          *--v16 = v20;
        }
        while (v18 != v19);
        v18 = *v4;
      }
      a1[1] = v16;
      a1[2] = v10;
      a1[3] = v17;
      if (v18)
        operator delete(v18);
    }
    else
    {
      *v9 = v7;
      v10 = v9 + 1;
    }
    result = (char *)(v7 + 9);
    a1[2] = v10;
  }
  else
  {
    if (!v5)
      __cxa_bad_cast();
    return v5 + 9;
  }
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::UMTSHints>::~TlvWrapper(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24D5D4E30;
  v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  JUMPOUT(0x2199FEAC4);
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::HintType>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::GSMHints>::~TlvWrapper(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24D5D4DE0;
  v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  JUMPOUT(0x2199FEAC4);
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::NRHints>::~TlvWrapper(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24D5D4F20;
  v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  JUMPOUT(0x2199FEAC4);
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::IsBootstrapDatabase>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::MessageComplete>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::LTEHints_V3>::~TlvWrapper(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24D5D4E80;
  v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  JUMPOUT(0x2199FEAC4);
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::StatusType>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::BorderInfo>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::ClientRouter::SendProxy::SendProxy<nas::FrequencyHints::Request>(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v5;

  *(_DWORD *)a1 = a2;
  v5 = operator new();
  *(_QWORD *)v5 = a3;
  *(_QWORD *)(v5 + 8) = QMIServiceMsg::create();
  *(_DWORD *)(v5 + 16) = 25000;
  *(_QWORD *)(v5 + 24) = 0;
  *(_QWORD *)(v5 + 32) = 0;
  *(_QWORD *)(a1 + 8) = v5;
  return a1;
}

void sub_2168A0DFC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199FEAC4](v1, 0x10F0C401BA14CC5);
  _Unwind_Resume(a1);
}

qmi::MessageBase *qmi::Indication<(unsigned short)78,nas::SysInfo::IndicationTLVList>::Indication(qmi::MessageBase *a1, const void *a2)
{
  qmi::MessageBase *v3;

  v3 = (qmi::MessageBase *)qmi::MessageBase::MessageBase(a1, a2);
  qmi::MessageBase::validateMsgId(v3);
  return a1;
}

void sub_2168A0E4C(_Unwind_Exception *a1)
{
  qmi::MessageBase *v1;

  qmi::MessageBase::~MessageBase(v1);
  _Unwind_Resume(a1);
}

_BYTE *nas::tlv::writeField(_BYTE *a1, _DWORD *a2)
{
  _BYTE *result;
  uint64_t v3;
  uint64_t v4;

  *a1 = -51 * ((a2[2] - *a2) >> 1);
  result = a1 + 1;
  v3 = *(_QWORD *)a2;
  v4 = *((_QWORD *)a2 + 1);
  while (v3 != v4)
  {
    *(_WORD *)result = *(_WORD *)v3;
    *((_WORD *)result + 1) = *(_WORD *)(v3 + 2);
    result[4] = *(_BYTE *)(v3 + 4);
    *(_WORD *)(result + 5) = *(_WORD *)(v3 + 6);
    *(_WORD *)(result + 7) = *(_WORD *)(v3 + 8);
    result += 9;
    v3 += 10;
  }
  return result;
}

{
  _BYTE *result;
  uint64_t v3;
  uint64_t v4;

  *a1 = -51 * ((a2[2] - *a2) >> 2);
  result = a1 + 1;
  v3 = *(_QWORD *)a2;
  v4 = *((_QWORD *)a2 + 1);
  while (v3 != v4)
  {
    *(_WORD *)result = *(_WORD *)v3;
    *((_WORD *)result + 1) = *(_WORD *)(v3 + 2);
    *((_WORD *)result + 2) = *(_WORD *)(v3 + 4);
    *(_DWORD *)(result + 6) = *(_DWORD *)(v3 + 8);
    *((_WORD *)result + 5) = *(_WORD *)(v3 + 12);
    result[12] = *(_BYTE *)(v3 + 14);
    *(_DWORD *)(result + 13) = *(_DWORD *)(v3 + 16);
    result += 17;
    v3 += 20;
  }
  return result;
}

{
  _BYTE *v2;
  uint64_t v3;
  uint64_t v4;
  _BYTE *v5;

  *a1 = (a2[2] - *a2) >> 4;
  v2 = a1 + 1;
  v3 = *(_QWORD *)a2;
  v4 = *((_QWORD *)a2 + 1);
  if (*(_QWORD *)a2 == v4)
    return v2;
  do
  {
    *(_WORD *)v2 = *(_WORD *)v3;
    *((_WORD *)v2 + 1) = *(_WORD *)(v3 + 2);
    v2[4] = *(_BYTE *)(v3 + 4);
    *(_DWORD *)(v2 + 5) = *(_DWORD *)(v3 + 8);
    v2[9] = *(_BYTE *)(v3 + 12);
    v5 = v2 + 11;
    v2[10] = *(_BYTE *)(v3 + 13);
    v3 += 16;
    v2 += 11;
  }
  while (v3 != v4);
  return v5;
}

{
  _BYTE *result;
  uint64_t v3;
  uint64_t v4;

  *a1 = (a2[2] - *a2) >> 3;
  result = a1 + 1;
  v3 = *(_QWORD *)a2;
  v4 = *((_QWORD *)a2 + 1);
  while (v3 != v4)
  {
    *result = *(_BYTE *)v3;
    *(_WORD *)(result + 1) = *(_WORD *)(v3 + 2);
    *(_WORD *)(result + 3) = *(_WORD *)(v3 + 4);
    *(_WORD *)(result + 5) = *(_WORD *)(v3 + 6);
    result += 7;
    v3 += 8;
  }
  return result;
}

{
  _BYTE *result;
  uint64_t v3;
  uint64_t v4;
  _BYTE *v5;

  *a1 = (a2[2] - *a2) >> 5;
  result = a1 + 1;
  v3 = *(_QWORD *)a2;
  v4 = *((_QWORD *)a2 + 1);
  while (v3 != v4)
  {
    *result = *(_BYTE *)v3;
    *(_WORD *)(result + 1) = *(_WORD *)(v3 + 2);
    v5 = result + 4;
    result[3] = *(_DWORD *)(v3 + 16) - *(_DWORD *)(v3 + 8);
    memcpy(result + 4, *(const void **)(v3 + 8), *(_QWORD *)(v3 + 16) - *(_QWORD *)(v3 + 8));
    result = &v5[*(_QWORD *)(v3 + 16) - *(_QWORD *)(v3 + 8)];
    v3 += 32;
  }
  return result;
}

{
  _BYTE *v2;
  uint64_t v3;
  uint64_t v4;
  _BYTE *v5;

  *a1 = (a2[2] - *a2) >> 3;
  v2 = a1 + 1;
  v3 = *(_QWORD *)a2;
  v4 = *((_QWORD *)a2 + 1);
  if (*(_QWORD *)a2 == v4)
    return v2;
  do
  {
    *(_WORD *)v2 = *(_WORD *)v3;
    *((_WORD *)v2 + 1) = *(_WORD *)(v3 + 2);
    v2[4] = *(_BYTE *)(v3 + 4);
    v2[5] = *(_BYTE *)(v3 + 5);
    v5 = v2 + 7;
    v2[6] = *(_BYTE *)(v3 + 6);
    v3 += 8;
    v2 += 7;
  }
  while (v3 != v4);
  return v5;
}

_BYTE *nas::tlv::parseField(_BYTE *a1, const unsigned __int8 *a2, _BYTE *a3)
{
  _BYTE *result;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  *a3 = *a1;
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 1), a2, 1uLL);
  a3[1] = a1[1];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 2), a2, 1uLL);
  result = a1 + 3;
  a3[2] = a1[2] != 0;
  return result;
}

{
  _BYTE *result;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  *a3 = *a1;
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 1), a2, 1uLL);
  a3[1] = a1[1];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 2), a2, 1uLL);
  a3[2] = a1[2];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 3), a2, 1uLL);
  result = a1 + 4;
  a3[3] = a1[3];
  return result;
}

const char *dsd::asString(unsigned int a1)
{
  if (a1 > 0xC)
    return "???";
  else
    return off_24D5C2A58[(char)a1];
}

{
  if (a1 > 2)
    return "???";
  else
    return off_24D5C2A40[a1];
}

void QMINetworkRegistrationDriver::processSystemInfo_sync(uint64_t a1, unsigned int a2, unsigned __int8 *a3)
{
  os_log_t *v4;
  int v5;
  uint64_t v6;
  int v7;
  BOOL v8;
  _BOOL4 v9;
  unsigned int v10;
  NSObject *v11;
  int v12;
  int v13;
  os_log_t *v14;
  NSObject **v15;
  NSObject *v16;
  int IntValue;
  NSObject *v18;
  int v19;
  uint64_t **v20;
  uint64_t **v21;
  uint64_t **v22;
  NSObject *v23;
  int v24;
  int IntegerWidth;
  int v26;
  uint64_t v27;
  int v28;
  BOOL v29;
  _BOOL4 v30;
  unsigned int v31;
  NSObject *v32;
  int v33;
  int v34;
  BOOL v35;
  _BOOL4 v36;
  char v37;
  NSObject *v38;
  uint64_t **v39;
  BOOL v40;
  char v41;
  int v42;
  BOOL v43;
  _BOOL4 v44;
  char v45;
  NSObject *v46;
  uint64_t **v47;
  BOOL v48;
  char v49;
  int v50;
  BOOL v51;
  _BOOL4 v52;
  char v53;
  NSObject *v54;
  uint64_t **v55;
  BOOL v56;
  char v57;
  char v58;
  BOOL v59;
  _BOOL4 v60;
  NSObject *v61;
  uint64_t **v62;
  BOOL v63;
  char v64;
  capabilities::ct *v65;
  char v66;
  BOOL v67;
  _BOOL4 v68;
  NSObject *v69;
  uint64_t **v70;
  BOOL v71;
  char v72;
  NSObject *v73;
  NSObject *v74;
  uint64_t v75;
  int v76;
  NSObject *v77;
  uint64_t v78;
  uint64_t v79;
  NSObject *v80;
  uint64_t v81;
  NSObject *v82;
  uint64_t v83;
  uint64_t v84;
  uint8_t *v85;
  uint64_t v86;
  capabilities::ct *v87;
  uint64_t **v88;
  __int16 v89;
  uint64_t **v90;
  int v91;
  unsigned int v92;
  uint64_t **v93;
  uint64_t **v94;
  std::mutex *ServiceMap;
  _BOOL4 v96;
  std::__shared_weak_count *v97;
  unint64_t *v98;
  unint64_t v99;
  int v100;
  int v101;
  unsigned int v102;
  uint64_t v103;
  uint64_t **v104;
  uint64_t **v105;
  std::mutex *v106;
  _BOOL4 v107;
  std::__shared_weak_count *v108;
  unint64_t *v109;
  unint64_t v110;
  char *v111;
  int v112;
  unint64_t v113;
  unsigned int v114;
  uint64_t v115;
  uint64_t **v116;
  uint64_t **v117;
  char *v118;
  int v119;
  unint64_t v120;
  int v121;
  int v122;
  uint64_t **v123;
  uint8_t *v124;
  uint64_t v125;
  uint64_t **v126;
  os_log_t *v127;
  NSObject *v128;
  uint64_t v129;
  int v130;
  uint64_t *v131;
  NSObject *v132;
  uint64_t v133;
  int v134;
  int v135;
  uint64_t **v136;
  uint64_t **v137;
  NSObject *v138;
  uint64_t v139;
  int v140;
  int v141;
  int v142;
  NSObject *v143;
  uint64_t v144;
  int v145;
  uint64_t *v146;
  NSObject *v147;
  uint64_t v148;
  int v149;
  int v150;
  uint64_t **v151;
  uint64_t **v152;
  NSObject *v153;
  uint64_t v154;
  int v155;
  int v156;
  int v157;
  NSObject *v158;
  uint64_t v159;
  int v160;
  uint64_t *v161;
  NSObject *v162;
  uint64_t v163;
  int v164;
  int v165;
  uint64_t **v166;
  uint64_t **v167;
  NSObject *v168;
  uint64_t v169;
  int v170;
  int v171;
  int v172;
  NSObject *v173;
  int v174;
  int v175;
  NSObject *v176;
  uint64_t v177;
  int v178;
  uint64_t **v179;
  uint64_t *v180;
  NSObject *v181;
  uint64_t v182;
  int v183;
  uint64_t **v184;
  int v185;
  uint64_t **v186;
  uint64_t **v187;
  NSObject *v188;
  uint64_t v189;
  int v190;
  int v191;
  int v192;
  int v193;
  int v194;
  int v195;
  uint64_t **v196;
  int v197;
  NSObject *v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t **v201;
  uint64_t *v202;
  NSObject *v203;
  NSObject *v204;
  uint64_t v205;
  int v206;
  uint64_t **v207;
  uint64_t *v208;
  NSObject *v209;
  uint64_t v210;
  int v211;
  uint64_t **v212;
  int v213;
  uint64_t **v214;
  uint64_t **v215;
  NSObject *v216;
  uint64_t v217;
  int v218;
  int v219;
  int v220;
  uint64_t v221;
  char *v222;
  void *v223;
  int64_t v224;
  unint64_t v225;
  unint64_t v226;
  uint64_t v227;
  _DWORD *v228;
  unint64_t v229;
  _BYTE *v230;
  _BYTE *v231;
  int v232;
  char v233;
  uint64_t v234;
  char *v235;
  void *v236;
  int64_t v237;
  unint64_t v238;
  unint64_t v239;
  uint64_t v240;
  _DWORD *v241;
  unint64_t v242;
  _BYTE *v243;
  _BYTE *v244;
  int v245;
  char v246;
  uint64_t v247;
  uint64_t v248;
  uint64_t v249;
  capabilities::ct *v250;
  NSObject **v251;
  BOOL v252;
  uint8_t v253;
  int v254;
  uint8_t v255;
  uint8_t v256;
  uint8_t v257;
  uint8_t v258;
  uint8_t v259;
  int v260;
  const void **v261;
  const __CFBoolean *v262;
  uint64_t (*v263)(uint64_t);
  NSObject *v264;
  uint64_t v265;
  int v266;
  int v267;
  uint8_t v268;
  BOOL v269;
  uint8_t v270;
  uint8_t v271;
  BOOL v272;
  BOOL v273;
  char v274;
  unsigned __int8 v275;
  BOOL v276;
  uint64_t v277;
  uint64_t v278;
  _OWORD *v279;
  uint64_t **v280;
  uint64_t *v281;
  uint64_t **v282;
  int v283;
  uint64_t **v284;
  uint64_t **v285;
  uint64_t *v286;
  int v287;
  _DWORD *v288;
  uint64_t v289;
  uint64_t v290;
  _QWORD *v291;
  _OWORD *v292;
  _OWORD *v293;
  uint64_t **v294;
  uint64_t *v295;
  uint64_t **v296;
  int v297;
  uint64_t **v298;
  uint64_t **v299;
  uint64_t *v300;
  int v301;
  char *v302;
  __int128 v303;
  _QWORD *v304;
  _OWORD *v305;
  const void *v306;
  int64_t v307;
  char *v308;
  uint64_t v309;
  int v310;
  char v313[8];
  void *v314;
  char v315;
  uint8_t v316[8];
  void *v317;
  char v318;
  char v319[8];
  void *v320;
  char v321;
  uint8_t v322[8];
  void *v323;
  char v324;
  char v325[8];
  void *v326;
  char v327;
  uint8_t v328[8];
  void *v329;
  char v330;
  char v331[8];
  void *v332;
  char v333;
  uint8_t v334[2];
  char v335;
  void *v336;
  char v337;
  __int16 v338;
  char v339;
  void *__p;
  char v341;
  void *v342[2];
  __int128 v343;
  char v344[8];
  uint64_t **v345;
  uint64_t *v346;
  uint64_t v347;
  char v348;
  __int128 v349;
  __int128 v350;
  _BYTE v351[19];
  uint64_t **v352;
  uint64_t *v353;
  uint64_t v354;
  char v355;
  void *v356;
  char *v357;
  char *v358;
  char v359;
  __int16 v360;
  __int128 v361;
  _OWORD v362[5];
  __int128 v363;
  __int128 v364;
  void *v365[2];
  __int128 v366;
  uint64_t v367;
  uint8_t v368[4];
  uint64_t v369;
  __int16 v370;
  uint64_t v371;
  uint8_t v372[32];
  uint8_t buf[33];
  __int16 v374;
  char v375;
  BOOL v376;
  __int16 v377;
  char v378;
  uint8_t v379;
  __int16 v380;
  char v381;
  char v382;
  unsigned __int8 v383;
  __int16 v384;
  char v385;
  uint8_t v386[16];
  __int128 v387;
  uint64_t v388;

  v388 = *MEMORY[0x24BDAC8D0];
  if (a3[514])
    return;
  v367 = 0;
  *(_OWORD *)v365 = 0u;
  v366 = 0u;
  v363 = 0u;
  v364 = 0u;
  v361 = 0u;
  memset(v362, 0, sizeof(v362));
  LOBYTE(v361) = a3[528];
  v4 = (os_log_t *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 88) + 16))(*(_QWORD *)(a1 + 88));
  if (a3[400])
    v5 = *((_DWORD *)a3 + 99);
  else
    v5 = 0;
  memset(v372, 0, sizeof(v372));
  MCC::MCC((MCC *)v372);
  *(_OWORD *)v342 = 0u;
  v343 = 0u;
  MNC::MNC((MNC *)v342);
  v7 = 1;
  if (a3[2] && a3[76])
  {
    v8 = !a3[34] || a3[35] == 0;
    v9 = !v8;
    v6 = translateToNasRegistrationState(3, *a3, v5, v9);
    if ((_DWORD)v6 != -1)
    {
      v10 = v6;
      v11 = *v4;
      if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_216897000, v11, OS_LOG_TYPE_DEFAULT, "#I 1x system is present, processing it", buf, 2u);
        v12 = a3[2];
        v13 = a3[76];
      }
      else
      {
        v13 = 1;
        v12 = 1;
      }
      if (v12 && v13 && a3[68] && *a3 - 1 <= 2)
        convertMccAndMnc(a3 + 69, a3 + 72, (const MCC *)v372, (const MNC *)v342);
      v14 = (os_log_t *)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 88) + 16))(*(_QWORD *)(a1 + 88), a2);
      if (!a3[2])
        std::__throw_bad_optional_access[abi:ne180100]();
      if (*a3 - 1 <= 2)
      {
        v15 = v14;
        if (a3[408])
        {
          memset(buf, 0, 32);
          MEMORY[0x2199FDEAC](buf, *((unsigned __int16 *)a3 + 203));
          v16 = *v15;
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
          {
            IntValue = MCC::getIntValue((MCC *)buf);
            *(_DWORD *)v386 = 67109120;
            *(_DWORD *)&v386[4] = IntValue;
            _os_log_impl(&dword_216897000, v16, OS_LOG_TYPE_DEFAULT, "#I Baseband is sending CDMA derived MCC with %03d", v386, 8u);
          }
          if (MCC::valid((MCC *)buf))
          {
            MCC::operator=();
          }
          else
          {
            MEMORY[0x2199FDEAC](v386, 1023);
            MCC::operator=();
            if (SHIBYTE(v387) < 0)
              operator delete(*(void **)&v386[8]);
          }
        }
        else
        {
          v18 = *v14;
          if (os_log_type_enabled(*v14, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl(&dword_216897000, v18, OS_LOG_TYPE_DEFAULT, "#N CDMA service status and sys info is present, but there is no Derived MCC information", buf, 2u);
          }
          MEMORY[0x2199FDEAC](buf, 1023);
          MCC::operator=();
        }
        if ((char)buf[31] < 0)
          operator delete(*(void **)&buf[8]);
      }
      v19 = mapToRegStatus(v4, v10);
      v20 = ServingSystem::ratSystem((uint64_t)&v361, 3);
      *(_DWORD *)v20 = v19;
      *((_BYTE *)v20 + 4) = 1;
      v21 = ServingSystem::ratSystem((uint64_t)&v361, 3);
      std::optional<MCC>::operator=[abi:ne180100]<MCC&,void>((uint64_t)(v21 + 2));
      v22 = ServingSystem::ratSystem((uint64_t)&v361, 3);
      std::optional<MNC>::operator=[abi:ne180100]<MNC&,void>((MCC *)(v22 + 7), (const MCC *)v342);
      v23 = *v4;
      v6 = os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT);
      v7 = 0;
      if ((_DWORD)v6)
      {
        v24 = MCC::getIntValue((MCC *)v372);
        IntegerWidth = MNC::getIntegerWidth((MNC *)v342);
        v26 = MCC::getIntValue((MCC *)v342);
        if (!*((_BYTE *)ServingSystem::ratSystem((uint64_t)&v361, 3) + 4))
          std::__throw_bad_optional_access[abi:ne180100]();
        v27 = asString();
        *(_DWORD *)buf = 67109890;
        *(_DWORD *)&buf[4] = v24;
        *(_WORD *)&buf[8] = 1024;
        *(_DWORD *)&buf[10] = IntegerWidth;
        *(_WORD *)&buf[14] = 1024;
        *(_DWORD *)&buf[16] = v26;
        *(_WORD *)&buf[20] = 2080;
        *(_QWORD *)&buf[22] = v27;
        _os_log_impl(&dword_216897000, v23, OS_LOG_TYPE_DEFAULT, "#I 1x serving system: MCC: %d MNC: %0.*d Registration Status: %s", buf, 0x1Eu);
        v7 = 0;
      }
    }
  }
  v28 = 1;
  if (a3[5] && a3[111])
  {
    v29 = !a3[86] || a3[87] == 0;
    v30 = !v29;
    v6 = translateToNasRegistrationState(4, a3[3], v5, v30);
    if ((_DWORD)v6 != -1)
    {
      v31 = v6;
      v32 = *v4;
      if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_216897000, v32, OS_LOG_TYPE_DEFAULT, "#I HDR system is present, processing it", buf, 2u);
      }
      v33 = mapToRegStatus(v4, v31);
      v6 = (uint64_t)ServingSystem::ratSystem((uint64_t)&v361, 4);
      v28 = 0;
      *(_DWORD *)v6 = v33;
      *(_BYTE *)(v6 + 4) = 1;
    }
  }
  *(_QWORD *)buf = &off_24D5E9900;
  *(_QWORD *)&buf[8] = v4;
  *(_QWORD *)&buf[16] = 0;
  *(_QWORD *)&buf[24] = buf;
  v34 = 1;
  if (a3[9] && a3[148])
  {
    v35 = !a3[118] || a3[119] == 0;
    v36 = !v35;
    v6 = translateToNasRegistrationState(0, a3[6], v5, v36);
    if ((_DWORD)v6 != -1)
    {
      v37 = v6;
      v38 = *v4;
      if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)v386 = 0;
        _os_log_impl(&dword_216897000, v38, OS_LOG_TYPE_DEFAULT, "#I GSM system is present, processing it", v386, 2u);
      }
      v39 = ServingSystem::ratSystem((uint64_t)&v361, 0);
      if (a3[9] && a3[148] && a3[135] && a3[6] - 1 <= 2)
        convertMccAndMnc(a3 + 136, a3 + 139, (const MCC *)v372, (const MNC *)v342);
      MCC::MCC();
      MCC::MCC((MCC *)&v338, (const MCC *)v342);
      if (!a3[148])
        std::__throw_bad_optional_access[abi:ne180100]();
      if (a3[116])
        v40 = a3[117] == 0;
      else
        v40 = 1;
      v41 = !v40;
      v6 = std::function<void ()(ServingSystem::System &,nas::NasRegistrationState,MCC,MNC,BOOL)>::operator()(*(uint64_t *)&buf[24], (uint64_t)v39, v37, (uint64_t)v386, (uint64_t)&v338, v41);
      if (v341 < 0)
        operator delete(__p);
      if (SHIBYTE(v387) < 0)
        operator delete(*(void **)&v386[8]);
      v34 = 0;
    }
  }
  v42 = 1;
  if (a3[13] && a3[192])
  {
    v43 = !a3[158] || a3[159] == 0;
    v44 = !v43;
    v6 = translateToNasRegistrationState(2, a3[10], v5, v44);
    if ((_DWORD)v6 != -1)
    {
      v45 = v6;
      v46 = *v4;
      if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)v334 = 0;
        _os_log_impl(&dword_216897000, v46, OS_LOG_TYPE_DEFAULT, "#I WCDMA system is present, processing it", v334, 2u);
      }
      v47 = ServingSystem::ratSystem((uint64_t)&v361, 2);
      if (a3[13] && a3[192] && a3[175] && a3[10] - 1 <= 2)
        convertMccAndMnc(a3 + 176, a3 + 179, (const MCC *)v372, (const MNC *)v342);
      MCC::MCC();
      MCC::MCC((MCC *)v331, (const MCC *)v342);
      if (!a3[192])
        std::__throw_bad_optional_access[abi:ne180100]();
      if (a3[156])
        v48 = a3[157] == 0;
      else
        v48 = 1;
      v49 = !v48;
      v6 = std::function<void ()(ServingSystem::System &,nas::NasRegistrationState,MCC,MNC,BOOL)>::operator()(*(uint64_t *)&buf[24], (uint64_t)v47, v45, (uint64_t)v334, (uint64_t)v331, v49);
      if (v333 < 0)
        operator delete(v332);
      if (v337 < 0)
        operator delete(v336);
      v42 = 0;
    }
  }
  v50 = 1;
  if (a3[17] && a3[232])
  {
    v51 = !a3[202] || a3[203] == 0;
    v52 = !v51;
    v6 = translateToNasRegistrationState(7, a3[14], v5, v52);
    if ((_DWORD)v6 != -1)
    {
      v53 = v6;
      v54 = *v4;
      if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)v328 = 0;
        _os_log_impl(&dword_216897000, v54, OS_LOG_TYPE_DEFAULT, "#I LTE system is present, processing it", v328, 2u);
      }
      v55 = ServingSystem::ratSystem((uint64_t)&v361, 7);
      if (a3[17] && a3[232] && a3[219] && a3[14] - 1 <= 2)
        convertMccAndMnc(a3 + 220, a3 + 223, (const MCC *)v372, (const MNC *)v342);
      MCC::MCC();
      MCC::MCC((MCC *)v325, (const MCC *)v342);
      if (!a3[232])
        std::__throw_bad_optional_access[abi:ne180100]();
      if (a3[200])
        v56 = a3[201] == 0;
      else
        v56 = 1;
      v57 = !v56;
      v6 = std::function<void ()(ServingSystem::System &,nas::NasRegistrationState,MCC,MNC,BOOL)>::operator()(*(uint64_t *)&buf[24], (uint64_t)v55, v53, (uint64_t)v328, (uint64_t)v325, v57);
      if (v327 < 0)
        operator delete(v326);
      if (v330 < 0)
        operator delete(v329);
      v50 = 0;
    }
  }
  v58 = -1;
  if (a3[21] && a3[304])
  {
    v59 = !a3[246] || a3[247] == 0;
    v60 = !v59;
    v6 = translateToNasRegistrationState(9, a3[18], v5, v60);
    if ((_DWORD)v6 != -1)
    {
      v58 = v6;
      v61 = *v4;
      if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)v322 = 0;
        _os_log_impl(&dword_216897000, v61, OS_LOG_TYPE_DEFAULT, "#I TDSCDMA system is present, processing it", v322, 2u);
      }
      v62 = ServingSystem::ratSystem((uint64_t)&v361, 9);
      if (a3[21] && a3[304] && a3[263] && a3[18] - 1 <= 2)
        convertMccAndMnc(a3 + 264, a3 + 267, (const MCC *)v372, (const MNC *)v342);
      MCC::MCC();
      MCC::MCC((MCC *)v319, (const MCC *)v342);
      if (!a3[304])
        std::__throw_bad_optional_access[abi:ne180100]();
      if (a3[244])
        v63 = a3[245] == 0;
      else
        v63 = 1;
      v64 = !v63;
      v6 = std::function<void ()(ServingSystem::System &,nas::NasRegistrationState,MCC,MNC,BOOL)>::operator()(*(uint64_t *)&buf[24], (uint64_t)v62, v58, (uint64_t)v322, (uint64_t)v319, v64);
      if (v321 < 0)
        operator delete(v320);
      if (v324 < 0)
        operator delete(v323);
    }
  }
  v65 = (capabilities::ct *)capabilities::ct::supports5G((capabilities::ct *)v6);
  if ((_DWORD)v65)
  {
    v66 = -1;
    if (a3[25] && a3[348])
    {
      v67 = !a3[318] || a3[319] == 0;
      v68 = !v67;
      v65 = (capabilities::ct *)translateToNasRegistrationState(10, a3[22], v5, v68);
      if ((_DWORD)v65 != -1)
      {
        v66 = (char)v65;
        v310 = v7;
        v69 = *v4;
        if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)v316 = 0;
          _os_log_impl(&dword_216897000, v69, OS_LOG_TYPE_DEFAULT, "#I NR system is present, processing it", v316, 2u);
        }
        v70 = ServingSystem::ratSystem((uint64_t)&v361, 10);
        if (a3[25] && a3[348] && a3[335] && a3[22] - 1 <= 2)
          convertMccAndMnc(a3 + 336, a3 + 339, (const MCC *)v372, (const MNC *)v342);
        MCC::MCC();
        MCC::MCC((MCC *)v313, (const MCC *)v342);
        if (!a3[348])
          std::__throw_bad_optional_access[abi:ne180100]();
        if (a3[316])
          v71 = a3[317] == 0;
        else
          v71 = 1;
        v72 = !v71;
        v65 = (capabilities::ct *)std::function<void ()(ServingSystem::System &,nas::NasRegistrationState,MCC,MNC,BOOL)>::operator()(*(uint64_t *)&buf[24], (uint64_t)v70, v66, (uint64_t)v316, (uint64_t)v313, v72);
        v7 = v310;
        if (v315 < 0)
          operator delete(v314);
        if (v318 < 0)
          operator delete(v317);
      }
    }
  }
  else
  {
    v66 = -1;
  }
  if ((v7 & v28 & v34 & v42 & v50) == 1 && (v66 & v58) == -1)
  {
    if (v5 == 4 || v5 == 2)
    {
      v73 = *v4;
      if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)v368 = 0;
        _os_log_impl(&dword_216897000, v73, OS_LOG_TYPE_DEFAULT, "#I There is no serving system for the device, CS and PS are both invalid, marking the status as denied", v368, 2u);
      }
      v65 = (capabilities::ct *)mapToRegStatus(v4, 3u);
    }
    else
    {
      v74 = *v4;
      if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)v368 = 0;
        _os_log_impl(&dword_216897000, v74, OS_LOG_TYPE_DEFAULT, "#I There is no serving system for the device, marking the status as not registered", v368, 2u);
      }
      v65 = (capabilities::ct *)mapToRegStatus(v4, 0);
    }
    DWORD2(v362[1]) = (_DWORD)v65;
    BYTE12(v362[1]) = 1;
  }
  v75 = capabilities::ct::supports5G(v65);
  if (a3[475])
    v76 = v75;
  else
    v76 = 0;
  if (v76 == 1)
  {
    LOWORD(v362[2]) = a3[474] | 0x100;
    v77 = *v4;
    v75 = os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT);
    if ((_DWORD)v75)
    {
      v78 = asStringBool();
      *(_DWORD *)v368 = 136315138;
      v369 = v78;
      _os_log_impl(&dword_216897000, v77, OS_LOG_TYPE_DEFAULT, "#I Voice over CS status: %s", v368, 0xCu);
    }
  }
  if (a3[477])
    WORD1(v362[2]) = a3[476] | 0x100;
  if (capabilities::ct::supportsStewie((capabilities::ct *)v75) && a3[473] && a3[472])
  {
    if (MCC::valid((MCC *)v372))
      v79 = MCC::valid((MCC *)v342);
    else
      v79 = 0;
    v80 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
    {
      v81 = asStringBool();
      *(_DWORD *)v368 = 136315138;
      v369 = v81;
      _os_log_impl(&dword_216897000, v80, OS_LOG_TYPE_DEFAULT, "#I Scan completion result: %s", v368, 0xCu);
    }
    if ((_DWORD)v79)
    {
      v79 = 1;
      if (BYTE3(v362[2]))
      {
        if (BYTE2(v362[2]))
        {
          if (a3[416])
          {
            v79 = *((_DWORD *)a3 + 103) == 1;
            v82 = *v4;
            if (os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT))
            {
              v83 = asString();
              v84 = asStringBool();
              *(_DWORD *)v368 = 136315394;
              v369 = v83;
              v370 = 2080;
              v371 = v84;
              _os_log_impl(&dword_216897000, v82, OS_LOG_TYPE_DEFAULT, "#I On Sat system with emergency bearer support: %s, updated scan completion result to: %s", v368, 0x16u);
            }
          }
        }
      }
    }
    (*(void (**)(_QWORD, _QWORD, uint64_t))(**(_QWORD **)(a1 + 64) + 72))(*(_QWORD *)(a1 + 64), a2, v79);
  }
  v85 = *(uint8_t **)&buf[24];
  if (*(uint8_t **)&buf[24] == buf)
  {
    v86 = 4;
    v85 = buf;
  }
  else
  {
    if (!*(_QWORD *)&buf[24])
      goto LABEL_230;
    v86 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v85 + 8 * v86))();
LABEL_230:
  if (SHIBYTE(v343) < 0)
    operator delete(v342[1]);
  if ((char)v372[31] < 0)
    operator delete(*(void **)&v372[8]);
  v87 = (capabilities::ct *)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 88) + 16))(*(_QWORD *)(a1 + 88), a2);
  *(_QWORD *)buf = &off_24D5E9990;
  *(_QWORD *)&buf[8] = v87;
  *(_QWORD *)&buf[16] = 0;
  *(_QWORD *)&buf[24] = buf;
  if (a3[2] && a3[76])
  {
    v88 = ServingSystem::ratSystem((uint64_t)&v361, 3);
    if (a3[28])
    {
      v89 = ((a3[29] & 0xFB) != 0) | 0x100;
      *((_WORD *)v88 + 4) = v89;
      *((_WORD *)v88 + 5) = v89;
    }
    *((_DWORD *)v88 + 24) = 10;
    *((_BYTE *)v88 + 100) = 1;
    if (!*(_QWORD *)&buf[24])
      std::__throw_bad_function_call[abi:ne180100]();
    v87 = (capabilities::ct *)(*(uint64_t (**)(_QWORD, uint64_t **))(**(_QWORD **)&buf[24] + 48))(*(_QWORD *)&buf[24], v88);
  }
  if (a3[5] && a3[111])
  {
    v90 = ServingSystem::ratSystem((uint64_t)&v361, 4);
    if (a3[80])
      *((_WORD *)v90 + 5) = ((a3[81] & 0xFE) == 2) | 0x100;
    v91 = a3[90];
    if (a3[90])
    {
      if (a3[91] == 3)
      {
        v91 = 13;
      }
      else
      {
        v91 = a3[92];
        if (a3[92])
        {
          v92 = a3[93] - 2;
          if (v92 > 2)
            v91 = 0;
          else
            v91 = dword_216AC1044[(char)v92];
        }
      }
    }
    *((_DWORD *)v90 + 24) = v91;
    *((_BYTE *)v90 + 100) = 1;
    if (!*(_QWORD *)&buf[24])
      std::__throw_bad_function_call[abi:ne180100]();
    v87 = (capabilities::ct *)(*(uint64_t (**)(_QWORD, uint64_t **))(**(_QWORD **)&buf[24] + 48))(*(_QWORD *)&buf[24], v90);
  }
  if (a3[9] && a3[148])
  {
    v93 = ServingSystem::ratSystem((uint64_t)&v361, 0);
    v94 = v93;
    if (a3[112])
    {
      *((_WORD *)v93 + 4) = ((a3[113] & 0xFD) == 1) | 0x100;
      *((_WORD *)v93 + 5) = ((a3[113] & 0xFE) == 2) | 0x100;
    }
    if (capabilities::ct::supportsGemini((capabilities::ct *)v93)
      && (!*((_BYTE *)v94 + 11) || !*((_BYTE *)v94 + 10))
      && (!a3[400] || (*((_DWORD *)a3 + 99) - 3) >= 2)
      && a3[114]
      && (a3[115] & 0xFE) == 2)
    {
      memset(v386, 0, sizeof(v386));
      ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
      ctu::shared_ptr_map_impl<ctu::indexed_by_any_map_hashing_key>::get<DataServiceInterface>(ServiceMap, v386);
      if (*(_QWORD *)v386)
        v96 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)v386 + 760))(*(_QWORD *)v386) != a2;
      else
        v96 = 0;
      v97 = *(std::__shared_weak_count **)&v386[8];
      if (*(_QWORD *)&v386[8])
      {
        v98 = (unint64_t *)(*(_QWORD *)&v386[8] + 8);
        do
          v99 = __ldaxr(v98);
        while (__stlxr(v99 - 1, v98));
        if (!v99)
        {
          ((void (*)(std::__shared_weak_count *))v97->__on_zero_shared)(v97);
          std::__shared_weak_count::__release_weak(v97);
        }
      }
      if (v96)
        *((_WORD *)v94 + 5) = 257;
    }
    if (a3[143])
      v100 = 2;
    else
      v100 = 1;
    if (a3[142])
      v101 = v100;
    else
      v101 = 0;
    *((_DWORD *)v94 + 24) = v101;
    *((_BYTE *)v94 + 100) = 1;
    if (a3[511])
    {
      v102 = a3[510];
      if (v102 < 4)
        v103 = v102 + 1;
      else
        v103 = 0;
      (*(void (**)(_QWORD, _QWORD, uint64_t))(**(_QWORD **)(a1 + 64) + 192))(*(_QWORD *)(a1 + 64), a2, v103);
    }
    if (!*(_QWORD *)&buf[24])
      std::__throw_bad_function_call[abi:ne180100]();
    v87 = (capabilities::ct *)(*(uint64_t (**)(_QWORD, uint64_t **))(**(_QWORD **)&buf[24] + 48))(*(_QWORD *)&buf[24], v94);
  }
  if (a3[13] && a3[192])
  {
    v104 = ServingSystem::ratSystem((uint64_t)&v361, 2);
    v105 = v104;
    if (a3[152])
    {
      *((_WORD *)v104 + 4) = ((a3[153] & 0xFD) == 1) | 0x100;
      *((_WORD *)v104 + 5) = ((a3[153] & 0xFE) == 2) | 0x100;
    }
    if (capabilities::ct::supportsGemini((capabilities::ct *)v104)
      && (!*((_BYTE *)v105 + 11) || !*((_BYTE *)v105 + 10))
      && (!a3[400] || (*((_DWORD *)a3 + 99) - 3) >= 2)
      && a3[154]
      && (a3[155] & 0xFE) == 2)
    {
      memset(v386, 0, sizeof(v386));
      v106 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
      ctu::shared_ptr_map_impl<ctu::indexed_by_any_map_hashing_key>::get<DataServiceInterface>(v106, v386);
      if (*(_QWORD *)v386)
        v107 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)v386 + 760))(*(_QWORD *)v386) != a2;
      else
        v107 = 0;
      v108 = *(std::__shared_weak_count **)&v386[8];
      if (*(_QWORD *)&v386[8])
      {
        v109 = (unint64_t *)(*(_QWORD *)&v386[8] + 8);
        do
          v110 = __ldaxr(v109);
        while (__stlxr(v110 - 1, v109));
        if (!v110)
        {
          ((void (*)(std::__shared_weak_count *))v108->__on_zero_shared)(v108);
          std::__shared_weak_count::__release_weak(v108);
        }
      }
      if (v107)
        *((_WORD *)v105 + 5) = 257;
    }
    if (a3[184])
    {
      v111 = (char *)(a3 + 185);
    }
    else
    {
      v112 = a3[182];
      if (!a3[182])
      {
LABEL_315:
        *((_DWORD *)v105 + 24) = v112;
        *((_BYTE *)v105 + 100) = 1;
        if (a3[513])
        {
          v114 = a3[512];
          if (v114 < 4)
            v115 = v114 + 1;
          else
            v115 = 0;
          (*(void (**)(_QWORD, _QWORD, uint64_t))(**(_QWORD **)(a1 + 64) + 192))(*(_QWORD *)(a1 + 64), a2, v115);
        }
        if (!*(_QWORD *)&buf[24])
          std::__throw_bad_function_call[abi:ne180100]();
        v87 = (capabilities::ct *)(*(uint64_t (**)(_QWORD, uint64_t **))(**(_QWORD **)&buf[24] + 48))(*(_QWORD *)&buf[24], v105);
        goto LABEL_322;
      }
      v111 = (char *)(a3 + 183);
    }
    v113 = *v111;
    if (v113 > 9)
      v112 = 0;
    else
      v112 = dword_216AC1050[v113];
    goto LABEL_315;
  }
LABEL_322:
  if (a3[17] && a3[232])
  {
    v116 = ServingSystem::ratSystem((uint64_t)&v361, 7);
    if (a3[196])
    {
      *((_WORD *)v116 + 4) = ((a3[197] & 0xFD) == 1) | 0x100;
      *((_WORD *)v116 + 5) = ((a3[197] & 0xFE) == 2) | 0x100;
    }
    *((_DWORD *)v116 + 24) = 14;
    *((_BYTE *)v116 + 100) = 1;
    if (!*(_QWORD *)&buf[24])
      std::__throw_bad_function_call[abi:ne180100]();
    v87 = (capabilities::ct *)(*(uint64_t (**)(_QWORD, uint64_t **))(**(_QWORD **)&buf[24] + 48))(*(_QWORD *)&buf[24], v116);
  }
  if (a3[21] && a3[304])
  {
    v117 = ServingSystem::ratSystem((uint64_t)&v361, 9);
    if (a3[240])
    {
      *((_WORD *)v117 + 4) = ((a3[241] & 0xFD) == 1) | 0x100;
      *((_WORD *)v117 + 5) = ((a3[241] & 0xFE) == 2) | 0x100;
    }
    if (a3[272])
    {
      v118 = (char *)(a3 + 273);
    }
    else
    {
      v119 = a3[270];
      if (!a3[270])
      {
LABEL_339:
        *((_DWORD *)v117 + 24) = v119;
        *((_BYTE *)v117 + 100) = 1;
        if (!*(_QWORD *)&buf[24])
          std::__throw_bad_function_call[abi:ne180100]();
        v87 = (capabilities::ct *)(*(uint64_t (**)(_QWORD, uint64_t **))(**(_QWORD **)&buf[24] + 48))(*(_QWORD *)&buf[24], v117);
        goto LABEL_341;
      }
      v118 = (char *)(a3 + 271);
    }
    v120 = *v118;
    if (v120 > 9)
      v119 = 0;
    else
      v119 = dword_216AC1050[v120];
    goto LABEL_339;
  }
LABEL_341:
  v121 = capabilities::ct::supports5G(v87);
  if (a3[25])
    v122 = v121;
  else
    v122 = 0;
  if (v122 == 1 && a3[348])
  {
    v123 = ServingSystem::ratSystem((uint64_t)&v361, 10);
    if (a3[312])
    {
      *((_WORD *)v123 + 4) = ((a3[313] & 0xFD) == 1) | 0x100;
      *((_WORD *)v123 + 5) = ((a3[313] & 0xFE) == 2) | 0x100;
    }
    *((_DWORD *)v123 + 24) = 17;
    *((_BYTE *)v123 + 100) = 1;
    if (!*(_QWORD *)&buf[24])
      std::__throw_bad_function_call[abi:ne180100]();
    (*(void (**)(_QWORD, uint64_t **))(**(_QWORD **)&buf[24] + 48))(*(_QWORD *)&buf[24], v123);
  }
  v124 = *(uint8_t **)&buf[24];
  if (*(uint8_t **)&buf[24] == buf)
  {
    v125 = 4;
    v124 = buf;
    goto LABEL_354;
  }
  if (*(_QWORD *)&buf[24])
  {
    v125 = 5;
LABEL_354:
    (*(void (**)(void))(*(_QWORD *)v124 + 8 * v125))();
  }
  v126 = (uint64_t **)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 88) + 16))(*(_QWORD *)(a1 + 88), a2);
  v127 = (os_log_t *)v126;
  if (a3[9] && a3[148])
  {
    if (a3[124])
    {
      v128 = *v126;
      if (os_log_type_enabled((os_log_t)*v126, OS_LOG_TYPE_DEFAULT))
      {
        v129 = asString();
        v130 = *((_DWORD *)a3 + 32);
        *(_DWORD *)buf = 136315395;
        *(_QWORD *)&buf[4] = v129;
        *(_WORD *)&buf[12] = 1025;
        *(_DWORD *)&buf[14] = v130;
        _os_log_impl(&dword_216897000, v128, OS_LOG_TYPE_DEFAULT, "#I %s Cell ID: %{private}d", buf, 0x12u);
      }
      v126 = ServingSystem::gsmSystem((uint64_t)&v361, 0);
      v131 = (uint64_t *)*((unsigned int *)a3 + 32);
      if (!*((_BYTE *)v126 + 88))
        *((_BYTE *)v126 + 88) = 1;
      v126[10] = v131;
    }
    if (a3[120])
    {
      v132 = *v127;
      if (os_log_type_enabled(*v127, OS_LOG_TYPE_DEFAULT))
      {
        v133 = asString();
        v134 = *((unsigned __int16 *)a3 + 61);
        *(_DWORD *)buf = 136315395;
        *(_QWORD *)&buf[4] = v133;
        *(_WORD *)&buf[12] = 1025;
        *(_DWORD *)&buf[14] = v134;
        _os_log_impl(&dword_216897000, v132, OS_LOG_TYPE_DEFAULT, "#I %s Area code: %{private}d", buf, 0x12u);
      }
      v126 = ServingSystem::gsmSystem((uint64_t)&v361, 0);
      v135 = *((unsigned __int16 *)a3 + 61);
      if (!*((_BYTE *)v126 + 100))
        *((_BYTE *)v126 + 100) = 1;
      *((_DWORD *)v126 + 24) = v135;
    }
    if (a3[135])
    {
      memset(buf, 0, 32);
      MCC::MCC((MCC *)buf);
      *(_OWORD *)v386 = 0u;
      v387 = 0u;
      MNC::MNC((MNC *)v386);
      convertMccAndMnc(a3 + 136, a3 + 139, (const MCC *)buf, (const MNC *)v386);
      v136 = ServingSystem::gsmSystem((uint64_t)&v361, 0);
      std::optional<MCC>::operator=[abi:ne180100]<MCC&,void>((uint64_t)v136);
      v137 = ServingSystem::gsmSystem((uint64_t)&v361, 0);
      std::optional<MNC>::operator=[abi:ne180100]<MNC&,void>((MCC *)(v137 + 5), (const MCC *)v386);
      v138 = *v127;
      v126 = (uint64_t **)os_log_type_enabled(*v127, OS_LOG_TYPE_DEFAULT);
      if ((_DWORD)v126)
      {
        v139 = asString();
        v140 = MCC::getIntValue((MCC *)buf);
        v141 = MNC::getIntegerWidth((MNC *)v386);
        v142 = MCC::getIntValue((MCC *)v386);
        *(_DWORD *)v372 = 136315906;
        *(_QWORD *)&v372[4] = v139;
        *(_WORD *)&v372[12] = 1024;
        *(_DWORD *)&v372[14] = v140;
        *(_WORD *)&v372[18] = 1024;
        *(_DWORD *)&v372[20] = v141;
        *(_WORD *)&v372[24] = 1024;
        *(_DWORD *)&v372[26] = v142;
        _os_log_impl(&dword_216897000, v138, OS_LOG_TYPE_DEFAULT, "#I %s PLMN: %03d-%0.*d", v372, 0x1Eu);
      }
      if (SHIBYTE(v387) < 0)
        operator delete(*(void **)&v386[8]);
      if ((char)buf[31] < 0)
        operator delete(*(void **)&buf[8]);
    }
  }
  if (a3[13] && a3[192])
  {
    if (a3[164])
    {
      v143 = *v127;
      if (os_log_type_enabled(*v127, OS_LOG_TYPE_DEFAULT))
      {
        v144 = asString();
        v145 = *((_DWORD *)a3 + 42);
        *(_DWORD *)buf = 136315395;
        *(_QWORD *)&buf[4] = v144;
        *(_WORD *)&buf[12] = 1025;
        *(_DWORD *)&buf[14] = v145;
        _os_log_impl(&dword_216897000, v143, OS_LOG_TYPE_DEFAULT, "#I %s Cell ID: %{private}d", buf, 0x12u);
      }
      v126 = ServingSystem::gsmSystem((uint64_t)&v361, 2);
      v146 = (uint64_t *)*((unsigned int *)a3 + 42);
      if (!*((_BYTE *)v126 + 88))
        *((_BYTE *)v126 + 88) = 1;
      v126[10] = v146;
    }
    if (a3[160])
    {
      v147 = *v127;
      if (os_log_type_enabled(*v127, OS_LOG_TYPE_DEFAULT))
      {
        v148 = asString();
        v149 = *((unsigned __int16 *)a3 + 81);
        *(_DWORD *)buf = 136315395;
        *(_QWORD *)&buf[4] = v148;
        *(_WORD *)&buf[12] = 1025;
        *(_DWORD *)&buf[14] = v149;
        _os_log_impl(&dword_216897000, v147, OS_LOG_TYPE_DEFAULT, "#I %s Area code: %{private}d", buf, 0x12u);
      }
      v126 = ServingSystem::gsmSystem((uint64_t)&v361, 2);
      v150 = *((unsigned __int16 *)a3 + 81);
      if (!*((_BYTE *)v126 + 100))
        *((_BYTE *)v126 + 100) = 1;
      *((_DWORD *)v126 + 24) = v150;
    }
    if (a3[175])
    {
      memset(buf, 0, 32);
      MCC::MCC((MCC *)buf);
      *(_OWORD *)v386 = 0u;
      v387 = 0u;
      MNC::MNC((MNC *)v386);
      convertMccAndMnc(a3 + 176, a3 + 179, (const MCC *)buf, (const MNC *)v386);
      v151 = ServingSystem::gsmSystem((uint64_t)&v361, 2);
      std::optional<MCC>::operator=[abi:ne180100]<MCC&,void>((uint64_t)v151);
      v152 = ServingSystem::gsmSystem((uint64_t)&v361, 2);
      std::optional<MNC>::operator=[abi:ne180100]<MNC&,void>((MCC *)(v152 + 5), (const MCC *)v386);
      v153 = *v127;
      v126 = (uint64_t **)os_log_type_enabled(*v127, OS_LOG_TYPE_DEFAULT);
      if ((_DWORD)v126)
      {
        v154 = asString();
        v155 = MCC::getIntValue((MCC *)buf);
        v156 = MNC::getIntegerWidth((MNC *)v386);
        v157 = MCC::getIntValue((MCC *)v386);
        *(_DWORD *)v372 = 136315906;
        *(_QWORD *)&v372[4] = v154;
        *(_WORD *)&v372[12] = 1024;
        *(_DWORD *)&v372[14] = v155;
        *(_WORD *)&v372[18] = 1024;
        *(_DWORD *)&v372[20] = v156;
        *(_WORD *)&v372[24] = 1024;
        *(_DWORD *)&v372[26] = v157;
        _os_log_impl(&dword_216897000, v153, OS_LOG_TYPE_DEFAULT, "#I %s PLMN: %03d-%0.*d", v372, 0x1Eu);
      }
      if (SHIBYTE(v387) < 0)
        operator delete(*(void **)&v386[8]);
      if ((char)buf[31] < 0)
        operator delete(*(void **)&buf[8]);
    }
  }
  if (a3[17] && a3[232])
  {
    if (a3[208])
    {
      v158 = *v127;
      if (os_log_type_enabled(*v127, OS_LOG_TYPE_DEFAULT))
      {
        v159 = asString();
        v160 = *((_DWORD *)a3 + 53);
        *(_DWORD *)buf = 136315395;
        *(_QWORD *)&buf[4] = v159;
        *(_WORD *)&buf[12] = 1025;
        *(_DWORD *)&buf[14] = v160;
        _os_log_impl(&dword_216897000, v158, OS_LOG_TYPE_DEFAULT, "#I %s Cell ID: %{private}d", buf, 0x12u);
      }
      v126 = ServingSystem::gsmSystem((uint64_t)&v361, 7);
      v161 = (uint64_t *)*((unsigned int *)a3 + 53);
      if (!*((_BYTE *)v126 + 88))
        *((_BYTE *)v126 + 88) = 1;
      v126[10] = v161;
    }
    if (a3[204])
    {
      v162 = *v127;
      if (os_log_type_enabled(*v127, OS_LOG_TYPE_DEFAULT))
      {
        v163 = asString();
        v164 = *((unsigned __int16 *)a3 + 103);
        *(_DWORD *)buf = 136315395;
        *(_QWORD *)&buf[4] = v163;
        *(_WORD *)&buf[12] = 1025;
        *(_DWORD *)&buf[14] = v164;
        _os_log_impl(&dword_216897000, v162, OS_LOG_TYPE_DEFAULT, "#I %s Area code: %{private}d", buf, 0x12u);
      }
      v126 = ServingSystem::gsmSystem((uint64_t)&v361, 7);
      v165 = *((unsigned __int16 *)a3 + 103);
      if (!*((_BYTE *)v126 + 100))
        *((_BYTE *)v126 + 100) = 1;
      *((_DWORD *)v126 + 24) = v165;
    }
    if (a3[219])
    {
      memset(buf, 0, 32);
      MCC::MCC((MCC *)buf);
      *(_OWORD *)v386 = 0u;
      v387 = 0u;
      MNC::MNC((MNC *)v386);
      convertMccAndMnc(a3 + 220, a3 + 223, (const MCC *)buf, (const MNC *)v386);
      v166 = ServingSystem::gsmSystem((uint64_t)&v361, 7);
      std::optional<MCC>::operator=[abi:ne180100]<MCC&,void>((uint64_t)v166);
      v167 = ServingSystem::gsmSystem((uint64_t)&v361, 7);
      std::optional<MNC>::operator=[abi:ne180100]<MNC&,void>((MCC *)(v167 + 5), (const MCC *)v386);
      v168 = *v127;
      v126 = (uint64_t **)os_log_type_enabled(*v127, OS_LOG_TYPE_DEFAULT);
      if ((_DWORD)v126)
      {
        v169 = asString();
        v170 = MCC::getIntValue((MCC *)buf);
        v171 = MNC::getIntegerWidth((MNC *)v386);
        v172 = MCC::getIntValue((MCC *)v386);
        *(_DWORD *)v372 = 136315906;
        *(_QWORD *)&v372[4] = v169;
        *(_WORD *)&v372[12] = 1024;
        *(_DWORD *)&v372[14] = v170;
        *(_WORD *)&v372[18] = 1024;
        *(_DWORD *)&v372[20] = v171;
        *(_WORD *)&v372[24] = 1024;
        *(_DWORD *)&v372[26] = v172;
        _os_log_impl(&dword_216897000, v168, OS_LOG_TYPE_DEFAULT, "#I %s PLMN: %03d-%0.*d", v372, 0x1Eu);
      }
      if (SHIBYTE(v387) < 0)
        operator delete(*(void **)&v386[8]);
      if ((char)buf[31] < 0)
        operator delete(*(void **)&buf[8]);
    }
    if (!a3[232])
      goto LABEL_676;
    if (!a3[226])
      goto LABEL_425;
    v173 = *v127;
    if (os_log_type_enabled(*v127, OS_LOG_TYPE_DEFAULT))
    {
      v174 = *((unsigned __int16 *)a3 + 114);
      *(_DWORD *)buf = 67174657;
      *(_DWORD *)&buf[4] = v174;
      _os_log_impl(&dword_216897000, v173, OS_LOG_TYPE_DEFAULT, "#I LTE Area code: %{private}d", buf, 8u);
      if (!a3[232])
LABEL_676:
        std::__throw_bad_optional_access[abi:ne180100]();
    }
    v126 = ServingSystem::gsmSystem((uint64_t)&v361, 7);
    v175 = *((unsigned __int16 *)a3 + 114);
    if (!*((_BYTE *)v126 + 100))
      *((_BYTE *)v126 + 100) = 1;
    *((_DWORD *)v126 + 24) = v175;
  }
LABEL_425:
  if (capabilities::ct::supports5G((capabilities::ct *)v126) && a3[25] && a3[348])
  {
    if (a3[324])
    {
      v176 = *v127;
      if (os_log_type_enabled(*v127, OS_LOG_TYPE_DEFAULT))
      {
        v177 = asString();
        v178 = *((_DWORD *)a3 + 82);
        *(_DWORD *)buf = 136315395;
        *(_QWORD *)&buf[4] = v177;
        *(_WORD *)&buf[12] = 1025;
        *(_DWORD *)&buf[14] = v178;
        _os_log_impl(&dword_216897000, v176, OS_LOG_TYPE_DEFAULT, "#I %s Cell ID: %{private}d", buf, 0x12u);
      }
      v179 = ServingSystem::gsmSystem((uint64_t)&v361, 10);
      v180 = (uint64_t *)*((unsigned int *)a3 + 82);
      if (!*((_BYTE *)v179 + 88))
        *((_BYTE *)v179 + 88) = 1;
      v179[10] = v180;
    }
    if (a3[320])
    {
      v181 = *v127;
      if (os_log_type_enabled(*v127, OS_LOG_TYPE_DEFAULT))
      {
        v182 = asString();
        v183 = *((unsigned __int16 *)a3 + 161);
        *(_DWORD *)buf = 136315395;
        *(_QWORD *)&buf[4] = v182;
        *(_WORD *)&buf[12] = 1025;
        *(_DWORD *)&buf[14] = v183;
        _os_log_impl(&dword_216897000, v181, OS_LOG_TYPE_DEFAULT, "#I %s Area code: %{private}d", buf, 0x12u);
      }
      v184 = ServingSystem::gsmSystem((uint64_t)&v361, 10);
      v185 = *((unsigned __int16 *)a3 + 161);
      if (!*((_BYTE *)v184 + 100))
        *((_BYTE *)v184 + 100) = 1;
      *((_DWORD *)v184 + 24) = v185;
    }
    if (a3[335])
    {
      memset(buf, 0, 32);
      MCC::MCC((MCC *)buf);
      *(_OWORD *)v386 = 0u;
      v387 = 0u;
      MNC::MNC((MNC *)v386);
      convertMccAndMnc(a3 + 336, a3 + 339, (const MCC *)buf, (const MNC *)v386);
      v186 = ServingSystem::gsmSystem((uint64_t)&v361, 10);
      std::optional<MCC>::operator=[abi:ne180100]<MCC&,void>((uint64_t)v186);
      v187 = ServingSystem::gsmSystem((uint64_t)&v361, 10);
      std::optional<MNC>::operator=[abi:ne180100]<MNC&,void>((MCC *)(v187 + 5), (const MCC *)v386);
      v188 = *v127;
      if (os_log_type_enabled(*v127, OS_LOG_TYPE_DEFAULT))
      {
        v189 = asString();
        v190 = MCC::getIntValue((MCC *)buf);
        v191 = MNC::getIntegerWidth((MNC *)v386);
        v192 = MCC::getIntValue((MCC *)v386);
        *(_DWORD *)v372 = 136315906;
        *(_QWORD *)&v372[4] = v189;
        *(_WORD *)&v372[12] = 1024;
        *(_DWORD *)&v372[14] = v190;
        *(_WORD *)&v372[18] = 1024;
        *(_DWORD *)&v372[20] = v191;
        *(_WORD *)&v372[24] = 1024;
        *(_DWORD *)&v372[26] = v192;
        _os_log_impl(&dword_216897000, v188, OS_LOG_TYPE_DEFAULT, "#I %s PLMN: %03d-%0.*d", v372, 0x1Eu);
      }
      if (SHIBYTE(v387) < 0)
        operator delete(*(void **)&v386[8]);
      if ((char)buf[31] < 0)
        operator delete(*(void **)&buf[8]);
    }
    if (a3[481])
    {
      v193 = a3[478];
      v194 = a3[479];
      v195 = a3[480];
      v196 = ServingSystem::gsmSystem((uint64_t)&v361, 10);
      v197 = (v193 << 16) | (v194 << 8) | v195;
      *((_DWORD *)v196 + 24) = v197;
      *((_BYTE *)v196 + 100) = 1;
      v198 = *v127;
      if (os_log_type_enabled(*v127, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67174657;
        *(_DWORD *)&buf[4] = v197;
        _os_log_impl(&dword_216897000, v198, OS_LOG_TYPE_DEFAULT, "#I NR Area code: %{private}d", buf, 8u);
      }
    }
    if (a3[490])
    {
      v199 = a3[486];
      v200 = *(unsigned int *)(a3 + 482);
      v201 = ServingSystem::gsmSystem((uint64_t)&v361, 10);
      v202 = (uint64_t *)(v200 | (v199 << 32));
      v201[10] = v202;
      *((_BYTE *)v201 + 88) = 1;
      v203 = *v127;
      if (os_log_type_enabled(*v127, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134283521;
        *(_QWORD *)&buf[4] = v202;
        _os_log_impl(&dword_216897000, v203, OS_LOG_TYPE_DEFAULT, "#I NR Cell ID: %{private}llu", buf, 0xCu);
      }
    }
  }
  if (a3[21] && a3[304])
  {
    if (a3[252])
    {
      v204 = *v127;
      if (os_log_type_enabled(*v127, OS_LOG_TYPE_DEFAULT))
      {
        v205 = asString();
        v206 = *((_DWORD *)a3 + 64);
        *(_DWORD *)buf = 136315395;
        *(_QWORD *)&buf[4] = v205;
        *(_WORD *)&buf[12] = 1025;
        *(_DWORD *)&buf[14] = v206;
        _os_log_impl(&dword_216897000, v204, OS_LOG_TYPE_DEFAULT, "#I %s Cell ID: %{private}d", buf, 0x12u);
      }
      v207 = ServingSystem::gsmSystem((uint64_t)&v361, 9);
      v208 = (uint64_t *)*((unsigned int *)a3 + 64);
      if (!*((_BYTE *)v207 + 88))
        *((_BYTE *)v207 + 88) = 1;
      v207[10] = v208;
    }
    if (a3[248])
    {
      v209 = *v127;
      if (os_log_type_enabled(*v127, OS_LOG_TYPE_DEFAULT))
      {
        v210 = asString();
        v211 = *((unsigned __int16 *)a3 + 125);
        *(_DWORD *)buf = 136315395;
        *(_QWORD *)&buf[4] = v210;
        *(_WORD *)&buf[12] = 1025;
        *(_DWORD *)&buf[14] = v211;
        _os_log_impl(&dword_216897000, v209, OS_LOG_TYPE_DEFAULT, "#I %s Area code: %{private}d", buf, 0x12u);
      }
      v212 = ServingSystem::gsmSystem((uint64_t)&v361, 9);
      v213 = *((unsigned __int16 *)a3 + 125);
      if (!*((_BYTE *)v212 + 100))
        *((_BYTE *)v212 + 100) = 1;
      *((_DWORD *)v212 + 24) = v213;
    }
    if (a3[263])
    {
      memset(buf, 0, 32);
      MCC::MCC((MCC *)buf);
      *(_OWORD *)v386 = 0u;
      v387 = 0u;
      MNC::MNC((MNC *)v386);
      convertMccAndMnc(a3 + 264, a3 + 267, (const MCC *)buf, (const MNC *)v386);
      v214 = ServingSystem::gsmSystem((uint64_t)&v361, 9);
      std::optional<MCC>::operator=[abi:ne180100]<MCC&,void>((uint64_t)v214);
      v215 = ServingSystem::gsmSystem((uint64_t)&v361, 9);
      std::optional<MNC>::operator=[abi:ne180100]<MNC&,void>((MCC *)(v215 + 5), (const MCC *)v386);
      v216 = *v127;
      if (os_log_type_enabled(v216, OS_LOG_TYPE_DEFAULT))
      {
        v217 = asString();
        v218 = MCC::getIntValue((MCC *)buf);
        v219 = MNC::getIntegerWidth((MNC *)v386);
        v220 = MCC::getIntValue((MCC *)v386);
        *(_DWORD *)v372 = 136315906;
        *(_QWORD *)&v372[4] = v217;
        *(_WORD *)&v372[12] = 1024;
        *(_DWORD *)&v372[14] = v218;
        *(_WORD *)&v372[18] = 1024;
        *(_DWORD *)&v372[20] = v219;
        *(_WORD *)&v372[24] = 1024;
        *(_DWORD *)&v372[26] = v220;
        _os_log_impl(&dword_216897000, v216, OS_LOG_TYPE_DEFAULT, "#I %s PLMN: %03d-%0.*d", v372, 0x1Eu);
      }
      if (SHIBYTE(v387) < 0)
        operator delete(*(void **)&v386[8]);
      if ((char)buf[31] < 0)
        operator delete(*(void **)&buf[8]);
    }
  }
  if (a3[2] && a3[76])
  {
    if (a3[32])
    {
      if (!BYTE8(v366))
      {
        v365[0] = 0;
        v365[1] = 0;
        *(_QWORD *)&v366 = 0;
        BYTE8(v366) = 1;
      }
      v221 = a3[33];
      if ((_DWORD)v221 == 1)
      {
        v221 = 0;
      }
      else if (!a3[33])
      {
        v221 = 1;
      }
      v222 = (char *)v365[1];
      if (v365[1] >= (void *)v366)
      {
        v224 = ((char *)v365[1] - (char *)v365[0]) >> 3;
        if ((unint64_t)(v224 + 1) >> 61)
          goto LABEL_690;
        v225 = (uint64_t)(v366 - (unint64_t)v365[0]) >> 2;
        if (v225 <= v224 + 1)
          v225 = v224 + 1;
        if ((unint64_t)v366 - (unint64_t)v365[0] >= 0x7FFFFFFFFFFFFFF8)
          v226 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v226 = v225;
        if (v226)
          v226 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<embms::TMGIInfo>>(v226);
        else
          v227 = 0;
        v228 = (_DWORD *)(v226 + 8 * v224);
        v229 = v226 + 8 * v227;
        *(_QWORD *)v228 = (v221 << 32) | 3;
        v223 = v228 + 2;
        v230 = v365[1];
        v231 = v365[0];
        if (v365[1] != v365[0])
        {
          do
          {
            v232 = *((_DWORD *)v230 - 2);
            v230 -= 8;
            v233 = v230[4];
            *(v228 - 2) = v232;
            v228 -= 2;
            *((_BYTE *)v228 + 4) = v233;
          }
          while (v230 != v231);
          v230 = v365[0];
        }
        v365[0] = v228;
        v365[1] = v223;
        *(_QWORD *)&v366 = v229;
        if (v230)
          operator delete(v230);
      }
      else
      {
        *(_QWORD *)v365[1] = (v221 << 32) | 3;
        v223 = v222 + 8;
      }
      v365[1] = v223;
    }
    if (a3[44])
    {
      DWORD2(v362[2]) = 0;
      if (!BYTE4(v362[3]))
        BYTE4(v362[3]) = 1;
      DWORD1(v362[2]) = *(_DWORD *)(a3 + 46);
      WORD4(v362[2]) = *((_WORD *)a3 + 26);
      *(_QWORD *)((char *)&v362[2] + 12) = *((_QWORD *)a3 + 7);
    }
  }
  if (a3[5] && a3[111])
  {
    if (!a3[84])
    {
LABEL_530:
      if (a3[429])
      {
        *(_QWORD *)&v362[4] = 0;
        *((_QWORD *)&v362[3] + 1) = 0;
        if (!BYTE10(v362[4]))
          BYTE10(v362[4]) = 1;
        WORD4(v362[4]) = a3[428] | 0x100;
      }
      if (a3[94])
      {
        if (!BYTE10(v362[4]))
        {
          WORD4(v362[4]) = 0;
          BYTE10(v362[4]) = 1;
        }
        *(_OWORD *)((char *)&v362[3] + 8) = *(_OWORD *)(a3 + 95);
      }
      goto LABEL_538;
    }
    if (!BYTE8(v366))
    {
      v365[0] = 0;
      v365[1] = 0;
      *(_QWORD *)&v366 = 0;
      BYTE8(v366) = 1;
    }
    v234 = a3[85];
    if ((_DWORD)v234 == 1)
    {
      v234 = 0;
    }
    else if (!a3[85])
    {
      v234 = 1;
    }
    v235 = (char *)v365[1];
    if (v365[1] < (void *)v366)
    {
      *(_QWORD *)v365[1] = (v234 << 32) | 4;
      v236 = v235 + 8;
LABEL_529:
      v365[1] = v236;
      goto LABEL_530;
    }
    v237 = ((char *)v365[1] - (char *)v365[0]) >> 3;
    if (!((unint64_t)(v237 + 1) >> 61))
    {
      v238 = (uint64_t)(v366 - (unint64_t)v365[0]) >> 2;
      if (v238 <= v237 + 1)
        v238 = v237 + 1;
      if ((unint64_t)v366 - (unint64_t)v365[0] >= 0x7FFFFFFFFFFFFFF8)
        v239 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v239 = v238;
      if (v239)
        v239 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<embms::TMGIInfo>>(v239);
      else
        v240 = 0;
      v241 = (_DWORD *)(v239 + 8 * v237);
      v242 = v239 + 8 * v240;
      *(_QWORD *)v241 = (v234 << 32) | 4;
      v236 = v241 + 2;
      v243 = v365[1];
      v244 = v365[0];
      if (v365[1] != v365[0])
      {
        do
        {
          v245 = *((_DWORD *)v243 - 2);
          v243 -= 8;
          v246 = v243[4];
          *(v241 - 2) = v245;
          v241 -= 2;
          *((_BYTE *)v241 + 4) = v246;
        }
        while (v243 != v244);
        v243 = v365[0];
      }
      v365[0] = v241;
      v365[1] = v236;
      *(_QWORD *)&v366 = v242;
      if (v243)
        operator delete(v243);
      goto LABEL_529;
    }
LABEL_690:
    std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
  }
LABEL_538:
  v247 = a3[464];
  v248 = *((unsigned int *)a3 + 108);
  v249 = *(_QWORD *)(a1 + 64);
  if (!a3[464])
    v248 = 0;
  buf[0] = 0;
  v385 = 0;
  (*(void (**)(uint64_t, _QWORD, uint64_t, uint8_t *))(*(_QWORD *)v249 + 168))(v249, a2, v248 | (v247 << 32), buf);
  v250 = (capabilities::ct *)std::__optional_destruct_base<MCCAndMNC,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)buf);
  *(_WORD *)v372 = 0;
  v372[2] = 0;
  LOWORD(v342[0]) = 0;
  BYTE2(v342[0]) = 0;
  v338 = 0;
  v339 = 0;
  *(_WORD *)v334 = 0;
  v335 = 0;
  if (a3[232])
  {
    v250 = (capabilities::ct *)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 88) + 16))(*(_QWORD *)(a1 + 88), a2);
    v251 = (NSObject **)v250;
    if (a3[17])
      v252 = (a3[14] & 0xFD) == 1;
    else
      v252 = 0;
    v253 = v252;
    if (a3[416])
    {
      v254 = *((_DWORD *)a3 + 103);
      if (v254 == 2)
        v255 = 2;
      else
        v255 = v254 == 1;
    }
    else
    {
      v255 = 2;
    }
    if (a3[424])
    {
      v260 = *((_DWORD *)a3 + 105);
      if (v260 == 2)
        v257 = 2;
      else
        v257 = v260 == 1;
    }
    else
    {
      v257 = 2;
    }
    if (a3[431])
    {
      v258 = a3[430];
      *(_QWORD *)v386 = 0;
      DevicePersistentCopyValue(CFSTR("IMSSupportOnLTEOverride"), 0);
      ctu::cf::CFSharedRef<__CFBoolean const>::CFSharedRef<void const,void>(v386, (CFTypeRef *)buf);
      v261 = ctu::SharedRef<void const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,void const>::~SharedRef((const void **)buf);
      v263 = ctu::SharedRef<__CFBoolean const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFBoolean const>::get;
      if (!*(_QWORD *)v386)
        v263 = 0;
      if (v263)
      {
        buf[0] = 0;
        ctu::cf::assign((ctu::cf *)v261, *(BOOL **)v386, v262);
        v258 = buf[0];
        v264 = *v251;
        if (os_log_type_enabled(v264, OS_LOG_TYPE_DEFAULT))
        {
          v265 = CSIBOOLAsString();
          *(_DWORD *)buf = 136315138;
          *(_QWORD *)&buf[4] = v265;
          _os_log_impl(&dword_216897000, v264, OS_LOG_TYPE_DEFAULT, "#I IMS support on LTE is being overridden to %s", buf, 0xCu);
        }
      }
      v250 = (capabilities::ct *)ctu::SharedRef<__CFBoolean const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFBoolean const>::~SharedRef((const void **)v386);
      v259 = 1;
    }
    else
    {
      v258 = 0;
      v259 = 0;
    }
    v372[2] = 0;
    *(_WORD *)v372 = 0;
    LOWORD(v342[0]) = 0;
    v256 = 1;
    BYTE2(v342[0]) = 0;
  }
  else
  {
    v253 = 0;
    v256 = 0;
    v255 = 0;
    v257 = 0;
    v258 = 0;
    v259 = 0;
  }
  v266 = capabilities::ct::supportsVoNR(v250);
  if (a3[348])
    v267 = v266;
  else
    v267 = 0;
  if (v267 == 1)
  {
    v268 = a3[25];
    if (v268)
      v269 = (a3[22] & 0xFD) == 1;
    else
      v269 = 0;
    v270 = v269;
    v271 = a3[504];
    if (v271)
    {
      v272 = *((_DWORD *)a3 + 124) != 0;
      v273 = *((_DWORD *)a3 + 125) != 0;
      v271 = 1;
    }
    else
    {
      v272 = 0;
      v273 = 0;
    }
    v275 = a3[509];
    if (v275)
      v276 = a3[508] == 1;
    else
      v276 = 0;
    v274 = v276;
    v338 = 0;
    v339 = 0;
    *(_WORD *)v334 = 0;
    v335 = 0;
  }
  else
  {
    v270 = 0;
    v268 = 0;
    v272 = 0;
    v271 = 0;
    v273 = 0;
    v274 = 0;
    v275 = 0;
  }
  v277 = *(_QWORD *)(a1 + 64);
  buf[0] = v253;
  buf[1] = v256;
  *(_WORD *)&buf[2] = 0;
  buf[4] = v255;
  buf[7] = 0;
  *(_WORD *)&buf[5] = 0;
  buf[8] = v256;
  *(_WORD *)&buf[9] = *(_WORD *)v372;
  buf[11] = v372[2];
  buf[12] = v257;
  buf[15] = 0;
  *(_WORD *)&buf[13] = 0;
  buf[16] = v256;
  *(_WORD *)&buf[17] = v342[0];
  buf[19] = BYTE2(v342[0]);
  buf[20] = v258;
  buf[21] = v259;
  *(_WORD *)&buf[22] = 0;
  buf[24] = v270;
  buf[25] = v268;
  *(_WORD *)&buf[26] = 0;
  buf[28] = v272;
  buf[31] = 0;
  *(_WORD *)&buf[29] = 0;
  buf[32] = v271;
  v374 = v338;
  v375 = v339;
  v376 = v273;
  v378 = 0;
  v377 = 0;
  v379 = v271;
  v381 = v335;
  v380 = *(_WORD *)v334;
  v382 = v274;
  v383 = v275;
  v384 = 0;
  (*(void (**)(uint64_t, _QWORD, uint8_t *))(*(_QWORD *)v277 + 64))(v277, a2, buf);
  v278 = *(_QWORD *)(a1 + 64);
  v344[0] = v361;
  LOBYTE(v345) = 0;
  v348 = 0;
  if (LOBYTE(v362[1]))
  {
    v346 = 0;
    v347 = 0;
    v345 = &v346;
    v279 = (_OWORD *)*((_QWORD *)&v361 + 1);
    if (*((_OWORD **)&v361 + 1) != v362)
    {
      while (1)
      {
        v280 = &v346;
        if (v345 != &v346)
        {
          v281 = v346;
          v282 = &v346;
          if (v346)
          {
            do
            {
              v280 = (uint64_t **)v281;
              v281 = (uint64_t *)v281[1];
            }
            while (v281);
          }
          else
          {
            do
            {
              v280 = (uint64_t **)v282[2];
              v8 = *v280 == (uint64_t *)v282;
              v282 = v280;
            }
            while (v8);
          }
          v283 = *((_DWORD *)v279 + 8);
          if (*((_DWORD *)v280 + 8) >= v283)
            break;
        }
        if (v346)
          v284 = v280;
        else
          v284 = &v346;
        if (v346)
          v285 = v280 + 1;
        else
          v285 = &v346;
        if (!*v285)
          goto LABEL_612;
LABEL_615:
        v291 = (_QWORD *)*((_QWORD *)v279 + 1);
        if (v291)
        {
          do
          {
            v292 = v291;
            v291 = (_QWORD *)*v291;
          }
          while (v291);
        }
        else
        {
          do
          {
            v292 = (_OWORD *)*((_QWORD *)v279 + 2);
            v8 = *(_QWORD *)v292 == (_QWORD)v279;
            v279 = v292;
          }
          while (!v8);
        }
        v279 = v292;
        if (v292 == v362)
          goto LABEL_621;
      }
      v285 = &v346;
      v284 = &v346;
      if (v346)
      {
        v286 = v346;
        while (1)
        {
          while (1)
          {
            v284 = (uint64_t **)v286;
            v287 = *((_DWORD *)v286 + 8);
            if (v287 <= v283)
              break;
            v286 = *v284;
            v285 = v284;
            if (!*v284)
              goto LABEL_612;
          }
          if (v287 >= v283)
            goto LABEL_615;
          v286 = v284[1];
          if (!v286)
          {
            v285 = v284 + 1;
            break;
          }
        }
      }
LABEL_612:
      *(_QWORD *)&buf[16] = 0;
      v288 = operator new(0x98uLL);
      *(_QWORD *)buf = v288;
      *(_QWORD *)&buf[8] = &v346;
      v288[8] = *((_DWORD *)v279 + 8);
      v289 = *((_QWORD *)v279 + 5);
      v288[12] = *((_DWORD *)v279 + 12);
      *((_QWORD *)v288 + 5) = v289;
      std::__optional_copy_base<MCC,false>::__optional_copy_base[abi:ne180100]((_BYTE *)v288 + 56, (uint64_t)v279 + 56);
      std::__optional_copy_base<MNC,false>::__optional_copy_base[abi:ne180100]((MCC *)(v288 + 24), (const MCC *)(v279 + 6));
      v290 = *((_QWORD *)v279 + 17);
      v288[36] = *((_DWORD *)v279 + 36);
      *((_QWORD *)v288 + 17) = v290;
      buf[16] = 1;
      *(_QWORD *)v288 = 0;
      *((_QWORD *)v288 + 1) = 0;
      *((_QWORD *)v288 + 2) = v284;
      *v285 = (uint64_t *)v288;
      if (*v345)
      {
        v345 = (uint64_t **)*v345;
        v288 = *v285;
      }
      std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v346, (uint64_t *)v288);
      ++v347;
      *(_QWORD *)buf = 0;
      std::unique_ptr<std::__tree_node<std::__value_type<RadioAccessTechnology,ServingSystem::System>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<RadioAccessTechnology,ServingSystem::System>,void *>>>>::reset[abi:ne180100]((uint64_t)buf);
      goto LABEL_615;
    }
LABEL_621:
    v348 = 1;
  }
  v349 = *(_OWORD *)((char *)&v362[1] + 8);
  v350 = *(_OWORD *)((char *)&v362[2] + 8);
  *(_OWORD *)v351 = *(_OWORD *)((char *)&v362[3] + 8);
  *(_DWORD *)&v351[15] = *(_DWORD *)((char *)&v362[4] + 7);
  LOBYTE(v352) = 0;
  v355 = 0;
  if (BYTE8(v364))
  {
    v353 = 0;
    v354 = 0;
    v352 = &v353;
    v293 = (_OWORD *)v363;
    if ((__int128 *)v363 != (__int128 *)((char *)&v363 + 8))
    {
      while (1)
      {
        v294 = &v353;
        if (v352 != &v353)
        {
          v295 = v353;
          v296 = &v353;
          if (v353)
          {
            do
            {
              v294 = (uint64_t **)v295;
              v295 = (uint64_t *)v295[1];
            }
            while (v295);
          }
          else
          {
            do
            {
              v294 = (uint64_t **)v296[2];
              v8 = *v294 == (uint64_t *)v296;
              v296 = v294;
            }
            while (v8);
          }
          v297 = *((_DWORD *)v293 + 8);
          if (*((_DWORD *)v294 + 8) >= v297)
            break;
        }
        if (v353)
          v298 = v294;
        else
          v298 = &v353;
        if (v353)
          v299 = v294 + 1;
        else
          v299 = &v353;
        if (!*v299)
          goto LABEL_646;
LABEL_649:
        v304 = (_QWORD *)*((_QWORD *)v293 + 1);
        if (v304)
        {
          do
          {
            v305 = v304;
            v304 = (_QWORD *)*v304;
          }
          while (v304);
        }
        else
        {
          do
          {
            v305 = (_OWORD *)*((_QWORD *)v293 + 2);
            v8 = *(_QWORD *)v305 == (_QWORD)v293;
            v293 = v305;
          }
          while (!v8);
        }
        v293 = v305;
        if (v305 == (__int128 *)((char *)&v363 + 8))
          goto LABEL_655;
      }
      v299 = &v353;
      v298 = &v353;
      if (v353)
      {
        v300 = v353;
        while (1)
        {
          while (1)
          {
            v298 = (uint64_t **)v300;
            v301 = *((_DWORD *)v300 + 8);
            if (v301 <= v297)
              break;
            v300 = *v298;
            v299 = v298;
            if (!*v298)
              goto LABEL_646;
          }
          if (v301 >= v297)
            goto LABEL_649;
          v300 = v298[1];
          if (!v300)
          {
            v299 = v298 + 1;
            break;
          }
        }
      }
LABEL_646:
      *(_QWORD *)&buf[16] = 0;
      v302 = (char *)operator new(0x98uLL);
      *(_QWORD *)buf = v302;
      *(_QWORD *)&buf[8] = &v353;
      *((_DWORD *)v302 + 8) = *((_DWORD *)v293 + 8);
      std::__optional_copy_base<MCC,false>::__optional_copy_base[abi:ne180100](v302 + 40, (uint64_t)v293 + 40);
      std::__optional_copy_base<MNC,false>::__optional_copy_base[abi:ne180100]((MCC *)(v302 + 80), (const MCC *)(v293 + 5));
      v303 = *(_OWORD *)((char *)v293 + 120);
      *(_OWORD *)(v302 + 132) = *(_OWORD *)((char *)v293 + 132);
      *(_OWORD *)(v302 + 120) = v303;
      buf[16] = 1;
      *(_QWORD *)v302 = 0;
      *((_QWORD *)v302 + 1) = 0;
      *((_QWORD *)v302 + 2) = v298;
      *v299 = (uint64_t *)v302;
      if (*v352)
      {
        v352 = (uint64_t **)*v352;
        v302 = (char *)*v299;
      }
      std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v353, (uint64_t *)v302);
      ++v354;
      *(_QWORD *)buf = 0;
      std::unique_ptr<std::__tree_node<std::__value_type<RadioAccessTechnology,ServingSystem::GSMSystem>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<RadioAccessTechnology,ServingSystem::GSMSystem>,void *>>>>::reset[abi:ne180100]((uint64_t)buf);
      goto LABEL_649;
    }
LABEL_655:
    v355 = 1;
  }
  LOBYTE(v356) = 0;
  v359 = 0;
  if (BYTE8(v366))
  {
    v356 = 0;
    v357 = 0;
    v358 = 0;
    v306 = v365[0];
    v307 = (char *)v365[1] - (char *)v365[0];
    if (v365[1] != v365[0])
    {
      if (v307 < 0)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v308 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<embms::TMGIInfo>>(v307 >> 3);
      v356 = v308;
      v357 = v308;
      v358 = &v308[8 * v309];
      memmove(v308, v306, v307 - 3);
      v357 = &v308[8 * (v307 >> 3)];
    }
    v359 = 1;
  }
  v360 = v367;
  (*(void (**)(uint64_t, _QWORD, char *))(*(_QWORD *)v278 + 56))(v278, a2, v344);
  if (v359 && v356)
  {
    v357 = (char *)v356;
    operator delete(v356);
  }
  if (v355)
    std::__tree<std::__value_type<RadioAccessTechnology,ServingSystem::GSMSystem>,std::__map_value_compare<RadioAccessTechnology,std::__value_type<RadioAccessTechnology,ServingSystem::GSMSystem>,std::less<RadioAccessTechnology>,true>,std::allocator<std::__value_type<RadioAccessTechnology,ServingSystem::GSMSystem>>>::destroy(v353);
  if (v348)
    std::__tree<std::__value_type<RadioAccessTechnology,ServingSystem::System>,std::__map_value_compare<RadioAccessTechnology,std::__value_type<RadioAccessTechnology,ServingSystem::System>,std::less<RadioAccessTechnology>,true>,std::allocator<std::__value_type<RadioAccessTechnology,ServingSystem::System>>>::destroy(v346);
  if (BYTE8(v366) && v365[0])
  {
    v365[1] = v365[0];
    operator delete(v365[0]);
  }
  if (BYTE8(v364))
    std::__tree<std::__value_type<RadioAccessTechnology,ServingSystem::GSMSystem>,std::__map_value_compare<RadioAccessTechnology,std::__value_type<RadioAccessTechnology,ServingSystem::GSMSystem>,std::less<RadioAccessTechnology>,true>,std::allocator<std::__value_type<RadioAccessTechnology,ServingSystem::GSMSystem>>>::destroy(*((_QWORD **)&v363 + 1));
  if (LOBYTE(v362[1]))
    std::__tree<std::__value_type<RadioAccessTechnology,ServingSystem::System>,std::__map_value_compare<RadioAccessTechnology,std::__value_type<RadioAccessTechnology,ServingSystem::System>,std::less<RadioAccessTechnology>,true>,std::allocator<std::__value_type<RadioAccessTechnology,ServingSystem::System>>>::destroy(*(_QWORD **)&v362[0]);
}

void sub_2168A401C(_Unwind_Exception *a1)
{
  uint64_t v1;
  _QWORD *v3;
  uint64_t v4;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v1 - 144);
  v3 = *(_QWORD **)(v1 - 200);
  if (v3 == (_QWORD *)(v1 - 224))
  {
    v4 = 4;
    v3 = (_QWORD *)(v1 - 224);
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
  ServingSystem::~ServingSystem((ServingSystem *)&STACK[0x200]);
  _Unwind_Resume(a1);
}

void QMICellMonitorCommandDriver::sendRegistrationHintsForSlot(uint64_t a1, int a2, char a3, char a4, const void **a5, const void **a6, const void **a7, const void **a8, const void **a9, const void **a10, const void **a11)
{
  const void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char v18;
  int v19;
  uint64_t v20;
  const void **v21;
  _BYTE *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  char *v30;
  uint64_t *v31;
  char *v32;
  char *v33;
  uint64_t v34;
  const void **v35;
  char *v36;
  _BYTE *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  _QWORD *v41;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  char *v45;
  uint64_t *v46;
  char *v47;
  char *v48;
  uint64_t v49;
  char *v50;
  const void *v51;
  uint64_t v52;
  uint64_t v53;
  const void **v54;
  const void *v55;
  uint64_t v56;
  uint64_t v57;
  const void **v58;
  const void *v59;
  uint64_t v60;
  uint64_t v61;
  const void **v62;
  const void *v63;
  uint64_t v64;
  uint64_t v65;
  const void **v66;
  const void *v67;
  uint64_t v68;
  uint64_t v69;
  const void **v70;
  char *v71;
  unint64_t **v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  _QWORD *v76;
  const void *v77;
  uint64_t v78;
  uint64_t v79;
  const void **v80;
  char *v81;
  uint64_t *v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  _QWORD *v86;
  char *v87;
  char **v88;
  uint64_t v89;
  unint64_t v90;
  unint64_t v91;
  char *v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  _QWORD *v96;
  char *v97;
  char **v98;
  uint64_t v99;
  unint64_t v100;
  unint64_t v101;
  char *v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  _QWORD *v106;
  const void *v107;
  uint64_t v108;
  uint64_t v109;
  const void **v110;
  char *v111;
  unint64_t **v112;
  uint64_t v113;
  unint64_t v114;
  unint64_t v115;
  char *v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  _QWORD *v120;
  char *v121;
  char **v122;
  uint64_t *v123;
  char *v124;
  char *v125;
  uint64_t v126;
  void *v127;
  uint64_t v128;
  unint64_t v129;
  unint64_t v130;
  char *v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  _QWORD *v135;
  char *v136;
  char *v137;
  uint64_t *v138;
  char *v139;
  char *v140;
  uint64_t v141;
  uint64_t v142;
  unint64_t v143;
  unint64_t v144;
  char *v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  _QWORD *v149;
  uint64_t *v150;
  char *v151;
  char *v152;
  uint64_t v153;
  uint64_t v154;
  unint64_t v155;
  unint64_t v156;
  char *v157;
  uint64_t *v158;
  char *v159;
  char *v160;
  uint64_t v161;
  uint64_t v162;
  unint64_t v163;
  unint64_t v164;
  char *v165;
  uint64_t *v166;
  char *v167;
  char *v168;
  uint64_t v169;
  uint64_t *v170;
  char *v171;
  char *v172;
  uint64_t v173;
  uint64_t *v174;
  char *v175;
  char *v176;
  uint64_t v177;
  const void **v178;
  char *v179;
  _BYTE *v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  _QWORD *v184;
  uint64_t v185;
  unint64_t v186;
  unint64_t v187;
  char *v188;
  uint64_t *v189;
  char *v190;
  char *v191;
  uint64_t v192;
  uint64_t v193;
  std::__shared_weak_count *v194;
  unint64_t *p_shared_owners;
  uint64_t v196;
  unint64_t v197;
  std::__shared_weak_count *v198;
  unint64_t *v199;
  unint64_t v200;
  std::__shared_weak_count *v201;
  unint64_t *v202;
  unint64_t v203;
  uint64_t v204;
  uint64_t v206;
  char v208;
  char v210;
  char v212;
  char v213;
  char v216[8];
  uint64_t v217;
  _QWORD v218[2];
  void (*v219)(_QWORD *, char *);
  void *v220;
  void *__p;
  void *v222;
  uint64_t v223;
  _QWORD v224[2];
  char ***(*v225)(char ***, char **);
  void *v226;
  void *v227;
  void *v228;
  uint64_t v229;
  _QWORD v230[2];
  void (*v231)(uint64_t, unint64_t **);
  void *v232;
  void *v233;
  void *v234;
  uint64_t v235;
  _QWORD v236[2];
  char ***(*v237)(char ***, char **);
  void *v238;
  void *v239;
  void *v240;
  uint64_t v241;
  _QWORD v242[2];
  char ***(*v243)(char ***, char **);
  void *v244;
  void *v245;
  void *v246;
  uint64_t v247;
  _QWORD v248[2];
  void (*v249)(uint64_t, uint64_t *);
  void *v250;
  void *v251;
  void *v252;
  uint64_t v253;
  _QWORD v254[2];
  void (*v255)(uint64_t, unint64_t **);
  void *v256;
  void *v257;
  void *v258;
  uint64_t v259;
  _QWORD v260[2];
  void (*v261)(uint64_t, char *);
  void *v262;
  uint64_t v263;
  uint64_t v264;
  _QWORD v265[2];
  void (*v266)(uint64_t, _BYTE *);
  void *v267;
  uint64_t v268;
  char v269;
  __int128 v270;
  __int128 v271;
  _QWORD v272[5];
  std::__shared_weak_count *v273;
  _QWORD *v274;
  std::__shared_weak_count *v275;
  _QWORD aBlock[7];

  v13 = a5[1];
  v14 = *a5 != v13;
  v15 = 1;
  if (*a5 != v13)
    v15 = 2;
  if (*a6 != a6[1])
    v14 = v15;
  if (*a7 != a7[1])
    ++v14;
  if (*a8 != a8[1])
    ++v14;
  if (*a9 != a9[1])
    ++v14;
  if (*a10 != a10[1])
    ++v14;
  if (*a11 == a11[1])
    v16 = v14;
  else
    v16 = v14 + 1;
  v17 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 88) + 16))(*(_QWORD *)(a1 + 88));
  v18 = 0;
  v213 = 0;
  v212 = 0;
  v210 = 0;
  v208 = 0;
  v206 = 0;
  if ((a2 - 1) >= 3)
    v19 = 0;
  else
    v19 = a2;
  v20 = MEMORY[0x24BDAC760];
  do
  {
    v270 = 0u;
    v271 = 0u;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)&v270);
    v265[0] = v20;
    v265[1] = 0x40000000;
    v266 = (void (*)(uint64_t, _BYTE *))___ZN27QMICellMonitorCommandDriver28sendRegistrationHintsForSlotEN10subscriber7SimSlotE9FetchTypebNSt3__16vectorI14SystemRecord1xNS3_9allocatorIS5_EEEENS4_I16SystemRecordEVDONS6_IS9_EEEENS4_I15SystemRecordGSMNS6_ISC_EEEESE_NS4_I15SystemRecordLTENS6_ISF_EEEESE_NS4_I14SystemRecordNRNS6_ISI_EEEE_block_invoke;
    v267 = &__block_descriptor_tmp_19_6;
    v268 = a1;
    v269 = a3;
    v21 = (const void **)*((_QWORD *)&v270 + 1);
    if (*((_QWORD *)&v270 + 1) != (_QWORD)v271)
    {
      while (*((unsigned __int8 *)*v21 + 8) != 193)
      {
        if (++v21 == (const void **)v271)
          goto LABEL_27;
      }
    }
    if (v21 == (const void **)v271)
    {
LABEL_27:
      v23 = operator new();
      v24 = v23;
      *(_WORD *)(v23 + 8) = 193;
      *(_QWORD *)v23 = &off_24D5D4C50;
      v25 = v271;
      if ((unint64_t)v271 >= *((_QWORD *)&v271 + 1))
      {
        v27 = (uint64_t)(v271 - *((_QWORD *)&v270 + 1)) >> 3;
        if ((unint64_t)(v27 + 1) >> 61)
          goto LABEL_314;
        v28 = (uint64_t)(*((_QWORD *)&v271 + 1) - *((_QWORD *)&v270 + 1)) >> 2;
        if (v28 <= v27 + 1)
          v28 = v27 + 1;
        if (*((_QWORD *)&v271 + 1) - *((_QWORD *)&v270 + 1) >= 0x7FFFFFFFFFFFFFF8uLL)
          v29 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v29 = v28;
        if (v29)
          v30 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v271 + 8, v29);
        else
          v30 = 0;
        v31 = (uint64_t *)&v30[8 * v27];
        *v31 = v24;
        v26 = v31 + 1;
        v33 = (char *)*((_QWORD *)&v270 + 1);
        v32 = (char *)v271;
        if ((_QWORD)v271 != *((_QWORD *)&v270 + 1))
        {
          do
          {
            v34 = *((_QWORD *)v32 - 1);
            v32 -= 8;
            *--v31 = v34;
          }
          while (v32 != v33);
          v32 = (char *)*((_QWORD *)&v270 + 1);
        }
        *((_QWORD *)&v270 + 1) = v31;
        *(_QWORD *)&v271 = v26;
        *((_QWORD *)&v271 + 1) = &v30[8 * v29];
        if (v32)
          operator delete(v32);
      }
      else
      {
        *(_QWORD *)v271 = v23;
        v26 = (_QWORD *)(v25 + 8);
      }
      *(_QWORD *)&v271 = v26;
      v266((uint64_t)v265, (_BYTE *)(v24 + 9));
    }
    else
    {
      if (!v22)
        goto LABEL_313;
      ___ZN27QMICellMonitorCommandDriver28sendRegistrationHintsForSlotEN10subscriber7SimSlotE9FetchTypebNSt3__16vectorI14SystemRecord1xNS3_9allocatorIS5_EEEENS4_I16SystemRecordEVDONS6_IS9_EEEENS4_I15SystemRecordGSMNS6_ISC_EEEESE_NS4_I15SystemRecordLTENS6_ISF_EEEESE_NS4_I14SystemRecordNRNS6_ISI_EEEE_block_invoke((uint64_t)v265, v22 + 9);
    }
    v35 = (const void **)*((_QWORD *)&v270 + 1);
    if (*((_QWORD *)&v270 + 1) != (_QWORD)v271)
    {
      while (*((unsigned __int8 *)*v35 + 8) != 192)
      {
        if (++v35 == (const void **)v271)
          goto LABEL_51;
      }
    }
    if (v35 == (const void **)v271)
    {
LABEL_51:
      v38 = operator new();
      v39 = v38;
      *(_WORD *)(v38 + 8) = 192;
      *(_QWORD *)v38 = &off_24D5D4CA0;
      v40 = v271;
      if ((unint64_t)v271 >= *((_QWORD *)&v271 + 1))
      {
        v42 = (uint64_t)(v271 - *((_QWORD *)&v270 + 1)) >> 3;
        if ((unint64_t)(v42 + 1) >> 61)
LABEL_314:
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v43 = (uint64_t)(*((_QWORD *)&v271 + 1) - *((_QWORD *)&v270 + 1)) >> 2;
        if (v43 <= v42 + 1)
          v43 = v42 + 1;
        if (*((_QWORD *)&v271 + 1) - *((_QWORD *)&v270 + 1) >= 0x7FFFFFFFFFFFFFF8uLL)
          v44 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v44 = v43;
        if (v44)
          v45 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v271 + 8, v44);
        else
          v45 = 0;
        v46 = (uint64_t *)&v45[8 * v42];
        *v46 = v39;
        v41 = v46 + 1;
        v48 = (char *)*((_QWORD *)&v270 + 1);
        v47 = (char *)v271;
        if ((_QWORD)v271 != *((_QWORD *)&v270 + 1))
        {
          do
          {
            v49 = *((_QWORD *)v47 - 1);
            v47 -= 8;
            *--v46 = v49;
          }
          while (v47 != v48);
          v47 = (char *)*((_QWORD *)&v270 + 1);
        }
        *((_QWORD *)&v270 + 1) = v46;
        *(_QWORD *)&v271 = v41;
        *((_QWORD *)&v271 + 1) = &v45[8 * v44];
        if (v47)
          operator delete(v47);
      }
      else
      {
        *(_QWORD *)v271 = v38;
        v41 = (_QWORD *)(v40 + 8);
      }
      v37 = (_BYTE *)(v39 + 9);
      *(_QWORD *)&v271 = v41;
    }
    else
    {
      if (!v36)
LABEL_313:
        __cxa_bad_cast();
      v37 = v36 + 9;
    }
    *v37 = 0;
    v260[0] = v20;
    v260[1] = 0x40000000;
    v261 = ___ZN27QMICellMonitorCommandDriver28sendRegistrationHintsForSlotEN10subscriber7SimSlotE9FetchTypebNSt3__16vectorI14SystemRecord1xNS3_9allocatorIS5_EEEENS4_I16SystemRecordEVDONS6_IS9_EEEENS4_I15SystemRecordGSMNS6_ISC_EEEESE_NS4_I15SystemRecordLTENS6_ISF_EEEESE_NS4_I14SystemRecordNRNS6_ISI_EEEE_block_invoke_3;
    v262 = &__block_descriptor_tmp_24_6;
    v263 = v16;
    v264 = v17;
    v50 = qmi::MutableMessageBase::getTLV<nas::tlv::StatusType>(&v270);
    v261((uint64_t)v260, v50);
    if ((v18 & 1) != 0 || (v51 = *a5, v52 = (uint64_t)a5[1], v53 = v52 - (_QWORD)*a5, (const void *)v52 == *a5))
    {
      if ((v213 & 1) != 0 || (v55 = *a6, v56 = (uint64_t)a6[1], v57 = v56 - (_QWORD)*a6, (const void *)v56 == *a6))
      {
        if ((v212 & 1) != 0 || (v59 = *a7, v60 = (uint64_t)a7[1], v61 = v60 - (_QWORD)*a7, (const void *)v60 == *a7))
        {
          if ((v210 & 1) != 0 || (v63 = *a8, v64 = (uint64_t)a8[1], v65 = v64 - (_QWORD)*a8, (const void *)v64 == *a8))
          {
            if ((v208 & 1) != 0 || (v67 = *a9, v68 = (uint64_t)a9[1], v69 = v68 - (_QWORD)*a9, (const void *)v68 == *a9))
            {
              if ((v206 & 1) != 0
                || (v77 = *a10, v78 = (uint64_t)a10[1], v79 = v78 - (_QWORD)*a10, (const void *)v78 == *a10))
              {
                if ((v206 & 0x100000000) != 0)
                  goto LABEL_115;
                v107 = *a11;
                v108 = (uint64_t)a11[1];
                v109 = v108 - (_QWORD)*a11;
                if ((const void *)v108 == *a11)
                {
                  BYTE4(v206) = 0;
                  goto LABEL_273;
                }
                v218[0] = v20;
                v218[1] = 1174405120;
                v219 = (void (*)(_QWORD *, char *))___ZN27QMICellMonitorCommandDriver28sendRegistrationHintsForSlotEN10subscriber7SimSlotE9FetchTypebNSt3__16vectorI14SystemRecord1xNS3_9allocatorIS5_EEEENS4_I16SystemRecordEVDONS6_IS9_EEEENS4_I15SystemRecordGSMNS6_ISC_EEEESE_NS4_I15SystemRecordLTENS6_ISF_EEEESE_NS4_I14SystemRecordNRNS6_ISI_EEEE_block_invoke_38;
                v220 = &__block_descriptor_tmp_39_5;
                v222 = 0;
                v223 = 0;
                __p = 0;
                std::vector<SystemRecordNR>::__init_with_size[abi:ne180100]<SystemRecordNR*,SystemRecordNR*>(&__p, v107, v108, 0xCCCCCCCCCCCCCCCDLL * (v109 >> 2));
                v110 = (const void **)*((_QWORD *)&v270 + 1);
                if (*((_QWORD *)&v270 + 1) != (_QWORD)v271)
                {
                  while (*((unsigned __int8 *)*v110 + 8) != 224)
                  {
                    if (++v110 == (const void **)v271)
                      goto LABEL_205;
                  }
                }
                if (v110 == (const void **)v271)
                {
LABEL_205:
                  v146 = operator new();
                  v147 = v146;
                  *(_BYTE *)(v146 + 8) = -32;
                  *(_QWORD *)(v146 + 16) = 0;
                  v137 = (char *)(v146 + 16);
                  *(_QWORD *)v146 = &off_24D5D4F20;
                  *(_QWORD *)(v146 + 24) = 0;
                  *(_QWORD *)(v146 + 32) = 0;
                  v148 = v271;
                  if ((unint64_t)v271 >= *((_QWORD *)&v271 + 1))
                  {
                    v162 = (uint64_t)(v271 - *((_QWORD *)&v270 + 1)) >> 3;
                    if ((unint64_t)(v162 + 1) >> 61)
                      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
                    v163 = (uint64_t)(*((_QWORD *)&v271 + 1) - *((_QWORD *)&v270 + 1)) >> 2;
                    if (v163 <= v162 + 1)
                      v163 = v162 + 1;
                    if (*((_QWORD *)&v271 + 1) - *((_QWORD *)&v270 + 1) >= 0x7FFFFFFFFFFFFFF8uLL)
                      v164 = 0x1FFFFFFFFFFFFFFFLL;
                    else
                      v164 = v163;
                    if (v164)
                      v165 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v271 + 8, v164);
                    else
                      v165 = 0;
                    v174 = (uint64_t *)&v165[8 * v162];
                    *v174 = v147;
                    v149 = v174 + 1;
                    v176 = (char *)*((_QWORD *)&v270 + 1);
                    v175 = (char *)v271;
                    if ((_QWORD)v271 != *((_QWORD *)&v270 + 1))
                    {
                      do
                      {
                        v177 = *((_QWORD *)v175 - 1);
                        v175 -= 8;
                        *--v174 = v177;
                      }
                      while (v175 != v176);
                      v175 = (char *)*((_QWORD *)&v270 + 1);
                    }
                    *((_QWORD *)&v270 + 1) = v174;
                    *(_QWORD *)&v271 = v149;
                    *((_QWORD *)&v271 + 1) = &v165[8 * v164];
                    if (v175)
                      operator delete(v175);
                  }
                  else
                  {
                    *(_QWORD *)v271 = v146;
                    v149 = (_QWORD *)(v148 + 8);
                  }
                  *(_QWORD *)&v271 = v149;
                }
                else
                {
                  if (!v136)
                    __cxa_bad_cast();
                  v137 = v136 + 16;
                }
                v219(v218, v137);
                *qmi::MutableMessageBase::getTLV<nas::tlv::MessageComplete>(&v270) = --v16 == 0;
                v127 = __p;
                if (!__p)
                {
LABEL_115:
                  BYTE4(v206) = 1;
                  goto LABEL_273;
                }
                v222 = __p;
                BYTE4(v206) = 1;
              }
              else
              {
                v224[0] = v20;
                v224[1] = 1174405120;
                v225 = ___ZN27QMICellMonitorCommandDriver28sendRegistrationHintsForSlotEN10subscriber7SimSlotE9FetchTypebNSt3__16vectorI14SystemRecord1xNS3_9allocatorIS5_EEEENS4_I16SystemRecordEVDONS6_IS9_EEEENS4_I15SystemRecordGSMNS6_ISC_EEEESE_NS4_I15SystemRecordLTENS6_ISF_EEEESE_NS4_I14SystemRecordNRNS6_ISI_EEEE_block_invoke_36;
                v226 = &__block_descriptor_tmp_37_6;
                v228 = 0;
                v229 = 0;
                v227 = 0;
                std::vector<SystemRecordGSM>::__init_with_size[abi:ne180100]<SystemRecordGSM*,SystemRecordGSM*>(&v227, v77, v78, 0xCCCCCCCCCCCCCCCDLL * (v79 >> 1));
                v80 = (const void **)*((_QWORD *)&v270 + 1);
                if (*((_QWORD *)&v270 + 1) != (_QWORD)v271)
                {
                  while (*((unsigned __int8 *)*v80 + 8) != 178)
                  {
                    if (++v80 == (const void **)v271)
                      goto LABEL_181;
                  }
                }
                if (v80 == (const void **)v271)
                {
LABEL_181:
                  v132 = operator new();
                  v133 = v132;
                  *(_BYTE *)(v132 + 8) = -78;
                  *(_QWORD *)(v132 + 16) = 0;
                  v122 = (char **)(v132 + 16);
                  *(_QWORD *)v132 = &off_24D5D4ED0;
                  *(_QWORD *)(v132 + 24) = 0;
                  *(_QWORD *)(v132 + 32) = 0;
                  v134 = v271;
                  if ((unint64_t)v271 >= *((_QWORD *)&v271 + 1))
                  {
                    v154 = (uint64_t)(v271 - *((_QWORD *)&v270 + 1)) >> 3;
                    if ((unint64_t)(v154 + 1) >> 61)
                      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
                    v155 = (uint64_t)(*((_QWORD *)&v271 + 1) - *((_QWORD *)&v270 + 1)) >> 2;
                    if (v155 <= v154 + 1)
                      v155 = v154 + 1;
                    if (*((_QWORD *)&v271 + 1) - *((_QWORD *)&v270 + 1) >= 0x7FFFFFFFFFFFFFF8uLL)
                      v156 = 0x1FFFFFFFFFFFFFFFLL;
                    else
                      v156 = v155;
                    if (v156)
                      v157 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v271 + 8, v156);
                    else
                      v157 = 0;
                    v170 = (uint64_t *)&v157[8 * v154];
                    *v170 = v133;
                    v135 = v170 + 1;
                    v172 = (char *)*((_QWORD *)&v270 + 1);
                    v171 = (char *)v271;
                    if ((_QWORD)v271 != *((_QWORD *)&v270 + 1))
                    {
                      do
                      {
                        v173 = *((_QWORD *)v171 - 1);
                        v171 -= 8;
                        *--v170 = v173;
                      }
                      while (v171 != v172);
                      v171 = (char *)*((_QWORD *)&v270 + 1);
                    }
                    *((_QWORD *)&v270 + 1) = v170;
                    *(_QWORD *)&v271 = v135;
                    *((_QWORD *)&v271 + 1) = &v157[8 * v156];
                    if (v171)
                      operator delete(v171);
                  }
                  else
                  {
                    *(_QWORD *)v271 = v132;
                    v135 = (_QWORD *)(v134 + 8);
                  }
                  *(_QWORD *)&v271 = v135;
                }
                else
                {
                  if (!v121)
                    __cxa_bad_cast();
                  v122 = (char **)(v121 + 16);
                }
                v225((char ***)v224, v122);
                *qmi::MutableMessageBase::getTLV<nas::tlv::MessageComplete>(&v270) = --v16 == 0;
                v127 = v227;
                if (!v227)
                {
                  LOBYTE(v206) = 1;
                  goto LABEL_273;
                }
                v228 = v227;
                LOBYTE(v206) = 1;
              }
            }
            else
            {
              v230[0] = v20;
              v230[1] = 1174405120;
              v231 = ___ZN27QMICellMonitorCommandDriver28sendRegistrationHintsForSlotEN10subscriber7SimSlotE9FetchTypebNSt3__16vectorI14SystemRecord1xNS3_9allocatorIS5_EEEENS4_I16SystemRecordEVDONS6_IS9_EEEENS4_I15SystemRecordGSMNS6_ISC_EEEESE_NS4_I15SystemRecordLTENS6_ISF_EEEESE_NS4_I14SystemRecordNRNS6_ISI_EEEE_block_invoke_34;
              v232 = &__block_descriptor_tmp_35_4;
              v234 = 0;
              v235 = 0;
              v233 = 0;
              std::vector<SystemRecordLTE>::__init_with_size[abi:ne180100]<SystemRecordLTE*,SystemRecordLTE*>(&v233, v67, v68, v69 >> 4);
              v70 = (const void **)*((_QWORD *)&v270 + 1);
              if (*((_QWORD *)&v270 + 1) != (_QWORD)v271)
              {
                while (*((unsigned __int8 *)*v70 + 8) != 209)
                {
                  if (++v70 == (const void **)v271)
                    goto LABEL_158;
                }
              }
              if (v70 == (const void **)v271)
              {
LABEL_158:
                v117 = operator new();
                v118 = v117;
                *(_BYTE *)(v117 + 8) = -47;
                *(_QWORD *)(v117 + 16) = 0;
                v112 = (unint64_t **)(v117 + 16);
                *(_QWORD *)v117 = &off_24D5D4E80;
                *(_QWORD *)(v117 + 24) = 0;
                *(_QWORD *)(v117 + 32) = 0;
                v119 = v271;
                if ((unint64_t)v271 >= *((_QWORD *)&v271 + 1))
                {
                  v142 = (uint64_t)(v271 - *((_QWORD *)&v270 + 1)) >> 3;
                  if ((unint64_t)(v142 + 1) >> 61)
                    std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
                  v143 = (uint64_t)(*((_QWORD *)&v271 + 1) - *((_QWORD *)&v270 + 1)) >> 2;
                  if (v143 <= v142 + 1)
                    v143 = v142 + 1;
                  if (*((_QWORD *)&v271 + 1) - *((_QWORD *)&v270 + 1) >= 0x7FFFFFFFFFFFFFF8uLL)
                    v144 = 0x1FFFFFFFFFFFFFFFLL;
                  else
                    v144 = v143;
                  if (v144)
                    v145 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v271 + 8, v144);
                  else
                    v145 = 0;
                  v166 = (uint64_t *)&v145[8 * v142];
                  *v166 = v118;
                  v120 = v166 + 1;
                  v168 = (char *)*((_QWORD *)&v270 + 1);
                  v167 = (char *)v271;
                  if ((_QWORD)v271 != *((_QWORD *)&v270 + 1))
                  {
                    do
                    {
                      v169 = *((_QWORD *)v167 - 1);
                      v167 -= 8;
                      *--v166 = v169;
                    }
                    while (v167 != v168);
                    v167 = (char *)*((_QWORD *)&v270 + 1);
                  }
                  *((_QWORD *)&v270 + 1) = v166;
                  *(_QWORD *)&v271 = v120;
                  *((_QWORD *)&v271 + 1) = &v145[8 * v144];
                  if (v167)
                    operator delete(v167);
                }
                else
                {
                  *(_QWORD *)v271 = v117;
                  v120 = (_QWORD *)(v119 + 8);
                }
                *(_QWORD *)&v271 = v120;
              }
              else
              {
                if (!v111)
                  __cxa_bad_cast();
                v112 = (unint64_t **)(v111 + 16);
              }
              v231((uint64_t)v230, v112);
              *qmi::MutableMessageBase::getTLV<nas::tlv::MessageComplete>(&v270) = --v16 == 0;
              v127 = v233;
              if (!v233)
              {
                v208 = 1;
                goto LABEL_273;
              }
              v234 = v233;
              v208 = 1;
            }
          }
          else
          {
            v236[0] = v20;
            v236[1] = 1174405120;
            v237 = ___ZN27QMICellMonitorCommandDriver28sendRegistrationHintsForSlotEN10subscriber7SimSlotE9FetchTypebNSt3__16vectorI14SystemRecord1xNS3_9allocatorIS5_EEEENS4_I16SystemRecordEVDONS6_IS9_EEEENS4_I15SystemRecordGSMNS6_ISC_EEEESE_NS4_I15SystemRecordLTENS6_ISF_EEEESE_NS4_I14SystemRecordNRNS6_ISI_EEEE_block_invoke_32;
            v238 = &__block_descriptor_tmp_33_4;
            v240 = 0;
            v241 = 0;
            v239 = 0;
            std::vector<SystemRecordGSM>::__init_with_size[abi:ne180100]<SystemRecordGSM*,SystemRecordGSM*>(&v239, v63, v64, 0xCCCCCCCCCCCCCCCDLL * (v65 >> 1));
            v66 = (const void **)*((_QWORD *)&v270 + 1);
            if (*((_QWORD *)&v270 + 1) != (_QWORD)v271)
            {
              while (*((unsigned __int8 *)*v66 + 8) != 176)
              {
                if (++v66 == (const void **)v271)
                  goto LABEL_140;
              }
            }
            if (v66 == (const void **)v271)
            {
LABEL_140:
              v103 = operator new();
              v104 = v103;
              *(_BYTE *)(v103 + 8) = -80;
              *(_QWORD *)(v103 + 16) = 0;
              v98 = (char **)(v103 + 16);
              *(_QWORD *)v103 = &off_24D5D4E30;
              *(_QWORD *)(v103 + 24) = 0;
              *(_QWORD *)(v103 + 32) = 0;
              v105 = v271;
              if ((unint64_t)v271 >= *((_QWORD *)&v271 + 1))
              {
                v128 = (uint64_t)(v271 - *((_QWORD *)&v270 + 1)) >> 3;
                if ((unint64_t)(v128 + 1) >> 61)
                  std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
                v129 = (uint64_t)(*((_QWORD *)&v271 + 1) - *((_QWORD *)&v270 + 1)) >> 2;
                if (v129 <= v128 + 1)
                  v129 = v128 + 1;
                if (*((_QWORD *)&v271 + 1) - *((_QWORD *)&v270 + 1) >= 0x7FFFFFFFFFFFFFF8uLL)
                  v130 = 0x1FFFFFFFFFFFFFFFLL;
                else
                  v130 = v129;
                if (v130)
                  v131 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v271 + 8, v130);
                else
                  v131 = 0;
                v158 = (uint64_t *)&v131[8 * v128];
                *v158 = v104;
                v106 = v158 + 1;
                v160 = (char *)*((_QWORD *)&v270 + 1);
                v159 = (char *)v271;
                if ((_QWORD)v271 != *((_QWORD *)&v270 + 1))
                {
                  do
                  {
                    v161 = *((_QWORD *)v159 - 1);
                    v159 -= 8;
                    *--v158 = v161;
                  }
                  while (v159 != v160);
                  v159 = (char *)*((_QWORD *)&v270 + 1);
                }
                *((_QWORD *)&v270 + 1) = v158;
                *(_QWORD *)&v271 = v106;
                *((_QWORD *)&v271 + 1) = &v131[8 * v130];
                if (v159)
                  operator delete(v159);
              }
              else
              {
                *(_QWORD *)v271 = v103;
                v106 = (_QWORD *)(v105 + 8);
              }
              *(_QWORD *)&v271 = v106;
            }
            else
            {
              if (!v97)
                __cxa_bad_cast();
              v98 = (char **)(v97 + 16);
            }
            v237((char ***)v236, v98);
            *qmi::MutableMessageBase::getTLV<nas::tlv::MessageComplete>(&v270) = --v16 == 0;
            v127 = v239;
            if (!v239)
            {
              v210 = 1;
              goto LABEL_273;
            }
            v240 = v239;
            v210 = 1;
          }
        }
        else
        {
          v242[0] = v20;
          v242[1] = 1174405120;
          v243 = ___ZN27QMICellMonitorCommandDriver28sendRegistrationHintsForSlotEN10subscriber7SimSlotE9FetchTypebNSt3__16vectorI14SystemRecord1xNS3_9allocatorIS5_EEEENS4_I16SystemRecordEVDONS6_IS9_EEEENS4_I15SystemRecordGSMNS6_ISC_EEEESE_NS4_I15SystemRecordLTENS6_ISF_EEEESE_NS4_I14SystemRecordNRNS6_ISI_EEEE_block_invoke_30;
          v244 = &__block_descriptor_tmp_31_2;
          v246 = 0;
          v247 = 0;
          v245 = 0;
          std::vector<SystemRecordGSM>::__init_with_size[abi:ne180100]<SystemRecordGSM*,SystemRecordGSM*>(&v245, v59, v60, 0xCCCCCCCCCCCCCCCDLL * (v61 >> 1));
          v62 = (const void **)*((_QWORD *)&v270 + 1);
          if (*((_QWORD *)&v270 + 1) != (_QWORD)v271)
          {
            while (*((unsigned __int8 *)*v62 + 8) != 175)
            {
              if (++v62 == (const void **)v271)
                goto LABEL_127;
            }
          }
          if (v62 == (const void **)v271)
          {
LABEL_127:
            v93 = operator new();
            v94 = v93;
            *(_BYTE *)(v93 + 8) = -81;
            *(_QWORD *)(v93 + 16) = 0;
            v88 = (char **)(v93 + 16);
            *(_QWORD *)v93 = &off_24D5D4DE0;
            *(_QWORD *)(v93 + 24) = 0;
            *(_QWORD *)(v93 + 32) = 0;
            v95 = v271;
            if ((unint64_t)v271 >= *((_QWORD *)&v271 + 1))
            {
              v113 = (uint64_t)(v271 - *((_QWORD *)&v270 + 1)) >> 3;
              if ((unint64_t)(v113 + 1) >> 61)
                std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
              v114 = (uint64_t)(*((_QWORD *)&v271 + 1) - *((_QWORD *)&v270 + 1)) >> 2;
              if (v114 <= v113 + 1)
                v114 = v113 + 1;
              if (*((_QWORD *)&v271 + 1) - *((_QWORD *)&v270 + 1) >= 0x7FFFFFFFFFFFFFF8uLL)
                v115 = 0x1FFFFFFFFFFFFFFFLL;
              else
                v115 = v114;
              if (v115)
                v116 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v271 + 8, v115);
              else
                v116 = 0;
              v150 = (uint64_t *)&v116[8 * v113];
              *v150 = v94;
              v96 = v150 + 1;
              v152 = (char *)*((_QWORD *)&v270 + 1);
              v151 = (char *)v271;
              if ((_QWORD)v271 != *((_QWORD *)&v270 + 1))
              {
                do
                {
                  v153 = *((_QWORD *)v151 - 1);
                  v151 -= 8;
                  *--v150 = v153;
                }
                while (v151 != v152);
                v151 = (char *)*((_QWORD *)&v270 + 1);
              }
              *((_QWORD *)&v270 + 1) = v150;
              *(_QWORD *)&v271 = v96;
              *((_QWORD *)&v271 + 1) = &v116[8 * v115];
              if (v151)
                operator delete(v151);
            }
            else
            {
              *(_QWORD *)v271 = v93;
              v96 = (_QWORD *)(v95 + 8);
            }
            *(_QWORD *)&v271 = v96;
          }
          else
          {
            if (!v87)
              __cxa_bad_cast();
            v88 = (char **)(v87 + 16);
          }
          v243((char ***)v242, v88);
          *qmi::MutableMessageBase::getTLV<nas::tlv::MessageComplete>(&v270) = --v16 == 0;
          v127 = v245;
          if (!v245)
          {
            v212 = 1;
            goto LABEL_273;
          }
          v246 = v245;
          v212 = 1;
        }
      }
      else
      {
        v248[0] = v20;
        v248[1] = 1174405120;
        v249 = ___ZN27QMICellMonitorCommandDriver28sendRegistrationHintsForSlotEN10subscriber7SimSlotE9FetchTypebNSt3__16vectorI14SystemRecord1xNS3_9allocatorIS5_EEEENS4_I16SystemRecordEVDONS6_IS9_EEEENS4_I15SystemRecordGSMNS6_ISC_EEEESE_NS4_I15SystemRecordLTENS6_ISF_EEEESE_NS4_I14SystemRecordNRNS6_ISI_EEEE_block_invoke_28;
        v250 = &__block_descriptor_tmp_29_1;
        v252 = 0;
        v253 = 0;
        v251 = 0;
        std::vector<SystemRecordEVDO>::__init_with_size[abi:ne180100]<SystemRecordEVDO*,SystemRecordEVDO*>(&v251, v55, v56, 0xCCCCCCCCCCCCCCCDLL * (v57 >> 2));
        v58 = (const void **)*((_QWORD *)&v270 + 1);
        if (*((_QWORD *)&v270 + 1) != (_QWORD)v271)
        {
          while (*((unsigned __int8 *)*v58 + 8) != 164)
          {
            if (++v58 == (const void **)v271)
              goto LABEL_112;
          }
        }
        if (v58 == (const void **)v271)
        {
LABEL_112:
          v83 = operator new();
          v84 = v83;
          *(_BYTE *)(v83 + 8) = -92;
          *(_QWORD *)(v83 + 16) = 0;
          v82 = (uint64_t *)(v83 + 16);
          *(_QWORD *)v83 = off_24D5D4D90;
          *(_QWORD *)(v83 + 24) = 0;
          *(_QWORD *)(v83 + 32) = 0;
          v85 = v271;
          if ((unint64_t)v271 >= *((_QWORD *)&v271 + 1))
          {
            v99 = (uint64_t)(v271 - *((_QWORD *)&v270 + 1)) >> 3;
            if ((unint64_t)(v99 + 1) >> 61)
              std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
            v100 = (uint64_t)(*((_QWORD *)&v271 + 1) - *((_QWORD *)&v270 + 1)) >> 2;
            if (v100 <= v99 + 1)
              v100 = v99 + 1;
            if (*((_QWORD *)&v271 + 1) - *((_QWORD *)&v270 + 1) >= 0x7FFFFFFFFFFFFFF8uLL)
              v101 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v101 = v100;
            if (v101)
              v102 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v271 + 8, v101);
            else
              v102 = 0;
            v138 = (uint64_t *)&v102[8 * v99];
            *v138 = v84;
            v86 = v138 + 1;
            v140 = (char *)*((_QWORD *)&v270 + 1);
            v139 = (char *)v271;
            if ((_QWORD)v271 != *((_QWORD *)&v270 + 1))
            {
              do
              {
                v141 = *((_QWORD *)v139 - 1);
                v139 -= 8;
                *--v138 = v141;
              }
              while (v139 != v140);
              v139 = (char *)*((_QWORD *)&v270 + 1);
            }
            *((_QWORD *)&v270 + 1) = v138;
            *(_QWORD *)&v271 = v86;
            *((_QWORD *)&v271 + 1) = &v102[8 * v101];
            if (v139)
              operator delete(v139);
          }
          else
          {
            *(_QWORD *)v271 = v83;
            v86 = (_QWORD *)(v85 + 8);
          }
          *(_QWORD *)&v271 = v86;
        }
        else
        {
          if (!v81)
            __cxa_bad_cast();
          v82 = (uint64_t *)(v81 + 16);
        }
        v249((uint64_t)v248, v82);
        *qmi::MutableMessageBase::getTLV<nas::tlv::MessageComplete>(&v270) = --v16 == 0;
        v127 = v251;
        if (!v251)
        {
          v213 = 1;
          goto LABEL_273;
        }
        v252 = v251;
        v213 = 1;
      }
    }
    else
    {
      v254[0] = v20;
      v254[1] = 1174405120;
      v255 = ___ZN27QMICellMonitorCommandDriver28sendRegistrationHintsForSlotEN10subscriber7SimSlotE9FetchTypebNSt3__16vectorI14SystemRecord1xNS3_9allocatorIS5_EEEENS4_I16SystemRecordEVDONS6_IS9_EEEENS4_I15SystemRecordGSMNS6_ISC_EEEESE_NS4_I15SystemRecordLTENS6_ISF_EEEESE_NS4_I14SystemRecordNRNS6_ISI_EEEE_block_invoke_25;
      v256 = &__block_descriptor_tmp_27_6;
      v258 = 0;
      v259 = 0;
      v257 = 0;
      std::vector<SystemRecord1x>::__init_with_size[abi:ne180100]<SystemRecord1x*,SystemRecord1x*>(&v257, v51, v52, v53 >> 3);
      v54 = (const void **)*((_QWORD *)&v270 + 1);
      if (*((_QWORD *)&v270 + 1) != (_QWORD)v271)
      {
        while (*((unsigned __int8 *)*v54 + 8) != 163)
        {
          if (++v54 == (const void **)v271)
            goto LABEL_101;
        }
      }
      if (v54 == (const void **)v271)
      {
LABEL_101:
        v73 = operator new();
        v74 = v73;
        *(_BYTE *)(v73 + 8) = -93;
        *(_QWORD *)(v73 + 16) = 0;
        v72 = (unint64_t **)(v73 + 16);
        *(_QWORD *)v73 = &off_24D5D4D40;
        *(_QWORD *)(v73 + 24) = 0;
        *(_QWORD *)(v73 + 32) = 0;
        v75 = v271;
        if ((unint64_t)v271 >= *((_QWORD *)&v271 + 1))
        {
          v89 = (uint64_t)(v271 - *((_QWORD *)&v270 + 1)) >> 3;
          if ((unint64_t)(v89 + 1) >> 61)
            std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
          v90 = (uint64_t)(*((_QWORD *)&v271 + 1) - *((_QWORD *)&v270 + 1)) >> 2;
          if (v90 <= v89 + 1)
            v90 = v89 + 1;
          if (*((_QWORD *)&v271 + 1) - *((_QWORD *)&v270 + 1) >= 0x7FFFFFFFFFFFFFF8uLL)
            v91 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v91 = v90;
          if (v91)
            v92 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v271 + 8, v91);
          else
            v92 = 0;
          v123 = (uint64_t *)&v92[8 * v89];
          *v123 = v74;
          v76 = v123 + 1;
          v125 = (char *)*((_QWORD *)&v270 + 1);
          v124 = (char *)v271;
          if ((_QWORD)v271 != *((_QWORD *)&v270 + 1))
          {
            do
            {
              v126 = *((_QWORD *)v124 - 1);
              v124 -= 8;
              *--v123 = v126;
            }
            while (v124 != v125);
            v124 = (char *)*((_QWORD *)&v270 + 1);
          }
          *((_QWORD *)&v270 + 1) = v123;
          *(_QWORD *)&v271 = v76;
          *((_QWORD *)&v271 + 1) = &v92[8 * v91];
          if (v124)
            operator delete(v124);
        }
        else
        {
          *(_QWORD *)v271 = v73;
          v76 = (_QWORD *)(v75 + 8);
        }
        *(_QWORD *)&v271 = v76;
      }
      else
      {
        if (!v71)
          __cxa_bad_cast();
        v72 = (unint64_t **)(v71 + 16);
      }
      v255((uint64_t)v254, v72);
      *qmi::MutableMessageBase::getTLV<nas::tlv::MessageComplete>(&v270) = --v16 == 0;
      v127 = v257;
      if (!v257)
      {
        v18 = 1;
        goto LABEL_273;
      }
      v258 = v257;
      v18 = 1;
    }
    operator delete(v127);
LABEL_273:
    v178 = (const void **)*((_QWORD *)&v270 + 1);
    if (*((_QWORD *)&v270 + 1) != (_QWORD)v271)
    {
      while (*((unsigned __int8 *)*v178 + 8) != 195)
      {
        if (++v178 == (const void **)v271)
          goto LABEL_280;
      }
    }
    if (v178 == (const void **)v271)
    {
LABEL_280:
      v181 = operator new();
      v182 = v181;
      *(_WORD *)(v181 + 8) = 195;
      *(_QWORD *)v181 = &off_24D5D4F70;
      v183 = v271;
      if ((unint64_t)v271 >= *((_QWORD *)&v271 + 1))
      {
        v185 = (uint64_t)(v271 - *((_QWORD *)&v270 + 1)) >> 3;
        if ((unint64_t)(v185 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v186 = (uint64_t)(*((_QWORD *)&v271 + 1) - *((_QWORD *)&v270 + 1)) >> 2;
        if (v186 <= v185 + 1)
          v186 = v185 + 1;
        if (*((_QWORD *)&v271 + 1) - *((_QWORD *)&v270 + 1) >= 0x7FFFFFFFFFFFFFF8uLL)
          v187 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v187 = v186;
        if (v187)
          v188 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v271 + 8, v187);
        else
          v188 = 0;
        v189 = (uint64_t *)&v188[8 * v185];
        *v189 = v182;
        v184 = v189 + 1;
        v191 = (char *)*((_QWORD *)&v270 + 1);
        v190 = (char *)v271;
        if ((_QWORD)v271 != *((_QWORD *)&v270 + 1))
        {
          do
          {
            v192 = *((_QWORD *)v190 - 1);
            v190 -= 8;
            *--v189 = v192;
          }
          while (v190 != v191);
          v190 = (char *)*((_QWORD *)&v270 + 1);
        }
        *((_QWORD *)&v270 + 1) = v189;
        *(_QWORD *)&v271 = v184;
        *((_QWORD *)&v271 + 1) = &v188[8 * v187];
        if (v190)
          operator delete(v190);
      }
      else
      {
        *(_QWORD *)v271 = v181;
        v184 = (_QWORD *)(v183 + 8);
      }
      v180 = (_BYTE *)(v182 + 9);
      *(_QWORD *)&v271 = v184;
    }
    else
    {
      if (!v179)
        __cxa_bad_cast();
      v180 = v179 + 9;
    }
    *v180 = a4;
    v193 = qmi::ClientRouter::get();
    qmi::ClientRouter::SendProxy::SendProxy<nas::FrequencyHints::Request>((uint64_t)v216, v19, v193);
    v194 = (std::__shared_weak_count *)operator new(0x20uLL);
    v194->__shared_owners_ = 0;
    p_shared_owners = (unint64_t *)&v194->__shared_owners_;
    v194->__shared_weak_owners_ = 0;
    v194->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5D4FD8;
    v194[1].__vftable = (std::__shared_weak_count_vtbl *)v17;
    v274 = &v194[1].__vftable;
    v275 = v194;
    v196 = v217;
    v272[0] = v20;
    v272[1] = 1174405120;
    v272[2] = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN27QMICellMonitorCommandDriver28sendRegistrationHintsForSlotEN10subscriber7SimSlotE9FetchTypebNSt3__16vectorI14SystemRecord1xNS7_9allocatorIS9_EEEENS8_I16SystemRecordEVDONSA_ISD_EEEENS8_I15SystemRecordGSMNSA_ISG_EEEESI_NS8_I15SystemRecordLTENSA_ISJ_EEEESI_NS8_I14SystemRecordNRNSA_ISM_EEEEE3__2EEOS1_OT__block_invoke;
    v272[3] = &__block_descriptor_tmp_73_1;
    v272[4] = v194 + 1;
    v273 = v194;
    do
      v197 = __ldxr(p_shared_owners);
    while (__stxr(v197 + 1, p_shared_owners));
    aBlock[0] = v20;
    aBlock[1] = 0x40000000;
    aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_13;
    aBlock[3] = &unk_24D5D4C08;
    aBlock[4] = v272;
    *(_QWORD *)(v196 + 32) = _Block_copy(aBlock);
    v198 = v273;
    if (v273)
    {
      v199 = (unint64_t *)&v273->__shared_owners_;
      do
        v200 = __ldaxr(v199);
      while (__stlxr(v200 - 1, v199));
      if (!v200)
      {
        ((void (*)(std::__shared_weak_count *))v198->__on_zero_shared)(v198);
        std::__shared_weak_count::__release_weak(v198);
      }
    }
    v201 = v275;
    if (v275)
    {
      v202 = (unint64_t *)&v275->__shared_owners_;
      do
        v203 = __ldaxr(v202);
      while (__stlxr(v203 - 1, v202));
      if (!v203)
      {
        ((void (*)(std::__shared_weak_count *))v201->__on_zero_shared)(v201);
        std::__shared_weak_count::__release_weak(v201);
      }
    }
    v204 = v217;
    v217 = 0;
    if (v204)
      std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v217, v204);
    qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&v270);
  }
  while (v16);
}

void sub_2168A58A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void *__p)
{
  uint64_t v40;

  if (__p)
    operator delete(__p);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)(v40 - 256));
  _Unwind_Resume(a1);
}

void QMICellMonitorCommandDriver::sendRegistrationHints(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  unsigned int *v13;
  unsigned int v14;
  uint64_t v15;
  unsigned int *v16;
  unsigned int *v22;
  unsigned int *v23;
  uint64_t (*v24)(_QWORD);
  void *__p;
  void *v26;
  uint64_t v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  uint64_t v33;
  void *v34;
  void *v35;
  uint64_t v36;
  void *v37;
  void *v38;
  uint64_t v39;
  void *v40;
  void *v41;
  uint64_t v42;
  void *v43;
  void *v44;
  uint64_t v45;

  subscriber::makeSimSlotRange();
  v13 = v22;
  if (v22 != v23)
  {
    while ((v24(*v13) & 1) == 0)
    {
      if (++v13 == v23)
      {
        v13 = v23;
        break;
      }
    }
    while (v13 != v23)
    {
      v14 = *v13;
      if (*v13 == 3)
      {
        v15 = 3;
      }
      else if (v14 == 2)
      {
        v15 = 2;
      }
      else
      {
        v15 = v14 == 1;
      }
      v43 = 0;
      v44 = 0;
      v45 = 0;
      std::vector<SystemRecord1x>::__init_with_size[abi:ne180100]<SystemRecord1x*,SystemRecord1x*>(&v43, *(const void **)a5, *(_QWORD *)(a5 + 8), (uint64_t)(*(_QWORD *)(a5 + 8) - *(_QWORD *)a5) >> 3);
      v40 = 0;
      v41 = 0;
      v42 = 0;
      std::vector<SystemRecordEVDO>::__init_with_size[abi:ne180100]<SystemRecordEVDO*,SystemRecordEVDO*>(&v40, *(const void **)a6, *(_QWORD *)(a6 + 8), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(_QWORD *)(a6 + 8) - *(_QWORD *)a6) >> 2));
      v37 = 0;
      v38 = 0;
      v39 = 0;
      std::vector<SystemRecordGSM>::__init_with_size[abi:ne180100]<SystemRecordGSM*,SystemRecordGSM*>(&v37, *(const void **)a7, *(_QWORD *)(a7 + 8), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(_QWORD *)(a7 + 8) - *(_QWORD *)a7) >> 1));
      v34 = 0;
      v35 = 0;
      v36 = 0;
      std::vector<SystemRecordGSM>::__init_with_size[abi:ne180100]<SystemRecordGSM*,SystemRecordGSM*>(&v34, *(const void **)a8, *(_QWORD *)(a8 + 8), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(_QWORD *)(a8 + 8) - *(_QWORD *)a8) >> 1));
      v31 = 0;
      v32 = 0;
      v33 = 0;
      std::vector<SystemRecordLTE>::__init_with_size[abi:ne180100]<SystemRecordLTE*,SystemRecordLTE*>(&v31, *(const void **)a9, *(_QWORD *)(a9 + 8), (uint64_t)(*(_QWORD *)(a9 + 8) - *(_QWORD *)a9) >> 4);
      v28 = 0;
      v29 = 0;
      v30 = 0;
      std::vector<SystemRecordGSM>::__init_with_size[abi:ne180100]<SystemRecordGSM*,SystemRecordGSM*>(&v28, *(const void **)a10, *(_QWORD *)(a10 + 8), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(_QWORD *)(a10 + 8) - *(_QWORD *)a10) >> 1));
      __p = 0;
      v26 = 0;
      v27 = 0;
      std::vector<SystemRecordNR>::__init_with_size[abi:ne180100]<SystemRecordNR*,SystemRecordNR*>(&__p, *(const void **)a11, *(_QWORD *)(a11 + 8), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(_QWORD *)(a11 + 8) - *(_QWORD *)a11) >> 2));
      (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD, void **, void **, void **, void **, void **, void **, void **))(*(_QWORD *)a1 + 72))(a1, v15, a3, a4, &v43, &v40, &v37, &v34, &v31, &v28, &__p);
      if (__p)
      {
        v26 = __p;
        operator delete(__p);
      }
      if (v28)
      {
        v29 = v28;
        operator delete(v28);
      }
      if (v31)
      {
        v32 = v31;
        operator delete(v31);
      }
      if (v34)
      {
        v35 = v34;
        operator delete(v34);
      }
      if (v37)
      {
        v38 = v37;
        operator delete(v37);
      }
      if (v40)
      {
        v41 = v40;
        operator delete(v40);
      }
      if (v43)
      {
        v44 = v43;
        operator delete(v43);
      }
      v16 = v13 + 1;
      v13 = v23;
      if (v16 != v23)
      {
        v13 = v16;
        while ((v24(*v13) & 1) == 0)
        {
          if (++v13 == v23)
          {
            v13 = v23;
            break;
          }
        }
      }
    }
  }
}

void sub_2168A5C74(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31)
{
  uint64_t v31;
  void *v33;
  void *v34;
  void *v35;

  if (__p)
    operator delete(__p);
  if (a24)
    operator delete(a24);
  if (a27)
    operator delete(a27);
  if (a30)
    operator delete(a30);
  v33 = *(void **)(v31 - 160);
  if (v33)
  {
    *(_QWORD *)(v31 - 152) = v33;
    operator delete(v33);
  }
  v34 = *(void **)(v31 - 136);
  if (v34)
  {
    *(_QWORD *)(v31 - 128) = v34;
    operator delete(v34);
  }
  v35 = *(void **)(v31 - 112);
  if (v35)
  {
    *(_QWORD *)(v31 - 104) = v35;
    operator delete(v35);
  }
  _Unwind_Resume(exception_object);
}

void QMIDataCommandDriver::handleBandwidthInfo(uint64_t a1)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  std::__shared_weak_count *v11;

  v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    v3 = std::__shared_weak_count::lock(v2);
    v11 = v3;
    if (v3)
    {
      v4 = v3;
      v5 = *(_QWORD *)(a1 + 40);
      v10 = v5;
      if (v5)
      {
        v9 = 0;
        v8 = 0;
        rest::BandwidthInfo::BandwidthInfo();
        (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v5 + 936))(v5, &v8);
      }
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v7 = __ldaxr(p_shared_owners);
      while (__stlxr(v7 - 1, p_shared_owners));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
}

void sub_2168A5DE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void cast_message_type<nas::SysInfo::Indication const&>::cast(uint64_t a1@<X0>, qmi::MessageBase *a2@<X8>)
{
  if (*(_DWORD *)(a1 + 40) != 1 || *(_WORD *)(a1 + 44) == 3)
  {
    QMIServiceMsg::serialize((QMIServiceMsg *)a1);
    qmi::Indication<(unsigned short)78,nas::SysInfo::IndicationTLVList>::Indication(a2, 0);
  }
  else
  {
    QMIServiceMsg::getNewError((QMIServiceMsg *)a1);
    qmi::Indication<(unsigned short)78,nas::SysInfo::IndicationTLVList>::Indication((uint64_t)a2);
  }
}

void sub_2168A5E84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t **ServingSystem::ratSystem(uint64_t a1, int a2)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  BOOL v8;
  uint64_t *v9;
  uint64_t **v10;
  __int128 v12;
  void *v13[2];
  __int128 v14;
  __int128 v15;
  void *__p[2];
  __int128 v17;
  __int128 v18;
  int v19;

  v19 = a2;
  v4 = 1;
  if (!*(_BYTE *)(a1 + 32))
  {
    v13[0] = 0;
    v12 = (unint64_t)&v12 + 8;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)(a1 + 24) = 0;
    *(_QWORD *)(a1 + 8) = a1 + 16;
    *(_BYTE *)(a1 + 32) = 1;
    std::__tree<std::__value_type<RadioAccessTechnology,ServingSystem::System>,std::__map_value_compare<RadioAccessTechnology,std::__value_type<RadioAccessTechnology,ServingSystem::System>,std::less<RadioAccessTechnology>,true>,std::allocator<std::__value_type<RadioAccessTechnology,ServingSystem::System>>>::destroy(0);
    v4 = *(unsigned __int8 *)(a1 + 32);
    if (!*(_BYTE *)(a1 + 32))
      goto LABEL_22;
  }
  v5 = *(_QWORD *)(a1 + 16);
  if (!v5)
    goto LABEL_13;
  v6 = a1 + 16;
  do
  {
    v7 = *(_DWORD *)(v5 + 32);
    v8 = v7 < a2;
    if (v7 >= a2)
      v9 = (uint64_t *)v5;
    else
      v9 = (uint64_t *)(v5 + 8);
    if (!v8)
      v6 = v5;
    v5 = *v9;
  }
  while (*v9);
  if (v6 == a1 + 16 || *(_DWORD *)(v6 + 32) > a2)
  {
LABEL_13:
    v17 = 0u;
    v18 = 0u;
    v15 = 0u;
    *(_OWORD *)__p = 0u;
    *(_OWORD *)v13 = 0u;
    v14 = 0u;
    v12 = 0u;
    DWORD2(v18) = a2;
    v10 = std::__tree<std::__value_type<RadioAccessTechnology,ServingSystem::System>,std::__map_value_compare<RadioAccessTechnology,std::__value_type<RadioAccessTechnology,ServingSystem::System>,std::less<RadioAccessTechnology>,true>,std::allocator<std::__value_type<RadioAccessTechnology,ServingSystem::System>>>::__emplace_unique_key_args<RadioAccessTechnology,std::piecewise_construct_t const&,std::tuple<RadioAccessTechnology const&>,std::tuple<>>((uint64_t **)(a1 + 8), a2, &v19);
    v10[5] = 0;
    *((_DWORD *)v10 + 12) = DWORD2(v12);
    std::__optional_storage_base<MCC,false>::__assign_from[abi:ne180100]<std::__optional_copy_assign_base<MCC,false> const&>((uint64_t)(v10 + 7), (uint64_t)v13);
    std::__optional_storage_base<MNC,false>::__assign_from[abi:ne180100]<std::__optional_copy_assign_base<MNC,false> const&>((MCC *)(v10 + 12), (unsigned __int8 *)&v15 + 8);
    v10[17] = (uint64_t *)v18;
    *((_DWORD *)v10 + 36) = DWORD2(v18);
    if (BYTE8(v17) && SBYTE7(v17) < 0)
      operator delete(__p[0]);
    if ((_BYTE)v15 && SHIBYTE(v14) < 0)
      operator delete(v13[1]);
    v4 = *(unsigned __int8 *)(a1 + 32);
  }
  if (!v4)
LABEL_22:
    std::__throw_bad_optional_access[abi:ne180100]();
  return std::__tree<std::__value_type<RadioAccessTechnology,ServingSystem::System>,std::__map_value_compare<RadioAccessTechnology,std::__value_type<RadioAccessTechnology,ServingSystem::System>,std::less<RadioAccessTechnology>,true>,std::allocator<std::__value_type<RadioAccessTechnology,ServingSystem::System>>>::__emplace_unique_key_args<RadioAccessTechnology,std::piecewise_construct_t const&,std::tuple<RadioAccessTechnology const&>,std::tuple<>>((uint64_t **)(a1 + 8), a2, &v19)+ 5;
}

void sub_2168A6018(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  ServingSystem::System::~System(&a9);
  _Unwind_Resume(a1);
}

uint64_t **ServingSystem::gsmSystem(uint64_t a1, int a2)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  BOOL v8;
  uint64_t *v9;
  uint64_t **v10;
  void *v12[2];
  __int128 v13;
  __int128 v14;
  void *__p[2];
  __int128 v16;
  _OWORD v17[2];
  int v18;

  v18 = a2;
  v4 = 1;
  if (!*(_BYTE *)(a1 + 120))
  {
    v12[1] = 0;
    *(_QWORD *)&v13 = 0;
    v12[0] = &v12[1];
    *(_QWORD *)(a1 + 104) = 0;
    *(_QWORD *)(a1 + 112) = 0;
    *(_QWORD *)(a1 + 96) = a1 + 104;
    *(_BYTE *)(a1 + 120) = 1;
    std::__tree<std::__value_type<RadioAccessTechnology,ServingSystem::GSMSystem>,std::__map_value_compare<RadioAccessTechnology,std::__value_type<RadioAccessTechnology,ServingSystem::GSMSystem>,std::less<RadioAccessTechnology>,true>,std::allocator<std::__value_type<RadioAccessTechnology,ServingSystem::GSMSystem>>>::destroy(0);
    v4 = *(unsigned __int8 *)(a1 + 120);
    if (!*(_BYTE *)(a1 + 120))
      goto LABEL_22;
  }
  v5 = *(_QWORD *)(a1 + 104);
  if (!v5)
    goto LABEL_13;
  v6 = a1 + 104;
  do
  {
    v7 = *(_DWORD *)(v5 + 32);
    v8 = v7 < a2;
    if (v7 >= a2)
      v9 = (uint64_t *)v5;
    else
      v9 = (uint64_t *)(v5 + 8);
    if (!v8)
      v6 = v5;
    v5 = *v9;
  }
  while (*v9);
  if (v6 == a1 + 104 || *(_DWORD *)(v6 + 32) > a2)
  {
LABEL_13:
    memset(v17, 0, sizeof(v17));
    *(_OWORD *)__p = 0u;
    v16 = 0u;
    v13 = 0u;
    v14 = 0u;
    *(_OWORD *)v12 = 0u;
    DWORD2(v17[1]) = a2;
    v10 = std::__tree<std::__value_type<RadioAccessTechnology,ServingSystem::GSMSystem>,std::__map_value_compare<RadioAccessTechnology,std::__value_type<RadioAccessTechnology,ServingSystem::GSMSystem>,std::less<RadioAccessTechnology>,true>,std::allocator<std::__value_type<RadioAccessTechnology,ServingSystem::GSMSystem>>>::__emplace_unique_key_args<RadioAccessTechnology,std::piecewise_construct_t const&,std::tuple<RadioAccessTechnology const&>,std::tuple<>>((uint64_t **)(a1 + 96), a2, &v18);
    std::__optional_storage_base<MCC,false>::__assign_from[abi:ne180100]<std::__optional_copy_assign_base<MCC,false> const&>((uint64_t)(v10 + 5), (uint64_t)v12);
    std::__optional_storage_base<MNC,false>::__assign_from[abi:ne180100]<std::__optional_copy_assign_base<MNC,false> const&>((MCC *)(v10 + 10), (unsigned __int8 *)&v14 + 8);
    *(_OWORD *)(v10 + 15) = v17[0];
    *(_OWORD *)((char *)v10 + 132) = *(_OWORD *)((char *)v17 + 12);
    if (BYTE8(v16) && SBYTE7(v16) < 0)
      operator delete(__p[0]);
    if ((_BYTE)v14 && SHIBYTE(v13) < 0)
      operator delete(v12[1]);
    v4 = *(unsigned __int8 *)(a1 + 120);
  }
  if (!v4)
LABEL_22:
    std::__throw_bad_optional_access[abi:ne180100]();
  return std::__tree<std::__value_type<RadioAccessTechnology,ServingSystem::GSMSystem>,std::__map_value_compare<RadioAccessTechnology,std::__value_type<RadioAccessTechnology,ServingSystem::GSMSystem>,std::less<RadioAccessTechnology>,true>,std::allocator<std::__value_type<RadioAccessTechnology,ServingSystem::GSMSystem>>>::__emplace_unique_key_args<RadioAccessTechnology,std::piecewise_construct_t const&,std::tuple<RadioAccessTechnology const&>,std::tuple<>>((uint64_t **)(a1 + 96), a2, &v18)+ 5;
}

void sub_2168A6194(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  ServingSystem::GSMSystem::~GSMSystem(&a9);
  _Unwind_Resume(a1);
}

void filterMNC(const MNC *a1@<X0>, MNC *a2@<X8>)
{
  if (MCC::getIntValue(a1) == 1023)
    MNC::MNC(a2);
  else
    MCC::MCC(a2, a1);
}

void filterMCC(const MCC *a1@<X0>, MCC *a2@<X8>)
{
  if (MCC::getIntValue(a1) == 1023)
    MCC::MCC(a2);
  else
    MCC::MCC();
}

uint64_t translateToNasRegistrationState(uint64_t a1, int a2, int a3, int a4)
{
  char v4;
  char v5;

  v4 = 1;
  switch(a2)
  {
    case 0:
    case 1:
    case 3:
      if (a4)
        v5 = 3;
      else
        v5 = 2;
      goto LABEL_11;
    case 2:
      return v4;
    case 4:
      if (a4)
        v5 = 3;
      else
        v5 = 0;
LABEL_11:
      if (a3 == 4)
        v5 = 3;
      if (a3 == 2)
        v4 = 3;
      else
        v4 = v5;
      break;
    default:
      if (((a3 - 2) & 0xFFFFFFFD) != 0)
        v4 = 4;
      else
        v4 = 3;
      break;
  }
  return v4;
}

void convertMccAndMnc(unsigned __int8 *a1, unsigned __int8 *a2, const MCC *a3, const MNC *a4)
{
  int v7;
  int v9;
  int v10;
  uint64_t v11;
  void *__p;
  char v13;
  std::string v14;
  std::string v15;

  memset(&v15, 0, sizeof(v15));
  memset(&v14, 0, sizeof(v14));
  v7 = *a1;
  if (v7 != 255 && a1[1] != 255 && a1[2] != 255)
  {
    std::string::push_back(&v15, v7);
    std::string::push_back(&v15, a1[1]);
    std::string::push_back(&v15, a1[2]);
  }
  v9 = *a2;
  if (v9 != 255 && a2[1] != 255)
  {
    std::string::push_back(&v14, v9);
    std::string::push_back(&v14, a2[1]);
    v10 = a2[2];
    if (v10 != 255)
      std::string::push_back(&v14, v10);
  }
  MCC::MCC();
  MCC::operator=();
  if (v13 < 0)
    operator delete(__p);
  MNC::MNC();
  MCC::operator=();
  if (v13 < 0)
    operator delete(__p);
  filterMCC(a3, (MCC *)&v11);
  MCC::operator=();
  if (v13 < 0)
    operator delete(__p);
  filterMNC(a4, (MNC *)&v11);
  MCC::operator=();
  if (v13 < 0)
    operator delete(__p);
  if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v14.__r_.__value_.__l.__data_);
  if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v15.__r_.__value_.__l.__data_);
}

void sub_2168A64B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a15 < 0)
    operator delete(__p);
  if (a21 < 0)
    operator delete(a16);
  if (a27 < 0)
    operator delete(a22);
  _Unwind_Resume(exception_object);
}

uint64_t mapToRegStatus(os_log_t *a1, unsigned int a2)
{
  uint64_t v2;
  NSObject *v3;
  int v5;
  uint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  if (a2 > 3)
    v2 = 0;
  else
    v2 = dword_216AB9D10[a2];
  v3 = *a1;
  if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
  {
    v5 = 136315138;
    v6 = asString();
    _os_log_impl(&dword_216897000, v3, OS_LOG_TYPE_DEFAULT, "#I Mapping the registration state to %s", (uint8_t *)&v5, 0xCu);
  }
  return v2;
}

const char *dfs::asString(int a1)
{
  const char *result;

  result = "DFS_FILTER_STATUS_NONE";
  switch(a1)
  {
    case 0:
      return result;
    case 1:
      result = "DFS_FILTER_STATUS_INVALID";
      break;
    case 2:
      result = "DFS_FILTER_STATUS_VALID";
      break;
    case 3:
      result = "DFS_FILTER_STATUS_ACTIVE";
      break;
    case 4:
      result = "DFS_FILTER_STATUS_INACTIVE";
      break;
    case 5:
      result = "DFS_FILTER_STATUS_DELETED";
      break;
    default:
      if (a1 == 255)
        result = "DFS_FILTER_STATUS_MAX";
      else
        result = "UnknownValue";
      break;
  }
  return result;
}

uint64_t tlv::size<wds::tlv::ProfileTypeMask>()
{
  return 11;
}

_QWORD **tlv::writeV<wds::tlv::ProfileTypeMask>(_QWORD **result, _QWORD *a2)
{
  _QWORD *v2;

  v2 = *result;
  *v2 = *a2;
  *result = v2 + 1;
  return result;
}

void __clang_call_terminate(void *a1)
{
  __cxa_begin_catch(a1);
  std::terminate();
}

uint64_t tlv::parseV<wds::tlv::IPPref>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168A66BC(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168A66B0);
}

_BYTE **tlv::writeV<wds::tlv::IPPref>(_BYTE **result, _DWORD *a2)
{
  _BYTE *v2;

  v2 = *result;
  *v2 = *a2;
  *result = v2 + 1;
  return result;
}

uint64_t tlv::parseV<wds::tlv::PktDataHandle>(unint64_t *a1, int a2)
{
  unsigned int *v3;
  uint64_t result;

  v3 = (unsigned int *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 4uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168A671C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168A6710);
}

uint64_t tlv::size<wds::tlv::PktDataHandle>()
{
  return 7;
}

_DWORD **tlv::writeV<wds::tlv::PktDataHandle>(_DWORD **result, _DWORD *a2)
{
  _DWORD *v2;

  v2 = *result;
  *v2 = *a2;
  *result = v2 + 1;
  return result;
}

uint64_t tlv::parseV<wds::tlv::CallEndReason>(unint64_t *a1, int a2)
{
  unsigned __int16 *v3;
  uint64_t result;

  v3 = (unsigned __int16 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 2uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168A6784(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168A6778);
}

uint64_t tlv::parseV<wds::tlv::VerboseCallEndReasonType>(unint64_t *a1, int a2)
{
  unsigned __int16 *v3;
  const unsigned __int8 *v4;
  unsigned int v5;
  int v6;

  v3 = (unsigned __int16 *)*a1;
  v4 = (const unsigned __int8 *)(*a1 + a2);
  tlv::throwIfNotEnoughBytes(*a1, v4, 2uLL);
  v5 = *v3;
  tlv::throwIfNotEnoughBytes((unint64_t)(v3 + 1), v4, 2uLL);
  v6 = v3[1];
  *a1 = (unint64_t)(v3 + 2);
  return (v6 << 16) | v5;
}

void sub_2168A6800(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168A67ECLL);
}

uint64_t tlv::parseV<wds::tlv::IDataCallAppId>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168A684C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168A6840);
}

unint64_t tlv::parseV<wds::tlv::CarrierIPv6>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  unint64_t v5;
  const unsigned __int8 *v6;
  unint64_t result;

  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_BYTE *)(a3 + 16) = 0;
  v5 = *a1;
  v6 = (const unsigned __int8 *)(*a1 + a2);
  tlv::throwIfNotEnoughBytes(*a1, v6, 0x10uLL);
  *(_OWORD *)a3 = *(_OWORD *)v5;
  result = tlv::throwIfNotEnoughBytes(v5 + 16, v6, 1uLL);
  *(_BYTE *)(a3 + 16) = *(_BYTE *)(v5 + 16);
  *a1 = v5 + 17;
  return result;
}

void sub_2168A68D0(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
}

unint64_t tlv::parseV<wds::tlv::IPv6>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  unint64_t v5;
  const unsigned __int8 *v6;
  unint64_t result;

  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_BYTE *)(a3 + 16) = 0;
  v5 = *a1;
  v6 = (const unsigned __int8 *)(*a1 + a2);
  tlv::throwIfNotEnoughBytes(*a1, v6, 0x10uLL);
  *(_OWORD *)a3 = *(_OWORD *)v5;
  result = tlv::throwIfNotEnoughBytes(v5 + 16, v6, 1uLL);
  *(_BYTE *)(a3 + 16) = *(_BYTE *)(v5 + 16);
  *a1 = v5 + 17;
  return result;
}

void sub_2168A6958(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
}

uint64_t tlv::size<wds::tlv::HandOverContext>()
{
  return 24;
}

__n128 tlv::writeV<wds::tlv::HandOverContext>(uint64_t *a1, uint64_t a2)
{
  uint64_t v2;
  __n128 result;

  v2 = *a1;
  *(_DWORD *)v2 = *(_DWORD *)a2;
  result = *(__n128 *)(a2 + 4);
  *(__n128 *)(v2 + 4) = result;
  *(_BYTE *)(v2 + 20) = *(_BYTE *)(a2 + 20);
  *a1 = v2 + 21;
  return result;
}

char *wds::tlv::writeField(uint64_t a1, uint64_t a2)
{
  __int16 v3;
  __int16 v4;
  __int16 v5;
  char *v6;
  const void **v7;
  const void **v8;
  const void *v9;
  char *v10;
  int v11;
  const void *v12;
  size_t v13;
  char *v14;

  *(_BYTE *)a1 = *(_BYTE *)a2;
  *(_BYTE *)(a1 + 1) = *(_BYTE *)(a2 + 1);
  *(_BYTE *)(a1 + 2) = *(_BYTE *)(a2 + 2);
  v3 = *(_WORD *)(a2 + 3);
  *(_BYTE *)(a1 + 5) = *(_BYTE *)(a2 + 5);
  *(_WORD *)(a1 + 3) = v3;
  *(_BYTE *)(a1 + 6) = *(_BYTE *)(a2 + 6);
  *(_BYTE *)(a1 + 7) = *(_BYTE *)(a2 + 7);
  v4 = *(_WORD *)(a2 + 8);
  *(_BYTE *)(a1 + 10) = *(_BYTE *)(a2 + 10);
  *(_WORD *)(a1 + 8) = v4;
  *(_BYTE *)(a1 + 11) = *(_BYTE *)(a2 + 11);
  v5 = *(_WORD *)(a2 + 12);
  *(_BYTE *)(a1 + 14) = *(_BYTE *)(a2 + 14);
  *(_WORD *)(a1 + 12) = v5;
  v6 = (char *)(a1 + 16);
  *(_BYTE *)(a1 + 15) = -85 * ((*(_DWORD *)(a2 + 24) - *(_DWORD *)(a2 + 16)) >> 3);
  v7 = *(const void ***)(a2 + 16);
  v8 = *(const void ***)(a2 + 24);
  while (v7 != v8)
  {
    LOBYTE(v9) = *((_BYTE *)v7 + 23);
    if ((char)v9 < 0)
      v9 = v7[1];
    *v6 = (char)v9;
    v10 = v6 + 1;
    v11 = *((char *)v7 + 23);
    if (v11 >= 0)
      v12 = v7;
    else
      v12 = *v7;
    if (v11 >= 0)
      v13 = *((unsigned __int8 *)v7 + 23);
    else
      v13 = (size_t)v7[1];
    memcpy(v10, v12, v13);
    v14 = (char *)*((unsigned __int8 *)v7 + 23);
    if ((char)v14 < 0)
      v14 = (char *)v7[1];
    v6 = &v14[(_QWORD)v10];
    v7 += 3;
  }
  *v6 = *(_BYTE *)(a2 + 40);
  return v6 + 1;
}

uint64_t tlv::size<wds::tlv::ExtendedHandoffContext>(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v1 = *(_QWORD *)(a1 + 16);
  v2 = *(_QWORD *)(a1 + 24);
  if (v1 == v2)
    return 20;
  v3 = 0;
  do
  {
    v4 = *(unsigned __int8 *)(v1 + 23);
    if ((v4 & 0x80u) != 0)
      v4 = *(_QWORD *)(v1 + 8);
    v3 += v4 + 1;
    v1 += 24;
  }
  while (v1 != v2);
  return v3 + 20;
}

char *tlv::writeV<wds::tlv::ExtendedHandoffContext>(uint64_t *a1, uint64_t a2)
{
  char *result;

  result = wds::tlv::writeField(*a1, a2);
  *a1 = (uint64_t)result;
  return result;
}

uint64_t tlv::parseV<wds::tlv::PduSessionId>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168A6B60(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168A6B54);
}

uint64_t tlv::parseV<wds::tlv::ProhibitTimerHandle>(unint64_t *a1, int a2)
{
  unsigned int *v3;
  uint64_t result;

  v3 = (unsigned int *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 4uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168A6BAC(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168A6BA0);
}

unint64_t wds::tlv::parseField(unint64_t a1, const unsigned __int8 *a2, uint64_t a3)
{
  unint64_t result;

  tlv::throwIfNotEnoughBytes(a1, a2, 1uLL);
  *(_BYTE *)a3 = *(_BYTE *)a1 != 0;
  tlv::throwIfNotEnoughBytes(a1 + 1, a2, 4uLL);
  *(_DWORD *)(a3 + 4) = *(_DWORD *)(a1 + 1);
  tlv::throwIfNotEnoughBytes(a1 + 5, a2, 4uLL);
  result = a1 + 9;
  *(_DWORD *)(a3 + 8) = *(_DWORD *)(a1 + 5);
  return result;
}

{
  __int16 v6;
  __int16 v7;
  __int16 v8;

  tlv::throwIfNotEnoughBytes(a1, a2, 1uLL);
  *(_BYTE *)a3 = *(_BYTE *)a1;
  tlv::throwIfNotEnoughBytes(a1 + 1, a2, 1uLL);
  *(_BYTE *)(a3 + 1) = *(_BYTE *)(a1 + 1) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 2, a2, 1uLL);
  *(_BYTE *)(a3 + 2) = *(_BYTE *)(a1 + 2);
  tlv::throwIfNotEnoughBytes(a1 + 3, a2, 3uLL);
  v6 = *(_WORD *)(a1 + 3);
  *(_BYTE *)(a3 + 5) = *(_BYTE *)(a1 + 5);
  *(_WORD *)(a3 + 3) = v6;
  tlv::throwIfNotEnoughBytes(a1 + 6, a2, 1uLL);
  *(_BYTE *)(a3 + 6) = *(_BYTE *)(a1 + 6) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 7, a2, 1uLL);
  *(_BYTE *)(a3 + 7) = *(_BYTE *)(a1 + 7);
  tlv::throwIfNotEnoughBytes(a1 + 8, a2, 3uLL);
  v7 = *(_WORD *)(a1 + 8);
  *(_BYTE *)(a3 + 10) = *(_BYTE *)(a1 + 10);
  *(_WORD *)(a3 + 8) = v7;
  tlv::throwIfNotEnoughBytes(a1 + 11, a2, 1uLL);
  *(_BYTE *)(a3 + 11) = *(_BYTE *)(a1 + 11);
  tlv::throwIfNotEnoughBytes(a1 + 12, a2, 3uLL);
  v8 = *(_WORD *)(a1 + 12);
  *(_BYTE *)(a3 + 14) = *(_BYTE *)(a1 + 14);
  *(_WORD *)(a3 + 12) = v8;
  return a1 + 15;
}

{
  unint64_t result;

  tlv::throwIfNotEnoughBytes(a1, a2, 4uLL);
  *(_DWORD *)a3 = *(_DWORD *)a1;
  tlv::throwIfNotEnoughBytes(a1 + 4, a2, 4uLL);
  *(_DWORD *)(a3 + 4) = *(_DWORD *)(a1 + 4);
  tlv::throwIfNotEnoughBytes(a1 + 8, a2, 1uLL);
  *(_BYTE *)(a3 + 8) = *(_BYTE *)(a1 + 8);
  tlv::throwIfNotEnoughBytes(a1 + 9, a2, 1uLL);
  result = a1 + 10;
  *(_BYTE *)(a3 + 9) = *(_BYTE *)(a1 + 9) != 0;
  return result;
}

{
  tlv::throwIfNotEnoughBytes(a1, a2, 2uLL);
  *(_WORD *)a3 = *(_WORD *)a1;
  tlv::throwIfNotEnoughBytes(a1 + 2, a2, 1uLL);
  *(_BYTE *)(a3 + 2) = *(_BYTE *)(a1 + 2);
  tlv::throwIfNotEnoughBytes(a1 + 3, a2, 1uLL);
  *(_BYTE *)(a3 + 3) = *(_BYTE *)(a1 + 3);
  return a1 + 4;
}

{
  unint64_t v5;
  unint64_t v6;

  v5 = a1;
  tlv::throwIfNotEnoughBytes(a1, a2, 1uLL);
  *(_BYTE *)a3 = *(_BYTE *)v5 != 0;
  tlv::throwIfNotEnoughBytes(v5 + 1, a2, 0x10uLL);
  *(_OWORD *)(a3 + 1) = *(_OWORD *)(v5 + 1);
  tlv::throwIfNotEnoughBytes(v5 + 17, a2, 2uLL);
  v6 = *(unsigned __int16 *)(v5 + 17);
  v5 += 19;
  tlv::throwIfNotEnoughBytes(v5, a2, v6);
  std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((_QWORD *)(a3 + 24), (char *)v5, (char *)(v5 + v6), v6);
  return v5 + v6;
}

{
  tlv::throwIfNotEnoughBytes(a1, a2, 1uLL);
  *(_BYTE *)a3 = *(_BYTE *)a1;
  tlv::throwIfNotEnoughBytes(a1 + 1, a2, 4uLL);
  *(_DWORD *)(a3 + 4) = *(_DWORD *)(a1 + 1);
  tlv::throwIfNotEnoughBytes(a1 + 5, a2, 4uLL);
  *(_DWORD *)(a3 + 8) = *(_DWORD *)(a1 + 5);
  return a1 + 9;
}

uint64_t tlv::parseV<wds::tlv::ProhibitTimerInfo>(unint64_t *a1, int a2)
{
  uint64_t v3;
  int v4;

  v4 = 0;
  v3 = 0;
  *a1 = wds::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), (uint64_t)&v3);
  return v3;
}

void sub_2168A6C80(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168A6C68);
}

uint64_t tlv::size<wds::tlv::Profile3GPP_ProfileIdentifier>()
{
  return wds::tlv::getFieldSize() + 3;
}

_BYTE *tlv::writeV<wds::tlv::Profile3GPP_ProfileIdentifier>(_BYTE **a1, _BYTE *a2)
{
  _BYTE *result;

  result = wds::tlv::writeField(*a1, a2);
  *a1 = result;
  return result;
}

_BYTE *tlv::writeV<wds::tlv::Profile3GPP_PdpType>(_BYTE **a1, _DWORD *a2)
{
  _BYTE *result;

  result = wds::tlv::writeField(*a1, a2);
  *a1 = result;
  return result;
}

uint64_t tlv::size<wds::tlv::Profile3GPP_ApnName>(uint64_t a1)
{
  return wds::tlv::getFieldSize(a1) + 3;
}

char *tlv::writeV<wds::tlv::Profile3GPP_ApnName>(char **a1, _QWORD *a2)
{
  char *result;

  result = wds::tlv::writeField(*a1, a2);
  *a1 = result;
  return result;
}

uint64_t tlv::size<wds::tlv::Profile3GPP_IMSRequestQoSWithSigInd>()
{
  return wds::tlv::getFieldSize() + 3;
}

uint64_t tlv::writeV<wds::tlv::Profile3GPP_IMSRequestQoSWithSigInd>(uint64_t *a1, uint64_t a2)
{
  uint64_t result;

  result = wds::tlv::writeField(*a1, a2);
  *a1 = result;
  return result;
}

uint64_t tlv::size<wds::tlv::Profile3GPP_OperatorReservedPcoId>()
{
  return wds::tlv::getFieldSize() + 3;
}

_WORD *tlv::writeV<wds::tlv::Profile3GPP_OperatorReservedPcoId>(_WORD **a1, _WORD *a2)
{
  _WORD *result;

  result = wds::tlv::writeField(*a1, a2);
  *a1 = result;
  return result;
}

uint64_t tlv::size<wds::tlv::Profile3GPP_PcoMcc>()
{
  return 5;
}

_WORD **tlv::writeV<wds::tlv::Profile3GPP_PcoMcc>(_WORD **result, _WORD *a2)
{
  _WORD *v2;

  v2 = *result;
  *v2 = *a2;
  *result = v2 + 1;
  return result;
}

uint64_t tlv::size<wds::tlv::Profile3GPP_PcoMnc>()
{
  return 6;
}

uint64_t *tlv::writeV<wds::tlv::Profile3GPP_PcoMnc>(uint64_t *result, uint64_t a2)
{
  uint64_t v2;

  v2 = *result;
  *(_WORD *)v2 = *(_WORD *)a2;
  *(_BYTE *)(v2 + 2) = *(_BYTE *)(a2 + 2);
  *result = v2 + 3;
  return result;
}

uint64_t tlv::size<wds::tlv::Profile3GPP2_InactivityTimer>()
{
  return tlv::size<wds::tlv::IPPref>() + 3;
}

_DWORD *tlv::writeV<wds::tlv::Profile3GPP2_InactivityTimer>(_DWORD **a1, _DWORD *a2)
{
  _DWORD *result;

  result = wds::tlv::writeField(*a1, a2);
  *a1 = result;
  return result;
}

uint64_t tlv::parseV<wds::tlv::DeleteProfileStatus>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168A6E74(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168A6E68);
}

_BYTE **tlv::writeV<wds::tlv::ProfileIdentifer>(_BYTE **result, _BYTE *a2)
{
  _BYTE *v2;

  v2 = *result;
  *v2 = *a2;
  v2[1] = a2[1];
  *result = v2 + 2;
  return result;
}

_WORD *wds::tlv::writeField(_BYTE *a1, uint64_t a2)
{
  _BYTE *v3;
  __int16 v4;
  _BYTE *v5;
  char *v6;
  char *v7;
  __int16 v8;
  char *v9;
  char *v10;
  _BYTE *v11;
  _BYTE *v12;
  __int16 v13;
  _BYTE *v14;
  uint64_t v15;
  _WORD *v16;

  v3 = a1;
  if (*(_BYTE *)a2)
  {
    v4 = (_WORD)a1 + 3;
    v5 = wds::tlv::writeField(a1 + 3, (_DWORD *)(a2 + 4));
    *v3 = 17;
    *(_WORD *)(v3 + 1) = (_WORD)v5 - v4;
    v3 = v5;
  }
  v6 = wds::tlv::writeField(v3 + 3, (_QWORD *)(a2 + 8));
  v7 = v6;
  *v3 = 20;
  *(_WORD *)(v3 + 1) = (_WORD)v6 - ((_WORD)v3 + 3);
  if (*(_BYTE *)(a2 + 32))
  {
    v8 = (_WORD)v6 + 3;
    v9 = wds::tlv::writeField(v6 + 3, (_QWORD *)(a2 + 40));
    *v7 = 27;
    *(_WORD *)(v7 + 1) = (_WORD)v9 - v8;
    v7 = v9;
  }
  if (*(_BYTE *)(a2 + 64))
  {
    v10 = wds::tlv::writeField(v7 + 3, (_QWORD *)(a2 + 72));
    *v7 = 28;
    *(_WORD *)(v7 + 1) = (_WORD)v10 - ((_WORD)v7 + 3);
    v7 = v10;
  }
  v11 = wds::tlv::writeField(v7 + 3, (_BYTE *)(a2 + 96));
  v12 = v11;
  *v7 = 29;
  *(_WORD *)(v7 + 1) = (_WORD)v11 - ((_WORD)v7 + 3);
  if (*(_BYTE *)(a2 + 97))
  {
    v13 = (_WORD)v11 + 3;
    v14 = wds::tlv::writeField(v11 + 3, (_BYTE *)(a2 + 98));
    *v12 = 31;
    *(_WORD *)(v12 + 1) = (_WORD)v14 - v13;
    v12 = v14;
  }
  if (*(_BYTE *)(a2 + 100))
  {
    v15 = wds::tlv::writeField((uint64_t)(v12 + 3), a2 + 104);
    *v12 = 41;
    *(_WORD *)(v12 + 1) = v15 - ((_WORD)v12 + 3);
    v12 = (_BYTE *)v15;
  }
  if (*(_BYTE *)(a2 + 148))
  {
    v12[3] = *(_BYTE *)(a2 + 149);
    *(_WORD *)v12 = 310;
    v12[2] = 0;
    v12 += 4;
  }
  if (*(_BYTE *)(a2 + 150))
  {
    v16 = wds::tlv::writeField(v12 + 3, (_WORD *)(a2 + 152));
    *v12 = 55;
    *(_WORD *)(v12 + 1) = (_WORD)v16 - ((_WORD)v12 + 3);
    return v16;
  }
  return v12;
}

uint64_t wds::tlv::getFieldSize(_BYTE *a1)
{
  uint64_t v2;
  uint64_t FieldSize;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;

  if (*a1)
    v2 = wds::tlv::getFieldSize() + 9;
  else
    v2 = 6;
  FieldSize = wds::tlv::getFieldSize((uint64_t)(a1 + 8));
  if (a1[32])
    v4 = wds::tlv::getFieldSize((uint64_t)(a1 + 40)) + 3;
  else
    v4 = 0;
  if (a1[64])
    v5 = wds::tlv::getFieldSize((uint64_t)(a1 + 72)) + 3;
  else
    v5 = 0;
  v6 = wds::tlv::getFieldSize();
  if (a1[97])
    v7 = wds::tlv::getFieldSize() + 3;
  else
    v7 = 0;
  if (a1[100])
    v8 = wds::tlv::getFieldSize() + 3;
  else
    v8 = 0;
  v9 = a1[148];
  if (a1[150])
    v10 = wds::tlv::getFieldSize() + 3;
  else
    v10 = 0;
  return v2 + FieldSize + v4 + v5 + v6 + v7 + v8 + 4 * (v9 != 0) + v10;
}

uint64_t tlv::size<wds::tlv::Parameters3GPP>(_BYTE *a1)
{
  return wds::tlv::getFieldSize(a1) + 3;
}

_WORD *tlv::writeV<wds::tlv::Parameters3GPP>(_BYTE **a1, uint64_t a2)
{
  _WORD *result;

  result = wds::tlv::writeField(*a1, a2);
  *a1 = result;
  return result;
}

wds::tlv *wds::tlv::writeField(wds::tlv *this, unsigned __int8 *a2, const wds::tlv::Parameters3GPP2 *a3)
{
  wds::tlv *v4;
  __int16 v5;
  char *v6;
  wds::tlv *v7;
  char *v8;
  char *v9;
  wds::tlv *v10;
  wds::tlv *v11;
  char *v12;
  char *v13;
  wds::tlv *v14;
  wds::tlv *v15;
  _WORD *v16;

  v4 = this;
  if (*a2)
  {
    v5 = (_WORD)this + 3;
    v6 = wds::tlv::writeField((char *)this + 3, (_QWORD *)a2 + 1);
    *(_BYTE *)v4 = -95;
    *(_WORD *)((char *)v4 + 1) = (_WORD)v6 - v5;
    v4 = (wds::tlv *)v6;
  }
  if (a2[32])
  {
    v7 = (wds::tlv *)wds::tlv::writeField((_BYTE *)v4 + 3, (_DWORD *)a2 + 9);
    *(_BYTE *)v4 = -94;
    *(_WORD *)((char *)v4 + 1) = (_WORD)v7 - ((_WORD)v4 + 3);
    v4 = v7;
  }
  if (a2[40])
  {
    v8 = wds::tlv::writeField((char *)v4 + 3, (_QWORD *)a2 + 6);
    *(_BYTE *)v4 = -101;
    *(_WORD *)((char *)v4 + 1) = (_WORD)v8 - ((_WORD)v4 + 3);
    v4 = (wds::tlv *)v8;
  }
  if (a2[72])
  {
    v9 = wds::tlv::writeField((char *)v4 + 3, (_QWORD *)a2 + 10);
    *(_BYTE *)v4 = -100;
    *(_WORD *)((char *)v4 + 1) = (_WORD)v9 - ((_WORD)v4 + 3);
    v4 = (wds::tlv *)v9;
  }
  if (a2[104])
  {
    v10 = (wds::tlv *)wds::tlv::writeField((_BYTE *)v4 + 3, a2 + 105);
    *(_BYTE *)v4 = -102;
    *(_WORD *)((char *)v4 + 1) = (_WORD)v10 - ((_WORD)v4 + 3);
    v4 = v10;
  }
  if (a2[108])
  {
    v11 = (wds::tlv *)wds::tlv::writeField((wds::tlv *)((char *)v4 + 3), (_DWORD *)a2 + 28);
    *(_BYTE *)v4 = -86;
    *(_WORD *)((char *)v4 + 1) = (_WORD)v11 - ((_WORD)v4 + 3);
    v4 = v11;
  }
  if (a2[120])
  {
    v12 = wds::tlv::writeField((char *)v4 + 3, (_QWORD *)a2 + 16);
    *(_BYTE *)v4 = -82;
    *(_WORD *)((char *)v4 + 1) = (_WORD)v12 - ((_WORD)v4 + 3);
    v4 = (wds::tlv *)v12;
  }
  if (a2[152])
  {
    v13 = wds::tlv::writeField((char *)v4 + 3, (_QWORD *)a2 + 20);
    *(_BYTE *)v4 = -81;
    *(_WORD *)((char *)v4 + 1) = (_WORD)v13 - ((_WORD)v4 + 3);
    v4 = (wds::tlv *)v13;
  }
  if (a2[184])
  {
    v14 = (wds::tlv *)wds::tlv::writeField((_BYTE *)v4 + 3, a2 + 185);
    *(_BYTE *)v4 = -83;
    *(_WORD *)((char *)v4 + 1) = (_WORD)v14 - ((_WORD)v4 + 3);
    v4 = v14;
  }
  if (a2[186])
  {
    v15 = (wds::tlv *)wds::tlv::writeField((_BYTE *)v4 + 3, a2 + 187);
    *(_BYTE *)v4 = -93;
    *(_WORD *)((char *)v4 + 1) = (_WORD)v15 - ((_WORD)v4 + 3);
    v4 = v15;
  }
  if (a2[188])
  {
    v16 = wds::tlv::writeField((wds::tlv *)((char *)v4 + 3), (_WORD *)a2 + 95);
    *(_BYTE *)v4 = -67;
    *(_WORD *)((char *)v4 + 1) = (_WORD)v16 - ((_WORD)v4 + 3);
    return (wds::tlv *)v16;
  }
  return v4;
}

uint64_t wds::tlv::getFieldSize(wds::tlv *this, const wds::tlv::Parameters3GPP2 *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v14;

  if (*(_BYTE *)this)
    v14 = wds::tlv::getFieldSize((uint64_t)this + 8) + 3;
  else
    v14 = 0;
  if (*((_BYTE *)this + 32))
    v3 = wds::tlv::getFieldSize() + 3;
  else
    v3 = 0;
  if (*((_BYTE *)this + 40))
    v4 = wds::tlv::getFieldSize((uint64_t)this + 48) + 3;
  else
    v4 = 0;
  if (*((_BYTE *)this + 72))
    v5 = wds::tlv::getFieldSize((uint64_t)this + 80) + 3;
  else
    v5 = 0;
  if (*((_BYTE *)this + 104))
    v6 = wds::tlv::getFieldSize() + 3;
  else
    v6 = 0;
  if (*((_BYTE *)this + 108))
    v7 = tlv::size<wds::tlv::IPPref>() + 3;
  else
    v7 = 0;
  if (*((_BYTE *)this + 120))
    v8 = wds::tlv::getFieldSize((uint64_t)this + 128) + 3;
  else
    v8 = 0;
  if (*((_BYTE *)this + 152))
    v9 = wds::tlv::getFieldSize((uint64_t)this + 160) + 3;
  else
    v9 = 0;
  if (*((_BYTE *)this + 184))
    v10 = wds::tlv::getFieldSize() + 3;
  else
    v10 = 0;
  if (*((_BYTE *)this + 186))
    v11 = wds::tlv::getFieldSize() + 3;
  else
    v11 = 0;
  if (*((_BYTE *)this + 188))
    v12 = wds::tlv::getFieldSize() + 3;
  else
    v12 = 0;
  return v3 + v14 + v4 + v5 + v6 + v7 + v8 + v9 + v10 + v11 + v12;
}

uint64_t tlv::size<wds::tlv::Parameters3GPP2>(wds::tlv *a1, const wds::tlv::Parameters3GPP2 *a2)
{
  return wds::tlv::getFieldSize(a1, a2) + 3;
}

wds::tlv *tlv::writeV<wds::tlv::Parameters3GPP2>(wds::tlv **a1, unsigned __int8 *a2, const wds::tlv::Parameters3GPP2 *a3)
{
  wds::tlv *result;

  result = wds::tlv::writeField(*a1, a2, a3);
  *a1 = result;
  return result;
}

uint64_t tlv::size<wds::tlv::HandOverIPv6Prefix>()
{
  return 20;
}

__n128 tlv::writeV<wds::tlv::HandOverIPv6Prefix>(__n128 **a1, __n128 *a2)
{
  __n128 *v2;
  __n128 result;

  v2 = *a1;
  result = *a2;
  *v2 = *a2;
  v2[1].n128_u8[0] = a2[1].n128_u8[0];
  *a1 = (__n128 *)((char *)v2 + 17);
  return result;
}

uint64_t tlv::parseV<wds::tlv::PktStatus>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  const unsigned __int8 *v4;
  int v5;
  int v6;

  v3 = (unsigned __int8 *)*a1;
  v4 = (const unsigned __int8 *)(*a1 + a2);
  tlv::throwIfNotEnoughBytes(*a1, v4, 1uLL);
  v5 = *v3;
  tlv::throwIfNotEnoughBytes((unint64_t)(v3 + 1), v4, 1uLL);
  v6 = v3[1];
  *a1 = (unint64_t)(v3 + 2);
  return v5 | (v6 << 8);
}

void sub_2168A76C8(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168A76B4);
}

uint64_t tlv::parseV<wds::tlv::PrimaryDNSIPv4>(unint64_t *a1, int a2)
{
  unsigned int *v3;
  uint64_t result;

  v3 = (unsigned int *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 4uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168A7714(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168A7708);
}

uint64_t tlv::parseV<wds::tlv::SecondaryDNSIPv4>(unint64_t *a1, int a2)
{
  unsigned int *v3;
  uint64_t result;

  v3 = (unsigned int *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 4uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168A7760(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168A7754);
}

uint64_t tlv::parseV<wds::tlv::IPv4>(unint64_t *a1, int a2)
{
  unsigned int *v3;
  uint64_t result;

  v3 = (unsigned int *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 4uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168A77AC(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168A77A0);
}

int *wds::tlv::parseField(unsigned __int8 *a1, const unsigned __int8 *a2, _QWORD *a3)
{
  int *v6;
  unsigned int v7;
  _DWORD *v8;
  _DWORD *v9;
  int v10;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  v7 = *a1;
  v6 = (int *)(a1 + 1);
  std::vector<std::array<unsigned char,4ul>>::resize((uint64_t)a3, v7);
  v9 = (_DWORD *)*a3;
  v8 = (_DWORD *)a3[1];
  while (v9 != v8)
  {
    tlv::throwIfNotEnoughBytes((unint64_t)v6, a2, 4uLL);
    v10 = *v6++;
    *v9++ = v10;
  }
  return v6;
}

int *tlv::parseV<wds::tlv::ProxyIPv4List>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  int *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = wds::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = (unsigned __int8 *)result;
  return result;
}

void sub_2168A7868(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168A785CLL);
}

void sub_2168A7878(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t tlv::parseV<wds::tlv::PrimaryDNSIPv6>(unint64_t *a1, int a2)
{
  uint64_t *v3;
  uint64_t result;

  v3 = (uint64_t *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 0x10uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 2);
  return result;
}

void sub_2168A78D0(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168A78C4);
}

uint64_t tlv::parseV<wds::tlv::SecondaryDNSIPv6>(unint64_t *a1, int a2)
{
  uint64_t *v3;
  uint64_t result;

  v3 = (uint64_t *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 0x10uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 2);
  return result;
}

void sub_2168A7924(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168A7918);
}

uint64_t tlv::parseV<wds::tlv::MTU>(unint64_t *a1, int a2)
{
  unsigned int *v3;
  uint64_t result;

  v3 = (unsigned int *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 4uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168A7974(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168A7968);
}

__int128 *wds::tlv::parseField(unsigned __int8 *a1, const unsigned __int8 *a2, _QWORD *a3)
{
  __int128 *v6;
  unsigned int v7;
  _OWORD *v8;
  _OWORD *v9;
  __int128 v10;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  v7 = *a1;
  v6 = (__int128 *)(a1 + 1);
  std::vector<std::array<unsigned char,16ul>>::resize((uint64_t)a3, v7);
  v9 = (_OWORD *)*a3;
  v8 = (_OWORD *)a3[1];
  while (v9 != v8)
  {
    tlv::throwIfNotEnoughBytes((unint64_t)v6, a2, 0x10uLL);
    v10 = *v6++;
    *v9++ = v10;
  }
  return v6;
}

__int128 *tlv::parseV<wds::tlv::ProxyIPv6List>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  __int128 *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = wds::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = (unsigned __int8 *)result;
  return result;
}

void sub_2168A7A30(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168A7A24);
}

void sub_2168A7A40(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t wds::tlv::parseField(unint64_t a1, const unsigned __int8 *a2, uint64_t a3)
{
  unint64_t v5;
  unint64_t v6;

  v5 = a1;
  tlv::throwIfNotEnoughBytes(a1, a2, 2uLL);
  *(_WORD *)a3 = *(_WORD *)v5;
  tlv::throwIfNotEnoughBytes(v5 + 2, a2, 2uLL);
  *(_WORD *)(a3 + 2) = *(_WORD *)(v5 + 2);
  tlv::throwIfNotEnoughBytes(v5 + 4, a2, 1uLL);
  *(_BYTE *)(a3 + 4) = *(_BYTE *)(v5 + 4) != 0;
  tlv::throwIfNotEnoughBytes(v5 + 5, a2, 1uLL);
  v6 = *(unsigned __int8 *)(v5 + 5);
  v5 += 6;
  tlv::throwIfNotEnoughBytes(v5, a2, v6);
  std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((_QWORD *)(a3 + 8), (char *)v5, (char *)(v5 + v6), v6);
  tlv::throwIfNotEnoughBytes(v5 + v6, a2, 2uLL);
  *(_WORD *)(a3 + 32) = *(_WORD *)(v5 + v6);
  return v5 + v6 + 2;
}

uint64_t tlv::parseV<wds::tlv::OperatorReservedProtocolInformation>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t result;

  *(_QWORD *)(a3 + 32) = 0;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  result = wds::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), a3);
  *a1 = result;
  return result;
}

void sub_2168A7B78(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168A7B6CLL);
}

void sub_2168A7B88(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)(v1 + 8);
  if (v3)
  {
    *(_QWORD *)(v1 + 16) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t tlv::parseV<wds::tlv::SnssaiPdnInfo>(unint64_t *a1, int a2)
{
  _QWORD v3[2];

  memset(v3, 0, 15);
  *a1 = wds::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), (uint64_t)v3);
  return v3[0];
}

void sub_2168A7D24(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168A7CFCLL);
}

_DWORD **tlv::writeV<wds::tlv::PeripheralEndPoint>(_DWORD **result, _DWORD *a2)
{
  _DWORD *v2;

  v2 = *result;
  *v2 = *a2;
  v2[1] = a2[1];
  *result = v2 + 2;
  return result;
}

uint64_t tlv::size<wds::tlv::Ipv4AddressExtended>()
{
  return 19;
}

uint64_t *tlv::writeV<wds::tlv::Ipv4AddressExtended>(uint64_t *result, uint64_t a2)
{
  uint64_t v2;

  v2 = *result;
  *(_DWORD *)v2 = *(_DWORD *)a2;
  *(_DWORD *)(v2 + 4) = *(_DWORD *)(a2 + 4);
  *(_WORD *)(v2 + 8) = *(_WORD *)(a2 + 8);
  *(_WORD *)(v2 + 10) = *(_WORD *)(a2 + 10);
  *(_DWORD *)(v2 + 12) = *(_DWORD *)(a2 + 12);
  *result = v2 + 16;
  return result;
}

uint64_t tlv::size<wds::tlv::Ipv6AddressExtended>()
{
  return 43;
}

__n128 tlv::writeV<wds::tlv::Ipv6AddressExtended>(uint64_t *a1, uint64_t a2)
{
  uint64_t v2;
  __n128 result;

  v2 = *a1;
  *(_OWORD *)v2 = *(_OWORD *)a2;
  result = *(__n128 *)(a2 + 16);
  *(__n128 *)(v2 + 16) = result;
  *(_WORD *)(v2 + 32) = *(_WORD *)(a2 + 32);
  *(_WORD *)(v2 + 34) = *(_WORD *)(a2 + 34);
  *(_DWORD *)(v2 + 36) = *(_DWORD *)(a2 + 36);
  *a1 = v2 + 40;
  return result;
}

uint64_t tlv::size<wds::tlv::Ipv4Address>()
{
  return 15;
}

uint64_t *tlv::writeV<wds::tlv::Ipv4Address>(uint64_t *result, uint64_t a2)
{
  uint64_t v2;

  v2 = *result;
  *(_DWORD *)v2 = *(_DWORD *)a2;
  *(_DWORD *)(v2 + 4) = *(_DWORD *)(a2 + 4);
  *(_WORD *)(v2 + 8) = *(_WORD *)(a2 + 8);
  *(_WORD *)(v2 + 10) = *(_WORD *)(a2 + 10);
  *result = v2 + 12;
  return result;
}

uint64_t tlv::size<wds::tlv::Ipv6Address>()
{
  return 39;
}

__n128 tlv::writeV<wds::tlv::Ipv6Address>(uint64_t *a1, uint64_t a2)
{
  uint64_t v2;
  __n128 result;

  v2 = *a1;
  *(_OWORD *)v2 = *(_OWORD *)a2;
  result = *(__n128 *)(a2 + 16);
  *(__n128 *)(v2 + 16) = result;
  *(_WORD *)(v2 + 32) = *(_WORD *)(a2 + 32);
  *(_WORD *)(v2 + 34) = *(_WORD *)(a2 + 34);
  *a1 = v2 + 36;
  return result;
}

_BYTE *wds::tlv::writeField(_BYTE *a1, _DWORD *a2)
{
  _BYTE *result;
  uint64_t v3;
  uint64_t v4;

  *a1 = (a2[2] - *a2) >> 4;
  result = a1 + 1;
  v3 = *(_QWORD *)a2;
  v4 = *((_QWORD *)a2 + 1);
  while (v3 != v4)
  {
    *result = *(_BYTE *)v3;
    result[1] = *(_BYTE *)(v3 + 1);
    *((_WORD *)result + 1) = *(_WORD *)(v3 + 2);
    *((_WORD *)result + 2) = *(_WORD *)(v3 + 4);
    *((_WORD *)result + 3) = *(_WORD *)(v3 + 6);
    *((_WORD *)result + 4) = *(_WORD *)(v3 + 8);
    *(_DWORD *)(result + 10) = *(_DWORD *)(v3 + 12);
    result += 14;
    v3 += 16;
  }
  return result;
}

{
  _BYTE *result;
  uint64_t v3;
  uint64_t v4;
  _BYTE *v5;

  *a1 = -85 * ((a2[2] - *a2) >> 4);
  result = a1 + 1;
  v3 = *(_QWORD *)a2;
  v4 = *((_QWORD *)a2 + 1);
  while (v3 != v4)
  {
    *result = *(_BYTE *)v3;
    *(_OWORD *)(result + 1) = *(_OWORD *)(v3 + 1);
    *(_WORD *)(result + 17) = *(_DWORD *)(v3 + 32) - *(_DWORD *)(v3 + 24);
    v5 = result + 19;
    memcpy(result + 19, *(const void **)(v3 + 24), *(_QWORD *)(v3 + 32) - *(_QWORD *)(v3 + 24));
    result = &v5[*(_QWORD *)(v3 + 32) - *(_QWORD *)(v3 + 24)];
    v3 += 48;
  }
  return result;
}

{
  *a1 = *a2;
  return a1 + 1;
}

unint64_t tlv::size<wds::tlv::PacketList>(_QWORD *a1)
{
  uint64_t v1;

  v1 = a1[1];
  if (*a1 == v1)
    return 4;
  else
    return 14 * ((unint64_t)(v1 - *a1 - 16) >> 4) + 18;
}

_BYTE *tlv::writeV<wds::tlv::PacketList>(_BYTE **a1, _DWORD *a2)
{
  _BYTE *result;

  result = wds::tlv::writeField(*a1, a2);
  *a1 = result;
  return result;
}

uint64_t tlv::parseV<wds::tlv::SwitchFromSub>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168A7F3C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168A7F30);
}

uint64_t tlv::parseV<wds::tlv::ResultHandle>(unint64_t *a1, int a2)
{
  unsigned int *v3;
  uint64_t result;

  v3 = (unsigned int *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 4uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168A7F88(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168A7F7CLL);
}

uint64_t tlv::size<wds::tlv::RequestedBitrate>()
{
  return 12;
}

uint64_t *tlv::writeV<wds::tlv::RequestedBitrate>(uint64_t *result, uint64_t a2)
{
  uint64_t v2;

  v2 = *result;
  *(_DWORD *)v2 = *(_DWORD *)a2;
  *(_DWORD *)(v2 + 4) = *(_DWORD *)(a2 + 4);
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a2 + 8);
  *result = v2 + 9;
  return result;
}

uint64_t tlv::parseV<wds::tlv::BitRateInfo>(unint64_t *a1, int a2)
{
  uint64_t v3;
  int v4;

  v4 = 0;
  v3 = 0;
  *a1 = wds::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), (uint64_t)&v3);
  return v3;
}

void sub_2168A80A4(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168A808CLL);
}

uint64_t tlv::parseV<wds::tlv::BitrateBps>(unint64_t *a1, int a2)
{
  unsigned int *v3;
  uint64_t result;

  v3 = (unsigned int *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 4uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168A80EC(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168A80E0);
}

void std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<std::string>::__clear[abi:ne180100]((uint64_t *)v2);
    operator delete(**a1);
  }
}

void std::vector<std::string>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v2;
  uint64_t i;

  v2 = *a1;
  for (i = a1[1]; i != v2; i -= 24)
  {
    if (*(char *)(i - 1) < 0)
      operator delete(*(void **)(i - 24));
  }
  a1[1] = v2;
}

void wds::tlv::Parameters3GPP2::~Parameters3GPP2(wds::tlv::Parameters3GPP2 *this)
{
  if (*((_BYTE *)this + 188))
    *((_BYTE *)this + 188) = 0;
  if (*((_BYTE *)this + 186))
    *((_BYTE *)this + 186) = 0;
  if (*((_BYTE *)this + 184))
    *((_BYTE *)this + 184) = 0;
  if (*((_BYTE *)this + 152))
  {
    if (*((char *)this + 183) < 0)
      operator delete(*((void **)this + 20));
    *((_BYTE *)this + 152) = 0;
  }
  if (*((_BYTE *)this + 120))
  {
    if (*((char *)this + 151) < 0)
      operator delete(*((void **)this + 16));
    *((_BYTE *)this + 120) = 0;
  }
  if (*((_BYTE *)this + 108))
    *((_BYTE *)this + 108) = 0;
  if (*((_BYTE *)this + 104))
    *((_BYTE *)this + 104) = 0;
  if (*((_BYTE *)this + 72))
  {
    if (*((char *)this + 103) < 0)
      operator delete(*((void **)this + 10));
    *((_BYTE *)this + 72) = 0;
  }
  if (*((_BYTE *)this + 40))
  {
    if (*((char *)this + 71) < 0)
      operator delete(*((void **)this + 6));
    *((_BYTE *)this + 40) = 0;
  }
  if (*((_BYTE *)this + 32))
    *((_BYTE *)this + 32) = 0;
  if (*(_BYTE *)this)
  {
    if (*((char *)this + 31) < 0)
      operator delete(*((void **)this + 1));
    *(_BYTE *)this = 0;
  }
}

_QWORD *std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(_QWORD *result, char *__src, char *a3, unint64_t a4)
{
  _QWORD *v7;
  unint64_t v8;
  char *v9;
  uint64_t v10;
  size_t v11;
  _BYTE *v12;
  size_t v13;
  char *v14;
  char *v15;
  size_t v16;

  v7 = result;
  v8 = result[2];
  v9 = (char *)*result;
  if (v8 - *result < a4)
  {
    if (v9)
    {
      result[1] = v9;
      operator delete(v9);
      v8 = 0;
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if ((a4 & 0x8000000000000000) != 0)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = 2 * v8;
    if (2 * v8 <= a4)
      v10 = a4;
    if (v8 >= 0x3FFFFFFFFFFFFFFFLL)
      v11 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    result = std::vector<unsigned char>::__vallocate[abi:ne180100](v7, v11);
    v9 = (char *)v7[1];
    goto LABEL_17;
  }
  v12 = (_BYTE *)result[1];
  v13 = v12 - v9;
  if (v12 - v9 >= a4)
  {
LABEL_17:
    v16 = a3 - __src;
    if (v16)
      result = memmove(v9, __src, v16);
    v15 = &v9[v16];
    goto LABEL_20;
  }
  v14 = &__src[v13];
  if (v12 != v9)
  {
    result = memmove((void *)*result, __src, v13);
    v9 = (char *)v7[1];
  }
  if (a3 != v14)
    result = memmove(v9, v14, a3 - v14);
  v15 = &v9[a3 - v14];
LABEL_20:
  v7[1] = v15;
  return result;
}

char *std::vector<unsigned char>::__vallocate[abi:ne180100](_QWORD *a1, size_t __sz)
{
  char *result;

  if ((__sz & 0x8000000000000000) != 0)
    std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
  result = (char *)operator new(__sz);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[__sz];
  return result;
}

void std::vector<unsigned char>::__throw_length_error[abi:ne180100]()
{
  std::__throw_length_error[abi:ne180100]("vector");
}

void std::__throw_length_error[abi:ne180100](const char *a1)
{
  std::logic_error *exception;

  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::length_error::length_error[abi:ne180100](exception, a1);
  __cxa_throw(exception, (struct type_info *)off_24D5C2108, MEMORY[0x24BEDAAF0]);
}

void sub_2168A841C(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::length_error::length_error[abi:ne180100](std::logic_error *a1, const char *a2)
{
  std::logic_error *result;

  result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x24BEDB8B8] + 16);
  return result;
}

void std::__throw_bad_array_new_length[abi:ne180100]()
{
  std::bad_array_new_length *exception;
  std::bad_array_new_length *v1;

  exception = (std::bad_array_new_length *)__cxa_allocate_exception(8uLL);
  v1 = std::bad_array_new_length::bad_array_new_length(exception);
  __cxa_throw(v1, MEMORY[0x24BEDB748], MEMORY[0x24BEDABB8]);
}

void std::vector<std::string>::__swap_out_circular_buffer(std::vector<std::string> *this, std::__split_buffer<std::string> *__v)
{
  std::string *v4;
  std::string *begin;
  std::string *end;
  std::string *value;

  std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::string>,std::reverse_iterator<std::string*>,std::reverse_iterator<std::string*>,std::reverse_iterator<std::string*>>((uint64_t)&this->__end_cap_, (uint64_t)this->__end_, (uint64_t)this->__end_, (uint64_t)this->__begin_, (uint64_t)this->__begin_, (uint64_t)__v->__begin_, (uint64_t)__v->__begin_);
  __v->__begin_ = v4;
  begin = this->__begin_;
  this->__begin_ = v4;
  __v->__begin_ = begin;
  end = this->__end_;
  this->__end_ = __v->__end_;
  __v->__end_ = end;
  value = this->__end_cap_.__value_;
  this->__end_cap_.__value_ = __v->__end_cap_.__value_;
  __v->__end_cap_.__value_ = value;
  __v->__first_ = __v->__begin_;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(24 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::string>,std::reverse_iterator<std::string*>,std::reverse_iterator<std::string*>,std::reverse_iterator<std::string*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v9;
  __int128 v10;
  _QWORD v12[3];
  uint64_t v13;
  __int128 v14;
  __int128 v15;

  v7 = a7;
  *(_QWORD *)&v15 = a6;
  *((_QWORD *)&v15 + 1) = a7;
  v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  v13 = 0;
  if (a3 != a5)
  {
    v9 = a7;
    do
    {
      v10 = *(_OWORD *)(a3 - 24);
      *(_QWORD *)(v9 - 8) = *(_QWORD *)(a3 - 8);
      *(_OWORD *)(v9 - 24) = v10;
      v9 -= 24;
      *(_QWORD *)(a3 - 16) = 0;
      *(_QWORD *)(a3 - 8) = 0;
      *(_QWORD *)(a3 - 24) = 0;
      v7 -= 24;
      a3 -= 24;
    }
    while (a3 != a5);
    *((_QWORD *)&v15 + 1) = v9;
  }
  LOBYTE(v13) = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::reverse_iterator<std::string*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return a6;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::reverse_iterator<std::string*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::reverse_iterator<std::string*>>::operator()[abi:ne180100](a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::reverse_iterator<std::string*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8);
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    if (*(char *)(v1 + 23) < 0)
      operator delete(*(void **)v1);
    v1 += 24;
  }
}

void std::__split_buffer<std::string>::~__split_buffer(std::__split_buffer<std::string> *this)
{
  std::__split_buffer<std::string>::__destruct_at_end[abi:ne180100]((uint64_t)this, (void **)&this->__begin_->__r_.__value_.__l.__data_);
  if (this->__first_)
    operator delete(this->__first_);
}

void std::__split_buffer<std::string>::__destruct_at_end[abi:ne180100](uint64_t a1, void **a2)
{
  void **v2;
  void **v5;

  v2 = *(void ***)(a1 + 16);
  if (v2 != a2)
  {
    do
    {
      v5 = v2 - 3;
      *(_QWORD *)(a1 + 16) = v2 - 3;
      if (*((char *)v2 - 1) < 0)
      {
        operator delete(*v5);
        v5 = *(void ***)(a1 + 16);
      }
      v2 = v5;
    }
    while (v5 != a2);
  }
}

void std::string::__assign_trivial[abi:ne180100]<unsigned char const*,unsigned char const*>(std::string *this, std::string::value_type *a2, std::string::value_type *a3, std::string::size_type a4)
{
  std::string *v8;
  std::string::size_type size;
  std::string::size_type v10;
  unint64_t v11;
  unint64_t v12;
  std::string::value_type v13;

  if ((SHIBYTE(this->__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    v8 = this;
    if (a4 <= 0x16)
      goto LABEL_11;
    size = HIBYTE(this->__r_.__value_.__r.__words[2]);
    v10 = 22;
    goto LABEL_6;
  }
  v11 = this->__r_.__value_.__r.__words[2];
  v10 = (v11 & 0x7FFFFFFFFFFFFFFFLL) - 1;
  if (v10 < a4)
  {
    size = this->__r_.__value_.__l.__size_;
LABEL_6:
    std::string::__grow_by(this, v10, a4 - v10, size, 0, size, 0);
    this->__r_.__value_.__l.__size_ = 0;
    LOBYTE(v12) = *((_BYTE *)&this->__r_.__value_.__s + 23);
    goto LABEL_8;
  }
  v12 = HIBYTE(v11);
LABEL_8:
  v8 = this;
  if ((v12 & 0x80) != 0)
    v8 = (std::string *)this->__r_.__value_.__r.__words[0];
LABEL_11:
  while (a2 != a3)
  {
    v13 = *a2++;
    v8->__r_.__value_.__s.__data_[0] = v13;
    v8 = (std::string *)((char *)v8 + 1);
  }
  v8->__r_.__value_.__s.__data_[0] = 0;
  if (SHIBYTE(this->__r_.__value_.__r.__words[2]) < 0)
    this->__r_.__value_.__l.__size_ = a4;
  else
    *((_BYTE *)&this->__r_.__value_.__s + 23) = a4 & 0x7F;
}

void std::string::__throw_length_error[abi:ne180100]()
{
  std::__throw_length_error[abi:ne180100]("basic_string");
}

void boost::optional_detail::optional_base<tlv::NestedTlv<(unsigned char)27,wds::tlv::UserName>>::assign_expr<wds::tlv::UserName,wds::tlv::UserName>(uint64_t a1, uint64_t a2)
{
  std::string *v3;
  __int128 v4;

  if (*(_BYTE *)a1)
  {
    boost::optional_detail::optional_base<tlv::NestedTlv<(unsigned char)27,wds::tlv::UserName>>::assign_expr_to_initialized<wds::tlv::UserName>(a1, a2);
  }
  else
  {
    v3 = (std::string *)(a1 + 8);
    if (*(char *)(a2 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(v3, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
    }
    else
    {
      v4 = *(_OWORD *)a2;
      *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 16);
      *(_OWORD *)&v3->__r_.__value_.__l.__data_ = v4;
    }
    *(_BYTE *)a1 = 1;
  }
}

double boost::optional_detail::optional_base<tlv::NestedTlv<(unsigned char)27,wds::tlv::UserName>>::assign_expr_to_initialized<wds::tlv::UserName>(uint64_t a1, uint64_t a2)
{
  void **v3;
  double result;
  std::string v5;

  if (*(char *)(a2 + 23) < 0)
    std::string::__init_copy_ctor_external(&v5, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
  else
    v5 = *(std::string *)a2;
  v3 = (void **)(a1 + 8);
  if (*(char *)(a1 + 31) < 0)
    operator delete(*v3);
  result = *(double *)&v5.__r_.__value_.__l.__data_;
  *(_OWORD *)v3 = *(_OWORD *)&v5.__r_.__value_.__l.__data_;
  *(_QWORD *)(a1 + 24) = *((_QWORD *)&v5.__r_.__value_.__l + 2);
  return result;
}

void std::string::__init_copy_ctor_external(std::string *this, const std::string::value_type *__s, std::string::size_type __sz)
{
  std::string *v5;
  std::string::size_type v6;
  std::string::size_type v7;
  std::string *v8;

  v5 = this;
  if (__sz > 0x16)
  {
    if (__sz >= 0x7FFFFFFFFFFFFFF8)
      std::string::__throw_length_error[abi:ne180100]();
    v6 = (__sz & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__sz | 7) != 0x17)
      v6 = __sz | 7;
    v7 = v6 + 1;
    v8 = (std::string *)operator new(v6 + 1);
    v5->__r_.__value_.__l.__size_ = __sz;
    v5->__r_.__value_.__r.__words[2] = v7 | 0x8000000000000000;
    v5->__r_.__value_.__r.__words[0] = (std::string::size_type)v8;
    v5 = v8;
  }
  else
  {
    *((_BYTE *)&this->__r_.__value_.__s + 23) = __sz;
  }
  memmove(v5, __s, __sz + 1);
}

void std::vector<std::array<unsigned char,4ul>>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;

  v2 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 2;
  if (a2 <= v2)
  {
    if (a2 < v2)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 4 * a2;
  }
  else
  {
    std::vector<std::array<unsigned char,4ul>>::__append((void **)a1, a2 - v2);
  }
}

void std::vector<std::array<unsigned char,4ul>>::__append(void **a1, unint64_t a2)
{
  uint64_t v4;
  _BYTE *v5;
  _BYTE *v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  int v19;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 2)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 4 * a2);
      v7 += 4 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = v7 - (_BYTE *)*a1;
    v9 = a2 + (v8 >> 2);
    if (v9 >> 62)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 2;
    v11 = v5 - (_BYTE *)*a1;
    if (v11 >> 1 > v9)
      v9 = v11 >> 1;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFFCLL)
      v12 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v12 = v9;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::array<unsigned char,4ul>>>(v4, v12);
    else
      v13 = 0;
    v14 = &v13[4 * v10];
    v15 = &v13[4 * v12];
    bzero(v14, 4 * a2);
    v16 = &v14[4 * a2];
    v18 = (char *)*a1;
    v17 = (char *)a1[1];
    if (v17 != *a1)
    {
      do
      {
        v19 = *((_DWORD *)v17 - 1);
        v17 -= 4;
        *((_DWORD *)v14 - 1) = v19;
        v14 -= 4;
      }
      while (v17 != v18);
      v17 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v16;
    a1[2] = v15;
    if (v17)
      operator delete(v17);
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<std::array<unsigned char,4ul>>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 62)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(4 * a2);
}

void std::vector<std::array<unsigned char,16ul>>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;

  v2 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 4;
  if (a2 <= v2)
  {
    if (a2 < v2)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 16 * a2;
  }
  else
  {
    std::vector<std::array<unsigned char,16ul>>::__append((void **)a1, a2 - v2);
  }
}

void std::vector<std::array<unsigned char,16ul>>::__append(void **a1, unint64_t a2)
{
  uint64_t v4;
  _BYTE *v5;
  _BYTE *v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 4)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 16 * a2);
      v7 += 16 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = v7 - (_BYTE *)*a1;
    v9 = a2 + (v8 >> 4);
    if (v9 >> 60)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 4;
    v11 = v5 - (_BYTE *)*a1;
    if (v11 >> 3 > v9)
      v9 = v11 >> 3;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF0)
      v12 = 0xFFFFFFFFFFFFFFFLL;
    else
      v12 = v9;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::array<unsigned char,16ul>>>(v4, v12);
    else
      v13 = 0;
    v14 = &v13[16 * v10];
    v15 = &v13[16 * v12];
    bzero(v14, 16 * a2);
    v16 = &v14[16 * a2];
    v18 = (char *)*a1;
    v17 = (char *)a1[1];
    if (v17 != *a1)
    {
      do
      {
        *((_OWORD *)v14 - 1) = *((_OWORD *)v17 - 1);
        v14 -= 16;
        v17 -= 16;
      }
      while (v17 != v18);
      v17 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v16;
    a1[2] = v15;
    if (v17)
      operator delete(v17);
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<std::array<unsigned char,16ul>>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 60)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(16 * a2);
}

void tlv::parseV<wds::tlv::AttachParamsAPN>(std::string::value_type **a1@<X0>, int a2@<W1>, std::string *a3@<X8>)
{
  std::string::value_type *v4;

  a3->__r_.__value_.__r.__words[0] = 0;
  a3->__r_.__value_.__l.__size_ = 0;
  a3->__r_.__value_.__r.__words[2] = 0;
  v4 = &(*a1)[a2];
  std::string::__assign_trivial[abi:ne180100]<unsigned char const*,unsigned char const*>(a3, *a1, v4, a2);
  *a1 = v4;
}

void sub_2168A8C40(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168A8C30);
}

void sub_2168A8C50(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

uint64_t tlv::parseV<wds::tlv::AttachParamsIPType>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168A8CA4(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168A8C98);
}

uint64_t tlv::parseV<wds::tlv::AttachParamsIPv4Addr>(unint64_t *a1, int a2)
{
  unsigned int *v3;
  uint64_t result;

  v3 = (unsigned int *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 4uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168A8CF0(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168A8CE4);
}

uint64_t tlv::parseV<wds::tlv::AttachParamsIPv4Gateway>(unint64_t *a1, int a2)
{
  unsigned int *v3;
  uint64_t result;

  v3 = (unsigned int *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 4uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168A8D3C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168A8D30);
}

uint64_t tlv::parseV<wds::tlv::AttachParamsIPv4Mask>(unint64_t *a1, int a2)
{
  unsigned int *v3;
  uint64_t result;

  v3 = (unsigned int *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 4uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168A8D88(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168A8D7CLL);
}

unint64_t tlv::parseV<wds::tlv::AttachParamsIPv6Addr>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  unint64_t v5;
  const unsigned __int8 *v6;
  unint64_t result;

  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_BYTE *)(a3 + 16) = 0;
  v5 = *a1;
  v6 = (const unsigned __int8 *)(*a1 + a2);
  tlv::throwIfNotEnoughBytes(*a1, v6, 0x10uLL);
  *(_OWORD *)a3 = *(_OWORD *)v5;
  result = tlv::throwIfNotEnoughBytes(v5 + 16, v6, 1uLL);
  *(_BYTE *)(a3 + 16) = *(_BYTE *)(v5 + 16);
  *a1 = v5 + 17;
  return result;
}

void sub_2168A8E0C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
}

unint64_t tlv::parseV<wds::tlv::AttachParamsIPv6Gateway>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  unint64_t v5;
  const unsigned __int8 *v6;
  unint64_t result;

  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_BYTE *)(a3 + 16) = 0;
  v5 = *a1;
  v6 = (const unsigned __int8 *)(*a1 + a2);
  tlv::throwIfNotEnoughBytes(*a1, v6, 0x10uLL);
  *(_OWORD *)a3 = *(_OWORD *)v5;
  result = tlv::throwIfNotEnoughBytes(v5 + 16, v6, 1uLL);
  *(_BYTE *)(a3 + 16) = *(_BYTE *)(v5 + 16);
  *a1 = v5 + 17;
  return result;
}

void sub_2168A8E94(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
}

uint64_t tlv::parseV<wds::tlv::TransactionInfo>(unint64_t *a1, int a2)
{
  unsigned int v3;

  v3 = 0;
  *a1 = wds::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), (uint64_t)&v3);
  return v3;
}

void sub_2168A8F5C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168A8F48);
}

uint64_t tlv::parseV<wds::tlv::TdFragmentInfo>(unint64_t *a1, int a2)
{
  unsigned __int16 *v3;
  const unsigned __int8 *v4;
  unsigned int v5;
  int v6;

  v3 = (unsigned __int16 *)*a1;
  v4 = (const unsigned __int8 *)(*a1 + a2);
  tlv::throwIfNotEnoughBytes(*a1, v4, 2uLL);
  v5 = *v3;
  tlv::throwIfNotEnoughBytes((unint64_t)(v3 + 1), v4, 2uLL);
  v6 = v3[1];
  *a1 = (unint64_t)(v3 + 2);
  return (v6 << 16) | v5;
}

void sub_2168A8FD4(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168A8FC0);
}

_WORD **tlv::writeV<wds::tlv::TdFragmentInfo>(_WORD **result, _WORD *a2)
{
  _WORD *v2;

  v2 = *result;
  *v2 = *a2;
  v2[1] = a2[1];
  *result = v2 + 2;
  return result;
}

std::string::value_type *wds::tlv::parseField(unint64_t a1, const unsigned __int8 *a2, std::string *a3)
{
  std::string::value_type *v5;
  unsigned int v6;

  v5 = (std::string::value_type *)a1;
  tlv::throwIfNotEnoughBytes(a1, a2, 1uLL);
  v6 = *v5++;
  tlv::throwIfNotEnoughBytes((unint64_t)v5, a2, v6);
  std::string::__assign_trivial[abi:ne180100]<unsigned char const*,unsigned char const*>(a3, v5, &v5[v6], v6);
  return &v5[v6];
}

{
  std::string::value_type *v5;
  unsigned int v6;

  v5 = (std::string::value_type *)a1;
  tlv::throwIfNotEnoughBytes(a1, a2, 2uLL);
  v6 = *(unsigned __int16 *)v5;
  v5 += 2;
  tlv::throwIfNotEnoughBytes((unint64_t)v5, a2, v6);
  std::string::__assign_trivial[abi:ne180100]<unsigned char const*,unsigned char const*>(a3, v5, &v5[v6], v6);
  return &v5[v6];
}

std::string::value_type *wds::tlv::parseField(unsigned __int8 *a1, const unsigned __int8 *a2, uint64_t *a3)
{
  std::string::value_type *v6;
  unsigned int v7;
  std::string *v8;
  std::string *v9;
  std::string::value_type *result;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  v7 = *a1;
  v6 = (std::string::value_type *)(a1 + 1);
  std::vector<wds::tlv::DnnInfo>::resize(a3, v7);
  v8 = (std::string *)*a3;
  v9 = (std::string *)a3[1];
  while (1)
  {
    result = v6;
    if (v8 == v9)
      break;
    v6 = wds::tlv::parseField((unint64_t)v6, a2, v8++);
  }
  return result;
}

{
  std::string::value_type *v6;
  unsigned int v7;
  std::string *v8;
  std::string *v9;
  std::string::value_type *result;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  v7 = *a1;
  v6 = (std::string::value_type *)(a1 + 1);
  std::vector<wds::tlv::FqdnInfo>::resize(a3, v7);
  v8 = (std::string *)*a3;
  v9 = (std::string *)a3[1];
  while (1)
  {
    result = v6;
    if (v8 == v9)
      break;
    v6 = wds::tlv::parseField((unint64_t)v6, a2, v8++);
  }
  return result;
}

std::string::value_type *tlv::parseV<wds::tlv::DnnList>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  std::string::value_type *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = wds::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = (unsigned __int8 *)result;
  return result;
}

void sub_2168A9118(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168A9108);
}

void sub_2168A9128(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

void tlv::parseV<wds::tlv::Dnn>(std::string::value_type **a1@<X0>, int a2@<W1>, std::string *a3@<X8>)
{
  std::string::value_type *v4;

  a3->__r_.__value_.__r.__words[0] = 0;
  a3->__r_.__value_.__l.__size_ = 0;
  a3->__r_.__value_.__r.__words[2] = 0;
  v4 = &(*a1)[a2];
  std::string::__assign_trivial[abi:ne180100]<unsigned char const*,unsigned char const*>(a3, *a1, v4, a2);
  *a1 = v4;
}

void sub_2168A9190(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168A9180);
}

void sub_2168A91A0(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

uint64_t tlv::size<wds::tlv::Dnn>(uint64_t a1)
{
  uint64_t v1;

  v1 = *(unsigned __int8 *)(a1 + 23);
  if ((v1 & 0x80u) != 0)
    v1 = *(_QWORD *)(a1 + 8);
  return v1 + 3;
}

void *tlv::writeV<wds::tlv::Dnn>(void **a1, _QWORD *a2)
{
  _QWORD *v2;
  char *v4;
  size_t v5;
  size_t v6;
  void *result;
  uint64_t v8;

  v2 = a2;
  v4 = (char *)*a1;
  v5 = a2[1];
  if (*((char *)a2 + 23) >= 0)
  {
    v6 = *((unsigned __int8 *)a2 + 23);
  }
  else
  {
    a2 = (_QWORD *)*a2;
    v6 = v5;
  }
  result = memcpy(*a1, a2, v6);
  v8 = *((unsigned __int8 *)v2 + 23);
  if ((v8 & 0x80u) != 0)
    v8 = v2[1];
  *a1 = &v4[v8];
  return result;
}

char *wds::tlv::writeField(_BYTE *a1, _DWORD *a2)
{
  char *v2;
  const void **v3;
  const void **v4;
  const void *v5;
  char *v6;
  int v7;
  const void *v8;
  size_t v9;
  char *v10;

  *a1 = -85 * ((a2[2] - *a2) >> 3);
  v2 = a1 + 1;
  v3 = *(const void ***)a2;
  v4 = (const void **)*((_QWORD *)a2 + 1);
  while (v3 != v4)
  {
    LOWORD(v5) = *((unsigned __int8 *)v3 + 23);
    if ((char)v5 < 0)
      v5 = v3[1];
    *(_WORD *)v2 = (_WORD)v5;
    v6 = v2 + 2;
    v7 = *((char *)v3 + 23);
    if (v7 >= 0)
      v8 = v3;
    else
      v8 = *v3;
    if (v7 >= 0)
      v9 = *((unsigned __int8 *)v3 + 23);
    else
      v9 = (size_t)v3[1];
    memcpy(v6, v8, v9);
    v10 = (char *)*((unsigned __int8 *)v3 + 23);
    if ((char)v10 < 0)
      v10 = (char *)v3[1];
    v2 = &v10[(_QWORD)v6];
    v3 += 3;
  }
  return v2;
}

{
  char *v2;
  const void **v3;
  const void **v4;
  const void *v5;
  char *v6;
  int v7;
  const void *v8;
  size_t v9;
  char *v10;

  *a1 = -85 * ((a2[2] - *a2) >> 3);
  v2 = a1 + 1;
  v3 = *(const void ***)a2;
  v4 = (const void **)*((_QWORD *)a2 + 1);
  while (v3 != v4)
  {
    LOBYTE(v5) = *((_BYTE *)v3 + 23);
    if ((char)v5 < 0)
      v5 = v3[1];
    *v2 = (char)v5;
    v6 = v2 + 1;
    v7 = *((char *)v3 + 23);
    if (v7 >= 0)
      v8 = v3;
    else
      v8 = *v3;
    if (v7 >= 0)
      v9 = *((unsigned __int8 *)v3 + 23);
    else
      v9 = (size_t)v3[1];
    memcpy(v6, v8, v9);
    v10 = (char *)*((unsigned __int8 *)v3 + 23);
    if ((char)v10 < 0)
      v10 = (char *)v3[1];
    v2 = &v10[(_QWORD)v6];
    v3 += 3;
  }
  return v2;
}

std::string::value_type *tlv::parseV<wds::tlv::FqdnList>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  std::string::value_type *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = wds::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = (unsigned __int8 *)result;
  return result;
}

void sub_2168A93FC(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168A93ECLL);
}

void sub_2168A940C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

uint64_t tlv::size<wds::tlv::FqdnList>(uint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v1 = *a1;
  v2 = a1[1];
  if (*a1 == v2)
    return 4;
  v3 = 0;
  do
  {
    v4 = *(unsigned __int8 *)(v1 + 23);
    if ((v4 & 0x80u) != 0)
      v4 = *(_QWORD *)(v1 + 8);
    v3 += v4 + 2;
    v1 += 24;
  }
  while (v1 != v2);
  return v3 + 4;
}

char *tlv::writeV<wds::tlv::FqdnList>(char **a1, _DWORD *a2)
{
  char *result;

  result = wds::tlv::writeField(*a1, a2);
  *a1 = result;
  return result;
}

unint64_t wds::tlv::parseField(unsigned __int8 *a1, const unsigned __int8 *a2, uint64_t *a3)
{
  unint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t result;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  v7 = *a1;
  v6 = (unint64_t)(a1 + 1);
  std::vector<wds::tlv::AppInfo>::resize(a3, v7);
  v8 = *a3;
  v9 = a3[1];
  while (1)
  {
    result = v6;
    if (v8 == v9)
      break;
    v6 = wds::tlv::parseField(v6, a2, v8);
    v8 += 48;
  }
  return result;
}

{
  unint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  v7 = *a1;
  v6 = (unint64_t)(a1 + 1);
  std::vector<wds::tlv::Ipv6AddrInfo>::resize((uint64_t)a3, v7);
  v9 = *a3;
  v8 = a3[1];
  while (v9 != v8)
  {
    tlv::throwIfNotEnoughBytes(v6, a2, 0x10uLL);
    *(_OWORD *)v9 = *(_OWORD *)v6;
    tlv::throwIfNotEnoughBytes(v6 + 16, a2, 1uLL);
    *(_BYTE *)(v9 + 16) = *(_BYTE *)(v6 + 16);
    v6 += 17;
    v9 += 17;
  }
  return v6;
}

unint64_t tlv::parseV<wds::tlv::AppList>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  unint64_t result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = wds::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = (unsigned __int8 *)result;
  return result;
}

void sub_2168A9678(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168A9668);
}

void sub_2168A9688(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::vector<wds::tlv::AppInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

uint64_t tlv::size<wds::tlv::AppList>(uint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v1 = *a1;
  v2 = a1[1];
  if (*a1 == v2)
    return 4;
  v3 = 0;
  do
  {
    v3 = v3 + *(_QWORD *)(v1 + 32) - *(_QWORD *)(v1 + 24) + 19;
    v1 += 48;
  }
  while (v1 != v2);
  return v3 + 4;
}

_BYTE *tlv::writeV<wds::tlv::AppList>(_BYTE **a1, _DWORD *a2)
{
  _BYTE *result;

  result = wds::tlv::writeField(*a1, a2);
  *a1 = result;
  return result;
}

_DWORD *wds::tlv::parseField(unsigned __int8 *a1, const unsigned __int8 *a2, _QWORD *a3)
{
  _DWORD *v6;
  unsigned int v7;
  _DWORD *v8;
  _DWORD *v9;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  v7 = *a1;
  v6 = a1 + 1;
  std::vector<wds::tlv::Ipv4AddrInfo>::resize((uint64_t)a3, v7);
  v9 = (_DWORD *)*a3;
  v8 = (_DWORD *)a3[1];
  while (v9 != v8)
  {
    tlv::throwIfNotEnoughBytes((unint64_t)v6, a2, 4uLL);
    *v9 = *v6;
    tlv::throwIfNotEnoughBytes((unint64_t)(v6 + 1), a2, 4uLL);
    v9[1] = v6[1];
    v6 += 2;
    v9 += 2;
  }
  return v6;
}

unsigned __int8 *tlv::parseV<wds::tlv::Ipv4AddrList>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  unsigned __int8 *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = (unsigned __int8 *)wds::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = result;
  return result;
}

void sub_2168A97CC(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168A97C0);
}

void sub_2168A97DC(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

unint64_t tlv::size<wds::tlv::Ipv4AddrList>(_QWORD *a1)
{
  uint64_t v1;

  v1 = a1[1];
  if (v1 == *a1)
    return 4;
  else
    return (v1 - *a1) & 0xFFFFFFFFFFFFFFF8 | 4;
}

_BYTE **tlv::writeV<wds::tlv::Ipv4AddrList>(_BYTE **result, _DWORD *a2)
{
  _BYTE *v2;
  _DWORD *v3;
  _DWORD *v4;
  _DWORD *v5;

  v2 = *result;
  *v2 = (a2[2] - *a2) >> 3;
  v3 = v2 + 1;
  v4 = *(_DWORD **)a2;
  v5 = (_DWORD *)*((_QWORD *)a2 + 1);
  while (v4 != v5)
  {
    *v3 = *v4;
    v3[1] = v4[1];
    v3 += 2;
    v4 += 2;
  }
  *result = v3;
  return result;
}

unint64_t tlv::parseV<wds::tlv::Ipv6AddrList>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  unint64_t result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = wds::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = (unsigned __int8 *)result;
  return result;
}

void sub_2168A9924(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168A9918);
}

void sub_2168A9934(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

unint64_t tlv::size<wds::tlv::Ipv6AddrList>(_QWORD *a1)
{
  uint64_t v1;

  v1 = a1[1];
  if (*a1 == v1)
    return 4;
  else
    return 17 * ((v1 - *a1 - 17) / 0x11uLL) + 21;
}

_BYTE **tlv::writeV<wds::tlv::Ipv6AddrList>(_BYTE **result, _DWORD *a2)
{
  _BYTE *v2;
  _BYTE *v3;
  uint64_t v4;
  uint64_t v5;
  _BYTE *v6;

  v2 = *result;
  *v2 = -15 * (a2[2] - *a2);
  v3 = v2 + 1;
  v4 = *(_QWORD *)a2;
  v5 = *((_QWORD *)a2 + 1);
  if (*(_QWORD *)a2 == v5)
  {
    v6 = v3;
  }
  else
  {
    do
    {
      *(_OWORD *)v3 = *(_OWORD *)v4;
      v6 = v3 + 17;
      v3[16] = *(_BYTE *)(v4 + 16);
      v4 += 17;
      v3 += 17;
    }
    while (v4 != v5);
  }
  *result = v6;
  return result;
}

char *wds::tlv::parseField(unint64_t a1, const unsigned __int8 *a2, _QWORD *a3)
{
  char *v5;
  unsigned int v6;

  v5 = (char *)a1;
  tlv::throwIfNotEnoughBytes(a1, a2, 1uLL);
  v6 = *v5++;
  tlv::throwIfNotEnoughBytes((unint64_t)v5, a2, v6);
  std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(a3, v5, &v5[v6], v6);
  return &v5[v6];
}

char *tlv::parseV<wds::tlv::NextHdrProtList>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  char *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = wds::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), a3);
  *a1 = (unint64_t)result;
  return result;
}

void sub_2168A9A8C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168A9A80);
}

void sub_2168A9A9C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t tlv::size<wds::tlv::NextHdrProtList>(_QWORD *a1)
{
  return a1[1] - *a1 + 4;
}

void *tlv::writeV<wds::tlv::NextHdrProtList>(_BYTE **a1, uint64_t a2)
{
  _BYTE *v4;
  void *result;

  v4 = *a1;
  *v4++ = *(_DWORD *)(a2 + 8) - *(_DWORD *)a2;
  result = memcpy(v4, *(const void **)a2, *(_QWORD *)(a2 + 8) - *(_QWORD *)a2);
  *a1 = &v4[*(_QWORD *)(a2 + 8) - *(_QWORD *)a2];
  return result;
}

unsigned __int8 *wds::tlv::parseField(unint64_t a1, const unsigned __int8 *a2, void **a3)
{
  unsigned __int8 *v5;
  unsigned int v6;

  v5 = (unsigned __int8 *)a1;
  tlv::throwIfNotEnoughBytes(a1, a2, 1uLL);
  v6 = *v5++;
  tlv::throwIfNotEnoughBytes((unint64_t)v5, a2, 2 * v6);
  std::vector<unsigned short>::resize((uint64_t)a3, v6);
  memcpy(*a3, v5, 2 * v6);
  return &v5[2 * v6];
}

unsigned __int8 *tlv::parseV<wds::tlv::DestPortList>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  unsigned __int8 *result;

  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  result = wds::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), (void **)a3);
  *a1 = (unint64_t)result;
  return result;
}

void sub_2168A9BD8(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168A9BCCLL);
}

void sub_2168A9BE8(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *tlv::writeV<wds::tlv::DestPortList>(_BYTE **a1, _DWORD *a2)
{
  _BYTE *v3;
  const void *v4;
  size_t v6;
  void *result;

  v3 = *a1;
  *v3++ = (a2[2] - *a2) >> 1;
  v4 = *(const void **)a2;
  v6 = *((_QWORD *)a2 + 1) - (_QWORD)v4;
  result = memcpy(v3, v4, v6);
  *a1 = &v3[v6];
  return result;
}

_WORD *wds::tlv::parseField(unsigned __int8 *a1, const unsigned __int8 *a2, _QWORD *a3)
{
  _WORD *v6;
  unsigned int v7;
  _WORD *v8;
  _WORD *v9;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  v7 = *a1;
  v6 = a1 + 1;
  std::vector<std::array<unsigned char,4ul>>::resize((uint64_t)a3, v7);
  v9 = (_WORD *)*a3;
  v8 = (_WORD *)a3[1];
  while (v9 != v8)
  {
    tlv::throwIfNotEnoughBytes((unint64_t)v6, a2, 2uLL);
    *v9 = *v6;
    tlv::throwIfNotEnoughBytes((unint64_t)(v6 + 1), a2, 2uLL);
    v9[1] = v6[1];
    v6 += 2;
    v9 += 2;
  }
  return v6;
}

unsigned __int8 *tlv::parseV<wds::tlv::DestPortRangeList>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  unsigned __int8 *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = (unsigned __int8 *)wds::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = result;
  return result;
}

void sub_2168A9D24(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168A9D18);
}

void sub_2168A9D34(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

unint64_t tlv::size<wds::tlv::DestPortRangeList>(_QWORD *a1)
{
  uint64_t v1;

  v1 = a1[1];
  if (v1 == *a1)
    return 4;
  else
    return ((v1 - *a1) & 0xFFFFFFFFFFFFFFFCLL) + 4;
}

_BYTE **tlv::writeV<wds::tlv::DestPortRangeList>(_BYTE **result, _DWORD *a2)
{
  _BYTE *v2;
  _WORD *v3;
  _WORD *v4;
  _WORD *v5;

  v2 = *result;
  *v2 = (a2[2] - *a2) >> 2;
  v3 = v2 + 1;
  v4 = *(_WORD **)a2;
  v5 = (_WORD *)*((_QWORD *)a2 + 1);
  while (v4 != v5)
  {
    *v3 = *v4;
    v3[1] = v4[1];
    v3 += 2;
    v4 += 2;
  }
  *result = v3;
  return result;
}

uint64_t tlv::parseV<wds::tlv::TdApnTypeMask>(unint64_t *a1, int a2)
{
  uint64_t *v3;
  uint64_t result;

  v3 = (uint64_t *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 8uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168A9DEC(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168A9DE0);
}

uint64_t tlv::parseV<wds::tlv::TransactionId>(unint64_t *a1, int a2)
{
  unsigned int *v3;
  uint64_t result;

  v3 = (unsigned int *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 4uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168A9E38(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168A9E2CLL);
}

uint64_t tlv::parseV<wds::tlv::SliceDnnLookupStatus>(unint64_t *a1, int a2)
{
  unsigned int *v3;
  uint64_t result;

  v3 = (unsigned int *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 4uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168A9E84(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168A9E78);
}

BOOL tlv::parseV<wds::tlv::OTAAttachPerformed>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  _BOOL8 result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3 != 0;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168A9ED8(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168A9ECCLL);
}

_BYTE *wds::tlv::writeField(_BYTE *a1, _BYTE *a2)
{
  *a1 = *a2;
  return a1 + 1;
}

uint64_t wds::tlv::getFieldSize()
{
  return 1;
}

{
  return 34;
}

{
  return 2;
}

void tlv::parseV<wds::tlv::ProfileNAI>(std::string::value_type **a1@<X0>, int a2@<W1>, std::string *a3@<X8>)
{
  std::string::value_type *v4;

  a3->__r_.__value_.__r.__words[0] = 0;
  a3->__r_.__value_.__l.__size_ = 0;
  a3->__r_.__value_.__r.__words[2] = 0;
  v4 = &(*a1)[a2];
  std::string::__assign_trivial[abi:ne180100]<unsigned char const*,unsigned char const*>(a3, *a1, v4, a2);
  *a1 = v4;
}

void sub_2168A9F50(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168A9F40);
}

void sub_2168A9F60(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

unint64_t tlv::size<wds::tlv::FrameList>(_QWORD *a1)
{
  uint64_t v1;

  v1 = a1[1];
  if (*a1 == v1)
    return 3;
  else
    return 132 * ((v1 - *a1 - 132) / 0x84uLL) + 135;
}

uint64_t *tlv::writeV<wds::tlv::FrameList>(uint64_t *result, __int128 **a2)
{
  uint64_t v2;
  __int128 *v3;
  __int128 *v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;

  v2 = *result;
  v3 = *a2;
  v4 = a2[1];
  while (v3 != v4)
  {
    v5 = *v3;
    v6 = v3[1];
    v7 = v3[3];
    *(_OWORD *)(v2 + 32) = v3[2];
    *(_OWORD *)(v2 + 48) = v7;
    *(_OWORD *)v2 = v5;
    *(_OWORD *)(v2 + 16) = v6;
    v8 = v3[4];
    v9 = v3[5];
    v10 = v3[7];
    *(_OWORD *)(v2 + 96) = v3[6];
    *(_OWORD *)(v2 + 112) = v10;
    *(_OWORD *)(v2 + 64) = v8;
    *(_OWORD *)(v2 + 80) = v9;
    *(_BYTE *)(v2 + 128) = *((_BYTE *)v3 + 128);
    *(_BYTE *)(v2 + 129) = *((_BYTE *)v3 + 129);
    *(_WORD *)(v2 + 130) = *((_WORD *)v3 + 65);
    v2 += 132;
    v3 = (__int128 *)((char *)v3 + 132);
  }
  *result = v2;
  return result;
}

BOOL tlv::parseV<wds::tlv::AttachParamsValid>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  _BOOL8 result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3 != 0;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168AA05C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168AA050);
}

uint64_t tlv::parseV<wds::tlv::BackoffTimeMessage>(unint64_t *a1, int a2)
{
  unsigned int *v3;
  uint64_t result;

  v3 = (unsigned int *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 4uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168AA0A8(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168AA09CLL);
}

uint64_t *tlv::writeV<wds::tlv::LinkStat>(uint64_t *result, _DWORD *a2)
{
  uint64_t v2;

  v2 = *result;
  *(_DWORD *)v2 = *a2;
  *(_DWORD *)(v2 + 4) = a2[1];
  *(_BYTE *)(v2 + 8) = a2[2];
  *result = v2 + 9;
  return result;
}

void std::vector<wds::tlv::AppInfo>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<wds::tlv::AppInfo>::__clear[abi:ne180100]((uint64_t *)v2);
    operator delete(**a1);
  }
}

void std::vector<wds::tlv::AppInfo>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v2;
  uint64_t i;
  void *v4;

  v2 = *a1;
  for (i = a1[1]; i != v2; i -= 48)
  {
    v4 = *(void **)(i - 24);
    if (v4)
    {
      *(_QWORD *)(i - 16) = v4;
      operator delete(v4);
    }
  }
  a1[1] = v2;
}

void std::vector<unsigned short>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;

  v2 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 1;
  if (a2 <= v2)
  {
    if (a2 < v2)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 2 * a2;
  }
  else
  {
    std::vector<unsigned short>::__append((char **)a1, a2 - v2);
  }
}

void std::vector<unsigned short>::__append(char **a1, unint64_t a2)
{
  uint64_t v4;
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  __int16 v18;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 1)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 2 * a2);
      v7 += 2 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = *a1;
    v9 = v7 - *a1;
    v10 = a2 + (v9 >> 1);
    if (v10 < 0)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v11 = v9 >> 1;
    v12 = v5 - v8;
    if (v12 > v10)
      v10 = v12;
    if (v12 >= 0x7FFFFFFFFFFFFFFELL)
      v13 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v13 = v10;
    if (v13)
    {
      v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned short>>(v4, v13);
      v8 = *a1;
      v7 = a1[1];
    }
    else
    {
      v14 = 0;
    }
    v15 = &v14[2 * v11];
    v16 = &v14[2 * v13];
    bzero(v15, 2 * a2);
    v17 = &v15[2 * a2];
    while (v7 != v8)
    {
      v18 = *((_WORD *)v7 - 1);
      v7 -= 2;
      *((_WORD *)v15 - 1) = v18;
      v15 -= 2;
    }
    *a1 = v15;
    a1[1] = v17;
    a1[2] = v16;
    if (v8)
      operator delete(v8);
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned short>>(uint64_t a1, uint64_t a2)
{
  if (a2 < 0)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(2 * a2);
}

void std::vector<wds::tlv::DnnInfo>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  BOOL v5;
  unint64_t v6;
  uint64_t v7;

  v3 = a1[1];
  v4 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  v5 = a2 >= v4;
  v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    std::vector<wds::tlv::DnnInfo>::__append(a1, v6);
  }
  else if (!v5)
  {
    v7 = *a1 + 24 * a2;
    while (v3 != v7)
    {
      if (*(char *)(v3 - 1) < 0)
        operator delete(*(void **)(v3 - 24));
      v3 -= 24;
    }
    a1[1] = v7;
  }
}

void std::vector<wds::tlv::DnnInfo>::__append(uint64_t *a1, unint64_t a2)
{
  std::allocator<std::string> *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  std::string *v12;
  size_t v13;
  size_t v14;
  std::__split_buffer<std::string> v15;

  v6 = a1[2];
  v4 = (std::allocator<std::string> *)(a1 + 2);
  v5 = v6;
  v7 = *((_QWORD *)v4 - 1);
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - v7) >> 3) >= a2)
  {
    if (a2)
    {
      v13 = 24 * ((24 * a2 - 24) / 0x18) + 24;
      bzero(*((void **)v4 - 1), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = 0xAAAAAAAAAAAAAAABLL * ((v7 - *a1) >> 3);
    v9 = v8 + a2;
    if (v8 + a2 > 0xAAAAAAAAAAAAAAALL)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *a1) >> 3);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x555555555555555)
      v11 = 0xAAAAAAAAAAAAAAALL;
    else
      v11 = v9;
    v15.__end_cap_.__value_ = v4;
    if (v11)
      v12 = (std::string *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)v4, v11);
    else
      v12 = 0;
    v15.__first_ = v12;
    v15.__begin_ = v12 + v8;
    v15.__end_cap_.__value_ = &v12[v11];
    v14 = 24 * ((24 * a2 - 24) / 0x18) + 24;
    bzero(v15.__begin_, v14);
    v15.__end_ = (std::__split_buffer<std::string>::pointer)((char *)v15.__begin_ + v14);
    std::vector<wds::tlv::DnnInfo>::__swap_out_circular_buffer(a1, &v15);
    std::__split_buffer<std::string>::~__split_buffer(&v15);
  }
}

void sub_2168AA4AC(_Unwind_Exception *a1, std::__split_buffer<std::string> *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  std::__split_buffer<std::string>::~__split_buffer((std::__split_buffer<std::string> *)&a10);
  _Unwind_Resume(a1);
}

uint64_t std::vector<wds::tlv::DnnInfo>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<wds::tlv::DnnInfo>,std::reverse_iterator<wds::tlv::DnnInfo*>,std::reverse_iterator<wds::tlv::DnnInfo*>,std::reverse_iterator<wds::tlv::DnnInfo*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<wds::tlv::DnnInfo>,std::reverse_iterator<wds::tlv::DnnInfo*>,std::reverse_iterator<wds::tlv::DnnInfo*>,std::reverse_iterator<wds::tlv::DnnInfo*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v9;
  __int128 v10;
  _QWORD v12[3];
  uint64_t v13;
  __int128 v14;
  __int128 v15;

  v7 = a7;
  *(_QWORD *)&v15 = a6;
  *((_QWORD *)&v15 + 1) = a7;
  v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  v13 = 0;
  if (a3 != a5)
  {
    v9 = a7;
    do
    {
      v10 = *(_OWORD *)(a3 - 24);
      *(_QWORD *)(v9 - 8) = *(_QWORD *)(a3 - 8);
      *(_OWORD *)(v9 - 24) = v10;
      v9 -= 24;
      *(_QWORD *)(a3 - 16) = 0;
      *(_QWORD *)(a3 - 8) = 0;
      *(_QWORD *)(a3 - 24) = 0;
      v7 -= 24;
      a3 -= 24;
    }
    while (a3 != a5);
    *((_QWORD *)&v15 + 1) = v9;
  }
  LOBYTE(v13) = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<wds::tlv::DnnInfo>,std::reverse_iterator<wds::tlv::DnnInfo*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return a6;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<wds::tlv::DnnInfo>,std::reverse_iterator<wds::tlv::DnnInfo*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::reverse_iterator<std::string*>>::operator()[abi:ne180100](a1);
  return a1;
}

void std::vector<wds::tlv::FqdnInfo>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  BOOL v5;
  unint64_t v6;
  uint64_t v7;

  v3 = a1[1];
  v4 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  v5 = a2 >= v4;
  v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    std::vector<wds::tlv::FqdnInfo>::__append(a1, v6);
  }
  else if (!v5)
  {
    v7 = *a1 + 24 * a2;
    while (v3 != v7)
    {
      if (*(char *)(v3 - 1) < 0)
        operator delete(*(void **)(v3 - 24));
      v3 -= 24;
    }
    a1[1] = v7;
  }
}

void std::vector<wds::tlv::FqdnInfo>::__append(uint64_t *a1, unint64_t a2)
{
  std::allocator<std::string> *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  std::string *v12;
  size_t v13;
  size_t v14;
  std::__split_buffer<std::string> v15;

  v6 = a1[2];
  v4 = (std::allocator<std::string> *)(a1 + 2);
  v5 = v6;
  v7 = *((_QWORD *)v4 - 1);
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - v7) >> 3) >= a2)
  {
    if (a2)
    {
      v13 = 24 * ((24 * a2 - 24) / 0x18) + 24;
      bzero(*((void **)v4 - 1), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = 0xAAAAAAAAAAAAAAABLL * ((v7 - *a1) >> 3);
    v9 = v8 + a2;
    if (v8 + a2 > 0xAAAAAAAAAAAAAAALL)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *a1) >> 3);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x555555555555555)
      v11 = 0xAAAAAAAAAAAAAAALL;
    else
      v11 = v9;
    v15.__end_cap_.__value_ = v4;
    if (v11)
      v12 = (std::string *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)v4, v11);
    else
      v12 = 0;
    v15.__first_ = v12;
    v15.__begin_ = v12 + v8;
    v15.__end_cap_.__value_ = &v12[v11];
    v14 = 24 * ((24 * a2 - 24) / 0x18) + 24;
    bzero(v15.__begin_, v14);
    v15.__end_ = (std::__split_buffer<std::string>::pointer)((char *)v15.__begin_ + v14);
    std::vector<wds::tlv::FqdnInfo>::__swap_out_circular_buffer(a1, &v15);
    std::__split_buffer<std::string>::~__split_buffer(&v15);
  }
}

void sub_2168AA7E0(_Unwind_Exception *a1, std::__split_buffer<std::string> *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  std::__split_buffer<std::string>::~__split_buffer((std::__split_buffer<std::string> *)&a10);
  _Unwind_Resume(a1);
}

uint64_t std::vector<wds::tlv::FqdnInfo>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<wds::tlv::FqdnInfo>,std::reverse_iterator<wds::tlv::FqdnInfo*>,std::reverse_iterator<wds::tlv::FqdnInfo*>,std::reverse_iterator<wds::tlv::FqdnInfo*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<wds::tlv::FqdnInfo>,std::reverse_iterator<wds::tlv::FqdnInfo*>,std::reverse_iterator<wds::tlv::FqdnInfo*>,std::reverse_iterator<wds::tlv::FqdnInfo*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v9;
  __int128 v10;
  _QWORD v12[3];
  uint64_t v13;
  __int128 v14;
  __int128 v15;

  v7 = a7;
  *(_QWORD *)&v15 = a6;
  *((_QWORD *)&v15 + 1) = a7;
  v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  v13 = 0;
  if (a3 != a5)
  {
    v9 = a7;
    do
    {
      v10 = *(_OWORD *)(a3 - 24);
      *(_QWORD *)(v9 - 8) = *(_QWORD *)(a3 - 8);
      *(_OWORD *)(v9 - 24) = v10;
      v9 -= 24;
      *(_QWORD *)(a3 - 16) = 0;
      *(_QWORD *)(a3 - 8) = 0;
      *(_QWORD *)(a3 - 24) = 0;
      v7 -= 24;
      a3 -= 24;
    }
    while (a3 != a5);
    *((_QWORD *)&v15 + 1) = v9;
  }
  LOBYTE(v13) = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<wds::tlv::FqdnInfo>,std::reverse_iterator<wds::tlv::FqdnInfo*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return a6;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<wds::tlv::FqdnInfo>,std::reverse_iterator<wds::tlv::FqdnInfo*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::reverse_iterator<std::string*>>::operator()[abi:ne180100](a1);
  return a1;
}

void std::vector<wds::tlv::AppInfo>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  BOOL v5;
  unint64_t v6;
  uint64_t v7;
  void *v8;

  v3 = a1[1];
  v4 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 4);
  v5 = a2 >= v4;
  v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    std::vector<wds::tlv::AppInfo>::__append(a1, v6);
  }
  else if (!v5)
  {
    v7 = *a1 + 48 * a2;
    while (v3 != v7)
    {
      v8 = *(void **)(v3 - 24);
      if (v8)
      {
        *(_QWORD *)(v3 - 16) = v8;
        operator delete(v8);
      }
      v3 -= 48;
    }
    a1[1] = v7;
  }
}

void std::vector<wds::tlv::AppInfo>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  size_t v13;
  size_t v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - v7) >> 4) >= a2)
  {
    if (a2)
    {
      v13 = 48 * ((48 * a2 - 48) / 0x30) + 48;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = 0xAAAAAAAAAAAAAAABLL * ((v7 - *a1) >> 4);
    v9 = v8 + a2;
    if (v8 + a2 > 0x555555555555555)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *a1) >> 4);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x2AAAAAAAAAAAAAALL)
      v11 = 0x555555555555555;
    else
      v11 = v9;
    v19 = v4;
    if (v11)
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::AppInfo>>(v4, v11);
    else
      v12 = 0;
    v15 = v12;
    v16 = &v12[48 * v8];
    v18 = &v12[48 * v11];
    v14 = 48 * ((48 * a2 - 48) / 0x30) + 48;
    bzero(v16, v14);
    v17 = &v16[v14];
    std::vector<wds::tlv::AppInfo>::__swap_out_circular_buffer(a1, &v15);
    std::__split_buffer<wds::tlv::AppInfo>::~__split_buffer((uint64_t)&v15);
  }
}

void sub_2168AAB14(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<wds::tlv::AppInfo>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<wds::tlv::AppInfo>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<wds::tlv::AppInfo>,std::reverse_iterator<wds::tlv::AppInfo*>,std::reverse_iterator<wds::tlv::AppInfo*>,std::reverse_iterator<wds::tlv::AppInfo*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::AppInfo>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x555555555555556)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(48 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<wds::tlv::AppInfo>,std::reverse_iterator<wds::tlv::AppInfo*>,std::reverse_iterator<wds::tlv::AppInfo*>,std::reverse_iterator<wds::tlv::AppInfo*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  __int128 v8;
  uint64_t v9;
  _QWORD v11[3];
  uint64_t v12;
  __int128 v13;
  __int128 v14;

  v7 = a7;
  *(_QWORD *)&v14 = a6;
  *((_QWORD *)&v14 + 1) = a7;
  v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  v12 = 0;
  if (a3 == a5)
  {
    v9 = a6;
  }
  else
  {
    do
    {
      v8 = *(_OWORD *)(a3 - 48);
      *(_BYTE *)(v7 - 32) = *(_BYTE *)(a3 - 32);
      *(_OWORD *)(v7 - 48) = v8;
      *(_QWORD *)(v7 - 16) = 0;
      *(_QWORD *)(v7 - 8) = 0;
      *(_QWORD *)(v7 - 24) = 0;
      *(_OWORD *)(v7 - 24) = *(_OWORD *)(a3 - 24);
      *(_QWORD *)(v7 - 8) = *(_QWORD *)(a3 - 8);
      *(_QWORD *)(a3 - 24) = 0;
      *(_QWORD *)(a3 - 16) = 0;
      *(_QWORD *)(a3 - 8) = 0;
      v7 = *((_QWORD *)&v14 + 1) - 48;
      *((_QWORD *)&v14 + 1) -= 48;
      a3 -= 48;
    }
    while (a3 != a5);
    v9 = v14;
  }
  LOBYTE(v12) = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<wds::tlv::AppInfo>,std::reverse_iterator<wds::tlv::AppInfo*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v11);
  return v9;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<wds::tlv::AppInfo>,std::reverse_iterator<wds::tlv::AppInfo*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<wds::tlv::AppInfo>,std::reverse_iterator<wds::tlv::AppInfo*>>::operator()[abi:ne180100](a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<wds::tlv::AppInfo>,std::reverse_iterator<wds::tlv::AppInfo*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  void *v3;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8);
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    v3 = *(void **)(v1 + 24);
    if (v3)
    {
      *(_QWORD *)(v1 + 32) = v3;
      operator delete(v3);
    }
    v1 += 48;
  }
}

uint64_t std::__split_buffer<wds::tlv::AppInfo>::~__split_buffer(uint64_t a1)
{
  std::__split_buffer<wds::tlv::AppInfo>::__destruct_at_end[abi:ne180100](a1, *(_QWORD *)(a1 + 8));
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::__split_buffer<wds::tlv::AppInfo>::__destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  void *v5;

  v2 = *(_QWORD *)(a1 + 16);
  while (v2 != a2)
  {
    *(_QWORD *)(a1 + 16) = v2 - 48;
    v5 = *(void **)(v2 - 24);
    if (v5)
    {
      *(_QWORD *)(v2 - 16) = v5;
      operator delete(v5);
      v2 = *(_QWORD *)(a1 + 16);
    }
    else
    {
      v2 -= 48;
    }
  }
}

void std::vector<wds::tlv::Ipv4AddrInfo>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;

  v2 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 3;
  if (a2 <= v2)
  {
    if (a2 < v2)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 8 * a2;
  }
  else
  {
    std::vector<wds::tlv::Ipv4AddrInfo>::__append((void **)a1, a2 - v2);
  }
}

void std::vector<wds::tlv::Ipv4AddrInfo>::__append(void **a1, unint64_t a2)
{
  uint64_t v4;
  _BYTE *v5;
  _BYTE *v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 3)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 8 * a2);
      v7 += 8 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = v7 - (_BYTE *)*a1;
    v9 = a2 + (v8 >> 3);
    if (v9 >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 3;
    v11 = v5 - (_BYTE *)*a1;
    if (v11 >> 2 > v9)
      v9 = v11 >> 2;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v9;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>(v4, v12);
    else
      v13 = 0;
    v14 = &v13[8 * v10];
    v15 = &v13[8 * v12];
    bzero(v14, 8 * a2);
    v16 = &v14[8 * a2];
    v18 = (char *)*a1;
    v17 = (char *)a1[1];
    if (v17 != *a1)
    {
      do
      {
        v19 = *((_QWORD *)v17 - 1);
        v17 -= 8;
        *((_QWORD *)v14 - 1) = v19;
        v14 -= 8;
      }
      while (v17 != v18);
      v17 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v16;
    a1[2] = v15;
    if (v17)
      operator delete(v17);
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 61)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(8 * a2);
}

void std::vector<wds::tlv::Ipv6AddrInfo>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;

  v2 = 0xF0F0F0F0F0F0F0F1 * (*(_QWORD *)(a1 + 8) - *(_QWORD *)a1);
  v3 = a2 >= v2;
  v4 = a2 - v2;
  if (v4 != 0 && v3)
  {
    std::vector<wds::tlv::Ipv6AddrInfo>::__append((void **)a1, v4);
  }
  else if (!v3)
  {
    *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 17 * a2;
  }
}

void std::vector<wds::tlv::Ipv6AddrInfo>::__append(void **a1, unint64_t a2)
{
  uint64_t v4;
  _BYTE *v5;
  _BYTE *v6;
  char *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  size_t v13;
  char *v14;
  char *v15;
  size_t v16;
  char *v17;
  char *v18;
  char *v19;
  __int128 v20;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (0xF0F0F0F0F0F0F0F1 * (v6 - v7) >= a2)
  {
    if (a2)
    {
      v13 = 17 * ((17 * a2 - 17) / 0x11) + 17;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = 0xF0F0F0F0F0F0F0F1 * (v7 - (_BYTE *)*a1);
    v9 = v8 + a2;
    if (v8 + a2 >= 0xF0F0F0F0F0F0F10)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = 0xF0F0F0F0F0F0F0F1 * (v5 - (_BYTE *)*a1);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x787878787878787)
      v11 = 0xF0F0F0F0F0F0F0FLL;
    else
      v11 = v9;
    if (v11)
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv6AddrInfo>>(v4, v11);
    else
      v12 = 0;
    v14 = &v12[17 * v8];
    v15 = &v12[17 * v11];
    v16 = 17 * ((17 * a2 - 17) / 0x11) + 17;
    bzero(v14, v16);
    v17 = &v14[v16];
    v19 = (char *)*a1;
    v18 = (char *)a1[1];
    if (v18 != *a1)
    {
      do
      {
        v20 = *(_OWORD *)(v18 - 17);
        *(v14 - 1) = *(v18 - 1);
        *(_OWORD *)(v14 - 17) = v20;
        v14 -= 17;
        v18 -= 17;
      }
      while (v18 != v19);
      v18 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v17;
    a1[2] = v15;
    if (v18)
      operator delete(v18);
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv6AddrInfo>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xF0F0F0F0F0F0F10)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(17 * a2);
}

void std::vector<unsigned int>::resize(std::vector<unsigned int> *this, std::vector<unsigned int>::size_type __sz)
{
  std::vector<unsigned int>::size_type v2;

  v2 = this->__end_ - this->__begin_;
  if (__sz <= v2)
  {
    if (__sz < v2)
      this->__end_ = &this->__begin_[__sz];
  }
  else
  {
    std::vector<unsigned int>::__append(this, __sz - v2);
  }
}

void std::vector<unsigned int>::__append(std::vector<unsigned int> *this, std::vector<unsigned int>::size_type __n)
{
  std::__compressed_pair<unsigned int *> *p_end_cap;
  unsigned int *v5;
  unsigned int *value;
  unsigned int *end;
  std::vector<unsigned int>::pointer begin;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  unsigned int *v16;
  unsigned int *v17;
  int v18;

  value = this->__end_cap_.__value_;
  p_end_cap = &this->__end_cap_;
  v5 = value;
  end = p_end_cap[-1].__value_;
  if (__n <= value - end)
  {
    if (__n)
    {
      bzero(p_end_cap[-1].__value_, 4 * __n);
      end += __n;
    }
    this->__end_ = end;
  }
  else
  {
    begin = this->__begin_;
    v9 = (char *)end - (char *)this->__begin_;
    v10 = __n + (v9 >> 2);
    if (v10 >> 62)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v11 = v9 >> 2;
    v12 = (char *)v5 - (char *)begin;
    if (v12 >> 1 > v10)
      v10 = v12 >> 1;
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFFCLL)
      v13 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v13 = v10;
    if (v13)
    {
      v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::array<unsigned char,4ul>>>((uint64_t)p_end_cap, v13);
      begin = this->__begin_;
      end = this->__end_;
    }
    else
    {
      v14 = 0;
    }
    v15 = &v14[4 * v11];
    v16 = (unsigned int *)&v14[4 * v13];
    bzero(v15, 4 * __n);
    v17 = (unsigned int *)&v15[4 * __n];
    while (end != begin)
    {
      v18 = *--end;
      *((_DWORD *)v15 - 1) = v18;
      v15 -= 4;
    }
    this->__begin_ = (std::vector<unsigned int>::pointer)v15;
    this->__end_ = v17;
    this->__end_cap_.__value_ = v16;
    if (begin)
      operator delete(begin);
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::FrameData>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x1F07C1F07C1F07DLL)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(132 * a2);
}

uint64_t tlv::parseV<dms::tlv::PRLVersion>(unint64_t *a1, int a2)
{
  unsigned __int16 *v3;
  uint64_t result;

  v3 = (unsigned __int16 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 2uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168AB2AC(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168AB2A0);
}

uint64_t tlv::parseV<dms::tlv::BandCapability>(unint64_t *a1, int a2)
{
  uint64_t *v3;
  uint64_t result;

  v3 = (uint64_t *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 8uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168AB2F8(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168AB2ECLL);
}

uint64_t tlv::parseV<dms::tlv::TDSCDMABandCapability>(unint64_t *a1, int a2)
{
  uint64_t *v3;
  uint64_t result;

  v3 = (uint64_t *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 8uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168AB344(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168AB338);
}

unsigned __int16 *dms::tlv::parseField(unint64_t a1, const unsigned __int8 *a2, void **a3)
{
  unsigned __int16 *v5;
  unsigned int v6;

  v5 = (unsigned __int16 *)a1;
  tlv::throwIfNotEnoughBytes(a1, a2, 2uLL);
  v6 = *v5++;
  tlv::throwIfNotEnoughBytes((unint64_t)v5, a2, 2 * v6);
  std::vector<unsigned short>::resize((uint64_t)a3, v6);
  memcpy(*a3, v5, 2 * v6);
  return &v5[v6];
}

unsigned __int16 *tlv::parseV<dms::tlv::LTEBandCapabilityExtended>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  unsigned __int16 *result;

  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  result = dms::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), (void **)a3);
  *a1 = (unint64_t)result;
  return result;
}

void sub_2168AB408(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168AB3FCLL);
}

void sub_2168AB418(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

unsigned __int16 *tlv::parseV<dms::tlv::NRBandCapability>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  unsigned __int16 *result;

  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  result = dms::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), (void **)a3);
  *a1 = (unint64_t)result;
  return result;
}

void sub_2168AB470(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168AB464);
}

void sub_2168AB480(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t tlv::parseV<dms::tlv::PRLInitNotification>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168AB4D4(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168AB4C8);
}

void tlv::parseV<dms::tlv::TLVMIN>(std::string::value_type **a1@<X0>, int a2@<W1>, std::string *a3@<X8>)
{
  std::string::value_type *v4;

  a3->__r_.__value_.__r.__words[0] = 0;
  a3->__r_.__value_.__l.__size_ = 0;
  a3->__r_.__value_.__r.__words[2] = 0;
  v4 = &(*a1)[a2];
  std::string::__assign_trivial[abi:ne180100]<unsigned char const*,unsigned char const*>(a3, *a1, v4, a2);
  *a1 = v4;
}

void sub_2168AB538(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168AB528);
}

void sub_2168AB548(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

void tlv::parseV<dms::tlv::ESN>(std::string::value_type **a1@<X0>, int a2@<W1>, std::string *a3@<X8>)
{
  std::string::value_type *v4;

  a3->__r_.__value_.__r.__words[0] = 0;
  a3->__r_.__value_.__l.__size_ = 0;
  a3->__r_.__value_.__r.__words[2] = 0;
  v4 = &(*a1)[a2];
  std::string::__assign_trivial[abi:ne180100]<unsigned char const*,unsigned char const*>(a3, *a1, v4, a2);
  *a1 = v4;
}

void sub_2168AB5B4(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168AB5A4);
}

void sub_2168AB5C4(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

void tlv::parseV<dms::tlv::IMEI>(std::string::value_type **a1@<X0>, int a2@<W1>, std::string *a3@<X8>)
{
  std::string::value_type *v4;

  a3->__r_.__value_.__r.__words[0] = 0;
  a3->__r_.__value_.__l.__size_ = 0;
  a3->__r_.__value_.__r.__words[2] = 0;
  v4 = &(*a1)[a2];
  std::string::__assign_trivial[abi:ne180100]<unsigned char const*,unsigned char const*>(a3, *a1, v4, a2);
  *a1 = v4;
}

void sub_2168AB630(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168AB620);
}

void sub_2168AB640(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

void tlv::parseV<dms::tlv::MEID>(std::string::value_type **a1@<X0>, int a2@<W1>, std::string *a3@<X8>)
{
  std::string::value_type *v4;

  a3->__r_.__value_.__r.__words[0] = 0;
  a3->__r_.__value_.__l.__size_ = 0;
  a3->__r_.__value_.__r.__words[2] = 0;
  v4 = &(*a1)[a2];
  std::string::__assign_trivial[abi:ne180100]<unsigned char const*,unsigned char const*>(a3, *a1, v4, a2);
  *a1 = v4;
}

void sub_2168AB6AC(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168AB69CLL);
}

void sub_2168AB6BC(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

void tlv::parseV<dms::tlv::IMEISVN>(std::string::value_type **a1@<X0>, int a2@<W1>, std::string *a3@<X8>)
{
  std::string::value_type *v4;

  a3->__r_.__value_.__r.__words[0] = 0;
  a3->__r_.__value_.__l.__size_ = 0;
  a3->__r_.__value_.__r.__words[2] = 0;
  v4 = &(*a1)[a2];
  std::string::__assign_trivial[abi:ne180100]<unsigned char const*,unsigned char const*>(a3, *a1, v4, a2);
  *a1 = v4;
}

void sub_2168AB728(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168AB718);
}

void sub_2168AB738(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

uint64_t tlv::parseV<p2p::tlv::MessageType>(unint64_t *a1, int a2)
{
  unsigned __int16 *v3;
  uint64_t result;

  v3 = (unsigned __int16 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 2uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168AB78C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168AB780);
}

char *p2p::tlv::parseField(unint64_t a1, const unsigned __int8 *a2, _QWORD *a3)
{
  char *v5;
  unsigned int v6;

  v5 = (char *)a1;
  tlv::throwIfNotEnoughBytes(a1, a2, 2uLL);
  v6 = *(unsigned __int16 *)v5;
  v5 += 2;
  tlv::throwIfNotEnoughBytes((unint64_t)v5, a2, v6);
  std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(a3, v5, &v5[v6], v6);
  return &v5[v6];
}

char *tlv::parseV<p2p::tlv::MessageData>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  char *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = p2p::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), a3);
  *a1 = (unint64_t)result;
  return result;
}

void sub_2168AB840(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168AB834);
}

void sub_2168AB850(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t tlv::size<p2p::tlv::MessageData>(_QWORD *a1)
{
  return a1[1] - *a1 + 5;
}

void *tlv::writeV<p2p::tlv::MessageData>(_WORD **a1, uint64_t a2)
{
  _WORD *v4;
  void *result;

  v4 = *a1;
  *v4++ = *(_DWORD *)(a2 + 8) - *(_DWORD *)a2;
  result = memcpy(v4, *(const void **)a2, *(_QWORD *)(a2 + 8) - *(_QWORD *)a2);
  *a1 = (_WORD *)((char *)v4 + *(_QWORD *)(a2 + 8) - *(_QWORD *)a2);
  return result;
}

char *tlv::parseV<p2p::tlv::Watch_BB_Info>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  char *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = p2p::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), a3);
  *a1 = (unint64_t)result;
  return result;
}

void sub_2168AB918(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168AB90CLL);
}

void sub_2168AB928(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t tlv::size<p2p::tlv::HWVersion>(uint64_t a1)
{
  uint64_t v1;

  v1 = *(unsigned __int8 *)(a1 + 23);
  if ((v1 & 0x80u) != 0)
    v1 = *(_QWORD *)(a1 + 8);
  return v1 + 4;
}

void *tlv::writeV<p2p::tlv::HWVersion>(_BYTE **a1, _BYTE *a2)
{
  _BYTE *v2;
  _BYTE *v4;
  uint64_t v5;
  char *v6;
  size_t v7;
  size_t v8;
  void *result;
  uint64_t v10;

  v2 = a2;
  v4 = *a1;
  LOBYTE(v5) = a2[23];
  if ((v5 & 0x80u) != 0)
    v5 = *((_QWORD *)a2 + 1);
  *v4 = v5;
  v6 = v4 + 1;
  v7 = *((_QWORD *)a2 + 1);
  if ((char)a2[23] >= 0)
  {
    v8 = a2[23];
  }
  else
  {
    a2 = *(_BYTE **)a2;
    v8 = v7;
  }
  result = memcpy(v6, a2, v8);
  v10 = v2[23];
  if ((v10 & 0x80u) != 0)
    v10 = *((_QWORD *)v2 + 1);
  *a1 = &v6[v10];
  return result;
}

uint64_t tlv::parseV<p2p::tlv::Delete>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168ABA18(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168ABA0CLL);
}

_WORD **tlv::writeV<p2p::tlv::Companion_OS_Type>(_WORD **result, _DWORD *a2)
{
  _WORD *v2;

  v2 = *result;
  *v2 = *a2;
  *result = v2 + 1;
  return result;
}

_BYTE *vs::tlv::parseField(_BYTE *a1, const unsigned __int8 *a2, _BYTE *a3)
{
  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  *a3 = *a1;
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 1), a2, 1uLL);
  a3[1] = a1[1];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 2), a2, 1uLL);
  a3[2] = a1[2];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 3), a2, 1uLL);
  a3[3] = a1[3];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 4), a2, 1uLL);
  a3[4] = a1[4];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 5), a2, 1uLL);
  a3[5] = a1[5];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 6), a2, 1uLL);
  a3[6] = a1[6];
  return a1 + 7;
}

{
  _BYTE *result;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  *a3 = *a1;
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 1), a2, 1uLL);
  a3[1] = a1[1];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 2), a2, 1uLL);
  result = a1 + 3;
  a3[2] = a1[2] != 0;
  return result;
}

{
  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  *a3 = *a1;
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 1), a2, 1uLL);
  a3[1] = a1[1];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 2), a2, 1uLL);
  a3[2] = a1[2];
  return a1 + 3;
}

{
  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  *a3 = *a1;
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 1), a2, 1uLL);
  a3[1] = a1[1];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 2), a2, 1uLL);
  a3[2] = a1[2];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 3), a2, 1uLL);
  a3[3] = a1[3];
  return a1 + 4;
}

_BYTE *vs::tlv::writeField(_BYTE *a1, uint64_t a2)
{
  uint64_t v3;
  _BYTE *v4;
  size_t v5;
  size_t v6;
  const void *v7;
  size_t v8;
  uint64_t v9;

  *a1 = *(_BYTE *)a2;
  a1[1] = *(_DWORD *)(a2 + 4);
  a1[2] = *(_DWORD *)(a2 + 8);
  a1[3] = *(_BYTE *)(a2 + 12);
  a1[4] = *(_BYTE *)(a2 + 13);
  a1[5] = *(_DWORD *)(a2 + 16);
  LOBYTE(v3) = *(_BYTE *)(a2 + 47);
  if ((v3 & 0x80u) != 0)
    v3 = *(_QWORD *)(a2 + 32);
  v4 = a1 + 7;
  a1[6] = v3;
  v5 = *(unsigned __int8 *)(a2 + 47);
  v6 = *(_QWORD *)(a2 + 32);
  if ((v5 & 0x80u) == 0)
    v7 = (const void *)(a2 + 24);
  else
    v7 = *(const void **)(a2 + 24);
  if ((v5 & 0x80u) == 0)
    v8 = v5;
  else
    v8 = v6;
  memcpy(a1 + 7, v7, v8);
  v9 = *(unsigned __int8 *)(a2 + 47);
  if ((v9 & 0x80u) != 0)
    v9 = *(_QWORD *)(a2 + 32);
  return &v4[v9];
}

std::string::value_type *vs::tlv::parseField(unint64_t a1, const unsigned __int8 *a2, uint64_t a3)
{
  std::string::value_type *v5;
  unint64_t v6;

  v5 = (std::string::value_type *)a1;
  tlv::throwIfNotEnoughBytes(a1, a2, 1uLL);
  *(_BYTE *)a3 = *v5;
  tlv::throwIfNotEnoughBytes((unint64_t)(v5 + 1), a2, 1uLL);
  *(_BYTE *)(a3 + 1) = v5[1];
  tlv::throwIfNotEnoughBytes((unint64_t)(v5 + 2), a2, 1uLL);
  v6 = v5[2];
  v5 += 3;
  tlv::throwIfNotEnoughBytes((unint64_t)v5, a2, v6);
  std::string::__assign_trivial[abi:ne180100]<unsigned char const*,unsigned char const*>((std::string *)(a3 + 8), v5, &v5[v6], v6);
  return &v5[v6];
}

{
  std::string::value_type *v5;
  unint64_t v6;

  v5 = (std::string::value_type *)a1;
  tlv::throwIfNotEnoughBytes(a1, a2, 1uLL);
  *(_BYTE *)a3 = *v5;
  tlv::throwIfNotEnoughBytes((unint64_t)(v5 + 1), a2, 1uLL);
  *(_BYTE *)(a3 + 1) = v5[1];
  tlv::throwIfNotEnoughBytes((unint64_t)(v5 + 2), a2, 1uLL);
  *(_BYTE *)(a3 + 2) = v5[2];
  tlv::throwIfNotEnoughBytes((unint64_t)(v5 + 3), a2, 1uLL);
  v6 = v5[3];
  v5 += 4;
  tlv::throwIfNotEnoughBytes((unint64_t)v5, a2, v6);
  std::string::__assign_trivial[abi:ne180100]<unsigned char const*,unsigned char const*>((std::string *)(a3 + 8), v5, &v5[v6], v6);
  return &v5[v6];
}

unsigned __int8 *vs::tlv::parseField(unint64_t a1, const unsigned __int8 *a2, uint64_t a3)
{
  char *v5;
  unint64_t v6;

  v5 = (char *)a1;
  tlv::throwIfNotEnoughBytes(a1, a2, 1uLL);
  *(_DWORD *)a3 = *v5;
  tlv::throwIfNotEnoughBytes((unint64_t)(v5 + 1), a2, 1uLL);
  v6 = v5[1];
  v5 += 2;
  tlv::throwIfNotEnoughBytes((unint64_t)v5, a2, v6);
  std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((_QWORD *)(a3 + 8), v5, &v5[v6], v6);
  return (unsigned __int8 *)&v5[v6];
}

unsigned __int8 *tlv::parseV<vs::tlv::USSInfo>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  unsigned __int8 *result;

  *a3 = 0u;
  a3[1] = 0u;
  result = vs::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), (uint64_t)a3);
  *a1 = (unint64_t)result;
  return result;
}

void sub_2168ABE3C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168ABE30);
}

void sub_2168ABE4C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)(v1 + 8);
  if (v3)
  {
    *(_QWORD *)(v1 + 16) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t tlv::size<vs::tlv::USSInfo>(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8) + 5;
}

void *tlv::writeV<vs::tlv::USSInfo>(_BYTE **a1, uint64_t a2)
{
  _BYTE *v4;
  _BYTE *v5;
  void *result;

  v4 = *a1;
  *v4 = *(_DWORD *)a2;
  v5 = v4 + 2;
  v4[1] = *(_BYTE *)(a2 + 16) - *(_DWORD *)(a2 + 8);
  result = memcpy(v4 + 2, *(const void **)(a2 + 8), *(_QWORD *)(a2 + 16) - *(_QWORD *)(a2 + 8));
  *a1 = &v5[*(_QWORD *)(a2 + 16) - *(_QWORD *)(a2 + 8)];
  return result;
}

unsigned __int8 *tlv::parseV<vs::tlv::UTF16Data>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  unsigned __int8 *result;

  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  result = wds::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), (void **)a3);
  *a1 = (unint64_t)result;
  return result;
}

void sub_2168ABF20(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168ABF14);
}

void sub_2168ABF30(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

unsigned __int8 *vs::tlv::parseField(_BYTE *a1, unsigned __int8 *a2, uint64_t a3)
{
  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  *(_BYTE *)a3 = *a1;
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 1), a2, 1uLL);
  *(_BYTE *)(a3 + 1) = a1[1];
  std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((_QWORD *)(a3 + 8), a1 + 2, (char *)a2, a2 - (a1 + 2));
  return a2;
}

unsigned __int8 *tlv::parseV<vs::tlv::OtaspStatus>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  unsigned __int8 *v4;
  unsigned __int8 *v5;
  unsigned __int8 *result;

  *a3 = 0u;
  a3[1] = 0u;
  v4 = *a1;
  v5 = &v4[a2];
  result = vs::tlv::parseField(v4, v5, (uint64_t)a3);
  *a1 = v5;
  return result;
}

void sub_2168AC000(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168ABFF0);
}

void sub_2168AC010(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)(v1 + 8);
  if (v3)
  {
    *(_QWORD *)(v1 + 16) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t tlv::parseV<vs::tlv::SignalInfo>(_BYTE **a1, int a2)
{
  unsigned __int16 v3;
  unsigned __int8 v4;

  v4 = 0;
  v3 = 0;
  *a1 = vs::tlv::parseField(*a1, &(*a1)[a2], &v3);
  return v3 | (v4 << 16);
}

void sub_2168AC0E8(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168AC0CCLL);
}

unint64_t vs::tlv::parseField(unint64_t a1, const unsigned __int8 *a2, uint64_t a3)
{
  unint64_t v5;
  unint64_t v6;

  v5 = a1;
  tlv::throwIfNotEnoughBytes(a1, a2, 1uLL);
  *(_BYTE *)a3 = *(_BYTE *)v5;
  tlv::throwIfNotEnoughBytes(v5 + 1, a2, 1uLL);
  v6 = *(unsigned __int8 *)(v5 + 1);
  v5 += 2;
  tlv::throwIfNotEnoughBytes(v5, a2, v6);
  std::string::__assign_trivial[abi:ne180100]<unsigned char const*,unsigned char const*>((std::string *)(a3 + 8), (std::string::value_type *)v5, (std::string::value_type *)(v5 + v6), v6);
  return v5 + v6;
}

unint64_t tlv::parseV<vs::tlv::CallerIdInfo>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  unint64_t result;

  *a3 = 0u;
  a3[1] = 0u;
  result = vs::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), (uint64_t)a3);
  *a1 = result;
  return result;
}

void sub_2168AC1B4(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168AC1A8);
}

void sub_2168AC1C4(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 31) < 0)
    operator delete(*(void **)(v1 + 8));
  _Unwind_Resume(exception_object);
}

_QWORD *tlv::parseV<vs::tlv::DisplayBuffer>@<X0>(char **a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  char *v4;
  _QWORD *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  v4 = &(*a1)[a2];
  result = std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(a3, *a1, v4, a2);
  *a1 = v4;
  return result;
}

void sub_2168AC230(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168AC220);
}

void sub_2168AC240(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *tlv::parseV<vs::tlv::CallerName>@<X0>(char **a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  char *v4;
  _QWORD *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  v4 = &(*a1)[a2];
  result = std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(a3, *a1, v4, a2);
  *a1 = v4;
  return result;
}

void sub_2168AC2AC(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168AC29CLL);
}

void sub_2168AC2BC(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t tlv::parseV<vs::tlv::CallWaitingInfo>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168AC310(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168AC304);
}

uint64_t tlv::parseV<vs::tlv::LineControl>(_BYTE **a1, int a2)
{
  unsigned int v3;

  v3 = 0;
  *a1 = vs::tlv::parseField(*a1, &(*a1)[a2], &v3);
  return v3;
}

void sub_2168AC3EC(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168AC3D8);
}

void *tlv::writeV<vs::tlv::BurstDtmfInfo>(_BYTE **a1, uint64_t a2)
{
  _BYTE *v4;
  _BYTE *v5;
  void *result;

  v4 = *a1;
  *v4 = *(_BYTE *)a2;
  v5 = v4 + 2;
  v4[1] = *(_BYTE *)(a2 + 16) - *(_DWORD *)(a2 + 8);
  result = memcpy(v4 + 2, *(const void **)(a2 + 8), *(_QWORD *)(a2 + 16) - *(_QWORD *)(a2 + 8));
  *a1 = &v5[*(_QWORD *)(a2 + 16) - *(_QWORD *)(a2 + 8)];
  return result;
}

_BYTE *vs::tlv::parseField(unsigned __int8 *a1, const unsigned __int8 *a2, uint64_t *a3)
{
  _BYTE *v6;
  unsigned int v7;
  _BYTE *v8;
  _BYTE *v9;
  _BYTE *result;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  v7 = *a1;
  v6 = a1 + 1;
  std::vector<vs::tlv::CallListItem>::resize(a3, v7);
  v8 = (_BYTE *)*a3;
  v9 = (_BYTE *)a3[1];
  while (1)
  {
    result = v6;
    if (v8 == v9)
      break;
    v6 = vs::tlv::parseField(v6, a2, v8);
    v8 += 7;
  }
  return result;
}

unsigned __int8 *tlv::parseV<vs::tlv::CallList>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  unsigned __int8 *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = vs::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = result;
  return result;
}

void sub_2168AC50C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168AC500);
}

void sub_2168AC51C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

std::string::value_type *vs::tlv::parseField(unsigned __int8 *a1, const unsigned __int8 *a2, uint64_t *a3)
{
  std::string::value_type *v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  std::string::value_type *result;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  v7 = *a1;
  v6 = (std::string::value_type *)(a1 + 1);
  std::vector<vs::tlv::RemoteNumberListItem>::resize(a3, v7);
  v8 = *a3;
  v9 = a3[1];
  while (1)
  {
    result = v6;
    if (v8 == v9)
      break;
    v6 = vs::tlv::parseField((unint64_t)v6, a2, v8);
    v8 += 32;
  }
  return result;
}

{
  std::string::value_type *v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  std::string::value_type *result;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  v7 = *a1;
  v6 = (std::string::value_type *)(a1 + 1);
  std::vector<vs::tlv::RemoteNameListItem>::resize(a3, v7);
  v8 = *a3;
  v9 = a3[1];
  while (1)
  {
    result = v6;
    if (v8 == v9)
      break;
    v6 = vs::tlv::parseField((unint64_t)v6, a2, v8);
    v8 += 32;
  }
  return result;
}

std::string::value_type *tlv::parseV<vs::tlv::RemoteNumberList>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  std::string::value_type *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = vs::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = (unsigned __int8 *)result;
  return result;
}

void sub_2168AC5E4(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168AC5D4);
}

void sub_2168AC5F4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::vector<vs::tlv::RemoteNumberListItem>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

std::string::value_type *tlv::parseV<vs::tlv::RemoteNameList>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  std::string::value_type *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = vs::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = (unsigned __int8 *)result;
  return result;
}

void sub_2168AC6B8(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168AC6A8);
}

void sub_2168AC6C8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::vector<vs::tlv::RemoteNumberListItem>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

unint64_t vs::tlv::parseField(unsigned __int8 *a1, const unsigned __int8 *a2, uint64_t *a3)
{
  unint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  v7 = *a1;
  v6 = (unint64_t)(a1 + 1);
  std::vector<std::array<unsigned char,4ul>>::resize((uint64_t)a3, v7);
  v9 = *a3;
  v8 = a3[1];
  while (v9 != v8)
  {
    tlv::throwIfNotEnoughBytes(v6, a2, 1uLL);
    *(_BYTE *)v9 = *(_BYTE *)v6;
    tlv::throwIfNotEnoughBytes(v6 + 1, a2, 2uLL);
    *(_WORD *)(v9 + 2) = *(_WORD *)(v6 + 1);
    v6 += 3;
    v9 += 4;
  }
  return v6;
}

{
  unint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t result;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  v7 = *a1;
  v6 = (unint64_t)(a1 + 1);
  std::vector<vs::tlv::ServiceParam>::resize(a3, v7);
  v8 = *a3;
  v9 = a3[1];
  while (1)
  {
    result = v6;
    if (v8 == v9)
      break;
    v6 = vs::tlv::parseField(v6, a2, v8);
    v8 += 40;
  }
  return result;
}

unint64_t tlv::parseV<vs::tlv::CallEndReasonList>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  unint64_t result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = vs::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = (unsigned __int8 *)result;
  return result;
}

void sub_2168AC7A8(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168AC79CLL);
}

void sub_2168AC7B8(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_BYTE *vs::tlv::parseField(unsigned __int8 *a1, const unsigned __int8 *a2, _QWORD *a3)
{
  _BYTE *v6;
  unsigned int v7;
  _BYTE *v8;
  _BYTE *v9;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  v7 = *a1;
  v6 = a1 + 1;
  std::vector<vs::tlv::IsHandoverCallItem>::resize((uint64_t)a3, v7);
  v9 = (_BYTE *)*a3;
  v8 = (_BYTE *)a3[1];
  while (v9 != v8)
  {
    tlv::throwIfNotEnoughBytes((unint64_t)v6, a2, 1uLL);
    *v9 = *v6;
    tlv::throwIfNotEnoughBytes((unint64_t)(v6 + 1), a2, 1uLL);
    v9[1] = v6[1];
    v6 += 2;
    v9 += 2;
  }
  return v6;
}

{
  _BYTE *v6;
  unsigned int v7;
  _BYTE *v8;
  _BYTE *v9;
  _BYTE *result;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  v7 = *a1;
  v6 = a1 + 1;
  std::vector<vs::tlv::ParentCallInfoItem>::resize((uint64_t)a3, v7);
  v8 = (_BYTE *)*a3;
  v9 = (_BYTE *)a3[1];
  while (1)
  {
    result = v6;
    if (v8 == v9)
      break;
    v6 = vs::tlv::parseField(v6, a2, v8);
    v8 += 3;
  }
  return result;
}

unsigned __int8 *tlv::parseV<vs::tlv::IsHandoverCallList>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  unsigned __int8 *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = vs::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = result;
  return result;
}

void sub_2168AC89C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168AC890);
}

void sub_2168AC8AC(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

unsigned __int8 *tlv::parseV<vs::tlv::ParentCallInfo>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  unsigned __int8 *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = vs::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = result;
  return result;
}

void sub_2168AC96C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168AC960);
}

void sub_2168AC97C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t tlv::parseV<vs::tlv::NotificationType>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168AC9D0(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168AC9C4);
}

uint64_t tlv::parseV<vs::tlv::Error>(unint64_t *a1, int a2)
{
  unsigned __int16 *v3;
  uint64_t result;

  v3 = (unsigned __int16 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 2uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168ACA1C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168ACA10);
}

uint64_t tlv::parseV<vs::tlv::HandoverState>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168ACA68(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168ACA5CLL);
}

_BYTE *vs::tlv::writeField(_BYTE *a1, _DWORD *a2)
{
  _BYTE *result;
  uint64_t v3;
  uint64_t v4;

  *a1 = -85 * ((a2[2] - *a2) >> 4);
  result = a1 + 1;
  v3 = *(_QWORD *)a2;
  v4 = *((_QWORD *)a2 + 1);
  while (v3 != v4)
  {
    result = vs::tlv::writeField(result, v3);
    v3 += 48;
  }
  return result;
}

uint64_t tlv::size<vs::tlv::CallConfigList>(uint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v1 = *a1;
  v2 = a1[1];
  if (*a1 == v2)
    return 4;
  v3 = 0;
  do
  {
    v4 = *(unsigned __int8 *)(v1 + 47);
    if ((v4 & 0x80u) != 0)
      v4 = *(_QWORD *)(v1 + 32);
    v3 += v4 + 7;
    v1 += 48;
  }
  while (v1 != v2);
  return v3 + 4;
}

_BYTE *tlv::writeV<vs::tlv::CallConfigList>(_BYTE **a1, _DWORD *a2)
{
  _BYTE *result;

  result = vs::tlv::writeField(*a1, a2);
  *a1 = result;
  return result;
}

void std::vector<vs::tlv::RemoteNumberListItem>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<vs::tlv::RemoteNumberListItem>::__clear[abi:ne180100]((uint64_t *)v2);
    operator delete(**a1);
  }
}

void std::vector<vs::tlv::RemoteNumberListItem>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v2;
  uint64_t i;

  v2 = *a1;
  for (i = a1[1]; i != v2; i -= 32)
  {
    if (*(char *)(i - 1) < 0)
      operator delete(*(void **)(i - 24));
  }
  a1[1] = v2;
}

void std::vector<vs::tlv::CallConfigItem>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<vs::tlv::CallConfigItem>::__clear[abi:ne180100]((uint64_t *)v2);
    operator delete(**a1);
  }
}

void std::vector<vs::tlv::CallConfigItem>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v2;
  uint64_t i;

  v2 = *a1;
  for (i = a1[1]; i != v2; i -= 48)
  {
    if (*(char *)(i - 1) < 0)
      operator delete(*(void **)(i - 24));
  }
  a1[1] = v2;
}

void std::vector<vs::tlv::CallListItem>::resize(uint64_t *a1, unint64_t a2)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;

  v2 = 0x6DB6DB6DB6DB6DB7 * (a1[1] - *a1);
  v3 = a2 >= v2;
  v4 = a2 - v2;
  if (v4 != 0 && v3)
  {
    std::vector<vs::tlv::CallListItem>::__append(a1, v4);
  }
  else if (!v3)
  {
    a1[1] = *a1 - a2 + 8 * a2;
  }
}

void std::vector<vs::tlv::CallListItem>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  void *v12;
  size_t v13;
  uint64_t v14;
  uint64_t v15;
  size_t v16;
  size_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  int v21;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (0x6DB6DB6DB6DB6DB7 * (v6 - v7) >= a2)
  {
    if (a2)
    {
      v13 = 7 * ((7 * a2 - 7) / 7) + 7;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = 0x6DB6DB6DB6DB6DB7 * (v7 - *a1);
    v9 = v8 + a2;
    if (v8 + a2 > 0x2492492492492492)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = 0x6DB6DB6DB6DB6DB7 * (v5 - *a1);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x1249249249249249)
      v11 = 0x2492492492492492;
    else
      v11 = v9;
    if (v11)
      v12 = std::__allocate_at_least[abi:ne180100]<std::allocator<vs::tlv::CallListItem>>(v4, v11);
    else
      v12 = 0;
    v14 = (uint64_t)v12 + 8 * v8 - v8;
    v15 = (uint64_t)v12 + 8 * v11 - v11;
    v16 = 7 * ((7 * a2 - 7) / 7) + 7;
    bzero((void *)v14, v16);
    v17 = v14 + v16;
    v19 = *a1;
    v18 = a1[1];
    if (v18 != *a1)
    {
      do
      {
        v20 = *(_DWORD *)(v18 - 7);
        v18 -= 7;
        v21 = *(_DWORD *)(v18 + 3);
        *(_DWORD *)(v14 - 7) = v20;
        v14 -= 7;
        *(_DWORD *)(v14 + 3) = v21;
      }
      while (v18 != v19);
      v18 = *a1;
    }
    *a1 = v14;
    a1[1] = v17;
    a1[2] = v15;
    if (v18)
      operator delete((void *)v18);
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<vs::tlv::CallListItem>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x2492492492492493)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(7 * a2);
}

void std::vector<vs::tlv::RemoteNumberListItem>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;

  v3 = a1[1];
  v4 = (v3 - *a1) >> 5;
  if (a2 <= v4)
  {
    if (a2 < v4)
    {
      v5 = *a1 + 32 * a2;
      while (v3 != v5)
      {
        if (*(char *)(v3 - 1) < 0)
          operator delete(*(void **)(v3 - 24));
        v3 -= 32;
      }
      a1[1] = v5;
    }
  }
  else
  {
    std::vector<vs::tlv::RemoteNumberListItem>::__append(a1, a2 - v4);
  }
}

void std::vector<vs::tlv::RemoteNumberListItem>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (a2 <= (v6 - v7) >> 5)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 32 * a2);
      v7 += 32 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = v7 - *a1;
    v9 = a2 + (v8 >> 5);
    if (v9 >> 59)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 5;
    v11 = v5 - *a1;
    if (v11 >> 4 > v9)
      v9 = v11 >> 4;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFE0)
      v12 = 0x7FFFFFFFFFFFFFFLL;
    else
      v12 = v9;
    v18 = v4;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<vs::tlv::RemoteNumberListItem>>(v4, v12);
    else
      v13 = 0;
    v14 = v13;
    v15 = &v13[32 * v10];
    v17 = &v13[32 * v12];
    bzero(v15, 32 * a2);
    v16 = &v15[32 * a2];
    std::vector<vs::tlv::RemoteNumberListItem>::__swap_out_circular_buffer(a1, &v14);
    std::__split_buffer<vs::tlv::RemoteNumberListItem>::~__split_buffer((uint64_t)&v14);
  }
}

void sub_2168AD008(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<vs::tlv::RemoteNumberListItem>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<vs::tlv::RemoteNumberListItem>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<vs::tlv::RemoteNumberListItem>,std::reverse_iterator<vs::tlv::RemoteNumberListItem*>,std::reverse_iterator<vs::tlv::RemoteNumberListItem*>,std::reverse_iterator<vs::tlv::RemoteNumberListItem*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<vs::tlv::RemoteNumberListItem>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 59)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(32 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<vs::tlv::RemoteNumberListItem>,std::reverse_iterator<vs::tlv::RemoteNumberListItem*>,std::reverse_iterator<vs::tlv::RemoteNumberListItem*>,std::reverse_iterator<vs::tlv::RemoteNumberListItem*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  __int16 v8;
  __int128 v9;
  uint64_t v10;
  _QWORD v12[3];
  uint64_t v13;
  __int128 v14;
  __int128 v15;

  v7 = a7;
  *(_QWORD *)&v15 = a6;
  *((_QWORD *)&v15 + 1) = a7;
  v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  v13 = 0;
  if (a3 == a5)
  {
    v10 = a6;
  }
  else
  {
    do
    {
      v8 = *(_WORD *)(a3 - 32);
      a3 -= 32;
      *(_WORD *)(v7 - 32) = v8;
      v9 = *(_OWORD *)(a3 + 8);
      *(_QWORD *)(v7 - 8) = *(_QWORD *)(a3 + 24);
      *(_OWORD *)(v7 - 24) = v9;
      *(_QWORD *)(a3 + 8) = 0;
      *(_QWORD *)(a3 + 16) = 0;
      *(_QWORD *)(a3 + 24) = 0;
      v7 = *((_QWORD *)&v15 + 1) - 32;
      *((_QWORD *)&v15 + 1) -= 32;
    }
    while (a3 != a5);
    v10 = v15;
  }
  LOBYTE(v13) = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<vs::tlv::RemoteNumberListItem>,std::reverse_iterator<vs::tlv::RemoteNumberListItem*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return v10;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<vs::tlv::RemoteNumberListItem>,std::reverse_iterator<vs::tlv::RemoteNumberListItem*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<vs::tlv::RemoteNumberListItem>,std::reverse_iterator<vs::tlv::RemoteNumberListItem*>>::operator()[abi:ne180100](a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<vs::tlv::RemoteNumberListItem>,std::reverse_iterator<vs::tlv::RemoteNumberListItem*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8);
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    if (*(char *)(v1 + 31) < 0)
      operator delete(*(void **)(v1 + 8));
    v1 += 32;
  }
}

uint64_t std::__split_buffer<vs::tlv::RemoteNumberListItem>::~__split_buffer(uint64_t a1)
{
  std::__split_buffer<vs::tlv::RemoteNumberListItem>::__destruct_at_end[abi:ne180100](a1, *(_QWORD *)(a1 + 8));
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::__split_buffer<vs::tlv::RemoteNumberListItem>::__destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v5;

  v2 = *(_QWORD *)(a1 + 16);
  if (v2 != a2)
  {
    do
    {
      v5 = v2 - 32;
      *(_QWORD *)(a1 + 16) = v2 - 32;
      if (*(char *)(v2 - 1) < 0)
      {
        operator delete(*(void **)(v2 - 24));
        v5 = *(_QWORD *)(a1 + 16);
      }
      v2 = v5;
    }
    while (v5 != a2);
  }
}

void std::vector<vs::tlv::RemoteNameListItem>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;

  v3 = a1[1];
  v4 = (v3 - *a1) >> 5;
  if (a2 <= v4)
  {
    if (a2 < v4)
    {
      v5 = *a1 + 32 * a2;
      while (v3 != v5)
      {
        if (*(char *)(v3 - 1) < 0)
          operator delete(*(void **)(v3 - 24));
        v3 -= 32;
      }
      a1[1] = v5;
    }
  }
  else
  {
    std::vector<vs::tlv::RemoteNameListItem>::__append(a1, a2 - v4);
  }
}

void std::vector<vs::tlv::RemoteNameListItem>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (a2 <= (v6 - v7) >> 5)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 32 * a2);
      v7 += 32 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = v7 - *a1;
    v9 = a2 + (v8 >> 5);
    if (v9 >> 59)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 5;
    v11 = v5 - *a1;
    if (v11 >> 4 > v9)
      v9 = v11 >> 4;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFE0)
      v12 = 0x7FFFFFFFFFFFFFFLL;
    else
      v12 = v9;
    v18 = v4;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<vs::tlv::RemoteNumberListItem>>(v4, v12);
    else
      v13 = 0;
    v14 = v13;
    v15 = &v13[32 * v10];
    v17 = &v13[32 * v12];
    bzero(v15, 32 * a2);
    v16 = &v15[32 * a2];
    std::vector<vs::tlv::RemoteNameListItem>::__swap_out_circular_buffer(a1, &v14);
    std::__split_buffer<vs::tlv::RemoteNumberListItem>::~__split_buffer((uint64_t)&v14);
  }
}

void sub_2168AD3D0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<vs::tlv::RemoteNumberListItem>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<vs::tlv::RemoteNameListItem>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<vs::tlv::RemoteNameListItem>,std::reverse_iterator<vs::tlv::RemoteNameListItem*>,std::reverse_iterator<vs::tlv::RemoteNameListItem*>,std::reverse_iterator<vs::tlv::RemoteNameListItem*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<vs::tlv::RemoteNameListItem>,std::reverse_iterator<vs::tlv::RemoteNameListItem*>,std::reverse_iterator<vs::tlv::RemoteNameListItem*>,std::reverse_iterator<vs::tlv::RemoteNameListItem*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  __int16 v8;
  __int128 v9;
  uint64_t v10;
  _QWORD v12[3];
  uint64_t v13;
  __int128 v14;
  __int128 v15;

  v7 = a7;
  *(_QWORD *)&v15 = a6;
  *((_QWORD *)&v15 + 1) = a7;
  v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  v13 = 0;
  if (a3 == a5)
  {
    v10 = a6;
  }
  else
  {
    do
    {
      v8 = *(_WORD *)(a3 - 32);
      a3 -= 32;
      *(_BYTE *)(v7 - 30) = *(_BYTE *)(a3 + 2);
      *(_WORD *)(v7 - 32) = v8;
      v9 = *(_OWORD *)(a3 + 8);
      *(_QWORD *)(v7 - 8) = *(_QWORD *)(a3 + 24);
      *(_OWORD *)(v7 - 24) = v9;
      *(_QWORD *)(a3 + 8) = 0;
      *(_QWORD *)(a3 + 16) = 0;
      *(_QWORD *)(a3 + 24) = 0;
      v7 = *((_QWORD *)&v15 + 1) - 32;
      *((_QWORD *)&v15 + 1) -= 32;
    }
    while (a3 != a5);
    v10 = v15;
  }
  LOBYTE(v13) = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<vs::tlv::RemoteNameListItem>,std::reverse_iterator<vs::tlv::RemoteNameListItem*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return v10;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<vs::tlv::RemoteNameListItem>,std::reverse_iterator<vs::tlv::RemoteNameListItem*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<vs::tlv::RemoteNumberListItem>,std::reverse_iterator<vs::tlv::RemoteNumberListItem*>>::operator()[abi:ne180100](a1);
  return a1;
}

void std::vector<vs::tlv::IsHandoverCallItem>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;

  v2 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 1;
  if (a2 <= v2)
  {
    if (a2 < v2)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 2 * a2;
  }
  else
  {
    std::vector<vs::tlv::IsHandoverCallItem>::__append((void **)a1, a2 - v2);
  }
}

void std::vector<vs::tlv::IsHandoverCallItem>::__append(void **a1, unint64_t a2)
{
  uint64_t v4;
  _BYTE *v5;
  _BYTE *v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  __int16 v19;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 1)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 2 * a2);
      v7 += 2 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = v7 - (_BYTE *)*a1;
    if ((uint64_t)(a2 + (v8 >> 1)) < 0)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v9 = v8 >> 1;
    v10 = v5 - (_BYTE *)*a1;
    if (v10 <= a2 + (v8 >> 1))
      v11 = a2 + (v8 >> 1);
    else
      v11 = v10;
    if (v10 >= 0x7FFFFFFFFFFFFFFELL)
      v12 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned short>>(v4, v12);
    else
      v13 = 0;
    v14 = &v13[2 * v9];
    v15 = &v13[2 * v12];
    bzero(v14, 2 * a2);
    v16 = &v14[2 * a2];
    v18 = (char *)*a1;
    v17 = (char *)a1[1];
    if (v17 != *a1)
    {
      do
      {
        v19 = *((_WORD *)v17 - 1);
        v17 -= 2;
        *((_WORD *)v14 - 1) = v19;
        v14 -= 2;
      }
      while (v17 != v18);
      v17 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v16;
    a1[2] = v15;
    if (v17)
      operator delete(v17);
  }
}

void std::vector<vs::tlv::ParentCallInfoItem>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;

  v2 = 0xAAAAAAAAAAAAAAABLL * (*(_QWORD *)(a1 + 8) - *(_QWORD *)a1);
  v3 = a2 >= v2;
  v4 = a2 - v2;
  if (v4 != 0 && v3)
  {
    std::vector<vs::tlv::ParentCallInfoItem>::__append((char **)a1, v4);
  }
  else if (!v3)
  {
    *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 3 * a2;
  }
}

void std::vector<vs::tlv::ParentCallInfoItem>::__append(char **a1, unint64_t a2)
{
  uint64_t v4;
  char *v5;
  char *v6;
  char *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  size_t v13;
  char *v14;
  char *v15;
  size_t v16;
  char *v17;
  char *v18;
  char *v19;
  __int16 v20;
  char v21;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (0xAAAAAAAAAAAAAAABLL * (v6 - v7) >= a2)
  {
    if (a2)
    {
      v13 = 3 * ((3 * a2 - 3) / 3) + 3;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = 0xAAAAAAAAAAAAAAABLL * (v7 - *a1);
    v9 = v8 + a2;
    if (v8 + a2 >= 0x5555555555555556)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = 0xAAAAAAAAAAAAAAABLL * (v5 - *a1);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x2AAAAAAAAAAAAAAALL)
      v11 = 0x5555555555555555;
    else
      v11 = v9;
    if (v11)
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<vs::tlv::ParentCallInfoItem>>(v4, v11);
    else
      v12 = 0;
    v14 = &v12[3 * v8];
    v15 = &v12[3 * v11];
    v16 = 3 * ((3 * a2 - 3) / 3) + 3;
    bzero(v14, v16);
    v17 = &v14[v16];
    v19 = *a1;
    v18 = a1[1];
    if (v18 != *a1)
    {
      do
      {
        v20 = *(_WORD *)(v18 - 3);
        v18 -= 3;
        v21 = v18[2];
        *(_WORD *)(v14 - 3) = v20;
        v14 -= 3;
        v14[2] = v21;
      }
      while (v18 != v19);
      v18 = *a1;
    }
    *a1 = v14;
    a1[1] = v17;
    a1[2] = v15;
    if (v18)
      operator delete(v18);
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<vs::tlv::ParentCallInfoItem>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x5555555555555556)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(3 * a2);
}

uint64_t std::vector<vs::tlv::CallConfigItem>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<vs::tlv::CallConfigItem>,std::reverse_iterator<vs::tlv::CallConfigItem*>,std::reverse_iterator<vs::tlv::CallConfigItem*>,std::reverse_iterator<vs::tlv::CallConfigItem*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<vs::tlv::CallConfigItem>,std::reverse_iterator<vs::tlv::CallConfigItem*>,std::reverse_iterator<vs::tlv::CallConfigItem*>,std::reverse_iterator<vs::tlv::CallConfigItem*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v9;
  __int128 v10;
  __int128 v11;
  _QWORD v13[3];
  uint64_t v14;
  __int128 v15;
  __int128 v16;

  v7 = a7;
  *(_QWORD *)&v16 = a6;
  *((_QWORD *)&v16 + 1) = a7;
  v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  v14 = 0;
  if (a3 != a5)
  {
    v9 = a7;
    do
    {
      v10 = *(_OWORD *)(a3 - 48);
      *(_DWORD *)(v9 - 32) = *(_DWORD *)(a3 - 32);
      *(_OWORD *)(v9 - 48) = v10;
      v11 = *(_OWORD *)(a3 - 24);
      *(_QWORD *)(v9 - 8) = *(_QWORD *)(a3 - 8);
      *(_OWORD *)(v9 - 24) = v11;
      v9 -= 48;
      *(_QWORD *)(a3 - 16) = 0;
      *(_QWORD *)(a3 - 8) = 0;
      *(_QWORD *)(a3 - 24) = 0;
      v7 -= 48;
      a3 -= 48;
    }
    while (a3 != a5);
    *((_QWORD *)&v16 + 1) = v9;
  }
  LOBYTE(v14) = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<vs::tlv::CallConfigItem>,std::reverse_iterator<vs::tlv::CallConfigItem*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v13);
  return a6;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<vs::tlv::CallConfigItem>,std::reverse_iterator<vs::tlv::CallConfigItem*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<vs::tlv::CallConfigItem>,std::reverse_iterator<vs::tlv::CallConfigItem*>>::operator()[abi:ne180100](a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<vs::tlv::CallConfigItem>,std::reverse_iterator<vs::tlv::CallConfigItem*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8);
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    if (*(char *)(v1 + 47) < 0)
      operator delete(*(void **)(v1 + 24));
    v1 += 48;
  }
}

uint64_t std::__split_buffer<vs::tlv::CallConfigItem>::~__split_buffer(uint64_t a1)
{
  std::__split_buffer<vs::tlv::CallConfigItem>::__destruct_at_end[abi:ne180100](a1, *(_QWORD *)(a1 + 8));
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::__split_buffer<vs::tlv::CallConfigItem>::__destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v5;

  v2 = *(_QWORD *)(a1 + 16);
  if (v2 != a2)
  {
    do
    {
      v5 = v2 - 48;
      *(_QWORD *)(a1 + 16) = v2 - 48;
      if (*(char *)(v2 - 1) < 0)
      {
        operator delete(*(void **)(v2 - 24));
        v5 = *(_QWORD *)(a1 + 16);
      }
      v2 = v5;
    }
    while (v5 != a2);
  }
}

const char *uim::asString(unsigned int a1)
{
  if (a1 > 0x13)
    return "???";
  else
    return off_24D5C26D8[(char)a1];
}

{
  if (a1 > 4)
    return "???";
  else
    return off_24D5C2778[a1];
}

{
  if (a1 > 3)
    return "???";
  else
    return off_24D5C27A0[(char)a1];
}

{
  if (a1 > 6)
    return "???";
  else
    return off_24D5C27C0[a1];
}

{
  if (a1 > 0x11)
    return "???";
  else
    return off_24D5C27F8[a1];
}

const char *uim::asString(int a1)
{
  const char *result;

  result = "kUnknown";
  switch(a1)
  {
    case 0:
      return result;
    case 1:
      result = "kPowerDown";
      break;
    case 2:
      result = "kPollError";
      break;
    case 3:
      result = "kNoAtrReceived";
      break;
    case 4:
      result = "kVoltMismatch";
      break;
    case 5:
      result = "kParityError";
      break;
    case 6:
      result = "kUnknownPossiblyRemoved";
      break;
    case 7:
      result = "kTechnicalProblem";
      break;
    case 8:
      result = "kNullBytes";
      break;
    case 9:
      result = "kSapConnected";
      break;
    default:
      if (a1 == 64)
        result = "kRecovery";
      else
        result = "???";
      break;
  }
  return result;
}

uint64_t std::ostringstream::basic_ostringstream[abi:ne180100](uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  std::ios_base *v6;

  v2 = MEMORY[0x24BEDB870];
  v3 = MEMORY[0x24BEDB870] + 64;
  *(_QWORD *)(a1 + 112) = MEMORY[0x24BEDB870] + 64;
  v4 = *(_QWORD *)(MEMORY[0x24BEDB800] + 8);
  v5 = *(_QWORD *)(MEMORY[0x24BEDB800] + 16);
  *(_QWORD *)a1 = v4;
  *(_QWORD *)(a1 + *(_QWORD *)(v4 - 24)) = v5;
  v6 = (std::ios_base *)(a1 + *(_QWORD *)(*(_QWORD *)a1 - 24));
  std::ios_base::init(v6, (void *)(a1 + 8));
  v6[1].__vftable = 0;
  v6[1].__fmtflags_ = -1;
  *(_QWORD *)a1 = v2 + 24;
  *(_QWORD *)(a1 + 112) = v3;
  std::streambuf::basic_streambuf();
  *(_QWORD *)(a1 + 8) = MEMORY[0x24BEDB848] + 16;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_DWORD *)(a1 + 104) = 16;
  return a1;
}

void sub_2168ADC9C(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::ostream::~ostream();
  MEMORY[0x2199FEA70](v1);
  _Unwind_Resume(a1);
}

_QWORD *std::string::basic_string[abi:ne180100]<0>(_QWORD *a1, char *__s)
{
  size_t v4;
  size_t v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;

  v4 = strlen(__s);
  if (v4 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v5 = v4;
  if (v4 >= 0x17)
  {
    v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17)
      v7 = v4 | 7;
    v8 = v7 + 1;
    v6 = operator new(v7 + 1);
    a1[1] = v5;
    a1[2] = v8 | 0x8000000000000000;
    *a1 = v6;
  }
  else
  {
    *((_BYTE *)a1 + 23) = v4;
    v6 = a1;
    if (!v4)
      goto LABEL_9;
  }
  memmove(v6, __s, v5);
LABEL_9:
  *((_BYTE *)v6 + v5) = 0;
  return a1;
}

_QWORD *std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  const std::locale::facet *v10;
  uint64_t v11;
  _QWORD v13[2];
  std::locale v14;

  v13[0] = 0;
  v13[1] = 0;
  MEMORY[0x2199FE974](v13, a1);
  if (LOBYTE(v13[0]))
  {
    v6 = (uint64_t)a1 + *(_QWORD *)(*a1 - 24);
    v7 = *(_QWORD *)(v6 + 40);
    v8 = *(_DWORD *)(v6 + 8);
    v9 = *(_DWORD *)(v6 + 144);
    if (v9 == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)));
      v10 = std::locale::use_facet(&v14, MEMORY[0x24BEDB350]);
      v9 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 32);
      std::locale::~locale(&v14);
      *(_DWORD *)(v6 + 144) = v9;
    }
    if ((v8 & 0xB0) == 0x20)
      v11 = a2 + a3;
    else
      v11 = a2;
    if (!std::__pad_and_output[abi:ne180100]<char,std::char_traits<char>>(v7, a2, v11, a2 + a3, v6, (char)v9))
      std::ios_base::clear((std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24) + 32) | 5);
  }
  MEMORY[0x2199FE980](v13);
  return a1;
}

void sub_2168ADE80(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, std::locale a12)
{
  _QWORD *v12;

  MEMORY[0x2199FE980](&a10);
  __cxa_begin_catch(a1);
  std::ios_base::__set_badbit_and_consider_rethrow((std::ios_base *)((char *)v12 + *(_QWORD *)(*v12 - 24)));
  __cxa_end_catch();
  JUMPOUT(0x2168ADE60);
}

void sub_2168ADEC8(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t std::__pad_and_output[abi:ne180100]<char,std::char_traits<char>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int __c)
{
  uint64_t v6;
  uint64_t v11;
  int64_t v12;
  void **v13;
  uint64_t v14;
  uint64_t v15;
  void *__p[2];
  uint64_t v18;

  v6 = a1;
  if (a1)
  {
    v11 = *(_QWORD *)(a5 + 24);
    if (v11 <= a4 - a2)
      v12 = 0;
    else
      v12 = v11 - (a4 - a2);
    if (a3 - a2 >= 1 && (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 96))(a1) != a3 - a2)
      return 0;
    if (v12 >= 1)
    {
      __p[0] = 0;
      __p[1] = 0;
      v18 = 0;
      std::string::basic_string[abi:ne180100](__p, v12, __c);
      v13 = v18 >= 0 ? __p : (void **)__p[0];
      v14 = (*(uint64_t (**)(uint64_t, void **, int64_t))(*(_QWORD *)v6 + 96))(v6, v13, v12);
      if (SHIBYTE(v18) < 0)
        operator delete(__p[0]);
      if (v14 != v12)
        return 0;
    }
    v15 = a4 - a3;
    if (v15 < 1 || (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v6 + 96))(v6, a3, v15) == v15)
      *(_QWORD *)(a5 + 24) = 0;
    else
      return 0;
  }
  return v6;
}

void sub_2168AE004(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *std::string::basic_string[abi:ne180100](_QWORD *__b, size_t __len, int __c)
{
  void *v6;
  size_t v7;
  size_t v8;

  if (__len >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  if (__len >= 0x17)
  {
    v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17)
      v7 = __len | 7;
    v8 = v7 + 1;
    v6 = operator new(v7 + 1);
    __b[1] = __len;
    __b[2] = v8 | 0x8000000000000000;
    *__b = v6;
  }
  else
  {
    *((_BYTE *)__b + 23) = __len;
    v6 = __b;
    if (!__len)
      goto LABEL_9;
  }
  memset(v6, __c, __len);
LABEL_9:
  *((_BYTE *)v6 + __len) = 0;
  return __b;
}

uint64_t std::stringbuf::view[abi:ne180100](uint64_t a1)
{
  int v1;
  unint64_t v3;

  v1 = *(_DWORD *)(a1 + 96);
  if ((v1 & 0x10) != 0)
  {
    v3 = *(_QWORD *)(a1 + 48);
    if (*(_QWORD *)(a1 + 88) < v3)
      *(_QWORD *)(a1 + 88) = v3;
    return *(_QWORD *)(a1 + 40);
  }
  else if ((v1 & 8) != 0)
  {
    return *(_QWORD *)(a1 + 16);
  }
  else
  {
    return 0;
  }
}

uint64_t tlv::parseV<vs::tlv::ServiceClass>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168AE14C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168AE140);
}

uint64_t tlv::parseV<vs::tlv::SuppServiceStatus>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  const unsigned __int8 *v4;
  int v5;
  int v6;

  v3 = (unsigned __int8 *)*a1;
  v4 = (const unsigned __int8 *)(*a1 + a2);
  tlv::throwIfNotEnoughBytes(*a1, v4, 1uLL);
  v5 = *v3;
  tlv::throwIfNotEnoughBytes((unint64_t)(v3 + 1), v4, 1uLL);
  v6 = v3[1];
  *a1 = (unint64_t)(v3 + 2);
  return v5 | (v6 << 8);
}

void sub_2168AE1C4(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168AE1B0);
}

uint64_t vs::tlv::parseField(unint64_t a1, const unsigned __int8 *a2, uint64_t a3)
{
  std::string::value_type *v5;
  unint64_t v6;

  v5 = (std::string::value_type *)a1;
  tlv::throwIfNotEnoughBytes(a1, a2, 1uLL);
  *(_BYTE *)a3 = *v5;
  tlv::throwIfNotEnoughBytes((unint64_t)(v5 + 1), a2, 1uLL);
  *(_BYTE *)(a3 + 1) = v5[1];
  tlv::throwIfNotEnoughBytes((unint64_t)(v5 + 2), a2, 1uLL);
  v6 = v5[2];
  v5 += 3;
  tlv::throwIfNotEnoughBytes((unint64_t)v5, a2, v6);
  std::string::__assign_trivial[abi:ne180100]<unsigned char const*,unsigned char const*>((std::string *)(a3 + 8), v5, &v5[v6], v6);
  tlv::throwIfNotEnoughBytes((unint64_t)&v5[v6], a2, 1uLL);
  *(_BYTE *)(a3 + 32) = v5[v6];
  return (uint64_t)&v5[v6 + 1];
}

unint64_t tlv::parseV<vs::tlv::ServiceParams>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  unint64_t result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = vs::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = (unsigned __int8 *)result;
  return result;
}

void sub_2168AE340(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168AE330);
}

void sub_2168AE350(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::vector<vs::tlv::ServiceParam>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

uint64_t tlv::size<vs::tlv::CallBarringPassword>()
{
  return 16;
}

uint64_t *tlv::writeV<vs::tlv::CallBarringPassword>(uint64_t *result, uint64_t a2)
{
  uint64_t v2;

  v2 = *result;
  *(_BYTE *)v2 = *(_BYTE *)a2;
  *(_DWORD *)(v2 + 1) = *(_DWORD *)(a2 + 1);
  *(_DWORD *)(v2 + 5) = *(_DWORD *)(a2 + 5);
  *(_DWORD *)(v2 + 9) = *(_DWORD *)(a2 + 9);
  *result = v2 + 13;
  return result;
}

uint64_t tlv::parseV<vs::tlv::CnapResponse>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  const unsigned __int8 *v4;
  int v5;
  int v6;

  v3 = (unsigned __int8 *)*a1;
  v4 = (const unsigned __int8 *)(*a1 + a2);
  tlv::throwIfNotEnoughBytes(*a1, v4, 1uLL);
  v5 = *v3;
  tlv::throwIfNotEnoughBytes((unint64_t)(v3 + 1), v4, 1uLL);
  v6 = v3[1];
  *a1 = (unint64_t)(v3 + 2);
  return v5 | (v6 << 8);
}

void sub_2168AE404(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168AE3F0);
}

void std::vector<vs::tlv::ServiceParam>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<vs::tlv::ServiceParam>::__clear[abi:ne180100]((uint64_t *)v2);
    operator delete(**a1);
  }
}

void std::vector<vs::tlv::ServiceParam>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v2;
  uint64_t i;

  v2 = *a1;
  for (i = a1[1]; i != v2; i -= 40)
  {
    if (*(char *)(i - 9) < 0)
      operator delete(*(void **)(i - 32));
  }
  a1[1] = v2;
}

void std::vector<vs::tlv::ServiceParam>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  BOOL v5;
  unint64_t v6;
  uint64_t v7;

  v3 = a1[1];
  v4 = 0xCCCCCCCCCCCCCCCDLL * ((v3 - *a1) >> 3);
  v5 = a2 >= v4;
  v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    std::vector<vs::tlv::ServiceParam>::__append(a1, v6);
  }
  else if (!v5)
  {
    v7 = *a1 + 40 * a2;
    while (v3 != v7)
    {
      if (*(char *)(v3 - 9) < 0)
        operator delete(*(void **)(v3 - 32));
      v3 -= 40;
    }
    a1[1] = v7;
  }
}

void std::vector<vs::tlv::ServiceParam>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  size_t v13;
  size_t v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (0xCCCCCCCCCCCCCCCDLL * ((v6 - v7) >> 3) >= a2)
  {
    if (a2)
    {
      v13 = 40 * ((40 * a2 - 40) / 0x28) + 40;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = 0xCCCCCCCCCCCCCCCDLL * ((v7 - *a1) >> 3);
    v9 = v8 + a2;
    if (v8 + a2 > 0x666666666666666)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = 0xCCCCCCCCCCCCCCCDLL * ((v5 - *a1) >> 3);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x333333333333333)
      v11 = 0x666666666666666;
    else
      v11 = v9;
    v19 = v4;
    if (v11)
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<vs::tlv::ServiceParam>>(v4, v11);
    else
      v12 = 0;
    v15 = v12;
    v16 = &v12[40 * v8];
    v18 = &v12[40 * v11];
    v14 = 40 * ((40 * a2 - 40) / 0x28) + 40;
    bzero(v16, v14);
    v17 = &v16[v14];
    std::vector<vs::tlv::ServiceParam>::__swap_out_circular_buffer(a1, &v15);
    std::__split_buffer<vs::tlv::ServiceParam>::~__split_buffer((uint64_t)&v15);
  }
}

void sub_2168AE680(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<vs::tlv::ServiceParam>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<vs::tlv::ServiceParam>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<vs::tlv::ServiceParam>,std::reverse_iterator<vs::tlv::ServiceParam*>,std::reverse_iterator<vs::tlv::ServiceParam*>,std::reverse_iterator<vs::tlv::ServiceParam*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<vs::tlv::ServiceParam>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x666666666666667)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(40 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<vs::tlv::ServiceParam>,std::reverse_iterator<vs::tlv::ServiceParam*>,std::reverse_iterator<vs::tlv::ServiceParam*>,std::reverse_iterator<vs::tlv::ServiceParam*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  __int16 v8;
  __int128 v9;
  uint64_t v10;
  _QWORD v12[3];
  uint64_t v13;
  __int128 v14;
  __int128 v15;

  v7 = a7;
  *(_QWORD *)&v15 = a6;
  *((_QWORD *)&v15 + 1) = a7;
  v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  v13 = 0;
  if (a3 == a5)
  {
    v10 = a6;
  }
  else
  {
    do
    {
      v8 = *(_WORD *)(a3 - 40);
      a3 -= 40;
      *(_WORD *)(v7 - 40) = v8;
      v9 = *(_OWORD *)(a3 + 8);
      *(_QWORD *)(v7 - 16) = *(_QWORD *)(a3 + 24);
      *(_OWORD *)(v7 - 32) = v9;
      *(_QWORD *)(a3 + 16) = 0;
      *(_QWORD *)(a3 + 24) = 0;
      *(_QWORD *)(a3 + 8) = 0;
      *(_BYTE *)(v7 - 8) = *(_BYTE *)(a3 + 32);
      v7 = *((_QWORD *)&v15 + 1) - 40;
      *((_QWORD *)&v15 + 1) -= 40;
    }
    while (a3 != a5);
    v10 = v15;
  }
  LOBYTE(v13) = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<vs::tlv::ServiceParam>,std::reverse_iterator<vs::tlv::ServiceParam*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return v10;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<vs::tlv::ServiceParam>,std::reverse_iterator<vs::tlv::ServiceParam*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<vs::tlv::ServiceParam>,std::reverse_iterator<vs::tlv::ServiceParam*>>::operator()[abi:ne180100](a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<vs::tlv::ServiceParam>,std::reverse_iterator<vs::tlv::ServiceParam*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8);
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    if (*(char *)(v1 + 31) < 0)
      operator delete(*(void **)(v1 + 8));
    v1 += 40;
  }
}

uint64_t std::__split_buffer<vs::tlv::ServiceParam>::~__split_buffer(uint64_t a1)
{
  std::__split_buffer<vs::tlv::ServiceParam>::__destruct_at_end[abi:ne180100](a1, *(_QWORD *)(a1 + 8));
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::__split_buffer<vs::tlv::ServiceParam>::__destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v5;

  v2 = *(_QWORD *)(a1 + 16);
  if (v2 != a2)
  {
    do
    {
      v5 = v2 - 40;
      *(_QWORD *)(a1 + 16) = v2 - 40;
      if (*(char *)(v2 - 9) < 0)
      {
        operator delete(*(void **)(v2 - 32));
        v5 = *(_QWORD *)(a1 + 16);
      }
      v2 = v5;
    }
    while (v5 != a2);
  }
}

unint64_t wms::tlv::parseField(unint64_t a1, const unsigned __int8 *a2, uint64_t a3)
{
  tlv::throwIfNotEnoughBytes(a1, a2, 2uLL);
  *(_WORD *)a3 = *(_WORD *)a1;
  tlv::throwIfNotEnoughBytes(a1 + 2, a2, 2uLL);
  *(_WORD *)(a3 + 2) = *(_WORD *)(a1 + 2);
  tlv::throwIfNotEnoughBytes(a1 + 4, a2, 1uLL);
  *(_BYTE *)(a3 + 4) = *(_BYTE *)(a1 + 4);
  return a1 + 5;
}

{
  unint64_t v5;
  unint64_t v6;

  v5 = a1;
  tlv::throwIfNotEnoughBytes(a1, a2, 1uLL);
  *(_BYTE *)a3 = *(_BYTE *)v5;
  tlv::throwIfNotEnoughBytes(v5 + 1, a2, 2uLL);
  v6 = *(unsigned __int16 *)(v5 + 1);
  v5 += 3;
  tlv::throwIfNotEnoughBytes(v5, a2, v6);
  std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((_QWORD *)(a3 + 8), (char *)v5, (char *)(v5 + v6), v6);
  return v5 + v6;
}

{
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t result;

  tlv::throwIfNotEnoughBytes(a1, a2, 1uLL);
  *(_BYTE *)a3 = *(_BYTE *)a1;
  tlv::throwIfNotEnoughBytes(a1 + 1, a2, 2uLL);
  v6 = *(unsigned __int16 *)(a1 + 1);
  v7 = a1 + 3;
  std::vector<wms::tlv::BroadcastConfig3GPP>::resize(a3 + 8, v6);
  v8 = *(_QWORD *)(a3 + 8);
  v9 = *(_QWORD *)(a3 + 16);
  while (1)
  {
    result = v7;
    if (v8 == v9)
      break;
    v7 = wms::tlv::parseField(v7, a2, v8);
    v8 += 6;
  }
  return result;
}

uint64_t tlv::parseV<wms::tlv::Message_Mode>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168AE99C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168AE990);
}

uint64_t tlv::parseV<wms::tlv::MemoryStorageIdentification>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  const unsigned __int8 *v4;
  unsigned int v5;
  uint64_t v6;

  v3 = (unsigned __int8 *)*a1;
  v4 = (const unsigned __int8 *)(*a1 + a2);
  tlv::throwIfNotEnoughBytes(*a1, v4, 1uLL);
  v5 = *v3;
  tlv::throwIfNotEnoughBytes((unint64_t)(v3 + 1), v4, 4uLL);
  v6 = *(unsigned int *)(v3 + 1);
  *a1 = (unint64_t)(v3 + 5);
  return (v6 << 32) | v5;
}

void sub_2168AEA1C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168AEA04);
}

uint64_t tlv::size<wms::tlv::MemoryStorageIdentification>()
{
  return 8;
}

uint64_t *tlv::writeV<wms::tlv::MemoryStorageIdentification>(uint64_t *result, uint64_t a2)
{
  uint64_t v2;

  v2 = *result;
  *(_BYTE *)v2 = *(_BYTE *)a2;
  *(_DWORD *)(v2 + 1) = *(_DWORD *)(a2 + 4);
  *result = v2 + 5;
  return result;
}

uint64_t tlv::parseV<wms::tlv::ReadyStatus>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168AEA90(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168AEA84);
}

char *wms::tlv::parseField(unint64_t a1, const unsigned __int8 *a2, uint64_t a3)
{
  char *v5;
  __int16 v6;
  unint64_t v7;

  v5 = (char *)a1;
  tlv::throwIfNotEnoughBytes(a1, a2, 3uLL);
  v6 = *(_WORD *)v5;
  *(_BYTE *)(a3 + 2) = v5[2];
  *(_WORD *)a3 = v6;
  tlv::throwIfNotEnoughBytes((unint64_t)(v5 + 3), a2, 1uLL);
  v7 = v5[3];
  v5 += 4;
  tlv::throwIfNotEnoughBytes((unint64_t)v5, a2, v7);
  std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((_QWORD *)(a3 + 8), v5, &v5[v7], v7);
  return &v5[v7];
}

char *tlv::parseV<wms::tlv::SMSCInfo>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  char *result;

  *a3 = 0u;
  a3[1] = 0u;
  result = wms::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), (uint64_t)a3);
  *a1 = (unint64_t)result;
  return result;
}

void sub_2168AEB68(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168AEB5CLL);
}

void sub_2168AEB78(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)(v1 + 8);
  if (v3)
  {
    *(_QWORD *)(v1 + 16) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

unsigned __int8 *wms::tlv::parseField(unsigned __int8 *a1, const unsigned __int8 *a2, uint64_t a3)
{
  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  *(_DWORD *)a3 = *a1;
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 1), a2, 1uLL);
  *(_BYTE *)(a3 + 4) = a1[1] != 0;
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 2), a2, 1uLL);
  *(_BYTE *)(a3 + 5) = a1[2];
  return a1 + 3;
}

unsigned __int8 *wms::tlv::parseField(unsigned __int8 *a1, const unsigned __int8 *a2, uint64_t *a3)
{
  unsigned __int8 *v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  unsigned __int8 *result;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  v7 = *a1;
  v6 = a1 + 1;
  std::vector<wms::tlv::MsgTypeWaitingInfo>::resize((uint64_t)a3, v7);
  v8 = *a3;
  v9 = a3[1];
  while (1)
  {
    result = v6;
    if (v8 == v9)
      break;
    v6 = wms::tlv::parseField(v6, a2, v8);
    v8 += 8;
  }
  return result;
}

unsigned __int8 *tlv::parseV<wms::tlv::MsgWaitingInfo>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  unsigned __int8 *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = wms::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = result;
  return result;
}

void sub_2168AECB0(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168AECA4);
}

void sub_2168AECC0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

unint64_t tlv::size<wms::tlv::MsgWaitingInfo>(_QWORD *a1)
{
  uint64_t v1;

  v1 = a1[1];
  if (*a1 == v1)
    return 4;
  else
    return 3 * ((unint64_t)(v1 - *a1 - 8) >> 3) + 7;
}

_BYTE **tlv::writeV<wms::tlv::MsgWaitingInfo>(_BYTE **result, _DWORD *a2)
{
  _BYTE *v2;
  _BYTE *v3;
  uint64_t v4;
  uint64_t v5;
  _BYTE *v6;

  v2 = *result;
  *v2 = (a2[2] - *a2) >> 3;
  v3 = v2 + 1;
  v4 = *(_QWORD *)a2;
  v5 = *((_QWORD *)a2 + 1);
  if (*(_QWORD *)a2 == v5)
  {
    v6 = v3;
  }
  else
  {
    do
    {
      *v3 = *(_DWORD *)v4;
      v3[1] = *(_BYTE *)(v4 + 4);
      v6 = v3 + 3;
      v3[2] = *(_BYTE *)(v4 + 5);
      v4 += 8;
      v3 += 3;
    }
    while (v4 != v5);
  }
  *result = v6;
  return result;
}

uint64_t tlv::parseV<wms::tlv::TransportLayerRegistrationInfo>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168AEDA4(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168AED98);
}

unsigned __int8 *wms::tlv::parseField(unint64_t a1, const unsigned __int8 *a2, uint64_t a3)
{
  unsigned __int8 *v5;
  unint64_t v6;

  v5 = (unsigned __int8 *)a1;
  tlv::throwIfNotEnoughBytes(a1, a2, 1uLL);
  *(_DWORD *)a3 = *v5;
  tlv::throwIfNotEnoughBytes((unint64_t)(v5 + 1), a2, 4uLL);
  *(_DWORD *)(a3 + 4) = *(_DWORD *)(v5 + 1);
  tlv::throwIfNotEnoughBytes((unint64_t)(v5 + 5), a2, 1uLL);
  *(_BYTE *)(a3 + 8) = v5[5];
  tlv::throwIfNotEnoughBytes((unint64_t)(v5 + 6), a2, 2uLL);
  v6 = *((unsigned __int16 *)v5 + 3);
  v5 += 8;
  tlv::throwIfNotEnoughBytes((unint64_t)v5, a2, v6);
  std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((_QWORD *)(a3 + 16), (char *)v5, (char *)&v5[v6], v6);
  return &v5[v6];
}

{
  char *v5;
  unint64_t v6;

  v5 = (char *)a1;
  tlv::throwIfNotEnoughBytes(a1, a2, 1uLL);
  *(_DWORD *)a3 = *v5;
  tlv::throwIfNotEnoughBytes((unint64_t)(v5 + 1), a2, 1uLL);
  *(_BYTE *)(a3 + 4) = v5[1];
  tlv::throwIfNotEnoughBytes((unint64_t)(v5 + 2), a2, 2uLL);
  v6 = *((unsigned __int16 *)v5 + 1);
  v5 += 4;
  tlv::throwIfNotEnoughBytes((unint64_t)v5, a2, v6);
  std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((_QWORD *)(a3 + 8), v5, &v5[v6], v6);
  return (unsigned __int8 *)&v5[v6];
}

unsigned __int8 *tlv::parseV<wms::tlv::TransferRouteMTMessage>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  unsigned __int8 *result;

  *(_QWORD *)(a3 + 32) = 0;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  result = wms::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), a3);
  *a1 = (unint64_t)result;
  return result;
}

void sub_2168AEEAC(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168AEEA0);
}

void sub_2168AEEBC(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)(v1 + 16);
  if (v3)
  {
    *(_QWORD *)(v1 + 24) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

unint64_t tlv::parseV<wms::tlv::ETWSMessage>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  unint64_t result;

  *a3 = 0u;
  a3[1] = 0u;
  result = wms::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), (uint64_t)a3);
  *a1 = result;
  return result;
}

void sub_2168AEF94(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168AEF88);
}

void sub_2168AEFA4(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)(v1 + 8);
  if (v3)
  {
    *(_QWORD *)(v1 + 16) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

BOOL tlv::parseV<wms::tlv::MTSMSOnIMS>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  _BOOL8 result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3 != 0;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168AF000(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168AEFF4);
}

char *tlv::parseV<wms::tlv::WarningArea>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  char *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = p2p::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), a3);
  *a1 = (unint64_t)result;
  return result;
}

void sub_2168AF050(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168AF044);
}

void sub_2168AF060(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t tlv::size<wms::tlv::RawSend>(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8) + 6;
}

void *tlv::writeV<wms::tlv::RawSend>(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  void *result;

  v4 = *a1;
  *(_BYTE *)v4 = *(_BYTE *)a2;
  *(_WORD *)(v4 + 1) = *(_WORD *)(a2 + 16) - *(_DWORD *)(a2 + 8);
  v5 = v4 + 3;
  result = memcpy((void *)(v4 + 3), *(const void **)(a2 + 8), *(_QWORD *)(a2 + 16) - *(_QWORD *)(a2 + 8));
  *a1 = v5 + *(_QWORD *)(a2 + 16) - *(_QWORD *)(a2 + 8);
  return result;
}

_BYTE **tlv::writeV<wms::tlv::ForceDC>(_BYTE **result, uint64_t a2)
{
  _BYTE *v2;

  v2 = *result;
  *v2 = *(_BYTE *)a2;
  v2[1] = *(_DWORD *)(a2 + 4);
  *result = v2 + 2;
  return result;
}

uint64_t tlv::parseV<wms::tlv::MessageID>(unint64_t *a1, int a2)
{
  unsigned __int16 *v3;
  uint64_t result;

  v3 = (unsigned __int16 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 2uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168AF150(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168AF144);
}

uint64_t tlv::parseV<wms::tlv::CauseCode>(unint64_t *a1, int a2)
{
  unsigned __int16 *v3;
  uint64_t result;

  v3 = (unsigned __int16 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 2uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168AF19C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168AF190);
}

uint64_t tlv::parseV<wms::tlv::ErrorClass>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168AF1E8(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168AF1DCLL);
}

uint64_t tlv::parseV<wms::tlv::GWCauseInfo>(unint64_t *a1, int a2)
{
  unsigned __int16 *v3;
  const unsigned __int8 *v4;
  unsigned int v5;
  int v6;

  v3 = (unsigned __int16 *)*a1;
  v4 = (const unsigned __int8 *)(*a1 + a2);
  tlv::throwIfNotEnoughBytes(*a1, v4, 2uLL);
  v5 = *v3;
  tlv::throwIfNotEnoughBytes((unint64_t)(v3 + 1), v4, 1uLL);
  v6 = *((unsigned __int8 *)v3 + 2);
  *a1 = (unint64_t)v3 + 3;
  return (v6 << 16) | v5;
}

void sub_2168AF264(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168AF250);
}

BOOL tlv::parseV<wms::tlv::FailureType>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  _BOOL8 result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3 != 0;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168AF2B8(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168AF2ACLL);
}

unsigned __int8 *tlv::parseV<wms::tlv::RawMessage>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  unsigned __int8 *result;

  *a3 = 0u;
  a3[1] = 0u;
  result = wms::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), (uint64_t)a3);
  *a1 = (unint64_t)result;
  return result;
}

void sub_2168AF3A4(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168AF398);
}

void sub_2168AF3B4(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)(v1 + 8);
  if (v3)
  {
    *(_QWORD *)(v1 + 16) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t tlv::size<wms::tlv::MessageTag>()
{
  return 9;
}

uint64_t *tlv::writeV<wms::tlv::MessageTag>(uint64_t *result, uint64_t a2)
{
  uint64_t v2;

  v2 = *result;
  *(_BYTE *)v2 = *(_BYTE *)a2;
  *(_DWORD *)(v2 + 1) = *(_DWORD *)(a2 + 4);
  *(_BYTE *)(v2 + 5) = *(_DWORD *)(a2 + 8);
  *result = v2 + 6;
  return result;
}

unint64_t wms::tlv::parseField(unsigned int *a1, const unsigned __int8 *a2, _QWORD *a3)
{
  unint64_t v6;
  unsigned int v7;
  _DWORD *v8;
  _DWORD *v9;
  int v10;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 4uLL);
  v7 = *a1;
  v6 = (unint64_t)(a1 + 1);
  std::vector<wds::tlv::Ipv4AddrInfo>::resize((uint64_t)a3, v7);
  v9 = (_DWORD *)*a3;
  v8 = (_DWORD *)a3[1];
  while (v9 != v8)
  {
    tlv::throwIfNotEnoughBytes(v6, a2, 4uLL);
    *v9 = *(_DWORD *)v6;
    tlv::throwIfNotEnoughBytes(v6 + 4, a2, 1uLL);
    v10 = *(unsigned __int8 *)(v6 + 4);
    v6 += 5;
    v9[1] = v10;
    v9 += 2;
  }
  return v6;
}

unint64_t tlv::parseV<wms::tlv::MessageList>@<X0>(unsigned int **a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  unint64_t result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = wms::tlv::parseField(*a1, (const unsigned __int8 *)*a1 + a2, a3);
  *a1 = (unsigned int *)result;
  return result;
}

void sub_2168AF4C8(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168AF4BCLL);
}

void sub_2168AF4D8(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_BYTE *wms::tlv::writeField(_WORD *a1, _DWORD *a2)
{
  _BYTE *v2;
  _DWORD *v3;
  _DWORD *v4;
  _BYTE *v5;

  *a1 = (a2[2] - *a2) >> 4;
  v2 = a1 + 1;
  v3 = *(_DWORD **)a2;
  v4 = (_DWORD *)*((_QWORD *)a2 + 1);
  if (*(_DWORD **)a2 == v4)
    return v2;
  do
  {
    *v2 = *v3;
    v2[1] = v3[1];
    v2[2] = v3[2];
    v5 = v2 + 4;
    v2[3] = v3[3];
    v3 += 4;
    v2 += 4;
  }
  while (v3 != v4);
  return v5;
}

unint64_t tlv::size<wms::tlv::Routes>(_QWORD *a1)
{
  uint64_t v1;

  v1 = a1[1];
  if (*a1 == v1)
    return 5;
  else
    return (((unint64_t)(v1 - *a1 - 16) >> 2) & 0x3FFFFFFFFFFFFFFCLL) + 9;
}

_BYTE *tlv::writeV<wms::tlv::Routes>(_WORD **a1, _DWORD *a2)
{
  _BYTE *result;

  result = wms::tlv::writeField(*a1, a2);
  *a1 = result;
  return result;
}

uint64_t *tlv::writeV<wms::tlv::ACKInfo>(uint64_t *result, uint64_t a2)
{
  uint64_t v2;

  v2 = *result;
  *(_DWORD *)v2 = *(_DWORD *)a2;
  *(_BYTE *)(v2 + 4) = *(_DWORD *)(a2 + 4);
  *(_BYTE *)(v2 + 5) = *(_BYTE *)(a2 + 8);
  *result = v2 + 6;
  return result;
}

_BYTE **tlv::writeV<wms::tlv::_3GPP2Info>(_BYTE **result, _DWORD *a2)
{
  _BYTE *v2;

  v2 = *result;
  *v2 = *a2;
  v2[1] = a2[1];
  *result = v2 + 2;
  return result;
}

uint64_t tlv::parseV<wms::tlv::NWAckResp>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168AF62C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168AF620);
}

unint64_t tlv::size<wms::tlv::BroadcastConfigInfo3GPP_Req>(_QWORD *a1)
{
  uint64_t v1;

  v1 = a1[1];
  if (*a1 == v1)
    return 5;
  else
    return 5 * ((v1 - *a1 - 6) / 6uLL) + 10;
}

_WORD **tlv::writeV<wms::tlv::BroadcastConfigInfo3GPP_Req>(_WORD **result, _DWORD *a2)
{
  _WORD *v2;
  _WORD *v3;
  uint64_t v4;
  uint64_t v5;
  _WORD *v6;

  v2 = *result;
  *v2 = -21845 * ((a2[2] - *a2) >> 1);
  v3 = v2 + 1;
  v4 = *(_QWORD *)a2;
  v5 = *((_QWORD *)a2 + 1);
  if (*(_QWORD *)a2 == v5)
  {
    v6 = v3;
  }
  else
  {
    do
    {
      *v3 = *(_WORD *)v4;
      v3[1] = *(_WORD *)(v4 + 2);
      v6 = (_WORD *)((char *)v3 + 5);
      *((_BYTE *)v3 + 4) = *(_BYTE *)(v4 + 4);
      v4 += 6;
      v3 = (_WORD *)((char *)v3 + 5);
    }
    while (v4 != v5);
  }
  *result = v6;
  return result;
}

unint64_t tlv::parseV<wms::tlv::BroadcastConfigInfo3GPP_Resp>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  unint64_t result;

  *a3 = 0u;
  a3[1] = 0u;
  result = wms::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), (uint64_t)a3);
  *a1 = result;
  return result;
}

void sub_2168AF7A8(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168AF79CLL);
}

void sub_2168AF7B8(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)(v1 + 8);
  if (v3)
  {
    *(_QWORD *)(v1 + 16) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

unint64_t tlv::parseV<wms::tlv::BroadcastConfigInfo3GPP2_Resp>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  unint64_t result;

  *a3 = 0u;
  a3[1] = 0u;
  result = wms::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), (uint64_t)a3);
  *a1 = result;
  return result;
}

void sub_2168AF810(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168AF804);
}

void sub_2168AF820(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)(v1 + 8);
  if (v3)
  {
    *(_QWORD *)(v1 + 16) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t tlv::parseV<wms::tlv::IndicationRegistered>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168AF874(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168AF868);
}

void std::vector<wms::tlv::MsgTypeWaitingInfo>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;

  v2 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 3;
  if (a2 <= v2)
  {
    if (a2 < v2)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 8 * a2;
  }
  else
  {
    std::vector<wms::tlv::MsgTypeWaitingInfo>::__append((char **)a1, a2 - v2);
  }
}

void std::vector<wms::tlv::MsgTypeWaitingInfo>::__append(char **a1, unint64_t a2)
{
  uint64_t v4;
  char *v5;
  char *v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  int v19;
  __int16 v20;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 3)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 8 * a2);
      v7 += 8 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = v7 - *a1;
    v9 = a2 + (v8 >> 3);
    if (v9 >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 3;
    v11 = v5 - *a1;
    if (v11 >> 2 > v9)
      v9 = v11 >> 2;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v9;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>(v4, v12);
    else
      v13 = 0;
    v14 = &v13[8 * v10];
    v15 = &v13[8 * v12];
    bzero(v14, 8 * a2);
    v16 = &v14[8 * a2];
    v18 = *a1;
    v17 = a1[1];
    if (v17 != *a1)
    {
      do
      {
        v19 = *((_DWORD *)v17 - 2);
        v17 -= 8;
        v20 = *((_WORD *)v17 + 2);
        *((_DWORD *)v14 - 2) = v19;
        v14 -= 8;
        *((_WORD *)v14 + 2) = v20;
      }
      while (v17 != v18);
      v17 = *a1;
    }
    *a1 = v14;
    a1[1] = v16;
    a1[2] = v15;
    if (v17)
      operator delete(v17);
  }
}

void std::vector<wms::tlv::BroadcastConfig3GPP>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;

  v2 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 1);
  v3 = a2 >= v2;
  v4 = a2 - v2;
  if (v4 != 0 && v3)
  {
    std::vector<wms::tlv::BroadcastConfig3GPP>::__append((char **)a1, v4);
  }
  else if (!v3)
  {
    *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 6 * a2;
  }
}

void std::vector<wms::tlv::BroadcastConfig3GPP>::__append(char **a1, unint64_t a2)
{
  uint64_t v4;
  char *v5;
  char *v6;
  char *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  size_t v13;
  char *v14;
  char *v15;
  size_t v16;
  char *v17;
  char *v18;
  char *v19;
  int v20;
  char v21;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - v7) >> 1) >= a2)
  {
    if (a2)
    {
      v13 = 6 * ((6 * a2 - 6) / 6) + 6;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = 0xAAAAAAAAAAAAAAABLL * ((v7 - *a1) >> 1);
    v9 = v8 + a2;
    if (v8 + a2 > 0x2AAAAAAAAAAAAAAALL)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *a1) >> 1);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x1555555555555555)
      v11 = 0x2AAAAAAAAAAAAAAALL;
    else
      v11 = v9;
    if (v11)
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wms::tlv::BroadcastConfig3GPP>>(v4, v11);
    else
      v12 = 0;
    v14 = &v12[6 * v8];
    v15 = &v12[6 * v11];
    v16 = 6 * ((6 * a2 - 6) / 6) + 6;
    bzero(v14, v16);
    v17 = &v14[v16];
    v19 = *a1;
    v18 = a1[1];
    if (v18 != *a1)
    {
      do
      {
        v20 = *(_DWORD *)(v18 - 6);
        v18 -= 6;
        v21 = v18[4];
        *(_DWORD *)(v14 - 6) = v20;
        v14 -= 6;
        v14[4] = v21;
      }
      while (v18 != v19);
      v18 = *a1;
    }
    *a1 = v14;
    a1[1] = v17;
    a1[2] = v15;
    if (v18)
      operator delete(v18);
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<wms::tlv::BroadcastConfig3GPP>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x2AAAAAAAAAAAAAABLL)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(6 * a2);
}

uint64_t tlv::size<at::tlv::CommandResponse>(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8) + 11;
}

void *tlv::writeV<at::tlv::CommandResponse>(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  void *result;

  v4 = *a1;
  *(_DWORD *)v4 = *(_DWORD *)a2;
  *(_BYTE *)(v4 + 4) = *(_BYTE *)(a2 + 4);
  *(_BYTE *)(v4 + 5) = *(_BYTE *)(a2 + 5);
  *(_WORD *)(v4 + 6) = *(_WORD *)(a2 + 16) - *(_DWORD *)(a2 + 8);
  v5 = v4 + 8;
  result = memcpy((void *)(v4 + 8), *(const void **)(a2 + 8), *(_QWORD *)(a2 + 16) - *(_QWORD *)(a2 + 8));
  *a1 = v5 + *(_QWORD *)(a2 + 16) - *(_QWORD *)(a2 + 8);
  return result;
}

_BYTE *at::tlv::writeField(_BYTE *a1, _DWORD *a2)
{
  _BYTE *result;
  uint64_t v3;
  uint64_t v4;
  _BYTE *v5;

  *a1 = (a2[2] - *a2) >> 5;
  result = a1 + 1;
  v3 = *(_QWORD *)a2;
  v4 = *((_QWORD *)a2 + 1);
  while (v3 != v4)
  {
    *result = *(_BYTE *)v3;
    v5 = result + 2;
    result[1] = *(_DWORD *)(v3 + 16) - *(_DWORD *)(v3 + 8);
    memcpy(result + 2, *(const void **)(v3 + 8), *(_QWORD *)(v3 + 16) - *(_QWORD *)(v3 + 8));
    result = &v5[*(_QWORD *)(v3 + 16) - *(_QWORD *)(v3 + 8)];
    v3 += 32;
  }
  return result;
}

uint64_t tlv::size<at::tlv::DesiredCommands>(uint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v1 = *a1;
  v2 = a1[1];
  if (*a1 == v2)
    return 4;
  v3 = 0;
  do
  {
    v3 = v3 + *(_QWORD *)(v1 + 16) - *(_QWORD *)(v1 + 8) + 2;
    v1 += 32;
  }
  while (v1 != v2);
  return v3 + 4;
}

_BYTE *tlv::writeV<at::tlv::DesiredCommands>(_BYTE **a1, _DWORD *a2)
{
  _BYTE *result;

  result = at::tlv::writeField(*a1, a2);
  *a1 = result;
  return result;
}

unint64_t at::tlv::parseField(unint64_t a1, const unsigned __int8 *a2, uint64_t a3)
{
  unint64_t v5;
  unint64_t v6;

  v5 = a1;
  tlv::throwIfNotEnoughBytes(a1, a2, 4uLL);
  *(_DWORD *)a3 = *(_DWORD *)v5;
  tlv::throwIfNotEnoughBytes(v5 + 4, a2, 4uLL);
  *(_DWORD *)(a3 + 4) = *(_DWORD *)(v5 + 4);
  tlv::throwIfNotEnoughBytes(v5 + 8, a2, 1uLL);
  v6 = *(unsigned __int8 *)(v5 + 8);
  v5 += 9;
  tlv::throwIfNotEnoughBytes(v5, a2, v6);
  std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((_QWORD *)(a3 + 8), (char *)v5, (char *)(v5 + v6), v6);
  return v5 + v6;
}

unint64_t tlv::parseV<at::tlv::Command>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  unint64_t result;

  *a3 = 0u;
  a3[1] = 0u;
  result = at::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), (uint64_t)a3);
  *a1 = result;
  return result;
}

void sub_2168AFDFC(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168AFDF0);
}

void sub_2168AFE0C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)(v1 + 8);
  if (v3)
  {
    *(_QWORD *)(v1 + 16) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *tlv::parseV<at::tlv::Token>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  char *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = wds::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), a3);
  *a1 = (unint64_t)result;
  return result;
}

void sub_2168AFE64(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168AFE58);
}

void sub_2168AFE74(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<at::tlv::CommandCallback>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<at::tlv::CommandCallback>::__clear[abi:ne180100]((uint64_t *)v2);
    operator delete(**a1);
  }
}

void std::vector<at::tlv::CommandCallback>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v2;
  uint64_t i;
  void *v4;

  v2 = *a1;
  for (i = a1[1]; i != v2; i -= 32)
  {
    v4 = *(void **)(i - 24);
    if (v4)
    {
      *(_QWORD *)(i - 16) = v4;
      operator delete(v4);
    }
  }
  a1[1] = v2;
}

uint64_t std::vector<at::tlv::CommandCallback>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<at::tlv::CommandCallback>,std::reverse_iterator<at::tlv::CommandCallback*>,std::reverse_iterator<at::tlv::CommandCallback*>,std::reverse_iterator<at::tlv::CommandCallback*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<at::tlv::CommandCallback>,std::reverse_iterator<at::tlv::CommandCallback*>,std::reverse_iterator<at::tlv::CommandCallback*>,std::reverse_iterator<at::tlv::CommandCallback*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  char v8;
  uint64_t v9;
  _QWORD v11[3];
  uint64_t v12;
  __int128 v13;
  __int128 v14;

  v7 = a7;
  *(_QWORD *)&v14 = a6;
  *((_QWORD *)&v14 + 1) = a7;
  v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  v12 = 0;
  if (a3 == a5)
  {
    v9 = a6;
  }
  else
  {
    do
    {
      v8 = *(_BYTE *)(a3 - 32);
      a3 -= 32;
      *(_BYTE *)(v7 - 32) = v8;
      *(_QWORD *)(v7 - 16) = 0;
      *(_QWORD *)(v7 - 8) = 0;
      *(_QWORD *)(v7 - 24) = 0;
      *(_OWORD *)(v7 - 24) = *(_OWORD *)(a3 + 8);
      *(_QWORD *)(v7 - 8) = *(_QWORD *)(a3 + 24);
      *(_QWORD *)(a3 + 8) = 0;
      *(_QWORD *)(a3 + 16) = 0;
      *(_QWORD *)(a3 + 24) = 0;
      v7 = *((_QWORD *)&v14 + 1) - 32;
      *((_QWORD *)&v14 + 1) -= 32;
    }
    while (a3 != a5);
    v9 = v14;
  }
  LOBYTE(v12) = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<at::tlv::CommandCallback>,std::reverse_iterator<at::tlv::CommandCallback*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v11);
  return v9;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<at::tlv::CommandCallback>,std::reverse_iterator<at::tlv::CommandCallback*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<at::tlv::CommandCallback>,std::reverse_iterator<at::tlv::CommandCallback*>>::operator()[abi:ne180100](a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<at::tlv::CommandCallback>,std::reverse_iterator<at::tlv::CommandCallback*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  void *v3;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8);
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    v3 = *(void **)(v1 + 8);
    if (v3)
    {
      *(_QWORD *)(v1 + 16) = v3;
      operator delete(v3);
    }
    v1 += 32;
  }
}

uint64_t std::__split_buffer<at::tlv::CommandCallback>::~__split_buffer(uint64_t a1)
{
  std::__split_buffer<at::tlv::CommandCallback>::__destruct_at_end[abi:ne180100](a1, *(_QWORD *)(a1 + 8));
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::__split_buffer<at::tlv::CommandCallback>::__destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  void *v5;

  v2 = *(_QWORD *)(a1 + 16);
  while (v2 != a2)
  {
    *(_QWORD *)(a1 + 16) = v2 - 32;
    v5 = *(void **)(v2 - 24);
    if (v5)
    {
      *(_QWORD *)(v2 - 16) = v5;
      operator delete(v5);
      v2 = *(_QWORD *)(a1 + 16);
    }
    else
    {
      v2 -= 32;
    }
  }
}

const char *bsp::asString(unsigned int a1)
{
  if (a1 > 7)
    return "qmi file transfer result unknown";
  else
    return off_24D5C2888[a1];
}

{
  if (a1 > 4)
    return "???";
  else
    return off_24D5C2928[a1];
}

{
  if (a1 > 3)
    return "???";
  else
    return off_24D5C2950[a1];
}

const char *bsp::asString(int a1)
{
  if ((a1 + 1) > 0xB)
    return "qmi file type result unknown";
  else
    return off_24D5C28C8[a1 + 1];
}

const char *wds::asString(int a1)
{
  const char *v1;

  v1 = "UnknownValue";
  if (a1 == 1)
    v1 = "kProfileType3GPP2";
  if (a1)
    return v1;
  else
    return "kProfileType3GPP";
}

{
  const char *v1;

  v1 = "UnknownValue";
  if (a1 == 1)
    v1 = "kVoLTE";
  if (a1)
    return v1;
  else
    return "kDefault";
}

uint64_t wds::apply(const std::string *a1)
{
  if (!std::string::compare(a1, "CHAP"))
    return 2;
  else
    return 1;
}

const char *wds::asString(unsigned int a1)
{
  if (a1 > 9)
    return "Unknown";
  else
    return off_24D5C2970[(char)a1];
}

{
  if (a1 > 2)
    return "UnknownValue";
  else
    return off_24D5C29C0[(char)a1];
}

{
  if (a1 > 4)
    return "UnknownValue";
  else
    return off_24D5C29D8[a1];
}

{
  if (a1 > 7)
    return "UnknownValue";
  else
    return off_24D5C2A00[a1];
}

_QWORD *wds::asString@<X0>(int a1@<W0>, _QWORD *a2@<X8>)
{
  char *v3;
  _OWORD v5[4];
  void *__p[2];
  __int128 v7;
  __int128 v8;
  _OWORD v9[9];
  uint64_t v10;

  switch(a1)
  {
    case '@':
      v3 = "MIP_FA_ERR_REASON_UNSPECIFIED";
      return std::string::basic_string[abi:ne180100]<0>(a2, v3);
    case 'A':
      v3 = "MIP_FA_ERR_ADMINISTRATIVELY_PROHIBITED";
      return std::string::basic_string[abi:ne180100]<0>(a2, v3);
    case 'B':
      v3 = "MIP_FA_ERR_INSUFFICIENT_RESOURCES";
      return std::string::basic_string[abi:ne180100]<0>(a2, v3);
    case 'C':
      v3 = "MIP_FA_ERR_MOBILE_NODE_AUTHENTICATION_FAILURE";
      return std::string::basic_string[abi:ne180100]<0>(a2, v3);
    case 'D':
      v3 = "MIP_FA_ERR_HA_AUTHENTICATION_FAILURE";
      return std::string::basic_string[abi:ne180100]<0>(a2, v3);
    case 'E':
      v3 = "MIP_FA_ERR_REQUESTED_LIFETIME_TOO_LONG";
      return std::string::basic_string[abi:ne180100]<0>(a2, v3);
    case 'F':
      v3 = "MIP_FA_ERR_MALFORMED_REQUEST";
      return std::string::basic_string[abi:ne180100]<0>(a2, v3);
    case 'G':
      v3 = "MIP_FA_ERR_MALFORMED_REPLY";
      return std::string::basic_string[abi:ne180100]<0>(a2, v3);
    case 'H':
      v3 = "MIP_FA_ERR_ENCAPSULATION_UNAVAILABLE";
      return std::string::basic_string[abi:ne180100]<0>(a2, v3);
    case 'I':
      v3 = "MIP_FA_ERR_VJHC_UNAVAILABLE";
      return std::string::basic_string[abi:ne180100]<0>(a2, v3);
    case 'J':
      v3 = "MIP_FA_ERR_REVERSE_TUNNEL_UNAVAILABLE";
      return std::string::basic_string[abi:ne180100]<0>(a2, v3);
    case 'K':
      v3 = "MIP_FA_ERR_REVERSE_TUNNEL_IS_MANDATORY_AND_T_BIT_NOT_SET";
      return std::string::basic_string[abi:ne180100]<0>(a2, v3);
    case 'L':
    case 'M':
    case 'N':
    case 'P':
    case 'Q':
    case 'R':
    case 'S':
    case 'T':
    case 'U':
    case 'V':
    case 'W':
    case 'X':
    case 'Y':
    case 'Z':
    case '[':
    case '\\':
    case ']':
    case '^':
    case '_':
    case 'd':
    case 'e':
    case 'f':
    case 'g':
LABEL_7:
      v10 = 0;
      v8 = 0u;
      memset(v9, 0, sizeof(v9));
      *(_OWORD *)__p = 0u;
      v7 = 0u;
      memset(v5, 0, sizeof(v5));
      std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v5);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)"Unknown: ", 9);
      std::ostream::operator<<();
      std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v5 + 8, a2);
      *(_QWORD *)&v5[0] = *MEMORY[0x24BEDB800];
      *(_QWORD *)((char *)v5 + *(_QWORD *)(*(_QWORD *)&v5[0] - 24)) = *(_QWORD *)(MEMORY[0x24BEDB800] + 24);
      *((_QWORD *)&v5[0] + 1) = MEMORY[0x24BEDB848] + 16;
      if (SHIBYTE(v7) < 0)
        operator delete(__p[1]);
      std::streambuf::~streambuf();
      std::ostream::~ostream();
      return (_QWORD *)MEMORY[0x2199FEA70](v9);
    case 'O':
      v3 = "MIP_FA_ERR_DELIVERY_STYLE_NOT_SUPPORTED";
      return std::string::basic_string[abi:ne180100]<0>(a2, v3);
    case 'a':
      v3 = "MIP_FA_ERR_MISSING_NAI";
      return std::string::basic_string[abi:ne180100]<0>(a2, v3);
    case 'b':
      v3 = "MIP_FA_ERR_MISSING_HA";
      return std::string::basic_string[abi:ne180100]<0>(a2, v3);
    case 'c':
      v3 = "MIP_FA_ERR_MISSING_HOME_ADDR";
      return std::string::basic_string[abi:ne180100]<0>(a2, v3);
    case 'h':
      v3 = "MIP_FA_ERR_UNKNOWN_CHALLENGE";
      return std::string::basic_string[abi:ne180100]<0>(a2, v3);
    case 'i':
      v3 = "MIP_FA_ERR_MISSING_CHALLENGE";
      return std::string::basic_string[abi:ne180100]<0>(a2, v3);
    case 'j':
      v3 = "MIP_FA_ERR_STALE_CHALLENGE";
      return std::string::basic_string[abi:ne180100]<0>(a2, v3);
    default:
      switch(a1)
      {
        case 128:
          v3 = "MIP_HA_ERR_REASON_UNSPECIFIED";
          return std::string::basic_string[abi:ne180100]<0>(a2, v3);
        case 129:
          v3 = "MIP_HA_ERR_ADMINISTRATIVELY_PROHIBITED";
          return std::string::basic_string[abi:ne180100]<0>(a2, v3);
        case 130:
          v3 = "MIP_HA_ERR_INSUFFICIENT_RESOURCES";
          return std::string::basic_string[abi:ne180100]<0>(a2, v3);
        case 131:
          v3 = "MIP_HA_ERR_MOBILE_NODE_AUTHENTICATION_FAILURE";
          return std::string::basic_string[abi:ne180100]<0>(a2, v3);
        case 132:
          v3 = "MIP_HA_ERR_FA_AUTHENTICATION_FAILURE";
          return std::string::basic_string[abi:ne180100]<0>(a2, v3);
        case 133:
          v3 = "MIP_HA_ERR_REGISTRATION_ID_MISMATCH";
          return std::string::basic_string[abi:ne180100]<0>(a2, v3);
        case 134:
          v3 = "MIP_HA_ERR_MALFORMED_REQUEST";
          return std::string::basic_string[abi:ne180100]<0>(a2, v3);
        case 135:
          goto LABEL_7;
        case 136:
          v3 = "MIP_HA_ERR_UNKNOWN_HA_ADDR";
          return std::string::basic_string[abi:ne180100]<0>(a2, v3);
        case 137:
          v3 = "MIP_HA_ERR_REVERSE_TUNNEL_UNAVAILABLE";
          return std::string::basic_string[abi:ne180100]<0>(a2, v3);
        case 138:
          v3 = "MIP_HA_ERR_REVERSE_TUNNEL_IS_MANDATORY_AND_T_BIT_NOT_SET";
          return std::string::basic_string[abi:ne180100]<0>(a2, v3);
        case 139:
          v3 = "MIP_HA_ERR_ENCAPSULATION_UNAVAILABLE";
          return std::string::basic_string[abi:ne180100]<0>(a2, v3);
        default:
          if (a1 != -1)
            goto LABEL_7;
          v3 = "MIP_ERR_REASON_UNKNOWN";
          break;
      }
      return std::string::basic_string[abi:ne180100]<0>(a2, v3);
  }
}

{
  char *v3;
  _QWORD *result;
  _OWORD v5[4];
  void *__p[2];
  __int128 v7;
  __int128 v8;
  _OWORD v9[9];
  uint64_t v10;

  switch(a1)
  {
    case 201:
      v3 = "INTERNAL_ERROR";
      goto LABEL_49;
    case 202:
      v3 = "CALL_ENDED";
      goto LABEL_49;
    case 203:
      v3 = "INTERNAL_UNKNOWN_CAUSE_CODE";
      goto LABEL_49;
    case 204:
      v3 = "UNKNOWN_CAUSE_CODE";
      goto LABEL_49;
    case 205:
      v3 = "INTERNAL_CLOSE_IN_PROGRESS";
      goto LABEL_49;
    case 206:
      v3 = "NW_INITIATED_TERMINATION";
      goto LABEL_49;
    case 207:
      v3 = "APP_PREEMPTED";
      goto LABEL_49;
    case 208:
      v3 = "IPV4_CALL_DISALLOWED";
      goto LABEL_49;
    case 209:
      v3 = "ERR_PDN_IPV4_CALL_THROTTLED";
      goto LABEL_49;
    case 210:
      v3 = "IPV6_DISALLOWED";
      goto LABEL_49;
    case 211:
      v3 = "ERR_PDN_IPV6_CALL_THROTTLED";
      goto LABEL_49;
    case 212:
      v3 = "MODEM_RESTART";
      goto LABEL_49;
    case 213:
      v3 = "PDP_PPP_NOT_SUPPORTED";
      goto LABEL_49;
    case 214:
      v3 = "UNPREFERRED_RAT";
      goto LABEL_49;
    case 215:
      v3 = "PHYS_LINK_CLOSE_IN_PROGRESS";
      goto LABEL_49;
    case 216:
      v3 = "APN_PENDING_HANDOVER";
      goto LABEL_49;
    case 217:
      v3 = "PROFILE_BEARER_INCOMPATIBLE";
      goto LABEL_49;
    case 218:
      v3 = "MMGSDI_CARD_EVT";
      goto LABEL_49;
    case 219:
      v3 = "LPM_OR_PWR_DOWN";
      goto LABEL_49;
    case 221:
      v3 = "MPIT_EXPIRED";
      goto LABEL_49;
    case 222:
      v3 = "IPV6_ADDR_TRANSFER_FAILED";
      goto LABEL_49;
    case 223:
      v3 = "TRAT_SWAP_FAILED";
      goto LABEL_49;
    case 224:
      v3 = "EHRPD_TO_HRPD_FALLBACK";
      goto LABEL_49;
    case 225:
      v3 = "MANDATORY_APN_DISABLED";
      goto LABEL_49;
    case 226:
      v3 = "MIP_CONFIG_FAILURE";
      goto LABEL_49;
    case 227:
      v3 = "INTERNAL_PDN_INACTIVITY_TIMER_EXPIRED";
      goto LABEL_49;
    case 228:
      v3 = "MAX_V4_CONNECTIONS";
      goto LABEL_49;
    case 229:
      v3 = "MAX_V6_CONNECTIONS";
      goto LABEL_49;
    case 230:
      v3 = "APN_MISMATCH";
      goto LABEL_49;
    case 231:
      v3 = "IP_VERSION_MISMATCH";
      goto LABEL_49;
    case 232:
      v3 = "DUN_CALL_DISALLOWED";
      goto LABEL_49;
    case 233:
      v3 = "INVALID_PROFILE";
      goto LABEL_49;
    case 234:
      v3 = "INTERNAL_EPC_NONEPC_TRANSITION";
      goto LABEL_49;
    case 235:
      v3 = "INVALID_PROFILE_ID";
      goto LABEL_49;
    case 236:
      v3 = "INTERNAL_CALL_ALREADY_PRESENT";
      goto LABEL_49;
    case 237:
      v3 = "IFACE_IN_USE";
      goto LABEL_49;
    case 238:
      v3 = "IP_PDP_MISMATCH";
      goto LABEL_49;
    case 239:
      v3 = "APN_DISALLOWED_ON_ROAMING";
      goto LABEL_49;
    case 240:
      v3 = "APN_PARAM_CHANGE";
      goto LABEL_49;
    case 241:
      v3 = "IFACE_IN_USE_CFG_MATCH";
      goto LABEL_49;
    case 242:
      v3 = "NULL_APN_DISALLOWED";
      goto LABEL_49;
    case 243:
      v3 = "THERMAL_MITIGATION";
      goto LABEL_49;
    case 244:
      v3 = "SUBS_ID_MISMATCH";
      goto LABEL_49;
    case 245:
      v3 = "DATA_SETTINGS_DISABLED";
      goto LABEL_49;
    case 247:
      v3 = "APN_FORMAT_INVALID";
      goto LABEL_49;
    case 248:
      v3 = "DDS_CALL_ABORT";
      goto LABEL_49;
    case 249:
      v3 = "VALIDATION_FAILURE";
LABEL_49:
      result = std::string::basic_string[abi:ne180100]<0>(a2, v3);
      break;
    default:
      v10 = 0;
      v8 = 0u;
      memset(v9, 0, sizeof(v9));
      *(_OWORD *)__p = 0u;
      v7 = 0u;
      memset(v5, 0, sizeof(v5));
      std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v5);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)"Unknown: ", 9);
      std::ostream::operator<<();
      std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v5 + 8, a2);
      *(_QWORD *)&v5[0] = *MEMORY[0x24BEDB800];
      *(_QWORD *)((char *)v5 + *(_QWORD *)(*(_QWORD *)&v5[0] - 24)) = *(_QWORD *)(MEMORY[0x24BEDB800] + 24);
      *((_QWORD *)&v5[0] + 1) = MEMORY[0x24BEDB848] + 16;
      if (SHIBYTE(v7) < 0)
        operator delete(__p[1]);
      std::streambuf::~streambuf();
      std::ostream::~ostream();
      result = (_QWORD *)MEMORY[0x2199FEA70](v9);
      break;
  }
  return result;
}

{
  char *v3;
  _OWORD v5[16];
  uint64_t v6;

  if (a1 <= 1499)
  {
    switch(a1)
    {
      case 1000:
        v3 = "CONF_FAILED";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1001:
        v3 = "INCOM_REJ";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1002:
        v3 = "NO_GW_SRV";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1003:
        v3 = "NO_GPRS_CONTEXT";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1004:
        v3 = "ILLEGAL_MS";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1005:
        v3 = "ILLEGAL_ME";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1006:
        v3 = "GPRS_SERVICES_AND_NON_GPRS_SERVICES_NOT_ALLOWED";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1007:
        v3 = "GPRS_SERVICES_NOT_ALLOWED";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1008:
        v3 = "MS_IDENTITY_CANNOT_BE_DERIVED_BY_THE_NETWORK";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1009:
        v3 = "IMPLICITLY_DETACHED";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1010:
        v3 = "PLMN_NOT_ALLOWED";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1011:
        v3 = "LA_NOT_ALLOWED";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1012:
        v3 = "GPRS_SERVICES_NOT_ALLOWED_IN_THIS_PLMN";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1013:
        v3 = "PDP_DUPLICATE";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1014:
        v3 = "UE_RAT_CHANGE";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1015:
        v3 = "CONGESTION";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1016:
        v3 = "NO_PDP_CONTEXT_ACTIVATED";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1017:
        v3 = "ACCESS_CLASS_DSAC_REJECTION";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1018:
        v3 = "PDP_ACTIVATE_MAX_RETRY_FAILED";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1019:
        v3 = "RAB_FAILURE";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1020:
      case 1021:
      case 1022:
      case 1023:
      case 1024:
      case 1118:
      case 1119:
      case 1120:
      case 1122:
      case 1123:
      case 1124:
      case 1125:
      case 1126:
      case 1127:
      case 1128:
      case 1129:
      case 1131:
      case 1132:
      case 1133:
      case 1134:
      case 1135:
      case 1136:
      case 1139:
      case 1140:
      case 1141:
      case 1142:
      case 1143:
      case 1144:
      case 1145:
      case 1146:
      case 1147:
      case 1148:
      case 1149:
      case 1150:
      case 1151:
        goto LABEL_13;
      case 1025:
        v3 = "ESM_UNKNOWN_EPS_BEARER_CONTEXT";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1026:
        v3 = "DRB_RELEASED_AT_RRC";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1027:
        v3 = "NAS_SIG_CONN_RELEASED";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1028:
        v3 = "REASON_EMM_DETACHED";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1029:
        v3 = "EMM_ATTACH_FAILED";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1030:
        v3 = "EMM_ATTACH_STARTED";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1031:
        v3 = "LTE_NAS_SERVICE_REQ_FAILED";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1032:
        v3 = "ESM_ACTIVE_DEDICATED_BEARER_REACTIVATED_BY_NW";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1033:
        v3 = "ESM_LOWER_LAYER_FAILURE";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1034:
        v3 = "ESM_SYNC_UP_WITH_NW";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1035:
        v3 = "ESM_NW_ACTIVATED_DED_BEARER_WITH_ID_OF_DEF_BEARER";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1036:
        v3 = "ESM_BAD_OTA_MESSAGE";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1037:
        v3 = "ESM_DS_REJECTED_THE_CALL";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1038:
        v3 = "ESM_CONTEXT_TRANSFERED_DUE_TO_IRAT";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1039:
        v3 = "DS_EXPLICIT_DEACT";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1040:
        v3 = "ESM_LOCAL_CAUSE_NONE";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1041:
        v3 = "LTE_NAS_SERVICE_REQ_FAILED_NO_THROTTLE";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1042:
        v3 = "ACL_FAILURE";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1043:
        v3 = "LTE_NAS_SERVICE_REQ_FAILED_DS_DISALLOW";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1044:
        v3 = "EMM_T3417_EXPIRED";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1045:
        v3 = "EMM_T3417_EXT_EXPIRED";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1046:
        v3 = "LRRC_UL_DATA_CNF_FAILURE_TXN";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1047:
        v3 = "LRRC_UL_DATA_CNF_FAILURE_HO";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1048:
        v3 = "LRRC_UL_DATA_CNF_FAILURE_CONN_REL";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1049:
        v3 = "LRRC_UL_DATA_CNF_FAILURE_RLF";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1050:
        v3 = "LRRC_UL_DATA_CNF_FAILURE_CTRL_NOT_CONN";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1051:
        v3 = "LRRC_CONN_EST_FAILURE";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1052:
        v3 = "LRRC_CONN_EST_FAILURE_ABORTED";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1053:
        v3 = "LRRC_CONN_EST_FAILURE_ACCESS_BARRED";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1054:
        v3 = "LRRC_CONN_EST_FAILURE_CELL_RESEL";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1055:
        v3 = "LRRC_CONN_EST_FAILURE_CONFIG_FAILURE";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1056:
        v3 = "LRRC_CONN_EST_FAILURE_TIMER_EXPIRED";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1057:
        v3 = "LRRC_CONN_EST_FAILURE_LINK_FAILURE";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1058:
        v3 = "LRRC_CONN_EST_FAILURE_NOT_CAMPED";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1059:
        v3 = "LRRC_CONN_EST_FAILURE_SI_FAILURE";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1060:
        v3 = "LRRC_CONN_EST_FAILURE_CONN_REJECT";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1061:
        v3 = "LRRC_CONN_REL_NORMAL";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1062:
        v3 = "LRRC_CONN_REL_RLF";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1063:
        v3 = "LRRC_CONN_REL_CRE_FAILURE";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1064:
        v3 = "LRRC_CONN_REL_OOS_DURING_CRE";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1065:
        v3 = "LRRC_CONN_REL_ABORTED";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1066:
        v3 = "LRRC_CONN_REL_SIB_READ_ERROR";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1067:
        v3 = "DETACH_WITH_REATTACH_LTE_NW_DETACH";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1068:
        v3 = "DETACH_WITH_OUT_REATTACH_LTE_NW_DETACH";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1069:
        v3 = "PS_NET_DOWN_REASON_ESM_PROC_TIME_OUT";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1070:
        v3 = "INVALID_CONNECTION_ID";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1071:
        v3 = "INVALID_NSAPI";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1072:
        v3 = "INVALID_PRI_NSAPI";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1073:
        v3 = "INVALID_FIELD";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1074:
        v3 = "RAB_SETUP_FAILURE";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1075:
        v3 = "PDP_ESTABLISH_MAX_TIMEOUT";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1076:
        v3 = "PDP_MODIFY_MAX_TIMEOUT";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1077:
        v3 = "PDP_INACTIVE_MAX_TIMEOUT";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1078:
        v3 = "PDP_LOWERLAYER_ERROR";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1079:
        v3 = "PPD_UNKNOWN_REASON";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1080:
        v3 = "PDP_MODIFY_COLLISION";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1081:
        v3 = "PDP_MBMS_REQUEST_COLLISION";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1082:
        v3 = "MBMS_DUPLICATE";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1083:
        v3 = "SM_PS_DETACHED";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1084:
        v3 = "SM_NO_RADIO_AVAILABLE";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1085:
        v3 = "SM_ABORT_SERVICE_NOT_AVAILABLE";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1086:
        v3 = "MESSAGE_EXCEED_MAX_L2_LIMIT";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1087:
        v3 = "SM_NAS_SRV_REQ_FAILURE";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1088:
        v3 = "RRC_CONN_EST_FAILURE_REQ_ERROR";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1089:
        v3 = "RRC_CONN_EST_FAILURE_TAI_CHANGE";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1090:
        v3 = "RRC_CONN_EST_FAILURE_RF_UNAVAILABLE";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1091:
        v3 = "RRC_CONN_REL_ABORTED_IRAT_SUCCESS";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1092:
        v3 = "RRC_CONN_REL_RLF_SEC_NOT_ACTIVE";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1093:
        v3 = "RRC_CONN_REL_IRAT_TO_LTE_ABORTED";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1094:
        v3 = "RRC_CONN_REL_IRAT_FROM_LTE_TO_G_CCO_SUCCESS";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1095:
        v3 = "RRC_CONN_REL_IRAT_FROM_LTE_TO_G_CCO_ABORTED";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1096:
        v3 = "IMSI_UNKNOWN_IN_HSS";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1097:
        v3 = "IMEI_NOT_ACCEPTED";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1098:
        v3 = "EPS_SERVICES_AND_NON_EPS_SERVICES_NOT_ALLOWED";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1099:
        v3 = "EPS_SERVICES_NOT_ALLOWED_IN_PLMN";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1100:
        v3 = "MSC_TEMPORARILY_NOT_REACHABLE";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1101:
        v3 = "CS_DOMAIN_NOT_AVAILABLE";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1102:
        v3 = "ESM_FAILURE";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1103:
        v3 = "MAC_FAILURE";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1104:
        v3 = "SYNCH_FAILURE";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1105:
        v3 = "UE_SECURITY_CAPABILITIES_MISMATCH";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1106:
        v3 = "SECURITY_MODE_REJ_UNSPECIFIED";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1107:
        v3 = "NON_EPS_AUTH_UNACCEPTABLE";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1108:
        v3 = "CS_FALLBACK_CALL_EST_NOT_ALLOWED";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1109:
        v3 = "NO_EPS_BEARER_CONTEXT_ACTIVATED";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1110:
        v3 = "EMM_INVALID_STATE";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1111:
        v3 = "NAS_LAYER_FAILURE";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1112:
        v3 = "MULTI_PDN_NOT_ALLOWED";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1113:
        v3 = "EMBMS_NOT_ENABLED";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1114:
        v3 = "PENDING_REDIAL_CALL_CLEANUP";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1115:
        v3 = "EMBMS_REGULAR_DEACTIVATION";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1116:
        v3 = "TLB_REGULAR_DEACTIVATION";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1117:
        v3 = "LOWER_LAYER_REGISTRATION_FAILURE";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1121:
        v3 = "PS_NET_DOWN_REASON_ACCESS_BARRED";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1130:
        v3 = "PS_NET_DOWN_REASON_RRC_CONN_EST_CONN_REJECT";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1137:
        v3 = "CM_FAILURE_INVALID_STATE";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1138:
        v3 = "CM_FAILURE_DETACHED";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      case 1152:
        v3 = "NON_TRANSFERABLE_PDN";
        return std::string::basic_string[abi:ne180100]<0>(a2, v3);
      default:
        switch(a1)
        {
          case 500:
            v3 = "CDMA_LOCK";
            return std::string::basic_string[abi:ne180100]<0>(a2, v3);
          case 501:
            v3 = "INTERCEPT";
            return std::string::basic_string[abi:ne180100]<0>(a2, v3);
          case 502:
            v3 = "REORDER";
            return std::string::basic_string[abi:ne180100]<0>(a2, v3);
          case 503:
            v3 = "REL_SO_REJ";
            return std::string::basic_string[abi:ne180100]<0>(a2, v3);
          case 504:
            v3 = "INCOM_CALL";
            return std::string::basic_string[abi:ne180100]<0>(a2, v3);
          case 505:
            v3 = "ALERT_STOP";
            return std::string::basic_string[abi:ne180100]<0>(a2, v3);
          case 506:
            v3 = "ACTIVATION";
            return std::string::basic_string[abi:ne180100]<0>(a2, v3);
          case 507:
            v3 = "MAX_ACCESS_PROBE";
            return std::string::basic_string[abi:ne180100]<0>(a2, v3);
          case 508:
            v3 = "CCS_NOT_SUPPORTED_BY_BS";
            return std::string::basic_string[abi:ne180100]<0>(a2, v3);
          case 509:
            v3 = "NO_RESPONSE_FROM_BS";
            return std::string::basic_string[abi:ne180100]<0>(a2, v3);
          case 510:
            v3 = "REJECTED_BY_BS";
            return std::string::basic_string[abi:ne180100]<0>(a2, v3);
          case 511:
            v3 = "INCOMPATIBLE";
            return std::string::basic_string[abi:ne180100]<0>(a2, v3);
          case 512:
            v3 = "ALREADY_IN_TC";
            return std::string::basic_string[abi:ne180100]<0>(a2, v3);
          case 513:
            v3 = "USER_CAL_ORIG_DURING_GPS";
            return std::string::basic_string[abi:ne180100]<0>(a2, v3);
          case 514:
            v3 = "USER_CALL_ORIG_DURING_SMS";
            return std::string::basic_string[abi:ne180100]<0>(a2, v3);
          case 515:
            v3 = "NO_CDMA_SRV";
            return std::string::basic_string[abi:ne180100]<0>(a2, v3);
          case 516:
            v3 = "MC_ABORT";
            return std::string::basic_string[abi:ne180100]<0>(a2, v3);
          case 517:
            v3 = "PSIST_NG";
            return std::string::basic_string[abi:ne180100]<0>(a2, v3);
          case 518:
            v3 = "UIM_NOT_PRESENT";
            return std::string::basic_string[abi:ne180100]<0>(a2, v3);
          case 519:
            v3 = "RETRY_ORDER";
            return std::string::basic_string[abi:ne180100]<0>(a2, v3);
          case 520:
            v3 = "ACCESS_BLOCK";
            return std::string::basic_string[abi:ne180100]<0>(a2, v3);
          case 521:
            v3 = "ACCESS_BLOCK_ALL";
            return std::string::basic_string[abi:ne180100]<0>(a2, v3);
          case 522:
            v3 = "IS707B_MAX_ACC";
            return std::string::basic_string[abi:ne180100]<0>(a2, v3);
          case 523:
            v3 = "THERMAL_EMERGENCY";
            return std::string::basic_string[abi:ne180100]<0>(a2, v3);
          case 524:
            v3 = "CALL_ORIG_THROTTLED";
            return std::string::basic_string[abi:ne180100]<0>(a2, v3);
          case 525:
            v3 = "USER_CALL_ORIG_DURING_VOICE_CALL";
            return std::string::basic_string[abi:ne180100]<0>(a2, v3);
          default:
            goto LABEL_13;
        }
    }
  }
  switch(a1)
  {
    case 1500:
      v3 = "CD_GEN_OR_BUSY";
      return std::string::basic_string[abi:ne180100]<0>(a2, v3);
    case 1501:
      v3 = "CD_BILL_OR_AUTH";
      return std::string::basic_string[abi:ne180100]<0>(a2, v3);
    case 1502:
      v3 = "CHG_HDR";
      return std::string::basic_string[abi:ne180100]<0>(a2, v3);
    case 1503:
      v3 = "EXIT_HDR";
      return std::string::basic_string[abi:ne180100]<0>(a2, v3);
    case 1504:
      v3 = "HDR_NO_SESSION";
      return std::string::basic_string[abi:ne180100]<0>(a2, v3);
    case 1505:
      v3 = "HDR_ORIG_DURING_GPS_FIX";
      return std::string::basic_string[abi:ne180100]<0>(a2, v3);
    case 1506:
      v3 = "HDR_CS_TIMEOUT";
      return std::string::basic_string[abi:ne180100]<0>(a2, v3);
    case 1507:
      v3 = "HDR_RELEASED_BY_CM";
      return std::string::basic_string[abi:ne180100]<0>(a2, v3);
    case 1508:
      v3 = "COLLOC_ACQ_FAIL";
      return std::string::basic_string[abi:ne180100]<0>(a2, v3);
    case 1509:
      v3 = "OTASP_COMMIT_IN_PROG";
      return std::string::basic_string[abi:ne180100]<0>(a2, v3);
    case 1510:
      v3 = "NO_HYBR_HDR_SRV";
      return std::string::basic_string[abi:ne180100]<0>(a2, v3);
    case 1511:
      v3 = "HDR_NO_LOCK_GRANTED";
      return std::string::basic_string[abi:ne180100]<0>(a2, v3);
    case 1512:
      v3 = "HOLD_OTHER_IN_PROG";
      return std::string::basic_string[abi:ne180100]<0>(a2, v3);
    case 1513:
      v3 = "HDR_FADE";
      return std::string::basic_string[abi:ne180100]<0>(a2, v3);
    case 1514:
      v3 = "HDR_ACC_FAIL";
      return std::string::basic_string[abi:ne180100]<0>(a2, v3);
    case 1515:
      v3 = "UNSUPPORTED_1X_PREV";
      return std::string::basic_string[abi:ne180100]<0>(a2, v3);
    case 1516:
    case 1517:
LABEL_13:
      v6 = 0;
      memset(v5, 0, sizeof(v5));
      std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v5);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)"Unknown: ", 9);
      std::ostream::operator<<();
      std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v5 + 8, a2);
      return (_QWORD *)std::ostringstream::~ostringstream((uint64_t)v5);
    case 1518:
      v3 = "PS_NET_DOWN_REASON_RRC_FAIL_RESUME_REJ";
      return std::string::basic_string[abi:ne180100]<0>(a2, v3);
    default:
      switch(a1)
      {
        case 2500:
          v3 = "OFFLINE";
          return std::string::basic_string[abi:ne180100]<0>(a2, v3);
        case 2501:
          v3 = "EMERGENCY_MODE";
          return std::string::basic_string[abi:ne180100]<0>(a2, v3);
        case 2502:
          v3 = "PHONE_IN_USE";
          return std::string::basic_string[abi:ne180100]<0>(a2, v3);
        case 2503:
          v3 = "INVALID_MODE";
          return std::string::basic_string[abi:ne180100]<0>(a2, v3);
        case 2504:
          v3 = "INVALID_SIM_STATE";
          return std::string::basic_string[abi:ne180100]<0>(a2, v3);
        case 2505:
          v3 = "NO_COLLOC_HDR";
          return std::string::basic_string[abi:ne180100]<0>(a2, v3);
        case 2506:
          v3 = "CALL_CONTROL_REJECTED";
          return std::string::basic_string[abi:ne180100]<0>(a2, v3);
        case 2507:
        case 2508:
        case 2510:
        case 2511:
          goto LABEL_13;
        case 2509:
          v3 = "CALL_MANAGER";
          return std::string::basic_string[abi:ne180100]<0>(a2, v3);
        case 2512:
          v3 = "NO_TRM";
          return std::string::basic_string[abi:ne180100]<0>(a2, v3);
        default:
          switch(a1)
          {
            case 2000:
              v3 = "CLIENT_END";
              return std::string::basic_string[abi:ne180100]<0>(a2, v3);
            case 2001:
              v3 = "NO_SRV";
              return std::string::basic_string[abi:ne180100]<0>(a2, v3);
            case 2002:
              v3 = "FADE";
              return std::string::basic_string[abi:ne180100]<0>(a2, v3);
            case 2003:
              v3 = "REL_NORMAL";
              return std::string::basic_string[abi:ne180100]<0>(a2, v3);
            case 2004:
              v3 = "ACC_IN_PROG";
              return std::string::basic_string[abi:ne180100]<0>(a2, v3);
            case 2005:
              v3 = "ACC_FAIL";
              return std::string::basic_string[abi:ne180100]<0>(a2, v3);
            case 2006:
              v3 = "REDIR_OR_HANDOFF";
              return std::string::basic_string[abi:ne180100]<0>(a2, v3);
            case 2007:
              v3 = "CM_UNKNOWN_ERROR";
              return std::string::basic_string[abi:ne180100]<0>(a2, v3);
            default:
              goto LABEL_13;
          }
      }
  }
}

{
  char *v3;
  _OWORD v5[4];
  void *__p[2];
  __int128 v7;
  __int128 v8;
  _OWORD v9[9];
  uint64_t v10;

  switch(a1)
  {
    case -1:
      v3 = "PPP_UNKNOWN";
      return std::string::basic_string[abi:ne180100]<0>(a2, v3);
    case 0:
LABEL_6:
      v10 = 0;
      v8 = 0u;
      memset(v9, 0, sizeof(v9));
      *(_OWORD *)__p = 0u;
      v7 = 0u;
      memset(v5, 0, sizeof(v5));
      std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v5);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)"Unknown: ", 9);
      std::ostream::operator<<();
      std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v5 + 8, a2);
      *(_QWORD *)&v5[0] = *MEMORY[0x24BEDB800];
      *(_QWORD *)((char *)v5 + *(_QWORD *)(*(_QWORD *)&v5[0] - 24)) = *(_QWORD *)(MEMORY[0x24BEDB800] + 24);
      *((_QWORD *)&v5[0] + 1) = MEMORY[0x24BEDB848] + 16;
      if (SHIBYTE(v7) < 0)
        operator delete(__p[1]);
      std::streambuf::~streambuf();
      std::ostream::~ostream();
      return (_QWORD *)MEMORY[0x2199FEA70](v9);
    case 1:
      v3 = "TIMEOUT";
      return std::string::basic_string[abi:ne180100]<0>(a2, v3);
    case 2:
      v3 = "AUTH_FAILURE";
      return std::string::basic_string[abi:ne180100]<0>(a2, v3);
    case 3:
      v3 = "OPTION_MISMATCH";
      return std::string::basic_string[abi:ne180100]<0>(a2, v3);
    default:
      switch(a1)
      {
        case 31:
          v3 = "PAP_FAILURE";
          return std::string::basic_string[abi:ne180100]<0>(a2, v3);
        case 32:
          v3 = "CHAP_FAILURE";
          return std::string::basic_string[abi:ne180100]<0>(a2, v3);
        case 33:
          v3 = "CLOSE_IN_PROGRESS";
          return std::string::basic_string[abi:ne180100]<0>(a2, v3);
        case 34:
          v3 = "NV_REFRESH_IN_PROGRESS";
          return std::string::basic_string[abi:ne180100]<0>(a2, v3);
        default:
          goto LABEL_6;
      }
  }
}

{
  char *v3;
  _QWORD *result;
  _OWORD v5[4];
  void *__p[2];
  __int128 v7;
  __int128 v8;
  _OWORD v9[9];
  uint64_t v10;

  switch(a1)
  {
    case 1:
      v3 = "SUBS_LIMITED_TO_V4";
      goto LABEL_22;
    case 2:
      v3 = "SUBS_LIMITED_TO_V6";
      goto LABEL_22;
    case 4:
      v3 = "VSNCP_TIMEOUT";
      goto LABEL_22;
    case 5:
      v3 = "VSNCP_FAILURE";
      goto LABEL_22;
    case 6:
      v3 = "VSNCP_3GPP2I_GEN_ERROR";
      goto LABEL_22;
    case 7:
      v3 = "VSNCP_3GPP2I_UNAUTH_APN";
      goto LABEL_22;
    case 8:
      v3 = "VSNCP_3GPP2I_PDN_LIMIT_EXCEED";
      goto LABEL_22;
    case 9:
      v3 = "VSNCP_3GPP2I_NO_PDN_GW";
      goto LABEL_22;
    case 10:
      v3 = "VSNCP_3GPP2I_PDN_GW_UNREACH";
      goto LABEL_22;
    case 11:
      v3 = "VSNCP_3GPP2I_PDN_GW_REJ";
      goto LABEL_22;
    case 12:
      v3 = "VSNCP_3GPP2I_INSUFF_PARAM";
      goto LABEL_22;
    case 13:
      v3 = "VSNCP_3GPP2I_RESOURCE_UNAVAIL";
      goto LABEL_22;
    case 14:
      v3 = "VSNCP_3GPP2I_ADMIN_PROHIBIT";
      goto LABEL_22;
    case 15:
      v3 = "VSNCP_3GPP2I_PDN_ID_IN_USE";
      goto LABEL_22;
    case 16:
      v3 = "VSNCP_3GPP2I_SUBSCR_LIMITATION";
      goto LABEL_22;
    case 17:
      v3 = "VSNCP_3GPP2I_PDN_EXISTS_FOR_THIS_APN";
      goto LABEL_22;
    case 19:
      v3 = "VSNCP_3GPP2I_RECONNECT_NOT_ALLOWED";
LABEL_22:
      result = std::string::basic_string[abi:ne180100]<0>(a2, v3);
      break;
    default:
      v10 = 0;
      v8 = 0u;
      memset(v9, 0, sizeof(v9));
      *(_OWORD *)__p = 0u;
      v7 = 0u;
      memset(v5, 0, sizeof(v5));
      std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v5);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)"Unknown: ", 9);
      std::ostream::operator<<();
      std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v5 + 8, a2);
      *(_QWORD *)&v5[0] = *MEMORY[0x24BEDB800];
      *(_QWORD *)((char *)v5 + *(_QWORD *)(*(_QWORD *)&v5[0] - 24)) = *(_QWORD *)(MEMORY[0x24BEDB800] + 24);
      *((_QWORD *)&v5[0] + 1) = MEMORY[0x24BEDB848] + 16;
      if (SHIBYTE(v7) < 0)
        operator delete(__p[1]);
      std::streambuf::~streambuf();
      std::ostream::~ostream();
      result = (_QWORD *)MEMORY[0x2199FEA70](v9);
      break;
  }
  return result;
}

{
  char *v3;
  _OWORD v5[4];
  void *__p[2];
  __int128 v7;
  __int128 v8;
  _OWORD v9[9];
  uint64_t v10;

  switch(a1)
  {
    case 3:
      v3 = "IPV6_DISABLED";
      return std::string::basic_string[abi:ne180100]<0>(a2, v3);
    case 2:
      v3 = "IPV6_ERR_HRPD_IPV6_DISABLED";
      return std::string::basic_string[abi:ne180100]<0>(a2, v3);
    case 1:
      v3 = "PREFIX_UNAVAILABLE";
      return std::string::basic_string[abi:ne180100]<0>(a2, v3);
  }
  v10 = 0;
  v8 = 0u;
  memset(v9, 0, sizeof(v9));
  *(_OWORD *)__p = 0u;
  v7 = 0u;
  memset(v5, 0, sizeof(v5));
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v5);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)"Unknown: ", 9);
  std::ostream::operator<<();
  std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v5 + 8, a2);
  *(_QWORD *)&v5[0] = *MEMORY[0x24BEDB800];
  *(_QWORD *)((char *)v5 + *(_QWORD *)(*(_QWORD *)&v5[0] - 24)) = *(_QWORD *)(MEMORY[0x24BEDB800] + 24);
  *((_QWORD *)&v5[0] + 1) = MEMORY[0x24BEDB848] + 16;
  if (SHIBYTE(v7) < 0)
    operator delete(__p[1]);
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return (_QWORD *)MEMORY[0x2199FEA70](v9);
}

void sub_2168B0514(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::ostringstream::~ostringstream((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void sub_2168B0884(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::ostringstream::~ostringstream((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void sub_2168B1258(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::ostringstream::~ostringstream((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void sub_2168B1418(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::ostringstream::~ostringstream((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void sub_2168B1620(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::ostringstream::~ostringstream((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void sub_2168B1774(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::ostringstream::~ostringstream((uint64_t)&a9);
  _Unwind_Resume(a1);
}

_QWORD *wds::asString@<X0>(int a1@<W0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  _QWORD *result;
  char *v5;
  _OWORD v6[4];
  void *__p[2];
  __int128 v8;
  __int128 v9;
  _OWORD v10[9];
  uint64_t v11;

  switch(a1)
  {
    case 0:
    case 1:
      result = wds::asString(a2, a3);
      break;
    case 2:
      result = wds::asString(a2, a3);
      break;
    case 3:
      result = wds::asString(a2, a3);
      break;
    case 6:
      v5 = (char *)asString();
      result = std::string::basic_string[abi:ne180100]<0>(a3, v5);
      break;
    case 7:
      result = wds::asString(a2, a3);
      break;
    case 8:
      result = wds::asString(a2, a3);
      break;
    case 9:
      result = wds::asString(a2, a3);
      break;
    default:
      v11 = 0;
      v9 = 0u;
      memset(v10, 0, sizeof(v10));
      *(_OWORD *)__p = 0u;
      v8 = 0u;
      memset(v6, 0, sizeof(v6));
      std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v6);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v6, (uint64_t)"Unknown: ", 9);
      std::ostream::operator<<();
      std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v6 + 8, a3);
      *(_QWORD *)&v6[0] = *MEMORY[0x24BEDB800];
      *(_QWORD *)((char *)v6 + *(_QWORD *)(*(_QWORD *)&v6[0] - 24)) = *(_QWORD *)(MEMORY[0x24BEDB800] + 24);
      *((_QWORD *)&v6[0] + 1) = MEMORY[0x24BEDB848] + 16;
      if (SHIBYTE(v8) < 0)
        operator delete(__p[1]);
      std::streambuf::~streambuf();
      std::ostream::~ostream();
      result = (_QWORD *)MEMORY[0x2199FEA70](v10);
      break;
  }
  return result;
}

void sub_2168B1968(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::ostringstream::~ostringstream((uint64_t)&a9);
  _Unwind_Resume(a1);
}

const char *wds::asString(uint64_t a1)
{
  const char *result;

  if (a1 > 31)
  {
    if (a1 > 255)
    {
      switch(a1)
      {
        case 256:
          return "kInitialAttach";
        case 512:
          return "kEmergency";
        case 2048:
          return "kMissionCriticalSrv";
      }
    }
    else
    {
      switch(a1)
      {
        case 32:
          return "kHighPriorityData";
        case 64:
          return "kOverTheAirAdmin";
        case 128:
          return "kCarrierBrandedSrv";
      }
    }
    return "UnknownValue";
  }
  else
  {
    result = "kUnSpecified";
    switch(a1)
    {
      case 0:
        return result;
      case 1:
        result = "kDefaultInternet";
        break;
      case 2:
        result = "kIMS";
        break;
      case 3:
      case 5:
      case 6:
      case 7:
        return "UnknownValue";
      case 4:
        result = "kMMS";
        break;
      case 8:
        result = "kDialUpNetwork";
        break;
      default:
        if (a1 != 16)
          return "UnknownValue";
        result = "kSupl";
        break;
    }
  }
  return result;
}

const char *pdc::asString(int a1)
{
  const char *v1;
  const char *v2;

  v1 = "kNotProvisioned";
  v2 = "???";
  if (a1 == 3)
    v2 = "kInternal";
  if (a1 != 16)
    v1 = v2;
  if (a1)
    return v1;
  else
    return "kNone";
}

const char *dsd::asString(int a1)
{
  const char *result;

  if (a1 <= 99)
  {
    result = "kEX_NULL_BEARER";
    switch(a1)
    {
      case 0:
        return result;
      case 1:
        result = "kEX_3GPP_WCDMA";
        break;
      case 2:
        result = "kEX_3GPP_GERAN";
        break;
      case 3:
        result = "kEX_3GPP_LTE";
        break;
      case 4:
        result = "kEX_3GPP_TDSCDMA";
        break;
      case 5:
        result = "kEX_3GPP_WLAN";
        break;
      case 6:
        result = "kEX_3GPP_5G";
        break;
      default:
        return "???";
    }
  }
  else if (a1 > 199)
  {
    switch(a1)
    {
      case 200:
        return "kEX_3GPP2_MAX";
      case 201:
        return "kEX_WLAN";
      case 300:
        return "kEX_WLAN_MAX";
      default:
        return "???";
    }
  }
  else
  {
    switch(a1)
    {
      case 'd':
        result = "kEX_3GPP_MAX";
        break;
      case 'e':
        result = "kEX_3GPP2_1X";
        break;
      case 'f':
        result = "kEX_3GPP2_HRPD";
        break;
      case 'g':
        result = "kEX_3GPP2_EHRPD";
        break;
      case 'h':
        result = "kEX_3GPP2_WLAN";
        break;
      default:
        return "???";
    }
  }
  return result;
}

const char *dsd::asString(uint64_t a1)
{
  const char *v1;

  if (a1 >= 0x20000)
  {
    if (a1 <= 0xFFFFFFFFLL)
    {
      if (a1 <= 0x7FFFFFF)
      {
        if (a1 > 0x1FFFFFF)
        {
          if (a1 == 0x2000000)
            return "k3GPP2_1X_IS2000";
          if (a1 == 0x4000000)
            return "k3GPP2_1X_IS2000_REL_A";
        }
        else
        {
          if (a1 == 0x20000)
            return "k3GPP_LTE_CA_UL";
          if (a1 == 0x1000000)
            return "k3GPP2_1X_IS95";
        }
      }
      else if (a1 <= 0x1FFFFFFF)
      {
        if (a1 == 0x8000000)
          return "k3GPP2_HDR_REV0_DPA";
        if (a1 == 0x10000000)
          return "k3GPP2_HDR_REVA_DPA";
      }
      else
      {
        switch(a1)
        {
          case 0x20000000:
            return "k3GPP2_HDR_REVB_DPA";
          case 0x40000000:
            return "k3GPP2_HDR_REVA_MPA";
          case 0x80000000:
            return "k3GPP2_HDR_REVB_MPA";
        }
      }
    }
    else if (a1 > 0xFFFFFFFFFFLL)
    {
      if (a1 <= 0x3FFFFFFFFFFLL)
      {
        if (a1 == 0x10000000000)
          return "k3GPP_5G_TDD";
        if (a1 == 0x20000000000)
          return "k3GPP_5G_SUB6";
      }
      else
      {
        switch(a1)
        {
          case 0x40000000000:
            return "k3GPP_5G_MMWAVE";
          case 0x80000000000:
            return "k3GPP_5G_NSA";
          case 0x100000000000:
            return "k3GPP_5G_SA";
        }
      }
    }
    else if (a1 <= 0x3FFFFFFFFLL)
    {
      if (a1 == 0x100000000)
        return "k3GPP2_HDR_REVA_EMPA";
      if (a1 == 0x200000000)
        return "k3GPP2_HDR_REVB_EMPA";
    }
    else
    {
      switch(a1)
      {
        case 0x400000000:
          return "k3GPP2_HDR_REVB_MMPA";
        case 0x800000000:
          return "k3GPP2_HDR_EVDO_FMC";
        case 0x1000000000:
          return "k3GPP2_1X_CS";
      }
    }
    return "<unknown mask, probably a composite mask>";
  }
  if (a1 > 255)
  {
    if (a1 <= 4095)
    {
      if (a1 > 1023)
      {
        if (a1 == 1024)
          return "k3GPP_S2B";
        if (a1 == 2048)
          return "k3GPP_LTE_LIMITED";
      }
      else
      {
        if (a1 == 256)
          return "k3GPP_EDGE";
        if (a1 == 512)
          return "k3GPP_GSM";
      }
    }
    else if (a1 < 0x4000)
    {
      if (a1 == 4096)
        return "k3GPP_LTE_FDD";
      if (a1 == 0x2000)
        return "k3GPP_LTE_TDD";
    }
    else
    {
      switch(a1)
      {
        case 0x4000:
          return "k3GPP_TDSCDMA";
        case 0x8000:
          return "k3GPP_DC_HSUPA";
        case 0x10000:
          return "k3GPP_LTE_CA_DL";
      }
    }
    return "<unknown mask, probably a composite mask>";
  }
  if (a1 > 15)
  {
    if (a1 > 63)
    {
      if (a1 == 64)
        return "k3GPP_HSPA";
      if (a1 == 128)
        return "k3GPP_GPRS";
    }
    else
    {
      if (a1 == 16)
        return "k3GPP_DC_HSDPAPLUS";
      if (a1 == 32)
        return "k3GPP_64_QAM";
    }
    return "<unknown mask, probably a composite mask>";
  }
  v1 = "kUnspecified";
  switch(a1)
  {
    case 0:
      return v1;
    case 1:
      v1 = "k3GPP_WCDMA";
      break;
    case 2:
      v1 = "k3GPP_HSDPA";
      break;
    case 4:
      v1 = "k3GPP_HSUPA";
      break;
    case 8:
      v1 = "k3GPP_HSDPAPLUS";
      break;
    default:
      return "<unknown mask, probably a composite mask>";
  }
  return v1;
}

{
  const char *result;

  result = "kUnspecified";
  switch(a1)
  {
    case 0:
      return result;
    case 1:
      result = "k3GPP5gBasic";
      break;
    case 2:
      result = "k3GPP5gUltraWideBand";
      break;
    case 3:
    case 5:
    case 6:
    case 7:
      goto LABEL_5;
    case 4:
      result = "k3GPP5gSib2PlmnR15";
      break;
    case 8:
      result = "k3GPPSib2UpperLayer";
      break;
    default:
      if (a1 == 16)
        result = "k3GPPRestrictDecodedChannelNumberRegister";
      else
LABEL_5:
        result = "???";
      break;
  }
  return result;
}

uint64_t qos::tlv::writeField(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  *(_BYTE *)a1 = 16;
  *(_WORD *)(a1 + 1) = 1;
  *(_BYTE *)(a1 + 3) = *(_BYTE *)a2;
  *(_BYTE *)(a1 + 4) = 17;
  *(_WORD *)(a1 + 5) = 16;
  *(_BYTE *)(a1 + 7) = 16;
  *(_WORD *)(a1 + 8) = 13;
  *(_BYTE *)(a1 + 10) = 16;
  *(_WORD *)(a1 + 11) = 1;
  *(_BYTE *)(a1 + 13) = *(_BYTE *)(a2 + 1);
  *(_BYTE *)(a1 + 14) = 27;
  *(_WORD *)(a1 + 15) = 2;
  *(_WORD *)(a1 + 17) = *(_WORD *)(a2 + 2);
  *(_BYTE *)(a1 + 19) = 28;
  *(_WORD *)(a1 + 20) = 1;
  *(_BYTE *)(a1 + 22) = *(_BYTE *)(a2 + 4);
  *(_BYTE *)(a1 + 23) = 18;
  *(_WORD *)(a1 + 24) = 16;
  *(_BYTE *)(a1 + 26) = 16;
  *(_WORD *)(a1 + 27) = 13;
  *(_BYTE *)(a1 + 29) = 16;
  *(_WORD *)(a1 + 30) = 1;
  *(_BYTE *)(a1 + 32) = *(_BYTE *)(a2 + 1);
  *(_BYTE *)(a1 + 33) = 27;
  *(_WORD *)(a1 + 34) = 2;
  *(_WORD *)(a1 + 36) = *(_WORD *)(a2 + 2);
  *(_BYTE *)(a1 + 38) = 28;
  *(_WORD *)(a1 + 39) = 1;
  *(_BYTE *)(a1 + 41) = *(_BYTE *)(a2 + 4);
  *(_BYTE *)(a1 + 42) = 19;
  *(_WORD *)(a1 + 43) = 51;
  *(_BYTE *)(a1 + 45) = 16;
  *(_WORD *)(a1 + 46) = 48;
  v3 = writeIpv4FilterSpec(a1 + 48, a2);
  *(_BYTE *)v3 = 20;
  *(_WORD *)(v3 + 1) = 51;
  *(_BYTE *)(v3 + 3) = 16;
  *(_WORD *)(v3 + 4) = 48;
  return writeIpv4FilterSpec(v3 + 6, a2);
}

{
  uint64_t v3;

  *(_BYTE *)a1 = 16;
  *(_WORD *)(a1 + 1) = 1;
  *(_BYTE *)(a1 + 3) = *(_BYTE *)a2;
  *(_BYTE *)(a1 + 4) = 17;
  *(_WORD *)(a1 + 5) = 16;
  *(_BYTE *)(a1 + 7) = 16;
  *(_WORD *)(a1 + 8) = 13;
  *(_BYTE *)(a1 + 10) = 16;
  *(_WORD *)(a1 + 11) = 1;
  *(_BYTE *)(a1 + 13) = *(_BYTE *)(a2 + 1);
  *(_BYTE *)(a1 + 14) = 27;
  *(_WORD *)(a1 + 15) = 2;
  *(_WORD *)(a1 + 17) = *(_WORD *)(a2 + 2);
  *(_BYTE *)(a1 + 19) = 28;
  *(_WORD *)(a1 + 20) = 1;
  *(_BYTE *)(a1 + 22) = *(_BYTE *)(a2 + 4);
  *(_BYTE *)(a1 + 23) = 18;
  *(_WORD *)(a1 + 24) = 16;
  *(_BYTE *)(a1 + 26) = 16;
  *(_WORD *)(a1 + 27) = 13;
  *(_BYTE *)(a1 + 29) = 16;
  *(_WORD *)(a1 + 30) = 1;
  *(_BYTE *)(a1 + 32) = *(_BYTE *)(a2 + 1);
  *(_BYTE *)(a1 + 33) = 27;
  *(_WORD *)(a1 + 34) = 2;
  *(_WORD *)(a1 + 36) = *(_WORD *)(a2 + 2);
  *(_BYTE *)(a1 + 38) = 28;
  *(_WORD *)(a1 + 39) = 1;
  *(_BYTE *)(a1 + 41) = *(_BYTE *)(a2 + 4);
  *(_BYTE *)(a1 + 42) = 19;
  *(_WORD *)(a1 + 43) = 69;
  *(_BYTE *)(a1 + 45) = 16;
  *(_WORD *)(a1 + 46) = 66;
  v3 = writeIpv6FilterSpec(a1 + 48, a2);
  *(_BYTE *)v3 = 20;
  *(_WORD *)(v3 + 1) = 69;
  *(_BYTE *)(v3 + 3) = 16;
  *(_WORD *)(v3 + 4) = 66;
  return writeIpv6FilterSpec(v3 + 6, a2);
}

uint64_t writeIpv4FilterSpec(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)a1 = 16;
  *(_WORD *)(a1 + 1) = 1;
  *(_BYTE *)(a1 + 3) = *(_BYTE *)(a2 + 5);
  *(_BYTE *)(a1 + 4) = 17;
  *(_QWORD *)(a1 + 5) = 0x1E11000114040001;
  *(_WORD *)(a1 + 13) = 4;
  *(_WORD *)(a1 + 15) = *(_WORD *)(a2 + 8);
  *(_WORD *)(a1 + 17) = *(_WORD *)(a2 + 10);
  *(_BYTE *)(a1 + 19) = 29;
  *(_WORD *)(a1 + 20) = 4;
  *(_WORD *)(a1 + 22) = *(_WORD *)(a2 + 12);
  *(_WORD *)(a1 + 24) = *(_WORD *)(a2 + 14);
  *(_BYTE *)(a1 + 26) = 18;
  *(_WORD *)(a1 + 27) = 8;
  *(_DWORD *)(a1 + 29) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a1 + 33) = *(_DWORD *)(a2 + 20);
  *(_BYTE *)(a1 + 37) = 19;
  *(_WORD *)(a1 + 38) = 8;
  *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 + 24);
  *(_DWORD *)(a1 + 44) = *(_DWORD *)(a2 + 28);
  return a1 + 48;
}

uint64_t writeIpv6FilterSpec(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)a1 = 16;
  *(_WORD *)(a1 + 1) = 1;
  *(_BYTE *)(a1 + 3) = *(_BYTE *)(a2 + 5);
  *(_BYTE *)(a1 + 4) = 17;
  *(_QWORD *)(a1 + 5) = 0x1E11000114060001;
  *(_WORD *)(a1 + 13) = 4;
  *(_WORD *)(a1 + 15) = *(_WORD *)(a2 + 8);
  *(_WORD *)(a1 + 17) = *(_WORD *)(a2 + 10);
  *(_BYTE *)(a1 + 19) = 29;
  *(_WORD *)(a1 + 20) = 4;
  *(_WORD *)(a1 + 22) = *(_WORD *)(a2 + 12);
  *(_WORD *)(a1 + 24) = *(_WORD *)(a2 + 14);
  *(_BYTE *)(a1 + 26) = 22;
  *(_WORD *)(a1 + 27) = 17;
  *(_OWORD *)(a1 + 29) = *(_OWORD *)(a2 + 16);
  *(_BYTE *)(a1 + 45) = *(_BYTE *)(a2 + 32);
  *(_BYTE *)(a1 + 46) = 23;
  *(_WORD *)(a1 + 47) = 17;
  *(_OWORD *)(a1 + 49) = *(_OWORD *)(a2 + 33);
  *(_BYTE *)(a1 + 65) = *(_BYTE *)(a2 + 49);
  return a1 + 66;
}

uint64_t tlv::size<qos::tlv::QosSpecV4>()
{
  return 153;
}

uint64_t tlv::size<qos::tlv::QosSpecV6>()
{
  return 189;
}

uint64_t tlv::writeV<qos::tlv::QosSpecV4>(uint64_t *a1, uint64_t a2)
{
  uint64_t result;

  result = qos::tlv::writeField(*a1, a2);
  *a1 = result;
  return result;
}

uint64_t tlv::writeV<qos::tlv::QosSpecV6>(uint64_t *a1, uint64_t a2)
{
  uint64_t result;

  result = qos::tlv::writeField(*a1, a2);
  *a1 = result;
  return result;
}

const char *qos::asString(unsigned int a1)
{
  if (a1 > 6)
    return "UnknownValue";
  else
    return off_24D5C2AC0[a1];
}

const char *vinyl::asString(int a1)
{
  const char *result;

  if (a1 <= 15)
  {
    result = "kNoCommand";
    switch(a1)
    {
      case 0:
        return result;
      case 1:
        result = "kGetCsn";
        break;
      case 3:
        result = "kGetAvailableSpace";
        break;
      case 5:
        result = "kListProfiles";
        break;
      default:
LABEL_16:
        result = "???";
        break;
    }
  }
  else
  {
    switch(a1)
    {
      case 16:
        return "kSignIdMap";
      case 17:
      case 18:
      case 19:
        goto LABEL_16;
      case 20:
        return "kActivateProfile";
      case 21:
        return "kDeactivateProfile";
      case 22:
        return "kDeleteProfile";
      case 23:
        return "kSignPayload";
      default:
        if (a1 == 64)
        {
          result = "kGetFirmwareUpdateData";
        }
        else
        {
          if (a1 != 65)
            goto LABEL_16;
          result = "kSecureAka";
        }
        break;
    }
  }
  return result;
}

{
  if ((a1 - 1) > 0x18)
    return "???";
  else
    return off_24D5C2AF8[(char)(a1 - 1)];
}

const char *elqm::asString(int a1)
{
  if ((a1 - 18) > 4)
    return "???";
  else
    return off_24D5C2BC0[(__int16)(a1 - 18)];
}

uint64_t tlv::parseV<cat::tlv::FullFuncEventReportErrorMask>(unint64_t *a1, int a2)
{
  unsigned int *v3;
  uint64_t result;

  v3 = (unsigned int *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 4uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168B265C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168B2650);
}

unint64_t cat::tlv::parseField(unint64_t a1, const unsigned __int8 *a2, uint64_t a3)
{
  tlv::throwIfNotEnoughBytes(a1, a2, 1uLL);
  *(_BYTE *)a3 = *(_BYTE *)a1;
  tlv::throwIfNotEnoughBytes(a1 + 1, a2, 4uLL);
  *(_DWORD *)(a3 + 4) = *(_DWORD *)(a1 + 1);
  tlv::throwIfNotEnoughBytes(a1 + 5, a2, 1uLL);
  *(_BYTE *)(a3 + 8) = *(_BYTE *)(a1 + 5);
  return a1 + 6;
}

{
  unint64_t v5;
  unint64_t v6;

  v5 = a1;
  tlv::throwIfNotEnoughBytes(a1, a2, 1uLL);
  *(_BYTE *)a3 = *(_BYTE *)v5;
  tlv::throwIfNotEnoughBytes(v5 + 1, a2, 1uLL);
  v6 = *(unsigned __int8 *)(v5 + 1);
  v5 += 2;
  tlv::throwIfNotEnoughBytes(v5, a2, v6);
  std::string::__assign_trivial[abi:ne180100]<unsigned char const*,unsigned char const*>((std::string *)(a3 + 8), (std::string::value_type *)v5, (std::string::value_type *)(v5 + v6), v6);
  return v5 + v6;
}

uint64_t tlv::parseV<cat::tlv::DecodedHeaderId>(unint64_t *a1, int a2)
{
  uint64_t v3;
  int v4;

  v4 = 0;
  v3 = 0;
  *a1 = cat::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), (uint64_t)&v3);
  return v3;
}

void sub_2168B2728(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168B2710);
}

unint64_t tlv::parseV<cat::tlv::TextString>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  unint64_t result;

  *a3 = 0u;
  a3[1] = 0u;
  result = cat::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), (uint64_t)a3);
  *a1 = result;
  return result;
}

void sub_2168B27F4(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168B27E8);
}

void sub_2168B2804(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 31) < 0)
    operator delete(*(void **)(v1 + 8));
  _Unwind_Resume(exception_object);
}

uint64_t tlv::size<cat::tlv::TextString>(uint64_t a1)
{
  uint64_t v1;

  v1 = *(unsigned __int8 *)(a1 + 31);
  if ((v1 & 0x80u) != 0)
    v1 = *(_QWORD *)(a1 + 16);
  return v1 + 5;
}

void *tlv::writeV<cat::tlv::TextString>(_QWORD *a1, uint64_t a2)
{
  _BYTE *v4;
  uint64_t v5;
  char *v6;
  size_t v7;
  size_t v8;
  const void *v9;
  size_t v10;
  void *result;
  uint64_t v12;

  v4 = (_BYTE *)*a1;
  *(_BYTE *)*a1 = *(_BYTE *)a2;
  LOBYTE(v5) = *(_BYTE *)(a2 + 31);
  if ((v5 & 0x80u) != 0)
    v5 = *(_QWORD *)(a2 + 16);
  v6 = v4 + 2;
  v4[1] = v5;
  v7 = *(unsigned __int8 *)(a2 + 31);
  v8 = *(_QWORD *)(a2 + 16);
  if ((v7 & 0x80u) == 0)
    v9 = (const void *)(a2 + 8);
  else
    v9 = *(const void **)(a2 + 8);
  if ((v7 & 0x80u) == 0)
    v10 = v7;
  else
    v10 = v8;
  result = memcpy(v6, v9, v10);
  v12 = *(unsigned __int8 *)(a2 + 31);
  if ((v12 & 0x80u) != 0)
    v12 = *(_QWORD *)(a2 + 16);
  *a1 = &v6[v12];
  return result;
}

uint64_t tlv::parseV<cat::tlv::HighPriority>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168B2908(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168B28FCLL);
}

uint64_t tlv::parseV<cat::tlv::UserControl>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168B2954(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168B2948);
}

uint64_t tlv::parseV<cat::tlv::ImmediateResponseRequired>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168B29A0(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168B2994);
}

uint64_t tlv::parseV<cat::tlv::Duration>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  const unsigned __int8 *v4;
  int v5;
  int v6;

  v3 = (unsigned __int8 *)*a1;
  v4 = (const unsigned __int8 *)(*a1 + a2);
  tlv::throwIfNotEnoughBytes(*a1, v4, 1uLL);
  v5 = *v3;
  tlv::throwIfNotEnoughBytes((unint64_t)(v3 + 1), v4, 1uLL);
  v6 = v3[1];
  *a1 = (unint64_t)(v3 + 2);
  return v5 | (v6 << 8);
}

void sub_2168B2A18(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168B2A04);
}

uint64_t tlv::parseV<cat::tlv::ResponseFormat>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168B2A64(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168B2A58);
}

uint64_t tlv::parseV<cat::tlv::HelpAvailable>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168B2AB0(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168B2AA4);
}

uint64_t tlv::parseV<cat::tlv::ResponsePackingFormat>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168B2AFC(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168B2AF0);
}

uint64_t tlv::parseV<cat::tlv::ResponseLength>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  const unsigned __int8 *v4;
  int v5;
  int v6;

  v3 = (unsigned __int8 *)*a1;
  v4 = (const unsigned __int8 *)(*a1 + a2);
  tlv::throwIfNotEnoughBytes(*a1, v4, 1uLL);
  v5 = *v3;
  tlv::throwIfNotEnoughBytes((unint64_t)(v3 + 1), v4, 1uLL);
  v6 = v3[1];
  *a1 = (unint64_t)(v3 + 2);
  return v5 | (v6 << 8);
}

void sub_2168B2B74(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168B2B60);
}

uint64_t tlv::parseV<cat::tlv::ShowUserInput>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168B2BC0(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168B2BB4);
}

unint64_t tlv::parseV<cat::tlv::DefaultText>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  unint64_t result;

  *a3 = 0u;
  a3[1] = 0u;
  result = cat::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), (uint64_t)a3);
  *a1 = result;
  return result;
}

void sub_2168B2C10(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168B2C04);
}

void sub_2168B2C20(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 31) < 0)
    operator delete(*(void **)(v1 + 8));
  _Unwind_Resume(exception_object);
}

unint64_t tlv::parseV<cat::tlv::Alpha>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  unint64_t result;

  *a3 = 0u;
  a3[1] = 0u;
  result = cat::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), (uint64_t)a3);
  *a1 = result;
  return result;
}

void sub_2168B2C78(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168B2C6CLL);
}

void sub_2168B2C88(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 31) < 0)
    operator delete(*(void **)(v1 + 8));
  _Unwind_Resume(exception_object);
}

uint64_t tlv::parseV<cat::tlv::Tone>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168B2CDC(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168B2CD0);
}

uint64_t tlv::parseV<cat::tlv::SoftkeySelection>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168B2D28(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168B2D1CLL);
}

unint64_t cat::tlv::parseField(unsigned __int8 *a1, const unsigned __int8 *a2, uint64_t *a3)
{
  unint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t result;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  v7 = *a1;
  v6 = (unint64_t)(a1 + 1);
  std::vector<cat::tlv::Item>::resize(a3, v7);
  v8 = *a3;
  v9 = a3[1];
  while (1)
  {
    result = v6;
    if (v8 == v9)
      break;
    v6 = vs::tlv::parseField(v6, a2, v8);
    v8 += 32;
  }
  return result;
}

unint64_t tlv::parseV<cat::tlv::Items>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  unint64_t result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = cat::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = (unsigned __int8 *)result;
  return result;
}

void sub_2168B2DE8(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168B2DD8);
}

void sub_2168B2DF8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::vector<vs::tlv::RemoteNumberListItem>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

uint64_t tlv::parseV<cat::tlv::DefaultItem>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168B2E48(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168B2E3CLL);
}

unsigned __int8 *cat::tlv::parseField(unsigned __int8 *a1, const unsigned __int8 *a2, std::vector<unsigned int> *a3)
{
  unsigned __int8 *v6;
  unsigned int v7;
  std::vector<unsigned int>::pointer end;
  std::vector<unsigned int>::pointer begin;
  unsigned int v10;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  v7 = *a1;
  v6 = a1 + 1;
  std::vector<unsigned int>::resize(a3, v7);
  begin = a3->__begin_;
  end = a3->__end_;
  while (begin != end)
  {
    tlv::throwIfNotEnoughBytes((unint64_t)v6, a2, 1uLL);
    v10 = *v6++;
    *begin++ = v10;
  }
  return v6;
}

unsigned __int8 *tlv::parseV<cat::tlv::NextActionIndicatorList>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, std::vector<unsigned int> *a3@<X8>)
{
  unsigned __int8 *result;

  a3->__begin_ = 0;
  a3->__end_ = 0;
  a3->__end_cap_.__value_ = 0;
  result = cat::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = result;
  return result;
}

void sub_2168B2F04(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168B2EF8);
}

void sub_2168B2F14(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

std::string::value_type *tlv::parseV<cat::tlv::SmsTpdu>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, std::string *a3@<X8>)
{
  std::string::value_type *result;

  a3->__r_.__value_.__r.__words[0] = 0;
  a3->__r_.__value_.__l.__size_ = 0;
  a3->__r_.__value_.__r.__words[2] = 0;
  result = wds::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), a3);
  *a1 = (unint64_t)result;
  return result;
}

void sub_2168B2F6C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168B2F60);
}

void sub_2168B2F7C(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

uint64_t tlv::parseV<cat::tlv::IsCDMASms>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168B2FD0(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168B2FC4);
}

std::string::value_type *tlv::parseV<cat::tlv::Address>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  std::string::value_type *result;

  *a3 = 0u;
  a3[1] = 0u;
  result = vs::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), (uint64_t)a3);
  *a1 = (unint64_t)result;
  return result;
}

void sub_2168B3020(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168B3014);
}

void sub_2168B3030(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 31) < 0)
    operator delete(*(void **)(v1 + 8));
  _Unwind_Resume(exception_object);
}

uint64_t tlv::size<cat::tlv::Address>(uint64_t a1)
{
  uint64_t v1;

  v1 = *(unsigned __int8 *)(a1 + 31);
  if ((v1 & 0x80u) != 0)
    v1 = *(_QWORD *)(a1 + 16);
  return v1 + 6;
}

void *tlv::writeV<cat::tlv::Address>(_BYTE **a1, uint64_t a2)
{
  _BYTE *v4;
  uint64_t v5;
  char *v6;
  size_t v7;
  size_t v8;
  const void *v9;
  size_t v10;
  void *result;
  uint64_t v12;

  v4 = *a1;
  *v4 = *(_BYTE *)a2;
  v4[1] = *(_BYTE *)(a2 + 1);
  LOBYTE(v5) = *(_BYTE *)(a2 + 31);
  if ((v5 & 0x80u) != 0)
    v5 = *(_QWORD *)(a2 + 16);
  v6 = v4 + 3;
  v4[2] = v5;
  v7 = *(unsigned __int8 *)(a2 + 31);
  v8 = *(_QWORD *)(a2 + 16);
  if ((v7 & 0x80u) == 0)
    v9 = (const void *)(a2 + 8);
  else
    v9 = *(const void **)(a2 + 8);
  if ((v7 & 0x80u) == 0)
    v10 = v7;
  else
    v10 = v8;
  result = memcpy(v6, v9, v10);
  v12 = *(unsigned __int8 *)(a2 + 31);
  if ((v12 & 0x80u) != 0)
    v12 = *(_QWORD *)(a2 + 16);
  *a1 = &v6[v12];
  return result;
}

std::string::value_type *tlv::parseV<cat::tlv::Subaddress>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, std::string *a3@<X8>)
{
  std::string::value_type *result;

  a3->__r_.__value_.__r.__words[0] = 0;
  a3->__r_.__value_.__l.__size_ = 0;
  a3->__r_.__value_.__r.__words[2] = 0;
  result = wds::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), a3);
  *a1 = (unint64_t)result;
  return result;
}

void sub_2168B3140(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168B3134);
}

void sub_2168B3150(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

std::string::value_type *cat::tlv::parseField(unint64_t a1, const unsigned __int8 *a2, uint64_t a3)
{
  std::string::value_type *v5;
  unint64_t v6;

  v5 = (std::string::value_type *)a1;
  tlv::throwIfNotEnoughBytes(a1, a2, 1uLL);
  *(_BYTE *)a3 = *v5;
  tlv::throwIfNotEnoughBytes((unint64_t)(v5 + 1), a2, 1uLL);
  *(_BYTE *)(a3 + 1) = v5[1];
  tlv::throwIfNotEnoughBytes((unint64_t)(v5 + 2), a2, 1uLL);
  v6 = v5[2];
  v5 += 3;
  tlv::throwIfNotEnoughBytes((unint64_t)v5, a2, v6);
  std::string::__assign_trivial[abi:ne180100]<unsigned char const*,unsigned char const*>((std::string *)(a3 + 8), v5, &v5[v6], v6);
  return &v5[v6];
}

std::string::value_type *tlv::parseV<cat::tlv::USSDString>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  std::string::value_type *result;

  *a3 = 0u;
  a3[1] = 0u;
  result = cat::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), (uint64_t)a3);
  *a1 = (unint64_t)result;
  return result;
}

void sub_2168B3244(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168B3238);
}

void sub_2168B3254(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 31) < 0)
    operator delete(*(void **)(v1 + 8));
  _Unwind_Resume(exception_object);
}

uint64_t tlv::parseV<cat::tlv::NotificationRequired>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168B32A8(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168B329CLL);
}

uint64_t tlv::parseV<cat::tlv::ResponseType>(unint64_t *a1, int a2)
{
  unsigned int *v3;
  uint64_t result;

  v3 = (unsigned int *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 4uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168B32F4(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168B32E8);
}

std::string::value_type *tlv::parseV<cat::tlv::RpAddress>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  std::string::value_type *result;

  *a3 = 0u;
  a3[1] = 0u;
  result = vs::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), (uint64_t)a3);
  *a1 = (unint64_t)result;
  return result;
}

void sub_2168B3344(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168B3338);
}

void sub_2168B3354(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 31) < 0)
    operator delete(*(void **)(v1 + 8));
  _Unwind_Resume(exception_object);
}

std::string::value_type *tlv::parseV<cat::tlv::TpAddress>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  std::string::value_type *result;

  *a3 = 0u;
  a3[1] = 0u;
  result = vs::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), (uint64_t)a3);
  *a1 = (unint64_t)result;
  return result;
}

void sub_2168B33AC(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168B33A0);
}

void sub_2168B33BC(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 31) < 0)
    operator delete(*(void **)(v1 + 8));
  _Unwind_Resume(exception_object);
}

uint64_t tlv::parseV<cat::tlv::Slot>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168B3410(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168B3404);
}

uint64_t tlv::parseV<cat::tlv::Presentation>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168B345C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168B3450);
}

std::string::value_type *tlv::parseV<cat::tlv::DTMF>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, std::string *a3@<X8>)
{
  std::string::value_type *result;

  a3->__r_.__value_.__r.__words[0] = 0;
  a3->__r_.__value_.__l.__size_ = 0;
  a3->__r_.__value_.__r.__words[2] = 0;
  result = wds::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), a3);
  *a1 = (unint64_t)result;
  return result;
}

void sub_2168B34AC(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168B34A0);
}

void sub_2168B34BC(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

uint64_t tlv::parseV<cat::tlv::CallSetupRequirement>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168B3510(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168B3504);
}

unsigned __int8 *cat::tlv::parseField(unsigned __int8 *a1, const unsigned __int8 *a2, uint64_t a3)
{
  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  *(_DWORD *)a3 = *a1;
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 1), a2, 1uLL);
  *(_BYTE *)(a3 + 4) = a1[1];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 2), a2, 1uLL);
  *(_BYTE *)(a3 + 5) = a1[2];
  return a1 + 3;
}

uint64_t tlv::parseV<cat::tlv::Redial>(unsigned __int8 **a1, int a2)
{
  uint64_t v3;

  v3 = 0;
  *a1 = cat::tlv::parseField(*a1, &(*a1)[a2], (uint64_t)&v3);
  return v3;
}

void sub_2168B35D4(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168B35C0);
}

unint64_t tlv::parseV<cat::tlv::UserConfirmationAlpha>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  unint64_t result;

  *a3 = 0u;
  a3[1] = 0u;
  result = cat::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), (uint64_t)a3);
  *a1 = result;
  return result;
}

void sub_2168B3620(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168B3614);
}

void sub_2168B3630(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 31) < 0)
    operator delete(*(void **)(v1 + 8));
  _Unwind_Resume(exception_object);
}

unint64_t tlv::parseV<cat::tlv::SetupCallDisplayAlpha>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  unint64_t result;

  *a3 = 0u;
  a3[1] = 0u;
  result = cat::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), (uint64_t)a3);
  *a1 = result;
  return result;
}

void sub_2168B3688(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168B367CLL);
}

void sub_2168B3698(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 31) < 0)
    operator delete(*(void **)(v1 + 8));
  _Unwind_Resume(exception_object);
}

uint64_t tlv::parseV<cat::tlv::PackingRequired>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168B36EC(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168B36E0);
}

uint64_t tlv::parseV<cat::tlv::SpecificLanguageNotification>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168B3738(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168B372CLL);
}

uint64_t tlv::parseV<cat::tlv::Language>(unint64_t *a1, int a2)
{
  unsigned __int16 *v3;
  uint64_t result;

  v3 = (unsigned __int16 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 2uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168B3784(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168B3778);
}

uint64_t tlv::size<cat::tlv::TerminalResponse>(uint64_t a1)
{
  return *(_QWORD *)(a1 + 24) - *(_QWORD *)(a1 + 16) + 11;
}

void *tlv::writeV<cat::tlv::TerminalResponse>(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  void *result;

  v4 = *a1;
  *(_DWORD *)v4 = *(_DWORD *)a2;
  *(_BYTE *)(v4 + 4) = *(_BYTE *)(a2 + 4);
  *(_BYTE *)(v4 + 5) = *(_BYTE *)(a2 + 5);
  *(_BYTE *)(v4 + 6) = *(_DWORD *)(a2 + 8);
  v5 = v4 + 8;
  *(_BYTE *)(v4 + 7) = *(_BYTE *)(a2 + 24) - *(_DWORD *)(a2 + 16);
  result = memcpy((void *)(v4 + 8), *(const void **)(a2 + 16), *(_QWORD *)(a2 + 24) - *(_QWORD *)(a2 + 16));
  *a1 = v5 + *(_QWORD *)(a2 + 24) - *(_QWORD *)(a2 + 16);
  return result;
}

uint64_t tlv::size<cat::tlv::GetInkeyExtraInfo>(uint64_t a1)
{
  uint64_t v1;

  v1 = *(unsigned __int8 *)(a1 + 31);
  if ((v1 & 0x80u) != 0)
    v1 = *(_QWORD *)(a1 + 16);
  return v1 + 7;
}

void *tlv::writeV<cat::tlv::GetInkeyExtraInfo>(_BYTE **a1, uint64_t a2)
{
  _BYTE *v4;
  uint64_t v5;
  char *v6;
  size_t v7;
  size_t v8;
  const void *v9;
  size_t v10;
  void *result;
  uint64_t v12;

  v4 = *a1;
  *v4 = *(_DWORD *)a2;
  v4[1] = *(_BYTE *)(a2 + 4);
  v4[2] = *(_BYTE *)(a2 + 5);
  LOBYTE(v5) = *(_BYTE *)(a2 + 31);
  if ((v5 & 0x80u) != 0)
    v5 = *(_QWORD *)(a2 + 16);
  v6 = v4 + 4;
  v4[3] = v5;
  v7 = *(unsigned __int8 *)(a2 + 31);
  v8 = *(_QWORD *)(a2 + 16);
  if ((v7 & 0x80u) == 0)
    v9 = (const void *)(a2 + 8);
  else
    v9 = *(const void **)(a2 + 8);
  if ((v7 & 0x80u) == 0)
    v10 = v7;
  else
    v10 = v8;
  result = memcpy(v6, v9, v10);
  v12 = *(unsigned __int8 *)(a2 + 31);
  if ((v12 & 0x80u) != 0)
    v12 = *(_QWORD *)(a2 + 16);
  *a1 = &v6[v12];
  return result;
}

uint64_t tlv::parseV<cat::tlv::CallControlResult>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168B3924(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168B3918);
}

char *tlv::parseV<cat::tlv::SmsPPUiccAck>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  char *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = wds::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), a3);
  *a1 = (unint64_t)result;
  return result;
}

void sub_2168B3974(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168B3968);
}

void sub_2168B3984(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<cat::tlv::Item>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;

  v3 = a1[1];
  v4 = (v3 - *a1) >> 5;
  if (a2 <= v4)
  {
    if (a2 < v4)
    {
      v5 = *a1 + 32 * a2;
      while (v3 != v5)
      {
        if (*(char *)(v3 - 1) < 0)
          operator delete(*(void **)(v3 - 24));
        v3 -= 32;
      }
      a1[1] = v5;
    }
  }
  else
  {
    std::vector<cat::tlv::Item>::__append(a1, a2 - v4);
  }
}

void std::vector<cat::tlv::Item>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (a2 <= (v6 - v7) >> 5)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 32 * a2);
      v7 += 32 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = v7 - *a1;
    v9 = a2 + (v8 >> 5);
    if (v9 >> 59)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 5;
    v11 = v5 - *a1;
    if (v11 >> 4 > v9)
      v9 = v11 >> 4;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFE0)
      v12 = 0x7FFFFFFFFFFFFFFLL;
    else
      v12 = v9;
    v18 = v4;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<vs::tlv::RemoteNumberListItem>>(v4, v12);
    else
      v13 = 0;
    v14 = v13;
    v15 = &v13[32 * v10];
    v17 = &v13[32 * v12];
    bzero(v15, 32 * a2);
    v16 = &v15[32 * a2];
    std::vector<cat::tlv::Item>::__swap_out_circular_buffer(a1, &v14);
    std::__split_buffer<vs::tlv::RemoteNumberListItem>::~__split_buffer((uint64_t)&v14);
  }
}

void sub_2168B3B0C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<vs::tlv::RemoteNumberListItem>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<cat::tlv::Item>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<cat::tlv::Item>,std::reverse_iterator<cat::tlv::Item*>,std::reverse_iterator<cat::tlv::Item*>,std::reverse_iterator<cat::tlv::Item*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<cat::tlv::Item>,std::reverse_iterator<cat::tlv::Item*>,std::reverse_iterator<cat::tlv::Item*>,std::reverse_iterator<cat::tlv::Item*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v8;
  char v9;
  __int128 v10;
  uint64_t v11;
  _QWORD v13[3];
  uint64_t v14;
  __int128 v15;
  __int128 v16;

  v7 = a7;
  *(_QWORD *)&v16 = a6;
  *((_QWORD *)&v16 + 1) = a7;
  v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  v14 = 0;
  if (a3 == a5)
  {
    v11 = a6;
  }
  else
  {
    v8 = a7;
    do
    {
      v9 = *(_BYTE *)(a3 - 32);
      a3 -= 32;
      *(_BYTE *)(v8 - 32) = v9;
      v8 -= 32;
      v10 = *(_OWORD *)(a3 + 8);
      *(_QWORD *)(v8 + 24) = *(_QWORD *)(a3 + 24);
      *(_OWORD *)(v8 + 8) = v10;
      *(_QWORD *)(a3 + 16) = 0;
      *(_QWORD *)(a3 + 24) = 0;
      *(_QWORD *)(a3 + 8) = 0;
      v7 -= 32;
    }
    while (a3 != a5);
    *((_QWORD *)&v16 + 1) = v8;
    v11 = v16;
  }
  LOBYTE(v14) = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<cat::tlv::Item>,std::reverse_iterator<cat::tlv::Item*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v13);
  return v11;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<cat::tlv::Item>,std::reverse_iterator<cat::tlv::Item*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<vs::tlv::RemoteNumberListItem>,std::reverse_iterator<vs::tlv::RemoteNumberListItem*>>::operator()[abi:ne180100](a1);
  return a1;
}

_DWORD *qos::tlv::parseField(_DWORD *a1, const unsigned __int8 *a2, _DWORD *a3)
{
  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 4uLL);
  *a3 = *a1;
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 1), a2, 4uLL);
  a3[1] = a1[1];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 2), a2, 4uLL);
  a3[2] = a1[2];
  return a1 + 3;
}

uint64_t qos::tlv::parseField(qos::tlv *this, unsigned __int8 *a2, unsigned __int8 *a3, qos::tlv::FlowSpec *a4)
{
  tlv *v6;
  unsigned __int8 *v7;
  unsigned __int8 *v8;
  unsigned __int8 *v9;
  tlv *v10;
  unsigned __int8 *v11;
  unsigned __int8 *v12;
  tlv *v13;
  tlv *v14;
  tlv *v15;
  tlv *v16;
  tlv *v17;
  tlv *v18;
  tlv *v19;
  tlv *v20;
  tlv *v21;

  v6 = (tlv *)tlv::parseField<(unsigned char)17,qos::tlv::IpFlowTrafficClass>(this, a2, a3);
  v7 = (unsigned __int8 *)tlv::parseField<(unsigned char)19,qos::tlv::IpFlowDataRateTokenBucket>(v6, a2, a3 + 4);
  if (!a3[20])
    a3[20] = 1;
  *((_QWORD *)a3 + 3) = 0;
  v8 = tlv::parseField<(unsigned char)18,qos::tlv::IpFlowDataRateMinMax>(v7, a2, (_DWORD *)a3 + 6);
  v9 = tlv::parseField<(unsigned char)32,qos::tlv::IpFlowDataRateMinMaxEx>(v8, a2, (_QWORD *)a3 + 4);
  v10 = (tlv *)tlv::parseField<(unsigned char)20,qos::tlv::IpFlowLatency>((tlv *)v9, a2, (uint64_t)(a3 + 64));
  v11 = (unsigned __int8 *)tlv::parseField<(unsigned char)21,qos::tlv::IpFlowJitter>(v10, a2, (uint64_t)(a3 + 72));
  if (!a3[80])
    a3[80] = 1;
  *(_DWORD *)(a3 + 82) = 0;
  v12 = tlv::parseField<(unsigned char)22,qos::tlv::IpFlowPacketErrorRate>(v11, a2, (_WORD *)a3 + 41);
  v13 = (tlv *)tlv::parseField<(unsigned char)23,qos::tlv::IpFlowPacketSize>((tlv *)v12, a2, (uint64_t)(a3 + 88));
  v14 = (tlv *)tlv::parseField<(unsigned char)24,qos::tlv::IpFlowPacketSize>(v13, a2, (uint64_t)(a3 + 96));
  v15 = (tlv *)tlv::parseField<(unsigned char)25,qos::tlv::IpFlowBitErrorRate>(v14, a2, a3 + 104);
  v16 = (tlv *)tlv::parseField<(unsigned char)26,qos::tlv::IpFlowPriority>(v15, a2, a3 + 106);
  v17 = (tlv *)tlv::parseField<(unsigned char)27,qos::tlv::IpFlowProfileId>(v16, a2, (uint64_t)(a3 + 108));
  v18 = (tlv *)tlv::parseField<(unsigned char)28,qos::tlv::IpFlowPriority>(v17, a2, a3 + 112);
  v19 = (tlv *)tlv::parseField<(unsigned char)29,qos::tlv::IpFlow3GPPIMCNFlag>(v18, a2, a3 + 114);
  v20 = (tlv *)tlv::parseField<(unsigned char)30,qos::tlv::IpFlow3GPPSignalingIndication>(v19, a2, a3 + 116);
  v21 = (tlv *)tlv::parseField<(unsigned char)31,qos::tlv::LTEQoSClassIdentifier>(v20, a2, a3 + 118);
  return tlv::parseField<(unsigned char)16,qos::tlv::IpFlowIndex>(v21, a2, a3 + 120);
}

void sub_2168B3E08(void *a1)
{
  uint64_t v1;

  __cxa_begin_catch(a1);
  if (*(_BYTE *)(v1 + 80))
    *(_BYTE *)(v1 + 80) = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168B3D80);
}

void sub_2168B3E20(void *a1)
{
  uint64_t v1;

  __cxa_begin_catch(a1);
  if (*(_BYTE *)(v1 + 20))
    *(_BYTE *)(v1 + 20) = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168B3D2CLL);
}

uint64_t tlv::parseField<(unsigned char)17,qos::tlv::IpFlowTrafficClass>(tlv *this, unsigned __int8 *a2, _BYTE *a3)
{
  unint64_t v6;
  unint64_t v7;
  tlv::TlvParseException *exception;

  if (!*a3)
    *a3 = 1;
  a3[1] = 0;
  tlv::throwIfNotEnoughBytes((unint64_t)this, a2, 3uLL);
  v6 = *(unsigned __int8 *)this;
  if (v6 != 17)
  {
    exception = (tlv::TlvParseException *)__cxa_allocate_exception(0x10uLL);
    tlv::TlvParseException::TlvParseException(exception, 0x11uLL, v6);
  }
  v7 = *(unsigned __int16 *)((char *)this + 1);
  tlv::throwIfNotEnoughBytes((unint64_t)this + 3, a2, v7);
  tlv::throwIfNotEnoughBytes((unint64_t)this + 3, (const unsigned __int8 *)this + v7 + 3, 1uLL);
  a3[1] = *((_BYTE *)this + 3);
  return (uint64_t)this + 4;
}

void sub_2168B3F08(_Unwind_Exception *a1, int a2)
{
  _BYTE *v2;
  void *v3;

  __cxa_free_exception(v3);
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    if (*v2)
      *v2 = 0;
    __cxa_end_catch();
    JUMPOUT(0x2168B3EBCLL);
  }
  _Unwind_Resume(a1);
}

_DWORD *tlv::parseField<(unsigned char)19,qos::tlv::IpFlowDataRateTokenBucket>(tlv *this, unsigned __int8 *a2, unsigned __int8 *a3)
{
  int v5;
  _DWORD *v6;
  unint64_t v7;
  unint64_t v9;
  tlv::TlvParseException *exception;

  v5 = *a3;
  *((_DWORD *)a3 + 1) = 0;
  v6 = a3 + 4;
  *((_QWORD *)a3 + 1) = 0;
  if (!v5)
    *a3 = 1;
  tlv::throwIfNotEnoughBytes((unint64_t)this, a2, 3uLL);
  if (*(_BYTE *)this != 19)
  {
    v9 = *(unsigned __int8 *)this;
    exception = (tlv::TlvParseException *)__cxa_allocate_exception(0x10uLL);
    tlv::TlvParseException::TlvParseException(exception, 0x13uLL, v9);
  }
  v7 = *(unsigned __int16 *)((char *)this + 1);
  tlv::throwIfNotEnoughBytes((unint64_t)this + 3, a2, v7);
  return qos::tlv::parseField((tlv *)((char *)this + 3), (const unsigned __int8 *)this + v7 + 3, v6);
}

void sub_2168B4020(_Unwind_Exception *a1, int a2)
{
  _BYTE *v2;
  void *v3;

  __cxa_free_exception(v3);
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    if (*v2)
      *v2 = 0;
    __cxa_end_catch();
    JUMPOUT(0x2168B3FD0);
  }
  _Unwind_Resume(a1);
}

unsigned __int8 *tlv::parseField<(unsigned char)32,qos::tlv::IpFlowDataRateMinMaxEx>(unsigned __int8 *a1, const unsigned __int8 *a2, _QWORD *a3)
{
  unint64_t v6;
  unint64_t v8;
  tlv::TlvParseException *exception;
  void *__p;
  void *v11;
  uint64_t v12;

  __p = 0;
  v11 = 0;
  v12 = 0;
  boost::optional_detail::optional_base<tlv::NestedTlv<(unsigned char)32,qos::tlv::IpFlowDataRateMinMaxEx>>::assign_expr<qos::tlv::IpFlowDataRateMinMaxEx,qos::tlv::IpFlowDataRateMinMaxEx>(a3, (uint64_t)&__p);
  if (__p)
  {
    v11 = __p;
    operator delete(__p);
  }
  if (!*(_BYTE *)a3)
    __assert_rtn("get", "optional.hpp", 1212, "this->is_initialized()");
  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 3uLL);
  if (*a1 != 32)
  {
    v8 = *a1;
    exception = (tlv::TlvParseException *)__cxa_allocate_exception(0x10uLL);
    tlv::TlvParseException::TlvParseException(exception, 0x20uLL, v8);
  }
  v6 = *(unsigned __int16 *)(a1 + 1);
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 3), a2, v6);
  std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(a3 + 1, (char *)a1 + 3, (char *)&a1[v6 + 3], v6);
  return &a1[v6 + 3];
}

void sub_2168B417C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  uint64_t v11;
  void *v12;
  void *v15;

  __cxa_free_exception(v12);
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    if (*(_BYTE *)v11)
    {
      v15 = *(void **)(v11 + 8);
      if (v15)
      {
        *(_QWORD *)(v11 + 16) = v15;
        operator delete(v15);
      }
      *(_BYTE *)v11 = 0;
    }
    __cxa_end_catch();
    JUMPOUT(0x2168B4104);
  }
  _Unwind_Resume(a1);
}

uint64_t tlv::parseField<(unsigned char)20,qos::tlv::IpFlowLatency>(tlv *this, unsigned __int8 *a2, uint64_t a3)
{
  unint64_t v6;
  unint64_t v7;
  tlv::TlvParseException *exception;

  if (!*(_BYTE *)a3)
    *(_BYTE *)a3 = 1;
  *(_DWORD *)(a3 + 4) = 0;
  tlv::throwIfNotEnoughBytes((unint64_t)this, a2, 3uLL);
  v6 = *(unsigned __int8 *)this;
  if (v6 != 20)
  {
    exception = (tlv::TlvParseException *)__cxa_allocate_exception(0x10uLL);
    tlv::TlvParseException::TlvParseException(exception, 0x14uLL, v6);
  }
  v7 = *(unsigned __int16 *)((char *)this + 1);
  tlv::throwIfNotEnoughBytes((unint64_t)this + 3, a2, v7);
  tlv::throwIfNotEnoughBytes((unint64_t)this + 3, (const unsigned __int8 *)this + v7 + 3, 4uLL);
  *(_DWORD *)(a3 + 4) = *(_DWORD *)((char *)this + 3);
  return (uint64_t)this + 7;
}

void sub_2168B42C4(_Unwind_Exception *a1, int a2)
{
  _BYTE *v2;
  void *v3;

  __cxa_free_exception(v3);
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    if (*v2)
      *v2 = 0;
    __cxa_end_catch();
    JUMPOUT(0x2168B4278);
  }
  _Unwind_Resume(a1);
}

uint64_t tlv::parseField<(unsigned char)21,qos::tlv::IpFlowJitter>(tlv *this, unsigned __int8 *a2, uint64_t a3)
{
  unint64_t v6;
  unint64_t v7;
  tlv::TlvParseException *exception;

  if (!*(_BYTE *)a3)
    *(_BYTE *)a3 = 1;
  *(_DWORD *)(a3 + 4) = 0;
  tlv::throwIfNotEnoughBytes((unint64_t)this, a2, 3uLL);
  v6 = *(unsigned __int8 *)this;
  if (v6 != 21)
  {
    exception = (tlv::TlvParseException *)__cxa_allocate_exception(0x10uLL);
    tlv::TlvParseException::TlvParseException(exception, 0x15uLL, v6);
  }
  v7 = *(unsigned __int16 *)((char *)this + 1);
  tlv::throwIfNotEnoughBytes((unint64_t)this + 3, a2, v7);
  tlv::throwIfNotEnoughBytes((unint64_t)this + 3, (const unsigned __int8 *)this + v7 + 3, 4uLL);
  *(_DWORD *)(a3 + 4) = *(_DWORD *)((char *)this + 3);
  return (uint64_t)this + 7;
}

void sub_2168B43D8(_Unwind_Exception *a1, int a2)
{
  _BYTE *v2;
  void *v3;

  __cxa_free_exception(v3);
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    if (*v2)
      *v2 = 0;
    __cxa_end_catch();
    JUMPOUT(0x2168B438CLL);
  }
  _Unwind_Resume(a1);
}

uint64_t tlv::parseField<(unsigned char)23,qos::tlv::IpFlowPacketSize>(tlv *this, unsigned __int8 *a2, uint64_t a3)
{
  unint64_t v6;
  unint64_t v7;
  tlv::TlvParseException *exception;

  if (!*(_BYTE *)a3)
    *(_BYTE *)a3 = 1;
  *(_DWORD *)(a3 + 4) = 0;
  tlv::throwIfNotEnoughBytes((unint64_t)this, a2, 3uLL);
  v6 = *(unsigned __int8 *)this;
  if (v6 != 23)
  {
    exception = (tlv::TlvParseException *)__cxa_allocate_exception(0x10uLL);
    tlv::TlvParseException::TlvParseException(exception, 0x17uLL, v6);
  }
  v7 = *(unsigned __int16 *)((char *)this + 1);
  tlv::throwIfNotEnoughBytes((unint64_t)this + 3, a2, v7);
  tlv::throwIfNotEnoughBytes((unint64_t)this + 3, (const unsigned __int8 *)this + v7 + 3, 4uLL);
  *(_DWORD *)(a3 + 4) = *(_DWORD *)((char *)this + 3);
  return (uint64_t)this + 7;
}

void sub_2168B44EC(_Unwind_Exception *a1, int a2)
{
  _BYTE *v2;
  void *v3;

  __cxa_free_exception(v3);
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    if (*v2)
      *v2 = 0;
    __cxa_end_catch();
    JUMPOUT(0x2168B44A0);
  }
  _Unwind_Resume(a1);
}

uint64_t tlv::parseField<(unsigned char)24,qos::tlv::IpFlowPacketSize>(tlv *this, unsigned __int8 *a2, uint64_t a3)
{
  unint64_t v6;
  unint64_t v7;
  tlv::TlvParseException *exception;

  if (!*(_BYTE *)a3)
    *(_BYTE *)a3 = 1;
  *(_DWORD *)(a3 + 4) = 0;
  tlv::throwIfNotEnoughBytes((unint64_t)this, a2, 3uLL);
  v6 = *(unsigned __int8 *)this;
  if (v6 != 24)
  {
    exception = (tlv::TlvParseException *)__cxa_allocate_exception(0x10uLL);
    tlv::TlvParseException::TlvParseException(exception, 0x18uLL, v6);
  }
  v7 = *(unsigned __int16 *)((char *)this + 1);
  tlv::throwIfNotEnoughBytes((unint64_t)this + 3, a2, v7);
  tlv::throwIfNotEnoughBytes((unint64_t)this + 3, (const unsigned __int8 *)this + v7 + 3, 4uLL);
  *(_DWORD *)(a3 + 4) = *(_DWORD *)((char *)this + 3);
  return (uint64_t)this + 7;
}

void sub_2168B4600(_Unwind_Exception *a1, int a2)
{
  _BYTE *v2;
  void *v3;

  __cxa_free_exception(v3);
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    if (*v2)
      *v2 = 0;
    __cxa_end_catch();
    JUMPOUT(0x2168B45B4);
  }
  _Unwind_Resume(a1);
}

uint64_t tlv::parseField<(unsigned char)25,qos::tlv::IpFlowBitErrorRate>(tlv *this, unsigned __int8 *a2, _BYTE *a3)
{
  unint64_t v6;
  unint64_t v7;
  tlv::TlvParseException *exception;

  if (!*a3)
    *a3 = 1;
  a3[1] = 0;
  tlv::throwIfNotEnoughBytes((unint64_t)this, a2, 3uLL);
  v6 = *(unsigned __int8 *)this;
  if (v6 != 25)
  {
    exception = (tlv::TlvParseException *)__cxa_allocate_exception(0x10uLL);
    tlv::TlvParseException::TlvParseException(exception, 0x19uLL, v6);
  }
  v7 = *(unsigned __int16 *)((char *)this + 1);
  tlv::throwIfNotEnoughBytes((unint64_t)this + 3, a2, v7);
  tlv::throwIfNotEnoughBytes((unint64_t)this + 3, (const unsigned __int8 *)this + v7 + 3, 1uLL);
  a3[1] = *((_BYTE *)this + 3);
  return (uint64_t)this + 4;
}

void sub_2168B4714(_Unwind_Exception *a1, int a2)
{
  _BYTE *v2;
  void *v3;

  __cxa_free_exception(v3);
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    if (*v2)
      *v2 = 0;
    __cxa_end_catch();
    JUMPOUT(0x2168B46C8);
  }
  _Unwind_Resume(a1);
}

uint64_t tlv::parseField<(unsigned char)26,qos::tlv::IpFlowPriority>(tlv *this, unsigned __int8 *a2, _BYTE *a3)
{
  unint64_t v6;
  unint64_t v7;
  tlv::TlvParseException *exception;

  if (!*a3)
    *a3 = 1;
  a3[1] = 0;
  tlv::throwIfNotEnoughBytes((unint64_t)this, a2, 3uLL);
  v6 = *(unsigned __int8 *)this;
  if (v6 != 26)
  {
    exception = (tlv::TlvParseException *)__cxa_allocate_exception(0x10uLL);
    tlv::TlvParseException::TlvParseException(exception, 0x1AuLL, v6);
  }
  v7 = *(unsigned __int16 *)((char *)this + 1);
  tlv::throwIfNotEnoughBytes((unint64_t)this + 3, a2, v7);
  tlv::throwIfNotEnoughBytes((unint64_t)this + 3, (const unsigned __int8 *)this + v7 + 3, 1uLL);
  a3[1] = *((_BYTE *)this + 3);
  return (uint64_t)this + 4;
}

void sub_2168B4828(_Unwind_Exception *a1, int a2)
{
  _BYTE *v2;
  void *v3;

  __cxa_free_exception(v3);
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    if (*v2)
      *v2 = 0;
    __cxa_end_catch();
    JUMPOUT(0x2168B47DCLL);
  }
  _Unwind_Resume(a1);
}

uint64_t tlv::parseField<(unsigned char)27,qos::tlv::IpFlowProfileId>(tlv *this, unsigned __int8 *a2, uint64_t a3)
{
  unint64_t v6;
  unint64_t v7;
  tlv::TlvParseException *exception;

  if (!*(_BYTE *)a3)
    *(_BYTE *)a3 = 1;
  *(_WORD *)(a3 + 2) = 0;
  tlv::throwIfNotEnoughBytes((unint64_t)this, a2, 3uLL);
  v6 = *(unsigned __int8 *)this;
  if (v6 != 27)
  {
    exception = (tlv::TlvParseException *)__cxa_allocate_exception(0x10uLL);
    tlv::TlvParseException::TlvParseException(exception, 0x1BuLL, v6);
  }
  v7 = *(unsigned __int16 *)((char *)this + 1);
  tlv::throwIfNotEnoughBytes((unint64_t)this + 3, a2, v7);
  tlv::throwIfNotEnoughBytes((unint64_t)this + 3, (const unsigned __int8 *)this + v7 + 3, 2uLL);
  *(_WORD *)(a3 + 2) = *(_WORD *)((char *)this + 3);
  return (uint64_t)this + 5;
}

void sub_2168B493C(_Unwind_Exception *a1, int a2)
{
  _BYTE *v2;
  void *v3;

  __cxa_free_exception(v3);
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    if (*v2)
      *v2 = 0;
    __cxa_end_catch();
    JUMPOUT(0x2168B48F0);
  }
  _Unwind_Resume(a1);
}

uint64_t tlv::parseField<(unsigned char)28,qos::tlv::IpFlowPriority>(tlv *this, unsigned __int8 *a2, _BYTE *a3)
{
  unint64_t v6;
  unint64_t v7;
  tlv::TlvParseException *exception;

  if (!*a3)
    *a3 = 1;
  a3[1] = 0;
  tlv::throwIfNotEnoughBytes((unint64_t)this, a2, 3uLL);
  v6 = *(unsigned __int8 *)this;
  if (v6 != 28)
  {
    exception = (tlv::TlvParseException *)__cxa_allocate_exception(0x10uLL);
    tlv::TlvParseException::TlvParseException(exception, 0x1CuLL, v6);
  }
  v7 = *(unsigned __int16 *)((char *)this + 1);
  tlv::throwIfNotEnoughBytes((unint64_t)this + 3, a2, v7);
  tlv::throwIfNotEnoughBytes((unint64_t)this + 3, (const unsigned __int8 *)this + v7 + 3, 1uLL);
  a3[1] = *((_BYTE *)this + 3);
  return (uint64_t)this + 4;
}

void sub_2168B4A50(_Unwind_Exception *a1, int a2)
{
  _BYTE *v2;
  void *v3;

  __cxa_free_exception(v3);
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    if (*v2)
      *v2 = 0;
    __cxa_end_catch();
    JUMPOUT(0x2168B4A04);
  }
  _Unwind_Resume(a1);
}

uint64_t tlv::parseField<(unsigned char)29,qos::tlv::IpFlow3GPPIMCNFlag>(tlv *this, unsigned __int8 *a2, _BYTE *a3)
{
  unint64_t v6;
  unint64_t v7;
  tlv::TlvParseException *exception;

  if (!*a3)
    *a3 = 1;
  a3[1] = 0;
  tlv::throwIfNotEnoughBytes((unint64_t)this, a2, 3uLL);
  v6 = *(unsigned __int8 *)this;
  if (v6 != 29)
  {
    exception = (tlv::TlvParseException *)__cxa_allocate_exception(0x10uLL);
    tlv::TlvParseException::TlvParseException(exception, 0x1DuLL, v6);
  }
  v7 = *(unsigned __int16 *)((char *)this + 1);
  tlv::throwIfNotEnoughBytes((unint64_t)this + 3, a2, v7);
  tlv::throwIfNotEnoughBytes((unint64_t)this + 3, (const unsigned __int8 *)this + v7 + 3, 1uLL);
  a3[1] = *((_BYTE *)this + 3);
  return (uint64_t)this + 4;
}

void sub_2168B4B64(_Unwind_Exception *a1, int a2)
{
  _BYTE *v2;
  void *v3;

  __cxa_free_exception(v3);
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    if (*v2)
      *v2 = 0;
    __cxa_end_catch();
    JUMPOUT(0x2168B4B18);
  }
  _Unwind_Resume(a1);
}

uint64_t tlv::parseField<(unsigned char)30,qos::tlv::IpFlow3GPPSignalingIndication>(tlv *this, unsigned __int8 *a2, _BYTE *a3)
{
  unint64_t v6;
  unint64_t v7;
  tlv::TlvParseException *exception;

  if (!*a3)
    *a3 = 1;
  a3[1] = 0;
  tlv::throwIfNotEnoughBytes((unint64_t)this, a2, 3uLL);
  v6 = *(unsigned __int8 *)this;
  if (v6 != 30)
  {
    exception = (tlv::TlvParseException *)__cxa_allocate_exception(0x10uLL);
    tlv::TlvParseException::TlvParseException(exception, 0x1EuLL, v6);
  }
  v7 = *(unsigned __int16 *)((char *)this + 1);
  tlv::throwIfNotEnoughBytes((unint64_t)this + 3, a2, v7);
  tlv::throwIfNotEnoughBytes((unint64_t)this + 3, (const unsigned __int8 *)this + v7 + 3, 1uLL);
  a3[1] = *((_BYTE *)this + 3);
  return (uint64_t)this + 4;
}

void sub_2168B4C78(_Unwind_Exception *a1, int a2)
{
  _BYTE *v2;
  void *v3;

  __cxa_free_exception(v3);
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    if (*v2)
      *v2 = 0;
    __cxa_end_catch();
    JUMPOUT(0x2168B4C2CLL);
  }
  _Unwind_Resume(a1);
}

uint64_t tlv::parseField<(unsigned char)31,qos::tlv::LTEQoSClassIdentifier>(tlv *this, unsigned __int8 *a2, _BYTE *a3)
{
  unint64_t v6;
  unint64_t v7;
  tlv::TlvParseException *exception;

  if (!*a3)
    *a3 = 1;
  a3[1] = 0;
  tlv::throwIfNotEnoughBytes((unint64_t)this, a2, 3uLL);
  v6 = *(unsigned __int8 *)this;
  if (v6 != 31)
  {
    exception = (tlv::TlvParseException *)__cxa_allocate_exception(0x10uLL);
    tlv::TlvParseException::TlvParseException(exception, 0x1FuLL, v6);
  }
  v7 = *(unsigned __int16 *)((char *)this + 1);
  tlv::throwIfNotEnoughBytes((unint64_t)this + 3, a2, v7);
  tlv::throwIfNotEnoughBytes((unint64_t)this + 3, (const unsigned __int8 *)this + v7 + 3, 1uLL);
  a3[1] = *((_BYTE *)this + 3);
  return (uint64_t)this + 4;
}

void sub_2168B4D8C(_Unwind_Exception *a1, int a2)
{
  _BYTE *v2;
  void *v3;

  __cxa_free_exception(v3);
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    if (*v2)
      *v2 = 0;
    __cxa_end_catch();
    JUMPOUT(0x2168B4D40);
  }
  _Unwind_Resume(a1);
}

uint64_t tlv::parseField<(unsigned char)16,qos::tlv::IpFlowIndex>(tlv *this, unsigned __int8 *a2, _BYTE *a3)
{
  unint64_t v6;
  unint64_t v7;
  tlv::TlvParseException *exception;

  if (!*a3)
    *a3 = 1;
  a3[1] = 0;
  tlv::throwIfNotEnoughBytes((unint64_t)this, a2, 3uLL);
  v6 = *(unsigned __int8 *)this;
  if (v6 != 16)
  {
    exception = (tlv::TlvParseException *)__cxa_allocate_exception(0x10uLL);
    tlv::TlvParseException::TlvParseException(exception, 0x10uLL, v6);
  }
  v7 = *(unsigned __int16 *)((char *)this + 1);
  tlv::throwIfNotEnoughBytes((unint64_t)this + 3, a2, v7);
  tlv::throwIfNotEnoughBytes((unint64_t)this + 3, (const unsigned __int8 *)this + v7 + 3, 1uLL);
  a3[1] = *((_BYTE *)this + 3);
  return (uint64_t)this + 4;
}

void sub_2168B4EA0(_Unwind_Exception *a1, int a2)
{
  _BYTE *v2;
  void *v3;

  __cxa_free_exception(v3);
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    if (*v2)
      *v2 = 0;
    __cxa_end_catch();
    JUMPOUT(0x2168B4E54);
  }
  _Unwind_Resume(a1);
}

uint64_t qos::tlv::parseField(qos::tlv *this, unsigned __int8 *a2, const unsigned __int8 *a3, qos::tlv::QoSFilter *a4)
{
  tlv *v6;
  tlv *v7;
  unsigned __int8 *v8;
  unsigned __int8 *v9;
  unsigned __int8 *v10;
  unsigned __int8 *v11;
  unsigned __int8 *v12;
  unsigned __int8 *v13;
  unsigned __int8 *v14;
  unsigned __int8 *v15;
  unsigned __int8 *v16;
  unsigned __int8 *v17;
  unsigned __int8 *v18;
  int v19;
  unsigned __int8 *v20;
  int v21;
  unsigned __int8 *v22;
  unsigned __int8 *v23;
  unsigned __int8 *v24;
  unint64_t v25;
  unint64_t v26;
  tlv::TlvParseException *exception;

  v6 = (tlv *)tlv::parseField<(unsigned char)35,qos::tlv::FilterId>(this, a2, (uint64_t)a3);
  v7 = (tlv *)tlv::parseField<(unsigned char)34,qos::tlv::FilterPrecedence>(v6, a2, (uint64_t)(a3 + 4));
  v8 = (unsigned __int8 *)tlv::parseField<(unsigned char)33,qos::tlv::EspFilterSecurityPolicyIndex>(v7, a2, (uint64_t)(a3 + 8));
  if (!a3[16])
    *((_BYTE *)a3 + 16) = 1;
  *(_DWORD *)(a3 + 18) = 0;
  v9 = tlv::parseField<(unsigned char)37,qos::tlv::IpFilterPort>(v8, a2, (_WORD *)a3 + 9);
  if (!a3[22])
    *((_BYTE *)a3 + 22) = 1;
  *((_DWORD *)a3 + 6) = 0;
  v10 = tlv::parseField<(unsigned char)36,qos::tlv::IpFilterPort>(v9, a2, (_WORD *)a3 + 12);
  if (!a3[28])
    *((_BYTE *)a3 + 28) = 1;
  *(_DWORD *)(a3 + 30) = 0;
  v11 = tlv::parseField<(unsigned char)30,qos::tlv::IpFilterPort>(v10, a2, (_WORD *)a3 + 15);
  if (!a3[34])
    *((_BYTE *)a3 + 34) = 1;
  *((_DWORD *)a3 + 9) = 0;
  v12 = tlv::parseField<(unsigned char)29,qos::tlv::IpFilterPort>(v11, a2, (_WORD *)a3 + 18);
  if (!a3[40])
    *((_BYTE *)a3 + 40) = 1;
  *(_DWORD *)(a3 + 42) = 0;
  v13 = tlv::parseField<(unsigned char)28,qos::tlv::IpFilterPort>(v12, a2, (_WORD *)a3 + 21);
  if (!a3[46])
    *((_BYTE *)a3 + 46) = 1;
  *((_DWORD *)a3 + 12) = 0;
  v14 = tlv::parseField<(unsigned char)27,qos::tlv::IpFilterPort>(v13, a2, (_WORD *)a3 + 24);
  v15 = (unsigned __int8 *)tlv::parseField<(unsigned char)26,qos::tlv::Ipv6FilterFlowLabel>((tlv *)v14, a2, (uint64_t)(a3 + 52));
  if (!a3[60])
    *((_BYTE *)a3 + 60) = 1;
  *(_WORD *)(a3 + 61) = 0;
  v16 = tlv::parseField<(unsigned char)25,qos::tlv::Ipv6FilterTrafficClass>(v15, a2, (_BYTE *)a3 + 61);
  if (!a3[63])
    *((_BYTE *)a3 + 63) = 1;
  *((_WORD *)a3 + 32) = 0;
  v17 = tlv::parseField<(unsigned char)21,qos::tlv::IpFilterTypeOfService>(v16, a2, (_BYTE *)a3 + 64);
  v18 = (unsigned __int8 *)tlv::parseField<(unsigned char)20,qos::tlv::IpFilterProtocol>((tlv *)v17, a2, (_BYTE *)a3 + 66);
  *(_QWORD *)(a3 + 69) = 0;
  v19 = a3[68];
  *(_QWORD *)(a3 + 77) = 0;
  *((_BYTE *)a3 + 85) = 0;
  if (!v19)
    *((_BYTE *)a3 + 68) = 1;
  v20 = tlv::parseField<(unsigned char)23,qos::tlv::Ipv6FilterAddress>(v18, a2, (uint64_t)(a3 + 69));
  *(_QWORD *)(a3 + 87) = 0;
  v21 = a3[86];
  *(_QWORD *)(a3 + 95) = 0;
  *((_BYTE *)a3 + 103) = 0;
  if (!v21)
    *((_BYTE *)a3 + 86) = 1;
  v22 = tlv::parseField<(unsigned char)22,qos::tlv::Ipv6FilterAddress>(v20, a2, (uint64_t)(a3 + 87));
  if (!a3[104])
    *((_BYTE *)a3 + 104) = 1;
  *(_QWORD *)(a3 + 108) = 0;
  v23 = tlv::parseField<(unsigned char)19,qos::tlv::Ipv4FilterAddress>(v22, a2, (_DWORD *)a3 + 27);
  if (!a3[116])
    *((_BYTE *)a3 + 116) = 1;
  *((_QWORD *)a3 + 15) = 0;
  v24 = tlv::parseField<(unsigned char)18,qos::tlv::Ipv4FilterAddress>(v23, a2, (_DWORD *)a3 + 30);
  tlv::throwIfNotEnoughBytes((unint64_t)v24, a2, 3uLL);
  v25 = *v24;
  if (v25 != 17)
  {
    exception = (tlv::TlvParseException *)__cxa_allocate_exception(0x10uLL);
    tlv::TlvParseException::TlvParseException(exception, 0x11uLL, v25);
  }
  v26 = *(unsigned __int16 *)(v24 + 1);
  tlv::throwIfNotEnoughBytes((unint64_t)(v24 + 3), a2, v26);
  tlv::throwIfNotEnoughBytes((unint64_t)(v24 + 3), &v24[v26 + 3], 1uLL);
  *((_BYTE *)a3 + 128) = v24[3];
  return tlv::parseField<(unsigned char)16,qos::tlv::IpFilterIndex>((tlv *)(v24 + 4), a2, (_BYTE *)a3 + 129);
}

void sub_2168B51D4(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t tlv::parseField<(unsigned char)35,qos::tlv::FilterId>(tlv *this, unsigned __int8 *a2, uint64_t a3)
{
  unint64_t v6;
  unint64_t v7;
  tlv::TlvParseException *exception;

  if (!*(_BYTE *)a3)
    *(_BYTE *)a3 = 1;
  *(_WORD *)(a3 + 2) = 0;
  tlv::throwIfNotEnoughBytes((unint64_t)this, a2, 3uLL);
  v6 = *(unsigned __int8 *)this;
  if (v6 != 35)
  {
    exception = (tlv::TlvParseException *)__cxa_allocate_exception(0x10uLL);
    tlv::TlvParseException::TlvParseException(exception, 0x23uLL, v6);
  }
  v7 = *(unsigned __int16 *)((char *)this + 1);
  tlv::throwIfNotEnoughBytes((unint64_t)this + 3, a2, v7);
  tlv::throwIfNotEnoughBytes((unint64_t)this + 3, (const unsigned __int8 *)this + v7 + 3, 2uLL);
  *(_WORD *)(a3 + 2) = *(_WORD *)((char *)this + 3);
  return (uint64_t)this + 5;
}

void sub_2168B5498(_Unwind_Exception *a1, int a2)
{
  _BYTE *v2;
  void *v3;

  __cxa_free_exception(v3);
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    if (*v2)
      *v2 = 0;
    __cxa_end_catch();
    JUMPOUT(0x2168B544CLL);
  }
  _Unwind_Resume(a1);
}

uint64_t tlv::parseField<(unsigned char)34,qos::tlv::FilterPrecedence>(tlv *this, unsigned __int8 *a2, uint64_t a3)
{
  unint64_t v6;
  unint64_t v7;
  tlv::TlvParseException *exception;

  if (!*(_BYTE *)a3)
    *(_BYTE *)a3 = 1;
  *(_WORD *)(a3 + 2) = 0;
  tlv::throwIfNotEnoughBytes((unint64_t)this, a2, 3uLL);
  v6 = *(unsigned __int8 *)this;
  if (v6 != 34)
  {
    exception = (tlv::TlvParseException *)__cxa_allocate_exception(0x10uLL);
    tlv::TlvParseException::TlvParseException(exception, 0x22uLL, v6);
  }
  v7 = *(unsigned __int16 *)((char *)this + 1);
  tlv::throwIfNotEnoughBytes((unint64_t)this + 3, a2, v7);
  tlv::throwIfNotEnoughBytes((unint64_t)this + 3, (const unsigned __int8 *)this + v7 + 3, 2uLL);
  *(_WORD *)(a3 + 2) = *(_WORD *)((char *)this + 3);
  return (uint64_t)this + 5;
}

void sub_2168B55AC(_Unwind_Exception *a1, int a2)
{
  _BYTE *v2;
  void *v3;

  __cxa_free_exception(v3);
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    if (*v2)
      *v2 = 0;
    __cxa_end_catch();
    JUMPOUT(0x2168B5560);
  }
  _Unwind_Resume(a1);
}

uint64_t tlv::parseField<(unsigned char)33,qos::tlv::EspFilterSecurityPolicyIndex>(tlv *this, unsigned __int8 *a2, uint64_t a3)
{
  unint64_t v6;
  unint64_t v7;
  tlv::TlvParseException *exception;

  if (!*(_BYTE *)a3)
    *(_BYTE *)a3 = 1;
  *(_DWORD *)(a3 + 4) = 0;
  tlv::throwIfNotEnoughBytes((unint64_t)this, a2, 3uLL);
  v6 = *(unsigned __int8 *)this;
  if (v6 != 33)
  {
    exception = (tlv::TlvParseException *)__cxa_allocate_exception(0x10uLL);
    tlv::TlvParseException::TlvParseException(exception, 0x21uLL, v6);
  }
  v7 = *(unsigned __int16 *)((char *)this + 1);
  tlv::throwIfNotEnoughBytes((unint64_t)this + 3, a2, v7);
  tlv::throwIfNotEnoughBytes((unint64_t)this + 3, (const unsigned __int8 *)this + v7 + 3, 4uLL);
  *(_DWORD *)(a3 + 4) = *(_DWORD *)((char *)this + 3);
  return (uint64_t)this + 7;
}

void sub_2168B56C0(_Unwind_Exception *a1, int a2)
{
  _BYTE *v2;
  void *v3;

  __cxa_free_exception(v3);
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    if (*v2)
      *v2 = 0;
    __cxa_end_catch();
    JUMPOUT(0x2168B5674);
  }
  _Unwind_Resume(a1);
}

uint64_t tlv::parseField<(unsigned char)26,qos::tlv::Ipv6FilterFlowLabel>(tlv *this, unsigned __int8 *a2, uint64_t a3)
{
  unint64_t v6;
  unint64_t v7;
  tlv::TlvParseException *exception;

  if (!*(_BYTE *)a3)
    *(_BYTE *)a3 = 1;
  *(_DWORD *)(a3 + 4) = 0;
  tlv::throwIfNotEnoughBytes((unint64_t)this, a2, 3uLL);
  v6 = *(unsigned __int8 *)this;
  if (v6 != 26)
  {
    exception = (tlv::TlvParseException *)__cxa_allocate_exception(0x10uLL);
    tlv::TlvParseException::TlvParseException(exception, 0x1AuLL, v6);
  }
  v7 = *(unsigned __int16 *)((char *)this + 1);
  tlv::throwIfNotEnoughBytes((unint64_t)this + 3, a2, v7);
  tlv::throwIfNotEnoughBytes((unint64_t)this + 3, (const unsigned __int8 *)this + v7 + 3, 4uLL);
  *(_DWORD *)(a3 + 4) = *(_DWORD *)((char *)this + 3);
  return (uint64_t)this + 7;
}

void sub_2168B57D4(_Unwind_Exception *a1, int a2)
{
  _BYTE *v2;
  void *v3;

  __cxa_free_exception(v3);
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    if (*v2)
      *v2 = 0;
    __cxa_end_catch();
    JUMPOUT(0x2168B5788);
  }
  _Unwind_Resume(a1);
}

uint64_t tlv::parseField<(unsigned char)20,qos::tlv::IpFilterProtocol>(tlv *this, unsigned __int8 *a2, _BYTE *a3)
{
  unint64_t v6;
  unint64_t v7;
  tlv::TlvParseException *exception;

  if (!*a3)
    *a3 = 1;
  a3[1] = 0;
  tlv::throwIfNotEnoughBytes((unint64_t)this, a2, 3uLL);
  v6 = *(unsigned __int8 *)this;
  if (v6 != 20)
  {
    exception = (tlv::TlvParseException *)__cxa_allocate_exception(0x10uLL);
    tlv::TlvParseException::TlvParseException(exception, 0x14uLL, v6);
  }
  v7 = *(unsigned __int16 *)((char *)this + 1);
  tlv::throwIfNotEnoughBytes((unint64_t)this + 3, a2, v7);
  tlv::throwIfNotEnoughBytes((unint64_t)this + 3, (const unsigned __int8 *)this + v7 + 3, 1uLL);
  a3[1] = *((_BYTE *)this + 3);
  return (uint64_t)this + 4;
}

void sub_2168B58E8(_Unwind_Exception *a1, int a2)
{
  _BYTE *v2;
  void *v3;

  __cxa_free_exception(v3);
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    if (*v2)
      *v2 = 0;
    __cxa_end_catch();
    JUMPOUT(0x2168B589CLL);
  }
  _Unwind_Resume(a1);
}

uint64_t tlv::parseField<(unsigned char)16,qos::tlv::IpFilterIndex>(tlv *this, unsigned __int8 *a2, _BYTE *a3)
{
  unint64_t v6;
  unint64_t v7;
  tlv::TlvParseException *exception;

  if (!*a3)
    *a3 = 1;
  a3[1] = 0;
  tlv::throwIfNotEnoughBytes((unint64_t)this, a2, 3uLL);
  v6 = *(unsigned __int8 *)this;
  if (v6 != 16)
  {
    exception = (tlv::TlvParseException *)__cxa_allocate_exception(0x10uLL);
    tlv::TlvParseException::TlvParseException(exception, 0x10uLL, v6);
  }
  v7 = *(unsigned __int16 *)((char *)this + 1);
  tlv::throwIfNotEnoughBytes((unint64_t)this + 3, a2, v7);
  tlv::throwIfNotEnoughBytes((unint64_t)this + 3, (const unsigned __int8 *)this + v7 + 3, 1uLL);
  a3[1] = *((_BYTE *)this + 3);
  return (uint64_t)this + 4;
}

void sub_2168B59FC(_Unwind_Exception *a1, int a2)
{
  _BYTE *v2;
  void *v3;

  __cxa_free_exception(v3);
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    if (*v2)
      *v2 = 0;
    __cxa_end_catch();
    JUMPOUT(0x2168B59B0);
  }
  _Unwind_Resume(a1);
}

tlv *tlv::parseUnboundedSequence<tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>>(tlv *this, unsigned __int8 *a2, uint64_t *a3)
{
  tlv *v3;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  unint64_t v16;
  qos::tlv *v17;
  qos::tlv::QoSFilter *v18;
  unint64_t v20;
  tlv::TlvParseException *exception;
  _QWORD v22[5];

  v3 = this;
  if (this < (tlv *)a2)
  {
    v6 = (uint64_t)(a3 + 2);
    do
    {
      v7 = a3[1];
      v8 = a3[2];
      if (v7 >= v8)
      {
        v10 = 0xF83E0F83E0F83E1 * ((uint64_t)(v7 - *a3) >> 2);
        v11 = v10 + 1;
        if ((unint64_t)(v10 + 1) > 0x1F07C1F07C1F07CLL)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v12 = 0xF83E0F83E0F83E1 * ((uint64_t)(v8 - *a3) >> 2);
        if (2 * v12 > v11)
          v11 = 2 * v12;
        if (v12 >= 0xF83E0F83E0F83ELL)
          v13 = 0x1F07C1F07C1F07CLL;
        else
          v13 = v11;
        v22[4] = v6;
        if (v13)
          v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::FrameData>>(v6, v13);
        else
          v14 = 0;
        v15 = &v14[132 * v10];
        v22[0] = v14;
        v22[1] = v15;
        v22[3] = &v14[132 * v13];
        *(_OWORD *)v15 = 0u;
        *((_OWORD *)v15 + 1) = 0u;
        *((_OWORD *)v15 + 2) = 0u;
        *((_OWORD *)v15 + 3) = 0u;
        *((_OWORD *)v15 + 4) = 0u;
        *((_OWORD *)v15 + 5) = 0u;
        *((_OWORD *)v15 + 6) = 0u;
        *((_OWORD *)v15 + 7) = 0u;
        *(_DWORD *)(v15 + 127) = 0;
        v22[2] = v15 + 132;
        std::vector<tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>>::__swap_out_circular_buffer(a3, v22);
        v9 = a3[1];
        std::__split_buffer<tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>>::~__split_buffer((uint64_t)v22);
      }
      else
      {
        *(_DWORD *)(v7 + 127) = 0;
        *(_OWORD *)(v7 + 96) = 0u;
        *(_OWORD *)(v7 + 112) = 0u;
        *(_OWORD *)(v7 + 64) = 0u;
        *(_OWORD *)(v7 + 80) = 0u;
        *(_OWORD *)(v7 + 32) = 0u;
        *(_OWORD *)(v7 + 48) = 0u;
        *(_OWORD *)v7 = 0u;
        *(_OWORD *)(v7 + 16) = 0u;
        v9 = v7 + 132;
        a3[1] = v7 + 132;
      }
      a3[1] = v9;
      tlv::throwIfNotEnoughBytes((unint64_t)v3, a2, 3uLL);
      if (*(_BYTE *)v3 != 16)
      {
        v20 = *(unsigned __int8 *)v3;
        exception = (tlv::TlvParseException *)__cxa_allocate_exception(0x10uLL);
        tlv::TlvParseException::TlvParseException(exception, 0x10uLL, v20);
      }
      v16 = *(unsigned __int16 *)((char *)v3 + 1);
      v17 = (tlv *)((char *)v3 + 3);
      tlv::throwIfNotEnoughBytes((unint64_t)v17, a2, v16);
      v3 = (tlv *)qos::tlv::parseField(v17, (unsigned __int8 *)v17 + v16, (const unsigned __int8 *)(v9 - 132), v18);
    }
    while (v3 < (tlv *)a2);
  }
  return v3;
}

void sub_2168B5C30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  void *v10;

  __cxa_free_exception(v10);
  _Unwind_Resume(a1);
}

unint64_t qos::tlv::parseField(unint64_t a1, const unsigned __int8 *a2, uint64_t a3)
{
  tlv::throwIfNotEnoughBytes(a1, a2, 4uLL);
  *(_DWORD *)a3 = *(_DWORD *)a1;
  tlv::throwIfNotEnoughBytes(a1 + 4, a2, 1uLL);
  *(_BYTE *)(a3 + 4) = *(_BYTE *)(a1 + 4);
  tlv::throwIfNotEnoughBytes(a1 + 5, a2, 1uLL);
  *(_BYTE *)(a3 + 5) = *(_BYTE *)(a1 + 5);
  return a1 + 6;
}

{
  tlv::throwIfNotEnoughBytes(a1, a2, 8uLL);
  *(_QWORD *)a3 = *(_QWORD *)a1;
  tlv::throwIfNotEnoughBytes(a1 + 8, a2, 4uLL);
  *(_DWORD *)(a3 + 8) = *(_DWORD *)(a1 + 8);
  tlv::throwIfNotEnoughBytes(a1 + 12, a2, 8uLL);
  *(_QWORD *)(a3 + 16) = *(_QWORD *)(a1 + 12);
  tlv::throwIfNotEnoughBytes(a1 + 20, a2, 8uLL);
  *(_QWORD *)(a3 + 24) = *(_QWORD *)(a1 + 20);
  tlv::throwIfNotEnoughBytes(a1 + 28, a2, 4uLL);
  *(_DWORD *)(a3 + 32) = *(_DWORD *)(a1 + 28);
  tlv::throwIfNotEnoughBytes(a1 + 32, a2, 4uLL);
  *(_DWORD *)(a3 + 36) = *(_DWORD *)(a1 + 32);
  tlv::throwIfNotEnoughBytes(a1 + 36, a2, 4uLL);
  *(_DWORD *)(a3 + 40) = *(_DWORD *)(a1 + 36);
  tlv::throwIfNotEnoughBytes(a1 + 40, a2, 4uLL);
  *(_DWORD *)(a3 + 44) = *(_DWORD *)(a1 + 40);
  tlv::throwIfNotEnoughBytes(a1 + 44, a2, 4uLL);
  *(_DWORD *)(a3 + 48) = *(_DWORD *)(a1 + 44);
  tlv::throwIfNotEnoughBytes(a1 + 48, a2, 2uLL);
  *(_WORD *)(a3 + 52) = *(_WORD *)(a1 + 48);
  tlv::throwIfNotEnoughBytes(a1 + 50, a2, 2uLL);
  *(_WORD *)(a3 + 54) = *(_WORD *)(a1 + 50);
  tlv::throwIfNotEnoughBytes(a1 + 52, a2, 4uLL);
  *(_DWORD *)(a3 + 56) = *(_DWORD *)(a1 + 52);
  tlv::throwIfNotEnoughBytes(a1 + 56, a2, 4uLL);
  *(_DWORD *)(a3 + 60) = *(_DWORD *)(a1 + 56);
  tlv::throwIfNotEnoughBytes(a1 + 60, a2, 4uLL);
  *(_DWORD *)(a3 + 64) = *(_DWORD *)(a1 + 60);
  tlv::throwIfNotEnoughBytes(a1 + 64, a2, 4uLL);
  *(_DWORD *)(a3 + 68) = *(_DWORD *)(a1 + 64);
  tlv::throwIfNotEnoughBytes(a1 + 68, a2, 2uLL);
  *(_WORD *)(a3 + 72) = *(_WORD *)(a1 + 68);
  tlv::throwIfNotEnoughBytes(a1 + 70, a2, 1uLL);
  *(_BYTE *)(a3 + 74) = *(_BYTE *)(a1 + 70);
  tlv::throwIfNotEnoughBytes(a1 + 71, a2, 1uLL);
  *(_BYTE *)(a3 + 75) = *(_BYTE *)(a1 + 71);
  tlv::throwIfNotEnoughBytes(a1 + 72, a2, 1uLL);
  *(_BYTE *)(a3 + 76) = *(_BYTE *)(a1 + 72);
  tlv::throwIfNotEnoughBytes(a1 + 73, a2, 4uLL);
  *(_DWORD *)(a3 + 80) = *(_DWORD *)(a1 + 73);
  return a1 + 77;
}

{
  tlv::throwIfNotEnoughBytes(a1, a2, 1uLL);
  *(_BYTE *)a3 = *(_BYTE *)a1;
  tlv::throwIfNotEnoughBytes(a1 + 1, a2, 8uLL);
  *(_QWORD *)(a3 + 8) = *(_QWORD *)(a1 + 1);
  tlv::throwIfNotEnoughBytes(a1 + 9, a2, 4uLL);
  *(_DWORD *)(a3 + 16) = *(_DWORD *)(a1 + 9);
  tlv::throwIfNotEnoughBytes(a1 + 13, a2, 4uLL);
  *(_DWORD *)(a3 + 20) = *(_DWORD *)(a1 + 13);
  tlv::throwIfNotEnoughBytes(a1 + 17, a2, 4uLL);
  *(_DWORD *)(a3 + 24) = *(_DWORD *)(a1 + 17);
  tlv::throwIfNotEnoughBytes(a1 + 21, a2, 4uLL);
  *(_DWORD *)(a3 + 28) = *(_DWORD *)(a1 + 21);
  tlv::throwIfNotEnoughBytes(a1 + 25, a2, 1uLL);
  *(_BYTE *)(a3 + 32) = *(_BYTE *)(a1 + 25);
  tlv::throwIfNotEnoughBytes(a1 + 26, a2, 1uLL);
  *(_BYTE *)(a3 + 33) = *(_BYTE *)(a1 + 26);
  tlv::throwIfNotEnoughBytes(a1 + 27, a2, 8uLL);
  *(_QWORD *)(a3 + 40) = *(_QWORD *)(a1 + 27);
  tlv::throwIfNotEnoughBytes(a1 + 35, a2, 0x10uLL);
  *(_OWORD *)(a3 + 48) = *(_OWORD *)(a1 + 35);
  tlv::throwIfNotEnoughBytes(a1 + 51, a2, 1uLL);
  *(_BYTE *)(a3 + 64) = *(_BYTE *)(a1 + 51);
  tlv::throwIfNotEnoughBytes(a1 + 52, a2, 0x10uLL);
  *(_OWORD *)(a3 + 65) = *(_OWORD *)(a1 + 52);
  tlv::throwIfNotEnoughBytes(a1 + 68, a2, 1uLL);
  *(_BYTE *)(a3 + 81) = *(_BYTE *)(a1 + 68);
  tlv::throwIfNotEnoughBytes(a1 + 69, a2, 1uLL);
  *(_BYTE *)(a3 + 82) = *(_BYTE *)(a1 + 69);
  tlv::throwIfNotEnoughBytes(a1 + 70, a2, 1uLL);
  *(_BYTE *)(a3 + 83) = *(_BYTE *)(a1 + 70);
  tlv::throwIfNotEnoughBytes(a1 + 71, a2, 4uLL);
  *(_DWORD *)(a3 + 84) = *(_DWORD *)(a1 + 71);
  tlv::throwIfNotEnoughBytes(a1 + 75, a2, 4uLL);
  *(_DWORD *)(a3 + 88) = *(_DWORD *)(a1 + 75);
  tlv::throwIfNotEnoughBytes(a1 + 79, a2, 8uLL);
  *(_QWORD *)(a3 + 96) = *(_QWORD *)(a1 + 79);
  tlv::throwIfNotEnoughBytes(a1 + 87, a2, 2uLL);
  *(_WORD *)(a3 + 104) = *(_WORD *)(a1 + 87);
  tlv::throwIfNotEnoughBytes(a1 + 89, a2, 2uLL);
  *(_WORD *)(a3 + 106) = *(_WORD *)(a1 + 89);
  tlv::throwIfNotEnoughBytes(a1 + 91, a2, 2uLL);
  *(_WORD *)(a3 + 108) = *(_WORD *)(a1 + 91);
  tlv::throwIfNotEnoughBytes(a1 + 93, a2, 2uLL);
  *(_WORD *)(a3 + 110) = *(_WORD *)(a1 + 93);
  tlv::throwIfNotEnoughBytes(a1 + 95, a2, 8uLL);
  *(_QWORD *)(a3 + 112) = *(_QWORD *)(a1 + 95);
  tlv::throwIfNotEnoughBytes(a1 + 103, a2, 2uLL);
  *(_WORD *)(a3 + 120) = *(_WORD *)(a1 + 103);
  tlv::throwIfNotEnoughBytes(a1 + 105, a2, 2uLL);
  *(_WORD *)(a3 + 122) = *(_WORD *)(a1 + 105);
  tlv::throwIfNotEnoughBytes(a1 + 107, a2, 2uLL);
  *(_WORD *)(a3 + 124) = *(_WORD *)(a1 + 107);
  tlv::throwIfNotEnoughBytes(a1 + 109, a2, 2uLL);
  *(_WORD *)(a3 + 126) = *(_WORD *)(a1 + 109);
  tlv::throwIfNotEnoughBytes(a1 + 111, a2, 8uLL);
  *(_QWORD *)(a3 + 128) = *(_QWORD *)(a1 + 111);
  tlv::throwIfNotEnoughBytes(a1 + 119, a2, 1uLL);
  *(_BYTE *)(a3 + 136) = *(_BYTE *)(a1 + 119);
  tlv::throwIfNotEnoughBytes(a1 + 120, a2, 1uLL);
  *(_BYTE *)(a3 + 137) = *(_BYTE *)(a1 + 120);
  tlv::throwIfNotEnoughBytes(a1 + 121, a2, 8uLL);
  *(_QWORD *)(a3 + 144) = *(_QWORD *)(a1 + 121);
  tlv::throwIfNotEnoughBytes(a1 + 129, a2, 4uLL);
  *(_DWORD *)(a3 + 152) = *(_DWORD *)(a1 + 129);
  tlv::throwIfNotEnoughBytes(a1 + 133, a2, 8uLL);
  *(_QWORD *)(a3 + 160) = *(_QWORD *)(a1 + 133);
  tlv::throwIfNotEnoughBytes(a1 + 141, a2, 4uLL);
  *(_DWORD *)(a3 + 168) = *(_DWORD *)(a1 + 141);
  tlv::throwIfNotEnoughBytes(a1 + 145, a2, 2uLL);
  *(_WORD *)(a3 + 172) = *(_WORD *)(a1 + 145);
  tlv::throwIfNotEnoughBytes(a1 + 147, a2, 2uLL);
  *(_WORD *)(a3 + 174) = *(_WORD *)(a1 + 147);
  return a1 + 149;
}

{
  unint64_t result;

  tlv::throwIfNotEnoughBytes(a1, a2, 4uLL);
  *(_DWORD *)a3 = *(_DWORD *)a1;
  tlv::throwIfNotEnoughBytes(a1 + 4, a2, 1uLL);
  *(_BYTE *)(a3 + 4) = *(_BYTE *)(a1 + 4) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 5, a2, 4uLL);
  result = a1 + 9;
  *(_DWORD *)(a3 + 8) = *(_DWORD *)(a1 + 5);
  return result;
}

uint64_t qos::tlv::parseField(unsigned __int8 *a1, const unsigned __int8 *a2, unsigned __int8 *a3)
{
  unint64_t v6;
  qos::tlv *v7;
  qos::tlv::FlowSpec *v8;
  unint64_t v10;
  tlv::TlvParseException *exception;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 3uLL);
  if (*a1 != 16)
  {
    v10 = *a1;
    exception = (tlv::TlvParseException *)__cxa_allocate_exception(0x10uLL);
    tlv::TlvParseException::TlvParseException(exception, 0x10uLL, v10);
  }
  v6 = *(unsigned __int16 *)(a1 + 1);
  v7 = (qos::tlv *)(a1 + 3);
  tlv::throwIfNotEnoughBytes((unint64_t)v7, a2, v6);
  return qos::tlv::parseField(v7, (unsigned __int8 *)v7 + v6, a3, v8);
}

void sub_2168B5D5C(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t tlv::parseV<qos::tlv::BearerId>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168B5DA8(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168B5D9CLL);
}

unint64_t tlv::parseV<qos::tlv::TxQosGrantedFlow>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  unint64_t result;

  *(_QWORD *)(a3 + 80) = 0;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)a3 = 0u;
  result = qos::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), a3);
  *a1 = result;
  return result;
}

void sub_2168B6008(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
}

unint64_t tlv::parseV<qos::tlv::RxQosGrantedFlow>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  unint64_t result;

  *(_QWORD *)(a3 + 80) = 0;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)a3 = 0u;
  result = qos::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), a3);
  *a1 = result;
  return result;
}

void sub_2168B6060(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
}

unint64_t qos::tlv::parseField(unsigned __int8 *a1, const unsigned __int8 *a2, uint64_t *a3)
{
  unint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t result;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  v7 = *a1;
  v6 = (unint64_t)(a1 + 1);
  std::vector<qos::tlv::QosFilterSpec>::resize((uint64_t)a3, v7);
  v8 = *a3;
  v9 = a3[1];
  while (1)
  {
    result = v6;
    if (v8 == v9)
      break;
    v6 = qos::tlv::parseField(v6, a2, v8);
    v8 += 176;
  }
  return result;
}

unint64_t tlv::parseV<qos::tlv::TxQosFilterSpecList>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  unint64_t result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = qos::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = (unsigned __int8 *)result;
  return result;
}

void sub_2168B64A0(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168B6494);
}

void sub_2168B64B0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

unint64_t tlv::parseV<qos::tlv::RxQosFilterSpecList>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  unint64_t result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = qos::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = (unsigned __int8 *)result;
  return result;
}

void sub_2168B6508(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168B64FCLL);
}

void sub_2168B6518(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t tlv::parseV<qos::tlv::Tx5gQci>(unint64_t *a1, int a2)
{
  unsigned int *v3;
  uint64_t result;

  v3 = (unsigned int *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 4uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168B656C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168B6560);
}

uint64_t tlv::parseV<qos::tlv::Rx5gQci>(unint64_t *a1, int a2)
{
  unsigned int *v3;
  uint64_t result;

  v3 = (unsigned int *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 4uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168B65B8(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168B65ACLL);
}

unsigned int *qos::tlv::parseField(unsigned __int8 *a1, const unsigned __int8 *a2, std::vector<unsigned int> *a3)
{
  unsigned int *v6;
  unsigned int v7;
  std::vector<unsigned int>::pointer end;
  std::vector<unsigned int>::pointer begin;
  unsigned int v10;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  v7 = *a1;
  v6 = (unsigned int *)(a1 + 1);
  std::vector<unsigned int>::resize(a3, v7);
  begin = a3->__begin_;
  end = a3->__end_;
  while (begin != end)
  {
    tlv::throwIfNotEnoughBytes((unint64_t)v6, a2, 4uLL);
    v10 = *v6++;
    *begin++ = v10;
  }
  return v6;
}

unsigned int *tlv::parseV<qos::tlv::QoSIdsList>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, std::vector<unsigned int> *a3@<X8>)
{
  unsigned int *result;

  a3->__begin_ = 0;
  a3->__end_ = 0;
  a3->__end_cap_.__value_ = 0;
  result = qos::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = (unsigned __int8 *)result;
  return result;
}

void sub_2168B6674(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168B6668);
}

void sub_2168B6684(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *tlv::writeV<qos::tlv::NetworkProfileChange>(uint64_t *result, uint64_t a2)
{
  uint64_t v2;

  v2 = *result;
  *(_BYTE *)v2 = *(_BYTE *)a2;
  *(_WORD *)(v2 + 1) = *(_WORD *)(a2 + 2);
  *result = v2 + 3;
  return result;
}

uint64_t qos::tlv::parseField(qos::tlv *this, unsigned __int8 *a2, const unsigned __int8 *a3, qos::tlv::FlowInfo *a4)
{
  unint64_t v7;
  char *v8;
  unsigned __int8 *v9;
  unsigned __int8 *v10;
  unsigned __int8 *v11;
  unsigned __int8 *v12;
  tlv *v13;
  tlv *v14;
  tlv *v15;
  unint64_t v17;
  tlv::TlvParseException *exception;

  tlv::throwIfNotEnoughBytes((unint64_t)this, a2, 3uLL);
  if (*(_BYTE *)this != 16)
  {
    v17 = *(unsigned __int8 *)this;
    exception = (tlv::TlvParseException *)__cxa_allocate_exception(0x10uLL);
    tlv::TlvParseException::TlvParseException(exception, 0x10uLL, v17);
  }
  v7 = *(unsigned __int16 *)((char *)this + 1);
  v8 = (char *)this + 3;
  tlv::throwIfNotEnoughBytes((unint64_t)v8, a2, v7);
  v9 = (unsigned __int8 *)qos::tlv::parseField((unint64_t)v8, (const unsigned __int8 *)&v8[v7], (uint64_t)a3);
  v10 = (unsigned __int8 *)tlv::parseField<(unsigned char)20,qos::tlv::QoSFilterList>(v9, a2, (uint64_t)(a3 + 8));
  v11 = (unsigned __int8 *)tlv::parseField<(unsigned char)19,qos::tlv::QoSFilterList>(v10, a2, (uint64_t)(a3 + 40));
  v12 = (unsigned __int8 *)tlv::parseField<(unsigned char)18,qos::tlv::FlowGranted>(v11, a2, (_BYTE *)a3 + 72);
  v13 = (tlv *)tlv::parseField<(unsigned char)17,qos::tlv::FlowGranted>(v12, a2, (_BYTE *)a3 + 208);
  v14 = (tlv *)tlv::parseField<(unsigned char)21,qos::tlv::QoSFlowType>(v13, a2, (_BYTE *)a3 + 344);
  v15 = (tlv *)tlv::parseField<(unsigned char)22,qos::tlv::BearerId>(v14, a2, (_BYTE *)a3 + 346);
  return tlv::parseField<(unsigned char)23,qos::tlv::FlowControlSeqNum>(v15, a2, (uint64_t)(a3 + 348));
}

void sub_2168B67AC(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

tlv *tlv::parseField<(unsigned char)20,qos::tlv::QoSFilterList>(unsigned __int8 *a1, const unsigned __int8 *a2, uint64_t a3)
{
  unint64_t v6;
  unint64_t v8;
  tlv::TlvParseException *exception;
  uint64_t v10[3];
  void **v11;

  memset(v10, 0, sizeof(v10));
  boost::optional_detail::optional_base<tlv::NestedTlv<(unsigned char)20,qos::tlv::QoSFilterList>>::assign_expr<qos::tlv::QoSFilterList,qos::tlv::QoSFilterList>(a3, v10);
  v11 = (void **)v10;
  std::vector<tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>>::__destroy_vector::operator()[abi:ne180100](&v11);
  if (!*(_BYTE *)a3)
    __assert_rtn("get", "optional.hpp", 1212, "this->is_initialized()");
  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 3uLL);
  if (*a1 != 20)
  {
    v8 = *a1;
    exception = (tlv::TlvParseException *)__cxa_allocate_exception(0x10uLL);
    tlv::TlvParseException::TlvParseException(exception, 0x14uLL, v8);
  }
  v6 = *(unsigned __int16 *)(a1 + 1);
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 3), a2, v6);
  return tlv::parseUnboundedSequence<tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>>((tlv *)(a1 + 3), &a1[v6 + 3], (uint64_t *)(a3 + 8));
}

void sub_2168B68D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, _BYTE *a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  _BYTE *v12;
  void *v13;

  __cxa_free_exception(v13);
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    if (*v12)
    {
      a9 = v12 + 8;
      std::vector<tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a9);
      *v12 = 0;
    }
    __cxa_end_catch();
    JUMPOUT(0x2168B685CLL);
  }
  _Unwind_Resume(a1);
}

tlv *tlv::parseField<(unsigned char)19,qos::tlv::QoSFilterList>(unsigned __int8 *a1, const unsigned __int8 *a2, uint64_t a3)
{
  unint64_t v6;
  unint64_t v8;
  tlv::TlvParseException *exception;
  uint64_t v10[3];
  void **v11;

  memset(v10, 0, sizeof(v10));
  boost::optional_detail::optional_base<tlv::NestedTlv<(unsigned char)20,qos::tlv::QoSFilterList>>::assign_expr<qos::tlv::QoSFilterList,qos::tlv::QoSFilterList>(a3, v10);
  v11 = (void **)v10;
  std::vector<tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>>::__destroy_vector::operator()[abi:ne180100](&v11);
  if (!*(_BYTE *)a3)
    __assert_rtn("get", "optional.hpp", 1212, "this->is_initialized()");
  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 3uLL);
  if (*a1 != 19)
  {
    v8 = *a1;
    exception = (tlv::TlvParseException *)__cxa_allocate_exception(0x10uLL);
    tlv::TlvParseException::TlvParseException(exception, 0x13uLL, v8);
  }
  v6 = *(unsigned __int16 *)(a1 + 1);
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 3), a2, v6);
  return tlv::parseUnboundedSequence<tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>>((tlv *)(a1 + 3), &a1[v6 + 3], (uint64_t *)(a3 + 8));
}

void sub_2168B6A58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, _BYTE *a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  _BYTE *v12;
  void *v13;

  __cxa_free_exception(v13);
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    if (*v12)
    {
      a9 = v12 + 8;
      std::vector<tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a9);
      *v12 = 0;
    }
    __cxa_end_catch();
    JUMPOUT(0x2168B69E0);
  }
  _Unwind_Resume(a1);
}

uint64_t tlv::parseField<(unsigned char)18,qos::tlv::FlowGranted>(unsigned __int8 *a1, const unsigned __int8 *a2, _BYTE *a3)
{
  unint64_t v6;
  unint64_t v8;
  tlv::TlvParseException *exception;
  _OWORD v10[2];
  void *__p[2];
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v15 = 0u;
  v16 = 0u;
  v13 = 0u;
  v14 = 0u;
  *(_OWORD *)__p = 0u;
  v12 = 0u;
  memset(v10, 0, sizeof(v10));
  boost::optional_detail::optional_base<tlv::NestedTlv<(unsigned char)18,qos::tlv::FlowGranted>>::assign_expr<qos::tlv::FlowGranted,qos::tlv::FlowGranted>(a3, (const qos::tlv::FlowSpec *)v10);
  if (BYTE8(v16))
    BYTE8(v16) = 0;
  if (BYTE6(v16))
    BYTE6(v16) = 0;
  if (BYTE4(v16))
    BYTE4(v16) = 0;
  if (BYTE2(v16))
    BYTE2(v16) = 0;
  if ((_BYTE)v16)
    LOBYTE(v16) = 0;
  if (BYTE12(v15))
    BYTE12(v15) = 0;
  if (BYTE10(v15))
    BYTE10(v15) = 0;
  if (BYTE8(v15))
    BYTE8(v15) = 0;
  if ((_BYTE)v15)
    LOBYTE(v15) = 0;
  if (BYTE8(v14))
    BYTE8(v14) = 0;
  if ((_BYTE)v14)
    LOBYTE(v14) = 0;
  if (BYTE8(v13))
    BYTE8(v13) = 0;
  if ((_BYTE)v13)
    LOBYTE(v13) = 0;
  if (LOBYTE(__p[0]) && __p[1])
  {
    *(void **)&v12 = __p[1];
    operator delete(__p[1]);
  }
  if (!*a3)
    __assert_rtn("get", "optional.hpp", 1212, "this->is_initialized()");
  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 3uLL);
  if (*a1 != 18)
  {
    v8 = *a1;
    exception = (tlv::TlvParseException *)__cxa_allocate_exception(0x10uLL);
    tlv::TlvParseException::TlvParseException(exception, 0x12uLL, v8);
  }
  v6 = *(unsigned __int16 *)(a1 + 1);
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 3), a2, v6);
  return qos::tlv::parseField(a1 + 3, &a1[v6 + 3], a3 + 8);
}

void sub_2168B6CB8(_Unwind_Exception *a1, int a2)
{
  _BYTE *v2;
  void *v3;

  __cxa_free_exception(v3);
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    if (*v2)
    {
      qos::tlv::FlowSpec::~FlowSpec((qos::tlv::FlowSpec *)(v2 + 8));
      *v2 = 0;
    }
    __cxa_end_catch();
    JUMPOUT(0x2168B6C24);
  }
  _Unwind_Resume(a1);
}

uint64_t tlv::parseField<(unsigned char)17,qos::tlv::FlowGranted>(unsigned __int8 *a1, const unsigned __int8 *a2, _BYTE *a3)
{
  unint64_t v6;
  unint64_t v8;
  tlv::TlvParseException *exception;
  _OWORD v10[2];
  void *__p[2];
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v15 = 0u;
  v16 = 0u;
  v13 = 0u;
  v14 = 0u;
  *(_OWORD *)__p = 0u;
  v12 = 0u;
  memset(v10, 0, sizeof(v10));
  boost::optional_detail::optional_base<tlv::NestedTlv<(unsigned char)17,qos::tlv::FlowGranted>>::assign_expr<qos::tlv::FlowGranted,qos::tlv::FlowGranted>(a3, (const qos::tlv::FlowSpec *)v10);
  if (BYTE8(v16))
    BYTE8(v16) = 0;
  if (BYTE6(v16))
    BYTE6(v16) = 0;
  if (BYTE4(v16))
    BYTE4(v16) = 0;
  if (BYTE2(v16))
    BYTE2(v16) = 0;
  if ((_BYTE)v16)
    LOBYTE(v16) = 0;
  if (BYTE12(v15))
    BYTE12(v15) = 0;
  if (BYTE10(v15))
    BYTE10(v15) = 0;
  if (BYTE8(v15))
    BYTE8(v15) = 0;
  if ((_BYTE)v15)
    LOBYTE(v15) = 0;
  if (BYTE8(v14))
    BYTE8(v14) = 0;
  if ((_BYTE)v14)
    LOBYTE(v14) = 0;
  if (BYTE8(v13))
    BYTE8(v13) = 0;
  if ((_BYTE)v13)
    LOBYTE(v13) = 0;
  if (LOBYTE(__p[0]) && __p[1])
  {
    *(void **)&v12 = __p[1];
    operator delete(__p[1]);
  }
  if (!*a3)
    __assert_rtn("get", "optional.hpp", 1212, "this->is_initialized()");
  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 3uLL);
  if (*a1 != 17)
  {
    v8 = *a1;
    exception = (tlv::TlvParseException *)__cxa_allocate_exception(0x10uLL);
    tlv::TlvParseException::TlvParseException(exception, 0x11uLL, v8);
  }
  v6 = *(unsigned __int16 *)(a1 + 1);
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 3), a2, v6);
  return qos::tlv::parseField(a1 + 3, &a1[v6 + 3], a3 + 8);
}

void sub_2168B6F18(_Unwind_Exception *a1, int a2)
{
  _BYTE *v2;
  void *v3;

  __cxa_free_exception(v3);
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    if (*v2)
    {
      qos::tlv::FlowSpec::~FlowSpec((qos::tlv::FlowSpec *)(v2 + 8));
      *v2 = 0;
    }
    __cxa_end_catch();
    JUMPOUT(0x2168B6E84);
  }
  _Unwind_Resume(a1);
}

uint64_t tlv::parseField<(unsigned char)21,qos::tlv::QoSFlowType>(tlv *this, unsigned __int8 *a2, _BYTE *a3)
{
  unint64_t v6;
  unint64_t v7;
  tlv::TlvParseException *exception;

  if (!*a3)
    *a3 = 1;
  a3[1] = 0;
  tlv::throwIfNotEnoughBytes((unint64_t)this, a2, 3uLL);
  v6 = *(unsigned __int8 *)this;
  if (v6 != 21)
  {
    exception = (tlv::TlvParseException *)__cxa_allocate_exception(0x10uLL);
    tlv::TlvParseException::TlvParseException(exception, 0x15uLL, v6);
  }
  v7 = *(unsigned __int16 *)((char *)this + 1);
  tlv::throwIfNotEnoughBytes((unint64_t)this + 3, a2, v7);
  tlv::throwIfNotEnoughBytes((unint64_t)this + 3, (const unsigned __int8 *)this + v7 + 3, 1uLL);
  a3[1] = *((_BYTE *)this + 3);
  return (uint64_t)this + 4;
}

void sub_2168B7058(_Unwind_Exception *a1, int a2)
{
  _BYTE *v2;
  void *v3;

  __cxa_free_exception(v3);
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    if (*v2)
      *v2 = 0;
    __cxa_end_catch();
    JUMPOUT(0x2168B700CLL);
  }
  _Unwind_Resume(a1);
}

uint64_t tlv::parseField<(unsigned char)22,qos::tlv::BearerId>(tlv *this, unsigned __int8 *a2, _BYTE *a3)
{
  unint64_t v6;
  unint64_t v7;
  tlv::TlvParseException *exception;

  if (!*a3)
    *a3 = 1;
  a3[1] = 0;
  tlv::throwIfNotEnoughBytes((unint64_t)this, a2, 3uLL);
  v6 = *(unsigned __int8 *)this;
  if (v6 != 22)
  {
    exception = (tlv::TlvParseException *)__cxa_allocate_exception(0x10uLL);
    tlv::TlvParseException::TlvParseException(exception, 0x16uLL, v6);
  }
  v7 = *(unsigned __int16 *)((char *)this + 1);
  tlv::throwIfNotEnoughBytes((unint64_t)this + 3, a2, v7);
  tlv::throwIfNotEnoughBytes((unint64_t)this + 3, (const unsigned __int8 *)this + v7 + 3, 1uLL);
  a3[1] = *((_BYTE *)this + 3);
  return (uint64_t)this + 4;
}

void sub_2168B716C(_Unwind_Exception *a1, int a2)
{
  _BYTE *v2;
  void *v3;

  __cxa_free_exception(v3);
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    if (*v2)
      *v2 = 0;
    __cxa_end_catch();
    JUMPOUT(0x2168B7120);
  }
  _Unwind_Resume(a1);
}

uint64_t tlv::parseField<(unsigned char)23,qos::tlv::FlowControlSeqNum>(tlv *this, unsigned __int8 *a2, uint64_t a3)
{
  unint64_t v6;
  unint64_t v7;
  tlv::TlvParseException *exception;

  if (!*(_BYTE *)a3)
    *(_BYTE *)a3 = 1;
  *(_WORD *)(a3 + 2) = 0;
  tlv::throwIfNotEnoughBytes((unint64_t)this, a2, 3uLL);
  v6 = *(unsigned __int8 *)this;
  if (v6 != 23)
  {
    exception = (tlv::TlvParseException *)__cxa_allocate_exception(0x10uLL);
    tlv::TlvParseException::TlvParseException(exception, 0x17uLL, v6);
  }
  v7 = *(unsigned __int16 *)((char *)this + 1);
  tlv::throwIfNotEnoughBytes((unint64_t)this + 3, a2, v7);
  tlv::throwIfNotEnoughBytes((unint64_t)this + 3, (const unsigned __int8 *)this + v7 + 3, 2uLL);
  *(_WORD *)(a3 + 2) = *(_WORD *)((char *)this + 3);
  return (uint64_t)this + 5;
}

void sub_2168B7280(_Unwind_Exception *a1, int a2)
{
  _BYTE *v2;
  void *v3;

  __cxa_free_exception(v3);
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    if (*v2)
      *v2 = 0;
    __cxa_end_catch();
    JUMPOUT(0x2168B7234);
  }
  _Unwind_Resume(a1);
}

uint64_t tlv::parseV<qos::tlv::FlowInfo>@<X0>(qos::tlv **a1@<X0>, int a2@<W1>, qos::tlv::FlowInfo *a3@<X3>, uint64_t a4@<X8>)
{
  qos::tlv *v5;
  uint64_t result;

  *(_OWORD *)(a4 + 320) = 0u;
  *(_OWORD *)(a4 + 336) = 0u;
  *(_OWORD *)(a4 + 288) = 0u;
  *(_OWORD *)(a4 + 304) = 0u;
  *(_OWORD *)(a4 + 256) = 0u;
  *(_OWORD *)(a4 + 272) = 0u;
  *(_OWORD *)(a4 + 224) = 0u;
  *(_OWORD *)(a4 + 240) = 0u;
  *(_OWORD *)(a4 + 192) = 0u;
  *(_OWORD *)(a4 + 208) = 0u;
  *(_OWORD *)(a4 + 160) = 0u;
  *(_OWORD *)(a4 + 176) = 0u;
  *(_OWORD *)(a4 + 128) = 0u;
  *(_OWORD *)(a4 + 144) = 0u;
  *(_OWORD *)(a4 + 96) = 0u;
  *(_OWORD *)(a4 + 112) = 0u;
  *(_OWORD *)(a4 + 64) = 0u;
  *(_OWORD *)(a4 + 80) = 0u;
  *(_OWORD *)(a4 + 32) = 0u;
  *(_OWORD *)(a4 + 48) = 0u;
  v5 = *a1;
  *(_OWORD *)a4 = 0u;
  *(_OWORD *)(a4 + 16) = 0u;
  result = qos::tlv::parseField(v5, (unsigned __int8 *)v5 + a2, (const unsigned __int8 *)a4, a3);
  *a1 = (qos::tlv *)result;
  return result;
}

void sub_2168B7328(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168B731CLL);
}

void sub_2168B7338(_Unwind_Exception *a1)
{
  qos::tlv::FlowInfo *v1;

  qos::tlv::FlowInfo::~FlowInfo(v1);
  _Unwind_Resume(a1);
}

void qos::tlv::FlowInfo::~FlowInfo(qos::tlv::FlowInfo *this)
{
  void **v2;

  if (*((_BYTE *)this + 348))
    *((_BYTE *)this + 348) = 0;
  if (*((_BYTE *)this + 346))
    *((_BYTE *)this + 346) = 0;
  if (*((_BYTE *)this + 344))
    *((_BYTE *)this + 344) = 0;
  if (*((_BYTE *)this + 208))
  {
    qos::tlv::FlowSpec::~FlowSpec((qos::tlv::FlowInfo *)((char *)this + 216));
    *((_BYTE *)this + 208) = 0;
  }
  if (*((_BYTE *)this + 72))
  {
    qos::tlv::FlowSpec::~FlowSpec((qos::tlv::FlowInfo *)((char *)this + 80));
    *((_BYTE *)this + 72) = 0;
  }
  if (*((_BYTE *)this + 40))
  {
    v2 = (void **)((char *)this + 48);
    std::vector<tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>>::__destroy_vector::operator()[abi:ne180100](&v2);
    *((_BYTE *)this + 40) = 0;
  }
  if (*((_BYTE *)this + 8))
  {
    v2 = (void **)((char *)this + 16);
    std::vector<tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>>::__destroy_vector::operator()[abi:ne180100](&v2);
    *((_BYTE *)this + 8) = 0;
  }
}

unsigned int *tlv::parseV<qos::tlv::IdentifierList>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, std::vector<unsigned int> *a3@<X8>)
{
  unsigned int *result;

  a3->__begin_ = 0;
  a3->__end_ = 0;
  a3->__end_cap_.__value_ = 0;
  result = qos::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = (unsigned __int8 *)result;
  return result;
}

void sub_2168B7434(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168B7428);
}

void sub_2168B7444(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_BYTE **tlv::writeV<qos::tlv::QosIdentifierList>(_BYTE **result, _DWORD *a2)
{
  _BYTE *v2;
  _DWORD *v3;
  int *v4;
  int *v5;
  int v6;

  v2 = *result;
  *v2 = (a2[2] - *a2) >> 2;
  v3 = v2 + 1;
  v4 = *(int **)a2;
  v5 = (int *)*((_QWORD *)a2 + 1);
  while (v4 != v5)
  {
    v6 = *v4++;
    *v3++ = v6;
  }
  *result = v3;
  return result;
}

uint64_t tlv::parseV<qos::tlv::QosStatusInfo>(unint64_t *a1, int a2)
{
  uint64_t v3;

  v3 = 0;
  *a1 = qos::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), (uint64_t)&v3);
  return v3;
}

void sub_2168B74D8(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168B74C4);
}

uint64_t tlv::parseV<qos::tlv::QosFlowState>(unint64_t *a1, int a2)
{
  uint64_t v3;
  int v4;

  v4 = 0;
  v3 = 0;
  *a1 = qos::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), (uint64_t)&v3);
  return v3;
}

void sub_2168B75A8(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168B7590);
}

void qos::tlv::FlowSpec::~FlowSpec(qos::tlv::FlowSpec *this)
{
  void *v2;

  if (*((_BYTE *)this + 120))
    *((_BYTE *)this + 120) = 0;
  if (*((_BYTE *)this + 118))
    *((_BYTE *)this + 118) = 0;
  if (*((_BYTE *)this + 116))
    *((_BYTE *)this + 116) = 0;
  if (*((_BYTE *)this + 114))
    *((_BYTE *)this + 114) = 0;
  if (*((_BYTE *)this + 112))
    *((_BYTE *)this + 112) = 0;
  if (*((_BYTE *)this + 108))
    *((_BYTE *)this + 108) = 0;
  if (*((_BYTE *)this + 106))
    *((_BYTE *)this + 106) = 0;
  if (*((_BYTE *)this + 104))
    *((_BYTE *)this + 104) = 0;
  if (*((_BYTE *)this + 96))
    *((_BYTE *)this + 96) = 0;
  if (*((_BYTE *)this + 88))
    *((_BYTE *)this + 88) = 0;
  if (*((_BYTE *)this + 80))
    *((_BYTE *)this + 80) = 0;
  if (*((_BYTE *)this + 72))
    *((_BYTE *)this + 72) = 0;
  if (*((_BYTE *)this + 64))
    *((_BYTE *)this + 64) = 0;
  if (*((_BYTE *)this + 32))
  {
    v2 = (void *)*((_QWORD *)this + 5);
    if (v2)
    {
      *((_QWORD *)this + 6) = v2;
      operator delete(v2);
    }
    *((_BYTE *)this + 32) = 0;
  }
  if (*((_BYTE *)this + 20))
    *((_BYTE *)this + 20) = 0;
  if (*((_BYTE *)this + 4))
    *((_BYTE *)this + 4) = 0;
  if (*(_BYTE *)this)
    *(_BYTE *)this = 0;
}

void qos::tlv::QoSFilter::~QoSFilter(qos::tlv::QoSFilter *this)
{
  if (*((_BYTE *)this + 129))
    *((_BYTE *)this + 129) = 0;
  if (*((_BYTE *)this + 116))
    *((_BYTE *)this + 116) = 0;
  if (*((_BYTE *)this + 104))
    *((_BYTE *)this + 104) = 0;
  if (*((_BYTE *)this + 86))
    *((_BYTE *)this + 86) = 0;
  if (*((_BYTE *)this + 68))
    *((_BYTE *)this + 68) = 0;
  if (*((_BYTE *)this + 66))
    *((_BYTE *)this + 66) = 0;
  if (*((_BYTE *)this + 63))
    *((_BYTE *)this + 63) = 0;
  if (*((_BYTE *)this + 60))
    *((_BYTE *)this + 60) = 0;
  if (*((_BYTE *)this + 52))
    *((_BYTE *)this + 52) = 0;
  if (*((_BYTE *)this + 46))
    *((_BYTE *)this + 46) = 0;
  if (*((_BYTE *)this + 40))
    *((_BYTE *)this + 40) = 0;
  if (*((_BYTE *)this + 34))
    *((_BYTE *)this + 34) = 0;
  if (*((_BYTE *)this + 28))
    *((_BYTE *)this + 28) = 0;
  if (*((_BYTE *)this + 22))
    *((_BYTE *)this + 22) = 0;
  if (*((_BYTE *)this + 16))
    *((_BYTE *)this + 16) = 0;
  if (*((_BYTE *)this + 8))
    *((_BYTE *)this + 8) = 0;
  if (*((_BYTE *)this + 4))
    *((_BYTE *)this + 4) = 0;
  if (*(_BYTE *)this)
    *(_BYTE *)this = 0;
}

void std::vector<tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = v2;
    if (v4 != v2)
    {
      do
        qos::tlv::QoSFilter::~QoSFilter((qos::tlv::QoSFilter *)(v4 - 132));
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

unsigned __int8 *tlv::parseField<(unsigned char)18,qos::tlv::IpFlowDataRateMinMax>(unsigned __int8 *a1, const unsigned __int8 *a2, _DWORD *a3)
{
  unint64_t v6;
  unint64_t v8;
  tlv::TlvParseException *exception;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 3uLL);
  if (*a1 != 18)
  {
    v8 = *a1;
    exception = (tlv::TlvParseException *)__cxa_allocate_exception(0x10uLL);
    tlv::TlvParseException::TlvParseException(exception, 0x12uLL, v8);
  }
  v6 = *(unsigned __int16 *)(a1 + 1);
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 3), a2, v6);
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 3), &a1[v6 + 3], 4uLL);
  *a3 = *(_DWORD *)(a1 + 3);
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 7), &a1[v6 + 3], 4uLL);
  a3[1] = *(_DWORD *)(a1 + 7);
  return a1 + 11;
}

void sub_2168B78CC(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void boost::optional_detail::optional_base<tlv::NestedTlv<(unsigned char)32,qos::tlv::IpFlowDataRateMinMaxEx>>::assign_expr<qos::tlv::IpFlowDataRateMinMaxEx,qos::tlv::IpFlowDataRateMinMaxEx>(_QWORD *a1, uint64_t a2)
{
  if (*(_BYTE *)a1)
  {
    boost::optional_detail::optional_base<tlv::NestedTlv<(unsigned char)32,qos::tlv::IpFlowDataRateMinMaxEx>>::assign_expr_to_initialized<qos::tlv::IpFlowDataRateMinMaxEx>(a1, a2);
  }
  else
  {
    a1[2] = 0;
    a1[3] = 0;
    a1[1] = 0;
    std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(a1 + 1, *(const void **)a2, *(_QWORD *)(a2 + 8), *(_QWORD *)(a2 + 8) - *(_QWORD *)a2);
    *(_BYTE *)a1 = 1;
  }
}

double boost::optional_detail::optional_base<tlv::NestedTlv<(unsigned char)32,qos::tlv::IpFlowDataRateMinMaxEx>>::assign_expr_to_initialized<qos::tlv::IpFlowDataRateMinMaxEx>(_QWORD *a1, uint64_t a2)
{
  void *v3;
  double result;
  __int128 v5;
  uint64_t v6;

  v5 = 0uLL;
  v6 = 0;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(&v5, *(const void **)a2, *(_QWORD *)(a2 + 8), *(_QWORD *)(a2 + 8) - *(_QWORD *)a2);
  v3 = (void *)a1[1];
  if (v3)
  {
    a1[2] = v3;
    operator delete(v3);
  }
  result = *(double *)&v5;
  *(_OWORD *)(a1 + 1) = v5;
  a1[3] = v6;
  return result;
}

__n128 std::vector<unsigned char>::__move_assign(uint64_t a1, __n128 *a2)
{
  void *v4;
  __n128 result;

  v4 = *(void **)a1;
  if (v4)
  {
    *(_QWORD *)(a1 + 8) = v4;
    operator delete(v4);
    *(_QWORD *)a1 = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
  }
  result = *a2;
  *(__n128 *)a1 = *a2;
  *(_QWORD *)(a1 + 16) = a2[1].n128_u64[0];
  a2->n128_u64[0] = 0;
  a2->n128_u64[1] = 0;
  a2[1].n128_u64[0] = 0;
  return result;
}

_QWORD *std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(_QWORD *result, const void *a2, uint64_t a3, size_t __sz)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (__sz)
  {
    v6 = result;
    result = std::vector<unsigned char>::__vallocate[abi:ne180100](result, __sz);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_2168B7A44(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

unsigned __int8 *tlv::parseField<(unsigned char)22,qos::tlv::IpFlowPacketErrorRate>(unsigned __int8 *a1, const unsigned __int8 *a2, _WORD *a3)
{
  unint64_t v6;
  unint64_t v8;
  tlv::TlvParseException *exception;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 3uLL);
  if (*a1 != 22)
  {
    v8 = *a1;
    exception = (tlv::TlvParseException *)__cxa_allocate_exception(0x10uLL);
    tlv::TlvParseException::TlvParseException(exception, 0x16uLL, v8);
  }
  v6 = *(unsigned __int16 *)(a1 + 1);
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 3), a2, v6);
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 3), &a1[v6 + 3], 2uLL);
  *a3 = *(_WORD *)(a1 + 3);
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 5), &a1[v6 + 3], 2uLL);
  a3[1] = *(_WORD *)(a1 + 5);
  return a1 + 7;
}

void sub_2168B7B2C(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

unsigned __int8 *tlv::parseField<(unsigned char)37,qos::tlv::IpFilterPort>(unsigned __int8 *a1, const unsigned __int8 *a2, _WORD *a3)
{
  unint64_t v6;
  unint64_t v8;
  tlv::TlvParseException *exception;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 3uLL);
  if (*a1 != 37)
  {
    v8 = *a1;
    exception = (tlv::TlvParseException *)__cxa_allocate_exception(0x10uLL);
    tlv::TlvParseException::TlvParseException(exception, 0x25uLL, v8);
  }
  v6 = *(unsigned __int16 *)(a1 + 1);
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 3), a2, v6);
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 3), &a1[v6 + 3], 2uLL);
  *a3 = *(_WORD *)(a1 + 3);
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 5), &a1[v6 + 3], 2uLL);
  a3[1] = *(_WORD *)(a1 + 5);
  return a1 + 7;
}

void sub_2168B7C0C(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

unsigned __int8 *tlv::parseField<(unsigned char)36,qos::tlv::IpFilterPort>(unsigned __int8 *a1, const unsigned __int8 *a2, _WORD *a3)
{
  unint64_t v6;
  unint64_t v8;
  tlv::TlvParseException *exception;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 3uLL);
  if (*a1 != 36)
  {
    v8 = *a1;
    exception = (tlv::TlvParseException *)__cxa_allocate_exception(0x10uLL);
    tlv::TlvParseException::TlvParseException(exception, 0x24uLL, v8);
  }
  v6 = *(unsigned __int16 *)(a1 + 1);
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 3), a2, v6);
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 3), &a1[v6 + 3], 2uLL);
  *a3 = *(_WORD *)(a1 + 3);
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 5), &a1[v6 + 3], 2uLL);
  a3[1] = *(_WORD *)(a1 + 5);
  return a1 + 7;
}

void sub_2168B7CEC(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

unsigned __int8 *tlv::parseField<(unsigned char)30,qos::tlv::IpFilterPort>(unsigned __int8 *a1, const unsigned __int8 *a2, _WORD *a3)
{
  unint64_t v6;
  unint64_t v8;
  tlv::TlvParseException *exception;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 3uLL);
  if (*a1 != 30)
  {
    v8 = *a1;
    exception = (tlv::TlvParseException *)__cxa_allocate_exception(0x10uLL);
    tlv::TlvParseException::TlvParseException(exception, 0x1EuLL, v8);
  }
  v6 = *(unsigned __int16 *)(a1 + 1);
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 3), a2, v6);
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 3), &a1[v6 + 3], 2uLL);
  *a3 = *(_WORD *)(a1 + 3);
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 5), &a1[v6 + 3], 2uLL);
  a3[1] = *(_WORD *)(a1 + 5);
  return a1 + 7;
}

void sub_2168B7DCC(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

unsigned __int8 *tlv::parseField<(unsigned char)29,qos::tlv::IpFilterPort>(unsigned __int8 *a1, const unsigned __int8 *a2, _WORD *a3)
{
  unint64_t v6;
  unint64_t v8;
  tlv::TlvParseException *exception;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 3uLL);
  if (*a1 != 29)
  {
    v8 = *a1;
    exception = (tlv::TlvParseException *)__cxa_allocate_exception(0x10uLL);
    tlv::TlvParseException::TlvParseException(exception, 0x1DuLL, v8);
  }
  v6 = *(unsigned __int16 *)(a1 + 1);
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 3), a2, v6);
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 3), &a1[v6 + 3], 2uLL);
  *a3 = *(_WORD *)(a1 + 3);
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 5), &a1[v6 + 3], 2uLL);
  a3[1] = *(_WORD *)(a1 + 5);
  return a1 + 7;
}

void sub_2168B7EAC(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

unsigned __int8 *tlv::parseField<(unsigned char)28,qos::tlv::IpFilterPort>(unsigned __int8 *a1, const unsigned __int8 *a2, _WORD *a3)
{
  unint64_t v6;
  unint64_t v8;
  tlv::TlvParseException *exception;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 3uLL);
  if (*a1 != 28)
  {
    v8 = *a1;
    exception = (tlv::TlvParseException *)__cxa_allocate_exception(0x10uLL);
    tlv::TlvParseException::TlvParseException(exception, 0x1CuLL, v8);
  }
  v6 = *(unsigned __int16 *)(a1 + 1);
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 3), a2, v6);
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 3), &a1[v6 + 3], 2uLL);
  *a3 = *(_WORD *)(a1 + 3);
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 5), &a1[v6 + 3], 2uLL);
  a3[1] = *(_WORD *)(a1 + 5);
  return a1 + 7;
}

void sub_2168B7F8C(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

unsigned __int8 *tlv::parseField<(unsigned char)27,qos::tlv::IpFilterPort>(unsigned __int8 *a1, const unsigned __int8 *a2, _WORD *a3)
{
  unint64_t v6;
  unint64_t v8;
  tlv::TlvParseException *exception;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 3uLL);
  if (*a1 != 27)
  {
    v8 = *a1;
    exception = (tlv::TlvParseException *)__cxa_allocate_exception(0x10uLL);
    tlv::TlvParseException::TlvParseException(exception, 0x1BuLL, v8);
  }
  v6 = *(unsigned __int16 *)(a1 + 1);
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 3), a2, v6);
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 3), &a1[v6 + 3], 2uLL);
  *a3 = *(_WORD *)(a1 + 3);
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 5), &a1[v6 + 3], 2uLL);
  a3[1] = *(_WORD *)(a1 + 5);
  return a1 + 7;
}

void sub_2168B806C(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

unsigned __int8 *tlv::parseField<(unsigned char)25,qos::tlv::Ipv6FilterTrafficClass>(unsigned __int8 *a1, const unsigned __int8 *a2, _BYTE *a3)
{
  unint64_t v6;
  unint64_t v8;
  tlv::TlvParseException *exception;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 3uLL);
  if (*a1 != 25)
  {
    v8 = *a1;
    exception = (tlv::TlvParseException *)__cxa_allocate_exception(0x10uLL);
    tlv::TlvParseException::TlvParseException(exception, 0x19uLL, v8);
  }
  v6 = *(unsigned __int16 *)(a1 + 1);
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 3), a2, v6);
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 3), &a1[v6 + 3], 1uLL);
  *a3 = a1[3];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 4), &a1[v6 + 3], 1uLL);
  a3[1] = a1[4];
  return a1 + 5;
}

void sub_2168B814C(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

unsigned __int8 *tlv::parseField<(unsigned char)21,qos::tlv::IpFilterTypeOfService>(unsigned __int8 *a1, const unsigned __int8 *a2, _BYTE *a3)
{
  unint64_t v6;
  unint64_t v8;
  tlv::TlvParseException *exception;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 3uLL);
  if (*a1 != 21)
  {
    v8 = *a1;
    exception = (tlv::TlvParseException *)__cxa_allocate_exception(0x10uLL);
    tlv::TlvParseException::TlvParseException(exception, 0x15uLL, v8);
  }
  v6 = *(unsigned __int16 *)(a1 + 1);
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 3), a2, v6);
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 3), &a1[v6 + 3], 1uLL);
  *a3 = a1[3];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 4), &a1[v6 + 3], 1uLL);
  a3[1] = a1[4];
  return a1 + 5;
}

void sub_2168B822C(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

unsigned __int8 *tlv::parseField<(unsigned char)23,qos::tlv::Ipv6FilterAddress>(unsigned __int8 *a1, const unsigned __int8 *a2, uint64_t a3)
{
  unint64_t v6;
  unint64_t v8;
  tlv::TlvParseException *exception;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 3uLL);
  if (*a1 != 23)
  {
    v8 = *a1;
    exception = (tlv::TlvParseException *)__cxa_allocate_exception(0x10uLL);
    tlv::TlvParseException::TlvParseException(exception, 0x17uLL, v8);
  }
  v6 = *(unsigned __int16 *)(a1 + 1);
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 3), a2, v6);
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 3), &a1[v6 + 3], 0x10uLL);
  *(_OWORD *)a3 = *(_OWORD *)(a1 + 3);
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 19), &a1[v6 + 3], 1uLL);
  *(_BYTE *)(a3 + 16) = a1[19];
  return a1 + 20;
}

void sub_2168B830C(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

unsigned __int8 *tlv::parseField<(unsigned char)22,qos::tlv::Ipv6FilterAddress>(unsigned __int8 *a1, const unsigned __int8 *a2, uint64_t a3)
{
  unint64_t v6;
  unint64_t v8;
  tlv::TlvParseException *exception;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 3uLL);
  if (*a1 != 22)
  {
    v8 = *a1;
    exception = (tlv::TlvParseException *)__cxa_allocate_exception(0x10uLL);
    tlv::TlvParseException::TlvParseException(exception, 0x16uLL, v8);
  }
  v6 = *(unsigned __int16 *)(a1 + 1);
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 3), a2, v6);
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 3), &a1[v6 + 3], 0x10uLL);
  *(_OWORD *)a3 = *(_OWORD *)(a1 + 3);
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 19), &a1[v6 + 3], 1uLL);
  *(_BYTE *)(a3 + 16) = a1[19];
  return a1 + 20;
}

void sub_2168B83EC(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

unsigned __int8 *tlv::parseField<(unsigned char)19,qos::tlv::Ipv4FilterAddress>(unsigned __int8 *a1, const unsigned __int8 *a2, _DWORD *a3)
{
  unint64_t v6;
  unint64_t v8;
  tlv::TlvParseException *exception;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 3uLL);
  if (*a1 != 19)
  {
    v8 = *a1;
    exception = (tlv::TlvParseException *)__cxa_allocate_exception(0x10uLL);
    tlv::TlvParseException::TlvParseException(exception, 0x13uLL, v8);
  }
  v6 = *(unsigned __int16 *)(a1 + 1);
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 3), a2, v6);
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 3), &a1[v6 + 3], 4uLL);
  *a3 = *(_DWORD *)(a1 + 3);
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 7), &a1[v6 + 3], 4uLL);
  a3[1] = *(_DWORD *)(a1 + 7);
  return a1 + 11;
}

void sub_2168B84CC(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

unsigned __int8 *tlv::parseField<(unsigned char)18,qos::tlv::Ipv4FilterAddress>(unsigned __int8 *a1, const unsigned __int8 *a2, _DWORD *a3)
{
  unint64_t v6;
  unint64_t v8;
  tlv::TlvParseException *exception;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 3uLL);
  if (*a1 != 18)
  {
    v8 = *a1;
    exception = (tlv::TlvParseException *)__cxa_allocate_exception(0x10uLL);
    tlv::TlvParseException::TlvParseException(exception, 0x12uLL, v8);
  }
  v6 = *(unsigned __int16 *)(a1 + 1);
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 3), a2, v6);
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 3), &a1[v6 + 3], 4uLL);
  *a3 = *(_DWORD *)(a1 + 3);
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 7), &a1[v6 + 3], 4uLL);
  a3[1] = *(_DWORD *)(a1 + 7);
  return a1 + 11;
}

void sub_2168B85AC(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t std::vector<tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v5 = *a1;
  v4 = a1[1];
  result = a2[1];
  while (v4 != v5)
  {
    v4 -= 132;
    result = qos::tlv::QoSFilter::QoSFilter(result - 132, v4);
  }
  a2[1] = result;
  v7 = *a1;
  *a1 = result;
  a2[1] = v7;
  v8 = a1[1];
  a1[1] = a2[2];
  a2[2] = v8;
  v9 = a1[2];
  a1[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

uint64_t qos::tlv::QoSFilter::QoSFilter(uint64_t result, uint64_t a2)
{
  __int128 v2;
  __int128 v3;

  *(_BYTE *)result = 0;
  if (*(_BYTE *)a2)
  {
    *(_WORD *)(result + 2) = *(_WORD *)(a2 + 2);
    *(_BYTE *)result = 1;
  }
  *(_BYTE *)(result + 4) = 0;
  if (*(_BYTE *)(a2 + 4))
  {
    *(_WORD *)(result + 6) = *(_WORD *)(a2 + 6);
    *(_BYTE *)(result + 4) = 1;
  }
  *(_BYTE *)(result + 8) = 0;
  if (*(_BYTE *)(a2 + 8))
  {
    *(_DWORD *)(result + 12) = *(_DWORD *)(a2 + 12);
    *(_BYTE *)(result + 8) = 1;
  }
  *(_BYTE *)(result + 16) = 0;
  if (*(_BYTE *)(a2 + 16))
  {
    *(_DWORD *)(result + 18) = *(_DWORD *)(a2 + 18);
    *(_BYTE *)(result + 16) = 1;
  }
  *(_BYTE *)(result + 22) = 0;
  if (*(_BYTE *)(a2 + 22))
  {
    *(_DWORD *)(result + 24) = *(_DWORD *)(a2 + 24);
    *(_BYTE *)(result + 22) = 1;
  }
  *(_BYTE *)(result + 28) = 0;
  if (*(_BYTE *)(a2 + 28))
  {
    *(_DWORD *)(result + 30) = *(_DWORD *)(a2 + 30);
    *(_BYTE *)(result + 28) = 1;
  }
  *(_BYTE *)(result + 34) = 0;
  if (*(_BYTE *)(a2 + 34))
  {
    *(_DWORD *)(result + 36) = *(_DWORD *)(a2 + 36);
    *(_BYTE *)(result + 34) = 1;
  }
  *(_BYTE *)(result + 40) = 0;
  if (*(_BYTE *)(a2 + 40))
  {
    *(_DWORD *)(result + 42) = *(_DWORD *)(a2 + 42);
    *(_BYTE *)(result + 40) = 1;
  }
  *(_BYTE *)(result + 46) = 0;
  if (*(_BYTE *)(a2 + 46))
  {
    *(_DWORD *)(result + 48) = *(_DWORD *)(a2 + 48);
    *(_BYTE *)(result + 46) = 1;
  }
  *(_BYTE *)(result + 52) = 0;
  if (*(_BYTE *)(a2 + 52))
  {
    *(_DWORD *)(result + 56) = *(_DWORD *)(a2 + 56);
    *(_BYTE *)(result + 52) = 1;
  }
  *(_BYTE *)(result + 60) = 0;
  if (*(_BYTE *)(a2 + 60))
  {
    *(_WORD *)(result + 61) = *(_WORD *)(a2 + 61);
    *(_BYTE *)(result + 60) = 1;
  }
  *(_BYTE *)(result + 63) = 0;
  if (*(_BYTE *)(a2 + 63))
  {
    *(_WORD *)(result + 64) = *(_WORD *)(a2 + 64);
    *(_BYTE *)(result + 63) = 1;
  }
  *(_BYTE *)(result + 66) = 0;
  if (*(_BYTE *)(a2 + 66))
  {
    *(_BYTE *)(result + 67) = *(_BYTE *)(a2 + 67);
    *(_BYTE *)(result + 66) = 1;
  }
  *(_BYTE *)(result + 68) = 0;
  if (*(_BYTE *)(a2 + 68))
  {
    v2 = *(_OWORD *)(a2 + 69);
    *(_BYTE *)(result + 85) = *(_BYTE *)(a2 + 85);
    *(_OWORD *)(result + 69) = v2;
    *(_BYTE *)(result + 68) = 1;
  }
  *(_BYTE *)(result + 86) = 0;
  if (*(_BYTE *)(a2 + 86))
  {
    v3 = *(_OWORD *)(a2 + 87);
    *(_BYTE *)(result + 103) = *(_BYTE *)(a2 + 103);
    *(_OWORD *)(result + 87) = v3;
    *(_BYTE *)(result + 86) = 1;
  }
  *(_BYTE *)(result + 104) = 0;
  if (*(_BYTE *)(a2 + 104))
  {
    *(_QWORD *)(result + 108) = *(_QWORD *)(a2 + 108);
    *(_BYTE *)(result + 104) = 1;
  }
  *(_BYTE *)(result + 116) = 0;
  if (*(_BYTE *)(a2 + 116))
  {
    *(_QWORD *)(result + 120) = *(_QWORD *)(a2 + 120);
    *(_BYTE *)(result + 116) = 1;
  }
  *(_BYTE *)(result + 128) = *(_BYTE *)(a2 + 128);
  *(_BYTE *)(result + 129) = 0;
  if (*(_BYTE *)(a2 + 129))
  {
    *(_BYTE *)(result + 130) = *(_BYTE *)(a2 + 130);
    *(_BYTE *)(result + 129) = 1;
  }
  return result;
}

uint64_t std::__split_buffer<tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 132;
    qos::tlv::QoSFilter::~QoSFilter((qos::tlv::QoSFilter *)(i - 132));
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::vector<qos::tlv::QosFilterSpec>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;

  v2 = 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 4);
  v3 = a2 >= v2;
  v4 = a2 - v2;
  if (v4 != 0 && v3)
  {
    std::vector<qos::tlv::QosFilterSpec>::__append((void **)a1, v4);
  }
  else if (!v3)
  {
    *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 176 * a2;
  }
}

void std::vector<qos::tlv::QosFilterSpec>::__append(void **a1, unint64_t a2)
{
  uint64_t v4;
  _BYTE *v5;
  _BYTE *v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  size_t v13;
  char *v14;
  char *v15;
  size_t v16;
  char *v17;
  char *v18;
  char *v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (0x2E8BA2E8BA2E8BA3 * ((v6 - v7) >> 4) >= a2)
  {
    if (a2)
    {
      v13 = 176 * ((176 * a2 - 176) / 0xB0) + 176;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = 0x2E8BA2E8BA2E8BA3 * ((v7 - (_BYTE *)*a1) >> 4);
    v9 = v8 + a2;
    if (v8 + a2 > 0x1745D1745D1745DLL)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = 0x2E8BA2E8BA2E8BA3 * ((v5 - (_BYTE *)*a1) >> 4);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0xBA2E8BA2E8BA2ELL)
      v11 = 0x1745D1745D1745DLL;
    else
      v11 = v9;
    if (v11)
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<qos::tlv::QosFilterSpec>>(v4, v11);
    else
      v12 = 0;
    v14 = &v12[176 * v8];
    v15 = &v12[176 * v11];
    v16 = 176 * ((176 * a2 - 176) / 0xB0) + 176;
    bzero(v14, v16);
    v17 = &v14[v16];
    v19 = (char *)*a1;
    v18 = (char *)a1[1];
    if (v18 != *a1)
    {
      do
      {
        v20 = *((_OWORD *)v18 - 11);
        v21 = *((_OWORD *)v18 - 9);
        *((_OWORD *)v14 - 10) = *((_OWORD *)v18 - 10);
        *((_OWORD *)v14 - 9) = v21;
        *((_OWORD *)v14 - 11) = v20;
        v22 = *((_OWORD *)v18 - 8);
        v23 = *((_OWORD *)v18 - 7);
        v24 = *((_OWORD *)v18 - 5);
        *((_OWORD *)v14 - 6) = *((_OWORD *)v18 - 6);
        *((_OWORD *)v14 - 5) = v24;
        *((_OWORD *)v14 - 8) = v22;
        *((_OWORD *)v14 - 7) = v23;
        v25 = *((_OWORD *)v18 - 4);
        v26 = *((_OWORD *)v18 - 3);
        v27 = *((_OWORD *)v18 - 1);
        *((_OWORD *)v14 - 2) = *((_OWORD *)v18 - 2);
        *((_OWORD *)v14 - 1) = v27;
        *((_OWORD *)v14 - 4) = v25;
        *((_OWORD *)v14 - 3) = v26;
        v14 -= 176;
        v18 -= 176;
      }
      while (v18 != v19);
      v18 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v17;
    a1[2] = v15;
    if (v18)
      operator delete(v18);
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<qos::tlv::QosFilterSpec>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x1745D1745D1745ELL)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(176 * a2);
}

void boost::optional_detail::optional_base<tlv::NestedTlv<(unsigned char)20,qos::tlv::QoSFilterList>>::assign_expr<qos::tlv::QoSFilterList,qos::tlv::QoSFilterList>(uint64_t a1, uint64_t *a2)
{
  if (*(_BYTE *)a1)
  {
    boost::optional_detail::optional_base<tlv::NestedTlv<(unsigned char)20,qos::tlv::QoSFilterList>>::assign_expr_to_initialized<qos::tlv::QoSFilterList>(a1, a2);
  }
  else
  {
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)(a1 + 24) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    std::vector<tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>>::__init_with_size[abi:ne180100]<tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>*,tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>*>((_QWORD *)(a1 + 8), *a2, a2[1], 0xF83E0F83E0F83E1 * ((a2[1] - *a2) >> 2));
    *(_BYTE *)a1 = 1;
  }
}

void boost::optional_detail::optional_base<tlv::NestedTlv<(unsigned char)20,qos::tlv::QoSFilterList>>::assign_expr_to_initialized<qos::tlv::QoSFilterList>(uint64_t a1, uint64_t *a2)
{
  __int128 v3;
  uint64_t v4;
  void **v5;

  v3 = 0uLL;
  v4 = 0;
  std::vector<tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>>::__init_with_size[abi:ne180100]<tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>*,tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>*>(&v3, *a2, a2[1], 0xF83E0F83E0F83E1 * ((a2[1] - *a2) >> 2));
  std::vector<tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>>::__vdeallocate((void **)(a1 + 8));
  *(_OWORD *)(a1 + 8) = v3;
  *(_QWORD *)(a1 + 24) = v4;
  v4 = 0;
  v3 = 0uLL;
  v5 = (void **)&v3;
  std::vector<tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>>::__destroy_vector::operator()[abi:ne180100](&v5);
}

void std::vector<tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>>::__vdeallocate(void **a1)
{
  char *v1;
  char *v3;
  void *v4;

  v1 = (char *)*a1;
  if (*a1)
  {
    v3 = (char *)a1[1];
    v4 = v1;
    if (v3 != v1)
    {
      do
        qos::tlv::QoSFilter::~QoSFilter((qos::tlv::QoSFilter *)(v3 - 132));
      while (v3 != v1);
      v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

_QWORD *std::vector<tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>>::__init_with_size[abi:ne180100]<tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>*,tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>*>(_QWORD *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;

  if (a4)
  {
    v6 = result;
    std::vector<tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>>::__vallocate[abi:ne180100](result, a4);
    result = (_QWORD *)std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>>,tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>*,tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>*,tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>*>((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_2168B8CA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  uint64_t v9;
  uint64_t v10;

  *(_QWORD *)(v9 + 8) = v10;
  std::vector<tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

char *std::vector<tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >= 0x1F07C1F07C1F07DLL)
    std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::FrameData>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[132 * v4];
  return result;
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>>,tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>*,tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>*,tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;

  if (a2 != a3)
  {
    v7 = 0;
    do
    {
      qos::tlv::QoSFilter::QoSFilter(a4 + v7, a2 + v7);
      v7 += 132;
    }
    while (a2 + v7 != a3);
    a4 += v7;
  }
  return a4;
}

void sub_2168B8D78(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v4;

  if (v2)
  {
    v4 = v1 - 132;
    do
    {
      qos::tlv::QoSFilter::~QoSFilter((qos::tlv::QoSFilter *)(v4 + v2));
      v2 -= 132;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

void boost::optional_detail::optional_base<tlv::NestedTlv<(unsigned char)18,qos::tlv::FlowGranted>>::assign_expr<qos::tlv::FlowGranted,qos::tlv::FlowGranted>(_BYTE *a1, const qos::tlv::FlowSpec *a2)
{
  if (*a1)
  {
    boost::optional_detail::optional_base<tlv::NestedTlv<(unsigned char)18,qos::tlv::FlowGranted>>::assign_expr_to_initialized<qos::tlv::FlowGranted>((uint64_t)a1, a2);
  }
  else
  {
    qos::tlv::FlowSpec::FlowSpec((qos::tlv::FlowSpec *)(a1 + 8), a2);
    *a1 = 1;
  }
}

void boost::optional_detail::optional_base<tlv::NestedTlv<(unsigned char)18,qos::tlv::FlowGranted>>::assign_expr_to_initialized<qos::tlv::FlowGranted>(uint64_t a1, const qos::tlv::FlowSpec *a2)
{
  _BYTE v3[40];
  void *__p;
  void *v5;
  char v6;
  char v7;
  char v8;
  char v9;
  char v10;
  char v11;
  char v12;
  char v13;
  char v14;
  char v15;
  char v16;
  char v17;
  char v18;
  uint64_t v19;

  v19 = *MEMORY[0x24BDAC8D0];
  qos::tlv::FlowSpec::FlowSpec((qos::tlv::FlowSpec *)v3, a2);
  qos::tlv::FlowSpec::operator=(a1 + 8, (uint64_t)v3);
  if (v18)
    v18 = 0;
  if (v17)
    v17 = 0;
  if (v16)
    v16 = 0;
  if (v15)
    v15 = 0;
  if (v14)
    v14 = 0;
  if (v13)
    v13 = 0;
  if (v12)
    v12 = 0;
  if (v11)
    v11 = 0;
  if (v10)
    v10 = 0;
  if (v9)
    v9 = 0;
  if (v8)
    v8 = 0;
  if (v7)
    v7 = 0;
  if (v6)
    v6 = 0;
  if (v3[32])
  {
    if (__p)
    {
      v5 = __p;
      operator delete(__p);
    }
  }
}

uint64_t qos::tlv::FlowSpec::operator=(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;

  if (*(_BYTE *)a1)
  {
    if (*(_BYTE *)a2)
      *(_BYTE *)(a1 + 1) = *(_BYTE *)(a2 + 1);
    else
      *(_BYTE *)a1 = 0;
  }
  else if (*(_BYTE *)a2)
  {
    *(_BYTE *)(a1 + 1) = *(_BYTE *)(a2 + 1);
    *(_BYTE *)a1 = 1;
  }
  if (*(_BYTE *)(a1 + 4))
  {
    if (*(_BYTE *)(a2 + 4))
    {
      v4 = *(_QWORD *)(a2 + 8);
      *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
      *(_QWORD *)(a1 + 8) = v4;
    }
    else
    {
      *(_BYTE *)(a1 + 4) = 0;
    }
  }
  else if (*(_BYTE *)(a2 + 4))
  {
    v5 = *(_QWORD *)(a2 + 8);
    *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
    *(_QWORD *)(a1 + 8) = v5;
    *(_BYTE *)(a1 + 4) = 1;
  }
  if (*(_BYTE *)(a1 + 20))
  {
    if (*(_BYTE *)(a2 + 20))
      *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
    else
      *(_BYTE *)(a1 + 20) = 0;
  }
  else if (*(_BYTE *)(a2 + 20))
  {
    *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
    *(_BYTE *)(a1 + 20) = 1;
  }
  boost::optional_detail::optional_base<tlv::NestedTlv<(unsigned char)32,qos::tlv::IpFlowDataRateMinMaxEx>>::assign(a1 + 32, a2 + 32);
  if (*(_BYTE *)(a1 + 64))
  {
    if (*(_BYTE *)(a2 + 64))
      *(_DWORD *)(a1 + 68) = *(_DWORD *)(a2 + 68);
    else
      *(_BYTE *)(a1 + 64) = 0;
  }
  else if (*(_BYTE *)(a2 + 64))
  {
    *(_DWORD *)(a1 + 68) = *(_DWORD *)(a2 + 68);
    *(_BYTE *)(a1 + 64) = 1;
  }
  if (*(_BYTE *)(a1 + 72))
  {
    if (*(_BYTE *)(a2 + 72))
      *(_DWORD *)(a1 + 76) = *(_DWORD *)(a2 + 76);
    else
      *(_BYTE *)(a1 + 72) = 0;
  }
  else if (*(_BYTE *)(a2 + 72))
  {
    *(_DWORD *)(a1 + 76) = *(_DWORD *)(a2 + 76);
    *(_BYTE *)(a1 + 72) = 1;
  }
  if (*(_BYTE *)(a1 + 80))
  {
    if (*(_BYTE *)(a2 + 80))
      *(_DWORD *)(a1 + 82) = *(_DWORD *)(a2 + 82);
    else
      *(_BYTE *)(a1 + 80) = 0;
  }
  else if (*(_BYTE *)(a2 + 80))
  {
    *(_DWORD *)(a1 + 82) = *(_DWORD *)(a2 + 82);
    *(_BYTE *)(a1 + 80) = 1;
  }
  if (*(_BYTE *)(a1 + 88))
  {
    if (*(_BYTE *)(a2 + 88))
      *(_DWORD *)(a1 + 92) = *(_DWORD *)(a2 + 92);
    else
      *(_BYTE *)(a1 + 88) = 0;
  }
  else if (*(_BYTE *)(a2 + 88))
  {
    *(_DWORD *)(a1 + 92) = *(_DWORD *)(a2 + 92);
    *(_BYTE *)(a1 + 88) = 1;
  }
  if (*(_BYTE *)(a1 + 96))
  {
    if (*(_BYTE *)(a2 + 96))
      *(_DWORD *)(a1 + 100) = *(_DWORD *)(a2 + 100);
    else
      *(_BYTE *)(a1 + 96) = 0;
  }
  else if (*(_BYTE *)(a2 + 96))
  {
    *(_DWORD *)(a1 + 100) = *(_DWORD *)(a2 + 100);
    *(_BYTE *)(a1 + 96) = 1;
  }
  if (*(_BYTE *)(a1 + 104))
  {
    if (*(_BYTE *)(a2 + 104))
      *(_BYTE *)(a1 + 105) = *(_BYTE *)(a2 + 105);
    else
      *(_BYTE *)(a1 + 104) = 0;
  }
  else if (*(_BYTE *)(a2 + 104))
  {
    *(_BYTE *)(a1 + 105) = *(_BYTE *)(a2 + 105);
    *(_BYTE *)(a1 + 104) = 1;
  }
  if (*(_BYTE *)(a1 + 106))
  {
    if (*(_BYTE *)(a2 + 106))
      *(_BYTE *)(a1 + 107) = *(_BYTE *)(a2 + 107);
    else
      *(_BYTE *)(a1 + 106) = 0;
  }
  else if (*(_BYTE *)(a2 + 106))
  {
    *(_BYTE *)(a1 + 107) = *(_BYTE *)(a2 + 107);
    *(_BYTE *)(a1 + 106) = 1;
  }
  if (*(_BYTE *)(a1 + 108))
  {
    if (*(_BYTE *)(a2 + 108))
      *(_WORD *)(a1 + 110) = *(_WORD *)(a2 + 110);
    else
      *(_BYTE *)(a1 + 108) = 0;
  }
  else if (*(_BYTE *)(a2 + 108))
  {
    *(_WORD *)(a1 + 110) = *(_WORD *)(a2 + 110);
    *(_BYTE *)(a1 + 108) = 1;
  }
  if (*(_BYTE *)(a1 + 112))
  {
    if (*(_BYTE *)(a2 + 112))
      *(_BYTE *)(a1 + 113) = *(_BYTE *)(a2 + 113);
    else
      *(_BYTE *)(a1 + 112) = 0;
  }
  else if (*(_BYTE *)(a2 + 112))
  {
    *(_BYTE *)(a1 + 113) = *(_BYTE *)(a2 + 113);
    *(_BYTE *)(a1 + 112) = 1;
  }
  if (*(_BYTE *)(a1 + 114))
  {
    if (*(_BYTE *)(a2 + 114))
      *(_BYTE *)(a1 + 115) = *(_BYTE *)(a2 + 115);
    else
      *(_BYTE *)(a1 + 114) = 0;
  }
  else if (*(_BYTE *)(a2 + 114))
  {
    *(_BYTE *)(a1 + 115) = *(_BYTE *)(a2 + 115);
    *(_BYTE *)(a1 + 114) = 1;
  }
  if (*(_BYTE *)(a1 + 116))
  {
    if (*(_BYTE *)(a2 + 116))
      *(_BYTE *)(a1 + 117) = *(_BYTE *)(a2 + 117);
    else
      *(_BYTE *)(a1 + 116) = 0;
  }
  else if (*(_BYTE *)(a2 + 116))
  {
    *(_BYTE *)(a1 + 117) = *(_BYTE *)(a2 + 117);
    *(_BYTE *)(a1 + 116) = 1;
  }
  if (*(_BYTE *)(a1 + 118))
  {
    if (*(_BYTE *)(a2 + 118))
      *(_BYTE *)(a1 + 119) = *(_BYTE *)(a2 + 119);
    else
      *(_BYTE *)(a1 + 118) = 0;
  }
  else if (*(_BYTE *)(a2 + 118))
  {
    *(_BYTE *)(a1 + 119) = *(_BYTE *)(a2 + 119);
    *(_BYTE *)(a1 + 118) = 1;
  }
  if (*(_BYTE *)(a1 + 120))
  {
    if (*(_BYTE *)(a2 + 120))
      *(_BYTE *)(a1 + 121) = *(_BYTE *)(a2 + 121);
    else
      *(_BYTE *)(a1 + 120) = 0;
  }
  else if (*(_BYTE *)(a2 + 120))
  {
    *(_BYTE *)(a1 + 121) = *(_BYTE *)(a2 + 121);
    *(_BYTE *)(a1 + 120) = 1;
  }
  return a1;
}

void boost::optional_detail::optional_base<tlv::NestedTlv<(unsigned char)32,qos::tlv::IpFlowDataRateMinMaxEx>>::assign(uint64_t a1, uint64_t a2)
{
  void *v3;

  if (*(_BYTE *)a1)
  {
    if (*(_BYTE *)a2)
    {
      std::vector<unsigned char>::__move_assign(a1 + 8, (__n128 *)(a2 + 8));
    }
    else
    {
      v3 = *(void **)(a1 + 8);
      if (v3)
      {
        *(_QWORD *)(a1 + 16) = v3;
        operator delete(v3);
      }
      *(_BYTE *)a1 = 0;
    }
  }
  else if (*(_BYTE *)a2)
  {
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)(a1 + 24) = 0;
    *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
    *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    *(_QWORD *)(a2 + 24) = 0;
    *(_BYTE *)a1 = 1;
  }
}

qos::tlv::FlowSpec *qos::tlv::FlowSpec::FlowSpec(qos::tlv::FlowSpec *this, const qos::tlv::FlowSpec *a2)
{
  uint64_t v4;

  *(_BYTE *)this = 0;
  if (*(_BYTE *)a2)
  {
    *((_BYTE *)this + 1) = *((_BYTE *)a2 + 1);
    *(_BYTE *)this = 1;
  }
  *((_BYTE *)this + 4) = 0;
  if (*((_BYTE *)a2 + 4))
  {
    v4 = *((_QWORD *)a2 + 1);
    *((_DWORD *)this + 4) = *((_DWORD *)a2 + 4);
    *((_QWORD *)this + 1) = v4;
    *((_BYTE *)this + 4) = 1;
  }
  *((_BYTE *)this + 20) = 0;
  if (*((_BYTE *)a2 + 20))
  {
    *((_QWORD *)this + 3) = *((_QWORD *)a2 + 3);
    *((_BYTE *)this + 20) = 1;
  }
  boost::optional_detail::optional_base<tlv::NestedTlv<(unsigned char)32,qos::tlv::IpFlowDataRateMinMaxEx>>::optional_base((uint64_t)this + 32, (uint64_t)a2 + 32);
  *((_BYTE *)this + 64) = 0;
  if (*((_BYTE *)a2 + 64))
  {
    *((_DWORD *)this + 17) = *((_DWORD *)a2 + 17);
    *((_BYTE *)this + 64) = 1;
  }
  *((_BYTE *)this + 72) = 0;
  if (*((_BYTE *)a2 + 72))
  {
    *((_DWORD *)this + 19) = *((_DWORD *)a2 + 19);
    *((_BYTE *)this + 72) = 1;
  }
  *((_BYTE *)this + 80) = 0;
  if (*((_BYTE *)a2 + 80))
  {
    *(_DWORD *)((char *)this + 82) = *(_DWORD *)((char *)a2 + 82);
    *((_BYTE *)this + 80) = 1;
  }
  *((_BYTE *)this + 88) = 0;
  if (*((_BYTE *)a2 + 88))
  {
    *((_DWORD *)this + 23) = *((_DWORD *)a2 + 23);
    *((_BYTE *)this + 88) = 1;
  }
  *((_BYTE *)this + 96) = 0;
  if (*((_BYTE *)a2 + 96))
  {
    *((_DWORD *)this + 25) = *((_DWORD *)a2 + 25);
    *((_BYTE *)this + 96) = 1;
  }
  *((_BYTE *)this + 104) = 0;
  if (*((_BYTE *)a2 + 104))
  {
    *((_BYTE *)this + 105) = *((_BYTE *)a2 + 105);
    *((_BYTE *)this + 104) = 1;
  }
  *((_BYTE *)this + 106) = 0;
  if (*((_BYTE *)a2 + 106))
  {
    *((_BYTE *)this + 107) = *((_BYTE *)a2 + 107);
    *((_BYTE *)this + 106) = 1;
  }
  *((_BYTE *)this + 108) = 0;
  if (*((_BYTE *)a2 + 108))
  {
    *((_WORD *)this + 55) = *((_WORD *)a2 + 55);
    *((_BYTE *)this + 108) = 1;
  }
  *((_BYTE *)this + 112) = 0;
  if (*((_BYTE *)a2 + 112))
  {
    *((_BYTE *)this + 113) = *((_BYTE *)a2 + 113);
    *((_BYTE *)this + 112) = 1;
  }
  *((_BYTE *)this + 114) = 0;
  if (*((_BYTE *)a2 + 114))
  {
    *((_BYTE *)this + 115) = *((_BYTE *)a2 + 115);
    *((_BYTE *)this + 114) = 1;
  }
  *((_BYTE *)this + 116) = 0;
  if (*((_BYTE *)a2 + 116))
  {
    *((_BYTE *)this + 117) = *((_BYTE *)a2 + 117);
    *((_BYTE *)this + 116) = 1;
  }
  *((_BYTE *)this + 118) = 0;
  if (*((_BYTE *)a2 + 118))
  {
    *((_BYTE *)this + 119) = *((_BYTE *)a2 + 119);
    *((_BYTE *)this + 118) = 1;
  }
  *((_BYTE *)this + 120) = 0;
  if (*((_BYTE *)a2 + 120))
  {
    *((_BYTE *)this + 121) = *((_BYTE *)a2 + 121);
    *((_BYTE *)this + 120) = 1;
  }
  return this;
}

void sub_2168B953C(_Unwind_Exception *a1)
{
  _BYTE *v1;

  if (v1[20])
    v1[20] = 0;
  if (v1[4])
    v1[4] = 0;
  if (*v1)
    *v1 = 0;
  _Unwind_Resume(a1);
}

uint64_t boost::optional_detail::optional_base<tlv::NestedTlv<(unsigned char)32,qos::tlv::IpFlowDataRateMinMaxEx>>::optional_base(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)a1 = 0;
  if (*(_BYTE *)a2)
  {
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)(a1 + 24) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>((_QWORD *)(a1 + 8), *(const void **)(a2 + 8), *(_QWORD *)(a2 + 16), *(_QWORD *)(a2 + 16) - *(_QWORD *)(a2 + 8));
    *(_BYTE *)a1 = 1;
  }
  return a1;
}

void boost::optional_detail::optional_base<tlv::NestedTlv<(unsigned char)17,qos::tlv::FlowGranted>>::assign_expr<qos::tlv::FlowGranted,qos::tlv::FlowGranted>(_BYTE *a1, const qos::tlv::FlowSpec *a2)
{
  if (*a1)
  {
    boost::optional_detail::optional_base<tlv::NestedTlv<(unsigned char)17,qos::tlv::FlowGranted>>::assign_expr_to_initialized<qos::tlv::FlowGranted>((uint64_t)a1, a2);
  }
  else
  {
    qos::tlv::FlowSpec::FlowSpec((qos::tlv::FlowSpec *)(a1 + 8), a2);
    *a1 = 1;
  }
}

void boost::optional_detail::optional_base<tlv::NestedTlv<(unsigned char)17,qos::tlv::FlowGranted>>::assign_expr_to_initialized<qos::tlv::FlowGranted>(uint64_t a1, const qos::tlv::FlowSpec *a2)
{
  _BYTE v3[40];
  void *__p;
  void *v5;
  char v6;
  char v7;
  char v8;
  char v9;
  char v10;
  char v11;
  char v12;
  char v13;
  char v14;
  char v15;
  char v16;
  char v17;
  char v18;
  uint64_t v19;

  v19 = *MEMORY[0x24BDAC8D0];
  qos::tlv::FlowSpec::FlowSpec((qos::tlv::FlowSpec *)v3, a2);
  qos::tlv::FlowSpec::operator=(a1 + 8, (uint64_t)v3);
  if (v18)
    v18 = 0;
  if (v17)
    v17 = 0;
  if (v16)
    v16 = 0;
  if (v15)
    v15 = 0;
  if (v14)
    v14 = 0;
  if (v13)
    v13 = 0;
  if (v12)
    v12 = 0;
  if (v11)
    v11 = 0;
  if (v10)
    v10 = 0;
  if (v9)
    v9 = 0;
  if (v8)
    v8 = 0;
  if (v7)
    v7 = 0;
  if (v6)
    v6 = 0;
  if (v3[32])
  {
    if (__p)
    {
      v5 = __p;
      operator delete(__p);
    }
  }
}

std::logic_error *tlv::TlvParseException::TlvParseException(std::logic_error *this, unint64_t a2, unint64_t a3)
{
  std::string *v6;
  std::string::size_type size;
  std::string *v8;
  std::string::size_type v9;
  std::string __p;
  std::string v12;

  memset(&__p, 0, sizeof(__p));
  std::string::basic_string[abi:ne180100]<0>(&__p, "TLV parsing failed; expected ");
  std::to_string(&v12, a2);
  if ((v12.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v6 = &v12;
  else
    v6 = (std::string *)v12.__r_.__value_.__r.__words[0];
  if ((v12.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(v12.__r_.__value_.__r.__words[2]);
  else
    size = v12.__r_.__value_.__l.__size_;
  std::string::append(&__p, (const std::string::value_type *)v6, size);
  if (SHIBYTE(v12.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v12.__r_.__value_.__l.__data_);
  std::string::append(&__p, " bytes; got ", 0xCuLL);
  std::to_string(&v12, a3);
  if ((v12.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v8 = &v12;
  else
    v8 = (std::string *)v12.__r_.__value_.__r.__words[0];
  if ((v12.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v9 = HIBYTE(v12.__r_.__value_.__r.__words[2]);
  else
    v9 = v12.__r_.__value_.__l.__size_;
  std::string::append(&__p, (const std::string::value_type *)v8, v9);
  if (SHIBYTE(v12.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v12.__r_.__value_.__l.__data_);
  std::string::append(&__p, " bytes.", 7uLL);
  std::logic_error::logic_error(this, &__p);
  this->__vftable = (std::logic_error_vtbl *)(MEMORY[0x24BEDB8C0] + 16);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  this->__vftable = (std::logic_error_vtbl *)off_24D5C2BF8;
  return this;
}

void sub_2168B9844(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

std::logic_error *tlv::TlvParseException::TlvParseException(std::logic_error *this)
{
  std::logic_error *result;

  result = std::logic_error::logic_error(this, "TLV parsing failed; endpoint preceded beginning of buffer.");
  result->__vftable = (std::logic_error_vtbl *)off_24D5C2BF8;
  return result;
}

void tlv::TlvParseException::~TlvParseException(tlv::TlvParseException *this)
{
  MEMORY[0x2199FE89C](this);
  JUMPOUT(0x2199FEAC4);
}

uint64_t pbm::asString@<X0>(unsigned int a1@<W0>, _QWORD *a2@<X8>)
{
  uint64_t v4;

  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  v4 = a1;
  ctu::appendLabelIfBitSet();
  ctu::appendLabelIfBitSet();
  ctu::appendLabelIfBitSet();
  ctu::appendLabelIfBitSet();
  ctu::appendLabelIfBitSet();
  ctu::appendLabelIfBitSet();
  ctu::appendLabelIfBitSet();
  ctu::appendLabelIfBitSet();
  ctu::appendLabelIfBitSet();
  ctu::appendLabelIfBitSet();
  return MEMORY[0x2199FDFD8](a2, v4, " | ");
}

{
  _QWORD *v2;
  uint64_t result;
  uint64_t v4;
  int v5;
  uint64_t v6;

  v2 = a2;
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  v6 = a1;
  ctu::appendLabelIfBitSet();
  ctu::appendLabelIfBitSet();
  ctu::appendLabelIfBitSet();
  ctu::appendLabelIfBitSet();
  ctu::appendLabelIfBitSet();
  ctu::appendLabelIfBitSet();
  ctu::appendLabelIfBitSet();
  result = MEMORY[0x2199FDFD8](v2, v6, " | ");
  v4 = *((unsigned __int8 *)v2 + 23);
  v5 = (char)v4;
  if ((v4 & 0x80u) != 0)
    v4 = v2[1];
  if (!v4)
  {
    if (v5 < 0)
    {
      v2[1] = 4;
      v2 = (_QWORD *)*v2;
    }
    else
    {
      *((_BYTE *)v2 + 23) = 4;
    }
    strcpy((char *)v2, "none");
  }
  return result;
}

void sub_2168B9A60(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

const char *pbm::asString(unsigned int a1)
{
  if (a1 > 0xA)
    return "Session type unknown";
  else
    return off_24D5C2C10[(char)a1];
}

{
  if (a1 > 6)
    return "(unknown)";
  else
    return off_24D5C2C68[(char)a1];
}

void sub_2168B9C10(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

unint64_t dsd::tlv::parseField(unint64_t a1, const unsigned __int8 *a2, uint64_t a3)
{
  unint64_t result;

  tlv::throwIfNotEnoughBytes(a1, a2, 4uLL);
  *(_DWORD *)a3 = *(_DWORD *)a1;
  tlv::throwIfNotEnoughBytes(a1 + 4, a2, 4uLL);
  *(_DWORD *)(a3 + 4) = *(_DWORD *)(a1 + 4);
  tlv::throwIfNotEnoughBytes(a1 + 8, a2, 8uLL);
  result = a1 + 16;
  *(_QWORD *)(a3 + 8) = *(_QWORD *)(a1 + 8);
  return result;
}

{
  unint64_t result;

  tlv::throwIfNotEnoughBytes(a1, a2, 4uLL);
  *(_DWORD *)a3 = *(_DWORD *)a1;
  tlv::throwIfNotEnoughBytes(a1 + 4, a2, 4uLL);
  *(_DWORD *)(a3 + 4) = *(_DWORD *)(a1 + 4);
  tlv::throwIfNotEnoughBytes(a1 + 8, a2, 8uLL);
  *(_QWORD *)(a3 + 8) = *(_QWORD *)(a1 + 8);
  tlv::throwIfNotEnoughBytes(a1 + 16, a2, 8uLL);
  result = a1 + 24;
  *(_QWORD *)(a3 + 16) = *(_QWORD *)(a1 + 16);
  return result;
}

uint64_t tlv::parseV<dsd::tlv::CurrentDataSubscription>(unint64_t *a1, int a2)
{
  unsigned int *v3;
  uint64_t result;

  v3 = (unsigned int *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 4uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168B9CFC(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168B9CF0);
}

unint64_t tlv::parseV<dsd::tlv::GlobalUiInfo>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  unint64_t result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = dsd::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), (uint64_t)a3);
  *a1 = result;
  return result;
}

void sub_2168B9DD0(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
}

unint64_t dsd::tlv::parseField(char *a1, const unsigned __int8 *a2, uint64_t a3)
{
  unint64_t v6;
  char v7;
  char **i;
  unint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  char *v17;
  char *v18;
  char *v19;
  char *v20;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  v7 = *a1;
  v6 = (unint64_t)(a1 + 1);
  *(_BYTE *)a3 = v7;
  for (i = (char **)(a3 + 8); v6 < (unint64_t)a2; v6 = dsd::tlv::parseField(v6, a2, (uint64_t)(v11 - 2)))
  {
    v10 = *(_QWORD **)(a3 + 16);
    v9 = *(_QWORD *)(a3 + 24);
    if ((unint64_t)v10 >= v9)
    {
      v12 = ((char *)v10 - *i) >> 4;
      v13 = v12 + 1;
      if ((unint64_t)(v12 + 1) >> 60)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v14 = v9 - (_QWORD)*i;
      if (v14 >> 3 > v13)
        v13 = v14 >> 3;
      if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF0)
        v15 = 0xFFFFFFFFFFFFFFFLL;
      else
        v15 = v13;
      if (v15)
        v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::array<unsigned char,16ul>>>(a3 + 24, v15);
      else
        v16 = 0;
      v17 = &v16[16 * v12];
      *(_QWORD *)v17 = 0;
      *((_QWORD *)v17 + 1) = 0;
      v19 = *(char **)(a3 + 8);
      v18 = *(char **)(a3 + 16);
      v20 = v17;
      if (v18 != v19)
      {
        do
        {
          *((_OWORD *)v20 - 1) = *((_OWORD *)v18 - 1);
          v20 -= 16;
          v18 -= 16;
        }
        while (v18 != v19);
        v18 = *i;
      }
      v11 = v17 + 16;
      *(_QWORD *)(a3 + 8) = v20;
      *(_QWORD *)(a3 + 16) = v17 + 16;
      *(_QWORD *)(a3 + 24) = &v16[16 * v15];
      if (v18)
        operator delete(v18);
    }
    else
    {
      *v10 = 0;
      v10[1] = 0;
      v11 = v10 + 2;
    }
    *(_QWORD *)(a3 + 16) = v11;
  }
  return v6;
}

unint64_t tlv::parseV<dsd::tlv::DataSystemStatus>@<X0>(char **a1@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  unint64_t result;

  *a3 = 0u;
  a3[1] = 0u;
  result = dsd::tlv::parseField(*a1, (const unsigned __int8 *)&(*a1)[a2], (uint64_t)a3);
  *a1 = (char *)result;
  return result;
}

void sub_2168B9F60(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168B9F54);
}

void sub_2168B9F70(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)(v1 + 8);
  if (v3)
  {
    *(_QWORD *)(v1 + 16) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t tlv::parseV<dsd::tlv::DefaultDataSwitchResult>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168B9FC4(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168B9FB8);
}

uint64_t tlv::parseV<dsd::tlv::Reason>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168BA010(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168BA004);
}

BOOL tlv::parseV<dsd::tlv::UplinkEmergencyBottleneck>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  _BOOL8 result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3 != 0;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168BA064(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168BA058);
}

const char *qmi::wms::asString(int a1)
{
  const char *v1;

  v1 = "???";
  if (a1 == 1)
    v1 = "Enable";
  if (a1)
    return v1;
  else
    return "Disable";
}

{
  const char *v1;

  v1 = "???";
  if (a1 == 1)
    v1 = "NV";
  if (a1)
    return v1;
  else
    return "UIM";
}

{
  const char *v1;

  v1 = "???";
  if (a1 == 1)
    v1 = "GW";
  if (a1)
    return v1;
  else
    return "CDMA";
}

const char *qmi::wms::asString(unsigned int a1)
{
  if (a1 > 8)
    return "???";
  else
    return off_24D5C2CA0[(char)a1];
}

{
  if (a1 > 5)
    return "???";
  else
    return off_24D5C2CE8[a1];
}

{
  if (a1 > 3)
    return "???";
  else
    return off_24D5C2D18[a1];
}

{
  if (a1 > 3)
    return "Undefined WMS Service ready status";
  else
    return off_24D5C2D38[a1];
}

BOOL at::convert(int a1)
{
  return a1 == 0;
}

const char *vs::callList::asString(int a1)
{
  int v1;
  const char *result;

  v1 = a1 - 1;
  result = "ORIGINATION";
  switch(v1)
  {
    case 0:
      return result;
    case 1:
      result = "INCOMING";
      break;
    case 2:
      result = "CONVERSATION";
      break;
    case 3:
      result = "CC_IN_PROGRESS";
      break;
    case 4:
      result = "ALERTING";
      break;
    case 5:
      result = "HOLD";
      break;
    case 6:
      result = "WAITING";
      break;
    case 7:
      result = "DISCONNECTING";
      break;
    case 8:
      result = "END";
      break;
    case 9:
      result = "CALL_STATE_SETUP";
      break;
    default:
      if ("ORIGINATION" == 104)
        result = "SILENT_REDIAL";
      else
        result = "(unknown)";
      break;
  }
  return result;
}

{
  if ((a1 - 1) > 9)
    return "(unknown)";
  else
    return off_24D5C2D58[a1 - 1];
}

_WORD *nas::tlv::parseField(_WORD *a1, const unsigned __int8 *a2, _WORD *a3)
{
  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 2uLL);
  *a3 = *a1;
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 1), a2, 2uLL);
  a3[1] = a1[1];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 2), a2, 2uLL);
  a3[2] = a1[2];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 3), a2, 2uLL);
  a3[3] = a1[3];
  return a1 + 4;
}

char *nas::tlv::parseField(unint64_t a1, const unsigned __int8 *a2, uint64_t a3)
{
  _WORD *v6;
  _WORD *v7;

  tlv::throwIfNotEnoughBytes(a1, a2, 4uLL);
  *(_DWORD *)a3 = *(_DWORD *)a1;
  tlv::throwIfNotEnoughBytes(a1 + 4, a2, 2uLL);
  *(_WORD *)(a3 + 4) = *(_WORD *)(a1 + 4);
  v6 = nas::tlv::parseField<short,-1,2>((_WORD *)(a1 + 6), a2, (_WORD *)(a3 + 6));
  v7 = nas::tlv::parseField<short,-1,2>(v6, a2, (_WORD *)(a3 + 8));
  tlv::throwIfNotEnoughBytes((unint64_t)v7, a2, 4uLL);
  *(_DWORD *)(a3 + 12) = *(_DWORD *)v7;
  tlv::throwIfNotEnoughBytes((unint64_t)(v7 + 2), a2, 1uLL);
  *(_BYTE *)(a3 + 16) = *((_BYTE *)v7 + 4);
  tlv::throwIfNotEnoughBytes((unint64_t)v7 + 5, a2, 4uLL);
  *(_DWORD *)(a3 + 20) = *(_DWORD *)((char *)v7 + 5);
  tlv::throwIfNotEnoughBytes((unint64_t)v7 + 9, a2, 4uLL);
  *(_DWORD *)(a3 + 24) = *(_DWORD *)((char *)v7 + 9);
  tlv::throwIfNotEnoughBytes((unint64_t)v7 + 13, a2, 4uLL);
  *(_DWORD *)(a3 + 28) = *(_DWORD *)((char *)v7 + 13);
  return (char *)v7 + 17;
}

{
  char *v5;
  unint64_t v6;

  v5 = (char *)a1;
  tlv::throwIfNotEnoughBytes(a1, a2, 1uLL);
  *(_BYTE *)a3 = *v5;
  tlv::throwIfNotEnoughBytes((unint64_t)(v5 + 1), a2, 1uLL);
  *(_BYTE *)(a3 + 1) = v5[1];
  tlv::throwIfNotEnoughBytes((unint64_t)(v5 + 2), a2, 1uLL);
  *(_BYTE *)(a3 + 2) = v5[2];
  tlv::throwIfNotEnoughBytes((unint64_t)(v5 + 3), a2, 1uLL);
  v6 = v5[3];
  v5 += 4;
  tlv::throwIfNotEnoughBytes((unint64_t)v5, a2, v6);
  std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((_QWORD *)(a3 + 8), v5, &v5[v6], v6);
  return &v5[v6];
}

{
  _DWORD *v5;
  unint64_t v6;

  v5 = (_DWORD *)a1;
  tlv::throwIfNotEnoughBytes(a1, a2, 4uLL);
  *(_DWORD *)a3 = *v5;
  tlv::throwIfNotEnoughBytes((unint64_t)(v5 + 1), a2, 1uLL);
  v6 = *((unsigned __int8 *)v5 + 4);
  v5 = (_DWORD *)((char *)v5 + 5);
  tlv::throwIfNotEnoughBytes((unint64_t)v5, a2, 2 * v6);
  std::vector<unsigned short>::resize(a3 + 8, v6);
  memcpy(*(void **)(a3 + 8), v5, 2 * v6);
  return (char *)v5 + 2 * v6;
}

_WORD *nas::tlv::parseField(unint64_t a1, const unsigned __int8 *a2, uint64_t a3)
{
  _WORD *v6;
  _WORD *v7;

  tlv::throwIfNotEnoughBytes(a1, a2, 4uLL);
  *(_DWORD *)a3 = *(_DWORD *)a1;
  tlv::throwIfNotEnoughBytes(a1 + 4, a2, 2uLL);
  *(_WORD *)(a3 + 4) = *(_WORD *)(a1 + 4);
  v6 = nas::tlv::parseField<short,-1,2>((_WORD *)(a1 + 6), a2, (_WORD *)(a3 + 6));
  v7 = nas::tlv::parseField<short,-1,2>(v6, a2, (_WORD *)(a3 + 8));
  tlv::throwIfNotEnoughBytes((unint64_t)v7, a2, 1uLL);
  *(_BYTE *)(a3 + 10) = *(_BYTE *)v7;
  tlv::throwIfNotEnoughBytes((unint64_t)v7 + 1, a2, 1uLL);
  *(_BYTE *)(a3 + 11) = *((_BYTE *)v7 + 1);
  tlv::throwIfNotEnoughBytes((unint64_t)(v7 + 1), a2, 4uLL);
  *(_DWORD *)(a3 + 12) = *(_DWORD *)(v7 + 1);
  tlv::throwIfNotEnoughBytes((unint64_t)(v7 + 3), a2, 4uLL);
  *(_DWORD *)(a3 + 16) = *(_DWORD *)(v7 + 3);
  tlv::throwIfNotEnoughBytes((unint64_t)(v7 + 5), a2, 4uLL);
  *(_DWORD *)(a3 + 20) = *(_DWORD *)(v7 + 5);
  return v7 + 7;
}

{
  _WORD *v6;
  _WORD *v7;

  tlv::throwIfNotEnoughBytes(a1, a2, 4uLL);
  *(_DWORD *)a3 = *(_DWORD *)a1;
  tlv::throwIfNotEnoughBytes(a1 + 4, a2, 2uLL);
  *(_WORD *)(a3 + 4) = *(_WORD *)(a1 + 4);
  v6 = nas::tlv::parseField<short,-1,2>((_WORD *)(a1 + 6), a2, (_WORD *)(a3 + 6));
  v7 = nas::tlv::parseField<short,-1,2>(v6, a2, (_WORD *)(a3 + 8));
  tlv::throwIfNotEnoughBytes((unint64_t)v7, a2, 1uLL);
  *(_BYTE *)(a3 + 10) = *(_BYTE *)v7;
  tlv::throwIfNotEnoughBytes((unint64_t)v7 + 1, a2, 1uLL);
  *(_BYTE *)(a3 + 11) = *((_BYTE *)v7 + 1);
  tlv::throwIfNotEnoughBytes((unint64_t)(v7 + 1), a2, 4uLL);
  *(_DWORD *)(a3 + 12) = *(_DWORD *)(v7 + 1);
  tlv::throwIfNotEnoughBytes((unint64_t)(v7 + 3), a2, 1uLL);
  *(_BYTE *)(a3 + 16) = *((_BYTE *)v7 + 6);
  tlv::throwIfNotEnoughBytes((unint64_t)v7 + 7, a2, 1uLL);
  *(_BYTE *)(a3 + 17) = *((_BYTE *)v7 + 7);
  tlv::throwIfNotEnoughBytes((unint64_t)(v7 + 4), a2, 4uLL);
  *(_DWORD *)(a3 + 20) = *((_DWORD *)v7 + 2);
  tlv::throwIfNotEnoughBytes((unint64_t)(v7 + 6), a2, 4uLL);
  *(_DWORD *)(a3 + 24) = *((_DWORD *)v7 + 3);
  return v7 + 8;
}

unint64_t tlv::parseV<nas::tlv::GsmCellInformation>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  unint64_t result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = nas::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = (unsigned __int8 *)result;
  return result;
}

void sub_2168BB0A0(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168BB094);
}

void sub_2168BB0B0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

unint64_t tlv::parseV<nas::tlv::UmtsCellInformation>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  unint64_t result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = nas::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = (unsigned __int8 *)result;
  return result;
}

void sub_2168BB170(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168BB164);
}

void sub_2168BB180(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

unint64_t tlv::parseV<nas::tlv::TDSCDMACellInformation>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  unint64_t result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = nas::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = (unsigned __int8 *)result;
  return result;
}

void sub_2168BB1D8(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168BB1CCLL);
}

void sub_2168BB1E8(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

unint64_t tlv::parseV<nas::tlv::LteCellInformation_V3>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  unint64_t result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = nas::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = (unsigned __int8 *)result;
  return result;
}

void sub_2168BB2A8(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168BB29CLL);
}

void sub_2168BB2B8(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

unint64_t tlv::parseV<nas::tlv::NrCellInformation_V2>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  unint64_t result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = nas::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = (unsigned __int8 *)result;
  return result;
}

void sub_2168BB378(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168BB36CLL);
}

void sub_2168BB388(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

unint64_t tlv::parseV<nas::tlv::NrCellInformation_V3>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  unint64_t result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = nas::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = (unsigned __int8 *)result;
  return result;
}

void sub_2168BB448(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168BB43CLL);
}

void sub_2168BB458(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

unint64_t tlv::parseV<nas::tlv::Cdma1xCellInformation>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  unint64_t result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = nas::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = (unsigned __int8 *)result;
  return result;
}

void sub_2168BB518(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168BB50CLL);
}

void sub_2168BB528(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

unint64_t tlv::parseV<nas::tlv::CdmaEvdoCellInformation>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  unint64_t result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = nas::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = (unsigned __int8 *)result;
  return result;
}

void sub_2168BB5E8(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168BB5DCLL);
}

void sub_2168BB5F8(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

unsigned __int8 *tlv::parseV<nas::tlv::GsmNeighborInformation>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  unsigned __int8 *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = (unsigned __int8 *)wds::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = result;
  return result;
}

void sub_2168BB650(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168BB644);
}

void sub_2168BB660(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_WORD *nas::tlv::parseField(unsigned __int8 *a1, const unsigned __int8 *a2, _QWORD *a3)
{
  _WORD *v6;
  unsigned int v7;
  _WORD *v8;
  _WORD *v9;
  _WORD *result;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  v7 = *a1;
  v6 = a1 + 1;
  std::vector<wds::tlv::Ipv4AddrInfo>::resize((uint64_t)a3, v7);
  v8 = (_WORD *)*a3;
  v9 = (_WORD *)a3[1];
  while (1)
  {
    result = v6;
    if (v8 == v9)
      break;
    v6 = nas::tlv::parseField(v6, a2, v8);
    v8 += 4;
  }
  return result;
}

unsigned __int8 *tlv::parseV<nas::tlv::UmtsNeighborInformation>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  unsigned __int8 *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = (unsigned __int8 *)nas::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = result;
  return result;
}

void sub_2168BB720(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168BB714);
}

void sub_2168BB730(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

unint64_t tlv::parseV<nas::tlv::TDSCDMANeighborInformation>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  unint64_t result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = nas::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = (unsigned __int8 *)result;
  return result;
}

void sub_2168BB7F0(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168BB7E4);
}

void sub_2168BB800(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

unsigned __int8 *tlv::parseV<nas::tlv::NrNeighborInformation_V2>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  unsigned __int8 *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = (unsigned __int8 *)nas::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = result;
  return result;
}

void sub_2168BB8C0(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168BB8B4);
}

void sub_2168BB8D0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

unint64_t tlv::parseV<nas::tlv::Cdma1xNeighborInformation>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  unint64_t result;

  *a3 = 0u;
  a3[1] = 0u;
  result = nas::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), (uint64_t)a3);
  *a1 = result;
  return result;
}

void sub_2168BB9F4(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168BB9E8);
}

void sub_2168BBA04(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)(v1 + 8);
  if (v3)
  {
    *(_QWORD *)(v1 + 16) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

unint64_t tlv::parseV<nas::tlv::CdmaEvdoNeighborInformation>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  unint64_t result;

  *a3 = 0u;
  a3[1] = 0u;
  result = nas::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), (uint64_t)a3);
  *a1 = result;
  return result;
}

void sub_2168BBA5C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168BBA50);
}

void sub_2168BBA6C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)(v1 + 8);
  if (v3)
  {
    *(_QWORD *)(v1 + 16) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

unsigned __int8 *tlv::parseV<nas::tlv::MccInformation>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  unsigned __int8 *result;

  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  result = wds::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), (void **)a3);
  *a1 = (unint64_t)result;
  return result;
}

void sub_2168BBAC4(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168BBAB8);
}

void sub_2168BBAD4(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t tlv::parseV<nas::tlv::CsgIndicator>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168BBB28(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168BBB1CLL);
}

unint64_t tlv::size<nas::tlv::C2K1XHints>(_QWORD *a1)
{
  uint64_t v1;

  v1 = a1[1];
  if (*a1 == v1)
    return 4;
  else
    return 7 * ((unint64_t)(v1 - *a1 - 8) >> 3) + 11;
}

_BYTE *tlv::writeV<nas::tlv::C2K1XHints>(_BYTE **a1, _DWORD *a2)
{
  _BYTE *result;

  result = nas::tlv::writeField(*a1, a2);
  *a1 = result;
  return result;
}

uint64_t tlv::size<nas::tlv::C2KEVDOHints>(uint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v1 = *a1;
  v2 = a1[1];
  if (*a1 == v2)
    return 4;
  v3 = 0;
  do
  {
    v3 = v3 + *(_QWORD *)(v1 + 16) - *(_QWORD *)(v1 + 8) + 4;
    v1 += 32;
  }
  while (v1 != v2);
  return v3 + 4;
}

_BYTE *tlv::writeV<nas::tlv::C2KEVDOHints>(_BYTE **a1, _DWORD *a2)
{
  _BYTE *result;

  result = nas::tlv::writeField(*a1, a2);
  *a1 = result;
  return result;
}

unsigned __int8 *tlv::parseV<nas::tlv::LAPSMCCInfo>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  unsigned __int8 *result;

  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  result = wds::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), (void **)a3);
  *a1 = (unint64_t)result;
  return result;
}

void sub_2168BBD0C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168BBD00);
}

void sub_2168BBD1C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

unsigned __int8 *tlv::parseV<nas::tlv::LAPSPLMNInfo>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  unsigned __int8 *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = (unsigned __int8 *)wds::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = result;
  return result;
}

void sub_2168BBD74(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168BBD68);
}

void sub_2168BBD84(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<nas::tlv::GsmCell>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;

  v2 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 3);
  v3 = a2 >= v2;
  v4 = a2 - v2;
  if (v4 != 0 && v3)
  {
    std::vector<nas::tlv::GsmCell>::__append((void **)a1, v4);
  }
  else if (!v3)
  {
    *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 24 * a2;
  }
}

void std::vector<nas::tlv::GsmCell>::__append(void **a1, unint64_t a2)
{
  uint64_t v4;
  _BYTE *v5;
  _BYTE *v6;
  char *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  size_t v13;
  char *v14;
  char *v15;
  size_t v16;
  char *v17;
  char *v18;
  char *v19;
  __int128 v20;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - v7) >> 3) >= a2)
  {
    if (a2)
    {
      v13 = 24 * ((24 * a2 - 24) / 0x18) + 24;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = 0xAAAAAAAAAAAAAAABLL * ((v7 - (_BYTE *)*a1) >> 3);
    v9 = v8 + a2;
    if (v8 + a2 > 0xAAAAAAAAAAAAAAALL)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = 0xAAAAAAAAAAAAAAABLL * ((v5 - (_BYTE *)*a1) >> 3);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x555555555555555)
      v11 = 0xAAAAAAAAAAAAAAALL;
    else
      v11 = v9;
    if (v11)
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>(v4, v11);
    else
      v12 = 0;
    v14 = &v12[24 * v8];
    v15 = &v12[24 * v11];
    v16 = 24 * ((24 * a2 - 24) / 0x18) + 24;
    bzero(v14, v16);
    v17 = &v14[v16];
    v19 = (char *)*a1;
    v18 = (char *)a1[1];
    if (v18 != *a1)
    {
      do
      {
        v20 = *(_OWORD *)(v18 - 24);
        *((_QWORD *)v14 - 1) = *((_QWORD *)v18 - 1);
        *(_OWORD *)(v14 - 24) = v20;
        v14 -= 24;
        v18 -= 24;
      }
      while (v18 != v19);
      v18 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v17;
    a1[2] = v15;
    if (v18)
      operator delete(v18);
  }
}

void std::vector<nas::tlv::UmtsCell>::__append(void **a1, unint64_t a2)
{
  uint64_t v4;
  _BYTE *v5;
  _BYTE *v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  size_t v13;
  char *v14;
  char *v15;
  size_t v16;
  char *v17;
  char *v18;
  char *v19;
  __int128 v20;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (0x6DB6DB6DB6DB6DB7 * ((v6 - v7) >> 2) >= a2)
  {
    if (a2)
    {
      v13 = 28 * ((28 * a2 - 28) / 0x1C) + 28;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = 0x6DB6DB6DB6DB6DB7 * ((v7 - (_BYTE *)*a1) >> 2);
    v9 = v8 + a2;
    if (v8 + a2 > 0x924924924924924)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = 0x6DB6DB6DB6DB6DB7 * ((v5 - (_BYTE *)*a1) >> 2);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x492492492492492)
      v11 = 0x924924924924924;
    else
      v11 = v9;
    if (v11)
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<nas::tlv::UmtsCell>>(v4, v11);
    else
      v12 = 0;
    v14 = &v12[28 * v8];
    v15 = &v12[28 * v11];
    v16 = 28 * ((28 * a2 - 28) / 0x1C) + 28;
    bzero(v14, v16);
    v17 = &v14[v16];
    v19 = (char *)*a1;
    v18 = (char *)a1[1];
    if (v18 != *a1)
    {
      do
      {
        v20 = *(_OWORD *)(v18 - 28);
        *((_OWORD *)v14 - 1) = *((_OWORD *)v18 - 1);
        *(_OWORD *)(v14 - 28) = v20;
        v14 -= 28;
        v18 -= 28;
      }
      while (v18 != v19);
      v18 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v17;
    a1[2] = v15;
    if (v18)
      operator delete(v18);
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<nas::tlv::UmtsCell>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x924924924924925)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(28 * a2);
}

void std::vector<nas::tlv::LteCell_V3>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;

  v2 = 0x8E38E38E38E38E39 * ((uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 2);
  v3 = a2 >= v2;
  v4 = a2 - v2;
  if (v4 != 0 && v3)
  {
    std::vector<nas::tlv::LteCell_V3>::__append((void **)a1, v4);
  }
  else if (!v3)
  {
    *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 36 * a2;
  }
}

void std::vector<nas::tlv::LteCell_V3>::__append(void **a1, unint64_t a2)
{
  uint64_t v4;
  _BYTE *v5;
  _BYTE *v6;
  char *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  size_t v13;
  char *v14;
  char *v15;
  size_t v16;
  char *v17;
  char *v18;
  char *v19;
  __int128 v20;
  __int128 v21;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (0x8E38E38E38E38E39 * ((v6 - v7) >> 2) >= a2)
  {
    if (a2)
    {
      v13 = 36 * ((36 * a2 - 36) / 0x24) + 36;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = 0x8E38E38E38E38E39 * ((v7 - (_BYTE *)*a1) >> 2);
    v9 = v8 + a2;
    if (v8 + a2 > 0x71C71C71C71C71CLL)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = 0x8E38E38E38E38E39 * ((v5 - (_BYTE *)*a1) >> 2);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x38E38E38E38E38ELL)
      v11 = 0x71C71C71C71C71CLL;
    else
      v11 = v9;
    if (v11)
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<nas::tlv::LteCell_V3>>(v4, v11);
    else
      v12 = 0;
    v14 = &v12[36 * v8];
    v15 = &v12[36 * v11];
    v16 = 36 * ((36 * a2 - 36) / 0x24) + 36;
    bzero(v14, v16);
    v17 = &v14[v16];
    v19 = (char *)*a1;
    v18 = (char *)a1[1];
    if (v18 != *a1)
    {
      do
      {
        v20 = *(_OWORD *)(v18 - 36);
        v21 = *(_OWORD *)(v18 - 20);
        *((_WORD *)v14 - 2) = *((_WORD *)v18 - 2);
        *(_OWORD *)(v14 - 20) = v21;
        *(_OWORD *)(v14 - 36) = v20;
        v14 -= 36;
        v18 -= 36;
      }
      while (v18 != v19);
      v18 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v17;
    a1[2] = v15;
    if (v18)
      operator delete(v18);
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<nas::tlv::LteCell_V3>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x71C71C71C71C71DLL)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(36 * a2);
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<nas::tlv::LteCell_V4>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x444444444444445)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(60 * a2);
}

void std::vector<nas::tlv::NrCell_V2>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;

  v2 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 4);
  v3 = a2 >= v2;
  v4 = a2 - v2;
  if (v4 != 0 && v3)
  {
    std::vector<nas::tlv::NrCell_V2>::__append((void **)a1, v4);
  }
  else if (!v3)
  {
    *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 48 * a2;
  }
}

void std::vector<nas::tlv::NrCell_V2>::__append(void **a1, unint64_t a2)
{
  uint64_t v4;
  _BYTE *v5;
  _BYTE *v6;
  char *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  size_t v13;
  char *v14;
  char *v15;
  size_t v16;
  char *v17;
  char *v18;
  char *v19;
  __int128 v20;
  __int128 v21;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - v7) >> 4) >= a2)
  {
    if (a2)
    {
      v13 = 48 * ((48 * a2 - 48) / 0x30) + 48;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = 0xAAAAAAAAAAAAAAABLL * ((v7 - (_BYTE *)*a1) >> 4);
    v9 = v8 + a2;
    if (v8 + a2 > 0x555555555555555)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = 0xAAAAAAAAAAAAAAABLL * ((v5 - (_BYTE *)*a1) >> 4);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x2AAAAAAAAAAAAAALL)
      v11 = 0x555555555555555;
    else
      v11 = v9;
    if (v11)
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::AppInfo>>(v4, v11);
    else
      v12 = 0;
    v14 = &v12[48 * v8];
    v15 = &v12[48 * v11];
    v16 = 48 * ((48 * a2 - 48) / 0x30) + 48;
    bzero(v14, v16);
    v17 = &v14[v16];
    v19 = (char *)*a1;
    v18 = (char *)a1[1];
    if (v18 != *a1)
    {
      do
      {
        v20 = *((_OWORD *)v18 - 3);
        v21 = *((_OWORD *)v18 - 1);
        *((_OWORD *)v14 - 2) = *((_OWORD *)v18 - 2);
        *((_OWORD *)v14 - 1) = v21;
        *((_OWORD *)v14 - 3) = v20;
        v14 -= 48;
        v18 -= 48;
      }
      while (v18 != v19);
      v18 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v17;
    a1[2] = v15;
    if (v18)
      operator delete(v18);
  }
}

void std::vector<nas::tlv::NrCell_V3>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;

  v2 = 0x8E38E38E38E38E39 * ((uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 3);
  v3 = a2 >= v2;
  v4 = a2 - v2;
  if (v4 != 0 && v3)
  {
    std::vector<nas::tlv::NrCell_V3>::__append((void **)a1, v4);
  }
  else if (!v3)
  {
    *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 72 * a2;
  }
}

void std::vector<nas::tlv::NrCell_V3>::__append(void **a1, unint64_t a2)
{
  uint64_t v4;
  _BYTE *v5;
  _BYTE *v6;
  char *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  size_t v13;
  char *v14;
  char *v15;
  size_t v16;
  char *v17;
  char *v18;
  char *v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (0x8E38E38E38E38E39 * ((v6 - v7) >> 3) >= a2)
  {
    if (a2)
    {
      v13 = 72 * ((72 * a2 - 72) / 0x48) + 72;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = 0x8E38E38E38E38E39 * ((v7 - (_BYTE *)*a1) >> 3);
    v9 = v8 + a2;
    if (v8 + a2 > 0x38E38E38E38E38ELL)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = 0x8E38E38E38E38E39 * ((v5 - (_BYTE *)*a1) >> 3);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x1C71C71C71C71C7)
      v11 = 0x38E38E38E38E38ELL;
    else
      v11 = v9;
    if (v11)
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<nas::tlv::NrCell_V3>>(v4, v11);
    else
      v12 = 0;
    v14 = &v12[72 * v8];
    v15 = &v12[72 * v11];
    v16 = 72 * ((72 * a2 - 72) / 0x48) + 72;
    bzero(v14, v16);
    v17 = &v14[v16];
    v19 = (char *)*a1;
    v18 = (char *)a1[1];
    if (v18 != *a1)
    {
      do
      {
        *(_OWORD *)(v14 - 72) = *(_OWORD *)(v18 - 72);
        v20 = *(_OWORD *)(v18 - 56);
        v21 = *(_OWORD *)(v18 - 40);
        v22 = *(_OWORD *)(v18 - 24);
        *((_DWORD *)v14 - 2) = *((_DWORD *)v18 - 2);
        *(_OWORD *)(v14 - 24) = v22;
        *(_OWORD *)(v14 - 40) = v21;
        *(_OWORD *)(v14 - 56) = v20;
        v14 -= 72;
        v18 -= 72;
      }
      while (v18 != v19);
      v18 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v17;
    a1[2] = v15;
    if (v18)
      operator delete(v18);
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<nas::tlv::NrCell_V3>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x38E38E38E38E38FLL)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(72 * a2);
}

void std::vector<nas::tlv::Cdma1xCell>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;

  v2 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 5;
  if (a2 <= v2)
  {
    if (a2 < v2)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 32 * a2;
  }
  else
  {
    std::vector<nas::tlv::Cdma1xCell>::__append((void **)a1, a2 - v2);
  }
}

void std::vector<nas::tlv::Cdma1xCell>::__append(void **a1, unint64_t a2)
{
  uint64_t v4;
  _BYTE *v5;
  _BYTE *v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  __int128 v19;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 5)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 32 * a2);
      v7 += 32 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = v7 - (_BYTE *)*a1;
    v9 = a2 + (v8 >> 5);
    if (v9 >> 59)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 5;
    v11 = v5 - (_BYTE *)*a1;
    if (v11 >> 4 > v9)
      v9 = v11 >> 4;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFE0)
      v12 = 0x7FFFFFFFFFFFFFFLL;
    else
      v12 = v9;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<vs::tlv::RemoteNumberListItem>>(v4, v12);
    else
      v13 = 0;
    v14 = &v13[32 * v10];
    v15 = &v13[32 * v12];
    bzero(v14, 32 * a2);
    v16 = &v14[32 * a2];
    v18 = (char *)*a1;
    v17 = (char *)a1[1];
    if (v17 != *a1)
    {
      do
      {
        v19 = *((_OWORD *)v17 - 2);
        *(_OWORD *)(v14 - 18) = *(_OWORD *)(v17 - 18);
        *((_OWORD *)v14 - 2) = v19;
        v14 -= 32;
        v17 -= 32;
      }
      while (v17 != v18);
      v17 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v16;
    a1[2] = v15;
    if (v17)
      operator delete(v17);
  }
}

void std::vector<nas::tlv::LteNeighborCell_V3>::__append(void **a1, unint64_t a2)
{
  uint64_t v4;
  _BYTE *v5;
  _BYTE *v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  __int128 v19;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 5)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 32 * a2);
      v7 += 32 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = v7 - (_BYTE *)*a1;
    v9 = a2 + (v8 >> 5);
    if (v9 >> 59)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 5;
    v11 = v5 - (_BYTE *)*a1;
    if (v11 >> 4 > v9)
      v9 = v11 >> 4;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFE0)
      v12 = 0x7FFFFFFFFFFFFFFLL;
    else
      v12 = v9;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<vs::tlv::RemoteNumberListItem>>(v4, v12);
    else
      v13 = 0;
    v14 = &v13[32 * v10];
    v15 = &v13[32 * v12];
    bzero(v14, 32 * a2);
    v16 = &v14[32 * a2];
    v18 = (char *)*a1;
    v17 = (char *)a1[1];
    if (v17 != *a1)
    {
      do
      {
        v19 = *((_OWORD *)v17 - 1);
        *((_OWORD *)v14 - 2) = *((_OWORD *)v17 - 2);
        *((_OWORD *)v14 - 1) = v19;
        v14 -= 32;
        v17 -= 32;
      }
      while (v17 != v18);
      v17 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v16;
    a1[2] = v15;
    if (v17)
      operator delete(v17);
  }
}

void std::vector<nas::tlv::Cdma1xNeighborCell>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;

  v2 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 3;
  if (a2 <= v2)
  {
    if (a2 < v2)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 8 * a2;
  }
  else
  {
    std::vector<nas::tlv::Cdma1xNeighborCell>::__append((char **)a1, a2 - v2);
  }
}

void std::vector<nas::tlv::Cdma1xNeighborCell>::__append(char **a1, unint64_t a2)
{
  uint64_t v4;
  char *v5;
  char *v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  int v19;
  int v20;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 3)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 8 * a2);
      v7 += 8 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = v7 - *a1;
    v9 = a2 + (v8 >> 3);
    if (v9 >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 3;
    v11 = v5 - *a1;
    if (v11 >> 2 > v9)
      v9 = v11 >> 2;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v9;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>(v4, v12);
    else
      v13 = 0;
    v14 = &v13[8 * v10];
    v15 = &v13[8 * v12];
    bzero(v14, 8 * a2);
    v16 = &v14[8 * a2];
    v18 = *a1;
    v17 = a1[1];
    if (v17 != *a1)
    {
      do
      {
        v19 = *((_DWORD *)v17 - 2);
        v17 -= 8;
        v20 = *(_DWORD *)(v17 + 3);
        *((_DWORD *)v14 - 2) = v19;
        v14 -= 8;
        *(_DWORD *)(v14 + 3) = v20;
      }
      while (v17 != v18);
      v17 = *a1;
    }
    *a1 = v14;
    a1[1] = v16;
    a1[2] = v15;
    if (v17)
      operator delete(v17);
  }
}

uint64_t std::vector<nas::tlv::C2KEVDOHintItem>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<nas::tlv::C2KEVDOHintItem>,std::reverse_iterator<nas::tlv::C2KEVDOHintItem*>,std::reverse_iterator<nas::tlv::C2KEVDOHintItem*>,std::reverse_iterator<nas::tlv::C2KEVDOHintItem*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<nas::tlv::C2KEVDOHintItem>,std::reverse_iterator<nas::tlv::C2KEVDOHintItem*>,std::reverse_iterator<nas::tlv::C2KEVDOHintItem*>,std::reverse_iterator<nas::tlv::C2KEVDOHintItem*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  int v8;
  uint64_t v9;
  _QWORD v11[3];
  uint64_t v12;
  __int128 v13;
  __int128 v14;

  v7 = a7;
  *(_QWORD *)&v14 = a6;
  *((_QWORD *)&v14 + 1) = a7;
  v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  v12 = 0;
  if (a3 == a5)
  {
    v9 = a6;
  }
  else
  {
    do
    {
      v8 = *(_DWORD *)(a3 - 32);
      a3 -= 32;
      *(_DWORD *)(v7 - 32) = v8;
      *(_QWORD *)(v7 - 16) = 0;
      *(_QWORD *)(v7 - 8) = 0;
      *(_QWORD *)(v7 - 24) = 0;
      *(_OWORD *)(v7 - 24) = *(_OWORD *)(a3 + 8);
      *(_QWORD *)(v7 - 8) = *(_QWORD *)(a3 + 24);
      *(_QWORD *)(a3 + 8) = 0;
      *(_QWORD *)(a3 + 16) = 0;
      *(_QWORD *)(a3 + 24) = 0;
      v7 = *((_QWORD *)&v14 + 1) - 32;
      *((_QWORD *)&v14 + 1) -= 32;
    }
    while (a3 != a5);
    v9 = v14;
  }
  LOBYTE(v12) = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<nas::tlv::C2KEVDOHintItem>,std::reverse_iterator<nas::tlv::C2KEVDOHintItem*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v11);
  return v9;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<nas::tlv::C2KEVDOHintItem>,std::reverse_iterator<nas::tlv::C2KEVDOHintItem*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<at::tlv::CommandCallback>,std::reverse_iterator<at::tlv::CommandCallback*>>::operator()[abi:ne180100](a1);
  return a1;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<nas::tlv::GSMHintItem>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x199999999999999ALL)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(10 * a2);
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<nas::tlv::NRHintItem>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xCCCCCCCCCCCCCCDLL)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(20 * a2);
}

_QWORD *tlv::parseV<elqm::tlv::LinkState>@<X0>(char **a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  char *v4;
  _QWORD *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  v4 = &(*a1)[a2];
  result = std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(a3, *a1, v4, a2);
  *a1 = v4;
  return result;
}

void sub_2168BCDAC(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168BCD9CLL);
}

void sub_2168BCDBC(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *tlv::parseV<elqm::tlv::LinkQualityFingerPrint>@<X0>(char **a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  char *v4;
  _QWORD *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  v4 = &(*a1)[a2];
  result = std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(a3, *a1, v4, a2);
  *a1 = v4;
  return result;
}

void sub_2168BCE28(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168BCE18);
}

void sub_2168BCE38(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *tlv::parseV<elqm::tlv::TrafficClass>@<X0>(char **a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  char *v4;
  _QWORD *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  v4 = &(*a1)[a2];
  result = std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(a3, *a1, v4, a2);
  *a1 = v4;
  return result;
}

void sub_2168BCEA4(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168BCE94);
}

void sub_2168BCEB4(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *tlv::parseV<elqm::tlv::DataTransferTime>@<X0>(char **a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  char *v4;
  _QWORD *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  v4 = &(*a1)[a2];
  result = std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(a3, *a1, v4, a2);
  *a1 = v4;
  return result;
}

void sub_2168BCF20(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168BCF10);
}

void sub_2168BCF30(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *tlv::parseV<elqm::tlv::DataTransferTimeEnabled>@<X0>(char **a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  char *v4;
  _QWORD *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  v4 = &(*a1)[a2];
  result = std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(a3, *a1, v4, a2);
  *a1 = v4;
  return result;
}

void sub_2168BCF9C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168BCF8CLL);
}

void sub_2168BCFAC(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *tlv::parseV<elqm::tlv::LinkPowerCost>@<X0>(char **a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  char *v4;
  _QWORD *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  v4 = &(*a1)[a2];
  result = std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(a3, *a1, v4, a2);
  *a1 = v4;
  return result;
}

void sub_2168BD018(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168BD008);
}

void sub_2168BD028(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *tlv::parseV<elqm::tlv::DataStallEnabled>@<X0>(char **a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  char *v4;
  _QWORD *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  v4 = &(*a1)[a2];
  result = std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(a3, *a1, v4, a2);
  *a1 = v4;
  return result;
}

void sub_2168BD094(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168BD084);
}

void sub_2168BD0A4(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *tlv::parseV<elqm::tlv::NRServingCellTypeEnabled>@<X0>(char **a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  char *v4;
  _QWORD *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  v4 = &(*a1)[a2];
  result = std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(a3, *a1, v4, a2);
  *a1 = v4;
  return result;
}

void sub_2168BD110(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168BD100);
}

void sub_2168BD120(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *tlv::parseV<elqm::tlv::EstimatedThroughput>@<X0>(char **a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  char *v4;
  _QWORD *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  v4 = &(*a1)[a2];
  result = std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(a3, *a1, v4, a2);
  *a1 = v4;
  return result;
}

void sub_2168BD18C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168BD17CLL);
}

void sub_2168BD19C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t tlv::parseV<elqm::tlv::LinkStateSupported>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168BD1F0(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168BD1E4);
}

uint64_t tlv::parseV<elqm::tlv::LinkFingerprintSupported>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168BD23C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168BD230);
}

uint64_t tlv::parseV<elqm::tlv::TrafficClassSupported>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168BD288(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168BD27CLL);
}

uint64_t tlv::parseV<elqm::tlv::DataTransferTimeSupported>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168BD2D4(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168BD2C8);
}

uint64_t tlv::parseV<elqm::tlv::LinkPowerCostSupported>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168BD320(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168BD314);
}

uint64_t tlv::parseV<elqm::tlv::DataStallSupported>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168BD36C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168BD360);
}

uint64_t tlv::size<pbm::tlv::RecordInfo>()
{
  return 10;
}

uint64_t *tlv::writeV<pbm::tlv::RecordInfo>(uint64_t *result, uint64_t a2)
{
  uint64_t v2;

  v2 = *result;
  *(_BYTE *)v2 = *(_BYTE *)a2;
  *(_WORD *)(v2 + 1) = *(_WORD *)(a2 + 2);
  *(_WORD *)(v2 + 3) = *(_WORD *)(a2 + 4);
  *(_WORD *)(v2 + 5) = *(_WORD *)(a2 + 6);
  *result = v2 + 7;
  return result;
}

uint64_t tlv::parseV<pbm::tlv::NumRecords>(unint64_t *a1, int a2)
{
  unsigned __int16 *v3;
  uint64_t result;

  v3 = (unsigned __int16 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 2uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168BD3F0(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168BD3E4);
}

unint64_t pbm::tlv::parseField(unint64_t a1, const unsigned __int8 *a2, uint64_t a3)
{
  unint64_t v5;
  unint64_t v6;

  v5 = a1;
  tlv::throwIfNotEnoughBytes(a1, a2, 1uLL);
  *(_BYTE *)a3 = *(_BYTE *)v5;
  tlv::throwIfNotEnoughBytes(v5 + 1, a2, 1uLL);
  v6 = *(unsigned __int8 *)(v5 + 1);
  v5 += 2;
  tlv::throwIfNotEnoughBytes(v5, a2, v6);
  std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((_QWORD *)(a3 + 8), (char *)v5, (char *)(v5 + v6), v6);
  return v5 + v6;
}

{
  unint64_t v5;
  unint64_t v6;

  v5 = a1;
  tlv::throwIfNotEnoughBytes(a1, a2, 2uLL);
  *(_WORD *)a3 = *(_WORD *)v5;
  tlv::throwIfNotEnoughBytes(v5 + 2, a2, 1uLL);
  v6 = *(unsigned __int8 *)(v5 + 2);
  v5 += 3;
  tlv::throwIfNotEnoughBytes(v5, a2, v6);
  std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((_QWORD *)(a3 + 8), (char *)v5, (char *)(v5 + v6), v6);
  return v5 + v6;
}

{
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t result;

  tlv::throwIfNotEnoughBytes(a1, a2, 2uLL);
  *(_WORD *)a3 = *(_WORD *)a1;
  tlv::throwIfNotEnoughBytes(a1 + 2, a2, 1uLL);
  v6 = *(unsigned __int8 *)(a1 + 2);
  v7 = a1 + 3;
  std::vector<pbm::tlv::AdditionalNumberParam>::resize((uint64_t *)(a3 + 8), v6);
  v8 = *(_QWORD *)(a3 + 8);
  v9 = *(_QWORD *)(a3 + 16);
  while (1)
  {
    result = v7;
    if (v8 == v9)
      break;
    v7 = pbm::tlv::parseField(v7, a2, v8);
    v8 += 40;
  }
  return result;
}

{
  tlv::throwIfNotEnoughBytes(a1, a2, 1uLL);
  *(_BYTE *)a3 = *(_BYTE *)a1;
  tlv::throwIfNotEnoughBytes(a1 + 1, a2, 2uLL);
  *(_WORD *)(a3 + 2) = *(_WORD *)(a1 + 1);
  tlv::throwIfNotEnoughBytes(a1 + 3, a2, 2uLL);
  *(_WORD *)(a3 + 4) = *(_WORD *)(a1 + 3);
  tlv::throwIfNotEnoughBytes(a1 + 5, a2, 2uLL);
  *(_WORD *)(a3 + 6) = *(_WORD *)(a1 + 5);
  tlv::throwIfNotEnoughBytes(a1 + 7, a2, 1uLL);
  *(_BYTE *)(a3 + 8) = *(_BYTE *)(a1 + 7);
  tlv::throwIfNotEnoughBytes(a1 + 8, a2, 1uLL);
  *(_BYTE *)(a3 + 9) = *(_BYTE *)(a1 + 8);
  return a1 + 9;
}

{
  tlv::throwIfNotEnoughBytes(a1, a2, 1uLL);
  *(_BYTE *)a3 = *(_BYTE *)a1;
  tlv::throwIfNotEnoughBytes(a1 + 1, a2, 2uLL);
  *(_WORD *)(a3 + 2) = *(_WORD *)(a1 + 1);
  tlv::throwIfNotEnoughBytes(a1 + 3, a2, 1uLL);
  *(_BYTE *)(a3 + 4) = *(_BYTE *)(a1 + 3);
  tlv::throwIfNotEnoughBytes(a1 + 4, a2, 2uLL);
  *(_WORD *)(a3 + 6) = *(_WORD *)(a1 + 4);
  return a1 + 6;
}

{
  unint64_t result;

  tlv::throwIfNotEnoughBytes(a1, a2, 1uLL);
  *(_BYTE *)a3 = *(_BYTE *)a1;
  tlv::throwIfNotEnoughBytes(a1 + 1, a2, 2uLL);
  *(_WORD *)(a3 + 2) = *(_WORD *)(a1 + 1);
  tlv::throwIfNotEnoughBytes(a1 + 3, a2, 1uLL);
  result = a1 + 4;
  *(_BYTE *)(a3 + 4) = *(_BYTE *)(a1 + 3);
  return result;
}

unint64_t pbm::tlv::parseField(_BYTE *a1, const unsigned __int8 *a2, uint64_t a3)
{
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t result;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  *(_BYTE *)a3 = *a1;
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 1), a2, 1uLL);
  v6 = a1[1];
  v7 = (unint64_t)(a1 + 2);
  std::vector<pbm::tlv::EmergencyCategory>::resize((uint64_t *)(a3 + 8), v6);
  v8 = *(_QWORD *)(a3 + 8);
  v9 = *(_QWORD *)(a3 + 16);
  while (1)
  {
    result = v7;
    if (v8 == v9)
      break;
    v7 = pbm::tlv::parseField(v7, a2, v8);
    v8 += 32;
  }
  return result;
}

char *pbm::tlv::parseField(unint64_t a1, const unsigned __int8 *a2, _QWORD *a3)
{
  char *v5;
  unsigned int v6;
  char *v7;
  unsigned int v8;

  v5 = (char *)a1;
  tlv::throwIfNotEnoughBytes(a1, a2, 1uLL);
  v6 = *v5++;
  tlv::throwIfNotEnoughBytes((unint64_t)v5, a2, v6);
  v7 = &v5[v6];
  std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(a3, v5, v7, v6);
  tlv::throwIfNotEnoughBytes((unint64_t)v7, a2, 1uLL);
  v8 = *v7++;
  tlv::throwIfNotEnoughBytes((unint64_t)v7, a2, v8);
  std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(a3 + 3, v7, &v7[v8], v8);
  return &v7[v8];
}

char *pbm::tlv::parseField(_BYTE *a1, const unsigned __int8 *a2, uint64_t a3)
{
  unint64_t v6;
  char *v7;
  _QWORD *v8;
  _QWORD *v9;
  char *result;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  *(_BYTE *)a3 = *a1;
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 1), a2, 1uLL);
  v6 = a1[1];
  v7 = a1 + 2;
  std::vector<pbm::tlv::EmergencySubServiceNumber>::resize((uint64_t *)(a3 + 8), v6);
  v8 = *(_QWORD **)(a3 + 8);
  v9 = *(_QWORD **)(a3 + 16);
  while (1)
  {
    result = v7;
    if (v8 == v9)
      break;
    v7 = pbm::tlv::parseField((unint64_t)v7, a2, v8);
    v8 += 6;
  }
  return result;
}

char *pbm::tlv::parseField(unint64_t a1, const unsigned __int8 *a2, uint64_t a3)
{
  std::string::value_type *v5;
  unint64_t v6;
  unint64_t v7;
  char *v8;

  v5 = (std::string::value_type *)a1;
  tlv::throwIfNotEnoughBytes(a1, a2, 2uLL);
  *(_WORD *)a3 = *(_WORD *)v5;
  tlv::throwIfNotEnoughBytes((unint64_t)(v5 + 2), a2, 1uLL);
  *(_BYTE *)(a3 + 2) = v5[2];
  tlv::throwIfNotEnoughBytes((unint64_t)(v5 + 3), a2, 1uLL);
  *(_BYTE *)(a3 + 3) = v5[3];
  tlv::throwIfNotEnoughBytes((unint64_t)(v5 + 4), a2, 1uLL);
  v6 = v5[4];
  v5 += 5;
  tlv::throwIfNotEnoughBytes((unint64_t)v5, a2, v6);
  std::string::__assign_trivial[abi:ne180100]<unsigned char const*,unsigned char const*>((std::string *)(a3 + 8), v5, &v5[v6], v6);
  tlv::throwIfNotEnoughBytes((unint64_t)&v5[v6], a2, 1uLL);
  v8 = &v5[v6 + 1];
  v7 = v5[v6];
  tlv::throwIfNotEnoughBytes((unint64_t)v8, a2, v7);
  std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((_QWORD *)(a3 + 32), v8, &v8[v7], v7);
  return &v8[v7];
}

{
  unint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  char *result;

  tlv::throwIfNotEnoughBytes(a1, a2, 2uLL);
  *(_WORD *)a3 = *(_WORD *)a1;
  tlv::throwIfNotEnoughBytes(a1 + 2, a2, 1uLL);
  *(_BYTE *)(a3 + 2) = *(_BYTE *)(a1 + 2);
  tlv::throwIfNotEnoughBytes(a1 + 3, a2, 2uLL);
  *(_WORD *)(a3 + 4) = *(_WORD *)(a1 + 3);
  tlv::throwIfNotEnoughBytes(a1 + 5, a2, 1uLL);
  v6 = *(unsigned __int8 *)(a1 + 5);
  v7 = (char *)(a1 + 6);
  std::vector<pbm::tlv::BasicRecord>::resize((uint64_t *)(a3 + 8), v6);
  v8 = *(_QWORD *)(a3 + 8);
  v9 = *(_QWORD *)(a3 + 16);
  while (1)
  {
    result = v7;
    if (v8 == v9)
      break;
    v7 = pbm::tlv::parseField((unint64_t)v7, a2, v8);
    v8 += 56;
  }
  return result;
}

{
  unint64_t v6;
  char *v7;
  _QWORD *v8;
  _QWORD *v9;
  char *result;

  tlv::throwIfNotEnoughBytes(a1, a2, 2uLL);
  *(_WORD *)a3 = *(_WORD *)a1;
  tlv::throwIfNotEnoughBytes(a1 + 2, a2, 1uLL);
  v6 = *(unsigned __int8 *)(a1 + 2);
  v7 = (char *)(a1 + 3);
  std::vector<pbm::tlv::EmailParams>::resize((uint64_t *)(a3 + 8), v6);
  v8 = *(_QWORD **)(a3 + 8);
  v9 = *(_QWORD **)(a3 + 16);
  while (1)
  {
    result = v7;
    if (v8 == v9)
      break;
    v7 = wds::tlv::parseField((unint64_t)v7, a2, v8);
    v8 += 3;
  }
  return result;
}

char *tlv::parseV<pbm::tlv::BasicRecordData>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  char *result;

  *a3 = 0u;
  a3[1] = 0u;
  result = pbm::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), (uint64_t)a3);
  *a1 = (unint64_t)result;
  return result;
}

void sub_2168BD82C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168BD81CLL);
}

void sub_2168BD83C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  uint64_t v10;

  a10 = (void **)(v10 + 8);
  std::vector<pbm::tlv::BasicRecord>::__destroy_vector::operator()[abi:ne180100](&a10);
  _Unwind_Resume(a1);
}

unint64_t pbm::tlv::parseField(unsigned __int8 *a1, const unsigned __int8 *a2, uint64_t *a3)
{
  unint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t result;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  v7 = *a1;
  v6 = (unint64_t)(a1 + 1);
  std::vector<pbm::tlv::SecondName>::resize(a3, v7);
  v8 = *a3;
  v9 = a3[1];
  while (1)
  {
    result = v6;
    if (v8 == v9)
      break;
    v6 = pbm::tlv::parseField(v6, a2, v8);
    v8 += 32;
  }
  return result;
}

{
  unint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t result;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  v7 = *a1;
  v6 = (unint64_t)(a1 + 1);
  std::vector<pbm::tlv::AdditionalNumber>::resize(a3, v7);
  v8 = *a3;
  v9 = a3[1];
  while (1)
  {
    result = v6;
    if (v8 == v9)
      break;
    v6 = pbm::tlv::parseField(v6, a2, v8);
    v8 += 32;
  }
  return result;
}

{
  unint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t result;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  v7 = *a1;
  v6 = (unint64_t)(a1 + 1);
  std::vector<pbm::tlv::GroupId>::resize(a3, v7);
  v8 = *a3;
  v9 = a3[1];
  while (1)
  {
    result = v6;
    if (v8 == v9)
      break;
    v6 = pbm::tlv::parseField(v6, a2, v8);
    v8 += 32;
  }
  return result;
}

{
  unint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  v7 = *a1;
  v6 = (unint64_t)(a1 + 1);
  std::vector<pbm::tlv::HiddenRecord>::resize((uint64_t)a3, v7);
  v9 = *a3;
  v8 = a3[1];
  while (v9 != v8)
  {
    tlv::throwIfNotEnoughBytes(v6, a2, 2uLL);
    *(_WORD *)v9 = *(_WORD *)v6;
    tlv::throwIfNotEnoughBytes(v6 + 2, a2, 1uLL);
    *(_BYTE *)(v9 + 2) = *(_BYTE *)(v6 + 2);
    v6 += 3;
    v9 += 4;
  }
  return v6;
}

{
  unint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  __int16 v10;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  v7 = *a1;
  v6 = (unint64_t)(a1 + 1);
  std::vector<std::array<unsigned char,4ul>>::resize((uint64_t)a3, v7);
  v9 = *a3;
  v8 = a3[1];
  while (v9 != v8)
  {
    tlv::throwIfNotEnoughBytes(v6, a2, 1uLL);
    *(_BYTE *)v9 = *(_BYTE *)v6;
    tlv::throwIfNotEnoughBytes(v6 + 1, a2, 2uLL);
    v10 = *(_WORD *)(v6 + 1);
    v6 += 3;
    *(_WORD *)(v9 + 2) = v10;
    v9 += 4;
  }
  return v6;
}

unint64_t tlv::parseV<pbm::tlv::SecondNameInfo>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  unint64_t result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = pbm::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = (unsigned __int8 *)result;
  return result;
}

void sub_2168BD984(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168BD974);
}

void sub_2168BD994(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::vector<at::tlv::CommandCallback>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

uint64_t pbm::tlv::parseField(unint64_t a1, const unsigned __int8 *a2, uint64_t a3)
{
  char *v5;
  unint64_t v6;

  v5 = (char *)a1;
  tlv::throwIfNotEnoughBytes(a1, a2, 1uLL);
  *(_BYTE *)a3 = *v5;
  tlv::throwIfNotEnoughBytes((unint64_t)(v5 + 1), a2, 1uLL);
  *(_BYTE *)(a3 + 1) = v5[1];
  tlv::throwIfNotEnoughBytes((unint64_t)(v5 + 2), a2, 1uLL);
  v6 = v5[2];
  v5 += 3;
  tlv::throwIfNotEnoughBytes((unint64_t)v5, a2, v6);
  std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((_QWORD *)(a3 + 8), v5, &v5[v6], v6);
  tlv::throwIfNotEnoughBytes((unint64_t)&v5[v6], a2, 1uLL);
  *(_BYTE *)(a3 + 32) = v5[v6];
  return (uint64_t)&v5[v6 + 1];
}

unint64_t tlv::parseV<pbm::tlv::AdditionalNumberInfo>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  unint64_t result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = pbm::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = (unsigned __int8 *)result;
  return result;
}

void sub_2168BDB98(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168BDB88);
}

void sub_2168BDBA8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::vector<pbm::tlv::AdditionalNumber>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

unint64_t tlv::parseV<pbm::tlv::GroupIdInfo>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  unint64_t result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = pbm::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = (unsigned __int8 *)result;
  return result;
}

void sub_2168BDC6C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168BDC5CLL);
}

void sub_2168BDC7C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::vector<at::tlv::CommandCallback>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

char *pbm::tlv::parseField(unsigned __int8 *a1, const unsigned __int8 *a2, uint64_t *a3)
{
  char *v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  char *result;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  v7 = *a1;
  v6 = (char *)(a1 + 1);
  std::vector<pbm::tlv::EmailId>::resize(a3, v7);
  v8 = *a3;
  v9 = a3[1];
  while (1)
  {
    result = v6;
    if (v8 == v9)
      break;
    v6 = pbm::tlv::parseField((unint64_t)v6, a2, v8);
    v8 += 32;
  }
  return result;
}

{
  char *v6;
  unsigned int v7;
  _QWORD *v8;
  _QWORD *v9;
  char *result;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  v7 = *a1;
  v6 = (char *)(a1 + 1);
  std::vector<pbm::tlv::EmergencyNumber>::resize(a3, v7);
  v8 = (_QWORD *)*a3;
  v9 = (_QWORD *)a3[1];
  while (1)
  {
    result = v6;
    if (v8 == v9)
      break;
    v6 = wds::tlv::parseField((unint64_t)v6, a2, v8);
    v8 += 3;
  }
  return result;
}

{
  char *v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  char *result;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  v7 = *a1;
  v6 = (char *)(a1 + 1);
  std::vector<pbm::tlv::LocalEmergencyNumber>::resize(a3, v7);
  v8 = *a3;
  v9 = a3[1];
  while (1)
  {
    result = v6;
    if (v8 == v9)
      break;
    v6 = pbm::tlv::parseField(v6, a2, v8);
    v8 += 32;
  }
  return result;
}

char *tlv::parseV<pbm::tlv::EmailInfo>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  char *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = pbm::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = (unsigned __int8 *)result;
  return result;
}

void sub_2168BDDC4(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168BDDB4);
}

void sub_2168BDDD4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::vector<pbm::tlv::EmailId>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

unint64_t tlv::parseV<pbm::tlv::HiddenInfo>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  unint64_t result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = pbm::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = (unsigned __int8 *)result;
  return result;
}

void sub_2168BDEB4(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168BDEA8);
}

void sub_2168BDEC4(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t tlv::parseV<pbm::tlv::CapabilityBasicInformation>(unint64_t *a1, int a2)
{
  uint64_t v3;
  __int16 v4;

  v4 = 0;
  v3 = 0;
  *a1 = pbm::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), (uint64_t)&v3);
  return v3;
}

void sub_2168BDFE0(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168BDFC8);
}

uint64_t tlv::parseV<pbm::tlv::GroupCapability>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  const unsigned __int8 *v4;
  int v5;
  int v6;

  v3 = (unsigned __int8 *)*a1;
  v4 = (const unsigned __int8 *)(*a1 + a2);
  tlv::throwIfNotEnoughBytes(*a1, v4, 1uLL);
  v5 = *v3;
  tlv::throwIfNotEnoughBytes((unint64_t)(v3 + 1), v4, 1uLL);
  v6 = v3[1];
  *a1 = (unint64_t)(v3 + 2);
  return v5 | (v6 << 8);
}

void sub_2168BE054(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168BE040);
}

uint64_t tlv::parseV<pbm::tlv::AdditionalNumberCapability>(_BYTE **a1, int a2)
{
  unsigned __int16 v3;
  unsigned __int8 v4;

  v4 = 0;
  v3 = 0;
  *a1 = vs::tlv::parseField(*a1, &(*a1)[a2], &v3);
  return v3 | (v4 << 16);
}

void sub_2168BE0B4(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168BE098);
}

uint64_t tlv::parseV<pbm::tlv::EmailCapability>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  const unsigned __int8 *v4;
  int v5;
  int v6;

  v3 = (unsigned __int8 *)*a1;
  v4 = (const unsigned __int8 *)(*a1 + a2);
  tlv::throwIfNotEnoughBytes(*a1, v4, 1uLL);
  v5 = *v3;
  tlv::throwIfNotEnoughBytes((unint64_t)(v3 + 1), v4, 1uLL);
  v6 = v3[1];
  *a1 = (unint64_t)(v3 + 2);
  return v5 | (v6 << 8);
}

void sub_2168BE128(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168BE114);
}

uint64_t tlv::parseV<pbm::tlv::SecondNameCapability>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168BE174(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168BE168);
}

uint64_t tlv::parseV<pbm::tlv::HiddenRecordsCapability>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168BE1C0(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168BE1B4);
}

_BYTE *pbm::tlv::writeField(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  _BYTE *v4;

  *(_BYTE *)a1 = *(_BYTE *)a2;
  *(_WORD *)(a1 + 1) = *(_WORD *)(a2 + 2);
  *(_WORD *)(a1 + 3) = *(_WORD *)(a2 + 4);
  *(_BYTE *)(a1 + 5) = *(_BYTE *)(a2 + 6);
  *(_BYTE *)(a1 + 6) = *(_BYTE *)(a2 + 7);
  v3 = a1 + 8;
  *(_BYTE *)(a1 + 7) = *(_DWORD *)(a2 + 16) - *(_DWORD *)(a2 + 8);
  memcpy((void *)(a1 + 8), *(const void **)(a2 + 8), *(_QWORD *)(a2 + 16) - *(_QWORD *)(a2 + 8));
  v4 = (_BYTE *)(v3 + *(_QWORD *)(a2 + 16) - *(_QWORD *)(a2 + 8));
  *v4++ = *(_DWORD *)(a2 + 40) - *(_DWORD *)(a2 + 32);
  memcpy(v4, *(const void **)(a2 + 32), *(_QWORD *)(a2 + 40) - *(_QWORD *)(a2 + 32));
  return &v4[*(_QWORD *)(a2 + 40) - *(_QWORD *)(a2 + 32)];
}

uint64_t tlv::size<pbm::tlv::WriteRecordInfo>(_QWORD *a1)
{
  return a1[2] + a1[5] - (a1[1] + a1[4]) + 12;
}

_BYTE *tlv::writeV<pbm::tlv::WriteRecordInfo>(uint64_t *a1, uint64_t a2)
{
  _BYTE *result;

  result = pbm::tlv::writeField(*a1, a2);
  *a1 = (uint64_t)result;
  return result;
}

uint64_t tlv::parseV<pbm::tlv::WriteRecordId>(unint64_t *a1, int a2)
{
  unsigned __int16 *v3;
  uint64_t result;

  v3 = (unsigned __int16 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 2uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168BE2F4(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168BE2E8);
}

uint64_t tlv::parseV<pbm::tlv::RecordUpdateInfo>(unint64_t *a1, int a2)
{
  uint64_t v3;

  v3 = 0;
  *a1 = pbm::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), (uint64_t)&v3);
  return v3;
}

void sub_2168BE3D0(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168BE3BCLL);
}

char *tlv::parseV<pbm::tlv::HardCodedEmergencyNumbers>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  char *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = pbm::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = (unsigned __int8 *)result;
  return result;
}

void sub_2168BE48C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168BE47CLL);
}

void sub_2168BE49C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::vector<pbm::tlv::EmergencyNumber>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

char *tlv::parseV<pbm::tlv::NVEmergencyNumbers>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  char *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = pbm::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = (unsigned __int8 *)result;
  return result;
}

void sub_2168BE4F8(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168BE4E8);
}

void sub_2168BE508(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::vector<pbm::tlv::EmergencyNumber>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

_BYTE *pbm::tlv::parseField(unsigned __int8 *a1, const unsigned __int8 *a2, uint64_t *a3)
{
  _BYTE *v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  _BYTE *result;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  v7 = *a1;
  v6 = a1 + 1;
  std::vector<pbm::tlv::ECCEmergencyNumber>::resize(a3, v7);
  v8 = *a3;
  v9 = a3[1];
  while (1)
  {
    result = v6;
    if (v8 == v9)
      break;
    v6 = (_BYTE *)pbm::tlv::parseField(v6, a2, v8);
    v8 += 32;
  }
  return result;
}

unsigned __int8 *tlv::parseV<pbm::tlv::CardEmergencyNumbers>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  unsigned __int8 *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = pbm::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = result;
  return result;
}

void sub_2168BE5CC(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168BE5BCLL);
}

void sub_2168BE5DC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::vector<pbm::tlv::ECCEmergencyNumber>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

unsigned __int8 *tlv::parseV<pbm::tlv::NetworkEmergencyNumbers>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  unsigned __int8 *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = pbm::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = result;
  return result;
}

void sub_2168BE638(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168BE628);
}

void sub_2168BE648(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::vector<pbm::tlv::ECCEmergencyNumber>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

char *tlv::parseV<pbm::tlv::HardCodedEmergencyNumbersExtended>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  char *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = pbm::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = (unsigned __int8 *)result;
  return result;
}

void sub_2168BE6A4(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168BE694);
}

void sub_2168BE6B4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::vector<pbm::tlv::EmergencyNumber>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

char *tlv::parseV<pbm::tlv::NVEmergencyNumbersExtended>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  char *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = pbm::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = (unsigned __int8 *)result;
  return result;
}

void sub_2168BE710(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168BE700);
}

void sub_2168BE720(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::vector<pbm::tlv::EmergencyNumber>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

char *pbm::tlv::parseField(unsigned __int8 *a1, const unsigned __int8 *a2, _QWORD *a3)
{
  uint64_t v6;
  char *v7;
  unsigned int v8;
  _BYTE *v9;
  _BYTE *v10;
  unint64_t v11;
  BOOL v12;
  size_t v13;
  char v14;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  v8 = *a1;
  v7 = (char *)(a1 + 1);
  v6 = v8;
  v9 = (_BYTE *)*a3;
  v10 = (_BYTE *)a3[1];
  v11 = (unint64_t)&v10[-*a3];
  v12 = v8 >= v11;
  v13 = v8 - v11;
  if (v8 <= v11)
  {
    if (!v12)
    {
      v10 = &v9[v6];
      a3[1] = &v9[v6];
    }
  }
  else
  {
    std::vector<pbm::EmergencyCategory>::__append((uint64_t)a3, v13);
    v9 = (_BYTE *)*a3;
    v10 = (_BYTE *)a3[1];
  }
  while (v9 != v10)
  {
    tlv::throwIfNotEnoughBytes((unint64_t)v7, a2, 1uLL);
    v14 = *v7++;
    *v9++ = v14;
  }
  return v7;
}

char *tlv::parseV<pbm::tlv::HardCodedEmergencyNumbersCategories>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  char *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = pbm::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = (unsigned __int8 *)result;
  return result;
}

void sub_2168BE808(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168BE7FCLL);
}

void sub_2168BE818(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *tlv::parseV<pbm::tlv::NVEmergencyNumbersCategories>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  char *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = pbm::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = (unsigned __int8 *)result;
  return result;
}

void sub_2168BE870(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168BE864);
}

void sub_2168BE880(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *tlv::parseV<pbm::tlv::LocalEmergencyNumbersExtended>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  char *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = pbm::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = (unsigned __int8 *)result;
  return result;
}

void sub_2168BE948(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168BE938);
}

void sub_2168BE958(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::vector<pbm::tlv::LocalEmergencyNumber>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

unint64_t tlv::parseV<pbm::tlv::PhoneBookReadyInformation>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  unint64_t result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = pbm::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = (unsigned __int8 *)result;
  return result;
}

void sub_2168BEA38(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168BEA2CLL);
}

void sub_2168BEA48(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

unint64_t tlv::parseV<pbm::tlv::PBStateInfo>(unint64_t *a1, int a2)
{
  unsigned int v3;
  unsigned __int16 v4;

  v4 = 0;
  v3 = 0;
  *a1 = pbm::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), (uint64_t)&v3);
  return v3 | ((unint64_t)v4 << 32);
}

void sub_2168BEB20(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168BEB04);
}

void std::vector<pbm::tlv::EmergencyNumber>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<pbm::tlv::EmergencyNumber>::__clear[abi:ne180100]((uint64_t *)v2);
    operator delete(**a1);
  }
}

void std::vector<pbm::tlv::EmergencyNumber>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  void *v6;

  v3 = *a1;
  v2 = a1[1];
  if (v2 != *a1)
  {
    v4 = a1[1];
    do
    {
      v6 = *(void **)(v4 - 24);
      v4 -= 24;
      v5 = v6;
      if (v6)
      {
        *(_QWORD *)(v2 - 16) = v5;
        operator delete(v5);
      }
      v2 = v4;
    }
    while (v4 != v3);
  }
  a1[1] = v3;
}

void std::vector<pbm::tlv::EmergencySubServiceNumber>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 48;
        std::__destroy_at[abi:ne180100]<pbm::tlv::EmergencySubServiceNumber,0>(v4);
      }
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::__destroy_at[abi:ne180100]<pbm::tlv::EmergencySubServiceNumber,0>(uint64_t a1)
{
  void *v2;
  void *v3;

  v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(_QWORD *)(a1 + 32) = v2;
    operator delete(v2);
  }
  v3 = *(void **)a1;
  if (*(_QWORD *)a1)
  {
    *(_QWORD *)(a1 + 8) = v3;
    operator delete(v3);
  }
}

void std::vector<pbm::tlv::BasicRecord>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 56;
        std::__destroy_at[abi:ne180100]<pbm::tlv::BasicRecord,0>(v4);
      }
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::__destroy_at[abi:ne180100]<pbm::tlv::BasicRecord,0>(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 32);
  if (v2)
  {
    *(_QWORD *)(a1 + 40) = v2;
    operator delete(v2);
  }
  if (*(char *)(a1 + 31) < 0)
    operator delete(*(void **)(a1 + 8));
}

void std::vector<pbm::tlv::AdditionalNumberParam>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<pbm::tlv::AdditionalNumberParam>::__clear[abi:ne180100]((uint64_t *)v2);
    operator delete(**a1);
  }
}

void std::vector<pbm::tlv::AdditionalNumberParam>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v2;
  uint64_t i;
  void *v4;

  v2 = *a1;
  for (i = a1[1]; i != v2; i -= 40)
  {
    v4 = *(void **)(i - 32);
    if (v4)
    {
      *(_QWORD *)(i - 24) = v4;
      operator delete(v4);
    }
  }
  a1[1] = v2;
}

void std::vector<pbm::tlv::AdditionalNumber>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  char *v6;
  void **v7;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = v4 - 32;
        v7 = (void **)(v4 - 24);
        std::vector<pbm::tlv::AdditionalNumberParam>::__destroy_vector::operator()[abi:ne180100](&v7);
        v4 = v6;
      }
      while (v6 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<pbm::tlv::EmailId>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  char *v6;
  void **v7;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = v4 - 32;
        v7 = (void **)(v4 - 24);
        std::vector<pbm::tlv::EmergencyNumber>::__destroy_vector::operator()[abi:ne180100](&v7);
        v4 = v6;
      }
      while (v6 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<pbm::tlv::ECCEmergencyNumber>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  char *v6;
  void **v7;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = v4 - 32;
        v7 = (void **)(v4 - 24);
        std::vector<at::tlv::CommandCallback>::__destroy_vector::operator()[abi:ne180100](&v7);
        v4 = v6;
      }
      while (v6 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<pbm::tlv::LocalEmergencyNumber>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  char *v6;
  void **v7;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = v4 - 32;
        v7 = (void **)(v4 - 24);
        std::vector<pbm::tlv::EmergencySubServiceNumber>::__destroy_vector::operator()[abi:ne180100](&v7);
        v4 = v6;
      }
      while (v6 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<pbm::tlv::EmergencyNumber>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  BOOL v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  void *v10;

  v3 = a1[1];
  v4 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  v5 = a2 >= v4;
  v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    std::vector<pbm::tlv::EmergencyNumber>::__append(a1, v6);
  }
  else if (!v5)
  {
    v7 = *a1 + 24 * a2;
    if (v3 != v7)
    {
      v8 = a1[1];
      do
      {
        v10 = *(void **)(v8 - 24);
        v8 -= 24;
        v9 = v10;
        if (v10)
        {
          *(_QWORD *)(v3 - 16) = v9;
          operator delete(v9);
        }
        v3 = v8;
      }
      while (v8 != v7);
    }
    a1[1] = v7;
  }
}

void std::vector<pbm::tlv::EmergencyNumber>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  size_t v13;
  size_t v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - v7) >> 3) >= a2)
  {
    if (a2)
    {
      v13 = 24 * ((24 * a2 - 24) / 0x18) + 24;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = 0xAAAAAAAAAAAAAAABLL * ((v7 - *a1) >> 3);
    v9 = v8 + a2;
    if (v8 + a2 > 0xAAAAAAAAAAAAAAALL)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *a1) >> 3);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x555555555555555)
      v11 = 0xAAAAAAAAAAAAAAALL;
    else
      v11 = v9;
    v19 = v4;
    if (v11)
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>(v4, v11);
    else
      v12 = 0;
    v15 = v12;
    v16 = &v12[24 * v8];
    v18 = &v12[24 * v11];
    v14 = 24 * ((24 * a2 - 24) / 0x18) + 24;
    bzero(v16, v14);
    v17 = &v16[v14];
    std::vector<pbm::tlv::EmergencyNumber>::__swap_out_circular_buffer(a1, &v15);
    std::__split_buffer<pbm::tlv::EmergencyNumber>::~__split_buffer((uint64_t)&v15);
  }
}

void sub_2168BF17C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<pbm::tlv::EmergencyNumber>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<pbm::tlv::EmergencyNumber>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<pbm::tlv::EmergencyNumber>,std::reverse_iterator<pbm::tlv::EmergencyNumber*>,std::reverse_iterator<pbm::tlv::EmergencyNumber*>,std::reverse_iterator<pbm::tlv::EmergencyNumber*>>((uint64_t)(a1 + 2), a1[1], (_QWORD *)a1[1], *a1, (_QWORD *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<pbm::tlv::EmergencyNumber>,std::reverse_iterator<pbm::tlv::EmergencyNumber*>,std::reverse_iterator<pbm::tlv::EmergencyNumber*>,std::reverse_iterator<pbm::tlv::EmergencyNumber*>>(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4, _QWORD *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  __int128 v8;
  uint64_t v9;
  _QWORD v11[3];
  uint64_t v12;
  __int128 v13;
  __int128 v14;

  v7 = a7;
  *(_QWORD *)&v14 = a6;
  *((_QWORD *)&v14 + 1) = a7;
  v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  v12 = 0;
  if (a3 == a5)
  {
    v9 = a6;
  }
  else
  {
    do
    {
      *(_QWORD *)(v7 - 24) = 0;
      *(_QWORD *)(v7 - 16) = 0;
      *(_QWORD *)(v7 - 8) = 0;
      v8 = *(_OWORD *)(a3 - 3);
      a3 -= 3;
      *(_OWORD *)(v7 - 24) = v8;
      *(_QWORD *)(v7 - 8) = a3[2];
      *a3 = 0;
      a3[1] = 0;
      a3[2] = 0;
      v7 = *((_QWORD *)&v14 + 1) - 24;
      *((_QWORD *)&v14 + 1) -= 24;
    }
    while (a3 != a5);
    v9 = v14;
  }
  LOBYTE(v12) = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<pbm::tlv::EmergencyNumber>,std::reverse_iterator<pbm::tlv::EmergencyNumber*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v11);
  return v9;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<pbm::tlv::EmergencyNumber>,std::reverse_iterator<pbm::tlv::EmergencyNumber*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<pbm::tlv::EmergencyNumber>,std::reverse_iterator<pbm::tlv::EmergencyNumber*>>::operator()[abi:ne180100](a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<pbm::tlv::EmergencyNumber>,std::reverse_iterator<pbm::tlv::EmergencyNumber*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  void *v3;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8);
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    v3 = *(void **)v1;
    if (*(_QWORD *)v1)
    {
      *(_QWORD *)(v1 + 8) = v3;
      operator delete(v3);
    }
    v1 += 24;
  }
}

uint64_t std::__split_buffer<pbm::tlv::EmergencyNumber>::~__split_buffer(uint64_t a1)
{
  std::__split_buffer<pbm::tlv::EmergencyNumber>::__destruct_at_end[abi:ne180100](a1, *(_QWORD *)(a1 + 8));
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::__split_buffer<pbm::tlv::EmergencyNumber>::__destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  void *v5;

  v2 = *(_QWORD *)(a1 + 16);
  while (v2 != a2)
  {
    v5 = *(void **)(v2 - 24);
    *(_QWORD *)(a1 + 16) = v2 - 24;
    if (v5)
    {
      *(_QWORD *)(v2 - 16) = v5;
      operator delete(v5);
      v2 = *(_QWORD *)(a1 + 16);
    }
    else
    {
      v2 -= 24;
    }
  }
}

void std::vector<pbm::tlv::EmergencyCategory>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  void *v6;

  v3 = a1[1];
  v4 = (v3 - *a1) >> 5;
  if (a2 <= v4)
  {
    if (a2 < v4)
    {
      v5 = *a1 + 32 * a2;
      while (v3 != v5)
      {
        v6 = *(void **)(v3 - 24);
        if (v6)
        {
          *(_QWORD *)(v3 - 16) = v6;
          operator delete(v6);
        }
        v3 -= 32;
      }
      a1[1] = v5;
    }
  }
  else
  {
    std::vector<pbm::tlv::EmergencyCategory>::__append(a1, a2 - v4);
  }
}

void std::vector<pbm::tlv::EmergencyCategory>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (a2 <= (v6 - v7) >> 5)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 32 * a2);
      v7 += 32 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = v7 - *a1;
    v9 = a2 + (v8 >> 5);
    if (v9 >> 59)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 5;
    v11 = v5 - *a1;
    if (v11 >> 4 > v9)
      v9 = v11 >> 4;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFE0)
      v12 = 0x7FFFFFFFFFFFFFFLL;
    else
      v12 = v9;
    v18 = v4;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<vs::tlv::RemoteNumberListItem>>(v4, v12);
    else
      v13 = 0;
    v14 = v13;
    v15 = &v13[32 * v10];
    v17 = &v13[32 * v12];
    bzero(v15, 32 * a2);
    v16 = &v15[32 * a2];
    std::vector<pbm::tlv::EmergencyCategory>::__swap_out_circular_buffer(a1, &v14);
    std::__split_buffer<at::tlv::CommandCallback>::~__split_buffer((uint64_t)&v14);
  }
}

void sub_2168BF514(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<at::tlv::CommandCallback>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<pbm::tlv::EmergencyCategory>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<pbm::tlv::EmergencyCategory>,std::reverse_iterator<pbm::tlv::EmergencyCategory*>,std::reverse_iterator<pbm::tlv::EmergencyCategory*>,std::reverse_iterator<pbm::tlv::EmergencyCategory*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<pbm::tlv::EmergencyCategory>,std::reverse_iterator<pbm::tlv::EmergencyCategory*>,std::reverse_iterator<pbm::tlv::EmergencyCategory*>,std::reverse_iterator<pbm::tlv::EmergencyCategory*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  char v8;
  uint64_t v9;
  _QWORD v11[3];
  uint64_t v12;
  __int128 v13;
  __int128 v14;

  v7 = a7;
  *(_QWORD *)&v14 = a6;
  *((_QWORD *)&v14 + 1) = a7;
  v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  v12 = 0;
  if (a3 == a5)
  {
    v9 = a6;
  }
  else
  {
    do
    {
      v8 = *(_BYTE *)(a3 - 32);
      a3 -= 32;
      *(_BYTE *)(v7 - 32) = v8;
      *(_QWORD *)(v7 - 16) = 0;
      *(_QWORD *)(v7 - 8) = 0;
      *(_QWORD *)(v7 - 24) = 0;
      *(_OWORD *)(v7 - 24) = *(_OWORD *)(a3 + 8);
      *(_QWORD *)(v7 - 8) = *(_QWORD *)(a3 + 24);
      *(_QWORD *)(a3 + 8) = 0;
      *(_QWORD *)(a3 + 16) = 0;
      *(_QWORD *)(a3 + 24) = 0;
      v7 = *((_QWORD *)&v14 + 1) - 32;
      *((_QWORD *)&v14 + 1) -= 32;
    }
    while (a3 != a5);
    v9 = v14;
  }
  LOBYTE(v12) = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<pbm::tlv::EmergencyCategory>,std::reverse_iterator<pbm::tlv::EmergencyCategory*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v11);
  return v9;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<pbm::tlv::EmergencyCategory>,std::reverse_iterator<pbm::tlv::EmergencyCategory*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<at::tlv::CommandCallback>,std::reverse_iterator<at::tlv::CommandCallback*>>::operator()[abi:ne180100](a1);
  return a1;
}

void std::vector<pbm::tlv::EmergencySubServiceNumber>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  BOOL v5;
  unint64_t v6;
  uint64_t v7;

  v3 = a1[1];
  v4 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 4);
  v5 = a2 >= v4;
  v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    std::vector<pbm::tlv::EmergencySubServiceNumber>::__append(a1, v6);
  }
  else if (!v5)
  {
    v7 = *a1 + 48 * a2;
    while (v3 != v7)
    {
      v3 -= 48;
      std::__destroy_at[abi:ne180100]<pbm::tlv::EmergencySubServiceNumber,0>(v3);
    }
    a1[1] = v7;
  }
}

void std::vector<pbm::tlv::EmergencySubServiceNumber>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  size_t v13;
  size_t v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - v7) >> 4) >= a2)
  {
    if (a2)
    {
      v13 = 48 * ((48 * a2 - 48) / 0x30) + 48;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = 0xAAAAAAAAAAAAAAABLL * ((v7 - *a1) >> 4);
    v9 = v8 + a2;
    if (v8 + a2 > 0x555555555555555)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *a1) >> 4);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x2AAAAAAAAAAAAAALL)
      v11 = 0x555555555555555;
    else
      v11 = v9;
    v19 = v4;
    if (v11)
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::AppInfo>>(v4, v11);
    else
      v12 = 0;
    v15 = v12;
    v16 = &v12[48 * v8];
    v18 = &v12[48 * v11];
    v14 = 48 * ((48 * a2 - 48) / 0x30) + 48;
    bzero(v16, v14);
    v17 = &v16[v14];
    std::vector<pbm::tlv::EmergencySubServiceNumber>::__swap_out_circular_buffer(a1, &v15);
    std::__split_buffer<pbm::tlv::EmergencySubServiceNumber>::~__split_buffer((uint64_t)&v15);
  }
}

void sub_2168BF84C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<pbm::tlv::EmergencySubServiceNumber>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::vector<pbm::tlv::EmergencySubServiceNumber>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<pbm::tlv::EmergencySubServiceNumber>,std::reverse_iterator<pbm::tlv::EmergencySubServiceNumber*>,std::reverse_iterator<pbm::tlv::EmergencySubServiceNumber*>,std::reverse_iterator<pbm::tlv::EmergencySubServiceNumber*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v4;
  v5 = *a1;
  *a1 = v4;
  a2[1] = v5;
  v6 = a1[1];
  a1[1] = a2[2];
  a2[2] = v6;
  v7 = a1[2];
  a1[2] = a2[3];
  a2[3] = v7;
  *a2 = a2[1];
}

__n128 std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<pbm::tlv::EmergencySubServiceNumber>,std::reverse_iterator<pbm::tlv::EmergencySubServiceNumber*>,std::reverse_iterator<pbm::tlv::EmergencySubServiceNumber*>,std::reverse_iterator<pbm::tlv::EmergencySubServiceNumber*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __n128 result;

  if (a3 != a5)
  {
    v7 = 0;
    do
    {
      v8 = a7 + v7;
      v9 = a3 + v7;
      *(_QWORD *)(v8 - 48) = 0;
      *(_QWORD *)(v8 - 40) = 0;
      *(_QWORD *)(v8 - 32) = 0;
      *(_OWORD *)(v8 - 48) = *(_OWORD *)(a3 + v7 - 48);
      *(_QWORD *)(v8 - 32) = *(_QWORD *)(a3 + v7 - 32);
      *(_QWORD *)(v9 - 48) = 0;
      *(_QWORD *)(v9 - 40) = 0;
      *(_QWORD *)(v9 - 32) = 0;
      *(_QWORD *)(v8 - 24) = 0;
      *(_QWORD *)(v8 - 16) = 0;
      *(_QWORD *)(v8 - 8) = 0;
      result = *(__n128 *)(a3 + v7 - 24);
      *(__n128 *)(v8 - 24) = result;
      *(_QWORD *)(v8 - 8) = *(_QWORD *)(a3 + v7 - 8);
      *(_QWORD *)(v9 - 24) = 0;
      *(_QWORD *)(v9 - 16) = 0;
      *(_QWORD *)(v9 - 8) = 0;
      v7 -= 48;
    }
    while (a3 + v7 != a5);
  }
  return result;
}

uint64_t std::__split_buffer<pbm::tlv::EmergencySubServiceNumber>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 48;
    std::__destroy_at[abi:ne180100]<pbm::tlv::EmergencySubServiceNumber,0>(i - 48);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::vector<pbm::tlv::BasicRecord>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  BOOL v5;
  unint64_t v6;
  uint64_t v7;

  v3 = a1[1];
  v4 = 0x6DB6DB6DB6DB6DB7 * ((v3 - *a1) >> 3);
  v5 = a2 >= v4;
  v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    std::vector<pbm::tlv::BasicRecord>::__append(a1, v6);
  }
  else if (!v5)
  {
    v7 = *a1 + 56 * a2;
    while (v3 != v7)
    {
      v3 -= 56;
      std::__destroy_at[abi:ne180100]<pbm::tlv::BasicRecord,0>(v3);
    }
    a1[1] = v7;
  }
}

void std::vector<pbm::tlv::BasicRecord>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  size_t v13;
  size_t v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (0x6DB6DB6DB6DB6DB7 * ((v6 - v7) >> 3) >= a2)
  {
    if (a2)
    {
      v13 = 56 * ((56 * a2 - 56) / 0x38) + 56;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = 0x6DB6DB6DB6DB6DB7 * ((v7 - *a1) >> 3);
    v9 = v8 + a2;
    if (v8 + a2 > 0x492492492492492)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = 0x6DB6DB6DB6DB6DB7 * ((v5 - *a1) >> 3);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x249249249249249)
      v11 = 0x492492492492492;
    else
      v11 = v9;
    v19 = v4;
    if (v11)
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<pbm::tlv::BasicRecord>>(v4, v11);
    else
      v12 = 0;
    v15 = v12;
    v16 = &v12[56 * v8];
    v18 = &v12[56 * v11];
    v14 = 56 * ((56 * a2 - 56) / 0x38) + 56;
    bzero(v16, v14);
    v17 = &v16[v14];
    std::vector<pbm::tlv::BasicRecord>::__swap_out_circular_buffer(a1, &v15);
    std::__split_buffer<pbm::tlv::BasicRecord>::~__split_buffer((uint64_t)&v15);
  }
}

void sub_2168BFBB0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<pbm::tlv::BasicRecord>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t *std::vector<pbm::tlv::BasicRecord>::__swap_out_circular_buffer(uint64_t *result, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __int128 v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v3 = *result;
  v2 = result[1];
  v4 = a2[1];
  if (v2 != *result)
  {
    v5 = 0;
    do
    {
      v6 = v4 + v5;
      v7 = v2 + v5;
      *(_DWORD *)(v6 - 56) = *(_DWORD *)(v2 + v5 - 56);
      v8 = *(_OWORD *)(v2 + v5 - 48);
      *(_QWORD *)(v6 - 32) = *(_QWORD *)(v2 + v5 - 32);
      *(_OWORD *)(v6 - 48) = v8;
      *(_QWORD *)(v7 - 40) = 0;
      *(_QWORD *)(v7 - 32) = 0;
      *(_QWORD *)(v7 - 48) = 0;
      *(_QWORD *)(v6 - 24) = 0;
      *(_QWORD *)(v6 - 16) = 0;
      *(_QWORD *)(v6 - 8) = 0;
      *(_OWORD *)(v6 - 24) = *(_OWORD *)(v2 + v5 - 24);
      *(_QWORD *)(v6 - 8) = *(_QWORD *)(v2 + v5 - 8);
      *(_QWORD *)(v7 - 24) = 0;
      *(_QWORD *)(v7 - 16) = 0;
      *(_QWORD *)(v7 - 8) = 0;
      v5 -= 56;
    }
    while (v2 + v5 != v3);
    v4 += v5;
  }
  a2[1] = v4;
  v9 = *result;
  *result = v4;
  a2[1] = v9;
  v10 = result[1];
  result[1] = a2[2];
  a2[2] = v10;
  v11 = result[2];
  result[2] = a2[3];
  a2[3] = v11;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<pbm::tlv::BasicRecord>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x492492492492493)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(56 * a2);
}

uint64_t std::__split_buffer<pbm::tlv::BasicRecord>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 56;
    std::__destroy_at[abi:ne180100]<pbm::tlv::BasicRecord,0>(i - 56);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::vector<pbm::tlv::SecondName>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  void *v6;

  v3 = a1[1];
  v4 = (v3 - *a1) >> 5;
  if (a2 <= v4)
  {
    if (a2 < v4)
    {
      v5 = *a1 + 32 * a2;
      while (v3 != v5)
      {
        v6 = *(void **)(v3 - 24);
        if (v6)
        {
          *(_QWORD *)(v3 - 16) = v6;
          operator delete(v6);
        }
        v3 -= 32;
      }
      a1[1] = v5;
    }
  }
  else
  {
    std::vector<pbm::tlv::SecondName>::__append(a1, a2 - v4);
  }
}

void std::vector<pbm::tlv::SecondName>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (a2 <= (v6 - v7) >> 5)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 32 * a2);
      v7 += 32 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = v7 - *a1;
    v9 = a2 + (v8 >> 5);
    if (v9 >> 59)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 5;
    v11 = v5 - *a1;
    if (v11 >> 4 > v9)
      v9 = v11 >> 4;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFE0)
      v12 = 0x7FFFFFFFFFFFFFFLL;
    else
      v12 = v9;
    v18 = v4;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<vs::tlv::RemoteNumberListItem>>(v4, v12);
    else
      v13 = 0;
    v14 = v13;
    v15 = &v13[32 * v10];
    v17 = &v13[32 * v12];
    bzero(v15, 32 * a2);
    v16 = &v15[32 * a2];
    std::vector<pbm::tlv::SecondName>::__swap_out_circular_buffer(a1, &v14);
    std::__split_buffer<at::tlv::CommandCallback>::~__split_buffer((uint64_t)&v14);
  }
}

void sub_2168BFE70(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<at::tlv::CommandCallback>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<pbm::tlv::SecondName>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<pbm::tlv::SecondName>,std::reverse_iterator<pbm::tlv::SecondName*>,std::reverse_iterator<pbm::tlv::SecondName*>,std::reverse_iterator<pbm::tlv::SecondName*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<pbm::tlv::SecondName>,std::reverse_iterator<pbm::tlv::SecondName*>,std::reverse_iterator<pbm::tlv::SecondName*>,std::reverse_iterator<pbm::tlv::SecondName*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  __int16 v8;
  uint64_t v9;
  _QWORD v11[3];
  uint64_t v12;
  __int128 v13;
  __int128 v14;

  v7 = a7;
  *(_QWORD *)&v14 = a6;
  *((_QWORD *)&v14 + 1) = a7;
  v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  v12 = 0;
  if (a3 == a5)
  {
    v9 = a6;
  }
  else
  {
    do
    {
      v8 = *(_WORD *)(a3 - 32);
      a3 -= 32;
      *(_WORD *)(v7 - 32) = v8;
      *(_QWORD *)(v7 - 16) = 0;
      *(_QWORD *)(v7 - 8) = 0;
      *(_QWORD *)(v7 - 24) = 0;
      *(_OWORD *)(v7 - 24) = *(_OWORD *)(a3 + 8);
      *(_QWORD *)(v7 - 8) = *(_QWORD *)(a3 + 24);
      *(_QWORD *)(a3 + 8) = 0;
      *(_QWORD *)(a3 + 16) = 0;
      *(_QWORD *)(a3 + 24) = 0;
      v7 = *((_QWORD *)&v14 + 1) - 32;
      *((_QWORD *)&v14 + 1) -= 32;
    }
    while (a3 != a5);
    v9 = v14;
  }
  LOBYTE(v12) = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<pbm::tlv::SecondName>,std::reverse_iterator<pbm::tlv::SecondName*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v11);
  return v9;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<pbm::tlv::SecondName>,std::reverse_iterator<pbm::tlv::SecondName*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<at::tlv::CommandCallback>,std::reverse_iterator<at::tlv::CommandCallback*>>::operator()[abi:ne180100](a1);
  return a1;
}

void std::vector<pbm::tlv::AdditionalNumberParam>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  BOOL v5;
  unint64_t v6;
  uint64_t v7;
  void *v8;

  v3 = a1[1];
  v4 = 0xCCCCCCCCCCCCCCCDLL * ((v3 - *a1) >> 3);
  v5 = a2 >= v4;
  v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    std::vector<pbm::tlv::AdditionalNumberParam>::__append(a1, v6);
  }
  else if (!v5)
  {
    v7 = *a1 + 40 * a2;
    while (v3 != v7)
    {
      v8 = *(void **)(v3 - 32);
      if (v8)
      {
        *(_QWORD *)(v3 - 24) = v8;
        operator delete(v8);
      }
      v3 -= 40;
    }
    a1[1] = v7;
  }
}

void std::vector<pbm::tlv::AdditionalNumberParam>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  size_t v13;
  size_t v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (0xCCCCCCCCCCCCCCCDLL * ((v6 - v7) >> 3) >= a2)
  {
    if (a2)
    {
      v13 = 40 * ((40 * a2 - 40) / 0x28) + 40;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = 0xCCCCCCCCCCCCCCCDLL * ((v7 - *a1) >> 3);
    v9 = v8 + a2;
    if (v8 + a2 > 0x666666666666666)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = 0xCCCCCCCCCCCCCCCDLL * ((v5 - *a1) >> 3);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x333333333333333)
      v11 = 0x666666666666666;
    else
      v11 = v9;
    v19 = v4;
    if (v11)
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<vs::tlv::ServiceParam>>(v4, v11);
    else
      v12 = 0;
    v15 = v12;
    v16 = &v12[40 * v8];
    v18 = &v12[40 * v11];
    v14 = 40 * ((40 * a2 - 40) / 0x28) + 40;
    bzero(v16, v14);
    v17 = &v16[v14];
    std::vector<pbm::tlv::AdditionalNumberParam>::__swap_out_circular_buffer(a1, &v15);
    std::__split_buffer<pbm::tlv::AdditionalNumberParam>::~__split_buffer((uint64_t)&v15);
  }
}

void sub_2168C01B0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<pbm::tlv::AdditionalNumberParam>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<pbm::tlv::AdditionalNumberParam>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<pbm::tlv::AdditionalNumberParam>,std::reverse_iterator<pbm::tlv::AdditionalNumberParam*>,std::reverse_iterator<pbm::tlv::AdditionalNumberParam*>,std::reverse_iterator<pbm::tlv::AdditionalNumberParam*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<pbm::tlv::AdditionalNumberParam>,std::reverse_iterator<pbm::tlv::AdditionalNumberParam*>,std::reverse_iterator<pbm::tlv::AdditionalNumberParam*>,std::reverse_iterator<pbm::tlv::AdditionalNumberParam*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  __int16 v8;
  uint64_t v9;
  _QWORD v11[3];
  uint64_t v12;
  __int128 v13;
  __int128 v14;

  v7 = a7;
  *(_QWORD *)&v14 = a6;
  *((_QWORD *)&v14 + 1) = a7;
  v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  v12 = 0;
  if (a3 == a5)
  {
    v9 = a6;
  }
  else
  {
    do
    {
      v8 = *(_WORD *)(a3 - 40);
      a3 -= 40;
      *(_WORD *)(v7 - 40) = v8;
      *(_QWORD *)(v7 - 24) = 0;
      *(_QWORD *)(v7 - 16) = 0;
      *(_QWORD *)(v7 - 32) = 0;
      *(_OWORD *)(v7 - 32) = *(_OWORD *)(a3 + 8);
      *(_QWORD *)(v7 - 16) = *(_QWORD *)(a3 + 24);
      *(_QWORD *)(a3 + 16) = 0;
      *(_QWORD *)(a3 + 24) = 0;
      *(_QWORD *)(a3 + 8) = 0;
      *(_BYTE *)(v7 - 8) = *(_BYTE *)(a3 + 32);
      v7 = *((_QWORD *)&v14 + 1) - 40;
      *((_QWORD *)&v14 + 1) -= 40;
    }
    while (a3 != a5);
    v9 = v14;
  }
  LOBYTE(v12) = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<pbm::tlv::AdditionalNumberParam>,std::reverse_iterator<pbm::tlv::AdditionalNumberParam*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v11);
  return v9;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<pbm::tlv::AdditionalNumberParam>,std::reverse_iterator<pbm::tlv::AdditionalNumberParam*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<pbm::tlv::AdditionalNumberParam>,std::reverse_iterator<pbm::tlv::AdditionalNumberParam*>>::operator()[abi:ne180100](a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<pbm::tlv::AdditionalNumberParam>,std::reverse_iterator<pbm::tlv::AdditionalNumberParam*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  void *v3;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8);
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    v3 = *(void **)(v1 + 8);
    if (v3)
    {
      *(_QWORD *)(v1 + 16) = v3;
      operator delete(v3);
    }
    v1 += 40;
  }
}

uint64_t std::__split_buffer<pbm::tlv::AdditionalNumberParam>::~__split_buffer(uint64_t a1)
{
  std::__split_buffer<pbm::tlv::AdditionalNumberParam>::__destruct_at_end[abi:ne180100](a1, *(_QWORD *)(a1 + 8));
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::__split_buffer<pbm::tlv::AdditionalNumberParam>::__destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  void *v5;

  v2 = *(_QWORD *)(a1 + 16);
  while (v2 != a2)
  {
    *(_QWORD *)(a1 + 16) = v2 - 40;
    v5 = *(void **)(v2 - 32);
    if (v5)
    {
      *(_QWORD *)(v2 - 24) = v5;
      operator delete(v5);
      v2 = *(_QWORD *)(a1 + 16);
    }
    else
    {
      v2 -= 40;
    }
  }
}

void std::vector<pbm::tlv::AdditionalNumber>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  void **v7;

  v3 = a1[1];
  v4 = (v3 - *a1) >> 5;
  if (a2 <= v4)
  {
    if (a2 < v4)
    {
      v5 = *a1 + 32 * a2;
      if (v3 != v5)
      {
        do
        {
          v6 = v3 - 32;
          v7 = (void **)(v3 - 24);
          std::vector<pbm::tlv::AdditionalNumberParam>::__destroy_vector::operator()[abi:ne180100](&v7);
          v3 = v6;
        }
        while (v6 != v5);
      }
      a1[1] = v5;
    }
  }
  else
  {
    std::vector<pbm::tlv::AdditionalNumber>::__append(a1, a2 - v4);
  }
}

void std::vector<pbm::tlv::AdditionalNumber>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  void *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (a2 <= (v6 - v7) >> 5)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 32 * a2);
      v7 += 32 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = v7 - *a1;
    v9 = a2 + (v8 >> 5);
    if (v9 >> 59)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 5;
    v11 = v5 - *a1;
    if (v11 >> 4 > v9)
      v9 = v11 >> 4;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFE0)
      v12 = 0x7FFFFFFFFFFFFFFLL;
    else
      v12 = v9;
    v18 = v4;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<vs::tlv::RemoteNumberListItem>>(v4, v12);
    else
      v13 = 0;
    v14 = v13;
    v15 = &v13[32 * v10];
    v17 = &v13[32 * v12];
    bzero(v15, 32 * a2);
    v16 = &v15[32 * a2];
    std::vector<pbm::tlv::AdditionalNumber>::__swap_out_circular_buffer(a1, &v14);
    std::__split_buffer<pbm::tlv::AdditionalNumber>::~__split_buffer(&v14);
  }
}

void sub_2168C056C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<pbm::tlv::AdditionalNumber>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<pbm::tlv::AdditionalNumber>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<pbm::tlv::AdditionalNumber>,std::reverse_iterator<pbm::tlv::AdditionalNumber*>,std::reverse_iterator<pbm::tlv::AdditionalNumber*>,std::reverse_iterator<pbm::tlv::AdditionalNumber*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<pbm::tlv::AdditionalNumber>,std::reverse_iterator<pbm::tlv::AdditionalNumber*>,std::reverse_iterator<pbm::tlv::AdditionalNumber*>,std::reverse_iterator<pbm::tlv::AdditionalNumber*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  __int16 v8;
  uint64_t v9;
  _QWORD v11[3];
  uint64_t v12;
  __int128 v13;
  __int128 v14;

  v7 = a7;
  *(_QWORD *)&v14 = a6;
  *((_QWORD *)&v14 + 1) = a7;
  v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  v12 = 0;
  if (a3 == a5)
  {
    v9 = a6;
  }
  else
  {
    do
    {
      v8 = *(_WORD *)(a3 - 32);
      a3 -= 32;
      *(_WORD *)(v7 - 32) = v8;
      *(_QWORD *)(v7 - 16) = 0;
      *(_QWORD *)(v7 - 8) = 0;
      *(_QWORD *)(v7 - 24) = 0;
      *(_OWORD *)(v7 - 24) = *(_OWORD *)(a3 + 8);
      *(_QWORD *)(v7 - 8) = *(_QWORD *)(a3 + 24);
      *(_QWORD *)(a3 + 8) = 0;
      *(_QWORD *)(a3 + 16) = 0;
      *(_QWORD *)(a3 + 24) = 0;
      v7 = *((_QWORD *)&v14 + 1) - 32;
      *((_QWORD *)&v14 + 1) -= 32;
    }
    while (a3 != a5);
    v9 = v14;
  }
  LOBYTE(v12) = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<pbm::tlv::AdditionalNumber>,std::reverse_iterator<pbm::tlv::AdditionalNumber*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v11);
  return v9;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<pbm::tlv::AdditionalNumber>,std::reverse_iterator<pbm::tlv::AdditionalNumber*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<pbm::tlv::AdditionalNumber>,std::reverse_iterator<pbm::tlv::AdditionalNumber*>>::operator()[abi:ne180100](a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<pbm::tlv::AdditionalNumber>,std::reverse_iterator<pbm::tlv::AdditionalNumber*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  void **v3;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8);
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    v3 = (void **)(v1 + 8);
    std::vector<pbm::tlv::AdditionalNumberParam>::__destroy_vector::operator()[abi:ne180100](&v3);
    v1 += 32;
  }
}

void **std::__split_buffer<pbm::tlv::AdditionalNumber>::~__split_buffer(void **a1)
{
  std::__split_buffer<pbm::tlv::AdditionalNumber>::clear[abi:ne180100]((uint64_t)a1);
  if (*a1)
    operator delete(*a1);
  return a1;
}

void std::__split_buffer<pbm::tlv::AdditionalNumber>::clear[abi:ne180100](uint64_t a1)
{
  uint64_t i;
  uint64_t v2;
  void **v4;

  v2 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v2; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 32;
    v4 = (void **)(i - 24);
    std::vector<pbm::tlv::AdditionalNumberParam>::__destroy_vector::operator()[abi:ne180100](&v4);
  }
}

void std::vector<pbm::tlv::GroupId>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  void *v6;

  v3 = a1[1];
  v4 = (v3 - *a1) >> 5;
  if (a2 <= v4)
  {
    if (a2 < v4)
    {
      v5 = *a1 + 32 * a2;
      while (v3 != v5)
      {
        v6 = *(void **)(v3 - 24);
        if (v6)
        {
          *(_QWORD *)(v3 - 16) = v6;
          operator delete(v6);
        }
        v3 -= 32;
      }
      a1[1] = v5;
    }
  }
  else
  {
    std::vector<pbm::tlv::GroupId>::__append(a1, a2 - v4);
  }
}

void std::vector<pbm::tlv::GroupId>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (a2 <= (v6 - v7) >> 5)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 32 * a2);
      v7 += 32 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = v7 - *a1;
    v9 = a2 + (v8 >> 5);
    if (v9 >> 59)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 5;
    v11 = v5 - *a1;
    if (v11 >> 4 > v9)
      v9 = v11 >> 4;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFE0)
      v12 = 0x7FFFFFFFFFFFFFFLL;
    else
      v12 = v9;
    v18 = v4;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<vs::tlv::RemoteNumberListItem>>(v4, v12);
    else
      v13 = 0;
    v14 = v13;
    v15 = &v13[32 * v10];
    v17 = &v13[32 * v12];
    bzero(v15, 32 * a2);
    v16 = &v15[32 * a2];
    std::vector<pbm::tlv::GroupId>::__swap_out_circular_buffer(a1, &v14);
    std::__split_buffer<at::tlv::CommandCallback>::~__split_buffer((uint64_t)&v14);
  }
}

void sub_2168C090C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<at::tlv::CommandCallback>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<pbm::tlv::GroupId>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<pbm::tlv::GroupId>,std::reverse_iterator<pbm::tlv::GroupId*>,std::reverse_iterator<pbm::tlv::GroupId*>,std::reverse_iterator<pbm::tlv::GroupId*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<pbm::tlv::GroupId>,std::reverse_iterator<pbm::tlv::GroupId*>,std::reverse_iterator<pbm::tlv::GroupId*>,std::reverse_iterator<pbm::tlv::GroupId*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  __int16 v8;
  uint64_t v9;
  _QWORD v11[3];
  uint64_t v12;
  __int128 v13;
  __int128 v14;

  v7 = a7;
  *(_QWORD *)&v14 = a6;
  *((_QWORD *)&v14 + 1) = a7;
  v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  v12 = 0;
  if (a3 == a5)
  {
    v9 = a6;
  }
  else
  {
    do
    {
      v8 = *(_WORD *)(a3 - 32);
      a3 -= 32;
      *(_WORD *)(v7 - 32) = v8;
      *(_QWORD *)(v7 - 16) = 0;
      *(_QWORD *)(v7 - 8) = 0;
      *(_QWORD *)(v7 - 24) = 0;
      *(_OWORD *)(v7 - 24) = *(_OWORD *)(a3 + 8);
      *(_QWORD *)(v7 - 8) = *(_QWORD *)(a3 + 24);
      *(_QWORD *)(a3 + 8) = 0;
      *(_QWORD *)(a3 + 16) = 0;
      *(_QWORD *)(a3 + 24) = 0;
      v7 = *((_QWORD *)&v14 + 1) - 32;
      *((_QWORD *)&v14 + 1) -= 32;
    }
    while (a3 != a5);
    v9 = v14;
  }
  LOBYTE(v12) = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<pbm::tlv::GroupId>,std::reverse_iterator<pbm::tlv::GroupId*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v11);
  return v9;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<pbm::tlv::GroupId>,std::reverse_iterator<pbm::tlv::GroupId*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<at::tlv::CommandCallback>,std::reverse_iterator<at::tlv::CommandCallback*>>::operator()[abi:ne180100](a1);
  return a1;
}

void std::vector<pbm::tlv::EmailParams>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  BOOL v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  void *v10;

  v3 = a1[1];
  v4 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  v5 = a2 >= v4;
  v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    std::vector<pbm::tlv::EmailParams>::__append(a1, v6);
  }
  else if (!v5)
  {
    v7 = *a1 + 24 * a2;
    if (v3 != v7)
    {
      v8 = a1[1];
      do
      {
        v10 = *(void **)(v8 - 24);
        v8 -= 24;
        v9 = v10;
        if (v10)
        {
          *(_QWORD *)(v3 - 16) = v9;
          operator delete(v9);
        }
        v3 = v8;
      }
      while (v8 != v7);
    }
    a1[1] = v7;
  }
}

void std::vector<pbm::tlv::EmailParams>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  size_t v13;
  size_t v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - v7) >> 3) >= a2)
  {
    if (a2)
    {
      v13 = 24 * ((24 * a2 - 24) / 0x18) + 24;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = 0xAAAAAAAAAAAAAAABLL * ((v7 - *a1) >> 3);
    v9 = v8 + a2;
    if (v8 + a2 > 0xAAAAAAAAAAAAAAALL)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *a1) >> 3);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x555555555555555)
      v11 = 0xAAAAAAAAAAAAAAALL;
    else
      v11 = v9;
    v19 = v4;
    if (v11)
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>(v4, v11);
    else
      v12 = 0;
    v15 = v12;
    v16 = &v12[24 * v8];
    v18 = &v12[24 * v11];
    v14 = 24 * ((24 * a2 - 24) / 0x18) + 24;
    bzero(v16, v14);
    v17 = &v16[v14];
    std::vector<pbm::tlv::EmailParams>::__swap_out_circular_buffer(a1, &v15);
    std::__split_buffer<pbm::tlv::EmergencyNumber>::~__split_buffer((uint64_t)&v15);
  }
}

void sub_2168C0C54(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<pbm::tlv::EmergencyNumber>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<pbm::tlv::EmailParams>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<pbm::tlv::EmailParams>,std::reverse_iterator<pbm::tlv::EmailParams*>,std::reverse_iterator<pbm::tlv::EmailParams*>,std::reverse_iterator<pbm::tlv::EmailParams*>>((uint64_t)(a1 + 2), a1[1], (_QWORD *)a1[1], *a1, (_QWORD *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<pbm::tlv::EmailParams>,std::reverse_iterator<pbm::tlv::EmailParams*>,std::reverse_iterator<pbm::tlv::EmailParams*>,std::reverse_iterator<pbm::tlv::EmailParams*>>(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4, _QWORD *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  __int128 v8;
  uint64_t v9;
  _QWORD v11[3];
  uint64_t v12;
  __int128 v13;
  __int128 v14;

  v7 = a7;
  *(_QWORD *)&v14 = a6;
  *((_QWORD *)&v14 + 1) = a7;
  v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  v12 = 0;
  if (a3 == a5)
  {
    v9 = a6;
  }
  else
  {
    do
    {
      *(_QWORD *)(v7 - 24) = 0;
      *(_QWORD *)(v7 - 16) = 0;
      *(_QWORD *)(v7 - 8) = 0;
      v8 = *(_OWORD *)(a3 - 3);
      a3 -= 3;
      *(_OWORD *)(v7 - 24) = v8;
      *(_QWORD *)(v7 - 8) = a3[2];
      *a3 = 0;
      a3[1] = 0;
      a3[2] = 0;
      v7 = *((_QWORD *)&v14 + 1) - 24;
      *((_QWORD *)&v14 + 1) -= 24;
    }
    while (a3 != a5);
    v9 = v14;
  }
  LOBYTE(v12) = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<pbm::tlv::EmailParams>,std::reverse_iterator<pbm::tlv::EmailParams*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v11);
  return v9;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<pbm::tlv::EmailParams>,std::reverse_iterator<pbm::tlv::EmailParams*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<pbm::tlv::EmergencyNumber>,std::reverse_iterator<pbm::tlv::EmergencyNumber*>>::operator()[abi:ne180100](a1);
  return a1;
}

void std::vector<pbm::tlv::EmailId>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  void **v7;

  v3 = a1[1];
  v4 = (v3 - *a1) >> 5;
  if (a2 <= v4)
  {
    if (a2 < v4)
    {
      v5 = *a1 + 32 * a2;
      if (v3 != v5)
      {
        do
        {
          v6 = v3 - 32;
          v7 = (void **)(v3 - 24);
          std::vector<pbm::tlv::EmergencyNumber>::__destroy_vector::operator()[abi:ne180100](&v7);
          v3 = v6;
        }
        while (v6 != v5);
      }
      a1[1] = v5;
    }
  }
  else
  {
    std::vector<pbm::tlv::EmailId>::__append(a1, a2 - v4);
  }
}

void std::vector<pbm::tlv::EmailId>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  void *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (a2 <= (v6 - v7) >> 5)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 32 * a2);
      v7 += 32 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = v7 - *a1;
    v9 = a2 + (v8 >> 5);
    if (v9 >> 59)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 5;
    v11 = v5 - *a1;
    if (v11 >> 4 > v9)
      v9 = v11 >> 4;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFE0)
      v12 = 0x7FFFFFFFFFFFFFFLL;
    else
      v12 = v9;
    v18 = v4;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<vs::tlv::RemoteNumberListItem>>(v4, v12);
    else
      v13 = 0;
    v14 = v13;
    v15 = &v13[32 * v10];
    v17 = &v13[32 * v12];
    bzero(v15, 32 * a2);
    v16 = &v15[32 * a2];
    std::vector<pbm::tlv::EmailId>::__swap_out_circular_buffer(a1, &v14);
    std::__split_buffer<pbm::tlv::EmailId>::~__split_buffer(&v14);
  }
}

void sub_2168C0F30(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<pbm::tlv::EmailId>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<pbm::tlv::EmailId>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<pbm::tlv::EmailId>,std::reverse_iterator<pbm::tlv::EmailId*>,std::reverse_iterator<pbm::tlv::EmailId*>,std::reverse_iterator<pbm::tlv::EmailId*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<pbm::tlv::EmailId>,std::reverse_iterator<pbm::tlv::EmailId*>,std::reverse_iterator<pbm::tlv::EmailId*>,std::reverse_iterator<pbm::tlv::EmailId*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  __int16 v8;
  uint64_t v9;
  _QWORD v11[3];
  uint64_t v12;
  __int128 v13;
  __int128 v14;

  v7 = a7;
  *(_QWORD *)&v14 = a6;
  *((_QWORD *)&v14 + 1) = a7;
  v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  v12 = 0;
  if (a3 == a5)
  {
    v9 = a6;
  }
  else
  {
    do
    {
      v8 = *(_WORD *)(a3 - 32);
      a3 -= 32;
      *(_WORD *)(v7 - 32) = v8;
      *(_QWORD *)(v7 - 16) = 0;
      *(_QWORD *)(v7 - 8) = 0;
      *(_QWORD *)(v7 - 24) = 0;
      *(_OWORD *)(v7 - 24) = *(_OWORD *)(a3 + 8);
      *(_QWORD *)(v7 - 8) = *(_QWORD *)(a3 + 24);
      *(_QWORD *)(a3 + 8) = 0;
      *(_QWORD *)(a3 + 16) = 0;
      *(_QWORD *)(a3 + 24) = 0;
      v7 = *((_QWORD *)&v14 + 1) - 32;
      *((_QWORD *)&v14 + 1) -= 32;
    }
    while (a3 != a5);
    v9 = v14;
  }
  LOBYTE(v12) = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<pbm::tlv::EmailId>,std::reverse_iterator<pbm::tlv::EmailId*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v11);
  return v9;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<pbm::tlv::EmailId>,std::reverse_iterator<pbm::tlv::EmailId*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<pbm::tlv::EmailId>,std::reverse_iterator<pbm::tlv::EmailId*>>::operator()[abi:ne180100](a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<pbm::tlv::EmailId>,std::reverse_iterator<pbm::tlv::EmailId*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  void **v3;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8);
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    v3 = (void **)(v1 + 8);
    std::vector<pbm::tlv::EmergencyNumber>::__destroy_vector::operator()[abi:ne180100](&v3);
    v1 += 32;
  }
}

void **std::__split_buffer<pbm::tlv::EmailId>::~__split_buffer(void **a1)
{
  std::__split_buffer<pbm::tlv::EmailId>::clear[abi:ne180100]((uint64_t)a1);
  if (*a1)
    operator delete(*a1);
  return a1;
}

void std::__split_buffer<pbm::tlv::EmailId>::clear[abi:ne180100](uint64_t a1)
{
  uint64_t i;
  uint64_t v2;
  void **v4;

  v2 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v2; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 32;
    v4 = (void **)(i - 24);
    std::vector<pbm::tlv::EmergencyNumber>::__destroy_vector::operator()[abi:ne180100](&v4);
  }
}

void std::vector<pbm::tlv::HiddenRecord>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;

  v2 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 2;
  if (a2 <= v2)
  {
    if (a2 < v2)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 4 * a2;
  }
  else
  {
    std::vector<pbm::tlv::HiddenRecord>::__append((char **)a1, a2 - v2);
  }
}

void std::vector<pbm::tlv::HiddenRecord>::__append(char **a1, unint64_t a2)
{
  uint64_t v4;
  char *v5;
  char *v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  __int16 v19;
  char v20;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 2)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 4 * a2);
      v7 += 4 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = v7 - *a1;
    v9 = a2 + (v8 >> 2);
    if (v9 >> 62)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 2;
    v11 = v5 - *a1;
    if (v11 >> 1 > v9)
      v9 = v11 >> 1;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFFCLL)
      v12 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v12 = v9;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::array<unsigned char,4ul>>>(v4, v12);
    else
      v13 = 0;
    v14 = &v13[4 * v10];
    v15 = &v13[4 * v12];
    bzero(v14, 4 * a2);
    v16 = &v14[4 * a2];
    v18 = *a1;
    v17 = a1[1];
    if (v17 != *a1)
    {
      do
      {
        v19 = *((_WORD *)v17 - 2);
        v17 -= 4;
        v20 = v17[2];
        *((_WORD *)v14 - 2) = v19;
        v14 -= 4;
        v14[2] = v20;
      }
      while (v17 != v18);
      v17 = *a1;
    }
    *a1 = v14;
    a1[1] = v16;
    a1[2] = v15;
    if (v17)
      operator delete(v17);
  }
}

void std::vector<pbm::tlv::ECCEmergencyNumber>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  void **v7;

  v3 = a1[1];
  v4 = (v3 - *a1) >> 5;
  if (a2 <= v4)
  {
    if (a2 < v4)
    {
      v5 = *a1 + 32 * a2;
      if (v3 != v5)
      {
        do
        {
          v6 = v3 - 32;
          v7 = (void **)(v3 - 24);
          std::vector<at::tlv::CommandCallback>::__destroy_vector::operator()[abi:ne180100](&v7);
          v3 = v6;
        }
        while (v6 != v5);
      }
      a1[1] = v5;
    }
  }
  else
  {
    std::vector<pbm::tlv::ECCEmergencyNumber>::__append(a1, a2 - v4);
  }
}

void std::vector<pbm::tlv::ECCEmergencyNumber>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  void *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (a2 <= (v6 - v7) >> 5)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 32 * a2);
      v7 += 32 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = v7 - *a1;
    v9 = a2 + (v8 >> 5);
    if (v9 >> 59)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 5;
    v11 = v5 - *a1;
    if (v11 >> 4 > v9)
      v9 = v11 >> 4;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFE0)
      v12 = 0x7FFFFFFFFFFFFFFLL;
    else
      v12 = v9;
    v18 = v4;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<vs::tlv::RemoteNumberListItem>>(v4, v12);
    else
      v13 = 0;
    v14 = v13;
    v15 = &v13[32 * v10];
    v17 = &v13[32 * v12];
    bzero(v15, 32 * a2);
    v16 = &v15[32 * a2];
    std::vector<pbm::tlv::ECCEmergencyNumber>::__swap_out_circular_buffer(a1, &v14);
    std::__split_buffer<pbm::tlv::ECCEmergencyNumber>::~__split_buffer(&v14);
  }
}

void sub_2168C141C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<pbm::tlv::ECCEmergencyNumber>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<pbm::tlv::ECCEmergencyNumber>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<pbm::tlv::ECCEmergencyNumber>,std::reverse_iterator<pbm::tlv::ECCEmergencyNumber*>,std::reverse_iterator<pbm::tlv::ECCEmergencyNumber*>,std::reverse_iterator<pbm::tlv::ECCEmergencyNumber*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<pbm::tlv::ECCEmergencyNumber>,std::reverse_iterator<pbm::tlv::ECCEmergencyNumber*>,std::reverse_iterator<pbm::tlv::ECCEmergencyNumber*>,std::reverse_iterator<pbm::tlv::ECCEmergencyNumber*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  char v8;
  uint64_t v9;
  _QWORD v11[3];
  uint64_t v12;
  __int128 v13;
  __int128 v14;

  v7 = a7;
  *(_QWORD *)&v14 = a6;
  *((_QWORD *)&v14 + 1) = a7;
  v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  v12 = 0;
  if (a3 == a5)
  {
    v9 = a6;
  }
  else
  {
    do
    {
      v8 = *(_BYTE *)(a3 - 32);
      a3 -= 32;
      *(_BYTE *)(v7 - 32) = v8;
      *(_QWORD *)(v7 - 16) = 0;
      *(_QWORD *)(v7 - 8) = 0;
      *(_QWORD *)(v7 - 24) = 0;
      *(_OWORD *)(v7 - 24) = *(_OWORD *)(a3 + 8);
      *(_QWORD *)(v7 - 8) = *(_QWORD *)(a3 + 24);
      *(_QWORD *)(a3 + 8) = 0;
      *(_QWORD *)(a3 + 16) = 0;
      *(_QWORD *)(a3 + 24) = 0;
      v7 = *((_QWORD *)&v14 + 1) - 32;
      *((_QWORD *)&v14 + 1) -= 32;
    }
    while (a3 != a5);
    v9 = v14;
  }
  LOBYTE(v12) = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<pbm::tlv::ECCEmergencyNumber>,std::reverse_iterator<pbm::tlv::ECCEmergencyNumber*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v11);
  return v9;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<pbm::tlv::ECCEmergencyNumber>,std::reverse_iterator<pbm::tlv::ECCEmergencyNumber*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<pbm::tlv::ECCEmergencyNumber>,std::reverse_iterator<pbm::tlv::ECCEmergencyNumber*>>::operator()[abi:ne180100](a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<pbm::tlv::ECCEmergencyNumber>,std::reverse_iterator<pbm::tlv::ECCEmergencyNumber*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  void **v3;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8);
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    v3 = (void **)(v1 + 8);
    std::vector<at::tlv::CommandCallback>::__destroy_vector::operator()[abi:ne180100](&v3);
    v1 += 32;
  }
}

void **std::__split_buffer<pbm::tlv::ECCEmergencyNumber>::~__split_buffer(void **a1)
{
  std::__split_buffer<pbm::tlv::ECCEmergencyNumber>::clear[abi:ne180100]((uint64_t)a1);
  if (*a1)
    operator delete(*a1);
  return a1;
}

void std::__split_buffer<pbm::tlv::ECCEmergencyNumber>::clear[abi:ne180100](uint64_t a1)
{
  uint64_t i;
  uint64_t v2;
  void **v4;

  v2 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v2; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 32;
    v4 = (void **)(i - 24);
    std::vector<at::tlv::CommandCallback>::__destroy_vector::operator()[abi:ne180100](&v4);
  }
}

void std::vector<pbm::EmergencyCategory>::__append(uint64_t a1, size_t a2)
{
  uint64_t v4;
  char *v5;
  unint64_t v6;
  char *v7;
  unint64_t v8;
  unint64_t v9;
  size_t v10;
  void *v11;
  char *v12;
  char *v13;
  char *v14;
  char v15;

  v5 = *(char **)(a1 + 8);
  v4 = *(_QWORD *)(a1 + 16);
  if (v4 - (uint64_t)v5 >= a2)
  {
    if (a2)
    {
      bzero(*(void **)(a1 + 8), a2);
      v5 += a2;
    }
    *(_QWORD *)(a1 + 8) = v5;
  }
  else
  {
    v6 = *(_QWORD *)a1;
    v7 = &v5[-*(_QWORD *)a1];
    v8 = (unint64_t)&v7[a2];
    if ((uint64_t)&v7[a2] < 0)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v9 = v4 - v6;
    if (2 * v9 > v8)
      v8 = 2 * v9;
    if (v9 >= 0x3FFFFFFFFFFFFFFFLL)
      v10 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v10 = v8;
    if (v10)
      v11 = operator new(v10);
    else
      v11 = 0;
    v12 = &v7[(_QWORD)v11];
    v13 = (char *)v11 + v10;
    bzero(v12, a2);
    if (v5 == (char *)v6)
    {
      v11 = v12;
    }
    else
    {
      v14 = &v5[~v6];
      do
      {
        v15 = *--v5;
        (v14--)[(_QWORD)v11] = v15;
      }
      while (v5 != (char *)v6);
    }
    *(_QWORD *)a1 = v11;
    *(_QWORD *)(a1 + 8) = &v12[a2];
    *(_QWORD *)(a1 + 16) = v13;
    if (v6)
      operator delete((void *)v6);
  }
}

void std::vector<pbm::tlv::LocalEmergencyNumber>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  void **v7;

  v3 = a1[1];
  v4 = (v3 - *a1) >> 5;
  if (a2 <= v4)
  {
    if (a2 < v4)
    {
      v5 = *a1 + 32 * a2;
      if (v3 != v5)
      {
        do
        {
          v6 = v3 - 32;
          v7 = (void **)(v3 - 24);
          std::vector<pbm::tlv::EmergencySubServiceNumber>::__destroy_vector::operator()[abi:ne180100](&v7);
          v3 = v6;
        }
        while (v6 != v5);
      }
      a1[1] = v5;
    }
  }
  else
  {
    std::vector<pbm::tlv::LocalEmergencyNumber>::__append(a1, a2 - v4);
  }
}

void std::vector<pbm::tlv::LocalEmergencyNumber>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  void *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (a2 <= (v6 - v7) >> 5)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 32 * a2);
      v7 += 32 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = v7 - *a1;
    v9 = a2 + (v8 >> 5);
    if (v9 >> 59)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 5;
    v11 = v5 - *a1;
    if (v11 >> 4 > v9)
      v9 = v11 >> 4;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFE0)
      v12 = 0x7FFFFFFFFFFFFFFLL;
    else
      v12 = v9;
    v18 = v4;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<vs::tlv::RemoteNumberListItem>>(v4, v12);
    else
      v13 = 0;
    v14 = v13;
    v15 = &v13[32 * v10];
    v17 = &v13[32 * v12];
    bzero(v15, 32 * a2);
    v16 = &v15[32 * a2];
    std::vector<pbm::tlv::LocalEmergencyNumber>::__swap_out_circular_buffer(a1, &v14);
    std::__split_buffer<pbm::tlv::LocalEmergencyNumber>::~__split_buffer(&v14);
  }
}

void sub_2168C18F4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<pbm::tlv::LocalEmergencyNumber>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<pbm::tlv::LocalEmergencyNumber>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<pbm::tlv::LocalEmergencyNumber>,std::reverse_iterator<pbm::tlv::LocalEmergencyNumber*>,std::reverse_iterator<pbm::tlv::LocalEmergencyNumber*>,std::reverse_iterator<pbm::tlv::LocalEmergencyNumber*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<pbm::tlv::LocalEmergencyNumber>,std::reverse_iterator<pbm::tlv::LocalEmergencyNumber*>,std::reverse_iterator<pbm::tlv::LocalEmergencyNumber*>,std::reverse_iterator<pbm::tlv::LocalEmergencyNumber*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  char v8;
  uint64_t v9;
  _QWORD v11[3];
  uint64_t v12;
  __int128 v13;
  __int128 v14;

  v7 = a7;
  *(_QWORD *)&v14 = a6;
  *((_QWORD *)&v14 + 1) = a7;
  v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  v12 = 0;
  if (a3 == a5)
  {
    v9 = a6;
  }
  else
  {
    do
    {
      v8 = *(_BYTE *)(a3 - 32);
      a3 -= 32;
      *(_BYTE *)(v7 - 32) = v8;
      *(_QWORD *)(v7 - 16) = 0;
      *(_QWORD *)(v7 - 8) = 0;
      *(_QWORD *)(v7 - 24) = 0;
      *(_OWORD *)(v7 - 24) = *(_OWORD *)(a3 + 8);
      *(_QWORD *)(v7 - 8) = *(_QWORD *)(a3 + 24);
      *(_QWORD *)(a3 + 8) = 0;
      *(_QWORD *)(a3 + 16) = 0;
      *(_QWORD *)(a3 + 24) = 0;
      v7 = *((_QWORD *)&v14 + 1) - 32;
      *((_QWORD *)&v14 + 1) -= 32;
    }
    while (a3 != a5);
    v9 = v14;
  }
  LOBYTE(v12) = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<pbm::tlv::LocalEmergencyNumber>,std::reverse_iterator<pbm::tlv::LocalEmergencyNumber*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v11);
  return v9;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<pbm::tlv::LocalEmergencyNumber>,std::reverse_iterator<pbm::tlv::LocalEmergencyNumber*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<pbm::tlv::LocalEmergencyNumber>,std::reverse_iterator<pbm::tlv::LocalEmergencyNumber*>>::operator()[abi:ne180100](a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<pbm::tlv::LocalEmergencyNumber>,std::reverse_iterator<pbm::tlv::LocalEmergencyNumber*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  void **v3;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8);
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    v3 = (void **)(v1 + 8);
    std::vector<pbm::tlv::EmergencySubServiceNumber>::__destroy_vector::operator()[abi:ne180100](&v3);
    v1 += 32;
  }
}

void **std::__split_buffer<pbm::tlv::LocalEmergencyNumber>::~__split_buffer(void **a1)
{
  std::__split_buffer<pbm::tlv::LocalEmergencyNumber>::clear[abi:ne180100]((uint64_t)a1);
  if (*a1)
    operator delete(*a1);
  return a1;
}

void std::__split_buffer<pbm::tlv::LocalEmergencyNumber>::clear[abi:ne180100](uint64_t a1)
{
  uint64_t i;
  uint64_t v2;
  void **v4;

  v2 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v2; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 32;
    v4 = (void **)(i - 24);
    std::vector<pbm::tlv::EmergencySubServiceNumber>::__destroy_vector::operator()[abi:ne180100](&v4);
  }
}

unsigned __int8 *uim::tlv::parseField(unsigned __int8 *a1, const unsigned __int8 *a2, uint64_t a3)
{
  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  *(_DWORD *)a3 = *a1;
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 1), a2, 1uLL);
  *(_DWORD *)(a3 + 4) = a1[1];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 2), a2, 1uLL);
  *(_BYTE *)(a3 + 8) = a1[2];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 3), a2, 1uLL);
  *(_BYTE *)(a3 + 9) = a1[3];
  return a1 + 4;
}

{
  unsigned __int8 *v6;
  unsigned int v7;
  unint64_t v8;
  unsigned __int8 *v9;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  *(_DWORD *)a3 = *a1;
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 1), a2, 1uLL);
  *(_DWORD *)(a3 + 4) = a1[1];
  v6 = uim::tlv::parseField(a1 + 2, a2, a3 + 8);
  tlv::throwIfNotEnoughBytes((unint64_t)v6, a2, 1uLL);
  v7 = *v6++;
  tlv::throwIfNotEnoughBytes((unint64_t)v6, a2, v7);
  v8 = (unint64_t)&v6[v7];
  std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((_QWORD *)(a3 + 24), (char *)v6, (char *)v8, v7);
  tlv::throwIfNotEnoughBytes(v8, a2, 1uLL);
  *(_BYTE *)(a3 + 48) = *(_BYTE *)v8;
  v9 = cat::tlv::parseField((unsigned __int8 *)(v8 + 1), a2, a3 + 52);
  return cat::tlv::parseField(v9, a2, a3 + 60);
}

{
  unsigned __int8 *v6;
  unint64_t v7;
  unsigned __int8 *v8;
  uint64_t v9;
  uint64_t v10;
  unsigned __int8 *result;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  *(_DWORD *)a3 = *a1;
  v6 = cat::tlv::parseField(a1 + 1, a2, a3 + 4);
  tlv::throwIfNotEnoughBytes((unint64_t)v6, a2, 1uLL);
  *(_BYTE *)(a3 + 12) = *v6;
  tlv::throwIfNotEnoughBytes((unint64_t)(v6 + 1), a2, 1uLL);
  v7 = v6[1];
  v8 = v6 + 2;
  std::vector<uim::tlv::App>::resize((uint64_t *)(a3 + 16), v7);
  v9 = *(_QWORD *)(a3 + 16);
  v10 = *(_QWORD *)(a3 + 24);
  while (1)
  {
    result = v8;
    if (v9 == v10)
      break;
    v8 = uim::tlv::parseField(v8, a2, v9);
    v9 += 72;
  }
  return result;
}

uint64_t tlv::parseV<uim::tlv::RetriesLeft>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  const unsigned __int8 *v4;
  int v5;
  int v6;

  v3 = (unsigned __int8 *)*a1;
  v4 = (const unsigned __int8 *)(*a1 + a2);
  tlv::throwIfNotEnoughBytes(*a1, v4, 1uLL);
  v5 = *v3;
  tlv::throwIfNotEnoughBytes((unint64_t)(v3 + 1), v4, 1uLL);
  v6 = v3[1];
  *a1 = (unint64_t)(v3 + 2);
  return v5 | (v6 << 8);
}

void sub_2168C1D9C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C1D88);
}

char *uim::tlv::parseField(unint64_t a1, const unsigned __int8 *a2, uint64_t a3)
{
  unint64_t v6;
  char *v7;
  unint64_t v8;
  unint64_t v9;
  std::logic_error *exception;

  tlv::throwIfNotEnoughBytes(a1, a2, 2uLL);
  *(_WORD *)a3 = *(_WORD *)a1;
  tlv::throwIfNotEnoughBytes(a1 + 2, a2, 1uLL);
  v6 = *(unsigned __int8 *)(a1 + 2);
  if ((v6 & 1) != 0)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::length_error::length_error[abi:ne180100](exception, "Invalid length value");
    __cxa_throw(exception, (struct type_info *)off_24D5C2108, MEMORY[0x24BEDAAF0]);
  }
  v7 = (char *)(a1 + 3);
  v8 = v6 >> 1;
  v9 = 2 * (v6 >> 1);
  tlv::throwIfNotEnoughBytes((unint64_t)v7, a2, v9);
  std::vector<unsigned short>::resize(a3 + 8, v8);
  memcpy(*(void **)(a3 + 8), v7, v9);
  return &v7[2 * v8];
}

void sub_2168C1E7C(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void *tlv::writeV<uim::tlv::FileId>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  const void *v5;
  uint64_t v6;
  size_t v7;
  void *result;

  v3 = *a1;
  *(_WORD *)v3 = *(_WORD *)a2;
  v4 = v3 + 3;
  *(_BYTE *)(v3 + 2) = (*(_DWORD *)(a2 + 16) - *(_DWORD *)(a2 + 8)) & 0xFE;
  v6 = a2 + 8;
  v5 = *(const void **)(a2 + 8);
  v7 = *(_QWORD *)(v6 + 8) - (_QWORD)v5;
  result = memcpy((void *)(v3 + 3), v5, v7);
  *a1 = v4 + v7;
  return result;
}

uint64_t tlv::parseV<uim::tlv::CardResult>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  const unsigned __int8 *v4;
  int v5;
  int v6;

  v3 = (unsigned __int8 *)*a1;
  v4 = (const unsigned __int8 *)(*a1 + a2);
  tlv::throwIfNotEnoughBytes(*a1, v4, 1uLL);
  v5 = *v3;
  tlv::throwIfNotEnoughBytes((unint64_t)(v3 + 1), v4, 1uLL);
  v6 = v3[1];
  *a1 = (unint64_t)(v3 + 2);
  return v5 | (v6 << 8);
}

void sub_2168C1F58(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C1F44);
}

char *tlv::parseV<uim::tlv::ReadResult>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  char *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = p2p::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), a3);
  *a1 = (unint64_t)result;
  return result;
}

void sub_2168C1FA8(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C1F9CLL);
}

void sub_2168C1FB8(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

unsigned __int8 *uim::tlv::parseField(_BYTE *a1, const unsigned __int8 *a2, uint64_t a3)
{
  unint64_t v6;
  unsigned __int8 *v7;
  uint64_t v8;
  uint64_t v9;
  unsigned __int8 *result;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  *(_BYTE *)a3 = *a1;
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 1), a2, 1uLL);
  *(_BYTE *)(a3 + 1) = a1[1];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 2), a2, 1uLL);
  *(_BYTE *)(a3 + 2) = a1[2];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 3), a2, 1uLL);
  *(_BYTE *)(a3 + 3) = a1[3];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 4), a2, 1uLL);
  *(_BYTE *)(a3 + 4) = a1[4];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 5), a2, 1uLL);
  *(_BYTE *)(a3 + 5) = a1[5];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 6), a2, 1uLL);
  *(_BYTE *)(a3 + 6) = a1[6];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 7), a2, 1uLL);
  *(_BYTE *)(a3 + 7) = a1[7];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 8), a2, 1uLL);
  v6 = a1[8];
  v7 = a1 + 9;
  std::vector<uim::tlv::Slot>::resize((uint64_t *)(a3 + 8), v6);
  v9 = *(_QWORD *)(a3 + 8);
  v8 = *(_QWORD *)(a3 + 16);
  while (1)
  {
    result = v7;
    if (v9 == v8)
      break;
    v7 = uim::tlv::parseField(v7, a2, v9);
    v9 += 40;
  }
  return result;
}

unsigned __int8 *tlv::parseV<uim::tlv::CardStatus>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  unsigned __int8 *result;

  *a3 = 0u;
  a3[1] = 0u;
  result = uim::tlv::parseField(*a1, &(*a1)[a2], (uint64_t)a3);
  *a1 = result;
  return result;
}

void sub_2168C2144(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C2134);
}

void sub_2168C2154(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  uint64_t v10;

  a10 = (void **)(v10 + 8);
  std::vector<uim::tlv::Slot>::__destroy_vector::operator()[abi:ne180100](&a10);
  _Unwind_Resume(a1);
}

unsigned __int8 *uim::tlv::parseField(uim::tlv *this, const unsigned __int8 *a2, const unsigned __int8 *a3, uim::tlv::ExtendedCardStatus *a4)
{
  _BYTE *v7;
  unsigned int v8;
  _BYTE *v9;
  _BYTE *v10;
  unsigned __int8 *v11;
  unsigned int v12;
  _BYTE *v13;
  _BYTE *v14;
  unsigned __int8 *v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  unsigned __int8 *result;

  tlv::throwIfNotEnoughBytes((unint64_t)this, a2, 1uLL);
  v8 = *(unsigned __int8 *)this;
  v7 = (char *)this + 1;
  std::vector<vs::tlv::IsHandoverCallItem>::resize((uint64_t)a3, v8);
  v9 = *(_BYTE **)a3;
  v10 = (_BYTE *)*((_QWORD *)a3 + 1);
  while (v9 != v10)
  {
    tlv::throwIfNotEnoughBytes((unint64_t)v7, a2, 1uLL);
    *v9 = *v7;
    tlv::throwIfNotEnoughBytes((unint64_t)(v7 + 1), a2, 1uLL);
    v9[1] = v7[1];
    v7 += 2;
    v9 += 2;
  }
  tlv::throwIfNotEnoughBytes((unint64_t)v7, a2, 1uLL);
  v12 = *v7;
  v11 = v7 + 1;
  std::vector<vs::tlv::IsHandoverCallItem>::resize((uint64_t)(a3 + 24), v12);
  v13 = (_BYTE *)*((_QWORD *)a3 + 3);
  v14 = (_BYTE *)*((_QWORD *)a3 + 4);
  while (v13 != v14)
  {
    tlv::throwIfNotEnoughBytes((unint64_t)v11, a2, 1uLL);
    *v13 = *v11;
    tlv::throwIfNotEnoughBytes((unint64_t)(v11 + 1), a2, 1uLL);
    v13[1] = v11[1];
    v11 += 2;
    v13 += 2;
  }
  tlv::throwIfNotEnoughBytes((unint64_t)v11, a2, 1uLL);
  v16 = *v11;
  v15 = v11 + 1;
  std::vector<uim::tlv::Slot>::resize((uint64_t *)a3 + 6, v16);
  v18 = *((_QWORD *)a3 + 6);
  v17 = *((_QWORD *)a3 + 7);
  while (1)
  {
    result = v15;
    if (v18 == v17)
      break;
    v15 = uim::tlv::parseField(v15, a2, v18);
    v18 += 40;
  }
  return result;
}

unsigned __int8 *tlv::parseV<uim::tlv::ExtendedCardStatus>@<X0>(uim::tlv **a1@<X0>, int a2@<W1>, uim::tlv::ExtendedCardStatus *a3@<X3>, uint64_t a4@<X8>)
{
  unsigned __int8 *result;

  *(_QWORD *)(a4 + 64) = 0;
  *(_OWORD *)(a4 + 32) = 0u;
  *(_OWORD *)(a4 + 48) = 0u;
  *(_OWORD *)a4 = 0u;
  *(_OWORD *)(a4 + 16) = 0u;
  result = uim::tlv::parseField(*a1, (const unsigned __int8 *)*a1 + a2, (const unsigned __int8 *)a4, a3);
  *a1 = (uim::tlv *)result;
  return result;
}

void sub_2168C22D4(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C22C8);
}

void sub_2168C22E4(_Unwind_Exception *a1)
{
  uim::tlv::ExtendedCardStatus *v1;

  uim::tlv::ExtendedCardStatus::~ExtendedCardStatus(v1);
  _Unwind_Resume(a1);
}

void uim::tlv::ExtendedCardStatus::~ExtendedCardStatus(uim::tlv::ExtendedCardStatus *this)
{
  void *v2;
  void *v3;
  void **v4;

  v4 = (void **)((char *)this + 48);
  std::vector<uim::tlv::Slot>::__destroy_vector::operator()[abi:ne180100](&v4);
  v2 = (void *)*((_QWORD *)this + 3);
  if (v2)
  {
    *((_QWORD *)this + 4) = v2;
    operator delete(v2);
  }
  v3 = *(void **)this;
  if (*(_QWORD *)this)
  {
    *((_QWORD *)this + 1) = v3;
    operator delete(v3);
  }
}

char *uim::tlv::parseField(unint64_t a1, const unsigned __int8 *a2, _QWORD *a3)
{
  char *v5;
  unsigned int v6;
  char *v7;
  unsigned int v8;
  char *v9;
  unsigned int v10;

  v5 = (char *)a1;
  tlv::throwIfNotEnoughBytes(a1, a2, 1uLL);
  v6 = *v5++;
  tlv::throwIfNotEnoughBytes((unint64_t)v5, a2, v6);
  v7 = &v5[v6];
  std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(a3, v5, v7, v6);
  tlv::throwIfNotEnoughBytes((unint64_t)v7, a2, 1uLL);
  v8 = *v7++;
  tlv::throwIfNotEnoughBytes((unint64_t)v7, a2, v8);
  v9 = &v7[v8];
  std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(a3 + 3, v7, v9, v8);
  tlv::throwIfNotEnoughBytes((unint64_t)v9, a2, 1uLL);
  v10 = *v9++;
  tlv::throwIfNotEnoughBytes((unint64_t)v9, a2, v10);
  std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(a3 + 6, v9, &v9[v10], v10);
  return &v9[v10];
}

char *uim::tlv::parseField(unsigned __int8 *a1, const unsigned __int8 *a2, uint64_t *a3)
{
  char *v6;
  unsigned int v7;
  _QWORD *v8;
  _QWORD *v9;
  char *result;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  v7 = *a1;
  v6 = (char *)(a1 + 1);
  std::vector<uim::tlv::ExtendedCardInfo>::resize(a3, v7);
  v8 = (_QWORD *)*a3;
  v9 = (_QWORD *)a3[1];
  while (1)
  {
    result = v6;
    if (v8 == v9)
      break;
    v6 = uim::tlv::parseField((unint64_t)v6, a2, v8);
    v8 += 9;
  }
  return result;
}

char *tlv::parseV<uim::tlv::ExtendedCardInfoList>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  char *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = uim::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = (unsigned __int8 *)result;
  return result;
}

void sub_2168C24E8(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C24D8);
}

void sub_2168C24F8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::vector<uim::tlv::ExtendedCardInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

BOOL tlv::parseV<uim::tlv::VinylSupportLegacy>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  _BOOL8 result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3 != 0;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168C2550(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C2544);
}

_QWORD *tlv::parseV<uim::tlv::VinylSupport>@<X0>(char **a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  char *v4;
  _QWORD *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  v4 = &(*a1)[a2];
  result = std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(a3, *a1, v4, a2);
  *a1 = v4;
  return result;
}

void sub_2168C25B4(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C25A4);
}

void sub_2168C25C4(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

unsigned __int8 *uim::tlv::parseField(tlv *this, unsigned __int8 *a2, unint64_t *a3)
{
  unsigned __int8 *v3;
  unint64_t v6;
  _BYTE *v7;
  _BYTE *v8;
  unint64_t v9;
  _BYTE *v10;
  unint64_t v11;
  unint64_t v12;
  size_t v13;
  char *v14;
  char *v15;
  _BYTE *v16;
  _BYTE *v17;
  char v18;
  char v19;

  v3 = (unsigned __int8 *)this;
  if (this < (tlv *)a2)
  {
    do
    {
      v7 = (_BYTE *)a3[1];
      v6 = a3[2];
      if ((unint64_t)v7 >= v6)
      {
        v9 = *a3;
        v10 = &v7[-*a3];
        v11 = (unint64_t)(v10 + 1);
        if ((uint64_t)(v10 + 1) < 0)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v12 = v6 - v9;
        if (2 * v12 > v11)
          v11 = 2 * v12;
        if (v12 >= 0x3FFFFFFFFFFFFFFFLL)
          v13 = 0x7FFFFFFFFFFFFFFFLL;
        else
          v13 = v11;
        if (v13)
          v14 = (char *)operator new(v13);
        else
          v14 = 0;
        v15 = &v10[(_QWORD)v14];
        v16 = &v10[(_QWORD)v14];
        *v16 = 0;
        v8 = v16 + 1;
        if (v7 != (_BYTE *)v9)
        {
          v17 = &v7[~v9];
          do
          {
            v18 = *--v7;
            (v17--)[(_QWORD)v14] = v18;
          }
          while (v7 != (_BYTE *)v9);
          v15 = v14;
        }
        *a3 = (unint64_t)v15;
        a3[1] = (unint64_t)v8;
        a3[2] = (unint64_t)&v14[v13];
        if (v9)
          operator delete((void *)v9);
      }
      else
      {
        *v7 = 0;
        v8 = v7 + 1;
      }
      a3[1] = (unint64_t)v8;
      tlv::throwIfNotEnoughBytes((unint64_t)v3, a2, 1uLL);
      v19 = *v3++;
      *(v8 - 1) = v19;
    }
    while (v3 != a2);
    return a2;
  }
  return v3;
}

unsigned __int8 *tlv::parseV<uim::tlv::HardwareSlotTypes>@<X0>(tlv **a1@<X0>, int a2@<W1>, unint64_t *a3@<X8>)
{
  unsigned __int8 *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = uim::tlv::parseField(*a1, (unsigned __int8 *)*a1 + a2, a3);
  *a1 = (tlv *)result;
  return result;
}

void sub_2168C2744(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C2738);
}

void sub_2168C2754(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t tlv::parseV<uim::tlv::LChannelId>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168C27A8(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C279CLL);
}

char *tlv::parseV<uim::tlv::APDU>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  char *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = p2p::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), a3);
  *a1 = (unint64_t)result;
  return result;
}

void sub_2168C27F8(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C27ECLL);
}

void sub_2168C2808(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *tlv::parseV<uim::tlv::IsMomentaryPowerDown>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  char *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = wds::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), a3);
  *a1 = (unint64_t)result;
  return result;
}

void sub_2168C2860(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C2854);
}

void sub_2168C2870(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

tlv *tlv::parseUnboundedSequence<uim::tlv::IccidSlotInfo>(tlv *this, unsigned __int8 *a2, char **a3)
{
  tlv *v3;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;
  int v20;
  uint64_t v21;

  v3 = this;
  if (this < (tlv *)a2)
  {
    v6 = (uint64_t)(a3 + 2);
    do
    {
      v7 = (unint64_t)a3[1];
      v8 = (unint64_t)a3[2];
      if (v7 >= v8)
      {
        v10 = 0x2E8BA2E8BA2E8BA3 * (v7 - (_QWORD)*a3);
        v11 = v10 + 1;
        if ((unint64_t)(v10 + 1) > 0x1745D1745D1745D1)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v12 = 0x2E8BA2E8BA2E8BA3 * (v8 - (_QWORD)*a3);
        if (2 * v12 > v11)
          v11 = 2 * v12;
        if (v12 >= 0xBA2E8BA2E8BA2E8)
          v13 = 0x1745D1745D1745D1;
        else
          v13 = v11;
        if (v13)
          v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<uim::tlv::IccidSlotInfo>>(v6, v13);
        else
          v14 = 0;
        v15 = &v14[11 * v10];
        *(_DWORD *)(v15 + 7) = 0;
        *(_QWORD *)v15 = 0;
        v17 = *a3;
        v16 = a3[1];
        v18 = v15;
        if (v16 != *a3)
        {
          do
          {
            v19 = *(_QWORD *)(v16 - 11);
            v16 -= 11;
            v20 = *(_DWORD *)(v16 + 7);
            *(_QWORD *)(v18 - 11) = v19;
            v18 -= 11;
            *(_DWORD *)(v18 + 7) = v20;
          }
          while (v16 != v17);
          v16 = *a3;
        }
        v9 = v15 + 11;
        *a3 = v18;
        a3[1] = v15 + 11;
        a3[2] = &v14[11 * v13];
        if (v16)
          operator delete(v16);
      }
      else
      {
        *(_DWORD *)(v7 + 7) = 0;
        *(_QWORD *)v7 = 0;
        v9 = (char *)(v7 + 11);
      }
      a3[1] = v9;
      tlv::throwIfNotEnoughBytes((unint64_t)v3, a2, 1uLL);
      *(v9 - 11) = *(_BYTE *)v3;
      tlv::throwIfNotEnoughBytes((unint64_t)v3 + 1, a2, 0xAuLL);
      v21 = *(_QWORD *)((char *)v3 + 1);
      *((_WORD *)v9 - 1) = *(_WORD *)((char *)v3 + 9);
      *(_QWORD *)(v9 - 10) = v21;
      v3 = (tlv *)((char *)v3 + 11);
    }
    while (v3 < (tlv *)a2);
  }
  return v3;
}

tlv *tlv::parseV<uim::tlv::Iccids>@<X0>(tlv **a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  tlv *result;

  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  result = tlv::parseUnboundedSequence<uim::tlv::IccidSlotInfo>(*a1, (unsigned __int8 *)*a1 + a2, (char **)a3);
  *a1 = result;
  return result;
}

void sub_2168C2A58(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C2A4CLL);
}

void sub_2168C2A68(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t tlv::size<uim::tlv::WriteTransparent>(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8) + 7;
}

void *tlv::writeV<uim::tlv::WriteTransparent>(_WORD **a1, uint64_t a2)
{
  _WORD *v4;
  _WORD *v5;
  void *result;

  v4 = *a1;
  *v4 = *(_WORD *)a2;
  v4[1] = *(_WORD *)(a2 + 16) - *(_DWORD *)(a2 + 8);
  v5 = v4 + 2;
  result = memcpy(v4 + 2, *(const void **)(a2 + 8), *(_QWORD *)(a2 + 16) - *(_QWORD *)(a2 + 8));
  *a1 = (_WORD *)((char *)v5 + *(_QWORD *)(a2 + 16) - *(_QWORD *)(a2 + 8));
  return result;
}

unint64_t uim::tlv::parseField(unint64_t a1, const unsigned __int8 *a2, uint64_t a3)
{
  unint64_t v5;
  unint64_t v6;

  v5 = a1;
  tlv::throwIfNotEnoughBytes(a1, a2, 2uLL);
  *(_WORD *)a3 = *(_WORD *)v5;
  tlv::throwIfNotEnoughBytes(v5 + 2, a2, 2uLL);
  *(_WORD *)(a3 + 2) = *(_WORD *)(v5 + 2);
  tlv::throwIfNotEnoughBytes(v5 + 4, a2, 1uLL);
  *(_DWORD *)(a3 + 4) = *(unsigned __int8 *)(v5 + 4);
  tlv::throwIfNotEnoughBytes(v5 + 5, a2, 2uLL);
  *(_WORD *)(a3 + 8) = *(_WORD *)(v5 + 5);
  tlv::throwIfNotEnoughBytes(v5 + 7, a2, 2uLL);
  *(_WORD *)(a3 + 10) = *(_WORD *)(v5 + 7);
  tlv::throwIfNotEnoughBytes(v5 + 9, a2, 1uLL);
  *(_DWORD *)(a3 + 12) = *(unsigned __int8 *)(v5 + 9);
  tlv::throwIfNotEnoughBytes(v5 + 10, a2, 2uLL);
  *(_DWORD *)(a3 + 16) = *(unsigned __int16 *)(v5 + 10);
  tlv::throwIfNotEnoughBytes(v5 + 12, a2, 1uLL);
  *(_DWORD *)(a3 + 20) = *(unsigned __int8 *)(v5 + 12);
  tlv::throwIfNotEnoughBytes(v5 + 13, a2, 2uLL);
  *(_DWORD *)(a3 + 24) = *(unsigned __int16 *)(v5 + 13);
  tlv::throwIfNotEnoughBytes(v5 + 15, a2, 1uLL);
  *(_DWORD *)(a3 + 28) = *(unsigned __int8 *)(v5 + 15);
  tlv::throwIfNotEnoughBytes(v5 + 16, a2, 2uLL);
  *(_DWORD *)(a3 + 32) = *(unsigned __int16 *)(v5 + 16);
  tlv::throwIfNotEnoughBytes(v5 + 18, a2, 1uLL);
  *(_DWORD *)(a3 + 36) = *(unsigned __int8 *)(v5 + 18);
  tlv::throwIfNotEnoughBytes(v5 + 19, a2, 2uLL);
  *(_DWORD *)(a3 + 40) = *(unsigned __int16 *)(v5 + 19);
  tlv::throwIfNotEnoughBytes(v5 + 21, a2, 1uLL);
  *(_DWORD *)(a3 + 44) = *(unsigned __int8 *)(v5 + 21);
  tlv::throwIfNotEnoughBytes(v5 + 22, a2, 2uLL);
  *(_DWORD *)(a3 + 48) = *(unsigned __int16 *)(v5 + 22);
  tlv::throwIfNotEnoughBytes(v5 + 24, a2, 2uLL);
  v6 = *(unsigned __int16 *)(v5 + 24);
  v5 += 26;
  tlv::throwIfNotEnoughBytes(v5, a2, v6);
  std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((_QWORD *)(a3 + 56), (char *)v5, (char *)(v5 + v6), v6);
  return v5 + v6;
}

unint64_t tlv::parseV<uim::tlv::FileAttributes>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  unint64_t result;

  a3[3] = 0u;
  a3[4] = 0u;
  a3[1] = 0u;
  a3[2] = 0u;
  *a3 = 0u;
  result = uim::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), (uint64_t)a3);
  *a1 = result;
  return result;
}

void sub_2168C2D18(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C2D0CLL);
}

void sub_2168C2D28(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)(v1 + 56);
  if (v3)
  {
    *(_QWORD *)(v1 + 64) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *tlv::writeV<uim::tlv::SetPinProtection>(_BYTE **a1, uint64_t a2)
{
  _BYTE *v4;
  uint64_t v5;
  char *v6;
  size_t v7;
  size_t v8;
  const void *v9;
  size_t v10;
  void *result;
  uint64_t v12;

  v4 = *a1;
  *v4 = *(_DWORD *)a2;
  v4[1] = *(_BYTE *)(a2 + 4);
  LOBYTE(v5) = *(_BYTE *)(a2 + 31);
  if ((v5 & 0x80u) != 0)
    v5 = *(_QWORD *)(a2 + 16);
  v6 = v4 + 3;
  v4[2] = v5;
  v7 = *(unsigned __int8 *)(a2 + 31);
  v8 = *(_QWORD *)(a2 + 16);
  if ((v7 & 0x80u) == 0)
    v9 = (const void *)(a2 + 8);
  else
    v9 = *(const void **)(a2 + 8);
  if ((v7 & 0x80u) == 0)
    v10 = v7;
  else
    v10 = v8;
  result = memcpy(v6, v9, v10);
  v12 = *(unsigned __int8 *)(a2 + 31);
  if ((v12 & 0x80u) != 0)
    v12 = *(_QWORD *)(a2 + 16);
  *a1 = &v6[v12];
  return result;
}

void *tlv::writeV<uim::tlv::VerifyPin>(_QWORD *a1, uint64_t a2)
{
  _BYTE *v4;
  uint64_t v5;
  char *v6;
  size_t v7;
  size_t v8;
  const void *v9;
  size_t v10;
  void *result;
  uint64_t v12;

  v4 = (_BYTE *)*a1;
  *(_BYTE *)*a1 = *(_DWORD *)a2;
  LOBYTE(v5) = *(_BYTE *)(a2 + 31);
  if ((v5 & 0x80u) != 0)
    v5 = *(_QWORD *)(a2 + 16);
  v6 = v4 + 2;
  v4[1] = v5;
  v7 = *(unsigned __int8 *)(a2 + 31);
  v8 = *(_QWORD *)(a2 + 16);
  if ((v7 & 0x80u) == 0)
    v9 = (const void *)(a2 + 8);
  else
    v9 = *(const void **)(a2 + 8);
  if ((v7 & 0x80u) == 0)
    v10 = v7;
  else
    v10 = v8;
  result = memcpy(v6, v9, v10);
  v12 = *(unsigned __int8 *)(a2 + 31);
  if ((v12 & 0x80u) != 0)
    v12 = *(_QWORD *)(a2 + 16);
  *a1 = &v6[v12];
  return result;
}

char *uim::tlv::writeField(_BYTE *a1, uint64_t a2)
{
  uint64_t v3;
  _BYTE *v4;
  size_t v5;
  size_t v6;
  const void *v7;
  size_t v8;
  uint64_t v9;
  _BYTE *v10;
  char *v11;
  int v12;
  const void *v13;
  size_t v14;
  uint64_t v15;

  *a1 = *(_DWORD *)a2;
  LOBYTE(v3) = *(_BYTE *)(a2 + 31);
  if ((v3 & 0x80u) != 0)
    v3 = *(_QWORD *)(a2 + 16);
  v4 = a1 + 2;
  a1[1] = v3;
  v5 = *(unsigned __int8 *)(a2 + 31);
  v6 = *(_QWORD *)(a2 + 16);
  if ((v5 & 0x80u) == 0)
    v7 = (const void *)(a2 + 8);
  else
    v7 = *(const void **)(a2 + 8);
  if ((v5 & 0x80u) == 0)
    v8 = v5;
  else
    v8 = v6;
  memcpy(a1 + 2, v7, v8);
  v9 = *(unsigned __int8 *)(a2 + 31);
  if ((v9 & 0x80u) != 0)
    v9 = *(_QWORD *)(a2 + 16);
  v10 = &v4[v9];
  LOBYTE(v9) = *(_BYTE *)(a2 + 55);
  if ((v9 & 0x80u) != 0)
    v9 = *(_QWORD *)(a2 + 40);
  *v10 = v9;
  v11 = v10 + 1;
  v12 = *(char *)(a2 + 55);
  if (v12 >= 0)
    v13 = (const void *)(a2 + 32);
  else
    v13 = *(const void **)(a2 + 32);
  if (v12 >= 0)
    v14 = *(unsigned __int8 *)(a2 + 55);
  else
    v14 = *(_QWORD *)(a2 + 40);
  memcpy(v11, v13, v14);
  v15 = *(unsigned __int8 *)(a2 + 55);
  if ((v15 & 0x80u) != 0)
    v15 = *(_QWORD *)(a2 + 40);
  return &v11[v15];
}

uint64_t tlv::size<uim::tlv::UnblockPin>(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *(unsigned __int8 *)(a1 + 31);
  if ((v1 & 0x80u) != 0)
    v1 = *(_QWORD *)(a1 + 16);
  v2 = *(unsigned __int8 *)(a1 + 55);
  if ((v2 & 0x80u) != 0)
    v2 = *(_QWORD *)(a1 + 40);
  return v1 + v2 + 6;
}

char *tlv::writeV<uim::tlv::UnblockPin>(char **a1, uint64_t a2)
{
  char *result;

  result = uim::tlv::writeField(*a1, a2);
  *a1 = result;
  return result;
}

uint64_t uim::tlv::writeField(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  const void *v6;
  size_t v7;

  *(_BYTE *)a1 = *(_BYTE *)a2;
  *(_BYTE *)(a1 + 1) = *(_BYTE *)(a2 + 1);
  *(_WORD *)(a1 + 2) = (*(_DWORD *)(a2 + 16) - *(_DWORD *)(a2 + 8)) >> 5;
  result = a1 + 4;
  v3 = *(_QWORD *)(a2 + 8);
  v4 = *(_QWORD *)(a2 + 16);
  while (v3 != v4)
  {
    *(_WORD *)result = *(_WORD *)v3;
    v5 = result + 3;
    *(_BYTE *)(result + 2) = (*(_DWORD *)(v3 + 16) - *(_DWORD *)(v3 + 8)) & 0xFE;
    v6 = *(const void **)(v3 + 8);
    v7 = *(_QWORD *)(v3 + 16) - (_QWORD)v6;
    memcpy((void *)(result + 3), v6, v7);
    result = v5 + v7;
    v3 += 32;
  }
  return result;
}

uint64_t tlv::size<uim::tlv::RefreshReg>(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v1 = *(_QWORD *)(a1 + 8);
  v2 = *(_QWORD *)(a1 + 16);
  if (v1 == v2)
    return 7;
  v3 = 0;
  do
  {
    v3 = v3 + *(_QWORD *)(v1 + 16) - *(_QWORD *)(v1 + 8) + 3;
    v1 += 32;
  }
  while (v1 != v2);
  return v3 + 7;
}

uint64_t tlv::writeV<uim::tlv::RefreshReg>(uint64_t *a1, uint64_t a2)
{
  uint64_t result;

  result = uim::tlv::writeField(*a1, a2);
  *a1 = result;
  return result;
}

char *uim::tlv::parseField(uim::tlv *this, const unsigned __int8 *a2, unsigned __int8 *a3, uim::tlv::Refresh *a4)
{
  unsigned __int16 *v7;
  char *v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  char *result;

  tlv::throwIfNotEnoughBytes((unint64_t)this, a2, 1uLL);
  *a3 = *(_BYTE *)this;
  tlv::throwIfNotEnoughBytes((unint64_t)this + 1, a2, 1uLL);
  *((_DWORD *)a3 + 1) = *((unsigned __int8 *)this + 1);
  v7 = (unsigned __int16 *)pbm::tlv::parseField((unint64_t)this + 2, a2, (uint64_t)(a3 + 8));
  tlv::throwIfNotEnoughBytes((unint64_t)v7, a2, 2uLL);
  v9 = *v7;
  v8 = (char *)(v7 + 1);
  std::vector<uim::tlv::FileId>::resize((uint64_t *)a3 + 5, v9);
  v10 = *((_QWORD *)a3 + 5);
  v11 = *((_QWORD *)a3 + 6);
  while (1)
  {
    result = v8;
    if (v10 == v11)
      break;
    v8 = uim::tlv::parseField((unint64_t)v8, a2, v10);
    v10 += 32;
  }
  return result;
}

char *tlv::parseV<uim::tlv::Refresh>@<X0>(uim::tlv **a1@<X0>, int a2@<W1>, uim::tlv::Refresh *a3@<X3>, uint64_t a4@<X8>)
{
  char *result;

  *(_OWORD *)(a4 + 32) = 0u;
  *(_OWORD *)(a4 + 48) = 0u;
  *(_OWORD *)a4 = 0u;
  *(_OWORD *)(a4 + 16) = 0u;
  result = uim::tlv::parseField(*a1, (const unsigned __int8 *)*a1 + a2, (unsigned __int8 *)a4, a3);
  *a1 = (uim::tlv *)result;
  return result;
}

void sub_2168C3188(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C317CLL);
}

void sub_2168C3198(_Unwind_Exception *a1)
{
  uim::tlv::Refresh *v1;

  uim::tlv::Refresh::~Refresh(v1);
  _Unwind_Resume(a1);
}

void uim::tlv::Refresh::~Refresh(uim::tlv::Refresh *this)
{
  void *v2;
  void **v3;

  v3 = (void **)((char *)this + 40);
  std::vector<at::tlv::CommandCallback>::__destroy_vector::operator()[abi:ne180100](&v3);
  v2 = (void *)*((_QWORD *)this + 2);
  if (v2)
  {
    *((_QWORD *)this + 3) = v2;
    operator delete(v2);
  }
}

void *tlv::writeV<uim::tlv::AuthData>(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  void *result;

  v4 = *a1;
  *(_BYTE *)v4 = *(_DWORD *)a2;
  *(_WORD *)(v4 + 1) = *(_WORD *)(a2 + 16) - *(_DWORD *)(a2 + 8);
  v5 = v4 + 3;
  result = memcpy((void *)(v4 + 3), *(const void **)(a2 + 8), *(_QWORD *)(a2 + 16) - *(_QWORD *)(a2 + 8));
  *a1 = v5 + *(_QWORD *)(a2 + 16) - *(_QWORD *)(a2 + 8);
  return result;
}

char *tlv::parseV<uim::tlv::AuthResult>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  char *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = p2p::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), a3);
  *a1 = (unint64_t)result;
  return result;
}

void sub_2168C329C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C3290);
}

void sub_2168C32AC(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t tlv::parseV<uim::tlv::DebouncingState>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  const unsigned __int8 *v4;
  unsigned int v5;

  v3 = (unsigned __int8 *)*a1;
  v4 = (const unsigned __int8 *)(*a1 + a2);
  tlv::throwIfNotEnoughBytes(*a1, v4, 1uLL);
  v5 = *v3;
  tlv::throwIfNotEnoughBytes((unint64_t)(v3 + 1), v4, 8uLL);
  *a1 = (unint64_t)(v3 + 9);
  return v5;
}

void sub_2168C332C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C3318);
}

void std::vector<uim::tlv::App>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<uim::tlv::App>::__clear[abi:ne180100]((uint64_t *)v2);
    operator delete(**a1);
  }
}

void std::vector<uim::tlv::App>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v2;
  uint64_t i;
  void *v4;

  v2 = *a1;
  for (i = a1[1]; i != v2; i -= 72)
  {
    v4 = *(void **)(i - 48);
    if (v4)
    {
      *(_QWORD *)(i - 40) = v4;
      operator delete(v4);
    }
  }
  a1[1] = v2;
}

void std::vector<uim::tlv::Slot>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  char *v6;
  void **v7;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = v4 - 40;
        v7 = (void **)(v4 - 24);
        std::vector<uim::tlv::App>::__destroy_vector::operator()[abi:ne180100](&v7);
        v4 = v6;
      }
      while (v6 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<uim::tlv::ExtendedCardInfo>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 72;
        std::__destroy_at[abi:ne180100]<uim::tlv::ExtendedCardInfo,0>(v4);
      }
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::__destroy_at[abi:ne180100]<uim::tlv::ExtendedCardInfo,0>(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;

  v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(_QWORD *)(a1 + 56) = v2;
    operator delete(v2);
  }
  v3 = *(void **)(a1 + 24);
  if (v3)
  {
    *(_QWORD *)(a1 + 32) = v3;
    operator delete(v3);
  }
  v4 = *(void **)a1;
  if (*(_QWORD *)a1)
  {
    *(_QWORD *)(a1 + 8) = v4;
    operator delete(v4);
  }
}

void std::vector<uim::tlv::App>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  BOOL v5;
  unint64_t v6;
  uint64_t v7;
  void *v8;

  v3 = a1[1];
  v4 = 0x8E38E38E38E38E39 * ((v3 - *a1) >> 3);
  v5 = a2 >= v4;
  v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    std::vector<uim::tlv::App>::__append(a1, v6);
  }
  else if (!v5)
  {
    v7 = *a1 + 72 * a2;
    while (v3 != v7)
    {
      v8 = *(void **)(v3 - 48);
      if (v8)
      {
        *(_QWORD *)(v3 - 40) = v8;
        operator delete(v8);
      }
      v3 -= 72;
    }
    a1[1] = v7;
  }
}

void std::vector<uim::tlv::App>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  size_t v13;
  size_t v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (0x8E38E38E38E38E39 * ((v6 - v7) >> 3) >= a2)
  {
    if (a2)
    {
      v13 = 72 * ((72 * a2 - 72) / 0x48) + 72;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = 0x8E38E38E38E38E39 * ((v7 - *a1) >> 3);
    v9 = v8 + a2;
    if (v8 + a2 > 0x38E38E38E38E38ELL)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = 0x8E38E38E38E38E39 * ((v5 - *a1) >> 3);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x1C71C71C71C71C7)
      v11 = 0x38E38E38E38E38ELL;
    else
      v11 = v9;
    v19 = v4;
    if (v11)
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<nas::tlv::NrCell_V3>>(v4, v11);
    else
      v12 = 0;
    v15 = v12;
    v16 = &v12[72 * v8];
    v18 = &v12[72 * v11];
    v14 = 72 * ((72 * a2 - 72) / 0x48) + 72;
    bzero(v16, v14);
    v17 = &v16[v14];
    std::vector<uim::tlv::App>::__swap_out_circular_buffer(a1, &v15);
    std::__split_buffer<uim::tlv::App>::~__split_buffer((uint64_t)&v15);
  }
}

void sub_2168C372C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<uim::tlv::App>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<uim::tlv::App>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<uim::tlv::App>,std::reverse_iterator<uim::tlv::App*>,std::reverse_iterator<uim::tlv::App*>,std::reverse_iterator<uim::tlv::App*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<uim::tlv::App>,std::reverse_iterator<uim::tlv::App*>,std::reverse_iterator<uim::tlv::App*>,std::reverse_iterator<uim::tlv::App*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  __int128 v8;
  __int16 v9;
  uint64_t v10;
  _QWORD v12[3];
  uint64_t v13;
  __int128 v14;
  __int128 v15;

  v7 = a7;
  *(_QWORD *)&v15 = a6;
  *((_QWORD *)&v15 + 1) = a7;
  v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  v13 = 0;
  if (a3 == a5)
  {
    v10 = a6;
  }
  else
  {
    do
    {
      v8 = *(_OWORD *)(a3 - 72);
      *(_WORD *)(v7 - 56) = *(_WORD *)(a3 - 56);
      *(_OWORD *)(v7 - 72) = v8;
      *(_QWORD *)(v7 - 40) = 0;
      *(_QWORD *)(v7 - 32) = 0;
      *(_QWORD *)(v7 - 48) = 0;
      *(_OWORD *)(v7 - 48) = *(_OWORD *)(a3 - 48);
      *(_QWORD *)(v7 - 32) = *(_QWORD *)(a3 - 32);
      *(_QWORD *)(a3 - 48) = 0;
      *(_QWORD *)(a3 - 40) = 0;
      *(_QWORD *)(a3 - 32) = 0;
      v9 = *(_WORD *)(a3 - 8);
      *(_OWORD *)(v7 - 24) = *(_OWORD *)(a3 - 24);
      *(_WORD *)(v7 - 8) = v9;
      v7 = *((_QWORD *)&v15 + 1) - 72;
      *((_QWORD *)&v15 + 1) -= 72;
      a3 -= 72;
    }
    while (a3 != a5);
    v10 = v15;
  }
  LOBYTE(v13) = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<uim::tlv::App>,std::reverse_iterator<uim::tlv::App*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return v10;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<uim::tlv::App>,std::reverse_iterator<uim::tlv::App*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<uim::tlv::App>,std::reverse_iterator<uim::tlv::App*>>::operator()[abi:ne180100](a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<uim::tlv::App>,std::reverse_iterator<uim::tlv::App*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  void *v3;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8);
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    v3 = *(void **)(v1 + 24);
    if (v3)
    {
      *(_QWORD *)(v1 + 32) = v3;
      operator delete(v3);
    }
    v1 += 72;
  }
}

uint64_t std::__split_buffer<uim::tlv::App>::~__split_buffer(uint64_t a1)
{
  std::__split_buffer<uim::tlv::App>::__destruct_at_end[abi:ne180100](a1, *(_QWORD *)(a1 + 8));
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::__split_buffer<uim::tlv::App>::__destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  void *v5;

  v2 = *(_QWORD *)(a1 + 16);
  while (v2 != a2)
  {
    *(_QWORD *)(a1 + 16) = v2 - 72;
    v5 = *(void **)(v2 - 48);
    if (v5)
    {
      *(_QWORD *)(v2 - 40) = v5;
      operator delete(v5);
      v2 = *(_QWORD *)(a1 + 16);
    }
    else
    {
      v2 -= 72;
    }
  }
}

void std::vector<uim::tlv::Slot>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  BOOL v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void **v9;

  v3 = a1[1];
  v4 = 0xCCCCCCCCCCCCCCCDLL * ((v3 - *a1) >> 3);
  v5 = a2 >= v4;
  v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    std::vector<uim::tlv::Slot>::__append(a1, v6);
  }
  else if (!v5)
  {
    v7 = *a1 + 40 * a2;
    if (v3 != v7)
    {
      do
      {
        v8 = v3 - 40;
        v9 = (void **)(v3 - 24);
        std::vector<uim::tlv::App>::__destroy_vector::operator()[abi:ne180100](&v9);
        v3 = v8;
      }
      while (v8 != v7);
    }
    a1[1] = v7;
  }
}

void std::vector<uim::tlv::Slot>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  size_t v13;
  size_t v14;
  void *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (0xCCCCCCCCCCCCCCCDLL * ((v6 - v7) >> 3) >= a2)
  {
    if (a2)
    {
      v13 = 40 * ((40 * a2 - 40) / 0x28) + 40;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = 0xCCCCCCCCCCCCCCCDLL * ((v7 - *a1) >> 3);
    v9 = v8 + a2;
    if (v8 + a2 > 0x666666666666666)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = 0xCCCCCCCCCCCCCCCDLL * ((v5 - *a1) >> 3);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x333333333333333)
      v11 = 0x666666666666666;
    else
      v11 = v9;
    v19 = v4;
    if (v11)
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<vs::tlv::ServiceParam>>(v4, v11);
    else
      v12 = 0;
    v15 = v12;
    v16 = &v12[40 * v8];
    v18 = &v12[40 * v11];
    v14 = 40 * ((40 * a2 - 40) / 0x28) + 40;
    bzero(v16, v14);
    v17 = &v16[v14];
    std::vector<uim::tlv::Slot>::__swap_out_circular_buffer(a1, &v15);
    std::__split_buffer<uim::tlv::Slot>::~__split_buffer(&v15);
  }
}

void sub_2168C3B70(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<uim::tlv::Slot>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<uim::tlv::Slot>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<uim::tlv::Slot>,std::reverse_iterator<uim::tlv::Slot*>,std::reverse_iterator<uim::tlv::Slot*>,std::reverse_iterator<uim::tlv::Slot*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<uim::tlv::Slot>,std::reverse_iterator<uim::tlv::Slot*>,std::reverse_iterator<uim::tlv::Slot*>,std::reverse_iterator<uim::tlv::Slot*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD v11[3];
  uint64_t v12;
  __int128 v13;
  __int128 v14;

  v7 = a7;
  *(_QWORD *)&v14 = a6;
  *((_QWORD *)&v14 + 1) = a7;
  v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  v12 = 0;
  if (a3 == a5)
  {
    v9 = a6;
  }
  else
  {
    do
    {
      v8 = *(_QWORD *)(a3 - 40);
      a3 -= 40;
      *(_QWORD *)(v7 - 35) = *(_QWORD *)(a3 + 5);
      *(_QWORD *)(v7 - 40) = v8;
      *(_QWORD *)(v7 - 16) = 0;
      *(_QWORD *)(v7 - 8) = 0;
      *(_QWORD *)(v7 - 24) = 0;
      *(_OWORD *)(v7 - 24) = *(_OWORD *)(a3 + 16);
      *(_QWORD *)(v7 - 8) = *(_QWORD *)(a3 + 32);
      *(_QWORD *)(a3 + 16) = 0;
      *(_QWORD *)(a3 + 24) = 0;
      *(_QWORD *)(a3 + 32) = 0;
      v7 = *((_QWORD *)&v14 + 1) - 40;
      *((_QWORD *)&v14 + 1) -= 40;
    }
    while (a3 != a5);
    v9 = v14;
  }
  LOBYTE(v12) = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<uim::tlv::Slot>,std::reverse_iterator<uim::tlv::Slot*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v11);
  return v9;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<uim::tlv::Slot>,std::reverse_iterator<uim::tlv::Slot*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<uim::tlv::Slot>,std::reverse_iterator<uim::tlv::Slot*>>::operator()[abi:ne180100](a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<uim::tlv::Slot>,std::reverse_iterator<uim::tlv::Slot*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  void **v3;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8);
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    v3 = (void **)(v1 + 16);
    std::vector<uim::tlv::App>::__destroy_vector::operator()[abi:ne180100](&v3);
    v1 += 40;
  }
}

void **std::__split_buffer<uim::tlv::Slot>::~__split_buffer(void **a1)
{
  std::__split_buffer<uim::tlv::Slot>::clear[abi:ne180100]((uint64_t)a1);
  if (*a1)
    operator delete(*a1);
  return a1;
}

void std::__split_buffer<uim::tlv::Slot>::clear[abi:ne180100](uint64_t a1)
{
  uint64_t i;
  uint64_t v2;
  void **v4;

  v2 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v2; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 40;
    v4 = (void **)(i - 24);
    std::vector<uim::tlv::App>::__destroy_vector::operator()[abi:ne180100](&v4);
  }
}

void std::vector<uim::tlv::ExtendedCardInfo>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  BOOL v5;
  unint64_t v6;
  uint64_t v7;

  v3 = a1[1];
  v4 = 0x8E38E38E38E38E39 * ((v3 - *a1) >> 3);
  v5 = a2 >= v4;
  v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    std::vector<uim::tlv::ExtendedCardInfo>::__append(a1, v6);
  }
  else if (!v5)
  {
    v7 = *a1 + 72 * a2;
    while (v3 != v7)
    {
      v3 -= 72;
      std::__destroy_at[abi:ne180100]<uim::tlv::ExtendedCardInfo,0>(v3);
    }
    a1[1] = v7;
  }
}

void std::vector<uim::tlv::ExtendedCardInfo>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  size_t v13;
  size_t v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (0x8E38E38E38E38E39 * ((v6 - v7) >> 3) >= a2)
  {
    if (a2)
    {
      v13 = 72 * ((72 * a2 - 72) / 0x48) + 72;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = 0x8E38E38E38E38E39 * ((v7 - *a1) >> 3);
    v9 = v8 + a2;
    if (v8 + a2 > 0x38E38E38E38E38ELL)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = 0x8E38E38E38E38E39 * ((v5 - *a1) >> 3);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x1C71C71C71C71C7)
      v11 = 0x38E38E38E38E38ELL;
    else
      v11 = v9;
    v19 = v4;
    if (v11)
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<nas::tlv::NrCell_V3>>(v4, v11);
    else
      v12 = 0;
    v15 = v12;
    v16 = &v12[72 * v8];
    v18 = &v12[72 * v11];
    v14 = 72 * ((72 * a2 - 72) / 0x48) + 72;
    bzero(v16, v14);
    v17 = &v16[v14];
    std::vector<uim::tlv::ExtendedCardInfo>::__swap_out_circular_buffer(a1, &v15);
    std::__split_buffer<uim::tlv::ExtendedCardInfo>::~__split_buffer((uint64_t)&v15);
  }
}

void sub_2168C3FC8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<uim::tlv::ExtendedCardInfo>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::vector<uim::tlv::ExtendedCardInfo>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v5 = *a1;
  v4 = a1[1];
  v6 = (_QWORD *)a2[1];
  while (v4 != v5)
  {
    v6 -= 9;
    v4 -= 72;
    std::construct_at[abi:ne180100]<uim::tlv::ExtendedCardInfo,uim::tlv::ExtendedCardInfo,uim::tlv::ExtendedCardInfo*>(v6, v4);
  }
  a2[1] = v6;
  v7 = *a1;
  *a1 = (uint64_t)v6;
  a2[1] = v7;
  v8 = a1[1];
  a1[1] = a2[2];
  a2[2] = v8;
  v9 = a1[2];
  a1[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
}

__n128 std::construct_at[abi:ne180100]<uim::tlv::ExtendedCardInfo,uim::tlv::ExtendedCardInfo,uim::tlv::ExtendedCardInfo*>(_QWORD *a1, uint64_t a2)
{
  __n128 result;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  *(_OWORD *)a1 = *(_OWORD *)a2;
  a1[2] = *(_QWORD *)(a2 + 16);
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  a1[3] = 0;
  a1[4] = 0;
  a1[5] = 0;
  *(_OWORD *)(a1 + 3) = *(_OWORD *)(a2 + 24);
  a1[5] = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 24) = 0;
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 40) = 0;
  a1[6] = 0;
  a1[7] = 0;
  a1[8] = 0;
  result = *(__n128 *)(a2 + 48);
  *((__n128 *)a1 + 3) = result;
  a1[8] = *(_QWORD *)(a2 + 64);
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(a2 + 56) = 0;
  *(_QWORD *)(a2 + 64) = 0;
  return result;
}

uint64_t std::__split_buffer<uim::tlv::ExtendedCardInfo>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 72;
    std::__destroy_at[abi:ne180100]<uim::tlv::ExtendedCardInfo,0>(i - 72);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<uim::tlv::IccidSlotInfo>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x1745D1745D1745D2)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(11 * a2);
}

void std::vector<uim::tlv::FileId>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  void *v6;

  v3 = a1[1];
  v4 = (v3 - *a1) >> 5;
  if (a2 <= v4)
  {
    if (a2 < v4)
    {
      v5 = *a1 + 32 * a2;
      while (v3 != v5)
      {
        v6 = *(void **)(v3 - 24);
        if (v6)
        {
          *(_QWORD *)(v3 - 16) = v6;
          operator delete(v6);
        }
        v3 -= 32;
      }
      a1[1] = v5;
    }
  }
  else
  {
    std::vector<uim::tlv::FileId>::__append(a1, a2 - v4);
  }
}

void std::vector<uim::tlv::FileId>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (a2 <= (v6 - v7) >> 5)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 32 * a2);
      v7 += 32 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = v7 - *a1;
    v9 = a2 + (v8 >> 5);
    if (v9 >> 59)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 5;
    v11 = v5 - *a1;
    if (v11 >> 4 > v9)
      v9 = v11 >> 4;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFE0)
      v12 = 0x7FFFFFFFFFFFFFFLL;
    else
      v12 = v9;
    v18 = v4;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<vs::tlv::RemoteNumberListItem>>(v4, v12);
    else
      v13 = 0;
    v14 = v13;
    v15 = &v13[32 * v10];
    v17 = &v13[32 * v12];
    bzero(v15, 32 * a2);
    v16 = &v15[32 * a2];
    std::vector<uim::tlv::FileId>::__swap_out_circular_buffer(a1, &v14);
    std::__split_buffer<at::tlv::CommandCallback>::~__split_buffer((uint64_t)&v14);
  }
}

void sub_2168C42D0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<at::tlv::CommandCallback>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<uim::tlv::FileId>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<uim::tlv::FileId>,std::reverse_iterator<uim::tlv::FileId*>,std::reverse_iterator<uim::tlv::FileId*>,std::reverse_iterator<uim::tlv::FileId*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<uim::tlv::FileId>,std::reverse_iterator<uim::tlv::FileId*>,std::reverse_iterator<uim::tlv::FileId*>,std::reverse_iterator<uim::tlv::FileId*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  __int16 v8;
  uint64_t v9;
  _QWORD v11[3];
  uint64_t v12;
  __int128 v13;
  __int128 v14;

  v7 = a7;
  *(_QWORD *)&v14 = a6;
  *((_QWORD *)&v14 + 1) = a7;
  v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  v12 = 0;
  if (a3 == a5)
  {
    v9 = a6;
  }
  else
  {
    do
    {
      v8 = *(_WORD *)(a3 - 32);
      a3 -= 32;
      *(_WORD *)(v7 - 32) = v8;
      *(_QWORD *)(v7 - 16) = 0;
      *(_QWORD *)(v7 - 8) = 0;
      *(_QWORD *)(v7 - 24) = 0;
      *(_OWORD *)(v7 - 24) = *(_OWORD *)(a3 + 8);
      *(_QWORD *)(v7 - 8) = *(_QWORD *)(a3 + 24);
      *(_QWORD *)(a3 + 8) = 0;
      *(_QWORD *)(a3 + 16) = 0;
      *(_QWORD *)(a3 + 24) = 0;
      v7 = *((_QWORD *)&v14 + 1) - 32;
      *((_QWORD *)&v14 + 1) -= 32;
    }
    while (a3 != a5);
    v9 = v14;
  }
  LOBYTE(v12) = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<uim::tlv::FileId>,std::reverse_iterator<uim::tlv::FileId*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v11);
  return v9;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<uim::tlv::FileId>,std::reverse_iterator<uim::tlv::FileId*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<at::tlv::CommandCallback>,std::reverse_iterator<at::tlv::CommandCallback*>>::operator()[abi:ne180100](a1);
  return a1;
}

uint64_t tlv::size<wds::tlv::FilteringPortsList1>(_QWORD *a1)
{
  uint64_t v1;

  v1 = a1[1];
  if (v1 == *a1)
    return 3;
  else
    return (v1 - *a1) | 3;
}

uint64_t *tlv::writeV<wds::tlv::FilteringPortsList1>(uint64_t *result, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *result;
  v3 = *a2;
  v4 = a2[1];
  while (v3 != v4)
  {
    *(_BYTE *)v2 = *(_BYTE *)v3;
    *(_BYTE *)(v2 + 1) = *(_BYTE *)(v3 + 1);
    *(_WORD *)(v2 + 2) = *(_WORD *)(v3 + 2);
    v2 += 4;
    v3 += 4;
  }
  *result = v2;
  return result;
}

unint64_t tlv::size<wds::tlv::FilteringPortsList2>(_QWORD *a1)
{
  uint64_t v1;

  v1 = a1[1];
  if (*a1 == v1)
    return 3;
  else
    return 5 * ((v1 - *a1 - 6) / 6uLL) + 8;
}

uint64_t *tlv::writeV<wds::tlv::FilteringPortsList2>(uint64_t *result, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *result;
  v3 = *a2;
  v4 = a2[1];
  while (v3 != v4)
  {
    *(_BYTE *)v2 = *(_BYTE *)v3;
    *(_BYTE *)(v2 + 1) = *(_BYTE *)(v3 + 1);
    *(_BYTE *)(v2 + 2) = *(_BYTE *)(v3 + 2);
    *(_WORD *)(v2 + 3) = *(_WORD *)(v3 + 4);
    v2 += 5;
    v3 += 6;
  }
  *result = v2;
  return result;
}

unint64_t tlv::size<wds::tlv::FilteringPortsList3>(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *(_QWORD *)(a1 + 8);
  v2 = *(_QWORD *)(a1 + 16);
  if (v1 == v2)
    return 5;
  else
    return 5 * ((v2 - v1 - 6) / 6uLL) + 10;
}

_WORD **tlv::writeV<wds::tlv::FilteringPortsList3>(_WORD **result, uint64_t a2)
{
  _WORD *v2;
  _WORD *v3;
  uint64_t v4;
  uint64_t v5;

  v2 = *result;
  *v2 = *(_WORD *)a2;
  v3 = v2 + 1;
  v4 = *(_QWORD *)(a2 + 8);
  v5 = *(_QWORD *)(a2 + 16);
  while (v4 != v5)
  {
    *(_BYTE *)v3 = *(_BYTE *)v4;
    *((_BYTE *)v3 + 1) = *(_BYTE *)(v4 + 1);
    *((_BYTE *)v3 + 2) = *(_BYTE *)(v4 + 2);
    *(_WORD *)((char *)v3 + 3) = *(_WORD *)(v4 + 4);
    v3 = (_WORD *)((char *)v3 + 5);
    v4 += 6;
  }
  *result = v3;
  return result;
}

uint64_t tlv::parseV<vs::tlv::CallIdentifier>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168C45C8(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C45BCLL);
}

uint64_t tlv::parseV<vs::tlv::FailureCause>(unint64_t *a1, int a2)
{
  unsigned __int16 *v3;
  uint64_t result;

  v3 = (unsigned __int16 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 2uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168C4614(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C4608);
}

BOOL tlv::parseV<nas::tlv::EMBMSStatus>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  _BOOL8 result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3 != 0;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168C4668(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C465CLL);
}

unint64_t tlv::parseV<nas::tlv::EMBMSSignalQualityAndTMGIInfoData>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  unint64_t result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = nas::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = (unsigned __int8 *)result;
  return result;
}

void sub_2168C4874(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C4864);
}

void sub_2168C4884(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::vector<nas::tlv::EMBMSSignalQualityAndTMGIInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

void std::vector<nas::tlv::EMBMSSignalQualityAndTMGIInfo>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<nas::tlv::EMBMSSignalQualityAndTMGIInfo>::__clear[abi:ne180100]((uint64_t *)v2);
    operator delete(**a1);
  }
}

void std::vector<nas::tlv::EMBMSSignalQualityAndTMGIInfo>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v2;
  uint64_t i;
  void *v4;

  v2 = *a1;
  for (i = a1[1]; i != v2; i -= 40)
  {
    v4 = *(void **)(i - 24);
    if (v4)
    {
      *(_QWORD *)(i - 16) = v4;
      operator delete(v4);
    }
  }
  a1[1] = v2;
}

void std::vector<nas::tlv::EMBMSTMGIInfo>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;

  v2 = 0x8E38E38E38E38E39 * (*(_QWORD *)(a1 + 8) - *(_QWORD *)a1);
  v3 = a2 >= v2;
  v4 = a2 - v2;
  if (v4 != 0 && v3)
  {
    std::vector<nas::tlv::EMBMSTMGIInfo>::__append((char **)a1, v4);
  }
  else if (!v3)
  {
    *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 9 * a2;
  }
}

void std::vector<nas::tlv::EMBMSTMGIInfo>::__append(char **a1, unint64_t a2)
{
  uint64_t v4;
  char *v5;
  char *v6;
  char *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  size_t v13;
  char *v14;
  char *v15;
  size_t v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;
  char v21;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (0x8E38E38E38E38E39 * (v6 - v7) >= a2)
  {
    if (a2)
    {
      v13 = 9 * ((9 * a2 - 9) / 9) + 9;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = 0x8E38E38E38E38E39 * (v7 - *a1);
    v9 = v8 + a2;
    if (v8 + a2 > 0x1C71C71C71C71C71)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = 0x8E38E38E38E38E39 * (v5 - *a1);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0xE38E38E38E38E38)
      v11 = 0x1C71C71C71C71C71;
    else
      v11 = v9;
    if (v11)
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<nas::tlv::EMBMSTMGIInfo>>(v4, v11);
    else
      v12 = 0;
    v14 = &v12[9 * v8];
    v15 = &v12[9 * v11];
    v16 = 9 * ((9 * a2 - 9) / 9) + 9;
    bzero(v14, v16);
    v17 = &v14[v16];
    v19 = *a1;
    v18 = a1[1];
    if (v18 != *a1)
    {
      do
      {
        v20 = *(_QWORD *)(v18 - 9);
        v18 -= 9;
        v21 = v18[8];
        *(_QWORD *)(v14 - 9) = v20;
        v14 -= 9;
        v14[8] = v21;
      }
      while (v18 != v19);
      v18 = *a1;
    }
    *a1 = v14;
    a1[1] = v17;
    a1[2] = v15;
    if (v18)
      operator delete(v18);
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<nas::tlv::EMBMSTMGIInfo>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x1C71C71C71C71C72)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(9 * a2);
}

void std::vector<nas::tlv::EMBMSSignalQualityAndTMGIInfo>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  BOOL v5;
  unint64_t v6;
  uint64_t v7;
  void *v8;

  v3 = a1[1];
  v4 = 0xCCCCCCCCCCCCCCCDLL * ((v3 - *a1) >> 3);
  v5 = a2 >= v4;
  v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    std::vector<nas::tlv::EMBMSSignalQualityAndTMGIInfo>::__append(a1, v6);
  }
  else if (!v5)
  {
    v7 = *a1 + 40 * a2;
    while (v3 != v7)
    {
      v8 = *(void **)(v3 - 24);
      if (v8)
      {
        *(_QWORD *)(v3 - 16) = v8;
        operator delete(v8);
      }
      v3 -= 40;
    }
    a1[1] = v7;
  }
}

void std::vector<nas::tlv::EMBMSSignalQualityAndTMGIInfo>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  size_t v13;
  size_t v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (0xCCCCCCCCCCCCCCCDLL * ((v6 - v7) >> 3) >= a2)
  {
    if (a2)
    {
      v13 = 40 * ((40 * a2 - 40) / 0x28) + 40;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = 0xCCCCCCCCCCCCCCCDLL * ((v7 - *a1) >> 3);
    v9 = v8 + a2;
    if (v8 + a2 > 0x666666666666666)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = 0xCCCCCCCCCCCCCCCDLL * ((v5 - *a1) >> 3);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x333333333333333)
      v11 = 0x666666666666666;
    else
      v11 = v9;
    v19 = v4;
    if (v11)
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<vs::tlv::ServiceParam>>(v4, v11);
    else
      v12 = 0;
    v15 = v12;
    v16 = &v12[40 * v8];
    v18 = &v12[40 * v11];
    v14 = 40 * ((40 * a2 - 40) / 0x28) + 40;
    bzero(v16, v14);
    v17 = &v16[v14];
    std::vector<nas::tlv::EMBMSSignalQualityAndTMGIInfo>::__swap_out_circular_buffer(a1, &v15);
    std::__split_buffer<nas::tlv::EMBMSSignalQualityAndTMGIInfo>::~__split_buffer((uint64_t)&v15);
  }
}

void sub_2168C4D2C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<nas::tlv::EMBMSSignalQualityAndTMGIInfo>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<nas::tlv::EMBMSSignalQualityAndTMGIInfo>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<nas::tlv::EMBMSSignalQualityAndTMGIInfo>,std::reverse_iterator<nas::tlv::EMBMSSignalQualityAndTMGIInfo*>,std::reverse_iterator<nas::tlv::EMBMSSignalQualityAndTMGIInfo*>,std::reverse_iterator<nas::tlv::EMBMSSignalQualityAndTMGIInfo*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<nas::tlv::EMBMSSignalQualityAndTMGIInfo>,std::reverse_iterator<nas::tlv::EMBMSSignalQualityAndTMGIInfo*>,std::reverse_iterator<nas::tlv::EMBMSSignalQualityAndTMGIInfo*>,std::reverse_iterator<nas::tlv::EMBMSSignalQualityAndTMGIInfo*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD v11[3];
  uint64_t v12;
  __int128 v13;
  __int128 v14;

  v7 = a7;
  *(_QWORD *)&v14 = a6;
  *((_QWORD *)&v14 + 1) = a7;
  v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  v12 = 0;
  if (a3 == a5)
  {
    v9 = a6;
  }
  else
  {
    do
    {
      v8 = *(_QWORD *)(a3 - 40);
      a3 -= 40;
      *(_DWORD *)(v7 - 32) = *(_DWORD *)(a3 + 8);
      *(_QWORD *)(v7 - 40) = v8;
      *(_QWORD *)(v7 - 16) = 0;
      *(_QWORD *)(v7 - 8) = 0;
      *(_QWORD *)(v7 - 24) = 0;
      *(_OWORD *)(v7 - 24) = *(_OWORD *)(a3 + 16);
      *(_QWORD *)(v7 - 8) = *(_QWORD *)(a3 + 32);
      *(_QWORD *)(a3 + 16) = 0;
      *(_QWORD *)(a3 + 24) = 0;
      *(_QWORD *)(a3 + 32) = 0;
      v7 = *((_QWORD *)&v14 + 1) - 40;
      *((_QWORD *)&v14 + 1) -= 40;
    }
    while (a3 != a5);
    v9 = v14;
  }
  LOBYTE(v12) = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<nas::tlv::EMBMSSignalQualityAndTMGIInfo>,std::reverse_iterator<nas::tlv::EMBMSSignalQualityAndTMGIInfo*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v11);
  return v9;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<nas::tlv::EMBMSSignalQualityAndTMGIInfo>,std::reverse_iterator<nas::tlv::EMBMSSignalQualityAndTMGIInfo*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<nas::tlv::EMBMSSignalQualityAndTMGIInfo>,std::reverse_iterator<nas::tlv::EMBMSSignalQualityAndTMGIInfo*>>::operator()[abi:ne180100](a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<nas::tlv::EMBMSSignalQualityAndTMGIInfo>,std::reverse_iterator<nas::tlv::EMBMSSignalQualityAndTMGIInfo*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  void *v3;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8);
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    v3 = *(void **)(v1 + 16);
    if (v3)
    {
      *(_QWORD *)(v1 + 24) = v3;
      operator delete(v3);
    }
    v1 += 40;
  }
}

uint64_t std::__split_buffer<nas::tlv::EMBMSSignalQualityAndTMGIInfo>::~__split_buffer(uint64_t a1)
{
  std::__split_buffer<nas::tlv::EMBMSSignalQualityAndTMGIInfo>::__destruct_at_end[abi:ne180100](a1, *(_QWORD *)(a1 + 8));
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::__split_buffer<nas::tlv::EMBMSSignalQualityAndTMGIInfo>::__destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  void *v5;

  v2 = *(_QWORD *)(a1 + 16);
  while (v2 != a2)
  {
    *(_QWORD *)(a1 + 16) = v2 - 40;
    v5 = *(void **)(v2 - 24);
    if (v5)
    {
      *(_QWORD *)(v2 - 16) = v5;
      operator delete(v5);
      v2 = *(_QWORD *)(a1 + 16);
    }
    else
    {
      v2 -= 40;
    }
  }
}

uint64_t tlv::size<awd::tlv::AddConfig>(uint64_t a1)
{
  return *(_QWORD *)(a1 + 24) - *(_QWORD *)(a1 + 16) + 19;
}

void *tlv::writeV<awd::tlv::AddConfig>(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  void *result;

  v4 = *a1;
  *(_DWORD *)v4 = *(_DWORD *)a2;
  *(_DWORD *)(v4 + 4) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(v4 + 8) = *(_DWORD *)(a2 + 8);
  *(_BYTE *)(v4 + 12) = *(_BYTE *)(a2 + 12);
  *(_BYTE *)(v4 + 13) = *(_BYTE *)(a2 + 13);
  *(_WORD *)(v4 + 14) = *(_WORD *)(a2 + 24) - *(_DWORD *)(a2 + 16);
  v5 = v4 + 16;
  result = memcpy((void *)(v4 + 16), *(const void **)(a2 + 16), *(_QWORD *)(a2 + 24) - *(_QWORD *)(a2 + 16));
  *a1 = v5 + *(_QWORD *)(a2 + 24) - *(_QWORD *)(a2 + 16);
  return result;
}

_DWORD **tlv::writeV<awd::tlv::MetricsExt>(_DWORD **result, _DWORD *a2)
{
  _DWORD *v2;

  v2 = *result;
  *v2 = *a2;
  v2[1] = a2[1];
  v2[2] = a2[2];
  v2[3] = a2[3];
  *result = v2 + 4;
  return result;
}

_DWORD **tlv::writeV<awd::tlv::Metrics>(_DWORD **result, _DWORD *a2)
{
  _DWORD *v2;

  v2 = *result;
  *v2 = *a2;
  v2[1] = a2[1];
  v2[2] = a2[2];
  *result = v2 + 3;
  return result;
}

uint64_t *tlv::writeV<awd::tlv::MetricIndicationExt>(uint64_t *result, uint64_t a2)
{
  uint64_t v2;

  v2 = *result;
  *(_DWORD *)v2 = *(_DWORD *)a2;
  *(_BYTE *)(v2 + 4) = *(_BYTE *)(a2 + 4);
  *(_QWORD *)(v2 + 5) = *(_QWORD *)(a2 + 8);
  *result = v2 + 13;
  return result;
}

uint64_t *tlv::writeV<awd::tlv::PIILocationExt>(uint64_t *result, uint64_t a2)
{
  uint64_t v2;

  v2 = *result;
  *(_DWORD *)v2 = *(_DWORD *)a2;
  *(_BYTE *)(v2 + 4) = *(_BYTE *)(a2 + 4);
  *(_BYTE *)(v2 + 5) = *(_BYTE *)(a2 + 5);
  *result = v2 + 6;
  return result;
}

uint64_t *tlv::writeV<awd::tlv::MetricIndication>(uint64_t *result, uint64_t a2)
{
  uint64_t v2;

  v2 = *result;
  *(_BYTE *)v2 = *(_BYTE *)a2;
  *(_QWORD *)(v2 + 1) = *(_QWORD *)(a2 + 8);
  *result = v2 + 9;
  return result;
}

unint64_t tlv::parseV<awd::tlv::MetricData>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  unint64_t result;

  a3[1] = 0u;
  a3[2] = 0u;
  *a3 = 0u;
  result = awd::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), (uint64_t)a3);
  *a1 = result;
  return result;
}

void sub_2168C51F0(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C51E4);
}

void sub_2168C5200(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)(v1 + 24);
  if (v3)
  {
    *(_QWORD *)(v1 + 32) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

unint64_t tlv::parseV<awd::tlv::MetricDataEnd>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  unint64_t result;

  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_DWORD *)(a3 + 16) = 0;
  result = awd::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), a3);
  *a1 = result;
  return result;
}

void sub_2168C52F4(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
}

unint64_t tlv::parseV<awd::tlv::SubmitTrigger>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  unint64_t result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = awd::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), (uint64_t)a3);
  *a1 = result;
  return result;
}

void sub_2168C53E0(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
}

unint64_t tlv::parseV<awd::tlv::PIILocationUsed>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  unint64_t result;

  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_DWORD *)(a3 + 16) = 0;
  result = awd::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), a3);
  *a1 = result;
  return result;
}

void sub_2168C5514(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
}

uint64_t tlv::parseV<awd::tlv::ConfigurationSuccess>(unint64_t *a1, int a2)
{
  unint64_t v3;
  const unsigned __int8 *v4;
  unsigned int v5;
  uint64_t v6;

  v3 = *a1;
  v4 = (const unsigned __int8 *)(*a1 + a2);
  tlv::throwIfNotEnoughBytes(*a1, v4, 4uLL);
  v5 = *(_DWORD *)v3;
  tlv::throwIfNotEnoughBytes(v3 + 4, v4, 1uLL);
  v6 = *(unsigned __int8 *)(v3 + 4);
  *a1 = v3 + 5;
  return (v6 << 32) | v5;
}

void sub_2168C5594(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C557CLL);
}

uint64_t tlv::parseV<wds::tlv::ProfileId>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  const unsigned __int8 *v4;
  unsigned int v5;
  uint64_t v6;

  v3 = (unsigned __int8 *)*a1;
  v4 = (const unsigned __int8 *)(*a1 + a2);
  tlv::throwIfNotEnoughBytes(*a1, v4, 1uLL);
  v5 = *v3;
  tlv::throwIfNotEnoughBytes((unint64_t)(v3 + 1), v4, 1uLL);
  v6 = v3[1];
  *a1 = (unint64_t)(v3 + 2);
  return (v6 << 32) | v5;
}

void sub_2168C5614(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C55FCLL);
}

_BYTE **tlv::writeV<wds::tlv::ProfileId>(_BYTE **result, uint64_t a2)
{
  _BYTE *v2;

  v2 = *result;
  *v2 = *(_DWORD *)a2;
  v2[1] = *(_BYTE *)(a2 + 4);
  *result = v2 + 2;
  return result;
}

uint64_t tlv::size<wds::tlv::PcoContainerIds>()
{
  return 23;
}

__n128 tlv::writeV<wds::tlv::PcoContainerIds>(__n128 **a1, __n128 *a2)
{
  __n128 *v2;
  __n128 result;

  v2 = *a1;
  result = *a2;
  v2[1].n128_u32[0] = a2[1].n128_u32[0];
  *v2 = result;
  *a1 = (__n128 *)((char *)v2 + 20);
  return result;
}

uint64_t tlv::size<wds::tlv::FallbackApnList>(uint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v1 = *a1;
  v2 = a1[1];
  if (*a1 == v2)
    return 4;
  v3 = 0;
  do
  {
    v4 = *(unsigned __int8 *)(v1 + 23);
    if ((v4 & 0x80u) != 0)
      v4 = *(_QWORD *)(v1 + 8);
    v3 += v4 + 1;
    v1 += 24;
  }
  while (v1 != v2);
  return v3 + 4;
}

char *tlv::writeV<wds::tlv::FallbackApnList>(char **a1, _DWORD *a2)
{
  char *result;

  result = wds::tlv::writeField(*a1, a2);
  *a1 = result;
  return result;
}

uint64_t tlv::parseV<audio::tlv::VocoderInfo>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  const unsigned __int8 *v4;
  int v5;
  int v6;

  v3 = (unsigned __int8 *)*a1;
  v4 = (const unsigned __int8 *)(*a1 + a2);
  tlv::throwIfNotEnoughBytes(*a1, v4, 1uLL);
  v5 = *v3;
  tlv::throwIfNotEnoughBytes((unint64_t)(v3 + 1), v4, 1uLL);
  v6 = v3[1];
  *a1 = (unint64_t)(v3 + 2);
  return v5 | (v6 << 8);
}

void sub_2168C57EC(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C57D8);
}

uint64_t tlv::parseV<audio::tlv::I2SClockRateInfo>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168C5838(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C582CLL);
}

uint64_t tlv::parseV<audio::tlv::EVSCodecInfo>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  const unsigned __int8 *v4;
  int v5;
  int v6;

  v3 = (unsigned __int8 *)*a1;
  v4 = (const unsigned __int8 *)(*a1 + a2);
  tlv::throwIfNotEnoughBytes(*a1, v4, 1uLL);
  v5 = *v3;
  tlv::throwIfNotEnoughBytes((unint64_t)(v3 + 1), v4, 1uLL);
  v6 = v3[1];
  *a1 = (unint64_t)(v3 + 2);
  return v5 | (v6 << 8);
}

void sub_2168C58B0(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C589CLL);
}

uint64_t tlv::parseV<audio::tlv::CallProgressToneId>(unint64_t *a1, int a2)
{
  unsigned __int16 *v3;
  uint64_t result;

  v3 = (unsigned __int16 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 2uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168C58FC(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C58F0);
}

_DWORD *audio::tlv::parseField(_DWORD *a1, const unsigned __int8 *a2, _DWORD *a3)
{
  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 4uLL);
  *a3 = *a1;
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 1), a2, 4uLL);
  a3[1] = a1[1];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 2), a2, 4uLL);
  a3[2] = a1[2];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 3), a2, 4uLL);
  a3[3] = a1[3];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 4), a2, 4uLL);
  a3[4] = a1[4];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 5), a2, 4uLL);
  a3[5] = a1[5];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 6), a2, 4uLL);
  a3[6] = a1[6];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 7), a2, 4uLL);
  a3[7] = a1[7];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 8), a2, 4uLL);
  a3[8] = a1[8];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 9), a2, 4uLL);
  a3[9] = a1[9];
  return a1 + 10;
}

{
  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 4uLL);
  *a3 = *a1;
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 1), a2, 4uLL);
  a3[1] = a1[1];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 2), a2, 4uLL);
  a3[2] = a1[2];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 3), a2, 4uLL);
  a3[3] = a1[3];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 4), a2, 4uLL);
  a3[4] = a1[4];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 5), a2, 4uLL);
  a3[5] = a1[5];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 6), a2, 4uLL);
  a3[6] = a1[6];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 7), a2, 4uLL);
  a3[7] = a1[7];
  return a1 + 8;
}

{
  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 4uLL);
  *a3 = *a1;
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 1), a2, 4uLL);
  a3[1] = a1[1];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 2), a2, 4uLL);
  a3[2] = a1[2];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 3), a2, 4uLL);
  a3[3] = a1[3];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 4), a2, 4uLL);
  a3[4] = a1[4];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 5), a2, 4uLL);
  a3[5] = a1[5];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 6), a2, 4uLL);
  a3[6] = a1[6];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 7), a2, 4uLL);
  a3[7] = a1[7];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 8), a2, 4uLL);
  a3[8] = a1[8];
  return a1 + 9;
}

{
  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 4uLL);
  *a3 = *a1;
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 1), a2, 4uLL);
  a3[1] = a1[1];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 2), a2, 4uLL);
  a3[2] = a1[2];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 3), a2, 4uLL);
  a3[3] = a1[3];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 4), a2, 4uLL);
  a3[4] = a1[4];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 5), a2, 4uLL);
  a3[5] = a1[5];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 6), a2, 4uLL);
  a3[6] = a1[6];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 7), a2, 4uLL);
  a3[7] = a1[7];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 8), a2, 4uLL);
  a3[8] = a1[8];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 9), a2, 4uLL);
  a3[9] = a1[9];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 10), a2, 4uLL);
  a3[10] = a1[10];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 11), a2, 4uLL);
  a3[11] = a1[11];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 12), a2, 4uLL);
  a3[12] = a1[12];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 13), a2, 4uLL);
  a3[13] = a1[13];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 14), a2, 4uLL);
  a3[14] = a1[14];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 15), a2, 4uLL);
  a3[15] = a1[15];
  return a1 + 16;
}

{
  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 4uLL);
  *a3 = *a1;
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 1), a2, 4uLL);
  a3[1] = a1[1];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 2), a2, 4uLL);
  a3[2] = a1[2];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 3), a2, 4uLL);
  a3[3] = a1[3];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 4), a2, 4uLL);
  a3[4] = a1[4];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 5), a2, 4uLL);
  a3[5] = a1[5];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 6), a2, 4uLL);
  a3[6] = a1[6];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 7), a2, 4uLL);
  a3[7] = a1[7];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 8), a2, 4uLL);
  a3[8] = a1[8];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 9), a2, 4uLL);
  a3[9] = a1[9];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 10), a2, 4uLL);
  a3[10] = a1[10];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 11), a2, 4uLL);
  a3[11] = a1[11];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 12), a2, 4uLL);
  a3[12] = a1[12];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 13), a2, 4uLL);
  a3[13] = a1[13];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 14), a2, 4uLL);
  a3[14] = a1[14];
  return a1 + 15;
}

{
  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 4uLL);
  *a3 = *a1;
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 1), a2, 4uLL);
  a3[1] = a1[1];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 2), a2, 4uLL);
  a3[2] = a1[2];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 3), a2, 4uLL);
  a3[3] = a1[3];
  return a1 + 4;
}

{
  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 4uLL);
  *a3 = *a1;
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 1), a2, 4uLL);
  a3[1] = a1[1];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 2), a2, 4uLL);
  a3[2] = a1[2];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 3), a2, 4uLL);
  a3[3] = a1[3];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 4), a2, 4uLL);
  a3[4] = a1[4];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 5), a2, 4uLL);
  a3[5] = a1[5];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 6), a2, 4uLL);
  a3[6] = a1[6];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 7), a2, 4uLL);
  a3[7] = a1[7];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 8), a2, 4uLL);
  a3[8] = a1[8];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 9), a2, 4uLL);
  a3[9] = a1[9];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 10), a2, 4uLL);
  a3[10] = a1[10];
  return a1 + 11;
}

_DWORD *tlv::parseV<audio::tlv::AudioInterfaceStatus>@<X0>(_DWORD **a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  _DWORD *result;

  *(_QWORD *)(a3 + 32) = 0;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  result = audio::tlv::parseField(*a1, (const unsigned __int8 *)*a1 + a2, (_DWORD *)a3);
  *a1 = result;
  return result;
}

void sub_2168C5A64(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
}

_DWORD *tlv::parseV<audio::tlv::AMRNBBitRateDistInfo>@<X0>(_DWORD **a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  _DWORD *result;

  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  result = audio::tlv::parseField(*a1, (const unsigned __int8 *)*a1 + a2, (_DWORD *)a3);
  *a1 = result;
  return result;
}

void sub_2168C5B98(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
}

_DWORD *tlv::parseV<audio::tlv::AMRWBBitRateDistInfo>@<X0>(_DWORD **a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  _DWORD *result;

  *(_DWORD *)(a3 + 32) = 0;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  result = audio::tlv::parseField(*a1, (const unsigned __int8 *)*a1 + a2, (_DWORD *)a3);
  *a1 = result;
  return result;
}

void sub_2168C5CE8(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
}

_DWORD *tlv::parseV<audio::tlv::EVSBitRateDistInfo>@<X0>(_DWORD **a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  _DWORD *result;

  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  result = audio::tlv::parseField(*a1, (const unsigned __int8 *)*a1 + a2, (_DWORD *)a3);
  *a1 = result;
  return result;
}

void sub_2168C5EE0(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
}

_DWORD *tlv::parseV<audio::tlv::DistortionTypesDistUL>@<X0>(_DWORD **a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  _DWORD *result;

  *(_DWORD *)(a3 + 32) = 0;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  result = audio::tlv::parseField(*a1, (const unsigned __int8 *)*a1 + a2, (_DWORD *)a3);
  *a1 = result;
  return result;
}

void sub_2168C5F30(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
}

_DWORD *tlv::parseV<audio::tlv::DistortionTypesDistDL>@<X0>(_DWORD **a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  _DWORD *result;

  *(_OWORD *)(a3 + 44) = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)a3 = 0u;
  result = audio::tlv::parseField(*a1, (const unsigned __int8 *)*a1 + a2, (_DWORD *)a3);
  *a1 = result;
  return result;
}

void sub_2168C6114(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
}

uint64_t tlv::parseV<audio::tlv::AudioDistortionInfo>(_DWORD **a1, int a2)
{
  uint64_t v3;
  int v4;

  v4 = 0;
  v3 = 0;
  *a1 = qos::tlv::parseField(*a1, (const unsigned __int8 *)*a1 + a2, &v3);
  return v3;
}

void sub_2168C6170(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C6158);
}

uint64_t tlv::parseV<audio::tlv::AudioDistortionRatAndVocoderInfo>(_DWORD **a1, int a2)
{
  _QWORD v3[2];

  v3[0] = 0;
  v3[1] = 0;
  *a1 = audio::tlv::parseField(*a1, (const unsigned __int8 *)*a1 + a2, v3);
  return v3[0];
}

void sub_2168C6248(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C6234);
}

_DWORD *tlv::parseV<audio::tlv::RadioMetrics>@<X0>(_DWORD **a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  _DWORD *result;

  *(_OWORD *)(a3 + 28) = 0u;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  result = audio::tlv::parseField(*a1, (const unsigned __int8 *)*a1 + a2, (_DWORD *)a3);
  *a1 = result;
  return result;
}

void sub_2168C63C4(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
}

_DWORD *tlv::parseV<audio::tlv::AudioJBMStat>@<X0>(_DWORD **a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  _DWORD *result;

  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  result = audio::tlv::parseField(*a1, (const unsigned __int8 *)*a1 + a2, (_DWORD *)a3);
  *a1 = result;
  return result;
}

void sub_2168C6410(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
}

uint64_t tlv::parseV<nas::tlv::NetworkNameSource>(unint64_t *a1, int a2)
{
  unsigned int *v3;
  uint64_t result;

  v3 = (unsigned int *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 4uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168C645C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C6450);
}

BOOL tlv::parseV<nas::tlv::PlmnMode>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  _BOOL8 result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3 != 0;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168C64B0(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C64A4);
}

unsigned __int8 *nas::tlv::parseField(unint64_t a1, const unsigned __int8 *a2, uint64_t a3)
{
  unsigned __int8 *v6;
  unint64_t v7;

  tlv::throwIfNotEnoughBytes(a1, a2, 2uLL);
  *(_WORD *)a3 = *(_WORD *)a1;
  tlv::throwIfNotEnoughBytes(a1 + 2, a2, 2uLL);
  *(_WORD *)(a3 + 2) = *(_WORD *)(a1 + 2);
  tlv::throwIfNotEnoughBytes(a1 + 4, a2, 1uLL);
  *(_BYTE *)(a3 + 4) = *(_BYTE *)(a1 + 4);
  v6 = nas::tlv::parseField((unsigned __int8 *)(a1 + 5), a2, (int *)(a3 + 8));
  tlv::throwIfNotEnoughBytes((unint64_t)v6, a2, 1uLL);
  *(_BYTE *)(a3 + 12) = *v6 != 0;
  tlv::throwIfNotEnoughBytes((unint64_t)(v6 + 1), a2, 1uLL);
  v7 = v6[1];
  v6 += 2;
  tlv::throwIfNotEnoughBytes((unint64_t)v6, a2, v7);
  std::string::__assign_trivial[abi:ne180100]<unsigned char const*,unsigned char const*>((std::string *)(a3 + 16), (std::string::value_type *)v6, (std::string::value_type *)&v6[v7], v7);
  return &v6[v7];
}

uint64_t tlv::parseV<nas::tlv::CDMAServiceStatus>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  const unsigned __int8 *v4;
  int v5;
  int v6;

  v3 = (unsigned __int8 *)*a1;
  v4 = (const unsigned __int8 *)(*a1 + a2);
  tlv::throwIfNotEnoughBytes(*a1, v4, 1uLL);
  v5 = *v3;
  tlv::throwIfNotEnoughBytes((unint64_t)(v3 + 1), v4, 1uLL);
  v6 = v3[1] != 0;
  *a1 = (unint64_t)(v3 + 2);
  return v5 | (v6 << 8);
}

void sub_2168C6614(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C6600);
}

uint64_t tlv::parseV<nas::tlv::HDRServiceStatus>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  const unsigned __int8 *v4;
  int v5;
  int v6;

  v3 = (unsigned __int8 *)*a1;
  v4 = (const unsigned __int8 *)(*a1 + a2);
  tlv::throwIfNotEnoughBytes(*a1, v4, 1uLL);
  v5 = *v3;
  tlv::throwIfNotEnoughBytes((unint64_t)(v3 + 1), v4, 1uLL);
  v6 = v3[1] != 0;
  *a1 = (unint64_t)(v3 + 2);
  return v5 | (v6 << 8);
}

void sub_2168C6694(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C6680);
}

uint64_t tlv::parseV<nas::tlv::TDSCDMAServiceStatus>(_BYTE **a1, int a2)
{
  unsigned __int16 v3;
  unsigned __int8 v4;

  v4 = 0;
  v3 = 0;
  *a1 = nas::tlv::parseField(*a1, &(*a1)[a2], &v3);
  return v3 | (v4 << 16);
}

void sub_2168C66F4(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C66D8);
}

unint64_t tlv::parseV<nas::tlv::CDMASysInfo>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  unint64_t result;

  a3[1] = 0u;
  a3[2] = 0u;
  *a3 = 0u;
  result = nas::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), (uint64_t)a3);
  *a1 = result;
  return result;
}

void sub_2168C6A90(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
}

unint64_t tlv::parseV<nas::tlv::HDRSysInfo>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  unint64_t result;

  *a3 = 0;
  a3[1] = 0;
  *(_QWORD *)((char *)a3 + 23) = 0;
  a3[2] = 0;
  result = nas::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), (uint64_t)a3);
  *a1 = result;
  return result;
}

void sub_2168C6CD8(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
}

unint64_t tlv::parseV<nas::tlv::GSMSysInfo>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  unint64_t result;

  *(_DWORD *)(a3 + 32) = 0;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  result = nas::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), a3);
  *a1 = result;
  return result;
}

void sub_2168C6FD8(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
}

unint64_t tlv::parseV<nas::tlv::WCDMASysInfo>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  unint64_t result;

  *(_QWORD *)(a3 + 32) = 0;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  result = nas::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), a3);
  *a1 = result;
  return result;
}

void sub_2168C7300(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
}

unint64_t tlv::parseV<nas::tlv::NR5GSysInfo>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  unint64_t result;

  *(_DWORD *)(a3 + 32) = 0;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  result = nas::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), a3);
  *a1 = result;
  return result;
}

void sub_2168C7350(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
}

uint64_t tlv::parseV<nas::tlv::NR5GTAC>(unint64_t *a1, int a2)
{
  unsigned __int16 *v3;
  uint64_t result;

  v3 = (unsigned __int16 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 3uLL);
  result = *v3 | (*((unsigned __int8 *)v3 + 2) << 16);
  *a1 = (unint64_t)v3 + 3;
  return result;
}

void sub_2168C73A8(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C739CLL);
}

uint64_t tlv::parseV<nas::tlv::NR5GCellID>(unint64_t *a1, int a2)
{
  uint64_t *v3;
  uint64_t result;

  v3 = (uint64_t *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 8uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168C73F4(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C73E8);
}

uint64_t tlv::parseV<nas::tlv::NR5GServiceAreaRestrictionInfo>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168C7440(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C7434);
}

unsigned __int8 *nas::tlv::parseField(unint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  __int16 v6;
  __int16 v7;

  tlv::throwIfNotEnoughBytes(a1, a2, 1uLL);
  *(_BYTE *)a3 = *(_BYTE *)a1 != 0;
  tlv::throwIfNotEnoughBytes(a1 + 1, a2, 1uLL);
  *(_BYTE *)(a3 + 1) = *(_BYTE *)(a1 + 1);
  tlv::throwIfNotEnoughBytes(a1 + 2, a2, 1uLL);
  *(_BYTE *)(a3 + 2) = *(_BYTE *)(a1 + 2) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 3, a2, 1uLL);
  *(_BYTE *)(a3 + 3) = *(_BYTE *)(a1 + 3);
  tlv::throwIfNotEnoughBytes(a1 + 4, a2, 1uLL);
  *(_BYTE *)(a3 + 4) = *(_BYTE *)(a1 + 4) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 5, a2, 1uLL);
  *(_BYTE *)(a3 + 5) = *(_BYTE *)(a1 + 5);
  tlv::throwIfNotEnoughBytes(a1 + 6, a2, 1uLL);
  *(_BYTE *)(a3 + 6) = *(_BYTE *)(a1 + 6) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 7, a2, 1uLL);
  *(_BYTE *)(a3 + 7) = *(_BYTE *)(a1 + 7) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 8, a2, 1uLL);
  *(_BYTE *)(a3 + 8) = *(_BYTE *)(a1 + 8) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 9, a2, 2uLL);
  *(_WORD *)(a3 + 10) = *(_WORD *)(a1 + 9);
  tlv::throwIfNotEnoughBytes(a1 + 11, a2, 1uLL);
  *(_BYTE *)(a3 + 12) = *(_BYTE *)(a1 + 11) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 12, a2, 4uLL);
  *(_DWORD *)(a3 + 16) = *(_DWORD *)(a1 + 12);
  tlv::throwIfNotEnoughBytes(a1 + 16, a2, 1uLL);
  *(_BYTE *)(a3 + 20) = *(_BYTE *)(a1 + 16) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 17, a2, 1uLL);
  *(_BYTE *)(a3 + 21) = *(_BYTE *)(a1 + 17);
  tlv::throwIfNotEnoughBytes(a1 + 18, a2, 1uLL);
  *(_BYTE *)(a3 + 22) = *(_BYTE *)(a1 + 18);
  tlv::throwIfNotEnoughBytes(a1 + 19, a2, 1uLL);
  *(_BYTE *)(a3 + 23) = *(_BYTE *)(a1 + 19) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 20, a2, 3uLL);
  v6 = *(_WORD *)(a1 + 20);
  *(_BYTE *)(a3 + 26) = *(_BYTE *)(a1 + 22);
  *(_WORD *)(a3 + 24) = v6;
  tlv::throwIfNotEnoughBytes(a1 + 23, a2, 3uLL);
  v7 = *(_WORD *)(a1 + 23);
  *(_BYTE *)(a3 + 29) = *(_BYTE *)(a1 + 25);
  *(_WORD *)(a3 + 27) = v7;
  tlv::throwIfNotEnoughBytes(a1 + 26, a2, 1uLL);
  *(_BYTE *)(a3 + 30) = *(_BYTE *)(a1 + 26) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 27, a2, 1uLL);
  *(_BYTE *)(a3 + 31) = *(_BYTE *)(a1 + 27);
  tlv::throwIfNotEnoughBytes(a1 + 28, a2, 1uLL);
  *(_BYTE *)(a3 + 32) = *(_BYTE *)(a1 + 28) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 29, a2, 1uLL);
  *(_BYTE *)(a3 + 33) = *(_BYTE *)(a1 + 29);
  std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((_QWORD *)(a3 + 40), (char *)(a1 + 30), (char *)a2, (unint64_t)&a2[-a1 - 30]);
  return a2;
}

unsigned __int8 *tlv::parseV<nas::tlv::TDSCDMASysInfo>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  unint64_t v4;
  unsigned __int8 *v5;
  unsigned __int8 *result;

  a3[2] = 0u;
  a3[3] = 0u;
  *a3 = 0u;
  a3[1] = 0u;
  v4 = *a1;
  v5 = (unsigned __int8 *)(v4 + a2);
  result = nas::tlv::parseField(v4, v5, (uint64_t)a3);
  *a1 = (unint64_t)v5;
  return result;
}

void sub_2168C7754(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C7744);
}

void sub_2168C7764(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)(v1 + 40);
  if (v3)
  {
    *(_QWORD *)(v1 + 48) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t tlv::parseV<nas::tlv::CDMASysInfoEx>(unint64_t *a1, int a2)
{
  unsigned __int16 *v3;
  const unsigned __int8 *v4;
  unsigned int v5;
  int v6;

  v3 = (unsigned __int16 *)*a1;
  v4 = (const unsigned __int8 *)(*a1 + a2);
  tlv::throwIfNotEnoughBytes(*a1, v4, 2uLL);
  v5 = *v3;
  tlv::throwIfNotEnoughBytes((unint64_t)(v3 + 1), v4, 2uLL);
  v6 = v3[1];
  *a1 = (unint64_t)(v3 + 2);
  return (v6 << 16) | v5;
}

void sub_2168C77E8(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C77D4);
}

uint64_t tlv::parseV<nas::tlv::HDRSysInfoEx>(unint64_t *a1, int a2)
{
  unsigned __int16 *v3;
  uint64_t result;

  v3 = (unsigned __int16 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 2uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168C7834(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C7828);
}

uint64_t tlv::parseV<nas::tlv::GSMSysInfoEx>(unint64_t *a1, int a2)
{
  unsigned __int16 *v3;
  const unsigned __int8 *v4;
  unsigned int v5;
  uint64_t v6;

  v3 = (unsigned __int16 *)*a1;
  v4 = (const unsigned __int8 *)(*a1 + a2);
  tlv::throwIfNotEnoughBytes(*a1, v4, 2uLL);
  v5 = *v3;
  tlv::throwIfNotEnoughBytes((unint64_t)(v3 + 1), v4, 4uLL);
  v6 = *(unsigned int *)(v3 + 1);
  *a1 = (unint64_t)(v3 + 3);
  return (v6 << 32) | v5;
}

void sub_2168C78B4(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C789CLL);
}

uint64_t tlv::parseV<nas::tlv::WCDMASysInfoEx>(unint64_t *a1, int a2)
{
  unsigned __int16 *v3;
  const unsigned __int8 *v4;
  unsigned int v5;
  uint64_t v6;

  v3 = (unsigned __int16 *)*a1;
  v4 = (const unsigned __int8 *)(*a1 + a2);
  tlv::throwIfNotEnoughBytes(*a1, v4, 2uLL);
  v5 = *v3;
  tlv::throwIfNotEnoughBytes((unint64_t)(v3 + 1), v4, 4uLL);
  v6 = *(unsigned int *)(v3 + 1);
  *a1 = (unint64_t)(v3 + 3);
  return (v6 << 32) | v5;
}

void sub_2168C7934(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C791CLL);
}

uint64_t tlv::parseV<nas::tlv::NR5GEmergencyServiceInfo>(unint64_t *a1, int a2)
{
  unsigned int *v3;
  const unsigned __int8 *v4;
  unsigned int v5;
  uint64_t v6;

  v3 = (unsigned int *)*a1;
  v4 = (const unsigned __int8 *)(*a1 + a2);
  tlv::throwIfNotEnoughBytes(*a1, v4, 4uLL);
  v5 = *v3;
  tlv::throwIfNotEnoughBytes((unint64_t)(v3 + 1), v4, 4uLL);
  v6 = v3[1];
  *a1 = (unint64_t)(v3 + 2);
  return (v6 << 32) | v5;
}

void sub_2168C79B4(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C799CLL);
}

uint64_t tlv::parseV<nas::tlv::NR5GVoiceSupportInfo>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168C7A00(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C79F4);
}

BOOL tlv::parseV<nas::tlv::LTEVoiceSupportSysInfo>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  _BOOL8 result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3 != 0;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168C7A54(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C7A48);
}

uint64_t tlv::parseV<nas::tlv::GSMCipherDomainSysInfo>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168C7AA0(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C7A94);
}

uint64_t tlv::parseV<nas::tlv::WCDMACipherDomainSysInfo>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168C7AEC(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C7AE0);
}

uint64_t tlv::parseV<nas::tlv::CDMADerivedMCC>(unint64_t *a1, int a2)
{
  unsigned __int16 *v3;
  uint64_t result;

  v3 = (unsigned __int16 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 2uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168C7B38(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C7B2CLL);
}

uint64_t tlv::parseV<nas::tlv::HDRSubnetMaskLength>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168C7B84(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C7B78);
}

BOOL tlv::parseV<nas::tlv::AgentVoiceSupportStatus>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  _BOOL8 result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3 != 0;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168C7BD8(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C7BCCLL);
}

BOOL tlv::parseV<nas::tlv::CSVoiceSupportStatus>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  _BOOL8 result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3 != 0;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168C7C2C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C7C20);
}

BOOL tlv::parseV<nas::tlv::IsSatelliteSystem>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  _BOOL8 result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3 != 0;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168C7C80(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C7C74);
}

unint64_t tlv::parseV<nas::tlv::SrvProviderName>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  unint64_t result;

  *a3 = 0u;
  a3[1] = 0u;
  result = nas::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), (uint64_t)a3);
  *a1 = result;
  return result;
}

void sub_2168C7E04(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C7DF8);
}

void sub_2168C7E14(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)(v1 + 8);
  if (v3)
  {
    *(_QWORD *)(v1 + 16) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t tlv::parseV<nas::tlv::IpPrefInfo>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  const unsigned __int8 *v4;
  unsigned int v5;

  v3 = (unsigned __int8 *)*a1;
  v4 = (const unsigned __int8 *)(*a1 + a2);
  tlv::throwIfNotEnoughBytes(*a1, v4, 1uLL);
  v5 = *v3;
  tlv::throwIfNotEnoughBytes((unint64_t)(v3 + 1), v4, 8uLL);
  *a1 = (unint64_t)(v3 + 9);
  return v5;
}

void sub_2168C7E94(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C7E80);
}

unsigned int *tlv::parseV<nas::tlv::NetworkNameSourceList>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, std::vector<unsigned int> *a3@<X8>)
{
  unsigned int *result;

  a3->__begin_ = 0;
  a3->__end_ = 0;
  a3->__end_cap_.__value_ = 0;
  result = qos::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = (unsigned __int8 *)result;
  return result;
}

void sub_2168C7EE4(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C7ED8);
}

void sub_2168C7EF4(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t tlv::parseV<nas::tlv::LTEEMBMSCoverageInfo>(unint64_t *a1, int a2)
{
  unsigned int *v3;
  uint64_t result;

  v3 = (unsigned int *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 4uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168C7F48(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C7F3CLL);
}

char *nas::tlv::parseField(nas::tlv *this, const unsigned __int8 *a2, unsigned __int8 *a3, nas::tlv::EvoNitzInfo *a4)
{
  nas::tlv *v6;
  unint64_t v7;
  unint64_t v8;
  char *v9;

  v6 = this;
  tlv::throwIfNotEnoughBytes((unint64_t)this, a2, 1uLL);
  *a3 = *(_BYTE *)v6;
  tlv::throwIfNotEnoughBytes((unint64_t)v6 + 1, a2, 1uLL);
  a3[1] = *((_BYTE *)v6 + 1);
  tlv::throwIfNotEnoughBytes((unint64_t)v6 + 2, a2, 1uLL);
  a3[2] = *((_BYTE *)v6 + 2);
  tlv::throwIfNotEnoughBytes((unint64_t)v6 + 3, a2, 1uLL);
  a3[3] = *((_BYTE *)v6 + 3);
  tlv::throwIfNotEnoughBytes((unint64_t)v6 + 4, a2, 1uLL);
  v7 = *((unsigned __int8 *)v6 + 4);
  v6 = (nas::tlv *)((char *)v6 + 5);
  tlv::throwIfNotEnoughBytes((unint64_t)v6, a2, v7);
  std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((_QWORD *)a3 + 1, (char *)v6, (char *)v6 + v7, v7);
  tlv::throwIfNotEnoughBytes((unint64_t)v6 + v7, a2, 1uLL);
  v9 = (char *)v6 + v7 + 1;
  v8 = *((unsigned __int8 *)v6 + v7);
  tlv::throwIfNotEnoughBytes((unint64_t)v9, a2, v8);
  std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((_QWORD *)a3 + 4, v9, &v9[v8], v8);
  return &v9[v8];
}

char *tlv::parseV<nas::tlv::EvoNitzInfo>@<X0>(nas::tlv **a1@<X0>, int a2@<W1>, nas::tlv::EvoNitzInfo *a3@<X3>, uint64_t a4@<X8>)
{
  char *result;

  *(_QWORD *)(a4 + 48) = 0;
  *(_OWORD *)(a4 + 16) = 0u;
  *(_OWORD *)(a4 + 32) = 0u;
  *(_OWORD *)a4 = 0u;
  result = nas::tlv::parseField(*a1, (const unsigned __int8 *)*a1 + a2, (unsigned __int8 *)a4, a3);
  *a1 = (nas::tlv *)result;
  return result;
}

void sub_2168C80B4(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C80A8);
}

void sub_2168C80C4(_Unwind_Exception *a1)
{
  nas::tlv::EvoNitzInfo *v1;

  nas::tlv::EvoNitzInfo::~EvoNitzInfo(v1);
  _Unwind_Resume(a1);
}

void nas::tlv::EvoNitzInfo::~EvoNitzInfo(nas::tlv::EvoNitzInfo *this)
{
  void *v2;
  void *v3;

  v2 = (void *)*((_QWORD *)this + 4);
  if (v2)
  {
    *((_QWORD *)this + 5) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 1);
  if (v3)
  {
    *((_QWORD *)this + 2) = v3;
    operator delete(v3);
  }
}

char *tlv::parseV<nas::tlv::Iccid>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  char *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = wds::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), a3);
  *a1 = (unint64_t)result;
  return result;
}

void sub_2168C8154(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C8148);
}

void sub_2168C8164(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

BOOL tlv::parseV<nas::tlv::ScanCompletionStatus>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  _BOOL8 result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3 != 0;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168C81C0(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C81B4);
}

uint64_t tlv::parseV<nas::tlv::ScanStatus>(unint64_t *a1, int a2)
{
  unsigned __int16 *v3;
  uint64_t result;

  v3 = (unsigned __int16 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 2uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168C820C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C8200);
}

unsigned __int8 *nas::tlv::parseField(unsigned __int16 *a1, const unsigned __int8 *a2, uint64_t *a3)
{
  unsigned __int8 *v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  unsigned __int8 *result;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 2uLL);
  v7 = *a1;
  v6 = (unsigned __int8 *)(a1 + 1);
  std::vector<nas::tlv::IncrementalNetworkInterfaceItem>::resize(a3, v7);
  v8 = *a3;
  v9 = a3[1];
  while (1)
  {
    result = v6;
    if (v8 == v9)
      break;
    v6 = nas::tlv::parseField((unint64_t)v6, a2, v8);
    v8 += 40;
  }
  return result;
}

unsigned __int8 *tlv::parseV<nas::tlv::IncrementalNetworkInfo>@<X0>(unsigned __int16 **a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  unsigned __int8 *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = nas::tlv::parseField(*a1, (const unsigned __int8 *)*a1 + a2, a3);
  *a1 = (unsigned __int16 *)result;
  return result;
}

void sub_2168C82CC(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C82BCLL);
}

void sub_2168C82DC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::vector<nas::tlv::IncrementalNetworkInterfaceItem>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

uint64_t *tlv::writeV<nas::tlv::ManualNetworkRegisterInformation>(uint64_t *result, uint64_t a2)
{
  uint64_t v2;

  v2 = *result;
  *(_WORD *)v2 = *(_WORD *)a2;
  *(_WORD *)(v2 + 2) = *(_WORD *)(a2 + 2);
  *(_BYTE *)(v2 + 4) = *(_BYTE *)(a2 + 4);
  *result = v2 + 5;
  return result;
}

char *nas::tlv::parseField(nas::tlv *this, const unsigned __int8 *a2, const unsigned __int8 *a3, nas::tlv::PlmnNameInfo *a4)
{
  unint64_t v6;
  char *v7;

  v6 = nas::tlv::parseField((unint64_t)this, a2, (uint64_t)a3);
  v7 = nas::tlv::parseField(v6, a2, (uint64_t)(a3 + 32));
  return nas::tlv::parseField((unint64_t)v7, a2, (uint64_t)(a3 + 64));
}

char *tlv::parseV<nas::tlv::PlmnNameInfo>@<X0>(nas::tlv **a1@<X0>, int a2@<W1>, nas::tlv::PlmnNameInfo *a3@<X3>, uint64_t a4@<X8>)
{
  char *result;

  *(_OWORD *)(a4 + 64) = 0u;
  *(_OWORD *)(a4 + 80) = 0u;
  *(_OWORD *)(a4 + 32) = 0u;
  *(_OWORD *)(a4 + 48) = 0u;
  *(_OWORD *)a4 = 0u;
  *(_OWORD *)(a4 + 16) = 0u;
  result = nas::tlv::parseField(*a1, (const unsigned __int8 *)*a1 + a2, (const unsigned __int8 *)a4, a3);
  *a1 = (nas::tlv *)result;
  return result;
}

void sub_2168C8398(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C838CLL);
}

void sub_2168C83A8(_Unwind_Exception *a1)
{
  nas::tlv::PlmnNameInfo *v1;

  nas::tlv::PlmnNameInfo::~PlmnNameInfo(v1);
  _Unwind_Resume(a1);
}

void nas::tlv::PlmnNameInfo::~PlmnNameInfo(nas::tlv::PlmnNameInfo *this)
{
  void *v2;
  void *v3;
  void *v4;

  v2 = (void *)*((_QWORD *)this + 9);
  if (v2)
  {
    *((_QWORD *)this + 10) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 5);
  if (v3)
  {
    *((_QWORD *)this + 6) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 1);
  if (v4)
  {
    *((_QWORD *)this + 2) = v4;
    operator delete(v4);
  }
}

uint64_t tlv::parseV<nas::tlv::UniversalTime>(unint64_t *a1, int a2)
{
  uint64_t v3;

  v3 = 0;
  *a1 = nas::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), (uint64_t)&v3);
  return v3;
}

void sub_2168C851C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C8508);
}

uint64_t tlv::parseV<nas::tlv::TimeZone>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168C8564(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C8558);
}

uint64_t tlv::parseV<nas::tlv::DatelightSavings>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168C85B0(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C85A4);
}

uint64_t tlv::parseV<nas::tlv::TimeFromRadioInterface>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168C85FC(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C85F0);
}

unint64_t tlv::parseV<nas::tlv::TimeFromPLMN>(unint64_t *a1, int a2)
{
  unsigned __int16 *v3;
  const unsigned __int8 *v4;
  unint64_t v5;
  unint64_t v6;

  v3 = (unsigned __int16 *)*a1;
  v4 = (const unsigned __int8 *)(*a1 + a2);
  tlv::throwIfNotEnoughBytes(*a1, v4, 3uLL);
  v5 = *v3 | ((unint64_t)*((unsigned __int8 *)v3 + 2) << 16);
  tlv::throwIfNotEnoughBytes((unint64_t)v3 + 3, v4, 3uLL);
  v6 = ((unint64_t)*(unsigned __int16 *)((char *)v3 + 3) << 24) | ((unint64_t)*((unsigned __int8 *)v3 + 5) << 40) | v5;
  *a1 = (unint64_t)(v3 + 3);
  return v6;
}

void sub_2168C868C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C8678);
}

BOOL tlv::parseV<nas::tlv::SysInfoNoChange>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  _BOOL8 result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3 != 0;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168C86DC(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C86D0);
}

char *tlv::parseV<nas::tlv::WCDMAClosedSubscriberGroup>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  char *result;

  *a3 = 0u;
  a3[1] = 0u;
  result = nas::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), (uint64_t)a3);
  *a1 = (unint64_t)result;
  return result;
}

void sub_2168C87C0(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C87B4);
}

void sub_2168C87D0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)(v1 + 8);
  if (v3)
  {
    *(_QWORD *)(v1 + 16) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *tlv::parseV<nas::tlv::PlmnShortName>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  char *result;

  *a3 = 0u;
  a3[1] = 0u;
  result = nas::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), (uint64_t)a3);
  *a1 = (unint64_t)result;
  return result;
}

void sub_2168C8828(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C881CLL);
}

void sub_2168C8838(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)(v1 + 8);
  if (v3)
  {
    *(_QWORD *)(v1 + 16) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *tlv::parseV<nas::tlv::PlmnLongName>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  char *result;

  *a3 = 0u;
  a3[1] = 0u;
  result = nas::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), (uint64_t)a3);
  *a1 = (unint64_t)result;
  return result;
}

void sub_2168C8890(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C8884);
}

void sub_2168C88A0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)(v1 + 8);
  if (v3)
  {
    *(_QWORD *)(v1 + 16) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t tlv::parseV<nas::tlv::RadioIf>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168C88F4(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C88E8);
}

uint64_t tlv::parseV<nas::tlv::ServiceDomain>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168C8940(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C8934);
}

uint64_t tlv::parseV<nas::tlv::RejCause>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168C898C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C8980);
}

unint64_t tlv::size<nas::tlv::IpRegistrationStates>(_QWORD *a1)
{
  uint64_t v1;

  v1 = a1[1];
  if (*a1 == v1)
    return 4;
  else
    return 5 * ((unint64_t)(v1 - *a1 - 8) >> 3) + 9;
}

_BYTE **tlv::writeV<nas::tlv::IpRegistrationStates>(_BYTE **result, _DWORD *a2)
{
  _BYTE *v2;
  _BYTE *v3;
  uint64_t v4;
  uint64_t v5;
  _BYTE *v6;

  v2 = *result;
  *v2 = (a2[2] - *a2) >> 3;
  v3 = v2 + 1;
  v4 = *(_QWORD *)a2;
  v5 = *((_QWORD *)a2 + 1);
  if (*(_QWORD *)a2 == v5)
  {
    v6 = v3;
  }
  else
  {
    do
    {
      *(_DWORD *)v3 = *(_DWORD *)v4;
      v6 = v3 + 5;
      v3[4] = *(_BYTE *)(v4 + 4);
      v4 += 8;
      v3 += 5;
    }
    while (v4 != v5);
  }
  *result = v6;
  return result;
}

uint64_t tlv::parseV<nas::tlv::E911Sub>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168C8A60(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C8A54);
}

uint64_t tlv::parseV<nas::tlv::T3402Timer>(unint64_t *a1, int a2)
{
  unsigned int *v3;
  uint64_t result;

  v3 = (unsigned int *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 4uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168C8AAC(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C8AA0);
}

uint64_t tlv::parseV<nas::tlv::CambioMode>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168C8AF8(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C8AECLL);
}

unint64_t tlv::parseV<nas::tlv::ManuallySelectedPLMN>(unint64_t *a1, int a2)
{
  unsigned __int16 *v3;
  const unsigned __int8 *v4;
  unint64_t v5;
  unint64_t v6;

  v3 = (unsigned __int16 *)*a1;
  v4 = (const unsigned __int8 *)(*a1 + a2);
  tlv::throwIfNotEnoughBytes(*a1, v4, 3uLL);
  v5 = *v3 | ((unint64_t)*((unsigned __int8 *)v3 + 2) << 16);
  tlv::throwIfNotEnoughBytes((unint64_t)v3 + 3, v4, 3uLL);
  v6 = ((unint64_t)*(unsigned __int16 *)((char *)v3 + 3) << 24) | ((unint64_t)*((unsigned __int8 *)v3 + 5) << 40) | v5;
  *a1 = (unint64_t)(v3 + 3);
  return v6;
}

void sub_2168C8B88(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C8B74);
}

unint64_t tlv::parseV<nas::tlv::BasebandSelectedPLMN>(unint64_t *a1, int a2)
{
  unsigned __int16 *v3;
  const unsigned __int8 *v4;
  unint64_t v5;
  unint64_t v6;

  v3 = (unsigned __int16 *)*a1;
  v4 = (const unsigned __int8 *)(*a1 + a2);
  tlv::throwIfNotEnoughBytes(*a1, v4, 3uLL);
  v5 = *v3 | ((unint64_t)*((unsigned __int8 *)v3 + 2) << 16);
  tlv::throwIfNotEnoughBytes((unint64_t)v3 + 3, v4, 3uLL);
  v6 = ((unint64_t)*(unsigned __int16 *)((char *)v3 + 3) << 24) | ((unint64_t)*((unsigned __int8 *)v3 + 5) << 40) | v5;
  *a1 = (unint64_t)(v3 + 3);
  return v6;
}

void sub_2168C8C14(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C8C00);
}

uint64_t tlv::parseV<nas::tlv::CnfReason>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  const unsigned __int8 *v4;
  unsigned int v5;
  uint64_t v6;

  v3 = (unsigned __int8 *)*a1;
  v4 = (const unsigned __int8 *)(*a1 + a2);
  tlv::throwIfNotEnoughBytes(*a1, v4, 1uLL);
  v5 = *v3;
  tlv::throwIfNotEnoughBytes((unint64_t)(v3 + 1), v4, 4uLL);
  v6 = *(unsigned int *)(v3 + 1);
  *a1 = (unint64_t)(v3 + 5);
  return (v6 << 32) | v5;
}

void sub_2168C8C90(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C8C78);
}

uint64_t tlv::size<nas::tlv::WiFiNetworkDescription>()
{
  return 41;
}

__n128 tlv::writeV<nas::tlv::WiFiNetworkDescription>(uint64_t *a1, uint64_t a2)
{
  uint64_t v2;
  __n128 result;
  __int128 v4;
  int v5;

  v2 = *a1;
  result = *(__n128 *)a2;
  v4 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)v2 = *(_OWORD *)a2;
  *(_OWORD *)(v2 + 16) = v4;
  v5 = *(_DWORD *)(a2 + 32);
  *(_WORD *)(v2 + 36) = *(_WORD *)(a2 + 36);
  *(_DWORD *)(v2 + 32) = v5;
  *a1 = v2 + 38;
  return result;
}

uint64_t *tlv::writeV<nas::tlv::PreferredPlmnImsi>(uint64_t *result, uint64_t a2)
{
  uint64_t v2;

  v2 = *result;
  *(_BYTE *)v2 = *(_BYTE *)a2;
  *(_QWORD *)(v2 + 1) = *(_QWORD *)(a2 + 1);
  *result = v2 + 9;
  return result;
}

_BYTE *tlv::writeV<nas::tlv::PreferredPlmnList>(_BYTE **a1, _DWORD *a2)
{
  _BYTE *result;

  result = nas::tlv::writeField(*a1, a2);
  *a1 = result;
  return result;
}

BOOL tlv::parseV<nas::tlv::ChecksumResult>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  _BOOL8 result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3 != 0;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168C8DC8(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C8DBCLL);
}

uint64_t tlv::parseV<nas::tlv::SysMode>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168C8E14(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C8E08);
}

uint64_t tlv::parseV<nas::tlv::GeoMcc>(unint64_t *a1, int a2)
{
  unsigned __int16 *v3;
  uint64_t result;

  v3 = (unsigned __int16 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 3uLL);
  result = *v3 | (*((unsigned __int8 *)v3 + 2) << 16);
  *a1 = (unint64_t)v3 + 3;
  return result;
}

void sub_2168C8E6C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C8E60);
}

uint64_t tlv::parseV<nas::tlv::GeoMnc>(unint64_t *a1, int a2)
{
  unsigned __int16 *v3;
  uint64_t result;

  v3 = (unsigned __int16 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 3uLL);
  result = *v3 | (*((unsigned __int8 *)v3 + 2) << 16);
  *a1 = (unint64_t)v3 + 3;
  return result;
}

void sub_2168C8EC4(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C8EB8);
}

BOOL tlv::parseV<nas::tlv::SmsReady>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  _BOOL8 result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3 != 0;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168C8F18(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C8F0CLL);
}

void std::vector<nas::tlv::IncrementalNetworkInterfaceItem>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<nas::tlv::IncrementalNetworkInterfaceItem>::__clear[abi:ne180100]((uint64_t *)v2);
    operator delete(**a1);
  }
}

void std::vector<nas::tlv::IncrementalNetworkInterfaceItem>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v2;
  uint64_t i;

  v2 = *a1;
  for (i = a1[1]; i != v2; i -= 40)
  {
    if (*(char *)(i - 1) < 0)
      operator delete(*(void **)(i - 24));
  }
  a1[1] = v2;
}

void std::vector<nas::tlv::IncrementalNetworkInterfaceItem>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  BOOL v5;
  unint64_t v6;
  uint64_t v7;

  v3 = a1[1];
  v4 = 0xCCCCCCCCCCCCCCCDLL * ((v3 - *a1) >> 3);
  v5 = a2 >= v4;
  v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    std::vector<nas::tlv::IncrementalNetworkInterfaceItem>::__append(a1, v6);
  }
  else if (!v5)
  {
    v7 = *a1 + 40 * a2;
    while (v3 != v7)
    {
      if (*(char *)(v3 - 1) < 0)
        operator delete(*(void **)(v3 - 24));
      v3 -= 40;
    }
    a1[1] = v7;
  }
}

uint64_t std::vector<nas::tlv::IncrementalNetworkInterfaceItem>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  _QWORD *v13;
  char *v14;
  char *v15;
  _QWORD v16[5];

  v6 = a1[2];
  result = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD **)(result - 8);
  if (0xCCCCCCCCCCCCCCCDLL * ((v6 - (uint64_t)v7) >> 3) >= a2)
  {
    if (a2)
    {
      v13 = &v7[5 * a2];
      do
      {
        *v7 = 0;
        v7[1] = 0;
        *((_DWORD *)v7 + 2) = -1;
        v7[3] = 0;
        v7[4] = 0;
        v7[2] = 0;
        v7 += 5;
      }
      while (v7 != v13);
      v7 = v13;
    }
    a1[1] = (uint64_t)v7;
  }
  else
  {
    v8 = 0xCCCCCCCCCCCCCCCDLL * (((uint64_t)v7 - *a1) >> 3);
    v9 = v8 + a2;
    if (v8 + a2 > 0x666666666666666)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = 0xCCCCCCCCCCCCCCCDLL * ((v5 - *a1) >> 3);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x333333333333333)
      v11 = 0x666666666666666;
    else
      v11 = v9;
    v16[4] = result;
    if (v11)
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<vs::tlv::ServiceParam>>(result, v11);
    else
      v12 = 0;
    v14 = &v12[40 * v8];
    v16[0] = v12;
    v16[1] = v14;
    v16[3] = &v12[40 * v11];
    v15 = &v14[40 * a2];
    do
    {
      *(_QWORD *)v14 = 0;
      *((_QWORD *)v14 + 1) = 0;
      *((_DWORD *)v14 + 2) = -1;
      *((_QWORD *)v14 + 3) = 0;
      *((_QWORD *)v14 + 4) = 0;
      *((_QWORD *)v14 + 2) = 0;
      v14 += 40;
    }
    while (v14 != v15);
    v16[2] = v15;
    std::vector<nas::tlv::IncrementalNetworkInterfaceItem>::__swap_out_circular_buffer(a1, v16);
    return std::__split_buffer<nas::tlv::IncrementalNetworkInterfaceItem>::~__split_buffer((uint64_t)v16);
  }
  return result;
}

void sub_2168C9188(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<nas::tlv::IncrementalNetworkInterfaceItem>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<nas::tlv::IncrementalNetworkInterfaceItem>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<nas::tlv::IncrementalNetworkInterfaceItem>,std::reverse_iterator<nas::tlv::IncrementalNetworkInterfaceItem*>,std::reverse_iterator<nas::tlv::IncrementalNetworkInterfaceItem*>,std::reverse_iterator<nas::tlv::IncrementalNetworkInterfaceItem*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<nas::tlv::IncrementalNetworkInterfaceItem>,std::reverse_iterator<nas::tlv::IncrementalNetworkInterfaceItem*>,std::reverse_iterator<nas::tlv::IncrementalNetworkInterfaceItem*>,std::reverse_iterator<nas::tlv::IncrementalNetworkInterfaceItem*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v8;
  __int128 v9;
  uint64_t v10;
  _QWORD v12[3];
  uint64_t v13;
  __int128 v14;
  __int128 v15;

  v7 = a7;
  *(_QWORD *)&v15 = a6;
  *((_QWORD *)&v15 + 1) = a7;
  v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  v13 = 0;
  if (a3 == a5)
  {
    v10 = a6;
  }
  else
  {
    do
    {
      v8 = *(_QWORD *)(a3 - 40);
      a3 -= 40;
      *(_QWORD *)(v7 - 35) = *(_QWORD *)(a3 + 5);
      *(_QWORD *)(v7 - 40) = v8;
      v9 = *(_OWORD *)(a3 + 16);
      *(_QWORD *)(v7 - 8) = *(_QWORD *)(a3 + 32);
      *(_OWORD *)(v7 - 24) = v9;
      *(_QWORD *)(a3 + 16) = 0;
      *(_QWORD *)(a3 + 24) = 0;
      *(_QWORD *)(a3 + 32) = 0;
      v7 = *((_QWORD *)&v15 + 1) - 40;
      *((_QWORD *)&v15 + 1) -= 40;
    }
    while (a3 != a5);
    v10 = v15;
  }
  LOBYTE(v13) = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<nas::tlv::IncrementalNetworkInterfaceItem>,std::reverse_iterator<nas::tlv::IncrementalNetworkInterfaceItem*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return v10;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<nas::tlv::IncrementalNetworkInterfaceItem>,std::reverse_iterator<nas::tlv::IncrementalNetworkInterfaceItem*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<nas::tlv::IncrementalNetworkInterfaceItem>,std::reverse_iterator<nas::tlv::IncrementalNetworkInterfaceItem*>>::operator()[abi:ne180100](a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<nas::tlv::IncrementalNetworkInterfaceItem>,std::reverse_iterator<nas::tlv::IncrementalNetworkInterfaceItem*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8);
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    if (*(char *)(v1 + 39) < 0)
      operator delete(*(void **)(v1 + 16));
    v1 += 40;
  }
}

uint64_t std::__split_buffer<nas::tlv::IncrementalNetworkInterfaceItem>::~__split_buffer(uint64_t a1)
{
  std::__split_buffer<nas::tlv::IncrementalNetworkInterfaceItem>::__destruct_at_end[abi:ne180100](a1, *(_QWORD *)(a1 + 8));
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::__split_buffer<nas::tlv::IncrementalNetworkInterfaceItem>::__destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v5;

  v2 = *(_QWORD *)(a1 + 16);
  if (v2 != a2)
  {
    do
    {
      v5 = v2 - 40;
      *(_QWORD *)(a1 + 16) = v2 - 40;
      if (*(char *)(v2 - 1) < 0)
      {
        operator delete(*(void **)(v2 - 24));
        v5 = *(_QWORD *)(a1 + 16);
      }
      v2 = v5;
    }
    while (v5 != a2);
  }
}

unint64_t bsp::tlv::parseField(unint64_t a1, const unsigned __int8 *a2, uint64_t a3)
{
  unint64_t result;

  tlv::throwIfNotEnoughBytes(a1, a2, 2uLL);
  *(_WORD *)a3 = *(_WORD *)a1;
  tlv::throwIfNotEnoughBytes(a1 + 2, a2, 1uLL);
  *(_BYTE *)(a3 + 2) = *(_BYTE *)(a1 + 2);
  tlv::throwIfNotEnoughBytes(a1 + 3, a2, 1uLL);
  result = a1 + 4;
  *(_DWORD *)(a3 + 4) = *(unsigned __int8 *)(a1 + 3);
  return result;
}

{
  tlv::throwIfNotEnoughBytes(a1, a2, 1uLL);
  *(_BYTE *)a3 = *(_BYTE *)a1;
  tlv::throwIfNotEnoughBytes(a1 + 1, a2, 1uLL);
  *(_BYTE *)(a3 + 1) = *(_BYTE *)(a1 + 1);
  tlv::throwIfNotEnoughBytes(a1 + 2, a2, 2uLL);
  *(_WORD *)(a3 + 2) = *(_WORD *)(a1 + 2);
  return a1 + 4;
}

uint64_t tlv::parseV<bsp::tlv::ActivationProvisioningStatus>(unint64_t *a1, int a2)
{
  uint64_t v3;

  v3 = 0;
  *a1 = bsp::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), (uint64_t)&v3);
  return v3;
}

void sub_2168C9468(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C9454);
}

uint64_t bsp::tlv::parseField(bsp::tlv *this, const unsigned __int8 *a2, unsigned __int8 *a3, ActivationInfo *a4)
{
  int v7;

  tlv::throwIfNotEnoughBytes((unint64_t)this, a2, 1uLL);
  *a3 = *(_BYTE *)this;
  tlv::throwIfNotEnoughBytes((unint64_t)this + 1, a2, 1uLL);
  a3[1] = *((_BYTE *)this + 1);
  tlv::throwIfNotEnoughBytes((unint64_t)this + 2, a2, 2uLL);
  *((_WORD *)a3 + 1) = *((_WORD *)this + 1);
  tlv::throwIfNotEnoughBytes((unint64_t)this + 4, a2, 2uLL);
  *((_WORD *)a3 + 2) = *((_WORD *)this + 2);
  tlv::throwIfNotEnoughBytes((unint64_t)this + 6, a2, 7uLL);
  v7 = *(_DWORD *)((char *)this + 6);
  *(_DWORD *)(a3 + 9) = *(_DWORD *)((char *)this + 9);
  *(_DWORD *)(a3 + 6) = v7;
  return (uint64_t)this + 13;
}

uint64_t tlv::parseV<bsp::tlv::ActivationInfo>(bsp::tlv **a1, int a2, uint64_t a3, ActivationInfo *a4)
{
  _QWORD v5[2];

  memset(v5, 0, 14);
  *a1 = (bsp::tlv *)bsp::tlv::parseField(*a1, (const unsigned __int8 *)*a1 + a2, (unsigned __int8 *)v5, a4);
  return v5[0];
}

void sub_2168C9570(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C9550);
}

_QWORD *tlv::parseV<bsp::tlv::ActivationRootManifestHash>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  _QWORD *v6;
  unint64_t v7;
  unsigned __int8 *v8;
  __int128 v9;
  _QWORD *result;

  v6 = (_QWORD *)a3 + 3;
  a3[1] = 0u;
  a3[2] = 0u;
  *a3 = 0u;
  v7 = *a1;
  v8 = (unsigned __int8 *)(*a1 + a2);
  tlv::throwIfNotEnoughBytes(*a1, v8, 0x14uLL);
  v9 = *(_OWORD *)v7;
  *((_DWORD *)a3 + 4) = *(_DWORD *)(v7 + 16);
  *a3 = v9;
  result = std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(v6, (char *)(v7 + 20), (char *)v8, a2 - 20);
  *a1 = (unint64_t)v8;
  return result;
}

void sub_2168C9608(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C95F4);
}

void sub_2168C9618(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void *v4;

  v4 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 32) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

uint64_t tlv::parseV<bsp::tlv::ActivationImei>(unint64_t *a1, int a2)
{
  uint64_t *v3;
  uint64_t result;

  v3 = (uint64_t *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 8uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168C966C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C9660);
}

unint64_t tlv::parseV<bsp::tlv::ActivationMeid>(unint64_t *a1, int a2)
{
  unsigned int *v3;
  unint64_t result;

  v3 = (unsigned int *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 7uLL);
  result = *v3 | ((unint64_t)(*((unsigned __int16 *)v3 + 2) | (*((unsigned __int8 *)v3 + 6) << 16)) << 32);
  *a1 = (unint64_t)v3 + 7;
  return result;
}

void sub_2168C96CC(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C96C0);
}

uint64_t tlv::parseV<bsp::tlv::ActivationImsi>(unint64_t *a1, int a2)
{
  uint64_t *v3;
  uint64_t result;

  v3 = (uint64_t *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 8uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168C9718(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C970CLL);
}

_QWORD *tlv::parseV<bsp::tlv::ActivationGid1>@<X0>(char **a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  char *v4;
  _QWORD *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  v4 = &(*a1)[a2];
  result = std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(a3, *a1, v4, a2);
  *a1 = v4;
  return result;
}

void sub_2168C977C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C976CLL);
}

void sub_2168C978C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *tlv::parseV<bsp::tlv::ActivationGid2>@<X0>(char **a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  char *v4;
  _QWORD *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  v4 = &(*a1)[a2];
  result = std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(a3, *a1, v4, a2);
  *a1 = v4;
  return result;
}

void sub_2168C97F8(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C97E8);
}

void sub_2168C9808(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *tlv::parseV<bsp::tlv::ActivationIccid>@<X0>(char **a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  char *v4;
  _QWORD *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  v4 = &(*a1)[a2];
  result = std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(a3, *a1, v4, a2);
  *a1 = v4;
  return result;
}

void sub_2168C9874(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C9864);
}

void sub_2168C9884(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t tlv::parseV<bsp::tlv::ActivationVersion>(unint64_t *a1, int a2)
{
  unsigned int *v3;
  uint64_t result;

  v3 = (unsigned int *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 4uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168C98D8(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C98CCLL);
}

uint64_t tlv::parseV<bsp::tlv::ActivationMode>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168C9924(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C9918);
}

uint64_t tlv::parseV<bsp::tlv::ActivationType>(unint64_t *a1, int a2)
{
  unsigned __int16 *v3;
  uint64_t result;

  v3 = (unsigned __int16 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 2uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168C9970(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C9964);
}

_QWORD *tlv::parseV<bsp::tlv::ActivationPublicKeyHash>@<X0>(char **a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  char *v4;
  _QWORD *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  v4 = &(*a1)[a2];
  result = std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(a3, *a1, v4, a2);
  *a1 = v4;
  return result;
}

void sub_2168C99D4(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C99C4);
}

void sub_2168C99E4(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *tlv::parseV<bsp::tlv::ActivationFactoryKeyHash>@<X0>(char **a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  char *v4;
  _QWORD *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  v4 = &(*a1)[a2];
  result = std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(a3, *a1, v4, a2);
  *a1 = v4;
  return result;
}

void sub_2168C9A50(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C9A40);
}

void sub_2168C9A60(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t tlv::parseV<bsp::tlv::ActivationFactoryDebug>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168C9AB4(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C9AA8);
}

uint64_t tlv::parseV<bsp::tlv::ActivationMoringaFlags>(_DWORD **a1, int a2)
{
  uint64_t v3;
  int v4;

  v4 = 0;
  v3 = 0;
  *a1 = qos::tlv::parseField(*a1, (const unsigned __int8 *)*a1 + a2, &v3);
  return v3;
}

void sub_2168C9B10(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C9AF8);
}

BOOL tlv::parseV<bsp::tlv::CDRXInfo>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  _BOOL8 result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3 != 0;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168C9B60(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C9B54);
}

uint64_t tlv::parseV<bsp::tlv::SubscriptionID>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168C9BAC(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C9BA0);
}

uint64_t tlv::parseV<bsp::tlv::AQMReportRBUplinkRate>(unint64_t *a1, int a2)
{
  unsigned int *v3;
  uint64_t result;

  v3 = (unsigned int *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 4uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168C9BF8(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C9BECLL);
}

uint64_t tlv::parseV<bsp::tlv::AQMReportRBDownlinkRate>(unint64_t *a1, int a2)
{
  unsigned int *v3;
  uint64_t result;

  v3 = (unsigned int *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 4uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168C9C44(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C9C38);
}

uint64_t tlv::size<bsp::tlv::FileTransferInfo>(uint64_t a1)
{
  return *(_QWORD *)(a1 + 24) - *(_QWORD *)(a1 + 16) + 9;
}

void *tlv::writeV<bsp::tlv::FileTransferInfo>(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  void *result;

  v4 = *a1;
  *(_BYTE *)v4 = *(_DWORD *)a2;
  *(_BYTE *)(v4 + 1) = *(_BYTE *)(a2 + 4);
  *(_WORD *)(v4 + 2) = *(_WORD *)(a2 + 6);
  *(_WORD *)(v4 + 4) = *(_WORD *)(a2 + 8);
  v5 = v4 + 6;
  result = memcpy((void *)(v4 + 6), *(const void **)(a2 + 16), *(_QWORD *)(a2 + 24) - *(_QWORD *)(a2 + 16));
  *a1 = v5 + *(_QWORD *)(a2 + 24) - *(_QWORD *)(a2 + 16);
  return result;
}

uint64_t tlv::parseV<bsp::tlv::ExpectedSegmentInfo>(unint64_t *a1, int a2)
{
  unsigned __int16 *v3;
  uint64_t result;

  v3 = (unsigned __int16 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 2uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168C9D14(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C9D08);
}

uint64_t tlv::parseV<bsp::tlv::TransferStatus>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  const unsigned __int8 *v4;
  unsigned int v5;
  uint64_t v6;

  v3 = (unsigned __int8 *)*a1;
  v4 = (const unsigned __int8 *)(*a1 + a2);
  tlv::throwIfNotEnoughBytes(*a1, v4, 1uLL);
  v5 = *v3;
  tlv::throwIfNotEnoughBytes((unint64_t)(v3 + 1), v4, 1uLL);
  v6 = v3[1];
  *a1 = (unint64_t)(v3 + 2);
  return (v6 << 32) | v5;
}

void sub_2168C9D94(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C9D7CLL);
}

uint64_t tlv::parseV<bsp::tlv::ChipInformation>(unint64_t *a1, int a2)
{
  unsigned int *v3;
  const unsigned __int8 *v4;
  unsigned int v5;
  uint64_t v6;

  v3 = (unsigned int *)*a1;
  v4 = (const unsigned __int8 *)(*a1 + a2);
  tlv::throwIfNotEnoughBytes(*a1, v4, 4uLL);
  v5 = *v3;
  tlv::throwIfNotEnoughBytes((unint64_t)(v3 + 1), v4, 4uLL);
  v6 = v3[1];
  *a1 = (unint64_t)(v3 + 2);
  return (v6 << 32) | v5;
}

void sub_2168C9E14(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C9DFCLL);
}

unint64_t tlv::parseV<bsp::tlv::ActivationProvisioningInfo>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  unint64_t v5;
  const unsigned __int8 *v6;
  unint64_t result;

  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_DWORD *)(a3 + 23) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  v5 = *a1;
  v6 = (const unsigned __int8 *)(*a1 + a2);
  tlv::throwIfNotEnoughBytes(*a1, v6, 0x14uLL);
  *(_OWORD *)a3 = *(_OWORD *)v5;
  *(_DWORD *)(a3 + 16) = *(_DWORD *)(v5 + 16);
  result = tlv::throwIfNotEnoughBytes(v5 + 20, v6, 7uLL);
  *(_DWORD *)(a3 + 20) = *(_DWORD *)(v5 + 20);
  *(_DWORD *)(a3 + 23) = *(_DWORD *)(v5 + 23);
  *a1 = v5 + 27;
  return result;
}

void sub_2168C9EB8(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
}

uint64_t tlv::parseV<bsp::tlv::ActivationState>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168C9F0C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C9F00);
}

uint64_t tlv::parseV<bsp::tlv::ActivationPriVersionSlot1>(unint64_t *a1, int a2)
{
  unsigned int v3;

  v3 = 0;
  *a1 = bsp::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), (uint64_t)&v3);
  return v3;
}

void sub_2168C9FD0(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168C9FBCLL);
}

uint64_t tlv::parseV<bsp::tlv::ActivationPriVersionSlot2>(unint64_t *a1, int a2)
{
  unsigned int v3;

  v3 = 0;
  *a1 = bsp::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), (uint64_t)&v3);
  return v3;
}

void sub_2168CA020(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CA00CLL);
}

uint64_t tlv::parseV<bsp::tlv::ActivationIccidSlot1>(unint64_t *a1, int a2)
{
  uint64_t *v3;
  uint64_t result;

  v3 = (uint64_t *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 0xAuLL);
  result = *v3;
  *a1 = (unint64_t)v3 + 10;
  return result;
}

void sub_2168CA070(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CA064);
}

uint64_t tlv::parseV<bsp::tlv::ActivationImsiSlot1>(unint64_t *a1, int a2)
{
  uint64_t *v3;
  uint64_t result;

  v3 = (uint64_t *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 8uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168CA0C0(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CA0B4);
}

_QWORD *tlv::parseV<bsp::tlv::ActivationGid1Slot1>@<X0>(char **a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  char *v4;
  _QWORD *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  v4 = &(*a1)[a2];
  result = std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(a3, *a1, v4, a2);
  *a1 = v4;
  return result;
}

void sub_2168CA124(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CA114);
}

void sub_2168CA134(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *tlv::parseV<bsp::tlv::ActivationGid2Slot1>@<X0>(char **a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  char *v4;
  _QWORD *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  v4 = &(*a1)[a2];
  result = std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(a3, *a1, v4, a2);
  *a1 = v4;
  return result;
}

void sub_2168CA1A0(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CA190);
}

void sub_2168CA1B0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t tlv::parseV<bsp::tlv::ActivationIccidSlot2>(unint64_t *a1, int a2)
{
  uint64_t *v3;
  uint64_t result;

  v3 = (uint64_t *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 0xAuLL);
  result = *v3;
  *a1 = (unint64_t)v3 + 10;
  return result;
}

void sub_2168CA20C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CA200);
}

uint64_t tlv::parseV<bsp::tlv::ActivationImsiSlot2>(unint64_t *a1, int a2)
{
  uint64_t *v3;
  uint64_t result;

  v3 = (uint64_t *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 8uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168CA25C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CA250);
}

_QWORD *tlv::parseV<bsp::tlv::ActivationGid1Slot2>@<X0>(char **a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  char *v4;
  _QWORD *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  v4 = &(*a1)[a2];
  result = std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(a3, *a1, v4, a2);
  *a1 = v4;
  return result;
}

void sub_2168CA2C0(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CA2B0);
}

void sub_2168CA2D0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *tlv::parseV<bsp::tlv::ActivationGid2Slot2>@<X0>(char **a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  char *v4;
  _QWORD *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  v4 = &(*a1)[a2];
  result = std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(a3, *a1, v4, a2);
  *a1 = v4;
  return result;
}

void sub_2168CA33C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CA32CLL);
}

void sub_2168CA34C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t tlv::parseV<bsp::tlv::ActivationTypeMode>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168CA3A0(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CA394);
}

uint64_t tlv::parseV<bsp::tlv::ActivationServiceProvisioned>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168CA3EC(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CA3E0);
}

uint64_t tlv::parseV<bsp::tlv::ActivationCardProvisionedSlot1>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168CA438(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CA42CLL);
}

uint64_t tlv::parseV<bsp::tlv::ActivationCardProvisionedSlot2>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168CA484(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CA478);
}

uint64_t tlv::parseV<bsp::tlv::ActivationManifestResult>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168CA4D0(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CA4C4);
}

BOOL tlv::parseV<bsp::tlv::DsdsAllowed>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  _BOOL8 result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3 != 0;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168CA524(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CA518);
}

BOOL tlv::parseV<bsp::tlv::NrAllowed>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  _BOOL8 result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3 != 0;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168CA578(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CA56CLL);
}

uint64_t tlv::parseV<bsp::tlv::ActivationImeiSlot2>(unint64_t *a1, int a2)
{
  uint64_t *v3;
  uint64_t result;

  v3 = (uint64_t *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 8uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168CA5C4(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CA5B8);
}

BOOL tlv::parseV<bsp::tlv::Slot1IsAccepted>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  _BOOL8 result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3 != 0;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168CA618(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CA60CLL);
}

BOOL tlv::parseV<bsp::tlv::Slot2IsAccepted>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  _BOOL8 result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3 != 0;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168CA66C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CA660);
}

BOOL tlv::parseV<bsp::tlv::Slot1IsEmbedded>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  _BOOL8 result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3 != 0;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168CA6C0(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CA6B4);
}

BOOL tlv::parseV<bsp::tlv::Slot2IsEmbedded>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  _BOOL8 result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3 != 0;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168CA714(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CA708);
}

uint64_t tlv::parseV<bsp::tlv::BootstrapVersion>(unint64_t *a1, int a2)
{
  unsigned int *v3;
  uint64_t result;

  v3 = (unsigned int *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 4uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168CA760(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CA754);
}

BOOL tlv::parseV<bsp::tlv::Slot1IsBootstrap>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  _BOOL8 result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3 != 0;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168CA7B4(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CA7A8);
}

BOOL tlv::parseV<bsp::tlv::Slot2IsBootstrap>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  _BOOL8 result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3 != 0;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168CA808(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CA7FCLL);
}

uint64_t tlv::parseV<nas::tlv::BandPref>(unint64_t *a1, int a2)
{
  uint64_t *v3;
  uint64_t result;

  v3 = (uint64_t *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 8uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168CA854(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CA848);
}

__n128 tlv::parseV<nas::tlv::LTEBandPrefExtended>@<Q0>(unint64_t *a1@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  unint64_t v5;
  __n128 result;
  __int128 v7;

  *a3 = 0u;
  a3[1] = 0u;
  v5 = *a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 0x20uLL);
  result = *(__n128 *)v5;
  v7 = *(_OWORD *)(v5 + 16);
  *a3 = *(_OWORD *)v5;
  a3[1] = v7;
  *a1 = v5 + 32;
  return result;
}

void sub_2168CA8BC(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
}

uint64_t tlv::size<nas::tlv::LTEBandPrefExtended>()
{
  return 35;
}

__n128 tlv::writeV<nas::tlv::LTEBandPrefExtended>(_OWORD **a1, uint64_t a2)
{
  _OWORD *v2;
  __n128 result;
  __int128 v4;

  v2 = *a1;
  result = *(__n128 *)a2;
  v4 = *(_OWORD *)(a2 + 16);
  *v2 = *(_OWORD *)a2;
  v2[1] = v4;
  *a1 = v2 + 2;
  return result;
}

__n128 tlv::parseV<nas::tlv::NRBandPref>@<Q0>(unint64_t *a1@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  unint64_t v5;
  __int128 v6;
  __n128 result;
  __int128 v8;

  a3[2] = 0u;
  a3[3] = 0u;
  *a3 = 0u;
  a3[1] = 0u;
  v5 = *a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 0x40uLL);
  v6 = *(_OWORD *)(v5 + 16);
  *a3 = *(_OWORD *)v5;
  a3[1] = v6;
  result = *(__n128 *)(v5 + 32);
  v8 = *(_OWORD *)(v5 + 48);
  a3[2] = result;
  a3[3] = v8;
  *a1 = v5 + 64;
  return result;
}

void sub_2168CA950(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
}

uint64_t tlv::size<nas::tlv::NRBandPref>()
{
  return 67;
}

__n128 tlv::writeV<nas::tlv::NRBandPref>(uint64_t *a1, uint64_t a2)
{
  uint64_t v2;
  __n128 result;
  __int128 v4;
  __int128 v5;

  v2 = *a1;
  result = *(__n128 *)a2;
  v4 = *(_OWORD *)(a2 + 16);
  v5 = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(v2 + 32) = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(v2 + 48) = v5;
  *(__n128 *)v2 = result;
  *(_OWORD *)(v2 + 16) = v4;
  *a1 = v2 + 64;
  return result;
}

uint64_t tlv::parseV<nas::tlv::TDSCDMABandPref>(unint64_t *a1, int a2)
{
  uint64_t *v3;
  uint64_t result;

  v3 = (uint64_t *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 8uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168CA9C4(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CA9B8);
}

uint64_t tlv::parseV<nas::tlv::EmergencyMode>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168CAA10(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CAA04);
}

uint64_t tlv::parseV<nas::tlv::ModePreference>(unint64_t *a1, int a2)
{
  unsigned __int16 *v3;
  uint64_t result;

  v3 = (unsigned __int16 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 2uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168CAA5C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CAA50);
}

uint64_t tlv::parseV<nas::tlv::GwAcqOrderPref>(unint64_t *a1, int a2)
{
  unsigned int *v3;
  uint64_t result;

  v3 = (unsigned int *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 4uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168CAAA8(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CAA9CLL);
}

uint64_t tlv::parseV<nas::tlv::DefaultVoiceSubs>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168CAAF4(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CAAE8);
}

uint64_t tlv::parseV<nas::tlv::ActiveSubs>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  const unsigned __int8 *v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;

  v3 = (unsigned __int8 *)*a1;
  v4 = (const unsigned __int8 *)(*a1 + a2);
  tlv::throwIfNotEnoughBytes(*a1, v4, 1uLL);
  v5 = *v3;
  tlv::throwIfNotEnoughBytes((unint64_t)(v3 + 1), v4, 7uLL);
  v6 = *(unsigned __int16 *)(v3 + 5) | (v3[7] << 16);
  v7 = *(unsigned int *)(v3 + 1);
  *a1 = (unint64_t)(v3 + 8);
  return (v7 << 8) | (v6 << 40) | v5;
}

void sub_2168CAB84(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CAB6CLL);
}

uint64_t *tlv::writeV<nas::tlv::ActiveSubs>(uint64_t *result, uint64_t a2)
{
  uint64_t v2;
  int v3;

  v2 = *result;
  *(_BYTE *)v2 = *(_BYTE *)a2;
  v3 = *(_DWORD *)(a2 + 1);
  *(_DWORD *)(v2 + 4) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(v2 + 1) = v3;
  *result = v2 + 8;
  return result;
}

uint64_t tlv::parseV<nas::tlv::NRDisableMode>(unint64_t *a1, int a2)
{
  unsigned int *v3;
  uint64_t result;

  v3 = (unsigned int *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 4uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168CABF8(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CABECLL);
}

uint64_t tlv::parseV<nas::tlv::IsSADisabled>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168CAC44(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CAC38);
}

uint64_t tlv::parseV<nas::tlv::IsNSADisabled>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168CAC90(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CAC84);
}

uint64_t tlv::parseV<nas::tlv::SADisableReasonMask>(unint64_t *a1, int a2)
{
  unsigned int *v3;
  uint64_t result;

  v3 = (unsigned int *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 4uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168CACDC(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CACD0);
}

uint64_t tlv::parseV<nas::tlv::NSADisableReasonMask>(unint64_t *a1, int a2)
{
  unsigned int *v3;
  uint64_t result;

  v3 = (unsigned int *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 4uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168CAD28(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CAD1CLL);
}

uint64_t tlv::parseV<nas::tlv::LinkQuality>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168CAD74(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CAD68);
}

uint64_t *tlv::writeV<nas::tlv::NetworkSelectionPreference>(uint64_t *result, uint64_t a2)
{
  uint64_t v2;

  v2 = *result;
  *(_BYTE *)v2 = *(_BYTE *)a2;
  *(_WORD *)(v2 + 1) = *(_WORD *)(a2 + 2);
  *(_WORD *)(v2 + 3) = *(_WORD *)(a2 + 4);
  *result = v2 + 5;
  return result;
}

char *tlv::writeV<nas::tlv::NetworkSelectionPreferenceRAT>(char **a1, int *a2)
{
  char *result;

  result = nas::tlv::writeField(*a1, a2);
  *a1 = result;
  return result;
}

uint64_t tlv::parseV<nas::tlv::StandbyPreferenceReport>(_BYTE **a1, int a2)
{
  unsigned int v3;

  v3 = 0;
  *a1 = nas::tlv::parseField(*a1, &(*a1)[a2], &v3);
  return v3;
}

void sub_2168CAEA0(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CAE8CLL);
}

unsigned __int8 *vinyl::tlv::parseField(unint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  tlv::throwIfNotEnoughBytes(a1, a2, 2uLL);
  *(_WORD *)a3 = *(_WORD *)a1;
  tlv::throwIfNotEnoughBytes(a1 + 2, a2, 2uLL);
  *(_WORD *)(a3 + 2) = *(_WORD *)(a1 + 2);
  std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((_QWORD *)(a3 + 8), (char *)(a1 + 4), (char *)a2, (unint64_t)&a2[-a1 - 4]);
  return a2;
}

{
  tlv::throwIfNotEnoughBytes(a1, a2, 1uLL);
  *(_BYTE *)a3 = *(_BYTE *)a1;
  tlv::throwIfNotEnoughBytes(a1 + 1, a2, 1uLL);
  *(_BYTE *)(a3 + 1) = *(_BYTE *)(a1 + 1);
  tlv::throwIfNotEnoughBytes(a1 + 2, a2, 2uLL);
  *(_WORD *)(a3 + 2) = *(_WORD *)(a1 + 2);
  std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((_QWORD *)(a3 + 8), (char *)(a1 + 4), (char *)a2, (unint64_t)&a2[-a1 - 4]);
  return a2;
}

unsigned __int8 *tlv::parseV<vinyl::tlv::PayloadData>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  unint64_t v4;
  unsigned __int8 *v5;
  unsigned __int8 *result;

  *a3 = 0u;
  a3[1] = 0u;
  v4 = *a1;
  v5 = (unsigned __int8 *)(v4 + a2);
  result = vinyl::tlv::parseField(v4, v5, (uint64_t)a3);
  *a1 = (unint64_t)v5;
  return result;
}

void sub_2168CAF64(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CAF54);
}

void sub_2168CAF74(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)(v1 + 8);
  if (v3)
  {
    *(_QWORD *)(v1 + 16) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *tlv::writeV<vinyl::tlv::PayloadData>(_WORD **a1, uint64_t a2)
{
  _WORD *v4;
  _WORD *v5;
  void *result;

  v4 = *a1;
  *v4 = *(_WORD *)a2;
  v4[1] = *(_WORD *)(a2 + 2);
  v5 = v4 + 2;
  result = memcpy(v4 + 2, *(const void **)(a2 + 8), *(_QWORD *)(a2 + 16) - *(_QWORD *)(a2 + 8));
  *a1 = (_WORD *)((char *)v5 + *(_QWORD *)(a2 + 16) - *(_QWORD *)(a2 + 8));
  return result;
}

uint64_t tlv::size<vinyl::tlv::TapeRequestPayloadData>(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8) + 8;
}

void *tlv::writeV<vinyl::tlv::TapeRequestPayloadData>(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  void *result;

  v4 = *a1;
  *(_BYTE *)v4 = *(_BYTE *)a2;
  *(_WORD *)(v4 + 1) = *(_WORD *)(a2 + 2);
  *(_WORD *)(v4 + 3) = *(_WORD *)(a2 + 4);
  v5 = v4 + 5;
  result = memcpy((void *)(v4 + 5), *(const void **)(a2 + 8), *(_QWORD *)(a2 + 16) - *(_QWORD *)(a2 + 8));
  *a1 = v5 + *(_QWORD *)(a2 + 16) - *(_QWORD *)(a2 + 8);
  return result;
}

unsigned __int8 *tlv::parseV<vinyl::tlv::IndFwUpdProfileSummary>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  unint64_t v4;
  unsigned __int8 *v5;
  unsigned __int8 *result;

  *a3 = 0u;
  a3[1] = 0u;
  v4 = *a1;
  v5 = (unsigned __int8 *)(v4 + a2);
  result = vinyl::tlv::parseField(v4, v5, (uint64_t)a3);
  *a1 = (unint64_t)v5;
  return result;
}

void sub_2168CB13C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CB12CLL);
}

void sub_2168CB14C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)(v1 + 8);
  if (v3)
  {
    *(_QWORD *)(v1 + 16) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *tlv::writeV<vinyl::tlv::ReqCommand>(uint64_t *result, uint64_t a2)
{
  uint64_t v2;

  v2 = *result;
  *(_BYTE *)v2 = *(_BYTE *)a2;
  *(_DWORD *)(v2 + 1) = *(_DWORD *)(a2 + 4);
  *(_BYTE *)(v2 + 5) = *(_BYTE *)(a2 + 8);
  *result = v2 + 6;
  return result;
}

__n128 tlv::writeV<vinyl::tlv::ReqProfileId>(__n128 **a1, __n128 *a2)
{
  __n128 *v2;
  __n128 result;

  v2 = *a1;
  result = *a2;
  *v2 = *a2;
  *a1 = v2 + 1;
  return result;
}

unint64_t tlv::size<vinyl::tlv::ReqProfileIdList>(_QWORD *a1)
{
  uint64_t v1;

  v1 = a1[1];
  if (v1 == *a1)
    return 4;
  else
    return (v1 - *a1) & 0xFFFFFFFFFFFFFFF0 | 4;
}

_BYTE **tlv::writeV<vinyl::tlv::ReqProfileIdList>(_BYTE **result, _DWORD *a2)
{
  _BYTE *v2;
  _OWORD *v3;
  __int128 *v4;
  __int128 *v5;
  __int128 v6;

  v2 = *result;
  *v2 = (a2[2] - *a2) >> 4;
  v3 = v2 + 1;
  v4 = *(__int128 **)a2;
  v5 = (__int128 *)*((_QWORD *)a2 + 1);
  while (v4 != v5)
  {
    v6 = *v4++;
    *v3++ = v6;
  }
  *result = v3;
  return result;
}

uint64_t tlv::parseV<vinyl::tlv::RespCsn>(unint64_t *a1, int a2)
{
  uint64_t *v3;
  uint64_t result;

  v3 = (uint64_t *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 0x10uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 2);
  return result;
}

void sub_2168CB234(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CB228);
}

unint64_t vinyl::tlv::parseField(unint64_t a1, const unsigned __int8 *a2, uint64_t a3)
{
  tlv::throwIfNotEnoughBytes(a1, a2, 1uLL);
  *(_BYTE *)a3 = *(_BYTE *)a1;
  tlv::throwIfNotEnoughBytes(a1 + 1, a2, 1uLL);
  *(_BYTE *)(a3 + 1) = *(_BYTE *)(a1 + 1) != 0;
  tlv::throwIfNotEnoughBytes(a1 + 2, a2, 4uLL);
  *(_DWORD *)(a3 + 4) = *(_DWORD *)(a1 + 2);
  tlv::throwIfNotEnoughBytes(a1 + 6, a2, 1uLL);
  *(_BYTE *)(a3 + 8) = *(_BYTE *)(a1 + 6);
  tlv::throwIfNotEnoughBytes(a1 + 7, a2, 1uLL);
  *(_BYTE *)(a3 + 9) = *(_BYTE *)(a1 + 7);
  return a1 + 8;
}

{
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int16 v9;
  __int128 v10;
  __int128 v11;
  __int16 v12;
  __int16 v13;
  __int128 v14;

  tlv::throwIfNotEnoughBytes(a1, a2, 1uLL);
  *(_BYTE *)a3 = *(_BYTE *)a1;
  tlv::throwIfNotEnoughBytes(a1 + 1, a2, 1uLL);
  *(_BYTE *)(a3 + 1) = *(_BYTE *)(a1 + 1);
  tlv::throwIfNotEnoughBytes(a1 + 2, a2, 1uLL);
  *(_BYTE *)(a3 + 2) = *(_BYTE *)(a1 + 2);
  tlv::throwIfNotEnoughBytes(a1 + 3, a2, 0x10uLL);
  *(_OWORD *)(a3 + 3) = *(_OWORD *)(a1 + 3);
  tlv::throwIfNotEnoughBytes(a1 + 19, a2, 1uLL);
  *(_BYTE *)(a3 + 19) = *(_BYTE *)(a1 + 19);
  tlv::throwIfNotEnoughBytes(a1 + 20, a2, 0x20uLL);
  v6 = *(_OWORD *)(a1 + 20);
  *(_OWORD *)(a3 + 36) = *(_OWORD *)(a1 + 36);
  *(_OWORD *)(a3 + 20) = v6;
  tlv::throwIfNotEnoughBytes(a1 + 52, a2, 8uLL);
  *(_QWORD *)(a3 + 52) = *(_QWORD *)(a1 + 52);
  tlv::throwIfNotEnoughBytes(a1 + 60, a2, 8uLL);
  *(_QWORD *)(a3 + 60) = *(_QWORD *)(a1 + 60);
  tlv::throwIfNotEnoughBytes(a1 + 68, a2, 8uLL);
  *(_QWORD *)(a3 + 68) = *(_QWORD *)(a1 + 68);
  tlv::throwIfNotEnoughBytes(a1 + 76, a2, 0x20uLL);
  v7 = *(_OWORD *)(a1 + 76);
  *(_OWORD *)(a3 + 92) = *(_OWORD *)(a1 + 92);
  *(_OWORD *)(a3 + 76) = v7;
  tlv::throwIfNotEnoughBytes(a1 + 108, a2, 0x18uLL);
  v8 = *(_OWORD *)(a1 + 108);
  *(_QWORD *)(a3 + 124) = *(_QWORD *)(a1 + 124);
  *(_OWORD *)(a3 + 108) = v8;
  tlv::throwIfNotEnoughBytes(a1 + 132, a2, 3uLL);
  v9 = *(_WORD *)(a1 + 132);
  *(_BYTE *)(a3 + 134) = *(_BYTE *)(a1 + 134);
  *(_WORD *)(a3 + 132) = v9;
  tlv::throwIfNotEnoughBytes(a1 + 135, a2, 8uLL);
  *(_QWORD *)(a3 + 135) = *(_QWORD *)(a1 + 135);
  tlv::throwIfNotEnoughBytes(a1 + 143, a2, 0x20uLL);
  v10 = *(_OWORD *)(a1 + 143);
  *(_OWORD *)(a3 + 159) = *(_OWORD *)(a1 + 159);
  *(_OWORD *)(a3 + 143) = v10;
  tlv::throwIfNotEnoughBytes(a1 + 175, a2, 0x18uLL);
  v11 = *(_OWORD *)(a1 + 175);
  *(_QWORD *)(a3 + 191) = *(_QWORD *)(a1 + 191);
  *(_OWORD *)(a3 + 175) = v11;
  tlv::throwIfNotEnoughBytes(a1 + 199, a2, 3uLL);
  v12 = *(_WORD *)(a1 + 199);
  *(_BYTE *)(a3 + 201) = *(_BYTE *)(a1 + 201);
  *(_WORD *)(a3 + 199) = v12;
  tlv::throwIfNotEnoughBytes(a1 + 202, a2, 2uLL);
  *(_WORD *)(a3 + 202) = *(_WORD *)(a1 + 202);
  tlv::throwIfNotEnoughBytes(a1 + 204, a2, 8uLL);
  *(_QWORD *)(a3 + 204) = *(_QWORD *)(a1 + 204);
  tlv::throwIfNotEnoughBytes(a1 + 212, a2, 3uLL);
  v13 = *(_WORD *)(a1 + 212);
  *(_BYTE *)(a3 + 214) = *(_BYTE *)(a1 + 214);
  *(_WORD *)(a3 + 212) = v13;
  tlv::throwIfNotEnoughBytes(a1 + 215, a2, 0x20uLL);
  v14 = *(_OWORD *)(a1 + 215);
  *(_OWORD *)(a3 + 231) = *(_OWORD *)(a1 + 231);
  *(_OWORD *)(a3 + 215) = v14;
  tlv::throwIfNotEnoughBytes(a1 + 247, a2, 1uLL);
  *(_BYTE *)(a3 + 247) = *(_BYTE *)(a1 + 247);
  tlv::throwIfNotEnoughBytes(a1 + 248, a2, 1uLL);
  *(_BYTE *)(a3 + 248) = *(_BYTE *)(a1 + 248);
  return a1 + 249;
}

{
  tlv::throwIfNotEnoughBytes(a1, a2, 1uLL);
  *(_BYTE *)a3 = *(_BYTE *)a1;
  tlv::throwIfNotEnoughBytes(a1 + 1, a2, 2uLL);
  *(_WORD *)(a3 + 2) = *(_WORD *)(a1 + 1);
  tlv::throwIfNotEnoughBytes(a1 + 3, a2, 2uLL);
  *(_WORD *)(a3 + 4) = *(_WORD *)(a1 + 3);
  tlv::throwIfNotEnoughBytes(a1 + 5, a2, 4uLL);
  *(_DWORD *)(a3 + 8) = *(_DWORD *)(a1 + 5);
  tlv::throwIfNotEnoughBytes(a1 + 9, a2, 1uLL);
  *(_BYTE *)(a3 + 12) = *(_BYTE *)(a1 + 9);
  tlv::throwIfNotEnoughBytes(a1 + 10, a2, 1uLL);
  *(_BYTE *)(a3 + 13) = *(_BYTE *)(a1 + 10);
  return a1 + 11;
}

uint64_t tlv::parseV<vinyl::tlv::IndResult>(unint64_t *a1, int a2)
{
  uint64_t v3;
  int v4;

  v4 = 0;
  v3 = 0;
  *a1 = vinyl::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), (uint64_t)&v3);
  return v3;
}

void sub_2168CB33C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CB324);
}

_QWORD *tlv::parseV<vinyl::tlv::IndAvailableSpace>@<X0>(char **a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  char *v4;
  _QWORD *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  v4 = &(*a1)[a2];
  result = std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(a3, *a1, v4, a2);
  *a1 = v4;
  return result;
}

void sub_2168CB39C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CB38CLL);
}

void sub_2168CB3AC(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_BYTE *vinyl::tlv::parseField(_BYTE *a1, const unsigned __int8 *a2, BOOL *a3)
{
  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  *a3 = *a1 != 0;
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 1), a2, 1uLL);
  a3[1] = a1[1] != 0;
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 2), a2, 1uLL);
  a3[2] = a1[2];
  return a1 + 3;
}

uint64_t tlv::parseV<vinyl::tlv::IndManagerReady>(_BYTE **a1, int a2)
{
  unsigned __int16 v3;
  unsigned __int8 v4;

  v4 = 0;
  v3 = 0;
  *a1 = vinyl::tlv::parseField(*a1, &(*a1)[a2], (BOOL *)&v3);
  return v3 | (v4 << 16);
}

void sub_2168CB494(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CB478);
}

unint64_t tlv::parseV<vinyl::tlv::IndFwUpdGetData>@<X0>(unint64_t *a1@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  unint64_t v4;
  unint64_t result;

  *(_OWORD *)((char *)a3 + 234) = 0u;
  a3[13] = 0u;
  a3[14] = 0u;
  a3[11] = 0u;
  a3[12] = 0u;
  a3[9] = 0u;
  a3[10] = 0u;
  a3[7] = 0u;
  a3[8] = 0u;
  a3[5] = 0u;
  a3[6] = 0u;
  a3[3] = 0u;
  a3[4] = 0u;
  a3[1] = 0u;
  a3[2] = 0u;
  v4 = *a1;
  *a3 = 0u;
  result = vinyl::tlv::parseField(v4, (const unsigned __int8 *)(v4 + a2), (uint64_t)a3);
  *a1 = result;
  return result;
}

void sub_2168CB77C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
}

uint64_t tlv::parseV<vinyl::tlv::IndFwUpdChipId>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168CB7C8(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CB7BCLL);
}

uint64_t tlv::parseV<vinyl::tlv::IndTapeIndResult>(unint64_t *a1, int a2)
{
  _QWORD v3[2];

  v3[0] = 0;
  v3[1] = 0;
  *a1 = vinyl::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), (uint64_t)v3);
  return v3[0];
}

void sub_2168CB8D4(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CB8C0);
}

uint64_t *tlv::writeV<vinyl::tlv::TapeReqGetEid>(uint64_t *result, uint64_t a2)
{
  uint64_t v2;

  v2 = *result;
  *(_DWORD *)v2 = *(_DWORD *)a2;
  *(_BYTE *)(v2 + 4) = *(_BYTE *)(a2 + 4);
  *result = v2 + 5;
  return result;
}

uint64_t tlv::parseV<vinyl::tlv::RespTapeEidResultEid>(unint64_t *a1, int a2)
{
  uint64_t *v3;
  uint64_t result;

  v3 = (uint64_t *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 0x10uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 2);
  return result;
}

void sub_2168CB940(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CB934);
}

uint64_t tlv::parseV<vinyl::tlv::RespTapeDeviceCapsResultTransactionId>(unint64_t *a1, int a2)
{
  unsigned int *v3;
  uint64_t result;

  v3 = (unsigned int *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 4uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168CB990(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CB984);
}

_BYTE *vinyl::tlv::parseField(_BYTE *a1, const unsigned __int8 *a2, _BYTE *a3)
{
  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  *a3 = *a1;
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 1), a2, 1uLL);
  a3[1] = a1[1];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 2), a2, 1uLL);
  a3[2] = a1[2];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 3), a2, 1uLL);
  a3[3] = a1[3];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 4), a2, 1uLL);
  a3[4] = a1[4];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 5), a2, 1uLL);
  a3[5] = a1[5];
  return a1 + 6;
}

unint64_t tlv::parseV<vinyl::tlv::RespTapeDeviceCapsRadioRelVers>(_BYTE **a1, int a2)
{
  unsigned int v3;
  unsigned __int16 v4;

  v4 = 0;
  v3 = 0;
  *a1 = vinyl::tlv::parseField(*a1, &(*a1)[a2], &v3);
  return v3 | ((unint64_t)v4 << 32);
}

void sub_2168CBAA8(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CBA8CLL);
}

uint64_t tlv::parseV<vinyl::tlv::RespTapeDeviceCapsRadioRel5GVers>(_BYTE **a1, int a2)
{
  unsigned __int16 v3;
  unsigned __int8 v4;

  v4 = 0;
  v3 = 0;
  *a1 = vs::tlv::parseField(*a1, &(*a1)[a2], &v3);
  return v3 | (v4 << 16);
}

void sub_2168CBB04(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CBAE8);
}

uint64_t tlv::parseV<vinyl::tlv::VinylSlotTestModeResp>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168CBB4C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CBB40);
}

uint64_t tlv::parseV<vinyl::tlv::RespEosState>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168CBB98(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CBB8CLL);
}

uint64_t tlv::parseV<vinyl::tlv::RespEosAssertionState>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168CBBE4(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CBBD8);
}

uint64_t tlv::parseV<vinyl::tlv::IndEosState>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168CBC30(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CBC24);
}

uint64_t tlv::parseV<vinyl::tlv::IndEosAssertionState>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168CBC7C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CBC70);
}

uint64_t tlv::parseV<vinyl::tlv::RespVSimEnableError>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168CBCC8(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CBCBCLL);
}

uint64_t tlv::parseV<vinyl::tlv::IndVSimEnableError>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168CBD14(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CBD08);
}

uint64_t tlv::parseV<nas::tlv::DataLinkQuality>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168CBD60(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CBD54);
}

uint64_t tlv::parseV<nas::tlv::VoiceLinkQuality>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168CBDAC(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CBDA0);
}

_QWORD *tlv::parseV<nas::tlv::EnhancedVoiceLinkQuality>@<X0>(char **a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  char *v4;
  _QWORD *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  v4 = &(*a1)[a2];
  result = std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(a3, *a1, v4, a2);
  *a1 = v4;
  return result;
}

void sub_2168CBE10(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CBE00);
}

void sub_2168CBE20(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t tlv::parseV<nas::tlv::CdmaSigInfo>(_BYTE **a1, int a2)
{
  _BYTE *v3;
  const unsigned __int8 *v4;
  _WORD *v5;
  unsigned int v7;

  v7 = 0;
  v3 = *a1;
  v4 = &v3[a2];
  v5 = nas::tlv::parseField<signed char,1,1>(v3, v4, &v7);
  *a1 = nas::tlv::parseField<short,-1,2>(v5, v4, (_WORD *)&v7 + 1);
  return v7;
}

void sub_2168CBE98(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CBE80);
}

char *nas::tlv::parseField(_BYTE *a1, const unsigned __int8 *a2, uint64_t a3)
{
  _WORD *v5;
  _WORD *v6;

  v5 = nas::tlv::parseField<signed char,1,1>(a1, a2, (_BYTE *)a3);
  v6 = nas::tlv::parseField<short,-1,2>(v5, a2, (_WORD *)(a3 + 2));
  tlv::throwIfNotEnoughBytes((unint64_t)v6, a2, 1uLL);
  *(_BYTE *)(a3 + 4) = *(_BYTE *)v6;
  tlv::throwIfNotEnoughBytes((unint64_t)v6 + 1, a2, 4uLL);
  *(_DWORD *)(a3 + 8) = *(_DWORD *)((char *)v6 + 1);
  return (char *)v6 + 5;
}

uint64_t tlv::parseV<nas::tlv::HdrSigInfo>(char **a1, int a2)
{
  uint64_t v3;
  int v4;

  v4 = 0;
  v3 = 0;
  *a1 = nas::tlv::parseField(*a1, (const unsigned __int8 *)&(*a1)[a2], (uint64_t)&v3);
  return v3;
}

void sub_2168CBF5C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CBF44);
}

uint64_t tlv::parseV<nas::tlv::GsmSigInfo>(_BYTE **a1, int a2)
{
  unsigned __int8 v3;

  v3 = 0;
  *a1 = nas::tlv::parseField<signed char,1,1>(*a1, &(*a1)[a2], &v3);
  return v3;
}

void sub_2168CBFAC(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CBF98);
}

uint64_t tlv::parseV<nas::tlv::WCdmaSigInfo>(_BYTE **a1, int a2)
{
  _BYTE *v3;
  const unsigned __int8 *v4;
  _WORD *v5;
  unsigned int v7;

  v7 = 0;
  v3 = *a1;
  v4 = &v3[a2];
  v5 = nas::tlv::parseField<signed char,1,1>(v3, v4, &v7);
  *a1 = nas::tlv::parseField<short,-1,2>(v5, v4, (_WORD *)&v7 + 1);
  return v7;
}

void sub_2168CC018(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CC000);
}

_WORD *nas::tlv::parseField(_BYTE *a1, const unsigned __int8 *a2, uint64_t a3)
{
  _BYTE *v5;
  _WORD *v6;
  _WORD *v7;

  v5 = nas::tlv::parseField<signed char,1,1>(a1, a2, (_BYTE *)a3);
  v6 = nas::tlv::parseField<signed char,1,1>(v5, a2, (_BYTE *)(a3 + 1));
  v7 = nas::tlv::parseField<short,-1,2>(v6, a2, (_WORD *)(a3 + 2));
  return nas::tlv::parseField<short,-1,2>(v7, a2, (_WORD *)(a3 + 4));
}

unint64_t tlv::parseV<nas::tlv::LteSigInfo>(_BYTE **a1, int a2)
{
  unsigned int v3;
  unsigned __int16 v4;

  v4 = 0;
  v3 = 0;
  *a1 = nas::tlv::parseField(*a1, &(*a1)[a2], (uint64_t)&v3);
  return v3 | ((unint64_t)v4 << 32);
}

void sub_2168CC0B8(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CC09CLL);
}

uint64_t tlv::parseV<nas::tlv::NrSigInfo>(_WORD **a1, int a2)
{
  _WORD *v3;
  const unsigned __int8 *v4;
  _WORD *v5;
  unsigned int v7;

  v7 = 0;
  v3 = *a1;
  v4 = (const unsigned __int8 *)v3 + a2;
  v5 = nas::tlv::parseField<short,-1,2>(v3, v4, &v7);
  *a1 = nas::tlv::parseField<short,-1,2>(v5, v4, (_WORD *)&v7 + 1);
  return v7;
}

void sub_2168CC124(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CC10CLL);
}

uint64_t tlv::parseV<nas::tlv::NrSigInfoExt>(_WORD **a1, int a2)
{
  unsigned __int16 v3;

  v3 = 0;
  *a1 = nas::tlv::parseField<short,-1,2>(*a1, (const unsigned __int8 *)*a1 + a2, &v3);
  return v3;
}

void sub_2168CC174(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CC160);
}

uint64_t tlv::parseV<nas::tlv::TDSCDMASigInfo>(_BYTE **a1, int a2)
{
  _BYTE *v3;
  const unsigned __int8 *v4;
  _WORD *v5;
  unsigned int v7;

  v7 = 0;
  v3 = *a1;
  v4 = &v3[a2];
  v5 = nas::tlv::parseField<signed char,1,1>(v3, v4, &v7);
  *a1 = nas::tlv::parseField<short,-1,2>(v5, v4, (_WORD *)&v7 + 1);
  return v7;
}

void sub_2168CC1E0(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CC1C8);
}

uint64_t tlv::parseV<nas::tlv::BBStatus>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168CC228(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CC21CLL);
}

uint64_t tlv::parseV<nas::tlv::BBCampFreq>(unint64_t *a1, int a2)
{
  uint64_t *v3;
  const unsigned __int8 *v4;
  uint64_t v5;

  v3 = (uint64_t *)*a1;
  v4 = (const unsigned __int8 *)(*a1 + a2);
  tlv::throwIfNotEnoughBytes(*a1, v4, 8uLL);
  v5 = *v3;
  tlv::throwIfNotEnoughBytes((unint64_t)(v3 + 1), v4, 4uLL);
  *a1 = (unint64_t)v3 + 12;
  return v5;
}

void sub_2168CC2A0(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CC28CLL);
}

uint64_t tlv::parseV<nas::tlv::BBSearchFreq>(unint64_t *a1, int a2)
{
  uint64_t *v3;
  const unsigned __int8 *v4;
  uint64_t v5;

  v3 = (uint64_t *)*a1;
  v4 = (const unsigned __int8 *)(*a1 + a2);
  tlv::throwIfNotEnoughBytes(*a1, v4, 8uLL);
  v5 = *v3;
  tlv::throwIfNotEnoughBytes((unint64_t)(v3 + 1), v4, 4uLL);
  *a1 = (unint64_t)v3 + 12;
  return v5;
}

void sub_2168CC318(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CC304);
}

unint64_t tlv::parseV<nas::tlv::BBHoppingList>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  unint64_t result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = nas::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = (unsigned __int8 *)result;
  return result;
}

void sub_2168CC3F4(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CC3E8);
}

void sub_2168CC404(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

unint64_t tlv::parseV<nas::tlv::BBNeighborList>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  unint64_t result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = nas::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = (unsigned __int8 *)result;
  return result;
}

void sub_2168CC45C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CC450);
}

void sub_2168CC46C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

unint64_t tlv::parseV<nas::tlv::BBHRPLMNList>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  unint64_t result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = nas::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = (unsigned __int8 *)result;
  return result;
}

void sub_2168CC4C4(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CC4B8);
}

void sub_2168CC4D4(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t tlv::parseV<nas::tlv::BBCampSecondFreq>(unint64_t *a1, int a2)
{
  uint64_t *v3;
  const unsigned __int8 *v4;
  uint64_t v5;

  v3 = (uint64_t *)*a1;
  v4 = (const unsigned __int8 *)(*a1 + a2);
  tlv::throwIfNotEnoughBytes(*a1, v4, 8uLL);
  v5 = *v3;
  tlv::throwIfNotEnoughBytes((unint64_t)(v3 + 1), v4, 4uLL);
  *a1 = (unint64_t)v3 + 12;
  return v5;
}

void sub_2168CC554(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CC540);
}

unint64_t tlv::parseV<nas::tlv::BBNeighborSecondList>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  unint64_t result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = nas::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = (unsigned __int8 *)result;
  return result;
}

void sub_2168CC5A4(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CC598);
}

void sub_2168CC5B4(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t tlv::parseV<nas::tlv::BBCampUplinkFreq>(unint64_t *a1, int a2)
{
  uint64_t *v3;
  const unsigned __int8 *v4;
  uint64_t v5;

  v3 = (uint64_t *)*a1;
  v4 = (const unsigned __int8 *)(*a1 + a2);
  tlv::throwIfNotEnoughBytes(*a1, v4, 8uLL);
  v5 = *v3;
  tlv::throwIfNotEnoughBytes((unint64_t)(v3 + 1), v4, 4uLL);
  *a1 = (unint64_t)v3 + 12;
  return v5;
}

void sub_2168CC634(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CC620);
}

unint64_t tlv::parseV<nas::tlv::DLSCellFrequencyList>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  unint64_t result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = nas::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = (unsigned __int8 *)result;
  return result;
}

void sub_2168CC684(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CC678);
}

void sub_2168CC694(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

unint64_t tlv::parseV<nas::tlv::BBSearchFreqList>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  unint64_t result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = nas::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = (unsigned __int8 *)result;
  return result;
}

void sub_2168CC6EC(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CC6E0);
}

void sub_2168CC6FC(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<nas::tlv::BBFreqItem>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;

  v2 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 4;
  if (a2 <= v2)
  {
    if (a2 < v2)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 16 * a2;
  }
  else
  {
    std::vector<nas::tlv::BBFreqItem>::__append((char **)a1, a2 - v2);
  }
}

void std::vector<nas::tlv::BBFreqItem>::__append(char **a1, unint64_t a2)
{
  uint64_t v4;
  char *v5;
  char *v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;
  int v20;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 4)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 16 * a2);
      v7 += 16 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = v7 - *a1;
    v9 = a2 + (v8 >> 4);
    if (v9 >> 60)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 4;
    v11 = v5 - *a1;
    if (v11 >> 3 > v9)
      v9 = v11 >> 3;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF0)
      v12 = 0xFFFFFFFFFFFFFFFLL;
    else
      v12 = v9;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::array<unsigned char,16ul>>>(v4, v12);
    else
      v13 = 0;
    v14 = &v13[16 * v10];
    v15 = &v13[16 * v12];
    bzero(v14, 16 * a2);
    v16 = &v14[16 * a2];
    v18 = *a1;
    v17 = a1[1];
    if (v17 != *a1)
    {
      do
      {
        v19 = *((_QWORD *)v17 - 2);
        v17 -= 16;
        v20 = *((_DWORD *)v17 + 2);
        *((_QWORD *)v14 - 2) = v19;
        v14 -= 16;
        *((_DWORD *)v14 + 2) = v20;
      }
      while (v17 != v18);
      v17 = *a1;
    }
    *a1 = v14;
    a1[1] = v16;
    a1[2] = v15;
    if (v17)
      operator delete(v17);
  }
}

unsigned __int8 *wds::tlv::parseField(unsigned __int8 *a1, const unsigned __int8 *a2, _DWORD *a3)
{
  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  *a3 = *a1;
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 1), a2, 4uLL);
  a3[1] = *(_DWORD *)(a1 + 1);
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 5), a2, 4uLL);
  a3[2] = *(_DWORD *)(a1 + 5);
  return a1 + 9;
}

char *wds::tlv::writeField(char *a1, _QWORD *a2)
{
  _QWORD *v2;
  size_t v4;
  size_t v5;
  uint64_t v6;

  v2 = a2;
  v4 = a2[1];
  if (*((char *)a2 + 23) >= 0)
  {
    v5 = *((unsigned __int8 *)a2 + 23);
  }
  else
  {
    a2 = (_QWORD *)*a2;
    v5 = v4;
  }
  memcpy(a1, a2, v5);
  v6 = *((unsigned __int8 *)v2 + 23);
  if ((v6 & 0x80u) != 0)
    v6 = v2[1];
  return &a1[v6];
}

uint64_t wds::tlv::getFieldSize(uint64_t a1)
{
  if (*(char *)(a1 + 23) >= 0)
    return *(unsigned __int8 *)(a1 + 23);
  else
    return *(_QWORD *)(a1 + 8);
}

_DWORD *wds::tlv::writeField(_DWORD *a1, _DWORD *a2)
{
  *a1 = *a2;
  return a1 + 1;
}

uint64_t wds::tlv::writeField(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)a1 = *(_BYTE *)a2;
  *(_DWORD *)(a1 + 1) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(a1 + 5) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a1 + 9) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a1 + 13) = *(_DWORD *)(a2 + 16);
  *(_BYTE *)(a1 + 17) = *(_BYTE *)(a2 + 20);
  *(_DWORD *)(a1 + 18) = *(_DWORD *)(a2 + 24);
  *(_BYTE *)(a1 + 22) = *(_BYTE *)(a2 + 28);
  *(_BYTE *)(a1 + 23) = *(_BYTE *)(a2 + 29);
  *(_BYTE *)(a1 + 24) = *(_BYTE *)(a2 + 30);
  *(_DWORD *)(a1 + 25) = *(_DWORD *)(a2 + 32);
  *(_DWORD *)(a1 + 29) = *(_DWORD *)(a2 + 36);
  *(_BYTE *)(a1 + 33) = *(_BYTE *)(a2 + 40);
  return a1 + 34;
}

_WORD *wds::tlv::writeField(_WORD *a1, _WORD *a2)
{
  *a1 = *a2;
  return a1 + 1;
}

uint64_t tlv::parseV<wds::tlv::DormancyStatus>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168CCA0C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CCA00);
}

uint64_t tlv::parseV<wds::tlv::CurrentDataBearerTech>(unint64_t *a1, int a2)
{
  uint64_t v3;
  int v4;

  v4 = 0;
  v3 = 0;
  *a1 = wds::tlv::parseField(*a1, (const unsigned __int8 *)(*a1 + a2), (uint64_t)&v3);
  return v3;
}

void sub_2168CCAD8(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CCAC0);
}

unsigned __int8 *wds::tlv::parseField(unsigned __int8 *a1, const unsigned __int8 *a2, uint64_t a3)
{
  unsigned __int8 *v6;
  _QWORD *v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  char *v15;
  char *v16;
  _DWORD *v17;
  _DWORD *v18;
  char *v19;
  uint64_t v20;
  int v21;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  *(_DWORD *)a3 = *a1;
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 1), a2, 1uLL);
  *(_BYTE *)(a3 + 4) = a1[1];
  v6 = a1 + 2;
  if (v6 < a2)
  {
    v7 = (_QWORD *)(a3 + 8);
    do
    {
      v9 = *(_QWORD *)(a3 + 16);
      v8 = *(_QWORD *)(a3 + 24);
      if (v9 >= v8)
      {
        v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v9 - *v7) >> 2);
        v12 = v11 + 1;
        if (v11 + 1 > 0x1555555555555555)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v13 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v8 - *v7) >> 2);
        if (2 * v13 > v12)
          v12 = 2 * v13;
        if (v13 >= 0xAAAAAAAAAAAAAAALL)
          v14 = 0x1555555555555555;
        else
          v14 = v12;
        if (v14)
          v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::CurrentDataSystem>>(a3 + 24, v14);
        else
          v15 = 0;
        v16 = &v15[12 * v11];
        *((_DWORD *)v16 + 2) = 0;
        *(_QWORD *)v16 = 0;
        v18 = *(_DWORD **)(a3 + 8);
        v17 = *(_DWORD **)(a3 + 16);
        v19 = v16;
        if (v17 != v18)
        {
          do
          {
            v20 = *(_QWORD *)(v17 - 3);
            v17 -= 3;
            v21 = v17[2];
            *(_QWORD *)(v19 - 12) = v20;
            v19 -= 12;
            *((_DWORD *)v19 + 2) = v21;
          }
          while (v17 != v18);
          v17 = (_DWORD *)*v7;
        }
        v10 = v16 + 12;
        *(_QWORD *)(a3 + 8) = v19;
        *(_QWORD *)(a3 + 16) = v16 + 12;
        *(_QWORD *)(a3 + 24) = &v15[12 * v14];
        if (v17)
          operator delete(v17);
      }
      else
      {
        *(_DWORD *)(v9 + 8) = 0;
        *(_QWORD *)v9 = 0;
        v10 = (char *)(v9 + 12);
      }
      *(_QWORD *)(a3 + 16) = v10;
      v6 = wds::tlv::parseField(v6, a2, (_DWORD *)v10 - 3);
    }
    while (v6 < a2);
  }
  return v6;
}

unsigned __int8 *tlv::parseV<wds::tlv::DataSystemStatus>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  unsigned __int8 *result;

  *a3 = 0u;
  a3[1] = 0u;
  result = wds::tlv::parseField(*a1, &(*a1)[a2], (uint64_t)a3);
  *a1 = result;
  return result;
}

void sub_2168CCCAC(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CCCA0);
}

void sub_2168CCCBC(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)(v1 + 8);
  if (v3)
  {
    *(_QWORD *)(v1 + 16) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t tlv::parseV<wds::tlv::DataTransmitSpeed>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168CCD10(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CCD04);
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::CurrentDataSystem>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x1555555555555556)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(12 * a2);
}

const char *nas::asString(unsigned int a1)
{
  if (a1 > 0xC)
    return "(unknown)";
  else
    return off_24D5C2DA8[(char)a1];
}

{
  if (a1 > 5)
    return "???";
  else
    return off_24D5C2E10[(char)a1];
}

{
  if (a1 > 4)
    return "???";
  else
    return off_24D5C2E40[(__int16)a1];
}

{
  if (a1 > 4)
    return "???";
  else
    return off_24D5C2E68[a1];
}

{
  if (a1 > 2)
    return "???";
  else
    return off_24D5C2E90[a1];
}

uint64_t nas::asBand(uint64_t result)
{
  uint64_t v1;

  if (result >= 0x2000)
  {
    if (result > 0x7FFFFFFF)
    {
      if (result <= 0x1FFFFFFFFFFFFFFLL)
      {
        if (result == 0x80000000)
          return 0x8000;
        if (result == 0x100000000000000)
          return 0x10000;
      }
      else
      {
        switch(result)
        {
          case 0x200000000000000:
            return 0x20000;
          case 0x400000000000000:
            return 0x40000;
          case 0x800000000000000:
            return 0x80000;
        }
      }
    }
    else if (result < 0x8000)
    {
      if (result == 0x2000)
        return 1024;
      if (result == 0x4000)
        return 2048;
    }
    else
    {
      switch(result)
      {
        case 0x8000:
          return 4096;
        case 0x10000000:
          return 0x2000;
        case 0x20000000:
          return 0x4000;
      }
    }
    return 0;
  }
  if (result > 31)
  {
    if (result <= 1023)
    {
      if (result == 32 || result == 64)
        return result;
    }
    else
    {
      switch(result)
      {
        case 1024:
          return 128;
        case 2048:
          return 256;
        case 4096:
          return 512;
      }
    }
    return 0;
  }
  v1 = result - 1;
  result = 1;
  switch(v1)
  {
    case 0:
      return result;
    case 1:
      result = 2;
      break;
    case 3:
      result = 4;
      break;
    case 7:
      result = 8;
      break;
    default:
      return 0;
  }
  return result;
}

{
  if ((int)result > 1023)
  {
    if ((int)result >= 0x8000)
    {
      if ((int)result < 0x20000)
      {
        if ((_DWORD)result == 0x8000)
          return 0x80000000;
        if ((_DWORD)result == 0x10000)
          return 0x100000000000000;
      }
      else
      {
        switch((_DWORD)result)
        {
          case 0x20000:
            return 0x200000000000000;
          case 0x40000:
            return 0x400000000000000;
          case 0x80000:
            return 0x800000000000000;
        }
      }
    }
    else if ((int)result <= 4095)
    {
      if ((_DWORD)result == 1024)
        return 0x2000;
      if ((_DWORD)result == 2048)
        return 0x4000;
    }
    else
    {
      switch((_DWORD)result)
      {
        case 0x1000:
          return 0x8000;
        case 0x2000:
          return 0x10000000;
        case 0x4000:
          return 0x20000000;
      }
    }
    return 0;
  }
  if ((int)result > 31)
  {
    if ((int)result <= 127)
    {
      if ((_DWORD)result == 32)
        return 32;
      if ((_DWORD)result == 64)
        return 64;
    }
    else
    {
      switch((_DWORD)result)
      {
        case 0x80:
          return 1024;
        case 0x100:
          return 2048;
        case 0x200:
          return 4096;
      }
    }
    return 0;
  }
  result = result;
  switch((int)result)
  {
    case 1:
      return result;
    case 2:
      result = 2;
      break;
    case 3:
    case 5:
    case 6:
    case 7:
      return 0;
    case 4:
      result = 4;
      break;
    case 8:
      result = 8;
      break;
    default:
      if ((_DWORD)result != 16)
        return 0;
      result = 16;
      break;
  }
  return result;
}

{
  result = result;
  switch((int)result)
  {
    case 1:
      return result;
    case 2:
      result = 2;
      break;
    case 3:
    case 5:
    case 6:
    case 7:
      goto LABEL_6;
    case 4:
      result = 4;
      break;
    case 8:
      result = 8;
      break;
    default:
      if ((_DWORD)result == 16)
      {
        result = 16;
      }
      else if ((_DWORD)result == 32)
      {
        result = 32;
      }
      else
      {
LABEL_6:
        result = 0;
      }
      break;
  }
  return result;
}

const char *nas::asString(int a1)
{
  const char *v1;

  v1 = "kNormal";
  if (a1 == 1)
    v1 = "kTemporary";
  if (a1 == 2)
    return "kPermanent";
  else
    return v1;
}

{
  const char *v1;

  v1 = "Unknown";
  if (a1 == 1)
    v1 = "nas::ImsCallStatus::Stop";
  if (a1)
    return v1;
  else
    return "nas::ImsCallStatus::Start";
}

{
  const char *v1;
  const char *v2;

  v1 = "kNR5g";
  v2 = "???";
  if (a1 == 8)
    v2 = "kLTE";
  if (a1 != 12)
    v1 = v2;
  if (a1)
    return v1;
  else
    return "kNoService";
}

{
  const char *v1;

  v1 = "???";
  if (a1 == 1)
    v1 = "kSecondary";
  if (a1)
    return v1;
  else
    return "kPrimary";
}

uint64_t nas::asBand(uint64_t a1)
{
  if (a1 < 0x20000)
  {
    if (a1 > 511)
    {
      if (a1 == 512)
        return 4;
      if (a1 == 0x10000)
        return 8;
    }
    else
    {
      if (a1 == 128)
        return 1;
      if (a1 == 256)
        return 2;
    }
  }
  else if (a1 < 0x80000)
  {
    if (a1 == 0x20000)
      return 16;
    if (a1 == 0x40000)
      return 32;
  }
  else
  {
    switch(a1)
    {
      case 0x80000:
        return 64;
      case 0x100000:
        return 128;
      case 0x200000:
        return 256;
    }
  }
  return 0;
}

{
  if (a1 <= 0x7FFFFFF)
  {
    if (a1 <= 0xFFFFFF)
    {
      if (a1 == 0x400000)
        return 1;
      if (a1 == 0x800000)
        return 2;
    }
    else
    {
      switch(a1)
      {
        case 0x1000000:
          return 4;
        case 0x2000000:
          return 8;
        case 0x4000000:
          return 16;
      }
    }
  }
  else if (a1 > 0x3FFFFFFFFFFFFLL)
  {
    switch(a1)
    {
      case 0x4000000000000:
        return 256;
      case 0x1000000000000000:
        return 512;
      case 0x2000000000000000:
        return 1024;
    }
  }
  else
  {
    switch(a1)
    {
      case 0x8000000:
        return 32;
      case 0x1000000000000:
        return 64;
      case 0x2000000000000:
        return 128;
    }
  }
  return 0;
}

{
  uint64_t v1;
  uint64_t result;

  v1 = a1 - 1;
  result = 1;
  switch(v1)
  {
    case 0:
      return result;
    case 1:
      result = 2;
      break;
    case 3:
      result = 4;
      break;
    case 7:
      result = 8;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

uint64_t nas::asBand(int a1)
{
  int v1;
  uint64_t result;

  if (a1 > 31)
  {
    if (a1 > 127)
    {
      if (a1 == 128)
        return 0x100000;
      if (a1 == 256)
        return 0x200000;
    }
    else
    {
      if (a1 == 32)
        return 0x40000;
      if (a1 == 64)
        return 0x80000;
    }
    return 0;
  }
  v1 = a1 - 1;
  result = 128;
  switch(v1)
  {
    case 0:
      return result;
    case 1:
      result = 256;
      break;
    case 3:
      result = 512;
      break;
    case 7:
      result = 0x10000;
      break;
    default:
      return 0;
  }
  return result;
}

{
  int v1;
  uint64_t result;

  if (a1 > 63)
  {
    if (a1 <= 255)
    {
      if (a1 == 64)
        return 0x1000000000000;
      if (a1 == 128)
        return 0x2000000000000;
    }
    else
    {
      switch(a1)
      {
        case 256:
          return 0x4000000000000;
        case 512:
          return 0x1000000000000000;
        case 1024:
          return 0x2000000000000000;
      }
    }
    return 0;
  }
  v1 = a1 - 1;
  result = 0x400000;
  switch(v1)
  {
    case 0:
      return result;
    case 1:
      result = 0x800000;
      break;
    case 3:
      result = 0x1000000;
      break;
    case 7:
      result = 0x2000000;
      break;
    default:
      return 0;
  }
  return result;
}

uint64_t nas::convert(uint64_t result)
{
  if ((result - 1) >= 6)
    return 0;
  else
    return result;
}

_BYTE *nas::operator|=(_BYTE *result, char a2)
{
  *result |= a2;
  return result;
}

char *nas::tlv::writeField(char *a1, int *a2)
{
  int v2;
  char v3;

  v2 = *a2;
  if (*a2 > 6)
  {
    if (v2 == 7)
    {
      v3 = 8;
      goto LABEL_11;
    }
    if (v2 == 10)
    {
      v3 = 12;
      goto LABEL_11;
    }
LABEL_8:
    v3 = 0;
    goto LABEL_11;
  }
  if (!v2)
  {
    v3 = 4;
    goto LABEL_11;
  }
  if (v2 != 2)
    goto LABEL_8;
  v3 = 5;
LABEL_11:
  *a1 = v3;
  return a1 + 1;
}

unsigned __int8 *nas::tlv::parseField(unsigned __int8 *a1, const unsigned __int8 *a2, int *a3)
{
  unsigned int v5;
  int v6;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  v5 = *a1 - 4;
  if (v5 > 8)
    v6 = 11;
  else
    v6 = dword_216A9C370[(char)v5];
  *a3 = v6;
  return a1 + 1;
}

_BYTE *nas::tlv::parseField<signed char,1,1>(_BYTE *a1, const unsigned __int8 *a2, _BYTE *a3)
{
  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  *a3 = *a1;
  return a1 + 1;
}

_WORD *nas::tlv::parseField<short,-1,2>(_WORD *a1, const unsigned __int8 *a2, _WORD *a3)
{
  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 2uLL);
  *a3 = *a1;
  return a1 + 1;
}

uint64_t tlv::parseV<pdc::tlv::IndicationToken>(unint64_t *a1, int a2)
{
  unsigned int *v3;
  uint64_t result;

  v3 = (unsigned int *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 4uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168CD728(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CD71CLL);
}

uint64_t tlv::parseV<pdc::tlv::ErrorCode>(unint64_t *a1, int a2)
{
  unsigned __int16 *v3;
  uint64_t result;

  v3 = (unsigned __int16 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 2uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168CD774(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CD768);
}

__n128 tlv::writeV<sft::tlv::SecurityCredentials>(uint64_t *a1, uint64_t a2)
{
  uint64_t v2;
  __n128 result;

  v2 = *a1;
  *(_QWORD *)v2 = *(_QWORD *)a2;
  result = *(__n128 *)(a2 + 8);
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a2 + 24);
  *(__n128 *)(v2 + 8) = result;
  *a1 = v2 + 40;
  return result;
}

_DWORD *sft::tlv::writeField(_BYTE *a1, _DWORD *a2)
{
  _DWORD *v2;
  int *v3;
  int *v4;
  int v5;
  _DWORD *result;
  int *v7;
  int *v8;
  int v9;

  *a1 = (a2[2] - *a2) >> 2;
  v2 = a1 + 1;
  v3 = *(int **)a2;
  v4 = (int *)*((_QWORD *)a2 + 1);
  while (v3 != v4)
  {
    v5 = *v3++;
    *v2++ = v5;
  }
  *(_BYTE *)v2 = (a2[8] - a2[6]) >> 2;
  result = (_DWORD *)((char *)v2 + 1);
  v7 = (int *)*((_QWORD *)a2 + 3);
  v8 = (int *)*((_QWORD *)a2 + 4);
  while (v7 != v8)
  {
    v9 = *v7++;
    *result++ = v9;
  }
  return result;
}

unint64_t tlv::size<sft::tlv::EARFCN>(_QWORD *a1)
{
  unint64_t v1;
  unint64_t v2;

  v1 = (a1[4] - a1[3]) & 0xFFFFFFFFFFFFFFFCLL;
  if (a1[4] == a1[3])
    v1 = 0;
  v2 = ((a1[1] - *a1) & 0xFFFFFFFFFFFFFFFCLL) + 5;
  if (a1[1] == *a1)
    v2 = 5;
  return v2 + v1;
}

_DWORD *tlv::writeV<sft::tlv::EARFCN>(_BYTE **a1, _DWORD *a2)
{
  _DWORD *result;

  result = sft::tlv::writeField(*a1, a2);
  *a1 = result;
  return result;
}

uint64_t sft::tlv::writeField(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
  *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
  *(_DWORD *)(a1 + 52) = *(_DWORD *)(a2 + 52);
  *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
  *(_DWORD *)(a1 + 64) = *(_DWORD *)(a2 + 64);
  *(_QWORD *)(a1 + 68) = *(_QWORD *)(a2 + 72);
  *(_DWORD *)(a1 + 76) = *(_DWORD *)(a2 + 80);
  *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 88);
  v3 = a1 + 89;
  *(_BYTE *)(a1 + 88) = *(_DWORD *)(a2 + 104) - *(_DWORD *)(a2 + 96);
  memcpy((void *)(a1 + 89), *(const void **)(a2 + 96), *(_QWORD *)(a2 + 104) - *(_QWORD *)(a2 + 96));
  v4 = v3 + *(_QWORD *)(a2 + 104) - *(_QWORD *)(a2 + 96);
  *(_DWORD *)v4 = *(_DWORD *)(a2 + 120);
  *(_BYTE *)(v4 + 4) = *(_BYTE *)(a2 + 124);
  *(_DWORD *)(v4 + 5) = *(_DWORD *)(a2 + 128);
  *(_QWORD *)(v4 + 9) = *(_QWORD *)(a2 + 136);
  *(_BYTE *)(v4 + 17) = *(_BYTE *)(a2 + 144);
  *(_QWORD *)(v4 + 18) = *(_QWORD *)(a2 + 152);
  return v4 + 26;
}

uint64_t tlv::size<sft::tlv::LocationData>(uint64_t a1)
{
  return *(_QWORD *)(a1 + 104) - *(_QWORD *)(a1 + 96) + 118;
}

uint64_t tlv::writeV<sft::tlv::LocationData>(uint64_t *a1, uint64_t a2)
{
  uint64_t result;

  result = sft::tlv::writeField(*a1, a2);
  *a1 = result;
  return result;
}

uint64_t tlv::parseV<sft::tlv::DeactivationReason>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168CD9C0(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CD9B4);
}

uint64_t tlv::parseV<sft::tlv::CellularTXDeferTime>(unint64_t *a1, int a2)
{
  unsigned int *v3;
  uint64_t result;

  v3 = (unsigned int *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 4uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168CDA0C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CDA00);
}

uint64_t tlv::parseV<sft::tlv::SftTxDeferTime>(unint64_t *a1, int a2)
{
  uint64_t *v3;
  uint64_t result;

  v3 = (uint64_t *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 8uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168CDA58(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CDA4CLL);
}

unint64_t tlv::size<sft::tlv::TargetLineSets>(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *(_QWORD *)(a1 + 8);
  v2 = *(_QWORD *)(a1 + 16);
  if (v1 == v2)
    return 5;
  else
    return 139 * ((v2 - v1 - 139) / 0x8BuLL) + 144;
}

_BYTE **tlv::writeV<sft::tlv::TargetLineSets>(_BYTE **result, uint64_t a2)
{
  _BYTE *v2;
  _BYTE *v3;
  uint64_t v4;
  uint64_t v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;

  v2 = *result;
  *v2 = *(_BYTE *)a2;
  v3 = v2 + 2;
  v2[1] = 35 * (*(_DWORD *)(a2 + 16) - *(_DWORD *)(a2 + 8));
  v4 = *(_QWORD *)(a2 + 8);
  v5 = *(_QWORD *)(a2 + 16);
  while (v4 != v5)
  {
    *v3 = *(_BYTE *)v4;
    *(_OWORD *)(v3 + 1) = *(_OWORD *)(v4 + 1);
    v6 = *(_OWORD *)(v4 + 17);
    v7 = *(_OWORD *)(v4 + 33);
    v8 = *(_OWORD *)(v4 + 49);
    *(_QWORD *)(v3 + 62) = *(_QWORD *)(v4 + 62);
    *(_OWORD *)(v3 + 49) = v8;
    *(_OWORD *)(v3 + 33) = v7;
    *(_OWORD *)(v3 + 17) = v6;
    v9 = *(_OWORD *)(v4 + 102);
    v10 = *(_OWORD *)(v4 + 118);
    v11 = *(_QWORD *)(v4 + 131);
    *(_OWORD *)(v3 + 86) = *(_OWORD *)(v4 + 86);
    *(_QWORD *)(v3 + 131) = v11;
    *(_OWORD *)(v3 + 118) = v10;
    *(_OWORD *)(v3 + 102) = v9;
    *(_OWORD *)(v3 + 70) = *(_OWORD *)(v4 + 70);
    v3 += 139;
    v4 += 139;
  }
  *result = v3;
  return result;
}

uint64_t tlv::parseV<sft::tlv::SharedSecredUsage>(unint64_t *a1, int a2)
{
  unint64_t v3;
  const unsigned __int8 *v4;
  __int128 v6;

  v3 = *a1;
  v4 = (const unsigned __int8 *)(*a1 + a2);
  tlv::throwIfNotEnoughBytes(*a1, v4, 1uLL);
  LOBYTE(v6) = *(_BYTE *)v3;
  tlv::throwIfNotEnoughBytes(v3 + 1, v4, 8uLL);
  *(_QWORD *)((char *)&v6 + 1) = *(_QWORD *)(v3 + 1);
  *a1 = v3 + 9;
  return v6;
}

void sub_2168CDBFC(_Unwind_Exception *a1, int a2)
{
  _QWORD *v2;

  if (a2)
  {
    __cxa_begin_catch(a1);
    *v2 = 0;
    __cxa_end_catch();
    JUMPOUT(0x2168CDBC8);
  }
  _Unwind_Resume(a1);
}

uint64_t tlv::parseV<sft::tlv::SuspendReason>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168CDC50(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CDC44);
}

uint64_t tlv::parseV<sft::tlv::RequestedAction>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168CDC9C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CDC90);
}

__n128 tlv::parseV<sft::tlv::GeneratedAppKey>@<Q0>(unint64_t *a1@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  unint64_t v5;
  __n128 result;
  __int128 v7;

  *a3 = 0u;
  a3[1] = 0u;
  v5 = *a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 0x20uLL);
  result = *(__n128 *)v5;
  v7 = *(_OWORD *)(v5 + 16);
  *a3 = *(_OWORD *)v5;
  a3[1] = v7;
  *a1 = v5 + 32;
  return result;
}

void sub_2168CDD04(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
}

uint64_t tlv::parseV<sft::tlv::ConnectionStatus>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168CDD54(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CDD48);
}

uint64_t tlv::parseV<sft::tlv::RegistrationStatus>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168CDDA0(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CDD94);
}

uint64_t tlv::parseV<sft::tlv::RSSI>(unint64_t *a1, int a2)
{
  unsigned int *v3;
  uint64_t result;

  v3 = (unsigned int *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 4uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168CDDEC(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CDDE0);
}

uint64_t tlv::parseV<sft::tlv::CongestionStatus>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168CDE38(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CDE2CLL);
}

uint64_t tlv::parseV<sft::tlv::CurrentFMNum>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168CDE84(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CDE78);
}

uint64_t tlv::parseV<sft::tlv::BBUID>(unint64_t *a1, int a2)
{
  unsigned int *v3;
  uint64_t result;

  v3 = (unsigned int *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 4uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168CDED0(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CDEC4);
}

uint64_t tlv::parseV<sft::tlv::GUID>(unint64_t *a1, int a2)
{
  uint64_t *v3;
  uint64_t result;

  v3 = (uint64_t *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 0x10uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 2);
  return result;
}

void sub_2168CDF20(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CDF14);
}

uint64_t tlv::parseV<sft::tlv::BBMessageID>(unint64_t *a1, int a2)
{
  unsigned __int16 *v3;
  uint64_t result;

  v3 = (unsigned __int16 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 2uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168CDF70(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CDF64);
}

_QWORD *tlv::parseV<sft::tlv::Message>@<X0>(char **a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  char *v4;
  _QWORD *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  v4 = &(*a1)[a2];
  result = std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(a3, *a1, v4, a2);
  *a1 = v4;
  return result;
}

void sub_2168CDFD4(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CDFC4);
}

void sub_2168CDFE4(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t tlv::parseV<sft::tlv::MessageSendResult>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168CE038(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CE02CLL);
}

uint64_t tlv::size<sft::tlv::FileTransferInfo>(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8) + 9;
}

void *tlv::writeV<sft::tlv::FileTransferInfo>(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  void *result;

  v4 = *a1;
  *(_BYTE *)v4 = *(_BYTE *)a2;
  *(_BYTE *)(v4 + 1) = *(_BYTE *)(a2 + 1);
  *(_WORD *)(v4 + 2) = *(_WORD *)(a2 + 2);
  *(_WORD *)(v4 + 4) = *(_WORD *)(a2 + 4);
  v5 = v4 + 6;
  result = memcpy((void *)(v4 + 6), *(const void **)(a2 + 8), *(_QWORD *)(a2 + 16) - *(_QWORD *)(a2 + 8));
  *a1 = v5 + *(_QWORD *)(a2 + 16) - *(_QWORD *)(a2 + 8);
  return result;
}

uint64_t tlv::parseV<sft::tlv::ExpectedSegmentInfo>(unint64_t *a1, int a2)
{
  unsigned __int16 *v3;
  uint64_t result;

  v3 = (unsigned __int16 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 2uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168CE108(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CE0FCLL);
}

uint64_t tlv::parseV<sft::tlv::TransferStatus>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  const unsigned __int8 *v4;
  int v5;
  int v6;

  v3 = (unsigned __int8 *)*a1;
  v4 = (const unsigned __int8 *)(*a1 + a2);
  tlv::throwIfNotEnoughBytes(*a1, v4, 1uLL);
  v5 = *v3;
  tlv::throwIfNotEnoughBytes((unint64_t)(v3 + 1), v4, 1uLL);
  v6 = v3[1];
  *a1 = (unint64_t)(v3 + 2);
  return v5 | (v6 << 8);
}

void sub_2168CE180(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CE16CLL);
}

BOOL tlv::parseV<sft::tlv::HWSupport>(unint64_t *a1, int a2)
{
  unsigned __int8 *v3;
  _BOOL8 result;

  v3 = (unsigned __int8 *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 1uLL);
  result = *v3 != 0;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168CE1D4(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CE1C8);
}

_BYTE *sft::tlv::writeField(_BYTE *a1, _DWORD *a2)
{
  _BYTE *v2;
  int *v3;
  int *v4;
  int v5;
  _BYTE *v6;
  uint64_t v7;
  uint64_t v8;
  _BYTE *result;

  *a1 = (a2[2] - *a2) >> 2;
  v2 = a1 + 1;
  v3 = *(int **)a2;
  v4 = (int *)*((_QWORD *)a2 + 1);
  while (v3 != v4)
  {
    v5 = *v3++;
    *(_DWORD *)v2 = v5;
    v2 += 4;
  }
  *(_DWORD *)v2 = a2[6];
  v6 = v2 + 5;
  v2[4] = -85 * ((a2[10] - a2[8]) >> 2);
  v7 = *((_QWORD *)a2 + 4);
  v8 = *((_QWORD *)a2 + 5);
  if (v7 == v8)
    return v2 + 5;
  do
  {
    *(_DWORD *)v6 = *(_DWORD *)v7;
    *((_DWORD *)v6 + 1) = *(_DWORD *)(v7 + 4);
    result = v6 + 9;
    v6[8] = *(_BYTE *)(v7 + 8);
    v7 += 12;
    v6 += 9;
  }
  while (v7 != v8);
  return result;
}

unint64_t sft::tlv::getFieldSize(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;

  v1 = a1[4];
  v2 = a1[5];
  if (v1 == v2)
    v3 = 0;
  else
    v3 = 9 * ((v2 - v1 - 12) / 0xCuLL) + 9;
  v4 = ((a1[1] - *a1) & 0xFFFFFFFFFFFFFFFCLL) + 6;
  if (a1[1] == *a1)
    v4 = 6;
  return v3 + v4;
}

unint64_t tlv::size<sft::tlv::HeatMapData>(_QWORD *a1)
{
  return sft::tlv::getFieldSize(a1) + 3;
}

_BYTE *tlv::writeV<sft::tlv::HeatMapData>(_BYTE **a1, _DWORD *a2)
{
  _BYTE *result;

  result = sft::tlv::writeField(*a1, a2);
  *a1 = result;
  return result;
}

uint64_t tlv::parseV<sft::tlv::ServiceOutageInfoIdentifier>(unint64_t *a1, int a2)
{
  unsigned int *v3;
  uint64_t result;

  v3 = (unsigned int *)*a1;
  tlv::throwIfNotEnoughBytes(*a1, (const unsigned __int8 *)(*a1 + a2), 4uLL);
  result = *v3;
  *a1 = (unint64_t)(v3 + 1);
  return result;
}

void sub_2168CE354(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CE348);
}

unint64_t sft::tlv::parseField(unint64_t a1, const unsigned __int8 *a2, uint64_t a3)
{
  tlv::throwIfNotEnoughBytes(a1, a2, 1uLL);
  *(_BYTE *)a3 = *(_BYTE *)a1;
  tlv::throwIfNotEnoughBytes(a1 + 1, a2, 8uLL);
  *(_QWORD *)(a3 + 8) = *(_QWORD *)(a1 + 1);
  tlv::throwIfNotEnoughBytes(a1 + 9, a2, 8uLL);
  *(_QWORD *)(a3 + 16) = *(_QWORD *)(a1 + 9);
  return a1 + 17;
}

unint64_t sft::tlv::parseField(unsigned __int8 *a1, const unsigned __int8 *a2, uint64_t *a3)
{
  unint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t result;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  v7 = *a1;
  v6 = (unint64_t)(a1 + 1);
  std::vector<nas::tlv::GsmCell>::resize((uint64_t)a3, v7);
  v8 = *a3;
  v9 = a3[1];
  while (1)
  {
    result = v6;
    if (v8 == v9)
      break;
    v6 = sft::tlv::parseField(v6, a2, v8);
    v8 += 24;
  }
  return result;
}

unint64_t tlv::parseV<sft::tlv::SatelliteOutages>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  unint64_t result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = sft::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = (unsigned __int8 *)result;
  return result;
}

void sub_2168CE47C(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CE470);
}

void sub_2168CE48C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *tlv::parseV<sft::tlv::BroadcastInfoBlob>@<X0>(char **a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  char *v4;
  _QWORD *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  v4 = &(*a1)[a2];
  result = std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(a3, *a1, v4, a2);
  *a1 = v4;
  return result;
}

void sub_2168CE4F8(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x2168CE4E8);
}

void sub_2168CE508(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

float tlv::writeV<sft::tlv::Orientation>(_DWORD **a1, float *a2)
{
  _DWORD *v2;
  float result;

  v2 = *a1;
  result = *a2;
  *v2 = *(_DWORD *)a2;
  *a1 = v2 + 1;
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<sft::tlv::TargetLineSet>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x1D77B654B82C33ALL)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(139 * a2);
}

_QWORD *QMIDataContextIP::QMIDataContextIP(_QWORD *a1, uint64_t *a2, uint64_t *a3, char a4, uint64_t *a5, int a6, NSObject **a7, uint64_t *a8)
{
  std::__shared_weak_count *v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  NSObject *v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  uint64_t v38;
  std::__shared_weak_count *v39;
  dispatch_object_t object;
  uint64_t v41;
  std::__shared_weak_count *v42;
  uint64_t v43;
  std::__shared_weak_count *v44;
  uint64_t v45;
  std::__shared_weak_count *v46;

  v12 = (std::__shared_weak_count *)a2[1];
  v45 = *a2;
  v46 = v12;
  if (v12)
  {
    p_shared_owners = (unint64_t *)&v12->__shared_owners_;
    do
      v14 = __ldxr(p_shared_owners);
    while (__stxr(v14 + 1, p_shared_owners));
  }
  v15 = (std::__shared_weak_count *)a3[1];
  v43 = *a3;
  v44 = v15;
  if (v15)
  {
    v16 = (unint64_t *)&v15->__shared_owners_;
    do
      v17 = __ldxr(v16);
    while (__stxr(v17 + 1, v16));
  }
  v18 = (std::__shared_weak_count *)a5[1];
  v41 = *a5;
  v42 = v18;
  if (v18)
  {
    v19 = (unint64_t *)&v18->__shared_owners_;
    do
      v20 = __ldxr(v19);
    while (__stxr(v20 + 1, v19));
  }
  v21 = *a7;
  object = v21;
  if (v21)
    dispatch_retain(v21);
  v22 = (std::__shared_weak_count *)a8[1];
  v38 = *a8;
  v39 = v22;
  if (v22)
  {
    v23 = (unint64_t *)&v22->__shared_owners_;
    do
      v24 = __ldxr(v23);
    while (__stxr(v24 + 1, v23));
  }
  QMIDataContextIPBase::QMIDataContextIPBase((uint64_t)a1, &v45, &v43, a4, &v41, a6, &object, &v38);
  v25 = v39;
  if (v39)
  {
    v26 = (unint64_t *)&v39->__shared_owners_;
    do
      v27 = __ldaxr(v26);
    while (__stlxr(v27 - 1, v26));
    if (!v27)
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }
  if (object)
    dispatch_release(object);
  v28 = v42;
  if (v42)
  {
    v29 = (unint64_t *)&v42->__shared_owners_;
    do
      v30 = __ldaxr(v29);
    while (__stlxr(v30 - 1, v29));
    if (!v30)
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
  }
  v31 = v44;
  if (v44)
  {
    v32 = (unint64_t *)&v44->__shared_owners_;
    do
      v33 = __ldaxr(v32);
    while (__stlxr(v33 - 1, v32));
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
      std::__shared_weak_count::__release_weak(v31);
    }
  }
  v34 = v46;
  if (v46)
  {
    v35 = (unint64_t *)&v46->__shared_owners_;
    do
      v36 = __ldaxr(v35);
    while (__stlxr(v36 - 1, v35));
    if (!v36)
    {
      ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
      std::__shared_weak_count::__release_weak(v34);
    }
  }
  *a1 = &off_24D5C2EB8;
  return a1;
}

void sub_2168CE768(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, dispatch_object_t object, char a13, uint64_t a14, char a15)
{
  uint64_t v15;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a10);
  if (object)
    dispatch_release(object);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a15);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v15 - 48);
  _Unwind_Resume(a1);
}

void QMIDataContextIP::~QMIDataContextIP(QMIDataContextIP *this)
{
  QMIDataContextIPBase::~QMIDataContextIPBase(this);
  JUMPOUT(0x2199FEAC4);
}

void QMIDataContextIP::setParameters3GPP(uint64_t a1, _QWORD *a2, int a3, int a4, char a5)
{
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  const void **v15;
  const void **v16;
  char **v17;
  char *v18;
  char *v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t *v22;
  _QWORD *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  char *v28;
  uint64_t *v29;
  char *v30;
  char *v31;
  char *v32;
  uint64_t v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  std::__shared_weak_count *v37;
  unint64_t *v38;
  unint64_t v39;
  _QWORD v40[2];
  void (*v41)(uint64_t, uint64_t);
  void *v42;
  uint64_t v43;
  uint64_t v44;
  std::__shared_weak_count *v45;
  int v46;
  int v47;
  char v48;
  uint64_t v49;
  std::__shared_weak_count *v50;
  uint64_t v51;
  std::__shared_weak_count *v52;

  v10 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(a1 + 104));
  v49 = *(_QWORD *)(a1 + 96);
  v50 = v10;
  v51 = 0;
  v52 = 0;
  (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v49 + 240))(&v51);
  p_shared_owners = (unint64_t *)&v10->__shared_owners_;
  do
    v12 = __ldaxr(p_shared_owners);
  while (__stlxr(v12 - 1, p_shared_owners));
  if (!v12)
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  if (v51)
  {
    v40[0] = MEMORY[0x24BDAC760];
    v40[1] = 1174405120;
    v41 = ___ZN16QMIDataContextIP17setParameters3GPPERN3wds17StartNetworkIface7RequestE18DataProtocolFamily19AuthTypeRequirementb_block_invoke;
    v42 = &__block_descriptor_tmp;
    v43 = a1;
    v44 = v51;
    v45 = v52;
    if (v52)
    {
      v13 = (unint64_t *)&v52->__shared_owners_;
      do
        v14 = __ldxr(v13);
      while (__stxr(v14 + 1, v13));
    }
    v46 = a4;
    v47 = a3;
    v48 = a5;
    v15 = (const void **)a2[1];
    v16 = (const void **)a2[2];
    v17 = (char **)(a2 + 1);
    if (v15 != v16)
    {
      while (*((unsigned __int8 *)*v15 + 8) != 192)
      {
        if (++v15 == v16)
          goto LABEL_16;
      }
    }
    if (v15 == v16)
    {
LABEL_16:
      v20 = operator new();
      *(_BYTE *)(v20 + 8) = -64;
      *(_QWORD *)v20 = off_24D5C3120;
      *(_BYTE *)(v20 + 16) = 0;
      v19 = (char *)(v20 + 16);
      *(_BYTE *)(v20 + 80) = 0;
      *(_WORD *)(v20 + 112) = 0;
      *(_BYTE *)(v20 + 116) = 0;
      *(_BYTE *)(v20 + 164) = 0;
      *(_BYTE *)(v20 + 166) = 0;
      *(_QWORD *)(v20 + 32) = 0;
      *(_QWORD *)(v20 + 40) = 0;
      *(_QWORD *)(v20 + 24) = 0;
      *(_BYTE *)(v20 + 48) = 0;
      v21 = a2[3];
      v22 = (uint64_t *)a2[2];
      if ((unint64_t)v22 >= v21)
      {
        v24 = ((char *)v22 - *v17) >> 3;
        if ((unint64_t)(v24 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v25 = v21 - (_QWORD)*v17;
        v26 = v25 >> 2;
        if (v25 >> 2 <= (unint64_t)(v24 + 1))
          v26 = v24 + 1;
        if ((unint64_t)v25 >= 0x7FFFFFFFFFFFFFF8)
          v27 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v27 = v26;
        if (v27)
          v28 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a2 + 3), v27);
        else
          v28 = 0;
        v29 = (uint64_t *)&v28[8 * v24];
        v30 = &v28[8 * v27];
        *v29 = v20;
        v23 = v29 + 1;
        v32 = (char *)a2[1];
        v31 = (char *)a2[2];
        if (v31 != v32)
        {
          do
          {
            v33 = *((_QWORD *)v31 - 1);
            v31 -= 8;
            *--v29 = v33;
          }
          while (v31 != v32);
          v31 = *v17;
        }
        a2[1] = v29;
        a2[2] = v23;
        a2[3] = v30;
        if (v31)
          operator delete(v31);
      }
      else
      {
        *v22 = v20;
        v23 = v22 + 1;
      }
      a2[2] = v23;
    }
    else
    {
      if (!v18)
        __cxa_bad_cast();
      v19 = v18 + 16;
    }
    v41((uint64_t)v40, (uint64_t)v19);
    v34 = v45;
    if (v45)
    {
      v35 = (unint64_t *)&v45->__shared_owners_;
      do
        v36 = __ldaxr(v35);
      while (__stlxr(v36 - 1, v35));
      if (!v36)
      {
        ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
        std::__shared_weak_count::__release_weak(v34);
      }
    }
  }
  v37 = v52;
  if (v52)
  {
    v38 = (unint64_t *)&v52->__shared_owners_;
    do
      v39 = __ldaxr(v38);
    while (__stlxr(v39 - 1, v38));
    if (!v39)
    {
      ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
      std::__shared_weak_count::__release_weak(v37);
    }
  }
}

void sub_2168CEAC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void ___ZN16QMIDataContextIP17setParameters3GPPERN3wds17StartNetworkIface7RequestE18DataProtocolFamily19AuthTypeRequirementb_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  NSObject *v8;
  int v9;
  void **v10;
  void **v11;
  void *v12;
  NSObject *v13;
  void **v14;
  void **v15;
  std::string::size_type v16;
  uint64_t v17;
  std::string::value_type *v18;
  std::string::size_type v19;
  std::__shared_weak_count *v20;
  std::string::value_type *v21;
  std::string::size_type v22;
  NSObject *v23;
  uint64_t v24;
  uint64_t v25;
  std::__shared_weak_count *v26;
  int v27;
  int v28;
  int v29;
  int v30;
  char v31;
  NSObject *v32;
  int v33;
  NSObject *v34;
  const char *v35;
  NSObject *v36;
  int v37;
  int v38;
  BOOL *v39;
  CFTypeID v40;
  const __CFBoolean *v41;
  NSObject *v42;
  int v43;
  NSObject *v44;
  std::__shared_weak_count *v45;
  int v46;
  unint64_t *v47;
  unint64_t v48;
  NSObject *v49;
  NSObject *v50;
  __int16 v51;
  CFTypeRef cf;
  void *v53;
  std::__shared_weak_count *v54;
  uint64_t v55;
  void *__p[2];
  uint64_t v57;
  std::string v58;
  _BYTE buf[24];
  void *v60;
  uint64_t v61;

  v61 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)(a1 + 32);
  __p[0] = 0;
  __p[1] = 0;
  v57 = 0;
  std::string::basic_string[abi:ne180100]<0>(__p, (char *)&unk_216AC4FCA);
  if (((*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 40) + 88))(*(_QWORD *)(a1 + 40), 0) & 1) == 0)
  {
    v5 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v4 + 104));
    v53 = *(void **)(v4 + 96);
    v54 = v5;
    (*(void (**)(_BYTE *__return_ptr))(*(_QWORD *)v53 + 304))(buf);
    if (SHIBYTE(v57) < 0)
      operator delete(__p[0]);
    *(_OWORD *)__p = *(_OWORD *)buf;
    v57 = *(_QWORD *)&buf[16];
    buf[23] = 0;
    buf[0] = 0;
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
    if ((*(unsigned int (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 40) + 104))(*(_QWORD *)(a1 + 40), 0)
      && (*(unsigned int (**)(_QWORD))(**(_QWORD **)(a1 + 40) + 80))(*(_QWORD *)(a1 + 40)))
    {
      v8 = *(NSObject **)(v4 + 40);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        v9 = SHIBYTE(v57);
        v10 = (void **)__p[0];
        (*(void (**)(void **__return_ptr))(**(_QWORD **)(a1 + 40) + 288))(&v53);
        v11 = __p;
        if (v9 < 0)
          v11 = v10;
        if (v55 >= 0)
          v12 = &v53;
        else
          v12 = v53;
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = "setParameters3GPP_block_invoke";
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = v11;
        *(_WORD *)&buf[22] = 2080;
        v60 = v12;
        _os_log_impl(&dword_216897000, v8, OS_LOG_TYPE_DEFAULT, "#I %s: Modifying APN name %s to alt-name %s in 3GPP parameters", buf, 0x20u);
        if (SHIBYTE(v55) < 0)
          operator delete(v53);
      }
      (*(void (**)(_BYTE *__return_ptr))(**(_QWORD **)(a1 + 40) + 288))(buf);
      if (SHIBYTE(v57) < 0)
        operator delete(__p[0]);
      *(_OWORD *)__p = *(_OWORD *)buf;
      v57 = *(_QWORD *)&buf[16];
    }
  }
  v13 = *(NSObject **)(v4 + 40);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    v14 = __p;
    if (v57 < 0)
      v14 = (void **)__p[0];
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = "setParameters3GPP_block_invoke";
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = v14;
    _os_log_impl(&dword_216897000, v13, OS_LOG_TYPE_DEFAULT, "#I %s: APN name %s in 3GPP parameters", buf, 0x16u);
  }
  if (v57 >= 0)
    v15 = __p;
  else
    v15 = (void **)__p[0];
  if (v57 >= 0)
    v16 = HIBYTE(v57);
  else
    v16 = (std::string::size_type)__p[1];
  std::string::__assign_trivial[abi:ne180100]<unsigned char const*,unsigned char const*>((std::string *)(a2 + 8), (std::string::value_type *)v15, (std::string::value_type *)v15 + v16, v16);
  (*(void (**)(_BYTE *__return_ptr))(**(_QWORD **)(a1 + 40) + 264))(buf);
  v17 = buf[23];
  if (buf[23] < 0)
    v17 = *(_QWORD *)&buf[8];
  if (v17)
  {
    v53 = 0;
    v54 = 0;
    v55 = 0;
    boost::optional_detail::optional_base<tlv::NestedTlv<(unsigned char)27,wds::tlv::UserName>>::assign_expr<wds::tlv::UserName,wds::tlv::UserName>(a2 + 32, (uint64_t)&v53);
    if (SHIBYTE(v55) < 0)
      operator delete(v53);
    if (!*(_BYTE *)(a2 + 32))
      __assert_rtn("operator->", "optional.hpp", 1222, "this->is_initialized()");
    if (buf[23] >= 0)
      v18 = buf;
    else
      v18 = *(std::string::value_type **)buf;
    if (buf[23] >= 0)
      v19 = buf[23];
    else
      v19 = *(_QWORD *)&buf[8];
    std::string::__assign_trivial[abi:ne180100]<unsigned char const*,unsigned char const*>((std::string *)(a2 + 40), v18, &v18[v19], v19);
  }
  (*(void (**)(void **__return_ptr))(**(_QWORD **)(a1 + 40) + 272))(&v53);
  v20 = (std::__shared_weak_count *)HIBYTE(v55);
  if (v55 < 0)
    v20 = v54;
  if (v20)
  {
    memset(&v58, 0, sizeof(v58));
    boost::optional_detail::optional_base<tlv::NestedTlv<(unsigned char)27,wds::tlv::UserName>>::assign_expr<wds::tlv::UserName,wds::tlv::UserName>(a2 + 64, (uint64_t)&v58);
    if (SHIBYTE(v58.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v58.__r_.__value_.__l.__data_);
    if (!*(_BYTE *)(a2 + 64))
      __assert_rtn("operator->", "optional.hpp", 1222, "this->is_initialized()");
    if (v55 >= 0)
      v21 = (std::string::value_type *)&v53;
    else
      v21 = (std::string::value_type *)v53;
    if (v55 >= 0)
      v22 = HIBYTE(v55);
    else
      v22 = (std::string::size_type)v54;
    std::string::__assign_trivial[abi:ne180100]<unsigned char const*,unsigned char const*>((std::string *)(a2 + 72), v21, &v21[v22], v22);
  }
  v23 = *(NSObject **)(v4 + 40);
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    v24 = asString();
    LODWORD(v58.__r_.__value_.__l.__data_) = 136315394;
    *(std::string::size_type *)((char *)v58.__r_.__value_.__r.__words + 4) = (std::string::size_type)"setParameters3GPP_block_invoke";
    WORD2(v58.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&v58.__r_.__value_.__r.__words[1] + 6) = v24;
    _os_log_impl(&dword_216897000, v23, OS_LOG_TYPE_DEFAULT, "#I %s: Auth Type requirement = %s", (uint8_t *)&v58, 0x16u);
  }
  if (*(_DWORD *)(a1 + 56) == 1)
    goto LABEL_66;
  v25 = buf[23];
  if (buf[23] < 0)
    v25 = *(_QWORD *)&buf[8];
  if (v25)
    goto LABEL_66;
  v26 = (std::__shared_weak_count *)HIBYTE(v55);
  if (v55 < 0)
    v26 = v54;
  if (v26)
  {
LABEL_66:
    (*(void (**)(std::string *__return_ptr))(**(_QWORD **)(a1 + 40) + 280))(&v58);
    v27 = std::string::compare(&v58, "PAP");
    v28 = v27;
    if (SHIBYTE(v58.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v58.__r_.__value_.__l.__data_);
      if (v28)
        goto LABEL_68;
    }
    else if (v27)
    {
LABEL_68:
      (*(void (**)(std::string *__return_ptr))(**(_QWORD **)(a1 + 40) + 280))(&v58);
      v29 = std::string::compare(&v58, "CHAP");
      v30 = v29;
      if (SHIBYTE(v58.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v58.__r_.__value_.__l.__data_);
        if (v30)
          goto LABEL_76;
      }
      else if (v29)
      {
        goto LABEL_76;
      }
      v31 = 2;
      goto LABEL_75;
    }
    v31 = 1;
LABEL_75:
    *(_BYTE *)(a2 + 96) = v31;
  }
LABEL_76:
  if ((*(unsigned int (**)(_QWORD))(**(_QWORD **)(v4 + 616) + 48))(*(_QWORD *)(v4 + 616)))
  {
    v32 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v58.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)v58.__r_.__value_.__r.__words + 4) = (std::string::size_type)"setParameters3GPP_block_invoke";
      _os_log_impl(&dword_216897000, v32, OS_LOG_TYPE_DEFAULT, "#I %s: Required to ask for v4 & v6 PDP types, asking for 3GPP types v4v6", (uint8_t *)&v58, 0xCu);
    }
    if (!*(_BYTE *)a2)
      *(_BYTE *)a2 = 1;
    *(_DWORD *)(a2 + 4) = 3;
  }
  else
  {
    v33 = *(_DWORD *)(a1 + 60);
    if ((v33 & 2) != 0)
    {
      v34 = *(NSObject **)(v4 + 40);
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
      {
        v35 = "v4v6";
        if ((v33 & 1) == 0)
          v35 = "v6";
        LODWORD(v58.__r_.__value_.__l.__data_) = 136315394;
        *(std::string::size_type *)((char *)v58.__r_.__value_.__r.__words + 4) = (std::string::size_type)"setParameters3GPP_block_invoke";
        WORD2(v58.__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&v58.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v35;
        _os_log_impl(&dword_216897000, v34, OS_LOG_TYPE_DEFAULT, "#I %s: Asking for 3GPP type(s) %s", (uint8_t *)&v58, 0x16u);
      }
      if (!*(_BYTE *)a2)
        *(_BYTE *)a2 = 1;
      *(_DWORD *)(a2 + 4) = 0;
      *(_DWORD *)(a2 + 4) = *(_DWORD *)(a1 + 60) & 1 | 2;
    }
  }
  v36 = *(NSObject **)(v4 + 40);
  if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
  {
    v37 = (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 40) + 56))(*(_QWORD *)(a1 + 40), 0);
    v38 = *(unsigned __int8 *)(a1 + 64);
    LODWORD(v58.__r_.__value_.__l.__data_) = 136315650;
    *(std::string::size_type *)((char *)v58.__r_.__value_.__r.__words + 4) = (std::string::size_type)"setParameters3GPP_block_invoke";
    WORD2(v58.__r_.__value_.__r.__words[1]) = 1024;
    *(_DWORD *)((char *)&v58.__r_.__value_.__r.__words[1] + 6) = v37;
    WORD1(v58.__r_.__value_.__r.__words[2]) = 1024;
    HIDWORD(v58.__r_.__value_.__r.__words[2]) = v38;
    _os_log_impl(&dword_216897000, v36, OS_LOG_TYPE_DEFAULT, "#I %s: ims=%d, sigInd=%d", (uint8_t *)&v58, 0x18u);
  }
  if ((*(unsigned int (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 40) + 56))(*(_QWORD *)(a1 + 40), 0))
  {
    if (!*(_BYTE *)(a2 + 97))
      *(_BYTE *)(a2 + 97) = 1;
    *(_BYTE *)(a2 + 98) = 1;
    if (*(_BYTE *)(a1 + 64))
    {
      cf = 0;
      (*(void (**)(CFTypeRef *__return_ptr, _QWORD, const __CFString *, _QWORD, _QWORD))(**(_QWORD **)(v4 + 616)
                                                                                                  + 88))(&cf, *(_QWORD *)(v4 + 616), CFSTR("SupportsIMSSignalingIndication"), *MEMORY[0x24BDBD268], 0);
      v39 = (BOOL *)cf;
      v58.__r_.__value_.__s.__data_[0] = 0;
      if (!cf)
        goto LABEL_105;
      v40 = CFGetTypeID(cf);
      if (v40 == CFBooleanGetTypeID())
        ctu::cf::assign((ctu::cf *)&v58, v39, v41);
      if (v58.__r_.__value_.__s.__data_[0])
      {
        v42 = *(NSObject **)(v4 + 40);
        if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(v58.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)v58.__r_.__value_.__r.__words + 4) = (std::string::size_type)"setParameters3GPP_block_invoke";
          _os_log_impl(&dword_216897000, v42, OS_LOG_TYPE_DEFAULT, "#I %s: The carrier supports IMSSignalingIndication Capability", (uint8_t *)&v58, 0xCu);
        }
        v43 = *(unsigned __int8 *)(a2 + 100);
        *(_OWORD *)(a2 + 104) = 0u;
        *(_OWORD *)(a2 + 120) = 0u;
        *(_OWORD *)(a2 + 129) = 0u;
        if (!v43)
          *(_BYTE *)(a2 + 100) = 1;
        *(_BYTE *)(a2 + 104) = 3;
        *(_DWORD *)(a2 + 140) = 1;
        *(_BYTE *)(a2 + 144) = 1;
      }
      else
      {
LABEL_105:
        v44 = *(NSObject **)(v4 + 40);
        if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(v58.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)v58.__r_.__value_.__r.__words + 4) = (std::string::size_type)"setParameters3GPP_block_invoke";
          _os_log_impl(&dword_216897000, v44, OS_LOG_TYPE_DEFAULT, "#I %s: The device supports IMSSignalingIndication Capability but carrier doesn't. No need to fill SigInd parameters", (uint8_t *)&v58, 0xCu);
        }
      }
      ctu::SharedRef<void const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,void const>::~SharedRef(&cf);
    }
  }
  if ((*(unsigned int (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 40) + 88))(*(_QWORD *)(a1 + 40), 0))
  {
    v45 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v4 + 104));
    v58.__r_.__value_.__r.__words[0] = *(_QWORD *)(v4 + 96);
    v58.__r_.__value_.__l.__size_ = (std::string::size_type)v45;
    v46 = (*(uint64_t (**)(std::string::size_type))(*(_QWORD *)v58.__r_.__value_.__l.__data_ + 248))(v58.__r_.__value_.__r.__words[0]);
    v47 = (unint64_t *)&v45->__shared_owners_;
    do
      v48 = __ldaxr(v47);
    while (__stlxr(v48 - 1, v47));
    if (!v48)
    {
      ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
      std::__shared_weak_count::__release_weak(v45);
    }
    if (v46 != 2)
    {
      v49 = *(NSObject **)(v4 + 40);
      if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(v58.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)v58.__r_.__value_.__r.__words + 4) = (std::string::size_type)"setParameters3GPP_block_invoke";
        _os_log_impl(&dword_216897000, v49, OS_LOG_TYPE_DEFAULT, "#I %s: Applying SupportEm tlv to start network", (uint8_t *)&v58, 0xCu);
      }
      if (!*(_BYTE *)(a2 + 148))
        *(_BYTE *)(a2 + 148) = 1;
      *(_BYTE *)(a2 + 149) = 1;
    }
  }
  if ((*(unsigned int (**)(_QWORD))(**(_QWORD **)(a1 + 40) + 152))(*(_QWORD *)(a1 + 40)))
  {
    v50 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v58.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)v58.__r_.__value_.__r.__words + 4) = (std::string::size_type)"setParameters3GPP_block_invoke";
      _os_log_impl(&dword_216897000, v50, OS_LOG_TYPE_DEFAULT, "#I %s: Applying PCO to SNI", (uint8_t *)&v58, 0xCu);
    }
    v51 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 40) + 152))(*(_QWORD *)(a1 + 40));
    if (!*(_BYTE *)(a2 + 150))
      *(_BYTE *)(a2 + 150) = 1;
    *(_WORD *)(a2 + 152) = v51;
  }
  if (SHIBYTE(v55) < 0)
    operator delete(v53);
  if ((buf[23] & 0x80000000) != 0)
    operator delete(*(void **)buf);
  if (SHIBYTE(v57) < 0)
    operator delete(__p[0]);
}

void sub_2168CF4EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (a21 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t __copy_helper_block_e8_40c57_ZTSNSt3__110shared_ptrIK28DataAPNSettingsInfoInterfaceEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 48) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_40c57_ZTSNSt3__110shared_ptrIK28DataAPNSettingsInfoInterfaceEE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 40);
}

void QMIDataContextIP::setParameters3GPP2(uint64_t a1, _QWORD *a2, int a3)
{
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  char *v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  _QWORD v18[2];
  void (*v19)(uint64_t, uint64_t);
  void *v20;
  uint64_t v21;
  uint64_t v22;
  std::__shared_weak_count *v23;
  int v24;
  uint64_t v25;
  std::__shared_weak_count *v26;
  uint64_t v27;
  std::__shared_weak_count *v28;

  v6 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(a1 + 104));
  v25 = *(_QWORD *)(a1 + 96);
  v26 = v6;
  v27 = 0;
  v28 = 0;
  (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v25 + 240))(&v27);
  p_shared_owners = (unint64_t *)&v6->__shared_owners_;
  do
    v8 = __ldaxr(p_shared_owners);
  while (__stlxr(v8 - 1, p_shared_owners));
  if (!v8)
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
  if (v27)
  {
    v18[0] = MEMORY[0x24BDAC760];
    v18[1] = 1174405120;
    v19 = ___ZN16QMIDataContextIP18setParameters3GPP2ERN3wds17StartNetworkIface7RequestE18DataProtocolFamily_block_invoke;
    v20 = &__block_descriptor_tmp_10;
    v21 = a1;
    v22 = v27;
    v23 = v28;
    if (v28)
    {
      v9 = (unint64_t *)&v28->__shared_owners_;
      do
        v10 = __ldxr(v9);
      while (__stxr(v10 + 1, v9));
    }
    v24 = a3;
    v11 = qmi::MutableMessageBase::getTLV<wds::tlv::Parameters3GPP2>(a2);
    v19((uint64_t)v18, (uint64_t)v11);
    v12 = v23;
    if (v23)
    {
      v13 = (unint64_t *)&v23->__shared_owners_;
      do
        v14 = __ldaxr(v13);
      while (__stlxr(v14 - 1, v13));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }
  }
  v15 = v28;
  if (v28)
  {
    v16 = (unint64_t *)&v28->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
}

void sub_2168CF758(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void ___ZN16QMIDataContextIP18setParameters3GPP2ERN3wds17StartNetworkIface7RequestE18DataProtocolFamily_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  NSObject *v8;
  int v9;
  void **v10;
  void **v11;
  void *v12;
  NSObject *v13;
  void **v14;
  void **v15;
  std::string::size_type v16;
  char v17;
  char v18;
  void *v19;
  std::__shared_weak_count *v20;
  void **v21;
  std::string::size_type v22;
  std::string::value_type *v23;
  std::string::size_type v24;
  _BYTE *v25;
  void **v26;
  std::string::size_type v27;
  std::__shared_weak_count *v28;
  std::string::value_type *v29;
  std::string::size_type v30;
  void *v31;
  std::__shared_weak_count *v32;
  uint64_t (*v33)(uint64_t);
  NSObject *v34;
  int v35;
  int v36;
  NSObject *v37;
  const char *v38;
  NSObject *v39;
  __int16 v40;
  CFNumberRef number;
  int valuePtr;
  void *v43;
  std::__shared_weak_count *v44;
  unsigned __int8 v45;
  void *v46[2];
  void *v47;
  std::string buf;
  void *__p[6];

  __p[5] = *(void **)MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)(a1 + 32);
  memset(__p, 0, 24);
  boost::optional_detail::optional_base<tlv::NestedTlv<(unsigned char)27,wds::tlv::UserName>>::assign_expr<wds::tlv::UserName,wds::tlv::UserName>(a2, (uint64_t)__p);
  if (SHIBYTE(__p[2]) < 0)
    operator delete(__p[0]);
  v46[0] = 0;
  v46[1] = 0;
  v47 = 0;
  std::string::basic_string[abi:ne180100]<0>(v46, (char *)&unk_216AC4FCA);
  if (((*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 40) + 88))(*(_QWORD *)(a1 + 40), 0) & 1) == 0)
  {
    v5 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v4 + 104));
    v43 = *(void **)(v4 + 96);
    v44 = v5;
    (*(void (**)(void **__return_ptr))(*(_QWORD *)v43 + 304))(__p);
    if (SHIBYTE(v47) < 0)
      operator delete(v46[0]);
    *(_OWORD *)v46 = *(_OWORD *)__p;
    v47 = __p[2];
    HIBYTE(__p[2]) = 0;
    LOBYTE(__p[0]) = 0;
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
    if ((*(unsigned int (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 40) + 104))(*(_QWORD *)(a1 + 40), 0)
      && (*(unsigned int (**)(_QWORD))(**(_QWORD **)(a1 + 40) + 80))(*(_QWORD *)(a1 + 40)))
    {
      v8 = *(NSObject **)(v4 + 40);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        v9 = SHIBYTE(v47);
        v10 = (void **)v46[0];
        (*(void (**)(void **__return_ptr))(**(_QWORD **)(a1 + 40) + 288))(&v43);
        v11 = v46;
        if (v9 < 0)
          v11 = v10;
        if ((v45 & 0x80u) == 0)
          v12 = &v43;
        else
          v12 = v43;
        LODWORD(__p[0]) = 136315650;
        *(void **)((char *)__p + 4) = "setParameters3GPP2_block_invoke";
        WORD2(__p[1]) = 2080;
        *(void **)((char *)&__p[1] + 6) = v11;
        HIWORD(__p[2]) = 2080;
        __p[3] = v12;
        _os_log_impl(&dword_216897000, v8, OS_LOG_TYPE_DEFAULT, "#I %s: Modifying APN name %s to alt-name %s in 3GPP2 parameters", (uint8_t *)__p, 0x20u);
        if ((char)v45 < 0)
          operator delete(v43);
      }
      (*(void (**)(void **__return_ptr))(**(_QWORD **)(a1 + 40) + 288))(__p);
      if (SHIBYTE(v47) < 0)
        operator delete(v46[0]);
      *(_OWORD *)v46 = *(_OWORD *)__p;
      v47 = __p[2];
    }
  }
  v13 = *(NSObject **)(v4 + 40);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    v14 = v46;
    if (SHIBYTE(v47) < 0)
      v14 = (void **)v46[0];
    LODWORD(__p[0]) = 136315394;
    *(void **)((char *)__p + 4) = "setParameters3GPP2_block_invoke";
    WORD2(__p[1]) = 2080;
    *(void **)((char *)&__p[1] + 6) = v14;
    _os_log_impl(&dword_216897000, v13, OS_LOG_TYPE_DEFAULT, "#I %s: APN name %s in 3GPP2 parameters", (uint8_t *)__p, 0x16u);
  }
  if (!*(_BYTE *)a2)
    __assert_rtn("operator->", "optional.hpp", 1222, "this->is_initialized()");
  if (SHIBYTE(v47) >= 0)
    v15 = v46;
  else
    v15 = (void **)v46[0];
  if (SHIBYTE(v47) >= 0)
    v16 = HIBYTE(v47);
  else
    v16 = (std::string::size_type)v46[1];
  std::string::__assign_trivial[abi:ne180100]<unsigned char const*,unsigned char const*>((std::string *)(a2 + 8), (std::string::value_type *)v15, (std::string::value_type *)v15 + v16, v16);
  (*(void (**)(void **__return_ptr))(**(_QWORD **)(a1 + 40) + 264))(__p);
  (*(void (**)(void **__return_ptr))(**(_QWORD **)(a1 + 40) + 272))(&v43);
  (*(void (**)(std::string *__return_ptr))(**(_QWORD **)(a1 + 40) + 280))(&buf);
  v17 = wds::apply(&buf);
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
    operator delete(buf.__r_.__value_.__l.__data_);
  v18 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v4 + 616) + 56))(*(_QWORD *)(v4 + 616));
  v19 = (void *)HIBYTE(__p[2]);
  if (SHIBYTE(__p[2]) < 0)
    v19 = __p[1];
  if ((v18 & 1) != 0)
  {
    if (v19)
    {
      v20 = (std::__shared_weak_count *)v45;
      if ((v45 & 0x80u) != 0)
        v20 = v44;
      if (v20)
      {
        memset(&buf, 0, sizeof(buf));
        boost::optional_detail::optional_base<tlv::NestedTlv<(unsigned char)27,wds::tlv::UserName>>::assign_expr<wds::tlv::UserName,wds::tlv::UserName>(a2 + 120, (uint64_t)&buf);
        if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
          operator delete(buf.__r_.__value_.__l.__data_);
        if (*(_BYTE *)(a2 + 120))
        {
          if (SHIBYTE(__p[2]) >= 0)
            v21 = __p;
          else
            v21 = (void **)__p[0];
          if (SHIBYTE(__p[2]) >= 0)
            v22 = HIBYTE(__p[2]);
          else
            v22 = (std::string::size_type)__p[1];
          std::string::__assign_trivial[abi:ne180100]<unsigned char const*,unsigned char const*>((std::string *)(a2 + 128), (std::string::value_type *)v21, (std::string::value_type *)v21 + v22, v22);
          memset(&buf, 0, sizeof(buf));
          boost::optional_detail::optional_base<tlv::NestedTlv<(unsigned char)27,wds::tlv::UserName>>::assign_expr<wds::tlv::UserName,wds::tlv::UserName>(a2 + 152, (uint64_t)&buf);
          if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
            operator delete(buf.__r_.__value_.__l.__data_);
          if (*(_BYTE *)(a2 + 152))
          {
            if ((v45 & 0x80u) == 0)
              v23 = (std::string::value_type *)&v43;
            else
              v23 = (std::string::value_type *)v43;
            if ((v45 & 0x80u) == 0)
              v24 = v45;
            else
              v24 = (std::string::size_type)v44;
            std::string::__assign_trivial[abi:ne180100]<unsigned char const*,unsigned char const*>((std::string *)(a2 + 160), v23, &v23[v24], v24);
            if (!*(_BYTE *)(a2 + 184))
              *(_BYTE *)(a2 + 184) = 1;
            v25 = (_BYTE *)(a2 + 185);
LABEL_97:
            *v25 = v17;
            goto LABEL_98;
          }
        }
LABEL_139:
        __assert_rtn("operator->", "optional.hpp", 1222, "this->is_initialized()");
      }
    }
  }
  else
  {
    if (v19)
    {
      memset(&buf, 0, sizeof(buf));
      boost::optional_detail::optional_base<tlv::NestedTlv<(unsigned char)27,wds::tlv::UserName>>::assign_expr<wds::tlv::UserName,wds::tlv::UserName>(a2 + 40, (uint64_t)&buf);
      if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
        operator delete(buf.__r_.__value_.__l.__data_);
      if (!*(_BYTE *)(a2 + 40))
        goto LABEL_139;
      if (SHIBYTE(__p[2]) >= 0)
        v26 = __p;
      else
        v26 = (void **)__p[0];
      if (SHIBYTE(__p[2]) >= 0)
        v27 = HIBYTE(__p[2]);
      else
        v27 = (std::string::size_type)__p[1];
      std::string::__assign_trivial[abi:ne180100]<unsigned char const*,unsigned char const*>((std::string *)(a2 + 48), (std::string::value_type *)v26, (std::string::value_type *)v26 + v27, v27);
    }
    v28 = (std::__shared_weak_count *)v45;
    if ((v45 & 0x80u) != 0)
      v28 = v44;
    if (v28)
    {
      memset(&buf, 0, sizeof(buf));
      boost::optional_detail::optional_base<tlv::NestedTlv<(unsigned char)27,wds::tlv::UserName>>::assign_expr<wds::tlv::UserName,wds::tlv::UserName>(a2 + 72, (uint64_t)&buf);
      if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
        operator delete(buf.__r_.__value_.__l.__data_);
      if (!*(_BYTE *)(a2 + 72))
        goto LABEL_139;
      if ((v45 & 0x80u) == 0)
        v29 = (std::string::value_type *)&v43;
      else
        v29 = (std::string::value_type *)v43;
      if ((v45 & 0x80u) == 0)
        v30 = v45;
      else
        v30 = (std::string::size_type)v44;
      std::string::__assign_trivial[abi:ne180100]<unsigned char const*,unsigned char const*>((std::string *)(a2 + 80), v29, &v29[v30], v30);
    }
    v31 = (void *)HIBYTE(__p[2]);
    if (SHIBYTE(__p[2]) < 0)
      v31 = __p[1];
    if (v31)
      goto LABEL_143;
    v32 = (std::__shared_weak_count *)v45;
    if ((v45 & 0x80u) != 0)
      v32 = v44;
    if (v32)
    {
LABEL_143:
      if (!*(_BYTE *)(a2 + 104))
        *(_BYTE *)(a2 + 104) = 1;
      v25 = (_BYTE *)(a2 + 105);
      goto LABEL_97;
    }
  }
LABEL_98:
  valuePtr = 0;
  number = 0;
  (*(void (**)(std::string *__return_ptr, _QWORD, const __CFString *, _QWORD, _QWORD))(**(_QWORD **)(v4 + 616)
                                                                                                + 88))(&buf, *(_QWORD *)(v4 + 616), CFSTR("PDNInactivityTimeout"), 0, 0);
  ctu::cf::CFSharedRef<__CFNumber const>::CFSharedRef<void const,void>(&number, (CFTypeRef *)&buf.__r_.__value_.__l.__data_);
  ctu::SharedRef<void const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,void const>::~SharedRef((const void **)&buf.__r_.__value_.__l.__data_);
  v33 = ctu::SharedRef<__CFNumber const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFNumber const>::get;
  if (!number)
    v33 = 0;
  if (!v33 || (CFNumberGetValue(number, kCFNumberIntType, &valuePtr), (LODWORD(v33) = valuePtr) == 0))
    valuePtr = 0;
  if (!*(_BYTE *)(a2 + 108))
    *(_BYTE *)(a2 + 108) = 1;
  *(_DWORD *)(a2 + 112) = (_DWORD)v33;
  if ((*(unsigned int (**)(_QWORD))(**(_QWORD **)(v4 + 616) + 48))(*(_QWORD *)(v4 + 616)))
  {
    v34 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"setParameters3GPP2_block_invoke";
      _os_log_impl(&dword_216897000, v34, OS_LOG_TYPE_DEFAULT, "#I %s: Required to ask for v4 & v6 PDP types, asking for 3GPP2 types v4v6", (uint8_t *)&buf, 0xCu);
    }
    if (!*(_BYTE *)(a2 + 32))
      *(_BYTE *)(a2 + 32) = 1;
    v35 = 2;
  }
  else
  {
    v36 = *(_DWORD *)(a1 + 56);
    if ((v36 & 2) == 0)
      goto LABEL_122;
    v37 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
    {
      v38 = "v4v6";
      if ((v36 & 1) == 0)
        v38 = "v6";
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"setParameters3GPP2_block_invoke";
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v38;
      _os_log_impl(&dword_216897000, v37, OS_LOG_TYPE_DEFAULT, "#I %s: Asking for 3GPP2 type(s) %s", (uint8_t *)&buf, 0x16u);
    }
    if (!*(_BYTE *)(a2 + 32))
      *(_BYTE *)(a2 + 32) = 1;
    *(_DWORD *)(a2 + 36) = 0;
    if ((*(_DWORD *)(a1 + 56) & 1) != 0)
      v35 = 2;
    else
      v35 = 1;
  }
  *(_DWORD *)(a2 + 36) = v35;
LABEL_122:
  if ((*(unsigned int (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 40) + 56))(*(_QWORD *)(a1 + 40), 0))
  {
    if (!*(_BYTE *)(a2 + 186))
      *(_BYTE *)(a2 + 186) = 1;
    *(_BYTE *)(a2 + 187) = 1;
  }
  if ((*(unsigned int (**)(_QWORD))(**(_QWORD **)(a1 + 40) + 152))(*(_QWORD *)(a1 + 40)))
  {
    v39 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"setParameters3GPP2_block_invoke";
      _os_log_impl(&dword_216897000, v39, OS_LOG_TYPE_DEFAULT, "#I %s: Applying PCO to SNI2", (uint8_t *)&buf, 0xCu);
    }
    v40 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 40) + 152))(*(_QWORD *)(a1 + 40));
    if (!*(_BYTE *)(a2 + 188))
      *(_BYTE *)(a2 + 188) = 1;
    *(_WORD *)(a2 + 190) = v40;
  }
  ctu::SharedRef<__CFNumber const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFNumber const>::~SharedRef((const void **)&number);
  if ((char)v45 < 0)
    operator delete(v43);
  if (SHIBYTE(__p[2]) < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v47) < 0)
    operator delete(v46[0]);
}

void sub_2168CFFDC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
  if (a23 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t ctu::SharedRef<__CFNumber const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFNumber const>::get(uint64_t a1)
{
  return *(_QWORD *)a1;
}

uint64_t ctu::SharedRef<__CFBoolean const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFBoolean const>::get(uint64_t a1)
{
  return *(_QWORD *)a1;
}

uint64_t ___ZN16QMIDataContextIP21setHandOverIPv6PrefixEb18DataProtocolFamilyRN3wds17StartNetworkIface7RequestE_block_invoke(uint64_t a1, unsigned __int8 *a2)
{
  CSIPacketAddress *v3;
  uint64_t result;

  v3 = (CSIPacketAddress *)(a1 + 32);
  CSIPacketAddress::toIPv6((CSIPacketAddress *)(a1 + 32), a2);
  result = CSIPacketAddress::getPrefixLen(v3);
  a2[16] = result;
  return result;
}

void __copy_helper_block_e8_32c22_ZTS16CSIPacketAddress(uint64_t a1, uint64_t a2)
{
  CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)(a1 + 32), (const CSIPacketAddress *)(a2 + 32));
}

uint64_t QMIDataContextIP::activateDataContextIP_Internal(uint64_t a1, int a2, uint64_t *a3, char a4)
{
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  int v11;
  NSObject *v12;
  _BOOL4 v13;
  NSObject *v14;
  uint64_t v15;
  std::__shared_weak_count *v16;
  int v17;
  unint64_t *v18;
  unint64_t v19;
  NSObject *v20;
  std::__shared_weak_count *v21;
  capabilities::ct *v22;
  int v23;
  unint64_t *v24;
  unint64_t v25;
  int v26;
  NSObject *v27;
  _BOOL8 v28;
  uint64_t v29;
  const char *v30;
  _QWORD *v31;
  uint64_t v32;
  const void **v33;
  const __CFBoolean *v34;
  uint64_t (*v35)(uint64_t);
  _BOOL4 v36;
  NSObject *v37;
  const char *v38;
  char *v39;
  char *v40;
  NSObject *v41;
  const char *v42;
  std::__shared_weak_count *v43;
  unint64_t *v44;
  unint64_t v45;
  NSObject *v46;
  _BYTE *v47;
  char v48;
  uint64_t v49;
  NSObject *v50;
  int v51;
  void **v52;
  int PrefixLen;
  void **p_p;
  capabilities::ct *v55;
  NSObject *v56;
  capabilities::ct *v57;
  BOOL *v58;
  CFTypeID v59;
  const __CFBoolean *v60;
  NSObject *v61;
  NSObject *v62;
  NSObject *v63;
  void *v64;
  NSObject *v65;
  int v66;
  std::__shared_weak_count *v67;
  uint64_t v68;
  uint64_t v69;
  unint64_t *v70;
  unint64_t v71;
  std::__shared_weak_count *v72;
  unint64_t *v73;
  unint64_t v74;
  _QWORD v76[5];
  _OWORD v77[2];
  uint64_t v78;
  std::__shared_weak_count *v79;
  void *__p;
  char v81;
  BOOL *v82[3];
  BOOL *v83;
  void *v84;
  void *v85;
  _QWORD *v86;
  _BYTE v87[22];
  __int16 v88;
  uint64_t v89;
  void *aBlock;
  _BYTE buf[40];
  uint64_t v92;

  v92 = *MEMORY[0x24BDAC8D0];
  v8 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(a1 + 104));
  *(_QWORD *)buf = *(_QWORD *)(a1 + 96);
  *(_QWORD *)&buf[8] = v8;
  v78 = 0;
  v79 = 0;
  (*(void (**)(uint64_t *__return_ptr))(**(_QWORD **)buf + 240))(&v78);
  p_shared_owners = (unint64_t *)&v8->__shared_owners_;
  do
    v10 = __ldaxr(p_shared_owners);
  while (__stlxr(v10 - 1, p_shared_owners));
  if (!v10)
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
  if (v78)
  {
    memset(v77, 0, sizeof(v77));
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v77);
    v11 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v78 + 128))(v78, 0);
    v12 = *(NSObject **)(a1 + 40);
    v13 = os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT);
    if (v11)
    {
      if (v13)
      {
        *(_DWORD *)buf = 136315138;
        *(_QWORD *)&buf[4] = "activateDataContextIP_Internal";
        _os_log_impl(&dword_216897000, v12, OS_LOG_TYPE_DEFAULT, "#I %s: Using Tethering NAI", buf, 0xCu);
      }
      *(_BYTE *)qmi::MutableMessageBase::getTLV<wds::tlv::CallType>(v77, 53) = 0;
    }
    else
    {
      if (v13)
      {
        *(_DWORD *)buf = 136315138;
        *(_QWORD *)&buf[4] = "activateDataContextIP_Internal";
        _os_log_impl(&dword_216897000, v12, OS_LOG_TYPE_DEFAULT, "#I %s: Using Embedded NAI", buf, 0xCu);
      }
      *(_BYTE *)qmi::MutableMessageBase::getTLV<wds::tlv::CallType>(v77, 53) = 1;
    }
    if ((*(unsigned int (**)(uint64_t, _QWORD))(*(_QWORD *)v78 + 56))(v78, 0))
    {
      v16 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(a1 + 104));
      *(_QWORD *)buf = *(_QWORD *)(a1 + 96);
      *(_QWORD *)&buf[8] = v16;
      v17 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)buf + 248))(*(_QWORD *)buf);
      v18 = (unint64_t *)&v16->__shared_owners_;
      do
        v19 = __ldaxr(v18);
      while (__stlxr(v19 - 1, v18));
      if (!v19)
      {
        ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
        std::__shared_weak_count::__release_weak(v16);
      }
      if (v17 != 2)
      {
        v20 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315138;
          *(_QWORD *)&buf[4] = "activateDataContextIP_Internal";
          _os_log_impl(&dword_216897000, v20, OS_LOG_TYPE_DEFAULT, "#I %s: Applying IDataCall tlv", buf, 0xCu);
        }
        *(_BYTE *)qmi::MutableMessageBase::getTLV<wds::tlv::IDataCall>(v77, 194) = 1;
      }
    }
    v21 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(a1 + 104));
    *(_QWORD *)buf = *(_QWORD *)(a1 + 96);
    *(_QWORD *)&buf[8] = v21;
    v22 = (capabilities::ct *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)buf + 248))(*(_QWORD *)buf);
    v23 = (int)v22;
    v24 = (unint64_t *)&v21->__shared_owners_;
    do
      v25 = __ldaxr(v24);
    while (__stlxr(v25 - 1, v24));
    if (!v25)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
    switch(v23)
    {
      case 0:
        if (((*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v78 + 88))(v78, 0) & 1) != 0)
          goto LABEL_29;
        v37 = *(NSObject **)(a1 + 40);
        v15 = 0;
        if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315138;
          *(_QWORD *)&buf[4] = "activateDataContextIP_Internal";
          v38 = "#I %s: wrong wireless technology, can't activate";
          goto LABEL_46;
        }
        goto LABEL_113;
      case 1:
        *qmi::MutableMessageBase::getTLV<wds::tlv::TechPref>(v77) = 1;
        QMIDataContextIP::setParameters3GPP(a1, v77, *(_DWORD *)(a1 + 284), 1, 1);
        v39 = qmi::MutableMessageBase::getTLV<wds::tlv::SecondaryDNSPreference>(v77);
        goto LABEL_100;
      case 2:
        if ((capabilities::ct::supportsCapabilityeHRPDDevice(v22) & 1) != 0)
          goto LABEL_49;
        v40 = qmi::MutableMessageBase::getTLV<wds::tlv::Parameters3GPP2>(v77);
        if (!v40[104])
          v40[104] = 1;
        v40[105] = 2;
        goto LABEL_101;
      case 3:
LABEL_49:
        *qmi::MutableMessageBase::getTLV<wds::tlv::TechPref>(v77) = 2;
        QMIDataContextIP::setParameters3GPP(a1, v77, *(_DWORD *)(a1 + 284), 0, 0);
        QMIDataContextIP::setParameters3GPP2(a1, v77, *(_DWORD *)(a1 + 284));
        v39 = qmi::MutableMessageBase::getTLV<wds::tlv::SecondaryDNSPreference>(v77);
        goto LABEL_100;
      case 4:
      case 5:
      case 6:
LABEL_29:
        *qmi::MutableMessageBase::getTLV<wds::tlv::TechPref>(v77) = 1;
        v26 = *(_DWORD *)(a1 + 284);
        v27 = *(NSObject **)(a1 + 40);
        v28 = os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT);
        if (v28)
        {
          v29 = asString();
          v30 = "false";
          *(_DWORD *)buf = 136315650;
          *(_QWORD *)&buf[4] = "setHandOverIPv6Prefix";
          *(_WORD *)&buf[12] = 2080;
          if (a2)
            v30 = "true";
          *(_QWORD *)&buf[14] = v30;
          *(_WORD *)&buf[22] = 2080;
          *(_QWORD *)&buf[24] = v29;
          _os_log_impl(&dword_216897000, v27, OS_LOG_TYPE_DEFAULT, "#I %s: IPv6Service: handOver: %s, allowedIpFamily: %s", buf, 0x20u);
        }
        if ((v26 & 2) == 0
          || *(_DWORD *)(a1 + 140) != 2
          || !a2
          || !capabilities::ct::supportsHandoverPDN((capabilities::ct *)v28))
        {
          goto LABEL_81;
        }
        v31 = operator new(0x10uLL);
        v32 = *MEMORY[0x24BDC3EB8];
        v85 = v31 + 2;
        v86 = v31 + 2;
        *v31 = v32;
        v31[1] = CFSTR("SetHandOverIPv6Prefix");
        v83 = 0;
        v84 = v31;
        (*(void (**)(_BYTE *__return_ptr, _QWORD, void **, _QWORD, _QWORD))(**(_QWORD **)(a1 + 616) + 96))(buf, *(_QWORD *)(a1 + 616), &v84, *MEMORY[0x24BDBD268], 0);
        ctu::cf::CFSharedRef<__CFBoolean const>::CFSharedRef<void const,void>(&v83, (CFTypeRef *)buf);
        v33 = ctu::SharedRef<void const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,void const>::~SharedRef((const void **)buf);
        v35 = ctu::SharedRef<__CFBoolean const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFBoolean const>::get;
        if (!v83)
          v35 = 0;
        if (v35)
        {
          buf[0] = 0;
          ctu::cf::assign((ctu::cf *)v33, v83, v34);
          v36 = buf[0] != 0;
        }
        else
        {
          v36 = 0;
        }
        v41 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
        {
          v42 = "false";
          if (v36)
            v42 = "true";
          *(_DWORD *)buf = 136315394;
          *(_QWORD *)&buf[4] = "setHandOverIPv6Prefix";
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = v42;
          _os_log_impl(&dword_216897000, v41, OS_LOG_TYPE_DEFAULT, "#I %s: IPv6Service: setIPv6Prefix: %s", buf, 0x16u);
        }
        if (!v36)
          goto LABEL_76;
        memset(v82, 0, sizeof(v82));
        v43 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(a1 + 104));
        *(_QWORD *)buf = *(_QWORD *)(a1 + 96);
        *(_QWORD *)&buf[8] = v43;
        (*(void (**)(BOOL **__return_ptr, _QWORD, uint64_t))(**(_QWORD **)buf + 216))(v82, *(_QWORD *)buf, 2);
        v44 = (unint64_t *)&v43->__shared_owners_;
        do
          v45 = __ldaxr(v44);
        while (__stlxr(v45 - 1, v44));
        if (!v45)
        {
          ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
          std::__shared_weak_count::__release_weak(v43);
        }
        if (CSIPacketAddress::isZeroIP((CSIPacketAddress *)v82))
        {
          v46 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
          {
            CSIPacketAddress::operator std::string();
            v47 = buf[23] >= 0 ? buf : *(_BYTE **)buf;
            *(_DWORD *)v87 = 136315394;
            *(_QWORD *)&v87[4] = "setHandOverIPv6Prefix";
            *(_WORD *)&v87[12] = 2080;
            *(_QWORD *)&v87[14] = v47;
            _os_log_impl(&dword_216897000, v46, OS_LOG_TYPE_DEFAULT, "#I %s: IPv6Service: ** ipv6Addr: %s handover impossible, going with regular activation", v87, 0x16u);
            if ((buf[23] & 0x80000000) != 0)
              operator delete(*(void **)buf);
          }
          v48 = 0;
        }
        else
        {
          *(_QWORD *)buf = MEMORY[0x24BDAC760];
          *(_QWORD *)&buf[8] = 1174405120;
          *(_QWORD *)&buf[16] = ___ZN16QMIDataContextIP21setHandOverIPv6PrefixEb18DataProtocolFamilyRN3wds17StartNetworkIface7RequestE_block_invoke;
          *(_QWORD *)&buf[24] = &__block_descriptor_tmp_15;
          CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)&buf[32], (const CSIPacketAddress *)v82);
          v49 = qmi::MutableMessageBase::getTLV<wds::tlv::HandOverIPv6Prefix>(v77, 208);
          (*(void (**)(_BYTE *, uint64_t))&buf[16])(buf, v49);
          v50 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
          {
            CSIPacketAddress::operator std::string();
            v51 = v81;
            v52 = (void **)__p;
            PrefixLen = CSIPacketAddress::getPrefixLen((CSIPacketAddress *)v82);
            p_p = &__p;
            *(_DWORD *)v87 = 136315650;
            *(_QWORD *)&v87[4] = "setHandOverIPv6Prefix";
            if (v51 < 0)
              p_p = v52;
            *(_WORD *)&v87[12] = 2080;
            *(_QWORD *)&v87[14] = p_p;
            v88 = 1024;
            LODWORD(v89) = PrefixLen;
            _os_log_impl(&dword_216897000, v50, OS_LOG_TYPE_DEFAULT, "#I %s: IPv6Service: ** ipv6Addr: %s, prefixLen: %d", v87, 0x1Cu);
            if (v81 < 0)
              operator delete(__p);
          }
LABEL_76:
          v48 = 1;
        }
        ctu::SharedRef<__CFBoolean const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFBoolean const>::~SharedRef((const void **)&v83);
        if (v84)
        {
          v85 = v84;
          operator delete(v84);
        }
        if ((v48 & 1) == 0)
          a2 = 0;
LABEL_81:
        QMIDataContextIP::setParameters3GPP(a1, v77, *(_DWORD *)(a1 + 284), 0, 1);
        if (a2
          && capabilities::ct::supportsHandoverPDN(v55)
          && (*(unsigned int (**)(_QWORD))(**(_QWORD **)(a1 + 616) + 40))(*(_QWORD *)(a1 + 616)))
        {
          v56 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315138;
            *(_QWORD *)&buf[4] = "activateDataContextIP_Internal";
            _os_log_impl(&dword_216897000, v56, OS_LOG_TYPE_DEFAULT, "#I %s: Set ITechHandoverPDN", buf, 0xCu);
          }
          *(_BYTE *)qmi::MutableMessageBase::getTLV<wds::tlv::ITechHandoverPDN>(v77, 209) = 1;
          QMIDataContextIPBase::setHandoverActivation((QMIDataContextIPBase *)a1, 1);
          if (capabilities::ct::supportsCapabilityeHRPDDevice(v57))
          {
            *(_QWORD *)v87 = 0;
            (*(void (**)(_BYTE *__return_ptr, _QWORD, const __CFString *, _QWORD, _QWORD))(**(_QWORD **)(a1 + 616) + 88))(v87, *(_QWORD *)(a1 + 616), CFSTR("SupportsEHRPD"), *MEMORY[0x24BDBD268], 0);
            v58 = *(BOOL **)v87;
            buf[0] = 0;
            if (!*(_QWORD *)v87)
              goto LABEL_96;
            v59 = CFGetTypeID(*(CFTypeRef *)v87);
            if (v59 == CFBooleanGetTypeID())
              ctu::cf::assign((ctu::cf *)buf, v58, v60);
            if (buf[0])
            {
              v61 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136315138;
                *(_QWORD *)&buf[4] = "activateDataContextIP_Internal";
                _os_log_impl(&dword_216897000, v61, OS_LOG_TYPE_DEFAULT, "#I %s: The device supports eHRPD Capability and  carrier too filling 3GPP2 parameters", buf, 0xCu);
              }
              QMIDataContextIP::setParameters3GPP2(a1, v77, *(_DWORD *)(a1 + 284));
            }
            else
            {
LABEL_96:
              v63 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136315138;
                *(_QWORD *)&buf[4] = "activateDataContextIP_Internal";
                _os_log_impl(&dword_216897000, v63, OS_LOG_TYPE_DEFAULT, "#I %s: The device supports eHRPD Capability but carrier doesn't .No need to fill 3GPP2 parameters", buf, 0xCu);
              }
            }
            ctu::SharedRef<void const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,void const>::~SharedRef((const void **)v87);
          }
          else
          {
            v62 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136315138;
              *(_QWORD *)&buf[4] = "activateDataContextIP_Internal";
              _os_log_impl(&dword_216897000, v62, OS_LOG_TYPE_DEFAULT, "#I %s: The device doesn't support eHRPD Capability No need to fill 3GPP2 parameters", buf, 0xCu);
            }
          }
        }
        v39 = qmi::MutableMessageBase::getTLV<wds::tlv::SecondaryDNSPreference>(v77);
LABEL_100:
        *(_DWORD *)v39 = 0;
LABEL_101:
        QMIDataContextIPBase::setDataContextIPState(a1, 4u);
        if ((a4 & 1) == 0)
          std::shared_ptr<QMIDataContextIPActivationLock>::operator=[abi:ne180100]((_QWORD *)(a1 + 560), a3);
        *(_QWORD *)v87 = a1 + 144;
        *(_QWORD *)&v87[8] = QMIServiceMsg::create();
        v89 = a1 + 176;
        aBlock = 0;
        *(_DWORD *)&v87[16] = 210000;
        v76[0] = MEMORY[0x24BDAC760];
        v76[1] = 0x40000000;
        v76[2] = ___ZN16QMIDataContextIP30activateDataContextIP_InternalEbNSt3__110shared_ptrI30QMIDataContextIPActivationLockEEb_block_invoke_49;
        v76[3] = &__block_descriptor_tmp_51;
        v76[4] = a1;
        *(_QWORD *)buf = MEMORY[0x24BDAC760];
        *(_QWORD *)&buf[8] = 0x40000000;
        *(_QWORD *)&buf[16] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3wds21StartNetworkIfaceBase8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
        *(_QWORD *)&buf[24] = &unk_24D5C3380;
        *(_QWORD *)&buf[32] = v76;
        v64 = _Block_copy(buf);
        aBlock = v64;
        if (*(_QWORD *)&v87[8])
        {
          qmi::Client::send();
          v64 = aBlock;
        }
        if (v64)
          _Block_release(v64);
        v65 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT))
        {
          v66 = *(unsigned __int16 *)(a1 + 176);
          v67 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(a1 + 104));
          *(_QWORD *)v87 = *(_QWORD *)(a1 + 96);
          *(_QWORD *)&v87[8] = v67;
          (*(void (**)(_QWORD))(**(_QWORD **)v87 + 248))(*(_QWORD *)v87);
          v68 = asString();
          v69 = asStringBool();
          *(_DWORD *)buf = 136315906;
          *(_QWORD *)&buf[4] = "activateDataContextIP_Internal";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v66;
          *(_WORD *)&buf[18] = 2080;
          *(_QWORD *)&buf[20] = v68;
          *(_WORD *)&buf[28] = 2080;
          *(_QWORD *)&buf[30] = v69;
          _os_log_impl(&dword_216897000, v65, OS_LOG_TYPE_DEFAULT, "#I %s: ca.lock: Sent StartNetworkIface fActivateTxId=%d tech=%s eHRPD=%s", buf, 0x26u);
          v70 = (unint64_t *)&v67->__shared_owners_;
          do
            v71 = __ldaxr(v70);
          while (__stlxr(v71 - 1, v70));
          if (!v71)
          {
            ((void (*)(std::__shared_weak_count *))v67->__on_zero_shared)(v67);
            std::__shared_weak_count::__release_weak(v67);
          }
        }
        v15 = 1;
LABEL_113:
        qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v77);
        break;
      default:
        v37 = *(NSObject **)(a1 + 40);
        v15 = 0;
        if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315138;
          *(_QWORD *)&buf[4] = "activateDataContextIP_Internal";
          v38 = "#I %s: wrong wireless technology";
LABEL_46:
          _os_log_impl(&dword_216897000, v37, OS_LOG_TYPE_DEFAULT, v38, buf, 0xCu);
          v15 = 0;
        }
        goto LABEL_113;
    }
  }
  else
  {
    v14 = *(NSObject **)(a1 + 40);
    v15 = 0;
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = "activateDataContextIP_Internal";
      _os_log_impl(&dword_216897000, v14, OS_LOG_TYPE_DEFAULT, "#E %s: Do not expect activation at this point !", buf, 0xCu);
      v15 = 0;
    }
  }
  v72 = v79;
  if (v79)
  {
    v73 = (unint64_t *)&v79->__shared_owners_;
    do
      v74 = __ldaxr(v73);
    while (__stlxr(v74 - 1, v73));
    if (!v74)
    {
      ((void (*)(std::__shared_weak_count *))v72->__on_zero_shared)(v72);
      std::__shared_weak_count::__release_weak(v72);
    }
  }
  return v15;
}

void sub_2168D0DE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,const void *a30,void *a31,uint64_t a32,uint64_t a33,char a34)
{
  if (a26 < 0)
    operator delete(__p);
  ctu::SharedRef<__CFBoolean const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFBoolean const>::~SharedRef(&a30);
  if (a31)
  {
    a32 = (uint64_t)a31;
    operator delete(a31);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a15);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a19);
  _Unwind_Resume(a1);
}

_QWORD *std::shared_ptr<QMIDataContextIPActivationLock>::operator=[abi:ne180100](_QWORD *a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;

  v4 = *a2;
  v3 = a2[1];
  if (v3)
  {
    v5 = (unint64_t *)(v3 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  v7 = (std::__shared_weak_count *)a1[1];
  *a1 = v4;
  a1[1] = v3;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  return a1;
}

void ___ZN16QMIDataContextIP30activateDataContextIP_InternalEbNSt3__110shared_ptrI30QMIDataContextIPActivationLockEEb_block_invoke_49(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)(v2 + 257))
    QMIDataContextIPBase::handleActivateResponse(v2, a2);
}

void qmi::Client::SendProxy::~SendProxy(qmi::Client::SendProxy *this)
{
  const void *v2;

  if (*((_QWORD *)this + 1))
    qmi::Client::send();
  v2 = (const void *)*((_QWORD *)this + 4);
  if (v2)
    _Block_release(v2);
}

uint64_t QMIDataContextIPBase::getDataContextIPState(QMIDataContextIPBase *this)
{
  return *((unsigned int *)this + 34);
}

uint64_t QMIDataContextIPBase::getIPAddress(QMIDataContextIPBase *this)
{
  return (uint64_t)this + 184;
}

uint64_t QMIDataContextIPBase::getOriginalIPv6Address(QMIDataContextIPBase *this)
{
  return (uint64_t)this + 184;
}

uint64_t QMIDataContextIPBase::getLinkLocalIPAddress(QMIDataContextIPBase *this)
{
  return (uint64_t)this + 184;
}

uint64_t QMIDataContextIPBase::getDNSAddresses(QMIDataContextIPBase *this)
{
  return (uint64_t)this + 208;
}

uint64_t QMIDataContextIPBase::clearContextIP(QMIDataContextIPBase *this)
{
  uint64_t result;
  _BYTE v3[24];

  CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)v3);
  result = CSIPacketAddress::operator=();
  *((_QWORD *)this + 27) = *((_QWORD *)this + 26);
  return result;
}

uint64_t QMIDataContextIPBase::getIpFamily(QMIDataContextIPBase *this)
{
  return *((unsigned int *)this + 35);
}

uint64_t QMIDataContextIPBase::getAppId(QMIDataContextIPBase *this)
{
  return *((unsigned __int8 *)this + 256);
}

uint64_t QMIDataContextIPBase::setAppId(uint64_t this, char a2)
{
  *(_BYTE *)(this + 256) = a2;
  return this;
}

void std::string::__throw_out_of_range[abi:ne180100]()
{
  std::__throw_out_of_range[abi:ne180100]("basic_string");
}

void std::__throw_out_of_range[abi:ne180100](const char *a1)
{
  std::logic_error *exception;

  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::out_of_range::out_of_range[abi:ne180100](exception, a1);
  __cxa_throw(exception, (struct type_info *)off_24D5C2110, MEMORY[0x24BEDAB00]);
}

void sub_2168D1080(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::out_of_range::out_of_range[abi:ne180100](std::logic_error *a1, const char *a2)
{
  std::logic_error *result;

  result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x24BEDB8C0] + 16);
  return result;
}

const void **ctu::SharedRef<void const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,void const>::~SharedRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

const void **ctu::SharedRef<__CFNumber const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFNumber const>::~SharedRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

const void **ctu::SharedRef<__CFBoolean const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFBoolean const>::~SharedRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

uint64_t std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](uint64_t a1)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;

  v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  return a1;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Parameters3GPP>::~TlvWrapper(uint64_t a1)
{
  *(_QWORD *)a1 = off_24D5C3120;
  if (*(_BYTE *)(a1 + 166))
    *(_BYTE *)(a1 + 166) = 0;
  if (*(_BYTE *)(a1 + 164))
    *(_BYTE *)(a1 + 164) = 0;
  if (*(_BYTE *)(a1 + 116))
    *(_BYTE *)(a1 + 116) = 0;
  if (*(_BYTE *)(a1 + 113))
    *(_BYTE *)(a1 + 113) = 0;
  if (*(_BYTE *)(a1 + 80))
  {
    if (*(char *)(a1 + 111) < 0)
      operator delete(*(void **)(a1 + 88));
    *(_BYTE *)(a1 + 80) = 0;
  }
  if (*(_BYTE *)(a1 + 48))
  {
    if (*(char *)(a1 + 79) < 0)
      operator delete(*(void **)(a1 + 56));
    *(_BYTE *)(a1 + 48) = 0;
  }
  if (*(char *)(a1 + 47) < 0)
    operator delete(*(void **)(a1 + 24));
  if (*(_BYTE *)(a1 + 16))
    *(_BYTE *)(a1 + 16) = 0;
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::Parameters3GPP>::~TlvWrapper(uint64_t a1)
{
  *(_QWORD *)a1 = off_24D5C3120;
  if (*(_BYTE *)(a1 + 166))
    *(_BYTE *)(a1 + 166) = 0;
  if (*(_BYTE *)(a1 + 164))
    *(_BYTE *)(a1 + 164) = 0;
  if (*(_BYTE *)(a1 + 116))
    *(_BYTE *)(a1 + 116) = 0;
  if (*(_BYTE *)(a1 + 113))
    *(_BYTE *)(a1 + 113) = 0;
  if (*(_BYTE *)(a1 + 80))
  {
    if (*(char *)(a1 + 111) < 0)
      operator delete(*(void **)(a1 + 88));
    *(_BYTE *)(a1 + 80) = 0;
  }
  if (*(_BYTE *)(a1 + 48))
  {
    if (*(char *)(a1 + 79) < 0)
      operator delete(*(void **)(a1 + 56));
    *(_BYTE *)(a1 + 48) = 0;
  }
  if (*(char *)(a1 + 47) < 0)
    operator delete(*(void **)(a1 + 24));
  if (*(_BYTE *)(a1 + 16))
    *(_BYTE *)(a1 + 16) = 0;
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Parameters3GPP>::getSize(uint64_t a1)
{
  return tlv::size<wds::tlv::Parameters3GPP>((_BYTE *)(a1 + 16));
}

_WORD *qmi::MutableMessageBase::TlvWrapper<wds::tlv::Parameters3GPP>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _WORD *result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::Parameters3GPP>((_BYTE **)a2, a1 + 16);
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Parameters3GPP>::clone(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  std::string *v4;
  std::string *v5;

  v2 = operator new();
  v3 = v2;
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)v2 = off_24D5C3120;
  *(_BYTE *)(v2 + 16) = 0;
  if (*(_BYTE *)(a1 + 16))
  {
    *(_DWORD *)(v2 + 20) = *(_DWORD *)(a1 + 20);
    *(_BYTE *)(v2 + 16) = 1;
  }
  if (*(char *)(a1 + 47) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)(v2 + 24), *(const std::string::value_type **)(a1 + 24), *(_QWORD *)(a1 + 32));
  }
  else
  {
    *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
    *(_QWORD *)(v2 + 40) = *(_QWORD *)(a1 + 40);
  }
  *(_BYTE *)(v3 + 48) = 0;
  if (*(_BYTE *)(a1 + 48))
  {
    v4 = (std::string *)(v3 + 56);
    if (*(char *)(a1 + 79) < 0)
    {
      std::string::__init_copy_ctor_external(v4, *(const std::string::value_type **)(a1 + 56), *(_QWORD *)(a1 + 64));
    }
    else
    {
      *(_OWORD *)&v4->__r_.__value_.__l.__data_ = *(_OWORD *)(a1 + 56);
      *(_QWORD *)(v3 + 72) = *(_QWORD *)(a1 + 72);
    }
    *(_BYTE *)(v3 + 48) = 1;
  }
  *(_BYTE *)(v3 + 80) = 0;
  if (*(_BYTE *)(a1 + 80))
  {
    v5 = (std::string *)(v3 + 88);
    if (*(char *)(a1 + 111) < 0)
    {
      std::string::__init_copy_ctor_external(v5, *(const std::string::value_type **)(a1 + 88), *(_QWORD *)(a1 + 96));
    }
    else
    {
      *(_OWORD *)&v5->__r_.__value_.__l.__data_ = *(_OWORD *)(a1 + 88);
      *(_QWORD *)(v3 + 104) = *(_QWORD *)(a1 + 104);
    }
    *(_BYTE *)(v3 + 80) = 1;
  }
  *(_BYTE *)(v3 + 112) = *(_BYTE *)(a1 + 112);
  *(_BYTE *)(v3 + 113) = 0;
  if (*(_BYTE *)(a1 + 113))
  {
    *(_BYTE *)(v3 + 114) = *(_BYTE *)(a1 + 114);
    *(_BYTE *)(v3 + 113) = 1;
  }
  *(_BYTE *)(v3 + 116) = 0;
  if (*(_BYTE *)(a1 + 116))
  {
    *(_OWORD *)(v3 + 120) = *(_OWORD *)(a1 + 120);
    *(_OWORD *)(v3 + 136) = *(_OWORD *)(a1 + 136);
    *(_OWORD *)(v3 + 148) = *(_OWORD *)(a1 + 148);
    *(_BYTE *)(v3 + 116) = 1;
  }
  *(_BYTE *)(v3 + 164) = 0;
  if (*(_BYTE *)(a1 + 164))
  {
    *(_BYTE *)(v3 + 165) = *(_BYTE *)(a1 + 165);
    *(_BYTE *)(v3 + 164) = 1;
  }
  *(_BYTE *)(v3 + 166) = 0;
  if (*(_BYTE *)(a1 + 166))
  {
    *(_WORD *)(v3 + 168) = *(_WORD *)(a1 + 168);
    *(_BYTE *)(v3 + 166) = 1;
  }
  return v3;
}

void sub_2168D151C(_Unwind_Exception *a1)
{
  uint64_t v1;
  void **v2;

  if (*(_BYTE *)(v1 + 48))
  {
    if (*(char *)(v1 + 79) < 0)
      operator delete(*(void **)(v1 + 56));
    *(_BYTE *)(v1 + 48) = 0;
  }
  if (*(char *)(v1 + 47) < 0)
    operator delete(*v2);
  if (*(_BYTE *)(v1 + 16))
    *(_BYTE *)(v1 + 16) = 0;
  MEMORY[0x2199FEAC4](v1, 0x1093C408AF197B0);
  _Unwind_Resume(a1);
}

_QWORD *ctu::cf::CFSharedRef<__CFNumber const>::CFSharedRef<void const,void>(_QWORD *a1, CFTypeRef *a2)
{
  CFTypeRef v3;
  CFTypeID v4;
  const void *v5;

  v3 = *a2;
  if (*a2)
  {
    v4 = CFGetTypeID(*a2);
    if (v4 == CFNumberGetTypeID())
      v5 = v3;
    else
      v5 = 0;
  }
  else
  {
    v5 = 0;
  }
  return ctu::SharedRef<__CFNumber const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFNumber const>::SharedRef(a1, v5);
}

_QWORD *ctu::SharedRef<__CFNumber const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFNumber const>::SharedRef(_QWORD *a1, CFTypeRef cf)
{
  *a1 = cf;
  if (cf)
    CFRetain(cf);
  return a1;
}

char *qmi::MutableMessageBase::getTLV<wds::tlv::Parameters3GPP2>(_QWORD *a1)
{
  const void **v2;
  const void **v3;
  char **v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  v4 = (char **)(a1 + 1);
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != 193)
    {
      if (++v2 == v3)
        goto LABEL_8;
    }
  }
  if (v2 == v3)
  {
LABEL_8:
    v7 = operator new();
    *(_BYTE *)(v7 + 8) = -63;
    *(_QWORD *)v7 = &off_24D5C3170;
    *(_BYTE *)(v7 + 16) = 0;
    v6 = v7 + 16;
    *(_BYTE *)(v7 + 48) = 0;
    *(_BYTE *)(v7 + 56) = 0;
    *(_BYTE *)(v7 + 88) = 0;
    *(_BYTE *)(v7 + 120) = 0;
    *(_BYTE *)(v7 + 124) = 0;
    *(_BYTE *)(v7 + 136) = 0;
    *(_BYTE *)(v7 + 168) = 0;
    *(_BYTE *)(v7 + 200) = 0;
    *(_BYTE *)(v7 + 202) = 0;
    *(_BYTE *)(v7 + 204) = 0;
    v8 = a1[3];
    v9 = (uint64_t *)a1[2];
    if ((unint64_t)v9 >= v8)
    {
      v11 = ((char *)v9 - *v4) >> 3;
      if ((unint64_t)(v11 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v12 = v8 - (_QWORD)*v4;
      v13 = v12 >> 2;
      if (v12 >> 2 <= (unint64_t)(v11 + 1))
        v13 = v11 + 1;
      if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
        v14 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v14 = v13;
      if (v14)
        v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v14);
      else
        v15 = 0;
      v16 = (uint64_t *)&v15[8 * v11];
      v17 = &v15[8 * v14];
      *v16 = v7;
      v10 = v16 + 1;
      v19 = (char *)a1[1];
      v18 = (char *)a1[2];
      if (v18 != v19)
      {
        do
        {
          v20 = *((_QWORD *)v18 - 1);
          v18 -= 8;
          *--v16 = v20;
        }
        while (v18 != v19);
        v18 = *v4;
      }
      a1[1] = v16;
      a1[2] = v10;
      a1[3] = v17;
      if (v18)
        operator delete(v18);
    }
    else
    {
      *v9 = v7;
      v10 = v9 + 1;
    }
    a1[2] = v10;
  }
  else
  {
    if (!v5)
      __cxa_bad_cast();
    return v5 + 16;
  }
  return (char *)v6;
}

_QWORD *qmi::MutableMessageBase::TlvWrapper<wds::tlv::Parameters3GPP2>::~TlvWrapper(_QWORD *a1)
{
  *a1 = &off_24D5C3170;
  wds::tlv::Parameters3GPP2::~Parameters3GPP2((wds::tlv::Parameters3GPP2 *)(a1 + 2));
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::Parameters3GPP2>::~TlvWrapper(_QWORD *a1)
{
  *a1 = &off_24D5C3170;
  wds::tlv::Parameters3GPP2::~Parameters3GPP2((wds::tlv::Parameters3GPP2 *)(a1 + 2));
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Parameters3GPP2>::getSize(uint64_t a1, const wds::tlv::Parameters3GPP2 *a2)
{
  return tlv::size<wds::tlv::Parameters3GPP2>((wds::tlv *)(a1 + 16), a2);
}

wds::tlv *qmi::MutableMessageBase::TlvWrapper<wds::tlv::Parameters3GPP2>::write(uint64_t a1, wds::tlv **a2, const wds::tlv::Parameters3GPP2 *a3)
{
  char v4;
  wds::tlv *v5;
  uint64_t v6;
  wds::tlv *result;
  char *v8;

  v4 = *(_BYTE *)(a1 + 8);
  v5 = *a2;
  v6 = (uint64_t)*a2 + 3;
  *a2 = (wds::tlv *)v6;
  result = tlv::writeV<wds::tlv::Parameters3GPP2>(a2, (unsigned __int8 *)(a1 + 16), a3);
  v8 = (char *)*a2 - v6;
  *(_BYTE *)v5 = v4;
  *(_WORD *)((char *)v5 + 1) = (_WORD)v8;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Parameters3GPP2>::clone(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  std::string *v4;
  std::string *v5;
  std::string *v6;
  std::string *v7;
  std::string *v8;

  v2 = operator new();
  v3 = v2;
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)v2 = &off_24D5C3170;
  *(_BYTE *)(v2 + 16) = 0;
  if (*(_BYTE *)(a1 + 16))
  {
    v4 = (std::string *)(v2 + 24);
    if (*(char *)(a1 + 47) < 0)
    {
      std::string::__init_copy_ctor_external(v4, *(const std::string::value_type **)(a1 + 24), *(_QWORD *)(a1 + 32));
    }
    else
    {
      *(_OWORD *)&v4->__r_.__value_.__l.__data_ = *(_OWORD *)(a1 + 24);
      *(_QWORD *)(v3 + 40) = *(_QWORD *)(a1 + 40);
    }
    *(_BYTE *)(v3 + 16) = 1;
  }
  *(_BYTE *)(v3 + 48) = 0;
  if (*(_BYTE *)(a1 + 48))
  {
    *(_DWORD *)(v3 + 52) = *(_DWORD *)(a1 + 52);
    *(_BYTE *)(v3 + 48) = 1;
  }
  *(_BYTE *)(v3 + 56) = 0;
  if (*(_BYTE *)(a1 + 56))
  {
    v5 = (std::string *)(v3 + 64);
    if (*(char *)(a1 + 87) < 0)
    {
      std::string::__init_copy_ctor_external(v5, *(const std::string::value_type **)(a1 + 64), *(_QWORD *)(a1 + 72));
    }
    else
    {
      *(_OWORD *)&v5->__r_.__value_.__l.__data_ = *(_OWORD *)(a1 + 64);
      *(_QWORD *)(v3 + 80) = *(_QWORD *)(a1 + 80);
    }
    *(_BYTE *)(v3 + 56) = 1;
  }
  *(_BYTE *)(v3 + 88) = 0;
  if (*(_BYTE *)(a1 + 88))
  {
    v6 = (std::string *)(v3 + 96);
    if (*(char *)(a1 + 119) < 0)
    {
      std::string::__init_copy_ctor_external(v6, *(const std::string::value_type **)(a1 + 96), *(_QWORD *)(a1 + 104));
    }
    else
    {
      *(_OWORD *)&v6->__r_.__value_.__l.__data_ = *(_OWORD *)(a1 + 96);
      *(_QWORD *)(v3 + 112) = *(_QWORD *)(a1 + 112);
    }
    *(_BYTE *)(v3 + 88) = 1;
  }
  *(_BYTE *)(v3 + 120) = 0;
  if (*(_BYTE *)(a1 + 120))
  {
    *(_BYTE *)(v3 + 121) = *(_BYTE *)(a1 + 121);
    *(_BYTE *)(v3 + 120) = 1;
  }
  *(_BYTE *)(v3 + 124) = 0;
  if (*(_BYTE *)(a1 + 124))
  {
    *(_DWORD *)(v3 + 128) = *(_DWORD *)(a1 + 128);
    *(_BYTE *)(v3 + 124) = 1;
  }
  *(_BYTE *)(v3 + 136) = 0;
  if (*(_BYTE *)(a1 + 136))
  {
    v7 = (std::string *)(v3 + 144);
    if (*(char *)(a1 + 167) < 0)
    {
      std::string::__init_copy_ctor_external(v7, *(const std::string::value_type **)(a1 + 144), *(_QWORD *)(a1 + 152));
    }
    else
    {
      *(_OWORD *)&v7->__r_.__value_.__l.__data_ = *(_OWORD *)(a1 + 144);
      *(_QWORD *)(v3 + 160) = *(_QWORD *)(a1 + 160);
    }
    *(_BYTE *)(v3 + 136) = 1;
  }
  *(_BYTE *)(v3 + 168) = 0;
  if (*(_BYTE *)(a1 + 168))
  {
    v8 = (std::string *)(v3 + 176);
    if (*(char *)(a1 + 199) < 0)
    {
      std::string::__init_copy_ctor_external(v8, *(const std::string::value_type **)(a1 + 176), *(_QWORD *)(a1 + 184));
    }
    else
    {
      *(_OWORD *)&v8->__r_.__value_.__l.__data_ = *(_OWORD *)(a1 + 176);
      *(_QWORD *)(v3 + 192) = *(_QWORD *)(a1 + 192);
    }
    *(_BYTE *)(v3 + 168) = 1;
  }
  *(_BYTE *)(v3 + 200) = 0;
  if (*(_BYTE *)(a1 + 200))
  {
    *(_BYTE *)(v3 + 201) = *(_BYTE *)(a1 + 201);
    *(_BYTE *)(v3 + 200) = 1;
  }
  *(_BYTE *)(v3 + 202) = 0;
  if (*(_BYTE *)(a1 + 202))
  {
    *(_BYTE *)(v3 + 203) = *(_BYTE *)(a1 + 203);
    *(_BYTE *)(v3 + 202) = 1;
  }
  *(_BYTE *)(v3 + 204) = 0;
  if (*(_BYTE *)(a1 + 204))
  {
    *(_WORD *)(v3 + 206) = *(_WORD *)(a1 + 206);
    *(_BYTE *)(v3 + 204) = 1;
  }
  return v3;
}

void sub_2168D1AB8(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(_BYTE *)(v1 + 136))
  {
    if (*(char *)(v1 + 167) < 0)
      operator delete(*(void **)(v1 + 144));
    *(_BYTE *)(v1 + 136) = 0;
  }
  if (*(_BYTE *)(v1 + 124))
    *(_BYTE *)(v1 + 124) = 0;
  if (*(_BYTE *)(v1 + 120))
    *(_BYTE *)(v1 + 120) = 0;
  if (*(_BYTE *)(v1 + 88))
  {
    if (*(char *)(v1 + 119) < 0)
      operator delete(*(void **)(v1 + 96));
    *(_BYTE *)(v1 + 88) = 0;
  }
  if (*(_BYTE *)(v1 + 56))
  {
    if (*(char *)(v1 + 87) < 0)
      operator delete(*(void **)(v1 + 64));
    *(_BYTE *)(v1 + 56) = 0;
  }
  if (*(_BYTE *)(v1 + 48))
    *(_BYTE *)(v1 + 48) = 0;
  if (*(_BYTE *)(v1 + 16))
  {
    if (*(char *)(v1 + 47) < 0)
      operator delete(*(void **)(v1 + 24));
    *(_BYTE *)(v1 + 16) = 0;
  }
  MEMORY[0x2199FEAC4](v1, 0x1081C40B43373BFLL);
  _Unwind_Resume(a1);
}

_QWORD *ctu::cf::CFSharedRef<__CFBoolean const>::CFSharedRef<void const,void>(_QWORD *a1, CFTypeRef *a2)
{
  CFTypeRef v3;
  CFTypeID v4;
  const void *v5;

  v3 = *a2;
  if (*a2)
  {
    v4 = CFGetTypeID(*a2);
    if (v4 == CFBooleanGetTypeID())
      v5 = v3;
    else
      v5 = 0;
  }
  else
  {
    v5 = 0;
  }
  return ctu::SharedRef<__CFBoolean const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFBoolean const>::SharedRef(a1, v5);
}

_QWORD *ctu::SharedRef<__CFBoolean const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFBoolean const>::SharedRef(_QWORD *a1, CFTypeRef cf)
{
  *a1 = cf;
  if (cf)
    CFRetain(cf);
  return a1;
}

uint64_t qmi::MutableMessageBase::getTLV<wds::tlv::HandOverIPv6Prefix>(_QWORD *a1, int a2)
{
  const void **v2;
  const void **v3;
  void *v4;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3)
        return qmi::MutableMessageBase::createTLV<wds::tlv::HandOverIPv6Prefix>(a1, a2);
    }
  }
  if (v2 == v3)
    return qmi::MutableMessageBase::createTLV<wds::tlv::HandOverIPv6Prefix>(a1, a2);
  if (!v4)
    __cxa_bad_cast();
  return (uint64_t)v4 + 9;
}

uint64_t qmi::MutableMessageBase::createTLV<wds::tlv::HandOverIPv6Prefix>(_QWORD *a1, char a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v4 = operator new();
  *(_BYTE *)(v4 + 8) = a2;
  *(_QWORD *)v4 = &off_24D5C31C0;
  *(_QWORD *)(v4 + 9) = 0;
  *(_QWORD *)(v4 + 17) = 0;
  *(_BYTE *)(v4 + 25) = 0;
  v5 = a1[3];
  v6 = (uint64_t *)a1[2];
  if ((unint64_t)v6 >= v5)
  {
    v8 = a1[1];
    v9 = ((uint64_t)v6 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v5 - v8;
    v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1))
      v11 = v9 + 1;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v12);
    else
      v13 = 0;
    v14 = (uint64_t *)&v13[8 * v9];
    v15 = &v13[8 * v12];
    *v14 = v4;
    v7 = v14 + 1;
    v17 = (char *)a1[1];
    v16 = (char *)a1[2];
    if (v16 != v17)
    {
      do
      {
        v18 = *((_QWORD *)v16 - 1);
        v16 -= 8;
        *--v14 = v18;
      }
      while (v16 != v17);
      v16 = (char *)a1[1];
    }
    a1[1] = v14;
    a1[2] = v7;
    a1[3] = v15;
    if (v16)
      operator delete(v16);
  }
  else
  {
    *v6 = v4;
    v7 = v6 + 1;
  }
  a1[2] = v7;
  return v4 + 9;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::HandOverIPv6Prefix>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::HandOverIPv6Prefix>::getSize()
{
  return tlv::size<wds::tlv::HandOverIPv6Prefix>();
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::HandOverIPv6Prefix>::write(uint64_t a1, __n128 **a2)
{
  unsigned __int8 v3;
  __n128 *v4;
  uint64_t v5;
  char *v6;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = *a2;
  v5 = (uint64_t)(*a2)->n128_i64 + 3;
  *a2 = (__n128 *)v5;
  tlv::writeV<wds::tlv::HandOverIPv6Prefix>(a2, (__n128 *)(a1 + 9));
  v6 = (char *)*a2 - v5;
  v4->n128_u8[0] = v3;
  *(unsigned __int16 *)((char *)v4->n128_u16 + 1) = (unsigned __int16)v6;
}

__n128 qmi::MutableMessageBase::TlvWrapper<wds::tlv::HandOverIPv6Prefix>::clone(uint64_t a1)
{
  uint64_t v2;
  __n128 result;

  v2 = operator new();
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)v2 = &off_24D5C31C0;
  result = *(__n128 *)(a1 + 9);
  *(__n128 *)(v2 + 9) = result;
  *(_BYTE *)(v2 + 25) = *(_BYTE *)(a1 + 25);
  return result;
}

uint64_t qmi::MutableMessageBase::getTLV<wds::tlv::CallType>(_QWORD *a1, int a2)
{
  const void **v2;
  const void **v3;
  void *v4;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3)
        return qmi::MutableMessageBase::createTLV<wds::tlv::CallType>(a1, a2);
    }
  }
  if (v2 == v3)
    return qmi::MutableMessageBase::createTLV<wds::tlv::CallType>(a1, a2);
  if (!v4)
    __cxa_bad_cast();
  return (uint64_t)v4 + 9;
}

uint64_t qmi::MutableMessageBase::createTLV<wds::tlv::CallType>(_QWORD *a1, char a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v4 = operator new();
  *(_BYTE *)(v4 + 8) = a2;
  *(_BYTE *)(v4 + 9) = 0;
  *(_QWORD *)v4 = &off_24D5C3210;
  v5 = a1[3];
  v6 = (uint64_t *)a1[2];
  if ((unint64_t)v6 >= v5)
  {
    v8 = a1[1];
    v9 = ((uint64_t)v6 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v5 - v8;
    v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1))
      v11 = v9 + 1;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v12);
    else
      v13 = 0;
    v14 = (uint64_t *)&v13[8 * v9];
    v15 = &v13[8 * v12];
    *v14 = v4;
    v7 = v14 + 1;
    v17 = (char *)a1[1];
    v16 = (char *)a1[2];
    if (v16 != v17)
    {
      do
      {
        v18 = *((_QWORD *)v16 - 1);
        v16 -= 8;
        *--v14 = v18;
      }
      while (v16 != v17);
      v16 = (char *)a1[1];
    }
    a1[1] = v14;
    a1[2] = v7;
    a1[3] = v15;
    if (v16)
      operator delete(v16);
  }
  else
  {
    *v6 = v4;
    v7 = v6 + 1;
  }
  a1[2] = v7;
  return v4 + 9;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::CallType>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::CallType>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<wds::tlv::CallType>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::CallType>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C3210;
  return result;
}

uint64_t qmi::MutableMessageBase::getTLV<wds::tlv::IDataCall>(_QWORD *a1, int a2)
{
  const void **v2;
  const void **v3;
  void *v4;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3)
        return qmi::MutableMessageBase::createTLV<wds::tlv::IDataCall>(a1, a2);
    }
  }
  if (v2 == v3)
    return qmi::MutableMessageBase::createTLV<wds::tlv::IDataCall>(a1, a2);
  if (!v4)
    __cxa_bad_cast();
  return (uint64_t)v4 + 9;
}

uint64_t qmi::MutableMessageBase::createTLV<wds::tlv::IDataCall>(_QWORD *a1, char a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v4 = operator new();
  *(_BYTE *)(v4 + 8) = a2;
  *(_BYTE *)(v4 + 9) = 0;
  *(_QWORD *)v4 = &off_24D5C3260;
  v5 = a1[3];
  v6 = (uint64_t *)a1[2];
  if ((unint64_t)v6 >= v5)
  {
    v8 = a1[1];
    v9 = ((uint64_t)v6 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v5 - v8;
    v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1))
      v11 = v9 + 1;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v12);
    else
      v13 = 0;
    v14 = (uint64_t *)&v13[8 * v9];
    v15 = &v13[8 * v12];
    *v14 = v4;
    v7 = v14 + 1;
    v17 = (char *)a1[1];
    v16 = (char *)a1[2];
    if (v16 != v17)
    {
      do
      {
        v18 = *((_QWORD *)v16 - 1);
        v16 -= 8;
        *--v14 = v18;
      }
      while (v16 != v17);
      v16 = (char *)a1[1];
    }
    a1[1] = v14;
    a1[2] = v7;
    a1[3] = v15;
    if (v16)
      operator delete(v16);
  }
  else
  {
    *v6 = v4;
    v7 = v6 + 1;
  }
  a1[2] = v7;
  return v4 + 9;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::IDataCall>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::IDataCall>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<wds::tlv::IDataCall>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::IDataCall>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C3260;
  return result;
}

char *qmi::MutableMessageBase::getTLV<wds::tlv::TechPref>(_QWORD *a1)
{
  const void **v2;
  const void **v3;
  char **v4;
  char *v5;
  char *result;
  uint64_t v7;
  unint64_t v8;
  uint64_t *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  v4 = (char **)(a1 + 1);
  if (v2 != v3)
  {
    while (*((_BYTE *)*v2 + 8) != 48)
    {
      if (++v2 == v3)
        goto LABEL_8;
    }
  }
  if (v2 == v3)
  {
LABEL_8:
    v7 = operator new();
    *(_WORD *)(v7 + 8) = 48;
    *(_QWORD *)v7 = &off_24D5C32B0;
    v8 = a1[3];
    v9 = (uint64_t *)a1[2];
    if ((unint64_t)v9 >= v8)
    {
      v11 = ((char *)v9 - *v4) >> 3;
      if ((unint64_t)(v11 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v12 = v8 - (_QWORD)*v4;
      v13 = v12 >> 2;
      if (v12 >> 2 <= (unint64_t)(v11 + 1))
        v13 = v11 + 1;
      if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
        v14 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v14 = v13;
      if (v14)
        v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v14);
      else
        v15 = 0;
      v16 = (uint64_t *)&v15[8 * v11];
      v17 = &v15[8 * v14];
      *v16 = v7;
      v10 = v16 + 1;
      v19 = (char *)a1[1];
      v18 = (char *)a1[2];
      if (v18 != v19)
      {
        do
        {
          v20 = *((_QWORD *)v18 - 1);
          v18 -= 8;
          *--v16 = v20;
        }
        while (v18 != v19);
        v18 = *v4;
      }
      a1[1] = v16;
      a1[2] = v10;
      a1[3] = v17;
      if (v18)
        operator delete(v18);
    }
    else
    {
      *v9 = v7;
      v10 = v9 + 1;
    }
    result = (char *)(v7 + 9);
    a1[2] = v10;
  }
  else
  {
    if (!v5)
      __cxa_bad_cast();
    return v5 + 9;
  }
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::TechPref>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::TechPref>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<wds::tlv::TechPref>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::TechPref>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C32B0;
  return result;
}

char *qmi::MutableMessageBase::getTLV<wds::tlv::SecondaryDNSPreference>(_QWORD *a1)
{
  const void **v2;
  const void **v3;
  char **v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  v4 = (char **)(a1 + 1);
  if (v2 != v3)
  {
    while (*((_BYTE *)*v2 + 8) != 17)
    {
      if (++v2 == v3)
        goto LABEL_8;
    }
  }
  if (v2 == v3)
  {
LABEL_8:
    v7 = operator new();
    *(_BYTE *)(v7 + 8) = 17;
    *(_DWORD *)(v7 + 12) = 0;
    v6 = v7 + 12;
    *(_QWORD *)v7 = &off_24D5C3300;
    v8 = a1[3];
    v9 = (uint64_t *)a1[2];
    if ((unint64_t)v9 >= v8)
    {
      v11 = ((char *)v9 - *v4) >> 3;
      if ((unint64_t)(v11 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v12 = v8 - (_QWORD)*v4;
      v13 = v12 >> 2;
      if (v12 >> 2 <= (unint64_t)(v11 + 1))
        v13 = v11 + 1;
      if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
        v14 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v14 = v13;
      if (v14)
        v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v14);
      else
        v15 = 0;
      v16 = (uint64_t *)&v15[8 * v11];
      v17 = &v15[8 * v14];
      *v16 = v7;
      v10 = v16 + 1;
      v19 = (char *)a1[1];
      v18 = (char *)a1[2];
      if (v18 != v19)
      {
        do
        {
          v20 = *((_QWORD *)v18 - 1);
          v18 -= 8;
          *--v16 = v20;
        }
        while (v18 != v19);
        v18 = *v4;
      }
      a1[1] = v16;
      a1[2] = v10;
      a1[3] = v17;
      if (v18)
        operator delete(v18);
    }
    else
    {
      *v9 = v7;
      v10 = v9 + 1;
    }
    a1[2] = v10;
  }
  else
  {
    if (!v5)
      __cxa_bad_cast();
    return v5 + 12;
  }
  return (char *)v6;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::SecondaryDNSPreference>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::SecondaryDNSPreference>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

_DWORD **qmi::MutableMessageBase::TlvWrapper<wds::tlv::SecondaryDNSPreference>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _DWORD *v4;
  uint64_t v5;
  _DWORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_DWORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::PktDataHandle>((_DWORD **)a2, (_DWORD *)(a1 + 12));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::SecondaryDNSPreference>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C3300;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a1 + 12);
  return result;
}

uint64_t qmi::MutableMessageBase::getTLV<wds::tlv::ITechHandoverPDN>(_QWORD *a1, int a2)
{
  const void **v2;
  const void **v3;
  void *v4;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3)
        return qmi::MutableMessageBase::createTLV<wds::tlv::ITechHandoverPDN>(a1, a2);
    }
  }
  if (v2 == v3)
    return qmi::MutableMessageBase::createTLV<wds::tlv::ITechHandoverPDN>(a1, a2);
  if (!v4)
    __cxa_bad_cast();
  return (uint64_t)v4 + 9;
}

uint64_t qmi::MutableMessageBase::createTLV<wds::tlv::ITechHandoverPDN>(_QWORD *a1, char a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v4 = operator new();
  *(_BYTE *)(v4 + 8) = a2;
  *(_BYTE *)(v4 + 9) = 0;
  *(_QWORD *)v4 = &off_24D5C3350;
  v5 = a1[3];
  v6 = (uint64_t *)a1[2];
  if ((unint64_t)v6 >= v5)
  {
    v8 = a1[1];
    v9 = ((uint64_t)v6 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v5 - v8;
    v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1))
      v11 = v9 + 1;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v12);
    else
      v13 = 0;
    v14 = (uint64_t *)&v13[8 * v9];
    v15 = &v13[8 * v12];
    *v14 = v4;
    v7 = v14 + 1;
    v17 = (char *)a1[1];
    v16 = (char *)a1[2];
    if (v16 != v17)
    {
      do
      {
        v18 = *((_QWORD *)v16 - 1);
        v16 -= 8;
        *--v14 = v18;
      }
      while (v16 != v17);
      v16 = (char *)a1[1];
    }
    a1[1] = v14;
    a1[2] = v7;
    a1[3] = v15;
    if (v16)
      operator delete(v16);
  }
  else
  {
    *v6 = v4;
    v7 = v6 + 1;
  }
  a1[2] = v7;
  return v4 + 9;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::ITechHandoverPDN>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::ITechHandoverPDN>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<wds::tlv::ITechHandoverPDN>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::ITechHandoverPDN>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C3350;
  return result;
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3wds21StartNetworkIfaceBase8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BYTE v3[24];

  v2 = *(_QWORD *)(a1 + 32);
  cast_message_type<wds::StartNetworkIfaceBase::Response const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_2168D2A24(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void cast_message_type<wds::StartNetworkIfaceBase::Response const&>::cast(uint64_t a1@<X0>, qmi::ResponseBase *a2@<X8>)
{
  if (*(_DWORD *)(a1 + 40) != 1 || *(_WORD *)(a1 + 44) == 3)
  {
    QMIServiceMsg::serialize((QMIServiceMsg *)a1);
    qmi::Response<(unsigned short)32,wds::StartNetworkIfaceBase::ResponseTLVList>::Response(a2, 0);
  }
  else
  {
    QMIServiceMsg::getNewError((QMIServiceMsg *)a1);
    qmi::Response<(unsigned short)32,wds::StartNetworkIfaceBase::ResponseTLVList>::Response((uint64_t)a2);
  }
}

void sub_2168D2AC4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t qmi::Response<(unsigned short)32,wds::StartNetworkIfaceBase::ResponseTLVList>::Response(uint64_t a1)
{
  qmi::MessageBase *v2;

  v2 = (qmi::MessageBase *)qmi::MessageBase::MessageBase();
  qmi::MessageBase::validateMsgId(v2);
  return a1;
}

void sub_2168D2B0C(_Unwind_Exception *a1)
{
  qmi::MessageBase *v1;

  qmi::MessageBase::~MessageBase(v1);
  _Unwind_Resume(a1);
}

qmi::ResponseBase *qmi::Response<(unsigned short)32,wds::StartNetworkIfaceBase::ResponseTLVList>::Response(qmi::ResponseBase *a1, const void *a2)
{
  qmi::MessageBase *v3;

  v3 = (qmi::MessageBase *)qmi::ResponseBase::ResponseBase(a1, a2);
  qmi::MessageBase::validateMsgId(v3);
  return a1;
}

void sub_2168D2B4C(_Unwind_Exception *a1)
{
  qmi::MessageBase *v1;

  qmi::MessageBase::~MessageBase(v1);
  _Unwind_Resume(a1);
}

uint64_t QMIAttachApnCommandDriverBase::bootstrap_sync(Registry **this)
{
  char *v2;
  NSObject *v3;
  unint64_t *p_shared_weak_owners;
  unint64_t v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  std::__shared_weak_count *v12;
  uint64_t v13;
  std::__shared_weak_count *v14;
  uint64_t v15;
  std::__shared_weak_count *v16;
  void *__p;
  char v18;
  dispatch_object_t v19;
  void *v20;
  char v21;
  _BYTE v22[16];
  __int128 v23;

  AttachApnCommandDriver::bootstrap_sync((AttachApnCommandDriver *)this);
  v2 = (char *)attachApnClientName();
  std::string::basic_string[abi:ne180100]<0>(&v20, v2);
  v3 = this[3];
  v19 = v3;
  if (v3)
    dispatch_retain(v3);
  std::string::basic_string[abi:ne180100]<0>(&__p, "data_1");
  std::shared_ptr<AttachApnCommandDriver>::shared_ptr[abi:ne180100]<AttachApnCommandDriver,void>(&v13, this + 1);
  v15 = v13;
  v16 = v14;
  if (v14)
  {
    p_shared_weak_owners = (unint64_t *)&v14->__shared_weak_owners_;
    do
      v5 = __ldxr(p_shared_weak_owners);
    while (__stxr(v5 + 1, p_shared_weak_owners));
  }
  Registry::getServerConnection(this[6]);
  qmi::Client::createWithQueueLocal();
  std::shared_ptr<qmi::Client::State>::operator=[abi:ne180100]((uint64_t)(this + 14), &v23);
  qmi::Client::~Client((qmi::Client *)v22);
  if (v12)
  {
    p_shared_owners = (unint64_t *)&v12->__shared_owners_;
    do
      v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)())v12->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  if (v16)
    std::__shared_weak_count::__release_weak(v16);
  v8 = v14;
  if (v14)
  {
    v9 = (unint64_t *)&v14->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  if (v18 < 0)
    operator delete(__p);
  if (v19)
    dispatch_release(v19);
  if (v21 < 0)
    operator delete(v20);
  qmi::Client::setHandler();
  return qmi::Client::setHandler();
}

void sub_2168D2D60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,std::__shared_weak_count *a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  uint64_t v31;
  NSObject *v33;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a20);
  if (a25)
    std::__shared_weak_count::__release_weak(a25);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a22);
  if (a31 < 0)
    operator delete(__p);
  v33 = *(NSObject **)(v31 - 112);
  if (v33)
    dispatch_release(v33);
  if (*(char *)(v31 - 81) < 0)
    operator delete(*(void **)(v31 - 104));
  _Unwind_Resume(a1);
}

uint64_t ___ZN29QMIAttachApnCommandDriverBase14bootstrap_syncEv_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 72))(*(_QWORD *)(a1 + 32));
}

uint64_t ___ZN29QMIAttachApnCommandDriverBase14bootstrap_syncEv_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 64))(*(_QWORD *)(a1 + 32));
}

uint64_t QMIAttachApnCommandDriverBase::start_sync(QMIAttachApnCommandDriverBase *this)
{
  AttachApnCommandDriver::start_sync(this);
  return qmi::Client::start((QMIAttachApnCommandDriverBase *)((char *)this + 96));
}

uint64_t QMIAttachApnCommandDriverBase::shutdown_sync(QMIAttachApnCommandDriverBase *this)
{
  AttachApnCommandDriver::shutdown_sync(this);
  return qmi::Client::stop((QMIAttachApnCommandDriverBase *)((char *)this + 96));
}

void QMIAttachApnCommandDriverBase::handleBasebandOn_sync(QMIAttachApnCommandDriverBase *this)
{
  NSObject *v2;
  _QWORD v3[5];
  uint8_t buf[16];

  v2 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_216897000, v2, OS_LOG_TYPE_DEFAULT, "#I registered", buf, 2u);
  }
  *((_BYTE *)this + 128) = 1;
  v3[0] = MEMORY[0x24BDAC760];
  v3[1] = 0x40000000;
  v3[2] = ___ZN29QMIAttachApnCommandDriverBase21handleBasebandOn_syncEv_block_invoke;
  v3[3] = &__block_descriptor_tmp_4;
  v3[4] = this;
  ctu::SharedSynchronizable<AttachApnCommandDriver>::execute_wrapped((uint64_t *)this + 1, (uint64_t)v3);
}

uint64_t ___ZN29QMIAttachApnCommandDriverBase21handleBasebandOn_syncEv_block_invoke(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 88);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 32))(result);
  return result;
}

void QMIAttachApnCommandDriverBase::handleBasebandOff_sync(QMIAttachApnCommandDriverBase *this)
{
  NSObject *v2;
  _QWORD v3[5];
  uint8_t buf[16];

  v2 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_216897000, v2, OS_LOG_TYPE_DEFAULT, "#I deregistered", buf, 2u);
  }
  *((_BYTE *)this + 128) = 0;
  v3[0] = MEMORY[0x24BDAC760];
  v3[1] = 0x40000000;
  v3[2] = ___ZN29QMIAttachApnCommandDriverBase22handleBasebandOff_syncEv_block_invoke;
  v3[3] = &__block_descriptor_tmp_5;
  v3[4] = this;
  ctu::SharedSynchronizable<AttachApnCommandDriver>::execute_wrapped((uint64_t *)this + 1, (uint64_t)v3);
}

uint64_t ___ZN29QMIAttachApnCommandDriverBase22handleBasebandOff_syncEv_block_invoke(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 88);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
  return result;
}

void QMIAttachApnCommandDriverBase::dumpState_sync(QMIAttachApnCommandDriverBase *this)
{
  NSObject *v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  uint64_t v6;

  v6 = *MEMORY[0x24BDAC8D0];
  v2 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v4) = 0;
    _os_log_impl(&dword_216897000, v2, OS_LOG_TYPE_DEFAULT, "#I Driver state:", (uint8_t *)&v4, 2u);
    v2 = *((_QWORD *)this + 5);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v3 = CSIBOOLAsString();
    v4 = 136315138;
    v5 = v3;
    _os_log_impl(&dword_216897000, v2, OS_LOG_TYPE_DEFAULT, "#I   fClientStarted: %s", (uint8_t *)&v4, 0xCu);
  }
}

uint64_t AttachApnCommandDriver::getName(AttachApnCommandDriver *this)
{
  return *((_QWORD *)this + 10);
}

uint64_t std::shared_ptr<qmi::Client::State>::operator=[abi:ne180100](uint64_t a1, __int128 *a2)
{
  __int128 v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;

  v3 = *a2;
  *(_QWORD *)a2 = 0;
  *((_QWORD *)a2 + 1) = 0;
  v4 = *(std::__shared_weak_count **)(a1 + 8);
  *(_OWORD *)a1 = v3;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  return a1;
}

_QWORD *std::shared_ptr<AttachApnCommandDriver>::shared_ptr[abi:ne180100]<AttachApnCommandDriver,void>(_QWORD *a1, _QWORD *a2)
{
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;

  v3 = (std::__shared_weak_count *)a2[1];
  *a1 = *a2;
  if (!v3)
  {
    a1[1] = 0;
LABEL_5:
    std::__throw_bad_weak_ptr[abi:ne180100]();
  }
  v4 = std::__shared_weak_count::lock(v3);
  a1[1] = v4;
  if (!v4)
    goto LABEL_5;
  return a1;
}

void std::__throw_bad_weak_ptr[abi:ne180100]()
{
  _QWORD *exception;

  exception = __cxa_allocate_exception(8uLL);
  *exception = MEMORY[0x24BEDB808] + 16;
  __cxa_throw(exception, MEMORY[0x24BEDB6D8], MEMORY[0x24BEDAC00]);
}

void ctu::SharedSynchronizable<AttachApnCommandDriver>::execute_wrapped(uint64_t *a1, uint64_t a2)
{
  std::__shared_weak_count *v3;
  uint64_t v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  NSObject *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t v14;
  _QWORD block[6];
  std::__shared_weak_count *v16;

  v3 = (std::__shared_weak_count *)a1[1];
  if (!v3 || (v5 = *a1, (v6 = std::__shared_weak_count::lock(v3)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v7 = v6;
  v8 = a1[2];
  block[0] = MEMORY[0x24BDAC760];
  block[1] = 1174405120;
  block[2] = ___ZNK3ctu20SharedSynchronizableI22AttachApnCommandDriverE15execute_wrappedEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_24D5C34A0;
  block[5] = v5;
  v16 = v7;
  p_shared_owners = (unint64_t *)&v7->__shared_owners_;
  do
    v10 = __ldxr(p_shared_owners);
  while (__stxr(v10 + 1, p_shared_owners));
  block[4] = a2;
  dispatch_async(v8, block);
  v11 = v16;
  if (v16)
  {
    v12 = (unint64_t *)&v16->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  do
    v14 = __ldaxr(p_shared_owners);
  while (__stlxr(v14 - 1, p_shared_owners));
  if (!v14)
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
}

uint64_t ___ZNK3ctu20SharedSynchronizableI22AttachApnCommandDriverE15execute_wrappedEU13block_pointerFvvE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t __copy_helper_block_e8_40c51_ZTSNSt3__110shared_ptrIK22AttachApnCommandDriverEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 48) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void __destroy_helper_block_e8_40c51_ZTSNSt3__110shared_ptrIK22AttachApnCommandDriverEE(uint64_t a1)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v3;

  v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1)
  {
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      v3 = __ldaxr(p_shared_owners);
    while (__stlxr(v3 - 1, p_shared_owners));
    if (!v3)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

void QMIAttachApnCommandDriver::create(unint64_t *a1@<X0>, int a2@<W2>, uint64_t *a3@<X8>)
{
  uint64_t v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  unint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  NSObject *v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  std::__shared_weak_count *v17;
  unint64_t v18;
  unint64_t *p_shared_weak_owners;
  unint64_t v20;
  unint64_t v21;
  unint64_t *v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t *v25;
  unint64_t v26;
  NSObject *v27;
  uint64_t v28;
  std::__shared_weak_count *v29;
  uint8_t v30[16];
  uint8_t buf[24];
  uint64_t v32;

  v32 = *MEMORY[0x24BDAC8D0];
  *a3 = 0;
  a3[1] = 0;
  v6 = operator new();
  v7 = *a1;
  v8 = (std::__shared_weak_count *)a1[1];
  v29 = v8;
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
    *(_QWORD *)buf = v7;
    *(_QWORD *)&buf[8] = v8;
    do
      v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
  }
  else
  {
    *(_OWORD *)buf = *a1;
  }
  AttachApnCommandDriver::AttachApnCommandDriver();
  *(_QWORD *)v6 = off_24D5C33B0;
  *(_OWORD *)(v6 + 96) = 0u;
  *(_OWORD *)(v6 + 112) = 0u;
  *(_BYTE *)(v6 + 128) = 0;
  if (*(_QWORD *)&buf[8])
  {
    v12 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      (*(void (**)(_QWORD))(**(_QWORD **)&buf[8] + 16))(*(_QWORD *)&buf[8]);
      std::__shared_weak_count::__release_weak(*(std::__shared_weak_count **)&buf[8]);
    }
  }
  *(_QWORD *)v6 = &off_24D5C34E0;
  if (a2 != 1)
  {
    v14 = *(NSObject **)(v6 + 40);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)v30 = 0;
      _os_log_fault_impl(&dword_216897000, v14, OS_LOG_TYPE_FAULT, "IMPLEMENTATION BUG", v30, 2u);
    }
  }
  *a3 = v6;
  a3[1] = 0;
  v15 = (std::__shared_weak_count *)operator new();
  v15->__shared_owners_ = 0;
  v16 = (unint64_t *)&v15->__shared_owners_;
  v15->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C3DA0;
  v15->__shared_weak_owners_ = 0;
  v15[1].__vftable = (std::__shared_weak_count_vtbl *)v6;
  a3[1] = (uint64_t)v15;
  v17 = *(std::__shared_weak_count **)(v6 + 16);
  if (v17)
  {
    if (v17->__shared_owners_ != -1)
      goto LABEL_29;
    do
      v18 = __ldxr(v16);
    while (__stxr(v18 + 1, v16));
    p_shared_weak_owners = (unint64_t *)&v15->__shared_weak_owners_;
    do
      v20 = __ldxr(p_shared_weak_owners);
    while (__stxr(v20 + 1, p_shared_weak_owners));
    *(_QWORD *)(v6 + 8) = v6;
    *(_QWORD *)(v6 + 16) = v15;
    std::__shared_weak_count::__release_weak(v17);
  }
  else
  {
    do
      v21 = __ldxr(v16);
    while (__stxr(v21 + 1, v16));
    v22 = (unint64_t *)&v15->__shared_weak_owners_;
    do
      v23 = __ldxr(v22);
    while (__stxr(v23 + 1, v22));
    *(_QWORD *)(v6 + 8) = v6;
    *(_QWORD *)(v6 + 16) = v15;
  }
  do
    v24 = __ldaxr(v16);
  while (__stlxr(v24 - 1, v16));
  if (!v24)
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
LABEL_29:
  if (v29)
  {
    v25 = (unint64_t *)&v29->__shared_owners_;
    do
      v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
      std::__shared_weak_count::__release_weak(v29);
    }
  }
  v27 = *(NSObject **)(*a3 + 40);
  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
  {
    v28 = subscriber::asString();
    *(_DWORD *)buf = 136315138;
    *(_QWORD *)&buf[4] = v28;
    _os_log_impl(&dword_216897000, v27, OS_LOG_TYPE_DEFAULT, "#I QMIAttachApnCommandDriver created for %s", buf, 0xCu);
  }
}

void sub_2168D35E4(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void QMIAttachApnCommandDriver::~QMIAttachApnCommandDriver(QMIAttachApnCommandDriver *this)
{
  *(_QWORD *)this = off_24D5C33B0;
  qmi::Client::~Client((QMIAttachApnCommandDriver *)((char *)this + 96));
  AttachApnCommandDriver::~AttachApnCommandDriver(this);
}

{
  *(_QWORD *)this = off_24D5C33B0;
  qmi::Client::~Client((QMIAttachApnCommandDriver *)((char *)this + 96));
  AttachApnCommandDriver::~AttachApnCommandDriver(this);
  JUMPOUT(0x2199FEAC4);
}

__int128 *QMIAttachApnCommandDriver::performPushSettingsToBB_sync(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  char v5;
  NSObject *v6;
  NSObject *v7;
  _QWORD *v8;
  const __CFDictionary *v9;
  uint64_t (*v10)(uint64_t);
  const void *Value;
  __CFString *v12;
  CFTypeID TypeID;
  NSObject *v14;
  void **v15;
  uint64_t (*v16)(uint64_t);
  CFIndex Count;
  CFIndex i;
  const void *ValueAtIndex;
  uint64_t (*v20)(uint64_t);
  NSObject *v21;
  CFTypeID v22;
  NSObject *v23;
  void **v24;
  uint64_t (*v25)(uint64_t);
  NSObject *v26;
  int v27;
  const void **v28;
  const void **v29;
  uint64_t v30;
  uint64_t v31;
  _QWORD *v32;
  uint8_t *v33;
  uint64_t v34;
  _QWORD *v35;
  const void *v36;
  _QWORD *v37;
  uint64_t (*v38)(uint64_t);
  void **v39;
  void *v40;
  uint64_t v41;
  uint64_t v42;
  std::string *v43;
  uint64_t v44;
  std::string *v45;
  int *v46;
  int Int;
  _DWORD *v48;
  int v49;
  _DWORD *v50;
  char *v51;
  _BYTE *v52;
  int *v53;
  int *v54;
  CFTypeID v55;
  const __CFNumber *v56;
  int v57;
  uint64_t v58;
  BOOL *v59;
  BOOL *v60;
  CFTypeID v61;
  const __CFBoolean *v62;
  int v63;
  char v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  unint64_t v68;
  unint64_t v69;
  __CFString *v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  int64x2_t v75;
  __CFString *v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  unint64_t v80;
  int v81;
  void *v82;
  _QWORD *v83;
  uint8_t *v84;
  uint64_t v85;
  _QWORD *v86;
  const void *v87;
  _QWORD *v88;
  int v89;
  void **v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  const void *v95;
  __CFString *v96;
  CFTypeID v97;
  NSObject *v98;
  void **v99;
  uint64_t (*v100)(uint64_t);
  CFIndex v101;
  CFIndex j;
  const void *v103;
  uint64_t (*v104)(uint64_t);
  CFTypeID v105;
  NSObject *v106;
  void **v107;
  uint64_t (*v108)(uint64_t);
  NSObject *v109;
  int v110;
  _QWORD *v111;
  uint8_t *v112;
  uint64_t v113;
  _QWORD *v114;
  const void *v115;
  _QWORD *v116;
  int v117;
  void **v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  const void **v122;
  const void **v123;
  uint64_t v124;
  uint64_t v125;
  _QWORD *v126;
  uint8_t *v127;
  uint64_t v128;
  _QWORD *v129;
  const void *v130;
  _QWORD *v131;
  uint64_t (*v132)(uint64_t);
  void **v133;
  void *v134;
  uint64_t v135;
  uint64_t v136;
  std::string *v137;
  uint64_t v138;
  std::string *v139;
  int *v140;
  char *v141;
  int *v142;
  int *v143;
  int v144;
  _DWORD *v145;
  int *v146;
  int *v147;
  CFTypeID v148;
  const __CFNumber *v149;
  int v150;
  _BYTE *v151;
  BOOL *v152;
  BOOL *v153;
  CFTypeID v154;
  const __CFBoolean *v155;
  int v156;
  char v157;
  std::string::size_type v158;
  std::string::size_type size;
  uint64_t v160;
  unint64_t v161;
  int v162;
  void *v163;
  _QWORD *v164;
  uint8_t *v165;
  uint64_t v166;
  _QWORD *v167;
  const void *v168;
  _QWORD *v169;
  int v170;
  void **v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  std::__shared_weak_count *v176;
  unint64_t *v177;
  unint64_t v178;
  unint64_t *p_shared_owners;
  unint64_t v180;
  NSObject *v181;
  unint64_t *p_shared_weak_owners;
  unint64_t v183;
  _QWORD *v184;
  uint64_t v185;
  uint64_t v186;
  __int128 *result;
  uint64_t v188;
  char v189;
  uint64_t v190;
  std::string *v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  char *v195;
  char *v196;
  _QWORD v198[6];
  dispatch_group_t v199;
  int v200;
  xpc_object_t v201;
  __CFDictionary *v202;
  xpc_object_t v203;
  _QWORD v204[6];
  dispatch_group_t group;
  int v206;
  _QWORD v207[2];
  xpc_object_t object;
  xpc_object_t v209;
  const void **v210;
  const void **v211;
  uint64_t v212;
  int64x2_t v213;
  __CFString *v214;
  _QWORD v215[3];
  char v216;
  __int128 v217;
  __int128 v218;
  int v219;
  std::string v220;
  std::string::size_type v221[2];
  __int128 v222;
  char v223;
  __CFString *v224;
  uint64_t v225;
  void (*v226)(uint64_t, _DWORD *);
  void *v227;
  int v228;
  int v229;
  __CFString *v230;
  uint64_t v231;
  void (*v232)(uint64_t, _DWORD *);
  void *v233;
  int v234;
  __CFString *v235;
  uint64_t v236;
  void (*v237)(uint64_t, _BYTE *);
  void *v238;
  const void ***v239;
  void *v240;
  uint64_t v241;
  void (*v242)(uint64_t, int *);
  void *v243;
  const void ***v244;
  CFArrayRef theArray;
  uint64_t v246;
  void (*v247)(uint64_t, char *);
  void *v248;
  std::string v249;
  std::string v250;
  __CFString *v251;
  uint64_t v252;
  void (*v253)(uint64_t, std::string *);
  void *v254;
  const void ***v255;
  std::string __s;
  void *__p[2];
  void (*v258)(uint64_t, std::string *);
  void *v259;
  std::string v260;
  __CFString *v261;
  int64x2_t v262;
  __CFString *v263;
  const void ***v264;
  _QWORD block[7];
  std::__shared_weak_count *v266;
  _BYTE v267[24];
  _BYTE *v268;
  char v269;
  uint8_t aBlock[16];
  __int128 v271;
  __int128 v272;
  __int128 v273;
  __int128 v274;
  void *v275[2];
  __int128 v276;
  __int128 v277;
  __int128 v278;
  __int128 v279;
  __int128 v280;
  __int128 v281;
  __int128 v282;
  __int128 v283;
  __int128 v284;
  __int128 v285;
  __int128 v286;
  uint64_t v287;
  __int128 v288;
  __int128 v289;
  uint8_t buf[16];
  __int128 v291;
  std::string v292;
  uint64_t v293;

  v293 = *MEMORY[0x24BDAC8D0];
  v288 = 0u;
  v289 = 0u;
  std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100]((uint64_t)&v288, a3);
  v5 = *(_BYTE *)(a3 + 32);
  v215[0] = 0;
  v215[1] = v215;
  v215[2] = 0x2000000000;
  v216 = 0;
  v6 = dispatch_group_create();
  v7 = v6;
  if (v6)
  {
    dispatch_retain(v6);
    dispatch_group_enter(v7);
    dispatch_release(v7);
  }
  v8 = (_QWORD *)&loc_216A9C000;
  if (*(_BYTE *)(a2 + 8))
  {
    v9 = *(const __CFDictionary **)a2;
    v10 = ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::get;
    if (!*(_QWORD *)a2)
      v10 = 0;
    if (v10)
    {
      v213 = 0uLL;
      v214 = 0;
      Value = CFDictionaryGetValue(v9, (const void *)*MEMORY[0x24BDC3D90]);
      v189 = v5;
      v12 = (__CFString *)MEMORY[0x24BDAC760];
      v190 = a2;
      if (Value)
      {
        v210 = 0;
        v211 = 0;
        v212 = 0;
        TypeID = CFArrayGetTypeID();
        if (TypeID == CFGetTypeID(Value))
        {
          theArray = 0;
          ctu::cf::CFSharedRef<__CFArray const>::CFSharedRef<void const,void>(&theArray, Value);
          v14 = a1[5];
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
          {
            memset(aBlock, 0, sizeof(aBlock));
            *(_QWORD *)&v271 = 0;
            ctu::cf::assign();
            *(_OWORD *)__p = *(_OWORD *)aBlock;
            v258 = (void (*)(uint64_t, std::string *))v271;
            v15 = *(void ***)aBlock;
            if ((SBYTE7(v271) & 0x80u) == 0)
              v15 = __p;
            *(_DWORD *)buf = 136315138;
            *(_QWORD *)&buf[4] = v15;
            _os_log_impl(&dword_216897000, v14, OS_LOG_TYPE_DEFAULT, "#I array of settings: %s", buf, 0xCu);
            if (SHIBYTE(v258) < 0)
              operator delete(__p[0]);
          }
          v16 = ctu::SharedRef<__CFArray const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFArray const>::get;
          if (!theArray)
            v16 = 0;
          if (v16)
          {
            Count = CFArrayGetCount(theArray);
            if (Count >= 1)
            {
              for (i = 0; i != Count; ++i)
              {
                *(_QWORD *)aBlock = 0;
                ValueAtIndex = CFArrayGetValueAtIndex(theArray, i);
                ctu::cf::CFSharedRef<__CFDictionary const>::CFSharedRef<void const,void>(aBlock, ValueAtIndex);
                v20 = ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::get;
                if (!*(_QWORD *)aBlock)
                  v20 = 0;
                if (v20)
                  std::vector<ctu::cf::CFSharedRef<__CFDictionary const>>::push_back[abi:ne180100](&v210, (const void **)aBlock);
                ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef((const void **)aBlock);
              }
            }
          }
          ctu::SharedRef<__CFArray const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFArray const>::~SharedRef((const void **)&theArray);
        }
        else
        {
          v22 = CFDictionaryGetTypeID();
          if (v22 == CFGetTypeID(Value))
          {
            theArray = 0;
            ctu::cf::CFSharedRef<__CFDictionary const>::CFSharedRef<void const,void>(&theArray, Value);
            v23 = a1[5];
            if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
            {
              memset(aBlock, 0, sizeof(aBlock));
              *(_QWORD *)&v271 = 0;
              ctu::cf::assign();
              *(_OWORD *)__p = *(_OWORD *)aBlock;
              v258 = (void (*)(uint64_t, std::string *))v271;
              v24 = *(void ***)aBlock;
              if ((SBYTE7(v271) & 0x80u) == 0)
                v24 = __p;
              *(_DWORD *)buf = 136315138;
              *(_QWORD *)&buf[4] = v24;
              _os_log_impl(&dword_216897000, v23, OS_LOG_TYPE_DEFAULT, "#I dict of settings: %s", buf, 0xCu);
              if (SHIBYTE(v258) < 0)
                operator delete(__p[0]);
            }
            v25 = ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::get;
            if (!theArray)
              v25 = 0;
            if (v25)
              std::vector<ctu::cf::CFSharedRef<__CFDictionary const>>::push_back[abi:ne180100](&v210, (const void **)&theArray);
            ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef((const void **)&theArray);
          }
          else
          {
            v26 = a1[5];
            if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
            {
              v27 = CFGetTypeID(Value);
              *(_DWORD *)aBlock = 67109120;
              *(_DWORD *)&aBlock[4] = v27;
              _os_log_impl(&dword_216897000, v26, OS_LOG_TYPE_DEFAULT, "#E unknown CF type: %d", aBlock, 8u);
            }
          }
        }
        v29 = v210;
        v28 = v211;
        if (v210 != v211)
        {
          v195 = (char *)*MEMORY[0x24BDC3DA8];
          v30 = *MEMORY[0x24BEDB7F0];
          v191 = *(std::string **)(MEMORY[0x24BEDB7F0] + 72);
          v192 = *(_QWORD *)(MEMORY[0x24BEDB7F0] + 64);
          v31 = MEMORY[0x24BEDB848] + 16;
          while (1)
          {
            v209 = 0;
            ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::SharedRef((const void **)&v209, v29);
            v287 = 0;
            v286 = 0u;
            v285 = 0u;
            v284 = 0u;
            v283 = 0u;
            v282 = 0u;
            v281 = 0u;
            v280 = 0u;
            v279 = 0u;
            v278 = 0u;
            v277 = 0u;
            v276 = 0u;
            *(_OWORD *)v275 = 0u;
            v274 = 0u;
            v273 = 0u;
            v272 = 0u;
            v271 = 0u;
            *(_OWORD *)aBlock = 0u;
            std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)aBlock);
            v32 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v271, (uint64_t)"trying to push ", 15);
            __p[1] = 0;
            __p[0] = 0;
            v258 = 0;
            ctu::cf::assign();
            *(_OWORD *)buf = *(_OWORD *)__p;
            *(_QWORD *)&v291 = v258;
            v33 = SHIBYTE(v258) >= 0 ? buf : *(uint8_t **)buf;
            v34 = SHIBYTE(v258) >= 0 ? BYTE7(v291) : *(_QWORD *)&buf[8];
            v35 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v32, (uint64_t)v33, v34);
            v37 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v35, (uint64_t)" attach APN ", 12);
            v38 = v209
                ? ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::get
                : 0;
            if (v38)
            {
              ctu::cf_to_xpc((ctu *)v209, v36);
              xpc::object::to_string((xpc::object *)&object);
            }
            else
            {
              std::string::basic_string[abi:ne180100]<0>(__p, "empty");
            }
            v39 = SHIBYTE(v258) >= 0 ? __p : (void **)__p[0];
            v40 = SHIBYTE(v258) >= 0 ? (void *)HIBYTE(v258) : __p[1];
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v37, (uint64_t)v39, (uint64_t)v40);
            if (SHIBYTE(v258) < 0)
              break;
            if (v38)
              goto LABEL_64;
LABEL_65:
            if (SBYTE7(v291) < 0)
              operator delete(*(void **)buf);
            v41 = a1[11];
            if (v41)
              (*(void (**)(uint64_t, uint8_t *))(*(_QWORD *)v41 + 48))(v41, aBlock);
            v207[0] = 0;
            v207[1] = 0;
            ctu::cf::dict_adapter::dict_adapter((ctu::cf::dict_adapter *)v207, (const __CFDictionary *)v209);
            *(_OWORD *)v221 = 0u;
            v222 = 0u;
            qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v221);
            v42 = qmi::MutableMessageBase::getTLV<wds::tlv::ProfileId>(v221, 1);
            *(_DWORD *)v42 = 0;
            *(_BYTE *)(v42 + 4) = -1;
            memset(&__s, 0, sizeof(__s));
            v262 = 0uLL;
            v261 = 0;
            ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)&v251, "username");
            ctu::cf::map_adapter::getString();
            MEMORY[0x2199FDFFC](&v251);
            if (v262.i8[15] < 0)
              operator delete(v261);
            if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0)
            {
              if (!__s.__r_.__value_.__l.__size_)
                goto LABEL_78;
              __p[0] = v12;
              __p[1] = (void *)1174405120;
              v258 = ___ZL27sCreateSettingsMessage_3GPPRKN3ctu2cf12dict_adapterERNSt3__16vectorIN3wds25ModifyProfileSettings3GPP7RequestENS4_9allocatorIS8_EEEE_block_invoke_2;
              v259 = &__block_descriptor_tmp_18;
              std::string::__init_copy_ctor_external(&v260, __s.__r_.__value_.__l.__data_, __s.__r_.__value_.__l.__size_);
            }
            else
            {
              if (!*((_BYTE *)&__s.__r_.__value_.__s + 23))
                goto LABEL_78;
              __p[0] = v12;
              __p[1] = (void *)1174405120;
              v258 = ___ZL27sCreateSettingsMessage_3GPPRKN3ctu2cf12dict_adapterERNSt3__16vectorIN3wds25ModifyProfileSettings3GPP7RequestENS4_9allocatorIS8_EEEE_block_invoke_2;
              v259 = &__block_descriptor_tmp_18;
              v260 = __s;
            }
            v43 = (std::string *)qmi::MutableMessageBase::getTLV<wds::tlv::UserName>(v221, 27);
            v258((uint64_t)__p, v43);
            if (SHIBYTE(v260.__r_.__value_.__r.__words[2]) < 0)
              operator delete(v260.__r_.__value_.__l.__data_);
LABEL_78:
            memset(&v250, 0, sizeof(v250));
            v262 = 0uLL;
            v261 = 0;
            ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)&v251, "password");
            ctu::cf::map_adapter::getString();
            MEMORY[0x2199FDFFC](&v251);
            if (v262.i8[15] < 0)
              operator delete(v261);
            if (SHIBYTE(v250.__r_.__value_.__r.__words[2]) < 0)
            {
              if (!v250.__r_.__value_.__l.__size_)
                goto LABEL_87;
              *(_QWORD *)buf = v12;
              *(_QWORD *)&buf[8] = 1174405120;
              *(_QWORD *)&v291 = ___ZL27sCreateSettingsMessage_3GPPRKN3ctu2cf12dict_adapterERNSt3__16vectorIN3wds25ModifyProfileSettings3GPP7RequestENS4_9allocatorIS8_EEEE_block_invoke_20;
              *((_QWORD *)&v291 + 1) = &__block_descriptor_tmp_21;
              std::string::__init_copy_ctor_external(&v292, v250.__r_.__value_.__l.__data_, v250.__r_.__value_.__l.__size_);
            }
            else
            {
              if (!*((_BYTE *)&v250.__r_.__value_.__s + 23))
                goto LABEL_87;
              *(_QWORD *)buf = v12;
              *(_QWORD *)&buf[8] = 1174405120;
              *(_QWORD *)&v291 = ___ZL27sCreateSettingsMessage_3GPPRKN3ctu2cf12dict_adapterERNSt3__16vectorIN3wds25ModifyProfileSettings3GPP7RequestENS4_9allocatorIS8_EEEE_block_invoke_20;
              *((_QWORD *)&v291 + 1) = &__block_descriptor_tmp_21;
              v292 = v250;
            }
            v44 = qmi::MutableMessageBase::getTLV<wds::tlv::Password>(v221, 28);
            ((void (*)(uint8_t *, uint64_t))v291)(buf, v44);
            if (SHIBYTE(v292.__r_.__value_.__r.__words[2]) < 0)
              operator delete(v292.__r_.__value_.__l.__data_);
LABEL_87:
            v251 = v12;
            v252 = 0x40000000;
            v253 = ___ZL27sCreateSettingsMessage_3GPPRKN3ctu2cf12dict_adapterERNSt3__16vectorIN3wds25ModifyProfileSettings3GPP7RequestENS4_9allocatorIS8_EEEE_block_invoke_22;
            v254 = &__block_descriptor_tmp_24;
            v255 = (const void ***)v207;
            v45 = (std::string *)qmi::MutableMessageBase::getTLV<wds::tlv::ApnName>(v221, 20);
            v253((uint64_t)&v251, v45);
            v240 = v12;
            v241 = 0x40000000;
            v242 = (void (*)(uint64_t, int *))___ZL27sCreateSettingsMessage_3GPPRKN3ctu2cf12dict_adapterERNSt3__16vectorIN3wds25ModifyProfileSettings3GPP7RequestENS4_9allocatorIS8_EEEE_block_invoke_2_25;
            v243 = &__block_descriptor_tmp_28;
            v244 = (const void ***)v207;
            v46 = (int *)qmi::MutableMessageBase::getTLV<wds::tlv::PdpType3GPP>(v221, 17);
            v242((uint64_t)&v240, v46);
            ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)&v261, "AllowedProtocolMaskInRoamingLTE");
            Int = ctu::cf::map_adapter::getInt((ctu::cf::map_adapter *)v207, v261);
            MEMORY[0x2199FDFFC](&v261);
            if ((Int - 1) <= 2)
            {
              v230 = v12;
              v231 = 0x40000000;
              v232 = (void (*)(uint64_t, _DWORD *))___ZL27sCreateSettingsMessage_3GPPRKN3ctu2cf12dict_adapterERNSt3__16vectorIN3wds25ModifyProfileSettings3GPP7RequestENS4_9allocatorIS8_EEEE_block_invoke_4;
              v233 = &__block_descriptor_tmp_34;
              v234 = Int - 1;
              v48 = (_DWORD *)qmi::MutableMessageBase::getTLV<wds::tlv::LTERoamingPdpType>(v221, 65);
              v232((uint64_t)&v230, v48);
            }
            ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)&v261, "AllowedProtocolMaskInRoamingUMTS");
            v49 = ctu::cf::map_adapter::getInt((ctu::cf::map_adapter *)v207, v261);
            MEMORY[0x2199FDFFC](&v261);
            if ((v49 - 1) <= 2)
            {
              v224 = v12;
              v225 = 0x40000000;
              v226 = (void (*)(uint64_t, _DWORD *))___ZL27sCreateSettingsMessage_3GPPRKN3ctu2cf12dict_adapterERNSt3__16vectorIN3wds25ModifyProfileSettings3GPP7RequestENS4_9allocatorIS8_EEEE_block_invoke_5;
              v227 = &__block_descriptor_tmp_37;
              v228 = v49 - 1;
              v50 = (_DWORD *)qmi::MutableMessageBase::getTLV<wds::tlv::UMTSRoamingPdpType>(v221, 66);
              v226((uint64_t)&v224, v50);
            }
            memset(&v220, 0, sizeof(v220));
            v262 = 0uLL;
            v261 = 0;
            ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)&v235, "auth_type");
            ctu::cf::map_adapter::getString();
            MEMORY[0x2199FDFFC](&v235);
            if (v262.i8[15] < 0)
              operator delete(v261);
            if (SHIBYTE(v220.__r_.__value_.__r.__words[2]) < 0)
            {
              if (v220.__r_.__value_.__l.__size_)
              {
                theArray = (CFArrayRef)v12;
                v246 = 1174405120;
                v247 = (void (*)(uint64_t, char *))___ZL27sCreateSettingsMessage_3GPPRKN3ctu2cf12dict_adapterERNSt3__16vectorIN3wds25ModifyProfileSettings3GPP7RequestENS4_9allocatorIS8_EEEE_block_invoke_6;
                v248 = &__block_descriptor_tmp_40;
                std::string::__init_copy_ctor_external(&v249, v220.__r_.__value_.__l.__data_, v220.__r_.__value_.__l.__size_);
LABEL_98:
                v51 = (char *)qmi::MutableMessageBase::getTLV<wds::tlv::AuthPref>(v221, 29);
                v247((uint64_t)&theArray, v51);
                if (SHIBYTE(v249.__r_.__value_.__r.__words[2]) < 0)
                  operator delete(v249.__r_.__value_.__l.__data_);
              }
            }
            else if (*((_BYTE *)&v220.__r_.__value_.__s + 23))
            {
              theArray = (CFArrayRef)v12;
              v246 = 1174405120;
              v247 = (void (*)(uint64_t, char *))___ZL27sCreateSettingsMessage_3GPPRKN3ctu2cf12dict_adapterERNSt3__16vectorIN3wds25ModifyProfileSettings3GPP7RequestENS4_9allocatorIS8_EEEE_block_invoke_6;
              v248 = &__block_descriptor_tmp_40;
              v249 = v220;
              goto LABEL_98;
            }
            v235 = v12;
            v236 = 0x40000000;
            v237 = ___ZL27sCreateSettingsMessage_3GPPRKN3ctu2cf12dict_adapterERNSt3__16vectorIN3wds25ModifyProfileSettings3GPP7RequestENS4_9allocatorIS8_EEEE_block_invoke_41;
            v238 = &__block_descriptor_tmp_45;
            v239 = (const void ***)v207;
            v52 = (_BYTE *)qmi::MutableMessageBase::getTLV<wds::tlv::ProxyAddrUsingPco>(v221, 31);
            v237((uint64_t)&v235, v52);
            LODWORD(v203) = -1;
            ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)&v261, "APNClass");
            v53 = (int *)(*(uint64_t (**)(_QWORD *, __CFString *))v207[0])(v207, v261);
            v54 = v53;
            if (v53)
            {
              v55 = CFGetTypeID(v53);
              if (v55 == CFNumberGetTypeID())
                v57 = ctu::cf::assign((ctu::cf *)&v203, v54, v56);
              else
                v57 = 0;
              CFRelease(v54);
            }
            else
            {
              v57 = 0;
            }
            MEMORY[0x2199FDFFC](&v261);
            if (v57 && (v203 & 0x80000000) == 0)
            {
              *(_QWORD *)&v217 = v12;
              *((_QWORD *)&v217 + 1) = 0x40000000;
              *(_QWORD *)&v218 = ___ZL27sCreateSettingsMessage_3GPPRKN3ctu2cf12dict_adapterERNSt3__16vectorIN3wds25ModifyProfileSettings3GPP7RequestENS4_9allocatorIS8_EEEE_block_invoke_2_47;
              *((_QWORD *)&v218 + 1) = &__block_descriptor_tmp_49;
              v219 = (int)v203;
              v58 = qmi::MutableMessageBase::getTLV<wds::tlv::APNClass>(v221, 49);
              ((void (*)(__int128 *, uint64_t))v218)(&v217, v58);
            }
            LOBYTE(v202) = 1;
            ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)&v261, v195);
            v59 = (BOOL *)(*(uint64_t (**)(_QWORD *, __CFString *))v207[0])(v207, v261);
            v60 = v59;
            if (v59)
            {
              v61 = CFGetTypeID(v59);
              if (v61 == CFBooleanGetTypeID())
                v63 = ctu::cf::assign((ctu::cf *)&v202, v60, v62);
              else
                v63 = 0;
              CFRelease(v60);
              MEMORY[0x2199FDFFC](&v261);
              if (v63)
              {
                v64 = (char)v202;
                *(_BYTE *)qmi::MutableMessageBase::getTLV<wds::tlv::RoamingDisallow>(v221, 62) = v64 ^ 1;
              }
            }
            else
            {
              MEMORY[0x2199FDFFC](&v261);
            }
            v65 = v213.i64[1];
            if (v213.i64[1] >= (unint64_t)v214)
            {
              v67 = (v213.i64[1] - v213.i64[0]) >> 5;
              if ((unint64_t)(v67 + 1) >> 59)
                std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
              v68 = ((uint64_t)v214 - v213.i64[0]) >> 4;
              if (v68 <= v67 + 1)
                v68 = v67 + 1;
              if ((unint64_t)v214 - v213.i64[0] >= 0x7FFFFFFFFFFFFFE0)
                v69 = 0x7FFFFFFFFFFFFFFLL;
              else
                v69 = v68;
              v264 = (const void ***)&v214;
              if (v69)
              {
                if (v69 >> 59)
                  std::__throw_bad_array_new_length[abi:ne180100]();
                v70 = (__CFString *)operator new(32 * v69);
              }
              else
              {
                v70 = 0;
              }
              v261 = v70;
              v262.i64[0] = (uint64_t)&v70[v67];
              v262.i64[1] = v262.i64[0];
              v263 = &v70[v69];
              qmi::MutableMessageBase::MutableMessageBase();
              v72 = v213.i64[1];
              v71 = v213.i64[0];
              v73 = v262.i64[1];
              v74 = v262.i64[0];
              if (v213.i64[1] == v213.i64[0])
              {
                v75 = vdupq_n_s64(v213.u64[1]);
              }
              else
              {
                do
                {
                  v72 -= 32;
                  v74 = qmi::MutableMessageBase::MutableMessageBase();
                }
                while (v72 != v71);
                v75 = v213;
              }
              v66 = v73 + 32;
              v213.i64[0] = v74;
              v213.i64[1] = v66;
              v262 = v75;
              v76 = v214;
              v214 = v263;
              v263 = v76;
              v261 = (__CFString *)v75.i64[0];
              std::__split_buffer<wds::ModifyProfileSettings3GPP::Request>::~__split_buffer((uint64_t)&v261);
            }
            else
            {
              qmi::MutableMessageBase::MutableMessageBase();
              v66 = v65 + 32;
            }
            v12 = (__CFString *)MEMORY[0x24BDAC760];
            v213.i64[1] = v66;
            if (SHIBYTE(v220.__r_.__value_.__r.__words[2]) < 0)
              operator delete(v220.__r_.__value_.__l.__data_);
            if (SHIBYTE(v250.__r_.__value_.__r.__words[2]) < 0)
              operator delete(v250.__r_.__value_.__l.__data_);
            if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0)
              operator delete(__s.__r_.__value_.__l.__data_);
            qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v221);
            MEMORY[0x2199FE02C](v207);
            *(_QWORD *)aBlock = v30;
            *(_QWORD *)&aBlock[*(_QWORD *)(v30 - 24)] = v192;
            *(_QWORD *)&v271 = v191;
            *((_QWORD *)&v271 + 1) = v31;
            if (SHIBYTE(v276) < 0)
              operator delete(v275[1]);
            std::streambuf::~streambuf();
            std::iostream::~basic_iostream();
            MEMORY[0x2199FEA70](&v278);
            ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef((const void **)&v209);
            if (++v29 == v28)
              goto LABEL_142;
          }
          operator delete(__p[0]);
          if (!v38)
            goto LABEL_65;
LABEL_64:
          xpc_release(object);
          goto LABEL_65;
        }
LABEL_142:
        *(_QWORD *)aBlock = &v210;
        std::vector<ctu::cf::CFSharedRef<__CFDictionary const>>::__destroy_vector::operator()[abi:ne180100]((void ***)aBlock);
        a2 = v190;
      }
      v78 = v213.i64[1];
      v77 = v213.i64[0];
      if (v213.i64[1] != v213.i64[0])
      {
        if (v213.i64[1] - v213.i64[0] >= 0x21uLL)
        {
          v79 = 32;
          v80 = 1;
          do
          {
            *(_BYTE *)qmi::MutableMessageBase::getTLV<wds::tlv::Append>((_QWORD *)(v77 + v79), 240) = 1;
            ++v80;
            v78 = v213.i64[1];
            v77 = v213.i64[0];
            v79 += 32;
          }
          while (v80 < (v213.i64[1] - v213.i64[0]) >> 5);
        }
        if (v77 != v78)
        {
          v81 = 0;
          do
          {
            *(_OWORD *)buf = 0u;
            v291 = 0u;
            qmi::MutableMessageBase::MutableMessageBase();
            __p[0] = a1 + 12;
            __p[1] = (void *)QMIServiceMsg::create();
            LODWORD(v258) = 25000;
            v259 = 0;
            v260.__r_.__value_.__r.__words[0] = 0;
            v204[0] = MEMORY[0x24BDAC760];
            v204[1] = 1174405120;
            v204[2] = ___ZN25QMIAttachApnCommandDriver28performPushSettingsToBB_syncENSt3__18optionalIN3ctu2cf11CFSharedRefIK14__CFDictionaryEEEERKN22AttachApnCommandDriver19AttachApnPushConfigE_block_invoke;
            v204[3] = &unk_24D5C3538;
            v204[5] = a1;
            group = v7;
            if (v7)
            {
              dispatch_retain(v7);
              if (group)
                dispatch_group_enter(group);
            }
            v204[4] = v215;
            v206 = v81;
            *(_QWORD *)aBlock = MEMORY[0x24BDAC760];
            *(_QWORD *)&aBlock[8] = 0x40000000;
            *(_QWORD *)&v271 = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke;
            *((_QWORD *)&v271 + 1) = &unk_24D5C3DF8;
            *(_QWORD *)&v272 = v204;
            v82 = _Block_copy(aBlock);
            v260.__r_.__value_.__r.__words[0] = (std::string::size_type)v82;
            if (__p[1])
            {
              qmi::Client::send();
              v82 = (void *)v260.__r_.__value_.__r.__words[0];
            }
            if (v82)
              _Block_release(v82);
            if (group)
            {
              dispatch_group_leave(group);
              if (group)
                dispatch_release(group);
            }
            qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)buf);
            v77 += 32;
            ++v81;
          }
          while (v77 != v78);
        }
        goto LABEL_188;
      }
      v287 = 0;
      v286 = 0u;
      v285 = 0u;
      v284 = 0u;
      v283 = 0u;
      v282 = 0u;
      v281 = 0u;
      v280 = 0u;
      v279 = 0u;
      v278 = 0u;
      v277 = 0u;
      v276 = 0u;
      *(_OWORD *)v275 = 0u;
      v274 = 0u;
      v273 = 0u;
      v272 = 0u;
      v271 = 0u;
      *(_OWORD *)aBlock = 0u;
      std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)aBlock);
      v83 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v271, (uint64_t)"Nothing found to push for ", 26);
      __p[1] = 0;
      __p[0] = 0;
      v258 = 0;
      ctu::cf::assign();
      *(_OWORD *)buf = *(_OWORD *)__p;
      *(_QWORD *)&v291 = v258;
      if (SHIBYTE(v258) >= 0)
        v84 = buf;
      else
        v84 = *(uint8_t **)buf;
      if (SHIBYTE(v258) >= 0)
        v85 = BYTE7(v291);
      else
        v85 = *(_QWORD *)&buf[8];
      v86 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v83, (uint64_t)v84, v85);
      v88 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v86, (uint64_t)": ", 2);
      v89 = *(unsigned __int8 *)(a2 + 8);
      if (*(_BYTE *)(a2 + 8))
      {
        ctu::cf_to_xpc(*(ctu **)a2, v87);
        xpc::object::to_string((xpc::object *)&v209);
      }
      else
      {
        std::string::basic_string[abi:ne180100]<0>(__p, "empty");
      }
      if (SHIBYTE(v258) >= 0)
        v90 = __p;
      else
        v90 = (void **)__p[0];
      if (SHIBYTE(v258) >= 0)
        v91 = HIBYTE(v258);
      else
        v91 = (uint64_t)__p[1];
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v88, (uint64_t)v90, v91);
      if (SHIBYTE(v258) < 0)
      {
        operator delete(__p[0]);
        if (!v89)
        {
LABEL_181:
          if (SBYTE7(v291) < 0)
            operator delete(*(void **)buf);
          v92 = a1[11];
          if (v92)
            (*(void (**)(uint64_t, uint8_t *))(*(_QWORD *)v92 + 48))(v92, aBlock);
          *(_QWORD *)aBlock = *MEMORY[0x24BEDB7F0];
          v93 = *(_QWORD *)(MEMORY[0x24BEDB7F0] + 72);
          *(_QWORD *)&aBlock[*(_QWORD *)(*(_QWORD *)aBlock - 24)] = *(_QWORD *)(MEMORY[0x24BEDB7F0] + 64);
          *(_QWORD *)&v271 = v93;
          *((_QWORD *)&v271 + 1) = MEMORY[0x24BEDB848] + 16;
          if (SHIBYTE(v276) < 0)
            operator delete(v275[1]);
          std::streambuf::~streambuf();
          std::iostream::~basic_iostream();
          MEMORY[0x2199FEA70](&v278);
LABEL_188:
          *(_QWORD *)aBlock = &v213;
          std::vector<wds::ModifyProfileSettings3GPP::Request>::__destroy_vector::operator()[abi:ne180100]((void ***)aBlock);
          memset(&v220, 0, sizeof(v220));
          v94 = v190;
          v95 = CFDictionaryGetValue(*(CFDictionaryRef *)v190, (const void *)*MEMORY[0x24BDC3D98]);
          v96 = (__CFString *)MEMORY[0x24BDAC760];
          if (v95)
          {
            v213 = 0uLL;
            v214 = 0;
            v97 = CFArrayGetTypeID();
            if (v97 == CFGetTypeID(v95))
            {
              theArray = 0;
              ctu::cf::CFSharedRef<__CFArray const>::CFSharedRef<void const,void>(&theArray, v95);
              v98 = a1[5];
              if (os_log_type_enabled(v98, OS_LOG_TYPE_DEFAULT))
              {
                memset(aBlock, 0, sizeof(aBlock));
                *(_QWORD *)&v271 = 0;
                ctu::cf::assign();
                *(_OWORD *)__p = *(_OWORD *)aBlock;
                v258 = (void (*)(uint64_t, std::string *))v271;
                v99 = *(void ***)aBlock;
                if ((SBYTE7(v271) & 0x80u) == 0)
                  v99 = __p;
                *(_DWORD *)buf = 136315138;
                *(_QWORD *)&buf[4] = v99;
                _os_log_impl(&dword_216897000, v98, OS_LOG_TYPE_DEFAULT, "#I array of settings: %s", buf, 0xCu);
                if (SHIBYTE(v258) < 0)
                  operator delete(__p[0]);
              }
              v100 = ctu::SharedRef<__CFArray const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFArray const>::get;
              if (!theArray)
                v100 = 0;
              if (v100)
              {
                v101 = CFArrayGetCount(theArray);
                if (v101 >= 1)
                {
                  for (j = 0; j != v101; ++j)
                  {
                    *(_QWORD *)aBlock = 0;
                    v103 = CFArrayGetValueAtIndex(theArray, j);
                    ctu::cf::CFSharedRef<__CFDictionary const>::CFSharedRef<void const,void>(aBlock, v103);
                    v104 = ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::get;
                    if (!*(_QWORD *)aBlock)
                      v104 = 0;
                    if (v104)
                      std::vector<ctu::cf::CFSharedRef<__CFDictionary const>>::push_back[abi:ne180100]((const void ***)&v213, (const void **)aBlock);
                    ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef((const void **)aBlock);
                  }
                }
              }
              ctu::SharedRef<__CFArray const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFArray const>::~SharedRef((const void **)&theArray);
            }
            else
            {
              v105 = CFDictionaryGetTypeID();
              if (v105 == CFGetTypeID(v95))
              {
                theArray = 0;
                ctu::cf::CFSharedRef<__CFDictionary const>::CFSharedRef<void const,void>(&theArray, v95);
                v106 = a1[5];
                if (os_log_type_enabled(v106, OS_LOG_TYPE_DEFAULT))
                {
                  memset(aBlock, 0, sizeof(aBlock));
                  *(_QWORD *)&v271 = 0;
                  ctu::cf::assign();
                  *(_OWORD *)__p = *(_OWORD *)aBlock;
                  v258 = (void (*)(uint64_t, std::string *))v271;
                  v107 = *(void ***)aBlock;
                  if ((SBYTE7(v271) & 0x80u) == 0)
                    v107 = __p;
                  *(_DWORD *)buf = 136315138;
                  *(_QWORD *)&buf[4] = v107;
                  _os_log_impl(&dword_216897000, v106, OS_LOG_TYPE_DEFAULT, "#I dict of settings: %s", buf, 0xCu);
                  if (SHIBYTE(v258) < 0)
                    operator delete(__p[0]);
                }
                v108 = ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::get;
                if (!theArray)
                  v108 = 0;
                if (v108)
                {
                  std::vector<ctu::cf::CFSharedRef<__CFDictionary const>>::push_back[abi:ne180100]((const void ***)&v213, (const void **)&theArray);
                }
                else
                {
                  v287 = 0;
                  v286 = 0u;
                  v285 = 0u;
                  v284 = 0u;
                  v283 = 0u;
                  v282 = 0u;
                  v281 = 0u;
                  v280 = 0u;
                  v279 = 0u;
                  v278 = 0u;
                  v277 = 0u;
                  v276 = 0u;
                  *(_OWORD *)v275 = 0u;
                  v274 = 0u;
                  v273 = 0u;
                  v272 = 0u;
                  v271 = 0u;
                  *(_OWORD *)aBlock = 0u;
                  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)aBlock);
                  v111 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v271, (uint64_t)"Nothing found to push for ", 26);
                  __p[1] = 0;
                  __p[0] = 0;
                  v258 = 0;
                  ctu::cf::assign();
                  *(_OWORD *)buf = *(_OWORD *)__p;
                  *(_QWORD *)&v291 = v258;
                  if (SHIBYTE(v258) >= 0)
                    v112 = buf;
                  else
                    v112 = *(uint8_t **)buf;
                  if (SHIBYTE(v258) >= 0)
                    v113 = BYTE7(v291);
                  else
                    v113 = *(_QWORD *)&buf[8];
                  v114 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v111, (uint64_t)v112, v113);
                  v116 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v114, (uint64_t)": ", 2);
                  v117 = *(unsigned __int8 *)(v190 + 8);
                  if (*(_BYTE *)(v190 + 8))
                  {
                    ctu::cf_to_xpc(*(ctu **)v190, v115);
                    xpc::object::to_string((xpc::object *)&v203);
                  }
                  else
                  {
                    std::string::basic_string[abi:ne180100]<0>(__p, "empty");
                  }
                  if (SHIBYTE(v258) >= 0)
                    v118 = __p;
                  else
                    v118 = (void **)__p[0];
                  if (SHIBYTE(v258) >= 0)
                    v119 = HIBYTE(v258);
                  else
                    v119 = (uint64_t)__p[1];
                  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v116, (uint64_t)v118, v119);
                  if (SHIBYTE(v258) < 0)
                    operator delete(__p[0]);
                  if (v117)
                    xpc_release(v203);
                  if (SBYTE7(v291) < 0)
                    operator delete(*(void **)buf);
                  v120 = a1[11];
                  if (v120)
                    (*(void (**)(uint64_t, uint8_t *))(*(_QWORD *)v120 + 48))(v120, aBlock);
                  *(_QWORD *)aBlock = *MEMORY[0x24BEDB7F0];
                  v121 = *(_QWORD *)(MEMORY[0x24BEDB7F0] + 72);
                  *(_QWORD *)&aBlock[*(_QWORD *)(*(_QWORD *)aBlock - 24)] = *(_QWORD *)(MEMORY[0x24BEDB7F0] + 64);
                  *(_QWORD *)&v271 = v121;
                  *((_QWORD *)&v271 + 1) = MEMORY[0x24BEDB848] + 16;
                  if (SHIBYTE(v276) < 0)
                    operator delete(v275[1]);
                  std::streambuf::~streambuf();
                  std::iostream::~basic_iostream();
                  MEMORY[0x2199FEA70](&v278);
                  v96 = (__CFString *)MEMORY[0x24BDAC760];
                }
                ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef((const void **)&theArray);
              }
              else
              {
                v109 = a1[5];
                if (os_log_type_enabled(v109, OS_LOG_TYPE_DEFAULT))
                {
                  v110 = CFGetTypeID(v95);
                  *(_DWORD *)aBlock = 67109120;
                  *(_DWORD *)&aBlock[4] = v110;
                  _os_log_impl(&dword_216897000, v109, OS_LOG_TYPE_DEFAULT, "#E unknown CF type: %d", aBlock, 8u);
                }
              }
            }
            v123 = (const void **)v213.i64[1];
            v122 = (const void **)v213.i64[0];
            if (v213.i64[0] != v213.i64[1])
            {
              v196 = (char *)*MEMORY[0x24BDC3DA8];
              v124 = *MEMORY[0x24BEDB7F0];
              v193 = *(_QWORD *)(MEMORY[0x24BEDB7F0] + 72);
              v194 = *(_QWORD *)(MEMORY[0x24BEDB7F0] + 64);
              v125 = MEMORY[0x24BEDB848] + 16;
              while (1)
              {
                v202 = 0;
                ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::SharedRef((const void **)&v202, v122);
                v287 = 0;
                v286 = 0u;
                v285 = 0u;
                v284 = 0u;
                v283 = 0u;
                v282 = 0u;
                v281 = 0u;
                v280 = 0u;
                v279 = 0u;
                v278 = 0u;
                v277 = 0u;
                v276 = 0u;
                *(_OWORD *)v275 = 0u;
                v274 = 0u;
                v273 = 0u;
                v272 = 0u;
                v271 = 0u;
                *(_OWORD *)aBlock = 0u;
                std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)aBlock);
                v126 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v271, (uint64_t)"trying to push ", 15);
                __p[1] = 0;
                __p[0] = 0;
                v258 = 0;
                ctu::cf::assign();
                *(_OWORD *)buf = *(_OWORD *)__p;
                *(_QWORD *)&v291 = v258;
                v127 = SHIBYTE(v258) >= 0 ? buf : *(uint8_t **)buf;
                v128 = SHIBYTE(v258) >= 0 ? BYTE7(v291) : *(_QWORD *)&buf[8];
                v129 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v126, (uint64_t)v127, v128);
                v131 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v129, (uint64_t)" attach APN ", 12);
                v132 = v202
                     ? ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::get
                     : 0;
                if (v132)
                {
                  ctu::cf_to_xpc(v202, v130);
                  xpc::object::to_string((xpc::object *)&v201);
                }
                else
                {
                  std::string::basic_string[abi:ne180100]<0>(__p, "empty");
                }
                v133 = SHIBYTE(v258) >= 0 ? __p : (void **)__p[0];
                v134 = SHIBYTE(v258) >= 0 ? (void *)HIBYTE(v258) : __p[1];
                std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v131, (uint64_t)v133, (uint64_t)v134);
                if (SHIBYTE(v258) < 0)
                  break;
                if (v132)
                  goto LABEL_269;
LABEL_270:
                if (SBYTE7(v291) < 0)
                  operator delete(*(void **)buf);
                v135 = a1[11];
                if (v135)
                  (*(void (**)(uint64_t, uint8_t *))(*(_QWORD *)v135 + 48))(v135, aBlock);
                v210 = 0;
                v211 = 0;
                ctu::cf::dict_adapter::dict_adapter((ctu::cf::dict_adapter *)&v210, v202);
                v217 = 0u;
                v218 = 0u;
                qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)&v217);
                v136 = qmi::MutableMessageBase::getTLV<wds::tlv::ProfileId>(&v217, 1);
                *(_DWORD *)v136 = 1;
                *(_BYTE *)(v136 + 4) = -1;
                v221[0] = 0;
                v221[1] = 0;
                *(_QWORD *)&v222 = 0;
                v262 = 0uLL;
                v261 = 0;
                ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)&v251, "username");
                ctu::cf::map_adapter::getString();
                MEMORY[0x2199FDFFC](&v251);
                if (v262.i8[15] < 0)
                  operator delete(v261);
                if (SBYTE7(v222) < 0)
                {
                  if (!v221[1])
                    goto LABEL_283;
                  __p[0] = v96;
                  __p[1] = (void *)1174405120;
                  v258 = ___ZL28sCreateSettingsMessage_3GPP2RKN3ctu2cf12dict_adapterERNSt3__16vectorIN3wds26ModifyProfileSettings3GPP27RequestENS4_9allocatorIS8_EEEE_block_invoke_2;
                  v259 = &__block_descriptor_tmp_58;
                  std::string::__init_copy_ctor_external(&v260, (const std::string::value_type *)v221[0], v221[1]);
                }
                else
                {
                  if (!BYTE7(v222))
                    goto LABEL_283;
                  __p[0] = v96;
                  __p[1] = (void *)1174405120;
                  v258 = ___ZL28sCreateSettingsMessage_3GPP2RKN3ctu2cf12dict_adapterERNSt3__16vectorIN3wds26ModifyProfileSettings3GPP27RequestENS4_9allocatorIS8_EEEE_block_invoke_2;
                  v259 = &__block_descriptor_tmp_58;
                  *(_OWORD *)&v260.__r_.__value_.__l.__data_ = *(_OWORD *)v221;
                  v260.__r_.__value_.__r.__words[2] = v222;
                }
                v137 = (std::string *)qmi::MutableMessageBase::getTLV<wds::tlv::UserName>(&v217, 155);
                v258((uint64_t)__p, v137);
                if (SHIBYTE(v260.__r_.__value_.__r.__words[2]) < 0)
                  operator delete(v260.__r_.__value_.__l.__data_);
LABEL_283:
                memset(&__s, 0, sizeof(__s));
                v262 = 0uLL;
                v261 = 0;
                ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)&v251, "password");
                ctu::cf::map_adapter::getString();
                MEMORY[0x2199FDFFC](&v251);
                if (v262.i8[15] < 0)
                  operator delete(v261);
                if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0)
                {
                  if (!__s.__r_.__value_.__l.__size_)
                    goto LABEL_292;
                  *(_QWORD *)buf = v96;
                  *(_QWORD *)&buf[8] = 1174405120;
                  *(_QWORD *)&v291 = ___ZL28sCreateSettingsMessage_3GPP2RKN3ctu2cf12dict_adapterERNSt3__16vectorIN3wds26ModifyProfileSettings3GPP27RequestENS4_9allocatorIS8_EEEE_block_invoke_59;
                  *((_QWORD *)&v291 + 1) = &__block_descriptor_tmp_60;
                  std::string::__init_copy_ctor_external(&v292, __s.__r_.__value_.__l.__data_, __s.__r_.__value_.__l.__size_);
                }
                else
                {
                  if (!*((_BYTE *)&__s.__r_.__value_.__s + 23))
                    goto LABEL_292;
                  *(_QWORD *)buf = v96;
                  *(_QWORD *)&buf[8] = 1174405120;
                  *(_QWORD *)&v291 = ___ZL28sCreateSettingsMessage_3GPP2RKN3ctu2cf12dict_adapterERNSt3__16vectorIN3wds26ModifyProfileSettings3GPP27RequestENS4_9allocatorIS8_EEEE_block_invoke_59;
                  *((_QWORD *)&v291 + 1) = &__block_descriptor_tmp_60;
                  v292 = __s;
                }
                v138 = qmi::MutableMessageBase::getTLV<wds::tlv::Password>(&v217, 156);
                ((void (*)(uint8_t *, uint64_t))v291)(buf, v138);
                if (SHIBYTE(v292.__r_.__value_.__r.__words[2]) < 0)
                  operator delete(v292.__r_.__value_.__l.__data_);
LABEL_292:
                v261 = v96;
                v262.i64[0] = 0x40000000;
                v262.i64[1] = (uint64_t)___ZL28sCreateSettingsMessage_3GPP2RKN3ctu2cf12dict_adapterERNSt3__16vectorIN3wds26ModifyProfileSettings3GPP27RequestENS4_9allocatorIS8_EEEE_block_invoke_61;
                v263 = (__CFString *)&__block_descriptor_tmp_62;
                v264 = &v210;
                v139 = (std::string *)qmi::MutableMessageBase::getTLV<wds::tlv::ApnName>(&v217, 161);
                ((void (*)(uint64_t, std::string *))v262.i64[1])((uint64_t)&v261, v139);
                v251 = v96;
                v252 = 0x40000000;
                v253 = (void (*)(uint64_t, std::string *))___ZL28sCreateSettingsMessage_3GPP2RKN3ctu2cf12dict_adapterERNSt3__16vectorIN3wds26ModifyProfileSettings3GPP27RequestENS4_9allocatorIS8_EEEE_block_invoke_2_63;
                v254 = &__block_descriptor_tmp_65;
                v255 = &v210;
                v140 = (int *)qmi::MutableMessageBase::getTLV<wds::tlv::PdpType3GPP2>(&v217, 162);
                v253((uint64_t)&v251, (std::string *)v140);
                memset(&v250, 0, sizeof(v250));
                v241 = 0;
                v240 = 0;
                v242 = 0;
                ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)&v235, "auth_type");
                ctu::cf::map_adapter::getString();
                MEMORY[0x2199FDFFC](&v235);
                if (SHIBYTE(v242) < 0)
                  operator delete(v240);
                if (SHIBYTE(v250.__r_.__value_.__r.__words[2]) < 0)
                {
                  if (v250.__r_.__value_.__l.__size_)
                  {
                    theArray = (CFArrayRef)v96;
                    v246 = 1174405120;
                    v247 = (void (*)(uint64_t, char *))___ZL28sCreateSettingsMessage_3GPP2RKN3ctu2cf12dict_adapterERNSt3__16vectorIN3wds26ModifyProfileSettings3GPP27RequestENS4_9allocatorIS8_EEEE_block_invoke_3;
                    v248 = &__block_descriptor_tmp_66;
                    std::string::__init_copy_ctor_external(&v249, v250.__r_.__value_.__l.__data_, v250.__r_.__value_.__l.__size_);
LABEL_299:
                    v141 = (char *)qmi::MutableMessageBase::getTLV<wds::tlv::AuthPref>(&v217, 154);
                    v247((uint64_t)&theArray, v141);
                    if (SHIBYTE(v249.__r_.__value_.__r.__words[2]) < 0)
                      operator delete(v249.__r_.__value_.__l.__data_);
                  }
                }
                else if (*((_BYTE *)&v250.__r_.__value_.__s + 23))
                {
                  theArray = (CFArrayRef)v96;
                  v246 = 1174405120;
                  v247 = (void (*)(uint64_t, char *))___ZL28sCreateSettingsMessage_3GPP2RKN3ctu2cf12dict_adapterERNSt3__16vectorIN3wds26ModifyProfileSettings3GPP27RequestENS4_9allocatorIS8_EEEE_block_invoke_3;
                  v248 = &__block_descriptor_tmp_66;
                  v249 = v250;
                  goto LABEL_299;
                }
                v240 = v96;
                v241 = 0x40000000;
                v242 = (void (*)(uint64_t, int *))___ZL28sCreateSettingsMessage_3GPP2RKN3ctu2cf12dict_adapterERNSt3__16vectorIN3wds26ModifyProfileSettings3GPP27RequestENS4_9allocatorIS8_EEEE_block_invoke_67;
                v243 = &__block_descriptor_tmp_70;
                v244 = &v210;
                v142 = (int *)qmi::MutableMessageBase::getTLV<wds::tlv::ProxyAddrNeeded>(&v217, 163);
                v242((uint64_t)&v240, v142);
                v235 = v96;
                v236 = 0x40000000;
                v237 = (void (*)(uint64_t, _BYTE *))___ZL28sCreateSettingsMessage_3GPP2RKN3ctu2cf12dict_adapterERNSt3__16vectorIN3wds26ModifyProfileSettings3GPP27RequestENS4_9allocatorIS8_EEEE_block_invoke_2_71;
                v238 = &__block_descriptor_tmp_75;
                v239 = &v210;
                v143 = (int *)qmi::MutableMessageBase::getTLV<wds::tlv::RatType>(&v217, 168);
                v237((uint64_t)&v235, v143);
                ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)&v230, "InactivityTimeout");
                v144 = ctu::cf::map_adapter::getInt((ctu::cf::map_adapter *)&v210, v230);
                MEMORY[0x2199FDFFC](&v230);
                if (v144 >= 1)
                {
                  v230 = v96;
                  v231 = 0x40000000;
                  v232 = (void (*)(uint64_t, _DWORD *))___ZL28sCreateSettingsMessage_3GPP2RKN3ctu2cf12dict_adapterERNSt3__16vectorIN3wds26ModifyProfileSettings3GPP27RequestENS4_9allocatorIS8_EEEE_block_invoke_3_77;
                  v233 = &__block_descriptor_tmp_79;
                  v234 = v144;
                  v145 = (_DWORD *)qmi::MutableMessageBase::getTLV<wds::tlv::InactivityTimer>(&v217, 170);
                  v232((uint64_t)&v230, v145);
                }
                v229 = -1;
                ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)&v224, "APNClass");
                v146 = (int *)((uint64_t (*)(const void ***, __CFString *))*v210)(&v210, v224);
                v147 = v146;
                if (v146)
                {
                  v148 = CFGetTypeID(v146);
                  if (v148 == CFNumberGetTypeID())
                    v150 = ctu::cf::assign((ctu::cf *)&v229, v147, v149);
                  else
                    v150 = 0;
                  CFRelease(v147);
                }
                else
                {
                  v150 = 0;
                }
                MEMORY[0x2199FDFFC](&v224);
                if (v150 && (v229 & 0x80000000) == 0)
                {
                  v224 = v96;
                  v225 = 0x40000000;
                  v226 = (void (*)(uint64_t, _DWORD *))___ZL28sCreateSettingsMessage_3GPP2RKN3ctu2cf12dict_adapterERNSt3__16vectorIN3wds26ModifyProfileSettings3GPP27RequestENS4_9allocatorIS8_EEEE_block_invoke_4;
                  v227 = &__block_descriptor_tmp_80;
                  v228 = v229;
                  v151 = (_BYTE *)qmi::MutableMessageBase::getTLV<wds::tlv::APNClass>(&v217, 49);
                  v226((uint64_t)&v224, v151);
                }
                v223 = 1;
                ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)v207, v196);
                v152 = (BOOL *)((uint64_t (*)(const void ***, _QWORD))*v210)(&v210, v207[0]);
                v153 = v152;
                if (v152)
                {
                  v154 = CFGetTypeID(v152);
                  if (v154 == CFBooleanGetTypeID())
                    v156 = ctu::cf::assign((ctu::cf *)&v223, v153, v155);
                  else
                    v156 = 0;
                  CFRelease(v153);
                  MEMORY[0x2199FDFFC](v207);
                  if (v156)
                  {
                    v157 = v223;
                    *(_BYTE *)qmi::MutableMessageBase::getTLV<wds::tlv::RoamingDisallow>(&v217, 62) = v157 ^ 1;
                  }
                }
                else
                {
                  MEMORY[0x2199FDFFC](v207);
                }
                std::vector<wds::ModifyProfileSettings3GPP2::Request>::push_back[abi:ne180100]((uint64_t *)&v220);
                if (SHIBYTE(v250.__r_.__value_.__r.__words[2]) < 0)
                  operator delete(v250.__r_.__value_.__l.__data_);
                if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0)
                  operator delete(__s.__r_.__value_.__l.__data_);
                if (SBYTE7(v222) < 0)
                  operator delete((void *)v221[0]);
                qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&v217);
                MEMORY[0x2199FE02C](&v210);
                *(_QWORD *)aBlock = v124;
                *(_QWORD *)&aBlock[*(_QWORD *)(v124 - 24)] = v194;
                *(_QWORD *)&v271 = v193;
                *((_QWORD *)&v271 + 1) = v125;
                if (SHIBYTE(v276) < 0)
                  operator delete(v275[1]);
                std::streambuf::~streambuf();
                std::iostream::~basic_iostream();
                MEMORY[0x2199FEA70](&v278);
                ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef((const void **)&v202);
                if (++v122 == v123)
                  goto LABEL_328;
              }
              operator delete(__p[0]);
              if (!v132)
                goto LABEL_270;
LABEL_269:
              xpc_release(v201);
              goto LABEL_270;
            }
LABEL_328:
            *(_QWORD *)aBlock = &v213;
            std::vector<ctu::cf::CFSharedRef<__CFDictionary const>>::__destroy_vector::operator()[abi:ne180100]((void ***)aBlock);
            v94 = v190;
          }
          size = v220.__r_.__value_.__l.__size_;
          v158 = v220.__r_.__value_.__r.__words[0];
          if (v220.__r_.__value_.__l.__size_ != v220.__r_.__value_.__r.__words[0])
          {
            if (v220.__r_.__value_.__l.__size_ - v220.__r_.__value_.__r.__words[0] >= 0x21)
            {
              v160 = 32;
              v161 = 1;
              do
              {
                *(_BYTE *)qmi::MutableMessageBase::getTLV<wds::tlv::Append>((_QWORD *)(v158 + v160), 240) = 1;
                ++v161;
                size = v220.__r_.__value_.__l.__size_;
                v158 = v220.__r_.__value_.__r.__words[0];
                v160 += 32;
              }
              while (v161 < (uint64_t)(v220.__r_.__value_.__l.__size_ - v220.__r_.__value_.__r.__words[0]) >> 5);
            }
            if (v158 != size)
            {
              v162 = 0;
              do
              {
                *(_OWORD *)buf = 0u;
                v291 = 0u;
                qmi::MutableMessageBase::MutableMessageBase();
                __p[0] = a1 + 12;
                __p[1] = (void *)QMIServiceMsg::create();
                LODWORD(v258) = 25000;
                v259 = 0;
                v260.__r_.__value_.__r.__words[0] = 0;
                v198[0] = MEMORY[0x24BDAC760];
                v198[1] = 1174405120;
                v198[2] = ___ZN25QMIAttachApnCommandDriver28performPushSettingsToBB_syncENSt3__18optionalIN3ctu2cf11CFSharedRefIK14__CFDictionaryEEEERKN22AttachApnCommandDriver19AttachApnPushConfigE_block_invoke_7;
                v198[3] = &unk_24D5C3570;
                v198[5] = a1;
                v199 = v7;
                if (v7)
                {
                  dispatch_retain(v7);
                  if (v199)
                    dispatch_group_enter(v199);
                }
                v198[4] = v215;
                v200 = v162;
                *(_QWORD *)aBlock = MEMORY[0x24BDAC760];
                *(_QWORD *)&aBlock[8] = 0x40000000;
                *(_QWORD *)&v271 = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke;
                *((_QWORD *)&v271 + 1) = &unk_24D5C3DF8;
                *(_QWORD *)&v272 = v198;
                v163 = _Block_copy(aBlock);
                v260.__r_.__value_.__r.__words[0] = (std::string::size_type)v163;
                if (__p[1])
                {
                  qmi::Client::send();
                  v163 = (void *)v260.__r_.__value_.__r.__words[0];
                }
                if (v163)
                  _Block_release(v163);
                if (v199)
                {
                  dispatch_group_leave(v199);
                  if (v199)
                    dispatch_release(v199);
                }
                qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)buf);
                v158 += 32;
                ++v162;
              }
              while (v158 != size);
            }
LABEL_374:
            *(_QWORD *)aBlock = &v220;
            std::vector<wds::ModifyProfileSettings3GPP::Request>::__destroy_vector::operator()[abi:ne180100]((void ***)aBlock);
            v5 = v189;
            v8 = &loc_216A9C000;
            goto LABEL_375;
          }
          v287 = 0;
          v286 = 0u;
          v285 = 0u;
          v284 = 0u;
          v283 = 0u;
          v282 = 0u;
          v281 = 0u;
          v280 = 0u;
          v279 = 0u;
          v278 = 0u;
          v277 = 0u;
          v276 = 0u;
          *(_OWORD *)v275 = 0u;
          v274 = 0u;
          v273 = 0u;
          v272 = 0u;
          v271 = 0u;
          *(_OWORD *)aBlock = 0u;
          std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)aBlock);
          v164 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v271, (uint64_t)"Nothing found to push for ", 26);
          __p[1] = 0;
          __p[0] = 0;
          v258 = 0;
          ctu::cf::assign();
          *(_OWORD *)buf = *(_OWORD *)__p;
          *(_QWORD *)&v291 = v258;
          if (SHIBYTE(v258) >= 0)
            v165 = buf;
          else
            v165 = *(uint8_t **)buf;
          if (SHIBYTE(v258) >= 0)
            v166 = BYTE7(v291);
          else
            v166 = *(_QWORD *)&buf[8];
          v167 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v164, (uint64_t)v165, v166);
          v169 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v167, (uint64_t)": ", 2);
          v170 = *(unsigned __int8 *)(v94 + 8);
          if (*(_BYTE *)(v94 + 8))
          {
            ctu::cf_to_xpc(*(ctu **)v94, v168);
            xpc::object::to_string((xpc::object *)&theArray);
          }
          else
          {
            std::string::basic_string[abi:ne180100]<0>(__p, "empty");
          }
          if (SHIBYTE(v258) >= 0)
            v171 = __p;
          else
            v171 = (void **)__p[0];
          if (SHIBYTE(v258) >= 0)
            v172 = HIBYTE(v258);
          else
            v172 = (uint64_t)__p[1];
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v169, (uint64_t)v171, v172);
          if (SHIBYTE(v258) < 0)
          {
            operator delete(__p[0]);
            if (!v170)
            {
LABEL_367:
              if (SBYTE7(v291) < 0)
                operator delete(*(void **)buf);
              v173 = a1[11];
              if (v173)
                (*(void (**)(uint64_t, uint8_t *))(*(_QWORD *)v173 + 48))(v173, aBlock);
              *(_QWORD *)aBlock = *MEMORY[0x24BEDB7F0];
              v174 = *(_QWORD *)(MEMORY[0x24BEDB7F0] + 72);
              *(_QWORD *)&aBlock[*(_QWORD *)(*(_QWORD *)aBlock - 24)] = *(_QWORD *)(MEMORY[0x24BEDB7F0] + 64);
              *(_QWORD *)&v271 = v174;
              *((_QWORD *)&v271 + 1) = MEMORY[0x24BEDB848] + 16;
              if (SHIBYTE(v276) < 0)
                operator delete(v275[1]);
              std::streambuf::~streambuf();
              std::iostream::~basic_iostream();
              MEMORY[0x2199FEA70](&v278);
              goto LABEL_374;
            }
          }
          else if (!v170)
          {
            goto LABEL_367;
          }
          xpc_release(theArray);
          goto LABEL_367;
        }
      }
      else if (!v89)
      {
        goto LABEL_181;
      }
      xpc_release(v209);
      goto LABEL_181;
    }
  }
  v21 = a1[5];
  if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)aBlock = 0;
    _os_log_impl(&dword_216897000, v21, OS_LOG_TYPE_DEFAULT, "#I dummy push complete", aBlock, 2u);
  }
LABEL_375:
  std::shared_ptr<AttachApnCommandDriver>::shared_ptr[abi:ne180100]<AttachApnCommandDriver,void>(aBlock, a1 + 1);
  v175 = *(_QWORD *)aBlock;
  v176 = *(std::__shared_weak_count **)&aBlock[8];
  if (*(_QWORD *)&aBlock[8])
  {
    v177 = (unint64_t *)(*(_QWORD *)&aBlock[8] + 16);
    do
      v178 = __ldxr(v177);
    while (__stxr(v178 + 1, v177));
    p_shared_owners = (unint64_t *)&v176->__shared_owners_;
    do
      v180 = __ldaxr(p_shared_owners);
    while (__stlxr(v180 - 1, p_shared_owners));
    if (!v180)
    {
      ((void (*)(std::__shared_weak_count *))v176->__on_zero_shared)(v176);
      std::__shared_weak_count::__release_weak(v176);
    }
  }
  v181 = a1[3];
  block[0] = MEMORY[0x24BDAC760];
  block[1] = v8[115];
  block[2] = ___ZN25QMIAttachApnCommandDriver28performPushSettingsToBB_syncENSt3__18optionalIN3ctu2cf11CFSharedRefIK14__CFDictionaryEEEERKN22AttachApnCommandDriver19AttachApnPushConfigE_block_invoke_9;
  block[3] = &unk_24D5C35A8;
  block[5] = a1;
  block[6] = v175;
  v266 = v176;
  if (v176)
  {
    p_shared_weak_owners = (unint64_t *)&v176->__shared_weak_owners_;
    do
      v183 = __ldxr(p_shared_weak_owners);
    while (__stxr(v183 + 1, p_shared_weak_owners));
  }
  block[4] = v215;
  v269 = v5;
  v184 = v267;
  v185 = *((_QWORD *)&v289 + 1);
  if (!*((_QWORD *)&v289 + 1))
    goto LABEL_388;
  if (*((__int128 **)&v289 + 1) != &v288)
  {
    v185 = (*(uint64_t (**)(void))(**((_QWORD **)&v289 + 1) + 16))();
LABEL_388:
    v268 = (_BYTE *)v185;
    goto LABEL_390;
  }
  v268 = v267;
  (*(void (**)(__int128 *, _BYTE *))(v288 + 24))(&v288, v267);
LABEL_390:
  dispatch_group_notify(v7, v181, block);
  if (v268 == v267)
  {
    v186 = 4;
  }
  else
  {
    if (!v268)
      goto LABEL_395;
    v186 = 5;
    v184 = v268;
  }
  (*(void (**)(_QWORD *))(*v184 + 8 * v186))(v184);
LABEL_395:
  if (v266)
    std::__shared_weak_count::__release_weak(v266);
  if (v176)
    std::__shared_weak_count::__release_weak(v176);
  if (v7)
  {
    dispatch_group_leave(v7);
    dispatch_release(v7);
  }
  _Block_object_dispose(v215, 8);
  result = (__int128 *)*((_QWORD *)&v289 + 1);
  if (*((__int128 **)&v289 + 1) == &v288)
  {
    v188 = 4;
    result = &v288;
  }
  else
  {
    if (!*((_QWORD *)&v289 + 1))
      return result;
    v188 = 5;
  }
  return (__int128 *)(*(uint64_t (**)(void))(*(_QWORD *)result + 8 * v188))();
}

void sub_2168D5B70(_Unwind_Exception *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  _Unwind_Resume(a1);
}

uint64_t ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::get(uint64_t a1)
{
  return *(_QWORD *)a1;
}

uint64_t ctu::SharedRef<__CFArray const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFArray const>::get(uint64_t a1)
{
  return *(_QWORD *)a1;
}

void std::vector<ctu::cf::CFSharedRef<__CFDictionary const>>::push_back[abi:ne180100](const void ***a1, const void **a2)
{
  const void **v4;
  unint64_t v5;
  const void **v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  const void **v11;
  const void **v12;
  const void **v13;
  const void **v14;
  const void **v15;
  const void *v16;
  const void **v17;

  v4 = a1[1];
  v5 = (unint64_t)a1[2];
  if ((unint64_t)v4 >= v5)
  {
    v7 = v4 - *a1;
    if ((unint64_t)(v7 + 1) >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v8 = v5 - (_QWORD)*a1;
    v9 = v8 >> 2;
    if (v8 >> 2 <= (unint64_t)(v7 + 1))
      v9 = v7 + 1;
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8)
      v10 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v10 = v9;
    if (v10)
    {
      if (v10 >> 61)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v11 = (const void **)operator new(8 * v10);
    }
    else
    {
      v11 = 0;
    }
    v12 = &v11[v10];
    v13 = ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::SharedRef(&v11[v7], a2);
    v6 = v13 + 1;
    v14 = *a1;
    v15 = a1[1];
    if (v15 == *a1)
    {
      *a1 = v13;
      a1[1] = v6;
      a1[2] = v12;
    }
    else
    {
      do
      {
        *--v13 = 0;
        v16 = *--v15;
        *v13 = v16;
        *v15 = 0;
      }
      while (v15 != v14);
      v15 = *a1;
      v17 = a1[1];
      *a1 = v13;
      a1[1] = v6;
      a1[2] = v12;
      while (v17 != v15)
        ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef(--v17);
    }
    if (v15)
      operator delete(v15);
  }
  else
  {
    v6 = ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::SharedRef(v4, a2)+ 1;
  }
  a1[1] = v6;
}

uint64_t std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100](uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  std::ios_base *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v2 = MEMORY[0x24BEDB858];
  v3 = MEMORY[0x24BEDB858] + 104;
  *(_QWORD *)(a1 + 128) = MEMORY[0x24BEDB858] + 104;
  *(_QWORD *)(a1 + 16) = v2 + 64;
  v4 = a1 + 16;
  v5 = (_QWORD *)MEMORY[0x24BEDB7F0];
  v6 = *(_QWORD *)(MEMORY[0x24BEDB7F0] + 16);
  v7 = *(_QWORD *)(MEMORY[0x24BEDB7F0] + 24);
  *(_QWORD *)a1 = v6;
  *(_QWORD *)(a1 + *(_QWORD *)(v6 - 24)) = v7;
  *(_QWORD *)(a1 + 8) = 0;
  v8 = (std::ios_base *)(a1 + *(_QWORD *)(*(_QWORD *)a1 - 24));
  std::ios_base::init(v8, (void *)(a1 + 24));
  v8[1].__vftable = 0;
  v8[1].__fmtflags_ = -1;
  v9 = v5[4];
  v10 = v5[5];
  *(_QWORD *)(a1 + 16) = v9;
  *(_QWORD *)(v4 + *(_QWORD *)(v9 - 24)) = v10;
  v11 = v5[1];
  *(_QWORD *)a1 = v11;
  *(_QWORD *)(a1 + *(_QWORD *)(v11 - 24)) = v5[6];
  *(_QWORD *)a1 = v2 + 24;
  *(_QWORD *)(a1 + 128) = v3;
  *(_QWORD *)(a1 + 16) = v2 + 64;
  std::streambuf::basic_streambuf();
  *(_QWORD *)(a1 + 24) = MEMORY[0x24BEDB848] + 16;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_DWORD *)(a1 + 120) = 24;
  return a1;
}

void sub_2168D65B4(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::iostream::~basic_iostream();
  MEMORY[0x2199FEA70](v1);
  _Unwind_Resume(a1);
}

uint64_t std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = MEMORY[0x24BEDB7F0];
  v3 = *MEMORY[0x24BEDB7F0];
  *(_QWORD *)a1 = *MEMORY[0x24BEDB7F0];
  v4 = *(_QWORD *)(v2 + 72);
  *(_QWORD *)(a1 + *(_QWORD *)(v3 - 24)) = *(_QWORD *)(v2 + 64);
  *(_QWORD *)(a1 + 24) = MEMORY[0x24BEDB848] + 16;
  *(_QWORD *)(a1 + 16) = v4;
  if (*(char *)(a1 + 111) < 0)
    operator delete(*(void **)(a1 + 88));
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199FEA70](a1 + 128);
  return a1;
}

void ___ZN25QMIAttachApnCommandDriver28performPushSettingsToBB_syncENSt3__18optionalIN3ctu2cf11CFSharedRefIK14__CFDictionaryEEEERKN22AttachApnCommandDriver19AttachApnPushConfigE_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  int v4;
  NSObject *v5;
  uint64_t v6;
  NSObject *v7;
  int v8;
  int v9;
  int v10;
  __int16 v11;
  uint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 + 40);
  v4 = *(_DWORD *)(a2 + 4);
  if (v4)
  {
    v5 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 67109378;
      v10 = v4;
      v11 = 2080;
      v12 = qmi::asString();
      _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#E Sending 3GPP settings failed with error %d (%s)", (uint8_t *)&v9, 0x12u);
    }
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
  }
  else
  {
    v6 = *(_QWORD *)(v3 + 88);
    if (v6)
      (*(void (**)(uint64_t))(*(_QWORD *)v6 + 16))(v6);
    v7 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      v8 = *(_DWORD *)(a1 + 56);
      v9 = 67109120;
      v10 = v8;
      _os_log_impl(&dword_216897000, v7, OS_LOG_TYPE_DEFAULT, "#I 3GPP settings success response received (request order %d)", (uint8_t *)&v9, 8u);
    }
  }
}

void __copy_helper_block_e8_48c30_ZTSN8dispatch13group_sessionE(uint64_t a1, uint64_t a2)
{
  NSObject *v3;
  NSObject *v4;

  v3 = *(NSObject **)(a2 + 48);
  *(_QWORD *)(a1 + 48) = v3;
  if (v3)
  {
    dispatch_retain(v3);
    v4 = *(NSObject **)(a1 + 48);
    if (v4)
      dispatch_group_enter(v4);
  }
}

void __destroy_helper_block_e8_48c30_ZTSN8dispatch13group_sessionE(uint64_t a1)
{
  NSObject *v2;
  NSObject *v3;

  v2 = *(NSObject **)(a1 + 48);
  if (v2)
  {
    dispatch_group_leave(v2);
    v3 = *(NSObject **)(a1 + 48);
    if (v3)
      dispatch_release(v3);
  }
}

void ___ZN25QMIAttachApnCommandDriver28performPushSettingsToBB_syncENSt3__18optionalIN3ctu2cf11CFSharedRefIK14__CFDictionaryEEEERKN22AttachApnCommandDriver19AttachApnPushConfigE_block_invoke_7(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  int v4;
  NSObject *v5;
  uint64_t v6;
  NSObject *v7;
  int v8;
  int v9;
  int v10;
  __int16 v11;
  uint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 + 40);
  v4 = *(_DWORD *)(a2 + 4);
  if (v4)
  {
    v5 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 67109378;
      v10 = v4;
      v11 = 2080;
      v12 = qmi::asString();
      _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#E Sending 3GPP2 settings failed with error %d (%s)", (uint8_t *)&v9, 0x12u);
    }
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
  }
  else
  {
    v6 = *(_QWORD *)(v3 + 88);
    if (v6)
      (*(void (**)(uint64_t))(*(_QWORD *)v6 + 16))(v6);
    v7 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      v8 = *(_DWORD *)(a1 + 56);
      v9 = 67109120;
      v10 = v8;
      _os_log_impl(&dword_216897000, v7, OS_LOG_TYPE_DEFAULT, "#I 3GPP2 settings success response received (request order %d)", (uint8_t *)&v9, 8u);
    }
  }
}

void ___ZN25QMIAttachApnCommandDriver28performPushSettingsToBB_syncENSt3__18optionalIN3ctu2cf11CFSharedRefIK14__CFDictionaryEEEERKN22AttachApnCommandDriver19AttachApnPushConfigE_block_invoke_9(uint64_t a1)
{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  uint64_t v6;
  int v7;
  int v8;
  _QWORD *v9;
  uint64_t v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  _BYTE v13[24];
  _BYTE *v14;
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v2 = *(std::__shared_weak_count **)(a1 + 56);
  if (v2)
  {
    v3 = *(_QWORD *)(a1 + 40);
    v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      v5 = v4;
      if (!*(_QWORD *)(a1 + 48))
        goto LABEL_10;
      v6 = *(_QWORD *)(v3 + 88);
      if (!v6)
        goto LABEL_10;
      v7 = *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
      v8 = *(unsigned __int8 *)(a1 + 96);
      std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100]((uint64_t)v13, a1 + 64);
      (*(void (**)(uint64_t, BOOL, BOOL, uint64_t, _BYTE *))(*(_QWORD *)v6 + 24))(v6, v7 != 0, v8 != 0, 1, v13);
      v9 = v14;
      if (v14 == v13)
      {
        v10 = 4;
        v9 = v13;
      }
      else
      {
        if (!v14)
          goto LABEL_10;
        v10 = 5;
      }
      (*(void (**)(void))(*v9 + 8 * v10))();
LABEL_10:
      p_shared_owners = (unint64_t *)&v5->__shared_owners_;
      do
        v12 = __ldaxr(p_shared_owners);
      while (__stlxr(v12 - 1, p_shared_owners));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
    }
  }
}

void sub_2168D6A7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, char *a15)
{
  char *v15;
  char *v17;
  uint64_t v18;

  v17 = a15;
  if (a15 == v15)
  {
    v18 = 4;
    v17 = &a12;
  }
  else
  {
    if (!a15)
      goto LABEL_6;
    v18 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v17 + 8 * v18))();
LABEL_6:
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a10);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_48c47_ZTSNSt3__18weak_ptrI22AttachApnCommandDriverEE64c28_ZTSKNSt3__18functionIFvvEEE(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a1 + 56) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 16);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100](a1 + 64, a2 + 64);
}

void sub_2168D6B0C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  std::__shared_weak_count *v3;

  v3 = *(std::__shared_weak_count **)(v1 + 56);
  if (v3)
    std::__shared_weak_count::__release_weak(v3);
  _Unwind_Resume(exception_object);
}

void __destroy_helper_block_e8_48c47_ZTSNSt3__18weak_ptrI22AttachApnCommandDriverEE64c28_ZTSKNSt3__18functionIFvvEEE(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  std::__shared_weak_count *v5;

  v2 = (_QWORD *)(a1 + 64);
  v3 = *(_QWORD **)(a1 + 88);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
  v5 = *(std::__shared_weak_count **)(a1 + 56);
  if (v5)
    std::__shared_weak_count::__release_weak(v5);
}

const void **ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

const void **ctu::SharedRef<__CFArray const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFArray const>::~SharedRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

const void **ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::SharedRef(const void **a1, const void **a2)
{
  const void *v3;

  v3 = *a2;
  *a1 = *a2;
  if (v3)
    CFRetain(v3);
  return a1;
}

void ___ZL27sCreateSettingsMessage_3GPPRKN3ctu2cf12dict_adapterERNSt3__16vectorIN3wds25ModifyProfileSettings3GPP7RequestENS4_9allocatorIS8_EEEE_block_invoke_2(uint64_t a1, std::string *this)
{
  std::string::value_type *v3;
  std::string::size_type v4;

  if (*(char *)(a1 + 55) < 0)
  {
    v3 = *(std::string::value_type **)(a1 + 32);
    v4 = *(_QWORD *)(a1 + 40);
  }
  else
  {
    v3 = (std::string::value_type *)(a1 + 32);
    v4 = *(unsigned __int8 *)(a1 + 55);
  }
  std::string::__assign_trivial[abi:ne180100]<unsigned char const*,unsigned char const*>(this, v3, &v3[v4], v4);
}

void __copy_helper_block_e8_32c66_ZTSNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE(uint64_t a1, uint64_t a2)
{
  std::string *v2;
  __int128 v3;

  v2 = (std::string *)(a1 + 32);
  if (*(char *)(a2 + 55) < 0)
  {
    std::string::__init_copy_ctor_external(v2, *(const std::string::value_type **)(a2 + 32), *(_QWORD *)(a2 + 40));
  }
  else
  {
    v3 = *(_OWORD *)(a2 + 32);
    v2->__r_.__value_.__r.__words[2] = *(_QWORD *)(a2 + 48);
    *(_OWORD *)&v2->__r_.__value_.__l.__data_ = v3;
  }
}

void __destroy_helper_block_e8_32c66_ZTSNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE(uint64_t a1)
{
  if (*(char *)(a1 + 55) < 0)
    operator delete(*(void **)(a1 + 32));
}

void ___ZL27sCreateSettingsMessage_3GPPRKN3ctu2cf12dict_adapterERNSt3__16vectorIN3wds25ModifyProfileSettings3GPP7RequestENS4_9allocatorIS8_EEEE_block_invoke_20(uint64_t a1, std::string *this)
{
  std::string::value_type *v3;
  std::string::size_type v4;

  if (*(char *)(a1 + 55) < 0)
  {
    v3 = *(std::string::value_type **)(a1 + 32);
    v4 = *(_QWORD *)(a1 + 40);
  }
  else
  {
    v3 = (std::string::value_type *)(a1 + 32);
    v4 = *(unsigned __int8 *)(a1 + 55);
  }
  std::string::__assign_trivial[abi:ne180100]<unsigned char const*,unsigned char const*>(this, v3, &v3[v4], v4);
}

void ___ZL27sCreateSettingsMessage_3GPPRKN3ctu2cf12dict_adapterERNSt3__16vectorIN3wds25ModifyProfileSettings3GPP7RequestENS4_9allocatorIS8_EEEE_block_invoke_22(uint64_t a1, std::string *a2)
{
  void *v3[2];
  uint64_t v4;
  uint64_t v5;

  v3[0] = 0;
  v3[1] = 0;
  v4 = 0;
  ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)&v5, "apn");
  ctu::cf::map_adapter::getString();
  MEMORY[0x2199FDFFC](&v5);
  std::string::__assign_trivial[abi:ne180100]<unsigned char const*,unsigned char const*>(a2, (std::string::value_type *)v3, (std::string::value_type *)v3, 0);
  if (SHIBYTE(v4) < 0)
    operator delete(v3[0]);
}

void sub_2168D6D58(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t ___ZL27sCreateSettingsMessage_3GPPRKN3ctu2cf12dict_adapterERNSt3__16vectorIN3wds25ModifyProfileSettings3GPP7RequestENS4_9allocatorIS8_EEEE_block_invoke_2_25(uint64_t a1, int *a2)
{
  ctu::cf::map_adapter *v3;
  uint64_t result;
  int v5;
  __CFString *v6;

  v3 = *(ctu::cf::map_adapter **)(a1 + 32);
  ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)&v6, "AllowedProtocolMask");
  LODWORD(v3) = ctu::cf::map_adapter::getInt(v3, v6);
  result = MEMORY[0x2199FDFFC](&v6);
  v5 = 2 * ((_DWORD)v3 == 2);
  if ((_DWORD)v3 == 3)
    v5 = 3;
  *a2 = v5;
  return result;
}

uint64_t ___ZL27sCreateSettingsMessage_3GPPRKN3ctu2cf12dict_adapterERNSt3__16vectorIN3wds25ModifyProfileSettings3GPP7RequestENS4_9allocatorIS8_EEEE_block_invoke_4(uint64_t result, _DWORD *a2)
{
  *a2 = *(_DWORD *)(result + 32);
  return result;
}

uint64_t ___ZL27sCreateSettingsMessage_3GPPRKN3ctu2cf12dict_adapterERNSt3__16vectorIN3wds25ModifyProfileSettings3GPP7RequestENS4_9allocatorIS8_EEEE_block_invoke_5(uint64_t result, _DWORD *a2)
{
  *a2 = *(_DWORD *)(result + 32);
  return result;
}

size_t ___ZL27sCreateSettingsMessage_3GPPRKN3ctu2cf12dict_adapterERNSt3__16vectorIN3wds25ModifyProfileSettings3GPP7RequestENS4_9allocatorIS8_EEEE_block_invoke_6(uint64_t a1, char *a2)
{
  _QWORD *v3;
  int v4;
  size_t v5;
  _QWORD *v6;
  size_t result;
  _QWORD *v8;
  char v9;

  v3 = (_QWORD *)(a1 + 32);
  v4 = *(char *)(a1 + 55);
  if (v4 >= 0)
    v5 = *(unsigned __int8 *)(a1 + 55);
  else
    v5 = *(_QWORD *)(a1 + 40);
  if (v5 == strlen((const char *)*MEMORY[0x24BDC3DC8]))
  {
    v6 = v4 >= 0 ? v3 : (_QWORD *)*v3;
    result = memcmp(v6, (const void *)*MEMORY[0x24BDC3DC8], v5);
    if (!(_DWORD)result)
    {
      v9 = 1;
      goto LABEL_16;
    }
  }
  result = strlen((const char *)*MEMORY[0x24BDC3DC0]);
  if (v5 == result)
  {
    v8 = v4 >= 0 ? v3 : (_QWORD *)*v3;
    result = memcmp(v8, (const void *)*MEMORY[0x24BDC3DC0], v5);
    if (!(_DWORD)result)
    {
      v9 = 2;
LABEL_16:
      *a2 = v9;
    }
  }
  return result;
}

void ___ZL27sCreateSettingsMessage_3GPPRKN3ctu2cf12dict_adapterERNSt3__16vectorIN3wds25ModifyProfileSettings3GPP7RequestENS4_9allocatorIS8_EEEE_block_invoke_41(uint64_t a1, _BYTE *a2)
{
  ctu::cf::map_adapter *v4;
  std::string *p_p;
  char Bool;
  std::string __p;
  __CFString *v8;

  memset(&__p, 0, sizeof(__p));
  std::string::basic_string[abi:ne180100]<0>(&__p, "Pcs");
  std::string::append(&__p, "cfAddressRequired", 0x11uLL);
  v4 = *(ctu::cf::map_adapter **)(a1 + 32);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)&v8, (const char *)p_p);
  Bool = ctu::cf::map_adapter::getBool(v4, v8);
  MEMORY[0x2199FDFFC](&v8);
  *a2 = Bool;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
}

uint64_t ___ZL27sCreateSettingsMessage_3GPPRKN3ctu2cf12dict_adapterERNSt3__16vectorIN3wds25ModifyProfileSettings3GPP7RequestENS4_9allocatorIS8_EEEE_block_invoke_2_47(uint64_t result, _BYTE *a2)
{
  *a2 = *(_DWORD *)(result + 32);
  return result;
}

uint64_t qmi::MutableMessageBase::getTLV<wds::tlv::ProfileId>(_QWORD *a1, int a2)
{
  const void **v2;
  const void **v3;
  void *v4;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3)
        return qmi::MutableMessageBase::createTLV<wds::tlv::ProfileId>(a1, a2);
    }
  }
  if (v2 == v3)
    return qmi::MutableMessageBase::createTLV<wds::tlv::ProfileId>(a1, a2);
  if (!v4)
    __cxa_bad_cast();
  return (uint64_t)v4 + 12;
}

uint64_t qmi::MutableMessageBase::createTLV<wds::tlv::ProfileId>(_QWORD *a1, char a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v4 = operator new();
  *(_BYTE *)(v4 + 8) = a2;
  *(_QWORD *)v4 = &off_24D5C3768;
  *(_DWORD *)(v4 + 12) = 0;
  *(_BYTE *)(v4 + 16) = 0;
  v5 = a1[3];
  v6 = (uint64_t *)a1[2];
  if ((unint64_t)v6 >= v5)
  {
    v8 = a1[1];
    v9 = ((uint64_t)v6 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v5 - v8;
    v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1))
      v11 = v9 + 1;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v12);
    else
      v13 = 0;
    v14 = (uint64_t *)&v13[8 * v9];
    v15 = &v13[8 * v12];
    *v14 = v4;
    v7 = v14 + 1;
    v17 = (char *)a1[1];
    v16 = (char *)a1[2];
    if (v16 != v17)
    {
      do
      {
        v18 = *((_QWORD *)v16 - 1);
        v16 -= 8;
        *--v14 = v18;
      }
      while (v16 != v17);
      v16 = (char *)a1[1];
    }
    a1[1] = v14;
    a1[2] = v7;
    a1[3] = v15;
    if (v16)
      operator delete(v16);
  }
  else
  {
    *v6 = v4;
    v7 = v6 + 1;
  }
  a1[2] = v7;
  return v4 + 12;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::ProfileId>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::ProfileId>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_PcoMcc>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<wds::tlv::ProfileId>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::ProfileId>((_BYTE **)a2, a1 + 12);
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::ProfileId>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C3768;
  *(_QWORD *)(result + 12) = *(_QWORD *)(a1 + 12);
  return result;
}

uint64_t qmi::MutableMessageBase::getTLV<wds::tlv::UserName>(_QWORD *a1, int a2)
{
  const void **v2;
  const void **v3;
  void *v4;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3)
        return qmi::MutableMessageBase::createTLV<wds::tlv::UserName>(a1, a2);
    }
  }
  if (v2 == v3)
    return qmi::MutableMessageBase::createTLV<wds::tlv::UserName>(a1, a2);
  if (!v4)
    __cxa_bad_cast();
  return (uint64_t)v4 + 16;
}

uint64_t qmi::MutableMessageBase::createTLV<wds::tlv::UserName>(_QWORD *a1, char a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v4 = operator new();
  *(_BYTE *)(v4 + 8) = a2;
  *(_QWORD *)v4 = off_24D5C37B8;
  *(_QWORD *)(v4 + 16) = 0;
  *(_QWORD *)(v4 + 24) = 0;
  *(_QWORD *)(v4 + 32) = 0;
  v5 = a1[3];
  v6 = (uint64_t *)a1[2];
  if ((unint64_t)v6 >= v5)
  {
    v8 = a1[1];
    v9 = ((uint64_t)v6 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v5 - v8;
    v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1))
      v11 = v9 + 1;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v12);
    else
      v13 = 0;
    v14 = (uint64_t *)&v13[8 * v9];
    v15 = &v13[8 * v12];
    *v14 = v4;
    v7 = v14 + 1;
    v17 = (char *)a1[1];
    v16 = (char *)a1[2];
    if (v16 != v17)
    {
      do
      {
        v18 = *((_QWORD *)v16 - 1);
        v16 -= 8;
        *--v14 = v18;
      }
      while (v16 != v17);
      v16 = (char *)a1[1];
    }
    a1[1] = v14;
    a1[2] = v7;
    a1[3] = v15;
    if (v16)
      operator delete(v16);
  }
  else
  {
    *v6 = v4;
    v7 = v6 + 1;
  }
  a1[2] = v7;
  return v4 + 16;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::UserName>::~TlvWrapper(uint64_t a1)
{
  *(_QWORD *)a1 = off_24D5C37B8;
  if (*(char *)(a1 + 39) < 0)
    operator delete(*(void **)(a1 + 16));
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::UserName>::~TlvWrapper(uint64_t a1)
{
  *(_QWORD *)a1 = off_24D5C37B8;
  if (*(char *)(a1 + 39) < 0)
    operator delete(*(void **)(a1 + 16));
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::UserName>::getSize(uint64_t a1)
{
  return tlv::size<wds::tlv::Dnn>(a1 + 16);
}

void *qmi::MutableMessageBase::TlvWrapper<wds::tlv::UserName>::write(uint64_t a1, void **a2)
{
  char v3;
  char *v4;
  uint64_t v5;
  void *result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (char *)*a2;
  v5 = (uint64_t)*a2 + 3;
  *a2 = (void *)v5;
  result = tlv::writeV<wds::tlv::Dnn>(a2, (_QWORD *)(a1 + 16));
  v7 = (char *)*a2 - v5;
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::UserName>::clone(uint64_t a1)
{
  uint64_t v2;
  std::string *v3;

  v2 = operator new();
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)v2 = off_24D5C37B8;
  v3 = (std::string *)(v2 + 16);
  if (*(char *)(a1 + 39) < 0)
  {
    std::string::__init_copy_ctor_external(v3, *(const std::string::value_type **)(a1 + 16), *(_QWORD *)(a1 + 24));
  }
  else
  {
    *(_OWORD *)&v3->__r_.__value_.__l.__data_ = *(_OWORD *)(a1 + 16);
    *(_QWORD *)(v2 + 32) = *(_QWORD *)(a1 + 32);
  }
  return v2;
}

void sub_2168D7528(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199FEAC4](v1, 0x1093C4081B1C094);
  _Unwind_Resume(a1);
}

uint64_t qmi::MutableMessageBase::getTLV<wds::tlv::Password>(_QWORD *a1, int a2)
{
  const void **v2;
  const void **v3;
  void *v4;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3)
        return qmi::MutableMessageBase::createTLV<wds::tlv::Password>(a1, a2);
    }
  }
  if (v2 == v3)
    return qmi::MutableMessageBase::createTLV<wds::tlv::Password>(a1, a2);
  if (!v4)
    __cxa_bad_cast();
  return (uint64_t)v4 + 16;
}

uint64_t qmi::MutableMessageBase::createTLV<wds::tlv::Password>(_QWORD *a1, char a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v4 = operator new();
  *(_BYTE *)(v4 + 8) = a2;
  *(_QWORD *)v4 = off_24D5C3808;
  *(_QWORD *)(v4 + 16) = 0;
  *(_QWORD *)(v4 + 24) = 0;
  *(_QWORD *)(v4 + 32) = 0;
  v5 = a1[3];
  v6 = (uint64_t *)a1[2];
  if ((unint64_t)v6 >= v5)
  {
    v8 = a1[1];
    v9 = ((uint64_t)v6 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v5 - v8;
    v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1))
      v11 = v9 + 1;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v12);
    else
      v13 = 0;
    v14 = (uint64_t *)&v13[8 * v9];
    v15 = &v13[8 * v12];
    *v14 = v4;
    v7 = v14 + 1;
    v17 = (char *)a1[1];
    v16 = (char *)a1[2];
    if (v16 != v17)
    {
      do
      {
        v18 = *((_QWORD *)v16 - 1);
        v16 -= 8;
        *--v14 = v18;
      }
      while (v16 != v17);
      v16 = (char *)a1[1];
    }
    a1[1] = v14;
    a1[2] = v7;
    a1[3] = v15;
    if (v16)
      operator delete(v16);
  }
  else
  {
    *v6 = v4;
    v7 = v6 + 1;
  }
  a1[2] = v7;
  return v4 + 16;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Password>::~TlvWrapper(uint64_t a1)
{
  *(_QWORD *)a1 = off_24D5C3808;
  if (*(char *)(a1 + 39) < 0)
    operator delete(*(void **)(a1 + 16));
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::Password>::~TlvWrapper(uint64_t a1)
{
  *(_QWORD *)a1 = off_24D5C3808;
  if (*(char *)(a1 + 39) < 0)
    operator delete(*(void **)(a1 + 16));
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Password>::getSize(uint64_t a1)
{
  return tlv::size<wds::tlv::Dnn>(a1 + 16);
}

void *qmi::MutableMessageBase::TlvWrapper<wds::tlv::Password>::write(uint64_t a1, void **a2)
{
  char v3;
  char *v4;
  uint64_t v5;
  void *result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (char *)*a2;
  v5 = (uint64_t)*a2 + 3;
  *a2 = (void *)v5;
  result = tlv::writeV<wds::tlv::Dnn>(a2, (_QWORD *)(a1 + 16));
  v7 = (char *)*a2 - v5;
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Password>::clone(uint64_t a1)
{
  uint64_t v2;
  std::string *v3;

  v2 = operator new();
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)v2 = off_24D5C3808;
  v3 = (std::string *)(v2 + 16);
  if (*(char *)(a1 + 39) < 0)
  {
    std::string::__init_copy_ctor_external(v3, *(const std::string::value_type **)(a1 + 16), *(_QWORD *)(a1 + 24));
  }
  else
  {
    *(_OWORD *)&v3->__r_.__value_.__l.__data_ = *(_OWORD *)(a1 + 16);
    *(_QWORD *)(v2 + 32) = *(_QWORD *)(a1 + 32);
  }
  return v2;
}

void sub_2168D7840(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199FEAC4](v1, 0x1093C4081B1C094);
  _Unwind_Resume(a1);
}

uint64_t qmi::MutableMessageBase::getTLV<wds::tlv::ApnName>(_QWORD *a1, int a2)
{
  const void **v2;
  const void **v3;
  void *v4;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3)
        return qmi::MutableMessageBase::createTLV<wds::tlv::ApnName>(a1, a2);
    }
  }
  if (v2 == v3)
    return qmi::MutableMessageBase::createTLV<wds::tlv::ApnName>(a1, a2);
  if (!v4)
    __cxa_bad_cast();
  return (uint64_t)v4 + 16;
}

uint64_t qmi::MutableMessageBase::createTLV<wds::tlv::ApnName>(_QWORD *a1, char a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v4 = operator new();
  *(_BYTE *)(v4 + 8) = a2;
  *(_QWORD *)v4 = off_24D5C3858;
  *(_QWORD *)(v4 + 16) = 0;
  *(_QWORD *)(v4 + 24) = 0;
  *(_QWORD *)(v4 + 32) = 0;
  v5 = a1[3];
  v6 = (uint64_t *)a1[2];
  if ((unint64_t)v6 >= v5)
  {
    v8 = a1[1];
    v9 = ((uint64_t)v6 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v5 - v8;
    v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1))
      v11 = v9 + 1;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v12);
    else
      v13 = 0;
    v14 = (uint64_t *)&v13[8 * v9];
    v15 = &v13[8 * v12];
    *v14 = v4;
    v7 = v14 + 1;
    v17 = (char *)a1[1];
    v16 = (char *)a1[2];
    if (v16 != v17)
    {
      do
      {
        v18 = *((_QWORD *)v16 - 1);
        v16 -= 8;
        *--v14 = v18;
      }
      while (v16 != v17);
      v16 = (char *)a1[1];
    }
    a1[1] = v14;
    a1[2] = v7;
    a1[3] = v15;
    if (v16)
      operator delete(v16);
  }
  else
  {
    *v6 = v4;
    v7 = v6 + 1;
  }
  a1[2] = v7;
  return v4 + 16;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::ApnName>::~TlvWrapper(uint64_t a1)
{
  *(_QWORD *)a1 = off_24D5C3858;
  if (*(char *)(a1 + 39) < 0)
    operator delete(*(void **)(a1 + 16));
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::ApnName>::~TlvWrapper(uint64_t a1)
{
  *(_QWORD *)a1 = off_24D5C3858;
  if (*(char *)(a1 + 39) < 0)
    operator delete(*(void **)(a1 + 16));
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::ApnName>::getSize(uint64_t a1)
{
  return tlv::size<wds::tlv::Dnn>(a1 + 16);
}

void *qmi::MutableMessageBase::TlvWrapper<wds::tlv::ApnName>::write(uint64_t a1, void **a2)
{
  char v3;
  char *v4;
  uint64_t v5;
  void *result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (char *)*a2;
  v5 = (uint64_t)*a2 + 3;
  *a2 = (void *)v5;
  result = tlv::writeV<wds::tlv::Dnn>(a2, (_QWORD *)(a1 + 16));
  v7 = (char *)*a2 - v5;
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::ApnName>::clone(uint64_t a1)
{
  uint64_t v2;
  std::string *v3;

  v2 = operator new();
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)v2 = off_24D5C3858;
  v3 = (std::string *)(v2 + 16);
  if (*(char *)(a1 + 39) < 0)
  {
    std::string::__init_copy_ctor_external(v3, *(const std::string::value_type **)(a1 + 16), *(_QWORD *)(a1 + 24));
  }
  else
  {
    *(_OWORD *)&v3->__r_.__value_.__l.__data_ = *(_OWORD *)(a1 + 16);
    *(_QWORD *)(v2 + 32) = *(_QWORD *)(a1 + 32);
  }
  return v2;
}

void sub_2168D7B58(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199FEAC4](v1, 0x1093C4081B1C094);
  _Unwind_Resume(a1);
}

uint64_t qmi::MutableMessageBase::getTLV<wds::tlv::PdpType3GPP>(_QWORD *a1, int a2)
{
  const void **v2;
  const void **v3;
  void *v4;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3)
        return qmi::MutableMessageBase::createTLV<wds::tlv::PdpType3GPP>(a1, a2);
    }
  }
  if (v2 == v3)
    return qmi::MutableMessageBase::createTLV<wds::tlv::PdpType3GPP>(a1, a2);
  if (!v4)
    __cxa_bad_cast();
  return (uint64_t)v4 + 12;
}

uint64_t qmi::MutableMessageBase::createTLV<wds::tlv::PdpType3GPP>(_QWORD *a1, char a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v4 = operator new();
  *(_BYTE *)(v4 + 8) = a2;
  *(_DWORD *)(v4 + 12) = 0;
  *(_QWORD *)v4 = &off_24D5C38A8;
  v5 = a1[3];
  v6 = (uint64_t *)a1[2];
  if ((unint64_t)v6 >= v5)
  {
    v8 = a1[1];
    v9 = ((uint64_t)v6 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v5 - v8;
    v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1))
      v11 = v9 + 1;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v12);
    else
      v13 = 0;
    v14 = (uint64_t *)&v13[8 * v9];
    v15 = &v13[8 * v12];
    *v14 = v4;
    v7 = v14 + 1;
    v17 = (char *)a1[1];
    v16 = (char *)a1[2];
    if (v16 != v17)
    {
      do
      {
        v18 = *((_QWORD *)v16 - 1);
        v16 -= 8;
        *--v14 = v18;
      }
      while (v16 != v17);
      v16 = (char *)a1[1];
    }
    a1[1] = v14;
    a1[2] = v7;
    a1[3] = v15;
    if (v16)
      operator delete(v16);
  }
  else
  {
    *v6 = v4;
    v7 = v6 + 1;
  }
  a1[2] = v7;
  return v4 + 12;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::PdpType3GPP>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::PdpType3GPP>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<wds::tlv::PdpType3GPP>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::IPPref>((_BYTE **)a2, (_DWORD *)(a1 + 12));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::PdpType3GPP>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C38A8;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a1 + 12);
  return result;
}

uint64_t qmi::MutableMessageBase::getTLV<wds::tlv::LTERoamingPdpType>(_QWORD *a1, int a2)
{
  const void **v2;
  const void **v3;
  void *v4;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3)
        return qmi::MutableMessageBase::createTLV<wds::tlv::LTERoamingPdpType>(a1, a2);
    }
  }
  if (v2 == v3)
    return qmi::MutableMessageBase::createTLV<wds::tlv::LTERoamingPdpType>(a1, a2);
  if (!v4)
    __cxa_bad_cast();
  return (uint64_t)v4 + 12;
}

uint64_t qmi::MutableMessageBase::createTLV<wds::tlv::LTERoamingPdpType>(_QWORD *a1, char a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v4 = operator new();
  *(_BYTE *)(v4 + 8) = a2;
  *(_DWORD *)(v4 + 12) = 0;
  *(_QWORD *)v4 = &off_24D5C38F8;
  v5 = a1[3];
  v6 = (uint64_t *)a1[2];
  if ((unint64_t)v6 >= v5)
  {
    v8 = a1[1];
    v9 = ((uint64_t)v6 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v5 - v8;
    v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1))
      v11 = v9 + 1;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v12);
    else
      v13 = 0;
    v14 = (uint64_t *)&v13[8 * v9];
    v15 = &v13[8 * v12];
    *v14 = v4;
    v7 = v14 + 1;
    v17 = (char *)a1[1];
    v16 = (char *)a1[2];
    if (v16 != v17)
    {
      do
      {
        v18 = *((_QWORD *)v16 - 1);
        v16 -= 8;
        *--v14 = v18;
      }
      while (v16 != v17);
      v16 = (char *)a1[1];
    }
    a1[1] = v14;
    a1[2] = v7;
    a1[3] = v15;
    if (v16)
      operator delete(v16);
  }
  else
  {
    *v6 = v4;
    v7 = v6 + 1;
  }
  a1[2] = v7;
  return v4 + 12;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::LTERoamingPdpType>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::LTERoamingPdpType>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP2_InactivityTimer>();
}

_DWORD *qmi::MutableMessageBase::TlvWrapper<wds::tlv::LTERoamingPdpType>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _DWORD *v4;
  uint64_t v5;
  _DWORD *result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_DWORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::Profile3GPP2_InactivityTimer>((_DWORD **)a2, (_DWORD *)(a1 + 12));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::LTERoamingPdpType>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C38F8;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a1 + 12);
  return result;
}

uint64_t qmi::MutableMessageBase::getTLV<wds::tlv::UMTSRoamingPdpType>(_QWORD *a1, int a2)
{
  const void **v2;
  const void **v3;
  void *v4;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3)
        return qmi::MutableMessageBase::createTLV<wds::tlv::UMTSRoamingPdpType>(a1, a2);
    }
  }
  if (v2 == v3)
    return qmi::MutableMessageBase::createTLV<wds::tlv::UMTSRoamingPdpType>(a1, a2);
  if (!v4)
    __cxa_bad_cast();
  return (uint64_t)v4 + 12;
}

uint64_t qmi::MutableMessageBase::createTLV<wds::tlv::UMTSRoamingPdpType>(_QWORD *a1, char a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v4 = operator new();
  *(_BYTE *)(v4 + 8) = a2;
  *(_DWORD *)(v4 + 12) = 0;
  *(_QWORD *)v4 = &off_24D5C3948;
  v5 = a1[3];
  v6 = (uint64_t *)a1[2];
  if ((unint64_t)v6 >= v5)
  {
    v8 = a1[1];
    v9 = ((uint64_t)v6 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v5 - v8;
    v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1))
      v11 = v9 + 1;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v12);
    else
      v13 = 0;
    v14 = (uint64_t *)&v13[8 * v9];
    v15 = &v13[8 * v12];
    *v14 = v4;
    v7 = v14 + 1;
    v17 = (char *)a1[1];
    v16 = (char *)a1[2];
    if (v16 != v17)
    {
      do
      {
        v18 = *((_QWORD *)v16 - 1);
        v16 -= 8;
        *--v14 = v18;
      }
      while (v16 != v17);
      v16 = (char *)a1[1];
    }
    a1[1] = v14;
    a1[2] = v7;
    a1[3] = v15;
    if (v16)
      operator delete(v16);
  }
  else
  {
    *v6 = v4;
    v7 = v6 + 1;
  }
  a1[2] = v7;
  return v4 + 12;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::UMTSRoamingPdpType>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::UMTSRoamingPdpType>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP2_InactivityTimer>();
}

_DWORD *qmi::MutableMessageBase::TlvWrapper<wds::tlv::UMTSRoamingPdpType>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _DWORD *v4;
  uint64_t v5;
  _DWORD *result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_DWORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::Profile3GPP2_InactivityTimer>((_DWORD **)a2, (_DWORD *)(a1 + 12));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::UMTSRoamingPdpType>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C3948;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a1 + 12);
  return result;
}

uint64_t qmi::MutableMessageBase::getTLV<wds::tlv::AuthPref>(_QWORD *a1, int a2)
{
  const void **v2;
  const void **v3;
  void *v4;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3)
        return qmi::MutableMessageBase::createTLV<wds::tlv::AuthPref>(a1, a2);
    }
  }
  if (v2 == v3)
    return qmi::MutableMessageBase::createTLV<wds::tlv::AuthPref>(a1, a2);
  if (!v4)
    __cxa_bad_cast();
  return (uint64_t)v4 + 9;
}

uint64_t qmi::MutableMessageBase::createTLV<wds::tlv::AuthPref>(_QWORD *a1, char a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v4 = operator new();
  *(_BYTE *)(v4 + 8) = a2;
  *(_BYTE *)(v4 + 9) = 0;
  *(_QWORD *)v4 = &off_24D5C3998;
  v5 = a1[3];
  v6 = (uint64_t *)a1[2];
  if ((unint64_t)v6 >= v5)
  {
    v8 = a1[1];
    v9 = ((uint64_t)v6 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v5 - v8;
    v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1))
      v11 = v9 + 1;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v12);
    else
      v13 = 0;
    v14 = (uint64_t *)&v13[8 * v9];
    v15 = &v13[8 * v12];
    *v14 = v4;
    v7 = v14 + 1;
    v17 = (char *)a1[1];
    v16 = (char *)a1[2];
    if (v16 != v17)
    {
      do
      {
        v18 = *((_QWORD *)v16 - 1);
        v16 -= 8;
        *--v14 = v18;
      }
      while (v16 != v17);
      v16 = (char *)a1[1];
    }
    a1[1] = v14;
    a1[2] = v7;
    a1[3] = v15;
    if (v16)
      operator delete(v16);
  }
  else
  {
    *v6 = v4;
    v7 = v6 + 1;
  }
  a1[2] = v7;
  return v4 + 9;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::AuthPref>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::AuthPref>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<wds::tlv::AuthPref>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::AuthPref>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C3998;
  return result;
}

uint64_t qmi::MutableMessageBase::getTLV<wds::tlv::ProxyAddrUsingPco>(_QWORD *a1, int a2)
{
  const void **v2;
  const void **v3;
  void *v4;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3)
        return qmi::MutableMessageBase::createTLV<wds::tlv::ProxyAddrUsingPco>(a1, a2);
    }
  }
  if (v2 == v3)
    return qmi::MutableMessageBase::createTLV<wds::tlv::ProxyAddrUsingPco>(a1, a2);
  if (!v4)
    __cxa_bad_cast();
  return (uint64_t)v4 + 9;
}

uint64_t qmi::MutableMessageBase::createTLV<wds::tlv::ProxyAddrUsingPco>(_QWORD *a1, char a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v4 = operator new();
  *(_BYTE *)(v4 + 8) = a2;
  *(_BYTE *)(v4 + 9) = 0;
  *(_QWORD *)v4 = &off_24D5C39E8;
  v5 = a1[3];
  v6 = (uint64_t *)a1[2];
  if ((unint64_t)v6 >= v5)
  {
    v8 = a1[1];
    v9 = ((uint64_t)v6 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v5 - v8;
    v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1))
      v11 = v9 + 1;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v12);
    else
      v13 = 0;
    v14 = (uint64_t *)&v13[8 * v9];
    v15 = &v13[8 * v12];
    *v14 = v4;
    v7 = v14 + 1;
    v17 = (char *)a1[1];
    v16 = (char *)a1[2];
    if (v16 != v17)
    {
      do
      {
        v18 = *((_QWORD *)v16 - 1);
        v16 -= 8;
        *--v14 = v18;
      }
      while (v16 != v17);
      v16 = (char *)a1[1];
    }
    a1[1] = v14;
    a1[2] = v7;
    a1[3] = v15;
    if (v16)
      operator delete(v16);
  }
  else
  {
    *v6 = v4;
    v7 = v6 + 1;
  }
  a1[2] = v7;
  return v4 + 9;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::ProxyAddrUsingPco>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::ProxyAddrUsingPco>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<wds::tlv::ProxyAddrUsingPco>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::ProxyAddrUsingPco>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C39E8;
  return result;
}

uint64_t qmi::MutableMessageBase::getTLV<wds::tlv::APNClass>(_QWORD *a1, int a2)
{
  const void **v2;
  const void **v3;
  void *v4;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3)
        return qmi::MutableMessageBase::createTLV<wds::tlv::APNClass>(a1, a2);
    }
  }
  if (v2 == v3)
    return qmi::MutableMessageBase::createTLV<wds::tlv::APNClass>(a1, a2);
  if (!v4)
    __cxa_bad_cast();
  return (uint64_t)v4 + 9;
}

uint64_t qmi::MutableMessageBase::createTLV<wds::tlv::APNClass>(_QWORD *a1, char a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v4 = operator new();
  *(_BYTE *)(v4 + 8) = a2;
  *(_BYTE *)(v4 + 9) = 0;
  *(_QWORD *)v4 = &off_24D5C3A38;
  v5 = a1[3];
  v6 = (uint64_t *)a1[2];
  if ((unint64_t)v6 >= v5)
  {
    v8 = a1[1];
    v9 = ((uint64_t)v6 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v5 - v8;
    v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1))
      v11 = v9 + 1;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v12);
    else
      v13 = 0;
    v14 = (uint64_t *)&v13[8 * v9];
    v15 = &v13[8 * v12];
    *v14 = v4;
    v7 = v14 + 1;
    v17 = (char *)a1[1];
    v16 = (char *)a1[2];
    if (v16 != v17)
    {
      do
      {
        v18 = *((_QWORD *)v16 - 1);
        v16 -= 8;
        *--v14 = v18;
      }
      while (v16 != v17);
      v16 = (char *)a1[1];
    }
    a1[1] = v14;
    a1[2] = v7;
    a1[3] = v15;
    if (v16)
      operator delete(v16);
  }
  else
  {
    *v6 = v4;
    v7 = v6 + 1;
  }
  a1[2] = v7;
  return v4 + 9;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::APNClass>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::APNClass>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<wds::tlv::APNClass>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::APNClass>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C3A38;
  return result;
}

uint64_t qmi::MutableMessageBase::getTLV<wds::tlv::RoamingDisallow>(_QWORD *a1, int a2)
{
  const void **v2;
  const void **v3;
  void *v4;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3)
        return qmi::MutableMessageBase::createTLV<wds::tlv::RoamingDisallow>(a1, a2);
    }
  }
  if (v2 == v3)
    return qmi::MutableMessageBase::createTLV<wds::tlv::RoamingDisallow>(a1, a2);
  if (!v4)
    __cxa_bad_cast();
  return (uint64_t)v4 + 9;
}

uint64_t qmi::MutableMessageBase::createTLV<wds::tlv::RoamingDisallow>(_QWORD *a1, char a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v4 = operator new();
  *(_BYTE *)(v4 + 8) = a2;
  *(_BYTE *)(v4 + 9) = 0;
  *(_QWORD *)v4 = &off_24D5C3A88;
  v5 = a1[3];
  v6 = (uint64_t *)a1[2];
  if ((unint64_t)v6 >= v5)
  {
    v8 = a1[1];
    v9 = ((uint64_t)v6 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v5 - v8;
    v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1))
      v11 = v9 + 1;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v12);
    else
      v13 = 0;
    v14 = (uint64_t *)&v13[8 * v9];
    v15 = &v13[8 * v12];
    *v14 = v4;
    v7 = v14 + 1;
    v17 = (char *)a1[1];
    v16 = (char *)a1[2];
    if (v16 != v17)
    {
      do
      {
        v18 = *((_QWORD *)v16 - 1);
        v16 -= 8;
        *--v14 = v18;
      }
      while (v16 != v17);
      v16 = (char *)a1[1];
    }
    a1[1] = v14;
    a1[2] = v7;
    a1[3] = v15;
    if (v16)
      operator delete(v16);
  }
  else
  {
    *v6 = v4;
    v7 = v6 + 1;
  }
  a1[2] = v7;
  return v4 + 9;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::RoamingDisallow>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::RoamingDisallow>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<wds::tlv::RoamingDisallow>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::RoamingDisallow>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C3A88;
  return result;
}

uint64_t std::__split_buffer<wds::ModifyProfileSettings3GPP::Request>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 32;
    qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)(i - 32));
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::vector<ctu::cf::CFSharedRef<__CFDictionary const>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  const void **v2;
  const void **v4;
  void *v5;

  v1 = *a1;
  v2 = (const void **)**a1;
  if (v2)
  {
    v4 = (const void **)v1[1];
    v5 = v2;
    if (v4 != v2)
    {
      do
        v4 = ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef(v4 - 1);
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t qmi::MutableMessageBase::getTLV<wds::tlv::Append>(_QWORD *a1, int a2)
{
  const void **v2;
  const void **v3;
  void *v4;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3)
        return qmi::MutableMessageBase::createTLV<wds::tlv::Append>(a1, a2);
    }
  }
  if (v2 == v3)
    return qmi::MutableMessageBase::createTLV<wds::tlv::Append>(a1, a2);
  if (!v4)
    __cxa_bad_cast();
  return (uint64_t)v4 + 9;
}

uint64_t qmi::MutableMessageBase::createTLV<wds::tlv::Append>(_QWORD *a1, char a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v4 = operator new();
  *(_BYTE *)(v4 + 8) = a2;
  *(_BYTE *)(v4 + 9) = 0;
  *(_QWORD *)v4 = &off_24D5C3AD8;
  v5 = a1[3];
  v6 = (uint64_t *)a1[2];
  if ((unint64_t)v6 >= v5)
  {
    v8 = a1[1];
    v9 = ((uint64_t)v6 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v5 - v8;
    v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1))
      v11 = v9 + 1;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v12);
    else
      v13 = 0;
    v14 = (uint64_t *)&v13[8 * v9];
    v15 = &v13[8 * v12];
    *v14 = v4;
    v7 = v14 + 1;
    v17 = (char *)a1[1];
    v16 = (char *)a1[2];
    if (v16 != v17)
    {
      do
      {
        v18 = *((_QWORD *)v16 - 1);
        v16 -= 8;
        *--v14 = v18;
      }
      while (v16 != v17);
      v16 = (char *)a1[1];
    }
    a1[1] = v14;
    a1[2] = v7;
    a1[3] = v15;
    if (v16)
      operator delete(v16);
  }
  else
  {
    *v6 = v4;
    v7 = v6 + 1;
  }
  a1[2] = v7;
  return v4 + 9;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::Append>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Append>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<wds::tlv::Append>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Append>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C3AD8;
  return result;
}

void std::vector<wds::ModifyProfileSettings3GPP::Request>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = v2;
    if (v4 != v2)
    {
      do
        qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)(v4 - 32));
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void ___ZL28sCreateSettingsMessage_3GPP2RKN3ctu2cf12dict_adapterERNSt3__16vectorIN3wds26ModifyProfileSettings3GPP27RequestENS4_9allocatorIS8_EEEE_block_invoke_2(uint64_t a1, std::string *this)
{
  std::string::value_type *v3;
  std::string::size_type v4;

  if (*(char *)(a1 + 55) < 0)
  {
    v3 = *(std::string::value_type **)(a1 + 32);
    v4 = *(_QWORD *)(a1 + 40);
  }
  else
  {
    v3 = (std::string::value_type *)(a1 + 32);
    v4 = *(unsigned __int8 *)(a1 + 55);
  }
  std::string::__assign_trivial[abi:ne180100]<unsigned char const*,unsigned char const*>(this, v3, &v3[v4], v4);
}

void ___ZL28sCreateSettingsMessage_3GPP2RKN3ctu2cf12dict_adapterERNSt3__16vectorIN3wds26ModifyProfileSettings3GPP27RequestENS4_9allocatorIS8_EEEE_block_invoke_59(uint64_t a1, std::string *this)
{
  std::string::value_type *v3;
  std::string::size_type v4;

  if (*(char *)(a1 + 55) < 0)
  {
    v3 = *(std::string::value_type **)(a1 + 32);
    v4 = *(_QWORD *)(a1 + 40);
  }
  else
  {
    v3 = (std::string::value_type *)(a1 + 32);
    v4 = *(unsigned __int8 *)(a1 + 55);
  }
  std::string::__assign_trivial[abi:ne180100]<unsigned char const*,unsigned char const*>(this, v3, &v3[v4], v4);
}

void ___ZL28sCreateSettingsMessage_3GPP2RKN3ctu2cf12dict_adapterERNSt3__16vectorIN3wds26ModifyProfileSettings3GPP27RequestENS4_9allocatorIS8_EEEE_block_invoke_61(uint64_t a1, std::string *a2)
{
  void *v3[2];
  uint64_t v4;
  uint64_t v5;

  v3[0] = 0;
  v3[1] = 0;
  v4 = 0;
  ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)&v5, "apn");
  ctu::cf::map_adapter::getString();
  MEMORY[0x2199FDFFC](&v5);
  std::string::__assign_trivial[abi:ne180100]<unsigned char const*,unsigned char const*>(a2, (std::string::value_type *)v3, (std::string::value_type *)v3, 0);
  if (SHIBYTE(v4) < 0)
    operator delete(v3[0]);
}

void sub_2168D903C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t ___ZL28sCreateSettingsMessage_3GPP2RKN3ctu2cf12dict_adapterERNSt3__16vectorIN3wds26ModifyProfileSettings3GPP27RequestENS4_9allocatorIS8_EEEE_block_invoke_2_63(uint64_t a1, int *a2)
{
  ctu::cf::map_adapter *v3;
  uint64_t result;
  int v5;
  __CFString *v6;

  v3 = *(ctu::cf::map_adapter **)(a1 + 32);
  ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)&v6, "AllowedProtocolMask");
  LODWORD(v3) = ctu::cf::map_adapter::getInt(v3, v6);
  result = MEMORY[0x2199FDFFC](&v6);
  v5 = (_DWORD)v3 == 2;
  if ((_DWORD)v3 == 3)
    v5 = 2;
  *a2 = v5;
  return result;
}

size_t ___ZL28sCreateSettingsMessage_3GPP2RKN3ctu2cf12dict_adapterERNSt3__16vectorIN3wds26ModifyProfileSettings3GPP27RequestENS4_9allocatorIS8_EEEE_block_invoke_3(uint64_t a1, char *a2)
{
  _QWORD *v3;
  int v4;
  size_t v5;
  _QWORD *v6;
  size_t result;
  _QWORD *v8;
  char v9;

  v3 = (_QWORD *)(a1 + 32);
  v4 = *(char *)(a1 + 55);
  if (v4 >= 0)
    v5 = *(unsigned __int8 *)(a1 + 55);
  else
    v5 = *(_QWORD *)(a1 + 40);
  if (v5 == strlen((const char *)*MEMORY[0x24BDC3DC8]))
  {
    v6 = v4 >= 0 ? v3 : (_QWORD *)*v3;
    result = memcmp(v6, (const void *)*MEMORY[0x24BDC3DC8], v5);
    if (!(_DWORD)result)
    {
      v9 = 1;
      goto LABEL_16;
    }
  }
  result = strlen((const char *)*MEMORY[0x24BDC3DC0]);
  if (v5 == result)
  {
    v8 = v4 >= 0 ? v3 : (_QWORD *)*v3;
    result = memcmp(v8, (const void *)*MEMORY[0x24BDC3DC0], v5);
    if (!(_DWORD)result)
    {
      v9 = 2;
LABEL_16:
      *a2 = v9;
    }
  }
  return result;
}

uint64_t ___ZL28sCreateSettingsMessage_3GPP2RKN3ctu2cf12dict_adapterERNSt3__16vectorIN3wds26ModifyProfileSettings3GPP27RequestENS4_9allocatorIS8_EEEE_block_invoke_67(uint64_t a1, _BYTE *a2)
{
  ctu::cf::map_adapter *v3;
  uint64_t result;
  __CFString *v5;

  v3 = *(ctu::cf::map_adapter **)(a1 + 32);
  ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)&v5, "PcscfAddressRequired");
  LOBYTE(v3) = ctu::cf::map_adapter::getBool(v3, v5);
  result = MEMORY[0x2199FDFFC](&v5);
  *a2 = (_BYTE)v3;
  return result;
}

uint64_t ___ZL28sCreateSettingsMessage_3GPP2RKN3ctu2cf12dict_adapterERNSt3__16vectorIN3wds26ModifyProfileSettings3GPP27RequestENS4_9allocatorIS8_EEEE_block_invoke_2_71(uint64_t a1, int *a2)
{
  ctu::cf::map_adapter *v4;
  int Bool;
  ctu::cf::map_adapter *v6;
  uint64_t result;
  int v8;
  __CFString *v9;

  v4 = *(ctu::cf::map_adapter **)(a1 + 32);
  ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)&v9, "hrpd");
  Bool = ctu::cf::map_adapter::getBool(v4, v9);
  MEMORY[0x2199FDFFC](&v9);
  v6 = *(ctu::cf::map_adapter **)(a1 + 32);
  ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)&v9, "ehrpd");
  LODWORD(v6) = ctu::cf::map_adapter::getBool(v6, v9);
  result = MEMORY[0x2199FDFFC](&v9);
  if ((_DWORD)v6)
    v8 = 3;
  else
    v8 = 1;
  if (!Bool)
    v8 = 2;
  *a2 = v8;
  return result;
}

void sub_2168D92D8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  MEMORY[0x2199FDFFC](va);
  _Unwind_Resume(a1);
}

uint64_t ___ZL28sCreateSettingsMessage_3GPP2RKN3ctu2cf12dict_adapterERNSt3__16vectorIN3wds26ModifyProfileSettings3GPP27RequestENS4_9allocatorIS8_EEEE_block_invoke_3_77(uint64_t result, _DWORD *a2)
{
  *a2 = *(_DWORD *)(result + 32);
  return result;
}

uint64_t ___ZL28sCreateSettingsMessage_3GPP2RKN3ctu2cf12dict_adapterERNSt3__16vectorIN3wds26ModifyProfileSettings3GPP27RequestENS4_9allocatorIS8_EEEE_block_invoke_4(uint64_t result, _BYTE *a2)
{
  *a2 = *(_DWORD *)(result + 32);
  return result;
}

uint64_t std::vector<wds::ModifyProfileSettings3GPP2::Request>::push_back[abi:ne180100](uint64_t *a1)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  uint64_t v17;

  v4 = a1[2];
  v2 = (uint64_t)(a1 + 2);
  v3 = v4;
  v5 = *(_QWORD *)(v2 - 8);
  if (v5 >= v4)
  {
    v8 = (uint64_t)(v5 - *a1) >> 5;
    if ((unint64_t)(v8 + 1) >> 59)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v9 = v3 - *a1;
    v10 = v9 >> 4;
    if (v9 >> 4 <= (unint64_t)(v8 + 1))
      v10 = v8 + 1;
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFE0)
      v11 = 0x7FFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    v17 = v2;
    if (v11)
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<vs::tlv::RemoteNumberListItem>>(v2, v11);
    else
      v12 = 0;
    v13 = v12;
    v14 = &v12[32 * v8];
    v16 = &v12[32 * v11];
    qmi::MutableMessageBase::MutableMessageBase();
    v15 = v14 + 32;
    std::vector<wds::ModifyProfileSettings3GPP2::Request>::__swap_out_circular_buffer(a1, &v13);
    v7 = a1[1];
    result = std::__split_buffer<wds::ModifyProfileSettings3GPP::Request>::~__split_buffer((uint64_t)&v13);
  }
  else
  {
    result = qmi::MutableMessageBase::MutableMessageBase();
    v7 = v5 + 32;
    a1[1] = v5 + 32;
  }
  a1[1] = v7;
  return result;
}

void sub_2168D93F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  uint64_t v10;
  uint64_t v11;

  *(_QWORD *)(v10 + 8) = v11;
  _Unwind_Resume(exception_object);
}

uint64_t qmi::MutableMessageBase::getTLV<wds::tlv::PdpType3GPP2>(_QWORD *a1, int a2)
{
  const void **v2;
  const void **v3;
  void *v4;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3)
        return qmi::MutableMessageBase::createTLV<wds::tlv::PdpType3GPP2>(a1, a2);
    }
  }
  if (v2 == v3)
    return qmi::MutableMessageBase::createTLV<wds::tlv::PdpType3GPP2>(a1, a2);
  if (!v4)
    __cxa_bad_cast();
  return (uint64_t)v4 + 12;
}

uint64_t qmi::MutableMessageBase::createTLV<wds::tlv::PdpType3GPP2>(_QWORD *a1, char a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v4 = operator new();
  *(_BYTE *)(v4 + 8) = a2;
  *(_DWORD *)(v4 + 12) = 0;
  *(_QWORD *)v4 = &off_24D5C3C78;
  v5 = a1[3];
  v6 = (uint64_t *)a1[2];
  if ((unint64_t)v6 >= v5)
  {
    v8 = a1[1];
    v9 = ((uint64_t)v6 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v5 - v8;
    v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1))
      v11 = v9 + 1;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v12);
    else
      v13 = 0;
    v14 = (uint64_t *)&v13[8 * v9];
    v15 = &v13[8 * v12];
    *v14 = v4;
    v7 = v14 + 1;
    v17 = (char *)a1[1];
    v16 = (char *)a1[2];
    if (v16 != v17)
    {
      do
      {
        v18 = *((_QWORD *)v16 - 1);
        v16 -= 8;
        *--v14 = v18;
      }
      while (v16 != v17);
      v16 = (char *)a1[1];
    }
    a1[1] = v14;
    a1[2] = v7;
    a1[3] = v15;
    if (v16)
      operator delete(v16);
  }
  else
  {
    *v6 = v4;
    v7 = v6 + 1;
  }
  a1[2] = v7;
  return v4 + 12;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::PdpType3GPP2>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::PdpType3GPP2>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<wds::tlv::PdpType3GPP2>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::IPPref>((_BYTE **)a2, (_DWORD *)(a1 + 12));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::PdpType3GPP2>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C3C78;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a1 + 12);
  return result;
}

uint64_t qmi::MutableMessageBase::getTLV<wds::tlv::ProxyAddrNeeded>(_QWORD *a1, int a2)
{
  const void **v2;
  const void **v3;
  void *v4;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3)
        return qmi::MutableMessageBase::createTLV<wds::tlv::ProxyAddrNeeded>(a1, a2);
    }
  }
  if (v2 == v3)
    return qmi::MutableMessageBase::createTLV<wds::tlv::ProxyAddrNeeded>(a1, a2);
  if (!v4)
    __cxa_bad_cast();
  return (uint64_t)v4 + 9;
}

uint64_t qmi::MutableMessageBase::createTLV<wds::tlv::ProxyAddrNeeded>(_QWORD *a1, char a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v4 = operator new();
  *(_BYTE *)(v4 + 8) = a2;
  *(_BYTE *)(v4 + 9) = 0;
  *(_QWORD *)v4 = &off_24D5C3CC8;
  v5 = a1[3];
  v6 = (uint64_t *)a1[2];
  if ((unint64_t)v6 >= v5)
  {
    v8 = a1[1];
    v9 = ((uint64_t)v6 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v5 - v8;
    v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1))
      v11 = v9 + 1;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v12);
    else
      v13 = 0;
    v14 = (uint64_t *)&v13[8 * v9];
    v15 = &v13[8 * v12];
    *v14 = v4;
    v7 = v14 + 1;
    v17 = (char *)a1[1];
    v16 = (char *)a1[2];
    if (v16 != v17)
    {
      do
      {
        v18 = *((_QWORD *)v16 - 1);
        v16 -= 8;
        *--v14 = v18;
      }
      while (v16 != v17);
      v16 = (char *)a1[1];
    }
    a1[1] = v14;
    a1[2] = v7;
    a1[3] = v15;
    if (v16)
      operator delete(v16);
  }
  else
  {
    *v6 = v4;
    v7 = v6 + 1;
  }
  a1[2] = v7;
  return v4 + 9;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::ProxyAddrNeeded>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::ProxyAddrNeeded>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<wds::tlv::ProxyAddrNeeded>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::ProxyAddrNeeded>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C3CC8;
  return result;
}

uint64_t qmi::MutableMessageBase::getTLV<wds::tlv::RatType>(_QWORD *a1, int a2)
{
  const void **v2;
  const void **v3;
  void *v4;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3)
        return qmi::MutableMessageBase::createTLV<wds::tlv::RatType>(a1, a2);
    }
  }
  if (v2 == v3)
    return qmi::MutableMessageBase::createTLV<wds::tlv::RatType>(a1, a2);
  if (!v4)
    __cxa_bad_cast();
  return (uint64_t)v4 + 12;
}

uint64_t qmi::MutableMessageBase::createTLV<wds::tlv::RatType>(_QWORD *a1, char a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v4 = operator new();
  *(_BYTE *)(v4 + 8) = a2;
  *(_DWORD *)(v4 + 12) = 0;
  *(_QWORD *)v4 = &off_24D5C3D18;
  v5 = a1[3];
  v6 = (uint64_t *)a1[2];
  if ((unint64_t)v6 >= v5)
  {
    v8 = a1[1];
    v9 = ((uint64_t)v6 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v5 - v8;
    v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1))
      v11 = v9 + 1;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v12);
    else
      v13 = 0;
    v14 = (uint64_t *)&v13[8 * v9];
    v15 = &v13[8 * v12];
    *v14 = v4;
    v7 = v14 + 1;
    v17 = (char *)a1[1];
    v16 = (char *)a1[2];
    if (v16 != v17)
    {
      do
      {
        v18 = *((_QWORD *)v16 - 1);
        v16 -= 8;
        *--v14 = v18;
      }
      while (v16 != v17);
      v16 = (char *)a1[1];
    }
    a1[1] = v14;
    a1[2] = v7;
    a1[3] = v15;
    if (v16)
      operator delete(v16);
  }
  else
  {
    *v6 = v4;
    v7 = v6 + 1;
  }
  a1[2] = v7;
  return v4 + 12;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::RatType>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::RatType>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<wds::tlv::RatType>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::IPPref>((_BYTE **)a2, (_DWORD *)(a1 + 12));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::RatType>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C3D18;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a1 + 12);
  return result;
}

uint64_t qmi::MutableMessageBase::getTLV<wds::tlv::InactivityTimer>(_QWORD *a1, int a2)
{
  const void **v2;
  const void **v3;
  void *v4;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3)
        return qmi::MutableMessageBase::createTLV<wds::tlv::InactivityTimer>(a1, a2);
    }
  }
  if (v2 == v3)
    return qmi::MutableMessageBase::createTLV<wds::tlv::InactivityTimer>(a1, a2);
  if (!v4)
    __cxa_bad_cast();
  return (uint64_t)v4 + 12;
}

uint64_t qmi::MutableMessageBase::createTLV<wds::tlv::InactivityTimer>(_QWORD *a1, char a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v4 = operator new();
  *(_BYTE *)(v4 + 8) = a2;
  *(_DWORD *)(v4 + 12) = 0;
  *(_QWORD *)v4 = &off_24D5C3D68;
  v5 = a1[3];
  v6 = (uint64_t *)a1[2];
  if ((unint64_t)v6 >= v5)
  {
    v8 = a1[1];
    v9 = ((uint64_t)v6 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v5 - v8;
    v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1))
      v11 = v9 + 1;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v12);
    else
      v13 = 0;
    v14 = (uint64_t *)&v13[8 * v9];
    v15 = &v13[8 * v12];
    *v14 = v4;
    v7 = v14 + 1;
    v17 = (char *)a1[1];
    v16 = (char *)a1[2];
    if (v16 != v17)
    {
      do
      {
        v18 = *((_QWORD *)v16 - 1);
        v16 -= 8;
        *--v14 = v18;
      }
      while (v16 != v17);
      v16 = (char *)a1[1];
    }
    a1[1] = v14;
    a1[2] = v7;
    a1[3] = v15;
    if (v16)
      operator delete(v16);
  }
  else
  {
    *v6 = v4;
    v7 = v6 + 1;
  }
  a1[2] = v7;
  return v4 + 12;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::InactivityTimer>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::InactivityTimer>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

_DWORD **qmi::MutableMessageBase::TlvWrapper<wds::tlv::InactivityTimer>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _DWORD *v4;
  uint64_t v5;
  _DWORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_DWORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::PktDataHandle>((_DWORD **)a2, (_DWORD *)(a1 + 12));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::InactivityTimer>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C3D68;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a1 + 12);
  return result;
}

uint64_t std::vector<wds::ModifyProfileSettings3GPP2::Request>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v5 = *a1;
  v4 = a1[1];
  result = a2[1];
  while (v4 != v5)
  {
    v4 -= 32;
    result = qmi::MutableMessageBase::MutableMessageBase();
  }
  a2[1] = result;
  v7 = *a1;
  *a1 = result;
  a2[1] = v7;
  v8 = a1[1];
  a1[1] = a2[2];
  a2[2] = v8;
  v9 = a1[2];
  a1[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

void std::__shared_ptr_pointer<QMIAttachApnCommandDriver *,std::shared_ptr<QMIAttachApnCommandDriver> ctu::SharedSynchronizable<AttachApnCommandDriver>::make_shared_ptr<QMIAttachApnCommandDriver>(QMIAttachApnCommandDriver*)::{lambda(QMIAttachApnCommandDriver *)#1},std::allocator<QMIAttachApnCommandDriver>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void std::__shared_ptr_pointer<QMIAttachApnCommandDriver *,std::shared_ptr<QMIAttachApnCommandDriver> ctu::SharedSynchronizable<AttachApnCommandDriver>::make_shared_ptr<QMIAttachApnCommandDriver>(QMIAttachApnCommandDriver*)::{lambda(QMIAttachApnCommandDriver *)#1},std::allocator<QMIAttachApnCommandDriver>>::__on_zero_shared(uint64_t a1)
{
  dispatch_barrier_async_f(*(dispatch_queue_t *)(*(_QWORD *)(a1 + 24) + 24), *(void **)(a1 + 24), (dispatch_function_t)std::shared_ptr<QMIAttachApnCommandDriver> ctu::SharedSynchronizable<AttachApnCommandDriver>::make_shared_ptr<QMIAttachApnCommandDriver>(QMIAttachApnCommandDriver*)::{lambda(QMIAttachApnCommandDriver*)#1}::operator() const(QMIAttachApnCommandDriver*)::{lambda(void *)#1}::__invoke);
}

uint64_t std::__shared_ptr_pointer<QMIAttachApnCommandDriver *,std::shared_ptr<QMIAttachApnCommandDriver> ctu::SharedSynchronizable<AttachApnCommandDriver>::make_shared_ptr<QMIAttachApnCommandDriver>(QMIAttachApnCommandDriver*)::{lambda(QMIAttachApnCommandDriver *)#1},std::allocator<QMIAttachApnCommandDriver>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

BOOL std::type_info::operator==[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a2 + 8);
  if (v2 == v3)
    return 1;
  if ((v3 & v2) < 0 != __OFSUB__(v2, v3))
    return strcmp((const char *)(v2 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL)) == 0;
  return 0;
}

uint64_t std::shared_ptr<QMIAttachApnCommandDriver> ctu::SharedSynchronizable<AttachApnCommandDriver>::make_shared_ptr<QMIAttachApnCommandDriver>(QMIAttachApnCommandDriver*)::{lambda(QMIAttachApnCommandDriver*)#1}::operator() const(QMIAttachApnCommandDriver*)::{lambda(void *)#1}::__invoke(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(_QWORD *)(a1 + 24) = a1;
      (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a2 + 24) + 24))(*(_QWORD *)(a2 + 24), a1);
    }
    else
    {
      *(_QWORD *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 16))(v3);
    }
  }
  else
  {
    *(_QWORD *)(a1 + 24) = 0;
  }
  return a1;
}

_QWORD *ctu::cf::CFSharedRef<__CFArray const>::CFSharedRef<void const,void>(_QWORD *a1, CFTypeRef cf)
{
  CFTypeID v4;

  if (cf && (v4 = CFGetTypeID(cf), v4 == CFArrayGetTypeID()))
  {
    *a1 = cf;
    CFRetain(cf);
  }
  else
  {
    *a1 = 0;
  }
  return a1;
}

_QWORD *ctu::cf::CFSharedRef<__CFDictionary const>::CFSharedRef<void const,void>(_QWORD *a1, CFTypeRef cf)
{
  CFTypeRef v3;
  CFTypeID v4;

  if (cf)
  {
    v3 = cf;
    v4 = CFGetTypeID(cf);
    if (v4 == CFDictionaryGetTypeID())
      cf = v3;
    else
      cf = 0;
  }
  return ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::SharedRef(a1, cf);
}

_QWORD *ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::SharedRef(_QWORD *a1, CFTypeRef cf)
{
  *a1 = cf;
  if (cf)
    CFRetain(cf);
  return a1;
}

void QMIDataContextIPAggregatorInterface::create(uint64_t *a1@<X0>, NSObject **a2@<X1>, _QWORD *a3@<X2>, char **a4@<X3>, uint64_t *a5@<X4>, uint64_t a6@<X5>, uint64_t *a7@<X8>)
{
  int v14;
  char *v15;
  std::__shared_weak_count *v16;
  unint64_t *p_shared_owners;
  unint64_t v18;
  char *DataContextName;
  uint64_t v20;
  uint64_t v21;
  unint64_t *v22;
  unint64_t v23;
  NSObject *v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  std::__shared_weak_count *v30;
  unint64_t v31;
  unint64_t *p_shared_weak_owners;
  unint64_t v33;
  unint64_t v34;
  unint64_t *v35;
  unint64_t v36;
  unint64_t v37;
  std::__shared_weak_count *v38;
  unint64_t *v39;
  unint64_t v40;
  std::__shared_weak_count *v41;
  unint64_t *v42;
  unint64_t v43;
  std::__shared_weak_count *v44;
  unint64_t *v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t v48;
  unint64_t *v49;
  unint64_t v50;
  NSObject *v51;
  std::__shared_weak_count *v52;
  unint64_t *v53;
  unint64_t v54;
  std::__shared_weak_count *v55;
  unint64_t *v56;
  std::__shared_weak_count *v57;
  unint64_t v58;
  unint64_t *v59;
  unint64_t v60;
  unint64_t v61;
  unint64_t *v62;
  unint64_t v63;
  unint64_t v64;
  std::__shared_weak_count *v65;
  unint64_t *v66;
  unint64_t v67;
  std::__shared_weak_count *v68;
  unint64_t *v69;
  unint64_t v70;
  unint64_t *v71;
  char *v72;
  int v73;
  uint64_t v74;
  unint64_t *v75;
  unint64_t v76;
  std::__shared_weak_count *v77;
  unint64_t *v78;
  unint64_t v79;
  std::__shared_weak_count *v80;
  unint64_t *v81;
  unint64_t v82;
  std::__shared_weak_count *v83;
  unint64_t *v84;
  unint64_t v85;
  std::__shared_weak_count *v86;
  unint64_t *v87;
  unint64_t v88;
  uint64_t v89;
  std::__shared_weak_count *v90;
  char *v91;
  std::__shared_weak_count *v92;
  uint64_t v93;
  std::__shared_weak_count *v94;
  dispatch_object_t v95;
  uint64_t v96;
  std::__shared_weak_count *v97;
  uint64_t v98;
  std::__shared_weak_count *v99;
  dispatch_object_t object;
  uint64_t v101;
  std::__shared_weak_count *v102;
  char *v103;
  std::__shared_weak_count *v104;

  *a7 = 0;
  a7[1] = 0;
  v14 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a3 + 56))(*a3);
  v15 = *a4;
  v16 = (std::__shared_weak_count *)a4[1];
  v103 = *a4;
  v104 = v16;
  if (v16)
  {
    p_shared_owners = (unint64_t *)&v16->__shared_owners_;
    do
      v18 = __ldxr(p_shared_owners);
    while (__stxr(v18 + 1, p_shared_owners));
    v15 = *a4;
  }
  (*(void (**)(char *))(*(_QWORD *)&v15[*(_QWORD *)(*(_QWORD *)v15 - 56)] + 24))(&v15[*(_QWORD *)(*(_QWORD *)v15 - 56)]);
  (*(void (**)(char *))(*((_QWORD *)*a4 + 1) + 48))(*a4 + 8);
  DataContextName = (char *)DataUtils::getDataContextName();
  if (capabilities::ct::supports2StepDataCallBringUp((capabilities::ct *)DataContextName))
  {
    v20 = operator new();
    v21 = a1[1];
    v101 = *a1;
    v102 = (std::__shared_weak_count *)v21;
    if (v21)
    {
      v22 = (unint64_t *)(v21 + 8);
      do
        v23 = __ldxr(v22);
      while (__stxr(v23 + 1, v22));
    }
    v24 = *a2;
    object = v24;
    if (v24)
      dispatch_retain(v24);
    v25 = (std::__shared_weak_count *)a3[1];
    v98 = *a3;
    v99 = v25;
    if (v25)
    {
      v26 = (unint64_t *)&v25->__shared_owners_;
      do
        v27 = __ldxr(v26);
      while (__stxr(v27 + 1, v26));
    }
    Mav16QMIDataContextIPAggregator::Mav16QMIDataContextIPAggregator(v20, &v101, &object, DataContextName, &v98);
    v28 = (std::__shared_weak_count *)operator new();
    v28->__shared_owners_ = 0;
    v29 = (unint64_t *)&v28->__shared_owners_;
    v28->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C4018;
    v28->__shared_weak_owners_ = 0;
    v28[1].__vftable = (std::__shared_weak_count_vtbl *)v20;
    v30 = *(std::__shared_weak_count **)(v20 + 32);
    if (v30)
    {
      if (v30->__shared_owners_ != -1)
        goto LABEL_27;
      do
        v31 = __ldxr(v29);
      while (__stxr(v31 + 1, v29));
      p_shared_weak_owners = (unint64_t *)&v28->__shared_weak_owners_;
      do
        v33 = __ldxr(p_shared_weak_owners);
      while (__stxr(v33 + 1, p_shared_weak_owners));
      *(_QWORD *)(v20 + 24) = v20;
      *(_QWORD *)(v20 + 32) = v28;
      std::__shared_weak_count::__release_weak(v30);
    }
    else
    {
      do
        v34 = __ldxr(v29);
      while (__stxr(v34 + 1, v29));
      v35 = (unint64_t *)&v28->__shared_weak_owners_;
      do
        v36 = __ldxr(v35);
      while (__stxr(v36 + 1, v35));
      *(_QWORD *)(v20 + 24) = v20;
      *(_QWORD *)(v20 + 32) = v28;
    }
    do
      v37 = __ldaxr(v29);
    while (__stlxr(v37 - 1, v29));
    if (!v37)
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
LABEL_27:
    v38 = (std::__shared_weak_count *)a7[1];
    *a7 = v20;
    a7[1] = (uint64_t)v28;
    if (v38)
    {
      v39 = (unint64_t *)&v38->__shared_owners_;
      do
        v40 = __ldaxr(v39);
      while (__stlxr(v40 - 1, v39));
      if (!v40)
      {
        ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
        std::__shared_weak_count::__release_weak(v38);
      }
    }
    v41 = v99;
    if (v99)
    {
      v42 = (unint64_t *)&v99->__shared_owners_;
      do
        v43 = __ldaxr(v42);
      while (__stlxr(v43 - 1, v42));
      if (!v43)
      {
        ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
        std::__shared_weak_count::__release_weak(v41);
      }
    }
    if (object)
      dispatch_release(object);
    v44 = v102;
    if (v102)
    {
      v45 = (unint64_t *)&v102->__shared_owners_;
      do
        v46 = __ldaxr(v45);
      while (__stlxr(v46 - 1, v45));
      goto LABEL_79;
    }
    goto LABEL_81;
  }
  v47 = operator new();
  v48 = a1[1];
  v96 = *a1;
  v97 = (std::__shared_weak_count *)v48;
  if (v48)
  {
    v49 = (unint64_t *)(v48 + 8);
    do
      v50 = __ldxr(v49);
    while (__stxr(v50 + 1, v49));
  }
  v51 = *a2;
  v95 = v51;
  if (v51)
    dispatch_retain(v51);
  v52 = (std::__shared_weak_count *)a3[1];
  v93 = *a3;
  v94 = v52;
  if (v52)
  {
    v53 = (unint64_t *)&v52->__shared_owners_;
    do
      v54 = __ldxr(v53);
    while (__stxr(v54 + 1, v53));
  }
  QMIDataContextIPAggregator::QMIDataContextIPAggregator(v47, &v96, &v95, DataContextName, &v93);
  v55 = (std::__shared_weak_count *)operator new();
  v55->__shared_owners_ = 0;
  v56 = (unint64_t *)&v55->__shared_owners_;
  v55->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C4090;
  v55->__shared_weak_owners_ = 0;
  v55[1].__vftable = (std::__shared_weak_count_vtbl *)v47;
  v57 = *(std::__shared_weak_count **)(v47 + 32);
  if (v57)
  {
    if (v57->__shared_owners_ != -1)
      goto LABEL_64;
    do
      v58 = __ldxr(v56);
    while (__stxr(v58 + 1, v56));
    v59 = (unint64_t *)&v55->__shared_weak_owners_;
    do
      v60 = __ldxr(v59);
    while (__stxr(v60 + 1, v59));
    *(_QWORD *)(v47 + 24) = v47;
    *(_QWORD *)(v47 + 32) = v55;
    std::__shared_weak_count::__release_weak(v57);
  }
  else
  {
    do
      v61 = __ldxr(v56);
    while (__stxr(v61 + 1, v56));
    v62 = (unint64_t *)&v55->__shared_weak_owners_;
    do
      v63 = __ldxr(v62);
    while (__stxr(v63 + 1, v62));
    *(_QWORD *)(v47 + 24) = v47;
    *(_QWORD *)(v47 + 32) = v55;
  }
  do
    v64 = __ldaxr(v56);
  while (__stlxr(v64 - 1, v56));
  if (!v64)
  {
    ((void (*)(std::__shared_weak_count *))v55->__on_zero_shared)(v55);
    std::__shared_weak_count::__release_weak(v55);
  }
LABEL_64:
  v65 = (std::__shared_weak_count *)a7[1];
  *a7 = v47;
  a7[1] = (uint64_t)v55;
  if (v65)
  {
    v66 = (unint64_t *)&v65->__shared_owners_;
    do
      v67 = __ldaxr(v66);
    while (__stlxr(v67 - 1, v66));
    if (!v67)
    {
      ((void (*)(std::__shared_weak_count *))v65->__on_zero_shared)(v65);
      std::__shared_weak_count::__release_weak(v65);
    }
  }
  v68 = v94;
  if (v94)
  {
    v69 = (unint64_t *)&v94->__shared_owners_;
    do
      v70 = __ldaxr(v69);
    while (__stlxr(v70 - 1, v69));
    if (!v70)
    {
      ((void (*)(std::__shared_weak_count *))v68->__on_zero_shared)(v68);
      std::__shared_weak_count::__release_weak(v68);
    }
  }
  if (v95)
    dispatch_release(v95);
  v44 = v97;
  if (v97)
  {
    v71 = (unint64_t *)&v97->__shared_owners_;
    do
      v46 = __ldaxr(v71);
    while (__stlxr(v46 - 1, v71));
LABEL_79:
    if (!v46)
    {
      ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
      std::__shared_weak_count::__release_weak(v44);
    }
  }
LABEL_81:
  v72 = v103;
  if (v103)
  {
    v73 = (*(uint64_t (**)(char *))(*(_QWORD *)&v103[*(_QWORD *)(*(_QWORD *)v103 - 56)] + 24))(&v103[*(_QWORD *)(*(_QWORD *)v103 - 56)]);
    v74 = *a7;
    *(_DWORD *)(*a7 + 8) = v73;
  }
  else
  {
    v74 = *a7;
  }
  v91 = v72;
  v92 = v104;
  if (v104)
  {
    v75 = (unint64_t *)&v104->__shared_owners_;
    do
      v76 = __ldxr(v75);
    while (__stxr(v76 + 1, v75));
  }
  v77 = (std::__shared_weak_count *)a5[1];
  v89 = *a5;
  v90 = v77;
  if (v77)
  {
    v78 = (unint64_t *)&v77->__shared_owners_;
    do
      v79 = __ldxr(v78);
    while (__stxr(v79 + 1, v78));
  }
  (*(void (**)(uint64_t, BOOL, char **, uint64_t *, uint64_t))(*(_QWORD *)v74 + 296))(v74, v14 == 0, &v91, &v89, a6);
  v80 = v90;
  if (v90)
  {
    v81 = (unint64_t *)&v90->__shared_owners_;
    do
      v82 = __ldaxr(v81);
    while (__stlxr(v82 - 1, v81));
    if (!v82)
    {
      ((void (*)(std::__shared_weak_count *))v80->__on_zero_shared)(v80);
      std::__shared_weak_count::__release_weak(v80);
    }
  }
  v83 = v92;
  if (v92)
  {
    v84 = (unint64_t *)&v92->__shared_owners_;
    do
      v85 = __ldaxr(v84);
    while (__stlxr(v85 - 1, v84));
    if (!v85)
    {
      ((void (*)(std::__shared_weak_count *))v83->__on_zero_shared)(v83);
      std::__shared_weak_count::__release_weak(v83);
    }
  }
  v86 = v104;
  if (v104)
  {
    v87 = (unint64_t *)&v104->__shared_owners_;
    do
      v88 = __ldaxr(v87);
    while (__stlxr(v88 - 1, v87));
    if (!v88)
    {
      ((void (*)(std::__shared_weak_count *))v86->__on_zero_shared)(v86);
      std::__shared_weak_count::__release_weak(v86);
    }
  }
}

void sub_2168DA628(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13, uint64_t a14, dispatch_object_t object, char a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,char a21)
{
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;

  (*(void (**)(uint64_t))(*(_QWORD *)v22 + 8))(v22);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  if (object)
    dispatch_release(object);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a16);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v23 - 96);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v21);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<Mav16QMIDataContextIPAggregator *,std::shared_ptr<Mav16QMIDataContextIPAggregator>::__shared_ptr_default_delete<Mav16QMIDataContextIPAggregator,Mav16QMIDataContextIPAggregator>,std::allocator<Mav16QMIDataContextIPAggregator>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

uint64_t std::__shared_ptr_pointer<Mav16QMIDataContextIPAggregator *,std::shared_ptr<Mav16QMIDataContextIPAggregator>::__shared_ptr_default_delete<Mav16QMIDataContextIPAggregator,Mav16QMIDataContextIPAggregator>,std::allocator<Mav16QMIDataContextIPAggregator>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t std::__shared_ptr_pointer<Mav16QMIDataContextIPAggregator *,std::shared_ptr<Mav16QMIDataContextIPAggregator>::__shared_ptr_default_delete<Mav16QMIDataContextIPAggregator,Mav16QMIDataContextIPAggregator>,std::allocator<Mav16QMIDataContextIPAggregator>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void std::__shared_ptr_pointer<QMIDataContextIPAggregator *,std::shared_ptr<QMIDataContextIPAggregator>::__shared_ptr_default_delete<QMIDataContextIPAggregator,QMIDataContextIPAggregator>,std::allocator<QMIDataContextIPAggregator>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

uint64_t std::__shared_ptr_pointer<QMIDataContextIPAggregator *,std::shared_ptr<QMIDataContextIPAggregator>::__shared_ptr_default_delete<QMIDataContextIPAggregator,QMIDataContextIPAggregator>,std::allocator<QMIDataContextIPAggregator>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t std::__shared_ptr_pointer<QMIDataContextIPAggregator *,std::shared_ptr<QMIDataContextIPAggregator>::__shared_ptr_default_delete<QMIDataContextIPAggregator,QMIDataContextIPAggregator>,std::allocator<QMIDataContextIPAggregator>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void QMIDataSystemDeterminationManager::create(_QWORD *a1@<X0>, uint64_t a2@<X1>, NSObject **a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v10;
  NSObject *v11;
  NSObject *v12;

  v10 = operator new();
  v11 = *a3;
  v12 = v11;
  if (v11)
    dispatch_retain(v11);
  QMIDataSystemDeterminationManager::QMIDataSystemDeterminationManager(v10, a1, a2, &v12, a4);
  *a5 = 0;
  a5[1] = 0;
  std::shared_ptr<QMIDataSystemDeterminationManager>::shared_ptr[abi:ne180100]<QMIDataSystemDeterminationManager,std::shared_ptr<QMIDataSystemDeterminationManager> ctu::SharedSynchronizable<QMIDataSystemDeterminationManager>::make_shared_ptr<QMIDataSystemDeterminationManager>(QMIDataSystemDeterminationManager*)::{lambda(QMIDataSystemDeterminationManager*)#1},void>(a5, v10);
  if (v11)
    dispatch_release(v11);
}

void sub_2168DA900(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  NSObject *v2;
  int v3;

  if (v2)
    dispatch_release(v2);
  if (v3)
    MEMORY[0x2199FEAC4](v1, 0x10E1C4028274AEDLL);
  _Unwind_Resume(exception_object);
}

uint64_t QMIDataSystemDeterminationManager::QMIDataSystemDeterminationManager(uint64_t a1, _QWORD *a2, uint64_t a3, NSObject **a4, uint64_t a5)
{
  const char *v9;
  NSObject *v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  char *v14;
  NSObject *v15;
  NSObject *v17;
  void *__p;
  char v19;
  _BYTE v20[16];
  _BYTE v21[8];

  *(_QWORD *)a1 = MEMORY[0x24BDC3D38] + 16;
  PersonalitySpecificImpl::PersonalitySpecificImpl();
  *(_QWORD *)a1 = &off_24D5C4280;
  if (PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1) == 1)
    v9 = "DATA.QMI.dsd.1";
  else
    v9 = "DATA.QMI.dsd.2";
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)v20, (const char *)*MEMORY[0x24BDC3E90], v9);
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  v10 = *a4;
  *(_QWORD *)(a1 + 40) = *a4;
  if (v10)
    dispatch_retain(v10);
  *(_QWORD *)(a1 + 48) = 0;
  ctu::OsLogLogger::OsLogLogger();
  ctu::OsLogLogger::OsLogLogger();
  MEMORY[0x2199FDF6C](v21);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v20);
  *(_QWORD *)a1 = &off_24D5C4280;
  *(_QWORD *)(a1 + 64) = *a2;
  v11 = a2[1];
  *(_QWORD *)(a1 + 72) = v11;
  if (v11)
  {
    v12 = (unint64_t *)(v11 + 8);
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }
  if (PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1) == 1)
    v14 = "DATA.QMI.dsd.1";
  else
    v14 = "DATA.QMI.dsd.2";
  std::string::basic_string[abi:ne180100]<0>(&__p, v14);
  v15 = *(NSObject **)(a1 + 40);
  v17 = v15;
  if (v15)
    dispatch_retain(v15);
  ctu::RestModule::RestModule();
  if (v17)
    dispatch_release(v17);
  if (v19 < 0)
    operator delete(__p);
  *(_QWORD *)(a1 + 96) = a5;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_BYTE *)(a1 + 168) = 0;
  *(_QWORD *)(a1 + 184) = 0;
  *(_QWORD *)(a1 + 192) = 0;
  *(_QWORD *)(a1 + 176) = 0;
  *(_BYTE *)(a1 + 200) = 0;
  return a1;
}

void sub_2168DAAE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, dispatch_object_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17)
{
  PersonalitySpecificImpl *v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;

  if (object)
    dispatch_release(object);
  if (a10)
    dispatch_release(a10);
  if (a16 < 0)
    operator delete(__p);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v20);
  MEMORY[0x2199FDF6C](v19);
  ctu::SharedSynchronizable<QMIDataSystemDeterminationManager>::~SharedSynchronizable(v18);
  PersonalitySpecificImpl::~PersonalitySpecificImpl(v17);
  PersonalitySpecific::~PersonalitySpecific(v17);
  _Unwind_Resume(a1);
}

void QMIDataSystemDeterminationManager::~QMIDataSystemDeterminationManager(QMIDataSystemDeterminationManager *this)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  *(_QWORD *)this = &off_24D5C4280;
  QMIDataSystemDeterminationManager::shutdown_sync((uint64_t)this);
  *((_QWORD *)this + 12) = 0;
  v2 = *((_QWORD *)this + 22);
  if (v2)
  {
    v3 = *((_QWORD *)this + 23);
    v4 = (void *)*((_QWORD *)this + 22);
    if (v3 != v2)
    {
      do
      {
        v3 -= 168;
        std::__destroy_at[abi:ne180100]<BasicSimInfo,0>(v3);
      }
      while (v3 != v2);
      v4 = (void *)*((_QWORD *)this + 22);
    }
    *((_QWORD *)this + 23) = v2;
    operator delete(v4);
  }
  qmi::Client::~Client((QMIDataSystemDeterminationManager *)((char *)this + 136));
  qmi::Client::~Client((QMIDataSystemDeterminationManager *)((char *)this + 104));
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)this + 80);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)this + 64);
  MEMORY[0x2199FDF6C]((char *)this + 56);
  ctu::SharedSynchronizable<QMIDataSystemDeterminationManager>::~SharedSynchronizable((_QWORD *)this + 3);
  PersonalitySpecificImpl::~PersonalitySpecificImpl(this);
}

{
  PersonalitySpecific *v1;

  QMIDataSystemDeterminationManager::~QMIDataSystemDeterminationManager(this);
  PersonalitySpecific::~PersonalitySpecific(v1);
}

{
  PersonalitySpecific *v1;

  QMIDataSystemDeterminationManager::~QMIDataSystemDeterminationManager(this);
  PersonalitySpecific::~PersonalitySpecific(v1);
  JUMPOUT(0x2199FEAC4);
}

uint64_t QMIDataSystemDeterminationManager::shutdown_sync(uint64_t this)
{
  _QWORD *v1;

  if (!*(_BYTE *)(this + 168))
  {
    v1 = (_QWORD *)this;
    *(_BYTE *)(this + 168) = 1;
    if (*(_QWORD *)(this + 120))
    {
      qmi::Client::stop((qmi::Client *)(this + 104));
      qmi::Client::release((qmi::Client *)(v1 + 13));
    }
    this = ctu::RestModule::disconnect((ctu::RestModule *)(v1 + 10));
    if (v1[19])
      return qmi::Client::stop((qmi::Client *)(v1 + 17));
  }
  return this;
}

uint64_t QMIDataSystemDeterminationManager::bootstrap(Registry **this)
{
  int v2;
  char *v3;
  NSObject *v4;
  std::__shared_weak_count *v5;
  Registry *v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_weak_owners;
  unint64_t v9;
  uint64_t *p_shared_owners;
  unint64_t v11;
  uint64_t *v12;
  unint64_t v13;
  uint64_t v14;
  capabilities::ct *v15;
  uint64_t result;
  char *v17;
  NSObject *v18;
  std::__shared_weak_count *v19;
  Registry *v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  uint64_t *v24;
  unint64_t v25;
  uint64_t *v26;
  unint64_t v27;
  const char *v28;
  _QWORD v29[5];
  std::__shared_weak_count *v30;
  Registry *v31;
  std::__shared_weak_count *v32;
  dispatch_object_t object;
  uint64_t v34;
  uint64_t v35;
  void (*v36)(uint64_t);
  void *v37;
  Registry **v38;
  uint64_t v39;
  uint64_t v40;
  void (*v41)(uint64_t);
  void *v42;
  Registry **v43;
  std::__shared_weak_count *v44;
  Registry *v45;
  std::__shared_weak_count *v46;
  Registry *v47;
  std::__shared_weak_count *v48;
  void *v49[2];
  char v50;
  dispatch_object_t v51;
  void *v52[2];
  char v53;
  _QWORD v54[2];
  __int128 v55;
  _QWORD *v56;

  v2 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)this);
  if (PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)this) == 1)
    v3 = "DATA.QMI.dsd.1";
  else
    v3 = "DATA.QMI.dsd.2";
  std::string::basic_string[abi:ne180100]<0>(v52, v3);
  v4 = this[5];
  v51 = v4;
  if (v4)
    dispatch_retain(v4);
  std::string::basic_string[abi:ne180100]<0>(v49, "dsd");
  v6 = this[3];
  v5 = (std::__shared_weak_count *)this[4];
  v45 = v6;
  if (!v5 || (v7 = std::__shared_weak_count::lock(v5), (v46 = v7) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v47 = v6;
  v48 = v7;
  p_shared_weak_owners = (unint64_t *)&v7->__shared_weak_owners_;
  do
    v9 = __ldxr(p_shared_weak_owners);
  while (__stxr(v9 + 1, p_shared_weak_owners));
  Registry::getServerConnection(this[8]);
  qmi::Client::createWithQueueLocal();
  std::shared_ptr<qmi::Client::State>::operator=[abi:ne180100]((uint64_t)(this + 15), &v55);
  qmi::Client::~Client((qmi::Client *)v54);
  if (v44)
  {
    p_shared_owners = &v44->__shared_owners_;
    do
      v11 = __ldaxr((unint64_t *)p_shared_owners);
    while (__stlxr(v11 - 1, (unint64_t *)p_shared_owners));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
      std::__shared_weak_count::__release_weak(v44);
    }
  }
  std::__shared_weak_count::__release_weak(v48);
  if (v46)
  {
    v12 = &v46->__shared_owners_;
    do
      v13 = __ldaxr((unint64_t *)v12);
    while (__stlxr(v13 - 1, (unint64_t *)v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
      std::__shared_weak_count::__release_weak(v46);
    }
  }
  if (v50 < 0)
    operator delete(v49[0]);
  if (v51)
    dispatch_release(v51);
  if (v53 < 0)
    operator delete(v52[0]);
  v14 = MEMORY[0x24BDAC760];
  v39 = MEMORY[0x24BDAC760];
  v40 = 0x40000000;
  v41 = ___ZN33QMIDataSystemDeterminationManager9bootstrapEv_block_invoke;
  v42 = &__block_descriptor_tmp_2;
  v43 = this;
  qmi::Client::setHandler();
  v34 = v14;
  v35 = 0x40000000;
  v36 = ___ZN33QMIDataSystemDeterminationManager9bootstrapEv_block_invoke_7;
  v37 = &__block_descriptor_tmp_8_0;
  v38 = this;
  v15 = (capabilities::ct *)qmi::Client::setHandler();
  result = capabilities::ct::supportsDynamicRRCReleaseVersionUpdate(v15);
  if ((_DWORD)result)
  {
    if (v2 == 1)
      v17 = "DATA.QMI.pdc.1";
    else
      v17 = "DATA.QMI.pdc.2";
    std::string::basic_string[abi:ne180100]<0>(v52, v17);
    v18 = this[5];
    object = v18;
    if (v18)
      dispatch_retain(v18);
    std::string::basic_string[abi:ne180100]<0>(v49, "pdc");
    v20 = this[3];
    v19 = (std::__shared_weak_count *)this[4];
    v45 = v20;
    if (!v19 || (v21 = std::__shared_weak_count::lock(v19), (v46 = v21) == 0))
      std::__throw_bad_weak_ptr[abi:ne180100]();
    v31 = v20;
    v32 = v21;
    v22 = (unint64_t *)&v21->__shared_weak_owners_;
    do
      v23 = __ldxr(v22);
    while (__stxr(v23 + 1, v22));
    Registry::getServerConnection(this[8]);
    qmi::Client::createWithQueueLocal();
    std::shared_ptr<qmi::Client::State>::operator=[abi:ne180100]((uint64_t)(this + 19), &v55);
    qmi::Client::~Client((qmi::Client *)v54);
    if (v30)
    {
      v24 = &v30->__shared_owners_;
      do
        v25 = __ldaxr((unint64_t *)v24);
      while (__stlxr(v25 - 1, (unint64_t *)v24));
      if (!v25)
      {
        ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
        std::__shared_weak_count::__release_weak(v30);
      }
    }
    std::__shared_weak_count::__release_weak(v32);
    if (v46)
    {
      v26 = &v46->__shared_owners_;
      do
        v27 = __ldaxr((unint64_t *)v26);
      while (__stlxr(v27 - 1, (unint64_t *)v26));
      if (!v27)
      {
        ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
        std::__shared_weak_count::__release_weak(v46);
      }
    }
    if (v50 < 0)
      operator delete(v49[0]);
    if (object)
      dispatch_release(object);
    if (v53 < 0)
      operator delete(v52[0]);
    v28 = (const char *)*MEMORY[0x24BED1E20];
    subscriber::simSlotAsInstance();
    qmi::Client::set((qmi::Client *)(this + 17), v28);
    v29[0] = v14;
    v29[1] = 0x40000000;
    v29[2] = ___ZN33QMIDataSystemDeterminationManager9bootstrapEv_block_invoke_10;
    v29[3] = &__block_descriptor_tmp_12;
    v29[4] = this;
    v54[0] = v14;
    v54[1] = 0x40000000;
    *(_QWORD *)&v55 = ___ZNK3qmi6Client13setIndHandlerIRKN3pdc14ActivateConfig10IndicationEEEvtU13block_pointerFvT_E_block_invoke;
    *((_QWORD *)&v55 + 1) = &unk_24D5C4668;
    v56 = v29;
    qmi::Client::setIndHandler();
    return qmi::Client::setIndShouldWake((qmi::Client *)(this + 17));
  }
  return result;
}

void sub_2168DB104(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17, dispatch_object_t object, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,char a31)
{
  uint64_t v31;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a14);
  if (a17)
    std::__shared_weak_count::__release_weak(a17);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a31);
  if (*(char *)(v31 - 137) < 0)
    operator delete(*(void **)(v31 - 160));
  if (object)
    dispatch_release(object);
  if (*(char *)(v31 - 105) < 0)
    operator delete(*(void **)(v31 - 128));
  _Unwind_Resume(a1);
}

void ___ZN33QMIDataSystemDeterminationManager9bootstrapEv_block_invoke(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  uint64_t v3;
  capabilities::ct *v4;
  capabilities::ct *ShouldWake;
  capabilities::ct *v6;
  capabilities::ct *v7;
  capabilities::ct *v8;
  int v9;
  uint64_t v10;
  int v11;
  const void **v12;
  char *v13;
  int *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  char *v22;
  uint64_t *v23;
  char *v24;
  char *v25;
  char *v26;
  uint64_t v27;
  _QWORD *v28;
  uint64_t v29;
  void *v30;
  uint64_t v31;
  _QWORD *v32;
  uint64_t v33;
  _QWORD *v34;
  uint64_t v35;
  _QWORD v36[5];
  _QWORD v37[5];
  _QWORD v38[5];
  _QWORD v39[5];
  _QWORD v40[16];
  uint64_t v41;
  int v42;
  uint64_t v43;
  void *v44;
  void *__p[2];
  __int128 v46;
  _QWORD aBlock[5];
  _QWORD v48[3];
  _QWORD *v49;
  _QWORD v50[3];
  _QWORD *v51;
  uint8_t buf[8];
  uint64_t v53;
  void *v54;
  void *v55;
  _QWORD *v56;
  _BYTE v57[24];
  _BYTE *v58;
  uint64_t v59;

  v59 = *MEMORY[0x24BDAC8D0];
  v1 = *(_QWORD *)(a1 + 32);
  if (*(_BYTE *)(v1 + 168))
  {
    v2 = *(NSObject **)(v1 + 56);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_216897000, v2, OS_LOG_TYPE_DEFAULT, "#N DSD client started in shutdown state", buf, 2u);
    }
    return;
  }
  v3 = MEMORY[0x24BDAC760];
  v40[10] = MEMORY[0x24BDAC760];
  v40[11] = 0x40000000;
  v40[12] = ___ZN33QMIDataSystemDeterminationManager27handleQMIClientStarted_syncEv_block_invoke;
  v40[13] = &__block_descriptor_tmp_13;
  v40[14] = v1;
  qmi::Client::setHandler();
  v40[5] = v3;
  v40[6] = 0x40000000;
  v40[7] = ___ZN33QMIDataSystemDeterminationManager27handleQMIClientStarted_syncEv_block_invoke_2;
  v40[8] = &__block_descriptor_tmp_14;
  v40[9] = v1;
  qmi::Client::setHandler();
  v40[0] = v3;
  v40[1] = 0x40000000;
  v40[2] = ___ZN33QMIDataSystemDeterminationManager27handleQMIClientStarted_syncEv_block_invoke_3;
  v40[3] = &__block_descriptor_tmp_15_0;
  v40[4] = v1;
  *(_QWORD *)buf = v3;
  v53 = 0x40000000;
  v54 = ___ZNK3qmi6Client13setIndHandlerIRKN3dsd18SystemStatusReport10IndicationEEEvtU13block_pointerFvT_E_block_invoke;
  v55 = &unk_24D5C4720;
  v56 = v40;
  v4 = (capabilities::ct *)qmi::Client::setIndHandler();
  ShouldWake = (capabilities::ct *)capabilities::ct::supportsUplinkHealthUpdate(v4);
  if ((_DWORD)ShouldWake)
  {
    v39[0] = v3;
    v39[1] = 0x40000000;
    v39[2] = ___ZN33QMIDataSystemDeterminationManager27handleQMIClientStarted_syncEv_block_invoke_4;
    v39[3] = &__block_descriptor_tmp_16;
    v39[4] = v1;
    *(_QWORD *)buf = v3;
    v53 = 0x40000000;
    v54 = ___ZNK3qmi6Client13setIndHandlerIRKN3dsd12UplinkHealth10IndicationEEEvtU13block_pointerFvT_E_block_invoke;
    v55 = &unk_24D5C4748;
    v56 = v39;
    qmi::Client::setIndHandler();
    ShouldWake = (capabilities::ct *)qmi::Client::setIndShouldWake((qmi::Client *)(v1 + 104));
  }
  v6 = (capabilities::ct *)capabilities::ct::supports5G(ShouldWake);
  if ((_DWORD)v6)
  {
    v38[0] = v3;
    v38[1] = 0x40000000;
    v38[2] = ___ZN33QMIDataSystemDeterminationManager27handleQMIClientStarted_syncEv_block_invoke_5;
    v38[3] = &__block_descriptor_tmp_17;
    v38[4] = v1;
    *(_QWORD *)buf = v3;
    v53 = 0x40000000;
    v54 = ___ZNK3qmi6Client13setIndHandlerIRKN3dsd6UiInfo10IndicationEEEvtU13block_pointerFvT_E_block_invoke;
    v55 = &unk_24D5C4770;
    v56 = v38;
    qmi::Client::setIndHandler();
    v37[0] = v3;
    v37[1] = 0x40000000;
    v37[2] = ___ZN33QMIDataSystemDeterminationManager27handleQMIClientStarted_syncEv_block_invoke_6;
    v37[3] = &__block_descriptor_tmp_18_0;
    v37[4] = v1;
    *(_QWORD *)buf = v3;
    v53 = 0x40000000;
    v54 = ___ZNK3qmi6Client13setIndHandlerIRKN3dsd22ThroughputEstimateInfo10IndicationEEEvtU13block_pointerFvT_E_block_invoke;
    v55 = &unk_24D5C4798;
    v56 = v37;
    v6 = (capabilities::ct *)qmi::Client::setIndHandler();
  }
  v7 = (capabilities::ct *)capabilities::ct::supportsDynamicRRCReleaseVersionUpdate(v6);
  if ((_DWORD)v7)
  {
    v36[0] = v3;
    v36[1] = 0x40000000;
    v36[2] = ___ZN33QMIDataSystemDeterminationManager27handleQMIClientStarted_syncEv_block_invoke_7;
    v36[3] = &__block_descriptor_tmp_19;
    v36[4] = v1;
    *(_QWORD *)buf = v3;
    v53 = 0x40000000;
    v54 = ___ZNK3qmi6Client13setIndHandlerIRKN3dsd24DynamicRRCReleaseVersion10IndicationEEEvtU13block_pointerFvT_E_block_invoke;
    v55 = &unk_24D5C47C0;
    v56 = v36;
    qmi::Client::setIndHandler();
    v7 = (capabilities::ct *)qmi::Client::setIndShouldWake((qmi::Client *)(v1 + 104));
  }
  v8 = (capabilities::ct *)capabilities::ct::supportsUplinkHealthUpdate(v7);
  if ((_DWORD)v8)
  {
    *(_BYTE *)(v1 + 200) = 0;
    v8 = (capabilities::ct *)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(v1 + 96) + 48))(*(_QWORD *)(v1 + 96), 0);
  }
  v50[0] = &off_24D5C47F0;
  v50[1] = v1;
  v50[2] = 0;
  v51 = v50;
  v9 = capabilities::ct::supportsGemini(v8);
  v10 = (uint64_t)v51;
  if (!v9)
  {
    if (!v51)
      std::__throw_bad_function_call[abi:ne180100]();
    (*(void (**)(_QWORD *))(*v51 + 48))(v51);
    goto LABEL_66;
  }
  if (!v51)
    goto LABEL_16;
  if (v51 != v50)
  {
    v10 = (*(uint64_t (**)(_QWORD *))(*v51 + 16))(v51);
LABEL_16:
    v49 = (_QWORD *)v10;
    goto LABEL_20;
  }
  v49 = v48;
  (*(void (**)(_QWORD *, _QWORD *))(v50[0] + 24))(v50, v48);
LABEL_20:
  PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)v1);
  subscriber::simSlotAsInstance();
  qmi::Client::set((qmi::Client *)(v1 + 104), (const char *)*MEMORY[0x24BED1E20]);
  *(_OWORD *)__p = 0u;
  v46 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  if (PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)v1) == 2)
    v11 = 2;
  else
    v11 = 1;
  v12 = (const void **)__p[1];
  if (__p[1] != (void *)v46)
  {
    while (*((_BYTE *)*v12 + 8) != 1)
    {
      if (++v12 == (const void **)v46)
        goto LABEL_30;
    }
  }
  if (v12 == (const void **)v46)
  {
LABEL_30:
    v15 = operator new();
    v16 = v15;
    *(_BYTE *)(v15 + 8) = 1;
    *(_QWORD *)v15 = &off_24D5C48D8;
    *(_DWORD *)(v15 + 12) = 0;
    v14 = (int *)(v15 + 12);
    v17 = v46;
    if ((unint64_t)v46 >= *((_QWORD *)&v46 + 1))
    {
      v19 = (uint64_t)(v46 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v19 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v20 = (uint64_t)(*((_QWORD *)&v46 + 1) - (unint64_t)__p[1]) >> 2;
      if (v20 <= v19 + 1)
        v20 = v19 + 1;
      if (*((_QWORD *)&v46 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v21 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v21 = v20;
      if (v21)
        v22 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v46 + 8, v21);
      else
        v22 = 0;
      v23 = (uint64_t *)&v22[8 * v19];
      v24 = &v22[8 * v21];
      *v23 = v16;
      v18 = v23 + 1;
      v26 = (char *)__p[1];
      v25 = (char *)v46;
      if ((void *)v46 != __p[1])
      {
        do
        {
          v27 = *((_QWORD *)v25 - 1);
          v25 -= 8;
          *--v23 = v27;
        }
        while (v25 != v26);
        v25 = (char *)__p[1];
      }
      __p[1] = v23;
      *(_QWORD *)&v46 = v18;
      *((_QWORD *)&v46 + 1) = v24;
      if (v25)
        operator delete(v25);
    }
    else
    {
      *(_QWORD *)v46 = v15;
      v18 = (_QWORD *)(v17 + 8);
    }
    *(_QWORD *)&v46 = v18;
  }
  else
  {
    if (!v13)
      __cxa_bad_cast();
    v14 = (int *)(v13 + 12);
  }
  *v14 = v11;
  v40[15] = v1 + 104;
  v41 = QMIServiceMsg::create();
  v42 = 25000;
  v43 = 0;
  v44 = 0;
  *(_QWORD *)buf = v3;
  v53 = 1174405120;
  v54 = ___ZN33QMIDataSystemDeterminationManager21bindSubscription_syncENSt3__18functionIFvvEEE_block_invoke;
  v55 = &__block_descriptor_tmp_20;
  v56 = (_QWORD *)v1;
  v28 = v57;
  v29 = (uint64_t)v49;
  if (!v49)
    goto LABEL_50;
  if (v49 != v48)
  {
    v29 = (*(uint64_t (**)(_QWORD *))(*v49 + 16))(v49);
LABEL_50:
    v58 = (_BYTE *)v29;
    goto LABEL_52;
  }
  v58 = v57;
  (*(void (**)(_QWORD *, _BYTE *))(v48[0] + 24))(v48, v57);
LABEL_52:
  aBlock[0] = v3;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_0;
  aBlock[3] = &unk_24D5C4908;
  aBlock[4] = buf;
  v30 = _Block_copy(aBlock);
  v44 = v30;
  if (v41)
  {
    qmi::Client::send();
    v30 = v44;
  }
  if (v30)
    _Block_release(v30);
  if (v58 == v57)
  {
    v31 = 4;
  }
  else
  {
    if (!v58)
      goto LABEL_61;
    v31 = 5;
    v28 = v58;
  }
  (*(void (**)(_QWORD *))(*v28 + 8 * v31))(v28);
LABEL_61:
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
  v32 = v49;
  if (v49 == v48)
  {
    v33 = 4;
    v32 = v48;
    goto LABEL_65;
  }
  if (v49)
  {
    v33 = 5;
LABEL_65:
    (*(void (**)(void))(*v32 + 8 * v33))();
  }
LABEL_66:
  v34 = v51;
  if (v51 == v50)
  {
    v35 = 4;
    v34 = v50;
  }
  else
  {
    if (!v51)
      return;
    v35 = 5;
  }
  (*(void (**)(void))(*v34 + 8 * v35))();
}

void sub_2168DB888(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,void *aBlock,char a49)
{
  uint64_t v49;
  _QWORD *v51;
  uint64_t v52;
  _QWORD *v53;
  uint64_t v54;

  if (a45)
    qmi::Client::send();
  if (aBlock)
    _Block_release(aBlock);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a49);
  v51 = *(_QWORD **)(v49 - 200);
  if (v51 == (_QWORD *)(v49 - 224))
  {
    v52 = 4;
    v51 = (_QWORD *)(v49 - 224);
  }
  else
  {
    if (!v51)
      goto LABEL_10;
    v52 = 5;
  }
  (*(void (**)(void))(*v51 + 8 * v52))();
LABEL_10:
  v53 = *(_QWORD **)(v49 - 168);
  if (v53 == (_QWORD *)(v49 - 192))
  {
    v54 = 4;
    v53 = (_QWORD *)(v49 - 192);
  }
  else
  {
    if (!v53)
      goto LABEL_15;
    v54 = 5;
  }
  (*(void (**)(void))(*v53 + 8 * v54))();
LABEL_15:
  _Unwind_Resume(a1);
}

void ___ZN33QMIDataSystemDeterminationManager9bootstrapEv_block_invoke_7(uint64_t a1)
{
  NSObject *v1;
  uint8_t v2[16];

  v1 = *(NSObject **)(*(_QWORD *)(a1 + 32) + 56);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v2 = 0;
    _os_log_impl(&dword_216897000, v1, OS_LOG_TYPE_DEFAULT, "#I DSD client stopped", v2, 2u);
  }
}

void ___ZN33QMIDataSystemDeterminationManager9bootstrapEv_block_invoke_10(uint64_t a1, qmi::MessageBase *a2)
{
  PersonalitySpecificImpl *v3;
  int v4;
  void *TlvValue;
  int v6;
  void *v7;
  int v8;
  unsigned __int16 v9;
  unsigned __int16 v10;
  NSObject *v11;
  const char *v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  int v18;
  subscriber *v19;
  NSObject *v20;
  uint64_t v21;
  const char *v22;
  uint64_t v23;
  xpc_object_t object;
  xpc_object_t v25;
  _BYTE buf[12];
  __int16 v27;
  int v28;
  __int16 v29;
  uint64_t v30;
  uint64_t v31;

  v31 = *MEMORY[0x24BDAC8D0];
  v3 = *(PersonalitySpecificImpl **)(a1 + 32);
  v4 = PersonalitySpecificImpl::simSlot(v3);
  TlvValue = (void *)qmi::MessageBase::findTlvValue(a2);
  if (TlvValue)
  {
    v7 = TlvValue;
    v8 = v6;
    v25 = TlvValue;
    v9 = tlv::parseV<pdc::tlv::ErrorCode>((unint64_t *)&v25, v6);
    if (v25)
    {
      v10 = v9;
      if (v9)
      {
        v11 = *((_QWORD *)v3 + 7);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        {
          v12 = pdc::asString(v10);
          v13 = *((_DWORD *)a2 + 1);
          v14 = qmi::asString();
          *(_DWORD *)buf = 136315650;
          *(_QWORD *)&buf[4] = v12;
          v27 = 1024;
          v28 = v13;
          v29 = 2080;
          v30 = v14;
          _os_log_error_impl(&dword_216897000, v11, OS_LOG_TYPE_ERROR, "PDC activate configuration indication for Dynamic RRC failed. Type: %s, error: %d (%s)", buf, 0x1Cu);
        }
      }
      else
      {
        v15 = qmi::MessageBase::findTlvValue(a2);
        v17 = v15;
        if (v15)
        {
          v18 = v16;
          *(_QWORD *)buf = v15;
          v19 = (subscriber *)tlv::parseV<pdc::tlv::IndicationToken>((unint64_t *)buf, v16);
          if (*(_QWORD *)buf)
          {
            LODWORD(v17) = subscriber::instanceAsSimSlot(v19);
          }
          else
          {
            ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 16, v17, v18);
            LODWORD(v17) = 0;
          }
        }
        v20 = *((_QWORD *)v3 + 7);
        if ((_DWORD)v17 == v4)
        {
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl(&dword_216897000, v20, OS_LOG_TYPE_DEFAULT, "#I PDC activate configuration indication for Dynamic RRC completed successfully", buf, 2u);
          }
          v25 = 0;
          v21 = subscriber::asString();
          ctu::rest::detail::write_enum_string_value((ctu::rest::detail *)v4, v21, v22);
          std::string::basic_string[abi:ne180100]<0>(buf, "/cc/events/baseband_refresh_complete");
          object = v25;
          v25 = xpc_null_create();
          ctu::RestModule::sendEvent();
          xpc_release(object);
          if (SBYTE3(v30) < 0)
            operator delete(*(void **)buf);
          xpc_release(v25);
        }
        else if (os_log_type_enabled(v20, OS_LOG_TYPE_FAULT))
        {
          v23 = subscriber::asString();
          *(_DWORD *)buf = 136315138;
          *(_QWORD *)&buf[4] = v23;
          _os_log_fault_impl(&dword_216897000, v20, OS_LOG_TYPE_FAULT, "Received PDC activate configuration indication for Dynamic RRC (%s) for wrong slot", buf, 0xCu);
        }
      }
    }
    else
    {
      ((void (*)(_QWORD, uint64_t, void *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 1, v7, v8);
    }
  }
}

void sub_2168DBC98(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, xpc_object_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

Registry **QMIDataSystemDeterminationManager::start(Registry **this)
{
  Registry **v1;
  unint64_t *p_shared_owners;
  unint64_t v3;
  std::__shared_weak_count *v4;

  if (!*((_BYTE *)this + 168))
  {
    v1 = this;
    if (capabilities::ct::supportsDynamicRRCReleaseVersionUpdate((capabilities::ct *)this))
    {
      Registry::createRestModuleOneTimeUseConnection(v1[8]);
      ctu::RestModule::connect();
      if (v4)
      {
        p_shared_owners = (unint64_t *)&v4->__shared_owners_;
        do
          v3 = __ldaxr(p_shared_owners);
        while (__stlxr(v3 - 1, p_shared_owners));
        if (!v3)
        {
          ((void (*)())v4->__on_zero_shared)();
          std::__shared_weak_count::__release_weak(v4);
        }
      }
      ctu::rest::property_sink_t<rest::sims_in_use>::bind((uint64_t)(v1 + 22));
      qmi::Client::start((qmi::Client *)(v1 + 17));
    }
    return (Registry **)qmi::Client::start((qmi::Client *)(v1 + 13));
  }
  return this;
}

void sub_2168DBDA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void ctu::rest::property_sink_t<rest::sims_in_use>::bind(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  void *__p;
  char v5;
  _QWORD v6[3];
  _QWORD *v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  std::string::basic_string[abi:ne180100]<0>(&__p, "/cc/props/sims_in_use");
  v6[0] = &off_24D5C4698;
  v6[1] = a1;
  v7 = v6;
  ctu::RestModule::observeProperty();
  v2 = v7;
  if (v7 == v6)
  {
    v3 = 4;
    v2 = v6;
  }
  else
  {
    if (!v7)
      goto LABEL_6;
    v3 = 5;
  }
  (*(void (**)(void))(*v2 + 8 * v3))();
LABEL_6:
  if (v5 < 0)
    operator delete(__p);
}

void sub_2168DBE7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, uint64_t a16, uint64_t a17, char *a18)
{
  char *v18;
  char *v20;
  uint64_t v21;

  v20 = a18;
  if (a18 == v18)
  {
    v21 = 4;
    v20 = &a15;
  }
  else
  {
    if (!a18)
      goto LABEL_6;
    v21 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v20 + 8 * v21))();
LABEL_6:
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void ___ZN33QMIDataSystemDeterminationManager27handleQMIClientStarted_syncEv_block_invoke(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  uint8_t v3[16];

  v1 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)(v1 + 168))
  {
    v2 = *(NSObject **)(v1 + 56);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v3 = 0;
      _os_log_impl(&dword_216897000, v2, OS_LOG_TYPE_DEFAULT, "#I Disable system status change report due to entering low power", v3, 2u);
    }
    QMIDataSystemDeterminationManager::sendSystemStatusChangeRequest_sync((QMIDataSystemDeterminationManager *)v1, 0);
  }
}

void ___ZN33QMIDataSystemDeterminationManager27handleQMIClientStarted_syncEv_block_invoke_2(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  capabilities::ct *v3;
  capabilities::ct *v4;
  void *v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  void (*v9)(uint64_t, qmi::MessageBase *);
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  void *aBlock;
  __int128 v17;
  __int128 v18;
  uint8_t buf[8];
  uint64_t v20;
  void (*v21)(uint64_t, QMIServiceMsg *);
  void *v22;
  uint64_t *v23;

  v1 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)(v1 + 168))
  {
    v2 = *(NSObject **)(v1 + 56);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_216897000, v2, OS_LOG_TYPE_DEFAULT, "#I Enable system status change report due to exiting low power", buf, 2u);
    }
    QMIDataSystemDeterminationManager::sendSystemStatusChangeRequest_sync((QMIDataSystemDeterminationManager *)v1, 1);
    QMIDataSystemDeterminationManager::sendGetCurrentDataSystemStatusRequest_sync((QMIDataSystemDeterminationManager *)v1);
    v4 = (capabilities::ct *)capabilities::ct::supports5G(v3);
    if ((_DWORD)v4)
    {
      v17 = 0u;
      v18 = 0u;
      qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)&v17);
      v12 = v1 + 104;
      v13 = QMIServiceMsg::create();
      v14 = 25000;
      v15 = 0;
      aBlock = 0;
      v7 = MEMORY[0x24BDAC760];
      v8 = 0x40000000;
      v9 = ___ZN33QMIDataSystemDeterminationManager18sendGetUiInfo_syncEv_block_invoke;
      v10 = &__block_descriptor_tmp_23;
      v11 = v1;
      *(_QWORD *)buf = MEMORY[0x24BDAC760];
      v20 = 0x40000000;
      v21 = ___ZNO3qmi6Client9SendProxy8callbackIRKN3dsd9GetUiInfo8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
      v22 = &unk_24D5C49D0;
      v23 = &v7;
      v5 = _Block_copy(buf);
      aBlock = v5;
      if (v13)
      {
        qmi::Client::send();
        v5 = aBlock;
      }
      if (v5)
        _Block_release(v5);
      qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&v17);
    }
    if (capabilities::ct::supports5G(v4))
    {
      v17 = 0u;
      v18 = 0u;
      qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)&v17);
      v12 = v1 + 104;
      v13 = QMIServiceMsg::create();
      v14 = 25000;
      v15 = 0;
      aBlock = 0;
      v7 = MEMORY[0x24BDAC760];
      v8 = 0x40000000;
      v9 = ___ZN33QMIDataSystemDeterminationManager25sendGetBandwidthInfo_syncEv_block_invoke;
      v10 = &__block_descriptor_tmp_26;
      v11 = v1;
      *(_QWORD *)buf = MEMORY[0x24BDAC760];
      v20 = 0x40000000;
      v21 = ___ZNO3qmi6Client9SendProxy8callbackIRKN3dsd22ThroughputEstimateInfo8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
      v22 = &unk_24D5C4E00;
      v23 = &v7;
      v6 = _Block_copy(buf);
      aBlock = v6;
      if (v13)
      {
        qmi::Client::send();
        v6 = aBlock;
      }
      if (v6)
        _Block_release(v6);
      qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&v17);
    }
  }
}

void sub_2168DC144(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *aBlock, char a19)
{
  if (a15)
    qmi::Client::send();
  if (aBlock)
    _Block_release(aBlock);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a19);
  _Unwind_Resume(a1);
}

void ___ZN33QMIDataSystemDeterminationManager27handleQMIClientStarted_syncEv_block_invoke_3(uint64_t a1, qmi::MessageBase *this)
{
  uint64_t v2;
  char *TlvValue;
  int v5;
  char *v6;
  int v7;
  char *v8;
  void *__p[2];
  __int128 v10;
  char *v11;

  v2 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)(v2 + 168))
  {
    if (*(_QWORD *)(v2 + 96))
    {
      TlvValue = (char *)qmi::MessageBase::findTlvValue(this);
      if (TlvValue)
      {
        v6 = TlvValue;
        v7 = v5;
        v11 = TlvValue;
        *(_OWORD *)__p = 0u;
        v10 = 0u;
        tlv::parseV<dsd::tlv::DataSystemStatus>(&v11, v5, __p);
        v8 = v11;
        if (v11)
          (*(void (**)(_QWORD, void **))(**(_QWORD **)(v2 + 96) + 16))(*(_QWORD *)(v2 + 96), __p);
        if (__p[1])
        {
          *(void **)&v10 = __p[1];
          operator delete(__p[1]);
        }
        if (!v8)
          ((void (*)(_QWORD, uint64_t, char *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)this, 16, v6, v7);
      }
    }
  }
}

void sub_2168DC288(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t ___ZN33QMIDataSystemDeterminationManager27handleQMIClientStarted_syncEv_block_invoke_4(uint64_t result, qmi::MessageBase *a2)
{
  uint64_t v2;
  NSObject *v4;
  _BOOL8 v5;
  unsigned __int8 v6;
  int v7;
  uint64_t v8;
  int v9;
  int v10;
  NSObject *v11;
  uint64_t v12;
  __int16 v13;
  int v14;
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(result + 32);
  if (!*(_BYTE *)(v2 + 168))
  {
    v4 = *(NSObject **)(v2 + 56);
    v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
    if (v5)
    {
      LOWORD(v12) = 0;
      _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I Received DSD UL Congestion Indication", (uint8_t *)&v12, 2u);
    }
    result = capabilities::ct::supportsUplinkHealthUpdate((capabilities::ct *)v5);
    if ((_DWORD)result)
    {
      v6 = *(_BYTE *)(v2 + 200);
      result = qmi::MessageBase::findTlvValue(a2);
      if (result)
      {
        v8 = result;
        v9 = v7;
        v12 = result;
        result = tlv::parseV<dsd::tlv::UplinkEmergencyBottleneck>((unint64_t *)&v12, v7);
        if (v12)
          v6 = result;
        else
          result = ((uint64_t (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 17, v8, v9);
      }
      v10 = *(unsigned __int8 *)(v2 + 200);
      if (v10 != v6)
      {
        v11 = *(NSObject **)(v2 + 56);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(v12) = 67109376;
          HIDWORD(v12) = v10;
          v13 = 1024;
          v14 = v6;
          _os_log_impl(&dword_216897000, v11, OS_LOG_TYPE_DEFAULT, "#I UL Emergency Bottleneck state change from %d to %d", (uint8_t *)&v12, 0xEu);
        }
        *(_BYTE *)(v2 + 200) = v6;
        return (*(uint64_t (**)(_QWORD, BOOL))(**(_QWORD **)(v2 + 96) + 48))(*(_QWORD *)(v2 + 96), v6 != 0);
      }
    }
  }
  return result;
}

uint64_t ___ZN33QMIDataSystemDeterminationManager27handleQMIClientStarted_syncEv_block_invoke_6(uint64_t result, qmi::MessageBase *this)
{
  uint64_t v2;
  uint64_t TlvValue;
  int v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  unsigned __int8 v20;
  unsigned __int8 v21;
  NSObject *v22;
  const char *v23;
  uint64_t v24;
  __int16 v25;
  int v26;
  __int16 v27;
  const char *v28;
  uint64_t v29;

  v29 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(result + 32);
  if (*(_BYTE *)(v2 + 168) || !*(_QWORD *)(v2 + 96))
    return result;
  TlvValue = qmi::MessageBase::findTlvValue(this);
  if (TlvValue)
  {
    v6 = TlvValue;
    v7 = v5;
    v24 = TlvValue;
    v8 = tlv::parseV<dsd::tlv::Uplink>((unint64_t *)&v24, v5);
    if (v24)
    {
      v9 = v8;
      goto LABEL_8;
    }
    ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)this, 16, v6, v7);
  }
  v9 = 0;
LABEL_8:
  v10 = qmi::MessageBase::findTlvValue(this);
  if (v10)
  {
    v12 = v10;
    v13 = v11;
    v24 = v10;
    v14 = tlv::parseV<dsd::tlv::Downlink>((unint64_t *)&v24, v11);
    if (v24)
    {
      v15 = v14;
      goto LABEL_13;
    }
    ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)this, 17, v12, v13);
  }
  v15 = 0;
LABEL_13:
  v16 = qmi::MessageBase::findTlvValue(this);
  if (!v16)
  {
LABEL_17:
    v21 = 0;
    goto LABEL_18;
  }
  v18 = v16;
  v19 = v17;
  v24 = v16;
  v20 = tlv::parseV<dsd::tlv::RAT>((unint64_t *)&v24, v17);
  if (!v24)
  {
    ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)this, 18, v18, v19);
    goto LABEL_17;
  }
  v21 = v20;
LABEL_18:
  v22 = *(NSObject **)(v2 + 56);
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    v23 = dsd::asString(v21);
    LODWORD(v24) = 67109634;
    HIDWORD(v24) = v9;
    v25 = 1024;
    v26 = v15;
    v27 = 2080;
    v28 = v23;
    _os_log_impl(&dword_216897000, v22, OS_LOG_TYPE_DEFAULT, "#I Throughput estimate info received. up: %u Kbps, dl: %u Kbps, rat: %s", (uint8_t *)&v24, 0x18u);
  }
  return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, _QWORD))(**(_QWORD **)(v2 + 96) + 32))(*(_QWORD *)(v2 + 96), v9, v15, v21);
}

void ___ZN33QMIDataSystemDeterminationManager27handleQMIClientStarted_syncEv_block_invoke_7(uint64_t a1, qmi::MessageBase *this)
{
  uint64_t v2;
  uint64_t TlvValue;
  int v5;
  uint64_t v6;
  int v7;
  unsigned __int8 v8;
  unsigned __int8 v9;
  NSObject *v10;
  int v11;
  _DWORD *v12;
  _DWORD *v13;
  _DWORD *v14;
  _DWORD *v15;
  unsigned int v16;
  _DWORD *v17;
  void *v18;
  unint64_t v19[2];
  uint64_t v20;
  int v21;
  uint64_t v22;
  void *v23;
  _OWORD v24[2];
  _QWORD aBlock[5];
  uint8_t buf[8];
  uint64_t v27;
  void (*v28)(uint64_t, uint64_t);
  void *v29;
  uint64_t v30;
  int v31;
  uint64_t v32;

  v32 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)(v2 + 168))
  {
    TlvValue = qmi::MessageBase::findTlvValue(this);
    if (TlvValue)
    {
      v6 = TlvValue;
      v7 = v5;
      v19[0] = TlvValue;
      v8 = tlv::parseV<dsd::tlv::Reason>(v19, v5);
      if (v19[0])
      {
        v9 = v8;
        v10 = *(NSObject **)(v2 + 56);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&buf[4] = v9;
          _os_log_impl(&dword_216897000, v10, OS_LOG_TYPE_DEFAULT, "#I Dynamic RRC release version indication received. Reason: %d", buf, 8u);
        }
        v11 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)v2);
        memset(v24, 0, sizeof(v24));
        qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v24);
        *(_DWORD *)qmi::MutableMessageBase::getTLV<pdc::tlv::ConfigurationType>(v24, 1) = 1;
        v12 = (_DWORD *)qmi::MutableMessageBase::getTLV<pdc::tlv::IndicationToken>(v24, 16);
        *v12 = subscriber::simSlotAsInstance();
        *(_DWORD *)qmi::MutableMessageBase::getTLV<pdc::tlv::ActivationType>(v24, 17) = 1;
        v13 = (_DWORD *)qmi::MutableMessageBase::getTLV<pdc::tlv::SlotId>(v24, 19);
        v14 = *(_DWORD **)(v2 + 176);
        v15 = *(_DWORD **)(v2 + 184);
        if (v14 != v15)
        {
          while (*v14 != v11)
          {
            v14 += 42;
            if (v14 == v15)
              goto LABEL_15;
          }
        }
        if (v14 == v15)
        {
LABEL_15:
          v16 = -1;
        }
        else
        {
          v16 = v14[1] - 1;
          if (v16 >= 3)
            v16 = -1;
        }
        *v13 = v16;
        v17 = (_DWORD *)qmi::MutableMessageBase::getTLV<pdc::tlv::SubscriptionId>(v24, 18);
        *v17 = subscriber::simSlotAsInstance();
        v19[1] = v2 + 136;
        v20 = QMIServiceMsg::create();
        v21 = 25000;
        v22 = 0;
        v23 = 0;
        *(_QWORD *)buf = MEMORY[0x24BDAC760];
        v27 = 0x40000000;
        v28 = ___ZZN33QMIDataSystemDeterminationManager38handleDynamicRRCReleaseVersionInd_syncERKN3dsd24DynamicRRCReleaseVersion10IndicationEENK3__0clERKNS0_3tlv6ReasonE_block_invoke;
        v29 = &__block_descriptor_tmp_42;
        v30 = v2;
        v31 = v11;
        aBlock[0] = MEMORY[0x24BDAC760];
        aBlock[1] = 0x40000000;
        aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3pdc14ActivateConfig8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
        aBlock[3] = &unk_24D5C4DD8;
        aBlock[4] = buf;
        v18 = _Block_copy(aBlock);
        v23 = v18;
        if (v20)
        {
          qmi::Client::send();
          v18 = v23;
        }
        if (v18)
          _Block_release(v18);
        qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v24);
      }
      else
      {
        ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)this, 19, v6, v7);
      }
    }
  }
}

void sub_2168DC8C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *aBlock, char a15)
{
  if (a11)
    qmi::Client::send();
  if (aBlock)
    _Block_release(aBlock);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a15);
  _Unwind_Resume(a1);
}

uint64_t ___ZN33QMIDataSystemDeterminationManager21bindSubscription_syncENSt3__18functionIFvvEEE_block_invoke(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v7;
  int v8;
  int v9;
  uint64_t v10;
  __int16 v11;
  int v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)(a2 + 4))
  {
    v4 = *(NSObject **)(*(_QWORD *)(a1 + 32) + 56);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v7 = qmi::asString();
      v8 = *(_DWORD *)(a2 + 4);
      v9 = 136315394;
      v10 = v7;
      v11 = 1024;
      v12 = v8;
      _os_log_error_impl(&dword_216897000, v4, OS_LOG_TYPE_ERROR, "Binding subscription: %s (0x%x)", (uint8_t *)&v9, 0x12u);
    }
  }
  v5 = *(_QWORD *)(a1 + 64);
  if (!v5)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 48))(v5);
}

uint64_t __copy_helper_block_e8_40c27_ZTSNSt3__18functionIFvvEEE(uint64_t a1, uint64_t a2)
{
  return std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100](a1 + 40, a2 + 40);
}

_QWORD *__destroy_helper_block_e8_40c27_ZTSNSt3__18functionIFvvEEE(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *result;
  uint64_t v3;

  v1 = (_QWORD *)(a1 + 40);
  result = *(_QWORD **)(a1 + 64);
  if (result == v1)
  {
    v3 = 4;
    result = v1;
  }
  else
  {
    if (!result)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

void QMIDataSystemDeterminationManager::sendSystemStatusChangeRequest_sync(QMIDataSystemDeterminationManager *this, char a2)
{
  const void **v4;
  char *v5;
  _BYTE *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  char *v14;
  uint64_t *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;
  void *v20;
  _QWORD v21[6];
  uint64_t v22;
  int v23;
  uint64_t v24;
  void *v25;
  void *__p[2];
  __int128 v27;
  _QWORD aBlock[5];

  *(_OWORD *)__p = 0u;
  v27 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  v4 = (const void **)__p[1];
  if (__p[1] != (void *)v27)
  {
    while (*((_BYTE *)*v4 + 8) != 17)
    {
      if (++v4 == (const void **)v27)
        goto LABEL_8;
    }
  }
  if (v4 == (const void **)v27)
  {
LABEL_8:
    v7 = operator new();
    v8 = v7;
    *(_WORD *)(v7 + 8) = 17;
    *(_QWORD *)v7 = &off_24D5C4950;
    v9 = v27;
    if ((unint64_t)v27 >= *((_QWORD *)&v27 + 1))
    {
      v11 = (uint64_t)(v27 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v11 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v12 = (uint64_t)(*((_QWORD *)&v27 + 1) - (unint64_t)__p[1]) >> 2;
      if (v12 <= v11 + 1)
        v12 = v11 + 1;
      if (*((_QWORD *)&v27 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v13 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v13 = v12;
      if (v13)
        v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v27 + 8, v13);
      else
        v14 = 0;
      v15 = (uint64_t *)&v14[8 * v11];
      v16 = &v14[8 * v13];
      *v15 = v8;
      v10 = v15 + 1;
      v18 = (char *)__p[1];
      v17 = (char *)v27;
      if ((void *)v27 != __p[1])
      {
        do
        {
          v19 = *((_QWORD *)v17 - 1);
          v17 -= 8;
          *--v15 = v19;
        }
        while (v17 != v18);
        v17 = (char *)__p[1];
      }
      __p[1] = v15;
      *(_QWORD *)&v27 = v10;
      *((_QWORD *)&v27 + 1) = v16;
      if (v17)
        operator delete(v17);
    }
    else
    {
      *(_QWORD *)v27 = v7;
      v10 = (_QWORD *)(v9 + 8);
    }
    v6 = (_BYTE *)(v8 + 9);
    *(_QWORD *)&v27 = v10;
  }
  else
  {
    if (!v5)
      __cxa_bad_cast();
    v6 = v5 + 9;
  }
  *v6 = a2;
  v21[5] = (char *)this + 104;
  v22 = QMIServiceMsg::create();
  v23 = 25000;
  v24 = 0;
  v25 = 0;
  v21[0] = MEMORY[0x24BDAC760];
  v21[1] = 0x40000000;
  v21[2] = ___ZN33QMIDataSystemDeterminationManager34sendSystemStatusChangeRequest_syncEb_block_invoke;
  v21[3] = &__block_descriptor_tmp_21_0;
  v21[4] = this;
  aBlock[0] = MEMORY[0x24BDAC760];
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3dsd18SystemStatusChange8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
  aBlock[3] = &unk_24D5C4980;
  aBlock[4] = v21;
  v20 = _Block_copy(aBlock);
  v25 = v20;
  if (v22)
  {
    qmi::Client::send();
    v20 = v25;
  }
  if (v20)
    _Block_release(v20);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
}

void sub_2168DCCA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  uint64_t v7;
  va_list va;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  va_list va1;

  va_start(va1, a6);
  va_start(va, a6);
  v7 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)va);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va1);
  _Unwind_Resume(a1);
}

void QMIDataSystemDeterminationManager::sendGetCurrentDataSystemStatusRequest_sync(QMIDataSystemDeterminationManager *this)
{
  void *v2;
  _QWORD v3[6];
  uint64_t v4;
  int v5;
  uint64_t v6;
  void *v7;
  _OWORD v8[2];
  _QWORD aBlock[5];

  memset(v8, 0, sizeof(v8));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v8);
  v3[5] = (char *)this + 104;
  v4 = QMIServiceMsg::create();
  v5 = 25000;
  v6 = 0;
  v7 = 0;
  v3[0] = MEMORY[0x24BDAC760];
  v3[1] = 0x40000000;
  v3[2] = ___ZN33QMIDataSystemDeterminationManager42sendGetCurrentDataSystemStatusRequest_syncEv_block_invoke;
  v3[3] = &__block_descriptor_tmp_22;
  v3[4] = this;
  aBlock[0] = MEMORY[0x24BDAC760];
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3dsd26GetCurrentDataSystemStatus8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
  aBlock[3] = &unk_24D5C49A8;
  aBlock[4] = v3;
  v2 = _Block_copy(aBlock);
  v7 = v2;
  if (v4)
  {
    qmi::Client::send();
    v2 = v7;
  }
  if (v2)
    _Block_release(v2);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v8);
}

void sub_2168DCDAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  uint64_t v7;
  va_list va;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  va_list va1;

  va_start(va1, a6);
  va_start(va, a6);
  v7 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)va);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va1);
  _Unwind_Resume(a1);
}

void ___ZN33QMIDataSystemDeterminationManager34sendSystemStatusChangeRequest_syncEb_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  NSObject *v4;
  _DWORD v5[2];
  __int16 v6;
  uint64_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)(v2 + 168))
  {
    v3 = *(_DWORD *)(a2 + 4);
    if (v3)
    {
      v4 = *(NSObject **)(v2 + 56);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        v5[0] = 67109378;
        v5[1] = v3;
        v6 = 2080;
        v7 = qmi::asString();
        _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#N Error in response to SystemStatusChange with code: %d (%s)", (uint8_t *)v5, 0x12u);
      }
    }
  }
}

void ___ZN33QMIDataSystemDeterminationManager42sendGetCurrentDataSystemStatusRequest_syncEv_block_invoke(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v2;
  int v4;
  NSObject *v5;
  _BOOL4 v6;
  char *TlvValue;
  int v8;
  char *v9;
  int v10;
  char *v11;
  char *v12;
  uint8_t buf[40];
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 32);
  if (*(_QWORD *)(v2 + 96) && !*(_BYTE *)(v2 + 168))
  {
    v4 = *((_DWORD *)a2 + 1);
    v5 = *(NSObject **)(v2 + 56);
    v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
    if (v4)
    {
      if (v6)
      {
        *(_DWORD *)buf = 67109378;
        *(_DWORD *)&buf[4] = v4;
        *(_WORD *)&buf[8] = 2080;
        *(_QWORD *)&buf[10] = qmi::asString();
        _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#N Failed to retrieve CurrentDataSystemStatus with error: %d (%s)", buf, 0x12u);
      }
    }
    else
    {
      if (v6)
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#N CurrentDataSystemStatus response received successfully", buf, 2u);
      }
      TlvValue = (char *)qmi::MessageBase::findTlvValue(a2);
      v9 = TlvValue;
      if (TlvValue)
      {
        v10 = v8;
        v12 = TlvValue;
        memset(buf, 0, 32);
        tlv::parseV<dsd::tlv::DataSystemStatus>(&v12, v8, buf);
        v11 = v12;
        if (v12)
          (*(void (**)(_QWORD, uint8_t *))(**(_QWORD **)(v2 + 96) + 16))(*(_QWORD *)(v2 + 96), buf);
        if (*(_QWORD *)&buf[8])
        {
          *(_QWORD *)&buf[16] = *(_QWORD *)&buf[8];
          operator delete(*(void **)&buf[8]);
        }
        if (!v11)
          ((void (*)(_QWORD, uint64_t, char *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 16, v9, v10);
      }
    }
  }
}

void sub_2168DD020(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void ___ZN33QMIDataSystemDeterminationManager18sendGetUiInfo_syncEv_block_invoke(uint64_t a1, qmi::MessageBase *this)
{
  uint64_t v2;
  int v4;
  NSObject *v5;
  uint64_t TlvValue;
  int v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint8_t buf[8];
  __int128 v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)(v2 + 168))
  {
    v4 = *((_DWORD *)this + 1);
    if (v4)
    {
      v5 = *(NSObject **)(v2 + 56);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109378;
        *(_DWORD *)&buf[4] = v4;
        LOWORD(v12) = 2080;
        *(_QWORD *)((char *)&v12 + 2) = qmi::asString();
        _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#N Failed to get UI Info with error: %d (%s)", buf, 0x12u);
      }
    }
    else
    {
      TlvValue = qmi::MessageBase::findTlvValue(this);
      if (TlvValue)
      {
        v8 = TlvValue;
        v9 = v7;
        v10 = TlvValue;
        *(_QWORD *)buf = 0;
        v12 = 0uLL;
        tlv::parseV<dsd::tlv::GlobalUiInfo>((unint64_t *)&v10, v7, buf);
        if (v10)
          QMIDataSystemDeterminationManager::handleUiMask_sync(v2, (uint64_t)buf);
        else
          ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)this, 16, v8, v9);
      }
    }
  }
}

void ___ZN33QMIDataSystemDeterminationManager36sendRegisterForUiInfoIndication_syncEv_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  NSObject *v4;
  _BOOL4 v5;
  const char *v6;
  NSObject *v7;
  uint32_t v8;
  _DWORD v9[2];
  __int16 v10;
  uint64_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)(v2 + 168))
  {
    v3 = *(_DWORD *)(a2 + 4);
    v4 = *(NSObject **)(v2 + 56);
    v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
    if (v3)
    {
      if (!v5)
        return;
      v9[0] = 67109378;
      v9[1] = v3;
      v10 = 2080;
      v11 = qmi::asString();
      v6 = "#N Failed to retrieve register for UI Info with error: %d (%s)";
      v7 = v4;
      v8 = 18;
    }
    else
    {
      if (!v5)
        return;
      LOWORD(v9[0]) = 0;
      v6 = "#N Register for UI Info response received successfully";
      v7 = v4;
      v8 = 2;
    }
    _os_log_impl(&dword_216897000, v7, OS_LOG_TYPE_DEFAULT, v6, (uint8_t *)v9, v8);
  }
}

uint64_t QMIDataSystemDeterminationManager::handleUiMask_sync(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;
  NSObject *v5;
  const char *v6;
  const char *v7;
  uint64_t v8;
  const char *v9;
  int v10;
  const char *v11;
  __int16 v12;
  const char *v13;
  __int16 v14;
  uint64_t v15;
  __int16 v16;
  const char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(result + 96);
  if (v2)
  {
    v4 = result;
    v5 = *(NSObject **)(result + 56);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = dsd::asString(*(_DWORD *)(a2 + 4));
      v7 = dsd::asString(*(_QWORD *)(a2 + 8));
      v8 = *(_QWORD *)(a2 + 8);
      v9 = dsd::asString(*(_QWORD *)(a2 + 16));
      v10 = 136315906;
      v11 = v6;
      v12 = 2080;
      v13 = v7;
      v14 = 2048;
      v15 = v8;
      v16 = 2080;
      v17 = v9;
      _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#I UI Info received, RAT %s, so_mask %s (%llu), mask %s", (uint8_t *)&v10, 0x2Au);
      v2 = *(_QWORD *)(v4 + 96);
    }
    return (*(uint64_t (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)v2 + 24))(v2, *(_QWORD *)(a2 + 8), *(_QWORD *)(a2 + 16));
  }
  return result;
}

void ___ZN33QMIDataSystemDeterminationManager32registerIndicationReporting_syncEv_block_invoke(uint64_t a1, uint64_t a2)
{
  NSObject *v2;
  uint8_t v3[16];
  uint8_t buf[16];

  v2 = *(NSObject **)(*(_QWORD *)(a1 + 32) + 56);
  if (*(_DWORD *)(a2 + 4))
  {
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_216897000, v2, OS_LOG_TYPE_ERROR, "Failed to register for indication reporting", buf, 2u);
    }
  }
  else if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v3 = 0;
    _os_log_impl(&dword_216897000, v2, OS_LOG_TYPE_DEFAULT, "#I Register for indication reporting successfully", v3, 2u);
  }
}

void ___ZN33QMIDataSystemDeterminationManager25sendGetBandwidthInfo_syncEv_block_invoke(uint64_t a1, qmi::MessageBase *this)
{
  uint64_t v2;
  int v4;
  NSObject *v5;
  uint64_t TlvValue;
  int v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int v21;
  unsigned __int8 v22;
  unsigned __int8 v23;
  NSObject *v24;
  const char *v25;
  uint64_t v26;
  __int16 v27;
  _WORD v28[11];

  *(_QWORD *)&v28[7] = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 32);
  if (*(_BYTE *)(v2 + 168))
    return;
  v4 = *((_DWORD *)this + 1);
  if (v4)
  {
    v5 = *(NSObject **)(v2 + 56);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      LODWORD(v26) = 67109378;
      HIDWORD(v26) = v4;
      v27 = 2080;
      *(_QWORD *)v28 = qmi::asString();
      _os_log_error_impl(&dword_216897000, v5, OS_LOG_TYPE_ERROR, "Failed to query for bandwidth info with error: %d (%s)", (uint8_t *)&v26, 0x12u);
    }
    return;
  }
  TlvValue = qmi::MessageBase::findTlvValue(this);
  if (TlvValue)
  {
    v8 = TlvValue;
    v9 = v7;
    v26 = TlvValue;
    v10 = tlv::parseV<dsd::tlv::Uplink>((unint64_t *)&v26, v7);
    if (v26)
    {
      v11 = v10;
      goto LABEL_10;
    }
    ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)this, 16, v8, v9);
  }
  v11 = 0;
LABEL_10:
  v12 = qmi::MessageBase::findTlvValue(this);
  if (v12)
  {
    v14 = v12;
    v15 = v13;
    v26 = v12;
    v16 = tlv::parseV<dsd::tlv::Downlink>((unint64_t *)&v26, v13);
    if (v26)
    {
      v17 = v16;
      goto LABEL_15;
    }
    ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)this, 17, v14, v15);
  }
  v17 = 0;
LABEL_15:
  v18 = qmi::MessageBase::findTlvValue(this);
  if (!v18)
  {
LABEL_19:
    v23 = 0;
    goto LABEL_20;
  }
  v20 = v18;
  v21 = v19;
  v26 = v18;
  v22 = tlv::parseV<dsd::tlv::RAT>((unint64_t *)&v26, v19);
  if (!v26)
  {
    ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)this, 18, v20, v21);
    goto LABEL_19;
  }
  v23 = v22;
LABEL_20:
  v24 = *(NSObject **)(v2 + 56);
  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
  {
    v25 = dsd::asString(v23);
    LODWORD(v26) = 67109634;
    HIDWORD(v26) = v11;
    v27 = 1024;
    *(_DWORD *)v28 = v17;
    v28[2] = 2080;
    *(_QWORD *)&v28[3] = v25;
    _os_log_impl(&dword_216897000, v24, OS_LOG_TYPE_DEFAULT, "#I Throughput estimate info queried. up: %u Kbps, dl: %u Kbps, rat: %s", (uint8_t *)&v26, 0x18u);
  }
  (*(void (**)(_QWORD, uint64_t, uint64_t, _QWORD))(**(_QWORD **)(v2 + 96) + 32))(*(_QWORD *)(v2 + 96), v11, v17, v23);
}

_QWORD *ctu::SharedSynchronizable<QMIDataSystemDeterminationManager>::~SharedSynchronizable(_QWORD *a1)
{
  NSObject *v2;
  NSObject *v3;
  std::__shared_weak_count *v4;

  v2 = a1[3];
  if (v2)
    dispatch_release(v2);
  v3 = a1[2];
  if (v3)
    dispatch_release(v3);
  v4 = (std::__shared_weak_count *)a1[1];
  if (v4)
    std::__shared_weak_count::__release_weak(v4);
  return a1;
}

void std::__destroy_at[abi:ne180100]<BasicSimInfo,0>(uint64_t a1)
{
  void *v2;
  void **v3;

  if (*(char *)(a1 + 167) < 0)
    operator delete(*(void **)(a1 + 144));
  if (*(char *)(a1 + 143) < 0)
    operator delete(*(void **)(a1 + 120));
  if (*(char *)(a1 + 119) < 0)
    operator delete(*(void **)(a1 + 96));
  if (*(char *)(a1 + 95) < 0)
    operator delete(*(void **)(a1 + 72));
  v3 = (void **)(a1 + 40);
  std::vector<pbm::tlv::AdditionalNumberParam>::__destroy_vector::operator()[abi:ne180100](&v3);
  v2 = *(void **)(a1 + 16);
  if (v2)
  {
    *(_QWORD *)(a1 + 24) = v2;
    operator delete(v2);
  }
}

uint64_t *std::shared_ptr<QMIDataSystemDeterminationManager>::shared_ptr[abi:ne180100]<QMIDataSystemDeterminationManager,std::shared_ptr<QMIDataSystemDeterminationManager> ctu::SharedSynchronizable<QMIDataSystemDeterminationManager>::make_shared_ptr<QMIDataSystemDeterminationManager>(QMIDataSystemDeterminationManager*)::{lambda(QMIDataSystemDeterminationManager*)#1},void>(uint64_t *a1, uint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24D5C4610;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = (uint64_t)v4;
  if (a2)
    v5 = (_QWORD *)(a2 + 24);
  else
    v5 = 0;
  std::shared_ptr<QMIDataSystemDeterminationManager>::__enable_weak_this[abi:ne180100]<QMIDataSystemDeterminationManager,QMIDataSystemDeterminationManager,void>((uint64_t)a1, v5, a2);
  return a1;
}

void sub_2168DD7A8(void *a1)
{
  dispatch_queue_t *v1;

  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[5], v1, (dispatch_function_t)std::shared_ptr<QMIDataSystemDeterminationManager> ctu::SharedSynchronizable<QMIDataSystemDeterminationManager>::make_shared_ptr<QMIDataSystemDeterminationManager>(QMIDataSystemDeterminationManager*)::{lambda(QMIDataSystemDeterminationManager*)#1}::operator() const(QMIDataSystemDeterminationManager*)::{lambda(void *)#1}::__invoke);
  __cxa_rethrow();
}

void sub_2168DD7C8(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void std::shared_ptr<QMIDataSystemDeterminationManager>::__enable_weak_this[abi:ne180100]<QMIDataSystemDeterminationManager,QMIDataSystemDeterminationManager,void>(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  unint64_t *p_shared_weak_owners;
  unint64_t v9;
  unint64_t *v10;
  unint64_t v11;

  if (a2)
  {
    v4 = (std::__shared_weak_count *)a2[1];
    if (!v4 || v4->__shared_owners_ == -1)
    {
      v5 = *(std::__shared_weak_count **)(a1 + 8);
      if (v5)
      {
        p_shared_owners = (unint64_t *)&v5->__shared_owners_;
        do
          v7 = __ldxr(p_shared_owners);
        while (__stxr(v7 + 1, p_shared_owners));
        p_shared_weak_owners = (unint64_t *)&v5->__shared_weak_owners_;
        do
          v9 = __ldxr(p_shared_weak_owners);
        while (__stxr(v9 + 1, p_shared_weak_owners));
        v4 = (std::__shared_weak_count *)a2[1];
      }
      *a2 = a3;
      a2[1] = v5;
      if (v4)
        std::__shared_weak_count::__release_weak(v4);
      if (v5)
      {
        v10 = (unint64_t *)&v5->__shared_owners_;
        do
          v11 = __ldaxr(v10);
        while (__stlxr(v11 - 1, v10));
        if (!v11)
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
      }
    }
  }
}

void std::__shared_ptr_pointer<QMIDataSystemDeterminationManager *,std::shared_ptr<QMIDataSystemDeterminationManager> ctu::SharedSynchronizable<QMIDataSystemDeterminationManager>::make_shared_ptr<QMIDataSystemDeterminationManager>(QMIDataSystemDeterminationManager*)::{lambda(QMIDataSystemDeterminationManager *)#1},std::allocator<QMIDataSystemDeterminationManager>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void std::__shared_ptr_pointer<QMIDataSystemDeterminationManager *,std::shared_ptr<QMIDataSystemDeterminationManager> ctu::SharedSynchronizable<QMIDataSystemDeterminationManager>::make_shared_ptr<QMIDataSystemDeterminationManager>(QMIDataSystemDeterminationManager*)::{lambda(QMIDataSystemDeterminationManager *)#1},std::allocator<QMIDataSystemDeterminationManager>>::__on_zero_shared(uint64_t a1)
{
  dispatch_barrier_async_f(*(dispatch_queue_t *)(*(_QWORD *)(a1 + 24) + 40), *(void **)(a1 + 24), (dispatch_function_t)std::shared_ptr<QMIDataSystemDeterminationManager> ctu::SharedSynchronizable<QMIDataSystemDeterminationManager>::make_shared_ptr<QMIDataSystemDeterminationManager>(QMIDataSystemDeterminationManager*)::{lambda(QMIDataSystemDeterminationManager*)#1}::operator() const(QMIDataSystemDeterminationManager*)::{lambda(void *)#1}::__invoke);
}

uint64_t std::__shared_ptr_pointer<QMIDataSystemDeterminationManager *,std::shared_ptr<QMIDataSystemDeterminationManager> ctu::SharedSynchronizable<QMIDataSystemDeterminationManager>::make_shared_ptr<QMIDataSystemDeterminationManager>(QMIDataSystemDeterminationManager*)::{lambda(QMIDataSystemDeterminationManager *)#1},std::allocator<QMIDataSystemDeterminationManager>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t std::shared_ptr<QMIDataSystemDeterminationManager> ctu::SharedSynchronizable<QMIDataSystemDeterminationManager>::make_shared_ptr<QMIDataSystemDeterminationManager>(QMIDataSystemDeterminationManager*)::{lambda(QMIDataSystemDeterminationManager*)#1}::operator() const(QMIDataSystemDeterminationManager*)::{lambda(void *)#1}::__invoke(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

void ___ZNK3qmi6Client13setIndHandlerIRKN3pdc14ActivateConfig10IndicationEEEvtU13block_pointerFvT_E_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BYTE v3[24];

  v2 = *(_QWORD *)(a1 + 32);
  cast_message_type<pdc::ActivateConfig::Indication const&>::cast(a2, (qmi::MessageBase *)v3);
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_2168DD964(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void cast_message_type<pdc::ActivateConfig::Indication const&>::cast(uint64_t a1@<X0>, qmi::MessageBase *a2@<X8>)
{
  if (*(_DWORD *)(a1 + 40) != 1 || *(_WORD *)(a1 + 44) == 3)
  {
    QMIServiceMsg::serialize((QMIServiceMsg *)a1);
    qmi::Indication<(unsigned short)39,pdc::ActivateConfig::IndicationTLVList>::Indication(a2, 0);
  }
  else
  {
    QMIServiceMsg::getNewError((QMIServiceMsg *)a1);
    qmi::Indication<(unsigned short)39,pdc::ActivateConfig::IndicationTLVList>::Indication((uint64_t)a2);
  }
}

void sub_2168DDA04(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t qmi::Indication<(unsigned short)39,pdc::ActivateConfig::IndicationTLVList>::Indication(uint64_t a1)
{
  qmi::MessageBase *v2;

  v2 = (qmi::MessageBase *)qmi::MessageBase::MessageBase();
  qmi::MessageBase::validateMsgId(v2);
  return a1;
}

void sub_2168DDA4C(_Unwind_Exception *a1)
{
  qmi::MessageBase *v1;

  qmi::MessageBase::~MessageBase(v1);
  _Unwind_Resume(a1);
}

qmi::MessageBase *qmi::Indication<(unsigned short)39,pdc::ActivateConfig::IndicationTLVList>::Indication(qmi::MessageBase *a1, const void *a2)
{
  qmi::MessageBase *v3;

  v3 = (qmi::MessageBase *)qmi::MessageBase::MessageBase(a1, a2);
  qmi::MessageBase::validateMsgId(v3);
  return a1;
}

void sub_2168DDA8C(_Unwind_Exception *a1)
{
  qmi::MessageBase *v1;

  qmi::MessageBase::~MessageBase(v1);
  _Unwind_Resume(a1);
}

void std::__function::__func<ctu::rest::property_sink_t<rest::sims_in_use>::bind(ctu::RestModule &)::{lambda(xpc::object const&)#1},std::allocator<ctu::rest::property_sink_t<rest::sims_in_use>::bind(ctu::RestModule &)::{lambda(xpc::object const&)#1}>,void ()(xpc::object)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<ctu::rest::property_sink_t<rest::sims_in_use>::bind(ctu::RestModule &)::{lambda(xpc::object const&)#1},std::allocator<ctu::rest::property_sink_t<rest::sims_in_use>::bind(ctu::RestModule &)::{lambda(xpc::object const&)#1}>,void ()(xpc::object)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5C4698;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<ctu::rest::property_sink_t<rest::sims_in_use>::bind(ctu::RestModule &)::{lambda(xpc::object const&)#1},std::allocator<ctu::rest::property_sink_t<rest::sims_in_use>::bind(ctu::RestModule &)::{lambda(xpc::object const&)#1}>,void ()(xpc::object)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5C4698;
  a2[1] = v2;
  return result;
}

void std::__function::__func<ctu::rest::property_sink_t<rest::sims_in_use>::bind(ctu::RestModule &)::{lambda(xpc::object const&)#1},std::allocator<ctu::rest::property_sink_t<rest::sims_in_use>::bind(ctu::RestModule &)::{lambda(xpc::object const&)#1}>,void ()(xpc::object)>::operator()(uint64_t a1, _QWORD *a2)
{
  _QWORD *v2;
  xpc_object_t v3;
  uint64_t v4;
  char *v5;
  uint64_t i;
  void *count;
  xpc_object_t j;
  unint64_t v9;
  char *v10;
  char *v11;
  char *v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;
  char *v21;
  char *v22;
  __int128 v23;
  int v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  uint64_t v29;
  xpc_object_t value;
  xpc_object_t v31;
  xpc_object_t object[2];
  xpc_object_t xarray;
  size_t index;
  xpc_object_t v35;

  v2 = *(_QWORD **)(a1 + 8);
  v3 = (xpc_object_t)*a2;
  v4 = MEMORY[0x24BDACF78];
  if (*a2 && MEMORY[0x2199FEDD0](*a2) == v4)
    xpc_retain(v3);
  else
    v3 = xpc_null_create();
  v5 = (char *)*v2;
  for (i = v2[1]; (char *)i != v5; std::__destroy_at[abi:ne180100]<BasicSimInfo,0>(i))
    i -= 168;
  v2[1] = v5;
  if (MEMORY[0x2199FEDD0](v3) == v4)
  {
    object[0] = v3;
    if (v3)
      xpc_retain(v3);
    else
      object[0] = xpc_null_create();
    xpc::array::iterator::iterator(&xarray, object, 0);
    xpc_release(object[0]);
    v35 = v3;
    if (v3)
      xpc_retain(v3);
    else
      v35 = xpc_null_create();
    v31 = v3;
    if (MEMORY[0x2199FEDD0](v3) == v4)
      count = (void *)xpc_array_get_count(v3);
    else
      count = 0;
    xpc::array::iterator::iterator(object, &v35, count);
    xpc_release(v35);
    for (j = (xpc_object_t)index; j != object[1] || xarray != object[0]; j = (xpc_object_t)++index)
    {
      v10 = (char *)v2[1];
      v9 = v2[2];
      if ((unint64_t)v10 >= v9)
      {
        v12 = (char *)*v2;
        v13 = 0xCF3CF3CF3CF3CF3DLL * ((uint64_t)&v10[-*v2] >> 3);
        v14 = v13 + 1;
        if (v13 + 1 > 0x186186186186186)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v15 = 0xCF3CF3CF3CF3CF3DLL * ((uint64_t)(v9 - (_QWORD)v12) >> 3);
        if (2 * v15 > v14)
          v14 = 2 * v15;
        if (v15 >= 0xC30C30C30C30C3)
          v16 = 0x186186186186186;
        else
          v16 = v14;
        if (v16)
        {
          if (v16 > 0x186186186186186)
            std::__throw_bad_array_new_length[abi:ne180100]();
          v17 = (char *)operator new(168 * v16);
        }
        else
        {
          v17 = 0;
        }
        v18 = &v17[168 * v13];
        *((_QWORD *)v18 + 20) = 0;
        *((_OWORD *)v18 + 8) = 0u;
        *((_OWORD *)v18 + 9) = 0u;
        v19 = &v17[168 * v16];
        *((_OWORD *)v18 + 6) = 0u;
        *((_OWORD *)v18 + 7) = 0u;
        *((_OWORD *)v18 + 4) = 0u;
        *((_OWORD *)v18 + 5) = 0u;
        *((_OWORD *)v18 + 2) = 0u;
        *((_OWORD *)v18 + 3) = 0u;
        *(_OWORD *)v18 = 0u;
        *((_OWORD *)v18 + 1) = 0u;
        v11 = v18 + 168;
        if (v10 == v12)
        {
          *v2 = v18;
          v2[1] = v11;
          v2[2] = v19;
        }
        else
        {
          v20 = 0;
          do
          {
            v21 = &v18[v20];
            v22 = &v10[v20];
            v23 = *(_OWORD *)&v10[v20 - 168];
            *((_QWORD *)v21 - 18) = 0;
            *((_QWORD *)v21 - 17) = 0;
            *(_OWORD *)(v21 - 168) = v23;
            *((_QWORD *)v21 - 19) = 0;
            *(_OWORD *)(v21 - 152) = *(_OWORD *)&v10[v20 - 152];
            *((_QWORD *)v21 - 17) = *(_QWORD *)&v10[v20 - 136];
            *((_QWORD *)v22 - 19) = 0;
            *((_QWORD *)v22 - 18) = 0;
            *((_QWORD *)v22 - 17) = 0;
            *((_QWORD *)v21 - 16) = 0;
            *((_QWORD *)v21 - 15) = 0;
            *((_QWORD *)v21 - 14) = 0;
            *((_OWORD *)v21 - 8) = *(_OWORD *)&v10[v20 - 128];
            *((_QWORD *)v21 - 14) = *(_QWORD *)&v10[v20 - 112];
            *((_QWORD *)v22 - 16) = 0;
            *((_QWORD *)v22 - 15) = 0;
            *((_QWORD *)v22 - 14) = 0;
            v24 = *(_DWORD *)&v10[v20 - 104];
            *((_WORD *)v21 - 50) = *(_WORD *)&v10[v20 - 100];
            *((_DWORD *)v21 - 26) = v24;
            v25 = *(_OWORD *)&v10[v20 - 96];
            *((_QWORD *)v21 - 10) = *(_QWORD *)&v10[v20 - 80];
            *((_OWORD *)v21 - 6) = v25;
            *((_QWORD *)v22 - 11) = 0;
            *((_QWORD *)v22 - 10) = 0;
            *((_QWORD *)v22 - 12) = 0;
            v26 = *(_OWORD *)&v10[v20 - 72];
            *((_QWORD *)v21 - 7) = *(_QWORD *)&v10[v20 - 56];
            *(_OWORD *)(v21 - 72) = v26;
            *((_QWORD *)v22 - 8) = 0;
            *((_QWORD *)v22 - 7) = 0;
            *((_QWORD *)v22 - 9) = 0;
            v27 = *(_OWORD *)&v10[v20 - 48];
            *((_QWORD *)v21 - 4) = *(_QWORD *)&v10[v20 - 32];
            *((_OWORD *)v21 - 3) = v27;
            *((_QWORD *)v22 - 6) = 0;
            *((_QWORD *)v22 - 5) = 0;
            *((_QWORD *)v22 - 4) = 0;
            v28 = *(_OWORD *)&v10[v20 - 24];
            *((_QWORD *)v21 - 1) = *(_QWORD *)&v10[v20 - 8];
            *(_OWORD *)(v21 - 24) = v28;
            *((_QWORD *)v22 - 3) = 0;
            *((_QWORD *)v22 - 2) = 0;
            *((_QWORD *)v22 - 1) = 0;
            v20 -= 168;
          }
          while (&v10[v20] != v12);
          v10 = (char *)*v2;
          v29 = v2[1];
          *v2 = &v18[v20];
          v2[1] = v11;
          v2[2] = v19;
          while ((char *)v29 != v10)
          {
            v29 -= 168;
            std::__destroy_at[abi:ne180100]<BasicSimInfo,0>(v29);
          }
        }
        if (v10)
          operator delete(v10);
      }
      else
      {
        *((_QWORD *)v10 + 20) = 0;
        *((_OWORD *)v10 + 8) = 0u;
        *((_OWORD *)v10 + 9) = 0u;
        *((_OWORD *)v10 + 6) = 0u;
        *((_OWORD *)v10 + 7) = 0u;
        *((_OWORD *)v10 + 4) = 0u;
        *((_OWORD *)v10 + 5) = 0u;
        *((_OWORD *)v10 + 2) = 0u;
        *((_OWORD *)v10 + 3) = 0u;
        *(_OWORD *)v10 = 0u;
        *((_OWORD *)v10 + 1) = 0u;
        v11 = v10 + 168;
        v2[1] = v10 + 168;
      }
      v2[1] = v11;
      value = xpc_array_get_value(xarray, (size_t)j);
      v35 = value;
      if (value)
        xpc_retain(value);
      else
        v35 = xpc_null_create();
      read_rest_value();
      xpc_release(v35);
    }
    xpc_release(xarray);
    xpc_release(xarray);
    v3 = v31;
  }
  xpc_release(v3);
}

void sub_2168DDEE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t a9, xpc_object_t a10, uint64_t a11, xpc_object_t a12, uint64_t a13, xpc_object_t object)
{
  xpc_release(object);
  xpc_release(a12);
  xpc_release(a9);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<ctu::rest::property_sink_t<rest::sims_in_use>::bind(ctu::RestModule &)::{lambda(xpc::object const&)#1},std::allocator<ctu::rest::property_sink_t<rest::sims_in_use>::bind(ctu::RestModule &)::{lambda(xpc::object const&)#1}>,void ()(xpc::object)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<ctu::rest::property_sink_t<rest::sims_in_use>::bind(ctu::RestModule &)::{lambda(xpc::object const&)#1},std::allocator<ctu::rest::property_sink_t<rest::sims_in_use>::bind(ctu::RestModule &)::{lambda(xpc::object const&)#1}>,void ()(xpc::object)>::target_type()
{
}

void **xpc::array::iterator::iterator(void **a1, void **a2, void *a3)
{
  void *v5;

  v5 = *a2;
  *a1 = *a2;
  if (v5)
    xpc_retain(v5);
  else
    *a1 = xpc_null_create();
  a1[1] = a3;
  return a1;
}

void ___ZNK3qmi6Client13setIndHandlerIRKN3dsd18SystemStatusReport10IndicationEEEvtU13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2168DE0B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ___ZNK3qmi6Client13setIndHandlerIRKN3dsd12UplinkHealth10IndicationEEEvtU13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2168DE1B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ___ZNK3qmi6Client13setIndHandlerIRKN3dsd6UiInfo10IndicationEEEvtU13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2168DE2B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ___ZNK3qmi6Client13setIndHandlerIRKN3dsd24DynamicRRCReleaseVersion10IndicationEEEvtU13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2168DE3AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void std::__function::__func<QMIDataSystemDeterminationManager::handleQMIClientStarted_sync(void)::$_0,std::allocator<QMIDataSystemDeterminationManager::handleQMIClientStarted_sync(void)::$_0>,void ()(void)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<QMIDataSystemDeterminationManager::handleQMIClientStarted_sync(void)::$_0,std::allocator<QMIDataSystemDeterminationManager::handleQMIClientStarted_sync(void)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5C47F0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<QMIDataSystemDeterminationManager::handleQMIClientStarted_sync(void)::$_0,std::allocator<QMIDataSystemDeterminationManager::handleQMIClientStarted_sync(void)::$_0>,void ()(void)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5C47F0;
  a2[1] = v2;
  return result;
}

void std::__function::__func<QMIDataSystemDeterminationManager::handleQMIClientStarted_sync(void)::$_0,std::allocator<QMIDataSystemDeterminationManager::handleQMIClientStarted_sync(void)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  QMIDataSystemDeterminationManager *v1;
  capabilities::ct *v2;
  capabilities::ct *v3;
  const void **v4;
  const void **v5;
  const void **v6;
  char *v7;
  _BYTE *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  char *v15;
  const void **v16;
  char *v17;
  char *v18;
  char *v19;
  const void *v20;
  char *v21;
  _BYTE *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;
  char *v29;
  const void **v30;
  char *v31;
  char *v32;
  char *v33;
  const void *v34;
  const void **i;
  char *v36;
  _BYTE *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  _QWORD *v41;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  char *v45;
  uint64_t *v46;
  char *v47;
  char *v48;
  char *v49;
  uint64_t v50;
  void *v51;
  NSObject *v52;
  capabilities::ct *v53;
  char *v54;
  int v55;
  const void **v56;
  _BYTE *v57;
  char *v58;
  uint64_t v59;
  _QWORD *v60;
  uint64_t v61;
  unint64_t v62;
  unint64_t v63;
  char *v64;
  char *v65;
  char *v66;
  char *v67;
  uint64_t v68;
  char *v69;
  const void **v70;
  _BYTE *v71;
  char *v72;
  uint64_t v73;
  _QWORD *v74;
  uint64_t v75;
  unint64_t v76;
  unint64_t v77;
  char *v78;
  char *v79;
  char *v80;
  char *v81;
  uint64_t v82;
  const void **v83;
  char *v84;
  _BYTE *v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  _QWORD *v89;
  uint64_t v90;
  unint64_t v91;
  unint64_t v92;
  char *v93;
  uint64_t *v94;
  char *v95;
  char *v96;
  char *v97;
  uint64_t v98;
  void *v99;
  uint64_t v100;
  uint64_t v101;
  void (*v102)(uint64_t, uint64_t);
  void *v103;
  QMIDataSystemDeterminationManager *v104;
  _QWORD *v105;
  uint64_t v106;
  int v107;
  uint64_t v108;
  void *v109;
  void *__p[2];
  __int128 v111;
  uint64_t aBlock;
  uint64_t v113;
  void *v114;
  void *v115;
  uint64_t *v116;

  v1 = *(QMIDataSystemDeterminationManager **)(a1 + 8);
  QMIDataSystemDeterminationManager::sendSystemStatusChangeRequest_sync(v1, 1);
  QMIDataSystemDeterminationManager::sendGetCurrentDataSystemStatusRequest_sync(v1);
  v3 = (capabilities::ct *)capabilities::ct::supports5G(v2);
  if ((_DWORD)v3 && capabilities::ct::supports5G(v3))
  {
    *(_OWORD *)__p = 0u;
    v111 = 0u;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
    v4 = (const void **)__p[1];
    v5 = (const void **)v111;
    v6 = (const void **)__p[1];
    if (__p[1] != (void *)v111)
    {
      v6 = (const void **)__p[1];
      while (*((_BYTE *)*v6 + 8) != 16)
      {
        if (++v6 == (const void **)v111)
          goto LABEL_11;
      }
    }
    if (v6 == (const void **)v111)
    {
LABEL_11:
      v9 = operator new();
      v10 = v9;
      *(_WORD *)(v9 + 8) = 16;
      *(_QWORD *)v9 = &off_24D5C4A18;
      v11 = v111;
      if ((unint64_t)v111 >= *((_QWORD *)&v111 + 1))
      {
        v12 = (uint64_t)(v111 - (unint64_t)__p[1]) >> 3;
        if ((unint64_t)(v12 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v13 = (uint64_t)(*((_QWORD *)&v111 + 1) - (unint64_t)__p[1]) >> 2;
        if (v13 <= v12 + 1)
          v13 = v12 + 1;
        if (*((_QWORD *)&v111 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v14 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v14 = v13;
        if (v14)
          v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v111 + 8, v14);
        else
          v15 = 0;
        v16 = (const void **)&v15[8 * v12];
        v17 = &v15[8 * v14];
        *v16 = (const void *)v10;
        v5 = v16 + 1;
        v19 = (char *)__p[1];
        v18 = (char *)v111;
        if ((void *)v111 != __p[1])
        {
          do
          {
            v20 = (const void *)*((_QWORD *)v18 - 1);
            v18 -= 8;
            *--v16 = v20;
          }
          while (v18 != v19);
          v18 = (char *)__p[1];
        }
        __p[1] = v16;
        *(_QWORD *)&v111 = v5;
        *((_QWORD *)&v111 + 1) = v17;
        if (v18)
          operator delete(v18);
      }
      else
      {
        *(_QWORD *)v111 = v9;
        v5 = (const void **)(v11 + 8);
      }
      v8 = (_BYTE *)(v10 + 9);
      *(_QWORD *)&v111 = v5;
      v4 = (const void **)__p[1];
    }
    else
    {
      if (!v7)
        __cxa_bad_cast();
      v8 = v7 + 9;
    }
    *v8 = 1;
    while (v4 != v5)
    {
      if (*((_BYTE *)*v4 + 8) == 17)
      {
        if (v4 != v5)
        {
          if (!v21)
            __cxa_bad_cast();
          v22 = v21 + 9;
          goto LABEL_52;
        }
        break;
      }
      ++v4;
    }
    v23 = operator new();
    v24 = v23;
    *(_WORD *)(v23 + 8) = 17;
    *(_QWORD *)v23 = &off_24D5C4A68;
    v25 = v111;
    if ((unint64_t)v111 >= *((_QWORD *)&v111 + 1))
    {
      v26 = (uint64_t)(v111 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v26 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v27 = (uint64_t)(*((_QWORD *)&v111 + 1) - (unint64_t)__p[1]) >> 2;
      if (v27 <= v26 + 1)
        v27 = v26 + 1;
      if (*((_QWORD *)&v111 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v28 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v28 = v27;
      if (v28)
        v29 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v111 + 8, v28);
      else
        v29 = 0;
      v30 = (const void **)&v29[8 * v26];
      v31 = &v29[8 * v28];
      *v30 = (const void *)v24;
      v5 = v30 + 1;
      v33 = (char *)__p[1];
      v32 = (char *)v111;
      if ((void *)v111 != __p[1])
      {
        do
        {
          v34 = (const void *)*((_QWORD *)v32 - 1);
          v32 -= 8;
          *--v30 = v34;
        }
        while (v32 != v33);
        v32 = (char *)__p[1];
      }
      __p[1] = v30;
      *(_QWORD *)&v111 = v5;
      *((_QWORD *)&v111 + 1) = v31;
      if (v32)
        operator delete(v32);
    }
    else
    {
      *(_QWORD *)v111 = v23;
      v5 = (const void **)(v25 + 8);
    }
    v22 = (_BYTE *)(v24 + 9);
    *(_QWORD *)&v111 = v5;
LABEL_52:
    *v22 = 0;
    for (i = (const void **)__p[1]; i != v5; ++i)
    {
      if (*((_BYTE *)*i + 8) == 18)
      {
        if (i != v5)
        {
          if (!v36)
            __cxa_bad_cast();
          v37 = v36 + 9;
          goto LABEL_76;
        }
        break;
      }
    }
    v38 = operator new();
    v39 = v38;
    *(_WORD *)(v38 + 8) = 18;
    *(_QWORD *)v38 = &off_24D5C4AB8;
    v40 = v111;
    if ((unint64_t)v111 >= *((_QWORD *)&v111 + 1))
    {
      v42 = (uint64_t)(v111 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v42 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v43 = (uint64_t)(*((_QWORD *)&v111 + 1) - (unint64_t)__p[1]) >> 2;
      if (v43 <= v42 + 1)
        v43 = v42 + 1;
      if (*((_QWORD *)&v111 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v44 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v44 = v43;
      if (v44)
        v45 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v111 + 8, v44);
      else
        v45 = 0;
      v46 = (uint64_t *)&v45[8 * v42];
      v47 = &v45[8 * v44];
      *v46 = v39;
      v41 = v46 + 1;
      v49 = (char *)__p[1];
      v48 = (char *)v111;
      if ((void *)v111 != __p[1])
      {
        do
        {
          v50 = *((_QWORD *)v48 - 1);
          v48 -= 8;
          *--v46 = v50;
        }
        while (v48 != v49);
        v48 = (char *)__p[1];
      }
      __p[1] = v46;
      *(_QWORD *)&v111 = v41;
      *((_QWORD *)&v111 + 1) = v47;
      if (v48)
        operator delete(v48);
    }
    else
    {
      *(_QWORD *)v111 = v38;
      v41 = (_QWORD *)(v40 + 8);
    }
    v37 = (_BYTE *)(v39 + 9);
    *(_QWORD *)&v111 = v41;
LABEL_76:
    *v37 = 0;
    v105 = (_QWORD *)((char *)v1 + 104);
    v106 = QMIServiceMsg::create();
    v107 = 25000;
    v108 = 0;
    v109 = 0;
    v100 = MEMORY[0x24BDAC760];
    v101 = 0x40000000;
    v102 = ___ZN33QMIDataSystemDeterminationManager36sendRegisterForUiInfoIndication_syncEv_block_invoke;
    v103 = &__block_descriptor_tmp_24_0;
    v104 = v1;
    aBlock = MEMORY[0x24BDAC760];
    v113 = 0x40000000;
    v114 = ___ZNO3qmi6Client9SendProxy8callbackIRKN3dsd20RegisterUiInfoChange8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
    v115 = &unk_24D5C4AE8;
    v116 = &v100;
    v51 = _Block_copy(&aBlock);
    v109 = v51;
    if (v106)
    {
      qmi::Client::send();
      v51 = v109;
    }
    if (v51)
      _Block_release(v51);
    qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
  }
  v52 = *((_QWORD *)v1 + 7);
  if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(aBlock) = 0;
    _os_log_impl(&dword_216897000, v52, OS_LOG_TYPE_DEFAULT, "#I Register DSD indications", (uint8_t *)&aBlock, 2u);
  }
  *(_OWORD *)__p = 0u;
  v111 = 0u;
  v53 = (capabilities::ct *)qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  v54 = (char *)capabilities::ct::supports5G(v53);
  v55 = (int)v54;
  if ((_DWORD)v54)
  {
    v56 = (const void **)__p[1];
    if (__p[1] != (void *)v111)
    {
      while (*((unsigned __int8 *)*v56 + 8) != 162)
      {
        if (++v56 == (const void **)v111)
          goto LABEL_91;
      }
    }
    if (v56 == (const void **)v111)
    {
LABEL_91:
      v54 = (char *)operator new();
      v58 = v54;
      *((_WORD *)v54 + 4) = 162;
      *(_QWORD *)v54 = &off_24D5C4B30;
      v59 = v111;
      if ((unint64_t)v111 >= *((_QWORD *)&v111 + 1))
      {
        v61 = (uint64_t)(v111 - (unint64_t)__p[1]) >> 3;
        if ((unint64_t)(v61 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v62 = (uint64_t)(*((_QWORD *)&v111 + 1) - (unint64_t)__p[1]) >> 2;
        if (v62 <= v61 + 1)
          v62 = v61 + 1;
        if (*((_QWORD *)&v111 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v63 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v63 = v62;
        if (v63)
          v64 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v111 + 8, v63);
        else
          v64 = 0;
        v65 = &v64[8 * v61];
        v66 = &v64[8 * v63];
        *(_QWORD *)v65 = v58;
        v60 = v65 + 8;
        v67 = (char *)__p[1];
        v54 = (char *)v111;
        if ((void *)v111 != __p[1])
        {
          do
          {
            v68 = *((_QWORD *)v54 - 1);
            v54 -= 8;
            *((_QWORD *)v65 - 1) = v68;
            v65 -= 8;
          }
          while (v54 != v67);
          v54 = (char *)__p[1];
        }
        __p[1] = v65;
        *(_QWORD *)&v111 = v60;
        *((_QWORD *)&v111 + 1) = v66;
        if (v54)
          operator delete(v54);
      }
      else
      {
        *(_QWORD *)v111 = v54;
        v60 = (_QWORD *)(v59 + 8);
      }
      v57 = v58 + 9;
      *(_QWORD *)&v111 = v60;
    }
    else
    {
      if (!v54)
        __cxa_bad_cast();
      v57 = v54 + 9;
    }
    *v57 = 1;
  }
  v69 = (char *)capabilities::ct::supportsDynamicRRCReleaseVersionUpdate((capabilities::ct *)v54);
  if ((_DWORD)v69)
  {
    v70 = (const void **)__p[1];
    if (__p[1] != (void *)v111)
    {
      while (*((unsigned __int8 *)*v70 + 8) != 163)
      {
        if (++v70 == (const void **)v111)
          goto LABEL_117;
      }
    }
    if (v70 == (const void **)v111)
    {
LABEL_117:
      v69 = (char *)operator new();
      v72 = v69;
      *((_WORD *)v69 + 4) = 163;
      *(_QWORD *)v69 = &off_24D5C4B80;
      v73 = v111;
      if ((unint64_t)v111 >= *((_QWORD *)&v111 + 1))
      {
        v75 = (uint64_t)(v111 - (unint64_t)__p[1]) >> 3;
        if ((unint64_t)(v75 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v76 = (uint64_t)(*((_QWORD *)&v111 + 1) - (unint64_t)__p[1]) >> 2;
        if (v76 <= v75 + 1)
          v76 = v75 + 1;
        if (*((_QWORD *)&v111 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v77 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v77 = v76;
        if (v77)
          v78 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v111 + 8, v77);
        else
          v78 = 0;
        v79 = &v78[8 * v75];
        v80 = &v78[8 * v77];
        *(_QWORD *)v79 = v72;
        v74 = v79 + 8;
        v81 = (char *)__p[1];
        v69 = (char *)v111;
        if ((void *)v111 != __p[1])
        {
          do
          {
            v82 = *((_QWORD *)v69 - 1);
            v69 -= 8;
            *((_QWORD *)v79 - 1) = v82;
            v79 -= 8;
          }
          while (v69 != v81);
          v69 = (char *)__p[1];
        }
        __p[1] = v79;
        *(_QWORD *)&v111 = v74;
        *((_QWORD *)&v111 + 1) = v80;
        if (v69)
          operator delete(v69);
      }
      else
      {
        *(_QWORD *)v111 = v69;
        v74 = (_QWORD *)(v73 + 8);
      }
      v71 = v72 + 9;
      *(_QWORD *)&v111 = v74;
    }
    else
    {
      if (!v69)
        __cxa_bad_cast();
      v71 = v69 + 9;
    }
    v55 = 1;
    *v71 = 1;
  }
  if (capabilities::ct::supportsUplinkHealthUpdate((capabilities::ct *)v69))
  {
    v83 = (const void **)__p[1];
    if (__p[1] != (void *)v111)
    {
      while (*((unsigned __int8 *)*v83 + 8) != 164)
      {
        if (++v83 == (const void **)v111)
          goto LABEL_145;
      }
    }
    if (v83 == (const void **)v111)
    {
LABEL_145:
      v86 = operator new();
      v87 = v86;
      *(_WORD *)(v86 + 8) = 164;
      *(_QWORD *)v86 = &off_24D5C4BD0;
      v88 = v111;
      if ((unint64_t)v111 >= *((_QWORD *)&v111 + 1))
      {
        v90 = (uint64_t)(v111 - (unint64_t)__p[1]) >> 3;
        if ((unint64_t)(v90 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v91 = (uint64_t)(*((_QWORD *)&v111 + 1) - (unint64_t)__p[1]) >> 2;
        if (v91 <= v90 + 1)
          v91 = v90 + 1;
        if (*((_QWORD *)&v111 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v92 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v92 = v91;
        if (v92)
          v93 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v111 + 8, v92);
        else
          v93 = 0;
        v94 = (uint64_t *)&v93[8 * v90];
        v95 = &v93[8 * v92];
        *v94 = v87;
        v89 = v94 + 1;
        v97 = (char *)__p[1];
        v96 = (char *)v111;
        if ((void *)v111 != __p[1])
        {
          do
          {
            v98 = *((_QWORD *)v96 - 1);
            v96 -= 8;
            *--v94 = v98;
          }
          while (v96 != v97);
          v96 = (char *)__p[1];
        }
        __p[1] = v94;
        *(_QWORD *)&v111 = v89;
        *((_QWORD *)&v111 + 1) = v95;
        if (v96)
          operator delete(v96);
      }
      else
      {
        *(_QWORD *)v111 = v86;
        v89 = (_QWORD *)(v88 + 8);
      }
      v85 = (_BYTE *)(v87 + 9);
      *(_QWORD *)&v111 = v89;
    }
    else
    {
      if (!v84)
        __cxa_bad_cast();
      v85 = v84 + 9;
    }
    *v85 = 1;
  }
  else if (!v55)
  {
    goto LABEL_167;
  }
  v105 = (_QWORD *)((char *)v1 + 104);
  v106 = QMIServiceMsg::create();
  v107 = 25000;
  v108 = 0;
  v109 = 0;
  v100 = MEMORY[0x24BDAC760];
  v101 = 0x40000000;
  v102 = ___ZN33QMIDataSystemDeterminationManager32registerIndicationReporting_syncEv_block_invoke;
  v103 = &__block_descriptor_tmp_25;
  v104 = v1;
  aBlock = MEMORY[0x24BDAC760];
  v113 = 0x40000000;
  v114 = ___ZNO3qmi6Client9SendProxy8callbackIRKN3dsd18RegisterIndication8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
  v115 = &unk_24D5C4C00;
  v116 = &v100;
  v99 = _Block_copy(&aBlock);
  v109 = v99;
  if (v106)
  {
    qmi::Client::send();
    v99 = v109;
  }
  if (v99)
    _Block_release(v99);
LABEL_167:
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
}

void sub_2168DEE70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *aBlock, char a19)
{
  if (a15)
    qmi::Client::send();
  if (aBlock)
    _Block_release(aBlock);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a19);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<QMIDataSystemDeterminationManager::handleQMIClientStarted_sync(void)::$_0,std::allocator<QMIDataSystemDeterminationManager::handleQMIClientStarted_sync(void)::$_0>,void ()(void)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<QMIDataSystemDeterminationManager::handleQMIClientStarted_sync(void)::$_0,std::allocator<QMIDataSystemDeterminationManager::handleQMIClientStarted_sync(void)::$_0>,void ()(void)>::target_type()
{
}

void std::__throw_bad_function_call[abi:ne180100]()
{
  _QWORD *exception;

  exception = __cxa_allocate_exception(8uLL);
}

void std::bad_function_call::~bad_function_call(std::bad_function_call *this)
{
  std::exception::~exception(this);
  JUMPOUT(0x2199FEAC4);
}

void qmi::MutableMessageBase::TlvWrapper<dsd::tlv::SubscriptionType>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<dsd::tlv::SubscriptionType>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

_DWORD **qmi::MutableMessageBase::TlvWrapper<dsd::tlv::SubscriptionType>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _DWORD *v4;
  uint64_t v5;
  _DWORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_DWORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::PktDataHandle>((_DWORD **)a2, (_DWORD *)(a1 + 12));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<dsd::tlv::SubscriptionType>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C48D8;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a1 + 12);
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<dsd::tlv::ReportDataSystemStatus>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<dsd::tlv::ReportDataSystemStatus>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<dsd::tlv::ReportDataSystemStatus>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<dsd::tlv::ReportDataSystemStatus>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C4950;
  return result;
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3dsd18SystemStatusChange8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2168DF1EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3dsd26GetCurrentDataSystemStatus8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2168DF2E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3dsd9GetUiInfo8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2168DF3E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<dsd::tlv::ReportUiChanges>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<dsd::tlv::ReportUiChanges>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<dsd::tlv::ReportUiChanges>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<dsd::tlv::ReportUiChanges>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C4A18;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<dsd::tlv::SuppressSoChange>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<dsd::tlv::SuppressSoChange>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<dsd::tlv::SuppressSoChange>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<dsd::tlv::SuppressSoChange>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C4A68;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<dsd::tlv::SuppressNullBearerChange>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<dsd::tlv::SuppressNullBearerChange>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<dsd::tlv::SuppressNullBearerChange>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<dsd::tlv::SuppressNullBearerChange>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C4AB8;
  return result;
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3dsd20RegisterUiInfoChange8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2168DF720(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<dsd::tlv::ReportThroughputEstimateInfo>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<dsd::tlv::ReportThroughputEstimateInfo>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<dsd::tlv::ReportThroughputEstimateInfo>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<dsd::tlv::ReportThroughputEstimateInfo>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C4B30;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<dsd::tlv::ReportDynamicRRCReleaseVersion>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<dsd::tlv::ReportDynamicRRCReleaseVersion>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<dsd::tlv::ReportDynamicRRCReleaseVersion>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<dsd::tlv::ReportDynamicRRCReleaseVersion>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C4B80;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<dsd::tlv::ReportUplinkHealth>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<dsd::tlv::ReportUplinkHealth>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<dsd::tlv::ReportUplinkHealth>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<dsd::tlv::ReportUplinkHealth>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C4BD0;
  return result;
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3dsd18RegisterIndication8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BYTE v3[24];

  v2 = *(_QWORD *)(a1 + 32);
  cast_message_type<dsd::RegisterIndication::Response const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_2168DF9E8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void cast_message_type<dsd::RegisterIndication::Response const&>::cast(uint64_t a1@<X0>, qmi::ResponseBase *a2@<X8>)
{
  if (*(_DWORD *)(a1 + 40) != 1 || *(_WORD *)(a1 + 44) == 3)
  {
    QMIServiceMsg::serialize((QMIServiceMsg *)a1);
    qmi::Response<(unsigned short)56,dsd::RegisterIndication::ResponseTLVList>::Response(a2, 0);
  }
  else
  {
    QMIServiceMsg::getNewError((QMIServiceMsg *)a1);
    qmi::Response<(unsigned short)56,dsd::RegisterIndication::ResponseTLVList>::Response((uint64_t)a2);
  }
}

void sub_2168DFA88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t qmi::Response<(unsigned short)56,dsd::RegisterIndication::ResponseTLVList>::Response(uint64_t a1)
{
  qmi::MessageBase *v2;

  v2 = (qmi::MessageBase *)qmi::MessageBase::MessageBase();
  qmi::MessageBase::validateMsgId(v2);
  return a1;
}

void sub_2168DFAD0(_Unwind_Exception *a1)
{
  qmi::MessageBase *v1;

  qmi::MessageBase::~MessageBase(v1);
  _Unwind_Resume(a1);
}

qmi::ResponseBase *qmi::Response<(unsigned short)56,dsd::RegisterIndication::ResponseTLVList>::Response(qmi::ResponseBase *a1, const void *a2)
{
  qmi::MessageBase *v3;

  v3 = (qmi::MessageBase *)qmi::ResponseBase::ResponseBase(a1, a2);
  qmi::MessageBase::validateMsgId(v3);
  return a1;
}

void sub_2168DFB10(_Unwind_Exception *a1)
{
  qmi::MessageBase *v1;

  qmi::MessageBase::~MessageBase(v1);
  _Unwind_Resume(a1);
}

void ___ZZN33QMIDataSystemDeterminationManager38handleDynamicRRCReleaseVersionInd_syncERKN3dsd24DynamicRRCReleaseVersion10IndicationEENK3__0clERKNS0_3tlv6ReasonE_block_invoke(uint64_t a1, uint64_t a2)
{
  int v3;
  NSObject *v4;
  _BOOL4 v5;
  int v6;
  ctu::rest::detail *v7;
  uint64_t v8;
  const char *v9;
  xpc_object_t object;
  uint8_t buf[8];
  char v12;
  xpc_object_t v13;

  v3 = *(_DWORD *)(a2 + 4);
  v4 = *(NSObject **)(*(_QWORD *)(a1 + 32) + 56);
  v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (v3)
  {
    if (v5)
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#N PDC activate configuration for Dynamic RRC failed", buf, 2u);
    }
  }
  else
  {
    if (v5)
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I PDC activate configuration for Dynamic RRC initiated", buf, 2u);
    }
    v6 = *(_DWORD *)(a1 + 40);
    v13 = 0;
    v7 = (ctu::rest::detail *)v6;
    v8 = subscriber::asString();
    ctu::rest::detail::write_enum_string_value(v7, v8, v9);
    std::string::basic_string[abi:ne180100]<0>(buf, "/cc/events/baseband_refresh_start");
    object = v13;
    v13 = xpc_null_create();
    ctu::RestModule::sendEvent();
    xpc_release(object);
    if (v12 < 0)
      operator delete(*(void **)buf);
    xpc_release(v13);
  }
}

void sub_2168DFC48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, xpc_object_t a17)
{
  xpc_release(object);
  if (a16 < 0)
    operator delete(__p);
  xpc_release(a17);
  _Unwind_Resume(a1);
}

uint64_t qmi::MutableMessageBase::getTLV<pdc::tlv::ConfigurationType>(_QWORD *a1, int a2)
{
  const void **v2;
  const void **v3;
  void *v4;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3)
        return qmi::MutableMessageBase::createTLV<pdc::tlv::ConfigurationType>(a1, a2);
    }
  }
  if (v2 == v3)
    return qmi::MutableMessageBase::createTLV<pdc::tlv::ConfigurationType>(a1, a2);
  if (!v4)
    __cxa_bad_cast();
  return (uint64_t)v4 + 12;
}

uint64_t qmi::MutableMessageBase::createTLV<pdc::tlv::ConfigurationType>(_QWORD *a1, char a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v4 = operator new();
  *(_BYTE *)(v4 + 8) = a2;
  *(_DWORD *)(v4 + 12) = 0;
  *(_QWORD *)v4 = &off_24D5C4C68;
  v5 = a1[3];
  v6 = (uint64_t *)a1[2];
  if ((unint64_t)v6 >= v5)
  {
    v8 = a1[1];
    v9 = ((uint64_t)v6 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v5 - v8;
    v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1))
      v11 = v9 + 1;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v12);
    else
      v13 = 0;
    v14 = (uint64_t *)&v13[8 * v9];
    v15 = &v13[8 * v12];
    *v14 = v4;
    v7 = v14 + 1;
    v17 = (char *)a1[1];
    v16 = (char *)a1[2];
    if (v16 != v17)
    {
      do
      {
        v18 = *((_QWORD *)v16 - 1);
        v16 -= 8;
        *--v14 = v18;
      }
      while (v16 != v17);
      v16 = (char *)a1[1];
    }
    a1[1] = v14;
    a1[2] = v7;
    a1[3] = v15;
    if (v16)
      operator delete(v16);
  }
  else
  {
    *v6 = v4;
    v7 = v6 + 1;
  }
  a1[2] = v7;
  return v4 + 12;
}

void qmi::MutableMessageBase::TlvWrapper<pdc::tlv::ConfigurationType>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<pdc::tlv::ConfigurationType>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

_DWORD **qmi::MutableMessageBase::TlvWrapper<pdc::tlv::ConfigurationType>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _DWORD *v4;
  uint64_t v5;
  _DWORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_DWORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::PktDataHandle>((_DWORD **)a2, (_DWORD *)(a1 + 12));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<pdc::tlv::ConfigurationType>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C4C68;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a1 + 12);
  return result;
}

uint64_t qmi::MutableMessageBase::getTLV<pdc::tlv::IndicationToken>(_QWORD *a1, int a2)
{
  const void **v2;
  const void **v3;
  void *v4;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3)
        return qmi::MutableMessageBase::createTLV<pdc::tlv::IndicationToken>(a1, a2);
    }
  }
  if (v2 == v3)
    return qmi::MutableMessageBase::createTLV<pdc::tlv::IndicationToken>(a1, a2);
  if (!v4)
    __cxa_bad_cast();
  return (uint64_t)v4 + 12;
}

uint64_t qmi::MutableMessageBase::createTLV<pdc::tlv::IndicationToken>(_QWORD *a1, char a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v4 = operator new();
  *(_BYTE *)(v4 + 8) = a2;
  *(_DWORD *)(v4 + 12) = 0;
  *(_QWORD *)v4 = &off_24D5C4CB8;
  v5 = a1[3];
  v6 = (uint64_t *)a1[2];
  if ((unint64_t)v6 >= v5)
  {
    v8 = a1[1];
    v9 = ((uint64_t)v6 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v5 - v8;
    v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1))
      v11 = v9 + 1;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v12);
    else
      v13 = 0;
    v14 = (uint64_t *)&v13[8 * v9];
    v15 = &v13[8 * v12];
    *v14 = v4;
    v7 = v14 + 1;
    v17 = (char *)a1[1];
    v16 = (char *)a1[2];
    if (v16 != v17)
    {
      do
      {
        v18 = *((_QWORD *)v16 - 1);
        v16 -= 8;
        *--v14 = v18;
      }
      while (v16 != v17);
      v16 = (char *)a1[1];
    }
    a1[1] = v14;
    a1[2] = v7;
    a1[3] = v15;
    if (v16)
      operator delete(v16);
  }
  else
  {
    *v6 = v4;
    v7 = v6 + 1;
  }
  a1[2] = v7;
  return v4 + 12;
}

void qmi::MutableMessageBase::TlvWrapper<pdc::tlv::IndicationToken>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<pdc::tlv::IndicationToken>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

_DWORD **qmi::MutableMessageBase::TlvWrapper<pdc::tlv::IndicationToken>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _DWORD *v4;
  uint64_t v5;
  _DWORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_DWORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::PktDataHandle>((_DWORD **)a2, (_DWORD *)(a1 + 12));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<pdc::tlv::IndicationToken>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C4CB8;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a1 + 12);
  return result;
}

uint64_t qmi::MutableMessageBase::getTLV<pdc::tlv::ActivationType>(_QWORD *a1, int a2)
{
  const void **v2;
  const void **v3;
  void *v4;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3)
        return qmi::MutableMessageBase::createTLV<pdc::tlv::ActivationType>(a1, a2);
    }
  }
  if (v2 == v3)
    return qmi::MutableMessageBase::createTLV<pdc::tlv::ActivationType>(a1, a2);
  if (!v4)
    __cxa_bad_cast();
  return (uint64_t)v4 + 12;
}

uint64_t qmi::MutableMessageBase::createTLV<pdc::tlv::ActivationType>(_QWORD *a1, char a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v4 = operator new();
  *(_BYTE *)(v4 + 8) = a2;
  *(_DWORD *)(v4 + 12) = 0;
  *(_QWORD *)v4 = &off_24D5C4D08;
  v5 = a1[3];
  v6 = (uint64_t *)a1[2];
  if ((unint64_t)v6 >= v5)
  {
    v8 = a1[1];
    v9 = ((uint64_t)v6 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v5 - v8;
    v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1))
      v11 = v9 + 1;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v12);
    else
      v13 = 0;
    v14 = (uint64_t *)&v13[8 * v9];
    v15 = &v13[8 * v12];
    *v14 = v4;
    v7 = v14 + 1;
    v17 = (char *)a1[1];
    v16 = (char *)a1[2];
    if (v16 != v17)
    {
      do
      {
        v18 = *((_QWORD *)v16 - 1);
        v16 -= 8;
        *--v14 = v18;
      }
      while (v16 != v17);
      v16 = (char *)a1[1];
    }
    a1[1] = v14;
    a1[2] = v7;
    a1[3] = v15;
    if (v16)
      operator delete(v16);
  }
  else
  {
    *v6 = v4;
    v7 = v6 + 1;
  }
  a1[2] = v7;
  return v4 + 12;
}

void qmi::MutableMessageBase::TlvWrapper<pdc::tlv::ActivationType>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<pdc::tlv::ActivationType>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

_DWORD **qmi::MutableMessageBase::TlvWrapper<pdc::tlv::ActivationType>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _DWORD *v4;
  uint64_t v5;
  _DWORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_DWORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::PktDataHandle>((_DWORD **)a2, (_DWORD *)(a1 + 12));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<pdc::tlv::ActivationType>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C4D08;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a1 + 12);
  return result;
}

uint64_t qmi::MutableMessageBase::getTLV<pdc::tlv::SlotId>(_QWORD *a1, int a2)
{
  const void **v2;
  const void **v3;
  void *v4;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3)
        return qmi::MutableMessageBase::createTLV<pdc::tlv::SlotId>(a1, a2);
    }
  }
  if (v2 == v3)
    return qmi::MutableMessageBase::createTLV<pdc::tlv::SlotId>(a1, a2);
  if (!v4)
    __cxa_bad_cast();
  return (uint64_t)v4 + 12;
}

uint64_t qmi::MutableMessageBase::createTLV<pdc::tlv::SlotId>(_QWORD *a1, char a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v4 = operator new();
  *(_BYTE *)(v4 + 8) = a2;
  *(_DWORD *)(v4 + 12) = 0;
  *(_QWORD *)v4 = &off_24D5C4D58;
  v5 = a1[3];
  v6 = (uint64_t *)a1[2];
  if ((unint64_t)v6 >= v5)
  {
    v8 = a1[1];
    v9 = ((uint64_t)v6 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v5 - v8;
    v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1))
      v11 = v9 + 1;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v12);
    else
      v13 = 0;
    v14 = (uint64_t *)&v13[8 * v9];
    v15 = &v13[8 * v12];
    *v14 = v4;
    v7 = v14 + 1;
    v17 = (char *)a1[1];
    v16 = (char *)a1[2];
    if (v16 != v17)
    {
      do
      {
        v18 = *((_QWORD *)v16 - 1);
        v16 -= 8;
        *--v14 = v18;
      }
      while (v16 != v17);
      v16 = (char *)a1[1];
    }
    a1[1] = v14;
    a1[2] = v7;
    a1[3] = v15;
    if (v16)
      operator delete(v16);
  }
  else
  {
    *v6 = v4;
    v7 = v6 + 1;
  }
  a1[2] = v7;
  return v4 + 12;
}

void qmi::MutableMessageBase::TlvWrapper<pdc::tlv::SlotId>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<pdc::tlv::SlotId>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

_DWORD **qmi::MutableMessageBase::TlvWrapper<pdc::tlv::SlotId>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _DWORD *v4;
  uint64_t v5;
  _DWORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_DWORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::PktDataHandle>((_DWORD **)a2, (_DWORD *)(a1 + 12));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<pdc::tlv::SlotId>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C4D58;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a1 + 12);
  return result;
}

uint64_t qmi::MutableMessageBase::getTLV<pdc::tlv::SubscriptionId>(_QWORD *a1, int a2)
{
  const void **v2;
  const void **v3;
  void *v4;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3)
        return qmi::MutableMessageBase::createTLV<pdc::tlv::SubscriptionId>(a1, a2);
    }
  }
  if (v2 == v3)
    return qmi::MutableMessageBase::createTLV<pdc::tlv::SubscriptionId>(a1, a2);
  if (!v4)
    __cxa_bad_cast();
  return (uint64_t)v4 + 12;
}

uint64_t qmi::MutableMessageBase::createTLV<pdc::tlv::SubscriptionId>(_QWORD *a1, char a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v4 = operator new();
  *(_BYTE *)(v4 + 8) = a2;
  *(_DWORD *)(v4 + 12) = 0;
  *(_QWORD *)v4 = &off_24D5C4DA8;
  v5 = a1[3];
  v6 = (uint64_t *)a1[2];
  if ((unint64_t)v6 >= v5)
  {
    v8 = a1[1];
    v9 = ((uint64_t)v6 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v5 - v8;
    v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1))
      v11 = v9 + 1;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v12);
    else
      v13 = 0;
    v14 = (uint64_t *)&v13[8 * v9];
    v15 = &v13[8 * v12];
    *v14 = v4;
    v7 = v14 + 1;
    v17 = (char *)a1[1];
    v16 = (char *)a1[2];
    if (v16 != v17)
    {
      do
      {
        v18 = *((_QWORD *)v16 - 1);
        v16 -= 8;
        *--v14 = v18;
      }
      while (v16 != v17);
      v16 = (char *)a1[1];
    }
    a1[1] = v14;
    a1[2] = v7;
    a1[3] = v15;
    if (v16)
      operator delete(v16);
  }
  else
  {
    *v6 = v4;
    v7 = v6 + 1;
  }
  a1[2] = v7;
  return v4 + 12;
}

void qmi::MutableMessageBase::TlvWrapper<pdc::tlv::SubscriptionId>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<pdc::tlv::SubscriptionId>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

_DWORD **qmi::MutableMessageBase::TlvWrapper<pdc::tlv::SubscriptionId>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _DWORD *v4;
  uint64_t v5;
  _DWORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_DWORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::PktDataHandle>((_DWORD **)a2, (_DWORD *)(a1 + 12));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<pdc::tlv::SubscriptionId>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C4DA8;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a1 + 12);
  return result;
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3pdc14ActivateConfig8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BYTE v3[24];

  v2 = *(_QWORD *)(a1 + 32);
  cast_message_type<pdc::ActivateConfig::Response const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_2168E088C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void cast_message_type<pdc::ActivateConfig::Response const&>::cast(uint64_t a1@<X0>, qmi::ResponseBase *a2@<X8>)
{
  if (*(_DWORD *)(a1 + 40) != 1 || *(_WORD *)(a1 + 44) == 3)
  {
    QMIServiceMsg::serialize((QMIServiceMsg *)a1);
    qmi::Response<(unsigned short)39,pdc::ActivateConfig::ResponseTLVList>::Response(a2, 0);
  }
  else
  {
    QMIServiceMsg::getNewError((QMIServiceMsg *)a1);
    qmi::Response<(unsigned short)39,pdc::ActivateConfig::ResponseTLVList>::Response((uint64_t)a2);
  }
}

void sub_2168E092C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t qmi::Response<(unsigned short)39,pdc::ActivateConfig::ResponseTLVList>::Response(uint64_t a1)
{
  qmi::MessageBase *v2;

  v2 = (qmi::MessageBase *)qmi::MessageBase::MessageBase();
  qmi::MessageBase::validateMsgId(v2);
  return a1;
}

void sub_2168E0974(_Unwind_Exception *a1)
{
  qmi::MessageBase *v1;

  qmi::MessageBase::~MessageBase(v1);
  _Unwind_Resume(a1);
}

qmi::ResponseBase *qmi::Response<(unsigned short)39,pdc::ActivateConfig::ResponseTLVList>::Response(qmi::ResponseBase *a1, const void *a2)
{
  qmi::MessageBase *v3;

  v3 = (qmi::MessageBase *)qmi::ResponseBase::ResponseBase(a1, a2);
  qmi::MessageBase::validateMsgId(v3);
  return a1;
}

void sub_2168E09B4(_Unwind_Exception *a1)
{
  qmi::MessageBase *v1;

  qmi::MessageBase::~MessageBase(v1);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3dsd22ThroughputEstimateInfo8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2168E0A84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void QMISMSCommandDriver::create(uint64_t a1@<X0>, dispatch_object_t *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v6;
  NSObject *object;

  *a3 = 0;
  a3[1] = 0;
  v6 = operator new();
  object = *a2;
  if (*a2)
    dispatch_retain(*a2);
  QMISMSCommandDriver::QMISMSCommandDriver(v6, a1);
  *a3 = 0;
  a3[1] = 0;
  std::shared_ptr<QMISMSCommandDriver>::shared_ptr[abi:ne180100]<QMISMSCommandDriver,std::shared_ptr<QMISMSCommandDriver> ctu::SharedSynchronizable<CSISMSCommandDriver>::make_shared_ptr<QMISMSCommandDriver>(QMISMSCommandDriver*)::{lambda(QMISMSCommandDriver*)#1},void>(a3, v6);
  if (object)
    dispatch_release(object);
}

void sub_2168E0B5C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object)
{
  uint64_t v10;
  int v11;

  if (object)
    dispatch_release(object);
  if (v11)
    MEMORY[0x2199FEAC4](v10, 0x10E1C4064771F02);
  _Unwind_Resume(exception_object);
}

uint64_t QMISMSCommandDriver::QMISMSCommandDriver(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD v8[3];
  _QWORD *v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v4 = CSISMSCommandDriver::CSISMSCommandDriver();
  v8[0] = &unk_24D5C4F88;
  v9 = v8;
  SimInstanceLogger<QMISMSCommandDriver,ctu::OsLogLogger,subscriber::SimSlot,std::function<char const* const ()(subscriber::SimSlot)>>::SimInstanceLogger((capabilities::ct *)(v4 + 88), a2, (uint64_t)v8);
  v5 = v9;
  if (v9 == v8)
  {
    v6 = 4;
    v5 = v8;
    goto LABEL_5;
  }
  if (v9)
  {
    v6 = 5;
LABEL_5:
    (*(void (**)(void))(*v5 + 8 * v6))();
  }
  *(_QWORD *)a1 = off_24D5C4E30;
  qmi::ClientRouter::ClientRouter((qmi::ClientRouter *)(a1 + 96), *(os_log_s **)(a1 + 40));
  return a1;
}

void sub_2168E0C74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  CSISMSCommandDriver *v13;
  uint64_t *v14;
  uint64_t v16;

  v16 = *v14;
  *v14 = 0;
  if (v16)
    (*(void (**)(uint64_t))(*(_QWORD *)v16 + 8))(v16);
  CSISMSCommandDriver::~CSISMSCommandDriver(v13);
  _Unwind_Resume(a1);
}

const char *`anonymous namespace'::sGetLogDomainForInstance(int a1)
{
  const char *v1;

  v1 = "msg.sms.qmi?";
  if (a1 == 2)
    v1 = "msg.sms.qmi.2";
  if (a1 == 1)
    return "msg.sms.qmi.1";
  else
    return v1;
}

{
  const char *v1;

  v1 = "set.bb.qmi.?";
  if (a1 == 2)
    v1 = "set.bb.qmi.2";
  if (a1 == 1)
    return "set.bb.qmi.1";
  else
    return v1;
}

{
  const char *v1;

  v1 = "sig.qmi.?";
  if (a1 == 2)
    v1 = "Embms.QMIDriver.2";
  if (a1 == 1)
    return "Embms.QMIDriver.1";
  else
    return v1;
}

{
  const char *v1;

  v1 = "elqm.qmi.?";
  if (a1 == 2)
    v1 = "elqm.qmi.2";
  if (a1 == 1)
    return "elqm.qmi.1";
  else
    return v1;
}

{
  const char *v1;

  v1 = "cm.qmi.?";
  if (a1 == 2)
    v1 = "cm.qmi.2";
  if (a1 == 1)
    return "cm.qmi.1";
  else
    return v1;
}

{
  const char *v1;

  v1 = "set.cdma.qmi.?";
  if (a1 == 2)
    v1 = "set.cdma.qmi.2";
  if (a1 == 1)
    return "set.cdma.qmi.1";
  else
    return v1;
}

{
  const char *v1;

  v1 = "pb.qmi.?";
  if (a1 == 2)
    v1 = "pb.qmi.2";
  if (a1 == 1)
    return "pb.qmi.1";
  else
    return v1;
}

{
  const char *v1;

  v1 = "pp.ibi.?";
  if (a1 == 2)
    v1 = "pp.qmi.2";
  if (a1 == 1)
    return "pp.qmi.1";
  else
    return v1;
}

{
  const char *v1;

  v1 = "pnp.qmi.?";
  if (a1 == 2)
    v1 = "pnp.qmi.2";
  if (a1 == 1)
    return "pnp.qmi.1";
  else
    return v1;
}

{
  const char *v1;

  v1 = "dfs.qmi.?";
  if (a1 == 2)
    v1 = "dfs.qmi.2";
  if (a1 == 1)
    return "dfs.qmi.1";
  else
    return v1;
}

{
  const char *v1;

  v1 = "dese.qmi.?";
  if (a1 == 2)
    v1 = "dese.qmi.2";
  if (a1 == 1)
    return "dese.qmi.1";
  else
    return v1;
}

{
  const char *v1;

  v1 = "sig.qmi.?";
  if (a1 == 2)
    v1 = "sig.qmi.2";
  if (a1 == 1)
    return "sig.qmi.1";
  else
    return v1;
}

{
  const char *v1;

  v1 = "call.CmdDriver.Eureka.sim?";
  if (a1 == 2)
    v1 = "call.CmdDriver.Eureka.sim2";
  if (a1 == 1)
    return "call.CmdDriver.Eureka.sim1";
  else
    return v1;
}

{
  const char *v1;

  v1 = "man.qmi.?";
  if (a1 == 2)
    v1 = "man.qmi.2";
  if (a1 == 1)
    return "man.qmi.1";
  else
    return v1;
}

{
  const char *v1;

  v1 = "subscr.dms.qmi.?";
  if (a1 == 2)
    v1 = "subscr.dms.qmi.2";
  if (a1 == 1)
    return "subscr.dms.qmi.1";
  else
    return v1;
}

{
  const char *v1;

  v1 = "set.supp.qmi.?";
  if (a1 == 2)
    v1 = "set.supp.qmi.2";
  if (a1 == 1)
    return "set.supp.qmi.1";
  else
    return v1;
}

{
  const char *v1;

  v1 = "reg.qmi.?";
  if (a1 == 2)
    v1 = "reg.qmi.2";
  if (a1 == 1)
    return "reg.qmi.1";
  else
    return v1;
}

capabilities::ct *SimInstanceLogger<QMISMSCommandDriver,ctu::OsLogLogger,subscriber::SimSlot,std::function<char const* const ()(subscriber::SimSlot)>>::SimInstanceLogger(capabilities::ct *a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  _BYTE v12[24];
  _BYTE *v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)a1 = 0;
  if ((capabilities::ct::supportsGemini(a1) & 1) == 0)
  {
    v5 = (_QWORD *)operator new();
    v6 = *(_QWORD *)a1;
    *(_QWORD *)a1 = v5;
    *v5 = &off_24D5C5038;
    v5[1] = (char *)a1 - 88;
    if (!v6)
      return a1;
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
  }
  if (*(_QWORD *)a1)
    return a1;
  v7 = (_QWORD *)operator new();
  std::__function::__value_func<char const* const ()(subscriber::SimSlot)>::__value_func[abi:ne180100]((uint64_t)v12, a3);
  SimInstanceLoggerDefault<ctu::OsLogLogger,subscriber::SimSlot,std::function<char const* const ()(subscriber::SimSlot)>>::SimInstanceLoggerDefault(v7);
  v8 = v13;
  if (v13 == v12)
  {
    v9 = 4;
    v8 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_10;
    v9 = 5;
  }
  (*(void (**)(void))(*v8 + 8 * v9))();
LABEL_10:
  v10 = *(_QWORD *)a1;
  *(_QWORD *)a1 = v7;
  if (v10)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 8))(v10);
  return a1;
}

void sub_2168E0E3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  uint64_t *v13;
  uint64_t v14;
  char *v15;
  char *v17;
  uint64_t v18;
  uint64_t v19;

  v17 = a13;
  if (a13 == v15)
  {
    v18 = 4;
    v17 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v18 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v17 + 8 * v18))();
LABEL_6:
  MEMORY[0x2199FEAC4](v14, 0x10A1C40FF1576FELL);
  v19 = *v13;
  *v13 = 0;
  if (v19)
    (*(void (**)(uint64_t))(*(_QWORD *)v19 + 8))(v19);
  _Unwind_Resume(a1);
}

void QMISMSCommandDriver::~QMISMSCommandDriver(QMISMSCommandDriver *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_24D5C4E30;
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)this + 96);
  v2 = *((_QWORD *)this + 11);
  *((_QWORD *)this + 11) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  CSISMSCommandDriver::~CSISMSCommandDriver(this);
}

{
  QMISMSCommandDriver::~QMISMSCommandDriver(this);
  JUMPOUT(0x2199FEAC4);
}

void QMISMSCommandDriver::bootstrap(_QWORD *a1, dispatch_object_t *a2)
{
  NSObject *v4;
  NSObject *v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  std::__shared_weak_count *v9;
  _QWORD *v10;
  unint64_t *p_shared_owners;
  NSObject *v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  uint64_t v16;
  uint8_t buf[8];

  v4 = a1[5];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I Bootstraping", buf, 2u);
  }
  v5 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v5);
  }
  v6 = (std::__shared_weak_count *)a1[2];
  if (!v6 || (v7 = a1[1], (v8 = std::__shared_weak_count::lock(v6)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v9 = v8;
  v10 = (_QWORD *)operator new();
  *v10 = a1;
  v10[1] = v5;
  p_shared_owners = (unint64_t *)&v9->__shared_owners_;
  v12 = a1[3];
  do
    v13 = __ldxr(p_shared_owners);
  while (__stxr(v13 + 1, p_shared_owners));
  v14 = (_QWORD *)operator new();
  *v14 = v10;
  v14[1] = v7;
  v14[2] = v9;
  v16 = 0;
  *(_QWORD *)buf = 0;
  dispatch_async_f(v12, v14, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0,dispatch_queue_s *::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>>)::{lambda(void *)#1}::__invoke);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v16);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)buf);
  do
    v15 = __ldaxr(p_shared_owners);
  while (__stlxr(v15 - 1, p_shared_owners));
  if (!v15)
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
}

void QMISMSCommandDriver::sendIndRegisterRequest_sync(uint64_t a1, int a2)
{
  const void **v4;
  const void **v5;
  const void **v6;
  char *v7;
  _BYTE *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  char *v15;
  const void **v16;
  char *v17;
  char *v18;
  char *v19;
  const void *v20;
  char *v21;
  _BYTE *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;
  char *v29;
  const void **v30;
  char *v31;
  char *v32;
  char *v33;
  const void *v34;
  const void **v35;
  const void **v36;
  char *v37;
  _BYTE *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  char *v45;
  const void **v46;
  char *v47;
  char *v48;
  char *v49;
  const void *v50;
  char *v51;
  _BYTE *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  unint64_t v57;
  unint64_t v58;
  char *v59;
  const void **v60;
  char *v61;
  char *v62;
  char *v63;
  const void *v64;
  const void **i;
  char *v66;
  _BYTE *v67;
  char *v68;
  uint64_t v69;
  _QWORD *v70;
  uint64_t v71;
  unint64_t v72;
  unint64_t v73;
  char *v74;
  char *v75;
  char *v76;
  char *v77;
  uint64_t v78;
  const void **v79;
  const void **v80;
  const void **v81;
  char *v82;
  _BYTE *v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  unint64_t v88;
  unint64_t v89;
  char *v90;
  const void **v91;
  char *v92;
  char *v93;
  char *v94;
  const void *v95;
  char *v96;
  _BYTE *v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  unint64_t v102;
  unint64_t v103;
  char *v104;
  const void **v105;
  char *v106;
  char *v107;
  char *v108;
  const void *v109;
  const void **v110;
  const void **v111;
  char *v112;
  _BYTE *v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  unint64_t v118;
  unint64_t v119;
  char *v120;
  const void **v121;
  char *v122;
  char *v123;
  char *v124;
  const void *v125;
  char *v126;
  _BYTE *v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  _QWORD *v131;
  uint64_t v132;
  unint64_t v133;
  unint64_t v134;
  char *v135;
  uint64_t *v136;
  char *v137;
  char *v138;
  char *v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  _QWORD *v143;
  unint64_t *v144;
  uint64_t v145;
  unint64_t v146;
  std::__shared_weak_count *v147;
  unint64_t *p_shared_owners;
  unint64_t v149;
  std::__shared_weak_count *v150;
  unint64_t *v151;
  unint64_t v152;
  uint64_t v153;
  uint64_t v154;
  void *__p[2];
  __int128 v156;
  _QWORD v157[5];
  std::__shared_weak_count *v158;
  char *v159;
  std::__shared_weak_count *v160;
  _QWORD aBlock[5];

  *(_OWORD *)__p = 0u;
  v156 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  v4 = (const void **)__p[1];
  v5 = (const void **)v156;
  v6 = (const void **)__p[1];
  if (__p[1] != (void *)v156)
  {
    v6 = (const void **)__p[1];
    while (*((_BYTE *)*v6 + 8) != 16)
    {
      if (++v6 == (const void **)v156)
        goto LABEL_9;
    }
  }
  if (v6 == (const void **)v156)
  {
LABEL_9:
    v9 = operator new();
    v10 = v9;
    *(_WORD *)(v9 + 8) = 16;
    *(_QWORD *)v9 = &off_24D5C5480;
    v11 = v156;
    if ((unint64_t)v156 >= *((_QWORD *)&v156 + 1))
    {
      v12 = (uint64_t)(v156 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v12 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v13 = (uint64_t)(*((_QWORD *)&v156 + 1) - (unint64_t)__p[1]) >> 2;
      if (v13 <= v12 + 1)
        v13 = v12 + 1;
      if (*((_QWORD *)&v156 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v14 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v14 = v13;
      if (v14)
        v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v156 + 8, v14);
      else
        v15 = 0;
      v16 = (const void **)&v15[8 * v12];
      v17 = &v15[8 * v14];
      *v16 = (const void *)v10;
      v5 = v16 + 1;
      v19 = (char *)__p[1];
      v18 = (char *)v156;
      if ((void *)v156 != __p[1])
      {
        do
        {
          v20 = (const void *)*((_QWORD *)v18 - 1);
          v18 -= 8;
          *--v16 = v20;
        }
        while (v18 != v19);
        v18 = (char *)__p[1];
      }
      __p[1] = v16;
      *(_QWORD *)&v156 = v5;
      *((_QWORD *)&v156 + 1) = v17;
      if (v18)
        operator delete(v18);
    }
    else
    {
      *(_QWORD *)v156 = v9;
      v5 = (const void **)(v11 + 8);
    }
    v8 = (_BYTE *)(v10 + 9);
    *(_QWORD *)&v156 = v5;
    v4 = (const void **)__p[1];
  }
  else
  {
    if (!v7)
      __cxa_bad_cast();
    v8 = v7 + 9;
  }
  *v8 = 1;
  while (v4 != v5)
  {
    if (*((_BYTE *)*v4 + 8) == 17)
    {
      if (v4 != v5)
      {
        if (!v21)
          __cxa_bad_cast();
        v22 = v21 + 9;
        goto LABEL_50;
      }
      break;
    }
    ++v4;
  }
  v23 = operator new();
  v24 = v23;
  *(_WORD *)(v23 + 8) = 17;
  *(_QWORD *)v23 = &off_24D5C54D0;
  v25 = v156;
  if ((unint64_t)v156 >= *((_QWORD *)&v156 + 1))
  {
    v26 = (uint64_t)(v156 - (unint64_t)__p[1]) >> 3;
    if ((unint64_t)(v26 + 1) >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v27 = (uint64_t)(*((_QWORD *)&v156 + 1) - (unint64_t)__p[1]) >> 2;
    if (v27 <= v26 + 1)
      v27 = v26 + 1;
    if (*((_QWORD *)&v156 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
      v28 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v28 = v27;
    if (v28)
      v29 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v156 + 8, v28);
    else
      v29 = 0;
    v30 = (const void **)&v29[8 * v26];
    v31 = &v29[8 * v28];
    *v30 = (const void *)v24;
    v5 = v30 + 1;
    v33 = (char *)__p[1];
    v32 = (char *)v156;
    if ((void *)v156 != __p[1])
    {
      do
      {
        v34 = (const void *)*((_QWORD *)v32 - 1);
        v32 -= 8;
        *--v30 = v34;
      }
      while (v32 != v33);
      v32 = (char *)__p[1];
    }
    __p[1] = v30;
    *(_QWORD *)&v156 = v5;
    *((_QWORD *)&v156 + 1) = v31;
    if (v32)
      operator delete(v32);
  }
  else
  {
    *(_QWORD *)v156 = v23;
    v5 = (const void **)(v25 + 8);
  }
  v22 = (_BYTE *)(v24 + 9);
  *(_QWORD *)&v156 = v5;
LABEL_50:
  *v22 = 1;
  v35 = (const void **)__p[1];
  if (__p[1] == v5)
    goto LABEL_58;
  v36 = (const void **)__p[1];
  while (*((_BYTE *)*v36 + 8) != 18)
  {
    if (++v36 == v5)
      goto LABEL_58;
  }
  if (v36 == v5)
  {
LABEL_58:
    v39 = operator new();
    v40 = v39;
    *(_WORD *)(v39 + 8) = 18;
    *(_QWORD *)v39 = &off_24D5C5520;
    v41 = v156;
    if ((unint64_t)v156 >= *((_QWORD *)&v156 + 1))
    {
      v42 = (uint64_t)(v156 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v42 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v43 = (uint64_t)(*((_QWORD *)&v156 + 1) - (unint64_t)__p[1]) >> 2;
      if (v43 <= v42 + 1)
        v43 = v42 + 1;
      if (*((_QWORD *)&v156 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v44 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v44 = v43;
      if (v44)
        v45 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v156 + 8, v44);
      else
        v45 = 0;
      v46 = (const void **)&v45[8 * v42];
      v47 = &v45[8 * v44];
      *v46 = (const void *)v40;
      v5 = v46 + 1;
      v49 = (char *)__p[1];
      v48 = (char *)v156;
      if ((void *)v156 != __p[1])
      {
        do
        {
          v50 = (const void *)*((_QWORD *)v48 - 1);
          v48 -= 8;
          *--v46 = v50;
        }
        while (v48 != v49);
        v48 = (char *)__p[1];
      }
      __p[1] = v46;
      *(_QWORD *)&v156 = v5;
      *((_QWORD *)&v156 + 1) = v47;
      if (v48)
        operator delete(v48);
    }
    else
    {
      *(_QWORD *)v156 = v39;
      v5 = (const void **)(v41 + 8);
    }
    v38 = (_BYTE *)(v40 + 9);
    *(_QWORD *)&v156 = v5;
    v35 = (const void **)__p[1];
  }
  else
  {
    if (!v37)
      __cxa_bad_cast();
    v38 = v37 + 9;
  }
  *v38 = 1;
  while (v35 != v5)
  {
    if (*((_BYTE *)*v35 + 8) == 19)
    {
      if (v35 != v5)
      {
        if (!v51)
          __cxa_bad_cast();
        v52 = v51 + 9;
        goto LABEL_99;
      }
      break;
    }
    ++v35;
  }
  v53 = operator new();
  v54 = v53;
  *(_WORD *)(v53 + 8) = 19;
  *(_QWORD *)v53 = &off_24D5C5570;
  v55 = v156;
  if ((unint64_t)v156 >= *((_QWORD *)&v156 + 1))
  {
    v56 = (uint64_t)(v156 - (unint64_t)__p[1]) >> 3;
    if ((unint64_t)(v56 + 1) >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v57 = (uint64_t)(*((_QWORD *)&v156 + 1) - (unint64_t)__p[1]) >> 2;
    if (v57 <= v56 + 1)
      v57 = v56 + 1;
    if (*((_QWORD *)&v156 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
      v58 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v58 = v57;
    if (v58)
      v59 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v156 + 8, v58);
    else
      v59 = 0;
    v60 = (const void **)&v59[8 * v56];
    v61 = &v59[8 * v58];
    *v60 = (const void *)v54;
    v5 = v60 + 1;
    v63 = (char *)__p[1];
    v62 = (char *)v156;
    if ((void *)v156 != __p[1])
    {
      do
      {
        v64 = (const void *)*((_QWORD *)v62 - 1);
        v62 -= 8;
        *--v60 = v64;
      }
      while (v62 != v63);
      v62 = (char *)__p[1];
    }
    __p[1] = v60;
    *(_QWORD *)&v156 = v5;
    *((_QWORD *)&v156 + 1) = v61;
    if (v62)
      operator delete(v62);
  }
  else
  {
    *(_QWORD *)v156 = v53;
    v5 = (const void **)(v55 + 8);
  }
  v52 = (_BYTE *)(v54 + 9);
  *(_QWORD *)&v156 = v5;
LABEL_99:
  *v52 = 1;
  for (i = (const void **)__p[1]; i != v5; ++i)
  {
    if (*((_BYTE *)*i + 8) == 20)
    {
      if (i != v5)
      {
        if (!v66)
          __cxa_bad_cast();
        v67 = v66 + 9;
        goto LABEL_123;
      }
      break;
    }
  }
  v66 = (char *)operator new();
  v68 = v66;
  *((_WORD *)v66 + 4) = 20;
  *(_QWORD *)v66 = &off_24D5C55C0;
  v69 = v156;
  if ((unint64_t)v156 >= *((_QWORD *)&v156 + 1))
  {
    v71 = (uint64_t)(v156 - (unint64_t)__p[1]) >> 3;
    if ((unint64_t)(v71 + 1) >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v72 = (uint64_t)(*((_QWORD *)&v156 + 1) - (unint64_t)__p[1]) >> 2;
    if (v72 <= v71 + 1)
      v72 = v71 + 1;
    if (*((_QWORD *)&v156 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
      v73 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v73 = v72;
    if (v73)
      v74 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v156 + 8, v73);
    else
      v74 = 0;
    v75 = &v74[8 * v71];
    v76 = &v74[8 * v73];
    *(_QWORD *)v75 = v68;
    v70 = v75 + 8;
    v77 = (char *)__p[1];
    v66 = (char *)v156;
    if ((void *)v156 != __p[1])
    {
      do
      {
        v78 = *((_QWORD *)v66 - 1);
        v66 -= 8;
        *((_QWORD *)v75 - 1) = v78;
        v75 -= 8;
      }
      while (v66 != v77);
      v66 = (char *)__p[1];
    }
    __p[1] = v75;
    *(_QWORD *)&v156 = v70;
    *((_QWORD *)&v156 + 1) = v76;
    if (v66)
      operator delete(v66);
  }
  else
  {
    *(_QWORD *)v156 = v66;
    v70 = (_QWORD *)(v69 + 8);
  }
  v67 = v68 + 9;
  *(_QWORD *)&v156 = v70;
LABEL_123:
  *v67 = 1;
  if (capabilities::ct::supports5G((capabilities::ct *)v66))
  {
    v79 = (const void **)__p[1];
    v80 = (const void **)v156;
    v81 = (const void **)__p[1];
    if (__p[1] != (void *)v156)
    {
      v81 = (const void **)__p[1];
      while (*((_BYTE *)*v81 + 8) != 21)
      {
        if (++v81 == (const void **)v156)
          goto LABEL_132;
      }
    }
    if (v81 == (const void **)v156)
    {
LABEL_132:
      v84 = operator new();
      v85 = v84;
      *(_WORD *)(v84 + 8) = 21;
      *(_QWORD *)v84 = &off_24D5C5610;
      v86 = v156;
      if ((unint64_t)v156 >= *((_QWORD *)&v156 + 1))
      {
        v87 = (uint64_t)(v156 - (unint64_t)__p[1]) >> 3;
        if ((unint64_t)(v87 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v88 = (uint64_t)(*((_QWORD *)&v156 + 1) - (unint64_t)__p[1]) >> 2;
        if (v88 <= v87 + 1)
          v88 = v87 + 1;
        if (*((_QWORD *)&v156 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v89 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v89 = v88;
        if (v89)
          v90 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v156 + 8, v89);
        else
          v90 = 0;
        v91 = (const void **)&v90[8 * v87];
        v92 = &v90[8 * v89];
        *v91 = (const void *)v85;
        v80 = v91 + 1;
        v94 = (char *)__p[1];
        v93 = (char *)v156;
        if ((void *)v156 != __p[1])
        {
          do
          {
            v95 = (const void *)*((_QWORD *)v93 - 1);
            v93 -= 8;
            *--v91 = v95;
          }
          while (v93 != v94);
          v93 = (char *)__p[1];
        }
        __p[1] = v91;
        *(_QWORD *)&v156 = v80;
        *((_QWORD *)&v156 + 1) = v92;
        if (v93)
          operator delete(v93);
      }
      else
      {
        *(_QWORD *)v156 = v84;
        v80 = (const void **)(v86 + 8);
      }
      v83 = (_BYTE *)(v85 + 9);
      *(_QWORD *)&v156 = v80;
      v79 = (const void **)__p[1];
    }
    else
    {
      if (!v82)
        __cxa_bad_cast();
      v83 = v82 + 9;
    }
    *v83 = 1;
    while (v79 != v80)
    {
      if (*((_BYTE *)*v79 + 8) == 22)
      {
        if (v79 != v80)
        {
          if (!v96)
            __cxa_bad_cast();
          v97 = v96 + 9;
          goto LABEL_173;
        }
        break;
      }
      ++v79;
    }
    v98 = operator new();
    v99 = v98;
    *(_WORD *)(v98 + 8) = 22;
    *(_QWORD *)v98 = &off_24D5C5660;
    v100 = v156;
    if ((unint64_t)v156 >= *((_QWORD *)&v156 + 1))
    {
      v101 = (uint64_t)(v156 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v101 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v102 = (uint64_t)(*((_QWORD *)&v156 + 1) - (unint64_t)__p[1]) >> 2;
      if (v102 <= v101 + 1)
        v102 = v101 + 1;
      if (*((_QWORD *)&v156 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v103 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v103 = v102;
      if (v103)
        v104 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v156 + 8, v103);
      else
        v104 = 0;
      v105 = (const void **)&v104[8 * v101];
      v106 = &v104[8 * v103];
      *v105 = (const void *)v99;
      v80 = v105 + 1;
      v108 = (char *)__p[1];
      v107 = (char *)v156;
      if ((void *)v156 != __p[1])
      {
        do
        {
          v109 = (const void *)*((_QWORD *)v107 - 1);
          v107 -= 8;
          *--v105 = v109;
        }
        while (v107 != v108);
        v107 = (char *)__p[1];
      }
      __p[1] = v105;
      *(_QWORD *)&v156 = v80;
      *((_QWORD *)&v156 + 1) = v106;
      if (v107)
        operator delete(v107);
    }
    else
    {
      *(_QWORD *)v156 = v98;
      v80 = (const void **)(v100 + 8);
    }
    v97 = (_BYTE *)(v99 + 9);
    *(_QWORD *)&v156 = v80;
LABEL_173:
    *v97 = 1;
    v110 = (const void **)__p[1];
    if (__p[1] == v80)
      goto LABEL_181;
    v111 = (const void **)__p[1];
    while (*((_BYTE *)*v111 + 8) != 23)
    {
      if (++v111 == v80)
        goto LABEL_181;
    }
    if (v111 == v80)
    {
LABEL_181:
      v114 = operator new();
      v115 = v114;
      *(_WORD *)(v114 + 8) = 23;
      *(_QWORD *)v114 = &off_24D5C56B0;
      v116 = v156;
      if ((unint64_t)v156 >= *((_QWORD *)&v156 + 1))
      {
        v117 = (uint64_t)(v156 - (unint64_t)__p[1]) >> 3;
        if ((unint64_t)(v117 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v118 = (uint64_t)(*((_QWORD *)&v156 + 1) - (unint64_t)__p[1]) >> 2;
        if (v118 <= v117 + 1)
          v118 = v117 + 1;
        if (*((_QWORD *)&v156 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v119 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v119 = v118;
        if (v119)
          v120 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v156 + 8, v119);
        else
          v120 = 0;
        v121 = (const void **)&v120[8 * v117];
        v122 = &v120[8 * v119];
        *v121 = (const void *)v115;
        v80 = v121 + 1;
        v124 = (char *)__p[1];
        v123 = (char *)v156;
        if ((void *)v156 != __p[1])
        {
          do
          {
            v125 = (const void *)*((_QWORD *)v123 - 1);
            v123 -= 8;
            *--v121 = v125;
          }
          while (v123 != v124);
          v123 = (char *)__p[1];
        }
        __p[1] = v121;
        *(_QWORD *)&v156 = v80;
        *((_QWORD *)&v156 + 1) = v122;
        if (v123)
          operator delete(v123);
      }
      else
      {
        *(_QWORD *)v156 = v114;
        v80 = (const void **)(v116 + 8);
      }
      v113 = (_BYTE *)(v115 + 9);
      *(_QWORD *)&v156 = v80;
      v110 = (const void **)__p[1];
    }
    else
    {
      if (!v112)
        __cxa_bad_cast();
      v113 = v112 + 9;
    }
    *v113 = 1;
    while (v110 != v80)
    {
      if (*((_BYTE *)*v110 + 8) == 24)
      {
        if (v110 != v80)
        {
          if (!v126)
            __cxa_bad_cast();
          v127 = v126 + 9;
          goto LABEL_222;
        }
        break;
      }
      ++v110;
    }
    v128 = operator new();
    v129 = v128;
    *(_WORD *)(v128 + 8) = 24;
    *(_QWORD *)v128 = &off_24D5C5700;
    v130 = v156;
    if ((unint64_t)v156 >= *((_QWORD *)&v156 + 1))
    {
      v132 = (uint64_t)(v156 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v132 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v133 = (uint64_t)(*((_QWORD *)&v156 + 1) - (unint64_t)__p[1]) >> 2;
      if (v133 <= v132 + 1)
        v133 = v132 + 1;
      if (*((_QWORD *)&v156 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v134 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v134 = v133;
      if (v134)
        v135 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v156 + 8, v134);
      else
        v135 = 0;
      v136 = (uint64_t *)&v135[8 * v132];
      v137 = &v135[8 * v134];
      *v136 = v129;
      v131 = v136 + 1;
      v139 = (char *)__p[1];
      v138 = (char *)v156;
      if ((void *)v156 != __p[1])
      {
        do
        {
          v140 = *((_QWORD *)v138 - 1);
          v138 -= 8;
          *--v136 = v140;
        }
        while (v138 != v139);
        v138 = (char *)__p[1];
      }
      __p[1] = v136;
      *(_QWORD *)&v156 = v131;
      *((_QWORD *)&v156 + 1) = v137;
      if (v138)
        operator delete(v138);
    }
    else
    {
      *(_QWORD *)v156 = v128;
      v131 = (_QWORD *)(v130 + 8);
    }
    v127 = (_BYTE *)(v129 + 9);
    *(_QWORD *)&v156 = v131;
LABEL_222:
    *v127 = 1;
  }
  v141 = qmi::ClientRouter::get();
  v142 = operator new();
  *(_QWORD *)v142 = v141;
  *(_QWORD *)(v142 + 8) = QMIServiceMsg::create();
  *(_DWORD *)(v142 + 16) = 25000;
  *(_QWORD *)(v142 + 24) = 0;
  *(_QWORD *)(v142 + 32) = 0;
  v154 = v142;
  v143 = operator new(0x28uLL);
  v143[1] = 0;
  v144 = v143 + 1;
  v143[2] = 0;
  *v143 = &off_24D5C5768;
  v143[3] = a1;
  *((_DWORD *)v143 + 8) = a2;
  v159 = (char *)(v143 + 3);
  v160 = (std::__shared_weak_count *)v143;
  v145 = MEMORY[0x24BDAC760];
  v157[0] = MEMORY[0x24BDAC760];
  v157[1] = 1174405120;
  v157[2] = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN19QMISMSCommandDriver27sendIndRegisterRequest_syncENS_16SubscriptionTypeEE3__9EEOS1_OT__block_invoke;
  v157[3] = &__block_descriptor_tmp_3;
  v157[4] = v143 + 3;
  v158 = (std::__shared_weak_count *)v143;
  do
    v146 = __ldxr(v144);
  while (__stxr(v146 + 1, v144));
  aBlock[0] = v145;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3wms18IndicationRegister8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
  aBlock[3] = &unk_24D5C57B0;
  aBlock[4] = v157;
  *(_QWORD *)(v142 + 32) = _Block_copy(aBlock);
  v147 = v158;
  if (v158)
  {
    p_shared_owners = (unint64_t *)&v158->__shared_owners_;
    do
      v149 = __ldaxr(p_shared_owners);
    while (__stlxr(v149 - 1, p_shared_owners));
    if (!v149)
    {
      ((void (*)(std::__shared_weak_count *))v147->__on_zero_shared)(v147);
      std::__shared_weak_count::__release_weak(v147);
    }
  }
  v150 = v160;
  if (v160)
  {
    v151 = (unint64_t *)&v160->__shared_owners_;
    do
      v152 = __ldaxr(v151);
    while (__stlxr(v152 - 1, v151));
    if (!v152)
    {
      ((void (*)(std::__shared_weak_count *))v150->__on_zero_shared)(v150);
      std::__shared_weak_count::__release_weak(v150);
    }
  }
  v153 = v154;
  v154 = 0;
  if (v153)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v154, v153);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
}

void sub_2168E1E3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

void QMISMSCommandDriver::initializeBaseband_sync(uint64_t a1, unsigned int a2)
{
  const void **v4;
  const void **v5;
  const void **v6;
  char *v7;
  _DWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  char *v15;
  const void **v16;
  char *v17;
  char *v18;
  char *v19;
  const void *v20;
  char *v21;
  _DWORD *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  char *v30;
  uint64_t *v31;
  char *v32;
  char *v33;
  char *v34;
  uint64_t v35;
  NSObject *v36;
  uint64_t v37;
  uint64_t v38;
  std::__shared_weak_count *v39;
  unint64_t *p_shared_owners;
  uint64_t v41;
  unint64_t v42;
  std::__shared_weak_count *v43;
  unint64_t *v44;
  unint64_t v45;
  unint64_t v46;
  uint64_t v47;
  const void **v48;
  char *v49;
  _DWORD *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  _QWORD *v54;
  uint64_t v55;
  unint64_t v56;
  unint64_t v57;
  char *v58;
  uint64_t *v59;
  char *v60;
  char *v61;
  char *v62;
  uint64_t v63;
  unsigned int v64;
  uint64_t v65;
  NSObject *v66;
  uint64_t v67;
  uint64_t v68;
  std::__shared_weak_count *v69;
  unint64_t *v70;
  unint64_t v71;
  std::__shared_weak_count *v72;
  unint64_t *v73;
  unint64_t v74;
  unint64_t v75;
  uint64_t v76;
  const void **v77;
  char *v78;
  _DWORD *v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  _QWORD *v83;
  uint64_t v84;
  unint64_t v85;
  unint64_t v86;
  char *v87;
  uint64_t *v88;
  char *v89;
  char *v90;
  char *v91;
  uint64_t v92;
  uint64_t v93;
  NSObject *v94;
  uint64_t v95;
  uint64_t v96;
  std::__shared_weak_count *v97;
  unint64_t *v98;
  unint64_t v99;
  std::__shared_weak_count *v100;
  unint64_t *v101;
  unint64_t v102;
  unint64_t v103;
  uint64_t v104;
  const void **v105;
  char *v106;
  _DWORD *v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  _QWORD *v111;
  uint64_t v112;
  unint64_t v113;
  unint64_t v114;
  char *v115;
  uint64_t *v116;
  char *v117;
  char *v118;
  char *v119;
  uint64_t v120;
  uint64_t v121;
  NSObject *v122;
  uint64_t v123;
  uint64_t v124;
  std::__shared_weak_count *v125;
  unint64_t *v126;
  unint64_t v127;
  std::__shared_weak_count *v128;
  unint64_t *v129;
  unint64_t v130;
  unint64_t v131;
  uint64_t v132;
  uint64_t v133;
  NSObject *v134;
  uint64_t v135;
  uint8_t *v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  std::__shared_weak_count *v140;
  unint64_t *v141;
  unint64_t v142;
  std::__shared_weak_count *v143;
  unint64_t *v144;
  unint64_t v145;
  unint64_t v146;
  uint64_t v147;
  uint64_t v148;
  void *__p[2];
  __int128 v150;
  uint64_t aBlock;
  uint64_t v152;
  void *v153;
  void *v154;
  uint8_t *v155;
  uint8_t buf[8];
  uint64_t v157;
  void *v158;
  uint8_t *v159;
  std::__shared_weak_count *v160;
  std::__shared_weak_count *v161;
  unsigned int v162;
  uint64_t v163;

  v163 = *MEMORY[0x24BDAC8D0];
  *(_OWORD *)__p = 0u;
  v150 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  v4 = (const void **)__p[1];
  v5 = (const void **)v150;
  v6 = (const void **)__p[1];
  if (__p[1] != (void *)v150)
  {
    v6 = (const void **)__p[1];
    while (*((_BYTE *)*v6 + 8) != 16)
    {
      if (++v6 == (const void **)v150)
        goto LABEL_9;
    }
  }
  if (v6 == (const void **)v150)
  {
LABEL_9:
    v9 = operator new();
    v10 = v9;
    *(_BYTE *)(v9 + 8) = 16;
    *(_QWORD *)v9 = &off_24D5C5EA8;
    *(_DWORD *)(v9 + 12) = 0;
    v8 = (_DWORD *)(v9 + 12);
    v11 = v150;
    if ((unint64_t)v150 >= *((_QWORD *)&v150 + 1))
    {
      v12 = (uint64_t)(v150 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v12 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v13 = (uint64_t)(*((_QWORD *)&v150 + 1) - (unint64_t)__p[1]) >> 2;
      if (v13 <= v12 + 1)
        v13 = v12 + 1;
      if (*((_QWORD *)&v150 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v14 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v14 = v13;
      if (v14)
        v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v150 + 8, v14);
      else
        v15 = 0;
      v16 = (const void **)&v15[8 * v12];
      v17 = &v15[8 * v14];
      *v16 = (const void *)v10;
      v5 = v16 + 1;
      v19 = (char *)__p[1];
      v18 = (char *)v150;
      if ((void *)v150 != __p[1])
      {
        do
        {
          v20 = (const void *)*((_QWORD *)v18 - 1);
          v18 -= 8;
          *--v16 = v20;
        }
        while (v18 != v19);
        v18 = (char *)__p[1];
      }
      __p[1] = v16;
      *(_QWORD *)&v150 = v5;
      *((_QWORD *)&v150 + 1) = v17;
      if (v18)
        operator delete(v18);
    }
    else
    {
      *(_QWORD *)v150 = v9;
      v5 = (const void **)(v11 + 8);
    }
    *(_QWORD *)&v150 = v5;
    v4 = (const void **)__p[1];
  }
  else
  {
    if (!v7)
      __cxa_bad_cast();
    v8 = v7 + 12;
  }
  *v8 = 1;
  while (v4 != v5)
  {
    if (*((_BYTE *)*v4 + 8) == 18)
    {
      if (v4 != v5)
      {
        if (!v21)
          __cxa_bad_cast();
        v22 = v21 + 12;
        goto LABEL_50;
      }
      break;
    }
    ++v4;
  }
  v23 = operator new();
  v24 = v23;
  *(_BYTE *)(v23 + 8) = 18;
  *(_QWORD *)v23 = &off_24D5C5EF8;
  *(_DWORD *)(v23 + 12) = 0;
  v22 = (_DWORD *)(v23 + 12);
  v25 = v150;
  if ((unint64_t)v150 >= *((_QWORD *)&v150 + 1))
  {
    v27 = (uint64_t)(v150 - (unint64_t)__p[1]) >> 3;
    if ((unint64_t)(v27 + 1) >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v28 = (uint64_t)(*((_QWORD *)&v150 + 1) - (unint64_t)__p[1]) >> 2;
    if (v28 <= v27 + 1)
      v28 = v27 + 1;
    if (*((_QWORD *)&v150 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
      v29 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v29 = v28;
    if (v29)
      v30 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v150 + 8, v29);
    else
      v30 = 0;
    v31 = (uint64_t *)&v30[8 * v27];
    v32 = &v30[8 * v29];
    *v31 = v24;
    v26 = v31 + 1;
    v34 = (char *)__p[1];
    v33 = (char *)v150;
    if ((void *)v150 != __p[1])
    {
      do
      {
        v35 = *((_QWORD *)v33 - 1);
        v33 -= 8;
        *--v31 = v35;
      }
      while (v33 != v34);
      v33 = (char *)__p[1];
    }
    __p[1] = v31;
    *(_QWORD *)&v150 = v26;
    *((_QWORD *)&v150 + 1) = v32;
    if (v33)
      operator delete(v33);
  }
  else
  {
    *(_QWORD *)v150 = v23;
    v26 = (_QWORD *)(v25 + 8);
  }
  *(_QWORD *)&v150 = v26;
LABEL_50:
  *v22 = 1;
  v36 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_216897000, v36, OS_LOG_TYPE_DEFAULT, "#I Setting event reports...", buf, 2u);
  }
  v37 = qmi::ClientRouter::get();
  v38 = operator new();
  *(_QWORD *)v38 = v37;
  *(_QWORD *)(v38 + 8) = QMIServiceMsg::create();
  *(_DWORD *)(v38 + 16) = 25000;
  *(_QWORD *)(v38 + 24) = 0;
  *(_QWORD *)(v38 + 32) = 0;
  v148 = v38;
  v39 = (std::__shared_weak_count *)operator new(0x20uLL);
  v39->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v39->__shared_owners_;
  v39->__shared_weak_owners_ = 0;
  v39->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C5F60;
  v39[1].__vftable = (std::__shared_weak_count_vtbl *)a1;
  v41 = MEMORY[0x24BDAC760];
  *(_QWORD *)buf = MEMORY[0x24BDAC760];
  v157 = 1174405120;
  v158 = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN19QMISMSCommandDriver14setEventReportENS_16SubscriptionTypeEE3__2EEOS1_OT__block_invoke;
  v159 = (uint8_t *)&__block_descriptor_tmp_52;
  v160 = v39 + 1;
  v161 = v39;
  do
    v42 = __ldxr(p_shared_owners);
  while (__stxr(v42 + 1, p_shared_owners));
  v162 = a2;
  aBlock = v41;
  v152 = 0x40000000;
  v153 = ___ZNO3qmi6Client9SendProxy8callbackIN3wms14SetEventReport8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
  v154 = &unk_24D5C5FA8;
  v155 = buf;
  *(_QWORD *)(v38 + 32) = _Block_copy(&aBlock);
  v43 = v161;
  if (v161)
  {
    v44 = (unint64_t *)&v161->__shared_owners_;
    do
      v45 = __ldaxr(v44);
    while (__stlxr(v45 - 1, v44));
    if (!v45)
    {
      ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
      std::__shared_weak_count::__release_weak(v43);
    }
  }
  do
    v46 = __ldaxr(p_shared_owners);
  while (__stlxr(v46 - 1, p_shared_owners));
  if (!v46)
  {
    ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
    std::__shared_weak_count::__release_weak(v39);
  }
  v47 = v148;
  v148 = 0;
  if (v47)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v148, v47);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
  QMISMSCommandDriver::setRoutes(a1, a2);
  *(_OWORD *)__p = 0u;
  v150 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  v48 = (const void **)__p[1];
  if (__p[1] != (void *)v150)
  {
    while (*((_BYTE *)*v48 + 8) != 1)
    {
      if (++v48 == (const void **)v150)
        goto LABEL_71;
    }
  }
  if (v48 == (const void **)v150)
  {
LABEL_71:
    v51 = operator new();
    v52 = v51;
    *(_BYTE *)(v51 + 8) = 1;
    *(_QWORD *)v51 = &off_24D5C5FF0;
    *(_DWORD *)(v51 + 12) = 0;
    v50 = (_DWORD *)(v51 + 12);
    v53 = v150;
    if ((unint64_t)v150 >= *((_QWORD *)&v150 + 1))
    {
      v55 = (uint64_t)(v150 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v55 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v56 = (uint64_t)(*((_QWORD *)&v150 + 1) - (unint64_t)__p[1]) >> 2;
      if (v56 <= v55 + 1)
        v56 = v55 + 1;
      if (*((_QWORD *)&v150 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v57 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v57 = v56;
      if (v57)
        v58 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v150 + 8, v57);
      else
        v58 = 0;
      v59 = (uint64_t *)&v58[8 * v55];
      v60 = &v58[8 * v57];
      *v59 = v52;
      v54 = v59 + 1;
      v62 = (char *)__p[1];
      v61 = (char *)v150;
      if ((void *)v150 != __p[1])
      {
        do
        {
          v63 = *((_QWORD *)v61 - 1);
          v61 -= 8;
          *--v59 = v63;
        }
        while (v61 != v62);
        v61 = (char *)__p[1];
      }
      __p[1] = v59;
      *(_QWORD *)&v150 = v54;
      *((_QWORD *)&v150 + 1) = v60;
      if (v61)
        operator delete(v61);
    }
    else
    {
      *(_QWORD *)v150 = v51;
      v54 = (_QWORD *)(v53 + 8);
    }
    *(_QWORD *)&v150 = v54;
  }
  else
  {
    if (!v49)
      __cxa_bad_cast();
    v50 = v49 + 12;
  }
  *v50 = 6;
  v64 = a2 - 1;
  if (a2 - 1 >= 3)
    v65 = 0;
  else
    v65 = a2;
  v66 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 88) + 16))(*(_QWORD *)(a1 + 88), v65);
  if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = 6;
    _os_log_impl(&dword_216897000, v66, OS_LOG_TYPE_DEFAULT, "#I Setting DCDisconnectTimer (value: %d)...", buf, 8u);
  }
  v67 = qmi::ClientRouter::get();
  v68 = operator new();
  *(_QWORD *)v68 = v67;
  *(_QWORD *)(v68 + 8) = QMIServiceMsg::create();
  *(_DWORD *)(v68 + 16) = 25000;
  *(_QWORD *)(v68 + 24) = 0;
  *(_QWORD *)(v68 + 32) = 0;
  v148 = v68;
  v69 = (std::__shared_weak_count *)operator new(0x20uLL);
  v69->__shared_owners_ = 0;
  v70 = (unint64_t *)&v69->__shared_owners_;
  v69->__shared_weak_owners_ = 0;
  v69->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C6058;
  v69[1].__vftable = (std::__shared_weak_count_vtbl *)a1;
  *(_QWORD *)buf = v41;
  v157 = 1174405120;
  v158 = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN19QMISMSCommandDriver20setDCDisconnectTimerENS_16SubscriptionTypeEjE3__1EEOS1_OT__block_invoke;
  v159 = (uint8_t *)&__block_descriptor_tmp_54;
  v160 = v69 + 1;
  v161 = v69;
  do
    v71 = __ldxr(v70);
  while (__stxr(v71 + 1, v70));
  v162 = a2;
  aBlock = v41;
  v152 = 0x40000000;
  v153 = ___ZNO3qmi6Client9SendProxy8callbackIN3wms20SetDcDisconnectTimer8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
  v154 = &unk_24D5C60A0;
  v155 = buf;
  *(_QWORD *)(v68 + 32) = _Block_copy(&aBlock);
  v72 = v161;
  if (v161)
  {
    v73 = (unint64_t *)&v161->__shared_owners_;
    do
      v74 = __ldaxr(v73);
    while (__stlxr(v74 - 1, v73));
    if (!v74)
    {
      ((void (*)(std::__shared_weak_count *))v72->__on_zero_shared)(v72);
      std::__shared_weak_count::__release_weak(v72);
    }
  }
  do
    v75 = __ldaxr(v70);
  while (__stlxr(v75 - 1, v70));
  if (!v75)
  {
    ((void (*)(std::__shared_weak_count *))v69->__on_zero_shared)(v69);
    std::__shared_weak_count::__release_weak(v69);
  }
  v76 = v148;
  v148 = 0;
  if (v76)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v148, v76);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
  *(_OWORD *)__p = 0u;
  v150 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  v77 = (const void **)__p[1];
  if (__p[1] != (void *)v150)
  {
    while (*((_BYTE *)*v77 + 8) != 1)
    {
      if (++v77 == (const void **)v150)
        goto LABEL_112;
    }
  }
  if (v77 == (const void **)v150)
  {
LABEL_112:
    v80 = operator new();
    v81 = v80;
    *(_BYTE *)(v80 + 8) = 1;
    *(_QWORD *)v80 = &off_24D5C61B8;
    *(_DWORD *)(v80 + 12) = 0;
    v79 = (_DWORD *)(v80 + 12);
    v82 = v150;
    if ((unint64_t)v150 >= *((_QWORD *)&v150 + 1))
    {
      v84 = (uint64_t)(v150 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v84 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v85 = (uint64_t)(*((_QWORD *)&v150 + 1) - (unint64_t)__p[1]) >> 2;
      if (v85 <= v84 + 1)
        v85 = v84 + 1;
      if (*((_QWORD *)&v150 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v86 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v86 = v85;
      if (v86)
        v87 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v150 + 8, v86);
      else
        v87 = 0;
      v88 = (uint64_t *)&v87[8 * v84];
      v89 = &v87[8 * v86];
      *v88 = v81;
      v83 = v88 + 1;
      v91 = (char *)__p[1];
      v90 = (char *)v150;
      if ((void *)v150 != __p[1])
      {
        do
        {
          v92 = *((_QWORD *)v90 - 1);
          v90 -= 8;
          *--v88 = v92;
        }
        while (v90 != v91);
        v90 = (char *)__p[1];
      }
      __p[1] = v88;
      *(_QWORD *)&v150 = v83;
      *((_QWORD *)&v150 + 1) = v89;
      if (v90)
        operator delete(v90);
    }
    else
    {
      *(_QWORD *)v150 = v80;
      v83 = (_QWORD *)(v82 + 8);
    }
    *(_QWORD *)&v150 = v83;
  }
  else
  {
    if (!v78)
      __cxa_bad_cast();
    v79 = v78 + 12;
  }
  *v79 = 5;
  if (v64 >= 3)
    v93 = 0;
  else
    v93 = a2;
  v94 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 88) + 16))(*(_QWORD *)(a1 + 88), v93);
  if (os_log_type_enabled(v94, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = 5;
    _os_log_impl(&dword_216897000, v94, OS_LOG_TYPE_DEFAULT, "#I Setting retry interval (value: %d)...", buf, 8u);
  }
  v95 = qmi::ClientRouter::get();
  v96 = operator new();
  *(_QWORD *)v96 = v95;
  *(_QWORD *)(v96 + 8) = QMIServiceMsg::create();
  *(_DWORD *)(v96 + 16) = 25000;
  *(_QWORD *)(v96 + 24) = 0;
  *(_QWORD *)(v96 + 32) = 0;
  v148 = v96;
  v97 = (std::__shared_weak_count *)operator new(0x20uLL);
  v97->__shared_owners_ = 0;
  v98 = (unint64_t *)&v97->__shared_owners_;
  v97->__shared_weak_owners_ = 0;
  v97->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C6220;
  v97[1].__vftable = (std::__shared_weak_count_vtbl *)a1;
  *(_QWORD *)buf = v41;
  v157 = 1174405120;
  v158 = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN19QMISMSCommandDriver16setRetryIntervalENS_16SubscriptionTypeEjE3__1EEOS1_OT__block_invoke;
  v159 = (uint8_t *)&__block_descriptor_tmp_57;
  v160 = v97 + 1;
  v161 = v97;
  do
    v99 = __ldxr(v98);
  while (__stxr(v99 + 1, v98));
  v162 = a2;
  aBlock = v41;
  v152 = 0x40000000;
  v153 = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_1;
  v154 = &unk_24D5C5E60;
  v155 = buf;
  *(_QWORD *)(v96 + 32) = _Block_copy(&aBlock);
  v100 = v161;
  if (v161)
  {
    v101 = (unint64_t *)&v161->__shared_owners_;
    do
      v102 = __ldaxr(v101);
    while (__stlxr(v102 - 1, v101));
    if (!v102)
    {
      ((void (*)(std::__shared_weak_count *))v100->__on_zero_shared)(v100);
      std::__shared_weak_count::__release_weak(v100);
    }
  }
  do
    v103 = __ldaxr(v98);
  while (__stlxr(v103 - 1, v98));
  if (!v103)
  {
    ((void (*)(std::__shared_weak_count *))v97->__on_zero_shared)(v97);
    std::__shared_weak_count::__release_weak(v97);
  }
  v104 = v148;
  v148 = 0;
  if (v104)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v148, v104);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
  *(_OWORD *)__p = 0u;
  v150 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  v105 = (const void **)__p[1];
  if (__p[1] != (void *)v150)
  {
    while (*((_BYTE *)*v105 + 8) != 1)
    {
      if (++v105 == (const void **)v150)
        goto LABEL_153;
    }
  }
  if (v105 == (const void **)v150)
  {
LABEL_153:
    v108 = operator new();
    v109 = v108;
    *(_BYTE *)(v108 + 8) = 1;
    *(_QWORD *)v108 = &off_24D5C6288;
    *(_DWORD *)(v108 + 12) = 0;
    v107 = (_DWORD *)(v108 + 12);
    v110 = v150;
    if ((unint64_t)v150 >= *((_QWORD *)&v150 + 1))
    {
      v112 = (uint64_t)(v150 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v112 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v113 = (uint64_t)(*((_QWORD *)&v150 + 1) - (unint64_t)__p[1]) >> 2;
      if (v113 <= v112 + 1)
        v113 = v112 + 1;
      if (*((_QWORD *)&v150 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v114 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v114 = v113;
      if (v114)
        v115 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v150 + 8, v114);
      else
        v115 = 0;
      v116 = (uint64_t *)&v115[8 * v112];
      v117 = &v115[8 * v114];
      *v116 = v109;
      v111 = v116 + 1;
      v119 = (char *)__p[1];
      v118 = (char *)v150;
      if ((void *)v150 != __p[1])
      {
        do
        {
          v120 = *((_QWORD *)v118 - 1);
          v118 -= 8;
          *--v116 = v120;
        }
        while (v118 != v119);
        v118 = (char *)__p[1];
      }
      __p[1] = v116;
      *(_QWORD *)&v150 = v111;
      *((_QWORD *)&v150 + 1) = v117;
      if (v118)
        operator delete(v118);
    }
    else
    {
      *(_QWORD *)v150 = v108;
      v111 = (_QWORD *)(v110 + 8);
    }
    *(_QWORD *)&v150 = v111;
  }
  else
  {
    if (!v106)
      __cxa_bad_cast();
    v107 = v106 + 12;
  }
  *v107 = 0;
  if (v64 >= 3)
    v121 = 0;
  else
    v121 = a2;
  v122 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 88) + 16))(*(_QWORD *)(a1 + 88), v121);
  if (os_log_type_enabled(v122, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = 0;
    _os_log_impl(&dword_216897000, v122, OS_LOG_TYPE_DEFAULT, "#I Setting retry period (value: %d)...", buf, 8u);
  }
  v123 = qmi::ClientRouter::get();
  v124 = operator new();
  *(_QWORD *)v124 = v123;
  *(_QWORD *)(v124 + 8) = QMIServiceMsg::create();
  *(_DWORD *)(v124 + 16) = 25000;
  *(_QWORD *)(v124 + 24) = 0;
  *(_QWORD *)(v124 + 32) = 0;
  v148 = v124;
  v125 = (std::__shared_weak_count *)operator new(0x20uLL);
  v125->__shared_owners_ = 0;
  v126 = (unint64_t *)&v125->__shared_owners_;
  v125->__shared_weak_owners_ = 0;
  v125->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C62F0;
  v125[1].__vftable = (std::__shared_weak_count_vtbl *)a1;
  *(_QWORD *)buf = v41;
  v157 = 1174405120;
  v158 = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN19QMISMSCommandDriver14setRetryPeriodENS_16SubscriptionTypeEjE3__1EEOS1_OT__block_invoke;
  v159 = (uint8_t *)&__block_descriptor_tmp_58_0;
  v160 = v125 + 1;
  v161 = v125;
  do
    v127 = __ldxr(v126);
  while (__stxr(v127 + 1, v126));
  v162 = a2;
  aBlock = v41;
  v152 = 0x40000000;
  v153 = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_1;
  v154 = &unk_24D5C5E60;
  v155 = buf;
  *(_QWORD *)(v124 + 32) = _Block_copy(&aBlock);
  v128 = v161;
  if (v161)
  {
    v129 = (unint64_t *)&v161->__shared_owners_;
    do
      v130 = __ldaxr(v129);
    while (__stlxr(v130 - 1, v129));
    if (!v130)
    {
      ((void (*)(std::__shared_weak_count *))v128->__on_zero_shared)(v128);
      std::__shared_weak_count::__release_weak(v128);
    }
  }
  do
    v131 = __ldaxr(v126);
  while (__stlxr(v131 - 1, v126));
  if (!v131)
  {
    ((void (*)(std::__shared_weak_count *))v125->__on_zero_shared)(v125);
    std::__shared_weak_count::__release_weak(v125);
  }
  v132 = v148;
  v148 = 0;
  if (v132)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v148, v132);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
  if (v64 >= 3)
    v133 = 0;
  else
    v133 = a2;
  v134 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 88) + 16))(*(_QWORD *)(a1 + 88), v133);
  if (os_log_type_enabled(v134, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_216897000, v134, OS_LOG_TYPE_DEFAULT, "#I Registering for service ready Ind...", buf, 2u);
  }
  *(_QWORD *)buf = &off_24D5C6340;
  v157 = a1;
  v159 = buf;
  qmi::ClientRouter::setIndHandlerInternal();
  v136 = v159;
  if (v159 == buf)
  {
    v137 = 4;
    v136 = buf;
    goto LABEL_196;
  }
  if (v159)
  {
    v137 = 5;
LABEL_196:
    (*(void (**)(uint8_t *, uint64_t))(*(_QWORD *)v136 + 8 * v137))(v136, v135);
  }
  *(_OWORD *)__p = 0u;
  v150 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  v138 = qmi::ClientRouter::get();
  v139 = operator new();
  *(_QWORD *)v139 = v138;
  *(_QWORD *)(v139 + 8) = QMIServiceMsg::create();
  *(_DWORD *)(v139 + 16) = 25000;
  *(_QWORD *)(v139 + 24) = 0;
  *(_QWORD *)(v139 + 32) = 0;
  v148 = v139;
  v140 = (std::__shared_weak_count *)operator new(0x20uLL);
  v140->__shared_owners_ = 0;
  v141 = (unint64_t *)&v140->__shared_owners_;
  v140->__shared_weak_owners_ = 0;
  v140->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C5908;
  v140[1].__vftable = (std::__shared_weak_count_vtbl *)a1;
  *(_QWORD *)buf = v41;
  v157 = 1174405120;
  v158 = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN19QMISMSCommandDriver21getServiceReadyStatusENS_16SubscriptionTypeEE3__0EEOS1_OT__block_invoke;
  v159 = (uint8_t *)&__block_descriptor_tmp_37_1;
  v160 = v140 + 1;
  v161 = v140;
  do
    v142 = __ldxr(v141);
  while (__stxr(v142 + 1, v141));
  v162 = a2;
  aBlock = v41;
  v152 = 0x40000000;
  v153 = ___ZNO3qmi6Client9SendProxy8callbackIRKN3wms21GetServiceReadyStatus8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
  v154 = &unk_24D5C5950;
  v155 = buf;
  *(_QWORD *)(v139 + 32) = _Block_copy(&aBlock);
  v143 = v161;
  if (v161)
  {
    v144 = (unint64_t *)&v161->__shared_owners_;
    do
      v145 = __ldaxr(v144);
    while (__stlxr(v145 - 1, v144));
    if (!v145)
    {
      ((void (*)(std::__shared_weak_count *))v143->__on_zero_shared)(v143);
      std::__shared_weak_count::__release_weak(v143);
    }
  }
  do
    v146 = __ldaxr(v141);
  while (__stlxr(v146 - 1, v141));
  if (!v146)
  {
    ((void (*)(std::__shared_weak_count *))v140->__on_zero_shared)(v140);
    std::__shared_weak_count::__release_weak(v140);
  }
  v147 = v148;
  v148 = 0;
  if (v147)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v148, v147);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
}

void sub_2168E2FAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,std::__shared_weak_count *a26)
{
  uint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  std::__shared_weak_count *v30;
  unint64_t *p_shared_owners;
  unint64_t v32;
  unint64_t v33;

  v30 = a26;
  if (a26)
  {
    p_shared_owners = (unint64_t *)&a26->__shared_owners_;
    do
      v32 = __ldaxr(p_shared_owners);
    while (__stlxr(v32 - 1, p_shared_owners));
    if (!v32)
    {
      ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
      std::__shared_weak_count::__release_weak(v30);
    }
  }
  do
    v33 = __ldaxr(v28);
  while (__stlxr(v33 - 1, v28));
  if (!v33)
  {
    ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
    std::__shared_weak_count::__release_weak(v27);
  }
  if (a10)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v26, a10);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a11);
  _Unwind_Resume(a1);
}

void sub_2168E328C()
{
  JUMPOUT(0x2168E3284);
}

void QMISMSCommandDriver::setRoutes(uint64_t a1, unsigned int a2)
{
  std::__shared_weak_count *v4;
  uint64_t v5;
  unsigned int v6;
  unsigned int v7;
  char *v8;
  std::string *v9;
  __int128 v10;
  const char *v11;
  size_t v12;
  std::string *v13;
  char *v14;
  char v15;
  std::vector<std::string>::pointer end;
  std::string *v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  std::string *v21;
  std::string *v22;
  char *v23;
  char *v24;
  char *v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t v29;
  char *v30;
  char *v31;
  char *v32;
  NSObject *v33;
  const void **v34;
  uint64_t v35;
  char *v36;
  _QWORD *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  _QWORD *v41;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  char *v45;
  uint64_t *v46;
  char *v47;
  char *v48;
  char *v49;
  uint64_t v50;
  char *v51;
  char *v52;
  size_t v53;
  unint64_t v54;
  uint64_t v55;
  char *v56;
  uint64_t v57;
  unint64_t v58;
  void **v59;
  char *v60;
  char *v61;
  char *v62;
  size_t v63;
  unint64_t v64;
  char *v65;
  NSObject *v66;
  std::vector<std::string>::pointer v67;
  std::vector<std::string>::pointer begin;
  std::vector<std::string>::pointer i;
  int v70;
  const std::string::value_type *v71;
  std::string::size_type size;
  std::string *p_aBlock;
  uint64_t v74;
  uint64_t v75;
  char *v76;
  unint64_t *v77;
  std::string::size_type v78;
  unint64_t v79;
  std::__shared_weak_count *v80;
  unint64_t *p_shared_owners;
  unint64_t v82;
  std::__shared_weak_count *v83;
  unint64_t *v84;
  unint64_t v85;
  uint64_t v86;
  std::__shared_weak_count *v87;
  unint64_t *v88;
  unint64_t v89;
  os_log_t *v90;
  unsigned int v91;
  uint64_t v92;
  uint64_t v93;
  _BYTE v94[32];
  uint64_t v95;
  std::__shared_weak_count *v96;
  std::vector<std::string> v97;
  void *__p;
  char *v99;
  char *v100;
  std::__split_buffer<std::string> __v;
  std::__shared_weak_count *v102;
  unsigned int v103;
  std::string aBlock;
  void *v105;
  std::__split_buffer<std::string> *p_v;
  __int128 buf;
  uint64_t v108;

  v108 = *MEMORY[0x24BDAC8D0];
  __p = 0;
  v99 = 0;
  v100 = 0;
  memset(&v97, 0, sizeof(v97));
  v95 = 0;
  v96 = 0;
  v4 = *(std::__shared_weak_count **)(a1 + 80);
  if (v4)
  {
    v96 = std::__shared_weak_count::lock(v4);
    if (v96)
      v95 = *(_QWORD *)(a1 + 72);
  }
  v91 = a2;
  if (a2 - 1 >= 3)
    v5 = 0;
  else
    v5 = a2;
  v92 = a1;
  v90 = (os_log_t *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 88) + 16))(*(_QWORD *)(a1 + 88), v5);
  v6 = 0;
  while (v95)
  {
    if ((*(unsigned int (**)(uint64_t, uint64_t))(*(_QWORD *)v95 + 400))(v95, v5))
      v7 = 0;
    else
      v7 = 2;
    v8 = (char *)qmi::wms::asString(v6);
    std::string::basic_string[abi:ne180100]<0>(v94, v8);
    v9 = std::string::append((std::string *)v94, ":", 1uLL);
    v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
    aBlock.__r_.__value_.__r.__words[2] = v9->__r_.__value_.__r.__words[2];
    *(_OWORD *)&aBlock.__r_.__value_.__l.__data_ = v10;
    v9->__r_.__value_.__l.__size_ = 0;
    v9->__r_.__value_.__r.__words[2] = 0;
    v9->__r_.__value_.__r.__words[0] = 0;
    v11 = qmi::wms::asString(v7);
    v12 = strlen(v11);
    v13 = std::string::append(&aBlock, v11, v12);
    v14 = (char *)v13->__r_.__value_.__r.__words[0];
    *(_QWORD *)&buf = v13->__r_.__value_.__l.__size_;
    *(_QWORD *)((char *)&buf + 7) = *(std::string::size_type *)((char *)&v13->__r_.__value_.__r.__words[1] + 7);
    v15 = HIBYTE(v13->__r_.__value_.__r.__words[2]);
    v13->__r_.__value_.__l.__size_ = 0;
    v13->__r_.__value_.__r.__words[2] = 0;
    v13->__r_.__value_.__r.__words[0] = 0;
    end = v97.__end_;
    if (v97.__end_ >= v97.__end_cap_.__value_)
    {
      v18 = 0xAAAAAAAAAAAAAAABLL * (((char *)v97.__end_ - (char *)v97.__begin_) >> 3);
      v19 = v18 + 1;
      if (v18 + 1 > 0xAAAAAAAAAAAAAAALL)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      if (0x5555555555555556 * (((char *)v97.__end_cap_.__value_ - (char *)v97.__begin_) >> 3) > v19)
        v19 = 0x5555555555555556 * (((char *)v97.__end_cap_.__value_ - (char *)v97.__begin_) >> 3);
      if (0xAAAAAAAAAAAAAAABLL * (((char *)v97.__end_cap_.__value_ - (char *)v97.__begin_) >> 3) >= 0x555555555555555)
        v20 = 0xAAAAAAAAAAAAAAALL;
      else
        v20 = v19;
      __v.__end_cap_.__value_ = (std::allocator<std::string> *)&v97.__end_cap_;
      if (v20)
        v21 = (std::string *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)&v97.__end_cap_, v20);
      else
        v21 = 0;
      v22 = v21 + v18;
      __v.__first_ = v21;
      __v.__begin_ = v22;
      __v.__end_cap_.__value_ = &v21[v20];
      v22->__r_.__value_.__r.__words[0] = (std::string::size_type)v14;
      v22->__r_.__value_.__l.__size_ = buf;
      *(std::string::size_type *)((char *)&v22->__r_.__value_.__r.__words[1] + 7) = *(_QWORD *)((char *)&buf + 7);
      *((_BYTE *)&v22->__r_.__value_.__s + 23) = v15;
      __v.__end_ = v22 + 1;
      std::vector<std::string>::__swap_out_circular_buffer(&v97, &__v);
      v17 = v97.__end_;
      std::__split_buffer<std::string>::~__split_buffer(&__v);
    }
    else
    {
      v97.__end_->__r_.__value_.__l.__data_ = v14;
      end->__r_.__value_.__l.__size_ = buf;
      *(std::string::size_type *)((char *)&end->__r_.__value_.__r.__words[1] + 7) = *(_QWORD *)((char *)&buf + 7);
      *((_BYTE *)&end->__r_.__value_.__s + 23) = v15;
      v17 = end + 1;
    }
    v97.__end_ = v17;
    if (SHIBYTE(aBlock.__r_.__value_.__r.__words[2]) < 0)
      operator delete(aBlock.__r_.__value_.__l.__data_);
    if ((v94[23] & 0x80000000) != 0)
      operator delete(*(void **)v94);
    v23 = v99;
    if (v99 >= v100)
    {
      v25 = (char *)__p;
      v26 = (v99 - (_BYTE *)__p) >> 4;
      v27 = v26 + 1;
      if ((unint64_t)(v26 + 1) >> 60)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v28 = v100 - (_BYTE *)__p;
      if ((v100 - (_BYTE *)__p) >> 3 > v27)
        v27 = v28 >> 3;
      if ((unint64_t)v28 >= 0x7FFFFFFFFFFFFFF0)
        v29 = 0xFFFFFFFFFFFFFFFLL;
      else
        v29 = v27;
      if (v29)
      {
        v30 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::array<unsigned char,16ul>>>((uint64_t)&v100, v29);
        v25 = (char *)__p;
        v23 = v99;
      }
      else
      {
        v30 = 0;
      }
      v31 = &v30[16 * v26];
      *(_DWORD *)v31 = 0;
      *((_DWORD *)v31 + 1) = v6;
      *((_DWORD *)v31 + 2) = 255;
      *((_DWORD *)v31 + 3) = v7;
      v32 = v31;
      if (v23 != v25)
      {
        do
        {
          *((_OWORD *)v32 - 1) = *((_OWORD *)v23 - 1);
          v32 -= 16;
          v23 -= 16;
        }
        while (v23 != v25);
        v25 = (char *)__p;
      }
      v24 = v31 + 16;
      __p = v32;
      v99 = v31 + 16;
      v100 = &v30[16 * v29];
      if (v25)
        operator delete(v25);
    }
    else
    {
      *(_DWORD *)v99 = 0;
      *((_DWORD *)v23 + 1) = v6;
      v24 = v23 + 16;
      *((_DWORD *)v23 + 2) = 255;
      *((_DWORD *)v23 + 3) = v7;
    }
    v99 = v24;
    if (++v6 == 6)
      goto LABEL_48;
  }
  v33 = *v90;
  if (os_log_type_enabled(*v90, OS_LOG_TYPE_ERROR))
  {
    LOWORD(__v.__first_) = 0;
    _os_log_error_impl(&dword_216897000, v33, OS_LOG_TYPE_ERROR, "Unable to get the Controller object. Not setting SMS routes..", (uint8_t *)&__v, 2u);
  }
LABEL_48:
  memset(v94, 0, sizeof(v94));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v94);
  v34 = *(const void ***)&v94[8];
  v35 = v92;
  if (*(_QWORD *)&v94[8] != *(_QWORD *)&v94[16])
  {
    while (*((_BYTE *)*v34 + 8) != 1)
    {
      if (++v34 == *(const void ***)&v94[16])
        goto LABEL_56;
    }
  }
  if (v34 == *(const void ***)&v94[16])
  {
LABEL_56:
    v38 = operator new();
    v39 = v38;
    *(_BYTE *)(v38 + 8) = 1;
    *(_QWORD *)(v38 + 16) = 0;
    v37 = (_QWORD *)(v38 + 16);
    *(_QWORD *)v38 = &off_24D5C60E8;
    *(_QWORD *)(v38 + 24) = 0;
    *(_QWORD *)(v38 + 32) = 0;
    v40 = *(_QWORD *)&v94[16];
    if (*(_QWORD *)&v94[16] >= *(_QWORD *)&v94[24])
    {
      v42 = (uint64_t)(*(_QWORD *)&v94[16] - *(_QWORD *)&v94[8]) >> 3;
      if ((unint64_t)(v42 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v43 = (uint64_t)(*(_QWORD *)&v94[24] - *(_QWORD *)&v94[8]) >> 2;
      if (v43 <= v42 + 1)
        v43 = v42 + 1;
      if (*(_QWORD *)&v94[24] - *(_QWORD *)&v94[8] >= 0x7FFFFFFFFFFFFFF8uLL)
        v44 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v44 = v43;
      if (v44)
        v45 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v94[24], v44);
      else
        v45 = 0;
      v46 = (uint64_t *)&v45[8 * v42];
      v47 = &v45[8 * v44];
      *v46 = v39;
      v41 = v46 + 1;
      v48 = *(char **)&v94[16];
      v49 = *(char **)&v94[8];
      if (*(_QWORD *)&v94[16] != *(_QWORD *)&v94[8])
      {
        do
        {
          v50 = *((_QWORD *)v48 - 1);
          v48 -= 8;
          *--v46 = v50;
        }
        while (v48 != v49);
        v48 = *(char **)&v94[8];
      }
      *(_QWORD *)&v94[8] = v46;
      *(_QWORD *)&v94[16] = v41;
      *(_QWORD *)&v94[24] = v47;
      if (v48)
        operator delete(v48);
    }
    else
    {
      **(_QWORD **)&v94[16] = v38;
      v41 = (_QWORD *)(v40 + 8);
    }
    *(_QWORD *)&v94[16] = v41;
    goto LABEL_73;
  }
  if (!v36)
    __cxa_bad_cast();
  v37 = v36 + 16;
  if (&__p != (void **)(v36 + 16))
  {
LABEL_73:
    v52 = (char *)__p;
    v51 = v99;
    v53 = v99 - (_BYTE *)__p;
    v54 = (v99 - (_BYTE *)__p) >> 4;
    v55 = v37[2];
    v56 = (char *)*v37;
    if (v54 <= (v55 - *v37) >> 4)
    {
      v62 = (char *)v37[1];
      v59 = (void **)(v37 + 1);
      v61 = v62;
      v63 = v62 - v56;
      v64 = (v62 - v56) >> 4;
      if (v64 < v54)
      {
        v65 = (char *)__p + 16 * v64;
        if (v61 != v56)
        {
          memmove(v56, __p, v63);
          v56 = (char *)*v59;
        }
        v35 = v92;
        v53 = v51 - v65;
        if (v51 != v65)
          memmove(v56, v65, v51 - v65);
        goto LABEL_92;
      }
    }
    else
    {
      if (v56)
      {
        v37[1] = v56;
        operator delete(v56);
        v55 = 0;
        *v37 = 0;
        v37[1] = 0;
        v37[2] = 0;
      }
      if ((v53 & 0x8000000000000000) != 0)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v57 = v55 >> 3;
      if (v55 >> 3 <= v54)
        v57 = v54;
      if ((unint64_t)v55 >= 0x7FFFFFFFFFFFFFF0)
        v58 = 0xFFFFFFFFFFFFFFFLL;
      else
        v58 = v57;
      std::vector<wms::tlv::Route>::__vallocate[abi:ne180100](v37, v58);
      v60 = (char *)v37[1];
      v59 = (void **)(v37 + 1);
      v56 = v60;
    }
    if (v51 != v52)
      memmove(v56, v52, v53);
    v35 = v92;
LABEL_92:
    *v59 = &v56[v53];
  }
  v66 = *(NSObject **)(v35 + 40);
  if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
  {
    begin = v97.__begin_;
    v67 = v97.__end_;
    memset(&aBlock, 0, sizeof(aBlock));
    if (v97.__begin_ == v97.__end_)
    {
      p_aBlock = &aBlock;
    }
    else
    {
      std::string::operator=(&aBlock, v97.__begin_);
      for (i = begin + 1; i != v67; ++i)
      {
        HIBYTE(__v.__end_) = 1;
        LOWORD(__v.__first_) = 44;
        std::string::append(&aBlock, (const std::string::value_type *)&__v, 1uLL);
        if (SHIBYTE(__v.__end_) < 0)
          operator delete(__v.__first_);
        v70 = SHIBYTE(i->__r_.__value_.__r.__words[2]);
        if (v70 >= 0)
          v71 = (const std::string::value_type *)i;
        else
          v71 = (const std::string::value_type *)i->__r_.__value_.__r.__words[0];
        if (v70 >= 0)
          size = HIBYTE(i->__r_.__value_.__r.__words[2]);
        else
          size = i->__r_.__value_.__l.__size_;
        std::string::append(&aBlock, v71, size);
      }
      p_aBlock = &aBlock;
      if ((aBlock.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        p_aBlock = (std::string *)aBlock.__r_.__value_.__r.__words[0];
    }
    LODWORD(buf) = 136315138;
    *(_QWORD *)((char *)&buf + 4) = p_aBlock;
    _os_log_impl(&dword_216897000, v66, OS_LOG_TYPE_DEFAULT, "#I Setting routes :[%s]", (uint8_t *)&buf, 0xCu);
    if (SHIBYTE(aBlock.__r_.__value_.__r.__words[2]) < 0)
      operator delete(aBlock.__r_.__value_.__l.__data_);
  }
  v74 = qmi::ClientRouter::get();
  v75 = operator new();
  *(_QWORD *)v75 = v74;
  *(_QWORD *)(v75 + 8) = QMIServiceMsg::create();
  *(_DWORD *)(v75 + 16) = 25000;
  *(_QWORD *)(v75 + 24) = 0;
  *(_QWORD *)(v75 + 32) = 0;
  v93 = v75;
  v76 = (char *)operator new(0x20uLL);
  *((_QWORD *)v76 + 1) = 0;
  v77 = (unint64_t *)(v76 + 8);
  *((_QWORD *)v76 + 2) = 0;
  *(_QWORD *)v76 = &off_24D5C6150;
  *((_QWORD *)v76 + 3) = v35;
  *(_QWORD *)&buf = v76 + 24;
  *((_QWORD *)&buf + 1) = v76;
  v78 = MEMORY[0x24BDAC760];
  __v.__first_ = (std::__split_buffer<std::string>::pointer)MEMORY[0x24BDAC760];
  __v.__begin_ = (std::__split_buffer<std::string>::pointer)1174405120;
  __v.__end_ = (std::__split_buffer<std::string>::pointer)___ZNO3qmi12ClientRouter9SendProxy8callbackIZN19QMISMSCommandDriver9setRoutesENS_16SubscriptionTypeEE3__1EEOS1_OT__block_invoke;
  __v.__end_cap_.__value_ = (std::string *)&__block_descriptor_tmp_56_0;
  __v.__end_cap_.__value_ = (std::allocator<std::string> *)(v76 + 24);
  v102 = (std::__shared_weak_count *)v76;
  do
    v79 = __ldxr(v77);
  while (__stxr(v79 + 1, v77));
  v103 = v91;
  aBlock.__r_.__value_.__r.__words[0] = v78;
  aBlock.__r_.__value_.__l.__size_ = 0x40000000;
  aBlock.__r_.__value_.__r.__words[2] = (std::string::size_type)___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_1;
  v105 = &unk_24D5C5E60;
  p_v = &__v;
  *(_QWORD *)(v75 + 32) = _Block_copy(&aBlock);
  v80 = v102;
  if (v102)
  {
    p_shared_owners = (unint64_t *)&v102->__shared_owners_;
    do
      v82 = __ldaxr(p_shared_owners);
    while (__stlxr(v82 - 1, p_shared_owners));
    if (!v82)
    {
      ((void (*)(std::__shared_weak_count *))v80->__on_zero_shared)(v80);
      std::__shared_weak_count::__release_weak(v80);
    }
  }
  v83 = (std::__shared_weak_count *)*((_QWORD *)&buf + 1);
  if (*((_QWORD *)&buf + 1))
  {
    v84 = (unint64_t *)(*((_QWORD *)&buf + 1) + 8);
    do
      v85 = __ldaxr(v84);
    while (__stlxr(v85 - 1, v84));
    if (!v85)
    {
      ((void (*)(std::__shared_weak_count *))v83->__on_zero_shared)(v83);
      std::__shared_weak_count::__release_weak(v83);
    }
  }
  v86 = v93;
  v93 = 0;
  if (v86)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v93, v86);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v94);
  v87 = v96;
  if (v96)
  {
    v88 = (unint64_t *)&v96->__shared_owners_;
    do
      v89 = __ldaxr(v88);
    while (__stlxr(v89 - 1, v88));
    if (!v89)
    {
      ((void (*)(std::__shared_weak_count *))v87->__on_zero_shared)(v87);
      std::__shared_weak_count::__release_weak(v87);
    }
  }
  __v.__first_ = (std::__split_buffer<std::string>::pointer)&v97;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&__v);
  if (__p)
  {
    v99 = (char *)__p;
    operator delete(__p);
  }
}

void sub_2168E3BC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7, uint64_t a8, int a9, __int16 a10, char a11, char a12, uint64_t a13, char a14, uint64_t a15, char a16, uint64_t a17, char *a18, void *__p, uint64_t a20,uint64_t a21,std::__split_buffer<std::string> *a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,void *__pa,void *a28)
{
  uint64_t v28;

  if (*(char *)(v28 - 153) < 0)
    operator delete(*(void **)(v28 - 176));
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a18);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a22);
  a18 = &a24;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&a18);
  if (__pa)
  {
    a28 = __pa;
    operator delete(__pa);
  }
  _Unwind_Resume(a1);
}

uint64_t QMISMSCommandDriver::stop(uint64_t a1)
{
  NSObject *v1;
  uint8_t v3[16];

  v1 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v3 = 0;
    _os_log_impl(&dword_216897000, v1, OS_LOG_TYPE_DEFAULT, "#I Stopping", v3, 2u);
  }
  return qmi::ClientRouter::stop();
}

uint64_t QMISMSCommandDriver::start(QMISMSCommandDriver *this)
{
  NSObject *v1;
  uint8_t v3[16];

  v1 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v3 = 0;
    _os_log_impl(&dword_216897000, v1, OS_LOG_TYPE_DEFAULT, "#I Starting", v3, 2u);
  }
  return qmi::ClientRouter::start();
}

uint64_t QMISMSCommandDriver::ready()
{
  return 1;
}

void QMISMSCommandDriver::readStoredMessages(uint64_t a1, int a2, int a3)
{
  os_log_t *v6;
  NSObject *v7;
  const void **v8;
  char *v9;
  _BYTE *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  char *v18;
  uint64_t *v19;
  char *v20;
  char *v21;
  char *v22;
  uint64_t v23;
  int v24;
  NSObject *v25;
  NSObject *v26;
  const char *v27;
  const void **v28;
  char *v29;
  _DWORD *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  _QWORD *v34;
  uint64_t v35;
  unint64_t v36;
  unint64_t v37;
  char *v38;
  uint64_t *v39;
  char *v40;
  char *v41;
  char *v42;
  uint64_t v43;
  int v44;
  uint64_t v45;
  uint64_t v46;
  _QWORD *v47;
  unint64_t *v48;
  uint64_t v49;
  unint64_t v50;
  std::__shared_weak_count *v51;
  unint64_t *p_shared_owners;
  unint64_t v53;
  std::__shared_weak_count *v54;
  unint64_t *v55;
  unint64_t v56;
  uint64_t v57;
  uint64_t v58;
  void *__p[2];
  __int128 v60;
  char *v61;
  std::__shared_weak_count *v62;
  _QWORD aBlock[5];
  __int128 buf;
  void (*v65)(uint64_t, qmi::MessageBase *);
  void *v66;
  char *v67;
  std::__shared_weak_count *v68;
  int v69;
  uint64_t v70;

  v70 = *MEMORY[0x24BDAC8D0];
  v6 = (os_log_t *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 88) + 16))(*(_QWORD *)(a1 + 88));
  v7 = *v6;
  if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl(&dword_216897000, v7, OS_LOG_TYPE_DEFAULT, "#I Requesting stored messages list", (uint8_t *)&buf, 2u);
  }
  *(_OWORD *)__p = 0u;
  v60 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  v8 = (const void **)__p[1];
  if (__p[1] != (void *)v60)
  {
    while (*((_BYTE *)*v8 + 8) != 1)
    {
      if (++v8 == (const void **)v60)
        goto LABEL_10;
    }
  }
  if (v8 == (const void **)v60)
  {
LABEL_10:
    v11 = operator new();
    v12 = v11;
    *(_WORD *)(v11 + 8) = 1;
    *(_QWORD *)v11 = &off_24D5C5998;
    v13 = v60;
    if ((unint64_t)v60 >= *((_QWORD *)&v60 + 1))
    {
      v15 = (uint64_t)(v60 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v15 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v16 = (uint64_t)(*((_QWORD *)&v60 + 1) - (unint64_t)__p[1]) >> 2;
      if (v16 <= v15 + 1)
        v16 = v15 + 1;
      if (*((_QWORD *)&v60 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v17 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v17 = v16;
      if (v17)
        v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v60 + 8, v17);
      else
        v18 = 0;
      v19 = (uint64_t *)&v18[8 * v15];
      v20 = &v18[8 * v17];
      *v19 = v12;
      v14 = v19 + 1;
      v22 = (char *)__p[1];
      v21 = (char *)v60;
      if ((void *)v60 != __p[1])
      {
        do
        {
          v23 = *((_QWORD *)v21 - 1);
          v21 -= 8;
          *--v19 = v23;
        }
        while (v21 != v22);
        v21 = (char *)__p[1];
      }
      __p[1] = v19;
      *(_QWORD *)&v60 = v14;
      *((_QWORD *)&v60 + 1) = v20;
      if (v21)
        operator delete(v21);
    }
    else
    {
      *(_QWORD *)v60 = v11;
      v14 = (_QWORD *)(v13 + 8);
    }
    v10 = (_BYTE *)(v12 + 9);
    *(_QWORD *)&v60 = v14;
  }
  else
  {
    if (!v9)
      __cxa_bad_cast();
    v10 = v9 + 9;
  }
  v24 = a3 ^ 1;
  *v10 = a3 ^ 1;
  v25 = *v6;
  if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 67109120;
    DWORD1(buf) = v24;
    _os_log_impl(&dword_216897000, v25, OS_LOG_TYPE_DEFAULT, "#I Setting memory storage to %d", (uint8_t *)&buf, 8u);
  }
  *(_DWORD *)qmi::MutableMessageBase::getTLV<wms::tlv::Message_Mode>(__p, 17) = 1;
  v26 = *v6;
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
  {
    v27 = qmi::wms::asString(1);
    LODWORD(buf) = 136315138;
    *(_QWORD *)((char *)&buf + 4) = v27;
    _os_log_impl(&dword_216897000, v26, OS_LOG_TYPE_DEFAULT, "#I Setting the message mode for stored messages to %s", (uint8_t *)&buf, 0xCu);
  }
  v28 = (const void **)__p[1];
  if (__p[1] != (void *)v60)
  {
    while (*((_BYTE *)*v28 + 8) != 16)
    {
      if (++v28 == (const void **)v60)
        goto LABEL_38;
    }
  }
  if (v28 == (const void **)v60)
  {
LABEL_38:
    v31 = operator new();
    v32 = v31;
    *(_BYTE *)(v31 + 8) = 16;
    *(_QWORD *)v31 = &off_24D5C5A38;
    *(_DWORD *)(v31 + 12) = 0;
    v30 = (_DWORD *)(v31 + 12);
    v33 = v60;
    if ((unint64_t)v60 >= *((_QWORD *)&v60 + 1))
    {
      v35 = (uint64_t)(v60 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v35 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v36 = (uint64_t)(*((_QWORD *)&v60 + 1) - (unint64_t)__p[1]) >> 2;
      if (v36 <= v35 + 1)
        v36 = v35 + 1;
      if (*((_QWORD *)&v60 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v37 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v37 = v36;
      if (v37)
        v38 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v60 + 8, v37);
      else
        v38 = 0;
      v39 = (uint64_t *)&v38[8 * v35];
      v40 = &v38[8 * v37];
      *v39 = v32;
      v34 = v39 + 1;
      v42 = (char *)__p[1];
      v41 = (char *)v60;
      if ((void *)v60 != __p[1])
      {
        do
        {
          v43 = *((_QWORD *)v41 - 1);
          v41 -= 8;
          *--v39 = v43;
        }
        while (v41 != v42);
        v41 = (char *)__p[1];
      }
      __p[1] = v39;
      *(_QWORD *)&v60 = v34;
      *((_QWORD *)&v60 + 1) = v40;
      if (v41)
        operator delete(v41);
    }
    else
    {
      *(_QWORD *)v60 = v31;
      v34 = (_QWORD *)(v33 + 8);
    }
    *(_QWORD *)&v60 = v34;
  }
  else
  {
    if (!v29)
      __cxa_bad_cast();
    v30 = v29 + 12;
  }
  *v30 = 1;
  if ((a2 - 1) >= 3)
    v44 = 0;
  else
    v44 = a2;
  v45 = qmi::ClientRouter::get();
  v46 = operator new();
  *(_QWORD *)v46 = v45;
  *(_QWORD *)(v46 + 8) = QMIServiceMsg::create();
  *(_DWORD *)(v46 + 16) = 25000;
  *(_QWORD *)(v46 + 24) = 0;
  *(_QWORD *)(v46 + 32) = 0;
  v58 = v46;
  v47 = operator new(0x28uLL);
  v47[1] = 0;
  v48 = v47 + 1;
  v47[2] = 0;
  *v47 = &off_24D5C5AA0;
  v47[3] = a1;
  *((_BYTE *)v47 + 32) = v24;
  v61 = (char *)(v47 + 3);
  v62 = (std::__shared_weak_count *)v47;
  v49 = MEMORY[0x24BDAC760];
  *(_QWORD *)&buf = MEMORY[0x24BDAC760];
  *((_QWORD *)&buf + 1) = 1174405120;
  v65 = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN19QMISMSCommandDriver18readStoredMessagesEN10subscriber7SimSlotEbE3__3EEOS1_OT__block_invoke;
  v66 = &__block_descriptor_tmp_41_0;
  v67 = (char *)(v47 + 3);
  v68 = (std::__shared_weak_count *)v47;
  do
    v50 = __ldxr(v48);
  while (__stxr(v50 + 1, v48));
  v69 = v44;
  aBlock[0] = v49;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3wms12ListMessages8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
  aBlock[3] = &unk_24D5C5AE8;
  aBlock[4] = &buf;
  *(_QWORD *)(v46 + 32) = _Block_copy(aBlock);
  v51 = v68;
  if (v68)
  {
    p_shared_owners = (unint64_t *)&v68->__shared_owners_;
    do
      v53 = __ldaxr(p_shared_owners);
    while (__stlxr(v53 - 1, p_shared_owners));
    if (!v53)
    {
      ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
      std::__shared_weak_count::__release_weak(v51);
    }
  }
  v54 = v62;
  if (v62)
  {
    v55 = (unint64_t *)&v62->__shared_owners_;
    do
      v56 = __ldaxr(v55);
    while (__stlxr(v56 - 1, v55));
    if (!v56)
    {
      ((void (*)(std::__shared_weak_count *))v54->__on_zero_shared)(v54);
      std::__shared_weak_count::__release_weak(v54);
    }
  }
  v57 = v58;
  v58 = 0;
  if (v57)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v58, v57);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
}

void sub_2168E43B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;
  va_list va;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v6 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v4);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  if (a3)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v3, a3);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

uint64_t QMISMSCommandDriver::storeMsgWaitingInfo(uint64_t a1, uint64_t a2, int a3, int a4, const void **a5)
{
  const void **v10;
  char *v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  char *v20;
  uint64_t *v21;
  char *v22;
  char *v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  NSObject *v27;
  const char *v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  void *v32;
  std::__shared_weak_count *v33;
  unint64_t *p_shared_owners;
  uint64_t v35;
  unint64_t v36;
  std::__shared_weak_count *v37;
  unint64_t *v38;
  unint64_t v39;
  std::__shared_weak_count *v40;
  unint64_t *v41;
  unint64_t v42;
  uint64_t v43;
  uint64_t v45;
  void *__p[2];
  __int128 v47;
  _QWORD *v48;
  std::__shared_weak_count *v49;
  _QWORD aBlock[5];
  _BYTE buf[24];
  void *v52;
  _QWORD *v53;
  std::__shared_weak_count *v54;
  int v55;
  uint64_t v56;

  v56 = *MEMORY[0x24BDAC8D0];
  *(_OWORD *)__p = 0u;
  v47 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  v10 = (const void **)__p[1];
  if (__p[1] != (void *)v47)
  {
    while (*((_BYTE *)*v10 + 8) != 1)
    {
      if (++v10 == (const void **)v47)
        goto LABEL_8;
    }
  }
  if (v10 == (const void **)v47)
  {
LABEL_8:
    v13 = operator new();
    v14 = v13;
    *(_BYTE *)(v13 + 8) = 1;
    *(_QWORD *)(v13 + 16) = 0;
    v12 = (uint64_t *)(v13 + 16);
    *(_QWORD *)v13 = &off_24D5C5B30;
    *(_QWORD *)(v13 + 24) = 0;
    *(_QWORD *)(v13 + 32) = 0;
    v15 = v47;
    if ((unint64_t)v47 >= *((_QWORD *)&v47 + 1))
    {
      v17 = (uint64_t)(v47 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v17 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v18 = (uint64_t)(*((_QWORD *)&v47 + 1) - (unint64_t)__p[1]) >> 2;
      if (v18 <= v17 + 1)
        v18 = v17 + 1;
      if (*((_QWORD *)&v47 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v19 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v19 = v18;
      if (v19)
        v20 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v47 + 8, v19);
      else
        v20 = 0;
      v21 = (uint64_t *)&v20[8 * v17];
      v22 = &v20[8 * v19];
      *v21 = v14;
      v16 = v21 + 1;
      v24 = (char *)__p[1];
      v23 = (char *)v47;
      if ((void *)v47 != __p[1])
      {
        do
        {
          v25 = *((_QWORD *)v23 - 1);
          v23 -= 8;
          *--v21 = v25;
        }
        while (v23 != v24);
        v23 = (char *)__p[1];
      }
      __p[1] = v21;
      *(_QWORD *)&v47 = v16;
      *((_QWORD *)&v47 + 1) = v22;
      if (v23)
        operator delete(v23);
    }
    else
    {
      *(_QWORD *)v47 = v13;
      v16 = (_QWORD *)(v15 + 8);
    }
    *(_QWORD *)&v47 = v16;
  }
  else
  {
    if (!v11)
      __cxa_bad_cast();
    v12 = (uint64_t *)(v11 + 16);
  }
  std::vector<wms::tlv::MsgTypeWaitingInfo>::resize((uint64_t)v12, 1uLL);
  v26 = *v12;
  *(_DWORD *)v26 = 0;
  *(_BYTE *)(v26 + 4) = a3;
  *(_BYTE *)(v26 + 5) = a4;
  v27 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 88) + 16))(*(_QWORD *)(a1 + 88), a2);
  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
  {
    v28 = "false";
    if (a3)
      v28 = "true";
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = v28;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = a4;
    _os_log_impl(&dword_216897000, v27, OS_LOG_TYPE_DEFAULT, "#I Setting MWI Info: Voice Mail - Active ? %s, Count = %d", buf, 0x12u);
  }
  if ((a2 - 1) >= 3)
    v29 = 0;
  else
    v29 = a2;
  v30 = qmi::ClientRouter::get();
  v31 = operator new();
  *(_QWORD *)v31 = v30;
  *(_QWORD *)(v31 + 8) = QMIServiceMsg::create();
  *(_DWORD *)(v31 + 16) = 25000;
  *(_QWORD *)(v31 + 24) = 0;
  *(_QWORD *)(v31 + 32) = 0;
  v45 = v31;
  if (*a5)
    v32 = _Block_copy(*a5);
  else
    v32 = 0;
  v33 = (std::__shared_weak_count *)operator new(0x28uLL);
  v33->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v33->__shared_owners_;
  v33->__shared_weak_owners_ = 0;
  v33->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C5B98;
  v33[1].__vftable = (std::__shared_weak_count_vtbl *)a1;
  v33[1].__shared_owners_ = (uint64_t)v32;
  v48 = &v33[1].__vftable;
  v49 = v33;
  v35 = MEMORY[0x24BDAC760];
  *(_QWORD *)buf = MEMORY[0x24BDAC760];
  *(_QWORD *)&buf[8] = 1174405120;
  *(_QWORD *)&buf[16] = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN19QMISMSCommandDriver19storeMsgWaitingInfoEN10subscriber7SimSlotEbhN8dispatch5blockIU13block_pointerFvbEEEE3__1EEOS1_OT__block_invoke;
  v52 = &__block_descriptor_tmp_45_0;
  v53 = &v33[1].__vftable;
  v54 = v33;
  do
    v36 = __ldxr(p_shared_owners);
  while (__stxr(v36 + 1, p_shared_owners));
  v55 = v29;
  aBlock[0] = v35;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3wms13SetMsgWaiting8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
  aBlock[3] = &unk_24D5C5BE0;
  aBlock[4] = buf;
  *(_QWORD *)(v31 + 32) = _Block_copy(aBlock);
  v37 = v54;
  if (v54)
  {
    v38 = (unint64_t *)&v54->__shared_owners_;
    do
      v39 = __ldaxr(v38);
    while (__stlxr(v39 - 1, v38));
    if (!v39)
    {
      ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
      std::__shared_weak_count::__release_weak(v37);
    }
  }
  v40 = v49;
  if (v49)
  {
    v41 = (unint64_t *)&v49->__shared_owners_;
    do
      v42 = __ldaxr(v41);
    while (__stlxr(v42 - 1, v41));
    if (!v42)
    {
      ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
      std::__shared_weak_count::__release_weak(v40);
    }
  }
  v43 = v45;
  v45 = 0;
  if (v43)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v45, v43);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
  return 1;
}

void sub_2168E48A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

uint64_t QMISMSCommandDriver::storeMsgWaitingInfo(subscriber::SimSlot,BOOL,unsigned char,dispatch::block<void({block_pointer})(BOOL)>)::$_1::~$_1(uint64_t a1)
{
  const void *v2;

  v2 = *(const void **)(a1 + 8);
  if (v2)
    _Block_release(v2);
  return a1;
}

void QMISMSCommandDriver::sendAck(uint64_t a1, uint64_t a2, uint64_t *a3, int a4, int a5, int a6, int a7, int a8, unsigned __int8 a9)
{
  _BOOL4 v16;
  NSObject *v17;
  const char *v18;
  const char *v19;
  const char *v20;
  _BOOL4 v21;
  int v22;
  std::mutex *ServiceMap;
  uint64_t (*v24)(uint64_t);
  BOOL *Value;
  const __CFBoolean *v26;
  BOOL *v27;
  CFTypeID v28;
  BOOL *v29;
  NSObject *v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  const void **v34;
  const void **v35;
  char *v36;
  char *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  unint64_t v43;
  char *v44;
  const void **v45;
  char *v46;
  char *v47;
  char *v48;
  const void *v49;
  NSObject *v50;
  const char *v51;
  const char *v52;
  const void **i;
  char *v54;
  _BYTE *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  unint64_t v60;
  unint64_t v61;
  char *v62;
  const void **v63;
  char *v64;
  char *v65;
  char *v66;
  const void *v67;
  const void **j;
  int v69;
  int v70;
  const void **k;
  char *v72;
  _WORD *v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  _QWORD *v77;
  uint64_t v78;
  unint64_t v79;
  unint64_t v80;
  char *v81;
  char *v82;
  int *v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  _QWORD *v87;
  uint64_t v88;
  unint64_t v89;
  unint64_t v90;
  char *v91;
  uint64_t *v92;
  char *v93;
  char *v94;
  char *v95;
  uint64_t v96;
  uint64_t *v97;
  char *v98;
  char *v99;
  char *v100;
  uint64_t v101;
  NSObject *v102;
  int v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  std::__shared_weak_count *v107;
  unint64_t *p_shared_owners;
  unint64_t v109;
  _QWORD *v110;
  unint64_t *v111;
  const __CFDictionary *v112;
  unint64_t v113;
  std::__shared_weak_count *v114;
  unint64_t *v115;
  unint64_t v116;
  std::__shared_weak_count *v117;
  unint64_t *v118;
  unint64_t v119;
  std::__shared_weak_count *v120;
  unint64_t *v121;
  unint64_t v122;
  uint64_t v123;
  int v124;
  uint64_t *v125;
  os_log_t *v127;
  BOOL *v128;
  uint64_t v129;
  std::__shared_weak_count *v130;
  char v131;
  int v132;
  uint64_t v133;
  void *__p[2];
  __int128 v135;
  char *v136;
  std::__shared_weak_count *v137;
  CFDictionaryRef theDict[6];
  _BYTE buf[40];
  std::__shared_weak_count *v140;
  int v141;
  uint64_t v142;

  v142 = *MEMORY[0x24BDAC8D0];
  v16 = a7 != 0;
  v127 = (os_log_t *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 88) + 16))(*(_QWORD *)(a1 + 88));
  v17 = *v127;
  if (os_log_type_enabled(*v127, OS_LOG_TYPE_DEFAULT))
  {
    v18 = "failure";
    if (a4)
      v18 = "success";
    if (a5)
      v19 = "permanent";
    else
      v19 = "temporary";
    *(_DWORD *)buf = 67109890;
    *(_DWORD *)&buf[4] = a6;
    *(_QWORD *)&buf[10] = v18;
    *(_WORD *)&buf[8] = 2080;
    *(_WORD *)&buf[18] = 2080;
    *(_QWORD *)&buf[20] = v19;
    if (a7)
      v20 = "GW";
    else
      v20 = "CDMA";
    *(_WORD *)&buf[28] = 2080;
    *(_QWORD *)&buf[30] = v20;
    _os_log_impl(&dword_216897000, v17, OS_LOG_TYPE_DEFAULT, "#I Acking messageID %u with %s and is %s on mode %s", buf, 0x26u);
  }
  v124 = a5;
  v21 = a7 != 0;
  *(_OWORD *)__p = 0u;
  v135 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  v22 = (v21 | a4) ^ 1;
  if ((v21 & a9) == 1 && (a4 & 1) == 0)
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = 0;
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 56));
    ctu::shared_ptr_map_impl<ctu::indexed_by_any_map_hashing_key>::get<CarrierSettingsInterface>(ServiceMap, buf);
    if (*(_QWORD *)buf)
    {
      theDict[0] = 0;
      (*(void (**)(BOOL **__return_ptr, _QWORD, uint64_t, uint64_t, const __CFString *, _QWORD, _QWORD))(**(_QWORD **)buf + 96))(&v128, *(_QWORD *)buf, a2, 1, CFSTR("SMSSettings"), 0, 0);
      ctu::cf::CFSharedRef<__CFDictionary const>::CFSharedRef<void const,void>(theDict, (CFTypeRef *)&v128);
      ctu::SharedRef<void const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,void const>::~SharedRef((const void **)&v128);
      v24 = ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::get;
      if (!theDict[0])
        v24 = 0;
      if (v24)
      {
        v128 = 0;
        Value = (BOOL *)CFDictionaryGetValue(theDict[0], CFSTR("SendNackOnSMSStorageFull"));
        v27 = Value;
        if (Value && (v28 = CFGetTypeID(Value), v28 == CFBooleanGetTypeID()))
        {
          v128 = v27;
          CFRetain(v27);
          v29 = v128;
        }
        else
        {
          v29 = 0;
          v128 = 0;
        }
        LOBYTE(v136) = 0;
        ctu::cf::assign((ctu::cf *)&v136, v29, v26);
        v22 = v136;
        ctu::SharedRef<__CFBoolean const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFBoolean const>::~SharedRef((const void **)&v128);
      }
      else
      {
        v22 = 0;
      }
      ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef((const void **)theDict);
    }
    else
    {
      v30 = *v127;
      if (os_log_type_enabled(*v127, OS_LOG_TYPE_ERROR))
      {
        LOWORD(theDict[0]) = 0;
        _os_log_error_impl(&dword_216897000, v30, OS_LOG_TYPE_ERROR, "Failed to get Carrier iface...", (uint8_t *)theDict, 2u);
      }
      v22 = 0;
    }
    v31 = *(std::__shared_weak_count **)&buf[8];
    if (*(_QWORD *)&buf[8])
    {
      v32 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
      do
        v33 = __ldaxr(v32);
      while (__stlxr(v33 - 1, v32));
      if (!v33)
      {
        ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
        std::__shared_weak_count::__release_weak(v31);
      }
    }
  }
  v125 = a3;
  v34 = (const void **)__p[1];
  v35 = (const void **)v135;
  if (__p[1] != (void *)v135)
  {
    while (*((_BYTE *)*v34 + 8) != 1)
    {
      if (++v34 == (const void **)v135)
        goto LABEL_39;
    }
  }
  if (v34 == (const void **)v135)
  {
LABEL_39:
    v38 = operator new();
    v39 = v38;
    *(_BYTE *)(v38 + 8) = 1;
    *(_QWORD *)v38 = &off_24D5C6458;
    *(_QWORD *)(v38 + 12) = 0;
    v37 = (char *)(v38 + 12);
    *(_BYTE *)(v38 + 20) = 0;
    v40 = v135;
    if ((unint64_t)v135 >= *((_QWORD *)&v135 + 1))
    {
      v41 = (uint64_t)(v135 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v41 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v42 = (uint64_t)(*((_QWORD *)&v135 + 1) - (unint64_t)__p[1]) >> 2;
      if (v42 <= v41 + 1)
        v42 = v41 + 1;
      if (*((_QWORD *)&v135 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v43 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v43 = v42;
      if (v43)
        v44 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v135 + 8, v43);
      else
        v44 = 0;
      v45 = (const void **)&v44[8 * v41];
      v46 = &v44[8 * v43];
      *v45 = (const void *)v39;
      v35 = v45 + 1;
      v48 = (char *)__p[1];
      v47 = (char *)v135;
      if ((void *)v135 != __p[1])
      {
        do
        {
          v49 = (const void *)*((_QWORD *)v47 - 1);
          v47 -= 8;
          *--v45 = v49;
        }
        while (v47 != v48);
        v47 = (char *)__p[1];
      }
      __p[1] = v45;
      *(_QWORD *)&v135 = v35;
      *((_QWORD *)&v135 + 1) = v46;
      if (v47)
        operator delete(v47);
    }
    else
    {
      *(_QWORD *)v135 = v38;
      v35 = (const void **)(v40 + 8);
    }
    *(_QWORD *)&v135 = v35;
  }
  else
  {
    if (!v36)
      __cxa_bad_cast();
    v37 = v36 + 12;
  }
  *(_DWORD *)v37 = a6;
  *((_DWORD *)v37 + 1) = v16;
  v37[8] = v22 ^ 1;
  v50 = *v127;
  if (os_log_type_enabled(*v127, OS_LOG_TYPE_DEFAULT))
  {
    v51 = "NACKing";
    if (!v22)
      v51 = "ACKing";
    v52 = "IMS";
    if (!a8)
      v52 = "signaling";
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = v51;
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = v52;
    _os_log_impl(&dword_216897000, v50, OS_LOG_TYPE_DEFAULT, "#I %s an SMS on %s", buf, 0x16u);
    v35 = (const void **)v135;
  }
  for (i = (const void **)__p[1]; i != v35; ++i)
  {
    if (*((_BYTE *)*i + 8) == 18)
    {
      if (i != v35)
      {
        if (!v54)
          __cxa_bad_cast();
        v55 = v54 + 9;
        goto LABEL_86;
      }
      break;
    }
  }
  v56 = operator new();
  v57 = v56;
  *(_WORD *)(v56 + 8) = 18;
  *(_QWORD *)v56 = &off_24D5C64A8;
  v58 = v135;
  if ((unint64_t)v135 >= *((_QWORD *)&v135 + 1))
  {
    v59 = (uint64_t)(v135 - (unint64_t)__p[1]) >> 3;
    if ((unint64_t)(v59 + 1) >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v60 = (uint64_t)(*((_QWORD *)&v135 + 1) - (unint64_t)__p[1]) >> 2;
    if (v60 <= v59 + 1)
      v60 = v59 + 1;
    if (*((_QWORD *)&v135 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
      v61 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v61 = v60;
    if (v61)
      v62 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v135 + 8, v61);
    else
      v62 = 0;
    v63 = (const void **)&v62[8 * v59];
    v64 = &v62[8 * v61];
    *v63 = (const void *)v57;
    v35 = v63 + 1;
    v66 = (char *)__p[1];
    v65 = (char *)v135;
    if ((void *)v135 != __p[1])
    {
      do
      {
        v67 = (const void *)*((_QWORD *)v65 - 1);
        v65 -= 8;
        *--v63 = v67;
      }
      while (v65 != v66);
      v65 = (char *)__p[1];
    }
    __p[1] = v63;
    *(_QWORD *)&v135 = v35;
    *((_QWORD *)&v135 + 1) = v64;
    if (v65)
      operator delete(v65);
  }
  else
  {
    *(_QWORD *)v135 = v56;
    v35 = (const void **)(v58 + 8);
  }
  v55 = (_BYTE *)(v57 + 9);
  *(_QWORD *)&v135 = v35;
LABEL_86:
  *v55 = a8;
  if (v22)
  {
    if (a7)
    {
      for (j = (const void **)__p[1]; j != v35; ++j)
      {
        if (*((_BYTE *)*j + 8) == 17)
        {
          if (j != v35)
          {
            if (!v72)
              __cxa_bad_cast();
            v73 = v72 + 9;
            goto LABEL_135;
          }
          break;
        }
      }
      v74 = operator new();
      v75 = v74;
      *(_WORD *)(v74 + 8) = 17;
      *(_QWORD *)v74 = &off_24D5C6548;
      *(_BYTE *)(v74 + 10) = 0;
      v76 = v135;
      if ((unint64_t)v135 >= *((_QWORD *)&v135 + 1))
      {
        v78 = (uint64_t)(v135 - (unint64_t)__p[1]) >> 3;
        if ((unint64_t)(v78 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v79 = (uint64_t)(*((_QWORD *)&v135 + 1) - (unint64_t)__p[1]) >> 2;
        if (v79 <= v78 + 1)
          v79 = v78 + 1;
        if (*((_QWORD *)&v135 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v80 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v80 = v79;
        if (v80)
          v81 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v135 + 8, v80);
        else
          v81 = 0;
        v92 = (uint64_t *)&v81[8 * v78];
        v93 = &v81[8 * v80];
        *v92 = v75;
        v77 = v92 + 1;
        v95 = (char *)__p[1];
        v94 = (char *)v135;
        if ((void *)v135 != __p[1])
        {
          do
          {
            v96 = *((_QWORD *)v94 - 1);
            v94 -= 8;
            *--v92 = v96;
          }
          while (v94 != v95);
          v94 = (char *)__p[1];
        }
        __p[1] = v92;
        *(_QWORD *)&v135 = v77;
        *((_QWORD *)&v135 + 1) = v93;
        if (v94)
          operator delete(v94);
      }
      else
      {
        *(_QWORD *)v135 = v74;
        v77 = (_QWORD *)(v76 + 8);
      }
      v73 = (_WORD *)(v75 + 9);
      *(_QWORD *)&v135 = v77;
LABEL_135:
      *v73 = 22;
    }
    else
    {
      if (v124)
        v69 = 3;
      else
        v69 = 2;
      if (v124)
        v70 = 103;
      else
        v70 = 102;
      for (k = (const void **)__p[1]; k != v35; ++k)
      {
        if (*((_BYTE *)*k + 8) == 16)
        {
          if (k != v35)
          {
            if (!v82)
              __cxa_bad_cast();
            v83 = (int *)(v82 + 12);
            goto LABEL_143;
          }
          break;
        }
      }
      v84 = operator new();
      v85 = v84;
      *(_BYTE *)(v84 + 8) = 16;
      *(_QWORD *)v84 = &off_24D5C64F8;
      *(_DWORD *)(v84 + 12) = 0;
      v83 = (int *)(v84 + 12);
      *(_DWORD *)(v84 + 16) = 0;
      v86 = v135;
      if ((unint64_t)v135 >= *((_QWORD *)&v135 + 1))
      {
        v88 = (uint64_t)(v135 - (unint64_t)__p[1]) >> 3;
        if ((unint64_t)(v88 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v89 = (uint64_t)(*((_QWORD *)&v135 + 1) - (unint64_t)__p[1]) >> 2;
        if (v89 <= v88 + 1)
          v89 = v88 + 1;
        if (*((_QWORD *)&v135 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v90 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v90 = v89;
        if (v90)
          v91 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v135 + 8, v90);
        else
          v91 = 0;
        v97 = (uint64_t *)&v91[8 * v88];
        v98 = &v91[8 * v90];
        *v97 = v85;
        v87 = v97 + 1;
        v100 = (char *)__p[1];
        v99 = (char *)v135;
        if ((void *)v135 != __p[1])
        {
          do
          {
            v101 = *((_QWORD *)v99 - 1);
            v99 -= 8;
            *--v97 = v101;
          }
          while (v99 != v100);
          v99 = (char *)__p[1];
        }
        __p[1] = v97;
        *(_QWORD *)&v135 = v87;
        *((_QWORD *)&v135 + 1) = v98;
        if (v99)
          operator delete(v99);
      }
      else
      {
        *(_QWORD *)v135 = v84;
        v87 = (_QWORD *)(v86 + 8);
      }
      *(_QWORD *)&v135 = v87;
LABEL_143:
      *v83 = v69;
      v83[1] = v70;
      v102 = *v127;
      if (os_log_type_enabled(*v127, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109376;
        *(_DWORD *)&buf[4] = v69;
        *(_WORD *)&buf[8] = 1024;
        *(_DWORD *)&buf[10] = v70;
        _os_log_impl(&dword_216897000, v102, OS_LOG_TYPE_DEFAULT, "#I Error Class: %d, Cause Code: %d", buf, 0xEu);
      }
    }
  }
  if ((a2 - 1) >= 3)
    v103 = 0;
  else
    v103 = a2;
  v104 = qmi::ClientRouter::get();
  v132 = v103;
  v105 = operator new();
  *(_QWORD *)v105 = v104;
  *(_QWORD *)(v105 + 8) = QMIServiceMsg::create();
  *(_QWORD *)(v105 + 24) = 0;
  *(_QWORD *)(v105 + 32) = 0;
  v133 = v105;
  *(_DWORD *)(v105 + 16) = *MEMORY[0x24BDC46A8];
  v106 = *v125;
  v107 = (std::__shared_weak_count *)v125[1];
  v128 = (BOOL *)a1;
  v129 = v106;
  v130 = v107;
  if (v107)
  {
    p_shared_owners = (unint64_t *)&v107->__shared_owners_;
    do
      v109 = __ldxr(p_shared_owners);
    while (__stxr(v109 + 1, p_shared_owners));
  }
  v131 = a4;
  v110 = operator new(0x38uLL);
  v110[1] = 0;
  v111 = v110 + 1;
  v110[2] = 0;
  v110[3] = a1;
  *v110 = &off_24D5C65B0;
  v110[4] = v106;
  v110[5] = v107;
  v129 = 0;
  v130 = 0;
  *((_BYTE *)v110 + 48) = a4;
  v136 = (char *)(v110 + 3);
  v137 = (std::__shared_weak_count *)v110;
  v112 = (const __CFDictionary *)MEMORY[0x24BDAC760];
  *(_QWORD *)buf = MEMORY[0x24BDAC760];
  *(_QWORD *)&buf[8] = 1174405120;
  *(_QWORD *)&buf[16] = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN19QMISMSCommandDriver7sendAckEN10subscriber7SimSlotENSt3__110shared_ptrIN3sms5ModelEEEbbjNS_3wms13MessageFormatEbbE3__4EEOS1_OT__block_invoke;
  *(_QWORD *)&buf[24] = &__block_descriptor_tmp_61;
  *(_QWORD *)&buf[32] = v110 + 3;
  v140 = (std::__shared_weak_count *)v110;
  do
    v113 = __ldxr(v111);
  while (__stxr(v113 + 1, v111));
  v141 = v103;
  theDict[0] = v112;
  theDict[1] = (CFDictionaryRef)0x40000000;
  theDict[2] = (CFDictionaryRef)___ZNO3qmi6Client9SendProxy8callbackIRKN3wms7SendAck8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
  theDict[3] = (CFDictionaryRef)&unk_24D5C65F8;
  theDict[4] = (CFDictionaryRef)buf;
  *(_QWORD *)(v105 + 32) = _Block_copy(theDict);
  v114 = v140;
  if (v140)
  {
    v115 = (unint64_t *)&v140->__shared_owners_;
    do
      v116 = __ldaxr(v115);
    while (__stlxr(v116 - 1, v115));
    if (!v116)
    {
      ((void (*)(std::__shared_weak_count *))v114->__on_zero_shared)(v114);
      std::__shared_weak_count::__release_weak(v114);
    }
  }
  v117 = v137;
  if (v137)
  {
    v118 = (unint64_t *)&v137->__shared_owners_;
    do
      v119 = __ldaxr(v118);
    while (__stlxr(v119 - 1, v118));
    if (!v119)
    {
      ((void (*)(std::__shared_weak_count *))v117->__on_zero_shared)(v117);
      std::__shared_weak_count::__release_weak(v117);
    }
  }
  v120 = v130;
  if (v130)
  {
    v121 = (unint64_t *)&v130->__shared_owners_;
    do
      v122 = __ldaxr(v121);
    while (__stlxr(v122 - 1, v121));
    if (!v122)
    {
      ((void (*)(std::__shared_weak_count *))v120->__on_zero_shared)(v120);
      std::__shared_weak_count::__release_weak(v120);
    }
  }
  v123 = v133;
  v133 = 0;
  if (v123)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v133, v123);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
}

void sub_2168E54E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,char a27)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

void QMISMSCommandDriver::sendSegment(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6;
  os_log_t *v7;
  unsigned int v8;
  int TransportType;
  const void **v10;
  NSObject *v11;
  const char *v12;
  char *v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  char *v22;
  uint64_t *v23;
  char *v24;
  char *v25;
  char *v26;
  uint64_t v27;
  void *v28;
  char v29;
  NSObject *v30;
  const char *v31;
  const void **v32;
  const void **v33;
  const void **v34;
  const void **v35;
  char *v36;
  char *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  char *v41;
  _BYTE *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  _QWORD *v46;
  uint64_t v47;
  unint64_t v48;
  unint64_t v49;
  char *v50;
  uint64_t v51;
  unint64_t v52;
  unint64_t v53;
  char *v54;
  const void **v55;
  char *v56;
  char *v57;
  char *v58;
  const void *v59;
  char *v60;
  _BYTE *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  _QWORD *v65;
  uint64_t v66;
  unint64_t v67;
  unint64_t v68;
  char *v69;
  uint64_t *v70;
  char *v71;
  char *v72;
  char *v73;
  uint64_t v74;
  char *v75;
  uint64_t *v76;
  char *v77;
  char *v78;
  char *v79;
  uint64_t v80;
  NSObject *v81;
  const void **v82;
  const void **v83;
  const void **v84;
  char *v85;
  _BYTE *v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  unint64_t v91;
  unint64_t v92;
  char *v93;
  const void **v94;
  char *v95;
  char *v96;
  char *v97;
  const void *v98;
  char *v99;
  _DWORD *v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  _QWORD *v104;
  uint64_t v105;
  unint64_t v106;
  unint64_t v107;
  char *v108;
  uint64_t *v109;
  char *v110;
  char *v111;
  char *v112;
  uint64_t v113;
  int v114;
  uint64_t v115;
  uint64_t v116;
  sms::Model *v117;
  uint64_t v118;
  unint64_t *v119;
  unint64_t v120;
  std::__shared_weak_count *v121;
  unint64_t *p_shared_owners;
  uint64_t v123;
  unint64_t v124;
  std::__shared_weak_count *v125;
  unint64_t *v126;
  unint64_t v127;
  std::__shared_weak_count *v128;
  unint64_t *v129;
  unint64_t v130;
  uint64_t v131;
  uint64_t v132;
  void *__p[2];
  __int128 v134;
  _QWORD *v135;
  std::__shared_weak_count *v136;
  _QWORD aBlock[5];
  __int128 buf;
  void (*v139)(uint64_t, qmi::MessageBase *);
  void *v140;
  _QWORD *v141;
  std::__shared_weak_count *v142;
  int v143;
  uint64_t v144;

  v144 = *MEMORY[0x24BDAC8D0];
  if (!*(_QWORD *)a2)
  {
    v11 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      return;
    LOWORD(buf) = 0;
    v12 = "Attempting to send segment of an null message";
    goto LABEL_14;
  }
  v6 = *(unsigned int *)(*(_QWORD *)a2 + 8);
  v7 = (os_log_t *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 88) + 16))(*(_QWORD *)(a1 + 88), v6);
  v8 = *(_DWORD *)(*(_QWORD *)a2 + 48);
  if (!v8)
  {
    v11 = *v7;
    if (!os_log_type_enabled(*v7, OS_LOG_TYPE_ERROR))
      return;
    LOWORD(buf) = 0;
    v12 = "Attempting to send segment with an invalid PDU type";
LABEL_14:
    _os_log_error_impl(&dword_216897000, v11, OS_LOG_TYPE_ERROR, v12, (uint8_t *)&buf, 2u);
    return;
  }
  TransportType = sms::Model::getTransportType(*(sms::Model **)a2);
  *(_OWORD *)__p = 0u;
  v134 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  v10 = (const void **)__p[1];
  if (__p[1] != (void *)v134)
  {
    while (*((_BYTE *)*v10 + 8) != 1)
    {
      if (++v10 == (const void **)v134)
        goto LABEL_15;
    }
  }
  if (v10 == (const void **)v134)
  {
LABEL_15:
    v15 = operator new();
    v16 = v15;
    *(_BYTE *)(v15 + 8) = 1;
    *(_QWORD *)v15 = &off_24D5C6640;
    *(_BYTE *)(v15 + 16) = 0;
    v14 = (char *)(v15 + 16);
    *(_QWORD *)(v15 + 32) = 0;
    *(_QWORD *)(v15 + 40) = 0;
    *(_QWORD *)(v15 + 24) = 0;
    v17 = v134;
    if ((unint64_t)v134 >= *((_QWORD *)&v134 + 1))
    {
      v19 = (uint64_t)(v134 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v19 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v20 = (uint64_t)(*((_QWORD *)&v134 + 1) - (unint64_t)__p[1]) >> 2;
      if (v20 <= v19 + 1)
        v20 = v19 + 1;
      if (*((_QWORD *)&v134 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v21 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v21 = v20;
      if (v21)
        v22 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v134 + 8, v21);
      else
        v22 = 0;
      v23 = (uint64_t *)&v22[8 * v19];
      v24 = &v22[8 * v21];
      *v23 = v16;
      v18 = v23 + 1;
      v26 = (char *)__p[1];
      v25 = (char *)v134;
      if ((void *)v134 != __p[1])
      {
        do
        {
          v27 = *((_QWORD *)v25 - 1);
          v25 -= 8;
          *--v23 = v27;
        }
        while (v25 != v26);
        v25 = (char *)__p[1];
      }
      __p[1] = v23;
      *(_QWORD *)&v134 = v18;
      *((_QWORD *)&v134 + 1) = v24;
      if (v25)
        operator delete(v25);
    }
    else
    {
      *(_QWORD *)v134 = v15;
      v18 = (_QWORD *)(v17 + 8);
    }
    *(_QWORD *)&v134 = v18;
  }
  else
  {
    if (!v13)
      __cxa_bad_cast();
    v14 = v13 + 16;
  }
  (*(void (**)(__int128 *__return_ptr))(**(_QWORD **)a2 + 168))(&buf);
  v28 = (void *)*((_QWORD *)v14 + 1);
  if (v28)
  {
    *((_QWORD *)v14 + 2) = v28;
    operator delete(v28);
  }
  *(_OWORD *)(v14 + 8) = buf;
  *((_QWORD *)v14 + 3) = v139;
  if (v8 >= 2)
    v29 = 0;
  else
    v29 = 6;
  *v14 = v29;
  if (v8 != 2 || TransportType == 2)
  {
    if (v8 != 1 || !a3 || TransportType == 2)
    {
      if (TransportType == 2)
        *qmi::MutableMessageBase::getTLV<wms::tlv::IMSControl>(__p) = 1;
      goto LABEL_124;
    }
    v35 = (const void **)__p[1];
    if (__p[1] != (void *)v134)
    {
      while (*((_BYTE *)*v35 + 8) != 18)
      {
        if (++v35 == (const void **)v134)
          goto LABEL_65;
      }
    }
    if (v35 == (const void **)v134)
    {
LABEL_65:
      v43 = operator new();
      v44 = v43;
      *(_WORD *)(v43 + 8) = 18;
      *(_QWORD *)v43 = &off_24D5C6780;
      v45 = v134;
      if ((unint64_t)v134 >= *((_QWORD *)&v134 + 1))
      {
        v51 = (uint64_t)(v134 - (unint64_t)__p[1]) >> 3;
        if ((unint64_t)(v51 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v52 = (uint64_t)(*((_QWORD *)&v134 + 1) - (unint64_t)__p[1]) >> 2;
        if (v52 <= v51 + 1)
          v52 = v51 + 1;
        if (*((_QWORD *)&v134 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v53 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v53 = v52;
        if (v53)
          v54 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v134 + 8, v53);
        else
          v54 = 0;
        v76 = (uint64_t *)&v54[8 * v51];
        v77 = &v54[8 * v53];
        *v76 = v44;
        v46 = v76 + 1;
        v79 = (char *)__p[1];
        v78 = (char *)v134;
        if ((void *)v134 != __p[1])
        {
          do
          {
            v80 = *((_QWORD *)v78 - 1);
            v78 -= 8;
            *--v76 = v80;
          }
          while (v78 != v79);
          v78 = (char *)__p[1];
        }
        __p[1] = v76;
        *(_QWORD *)&v134 = v46;
        *((_QWORD *)&v134 + 1) = v77;
        if (v78)
          operator delete(v78);
      }
      else
      {
        *(_QWORD *)v134 = v43;
        v46 = (_QWORD *)(v45 + 8);
      }
      v42 = (_BYTE *)(v44 + 9);
      *(_QWORD *)&v134 = v46;
    }
    else
    {
      if (!v41)
        __cxa_bad_cast();
      v42 = v41 + 9;
    }
    *v42 = 1;
    v75 = qmi::MutableMessageBase::getTLV<wms::tlv::IMSControl>(__p);
  }
  else
  {
    v30 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      v31 = " not";
      if (a3)
        v31 = (const char *)&unk_216AC4FCA;
      LODWORD(buf) = 136315138;
      *(_QWORD *)((char *)&buf + 4) = v31;
      _os_log_impl(&dword_216897000, v30, OS_LOG_TYPE_DEFAULT, "#I We're going to use the dedicated channel and there are%s more messages", (uint8_t *)&buf, 0xCu);
    }
    v32 = (const void **)__p[1];
    v33 = (const void **)v134;
    v34 = (const void **)__p[1];
    if (__p[1] != (void *)v134)
    {
      v34 = (const void **)__p[1];
      while (*((_BYTE *)*v34 + 8) != 16)
      {
        if (++v34 == (const void **)v134)
          goto LABEL_58;
      }
    }
    if (v34 == (const void **)v134)
    {
LABEL_58:
      v38 = operator new();
      v39 = v38;
      *(_BYTE *)(v38 + 8) = 16;
      *(_QWORD *)v38 = &off_24D5C6690;
      *(_BYTE *)(v38 + 12) = 0;
      v37 = (char *)(v38 + 12);
      *(_DWORD *)(v38 + 16) = 0;
      v40 = v134;
      if ((unint64_t)v134 >= *((_QWORD *)&v134 + 1))
      {
        v47 = (uint64_t)(v134 - (unint64_t)__p[1]) >> 3;
        if ((unint64_t)(v47 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v48 = (uint64_t)(*((_QWORD *)&v134 + 1) - (unint64_t)__p[1]) >> 2;
        if (v48 <= v47 + 1)
          v48 = v47 + 1;
        if (*((_QWORD *)&v134 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v49 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v49 = v48;
        if (v49)
          v50 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v134 + 8, v49);
        else
          v50 = 0;
        v55 = (const void **)&v50[8 * v47];
        v56 = &v50[8 * v49];
        *v55 = (const void *)v39;
        v33 = v55 + 1;
        v58 = (char *)__p[1];
        v57 = (char *)v134;
        if ((void *)v134 != __p[1])
        {
          do
          {
            v59 = (const void *)*((_QWORD *)v57 - 1);
            v57 -= 8;
            *--v55 = v59;
          }
          while (v57 != v58);
          v57 = (char *)__p[1];
        }
        __p[1] = v55;
        *(_QWORD *)&v134 = v33;
        *((_QWORD *)&v134 + 1) = v56;
        if (v57)
          operator delete(v57);
      }
      else
      {
        *(_QWORD *)v134 = v38;
        v33 = (const void **)(v40 + 8);
      }
      *(_QWORD *)&v134 = v33;
      v32 = (const void **)__p[1];
    }
    else
    {
      if (!v36)
        __cxa_bad_cast();
      v37 = v36 + 12;
    }
    *v37 = 1;
    *((_DWORD *)v37 + 1) = 0;
    while (v32 != v33)
    {
      if (*((_BYTE *)*v32 + 8) == 17)
      {
        if (v32 != v33)
        {
          if (!v60)
            __cxa_bad_cast();
          v61 = v60 + 9;
          goto LABEL_114;
        }
        break;
      }
      ++v32;
    }
    v62 = operator new();
    v63 = v62;
    *(_WORD *)(v62 + 8) = 17;
    *(_QWORD *)v62 = &off_24D5C66E0;
    v64 = v134;
    if ((unint64_t)v134 >= *((_QWORD *)&v134 + 1))
    {
      v66 = (uint64_t)(v134 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v66 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v67 = (uint64_t)(*((_QWORD *)&v134 + 1) - (unint64_t)__p[1]) >> 2;
      if (v67 <= v66 + 1)
        v67 = v66 + 1;
      if (*((_QWORD *)&v134 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v68 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v68 = v67;
      if (v68)
        v69 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v134 + 8, v68);
      else
        v69 = 0;
      v70 = (uint64_t *)&v69[8 * v66];
      v71 = &v69[8 * v68];
      *v70 = v63;
      v65 = v70 + 1;
      v73 = (char *)__p[1];
      v72 = (char *)v134;
      if ((void *)v134 != __p[1])
      {
        do
        {
          v74 = *((_QWORD *)v72 - 1);
          v72 -= 8;
          *--v70 = v74;
        }
        while (v72 != v73);
        v72 = (char *)__p[1];
      }
      __p[1] = v70;
      *(_QWORD *)&v134 = v65;
      *((_QWORD *)&v134 + 1) = v71;
      if (v72)
        operator delete(v72);
    }
    else
    {
      *(_QWORD *)v134 = v62;
      v65 = (_QWORD *)(v64 + 8);
    }
    v61 = (_BYTE *)(v63 + 9);
    *(_QWORD *)&v134 = v65;
LABEL_114:
    *v61 = a3;
    v75 = qmi::MutableMessageBase::getTLV<wms::tlv::IMSControl>(__p);
  }
  *v75 = 0;
LABEL_124:
  if (*(_BYTE *)(*(_QWORD *)a2 + 54))
  {
    v81 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v81, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl(&dword_216897000, v81, OS_LOG_TYPE_DEFAULT, "#N We are retrying a message", (uint8_t *)&buf, 2u);
    }
    v82 = (const void **)__p[1];
    v83 = (const void **)v134;
    v84 = (const void **)__p[1];
    if (__p[1] != (void *)v134)
    {
      v84 = (const void **)__p[1];
      while (*((_BYTE *)*v84 + 8) != 20)
      {
        if (++v84 == (const void **)v134)
          goto LABEL_135;
      }
    }
    if (v84 == (const void **)v134)
    {
LABEL_135:
      v87 = operator new();
      v88 = v87;
      *(_WORD *)(v87 + 8) = 20;
      *(_QWORD *)v87 = &off_24D5C67D0;
      v89 = v134;
      if ((unint64_t)v134 >= *((_QWORD *)&v134 + 1))
      {
        v90 = (uint64_t)(v134 - (unint64_t)__p[1]) >> 3;
        if ((unint64_t)(v90 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v91 = (uint64_t)(*((_QWORD *)&v134 + 1) - (unint64_t)__p[1]) >> 2;
        if (v91 <= v90 + 1)
          v91 = v90 + 1;
        if (*((_QWORD *)&v134 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v92 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v92 = v91;
        if (v92)
          v93 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v134 + 8, v92);
        else
          v93 = 0;
        v94 = (const void **)&v93[8 * v90];
        v95 = &v93[8 * v92];
        *v94 = (const void *)v88;
        v83 = v94 + 1;
        v97 = (char *)__p[1];
        v96 = (char *)v134;
        if ((void *)v134 != __p[1])
        {
          do
          {
            v98 = (const void *)*((_QWORD *)v96 - 1);
            v96 -= 8;
            *--v94 = v98;
          }
          while (v96 != v97);
          v96 = (char *)__p[1];
        }
        __p[1] = v94;
        *(_QWORD *)&v134 = v83;
        *((_QWORD *)&v134 + 1) = v95;
        if (v96)
          operator delete(v96);
      }
      else
      {
        *(_QWORD *)v134 = v87;
        v83 = (const void **)(v89 + 8);
      }
      v86 = (_BYTE *)(v88 + 9);
      *(_QWORD *)&v134 = v83;
      v82 = (const void **)__p[1];
    }
    else
    {
      if (!v85)
        __cxa_bad_cast();
      v86 = v85 + 9;
    }
    *v86 = 1;
    while (v82 != v83)
    {
      if (*((_BYTE *)*v82 + 8) == 21)
      {
        if (v82 != v83)
        {
          if (!v99)
            __cxa_bad_cast();
          v100 = v99 + 12;
          goto LABEL_176;
        }
        break;
      }
      ++v82;
    }
    v101 = operator new();
    v102 = v101;
    *(_BYTE *)(v101 + 8) = 21;
    *(_QWORD *)v101 = &off_24D5C6820;
    *(_DWORD *)(v101 + 12) = 0;
    v100 = (_DWORD *)(v101 + 12);
    v103 = v134;
    if ((unint64_t)v134 >= *((_QWORD *)&v134 + 1))
    {
      v105 = (uint64_t)(v134 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v105 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v106 = (uint64_t)(*((_QWORD *)&v134 + 1) - (unint64_t)__p[1]) >> 2;
      if (v106 <= v105 + 1)
        v106 = v105 + 1;
      if (*((_QWORD *)&v134 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v107 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v107 = v106;
      if (v107)
        v108 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v134 + 8, v107);
      else
        v108 = 0;
      v109 = (uint64_t *)&v108[8 * v105];
      v110 = &v108[8 * v107];
      *v109 = v102;
      v104 = v109 + 1;
      v112 = (char *)__p[1];
      v111 = (char *)v134;
      if ((void *)v134 != __p[1])
      {
        do
        {
          v113 = *((_QWORD *)v111 - 1);
          v111 -= 8;
          *--v109 = v113;
        }
        while (v111 != v112);
        v111 = (char *)__p[1];
      }
      __p[1] = v109;
      *(_QWORD *)&v134 = v104;
      *((_QWORD *)&v134 + 1) = v110;
      if (v111)
        operator delete(v111);
    }
    else
    {
      *(_QWORD *)v134 = v101;
      v104 = (_QWORD *)(v103 + 8);
    }
    *(_QWORD *)&v134 = v104;
LABEL_176:
    *v100 = sms::Model::getMessageID(*(sms::Model **)a2);
  }
  if ((v6 - 1) >= 3)
    v114 = 0;
  else
    v114 = v6;
  v115 = qmi::ClientRouter::get();
  v116 = operator new();
  *(_QWORD *)v116 = v115;
  *(_QWORD *)(v116 + 8) = QMIServiceMsg::create();
  *(_QWORD *)(v116 + 24) = 0;
  *(_QWORD *)(v116 + 32) = 0;
  v132 = v116;
  *(_DWORD *)(v116 + 16) = *MEMORY[0x24BDC46A8];
  v117 = *(sms::Model **)a2;
  v118 = *(_QWORD *)(a2 + 8);
  if (v118)
  {
    v119 = (unint64_t *)(v118 + 8);
    do
      v120 = __ldxr(v119);
    while (__stxr(v120 + 1, v119));
  }
  v121 = (std::__shared_weak_count *)operator new(0x30uLL);
  v121->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v121->__shared_owners_;
  v121->__shared_weak_owners_ = 0;
  v121->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C6888;
  v121[1].__vftable = (std::__shared_weak_count_vtbl *)a1;
  v121[1].__shared_owners_ = (uint64_t)v117;
  v121[1].__shared_weak_owners_ = v118;
  v135 = &v121[1].__vftable;
  v136 = v121;
  v123 = MEMORY[0x24BDAC760];
  *(_QWORD *)&buf = MEMORY[0x24BDAC760];
  *((_QWORD *)&buf + 1) = 1174405120;
  v139 = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN19QMISMSCommandDriver11sendSegmentENSt3__110shared_ptrIN3sms5ModelEEEbE3__9EEOS1_OT__block_invoke;
  v140 = &__block_descriptor_tmp_63;
  v141 = &v121[1].__vftable;
  v142 = v121;
  do
    v124 = __ldxr(p_shared_owners);
  while (__stxr(v124 + 1, p_shared_owners));
  v143 = v114;
  aBlock[0] = v123;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3wms7RawSend8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
  aBlock[3] = &unk_24D5C68D0;
  aBlock[4] = &buf;
  *(_QWORD *)(v116 + 32) = _Block_copy(aBlock);
  v125 = v142;
  if (v142)
  {
    v126 = (unint64_t *)&v142->__shared_owners_;
    do
      v127 = __ldaxr(v126);
    while (__stlxr(v127 - 1, v126));
    if (!v127)
    {
      ((void (*)(std::__shared_weak_count *))v125->__on_zero_shared)(v125);
      std::__shared_weak_count::__release_weak(v125);
    }
  }
  v128 = v136;
  if (v136)
  {
    v129 = (unint64_t *)&v136->__shared_owners_;
    do
      v130 = __ldaxr(v129);
    while (__stlxr(v130 - 1, v129));
    if (!v130)
    {
      ((void (*)(std::__shared_weak_count *))v128->__on_zero_shared)(v128);
      std::__shared_weak_count::__release_weak(v128);
    }
  }
  v131 = v132;
  v132 = 0;
  if (v131)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v132, v131);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
}

void sub_2168E6254(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

void QMISMSCommandDriver::sendSetBroadcastActivation(uint64_t a1, int a2, unsigned __int8 a3, uint64_t a4)
{
  NSObject **v8;
  const void **v9;
  const void **v10;
  char *v11;
  _BYTE *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  char *v19;
  const void **v20;
  char *v21;
  char *v22;
  char *v23;
  const void *v24;
  NSObject *v25;
  const void **i;
  char *v27;
  _BYTE *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  _QWORD *v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  char *v36;
  uint64_t *v37;
  char *v38;
  char *v39;
  char *v40;
  uint64_t v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  _QWORD *v45;
  unint64_t *v46;
  uint64_t v47;
  unint64_t v48;
  std::__shared_weak_count *v49;
  unint64_t *p_shared_owners;
  unint64_t v51;
  std::__shared_weak_count *v52;
  unint64_t *v53;
  unint64_t v54;
  uint64_t v55;
  uint64_t v56;
  void *__p[2];
  __int128 v58;
  char *v59;
  std::__shared_weak_count *v60;
  _QWORD aBlock[5];
  uint8_t buf[8];
  uint64_t v63;
  void (*v64)(uint64_t, uint64_t);
  void *v65;
  char *v66;
  std::__shared_weak_count *v67;
  int v68;
  uint64_t v69;

  v69 = *MEMORY[0x24BDAC8D0];
  *(_OWORD *)__p = 0u;
  v58 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  v8 = (NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 88) + 16))(*(_QWORD *)(a1 + 88), a4);
  v9 = (const void **)__p[1];
  v10 = (const void **)v58;
  if (__p[1] != (void *)v58)
  {
    while (*((_BYTE *)*v9 + 8) != 1)
    {
      if (++v9 == (const void **)v58)
        goto LABEL_8;
    }
  }
  if (v9 == (const void **)v58)
  {
LABEL_8:
    v13 = operator new();
    v14 = v13;
    *(_WORD *)(v13 + 8) = 1;
    *(_QWORD *)v13 = &off_24D5C6918;
    *(_BYTE *)(v13 + 10) = 0;
    v15 = v58;
    if ((unint64_t)v58 >= *((_QWORD *)&v58 + 1))
    {
      v16 = (uint64_t)(v58 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v16 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v17 = (uint64_t)(*((_QWORD *)&v58 + 1) - (unint64_t)__p[1]) >> 2;
      if (v17 <= v16 + 1)
        v17 = v16 + 1;
      if (*((_QWORD *)&v58 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v18 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v18 = v17;
      if (v18)
        v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v58 + 8, v18);
      else
        v19 = 0;
      v20 = (const void **)&v19[8 * v16];
      v21 = &v19[8 * v18];
      *v20 = (const void *)v14;
      v10 = v20 + 1;
      v23 = (char *)__p[1];
      v22 = (char *)v58;
      if ((void *)v58 != __p[1])
      {
        do
        {
          v24 = (const void *)*((_QWORD *)v22 - 1);
          v22 -= 8;
          *--v20 = v24;
        }
        while (v22 != v23);
        v22 = (char *)__p[1];
      }
      __p[1] = v20;
      *(_QWORD *)&v58 = v10;
      *((_QWORD *)&v58 + 1) = v21;
      if (v22)
        operator delete(v22);
    }
    else
    {
      *(_QWORD *)v58 = v13;
      v10 = (const void **)(v15 + 8);
    }
    v12 = (_BYTE *)(v14 + 9);
    *(_QWORD *)&v58 = v10;
  }
  else
  {
    if (!v11)
      __cxa_bad_cast();
    v12 = v11 + 9;
  }
  *v12 = a2;
  v12[1] = a3;
  v25 = *v8;
  if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109376;
    *(_DWORD *)&buf[4] = a2;
    LOWORD(v63) = 1024;
    *(_DWORD *)((char *)&v63 + 2) = a3;
    _os_log_impl(&dword_216897000, v25, OS_LOG_TYPE_DEFAULT, "#I Settings mode %d and activation %d in the TLV", buf, 0xEu);
    v10 = (const void **)v58;
  }
  for (i = (const void **)__p[1]; i != v10; ++i)
  {
    if (*((_BYTE *)*i + 8) == 16)
    {
      if (i != v10)
      {
        if (!v27)
          __cxa_bad_cast();
        v28 = v27 + 9;
        goto LABEL_51;
      }
      break;
    }
  }
  v29 = operator new();
  v30 = v29;
  *(_WORD *)(v29 + 8) = 16;
  *(_QWORD *)v29 = &off_24D5C6968;
  v31 = v58;
  if ((unint64_t)v58 >= *((_QWORD *)&v58 + 1))
  {
    v33 = (uint64_t)(v58 - (unint64_t)__p[1]) >> 3;
    if ((unint64_t)(v33 + 1) >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v34 = (uint64_t)(*((_QWORD *)&v58 + 1) - (unint64_t)__p[1]) >> 2;
    if (v34 <= v33 + 1)
      v34 = v33 + 1;
    if (*((_QWORD *)&v58 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
      v35 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v35 = v34;
    if (v35)
      v36 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v58 + 8, v35);
    else
      v36 = 0;
    v37 = (uint64_t *)&v36[8 * v33];
    v38 = &v36[8 * v35];
    *v37 = v30;
    v32 = v37 + 1;
    v40 = (char *)__p[1];
    v39 = (char *)v58;
    if ((void *)v58 != __p[1])
    {
      do
      {
        v41 = *((_QWORD *)v39 - 1);
        v39 -= 8;
        *--v37 = v41;
      }
      while (v39 != v40);
      v39 = (char *)__p[1];
    }
    __p[1] = v37;
    *(_QWORD *)&v58 = v32;
    *((_QWORD *)&v58 + 1) = v38;
    if (v39)
      operator delete(v39);
  }
  else
  {
    *(_QWORD *)v58 = v29;
    v32 = (_QWORD *)(v31 + 8);
  }
  v28 = (_BYTE *)(v30 + 9);
  *(_QWORD *)&v58 = v32;
LABEL_51:
  *v28 = 1;
  if ((a4 - 1) >= 3)
    v42 = 0;
  else
    v42 = a4;
  v43 = qmi::ClientRouter::get();
  v44 = operator new();
  *(_QWORD *)v44 = v43;
  *(_QWORD *)(v44 + 8) = QMIServiceMsg::create();
  *(_DWORD *)(v44 + 16) = 25000;
  *(_QWORD *)(v44 + 24) = 0;
  *(_QWORD *)(v44 + 32) = 0;
  v56 = v44;
  v45 = operator new(0x28uLL);
  v45[1] = 0;
  v46 = v45 + 1;
  v45[2] = 0;
  *v45 = &off_24D5C69D0;
  v45[3] = a1;
  *((_DWORD *)v45 + 8) = a2;
  v59 = (char *)(v45 + 3);
  v60 = (std::__shared_weak_count *)v45;
  v47 = MEMORY[0x24BDAC760];
  *(_QWORD *)buf = MEMORY[0x24BDAC760];
  v63 = 1174405120;
  v64 = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN19QMISMSCommandDriver26sendSetBroadcastActivationEN3sms19BroadcastConfigModeENS4_22BroadcastSMSActivationEN10subscriber7SimSlotEE3__2EEOS1_OT__block_invoke;
  v65 = &__block_descriptor_tmp_65_0;
  v66 = (char *)(v45 + 3);
  v67 = (std::__shared_weak_count *)v45;
  do
    v48 = __ldxr(v46);
  while (__stxr(v48 + 1, v46));
  v68 = v42;
  aBlock[0] = v47;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_1;
  aBlock[3] = &unk_24D5C5E60;
  aBlock[4] = buf;
  *(_QWORD *)(v44 + 32) = _Block_copy(aBlock);
  v49 = v67;
  if (v67)
  {
    p_shared_owners = (unint64_t *)&v67->__shared_owners_;
    do
      v51 = __ldaxr(p_shared_owners);
    while (__stlxr(v51 - 1, p_shared_owners));
    if (!v51)
    {
      ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
      std::__shared_weak_count::__release_weak(v49);
    }
  }
  v52 = v60;
  if (v60)
  {
    v53 = (unint64_t *)&v60->__shared_owners_;
    do
      v54 = __ldaxr(v53);
    while (__stlxr(v54 - 1, v53));
    if (!v54)
    {
      ((void (*)(std::__shared_weak_count *))v52->__on_zero_shared)(v52);
      std::__shared_weak_count::__release_weak(v52);
    }
  }
  v55 = v56;
  v56 = 0;
  if (v55)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v56, v55);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
}

void sub_2168E6844(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;
  va_list va;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v6 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v3);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  if (a3)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v4, a3);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

void QMISMSCommandDriver::sendSetBroadcastConfig3GPP(std::__shared_weak_count_vtbl *a1, int **a2, int a3)
{
  const void **v6;
  char *v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  char *v16;
  uint64_t *v17;
  char *v18;
  char *v19;
  char *v20;
  uint64_t v21;
  int *v22;
  int *v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  int v27;
  std::__shared_weak_count *v28;
  unint64_t *p_shared_owners;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  std::__shared_weak_count *v33;
  unint64_t *v34;
  unint64_t v35;
  std::__shared_weak_count *v36;
  unint64_t *v37;
  unint64_t v38;
  uint64_t v39;
  int v40;
  uint64_t v41;
  void *__p[2];
  __int128 v43;
  _QWORD v44[5];
  std::__shared_weak_count *v45;
  int v46;
  _QWORD *v47;
  std::__shared_weak_count *v48;
  _QWORD aBlock[5];

  *(_OWORD *)__p = 0u;
  v43 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  v6 = (const void **)__p[1];
  if (__p[1] != (void *)v43)
  {
    while (*((_BYTE *)*v6 + 8) != 16)
    {
      if (++v6 == (const void **)v43)
        goto LABEL_8;
    }
  }
  if (v6 == (const void **)v43)
  {
LABEL_8:
    v9 = operator new();
    v10 = v9;
    *(_BYTE *)(v9 + 8) = 16;
    *(_QWORD *)(v9 + 16) = 0;
    v8 = (uint64_t *)(v9 + 16);
    *(_QWORD *)v9 = &off_24D5C6A38;
    *(_QWORD *)(v9 + 24) = 0;
    *(_QWORD *)(v9 + 32) = 0;
    v11 = v43;
    if ((unint64_t)v43 >= *((_QWORD *)&v43 + 1))
    {
      v13 = (uint64_t)(v43 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v13 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v14 = (uint64_t)(*((_QWORD *)&v43 + 1) - (unint64_t)__p[1]) >> 2;
      if (v14 <= v13 + 1)
        v14 = v13 + 1;
      if (*((_QWORD *)&v43 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v15 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v15 = v14;
      if (v15)
        v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v43 + 8, v15);
      else
        v16 = 0;
      v17 = (uint64_t *)&v16[8 * v13];
      v18 = &v16[8 * v15];
      *v17 = v10;
      v12 = v17 + 1;
      v20 = (char *)__p[1];
      v19 = (char *)v43;
      if ((void *)v43 != __p[1])
      {
        do
        {
          v21 = *((_QWORD *)v19 - 1);
          v19 -= 8;
          *--v17 = v21;
        }
        while (v19 != v20);
        v19 = (char *)__p[1];
      }
      __p[1] = v17;
      *(_QWORD *)&v43 = v12;
      *((_QWORD *)&v43 + 1) = v18;
      if (v19)
        operator delete(v19);
    }
    else
    {
      *(_QWORD *)v43 = v9;
      v12 = (_QWORD *)(v11 + 8);
    }
    *(_QWORD *)&v43 = v12;
  }
  else
  {
    if (!v7)
      __cxa_bad_cast();
    v8 = (uint64_t *)(v7 + 16);
  }
  std::vector<wms::tlv::BroadcastConfig3GPP>::resize((uint64_t)v8, 0xAAAAAAAAAAAAAAABLL * (((char *)a2[1] - (char *)*a2) >> 1));
  v22 = *a2;
  v23 = a2[1];
  if (*a2 != v23)
  {
    v24 = *v8;
    do
    {
      v25 = *v22;
      *(_BYTE *)(v24 + 4) = *((_BYTE *)v22 + 4);
      *(_DWORD *)v24 = v25;
      v24 += 6;
      v22 = (int *)((char *)v22 + 6);
    }
    while (v22 != v23);
  }
  *qmi::MutableMessageBase::getTLV<wms::tlv::BroadcastConfigInfo>(__p) = 1;
  if ((a3 - 1) >= 3)
    a3 = 0;
  v26 = qmi::ClientRouter::get();
  qmi::ClientRouter::SendProxy::SendProxy<wms::SetBroadcastConfig::Request>((uint64_t)&v40, a3, v26);
  v27 = v40;
  v28 = (std::__shared_weak_count *)operator new(0x20uLL);
  v28->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v28->__shared_owners_;
  v28->__shared_weak_owners_ = 0;
  v28->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C6AF0;
  v28[1].__vftable = a1;
  v47 = &v28[1].__vftable;
  v48 = v28;
  v30 = v41;
  v31 = MEMORY[0x24BDAC760];
  v44[0] = MEMORY[0x24BDAC760];
  v44[1] = 1174405120;
  v44[2] = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN19QMISMSCommandDriver26sendSetBroadcastConfig3GPPERKNSt3__16vectorIN3sms19BroadcastConfig3GPPENS4_9allocatorIS7_EEEEN10subscriber7SimSlotEE3__2EEOS1_OT__block_invoke;
  v44[3] = &__block_descriptor_tmp_66_0;
  v44[4] = v28 + 1;
  v45 = v28;
  do
    v32 = __ldxr(p_shared_owners);
  while (__stxr(v32 + 1, p_shared_owners));
  v46 = v27;
  aBlock[0] = v31;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_1;
  aBlock[3] = &unk_24D5C5E60;
  aBlock[4] = v44;
  *(_QWORD *)(v30 + 32) = _Block_copy(aBlock);
  v33 = v45;
  if (v45)
  {
    v34 = (unint64_t *)&v45->__shared_owners_;
    do
      v35 = __ldaxr(v34);
    while (__stlxr(v35 - 1, v34));
    if (!v35)
    {
      ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
      std::__shared_weak_count::__release_weak(v33);
    }
  }
  v36 = v48;
  if (v48)
  {
    v37 = (unint64_t *)&v48->__shared_owners_;
    do
      v38 = __ldaxr(v37);
    while (__stlxr(v38 - 1, v37));
    if (!v38)
    {
      ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
      std::__shared_weak_count::__release_weak(v36);
    }
  }
  v39 = v41;
  v41 = 0;
  if (v39)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v41, v39);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
}

void sub_2168E6C4C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  va_list va;
  uint64_t v7;
  va_list va1;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  va_list va2;

  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v5 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v7 = va_arg(va2, _QWORD);
  v9 = va_arg(va2, _QWORD);
  v10 = va_arg(va2, _QWORD);
  v11 = va_arg(va2, _QWORD);
  v12 = va_arg(va2, _QWORD);
  v13 = va_arg(va2, _QWORD);
  v14 = va_arg(va2, _QWORD);
  v15 = va_arg(va2, _QWORD);
  v16 = va_arg(va2, _QWORD);
  v17 = va_arg(va2, _QWORD);
  v18 = va_arg(va2, _QWORD);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v2);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va2);
  v4 = v5;
  v5 = 0;
  if (v4)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)va, v4);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va1);
  _Unwind_Resume(a1);
}

void QMISMSCommandDriver::sendSetBroadcastConfig3GPP2(std::__shared_weak_count_vtbl *a1, int **a2, int a3)
{
  const void **v6;
  char *v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  char *v16;
  uint64_t *v17;
  char *v18;
  char *v19;
  char *v20;
  uint64_t v21;
  int *v22;
  int *v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  int v27;
  std::__shared_weak_count *v28;
  unint64_t *p_shared_owners;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  std::__shared_weak_count *v33;
  unint64_t *v34;
  unint64_t v35;
  std::__shared_weak_count *v36;
  unint64_t *v37;
  unint64_t v38;
  uint64_t v39;
  int v40;
  uint64_t v41;
  void *__p[2];
  __int128 v43;
  _QWORD v44[5];
  std::__shared_weak_count *v45;
  int v46;
  _QWORD *v47;
  std::__shared_weak_count *v48;
  _QWORD aBlock[5];

  *(_OWORD *)__p = 0u;
  v43 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  v6 = (const void **)__p[1];
  if (__p[1] != (void *)v43)
  {
    while (*((_BYTE *)*v6 + 8) != 17)
    {
      if (++v6 == (const void **)v43)
        goto LABEL_8;
    }
  }
  if (v6 == (const void **)v43)
  {
LABEL_8:
    v9 = operator new();
    v10 = v9;
    *(_BYTE *)(v9 + 8) = 17;
    *(_QWORD *)(v9 + 16) = 0;
    v8 = (uint64_t *)(v9 + 16);
    *(_QWORD *)v9 = &off_24D5C6B58;
    *(_QWORD *)(v9 + 24) = 0;
    *(_QWORD *)(v9 + 32) = 0;
    v11 = v43;
    if ((unint64_t)v43 >= *((_QWORD *)&v43 + 1))
    {
      v13 = (uint64_t)(v43 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v13 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v14 = (uint64_t)(*((_QWORD *)&v43 + 1) - (unint64_t)__p[1]) >> 2;
      if (v14 <= v13 + 1)
        v14 = v13 + 1;
      if (*((_QWORD *)&v43 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v15 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v15 = v14;
      if (v15)
        v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v43 + 8, v15);
      else
        v16 = 0;
      v17 = (uint64_t *)&v16[8 * v13];
      v18 = &v16[8 * v15];
      *v17 = v10;
      v12 = v17 + 1;
      v20 = (char *)__p[1];
      v19 = (char *)v43;
      if ((void *)v43 != __p[1])
      {
        do
        {
          v21 = *((_QWORD *)v19 - 1);
          v19 -= 8;
          *--v17 = v21;
        }
        while (v19 != v20);
        v19 = (char *)__p[1];
      }
      __p[1] = v17;
      *(_QWORD *)&v43 = v12;
      *((_QWORD *)&v43 + 1) = v18;
      if (v19)
        operator delete(v19);
    }
    else
    {
      *(_QWORD *)v43 = v9;
      v12 = (_QWORD *)(v11 + 8);
    }
    *(_QWORD *)&v43 = v12;
  }
  else
  {
    if (!v7)
      __cxa_bad_cast();
    v8 = (uint64_t *)(v7 + 16);
  }
  std::vector<wms::tlv::BroadcastConfig3GPP>::resize((uint64_t)v8, 0xAAAAAAAAAAAAAAABLL * (((char *)a2[1] - (char *)*a2) >> 1));
  v22 = *a2;
  v23 = a2[1];
  if (*a2 != v23)
  {
    v24 = *v8;
    do
    {
      v25 = *v22;
      *(_BYTE *)(v24 + 4) = *((_BYTE *)v22 + 4);
      *(_DWORD *)v24 = v25;
      v24 += 6;
      v22 = (int *)((char *)v22 + 6);
    }
    while (v22 != v23);
  }
  *qmi::MutableMessageBase::getTLV<wms::tlv::BroadcastConfigInfo>(__p) = 0;
  if ((a3 - 1) >= 3)
    a3 = 0;
  v26 = qmi::ClientRouter::get();
  qmi::ClientRouter::SendProxy::SendProxy<wms::SetBroadcastConfig::Request>((uint64_t)&v40, a3, v26);
  v27 = v40;
  v28 = (std::__shared_weak_count *)operator new(0x20uLL);
  v28->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v28->__shared_owners_;
  v28->__shared_weak_owners_ = 0;
  v28->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C6BC0;
  v28[1].__vftable = a1;
  v47 = &v28[1].__vftable;
  v48 = v28;
  v30 = v41;
  v31 = MEMORY[0x24BDAC760];
  v44[0] = MEMORY[0x24BDAC760];
  v44[1] = 1174405120;
  v44[2] = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN19QMISMSCommandDriver27sendSetBroadcastConfig3GPP2ERKNSt3__16vectorIN3sms20BroadcastConfig3GPP2ENS4_9allocatorIS7_EEEEN10subscriber7SimSlotEE3__2EEOS1_OT__block_invoke;
  v44[3] = &__block_descriptor_tmp_67;
  v44[4] = v28 + 1;
  v45 = v28;
  do
    v32 = __ldxr(p_shared_owners);
  while (__stxr(v32 + 1, p_shared_owners));
  v46 = v27;
  aBlock[0] = v31;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_1;
  aBlock[3] = &unk_24D5C5E60;
  aBlock[4] = v44;
  *(_QWORD *)(v30 + 32) = _Block_copy(aBlock);
  v33 = v45;
  if (v45)
  {
    v34 = (unint64_t *)&v45->__shared_owners_;
    do
      v35 = __ldaxr(v34);
    while (__stlxr(v35 - 1, v34));
    if (!v35)
    {
      ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
      std::__shared_weak_count::__release_weak(v33);
    }
  }
  v36 = v48;
  if (v48)
  {
    v37 = (unint64_t *)&v48->__shared_owners_;
    do
      v38 = __ldaxr(v37);
    while (__stlxr(v38 - 1, v37));
    if (!v38)
    {
      ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
      std::__shared_weak_count::__release_weak(v36);
    }
  }
  v39 = v41;
  v41 = 0;
  if (v39)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v41, v39);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
}

void sub_2168E7020(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  va_list va;
  uint64_t v7;
  va_list va1;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  va_list va2;

  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v5 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v7 = va_arg(va2, _QWORD);
  v9 = va_arg(va2, _QWORD);
  v10 = va_arg(va2, _QWORD);
  v11 = va_arg(va2, _QWORD);
  v12 = va_arg(va2, _QWORD);
  v13 = va_arg(va2, _QWORD);
  v14 = va_arg(va2, _QWORD);
  v15 = va_arg(va2, _QWORD);
  v16 = va_arg(va2, _QWORD);
  v17 = va_arg(va2, _QWORD);
  v18 = va_arg(va2, _QWORD);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v2);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va2);
  v4 = v5;
  v5 = 0;
  if (v4)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)va, v4);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va1);
  _Unwind_Resume(a1);
}

void QMISMSCommandDriver::sendGetBroadcastConfig3GPP(std::__shared_weak_count_vtbl *a1, int a2)
{
  uint64_t v4;
  int v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  _OWORD v20[2];
  _QWORD v21[5];
  std::__shared_weak_count *v22;
  int v23;
  _QWORD *v24;
  std::__shared_weak_count *v25;
  _QWORD aBlock[5];

  memset(v20, 0, sizeof(v20));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v20);
  *qmi::MutableMessageBase::getTLV<wms::tlv::BroadcastConfigInfo>(v20) = 1;
  if ((a2 - 1) >= 3)
    a2 = 0;
  v4 = qmi::ClientRouter::get();
  qmi::ClientRouter::SendProxy::SendProxy<wms::GetBroadcastConfig::Request>((uint64_t)&v18, a2, v4);
  v5 = v18;
  v6 = (std::__shared_weak_count *)operator new(0x20uLL);
  v6->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v6->__shared_owners_;
  v6->__shared_weak_owners_ = 0;
  v6->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C6C40;
  v6[1].__vftable = a1;
  v24 = &v6[1].__vftable;
  v25 = v6;
  v8 = v19;
  v9 = MEMORY[0x24BDAC760];
  v21[0] = MEMORY[0x24BDAC760];
  v21[1] = 1174405120;
  v21[2] = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN19QMISMSCommandDriver26sendGetBroadcastConfig3GPPEN10subscriber7SimSlotEE3__1EEOS1_OT__block_invoke;
  v21[3] = &__block_descriptor_tmp_68;
  v21[4] = v6 + 1;
  v22 = v6;
  do
    v10 = __ldxr(p_shared_owners);
  while (__stxr(v10 + 1, p_shared_owners));
  v23 = v5;
  aBlock[0] = v9;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_1;
  aBlock[3] = &unk_24D5C5E60;
  aBlock[4] = v21;
  *(_QWORD *)(v8 + 32) = _Block_copy(aBlock);
  v11 = v22;
  if (v22)
  {
    v12 = (unint64_t *)&v22->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  v14 = v25;
  if (v25)
  {
    v15 = (unint64_t *)&v25->__shared_owners_;
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
  v17 = v19;
  v19 = 0;
  if (v17)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v19, v17);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v20);
}

void sub_2168E7240(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  va_list va;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v6 = va_arg(va1, _QWORD);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v2);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v3 - 88);
  v5 = v6;
  v6 = 0;
  if (v5)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)va, v5);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va1);
  _Unwind_Resume(a1);
}

void QMISMSCommandDriver::sendGetBroadcastConfig3GPP2(std::__shared_weak_count_vtbl *a1, int a2)
{
  uint64_t v4;
  int v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  _OWORD v20[2];
  _QWORD v21[5];
  std::__shared_weak_count *v22;
  int v23;
  _QWORD *v24;
  std::__shared_weak_count *v25;
  _QWORD aBlock[5];

  memset(v20, 0, sizeof(v20));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v20);
  *qmi::MutableMessageBase::getTLV<wms::tlv::BroadcastConfigInfo>(v20) = 0;
  if ((a2 - 1) >= 3)
    a2 = 0;
  v4 = qmi::ClientRouter::get();
  qmi::ClientRouter::SendProxy::SendProxy<wms::GetBroadcastConfig::Request>((uint64_t)&v18, a2, v4);
  v5 = v18;
  v6 = (std::__shared_weak_count *)operator new(0x20uLL);
  v6->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v6->__shared_owners_;
  v6->__shared_weak_owners_ = 0;
  v6->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C6D10;
  v6[1].__vftable = a1;
  v24 = &v6[1].__vftable;
  v25 = v6;
  v8 = v19;
  v9 = MEMORY[0x24BDAC760];
  v21[0] = MEMORY[0x24BDAC760];
  v21[1] = 1174405120;
  v21[2] = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN19QMISMSCommandDriver27sendGetBroadcastConfig3GPP2EN10subscriber7SimSlotEE3__1EEOS1_OT__block_invoke;
  v21[3] = &__block_descriptor_tmp_69;
  v21[4] = v6 + 1;
  v22 = v6;
  do
    v10 = __ldxr(p_shared_owners);
  while (__stxr(v10 + 1, p_shared_owners));
  v23 = v5;
  aBlock[0] = v9;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_1;
  aBlock[3] = &unk_24D5C5E60;
  aBlock[4] = v21;
  *(_QWORD *)(v8 + 32) = _Block_copy(aBlock);
  v11 = v22;
  if (v22)
  {
    v12 = (unint64_t *)&v22->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  v14 = v25;
  if (v25)
  {
    v15 = (unint64_t *)&v25->__shared_owners_;
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
  v17 = v19;
  v19 = 0;
  if (v17)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v19, v17);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v20);
}

void sub_2168E7458(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  va_list va;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v6 = va_arg(va1, _QWORD);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v2);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v3 - 88);
  v5 = v6;
  v6 = 0;
  if (v5)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)va, v5);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va1);
  _Unwind_Resume(a1);
}

uint64_t QMISMSCommandDriver::getSmsc(std::__shared_weak_count_vtbl *a1, int a2)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  uint64_t v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v19;
  _OWORD v20[2];
  _QWORD v21[5];
  std::__shared_weak_count *v22;
  int v23;
  _QWORD *v24;
  std::__shared_weak_count *v25;
  _QWORD aBlock[5];

  memset(v20, 0, sizeof(v20));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v20);
  if ((a2 - 1) >= 3)
    v4 = 0;
  else
    v4 = a2;
  v5 = qmi::ClientRouter::get();
  v6 = operator new();
  *(_QWORD *)v6 = v5;
  *(_QWORD *)(v6 + 8) = QMIServiceMsg::create();
  *(_DWORD *)(v6 + 16) = 25000;
  *(_QWORD *)(v6 + 24) = 0;
  *(_QWORD *)(v6 + 32) = 0;
  v19 = v6;
  v7 = (std::__shared_weak_count *)operator new(0x20uLL);
  v7->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v7->__shared_owners_;
  v7->__shared_weak_owners_ = 0;
  v7->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C6DE0;
  v7[1].__vftable = a1;
  v24 = &v7[1].__vftable;
  v25 = v7;
  v9 = MEMORY[0x24BDAC760];
  v21[0] = MEMORY[0x24BDAC760];
  v21[1] = 1174405120;
  v21[2] = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN19QMISMSCommandDriver7getSmscEN10subscriber7SimSlotEE3__0EEOS1_OT__block_invoke;
  v21[3] = &__block_descriptor_tmp_70_0;
  v21[4] = v7 + 1;
  v22 = v7;
  do
    v10 = __ldxr(p_shared_owners);
  while (__stxr(v10 + 1, p_shared_owners));
  v23 = v4;
  aBlock[0] = v9;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_1;
  aBlock[3] = &unk_24D5C5E60;
  aBlock[4] = v21;
  *(_QWORD *)(v6 + 32) = _Block_copy(aBlock);
  v11 = v22;
  if (v22)
  {
    v12 = (unint64_t *)&v22->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  v14 = v25;
  if (v25)
  {
    v15 = (unint64_t *)&v25->__shared_owners_;
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
  v17 = v19;
  v19 = 0;
  if (v17)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v19, v17);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v20);
  return 1;
}

void sub_2168E7690(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  va_list va;

  va_start(va, a3);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v4);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v5 - 88);
  if (a3)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v3, a3);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

void CSIPhoneNumber::~CSIPhoneNumber(void **this)
{
  if (*((char *)this + 111) < 0)
    operator delete(this[11]);
  if (*((char *)this + 87) < 0)
    operator delete(this[8]);
  if (*((char *)this + 55) < 0)
    operator delete(this[4]);
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

BOOL QMISMSCommandDriver::processSmscInfo(uint64_t a1, uint64_t a2, unsigned __int8 *a3, uint64_t a4)
{
  os_log_t *v6;
  NSObject *v7;
  std::string::value_type *v8;
  std::string::value_type *v9;
  void **v10;
  void **v11;
  void **v12;
  _OWORD *v13;
  NSObject *v14;
  int v15;
  int v16;
  NSObject *v17;
  std::string v19;
  uint8_t buf[8];
  __int128 v21;
  uint64_t v22;
  __int128 v23;
  uint64_t v24;
  int v25;
  char v26;
  __int128 __p;
  uint64_t v28;
  __int128 v29;
  uint64_t v30;
  __int128 v31;
  char v32;
  uint64_t v33;

  v33 = *MEMORY[0x24BDAC8D0];
  v6 = (os_log_t *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  v7 = *v6;
  if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_216897000, v7, OS_LOG_TYPE_DEFAULT, "#I Received SMSC Info Indication", buf, 2u);
  }
  v8 = (std::string::value_type *)*((_QWORD *)a3 + 1);
  v9 = (std::string::value_type *)*((_QWORD *)a3 + 2);
  if (v8 == v9)
  {
    v14 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_216897000, v14, OS_LOG_TYPE_ERROR, "SMSC is empty", buf, 2u);
    }
  }
  else
  {
    memset(&v19, 0, sizeof(v19));
    std::string::__assign_trivial[abi:ne180100]<unsigned char const*,unsigned char const*>(&v19, v8, v9, v9 - v8);
    MEMORY[0x2199FD7BC](buf, &v19);
    *(_QWORD *)a4 = *(_QWORD *)buf;
    v10 = (void **)(a4 + 8);
    if (*(char *)(a4 + 31) < 0)
      operator delete(*v10);
    *(_OWORD *)v10 = v21;
    *(_QWORD *)(a4 + 24) = v22;
    HIBYTE(v22) = 0;
    LOBYTE(v21) = 0;
    v11 = (void **)(a4 + 32);
    if (*(char *)(a4 + 55) < 0)
      operator delete(*v11);
    *(_OWORD *)v11 = v23;
    *(_QWORD *)(a4 + 48) = v24;
    HIBYTE(v24) = 0;
    LOBYTE(v23) = 0;
    *(_DWORD *)(a4 + 56) = v25;
    *(_BYTE *)(a4 + 60) = v26;
    v12 = (void **)(a4 + 64);
    if (*(char *)(a4 + 87) < 0)
      operator delete(*v12);
    *(_OWORD *)v12 = __p;
    *(_QWORD *)(a4 + 80) = v28;
    HIBYTE(v28) = 0;
    LOBYTE(__p) = 0;
    v13 = (_OWORD *)(a4 + 88);
    if (*(char *)(a4 + 111) < 0)
    {
      operator delete(*(void **)(a4 + 88));
      v15 = SHIBYTE(v28);
      *v13 = v29;
      *(_QWORD *)(a4 + 104) = v30;
      HIBYTE(v30) = 0;
      LOBYTE(v29) = 0;
      *(_OWORD *)(a4 + 112) = v31;
      *(_BYTE *)(a4 + 128) = v32;
      if (v15 < 0)
        operator delete((void *)__p);
    }
    else
    {
      *v13 = v29;
      *(_QWORD *)(a4 + 104) = v30;
      HIBYTE(v30) = 0;
      LOBYTE(v29) = 0;
      *(_OWORD *)(a4 + 112) = v31;
      *(_BYTE *)(a4 + 128) = v32;
    }
    if (SHIBYTE(v24) < 0)
      operator delete((void *)v23);
    if (SHIBYTE(v22) < 0)
      operator delete((void *)v21);
    v16 = 10 * a3[1] + 100 * *a3 + a3[2] - 5328;
    v17 = *v6;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&buf[4] = v16;
      _os_log_impl(&dword_216897000, v17, OS_LOG_TYPE_DEFAULT, "#I Type of address %d", buf, 8u);
    }
    CSIPhoneNumber::setTypeOfAddress((CSIPhoneNumber *)a4);
    if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v19.__r_.__value_.__l.__data_);
  }
  return v8 != v9;
}

void sub_2168E7A74(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t QMISMSCommandDriver::setSmsc(uint64_t a1, uint64_t a2, CSIPhoneNumber *a3)
{
  NSObject **v6;
  const void **v7;
  char *v8;
  std::string *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  char *v17;
  uint64_t *v18;
  char *v19;
  char *v20;
  char *v21;
  uint64_t v22;
  NSObject *v23;
  uint64_t v24;
  void *v25;
  std::string::size_type v26;
  std::string::value_type *v27;
  std::string::size_type v28;
  const void **v29;
  char *v30;
  std::string *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  _QWORD *v35;
  uint64_t v36;
  unint64_t v37;
  unint64_t v38;
  char *v39;
  uint64_t *v40;
  char *v41;
  char *v42;
  char *v43;
  uint64_t v44;
  int TypeOfAddress;
  std::string *v46;
  unint64_t v47;
  std::string::size_type v48;
  unint64_t v49;
  uint64_t v50;
  uint64_t i;
  int v52;
  uint64_t v53;
  uint64_t v54;
  std::__shared_weak_count *v55;
  unint64_t *p_shared_owners;
  uint64_t v57;
  unint64_t v58;
  std::__shared_weak_count *v59;
  unint64_t *v60;
  unint64_t v61;
  std::__shared_weak_count *v62;
  unint64_t *v63;
  unint64_t v64;
  uint64_t v65;
  uint64_t v67;
  void *__p[2];
  __int128 v69;
  void *v70;
  uint64_t v71;
  void (*v72)(uint64_t, uint64_t);
  void *v73;
  _QWORD *v74;
  std::__shared_weak_count *v75;
  int v76;
  _QWORD *v77;
  std::__shared_weak_count *v78;
  _BYTE buf[24];
  void *v80;
  void **v81;
  uint64_t v82;

  v82 = *MEMORY[0x24BDAC8D0];
  *(_OWORD *)__p = 0u;
  v69 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  v6 = (NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 88) + 16))(*(_QWORD *)(a1 + 88), a2);
  v7 = (const void **)__p[1];
  if (__p[1] != (void *)v69)
  {
    while (*((_BYTE *)*v7 + 8) != 1)
    {
      if (++v7 == (const void **)v69)
        goto LABEL_8;
    }
  }
  if (v7 == (const void **)v69)
  {
LABEL_8:
    v10 = operator new();
    v11 = v10;
    *(_BYTE *)(v10 + 8) = 1;
    *(_QWORD *)(v10 + 16) = 0;
    v9 = (std::string *)(v10 + 16);
    *(_QWORD *)v10 = off_24D5C6E48;
    *(_QWORD *)(v10 + 24) = 0;
    *(_QWORD *)(v10 + 32) = 0;
    v12 = v69;
    if ((unint64_t)v69 >= *((_QWORD *)&v69 + 1))
    {
      v14 = (uint64_t)(v69 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v14 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v15 = (uint64_t)(*((_QWORD *)&v69 + 1) - (unint64_t)__p[1]) >> 2;
      if (v15 <= v14 + 1)
        v15 = v14 + 1;
      if (*((_QWORD *)&v69 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v16 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v16 = v15;
      if (v16)
        v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v69 + 8, v16);
      else
        v17 = 0;
      v18 = (uint64_t *)&v17[8 * v14];
      v19 = &v17[8 * v16];
      *v18 = v11;
      v13 = v18 + 1;
      v21 = (char *)__p[1];
      v20 = (char *)v69;
      if ((void *)v69 != __p[1])
      {
        do
        {
          v22 = *((_QWORD *)v20 - 1);
          v20 -= 8;
          *--v18 = v22;
        }
        while (v20 != v21);
        v20 = (char *)__p[1];
      }
      __p[1] = v18;
      *(_QWORD *)&v69 = v13;
      *((_QWORD *)&v69 + 1) = v19;
      if (v20)
        operator delete(v20);
    }
    else
    {
      *(_QWORD *)v69 = v10;
      v13 = (_QWORD *)(v12 + 8);
    }
    *(_QWORD *)&v69 = v13;
  }
  else
  {
    if (!v8)
      __cxa_bad_cast();
    v9 = (std::string *)(v8 + 16);
  }
  v70 = 0;
  v71 = 0;
  v72 = 0;
  CSIPhoneNumber::getFullNumber(a3);
  v23 = *v6;
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    v24 = HIBYTE(v72);
    v25 = &v70;
    if (SHIBYTE(v72) < 0)
    {
      v25 = v70;
      v24 = v71;
    }
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = v25;
    *(_WORD *)&buf[12] = 2048;
    *(_QWORD *)&buf[14] = v24;
    _os_log_impl(&dword_216897000, v23, OS_LOG_TYPE_DEFAULT, "#I Writing SMSC %s of length %lu", buf, 0x16u);
  }
  if (SHIBYTE(v72) >= 0)
    v26 = HIBYTE(v72);
  else
    v26 = v71;
  std::string::reserve(v9, v26);
  if (SHIBYTE(v72) >= 0)
    v27 = (std::string::value_type *)&v70;
  else
    v27 = (std::string::value_type *)v70;
  if (SHIBYTE(v72) >= 0)
    v28 = HIBYTE(v72);
  else
    v28 = v71;
  std::string::__assign_trivial[abi:ne180100]<unsigned char const*,unsigned char const*>(v9, v27, &v27[v28], v28);
  std::string::push_back(v9, 0);
  if (SHIBYTE(v72) < 0)
    operator delete(v70);
  v29 = (const void **)__p[1];
  if (__p[1] != (void *)v69)
  {
    while (*((_BYTE *)*v29 + 8) != 16)
    {
      if (++v29 == (const void **)v69)
        goto LABEL_47;
    }
  }
  if (v29 == (const void **)v69)
  {
LABEL_47:
    v32 = operator new();
    v33 = v32;
    *(_BYTE *)(v32 + 8) = 16;
    *(_QWORD *)(v32 + 16) = 0;
    v31 = (std::string *)(v32 + 16);
    *(_QWORD *)v32 = off_24D5C6E98;
    *(_QWORD *)(v32 + 24) = 0;
    *(_QWORD *)(v32 + 32) = 0;
    v34 = v69;
    if ((unint64_t)v69 >= *((_QWORD *)&v69 + 1))
    {
      v36 = (uint64_t)(v69 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v36 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v37 = (uint64_t)(*((_QWORD *)&v69 + 1) - (unint64_t)__p[1]) >> 2;
      if (v37 <= v36 + 1)
        v37 = v36 + 1;
      if (*((_QWORD *)&v69 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v38 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v38 = v37;
      if (v38)
        v39 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v69 + 8, v38);
      else
        v39 = 0;
      v40 = (uint64_t *)&v39[8 * v36];
      v41 = &v39[8 * v38];
      *v40 = v33;
      v35 = v40 + 1;
      v43 = (char *)__p[1];
      v42 = (char *)v69;
      if ((void *)v69 != __p[1])
      {
        do
        {
          v44 = *((_QWORD *)v42 - 1);
          v42 -= 8;
          *--v40 = v44;
        }
        while (v42 != v43);
        v42 = (char *)__p[1];
      }
      __p[1] = v40;
      *(_QWORD *)&v69 = v35;
      *((_QWORD *)&v69 + 1) = v41;
      if (v42)
        operator delete(v42);
    }
    else
    {
      *(_QWORD *)v69 = v32;
      v35 = (_QWORD *)(v34 + 8);
    }
    *(_QWORD *)&v69 = v35;
  }
  else
  {
    if (!v30)
      __cxa_bad_cast();
    v31 = (std::string *)(v30 + 16);
  }
  CSIPhoneNumber::getFullNumber(a3);
  if ((SHIBYTE(v72) & 0x80000000) == 0)
  {
    if (HIBYTE(v72))
      goto LABEL_66;
LABEL_70:
    std::string::push_back(v31, 0);
    goto LABEL_79;
  }
  v50 = v71;
  operator delete(v70);
  if (!v50)
    goto LABEL_70;
LABEL_66:
  TypeOfAddress = CSIPhoneNumber::getTypeOfAddress(a3);
  LODWORD(v70) = 0;
  snprintf((char *)&v70, 4uLL, "%d", TypeOfAddress);
  std::string::reserve(v31, 4uLL);
  v46 = v31;
  if (SHIBYTE(v31->__r_.__value_.__r.__words[2]) < 0)
  {
    v47 = v31->__r_.__value_.__r.__words[2];
    v48 = (v47 & 0x7FFFFFFFFFFFFFFFLL) - 1;
    if (v48 > 3)
    {
      v49 = HIBYTE(v47);
    }
    else
    {
      std::string::__grow_by(v31, v48, 5 - (v47 & 0x7FFFFFFFFFFFFFFFLL), v31->__r_.__value_.__l.__size_, 0, v31->__r_.__value_.__l.__size_, 0);
      v31->__r_.__value_.__l.__size_ = 0;
      LOBYTE(v49) = *((_BYTE *)&v31->__r_.__value_.__s + 23);
    }
    v46 = v31;
    if ((v49 & 0x80) != 0)
      v46 = (std::string *)v31->__r_.__value_.__r.__words[0];
  }
  for (i = 0; i != 4; ++i)
    v46->__r_.__value_.__s.__data_[i] = *((_BYTE *)&v70 + i);
  v46->__r_.__value_.__s.__data_[4] = 0;
  if (SHIBYTE(v31->__r_.__value_.__r.__words[2]) < 0)
    v31->__r_.__value_.__l.__size_ = 4;
  else
    *((_BYTE *)&v31->__r_.__value_.__s + 23) = 4;
LABEL_79:
  if ((a2 - 1) >= 3)
    v52 = 0;
  else
    v52 = a2;
  v53 = qmi::ClientRouter::get();
  v54 = operator new();
  *(_QWORD *)v54 = v53;
  *(_QWORD *)(v54 + 8) = QMIServiceMsg::create();
  *(_DWORD *)(v54 + 16) = 25000;
  *(_QWORD *)(v54 + 24) = 0;
  *(_QWORD *)(v54 + 32) = 0;
  v67 = v54;
  v55 = (std::__shared_weak_count *)operator new(0x20uLL);
  v55->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v55->__shared_owners_;
  v55->__shared_weak_owners_ = 0;
  v55->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C6F00;
  v55[1].__vftable = (std::__shared_weak_count_vtbl *)a1;
  v77 = &v55[1].__vftable;
  v78 = v55;
  v57 = MEMORY[0x24BDAC760];
  v70 = (void *)MEMORY[0x24BDAC760];
  v71 = 1174405120;
  v72 = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN19QMISMSCommandDriver7setSmscEN10subscriber7SimSlotERK14CSIPhoneNumberE3__2EEOS1_OT__block_invoke;
  v73 = &__block_descriptor_tmp_72;
  v74 = &v55[1].__vftable;
  v75 = v55;
  do
    v58 = __ldxr(p_shared_owners);
  while (__stxr(v58 + 1, p_shared_owners));
  v76 = v52;
  *(_QWORD *)buf = v57;
  *(_QWORD *)&buf[8] = 0x40000000;
  *(_QWORD *)&buf[16] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3wms14SetSmscAddress8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
  v80 = &unk_24D5C6F48;
  v81 = &v70;
  *(_QWORD *)(v54 + 32) = _Block_copy(buf);
  v59 = v75;
  if (v75)
  {
    v60 = (unint64_t *)&v75->__shared_owners_;
    do
      v61 = __ldaxr(v60);
    while (__stlxr(v61 - 1, v60));
    if (!v61)
    {
      ((void (*)(std::__shared_weak_count *))v59->__on_zero_shared)(v59);
      std::__shared_weak_count::__release_weak(v59);
    }
  }
  v62 = v78;
  if (v78)
  {
    v63 = (unint64_t *)&v78->__shared_owners_;
    do
      v64 = __ldaxr(v63);
    while (__stlxr(v64 - 1, v63));
    if (!v64)
    {
      ((void (*)(std::__shared_weak_count *))v62->__on_zero_shared)(v62);
      std::__shared_weak_count::__release_weak(v62);
    }
  }
  v65 = v67;
  v67 = 0;
  if (v65)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v67, v65);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
  return 1;
}

void sub_2168E8174(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  uint64_t v28;
  uint64_t v29;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v29);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a28);
  if (a12)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v28, a12);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a13);
  _Unwind_Resume(a1);
}

void QMISMSCommandDriver::fetchVoicemailNotifications(std::__shared_weak_count_vtbl *a1, int a2)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  uint64_t v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _OWORD v19[2];
  _QWORD v20[5];
  std::__shared_weak_count *v21;
  int v22;
  _QWORD *v23;
  std::__shared_weak_count *v24;
  _QWORD aBlock[5];

  memset(v19, 0, sizeof(v19));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v19);
  if ((a2 - 1) >= 3)
    v4 = 0;
  else
    v4 = a2;
  v5 = qmi::ClientRouter::get();
  v6 = operator new();
  *(_QWORD *)v6 = v5;
  *(_QWORD *)(v6 + 8) = QMIServiceMsg::create();
  *(_DWORD *)(v6 + 16) = 25000;
  *(_QWORD *)(v6 + 24) = 0;
  *(_QWORD *)(v6 + 32) = 0;
  v18 = v6;
  v7 = (std::__shared_weak_count *)operator new(0x20uLL);
  v7->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v7->__shared_owners_;
  v7->__shared_weak_owners_ = 0;
  v7->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C6FA8;
  v7[1].__vftable = a1;
  v23 = &v7[1].__vftable;
  v24 = v7;
  v9 = MEMORY[0x24BDAC760];
  v20[0] = MEMORY[0x24BDAC760];
  v20[1] = 1174405120;
  v20[2] = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN19QMISMSCommandDriver27fetchVoicemailNotificationsEN10subscriber7SimSlotEE3__0EEOS1_OT__block_invoke;
  v20[3] = &__block_descriptor_tmp_74;
  v20[4] = v7 + 1;
  v21 = v7;
  do
    v10 = __ldxr(p_shared_owners);
  while (__stxr(v10 + 1, p_shared_owners));
  v22 = v4;
  aBlock[0] = v9;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_1;
  aBlock[3] = &unk_24D5C5E60;
  aBlock[4] = v20;
  *(_QWORD *)(v6 + 32) = _Block_copy(aBlock);
  v11 = v21;
  if (v21)
  {
    v12 = (unint64_t *)&v21->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  v14 = v24;
  if (v24)
  {
    v15 = (unint64_t *)&v24->__shared_owners_;
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
  v17 = v18;
  v18 = 0;
  if (v17)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v18, v17);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v19);
}

void sub_2168E83F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  va_list va;

  va_start(va, a3);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v4);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v5 - 88);
  if (a3)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v3, a3);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

void QMISMSCommandDriver::handleMsgWaitingInfo(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v6;
  unsigned int v7;
  int v8;
  os_log_t *v9;
  uint64_t v10;
  os_log_t *v11;
  NSObject *v12;
  int v13;
  uint64_t v14;
  std::__shared_weak_count *v15;
  std::__shared_weak_count *v16;
  uint64_t v17;
  unint64_t *p_shared_owners;
  unint64_t v19;
  NSObject *v20;
  unint64_t *v21;
  unint64_t v22;
  uint8_t v23[16];
  uint8_t buf[8];
  std::__shared_weak_count *v25;
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  if (a3[1] == *a3)
    return;
  v6 = 0;
  v7 = *MEMORY[0x24BDC4180];
  v8 = *MEMORY[0x24BDC4178];
  while (1)
  {
    v9 = (os_log_t *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 88) + 16))(*(_QWORD *)(a1 + 88), a2);
    v10 = *a3;
    if (*(_DWORD *)(*a3 + 8 * v6))
      goto LABEL_17;
    v11 = v9;
    v12 = *v9;
    if (os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT))
    {
      v13 = *(unsigned __int8 *)(v10 + 8 * v6 + 5);
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&buf[4] = v13;
      _os_log_impl(&dword_216897000, v12, OS_LOG_TYPE_DEFAULT, "#I Received message waiting indication with %d number of messages", buf, 8u);
      v10 = *a3;
    }
    v14 = *(unsigned __int8 *)(v10 + 8 * v6 + 5) == v8 ? v7 : *(unsigned __int8 *)(v10 + 8 * v6 + 5);
    *(_QWORD *)buf = 0;
    v25 = 0;
    v15 = *(std::__shared_weak_count **)(a1 + 80);
    if (!v15)
      break;
    v16 = std::__shared_weak_count::lock(v15);
    v25 = v16;
    if (!v16)
      goto LABEL_20;
    v17 = *(_QWORD *)(a1 + 72);
    *(_QWORD *)buf = v17;
    if (!v17)
      goto LABEL_20;
    (*(void (**)(uint64_t, uint64_t, _QWORD, uint64_t))(*(_QWORD *)v17 + 136))(v17, a2, *(unsigned __int8 *)(*a3 + 8 * v6 + 4), v14);
    p_shared_owners = (unint64_t *)&v16->__shared_owners_;
    do
      v19 = __ldaxr(p_shared_owners);
    while (__stlxr(v19 - 1, p_shared_owners));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
    v10 = *a3;
LABEL_17:
    if (++v6 >= (unint64_t)((a3[1] - v10) >> 3))
      return;
  }
  v16 = 0;
LABEL_20:
  v20 = *v11;
  if (os_log_type_enabled(*v11, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)v23 = 0;
    _os_log_error_impl(&dword_216897000, v20, OS_LOG_TYPE_ERROR, "Failed to get Sms controller...", v23, 2u);
    if (v16)
    {
LABEL_22:
      v21 = (unint64_t *)&v16->__shared_owners_;
      do
        v22 = __ldaxr(v21);
      while (__stlxr(v22 - 1, v21));
      if (!v22)
      {
        ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
        std::__shared_weak_count::__release_weak(v16);
      }
    }
  }
  else if (v16)
  {
    goto LABEL_22;
  }
}

void sub_2168E86AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void QMISMSCommandDriver::setRadioMode(QMISMSCommandDriver *this, char a2)
{
  NSObject *v4;
  int *v5;
  int *v6;
  uint64_t (*v7)(_QWORD);
  int *v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  int v12;
  std::__shared_weak_count *v13;
  unint64_t *p_shared_owners;
  uint64_t v15;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  uint64_t v23;
  int *v24;
  int v25;
  uint64_t v26;
  int *v27;
  int *v28;
  uint64_t (*v29)(_QWORD);
  _OWORD v30[2];
  _QWORD *v31;
  std::__shared_weak_count *v32;
  _QWORD aBlock[5];
  __int128 buf;
  void (*v35)(uint64_t, uint64_t);
  void *v36;
  _QWORD *v37;
  std::__shared_weak_count *v38;
  int v39;
  uint64_t v40;

  v40 = *MEMORY[0x24BDAC8D0];
  v4 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 136315138;
    *(_QWORD *)((char *)&buf + 4) = CSIBOOLAsString();
    _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I Changing WMS radio mode to %s", (uint8_t *)&buf, 0xCu);
  }
  memset(v30, 0, sizeof(v30));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v30);
  *qmi::MutableMessageBase::getTLV<wms::tlv::SubscriptionType>(v30) = a2;
  subscriber::makeSimSlotRange();
  v6 = v27;
  v5 = v28;
  if (v27 != v28)
  {
    v7 = v29;
    while ((v29(*v6) & 1) == 0)
    {
      if (++v6 == v28)
      {
        v6 = v28;
        break;
      }
    }
    v8 = v28;
    if (v6 != v28)
    {
      v9 = MEMORY[0x24BDAC760];
      do
      {
        if ((*v6 - 1) >= 3)
          v10 = 0;
        else
          v10 = *v6;
        v11 = qmi::ClientRouter::get();
        qmi::ClientRouter::SendProxy::SendProxy<wms::BindSubscription::Request>((uint64_t)&v25, v10, v11);
        v12 = v25;
        v13 = (std::__shared_weak_count *)operator new(0x20uLL);
        v13->__shared_owners_ = 0;
        p_shared_owners = (unint64_t *)&v13->__shared_owners_;
        v13->__shared_weak_owners_ = 0;
        v13->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C7028;
        v13[1].__vftable = (std::__shared_weak_count_vtbl *)this;
        v31 = &v13[1].__vftable;
        v32 = v13;
        v15 = v26;
        *(_QWORD *)&buf = v9;
        *((_QWORD *)&buf + 1) = 1174405120;
        v35 = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN19QMISMSCommandDriver12setRadioModeEbE3__1EEOS1_OT__block_invoke;
        v36 = &__block_descriptor_tmp_75_0;
        v37 = &v13[1].__vftable;
        v38 = v13;
        do
          v16 = __ldxr(p_shared_owners);
        while (__stxr(v16 + 1, p_shared_owners));
        v39 = v12;
        aBlock[0] = v9;
        aBlock[1] = 0x40000000;
        aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3wms16BindSubscription8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
        aBlock[3] = &unk_24D5C58A8;
        aBlock[4] = &buf;
        *(_QWORD *)(v15 + 32) = _Block_copy(aBlock);
        v17 = v38;
        if (v38)
        {
          v18 = (unint64_t *)&v38->__shared_owners_;
          do
            v19 = __ldaxr(v18);
          while (__stlxr(v19 - 1, v18));
          if (!v19)
          {
            ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
            std::__shared_weak_count::__release_weak(v17);
          }
        }
        v20 = v32;
        if (v32)
        {
          v21 = (unint64_t *)&v32->__shared_owners_;
          do
            v22 = __ldaxr(v21);
          while (__stlxr(v22 - 1, v21));
          if (!v22)
          {
            ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
            std::__shared_weak_count::__release_weak(v20);
          }
        }
        v23 = v26;
        v26 = 0;
        if (v23)
          std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v26, v23);
        v24 = v6 + 1;
        v6 = v5;
        if (v24 != v5)
        {
          v6 = v24;
          while ((v7(*v6) & 1) == 0)
          {
            if (++v6 == v5)
            {
              v6 = v5;
              break;
            }
          }
        }
      }
      while (v6 != v8);
    }
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v30);
}

void sub_2168E89B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

void QMISMSCommandDriver::setSmsRoutes(_QWORD *a1, int a2)
{
  std::__shared_weak_count *v3;
  uint64_t v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_weak_owners;
  unint64_t v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  uint64_t v14;
  std::__shared_weak_count *v15;
  std::__shared_weak_count *v16;
  uint64_t v17;
  unint64_t *v18;
  NSObject *v19;
  unint64_t v20;
  _QWORD *v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;

  v3 = (std::__shared_weak_count *)a1[2];
  if (!v3 || (v5 = a1[1], (v6 = std::__shared_weak_count::lock(v3)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v7 = v6;
  p_shared_weak_owners = (unint64_t *)&v6->__shared_weak_owners_;
  do
    v9 = __ldxr(p_shared_weak_owners);
  while (__stxr(v9 + 1, p_shared_weak_owners));
  p_shared_owners = (unint64_t *)&v6->__shared_owners_;
  do
    v11 = __ldaxr(p_shared_owners);
  while (__stlxr(v11 - 1, p_shared_owners));
  if (!v11)
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v7);
  }
  do
    v12 = __ldxr(p_shared_weak_owners);
  while (__stxr(v12 + 1, p_shared_weak_owners));
  v13 = (std::__shared_weak_count *)a1[2];
  if (!v13 || (v14 = a1[1], (v15 = std::__shared_weak_count::lock(v13)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v16 = v15;
  v17 = operator new();
  *(_QWORD *)v17 = a1;
  *(_DWORD *)(v17 + 8) = a2;
  *(_QWORD *)(v17 + 16) = v5;
  *(_QWORD *)(v17 + 24) = v7;
  v18 = (unint64_t *)&v16->__shared_owners_;
  v19 = a1[3];
  do
    v20 = __ldxr(v18);
  while (__stxr(v20 + 1, v18));
  v21 = (_QWORD *)operator new();
  *v21 = v17;
  v21[1] = v14;
  v21[2] = v16;
  v23 = 0;
  v24 = 0;
  dispatch_async_f(v19, v21, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::setSmsRoutes(subscriber::SimSlot)::$_0>(QMISMSCommandDriver::setSmsRoutes(subscriber::SimSlot)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMISMSCommandDriver::setSmsRoutes(subscriber::SimSlot)::$_0,dispatch_queue_s *::default_delete<QMISMSCommandDriver::setSmsRoutes(subscriber::SimSlot)::$_0>>)::{lambda(void *)#1}::__invoke);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v23);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v24);
  do
    v22 = __ldaxr(v18);
  while (__stlxr(v22 - 1, v18));
  if (!v22)
  {
    ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
    std::__shared_weak_count::__release_weak(v16);
  }
  std::__shared_weak_count::__release_weak(v7);
}

void std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](uint64_t a1, uint64_t a2)
{
  const void *v3;

  if (a2)
  {
    if (*(_QWORD *)(a2 + 8))
      qmi::Client::send();
    v3 = *(const void **)(a2 + 32);
    if (v3)
      _Block_release(v3);
    JUMPOUT(0x2199FEAC4);
  }
}

void CSIPhoneNumber::CSIPhoneNumber(CSIPhoneNumber *this, const CSIPhoneNumber *a2)
{
  __int128 v4;
  __int128 v5;
  __int128 v6;
  std::string *v7;
  __int128 v8;
  __int128 v9;

  *(_QWORD *)this = *(_QWORD *)a2;
  if (*((char *)a2 + 31) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)((char *)this + 8), *((const std::string::value_type **)a2 + 1), *((_QWORD *)a2 + 2));
  }
  else
  {
    v4 = *(_OWORD *)((char *)a2 + 8);
    *((_QWORD *)this + 3) = *((_QWORD *)a2 + 3);
    *(_OWORD *)((char *)this + 8) = v4;
  }
  if (*((char *)a2 + 55) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)((char *)this + 32), *((const std::string::value_type **)a2 + 4), *((_QWORD *)a2 + 5));
  }
  else
  {
    v5 = *((_OWORD *)a2 + 2);
    *((_QWORD *)this + 6) = *((_QWORD *)a2 + 6);
    *((_OWORD *)this + 2) = v5;
  }
  *((_QWORD *)this + 7) = *((_QWORD *)a2 + 7);
  if (*((char *)a2 + 87) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)((char *)this + 64), *((const std::string::value_type **)a2 + 8), *((_QWORD *)a2 + 9));
  }
  else
  {
    v6 = *((_OWORD *)a2 + 4);
    *((_QWORD *)this + 10) = *((_QWORD *)a2 + 10);
    *((_OWORD *)this + 4) = v6;
  }
  v7 = (std::string *)((char *)this + 88);
  if (*((char *)a2 + 111) < 0)
  {
    std::string::__init_copy_ctor_external(v7, *((const std::string::value_type **)a2 + 11), *((_QWORD *)a2 + 12));
  }
  else
  {
    v8 = *(_OWORD *)((char *)a2 + 88);
    *((_QWORD *)this + 13) = *((_QWORD *)a2 + 13);
    *(_OWORD *)&v7->__r_.__value_.__l.__data_ = v8;
  }
  v9 = *((_OWORD *)a2 + 7);
  *((_BYTE *)this + 128) = *((_BYTE *)a2 + 128);
  *((_OWORD *)this + 7) = v9;
}

void sub_2168E8D20(_Unwind_Exception *exception_object)
{
  char *v1;
  void **v2;
  void **v3;
  void **v4;

  if (v1[87] < 0)
    operator delete(*v4);
  if (v1[55] < 0)
    operator delete(*v3);
  if (v1[31] < 0)
    operator delete(*v2);
  _Unwind_Resume(exception_object);
}

uint64_t *std::shared_ptr<QMISMSCommandDriver>::shared_ptr[abi:ne180100]<QMISMSCommandDriver,std::shared_ptr<QMISMSCommandDriver> ctu::SharedSynchronizable<CSISMSCommandDriver>::make_shared_ptr<QMISMSCommandDriver>(QMISMSCommandDriver*)::{lambda(QMISMSCommandDriver*)#1},void>(uint64_t *a1, uint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24D5C4F28;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = (uint64_t)v4;
  if (a2)
    v5 = (_QWORD *)(a2 + 8);
  else
    v5 = 0;
  std::shared_ptr<QMIDataSystemDeterminationManager>::__enable_weak_this[abi:ne180100]<QMIDataSystemDeterminationManager,QMIDataSystemDeterminationManager,void>((uint64_t)a1, v5, a2);
  return a1;
}

void sub_2168E8DD8(void *a1)
{
  dispatch_queue_t *v1;

  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)std::shared_ptr<QMISMSCommandDriver> ctu::SharedSynchronizable<CSISMSCommandDriver>::make_shared_ptr<QMISMSCommandDriver>(QMISMSCommandDriver*)::{lambda(QMISMSCommandDriver*)#1}::operator() const(QMISMSCommandDriver*)::{lambda(void *)#1}::__invoke);
  __cxa_rethrow();
}

void sub_2168E8DF8(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<QMISMSCommandDriver *,std::shared_ptr<QMISMSCommandDriver> ctu::SharedSynchronizable<CSISMSCommandDriver>::make_shared_ptr<QMISMSCommandDriver>(QMISMSCommandDriver*)::{lambda(QMISMSCommandDriver *)#1},std::allocator<QMISMSCommandDriver>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void std::__shared_ptr_pointer<QMISMSCommandDriver *,std::shared_ptr<QMISMSCommandDriver> ctu::SharedSynchronizable<CSISMSCommandDriver>::make_shared_ptr<QMISMSCommandDriver>(QMISMSCommandDriver*)::{lambda(QMISMSCommandDriver *)#1},std::allocator<QMISMSCommandDriver>>::__on_zero_shared(uint64_t a1)
{
  dispatch_barrier_async_f(*(dispatch_queue_t *)(*(_QWORD *)(a1 + 24) + 24), *(void **)(a1 + 24), (dispatch_function_t)std::shared_ptr<QMISMSCommandDriver> ctu::SharedSynchronizable<CSISMSCommandDriver>::make_shared_ptr<QMISMSCommandDriver>(QMISMSCommandDriver*)::{lambda(QMISMSCommandDriver*)#1}::operator() const(QMISMSCommandDriver*)::{lambda(void *)#1}::__invoke);
}

uint64_t std::__shared_ptr_pointer<QMISMSCommandDriver *,std::shared_ptr<QMISMSCommandDriver> ctu::SharedSynchronizable<CSISMSCommandDriver>::make_shared_ptr<QMISMSCommandDriver>(QMISMSCommandDriver*)::{lambda(QMISMSCommandDriver *)#1},std::allocator<QMISMSCommandDriver>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t std::shared_ptr<QMISMSCommandDriver> ctu::SharedSynchronizable<CSISMSCommandDriver>::make_shared_ptr<QMISMSCommandDriver>(QMISMSCommandDriver*)::{lambda(QMISMSCommandDriver*)#1}::operator() const(QMISMSCommandDriver*)::{lambda(void *)#1}::__invoke(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 32))(result);
  return result;
}

void std::__function::__func<char const* const (*)(subscriber::SimSlot),std::allocator<char const* const (*)(subscriber::SimSlot)>,char const* const ()(subscriber::SimSlot)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<char const* const (*)(subscriber::SimSlot),std::allocator<char const* const (*)(subscriber::SimSlot)>,char const* const ()(subscriber::SimSlot)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &unk_24D5C4F88;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<char const* const (*)(subscriber::SimSlot),std::allocator<char const* const (*)(subscriber::SimSlot)>,char const* const ()(subscriber::SimSlot)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &unk_24D5C4F88;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<char const* const (*)(subscriber::SimSlot),std::allocator<char const* const (*)(subscriber::SimSlot)>,char const* const ()(subscriber::SimSlot)>::operator()(uint64_t a1, unsigned int *a2)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 8))(*a2);
}

uint64_t std::__function::__func<char const* const (*)(subscriber::SimSlot),std::allocator<char const* const (*)(subscriber::SimSlot)>,char const* const ()(subscriber::SimSlot)>::target(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else
    return 0;
}

void *std::__function::__func<char const* const (*)(subscriber::SimSlot),std::allocator<char const* const (*)(subscriber::SimSlot)>,char const* const ()(subscriber::SimSlot)>::target_type()
{
}

void SimInstanceLoggable<QMISMSCommandDriver,ctu::OsLogLogger,subscriber::SimSlot>::~SimInstanceLoggable()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t SimInstanceLoggable<QMISMSCommandDriver,ctu::OsLogLogger,subscriber::SimSlot>::getLoggerForSlot(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8) + 40;
}

uint64_t std::__function::__value_func<char const* const ()(subscriber::SimSlot)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;

  v3 = (_QWORD *)(a2 + 24);
  v4 = *(_QWORD *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(_QWORD *)(a1 + 24) = a1;
      (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(_QWORD *)(a1 + 24) = v4;
  }
  else
  {
    v3 = (_QWORD *)(a1 + 24);
  }
  *v3 = 0;
  return a1;
}

_QWORD *SimInstanceLoggerDefault<ctu::OsLogLogger,subscriber::SimSlot,std::function<char const* const ()(subscriber::SimSlot)>>::SimInstanceLoggerDefault(_QWORD *a1)
{
  *a1 = &unk_24D5C5088;
  detail::createOsLogLoggers();
  detail::createUnknownOsLogLogger();
  return a1;
}

void sub_2168E9048(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  std::__tree<std::__value_type<subscriber::SimSlot,ctu::OsLogLogger>,std::__map_value_compare<subscriber::SimSlot,std::__value_type<subscriber::SimSlot,ctu::OsLogLogger>,std::less<subscriber::SimSlot>,true>,std::allocator<std::__value_type<subscriber::SimSlot,ctu::OsLogLogger>>>::destroy(v2, *(_QWORD **)(v1 + 16));
  _Unwind_Resume(a1);
}

uint64_t SimInstanceLoggerDefault<ctu::OsLogLogger,subscriber::SimSlot,std::function<char const* const ()(subscriber::SimSlot)>>::~SimInstanceLoggerDefault(uint64_t a1)
{
  *(_QWORD *)a1 = &unk_24D5C5088;
  MEMORY[0x2199FDF6C](a1 + 32);
  std::__tree<std::__value_type<subscriber::SimSlot,ctu::OsLogLogger>,std::__map_value_compare<subscriber::SimSlot,std::__value_type<subscriber::SimSlot,ctu::OsLogLogger>,std::less<subscriber::SimSlot>,true>,std::allocator<std::__value_type<subscriber::SimSlot,ctu::OsLogLogger>>>::destroy(a1 + 8, *(_QWORD **)(a1 + 16));
  return a1;
}

void SimInstanceLoggerDefault<ctu::OsLogLogger,subscriber::SimSlot,std::function<char const* const ()(subscriber::SimSlot)>>::~SimInstanceLoggerDefault(uint64_t a1)
{
  *(_QWORD *)a1 = &unk_24D5C5088;
  MEMORY[0x2199FDF6C](a1 + 32);
  std::__tree<std::__value_type<subscriber::SimSlot,ctu::OsLogLogger>,std::__map_value_compare<subscriber::SimSlot,std::__value_type<subscriber::SimSlot,ctu::OsLogLogger>,std::less<subscriber::SimSlot>,true>,std::allocator<std::__value_type<subscriber::SimSlot,ctu::OsLogLogger>>>::destroy(a1 + 8, *(_QWORD **)(a1 + 16));
  JUMPOUT(0x2199FEAC4);
}

void std::__tree<std::__value_type<subscriber::SimSlot,ctu::OsLogLogger>,std::__map_value_compare<subscriber::SimSlot,std::__value_type<subscriber::SimSlot,ctu::OsLogLogger>,std::less<subscriber::SimSlot>,true>,std::allocator<std::__value_type<subscriber::SimSlot,ctu::OsLogLogger>>>::destroy(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<subscriber::SimSlot,ctu::OsLogLogger>,std::__map_value_compare<subscriber::SimSlot,std::__value_type<subscriber::SimSlot,ctu::OsLogLogger>,std::less<subscriber::SimSlot>,true>,std::allocator<std::__value_type<subscriber::SimSlot,ctu::OsLogLogger>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<subscriber::SimSlot,ctu::OsLogLogger>,std::__map_value_compare<subscriber::SimSlot,std::__value_type<subscriber::SimSlot,ctu::OsLogLogger>,std::less<subscriber::SimSlot>,true>,std::allocator<std::__value_type<subscriber::SimSlot,ctu::OsLogLogger>>>::destroy(a1, a2[1]);
    MEMORY[0x2199FDF6C](a2 + 5);
    operator delete(a2);
  }
}

uint64_t *std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](uint64_t *a1)
{
  uint64_t v2;

  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v2 + 8);
    MEMORY[0x2199FEAC4](v2, 0x60C40A44E5E0CLL);
  }
  return a1;
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0,dispatch_queue_s *::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>>)::{lambda(void *)#1}::__invoke(_QWORD ***a1)
{
  _QWORD **v1;
  _QWORD *v2;
  _DWORD *v3;
  char *v4;
  std::__shared_weak_count *v5;
  uint64_t v6;
  std::__shared_weak_count *v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_weak_owners;
  unint64_t v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  NSObject *v13;
  std::__shared_weak_count *v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  unint64_t *v22;
  unint64_t v23;
  _DWORD *v24;
  __int128 *v25;
  uint64_t v26;
  void **v27;
  uint64_t v28;
  void **v29;
  uint64_t v30;
  __int128 *v31;
  uint64_t v32;
  __int128 *v33;
  uint64_t v34;
  __int128 *v35;
  uint64_t v36;
  __int128 *v37;
  uint64_t v38;
  Registry **v40;
  _QWORD ***v41;
  _QWORD **v42;
  _DWORD *v43;
  _DWORD *v44;
  uint64_t (*v45)(_QWORD);
  __int128 v46;
  __int128 v47;
  uint64_t v48;
  std::__shared_weak_count *v49;
  dispatch_object_t object;
  void *__p[2];
  char v52;
  void **v53;
  void *v54;
  _QWORD *v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  uint64_t v59;

  v59 = *MEMORY[0x24BDAC8D0];
  v1 = *a1;
  v41 = a1;
  v42 = v1;
  v2 = *v1;
  v40 = (Registry **)(*v1 + 7);
  subscriber::makeSimSlotRange();
  v3 = v43;
  if (v43 != v44)
  {
    while ((v45(*v3) & 1) == 0)
    {
      if (++v3 == v44)
      {
        v3 = v44;
        break;
      }
    }
    while (v3 != v44)
    {
      if (*v3 == 1)
      {
        v4 = "QMISMSCommandDriver.1";
      }
      else if (*v3 == 2)
      {
        v4 = "QMISMSCommandDriver.2";
      }
      else
      {
        v4 = 0;
      }
      v5 = (std::__shared_weak_count *)v2[2];
      if (!v5 || (v6 = v2[1], (v7 = std::__shared_weak_count::lock(v5)) == 0))
        std::__throw_bad_weak_ptr[abi:ne180100]();
      v8 = v7;
      p_shared_weak_owners = (unint64_t *)&v7->__shared_weak_owners_;
      do
        v10 = __ldxr(p_shared_weak_owners);
      while (__stxr(v10 + 1, p_shared_weak_owners));
      p_shared_owners = (unint64_t *)&v7->__shared_owners_;
      do
        v12 = __ldaxr(p_shared_owners);
      while (__stlxr(v12 - 1, p_shared_owners));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v8);
      }
      Registry::getServerConnection(*v40);
      v57 = 0u;
      v58 = 0u;
      std::string::basic_string[abi:ne180100]<0>(&v54, v4);
      v13 = v2[3];
      object = v13;
      if (v13)
        dispatch_retain(v13);
      std::string::basic_string[abi:ne180100]<0>(__p, "sms");
      v48 = 0;
      v49 = 0;
      v14 = std::__shared_weak_count::lock(v8);
      if (v14)
      {
        v15 = v14;
        v16 = (unint64_t *)&v14->__shared_weak_owners_;
        do
          v17 = __ldxr(v16);
        while (__stxr(v17 + 1, v16));
        v48 = v6;
        v49 = v14;
        std::__shared_weak_count::__release_weak(v8);
        v18 = (unint64_t *)&v15->__shared_owners_;
        do
          v19 = __ldaxr(v18);
        while (__stlxr(v19 - 1, v18));
        if (v19)
          goto LABEL_30;
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        v8 = v15;
      }
      else
      {
        v48 = 0;
        v49 = 0;
      }
      std::__shared_weak_count::__release_weak(v8);
LABEL_30:
      v47 = v46;
      v46 = 0uLL;
      qmi::Client::createWithQueueLocal();
      if (*((_QWORD *)&v47 + 1))
      {
        v20 = (unint64_t *)(*((_QWORD *)&v47 + 1) + 8);
        do
          v21 = __ldaxr(v20);
        while (__stlxr(v21 - 1, v20));
        if (!v21)
        {
          (*(void (**)(_QWORD))(**((_QWORD **)&v47 + 1) + 16))(*((_QWORD *)&v47 + 1));
          std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v47 + 1));
        }
      }
      if (v49)
        std::__shared_weak_count::__release_weak(v49);
      if (v52 < 0)
        operator delete(__p[0]);
      if (object)
        dispatch_release(object);
      if (SBYTE7(v56) < 0)
        operator delete(v54);
      v54 = 0;
      v55 = 0;
      v56 = v58;
      v58 = 0uLL;
      qmi::ClientRouter::addClient();
      qmi::Client::~Client((qmi::Client *)&v54);
      qmi::ClientRouter::get();
      qmi::Client::~Client((qmi::Client *)&v57);
      if (*((_QWORD *)&v46 + 1))
      {
        v22 = (unint64_t *)(*((_QWORD *)&v46 + 1) + 8);
        do
          v23 = __ldaxr(v22);
        while (__stlxr(v23 - 1, v22));
        if (!v23)
        {
          (*(void (**)(_QWORD))(**((_QWORD **)&v46 + 1) + 16))(*((_QWORD *)&v46 + 1));
          std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v46 + 1));
        }
      }
      v24 = v3 + 1;
      v3 = v44;
      if (v24 != v44)
      {
        v3 = v24;
        while ((v45(*v3) & 1) == 0)
        {
          if (++v3 == v44)
          {
            v3 = v44;
            break;
          }
        }
      }
    }
  }
  *(_QWORD *)&v57 = &off_24D5C52D8;
  *((_QWORD *)&v57 + 1) = v2;
  *((_QWORD *)&v58 + 1) = &v57;
  qmi::ClientRouter::setHandler();
  v25 = (__int128 *)*((_QWORD *)&v58 + 1);
  if (*((__int128 **)&v58 + 1) == &v57)
  {
    v26 = 4;
    v25 = &v57;
  }
  else
  {
    if (!*((_QWORD *)&v58 + 1))
      goto LABEL_59;
    v26 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v25 + 8 * v26))();
LABEL_59:
  v54 = &off_24D5C5368;
  v55 = v2;
  *((_QWORD *)&v56 + 1) = &v54;
  qmi::ClientRouter::setHandler();
  v27 = (void **)*((_QWORD *)&v56 + 1);
  if (*((void ***)&v56 + 1) == &v54)
  {
    v28 = 4;
    v27 = &v54;
  }
  else
  {
    if (!*((_QWORD *)&v56 + 1))
      goto LABEL_64;
    v28 = 5;
  }
  (*((void (**)(void))*v27 + v28))();
LABEL_64:
  __p[0] = &off_24D5C53E8;
  __p[1] = v2;
  v53 = __p;
  qmi::ClientRouter::setHandler();
  v29 = v53;
  if (v53 == __p)
  {
    v30 = 4;
    v29 = __p;
  }
  else
  {
    if (!v53)
      goto LABEL_69;
    v30 = 5;
  }
  (*((void (**)(void))*v29 + v30))();
LABEL_69:
  *(_QWORD *)&v57 = &off_24D5C50C8;
  *((_QWORD *)&v57 + 1) = v2;
  *((_QWORD *)&v58 + 1) = &v57;
  qmi::ClientRouter::setIndHandlerInternal();
  v31 = (__int128 *)*((_QWORD *)&v58 + 1);
  if (*((__int128 **)&v58 + 1) == &v57)
  {
    v32 = 4;
    v31 = &v57;
  }
  else
  {
    if (!*((_QWORD *)&v58 + 1))
      goto LABEL_74;
    v32 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v31 + 8 * v32))();
LABEL_74:
  qmi::ClientRouter::setIndShouldWake((qmi::ClientRouter *)(v2 + 12));
  *(_QWORD *)&v57 = &off_24D5C5158;
  *((_QWORD *)&v57 + 1) = v2;
  *((_QWORD *)&v58 + 1) = &v57;
  qmi::ClientRouter::setIndHandlerInternal();
  v33 = (__int128 *)*((_QWORD *)&v58 + 1);
  if (*((__int128 **)&v58 + 1) == &v57)
  {
    v34 = 4;
    v33 = &v57;
  }
  else
  {
    if (!*((_QWORD *)&v58 + 1))
      goto LABEL_79;
    v34 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v33 + 8 * v34))();
LABEL_79:
  qmi::ClientRouter::setIndShouldWake((qmi::ClientRouter *)(v2 + 12));
  *(_QWORD *)&v57 = &off_24D5C51D8;
  *((_QWORD *)&v57 + 1) = v2;
  *((_QWORD *)&v58 + 1) = &v57;
  qmi::ClientRouter::setIndHandlerInternal();
  v35 = (__int128 *)*((_QWORD *)&v58 + 1);
  if (*((__int128 **)&v58 + 1) == &v57)
  {
    v36 = 4;
    v35 = &v57;
  }
  else
  {
    if (!*((_QWORD *)&v58 + 1))
      goto LABEL_84;
    v36 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v35 + 8 * v36))();
LABEL_84:
  *(_QWORD *)&v57 = &off_24D5C5258;
  *((_QWORD *)&v57 + 1) = v2;
  *((_QWORD *)&v58 + 1) = &v57;
  qmi::ClientRouter::setIndHandlerInternal();
  v37 = (__int128 *)*((_QWORD *)&v58 + 1);
  if (*((__int128 **)&v58 + 1) == &v57)
  {
    v38 = 4;
    v37 = &v57;
    goto LABEL_88;
  }
  if (*((_QWORD *)&v58 + 1))
  {
    v38 = 5;
LABEL_88:
    (*(void (**)(void))(*(_QWORD *)v37 + 8 * v38))();
  }
  qmi::ClientRouter::setIndShouldWake((qmi::ClientRouter *)(v2 + 12));
  std::unique_ptr<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0,std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>>::~unique_ptr[abi:ne180100]((uint64_t *)&v42);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v41);
}

void sub_2168E9768(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,std::__shared_weak_count *a23,dispatch_object_t object,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,void *__p,uint64_t a33,int a34,__int16 a35,char a36,char a37,uint64_t a38)
{
  _QWORD *v38;
  uint64_t v39;
  _QWORD *v41;
  uint64_t v42;

  v41 = *(_QWORD **)(v39 - 120);
  if (v41 == v38)
  {
    v42 = 4;
    v41 = (_QWORD *)(v39 - 144);
  }
  else
  {
    if (!v41)
      goto LABEL_6;
    v42 = 5;
  }
  (*(void (**)(void))(*v41 + 8 * v42))();
LABEL_6:
  std::unique_ptr<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0,std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>>::~unique_ptr[abi:ne180100](&a13);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&a12);
  _Unwind_Resume(a1);
}

uint64_t *std::unique_ptr<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0,std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>>::~unique_ptr[abi:ne180100](uint64_t *a1)
{
  uint64_t v2;
  NSObject *v3;
  NSObject *v4;

  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    v3 = *(NSObject **)(v2 + 8);
    if (v3)
    {
      dispatch_group_leave(v3);
      v4 = *(NSObject **)(v2 + 8);
      if (v4)
        dispatch_release(v4);
    }
    MEMORY[0x2199FEAC4](v2, 0x20C40A4A59CD2);
  }
  return a1;
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMISMSCommandDriver::registerIndications_sync(void)::$_0>(unsigned short,QMISMSCommandDriver::registerIndications_sync(void)::$_0 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMISMSCommandDriver::registerIndications_sync(void)::$_0 &&,QMIServiceMsg const)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMISMSCommandDriver::registerIndications_sync(void)::$_0>(unsigned short,QMISMSCommandDriver::registerIndications_sync(void)::$_0 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMISMSCommandDriver::registerIndications_sync(void)::$_0 &&,QMIServiceMsg const)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5C50C8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMISMSCommandDriver::registerIndications_sync(void)::$_0>(unsigned short,QMISMSCommandDriver::registerIndications_sync(void)::$_0 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMISMSCommandDriver::registerIndications_sync(void)::$_0 &&,QMIServiceMsg const)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5C50C8;
  a2[1] = v2;
  return result;
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMISMSCommandDriver::registerIndications_sync(void)::$_0>(unsigned short,QMISMSCommandDriver::registerIndications_sync(void)::$_0 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMISMSCommandDriver::registerIndications_sync(void)::$_0 &&,QMIServiceMsg const)>::operator()(uint64_t a1, unsigned int *a2, QMIServiceMsg *this)
{
  unsigned int v4;
  uint64_t v6;
  uint64_t v7;
  os_log_t *v8;
  os_log_t *v9;
  int v10;
  os_log_t v11;
  void *v12;
  const char *v13;
  NSObject *v14;
  uint32_t v15;
  NSObject *v16;
  uint64_t TlvValue;
  int v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  NSObject *v23;
  const char *v24;
  void *v25;
  int v26;
  void *v27;
  int v28;
  BOOL v29;
  BOOL v30;
  NSObject *v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  _BYTE *v37;
  _BYTE *v38;
  uint64_t v39;
  int v40;
  uint64_t v41;
  int v42;
  unint64_t v43;
  std::__shared_weak_count *v44;
  std::__shared_weak_count *v45;
  uint64_t v46;
  NSObject *v47;
  const char *v48;
  uint64_t v49;
  NSObject *v50;
  BOOL v51;
  os_log_t *v52;
  NSObject *v53;
  const char *v54;
  std::__shared_weak_count *v55;
  uint64_t v56;
  NSObject *v57;
  NSObject *v58;
  NSObject *v59;
  void *v60;
  unint64_t *v61;
  unint64_t v62;
  _QWORD *v63;
  void *v64;
  void *v65;
  uint64_t v66;
  size_t v67;
  _QWORD *v68;
  uint64_t v69;
  unint64_t *v70;
  uint64_t v71;
  int v72;
  uint64_t v73;
  int v74;
  uint64_t v75;
  NSObject *v76;
  unsigned int v77;
  uint64_t v78;
  std::__shared_weak_count *v79;
  std::__shared_weak_count *v80;
  uint64_t v81;
  NSObject *v82;
  const char *v83;
  NSObject *v84;
  uint64_t v85;
  NSObject *v86;
  unint64_t *p_shared_owners;
  unint64_t v88;
  uint64_t v89;
  int v90;
  uint64_t v91;
  int v92;
  int v93;
  int v94;
  NSObject *v95;
  const char *v96;
  BOOL v97;
  BOOL v98;
  _WORD v99[2];
  int v100;
  void *v101;
  void *v102;
  uint64_t v103;
  __int128 v104;
  void *v105[2];
  uint64_t v106;
  unint64_t v107;
  uint64_t v108;
  std::__shared_weak_count *v109;
  void *__p[4];
  void *v111;
  _BYTE *v112;
  uint64_t v113;
  __int16 v114;
  _BYTE v115[24];
  _BYTE *v116;
  uint8_t buf[16];
  __int128 v118;
  __int128 v119;
  uint64_t v120;

  v120 = *MEMORY[0x24BDAC8D0];
  v4 = *a2;
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    memset(__p, 0, 24);
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v99, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v99);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v99);
  }
  v6 = *(_QWORD *)(a1 + 8);
  if (v4 - 1 >= 3)
    v7 = 0;
  else
    v7 = v4;
  if ((subscriber::isValidSimSlot() & 1) != 0)
  {
    v8 = (os_log_t *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v6 + 88) + 16))(*(_QWORD *)(v6 + 88), v7);
    v9 = v8;
    v10 = v100;
    if (v100)
    {
      v11 = *v8;
      if (os_log_type_enabled(*v8, OS_LOG_TYPE_ERROR))
      {
        v12 = (void *)qmi::asString();
        LODWORD(__p[0]) = 67109378;
        HIDWORD(__p[0]) = v10;
        LOWORD(__p[1]) = 2080;
        *(void **)((char *)&__p[1] + 2) = v12;
        v13 = "EventReportInd - (error 0x%x (%s))";
        v14 = v11;
        v15 = 18;
LABEL_67:
        _os_log_error_impl(&dword_216897000, v14, OS_LOG_TYPE_ERROR, v13, (uint8_t *)__p, v15);
        goto LABEL_16;
      }
      goto LABEL_16;
    }
    TlvValue = qmi::MessageBase::findTlvValue((qmi::MessageBase *)v99);
    v19 = TlvValue;
    if (TlvValue)
    {
      v20 = v18;
      *(_QWORD *)buf = TlvValue;
      v21 = tlv::parseV<wms::tlv::MemoryStorageIdentification>((unint64_t *)buf, v18);
      if (*(_QWORD *)buf)
      {
        v22 = v21;
        v23 = *v9;
        if (os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT))
        {
          v24 = qmi::wms::asString(v22);
          LODWORD(__p[0]) = 136315394;
          *(void **)((char *)__p + 4) = (void *)v24;
          WORD2(__p[1]) = 1024;
          *(_DWORD *)((char *)&__p[1] + 6) = HIDWORD(v22);
          _os_log_impl(&dword_216897000, v23, OS_LOG_TYPE_DEFAULT, "#I EventReportInd - Storage Indication, stored on %s at address %d", (uint8_t *)__p, 0x12u);
        }
      }
      else
      {
        ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(v99[0], 16, v19, v20);
      }
    }
    v25 = (void *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)v99);
    v27 = v25;
    if (v25)
    {
      v28 = v26;
      __p[0] = v25;
      v29 = tlv::parseV<wms::tlv::MTSMSOnIMS>((unint64_t *)__p, v26);
      if (__p[0])
      {
        v30 = v29;
        if (v29)
        {
          v31 = *v9;
          if (os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl(&dword_216897000, v31, OS_LOG_TYPE_DEFAULT, "#I Received Message is on IMS", buf, 2u);
          }
        }
LABEL_29:
        v101 = 0;
        v102 = 0;
        v103 = 0;
        v32 = qmi::MessageBase::findTlvValue((qmi::MessageBase *)v99);
        v34 = v32;
        if (!v32)
          goto LABEL_39;
        v35 = v33;
        *(_QWORD *)&v104 = v32;
        memset(__p, 0, 24);
        tlv::parseV<wms::tlv::WarningArea>((unint64_t *)&v104, v33, __p);
        v36 = v104;
        if ((_QWORD)v104)
        {
          v38 = __p[0];
          v37 = __p[1];
          if (__p[1] == __p[0])
          {
LABEL_35:
            if (v37)
            {
              __p[1] = v37;
              operator delete(v37);
            }
            if (!v36)
              ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(v99[0], 26, v34, v35);
LABEL_39:
            v39 = qmi::MessageBase::findTlvValue((qmi::MessageBase *)v99);
            v41 = v39;
            if (!v39)
              goto LABEL_101;
            v42 = v40;
            v106 = 0;
            v107 = v39;
            v104 = 0u;
            *(_OWORD *)v105 = 0u;
            tlv::parseV<wms::tlv::TransferRouteMTMessage>(&v107, v40, (uint64_t)&v104);
            v43 = v107;
            if (!v107)
            {
LABEL_97:
              if (v105[0])
              {
                v105[1] = v105[0];
                operator delete(v105[0]);
              }
              if (!v43)
                ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(v99[0], 17, v41, v42);
LABEL_101:
              v71 = qmi::MessageBase::findTlvValue((qmi::MessageBase *)v99);
              v73 = v71;
              if (!v71)
              {
LABEL_133:
                v89 = qmi::MessageBase::findTlvValue((qmi::MessageBase *)v99);
                v91 = v89;
                if (v89)
                {
                  v92 = v90;
                  *(_QWORD *)buf = v89;
                  v93 = tlv::parseV<wms::tlv::Message_Mode>((unint64_t *)buf, v90);
                  if (*(_QWORD *)buf)
                  {
                    v94 = v93;
                    v95 = *v9;
                    if (os_log_type_enabled(v95, OS_LOG_TYPE_DEFAULT))
                    {
                      v96 = qmi::wms::asString(v94);
                      LODWORD(__p[0]) = 136315138;
                      *(void **)((char *)__p + 4) = (void *)v96;
                      _os_log_impl(&dword_216897000, v95, OS_LOG_TYPE_DEFAULT, "#I Message Mode indication with mode %s", (uint8_t *)__p, 0xCu);
                    }
                  }
                  else
                  {
                    ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(v99[0], 18, v91, v92);
                  }
                }
                if (v101)
                {
                  v102 = v101;
                  operator delete(v101);
                }
                goto LABEL_16;
              }
              v74 = v72;
              *(_QWORD *)&v104 = v71;
              memset(__p, 0, sizeof(__p));
              tlv::parseV<wms::tlv::ETWSMessage>((unint64_t *)&v104, v72, __p);
              v75 = v104;
              if ((_QWORD)v104)
              {
                v76 = *v9;
                if (os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT))
                {
                  *(_WORD *)buf = 0;
                  _os_log_impl(&dword_216897000, v76, OS_LOG_TYPE_DEFAULT, "#I Wea Alert received", buf, 2u);
                }
                if (LOBYTE(__p[0]) - 1 <= 1)
                {
                  if (LOBYTE(__p[0]) == 2)
                    v77 = 5;
                  else
                    v77 = 0;
                  if (LOBYTE(__p[0]) == 1)
                    v78 = 4;
                  else
                    v78 = v77;
                  v79 = *(std::__shared_weak_count **)(v6 + 80);
                  if (v79)
                  {
                    v80 = std::__shared_weak_count::lock(v79);
                    if (v80)
                    {
                      v81 = *(_QWORD *)(v6 + 72);
                      if (v81)
                      {
                        v82 = *v9;
                        if (os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT))
                        {
                          if (v102 == v101)
                            v83 = "normal";
                          else
                            v83 = "geofenced";
                          *(_DWORD *)buf = 136315138;
                          *(_QWORD *)&buf[4] = v83;
                          _os_log_impl(&dword_216897000, v82, OS_LOG_TYPE_DEFAULT, "#I Handling as %s alert", buf, 0xCu);
                        }
                        (*(void (**)(uint64_t, uint64_t, void **, void **, uint64_t))(*(_QWORD *)v81 + 384))(v81, v7, &__p[1], &v101, v78);
                        v84 = *v9;
                        if (os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT))
                        {
                          v85 = sms::asString();
                          *(_DWORD *)buf = 136315138;
                          *(_QWORD *)&buf[4] = v85;
                          _os_log_impl(&dword_216897000, v84, OS_LOG_TYPE_DEFAULT, "#I WEA processing status: %s", buf, 0xCu);
                        }
                        goto LABEL_125;
                      }
                    }
                  }
                  else
                  {
                    v80 = 0;
                  }
                  v86 = *v9;
                  if (os_log_type_enabled(*v9, OS_LOG_TYPE_ERROR))
                  {
                    *(_WORD *)buf = 0;
                    _os_log_error_impl(&dword_216897000, v86, OS_LOG_TYPE_ERROR, "Failed to get Sms controller...", buf, 2u);
                    if (v80)
                      goto LABEL_125;
                  }
                  else if (v80)
                  {
LABEL_125:
                    p_shared_owners = (unint64_t *)&v80->__shared_owners_;
                    do
                      v88 = __ldaxr(p_shared_owners);
                    while (__stlxr(v88 - 1, p_shared_owners));
                    if (!v88)
                    {
                      ((void (*)(std::__shared_weak_count *))v80->__on_zero_shared)(v80);
                      std::__shared_weak_count::__release_weak(v80);
                    }
                  }
                }
              }
              if (__p[1])
              {
                __p[2] = __p[1];
                operator delete(__p[1]);
              }
              if (!v75)
                ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(v99[0], 19, v73, v74);
              goto LABEL_133;
            }
            if (BYTE8(v104) == 7)
            {
              v44 = *(std::__shared_weak_count **)(v6 + 80);
              if (v44)
              {
                v45 = std::__shared_weak_count::lock(v44);
                if (v45)
                {
                  v46 = *(_QWORD *)(v6 + 72);
                  if (v46)
                  {
                    v47 = *v9;
                    if (os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT))
                    {
                      if (v102 == v101)
                        v48 = "normal";
                      else
                        v48 = "geofenced";
                      LODWORD(__p[0]) = 136315138;
                      *(void **)((char *)__p + 4) = (void *)v48;
                      _os_log_impl(&dword_216897000, v47, OS_LOG_TYPE_DEFAULT, "#I Handling as %s alert", (uint8_t *)__p, 0xCu);
                    }
                    if (BYTE8(v104) == 7)
                    {
                      v49 = 3;
                    }
                    else if (BYTE8(v104) == 6)
                    {
                      v49 = 1;
                    }
                    else if (BYTE8(v104))
                    {
                      v49 = 0;
                    }
                    else
                    {
                      v49 = 2;
                    }
                    (*(void (**)(uint64_t, uint64_t, void **, void **, uint64_t))(*(_QWORD *)v46 + 384))(v46, v7, v105, &v101, v49);
                    v59 = *v9;
                    if (os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT))
                    {
                      v60 = (void *)sms::asString();
                      LODWORD(__p[0]) = 136315138;
                      *(void **)((char *)__p + 4) = v60;
                      _os_log_impl(&dword_216897000, v59, OS_LOG_TYPE_DEFAULT, "#I WEA processing status: %s", (uint8_t *)__p, 0xCu);
                    }
                    goto LABEL_82;
                  }
                }
              }
              else
              {
                v45 = 0;
              }
              v57 = *v9;
              if (os_log_type_enabled(*v9, OS_LOG_TYPE_ERROR))
              {
                LOWORD(__p[0]) = 0;
                _os_log_error_impl(&dword_216897000, v57, OS_LOG_TYPE_ERROR, "Failed to get Sms controller...", (uint8_t *)__p, 2u);
                if (!v45)
                  goto LABEL_97;
              }
              else if (!v45)
              {
                goto LABEL_97;
              }
LABEL_82:
              v61 = (unint64_t *)&v45->__shared_owners_;
              do
                v62 = __ldaxr(v61);
              while (__stlxr(v62 - 1, v61));
              goto LABEL_95;
            }
            v50 = *v9;
            if (os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(__p[0]) = 0;
              _os_log_impl(&dword_216897000, v50, OS_LOG_TYPE_DEFAULT, "#I MT Message indication", (uint8_t *)__p, 2u);
            }
            v51 = v30;
            v52 = (os_log_t *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v6 + 88) + 16))(*(_QWORD *)(v6 + 88), v7);
            v53 = *v52;
            if (os_log_type_enabled(*v52, OS_LOG_TYPE_DEFAULT))
            {
              LODWORD(__p[0]) = 67109120;
              HIDWORD(__p[0]) = v104;
              _os_log_impl(&dword_216897000, v53, OS_LOG_TYPE_DEFAULT, "#I   Ack Ind : %d", (uint8_t *)__p, 8u);
              v53 = *v52;
            }
            if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
            {
              LODWORD(__p[0]) = 67109120;
              HIDWORD(__p[0]) = DWORD1(v104);
              _os_log_impl(&dword_216897000, v53, OS_LOG_TYPE_DEFAULT, "#I   TxID    : %d", (uint8_t *)__p, 8u);
              v53 = *v52;
            }
            if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
            {
              v54 = qmi::wms::asString(BYTE8(v104));
              LODWORD(__p[0]) = 136315138;
              *(void **)((char *)__p + 4) = (void *)v54;
              _os_log_impl(&dword_216897000, v53, OS_LOG_TYPE_DEFAULT, "#I   Format  : %s", (uint8_t *)__p, 0xCu);
            }
            v108 = 0;
            v109 = 0;
            v55 = *(std::__shared_weak_count **)(v6 + 80);
            if (v55)
            {
              v98 = (_DWORD)v104 == 0;
              v45 = std::__shared_weak_count::lock(v55);
              v109 = v45;
              if (v45)
              {
                v97 = v51;
                v56 = *(_QWORD *)(v6 + 72);
                v108 = v56;
                if (v56)
                {
                  v118 = 0u;
                  v119 = 0u;
                  *(_OWORD *)buf = 0u;
                  sms::MTSmsDetails::MTSmsDetails();
                  __p[0] = (void *)v6;
                  LODWORD(__p[1]) = v7;
                  __p[2] = (void *)v104;
                  LOBYTE(__p[3]) = BYTE8(v104);
                  v112 = 0;
                  v113 = 0;
                  v111 = 0;
                  std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(&v111, v105[0], (uint64_t)v105[1], (char *)v105[1] - (char *)v105[0]);
                  LOBYTE(v114) = v97;
                  HIBYTE(v114) = v98;
                  v116 = 0;
                  v63 = operator new(0x48uLL);
                  v64 = __p[0];
                  *v63 = &off_24D5C63C0;
                  v63[1] = v64;
                  *((_DWORD *)v63 + 4) = __p[1];
                  v63[3] = __p[2];
                  *((_BYTE *)v63 + 32) = __p[3];
                  v63[6] = 0;
                  v63[7] = 0;
                  v65 = v111;
                  v66 = (uint64_t)v112;
                  v67 = v112 - (_BYTE *)v111;
                  v63[5] = 0;
                  std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(v63 + 5, v65, v66, v67);
                  *((_WORD *)v63 + 32) = v114;
                  v116 = v63;
                  (*(void (**)(uint64_t, uint8_t *, _BYTE *))(*(_QWORD *)v56 + 32))(v56, buf, v115);
                  v68 = v116;
                  if (v116 == v115)
                  {
                    v69 = 4;
                    v68 = v115;
                  }
                  else
                  {
                    if (!v116)
                    {
LABEL_90:
                      if (v111)
                      {
                        v112 = v111;
                        operator delete(v111);
                      }
                      sms::MTSmsDetails::~MTSmsDetails((sms::MTSmsDetails *)buf);
LABEL_93:
                      v70 = (unint64_t *)&v45->__shared_owners_;
                      do
                        v62 = __ldaxr(v70);
                      while (__stlxr(v62 - 1, v70));
LABEL_95:
                      if (!v62)
                      {
                        ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
                        std::__shared_weak_count::__release_weak(v45);
                      }
                      goto LABEL_97;
                    }
                    v69 = 5;
                  }
                  (*(void (**)(void))(*v68 + 8 * v69))();
                  goto LABEL_90;
                }
              }
            }
            else
            {
              v45 = 0;
            }
            v58 = *v52;
            if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
            {
              LOWORD(__p[0]) = 0;
              _os_log_error_impl(&dword_216897000, v58, OS_LOG_TYPE_ERROR, "Failed to get Sms controller...", (uint8_t *)__p, 2u);
            }
            if (!v45)
              goto LABEL_97;
            goto LABEL_93;
          }
          *(_QWORD *)buf = &v101;
          do
            std::back_insert_iterator<std::vector<unsigned char>>::operator=[abi:ne180100]((unint64_t **)buf, v38++);
          while (v38 != v37);
        }
        v37 = __p[0];
        goto LABEL_35;
      }
      ((void (*)(_QWORD, uint64_t, void *, _QWORD))*MEMORY[0x24BED8BD0])(v99[0], 22, v27, v28);
    }
    v30 = 0;
    goto LABEL_29;
  }
  v16 = *(NSObject **)(v6 + 40);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
  {
    LOWORD(__p[0]) = 0;
    v13 = "Invalid slot while handling EventReportInt";
    v14 = v16;
    v15 = 2;
    goto LABEL_67;
  }
LABEL_16:
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v99);
}

void sub_2168EA5D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,void *a25,void *__p,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36)
{
  std::__shared_weak_count *v36;
  unint64_t *p_shared_owners;
  unint64_t v39;

  p_shared_owners = (unint64_t *)&v36->__shared_owners_;
  do
    v39 = __ldaxr(p_shared_owners);
  while (__stlxr(v39 - 1, p_shared_owners));
  if (!v39)
  {
    ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
    std::__shared_weak_count::__release_weak(v36);
  }
  if (__p)
  {
    a27 = (uint64_t)__p;
    operator delete(__p);
  }
  if (a14)
  {
    a15 = (uint64_t)a14;
    operator delete(a14);
  }
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a11);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMISMSCommandDriver::registerIndications_sync(void)::$_0>(unsigned short,QMISMSCommandDriver::registerIndications_sync(void)::$_0 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMISMSCommandDriver::registerIndications_sync(void)::$_0 &&,QMIServiceMsg const)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMISMSCommandDriver::registerIndications_sync(void)::$_0>(unsigned short,QMISMSCommandDriver::registerIndications_sync(void)::$_0 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMISMSCommandDriver::registerIndications_sync(void)::$_0 &&,QMIServiceMsg const)>::target_type()
{
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMISMSCommandDriver::registerIndications_sync(void)::$_1>(unsigned short,QMISMSCommandDriver::registerIndications_sync(void)::$_1 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMISMSCommandDriver::registerIndications_sync(void)::$_1 &&,QMIServiceMsg const)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMISMSCommandDriver::registerIndications_sync(void)::$_1>(unsigned short,QMISMSCommandDriver::registerIndications_sync(void)::$_1 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMISMSCommandDriver::registerIndications_sync(void)::$_1 &&,QMIServiceMsg const)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5C5158;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMISMSCommandDriver::registerIndications_sync(void)::$_1>(unsigned short,QMISMSCommandDriver::registerIndications_sync(void)::$_1 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMISMSCommandDriver::registerIndications_sync(void)::$_1 &&,QMIServiceMsg const)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5C5158;
  a2[1] = v2;
  return result;
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMISMSCommandDriver::registerIndications_sync(void)::$_1>(unsigned short,QMISMSCommandDriver::registerIndications_sync(void)::$_1 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMISMSCommandDriver::registerIndications_sync(void)::$_1 &&,QMIServiceMsg const)>::operator()(uint64_t a1, _DWORD *a2, QMIServiceMsg *this)
{
  uint64_t v4;
  uint64_t v6;
  os_log_t *v7;
  NSObject **v8;
  int v9;
  os_log_t v10;
  uint64_t v11;
  const char *v12;
  NSObject *v13;
  uint32_t v14;
  NSObject *v15;
  unsigned __int8 *TlvValue;
  int v17;
  unsigned __int8 *v18;
  int v19;
  unsigned __int8 *v20;
  _WORD v21[2];
  int v22;
  unsigned __int8 *v23;
  void *__p;
  __int128 v25;
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  LODWORD(v4) = *a2;
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v25 = 0uLL;
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v21, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v21);
    if (__p)
    {
      *(_QWORD *)&v25 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v21);
  }
  v6 = *(_QWORD *)(a1 + 8);
  if ((v4 - 1) >= 3)
    v4 = 0;
  else
    v4 = v4;
  if ((subscriber::isValidSimSlot() & 1) == 0)
  {
    v15 = *(NSObject **)(v6 + 40);
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      goto LABEL_16;
    LOWORD(__p) = 0;
    v12 = "Invalid slot while handling MsgWaitingIndication";
    goto LABEL_27;
  }
  v7 = (os_log_t *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v6 + 88) + 16))(*(_QWORD *)(v6 + 88), v4);
  v8 = v7;
  v9 = v22;
  if (!v22)
  {
    TlvValue = (unsigned __int8 *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)v21);
    v18 = TlvValue;
    if (TlvValue)
    {
      v19 = v17;
      v23 = TlvValue;
      __p = 0;
      v25 = 0uLL;
      tlv::parseV<wms::tlv::MsgWaitingInfo>(&v23, v17, (uint64_t *)&__p);
      v20 = v23;
      if (v23)
        QMISMSCommandDriver::handleMsgWaitingInfo(v6, v4, (uint64_t *)&__p);
      if (__p)
      {
        *(_QWORD *)&v25 = __p;
        operator delete(__p);
      }
      if (v20
        || (((uint64_t (*)(_QWORD, uint64_t, unsigned __int8 *, _QWORD))*MEMORY[0x24BED8BD0])(v21[0], 1, v18, v19) & 1) != 0)
      {
        goto LABEL_16;
      }
    }
    v15 = *v8;
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      goto LABEL_16;
    LOWORD(__p) = 0;
    v12 = "Failed to apply mandatory MsgWaitingInfo tlv to indication";
LABEL_27:
    v13 = v15;
    v14 = 2;
    goto LABEL_28;
  }
  v10 = *v7;
  if (os_log_type_enabled(*v7, OS_LOG_TYPE_ERROR))
  {
    v11 = qmi::asString();
    LODWORD(__p) = 67109378;
    HIDWORD(__p) = v9;
    LOWORD(v25) = 2080;
    *(_QWORD *)((char *)&v25 + 2) = v11;
    v12 = "Error received invalid message waiting indication 0x%x, %s";
    v13 = v10;
    v14 = 18;
LABEL_28:
    _os_log_error_impl(&dword_216897000, v13, OS_LOG_TYPE_ERROR, v12, (uint8_t *)&__p, v14);
  }
LABEL_16:
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v21);
}

void sub_2168EAA8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14)
{
  if (__p)
  {
    a14 = (uint64_t)__p;
    operator delete(__p);
  }
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMISMSCommandDriver::registerIndications_sync(void)::$_1>(unsigned short,QMISMSCommandDriver::registerIndications_sync(void)::$_1 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMISMSCommandDriver::registerIndications_sync(void)::$_1 &&,QMIServiceMsg const)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMISMSCommandDriver::registerIndications_sync(void)::$_1>(unsigned short,QMISMSCommandDriver::registerIndications_sync(void)::$_1 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMISMSCommandDriver::registerIndications_sync(void)::$_1 &&,QMIServiceMsg const)>::target_type()
{
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMISMSCommandDriver::registerIndications_sync(void)::$_2>(unsigned short,QMISMSCommandDriver::registerIndications_sync(void)::$_2 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMISMSCommandDriver::registerIndications_sync(void)::$_2 &&,QMIServiceMsg const)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMISMSCommandDriver::registerIndications_sync(void)::$_2>(unsigned short,QMISMSCommandDriver::registerIndications_sync(void)::$_2 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMISMSCommandDriver::registerIndications_sync(void)::$_2 &&,QMIServiceMsg const)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5C51D8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMISMSCommandDriver::registerIndications_sync(void)::$_2>(unsigned short,QMISMSCommandDriver::registerIndications_sync(void)::$_2 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMISMSCommandDriver::registerIndications_sync(void)::$_2 &&,QMIServiceMsg const)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5C51D8;
  a2[1] = v2;
  return result;
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMISMSCommandDriver::registerIndications_sync(void)::$_2>(unsigned short,QMISMSCommandDriver::registerIndications_sync(void)::$_2 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMISMSCommandDriver::registerIndications_sync(void)::$_2 &&,QMIServiceMsg const)>::operator()(uint64_t a1, unsigned int *a2, QMIServiceMsg *this)
{
  unsigned int v4;
  _QWORD *v6;
  void *TlvValue;
  int v8;
  void *v9;
  int v10;
  int v11;
  int v12;
  std::__shared_weak_count *v13;
  std::__shared_weak_count *v14;
  uint64_t v15;
  uint64_t v16;
  NSObject *v17;
  unint64_t *p_shared_owners;
  unint64_t v19;
  _WORD v20[12];
  uint8_t buf[8];
  void *__p;
  void *v23;
  uint64_t v24;

  v4 = *a2;
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v23 = 0;
    v24 = 0;
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v20, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v20);
    if (__p)
    {
      v23 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v20);
  }
  v6 = *(_QWORD **)(a1 + 8);
  TlvValue = (void *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)v20);
  v9 = TlvValue;
  if (TlvValue)
  {
    v10 = v8;
    __p = TlvValue;
    v11 = tlv::parseV<wms::tlv::TransportLayerRegistrationInfo>((unint64_t *)&__p, v8);
    if (!__p)
    {
      ((void (*)(_QWORD, uint64_t, void *, _QWORD))*MEMORY[0x24BED8BD0])(v20[0], 1, v9, v10);
      goto LABEL_25;
    }
    v12 = v11;
    v13 = (std::__shared_weak_count *)v6[10];
    if (v13)
    {
      v14 = std::__shared_weak_count::lock(v13);
      if (v14)
      {
        v15 = v6[9];
        if (v15)
        {
          if (v4 - 1 >= 3)
            v16 = 0;
          else
            v16 = v4;
          (*(void (**)(uint64_t, uint64_t, BOOL, _QWORD, _QWORD))(*(_QWORD *)v15 + 72))(v15, v16, v12 != 0, 0, 0);
LABEL_21:
          p_shared_owners = (unint64_t *)&v14->__shared_owners_;
          do
            v19 = __ldaxr(p_shared_owners);
          while (__stlxr(v19 - 1, p_shared_owners));
          if (!v19)
          {
            ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
            std::__shared_weak_count::__release_weak(v14);
          }
          goto LABEL_25;
        }
      }
    }
    else
    {
      v14 = 0;
    }
    v17 = v6[5];
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_216897000, v17, OS_LOG_TYPE_ERROR, "Failed to get SMS controller", buf, 2u);
      if (!v14)
        goto LABEL_25;
    }
    else if (!v14)
    {
      goto LABEL_25;
    }
    goto LABEL_21;
  }
LABEL_25:
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v20);
}

void sub_2168EAD78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15)
{
  std::__shared_weak_count *v15;
  unint64_t *p_shared_owners;
  unint64_t v18;

  p_shared_owners = (unint64_t *)&v15->__shared_owners_;
  do
    v18 = __ldaxr(p_shared_owners);
  while (__stlxr(v18 - 1, p_shared_owners));
  if (!v18)
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a10);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMISMSCommandDriver::registerIndications_sync(void)::$_2>(unsigned short,QMISMSCommandDriver::registerIndications_sync(void)::$_2 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMISMSCommandDriver::registerIndications_sync(void)::$_2 &&,QMIServiceMsg const)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMISMSCommandDriver::registerIndications_sync(void)::$_2>(unsigned short,QMISMSCommandDriver::registerIndications_sync(void)::$_2 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMISMSCommandDriver::registerIndications_sync(void)::$_2 &&,QMIServiceMsg const)>::target_type()
{
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMISMSCommandDriver::registerIndications_sync(void)::$_3>(unsigned short,QMISMSCommandDriver::registerIndications_sync(void)::$_3 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMISMSCommandDriver::registerIndications_sync(void)::$_3 &&,QMIServiceMsg const)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMISMSCommandDriver::registerIndications_sync(void)::$_3>(unsigned short,QMISMSCommandDriver::registerIndications_sync(void)::$_3 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMISMSCommandDriver::registerIndications_sync(void)::$_3 &&,QMIServiceMsg const)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5C5258;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMISMSCommandDriver::registerIndications_sync(void)::$_3>(unsigned short,QMISMSCommandDriver::registerIndications_sync(void)::$_3 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMISMSCommandDriver::registerIndications_sync(void)::$_3 &&,QMIServiceMsg const)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5C5258;
  a2[1] = v2;
  return result;
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMISMSCommandDriver::registerIndications_sync(void)::$_3>(unsigned short,QMISMSCommandDriver::registerIndications_sync(void)::$_3 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMISMSCommandDriver::registerIndications_sync(void)::$_3 &&,QMIServiceMsg const)>::operator()(uint64_t a1, unsigned int *a2, QMIServiceMsg *this)
{
  unsigned int v4;
  _QWORD *v6;
  uint64_t v7;
  uint64_t TlvValue;
  int v9;
  uint64_t v10;
  int v11;
  unint64_t v12;
  _BOOL8 v13;
  std::__shared_weak_count *v14;
  std::__shared_weak_count *v15;
  unint64_t v16;
  NSObject *v17;
  unint64_t *p_shared_owners;
  unint64_t v19;
  _WORD v20[12];
  uint8_t buf[16];
  __int128 v22;
  void *v23;
  char v24;
  void *v25;
  char v26;
  void *v27;
  char v28;
  unint64_t v29;
  std::__shared_weak_count *v30;
  __int128 __p;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  uint64_t v39;

  v4 = *a2;
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0uLL;
    *(_QWORD *)&v32 = 0;
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v20, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v20);
    if ((_QWORD)__p)
    {
      *((_QWORD *)&__p + 1) = __p;
      operator delete((void *)__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v20);
  }
  v6 = *(_QWORD **)(a1 + 8);
  v39 = 0;
  v37 = 0u;
  v38 = 0u;
  v35 = 0u;
  v36 = 0u;
  v33 = 0u;
  v34 = 0u;
  __p = 0u;
  v32 = 0u;
  CSIPhoneNumber::CSIPhoneNumber((CSIPhoneNumber *)&__p);
  if (v4 - 1 >= 3)
    v7 = 0;
  else
    v7 = v4;
  TlvValue = qmi::MessageBase::findTlvValue((qmi::MessageBase *)v20);
  v10 = TlvValue;
  if (TlvValue)
  {
    v11 = v9;
    v29 = TlvValue;
    *(_OWORD *)buf = 0u;
    v22 = 0u;
    tlv::parseV<wms::tlv::SMSCInfo>(&v29, v9, buf);
    v12 = v29;
    if (v29)
      v13 = QMISMSCommandDriver::processSmscInfo(v6[11], v7, buf, (uint64_t)&__p);
    else
      v13 = 0;
    if (*(_QWORD *)&buf[8])
    {
      *(_QWORD *)&v22 = *(_QWORD *)&buf[8];
      operator delete(*(void **)&buf[8]);
    }
    if (!v12)
      ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(v20[0], 1, v10, v11);
  }
  else
  {
    v13 = 0;
  }
  v29 = 0;
  v30 = 0;
  v14 = (std::__shared_weak_count *)v6[10];
  if (v14)
  {
    v15 = std::__shared_weak_count::lock(v14);
    v30 = v15;
    if (v15)
    {
      v16 = v6[9];
      v29 = v16;
      if (v16)
      {
        CSIPhoneNumber::CSIPhoneNumber((CSIPhoneNumber *)buf, (const CSIPhoneNumber *)&__p);
        (*(void (**)(unint64_t, uint64_t, _BOOL8, uint8_t *))(*(_QWORD *)v16 + 56))(v16, v7, v13, buf);
        if (v28 < 0)
          operator delete(v27);
        if (v26 < 0)
          operator delete(v25);
        if (v24 < 0)
          operator delete(v23);
        if (SHIBYTE(v22) < 0)
          operator delete(*(void **)&buf[8]);
        goto LABEL_34;
      }
    }
  }
  else
  {
    v15 = 0;
  }
  v17 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)v6[11] + 16))(v6[11], v7);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl(&dword_216897000, v17, OS_LOG_TYPE_ERROR, "Failed to get Sms controller...", buf, 2u);
    if (!v15)
      goto LABEL_38;
  }
  else if (!v15)
  {
    goto LABEL_38;
  }
LABEL_34:
  p_shared_owners = (unint64_t *)&v15->__shared_owners_;
  do
    v19 = __ldaxr(p_shared_owners);
  while (__stlxr(v19 - 1, p_shared_owners));
  if (!v19)
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
LABEL_38:
  if (SHIBYTE(v37) < 0)
    operator delete(*((void **)&v36 + 1));
  if (SBYTE7(v36) < 0)
    operator delete((void *)v35);
  if (SBYTE7(v34) < 0)
    operator delete((void *)v33);
  if (SHIBYTE(v32) < 0)
    operator delete(*((void **)&__p + 1));
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v20);
}

void sub_2168EB194(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void *a13, void *__p, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,void *a33,uint64_t a34)
{
  CSIPhoneNumber::~CSIPhoneNumber(&a13);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a31);
  CSIPhoneNumber::~CSIPhoneNumber(&a33);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a10);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMISMSCommandDriver::registerIndications_sync(void)::$_3>(unsigned short,QMISMSCommandDriver::registerIndications_sync(void)::$_3 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMISMSCommandDriver::registerIndications_sync(void)::$_3 &&,QMIServiceMsg const)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMISMSCommandDriver::registerIndications_sync(void)::$_3>(unsigned short,QMISMSCommandDriver::registerIndications_sync(void)::$_3 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMISMSCommandDriver::registerIndications_sync(void)::$_3 &&,QMIServiceMsg const)>::target_type()
{
}

void std::__function::__func<QMISMSCommandDriver::registerEvents_sync(void)::$_0,std::allocator<QMISMSCommandDriver::registerEvents_sync(void)::$_0>,void ()(qmi::SubscriptionType)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<QMISMSCommandDriver::registerEvents_sync(void)::$_0,std::allocator<QMISMSCommandDriver::registerEvents_sync(void)::$_0>,void ()(qmi::SubscriptionType)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5C52D8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<QMISMSCommandDriver::registerEvents_sync(void)::$_0,std::allocator<QMISMSCommandDriver::registerEvents_sync(void)::$_0>,void ()(qmi::SubscriptionType)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5C52D8;
  a2[1] = v2;
  return result;
}

void std::__function::__func<QMISMSCommandDriver::registerEvents_sync(void)::$_0,std::allocator<QMISMSCommandDriver::registerEvents_sync(void)::$_0>,void ()(qmi::SubscriptionType)>::operator()(uint64_t a1, unsigned int *a2)
{
  unsigned int v2;
  uint64_t v3;
  uint64_t v4;
  NSObject *v5;
  _BOOL8 v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  NSObject *v18;
  uint64_t v19;
  uint64_t v20;
  _OWORD v21[2];
  uint8_t buf[8];
  uint64_t v23;
  void (*v24)(uint64_t, uint64_t);
  void *v25;
  std::__shared_weak_count *v26;
  std::__shared_weak_count *v27;
  _QWORD aBlock[5];

  v2 = *a2;
  v3 = *(_QWORD *)(a1 + 8);
  if (*a2 - 1 >= 3)
    v4 = 0;
  else
    v4 = v2;
  if ((subscriber::isValidSimSlot() & 1) != 0)
  {
    v5 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v3 + 88) + 16))(*(_QWORD *)(v3 + 88), v4);
    v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
    if (v6)
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#I Client Started", buf, 2u);
    }
    if (capabilities::ct::supports5G((capabilities::ct *)v6))
    {
      memset(v21, 0, sizeof(v21));
      qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v21);
      *qmi::MutableMessageBase::getTLV<wms::tlv::SubscriptionType>(v21) = v2 == 2;
      v7 = qmi::ClientRouter::get();
      qmi::ClientRouter::SendProxy::SendProxy<wms::BindSubscription::Request>((uint64_t)&v19, v2, v7);
      v8 = (std::__shared_weak_count *)operator new(0x28uLL);
      v8->__shared_owners_ = 0;
      p_shared_owners = (unint64_t *)&v8->__shared_owners_;
      v8->__shared_weak_owners_ = 0;
      v8->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C5860;
      v8[1].__vftable = (std::__shared_weak_count_vtbl *)v3;
      LODWORD(v8[1].__shared_owners_) = v2;
      v10 = v20;
      v11 = MEMORY[0x24BDAC760];
      *(_QWORD *)buf = MEMORY[0x24BDAC760];
      v23 = 1174405120;
      v24 = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN19QMISMSCommandDriver21bindSubscription_syncENS_16SubscriptionTypeEE3__0EEOS1_OT__block_invoke;
      v25 = &__block_descriptor_tmp_35_0;
      v26 = v8 + 1;
      v27 = v8;
      do
        v12 = __ldxr(p_shared_owners);
      while (__stxr(v12 + 1, p_shared_owners));
      aBlock[0] = v11;
      aBlock[1] = 0x40000000;
      aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3wms16BindSubscription8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
      aBlock[3] = &unk_24D5C58A8;
      aBlock[4] = buf;
      *(_QWORD *)(v10 + 32) = _Block_copy(aBlock);
      v13 = v27;
      if (v27)
      {
        v14 = (unint64_t *)&v27->__shared_owners_;
        do
          v15 = __ldaxr(v14);
        while (__stlxr(v15 - 1, v14));
        if (!v15)
        {
          ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
          std::__shared_weak_count::__release_weak(v13);
        }
      }
      do
        v16 = __ldaxr(p_shared_owners);
      while (__stlxr(v16 - 1, p_shared_owners));
      if (!v16)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
      v17 = v20;
      v20 = 0;
      if (v17)
        std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v20, v17);
      qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v21);
    }
    else
    {
      QMISMSCommandDriver::sendIndRegisterRequest_sync(v3, v2);
      QMISMSCommandDriver::initializeBaseband_sync(v3, v2);
    }
  }
  else
  {
    v18 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_216897000, v18, OS_LOG_TYPE_ERROR, "Invalid slot while starting QMI Client", buf, 2u);
    }
  }
}

void sub_2168EB54C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20)
{
  std::__shared_weak_count *v20;
  unint64_t *v21;
  std::__shared_weak_count *v23;
  unint64_t *p_shared_owners;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;

  v23 = a20;
  if (a20)
  {
    p_shared_owners = (unint64_t *)&a20->__shared_owners_;
    do
      v25 = __ldaxr(p_shared_owners);
    while (__stlxr(v25 - 1, p_shared_owners));
    if (!v25)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }
  do
    v26 = __ldaxr(v21);
  while (__stlxr(v26 - 1, v21));
  if (!v26)
  {
    ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
    std::__shared_weak_count::__release_weak(v20);
  }
  v27 = a10;
  a10 = 0;
  if (v27)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&a10, v27);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a11);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<QMISMSCommandDriver::registerEvents_sync(void)::$_0,std::allocator<QMISMSCommandDriver::registerEvents_sync(void)::$_0>,void ()(qmi::SubscriptionType)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<QMISMSCommandDriver::registerEvents_sync(void)::$_0,std::allocator<QMISMSCommandDriver::registerEvents_sync(void)::$_0>,void ()(qmi::SubscriptionType)>::target_type()
{
}

void std::__function::__func<QMISMSCommandDriver::registerEvents_sync(void)::$_1,std::allocator<QMISMSCommandDriver::registerEvents_sync(void)::$_1>,void ()(qmi::SubscriptionType)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<QMISMSCommandDriver::registerEvents_sync(void)::$_1,std::allocator<QMISMSCommandDriver::registerEvents_sync(void)::$_1>,void ()(qmi::SubscriptionType)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5C5368;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<QMISMSCommandDriver::registerEvents_sync(void)::$_1,std::allocator<QMISMSCommandDriver::registerEvents_sync(void)::$_1>,void ()(qmi::SubscriptionType)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5C5368;
  a2[1] = v2;
  return result;
}

void std::__function::__func<QMISMSCommandDriver::registerEvents_sync(void)::$_1,std::allocator<QMISMSCommandDriver::registerEvents_sync(void)::$_1>,void ()(qmi::SubscriptionType)>::operator()(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  uint8_t v3[16];

  v1 = *(_QWORD *)(a1 + 8);
  if ((subscriber::isValidSimSlot() & 1) != 0)
  {
    CSISMSCommandDriver::clientStopped();
  }
  else
  {
    v2 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v3 = 0;
      _os_log_error_impl(&dword_216897000, v2, OS_LOG_TYPE_ERROR, "Invalid slot while starting QMI Client", v3, 2u);
    }
  }
}

uint64_t std::__function::__func<QMISMSCommandDriver::registerEvents_sync(void)::$_1,std::allocator<QMISMSCommandDriver::registerEvents_sync(void)::$_1>,void ()(qmi::SubscriptionType)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<QMISMSCommandDriver::registerEvents_sync(void)::$_1,std::allocator<QMISMSCommandDriver::registerEvents_sync(void)::$_1>,void ()(qmi::SubscriptionType)>::target_type()
{
}

void std::__function::__func<QMISMSCommandDriver::registerEvents_sync(void)::$_2,std::allocator<QMISMSCommandDriver::registerEvents_sync(void)::$_2>,void ()(qmi::SubscriptionType)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<QMISMSCommandDriver::registerEvents_sync(void)::$_2,std::allocator<QMISMSCommandDriver::registerEvents_sync(void)::$_2>,void ()(qmi::SubscriptionType)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5C53E8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<QMISMSCommandDriver::registerEvents_sync(void)::$_2,std::allocator<QMISMSCommandDriver::registerEvents_sync(void)::$_2>,void ()(qmi::SubscriptionType)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5C53E8;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<QMISMSCommandDriver::registerEvents_sync(void)::$_2,std::allocator<QMISMSCommandDriver::registerEvents_sync(void)::$_2>,void ()(qmi::SubscriptionType)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<QMISMSCommandDriver::registerEvents_sync(void)::$_2,std::allocator<QMISMSCommandDriver::registerEvents_sync(void)::$_2>,void ()(qmi::SubscriptionType)>::target_type()
{
}

void qmi::MutableMessageBase::TlvWrapper<wms::tlv::RegTransportLayerInfo>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::RegTransportLayerInfo>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<wms::tlv::RegTransportLayerInfo>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::RegTransportLayerInfo>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C5480;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<wms::tlv::RegTransportNwInfo>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::RegTransportNwInfo>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<wms::tlv::RegTransportNwInfo>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::RegTransportNwInfo>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C54D0;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<wms::tlv::CallStatusInfo>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::CallStatusInfo>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<wms::tlv::CallStatusInfo>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::CallStatusInfo>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C5520;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<wms::tlv::ServiceReady>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::ServiceReady>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<wms::tlv::ServiceReady>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::ServiceReady>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C5570;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<wms::tlv::BroadcastConfig>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::BroadcastConfig>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<wms::tlv::BroadcastConfig>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::BroadcastConfig>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C55C0;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<wms::tlv::RegTransportLayerMwiInfo>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::RegTransportLayerMwiInfo>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<wms::tlv::RegTransportLayerMwiInfo>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::RegTransportLayerMwiInfo>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C5610;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<wms::tlv::SimReadyInfo>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::SimReadyInfo>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<wms::tlv::SimReadyInfo>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::SimReadyInfo>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C5660;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<wms::tlv::SmscAddrInfo>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::SmscAddrInfo>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<wms::tlv::SmscAddrInfo>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::SmscAddrInfo>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C56B0;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<wms::tlv::MemFullInd>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::MemFullInd>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<wms::tlv::MemFullInd>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::MemFullInd>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C5700;
  return result;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN19QMISMSCommandDriver27sendIndRegisterRequest_syncENS_16SubscriptionTypeEE3__9EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t *v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  __int16 v12;
  int v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)(a2 + 4))
  {
    v3 = *(uint64_t **)(a1 + 32);
    v4 = *v3;
    v5 = *((_DWORD *)v3 + 2);
    if (v5 - 1 >= 3)
      v6 = 0;
    else
      v6 = v5;
    v7 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v4 + 88) + 16))(*(_QWORD *)(v4 + 88), v6);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      v8 = qmi::asString();
      v9 = *(_DWORD *)(a2 + 4);
      v10 = 136315394;
      v11 = v8;
      v12 = 1024;
      v13 = v9;
      _os_log_error_impl(&dword_216897000, v7, OS_LOG_TYPE_ERROR, "Not registering for Sig Info events: %s (0x%x)", (uint8_t *)&v10, 0x12u);
    }
  }
}

uint64_t __copy_helper_block_e8_32c108_ZTSNSt3__110shared_ptrIZN19QMISMSCommandDriver27sendIndRegisterRequest_syncEN3qmi16SubscriptionTypeEE3__9EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c108_ZTSNSt3__110shared_ptrIZN19QMISMSCommandDriver27sendIndRegisterRequest_syncEN3qmi16SubscriptionTypeEE3__9EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMISMSCommandDriver::sendIndRegisterRequest_sync(qmi::SubscriptionType)::$_9,std::allocator<QMISMSCommandDriver::sendIndRegisterRequest_sync(qmi::SubscriptionType)::$_9>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C5768;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMISMSCommandDriver::sendIndRegisterRequest_sync(qmi::SubscriptionType)::$_9,std::allocator<QMISMSCommandDriver::sendIndRegisterRequest_sync(qmi::SubscriptionType)::$_9>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C5768;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3wms18IndicationRegister8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2168EC10C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

char *qmi::MutableMessageBase::getTLV<wms::tlv::SubscriptionType>(_QWORD *a1)
{
  const void **v2;
  const void **v3;
  char **v4;
  char *v5;
  char *result;
  uint64_t v7;
  unint64_t v8;
  uint64_t *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  v4 = (char **)(a1 + 1);
  if (v2 != v3)
  {
    while (*((_BYTE *)*v2 + 8) != 1)
    {
      if (++v2 == v3)
        goto LABEL_8;
    }
  }
  if (v2 == v3)
  {
LABEL_8:
    v7 = operator new();
    *(_WORD *)(v7 + 8) = 1;
    *(_QWORD *)v7 = &off_24D5C57F8;
    v8 = a1[3];
    v9 = (uint64_t *)a1[2];
    if ((unint64_t)v9 >= v8)
    {
      v11 = ((char *)v9 - *v4) >> 3;
      if ((unint64_t)(v11 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v12 = v8 - (_QWORD)*v4;
      v13 = v12 >> 2;
      if (v12 >> 2 <= (unint64_t)(v11 + 1))
        v13 = v11 + 1;
      if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
        v14 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v14 = v13;
      if (v14)
        v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v14);
      else
        v15 = 0;
      v16 = (uint64_t *)&v15[8 * v11];
      v17 = &v15[8 * v14];
      *v16 = v7;
      v10 = v16 + 1;
      v19 = (char *)a1[1];
      v18 = (char *)a1[2];
      if (v18 != v19)
      {
        do
        {
          v20 = *((_QWORD *)v18 - 1);
          v18 -= 8;
          *--v16 = v20;
        }
        while (v18 != v19);
        v18 = *v4;
      }
      a1[1] = v16;
      a1[2] = v10;
      a1[3] = v17;
      if (v18)
        operator delete(v18);
    }
    else
    {
      *v9 = v7;
      v10 = v9 + 1;
    }
    result = (char *)(v7 + 9);
    a1[2] = v10;
  }
  else
  {
    if (!v5)
      __cxa_bad_cast();
    return v5 + 9;
  }
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<wms::tlv::SubscriptionType>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::SubscriptionType>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<wms::tlv::SubscriptionType>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::SubscriptionType>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C57F8;
  return result;
}

uint64_t qmi::ClientRouter::SendProxy::SendProxy<wms::BindSubscription::Request>(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v5;

  *(_DWORD *)a1 = a2;
  v5 = operator new();
  *(_QWORD *)v5 = a3;
  *(_QWORD *)(v5 + 8) = QMIServiceMsg::create();
  *(_DWORD *)(v5 + 16) = 25000;
  *(_QWORD *)(v5 + 24) = 0;
  *(_QWORD *)(v5 + 32) = 0;
  *(_QWORD *)(a1 + 8) = v5;
  return a1;
}

void sub_2168EC3E8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199FEAC4](v1, 0x10F0C401BA14CC5);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN19QMISMSCommandDriver21bindSubscription_syncENS_16SubscriptionTypeEE3__0EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  _QWORD **v4;
  unsigned int v5;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  __int16 v12;
  int v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 + 32);
  v4 = *(_QWORD ***)v3;
  v5 = *(_DWORD *)(v3 + 8);
  if (v5 - 1 >= 3)
    v6 = 0;
  else
    v6 = v5;
  v7 = *(NSObject **)(*(uint64_t (**)(_QWORD *, uint64_t))(*v4[11] + 16))(v4[11], v6);
  if (*(_DWORD *)(a2 + 4))
  {
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      v8 = qmi::asString();
      v9 = *(_DWORD *)(a2 + 4);
      v10 = 136315394;
      v11 = v8;
      v12 = 1024;
      v13 = v9;
      _os_log_error_impl(&dword_216897000, v7, OS_LOG_TYPE_ERROR, "Error binding subscription: %s (0x%x)", (uint8_t *)&v10, 0x12u);
    }
  }
  else
  {
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v10) = 0;
      _os_log_impl(&dword_216897000, v7, OS_LOG_TYPE_DEFAULT, "#I Bind success", (uint8_t *)&v10, 2u);
    }
    QMISMSCommandDriver::sendIndRegisterRequest_sync((uint64_t)v4, *(_DWORD *)(v3 + 8));
    QMISMSCommandDriver::initializeBaseband_sync((uint64_t)v4, *(_DWORD *)(v3 + 8));
    ((void (*)(_QWORD **, uint64_t))(*v4)[10])(v4, v6);
  }
}

uint64_t __copy_helper_block_e8_32c102_ZTSNSt3__110shared_ptrIZN19QMISMSCommandDriver21bindSubscription_syncEN3qmi16SubscriptionTypeEE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c102_ZTSNSt3__110shared_ptrIZN19QMISMSCommandDriver21bindSubscription_syncEN3qmi16SubscriptionTypeEE3__0EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMISMSCommandDriver::bindSubscription_sync(qmi::SubscriptionType)::$_0,std::allocator<QMISMSCommandDriver::bindSubscription_sync(qmi::SubscriptionType)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C5860;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMISMSCommandDriver::bindSubscription_sync(qmi::SubscriptionType)::$_0,std::allocator<QMISMSCommandDriver::bindSubscription_sync(qmi::SubscriptionType)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C5860;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3wms16BindSubscription8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2168EC694(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN19QMISMSCommandDriver21getServiceReadyStatusENS_16SubscriptionTypeEE3__0EEOS1_OT__block_invoke(uint64_t a1, qmi::MessageBase *a2)
{
  unsigned int v3;
  uint64_t v4;
  uint64_t v5;
  os_log_t *v6;
  os_log_t *v7;
  int v8;
  os_log_t v9;
  const char *v10;
  NSObject *v11;
  uint32_t v12;
  uint64_t TlvValue;
  int v14;
  uint64_t v15;
  int v16;
  unsigned int ready;
  unsigned int v18;
  std::__shared_weak_count *v19;
  std::__shared_weak_count *v20;
  uint64_t v21;
  unsigned __int8 v22;
  unint64_t *p_shared_owners;
  unint64_t v24;
  NSObject *v25;
  const char *v26;
  NSObject *v27;
  unint64_t *v28;
  unint64_t v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  int v33;
  int v34;
  int v35;
  os_log_t v36;
  const char *v37;
  uint64_t v38;
  uint8_t buf[4];
  _DWORD v40[7];

  *(_QWORD *)&v40[5] = *MEMORY[0x24BDAC8D0];
  v3 = *(_DWORD *)(a1 + 48);
  v4 = **(_QWORD **)(a1 + 32);
  if (v3 - 1 >= 3)
    v5 = 0;
  else
    v5 = v3;
  v6 = (os_log_t *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v4 + 88) + 16))(*(_QWORD *)(v4 + 88), v5);
  v7 = v6;
  v8 = *((_DWORD *)a2 + 1);
  if (v8)
  {
    v9 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109378;
      v40[0] = v8;
      LOWORD(v40[1]) = 2080;
      *(_QWORD *)((char *)&v40[1] + 2) = qmi::asString();
      v10 = "#I WMS service ready status return error: 0x%04x (%s)";
      v11 = v9;
      v12 = 18;
LABEL_7:
      _os_log_impl(&dword_216897000, v11, OS_LOG_TYPE_DEFAULT, v10, buf, v12);
      return;
    }
    return;
  }
  TlvValue = qmi::MessageBase::findTlvValue(a2);
  if (TlvValue)
  {
    v15 = TlvValue;
    v16 = v14;
    v38 = TlvValue;
    ready = tlv::parseV<wms::tlv::ReadyStatus>((unint64_t *)&v38, v14);
    if (!v38)
    {
      ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 17, v15, v16);
      goto LABEL_30;
    }
    v18 = ready;
    v19 = *(std::__shared_weak_count **)(v4 + 80);
    if (v19)
    {
      v20 = std::__shared_weak_count::lock(v19);
      if (v20)
      {
        v21 = *(_QWORD *)(v4 + 72);
        if (v21)
        {
          if (v18 >= 4)
            v22 = 0;
          else
            v22 = v18;
          (*(void (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)v21 + 80))(v21, v5, v22);
          p_shared_owners = (unint64_t *)&v20->__shared_owners_;
          do
            v24 = __ldaxr(p_shared_owners);
          while (__stlxr(v24 - 1, p_shared_owners));
          if (!v24)
          {
            ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
            std::__shared_weak_count::__release_weak(v20);
          }
          v25 = *v7;
          if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
          {
            v26 = qmi::wms::asString(v18);
            *(_DWORD *)buf = 136315138;
            *(_QWORD *)v40 = v26;
            _os_log_impl(&dword_216897000, v25, OS_LOG_TYPE_DEFAULT, "#I getServiceReadyStatus: WMS service status: %s", buf, 0xCu);
          }
          goto LABEL_30;
        }
      }
    }
    else
    {
      v20 = 0;
    }
    v27 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_216897000, v27, OS_LOG_TYPE_ERROR, "Failed to get SMS controller...", buf, 2u);
      if (!v20)
        goto LABEL_30;
    }
    else if (!v20)
    {
      goto LABEL_30;
    }
    v28 = (unint64_t *)&v20->__shared_owners_;
    do
      v29 = __ldaxr(v28);
    while (__stlxr(v29 - 1, v28));
    if (!v29)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
LABEL_30:
  v30 = qmi::MessageBase::findTlvValue(a2);
  v32 = v30;
  if (v30)
  {
    v33 = v31;
    v38 = v30;
    v34 = tlv::parseV<wms::tlv::IndicationRegistered>((unint64_t *)&v38, v31);
    if (v38)
    {
      v35 = v34;
      v36 = *v7;
      if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
      {
        v37 = qmi::wms::asString(v35);
        *(_DWORD *)buf = 136315138;
        *(_QWORD *)v40 = v37;
        v10 = "#I Indication registered status: %s";
        v11 = v36;
        v12 = 12;
        goto LABEL_7;
      }
    }
    else
    {
      ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 16, v32, v33);
    }
  }
}

void sub_2168ECA00(_Unwind_Exception *exception_object)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v4;

  p_shared_owners = (unint64_t *)&v1->__shared_owners_;
  do
    v4 = __ldaxr(p_shared_owners);
  while (__stlxr(v4 - 1, p_shared_owners));
  if (!v4)
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t __copy_helper_block_e8_32c102_ZTSNSt3__110shared_ptrIZN19QMISMSCommandDriver21getServiceReadyStatusEN3qmi16SubscriptionTypeEE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c102_ZTSNSt3__110shared_ptrIZN19QMISMSCommandDriver21getServiceReadyStatusEN3qmi16SubscriptionTypeEE3__0EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMISMSCommandDriver::getServiceReadyStatus(qmi::SubscriptionType)::$_0,std::allocator<QMISMSCommandDriver::getServiceReadyStatus(qmi::SubscriptionType)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C5908;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMISMSCommandDriver::getServiceReadyStatus(qmi::SubscriptionType)::$_0,std::allocator<QMISMSCommandDriver::getServiceReadyStatus(qmi::SubscriptionType)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C5908;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3wms21GetServiceReadyStatus8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2168ECB74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<wms::tlv::MemoryStorage>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::MemoryStorage>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<wms::tlv::MemoryStorage>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::MemoryStorage>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C5998;
  return result;
}

char *qmi::MutableMessageBase::getTLV<wms::tlv::Message_Mode>(_QWORD *a1, int a2)
{
  char v2;
  const void **v4;
  const void **v5;
  char **v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t *v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  char *v17;
  uint64_t *v18;
  char *v19;
  char *v20;
  char *v21;
  uint64_t v22;

  v2 = a2;
  v4 = (const void **)a1[1];
  v5 = (const void **)a1[2];
  v6 = (char **)(a1 + 1);
  if (v4 != v5)
  {
    while (*((unsigned __int8 *)*v4 + 8) != a2)
    {
      if (++v4 == v5)
        goto LABEL_8;
    }
  }
  if (v4 == v5)
  {
LABEL_8:
    v9 = operator new();
    *(_BYTE *)(v9 + 8) = v2;
    *(_DWORD *)(v9 + 12) = 0;
    v8 = v9 + 12;
    *(_QWORD *)v9 = &off_24D5C59E8;
    v10 = a1[3];
    v11 = (uint64_t *)a1[2];
    if ((unint64_t)v11 >= v10)
    {
      v13 = ((char *)v11 - *v6) >> 3;
      if ((unint64_t)(v13 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v14 = v10 - (_QWORD)*v6;
      v15 = v14 >> 2;
      if (v14 >> 2 <= (unint64_t)(v13 + 1))
        v15 = v13 + 1;
      if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8)
        v16 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v16 = v15;
      if (v16)
        v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v16);
      else
        v17 = 0;
      v18 = (uint64_t *)&v17[8 * v13];
      v19 = &v17[8 * v16];
      *v18 = v9;
      v12 = v18 + 1;
      v21 = (char *)a1[1];
      v20 = (char *)a1[2];
      if (v20 != v21)
      {
        do
        {
          v22 = *((_QWORD *)v20 - 1);
          v20 -= 8;
          *--v18 = v22;
        }
        while (v20 != v21);
        v20 = *v6;
      }
      a1[1] = v18;
      a1[2] = v12;
      a1[3] = v19;
      if (v20)
        operator delete(v20);
    }
    else
    {
      *v11 = v9;
      v12 = v11 + 1;
    }
    a1[2] = v12;
  }
  else
  {
    if (!v7)
      __cxa_bad_cast();
    return v7 + 12;
  }
  return (char *)v8;
}

void qmi::MutableMessageBase::TlvWrapper<wms::tlv::Message_Mode>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::Message_Mode>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<wms::tlv::Message_Mode>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::IPPref>((_BYTE **)a2, (_DWORD *)(a1 + 12));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::Message_Mode>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C59E8;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a1 + 12);
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<wms::tlv::RequestedTag>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::RequestedTag>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<wms::tlv::RequestedTag>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::IPPref>((_BYTE **)a2, (_DWORD *)(a1 + 12));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::RequestedTag>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C5A38;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a1 + 12);
  return result;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN19QMISMSCommandDriver18readStoredMessagesEN10subscriber7SimSlotEbE3__3EEOS1_OT__block_invoke(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t *v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  os_log_t *v9;
  std::__shared_weak_count *v10;
  std::__shared_weak_count *v11;
  uint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  NSObject *v15;
  int v16;
  unsigned int *TlvValue;
  int v18;
  os_log_t *v19;
  _DWORD *v20;
  _DWORD *v21;
  _BOOL8 v22;
  uint64_t v23;
  const void **v24;
  char *v25;
  char *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  _QWORD *v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  char *v34;
  uint64_t *v35;
  char *v36;
  char *v37;
  uint64_t v38;
  NSObject *v39;
  int v40;
  const char *v41;
  const void **v42;
  char *v43;
  char *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  _QWORD *v48;
  uint64_t v49;
  unint64_t v50;
  unint64_t v51;
  char *v52;
  uint64_t *v53;
  char *v54;
  char *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  _BOOL8 v60;
  uint64_t v61;
  std::__shared_weak_count *v62;
  unint64_t *p_shared_owners;
  uint64_t v64;
  unint64_t v65;
  std::__shared_weak_count *v66;
  unint64_t *v67;
  unint64_t v68;
  unint64_t v69;
  uint64_t v70;
  NSObject *v71;
  unint64_t *v72;
  unint64_t v73;
  NSObject *v74;
  unsigned int *v75;
  int v76;
  unsigned int *v77;
  qmi::MessageBase *v78;
  _DWORD *v79;
  _DWORD *v80;
  uint64_t v81;
  unsigned int *v82;
  std::__shared_weak_count_vtbl *v83;
  uint64_t v84;
  int v85;
  int v86;
  uint64_t v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  _QWORD aBlock[5];
  uint8_t buf[8];
  __int128 v94;
  void *v95;
  std::__shared_weak_count *v96;
  std::__shared_weak_count *v97;
  uint64_t v98;

  v98 = *MEMORY[0x24BDAC8D0];
  v3 = *(uint64_t **)(a1 + 32);
  v4 = *(_DWORD *)(a1 + 48);
  v5 = *v3;
  if (v4 - 1 >= 3)
    v6 = 0;
  else
    v6 = v4;
  v7 = *((unsigned __int8 *)v3 + 8);
  v8 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v5 + 88) + 16))(*(_QWORD *)(v5 + 88), v6);
  if (!*((_DWORD *)a2 + 1))
  {
    TlvValue = (unsigned int *)qmi::MessageBase::findTlvValue(a2);
    if (!TlvValue)
      return;
    v77 = TlvValue;
    v78 = a2;
    v81 = 0;
    v82 = TlvValue;
    v79 = 0;
    v80 = 0;
    v76 = v18;
    tlv::parseV<wms::tlv::MessageList>(&v82, v18, &v79);
    v75 = v82;
    if (v82)
    {
      v19 = (os_log_t *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v5 + 88) + 16))(*(_QWORD *)(v5 + 88), v6);
      v21 = v79;
      v20 = v80;
      if (v80 == v79)
      {
        v74 = *v19;
        if (!os_log_type_enabled(*v19, OS_LOG_TYPE_DEFAULT))
        {
LABEL_94:
          if (v20)
          {
            v80 = v20;
            operator delete(v20);
          }
          if (!v75)
            ((void (*)(_QWORD, uint64_t, unsigned int *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)v78, 1, v77, v76);
          return;
        }
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_216897000, v74, OS_LOG_TYPE_DEFAULT, "#I No stored messages to request", buf, 2u);
      }
      else
      {
        v22 = v7 == 0;
        if ((v6 - 1) >= 3)
          v23 = 0;
        else
          v23 = v6;
        do
        {
          v90 = 0u;
          v91 = 0u;
          qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)&v90);
          v24 = (const void **)*((_QWORD *)&v90 + 1);
          if (*((_QWORD *)&v90 + 1) != (_QWORD)v91)
          {
            while (*((_BYTE *)*v24 + 8) != 1)
            {
              if (++v24 == (const void **)v91)
                goto LABEL_27;
            }
          }
          if (v24 == (const void **)v91)
          {
LABEL_27:
            v27 = operator new();
            v28 = v27;
            *(_BYTE *)(v27 + 8) = 1;
            *(_QWORD *)v27 = &off_24D5C5C28;
            *(_BYTE *)(v27 + 12) = 0;
            v26 = (char *)(v27 + 12);
            *(_DWORD *)(v27 + 16) = 0;
            v29 = v91;
            if ((unint64_t)v91 >= *((_QWORD *)&v91 + 1))
            {
              v31 = (uint64_t)(v91 - *((_QWORD *)&v90 + 1)) >> 3;
              if ((unint64_t)(v31 + 1) >> 61)
                std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
              v32 = (uint64_t)(*((_QWORD *)&v91 + 1) - *((_QWORD *)&v90 + 1)) >> 2;
              if (v32 <= v31 + 1)
                v32 = v31 + 1;
              if (*((_QWORD *)&v91 + 1) - *((_QWORD *)&v90 + 1) >= 0x7FFFFFFFFFFFFFF8uLL)
                v33 = 0x1FFFFFFFFFFFFFFFLL;
              else
                v33 = v32;
              if (v33)
                v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v91 + 8, v33);
              else
                v34 = 0;
              v35 = (uint64_t *)&v34[8 * v31];
              *v35 = v28;
              v30 = v35 + 1;
              v37 = (char *)*((_QWORD *)&v90 + 1);
              v36 = (char *)v91;
              if ((_QWORD)v91 != *((_QWORD *)&v90 + 1))
              {
                do
                {
                  v38 = *((_QWORD *)v36 - 1);
                  v36 -= 8;
                  *--v35 = v38;
                }
                while (v36 != v37);
                v36 = (char *)*((_QWORD *)&v90 + 1);
              }
              *((_QWORD *)&v90 + 1) = v35;
              *(_QWORD *)&v91 = v30;
              *((_QWORD *)&v91 + 1) = &v34[8 * v33];
              if (v36)
                operator delete(v36);
            }
            else
            {
              *(_QWORD *)v91 = v27;
              v30 = (_QWORD *)(v29 + 8);
            }
            *(_QWORD *)&v91 = v30;
          }
          else
          {
            if (!v25)
              __cxa_bad_cast();
            v26 = v25 + 12;
          }
          *v26 = v7;
          *((_DWORD *)v26 + 1) = *v21;
          *(_DWORD *)qmi::MutableMessageBase::getTLV<wms::tlv::Message_Mode>(&v90, 16) = v22;
          v39 = *(NSObject **)(v5 + 40);
          if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
          {
            v40 = *v21;
            v41 = qmi::wms::asString(v7);
            *(_DWORD *)buf = 67109378;
            *(_DWORD *)&buf[4] = v40;
            LOWORD(v94) = 2080;
            *(_QWORD *)((char *)&v94 + 2) = v41;
            _os_log_impl(&dword_216897000, v39, OS_LOG_TYPE_DEFAULT, "#I Requesting storaged message at index %d on storage %s", buf, 0x12u);
          }
          v88 = 0u;
          v89 = 0u;
          qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)&v88);
          v42 = (const void **)*((_QWORD *)&v88 + 1);
          if (*((_QWORD *)&v88 + 1) != (_QWORD)v89)
          {
            while (*((_BYTE *)*v42 + 8) != 1)
            {
              if (++v42 == (const void **)v89)
                goto LABEL_53;
            }
          }
          if (v42 == (const void **)v89)
          {
LABEL_53:
            v45 = operator new();
            v46 = v45;
            *(_BYTE *)(v45 + 8) = 1;
            *(_BYTE *)(v45 + 12) = 0;
            v44 = (char *)(v45 + 12);
            *(_QWORD *)v45 = &off_24D5C5C78;
            *(_QWORD *)(v45 + 16) = 0;
            v47 = v89;
            if ((unint64_t)v89 >= *((_QWORD *)&v89 + 1))
            {
              v49 = (uint64_t)(v89 - *((_QWORD *)&v88 + 1)) >> 3;
              if ((unint64_t)(v49 + 1) >> 61)
                std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
              v50 = (uint64_t)(*((_QWORD *)&v89 + 1) - *((_QWORD *)&v88 + 1)) >> 2;
              if (v50 <= v49 + 1)
                v50 = v49 + 1;
              if (*((_QWORD *)&v89 + 1) - *((_QWORD *)&v88 + 1) >= 0x7FFFFFFFFFFFFFF8uLL)
                v51 = 0x1FFFFFFFFFFFFFFFLL;
              else
                v51 = v50;
              if (v51)
                v52 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v89 + 8, v51);
              else
                v52 = 0;
              v53 = (uint64_t *)&v52[8 * v49];
              *v53 = v46;
              v48 = v53 + 1;
              v55 = (char *)*((_QWORD *)&v88 + 1);
              v54 = (char *)v89;
              if ((_QWORD)v89 != *((_QWORD *)&v88 + 1))
              {
                do
                {
                  v56 = *((_QWORD *)v54 - 1);
                  v54 -= 8;
                  *--v53 = v56;
                }
                while (v54 != v55);
                v54 = (char *)*((_QWORD *)&v88 + 1);
              }
              *((_QWORD *)&v88 + 1) = v53;
              *(_QWORD *)&v89 = v48;
              *((_QWORD *)&v89 + 1) = &v52[8 * v51];
              if (v54)
                operator delete(v54);
            }
            else
            {
              *(_QWORD *)v89 = v45;
              v48 = (_QWORD *)(v47 + 8);
            }
            *(_QWORD *)&v89 = v48;
          }
          else
          {
            if (!v43)
              __cxa_bad_cast();
            v44 = v43 + 12;
          }
          *v44 = v7;
          *(_QWORD *)(v44 + 4) = *v21;
          *(_DWORD *)qmi::MutableMessageBase::getTLV<wms::tlv::Message_Mode>(&v88, 16) = v22;
          v57 = qmi::ClientRouter::get();
          v86 = v23;
          v58 = operator new();
          v59 = v23;
          *(_QWORD *)v58 = v57;
          v60 = v22;
          *(_QWORD *)(v58 + 8) = QMIServiceMsg::create();
          *(_DWORD *)(v58 + 16) = 25000;
          *(_QWORD *)(v58 + 24) = 0;
          *(_QWORD *)(v58 + 32) = 0;
          v87 = v58;
          v83 = (std::__shared_weak_count_vtbl *)v5;
          qmi::MutableMessageBase::MutableMessageBase();
          v61 = v6;
          v85 = v6;
          v62 = (std::__shared_weak_count *)operator new(0x48uLL);
          v62->__shared_owners_ = 0;
          p_shared_owners = (unint64_t *)&v62->__shared_owners_;
          v62->__shared_weak_owners_ = 0;
          v62->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C5CE0;
          v62[1].__vftable = v83;
          qmi::MutableMessageBase::MutableMessageBase();
          LODWORD(v62[2].__shared_weak_owners_) = v85;
          v64 = v87;
          *(_QWORD *)buf = MEMORY[0x24BDAC760];
          *(_QWORD *)&v94 = 1174405120;
          *((_QWORD *)&v94 + 1) = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN19QMISMSCommandDriver21requestStoredMessagesEN10subscriber7SimSlotERKNSt3__16vectorIN3wms3tlv11MessageInfoENS6_9allocatorISA_EEEENS_3wms14SMSStorageTypeEE3__4EEOS1_OT__block_invoke;
          v95 = &__block_descriptor_tmp_47;
          v96 = v62 + 1;
          v97 = v62;
          do
            v65 = __ldxr(p_shared_owners);
          while (__stxr(v65 + 1, p_shared_owners));
          aBlock[0] = MEMORY[0x24BDAC760];
          aBlock[1] = 0x40000000;
          aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3wms7RawRead8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
          aBlock[3] = &unk_24D5C5D28;
          aBlock[4] = buf;
          *(_QWORD *)(v64 + 32) = _Block_copy(aBlock);
          v66 = v97;
          if (v97)
          {
            v67 = (unint64_t *)&v97->__shared_owners_;
            do
              v68 = __ldaxr(v67);
            while (__stlxr(v68 - 1, v67));
            if (!v68)
            {
              ((void (*)(std::__shared_weak_count *))v66->__on_zero_shared)(v66);
              std::__shared_weak_count::__release_weak(v66);
            }
          }
          do
            v69 = __ldaxr(p_shared_owners);
          while (__stlxr(v69 - 1, p_shared_owners));
          if (!v69)
          {
            ((void (*)(std::__shared_weak_count *))v62->__on_zero_shared)(v62);
            std::__shared_weak_count::__release_weak(v62);
          }
          qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&v84);
          v70 = v87;
          v87 = 0;
          if (v70)
            std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v87, v70);
          qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&v88);
          qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&v90);
          v21 += 2;
          v6 = v61;
          v22 = v60;
          v23 = v59;
        }
        while (v21 != v80);
      }
    }
    v20 = v79;
    goto LABEL_94;
  }
  v9 = (os_log_t *)v8;
  v10 = *(std::__shared_weak_count **)(v5 + 80);
  if (v10)
  {
    v11 = std::__shared_weak_count::lock(v10);
    if (v11)
    {
      v12 = *(_QWORD *)(v5 + 72);
      if (v12)
      {
        (*(void (**)(uint64_t))(*(_QWORD *)v12 + 152))(v12);
        v13 = (unint64_t *)&v11->__shared_owners_;
        do
          v14 = __ldaxr(v13);
        while (__stlxr(v14 - 1, v13));
        if (!v14)
        {
          ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
          std::__shared_weak_count::__release_weak(v11);
        }
        v15 = *v9;
        if (os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT))
        {
          v16 = *((_DWORD *)a2 + 1);
          *(_DWORD *)buf = 67109378;
          *(_DWORD *)&buf[4] = v16;
          LOWORD(v94) = 2080;
          *(_QWORD *)((char *)&v94 + 2) = qmi::asString();
          _os_log_impl(&dword_216897000, v15, OS_LOG_TYPE_DEFAULT, "#I Getting stored SMSs return error: 0x%04x (%s)", buf, 0x12u);
        }
        return;
      }
    }
  }
  else
  {
    v11 = 0;
  }
  v71 = *v9;
  if (os_log_type_enabled(*v9, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl(&dword_216897000, v71, OS_LOG_TYPE_ERROR, "Failed to get Sms controller...", buf, 2u);
    if (!v11)
      return;
  }
  else if (!v11)
  {
    return;
  }
  v72 = (unint64_t *)&v11->__shared_owners_;
  do
    v73 = __ldaxr(v72);
  while (__stlxr(v73 - 1, v72));
  if (!v73)
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
}

void sub_2168ED7F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,qmi::MutableMessageBase *a22,void *__p,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t __copy_helper_block_e8_32c98_ZTSNSt3__110shared_ptrIZN19QMISMSCommandDriver18readStoredMessagesEN10subscriber7SimSlotEbE3__3EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c98_ZTSNSt3__110shared_ptrIZN19QMISMSCommandDriver18readStoredMessagesEN10subscriber7SimSlotEbE3__3EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMISMSCommandDriver::readStoredMessages(subscriber::SimSlot,BOOL)::$_3,std::allocator<QMISMSCommandDriver::readStoredMessages(subscriber::SimSlot,BOOL)::$_3>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C5AA0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMISMSCommandDriver::readStoredMessages(subscriber::SimSlot,BOOL)::$_3,std::allocator<QMISMSCommandDriver::readStoredMessages(subscriber::SimSlot,BOOL)::$_3>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C5AA0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3wms12ListMessages8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2168EDA78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

_QWORD *qmi::MutableMessageBase::TlvWrapper<wms::tlv::MsgWaitingInfo>::~TlvWrapper(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24D5C5B30;
  v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<wms::tlv::MsgWaitingInfo>::~TlvWrapper(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24D5C5B30;
  v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  JUMPOUT(0x2199FEAC4);
}

unint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::MsgWaitingInfo>::getSize(uint64_t a1)
{
  return tlv::size<wms::tlv::MsgWaitingInfo>((_QWORD *)(a1 + 16));
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<wms::tlv::MsgWaitingInfo>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wms::tlv::MsgWaitingInfo>((_BYTE **)a2, (_DWORD *)(a1 + 16));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

_QWORD *qmi::MutableMessageBase::TlvWrapper<wms::tlv::MsgWaitingInfo>::clone(uint64_t a1)
{
  uint64_t v2;
  _QWORD *v3;
  _BYTE *v4;
  _BYTE *v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;

  v2 = operator new();
  v3 = (_QWORD *)v2;
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)(v2 + 16) = 0;
  *(_QWORD *)v2 = &off_24D5C5B30;
  *(_QWORD *)(v2 + 24) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  v5 = *(_BYTE **)(a1 + 16);
  v4 = *(_BYTE **)(a1 + 24);
  v6 = v4 - v5;
  if (v4 != v5)
  {
    if (v6 < 0)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v7 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>(v2 + 32, v6 >> 3);
    v3[2] = v7;
    v3[4] = &v7[8 * v8];
    memmove(v7, v5, v6 - 2);
    v3[3] = &v7[8 * (v6 >> 3)];
  }
  return v3;
}

void sub_2168EDC5C(_Unwind_Exception *a1)
{
  uint64_t v1;
  void **v2;
  void *v4;

  v4 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 24) = v4;
    operator delete(v4);
  }
  MEMORY[0x2199FEAC4](v1, 0x10A1C403082B835);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN19QMISMSCommandDriver19storeMsgWaitingInfoEN10subscriber7SimSlotEbhN8dispatch5blockIU13block_pointerFvbEEEE3__1EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t *v3;
  unsigned int v4;
  const void *v5;
  uint64_t v6;
  void (**v7)(void *, BOOL);
  uint64_t v8;
  NSObject **v9;
  int v10;
  NSObject *v11;
  NSObject *v12;
  _DWORD v13[2];
  __int16 v14;
  uint64_t v15;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  v3 = *(uint64_t **)(a1 + 32);
  v4 = *(_DWORD *)(a1 + 48);
  v6 = *v3;
  v5 = (const void *)v3[1];
  if (v5)
    v7 = (void (**)(void *, BOOL))_Block_copy(v5);
  else
    v7 = 0;
  if (v4 - 1 >= 3)
    v8 = 0;
  else
    v8 = v4;
  v9 = (NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v6 + 88) + 16))(*(_QWORD *)(v6 + 88), v8);
  v10 = *(_DWORD *)(a2 + 4);
  v11 = *v9;
  v12 = *v9;
  if (v10)
  {
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      v13[0] = 67109378;
      v13[1] = v10;
      v14 = 2080;
      v15 = qmi::asString();
      _os_log_error_impl(&dword_216897000, v11, OS_LOG_TYPE_ERROR, "Unable to store MWI info. Error: 0x%04x (%s)", (uint8_t *)v13, 0x12u);
    }
  }
  else if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v13[0]) = 0;
    _os_log_impl(&dword_216897000, v11, OS_LOG_TYPE_DEFAULT, "#I MWI info from AP stored successfully in baseband", (uint8_t *)v13, 2u);
  }
  v7[2](v7, v10 == 0);
  _Block_release(v7);
}

void sub_2168EDDDC(_Unwind_Exception *exception_object, int a2)
{
  if (!a2)
    _Unwind_Resume(exception_object);
  __clang_call_terminate(exception_object);
}

uint64_t __copy_helper_block_e8_32c139_ZTSNSt3__110shared_ptrIZN19QMISMSCommandDriver19storeMsgWaitingInfoEN10subscriber7SimSlotEbhN8dispatch5blockIU13block_pointerFvbEEEE3__1EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c139_ZTSNSt3__110shared_ptrIZN19QMISMSCommandDriver19storeMsgWaitingInfoEN10subscriber7SimSlotEbhN8dispatch5blockIU13block_pointerFvbEEEE3__1EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMISMSCommandDriver::storeMsgWaitingInfo(subscriber::SimSlot,BOOL,unsigned char,dispatch::block<void({block_pointer})(BOOL)>)::$_1,std::allocator<QMISMSCommandDriver::storeMsgWaitingInfo(subscriber::SimSlot,BOOL,unsigned char,dispatch::block<void({block_pointer})(BOOL)>)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C5B98;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMISMSCommandDriver::storeMsgWaitingInfo(subscriber::SimSlot,BOOL,unsigned char,dispatch::block<void({block_pointer})(BOOL)>)::$_1,std::allocator<QMISMSCommandDriver::storeMsgWaitingInfo(subscriber::SimSlot,BOOL,unsigned char,dispatch::block<void({block_pointer})(BOOL)>)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C5B98;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void std::__shared_ptr_emplace<QMISMSCommandDriver::storeMsgWaitingInfo(subscriber::SimSlot,BOOL,unsigned char,dispatch::block<void({block_pointer})(BOOL)>)::$_1,std::allocator<QMISMSCommandDriver::storeMsgWaitingInfo(subscriber::SimSlot,BOOL,unsigned char,dispatch::block<void({block_pointer})(BOOL)>)::$_1>>::__on_zero_shared(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 32);
  if (v1)
    _Block_release(v1);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3wms13SetMsgWaiting8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2168EDF64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<wms::tlv::MemoryStorageIdentification>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::MemoryStorageIdentification>::getSize()
{
  return tlv::size<wms::tlv::MemoryStorageIdentification>();
}

uint64_t *qmi::MutableMessageBase::TlvWrapper<wms::tlv::MemoryStorageIdentification>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t *result;
  uint64_t v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = *a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wms::tlv::MemoryStorageIdentification>(a2, a1 + 12);
  v7 = *a2 - v5;
  *(_BYTE *)v4 = v3;
  *(_WORD *)(v4 + 1) = v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::MemoryStorageIdentification>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C5C28;
  *(_QWORD *)(result + 12) = *(_QWORD *)(a1 + 12);
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<wms::tlv::MessageTag>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::MessageTag>::getSize()
{
  return tlv::size<wms::tlv::MessageTag>();
}

uint64_t *qmi::MutableMessageBase::TlvWrapper<wms::tlv::MessageTag>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t *result;
  uint64_t v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = *a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wms::tlv::MessageTag>(a2, a1 + 12);
  v7 = *a2 - v5;
  *(_BYTE *)v4 = v3;
  *(_WORD *)(v4 + 1) = v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::MessageTag>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C5C78;
  *(_QWORD *)(result + 12) = *(_QWORD *)(a1 + 12);
  *(_DWORD *)(result + 20) = *(_DWORD *)(a1 + 20);
  return result;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN19QMISMSCommandDriver21requestStoredMessagesEN10subscriber7SimSlotERKNSt3__16vectorIN3wms3tlv11MessageInfoENS6_9allocatorISA_EEEENS_3wms14SMSStorageTypeEE3__4EEOS1_OT__block_invoke(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  os_log_t *v6;
  std::__shared_weak_count *v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  uint64_t TlvValue;
  int v11;
  uint64_t v12;
  int v13;
  unint64_t v14;
  NSObject *v15;
  const char *v16;
  NSObject *v17;
  unint64_t *p_shared_owners;
  unint64_t v19;
  NSObject *v20;
  int v21;
  uint64_t v22;
  std::__shared_weak_count *v23;
  std::__shared_weak_count *v24;
  uint64_t v25;
  _QWORD *v26;
  uint64_t v27;
  _QWORD *v28;
  uint64_t v29;
  NSObject *v30;
  unint64_t *v31;
  unint64_t v32;
  uint64_t *v33;
  unint64_t v34;
  _QWORD v35[5];
  std::__shared_weak_count *v36;
  void *__p[2];
  __int128 v38;
  unint64_t v39;
  uint8_t v40[8];
  int v41;
  uint64_t v42;
  _BYTE v43[24];
  _BYTE *v44;
  uint8_t buf[32];
  __int128 v46;
  uint64_t v47;

  v47 = *MEMORY[0x24BDAC8D0];
  v3 = *(uint64_t **)(a1 + 32);
  v4 = *v3;
  v5 = *((unsigned int *)v3 + 10);
  qmi::MutableMessageBase::MutableMessageBase();
  v6 = (os_log_t *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v4 + 88) + 16))(*(_QWORD *)(v4 + 88), v5);
  if (*((_DWORD *)a2 + 1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = 0;
    v7 = *(std::__shared_weak_count **)(v4 + 80);
    if (v7)
    {
      v8 = std::__shared_weak_count::lock(v7);
      *(_QWORD *)&buf[8] = v8;
      if (v8)
      {
        v9 = *(_QWORD *)(v4 + 72);
        *(_QWORD *)buf = v9;
        if (v9)
        {
          (*(void (**)(uint64_t))(*(_QWORD *)v9 + 152))(v9);
LABEL_14:
          p_shared_owners = (unint64_t *)&v8->__shared_owners_;
          do
            v19 = __ldaxr(p_shared_owners);
          while (__stlxr(v19 - 1, p_shared_owners));
          if (!v19)
          {
            ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
            std::__shared_weak_count::__release_weak(v8);
          }
          goto LABEL_18;
        }
      }
    }
    else
    {
      v8 = 0;
    }
    v17 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v40 = 0;
      _os_log_error_impl(&dword_216897000, v17, OS_LOG_TYPE_ERROR, "Failed to get SMS controller", v40, 2u);
      if (v8)
        goto LABEL_14;
    }
    else if (v8)
    {
      goto LABEL_14;
    }
LABEL_18:
    v20 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
    {
      v21 = *((_DWORD *)a2 + 1);
      v22 = qmi::asString();
      *(_DWORD *)buf = 67109378;
      *(_DWORD *)&buf[4] = v21;
      *(_WORD *)&buf[8] = 2080;
      *(_QWORD *)&buf[10] = v22;
      _os_log_error_impl(&dword_216897000, v20, OS_LOG_TYPE_ERROR, "RawReadResponse - (error 0x%x (%s))", buf, 0x12u);
    }
    goto LABEL_20;
  }
  v35[4] = 0;
  v36 = 0;
  TlvValue = qmi::MessageBase::findTlvValue(a2);
  v12 = TlvValue;
  if (TlvValue)
  {
    v13 = v11;
    v39 = TlvValue;
    *(_OWORD *)__p = 0u;
    v38 = 0u;
    tlv::parseV<wms::tlv::RawMessage>(&v39, v11, __p);
    v14 = v39;
    if (v39)
    {
      v15 = *v6;
      if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
      {
        v16 = qmi::wms::asString(BYTE4(__p[0]));
        *(_DWORD *)buf = 136315138;
        *(_QWORD *)&buf[4] = v16;
        _os_log_impl(&dword_216897000, v15, OS_LOG_TYPE_DEFAULT, "#I RawReadResponse - received message with format %s", buf, 0xCu);
      }
      v23 = *(std::__shared_weak_count **)(v4 + 80);
      if (v23)
      {
        v24 = std::__shared_weak_count::lock(v23);
        if (v24)
        {
          v25 = *(_QWORD *)(v4 + 72);
          if (v25)
          {
            v46 = 0u;
            memset(buf, 0, sizeof(buf));
            sms::MTSmsDetails::MTSmsDetails();
            *(_QWORD *)v40 = v4;
            v41 = v5;
            qmi::MutableMessageBase::MutableMessageBase();
            v44 = 0;
            v26 = operator new(0x38uLL);
            v27 = *(_QWORD *)v40;
            *v26 = &off_24D5C5D58;
            v26[1] = v27;
            *((_DWORD *)v26 + 4) = v41;
            qmi::MutableMessageBase::MutableMessageBase();
            v44 = v26;
            (*(void (**)(uint64_t, uint8_t *, _BYTE *))(*(_QWORD *)v25 + 32))(v25, buf, v43);
            v28 = v44;
            if (v44 == v43)
            {
              v29 = 4;
              v28 = v43;
            }
            else
            {
              if (!v44)
              {
LABEL_35:
                qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&v42);
                sms::MTSmsDetails::~MTSmsDetails((sms::MTSmsDetails *)buf);
                goto LABEL_36;
              }
              v29 = 5;
            }
            (*(void (**)(void))(*v28 + 8 * v29))();
            goto LABEL_35;
          }
        }
      }
      else
      {
        v24 = 0;
      }
      v30 = *v6;
      if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_216897000, v30, OS_LOG_TYPE_ERROR, "Failed to get Sms controller...", buf, 2u);
        if (v24)
          goto LABEL_36;
      }
      else if (v24)
      {
LABEL_36:
        v31 = (unint64_t *)&v24->__shared_owners_;
        do
          v32 = __ldaxr(v31);
        while (__stlxr(v32 - 1, v31));
        if (!v32)
        {
          ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
          std::__shared_weak_count::__release_weak(v24);
        }
      }
    }
    if (__p[1])
    {
      *(void **)&v38 = __p[1];
      operator delete(__p[1]);
    }
    if (!v14)
      ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 1, v12, v13);
  }
  if (v36)
  {
    v33 = &v36->__shared_owners_;
    do
      v34 = __ldaxr((unint64_t *)v33);
    while (__stlxr(v34 - 1, (unint64_t *)v33));
    if (!v34)
    {
      ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
      std::__shared_weak_count::__release_weak(v36);
    }
  }
LABEL_20:
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v35);
}

void sub_2168EE5B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,char *a30)
{
  std::__shared_weak_count *v30;
  qmi::MutableMessageBase *v31;
  char *v32;
  uint64_t v33;
  char *v35;
  uint64_t v36;
  unint64_t *p_shared_owners;
  unint64_t v38;

  v35 = a30;
  if (a30 == v32)
  {
    v36 = 4;
    v35 = &a27;
  }
  else
  {
    if (!a30)
    {
LABEL_6:
      qmi::MutableMessageBase::~MutableMessageBase(v31);
      sms::MTSmsDetails::~MTSmsDetails((sms::MTSmsDetails *)(v33 - 160));
      p_shared_owners = (unint64_t *)&v30->__shared_owners_;
      do
        v38 = __ldaxr(p_shared_owners);
      while (__stlxr(v38 - 1, p_shared_owners));
      if (!v38)
      {
        ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
        std::__shared_weak_count::__release_weak(v30);
      }
      if (__p)
      {
        a17 = (uint64_t)__p;
        operator delete(__p);
      }
      std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
      qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a9);
      _Unwind_Resume(a1);
    }
    v36 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v35 + 8 * v36))();
  goto LABEL_6;
}

uint64_t __copy_helper_block_e8_32c183_ZTSNSt3__110shared_ptrIZN19QMISMSCommandDriver21requestStoredMessagesEN10subscriber7SimSlotERKNS_6vectorIN3wms3tlv11MessageInfoENS_9allocatorIS7_EEEEN3qmi3wms14SMSStorageTypeEE3__4EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c183_ZTSNSt3__110shared_ptrIZN19QMISMSCommandDriver21requestStoredMessagesEN10subscriber7SimSlotERKNS_6vectorIN3wms3tlv11MessageInfoENS_9allocatorIS7_EEEEN3qmi3wms14SMSStorageTypeEE3__4EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMISMSCommandDriver::requestStoredMessages(subscriber::SimSlot,std::vector<wms::tlv::MessageInfo> const&,qmi::wms::SMSStorageType)::$_4,std::allocator<QMISMSCommandDriver::requestStoredMessages(subscriber::SimSlot,std::vector<wms::tlv::MessageInfo> const&,qmi::wms::SMSStorageType)::$_4>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C5CE0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMISMSCommandDriver::requestStoredMessages(subscriber::SimSlot,std::vector<wms::tlv::MessageInfo> const&,qmi::wms::SMSStorageType)::$_4,std::allocator<QMISMSCommandDriver::requestStoredMessages(subscriber::SimSlot,std::vector<wms::tlv::MessageInfo> const&,qmi::wms::SMSStorageType)::$_4>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C5CE0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void std::__shared_ptr_emplace<QMISMSCommandDriver::requestStoredMessages(subscriber::SimSlot,std::vector<wms::tlv::MessageInfo> const&,qmi::wms::SMSStorageType)::$_4,std::allocator<QMISMSCommandDriver::requestStoredMessages(subscriber::SimSlot,std::vector<wms::tlv::MessageInfo> const&,qmi::wms::SMSStorageType)::$_4>>::__on_zero_shared(uint64_t a1)
{
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)(a1 + 32));
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3wms7RawRead8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2168EE7C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

_QWORD *std::__function::__func<QMISMSCommandDriver::handleRawReadResponse(subscriber::SimSlot,wms::ModifyTag::Request,wms::RawRead::Response const&)::$_0::operator() const(wms::tlv::RawMessage const&)::{lambda(sms::MsgPduProcessStatus,std::shared_ptr<sms::Model>)#1},std::allocator<QMISMSCommandDriver::handleRawReadResponse(subscriber::SimSlot,wms::ModifyTag::Request,wms::RawRead::Response const&)::$_0::operator() const(wms::tlv::RawMessage const&)::{lambda(sms::MsgPduProcessStatus,std::shared_ptr<sms::Model>)#1}>,void ()(sms::MsgPduProcessStatus,std::shared_ptr<sms::Model>)>::~__func(_QWORD *a1)
{
  *a1 = &off_24D5C5D58;
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)(a1 + 3));
  return a1;
}

void std::__function::__func<QMISMSCommandDriver::handleRawReadResponse(subscriber::SimSlot,wms::ModifyTag::Request,wms::RawRead::Response const&)::$_0::operator() const(wms::tlv::RawMessage const&)::{lambda(sms::MsgPduProcessStatus,std::shared_ptr<sms::Model>)#1},std::allocator<QMISMSCommandDriver::handleRawReadResponse(subscriber::SimSlot,wms::ModifyTag::Request,wms::RawRead::Response const&)::$_0::operator() const(wms::tlv::RawMessage const&)::{lambda(sms::MsgPduProcessStatus,std::shared_ptr<sms::Model>)#1}>,void ()(sms::MsgPduProcessStatus,std::shared_ptr<sms::Model>)>::~__func(_QWORD *a1)
{
  *a1 = &off_24D5C5D58;
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)(a1 + 3));
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<QMISMSCommandDriver::handleRawReadResponse(subscriber::SimSlot,wms::ModifyTag::Request,wms::RawRead::Response const&)::$_0::operator() const(wms::tlv::RawMessage const&)::{lambda(sms::MsgPduProcessStatus,std::shared_ptr<sms::Model>)#1},std::allocator<QMISMSCommandDriver::handleRawReadResponse(subscriber::SimSlot,wms::ModifyTag::Request,wms::RawRead::Response const&)::$_0::operator() const(wms::tlv::RawMessage const&)::{lambda(sms::MsgPduProcessStatus,std::shared_ptr<sms::Model>)#1}>,void ()(sms::MsgPduProcessStatus,std::shared_ptr<sms::Model>)>::__clone(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;

  v2 = operator new(0x38uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *v2 = &off_24D5C5D58;
  v2[1] = v3;
  *((_DWORD *)v2 + 4) = *(_DWORD *)(a1 + 16);
  qmi::MutableMessageBase::MutableMessageBase();
  return v2;
}

void sub_2168EE8C4(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<QMISMSCommandDriver::handleRawReadResponse(subscriber::SimSlot,wms::ModifyTag::Request,wms::RawRead::Response const&)::$_0::operator() const(wms::tlv::RawMessage const&)::{lambda(sms::MsgPduProcessStatus,std::shared_ptr<sms::Model>)#1},std::allocator<QMISMSCommandDriver::handleRawReadResponse(subscriber::SimSlot,wms::ModifyTag::Request,wms::RawRead::Response const&)::$_0::operator() const(wms::tlv::RawMessage const&)::{lambda(sms::MsgPduProcessStatus,std::shared_ptr<sms::Model>)#1}>,void ()(sms::MsgPduProcessStatus,std::shared_ptr<sms::Model>)>::__clone(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  *(_QWORD *)a2 = &off_24D5C5D58;
  v2 = *(_QWORD *)(a1 + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(a1 + 16);
  *(_QWORD *)(a2 + 8) = v2;
  return qmi::MutableMessageBase::MutableMessageBase();
}

void std::__function::__func<QMISMSCommandDriver::handleRawReadResponse(subscriber::SimSlot,wms::ModifyTag::Request,wms::RawRead::Response const&)::$_0::operator() const(wms::tlv::RawMessage const&)::{lambda(sms::MsgPduProcessStatus,std::shared_ptr<sms::Model>)#1},std::allocator<QMISMSCommandDriver::handleRawReadResponse(subscriber::SimSlot,wms::ModifyTag::Request,wms::RawRead::Response const&)::$_0::operator() const(wms::tlv::RawMessage const&)::{lambda(sms::MsgPduProcessStatus,std::shared_ptr<sms::Model>)#1}>,void ()(sms::MsgPduProcessStatus,std::shared_ptr<sms::Model>)>::destroy(uint64_t a1)
{
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)(a1 + 24));
}

void std::__function::__func<QMISMSCommandDriver::handleRawReadResponse(subscriber::SimSlot,wms::ModifyTag::Request,wms::RawRead::Response const&)::$_0::operator() const(wms::tlv::RawMessage const&)::{lambda(sms::MsgPduProcessStatus,std::shared_ptr<sms::Model>)#1},std::allocator<QMISMSCommandDriver::handleRawReadResponse(subscriber::SimSlot,wms::ModifyTag::Request,wms::RawRead::Response const&)::$_0::operator() const(wms::tlv::RawMessage const&)::{lambda(sms::MsgPduProcessStatus,std::shared_ptr<sms::Model>)#1}>,void ()(sms::MsgPduProcessStatus,std::shared_ptr<sms::Model>)>::destroy_deallocate(uint64_t a1)
{
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)(a1 + 24));
  operator delete((void *)a1);
}

void std::__function::__func<QMISMSCommandDriver::handleRawReadResponse(subscriber::SimSlot,wms::ModifyTag::Request,wms::RawRead::Response const&)::$_0::operator() const(wms::tlv::RawMessage const&)::{lambda(sms::MsgPduProcessStatus,std::shared_ptr<sms::Model>)#1},std::allocator<QMISMSCommandDriver::handleRawReadResponse(subscriber::SimSlot,wms::ModifyTag::Request,wms::RawRead::Response const&)::$_0::operator() const(wms::tlv::RawMessage const&)::{lambda(sms::MsgPduProcessStatus,std::shared_ptr<sms::Model>)#1}>,void ()(sms::MsgPduProcessStatus,std::shared_ptr<sms::Model>)>::operator()(uint64_t a1, int *a2, _QWORD *a3)
{
  int v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count_vtbl *v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  uint64_t v12;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t *v21;
  unint64_t v22;
  _DWORD v23[10];
  uint64_t v24;
  _QWORD v25[5];
  std::__shared_weak_count *v26;
  int v27;
  _QWORD *v28;
  std::__shared_weak_count *v29;
  _QWORD aBlock[5];

  v3 = *a2;
  v4 = (std::__shared_weak_count *)a3[1];
  *a3 = 0;
  a3[1] = 0;
  if (v3 == 4)
  {
    v5 = *(std::__shared_weak_count_vtbl **)(a1 + 8);
    v6 = *(_DWORD *)(a1 + 16);
    qmi::MutableMessageBase::MutableMessageBase();
    if ((v6 - 1) >= 3)
      v7 = 0;
    else
      v7 = v6;
    v8 = qmi::ClientRouter::get();
    v23[8] = v7;
    v9 = operator new();
    *(_QWORD *)v9 = v8;
    *(_QWORD *)(v9 + 8) = QMIServiceMsg::create();
    *(_DWORD *)(v9 + 16) = 25000;
    *(_QWORD *)(v9 + 24) = 0;
    *(_QWORD *)(v9 + 32) = 0;
    v24 = v9;
    v10 = (std::__shared_weak_count *)operator new(0x20uLL);
    v10->__shared_owners_ = 0;
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    v10->__shared_weak_owners_ = 0;
    v10->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C5E18;
    v10[1].__vftable = v5;
    v28 = &v10[1].__vftable;
    v29 = v10;
    v12 = MEMORY[0x24BDAC760];
    v25[0] = MEMORY[0x24BDAC760];
    v25[1] = 1174405120;
    v25[2] = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN19QMISMSCommandDriver19modifyStoredMessageEN10subscriber7SimSlotEN3wms9ModifyTag7RequestEE3__0EEOS1_OT__block_invoke;
    v25[3] = &__block_descriptor_tmp_49_0;
    v25[4] = v10 + 1;
    v26 = v10;
    do
      v13 = __ldxr(p_shared_owners);
    while (__stxr(v13 + 1, p_shared_owners));
    v27 = v7;
    aBlock[0] = v12;
    aBlock[1] = 0x40000000;
    aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_1;
    aBlock[3] = &unk_24D5C5E60;
    aBlock[4] = v25;
    *(_QWORD *)(v9 + 32) = _Block_copy(aBlock);
    v14 = v26;
    if (v26)
    {
      v15 = (unint64_t *)&v26->__shared_owners_;
      do
        v16 = __ldaxr(v15);
      while (__stlxr(v16 - 1, v15));
      if (!v16)
      {
        ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
        std::__shared_weak_count::__release_weak(v14);
      }
    }
    v17 = v29;
    if (v29)
    {
      v18 = (unint64_t *)&v29->__shared_owners_;
      do
        v19 = __ldaxr(v18);
      while (__stlxr(v19 - 1, v18));
      if (!v19)
      {
        ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
        std::__shared_weak_count::__release_weak(v17);
      }
    }
    v20 = v24;
    v24 = 0;
    if (v20)
      std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v24, v20);
    qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v23);
  }
  if (v4)
  {
    v21 = (unint64_t *)&v4->__shared_owners_;
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

void sub_2168EEB60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22)
{
  std::__shared_weak_count *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v26;
  unint64_t *p_shared_owners;
  unint64_t v28;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v24);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a22);
  v26 = a14;
  a14 = 0;
  if (v26)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v23, v26);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a9);
  if (v22)
  {
    p_shared_owners = (unint64_t *)&v22->__shared_owners_;
    do
      v28 = __ldaxr(p_shared_owners);
    while (__stlxr(v28 - 1, p_shared_owners));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
  }
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<QMISMSCommandDriver::handleRawReadResponse(subscriber::SimSlot,wms::ModifyTag::Request,wms::RawRead::Response const&)::$_0::operator() const(wms::tlv::RawMessage const&)::{lambda(sms::MsgPduProcessStatus,std::shared_ptr<sms::Model>)#1},std::allocator<QMISMSCommandDriver::handleRawReadResponse(subscriber::SimSlot,wms::ModifyTag::Request,wms::RawRead::Response const&)::$_0::operator() const(wms::tlv::RawMessage const&)::{lambda(sms::MsgPduProcessStatus,std::shared_ptr<sms::Model>)#1}>,void ()(sms::MsgPduProcessStatus,std::shared_ptr<sms::Model>)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<QMISMSCommandDriver::handleRawReadResponse(subscriber::SimSlot,wms::ModifyTag::Request,wms::RawRead::Response const&)::$_0::operator() const(wms::tlv::RawMessage const&)::{lambda(sms::MsgPduProcessStatus,std::shared_ptr<sms::Model>)#1},std::allocator<QMISMSCommandDriver::handleRawReadResponse(subscriber::SimSlot,wms::ModifyTag::Request,wms::RawRead::Response const&)::$_0::operator() const(wms::tlv::RawMessage const&)::{lambda(sms::MsgPduProcessStatus,std::shared_ptr<sms::Model>)#1}>,void ()(sms::MsgPduProcessStatus,std::shared_ptr<sms::Model>)>::target_type()
{
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN19QMISMSCommandDriver19modifyStoredMessageEN10subscriber7SimSlotEN3wms9ModifyTag7RequestEE3__0EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  uint64_t v3;
  uint64_t v4;
  NSObject *v5;
  uint8_t v6[16];

  if (*(_DWORD *)(a2 + 4))
  {
    v2 = *(_DWORD *)(a1 + 48);
    if (v2 - 1 >= 3)
      v3 = 0;
    else
      v3 = v2;
    v4 = *(_QWORD *)(**(_QWORD **)(a1 + 32) + 88);
    v5 = *(NSObject **)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v4 + 16))(v4, v3);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v6 = 0;
      _os_log_error_impl(&dword_216897000, v5, OS_LOG_TYPE_ERROR, "There was an error modifying the stored message", v6, 2u);
    }
  }
}

uint64_t __copy_helper_block_e8_32c122_ZTSNSt3__110shared_ptrIZN19QMISMSCommandDriver19modifyStoredMessageEN10subscriber7SimSlotEN3wms9ModifyTag7RequestEE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c122_ZTSNSt3__110shared_ptrIZN19QMISMSCommandDriver19modifyStoredMessageEN10subscriber7SimSlotEN3wms9ModifyTag7RequestEE3__0EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMISMSCommandDriver::modifyStoredMessage(subscriber::SimSlot,wms::ModifyTag::Request)::$_0,std::allocator<QMISMSCommandDriver::modifyStoredMessage(subscriber::SimSlot,wms::ModifyTag::Request)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C5E18;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMISMSCommandDriver::modifyStoredMessage(subscriber::SimSlot,wms::ModifyTag::Request)::$_0,std::allocator<QMISMSCommandDriver::modifyStoredMessage(subscriber::SimSlot,wms::ModifyTag::Request)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C5E18;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void qmi::MutableMessageBase::TlvWrapper<wms::tlv::ReportMTMessage>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::ReportMTMessage>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<wms::tlv::ReportMTMessage>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::IPPref>((_BYTE **)a2, (_DWORD *)(a1 + 12));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::ReportMTMessage>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C5EA8;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a1 + 12);
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<wms::tlv::ReportMwiMessage>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::ReportMwiMessage>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<wms::tlv::ReportMwiMessage>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::IPPref>((_BYTE **)a2, (_DWORD *)(a1 + 12));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::ReportMwiMessage>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C5EF8;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a1 + 12);
  return result;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN19QMISMSCommandDriver14setEventReportENS_16SubscriptionTypeEE3__2EEOS1_OT__block_invoke(uint64_t a1, _QWORD *a2)
{
  uint64_t *v2;
  unsigned int v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  _QWORD v11[3];
  uint8_t buf[4];
  int v13;
  __int16 v14;
  uint64_t v15;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  v2 = *(uint64_t **)(a1 + 32);
  v3 = *(_DWORD *)(a1 + 48);
  v4 = a2[1];
  v11[0] = *a2;
  v11[1] = v4;
  v5 = a2[2];
  v11[2] = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  v8 = *v2;
  if (v3 - 1 >= 3)
    v9 = 0;
  else
    v9 = v3;
  v10 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v8 + 88) + 16))(*(_QWORD *)(v8 + 88), v9);
  if (HIDWORD(v11[0]))
  {
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109378;
      v13 = HIDWORD(v11[0]);
      v14 = 2080;
      v15 = qmi::asString();
      _os_log_error_impl(&dword_216897000, v10, OS_LOG_TYPE_ERROR, "QMI_WMS_SET_EVENT_REPORT response failure (error: 0x%x (%s))", buf, 0x12u);
    }
  }
  else if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_216897000, v10, OS_LOG_TYPE_DEFAULT, "#I Event reports successfully enabled", buf, 2u);
  }
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v11);
}

void sub_2168EF028(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_32c95_ZTSNSt3__110shared_ptrIZN19QMISMSCommandDriver14setEventReportEN3qmi16SubscriptionTypeEE3__2EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c95_ZTSNSt3__110shared_ptrIZN19QMISMSCommandDriver14setEventReportEN3qmi16SubscriptionTypeEE3__2EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMISMSCommandDriver::setEventReport(qmi::SubscriptionType)::$_2,std::allocator<QMISMSCommandDriver::setEventReport(qmi::SubscriptionType)::$_2>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C5F60;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMISMSCommandDriver::setEventReport(qmi::SubscriptionType)::$_2,std::allocator<QMISMSCommandDriver::setEventReport(qmi::SubscriptionType)::$_2>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C5F60;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void ___ZNO3qmi6Client9SendProxy8callbackIN3wms14SetEventReport8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2168EF16C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<wms::tlv::DcDisconnectTimer>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::DcDisconnectTimer>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

_DWORD **qmi::MutableMessageBase::TlvWrapper<wms::tlv::DcDisconnectTimer>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _DWORD *v4;
  uint64_t v5;
  _DWORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_DWORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::PktDataHandle>((_DWORD **)a2, (_DWORD *)(a1 + 12));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::DcDisconnectTimer>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C5FF0;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a1 + 12);
  return result;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN19QMISMSCommandDriver20setDCDisconnectTimerENS_16SubscriptionTypeEjE3__1EEOS1_OT__block_invoke(uint64_t a1, _QWORD *a2)
{
  uint64_t *v2;
  unsigned int v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  _QWORD v11[3];
  uint8_t buf[4];
  int v13;
  __int16 v14;
  uint64_t v15;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  v2 = *(uint64_t **)(a1 + 32);
  v3 = *(_DWORD *)(a1 + 48);
  v4 = a2[1];
  v11[0] = *a2;
  v11[1] = v4;
  v5 = a2[2];
  v11[2] = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  v8 = *v2;
  if (v3 - 1 >= 3)
    v9 = 0;
  else
    v9 = v3;
  v10 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v8 + 88) + 16))(*(_QWORD *)(v8 + 88), v9);
  if (HIDWORD(v11[0]))
  {
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109378;
      v13 = HIDWORD(v11[0]);
      v14 = 2080;
      v15 = qmi::asString();
      _os_log_error_impl(&dword_216897000, v10, OS_LOG_TYPE_ERROR, "Setting DC disconnect timer failed (error: 0x%x (%s))", buf, 0x12u);
    }
  }
  else if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_216897000, v10, OS_LOG_TYPE_DEFAULT, "#I DCDisconnectTimer set successfully", buf, 2u);
  }
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v11);
}

void sub_2168EF3B4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_32c102_ZTSNSt3__110shared_ptrIZN19QMISMSCommandDriver20setDCDisconnectTimerEN3qmi16SubscriptionTypeEjE3__1EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c102_ZTSNSt3__110shared_ptrIZN19QMISMSCommandDriver20setDCDisconnectTimerEN3qmi16SubscriptionTypeEjE3__1EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMISMSCommandDriver::setDCDisconnectTimer(qmi::SubscriptionType,unsigned int)::$_1,std::allocator<QMISMSCommandDriver::setDCDisconnectTimer(qmi::SubscriptionType,unsigned int)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C6058;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMISMSCommandDriver::setDCDisconnectTimer(qmi::SubscriptionType,unsigned int)::$_1,std::allocator<QMISMSCommandDriver::setDCDisconnectTimer(qmi::SubscriptionType,unsigned int)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C6058;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void ___ZNO3qmi6Client9SendProxy8callbackIN3wms20SetDcDisconnectTimer8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2168EF4F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

_QWORD *qmi::MutableMessageBase::TlvWrapper<wms::tlv::Routes>::~TlvWrapper(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24D5C60E8;
  v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<wms::tlv::Routes>::~TlvWrapper(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24D5C60E8;
  v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  JUMPOUT(0x2199FEAC4);
}

unint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::Routes>::getSize(uint64_t a1)
{
  return tlv::size<wms::tlv::Routes>((_QWORD *)(a1 + 16));
}

_BYTE *qmi::MutableMessageBase::TlvWrapper<wms::tlv::Routes>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _WORD *v4;
  uint64_t v5;
  _BYTE *result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_WORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wms::tlv::Routes>((_WORD **)a2, (_DWORD *)(a1 + 16));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::Routes>::clone(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  _BYTE *v4;
  _BYTE *v5;
  int64_t v6;
  char *v7;

  v2 = operator new();
  v3 = v2;
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)(v2 + 16) = 0;
  *(_QWORD *)v2 = &off_24D5C60E8;
  *(_QWORD *)(v2 + 24) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  v5 = *(_BYTE **)(a1 + 16);
  v4 = *(_BYTE **)(a1 + 24);
  v6 = v4 - v5;
  if (v4 != v5)
  {
    std::vector<wms::tlv::Route>::__vallocate[abi:ne180100]((_QWORD *)(v2 + 16), v6 >> 4);
    v7 = *(char **)(v3 + 24);
    memmove(v7, v5, v6);
    *(_QWORD *)(v3 + 24) = &v7[16 * (v6 >> 4)];
  }
  return v3;
}

void sub_2168EF6C4(_Unwind_Exception *a1)
{
  uint64_t v1;
  void **v2;
  void *v4;

  v4 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 24) = v4;
    operator delete(v4);
  }
  MEMORY[0x2199FEAC4](v1, 0x10A1C403082B835);
  _Unwind_Resume(a1);
}

char *std::vector<wms::tlv::Route>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 60)
    std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::array<unsigned char,16ul>>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[16 * v4];
  return result;
}

_QWORD *std::string::basic_string[abi:ne180100](_QWORD *__dst, void *__src, size_t __len)
{
  void *v6;
  size_t v7;
  size_t v8;

  if (__len >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  if (__len >= 0x17)
  {
    v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17)
      v7 = __len | 7;
    v8 = v7 + 1;
    v6 = operator new(v7 + 1);
    __dst[1] = __len;
    __dst[2] = v8 | 0x8000000000000000;
    *__dst = v6;
  }
  else
  {
    *((_BYTE *)__dst + 23) = __len;
    v6 = __dst;
    if (!__len)
      goto LABEL_9;
  }
  memmove(v6, __src, __len);
LABEL_9:
  *((_BYTE *)v6 + __len) = 0;
  return __dst;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN19QMISMSCommandDriver9setRoutesENS_16SubscriptionTypeEE3__1EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unsigned int v4;
  uint64_t v5;
  NSObject *v6;
  int v7;
  NSObject *v8;
  _DWORD v9[2];
  __int16 v10;
  uint64_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v2 = **(_QWORD **)(a1 + 32);
  if (*(_DWORD *)(a2 + 4))
  {
    v4 = *(_DWORD *)(a1 + 48);
    if (v4 - 1 >= 3)
      v5 = 0;
    else
      v5 = v4;
    v6 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v2 + 88) + 16))(*(_QWORD *)(v2 + 88), v5);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      v7 = *(_DWORD *)(a2 + 4);
      v9[0] = 67109378;
      v9[1] = v7;
      v10 = 2080;
      v11 = qmi::asString();
      _os_log_error_impl(&dword_216897000, v6, OS_LOG_TYPE_ERROR, "Routes were not set successfully (error 0x%x (%s))", (uint8_t *)v9, 0x12u);
    }
  }
  else
  {
    v8 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v9[0]) = 0;
      _os_log_impl(&dword_216897000, v8, OS_LOG_TYPE_DEFAULT, "#I Routes set successfully", (uint8_t *)v9, 2u);
    }
  }
}

uint64_t __copy_helper_block_e8_32c89_ZTSNSt3__110shared_ptrIZN19QMISMSCommandDriver9setRoutesEN3qmi16SubscriptionTypeEE3__1EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c89_ZTSNSt3__110shared_ptrIZN19QMISMSCommandDriver9setRoutesEN3qmi16SubscriptionTypeEE3__1EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMISMSCommandDriver::setRoutes(qmi::SubscriptionType)::$_1,std::allocator<QMISMSCommandDriver::setRoutes(qmi::SubscriptionType)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C6150;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMISMSCommandDriver::setRoutes(qmi::SubscriptionType)::$_1,std::allocator<QMISMSCommandDriver::setRoutes(qmi::SubscriptionType)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C6150;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void qmi::MutableMessageBase::TlvWrapper<wms::tlv::RetryInterval>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::RetryInterval>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

_DWORD **qmi::MutableMessageBase::TlvWrapper<wms::tlv::RetryInterval>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _DWORD *v4;
  uint64_t v5;
  _DWORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_DWORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::PktDataHandle>((_DWORD **)a2, (_DWORD *)(a1 + 12));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::RetryInterval>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C61B8;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a1 + 12);
  return result;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN19QMISMSCommandDriver16setRetryIntervalENS_16SubscriptionTypeEjE3__1EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  unsigned int v3;
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  int v7;
  _DWORD v8[2];
  __int16 v9;
  uint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)(a2 + 4))
  {
    v3 = *(_DWORD *)(a1 + 48);
    if (v3 - 1 >= 3)
      v4 = 0;
    else
      v4 = v3;
    v5 = *(_QWORD *)(**(_QWORD **)(a1 + 32) + 88);
    v6 = *(NSObject **)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v5 + 16))(v5, v4);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      v7 = *(_DWORD *)(a2 + 4);
      v8[0] = 67109378;
      v8[1] = v7;
      v9 = 2080;
      v10 = qmi::asString();
      _os_log_error_impl(&dword_216897000, v6, OS_LOG_TYPE_ERROR, "SetRetryInterval response failure (error: 0x%x (%s))", (uint8_t *)v8, 0x12u);
    }
  }
}

uint64_t __copy_helper_block_e8_32c98_ZTSNSt3__110shared_ptrIZN19QMISMSCommandDriver16setRetryIntervalEN3qmi16SubscriptionTypeEjE3__1EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c98_ZTSNSt3__110shared_ptrIZN19QMISMSCommandDriver16setRetryIntervalEN3qmi16SubscriptionTypeEjE3__1EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMISMSCommandDriver::setRetryInterval(qmi::SubscriptionType,unsigned int)::$_1,std::allocator<QMISMSCommandDriver::setRetryInterval(qmi::SubscriptionType,unsigned int)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C6220;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMISMSCommandDriver::setRetryInterval(qmi::SubscriptionType,unsigned int)::$_1,std::allocator<QMISMSCommandDriver::setRetryInterval(qmi::SubscriptionType,unsigned int)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C6220;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void qmi::MutableMessageBase::TlvWrapper<wms::tlv::RetryPeriod>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::RetryPeriod>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

_DWORD **qmi::MutableMessageBase::TlvWrapper<wms::tlv::RetryPeriod>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _DWORD *v4;
  uint64_t v5;
  _DWORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_DWORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::PktDataHandle>((_DWORD **)a2, (_DWORD *)(a1 + 12));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::RetryPeriod>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C6288;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a1 + 12);
  return result;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN19QMISMSCommandDriver14setRetryPeriodENS_16SubscriptionTypeEjE3__1EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  unsigned int v3;
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  int v7;
  _DWORD v8[2];
  __int16 v9;
  uint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)(a2 + 4))
  {
    v3 = *(_DWORD *)(a1 + 48);
    if (v3 - 1 >= 3)
      v4 = 0;
    else
      v4 = v3;
    v5 = *(_QWORD *)(**(_QWORD **)(a1 + 32) + 88);
    v6 = *(NSObject **)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v5 + 16))(v5, v4);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      v7 = *(_DWORD *)(a2 + 4);
      v8[0] = 67109378;
      v8[1] = v7;
      v9 = 2080;
      v10 = qmi::asString();
      _os_log_error_impl(&dword_216897000, v6, OS_LOG_TYPE_ERROR, "SetRetryPeriod response failure (error: 0x%x (%s))", (uint8_t *)v8, 0x12u);
    }
  }
}

uint64_t __copy_helper_block_e8_32c96_ZTSNSt3__110shared_ptrIZN19QMISMSCommandDriver14setRetryPeriodEN3qmi16SubscriptionTypeEjE3__1EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c96_ZTSNSt3__110shared_ptrIZN19QMISMSCommandDriver14setRetryPeriodEN3qmi16SubscriptionTypeEjE3__1EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMISMSCommandDriver::setRetryPeriod(qmi::SubscriptionType,unsigned int)::$_1,std::allocator<QMISMSCommandDriver::setRetryPeriod(qmi::SubscriptionType,unsigned int)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C62F0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMISMSCommandDriver::setRetryPeriod(qmi::SubscriptionType,unsigned int)::$_1,std::allocator<QMISMSCommandDriver::setRetryPeriod(qmi::SubscriptionType,unsigned int)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C62F0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMISMSCommandDriver::registerForServiceReadyInd(qmi::SubscriptionType)::$_0>(unsigned short,QMISMSCommandDriver::registerForServiceReadyInd(qmi::SubscriptionType)::$_0 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMISMSCommandDriver::registerForServiceReadyInd(qmi::SubscriptionType)::$_0>(unsigned short,QMISMSCommandDriver::registerForServiceReadyInd(qmi::SubscriptionType)::$_0 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5C6340;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMISMSCommandDriver::registerForServiceReadyInd(qmi::SubscriptionType)::$_0>(unsigned short,QMISMSCommandDriver::registerForServiceReadyInd(qmi::SubscriptionType)::$_0 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5C6340;
  a2[1] = v2;
  return result;
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMISMSCommandDriver::registerForServiceReadyInd(qmi::SubscriptionType)::$_0>(unsigned short,QMISMSCommandDriver::registerForServiceReadyInd(qmi::SubscriptionType)::$_0 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::operator()(uint64_t a1, _DWORD *a2, QMIServiceMsg *this)
{
  uint64_t v4;
  uint64_t v6;
  os_log_t *v7;
  os_log_t *v8;
  int v9;
  NSObject *v10;
  uint64_t TlvValue;
  int v12;
  uint64_t v13;
  int v14;
  unsigned int ready;
  unsigned int v16;
  std::__shared_weak_count *v17;
  std::__shared_weak_count *v18;
  uint64_t v19;
  unsigned __int8 v20;
  unint64_t *p_shared_owners;
  unint64_t v22;
  NSObject *v23;
  const char *v24;
  NSObject *v25;
  unint64_t *v26;
  unint64_t v27;
  void *v28;
  _WORD v29[2];
  int v30;
  uint64_t v31;
  void *__p[4];

  __p[3] = *(void **)MEMORY[0x24BDAC8D0];
  LODWORD(v4) = *a2;
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    memset(__p, 0, 24);
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v29, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v29);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v29);
  }
  v6 = *(_QWORD *)(a1 + 8);
  if ((v4 - 1) >= 3)
    v4 = 0;
  else
    v4 = v4;
  v7 = (os_log_t *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v6 + 88) + 16))(*(_QWORD *)(v6 + 88), v4);
  v8 = v7;
  v9 = v30;
  if (v30)
  {
    v10 = *v7;
    if (os_log_type_enabled(*v7, OS_LOG_TYPE_ERROR))
    {
      v28 = (void *)qmi::asString();
      LODWORD(__p[0]) = 67109378;
      HIDWORD(__p[0]) = v9;
      LOWORD(__p[1]) = 2080;
      *(void **)((char *)&__p[1] + 2) = v28;
      _os_log_error_impl(&dword_216897000, v10, OS_LOG_TYPE_ERROR, "ServiceReadyInd - (error 0x%x (%s))", (uint8_t *)__p, 0x12u);
    }
    goto LABEL_14;
  }
  TlvValue = qmi::MessageBase::findTlvValue((qmi::MessageBase *)v29);
  v13 = TlvValue;
  if (!TlvValue)
    goto LABEL_14;
  v14 = v12;
  v31 = TlvValue;
  ready = tlv::parseV<wms::tlv::ReadyStatus>((unint64_t *)&v31, v12);
  if (!v31)
  {
    ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(v29[0], 1, v13, v14);
    goto LABEL_14;
  }
  v16 = ready;
  v17 = *(std::__shared_weak_count **)(v6 + 80);
  if (v17)
  {
    v18 = std::__shared_weak_count::lock(v17);
    if (v18)
    {
      v19 = *(_QWORD *)(v6 + 72);
      if (v19)
      {
        if (v16 >= 4)
          v20 = 0;
        else
          v20 = v16;
        (*(void (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)v19 + 80))(v19, v4, v20);
        p_shared_owners = (unint64_t *)&v18->__shared_owners_;
        do
          v22 = __ldaxr(p_shared_owners);
        while (__stlxr(v22 - 1, p_shared_owners));
        if (!v22)
        {
          ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
          std::__shared_weak_count::__release_weak(v18);
        }
        v23 = *v8;
        if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
        {
          v24 = qmi::wms::asString(v16);
          LODWORD(__p[0]) = 136315138;
          *(void **)((char *)__p + 4) = (void *)v24;
          _os_log_impl(&dword_216897000, v23, OS_LOG_TYPE_DEFAULT, "#I ServiceReadyInd: WMS service status: %s", (uint8_t *)__p, 0xCu);
        }
        goto LABEL_14;
      }
    }
  }
  else
  {
    v18 = 0;
  }
  v25 = *v8;
  if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
  {
    LOWORD(__p[0]) = 0;
    _os_log_error_impl(&dword_216897000, v25, OS_LOG_TYPE_ERROR, "Failed to get Sms controller...", (uint8_t *)__p, 2u);
    if (!v18)
      goto LABEL_14;
  }
  else if (!v18)
  {
    goto LABEL_14;
  }
  v26 = (unint64_t *)&v18->__shared_owners_;
  do
    v27 = __ldaxr(v26);
  while (__stlxr(v27 - 1, v26));
  if (!v27)
  {
    ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
    std::__shared_weak_count::__release_weak(v18);
  }
LABEL_14:
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v29);
}

void sub_2168F0128(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14)
{
  std::__shared_weak_count *v14;
  unint64_t *p_shared_owners;
  unint64_t v17;

  p_shared_owners = (unint64_t *)&v14->__shared_owners_;
  do
    v17 = __ldaxr(p_shared_owners);
  while (__stlxr(v17 - 1, p_shared_owners));
  if (!v17)
  {
    ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
    std::__shared_weak_count::__release_weak(v14);
  }
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMISMSCommandDriver::registerForServiceReadyInd(qmi::SubscriptionType)::$_0>(unsigned short,QMISMSCommandDriver::registerForServiceReadyInd(qmi::SubscriptionType)::$_0 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMISMSCommandDriver::registerForServiceReadyInd(qmi::SubscriptionType)::$_0>(unsigned short,QMISMSCommandDriver::registerForServiceReadyInd(qmi::SubscriptionType)::$_0 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::target_type()
{
}

unint64_t **std::back_insert_iterator<std::vector<unsigned char>>::operator=[abi:ne180100](unint64_t **a1, _BYTE *a2)
{
  unint64_t *v4;
  unint64_t v5;
  _BYTE *v6;
  uint64_t v7;
  unint64_t v8;
  _BYTE *v9;
  unint64_t v10;
  unint64_t v11;
  size_t v12;
  unint64_t v13;
  char *v14;
  _BYTE *v15;
  char v16;

  v4 = *a1;
  v6 = (_BYTE *)(*a1)[1];
  v5 = (*a1)[2];
  if ((unint64_t)v6 >= v5)
  {
    v8 = *v4;
    v9 = &v6[-*v4];
    v10 = (unint64_t)(v9 + 1);
    if ((uint64_t)(v9 + 1) < 0)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v11 = v5 - v8;
    if (2 * v11 > v10)
      v10 = 2 * v11;
    if (v11 >= 0x3FFFFFFFFFFFFFFFLL)
      v12 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v12 = v10;
    if (v12)
      v13 = (unint64_t)operator new(v12);
    else
      v13 = 0;
    v14 = (char *)(v13 + v12);
    v9[v13] = *a2;
    v7 = (uint64_t)&v9[v13 + 1];
    if (v6 == (_BYTE *)v8)
    {
      v13 += (unint64_t)v9;
    }
    else
    {
      v15 = &v6[~v8];
      do
      {
        v16 = *--v6;
        (v15--)[v13] = v16;
      }
      while (v6 != (_BYTE *)v8);
      v6 = (_BYTE *)*v4;
    }
    *v4 = v13;
    v4[1] = v7;
    v4[2] = (unint64_t)v14;
    if (v6)
      operator delete(v6);
  }
  else
  {
    *v6 = *a2;
    v7 = (uint64_t)(v6 + 1);
  }
  v4[1] = v7;
  return a1;
}

_QWORD *std::__function::__func<QMISMSCommandDriver::handleMTMessage(subscriber::SimSlot,wms::tlv::TransferRouteMTMessage const&,BOOL)::$_0,std::allocator<QMISMSCommandDriver::handleMTMessage(subscriber::SimSlot,wms::tlv::TransferRouteMTMessage const&,BOOL)::$_0>,void ()(sms::MsgPduProcessStatus,std::shared_ptr<sms::Model>)>::~__func(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24D5C63C0;
  v2 = (void *)a1[5];
  if (v2)
  {
    a1[6] = v2;
    operator delete(v2);
  }
  return a1;
}

void std::__function::__func<QMISMSCommandDriver::handleMTMessage(subscriber::SimSlot,wms::tlv::TransferRouteMTMessage const&,BOOL)::$_0,std::allocator<QMISMSCommandDriver::handleMTMessage(subscriber::SimSlot,wms::tlv::TransferRouteMTMessage const&,BOOL)::$_0>,void ()(sms::MsgPduProcessStatus,std::shared_ptr<sms::Model>)>::~__func(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24D5C63C0;
  v2 = (void *)a1[5];
  if (v2)
  {
    a1[6] = v2;
    operator delete(v2);
  }
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<QMISMSCommandDriver::handleMTMessage(subscriber::SimSlot,wms::tlv::TransferRouteMTMessage const&,BOOL)::$_0,std::allocator<QMISMSCommandDriver::handleMTMessage(subscriber::SimSlot,wms::tlv::TransferRouteMTMessage const&,BOOL)::$_0>,void ()(sms::MsgPduProcessStatus,std::shared_ptr<sms::Model>)>::__clone(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  const void *v4;
  uint64_t v5;

  v2 = operator new(0x48uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *v2 = &off_24D5C63C0;
  v2[1] = v3;
  *((_DWORD *)v2 + 4) = *(_DWORD *)(a1 + 16);
  v2[3] = *(_QWORD *)(a1 + 24);
  *((_BYTE *)v2 + 32) = *(_BYTE *)(a1 + 32);
  v2[6] = 0;
  v2[7] = 0;
  v4 = *(const void **)(a1 + 40);
  v5 = *(_QWORD *)(a1 + 48);
  v2[5] = 0;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(v2 + 5, v4, v5, v5 - (_QWORD)v4);
  *((_WORD *)v2 + 32) = *(_WORD *)(a1 + 64);
  return v2;
}

void sub_2168F03EC(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__function::__func<QMISMSCommandDriver::handleMTMessage(subscriber::SimSlot,wms::tlv::TransferRouteMTMessage const&,BOOL)::$_0,std::allocator<QMISMSCommandDriver::handleMTMessage(subscriber::SimSlot,wms::tlv::TransferRouteMTMessage const&,BOOL)::$_0>,void ()(sms::MsgPduProcessStatus,std::shared_ptr<sms::Model>)>::__clone(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  char v5;
  uint64_t v6;
  _QWORD *result;

  *(_QWORD *)a2 = &off_24D5C63C0;
  v3 = *(_QWORD *)(a1 + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(a1 + 16);
  *(_QWORD *)(a2 + 8) = v3;
  v4 = *(_QWORD *)(a1 + 24);
  v5 = *(_BYTE *)(a1 + 32);
  *(_QWORD *)(a2 + 40) = 0;
  v6 = a2 + 40;
  *(_BYTE *)(a2 + 32) = v5;
  *(_QWORD *)(a2 + 24) = v4;
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(a2 + 56) = 0;
  result = std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>((_QWORD *)(a2 + 40), *(const void **)(a1 + 40), *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 48) - *(_QWORD *)(a1 + 40));
  *(_WORD *)(v6 + 24) = *(_WORD *)(a1 + 64);
  return result;
}

void std::__function::__func<QMISMSCommandDriver::handleMTMessage(subscriber::SimSlot,wms::tlv::TransferRouteMTMessage const&,BOOL)::$_0,std::allocator<QMISMSCommandDriver::handleMTMessage(subscriber::SimSlot,wms::tlv::TransferRouteMTMessage const&,BOOL)::$_0>,void ()(sms::MsgPduProcessStatus,std::shared_ptr<sms::Model>)>::destroy(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 40);
  if (v2)
  {
    *(_QWORD *)(a1 + 48) = v2;
    operator delete(v2);
  }
}

void std::__function::__func<QMISMSCommandDriver::handleMTMessage(subscriber::SimSlot,wms::tlv::TransferRouteMTMessage const&,BOOL)::$_0,std::allocator<QMISMSCommandDriver::handleMTMessage(subscriber::SimSlot,wms::tlv::TransferRouteMTMessage const&,BOOL)::$_0>,void ()(sms::MsgPduProcessStatus,std::shared_ptr<sms::Model>)>::destroy_deallocate(_QWORD *__p)
{
  void *v2;

  v2 = (void *)__p[5];
  if (v2)
  {
    __p[6] = v2;
    operator delete(v2);
  }
  operator delete(__p);
}

void std::__function::__func<QMISMSCommandDriver::handleMTMessage(subscriber::SimSlot,wms::tlv::TransferRouteMTMessage const&,BOOL)::$_0,std::allocator<QMISMSCommandDriver::handleMTMessage(subscriber::SimSlot,wms::tlv::TransferRouteMTMessage const&,BOOL)::$_0>,void ()(sms::MsgPduProcessStatus,std::shared_ptr<sms::Model>)>::operator()(uint64_t a1, int *a2, uint64_t *a3)
{
  int v4;
  std::__shared_weak_count *v5;
  uint64_t v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  uint64_t v17[2];
  uint64_t v18[2];
  uint64_t v19[2];
  uint8_t buf[4];
  uint64_t v21;
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  v4 = *a2;
  v6 = *a3;
  v5 = (std::__shared_weak_count *)a3[1];
  *a3 = 0;
  a3[1] = 0;
  v7 = *(_QWORD *)(a1 + 8);
  v8 = *(NSObject **)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(v7 + 88) + 16))(*(_QWORD *)(v7 + 88), *(unsigned int *)(a1 + 16));
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315138;
    v21 = sms::asString();
    _os_log_impl(&dword_216897000, v8, OS_LOG_TYPE_DEFAULT, "#I Raw message parsing status is: %s", buf, 0xCu);
  }
  if (v4 == 9)
    goto LABEL_17;
  if (v4 == 1)
  {
    v9 = *(unsigned int *)(a1 + 16);
    v19[0] = 0;
    v19[1] = 0;
    QMISMSCommandDriver::sendAck(v7, v9, v19, 0, 0, *(_DWORD *)(a1 + 28), *(unsigned __int8 *)(a1 + 32), *(unsigned __int8 *)(a1 + 64), 1u);
    goto LABEL_17;
  }
  if (!*(_BYTE *)(a1 + 65))
  {
LABEL_17:
    if (!v5)
      return;
    goto LABEL_18;
  }
  v10 = *(unsigned int *)(a1 + 16);
  if (v4 != 4)
  {
    v18[0] = 0;
    v18[1] = 0;
    QMISMSCommandDriver::sendAck(v7, v10, v18, 0, 1, *(_DWORD *)(a1 + 28), *(unsigned __int8 *)(a1 + 32), *(unsigned __int8 *)(a1 + 64), 0);
    goto LABEL_17;
  }
  v17[0] = v6;
  v17[1] = (uint64_t)v5;
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
  }
  QMISMSCommandDriver::sendAck(v7, v10, v17, 1, 0, *(_DWORD *)(a1 + 28), *(unsigned __int8 *)(a1 + 32), *(unsigned __int8 *)(a1 + 64), 0);
  if (v5)
  {
    v13 = (unint64_t *)&v5->__shared_owners_;
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
LABEL_18:
    v15 = (unint64_t *)&v5->__shared_owners_;
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
}

void sub_2168F06B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v8;
  va_list va;

  va_start(va, a5);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va);
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<QMISMSCommandDriver::handleMTMessage(subscriber::SimSlot,wms::tlv::TransferRouteMTMessage const&,BOOL)::$_0,std::allocator<QMISMSCommandDriver::handleMTMessage(subscriber::SimSlot,wms::tlv::TransferRouteMTMessage const&,BOOL)::$_0>,void ()(sms::MsgPduProcessStatus,std::shared_ptr<sms::Model>)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<QMISMSCommandDriver::handleMTMessage(subscriber::SimSlot,wms::tlv::TransferRouteMTMessage const&,BOOL)::$_0,std::allocator<QMISMSCommandDriver::handleMTMessage(subscriber::SimSlot,wms::tlv::TransferRouteMTMessage const&,BOOL)::$_0>,void ()(sms::MsgPduProcessStatus,std::shared_ptr<sms::Model>)>::target_type()
{
}

void ctu::shared_ptr_map_impl<ctu::indexed_by_any_map_hashing_key>::get<CarrierSettingsInterface>(std::mutex *this@<X0>, _QWORD *a2@<X8>)
{
  unint64_t v4;
  unsigned __int8 *v5;
  uint64_t v6;
  unsigned int v7;
  _QWORD *v8;
  std::__shared_weak_count *v9;
  uint64_t v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;

  v4 = *(_QWORD *)(MEMORY[0x24BDC3CD8] + 8);
  if ((v4 & 0x8000000000000000) != 0)
  {
    v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    v6 = 5381;
    do
    {
      v4 = v6;
      v7 = *v5++;
      v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(this);
  v16 = v4;
  v8 = std::__hash_table<std::__hash_value_type<unsigned long,std::shared_ptr<void>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::shared_ptr<void>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::shared_ptr<void>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::shared_ptr<void>>>>::find<unsigned long>(&this[1].__m_.__sig, &v16);
  if (v8)
  {
    v10 = v8[3];
    v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      p_shared_owners = (unint64_t *)&v9->__shared_owners_;
      do
        v12 = __ldxr(p_shared_owners);
      while (__stxr(v12 + 1, p_shared_owners));
    }
  }
  else
  {
    v10 = 0;
    v9 = 0;
  }
  std::mutex::unlock(this);
  *a2 = v10;
  a2[1] = v9;
  if (v9)
  {
    v13 = (unint64_t *)&v9->__shared_owners_;
    do
      v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
    do
      v15 = __ldaxr(v13);
    while (__stlxr(v15 - 1, v13));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
}

void sub_2168F0860(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

_QWORD *std::__hash_table<std::__hash_value_type<unsigned long,std::shared_ptr<void>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::shared_ptr<void>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::shared_ptr<void>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::shared_ptr<void>>>>::find<unsigned long>(_QWORD *a1, unint64_t *a2)
{
  int8x8_t v2;
  unint64_t v3;
  uint8x8_t v4;
  unint64_t v5;
  _QWORD *v6;
  _QWORD *result;
  unint64_t v8;

  v2 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v2)
    return 0;
  v3 = *a2;
  v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    v5 = *a2;
    if (v3 >= *(_QWORD *)&v2)
      v5 = v3 % *(_QWORD *)&v2;
  }
  else
  {
    v5 = (*(_QWORD *)&v2 - 1) & v3;
  }
  v6 = *(_QWORD **)(*a1 + 8 * v5);
  if (!v6)
    return 0;
  result = (_QWORD *)*v6;
  if (*v6)
  {
    do
    {
      v8 = result[1];
      if (v3 == v8)
      {
        if (result[2] == v3)
          return result;
      }
      else
      {
        if (v4.u32[0] > 1uLL)
        {
          if (v8 >= *(_QWORD *)&v2)
            v8 %= *(_QWORD *)&v2;
        }
        else
        {
          v8 &= *(_QWORD *)&v2 - 1;
        }
        if (v8 != v5)
          return 0;
      }
      result = (_QWORD *)*result;
    }
    while (result);
  }
  return result;
}

_QWORD *ctu::cf::CFSharedRef<__CFDictionary const>::CFSharedRef<void const,void>(_QWORD *a1, CFTypeRef *a2)
{
  CFTypeRef v3;
  CFTypeID v4;
  const void *v5;

  v3 = *a2;
  if (*a2)
  {
    v4 = CFGetTypeID(*a2);
    if (v4 == CFDictionaryGetTypeID())
      v5 = v3;
    else
      v5 = 0;
  }
  else
  {
    v5 = 0;
  }
  return ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::SharedRef(a1, v5);
}

void qmi::MutableMessageBase::TlvWrapper<wms::tlv::ACKInfo>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::ACKInfo>::getSize()
{
  return tlv::size<wms::tlv::MessageTag>();
}

uint64_t *qmi::MutableMessageBase::TlvWrapper<wms::tlv::ACKInfo>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t *result;
  uint64_t v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = *a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wms::tlv::ACKInfo>(a2, a1 + 12);
  v7 = *a2 - v5;
  *(_BYTE *)v4 = v3;
  *(_WORD *)(v4 + 1) = v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::ACKInfo>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C6458;
  *(_QWORD *)(result + 12) = *(_QWORD *)(a1 + 12);
  *(_DWORD *)(result + 20) = *(_DWORD *)(a1 + 20);
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<wms::tlv::SmsOnIms>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::SmsOnIms>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<wms::tlv::SmsOnIms>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::SmsOnIms>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C64A8;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<wms::tlv::_3GPP2Info>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::_3GPP2Info>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_PcoMcc>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<wms::tlv::_3GPP2Info>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wms::tlv::_3GPP2Info>((_BYTE **)a2, (_DWORD *)(a1 + 12));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::_3GPP2Info>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C64F8;
  *(_QWORD *)(result + 12) = *(_QWORD *)(a1 + 12);
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<wms::tlv::_3GPPInfo>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::_3GPPInfo>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_PcoMcc>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<wms::tlv::_3GPPInfo>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::ProfileIdentifer>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::_3GPPInfo>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C6548;
  *(_WORD *)(result + 9) = *(_WORD *)(a1 + 9);
  return result;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN19QMISMSCommandDriver7sendAckEN10subscriber7SimSlotENSt3__110shared_ptrIN3sms5ModelEEEbbjNS_3wms13MessageFormatEbbE3__4EEOS1_OT__block_invoke(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t *v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  int v10;
  uint64_t v11;
  os_log_t *v12;
  std::__shared_weak_count *v13;
  uint64_t v14;
  int v15;
  NSObject *v16;
  NSObject *v17;
  uint64_t TlvValue;
  int v19;
  uint64_t v20;
  int v21;
  unsigned int v22;
  unsigned int v23;
  BOOL v24;
  NSObject *v25;
  const char *v26;
  NSObject *v27;
  const char *v28;
  BOOL v29;
  NSObject *v30;
  unint64_t *v31;
  unint64_t v32;
  std::__shared_weak_count *v33;
  unint64_t *v34;
  unint64_t v35;
  NSObject *v36;
  unint64_t *v37;
  unint64_t v38;
  unint64_t *v39;
  unint64_t v40;
  std::__shared_weak_count *v41;
  uint64_t v42;
  _BYTE buf[18];
  uint64_t v44;

  v44 = *MEMORY[0x24BDAC8D0];
  v3 = *(uint64_t **)(a1 + 32);
  v4 = *(_DWORD *)(a1 + 48);
  v5 = *v3;
  v6 = v3[1];
  v7 = (std::__shared_weak_count *)v3[2];
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }
  if (!v6)
  {
    v27 = *(NSObject **)(v5 + 40);
    if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
      goto LABEL_52;
    *(_WORD *)buf = 0;
    _os_log_error_impl(&dword_216897000, v27, OS_LOG_TYPE_ERROR, "Invalid sms model...", buf, 2u);
    if (!v7)
      return;
    goto LABEL_53;
  }
  v10 = *((unsigned __int8 *)v3 + 24);
  if (v4 - 1 >= 3)
    v11 = 0;
  else
    v11 = v4;
  v12 = (os_log_t *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v5 + 88) + 16))(*(_QWORD *)(v5 + 88), v11);
  v41 = 0;
  v13 = *(std::__shared_weak_count **)(v5 + 80);
  if (v13 && (v41 = std::__shared_weak_count::lock(v13)) != 0)
    v14 = *(_QWORD *)(v5 + 72);
  else
    v14 = 0;
  v15 = *((_DWORD *)a2 + 1);
  v16 = *v12;
  v17 = *v12;
  if (!v15)
  {
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      v28 = "Nak";
      if (v10)
        v28 = "Ack";
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = v28;
      _os_log_impl(&dword_216897000, v16, OS_LOG_TYPE_DEFAULT, "#I %s sent successfully", buf, 0xCu);
    }
    goto LABEL_34;
  }
  if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 67109378;
    *(_DWORD *)&buf[4] = v15;
    *(_WORD *)&buf[8] = 2080;
    *(_QWORD *)&buf[10] = qmi::asString();
    _os_log_error_impl(&dword_216897000, v16, OS_LOG_TYPE_ERROR, "sending ack failed (error: 0x%x (%s))", buf, 0x12u);
  }
  TlvValue = qmi::MessageBase::findTlvValue(a2);
  v20 = TlvValue;
  if (!TlvValue)
    goto LABEL_29;
  v21 = v19;
  v42 = TlvValue;
  v22 = tlv::parseV<wms::tlv::NWAckResp>((unint64_t *)&v42, v19);
  if (!v42)
  {
    ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 16, v20, v21);
LABEL_29:
    v24 = 1;
    goto LABEL_30;
  }
  v23 = v22;
  v24 = v22 > 2;
  v25 = *v12;
  if (os_log_type_enabled(*v12, OS_LOG_TYPE_DEFAULT))
  {
    v26 = (const char *)&unk_216AC4FCA;
    if (v23 > 2)
      v26 = " not";
    *(_DWORD *)buf = 67109378;
    *(_DWORD *)&buf[4] = v23;
    *(_WORD *)&buf[8] = 2080;
    *(_QWORD *)&buf[10] = v26;
    _os_log_impl(&dword_216897000, v25, OS_LOG_TYPE_DEFAULT, "#I Received a Network Ack Response of %d, this device should be on 2G, we are%s going to display", buf, 0x12u);
  }
LABEL_30:
  if (v10)
    v29 = v24;
  else
    v29 = 0;
  if (!v29)
  {
LABEL_34:
    if (v10)
    {
      v30 = *v12;
      if (os_log_type_enabled(*v12, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_216897000, v30, OS_LOG_TYPE_DEFAULT, "#I Notifying of message reception", buf, 2u);
      }
      if (v14)
      {
        *(_QWORD *)buf = v6;
        *(_QWORD *)&buf[8] = v7;
        if (v7)
        {
          v31 = (unint64_t *)&v7->__shared_owners_;
          do
            v32 = __ldxr(v31);
          while (__stxr(v32 + 1, v31));
        }
        (*(void (**)(uint64_t, _BYTE *))(*(_QWORD *)v14 + 24))(v14, buf);
        v33 = *(std::__shared_weak_count **)&buf[8];
        if (*(_QWORD *)&buf[8])
        {
          v34 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
          do
            v35 = __ldaxr(v34);
          while (__stlxr(v35 - 1, v34));
          if (!v35)
          {
            ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
            std::__shared_weak_count::__release_weak(v33);
          }
        }
      }
      else
      {
        v36 = *v12;
        if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)buf = 0;
          _os_log_error_impl(&dword_216897000, v36, OS_LOG_TYPE_ERROR, "Failed to get Sms controller...", buf, 2u);
        }
      }
    }
  }
  if (!v41)
    goto LABEL_52;
  v37 = (unint64_t *)&v41->__shared_owners_;
  do
    v38 = __ldaxr(v37);
  while (__stlxr(v38 - 1, v37));
  if (v38)
  {
LABEL_52:
    if (!v7)
      return;
    goto LABEL_53;
  }
  ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
  std::__shared_weak_count::__release_weak(v41);
  if (!v7)
    return;
LABEL_53:
  v39 = (unint64_t *)&v7->__shared_owners_;
  do
    v40 = __ldaxr(v39);
  while (__stlxr(v40 - 1, v39));
  if (!v40)
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
}

void sub_2168F10F8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v5;
  uint64_t v6;
  va_list va;
  uint64_t v8;
  uint64_t v9;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v6 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va);
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_32c134_ZTSNSt3__110shared_ptrIZN19QMISMSCommandDriver7sendAckEN10subscriber7SimSlotENS0_IN3sms5ModelEEEbbjN3qmi3wms13MessageFormatEbbE3__4EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c134_ZTSNSt3__110shared_ptrIZN19QMISMSCommandDriver7sendAckEN10subscriber7SimSlotENS0_IN3sms5ModelEEEbbjN3qmi3wms13MessageFormatEbbE3__4EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMISMSCommandDriver::sendAck(subscriber::SimSlot,std::shared_ptr<sms::Model>,BOOL,BOOL,unsigned int,qmi::wms::MessageFormat,BOOL,BOOL)::$_4,std::allocator<QMISMSCommandDriver::sendAck(subscriber::SimSlot,std::shared_ptr<sms::Model>,BOOL,BOOL,unsigned int,qmi::wms::MessageFormat,BOOL,BOOL)::$_4>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C65B0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMISMSCommandDriver::sendAck(subscriber::SimSlot,std::shared_ptr<sms::Model>,BOOL,BOOL,unsigned int,qmi::wms::MessageFormat,BOOL,BOOL)::$_4,std::allocator<QMISMSCommandDriver::sendAck(subscriber::SimSlot,std::shared_ptr<sms::Model>,BOOL,BOOL,unsigned int,qmi::wms::MessageFormat,BOOL,BOOL)::$_4>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C65B0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

uint64_t std::__shared_ptr_emplace<QMISMSCommandDriver::sendAck(subscriber::SimSlot,std::shared_ptr<sms::Model>,BOOL,BOOL,unsigned int,qmi::wms::MessageFormat,BOOL,BOOL)::$_4,std::allocator<QMISMSCommandDriver::sendAck(subscriber::SimSlot,std::shared_ptr<sms::Model>,BOOL,BOOL,unsigned int,qmi::wms::MessageFormat,BOOL,BOOL)::$_4>>::__on_zero_shared(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3wms7SendAck8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2168F1290(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

_QWORD *qmi::MutableMessageBase::TlvWrapper<wms::tlv::RawSend>::~TlvWrapper(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24D5C6640;
  v2 = (void *)a1[3];
  if (v2)
  {
    a1[4] = v2;
    operator delete(v2);
  }
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<wms::tlv::RawSend>::~TlvWrapper(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24D5C6640;
  v2 = (void *)a1[3];
  if (v2)
  {
    a1[4] = v2;
    operator delete(v2);
  }
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::RawSend>::getSize(uint64_t a1)
{
  return tlv::size<wms::tlv::RawSend>(a1 + 16);
}

void *qmi::MutableMessageBase::TlvWrapper<wms::tlv::RawSend>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  uint64_t v4;
  uint64_t v5;
  void *result;
  uint64_t v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = *a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wms::tlv::RawSend>(a2, a1 + 16);
  v7 = *a2 - v5;
  *(_BYTE *)v4 = v3;
  *(_WORD *)(v4 + 1) = v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::RawSend>::clone(uint64_t a1)
{
  uint64_t v2;

  v2 = operator new();
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)v2 = &off_24D5C6640;
  *(_BYTE *)(v2 + 16) = *(_BYTE *)(a1 + 16);
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 40) = 0;
  *(_QWORD *)(v2 + 24) = 0;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>((_QWORD *)(v2 + 24), *(const void **)(a1 + 24), *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 32) - *(_QWORD *)(a1 + 24));
  return v2;
}

void sub_2168F1424(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199FEAC4](v1, 0x1091C40AD8DF7F0);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<wms::tlv::ForceDC>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::ForceDC>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_PcoMcc>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<wms::tlv::ForceDC>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wms::tlv::ForceDC>((_BYTE **)a2, a1 + 12);
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::ForceDC>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C6690;
  *(_QWORD *)(result + 12) = *(_QWORD *)(a1 + 12);
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<wms::tlv::FollowDC>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::FollowDC>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<wms::tlv::FollowDC>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::FollowDC>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C66E0;
  return result;
}

char *qmi::MutableMessageBase::getTLV<wms::tlv::IMSControl>(_QWORD *a1)
{
  const void **v2;
  const void **v3;
  char **v4;
  char *v5;
  char *result;
  uint64_t v7;
  unint64_t v8;
  uint64_t *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  v4 = (char **)(a1 + 1);
  if (v2 != v3)
  {
    while (*((_BYTE *)*v2 + 8) != 19)
    {
      if (++v2 == v3)
        goto LABEL_8;
    }
  }
  if (v2 == v3)
  {
LABEL_8:
    v7 = operator new();
    *(_WORD *)(v7 + 8) = 19;
    *(_QWORD *)v7 = &off_24D5C6730;
    v8 = a1[3];
    v9 = (uint64_t *)a1[2];
    if ((unint64_t)v9 >= v8)
    {
      v11 = ((char *)v9 - *v4) >> 3;
      if ((unint64_t)(v11 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v12 = v8 - (_QWORD)*v4;
      v13 = v12 >> 2;
      if (v12 >> 2 <= (unint64_t)(v11 + 1))
        v13 = v11 + 1;
      if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
        v14 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v14 = v13;
      if (v14)
        v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v14);
      else
        v15 = 0;
      v16 = (uint64_t *)&v15[8 * v11];
      v17 = &v15[8 * v14];
      *v16 = v7;
      v10 = v16 + 1;
      v19 = (char *)a1[1];
      v18 = (char *)a1[2];
      if (v18 != v19)
      {
        do
        {
          v20 = *((_QWORD *)v18 - 1);
          v18 -= 8;
          *--v16 = v20;
        }
        while (v18 != v19);
        v18 = *v4;
      }
      a1[1] = v16;
      a1[2] = v10;
      a1[3] = v17;
      if (v18)
        operator delete(v18);
    }
    else
    {
      *v9 = v7;
      v10 = v9 + 1;
    }
    result = (char *)(v7 + 9);
    a1[2] = v10;
  }
  else
  {
    if (!v5)
      __cxa_bad_cast();
    return v5 + 9;
  }
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<wms::tlv::IMSControl>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::IMSControl>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<wms::tlv::IMSControl>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::IMSControl>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C6730;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<wms::tlv::LinkTimer>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::LinkTimer>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<wms::tlv::LinkTimer>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::LinkTimer>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C6780;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<wms::tlv::RetryControl>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::RetryControl>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<wms::tlv::RetryControl>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::RetryControl>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C67D0;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<wms::tlv::RetryID>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::RetryID>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

_DWORD **qmi::MutableMessageBase::TlvWrapper<wms::tlv::RetryID>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _DWORD *v4;
  uint64_t v5;
  _DWORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_DWORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::PktDataHandle>((_DWORD **)a2, (_DWORD *)(a1 + 12));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::RetryID>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C6820;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a1 + 12);
  return result;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN19QMISMSCommandDriver11sendSegmentENSt3__110shared_ptrIN3sms5ModelEEEbE3__9EEOS1_OT__block_invoke(uint64_t a1, qmi::MessageBase *this)
{
  uint64_t *v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  uint64_t TlvValue;
  int v11;
  uint64_t v12;
  int v13;
  unsigned __int16 v14;
  unsigned __int16 v15;
  NSObject *v16;
  uint64_t v17;
  os_log_t *v18;
  int v19;
  os_log_t *v20;
  unint64_t *v21;
  unint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  std::__shared_weak_count *v26;
  std::__shared_weak_count *v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  int v32;
  char v33;
  char v34;
  uint8_t v35;
  NSObject *v36;
  const char *v37;
  os_log_t v38;
  const char *v39;
  NSObject *v40;
  uint32_t v41;
  os_log_t v42;
  uint64_t v43;
  NSObject *v44;
  unint64_t *v45;
  unint64_t v46;
  uint64_t v47;
  int v48;
  uint64_t v49;
  int v50;
  unsigned __int16 v51;
  int v52;
  NSObject *v53;
  uint64_t v54;
  int v55;
  uint64_t v56;
  int v57;
  int v58;
  unsigned __int16 v59;
  NSObject *v60;
  int v61;
  sms *v62;
  int v63;
  uint64_t v64;
  int v65;
  uint64_t v66;
  int v67;
  BOOL v68;
  std::__shared_weak_count *v69;
  unint64_t v70;
  NSObject *v71;
  unint64_t *v72;
  unint64_t *v73;
  unint64_t v74;
  uint8_t v75[16];
  unint64_t v76;
  std::__shared_weak_count *v77;
  uint8_t v78[16];
  _BYTE buf[18];
  uint64_t v80;

  v80 = *MEMORY[0x24BDAC8D0];
  v3 = *(uint64_t **)(a1 + 32);
  v4 = *(_DWORD *)(a1 + 48);
  v5 = *v3;
  v6 = v3[1];
  v7 = (std::__shared_weak_count *)v3[2];
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }
  TlvValue = qmi::MessageBase::findTlvValue(this);
  v12 = TlvValue;
  if (TlvValue)
  {
    v13 = v11;
    *(_QWORD *)v78 = TlvValue;
    v14 = tlv::parseV<wms::tlv::MessageID>((unint64_t *)v78, v11);
    if (*(_QWORD *)v78)
    {
      v15 = v14;
      v16 = *(NSObject **)(v5 + 40);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&buf[4] = v15;
        _os_log_impl(&dword_216897000, v16, OS_LOG_TYPE_DEFAULT, "#I Setting Message ID to %hu", buf, 8u);
      }
      sms::Model::setMessageID((sms::Model *)v6);
    }
    else
    {
      ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)this, 1, v12, v13);
    }
  }
  if (v4 - 1 >= 3)
    v17 = 0;
  else
    v17 = v4;
  v18 = (os_log_t *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v5 + 88) + 16))(*(_QWORD *)(v5 + 88), v17);
  v19 = *((_DWORD *)this + 1);
  if (v19)
  {
    v20 = v18;
    *(_QWORD *)(v6 + 56) = 0;
    *(_OWORD *)v78 = xmmword_216A9D6A0;
    if (v19 != 54)
    {
      if (v19 == 56)
      {
        *(_QWORD *)(v6 + 56) = 5;
        v38 = *v18;
        if (!os_log_type_enabled(*v18, OS_LOG_TYPE_ERROR))
          goto LABEL_71;
        *(_DWORD *)buf = 134217984;
        *(_QWORD *)&buf[4] = 5;
        v39 = "Setting retry delay to %llu seconds";
        v40 = v38;
        v41 = 12;
      }
      else
      {
        if (v19 == 65537)
        {
          *(_QWORD *)buf = v6;
          *(_QWORD *)&buf[8] = v7;
          if (v7)
          {
            v21 = (unint64_t *)&v7->__shared_owners_;
            do
              v22 = __ldxr(v21);
            while (__stxr(v22 + 1, v21));
          }
          CSISMSCommandDriver::handleSmsSendTimeout();
          v23 = *(std::__shared_weak_count **)&buf[8];
          if (*(_QWORD *)&buf[8])
          {
            v24 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
            do
              v25 = __ldaxr(v24);
            while (__stlxr(v25 - 1, v24));
            if (!v25)
            {
              ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
              std::__shared_weak_count::__release_weak(v23);
            }
          }
          goto LABEL_71;
        }
        v42 = *v18;
        if (!os_log_type_enabled(*v18, OS_LOG_TYPE_ERROR))
          goto LABEL_71;
        v43 = qmi::asString();
        *(_DWORD *)buf = 67109378;
        *(_DWORD *)&buf[4] = v19;
        *(_WORD *)&buf[8] = 2080;
        *(_QWORD *)&buf[10] = v43;
        v39 = "QMI_WMS_RAW_SEND failed with error 0x%x (%s)";
        v40 = v42;
        v41 = 18;
      }
      _os_log_error_impl(&dword_216897000, v40, OS_LOG_TYPE_ERROR, v39, buf, v41);
      goto LABEL_71;
    }
    v29 = qmi::MessageBase::findTlvValue(this);
    v31 = v29;
    if (v29)
    {
      v32 = v30;
      v76 = v29;
      v33 = tlv::parseV<wms::tlv::ErrorClass>(&v76, v30);
      if (v76)
      {
        v34 = v33;
        v35 = v33 != 0;
        v78[8] = v35;
        v36 = *v20;
        if (os_log_type_enabled(*v20, OS_LOG_TYPE_ERROR))
        {
          v37 = "permanent";
          if (!v34)
            v37 = "temporary";
          *(_DWORD *)buf = 136315138;
          *(_QWORD *)&buf[4] = v37;
          _os_log_error_impl(&dword_216897000, v36, OS_LOG_TYPE_ERROR, "SMS Error Class: %s", buf, 0xCu);
        }
        goto LABEL_48;
      }
      ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)this, 17, v31, v32);
    }
    v35 = 0;
LABEL_48:
    v47 = qmi::MessageBase::findTlvValue(this);
    v49 = v47;
    if (v47)
    {
      v50 = v48;
      v76 = v47;
      v51 = tlv::parseV<wms::tlv::CauseCode>(&v76, v48);
      if (v76)
      {
        v52 = v51;
        *(_DWORD *)v78 = 1;
        *(_DWORD *)&v78[4] = v51;
        v53 = *v20;
        if (os_log_type_enabled(*v20, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&buf[4] = v52;
          _os_log_error_impl(&dword_216897000, v53, OS_LOG_TYPE_ERROR, "SMS Cause Code: %d", buf, 8u);
        }
      }
      else
      {
        ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)this, 16, v49, v50);
      }
    }
    v54 = qmi::MessageBase::findTlvValue(this);
    v56 = v54;
    if (v54)
    {
      v57 = v55;
      v76 = v54;
      v58 = tlv::parseV<wms::tlv::GWCauseInfo>(&v76, v55);
      if (v76)
      {
        v59 = v58;
        v60 = *v20;
        v61 = BYTE2(v58);
        if (os_log_type_enabled(*v20, OS_LOG_TYPE_ERROR))
        {
          v62 = (sms *)v59;
          *(_DWORD *)buf = 67109376;
          *(_DWORD *)&buf[4] = v59;
          *(_WORD *)&buf[8] = 1024;
          *(_DWORD *)&buf[10] = v61;
          _os_log_error_impl(&dword_216897000, v60, OS_LOG_TYPE_ERROR, "RPCause = %d, TPCause = %d", buf, 0xEu);
        }
        else
        {
          v62 = (sms *)v59;
        }
        *(_DWORD *)v78 = (_DWORD)v62;
        *(_DWORD *)&v78[4] = v61;
        v78[8] = 1;
        if (sms::isRPError(v62))
          v63 = 3;
        else
          v63 = 1;
        *(_DWORD *)&v78[12] = v63;
        if (((_DWORD)v62 - 35) < 5 && ((0x17u >> ((_BYTE)v62 - 35)) & 1) != 0)
        {
          v35 = 1;
        }
        else
        {
          v35 = shouldRetrySMS() ^ 1;
          v78[8] = v35;
        }
      }
      else
      {
        ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)this, 18, v56, v57);
      }
    }
    v64 = qmi::MessageBase::findTlvValue(this);
    v66 = v64;
    if (v64)
    {
      v67 = v65;
      *(_QWORD *)buf = v64;
      v68 = tlv::parseV<wms::tlv::FailureType>((unint64_t *)buf, v65);
      if (*(_QWORD *)buf)
        v78[8] = v68 | v35;
      else
        ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)this, 19, v66, v67);
    }
LABEL_71:
    v76 = 0;
    v77 = 0;
    v69 = *(std::__shared_weak_count **)(v5 + 80);
    if (v69)
    {
      v27 = std::__shared_weak_count::lock(v69);
      v77 = v27;
      if (v27)
      {
        v70 = *(_QWORD *)(v5 + 72);
        v76 = v70;
        if (v70)
        {
          (*(void (**)(unint64_t, _QWORD, uint8_t *))(*(_QWORD *)v70 + 48))(v70, *(unsigned int *)(v6 + 8), v78);
LABEL_78:
          v72 = (unint64_t *)&v27->__shared_owners_;
          do
            v46 = __ldaxr(v72);
          while (__stlxr(v46 - 1, v72));
          goto LABEL_80;
        }
      }
    }
    else
    {
      v27 = 0;
    }
    v71 = *(NSObject **)(v5 + 40);
    if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v75 = 0;
      _os_log_error_impl(&dword_216897000, v71, OS_LOG_TYPE_ERROR, "Failed to get SMS controller", v75, 2u);
      if (!v27)
        goto LABEL_82;
    }
    else if (!v27)
    {
      goto LABEL_82;
    }
    goto LABEL_78;
  }
  *(_QWORD *)buf = 0;
  *(_QWORD *)&buf[8] = 0;
  v26 = *(std::__shared_weak_count **)(v5 + 80);
  if (!v26)
  {
    v27 = 0;
    goto LABEL_41;
  }
  v27 = std::__shared_weak_count::lock(v26);
  *(_QWORD *)&buf[8] = v27;
  if (!v27 || (v28 = *(_QWORD *)(v5 + 72), (*(_QWORD *)buf = v28) == 0))
  {
LABEL_41:
    v44 = *(NSObject **)(v5 + 40);
    if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v78 = 0;
      _os_log_error_impl(&dword_216897000, v44, OS_LOG_TYPE_ERROR, "Failed to get SMS controller", v78, 2u);
      if (!v27)
        goto LABEL_82;
    }
    else if (!v27)
    {
      goto LABEL_82;
    }
    goto LABEL_43;
  }
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v28 + 40))(v28, *(unsigned int *)(v6 + 8));
LABEL_43:
  v45 = (unint64_t *)&v27->__shared_owners_;
  do
    v46 = __ldaxr(v45);
  while (__stlxr(v46 - 1, v45));
LABEL_80:
  if (!v46)
  {
    ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
    std::__shared_weak_count::__release_weak(v27);
  }
LABEL_82:
  if (v7)
  {
    v73 = (unint64_t *)&v7->__shared_owners_;
    do
      v74 = __ldaxr(v73);
    while (__stlxr(v74 - 1, v73));
    if (!v74)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
}

void sub_2168F2190(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v10;
  va_list va;

  va_start(va, a7);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va);
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v10 = __ldaxr(p_shared_owners);
    while (__stlxr(v10 - 1, p_shared_owners));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_32c88_ZTSNSt3__110shared_ptrIZN19QMISMSCommandDriver11sendSegmentENS0_IN3sms5ModelEEEbE3__9EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c88_ZTSNSt3__110shared_ptrIZN19QMISMSCommandDriver11sendSegmentENS0_IN3sms5ModelEEEbE3__9EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMISMSCommandDriver::sendSegment(std::shared_ptr<sms::Model>,BOOL)::$_9,std::allocator<QMISMSCommandDriver::sendSegment(std::shared_ptr<sms::Model>,BOOL)::$_9>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C6888;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMISMSCommandDriver::sendSegment(std::shared_ptr<sms::Model>,BOOL)::$_9,std::allocator<QMISMSCommandDriver::sendSegment(std::shared_ptr<sms::Model>,BOOL)::$_9>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C6888;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

uint64_t std::__shared_ptr_emplace<QMISMSCommandDriver::sendSegment(std::shared_ptr<sms::Model>,BOOL)::$_9,std::allocator<QMISMSCommandDriver::sendSegment(std::shared_ptr<sms::Model>,BOOL)::$_9>>::__on_zero_shared(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3wms7RawSend8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2168F2330(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<wms::tlv::ActivationInfo>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::ActivationInfo>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_PcoMcc>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<wms::tlv::ActivationInfo>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::ProfileIdentifer>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::ActivationInfo>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C6918;
  *(_WORD *)(result + 9) = *(_WORD *)(a1 + 9);
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<wms::tlv::FilteringInfo>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::FilteringInfo>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<wms::tlv::FilteringInfo>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::FilteringInfo>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C6968;
  return result;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN19QMISMSCommandDriver26sendSetBroadcastActivationEN3sms19BroadcastConfigModeENS4_22BroadcastSMSActivationEN10subscriber7SimSlotEE3__2EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t *v2;
  unsigned int v3;
  uint64_t v4;
  uint64_t v5;
  NSObject *v7;
  std::__shared_weak_count *v8;
  std::__shared_weak_count *v9;
  uint64_t v10;
  std::__shared_weak_count *v11;
  uint64_t v12;
  NSObject *v13;
  unint64_t *v14;
  unint64_t v15;
  NSObject *v16;
  unint64_t *p_shared_owners;
  int v18;
  _DWORD v19[2];
  __int16 v20;
  uint64_t v21;
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  v2 = *(uint64_t **)(a1 + 32);
  v3 = *(_DWORD *)(a1 + 48);
  v4 = *v2;
  if (v3 - 1 >= 3)
    v5 = 0;
  else
    v5 = v3;
  if (!*(_DWORD *)(a2 + 4))
  {
    v11 = *(std::__shared_weak_count **)(v4 + 80);
    if (v11)
    {
      v9 = std::__shared_weak_count::lock(v11);
      if (v9)
      {
        v12 = *(_QWORD *)(v4 + 72);
        if (v12)
        {
          (*(void (**)(uint64_t, uint64_t, _QWORD, uint64_t))(*(_QWORD *)v12 + 104))(v12, 1, *((unsigned int *)v2 + 2), v5);
LABEL_24:
          p_shared_owners = (unint64_t *)&v9->__shared_owners_;
          do
            v15 = __ldaxr(p_shared_owners);
          while (__stlxr(v15 - 1, p_shared_owners));
          goto LABEL_26;
        }
      }
    }
    else
    {
      v9 = 0;
    }
    v16 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v19[0]) = 0;
      _os_log_error_impl(&dword_216897000, v16, OS_LOG_TYPE_ERROR, "Failed to get SMS controller", (uint8_t *)v19, 2u);
      if (!v9)
        return;
    }
    else if (!v9)
    {
      return;
    }
    goto LABEL_24;
  }
  v7 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v4 + 88) + 16))(*(_QWORD *)(v4 + 88), v5);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    v18 = *(_DWORD *)(a2 + 4);
    v19[0] = 67109378;
    v19[1] = v18;
    v20 = 2080;
    v21 = qmi::asString();
    _os_log_error_impl(&dword_216897000, v7, OS_LOG_TYPE_ERROR, "Received for SetBroadcastActivation 0x%x, %s", (uint8_t *)v19, 0x12u);
  }
  v8 = *(std::__shared_weak_count **)(v4 + 80);
  if (!v8)
  {
    v9 = 0;
    goto LABEL_16;
  }
  v9 = std::__shared_weak_count::lock(v8);
  if (!v9 || (v10 = *(_QWORD *)(v4 + 72)) == 0)
  {
LABEL_16:
    v13 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v19[0]) = 0;
      _os_log_error_impl(&dword_216897000, v13, OS_LOG_TYPE_ERROR, "Failed to get SMS controller", (uint8_t *)v19, 2u);
      if (!v9)
        return;
    }
    else if (!v9)
    {
      return;
    }
    goto LABEL_18;
  }
  (*(void (**)(uint64_t, _QWORD, _QWORD, uint64_t))(*(_QWORD *)v10 + 104))(v10, 0, *((unsigned int *)v2 + 2), v5);
LABEL_18:
  v14 = (unint64_t *)&v9->__shared_owners_;
  do
    v15 = __ldaxr(v14);
  while (__stlxr(v15 - 1, v14));
LABEL_26:
  if (!v15)
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
}

void sub_2168F2740(_Unwind_Exception *exception_object)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v4;

  p_shared_owners = (unint64_t *)&v1->__shared_owners_;
  do
    v4 = __ldaxr(p_shared_owners);
  while (__stlxr(v4 - 1, p_shared_owners));
  if (!v4)
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t __copy_helper_block_e8_32c161_ZTSNSt3__110shared_ptrIZN19QMISMSCommandDriver26sendSetBroadcastActivationEN3sms19BroadcastConfigModeENS2_22BroadcastSMSActivationEN10subscriber7SimSlotEE3__2EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c161_ZTSNSt3__110shared_ptrIZN19QMISMSCommandDriver26sendSetBroadcastActivationEN3sms19BroadcastConfigModeENS2_22BroadcastSMSActivationEN10subscriber7SimSlotEE3__2EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMISMSCommandDriver::sendSetBroadcastActivation(sms::BroadcastConfigMode,sms::BroadcastSMSActivation,subscriber::SimSlot)::$_2,std::allocator<QMISMSCommandDriver::sendSetBroadcastActivation(sms::BroadcastConfigMode,sms::BroadcastSMSActivation,subscriber::SimSlot)::$_2>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C69D0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMISMSCommandDriver::sendSetBroadcastActivation(sms::BroadcastConfigMode,sms::BroadcastSMSActivation,subscriber::SimSlot)::$_2,std::allocator<QMISMSCommandDriver::sendSetBroadcastActivation(sms::BroadcastConfigMode,sms::BroadcastSMSActivation,subscriber::SimSlot)::$_2>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C69D0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

_QWORD *qmi::MutableMessageBase::TlvWrapper<wms::tlv::BroadcastConfigInfo3GPP_Req>::~TlvWrapper(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24D5C6A38;
  v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<wms::tlv::BroadcastConfigInfo3GPP_Req>::~TlvWrapper(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24D5C6A38;
  v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  JUMPOUT(0x2199FEAC4);
}

unint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::BroadcastConfigInfo3GPP_Req>::getSize(uint64_t a1)
{
  return tlv::size<wms::tlv::BroadcastConfigInfo3GPP_Req>((_QWORD *)(a1 + 16));
}

_WORD **qmi::MutableMessageBase::TlvWrapper<wms::tlv::BroadcastConfigInfo3GPP_Req>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _WORD *v4;
  uint64_t v5;
  _WORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_WORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wms::tlv::BroadcastConfigInfo3GPP_Req>((_WORD **)a2, (_DWORD *)(a1 + 16));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

_QWORD *qmi::MutableMessageBase::TlvWrapper<wms::tlv::BroadcastConfigInfo3GPP_Req>::clone(uint64_t a1)
{
  uint64_t v2;
  _QWORD *v3;
  _BYTE *v4;
  _BYTE *v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;

  v2 = operator new();
  v3 = (_QWORD *)v2;
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)(v2 + 16) = 0;
  *(_QWORD *)v2 = &off_24D5C6A38;
  *(_QWORD *)(v2 + 24) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  v5 = *(_BYTE **)(a1 + 16);
  v4 = *(_BYTE **)(a1 + 24);
  v6 = v4 - v5;
  if (v4 != v5)
  {
    if (0xAAAAAAAAAAAAAAABLL * (v6 >> 1) >= 0x2AAAAAAAAAAAAAABLL)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v7 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wms::tlv::BroadcastConfig3GPP>>(v2 + 32, 0xAAAAAAAAAAAAAAABLL * (v6 >> 1));
    v3[2] = v7;
    v3[4] = &v7[6 * v8];
    memmove(v7, v5, v6 - 1);
    v3[3] = &v7[2 * (v6 >> 1)];
  }
  return v3;
}

void sub_2168F29D0(_Unwind_Exception *a1)
{
  uint64_t v1;
  void **v2;
  void *v4;

  v4 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 24) = v4;
    operator delete(v4);
  }
  MEMORY[0x2199FEAC4](v1, 0x10A1C403082B835);
  _Unwind_Resume(a1);
}

char *qmi::MutableMessageBase::getTLV<wms::tlv::BroadcastConfigInfo>(_QWORD *a1)
{
  const void **v2;
  const void **v3;
  char **v4;
  char *v5;
  char *result;
  uint64_t v7;
  unint64_t v8;
  uint64_t *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  v4 = (char **)(a1 + 1);
  if (v2 != v3)
  {
    while (*((_BYTE *)*v2 + 8) != 1)
    {
      if (++v2 == v3)
        goto LABEL_8;
    }
  }
  if (v2 == v3)
  {
LABEL_8:
    v7 = operator new();
    *(_WORD *)(v7 + 8) = 1;
    *(_QWORD *)v7 = &off_24D5C6A88;
    v8 = a1[3];
    v9 = (uint64_t *)a1[2];
    if ((unint64_t)v9 >= v8)
    {
      v11 = ((char *)v9 - *v4) >> 3;
      if ((unint64_t)(v11 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v12 = v8 - (_QWORD)*v4;
      v13 = v12 >> 2;
      if (v12 >> 2 <= (unint64_t)(v11 + 1))
        v13 = v11 + 1;
      if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
        v14 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v14 = v13;
      if (v14)
        v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v14);
      else
        v15 = 0;
      v16 = (uint64_t *)&v15[8 * v11];
      v17 = &v15[8 * v14];
      *v16 = v7;
      v10 = v16 + 1;
      v19 = (char *)a1[1];
      v18 = (char *)a1[2];
      if (v18 != v19)
      {
        do
        {
          v20 = *((_QWORD *)v18 - 1);
          v18 -= 8;
          *--v16 = v20;
        }
        while (v18 != v19);
        v18 = *v4;
      }
      a1[1] = v16;
      a1[2] = v10;
      a1[3] = v17;
      if (v18)
        operator delete(v18);
    }
    else
    {
      *v9 = v7;
      v10 = v9 + 1;
    }
    result = (char *)(v7 + 9);
    a1[2] = v10;
  }
  else
  {
    if (!v5)
      __cxa_bad_cast();
    return v5 + 9;
  }
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<wms::tlv::BroadcastConfigInfo>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::BroadcastConfigInfo>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<wms::tlv::BroadcastConfigInfo>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::BroadcastConfigInfo>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C6A88;
  return result;
}

uint64_t qmi::ClientRouter::SendProxy::SendProxy<wms::SetBroadcastConfig::Request>(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v5;

  *(_DWORD *)a1 = a2;
  v5 = operator new();
  *(_QWORD *)v5 = a3;
  *(_QWORD *)(v5 + 8) = QMIServiceMsg::create();
  *(_DWORD *)(v5 + 16) = 25000;
  *(_QWORD *)(v5 + 24) = 0;
  *(_QWORD *)(v5 + 32) = 0;
  *(_QWORD *)(a1 + 8) = v5;
  return a1;
}

void sub_2168F2CA0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199FEAC4](v1, 0x10F0C401BA14CC5);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN19QMISMSCommandDriver26sendSetBroadcastConfig3GPPERKNSt3__16vectorIN3sms19BroadcastConfig3GPPENS4_9allocatorIS7_EEEEN10subscriber7SimSlotEE3__2EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  unsigned int v3;
  uint64_t v4;
  uint64_t v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  NSObject *v9;
  int v10;
  NSObject *v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  int v14;
  uint64_t v15;
  _DWORD v16[2];
  __int16 v17;
  uint64_t v18;
  uint64_t v19;

  v19 = *MEMORY[0x24BDAC8D0];
  v3 = *(_DWORD *)(a1 + 48);
  v4 = **(_QWORD **)(a1 + 32);
  if (v3 - 1 >= 3)
    v5 = 0;
  else
    v5 = v3;
  v6 = *(std::__shared_weak_count **)(v4 + 80);
  if (v6)
  {
    v7 = std::__shared_weak_count::lock(v6);
    if (v7)
    {
      v8 = *(_QWORD *)(v4 + 72);
      if (v8)
        goto LABEL_12;
    }
  }
  else
  {
    v7 = 0;
  }
  v9 = *(NSObject **)(v4 + 40);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v16[0]) = 0;
    _os_log_error_impl(&dword_216897000, v9, OS_LOG_TYPE_ERROR, "Failed to get SMS controller", (uint8_t *)v16, 2u);
  }
  v8 = 0;
LABEL_12:
  v10 = *(_DWORD *)(a2 + 4);
  if (v10)
  {
    v11 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v4 + 88) + 16))(*(_QWORD *)(v4 + 88), v5);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      v14 = *(_DWORD *)(a2 + 4);
      v15 = qmi::asString();
      v16[0] = 67109378;
      v16[1] = v14;
      v17 = 2080;
      v18 = v15;
      _os_log_error_impl(&dword_216897000, v11, OS_LOG_TYPE_ERROR, "Error received for sendSetBroadcastConfig 0x%x, %s", (uint8_t *)v16, 0x12u);
    }
  }
  (*(void (**)(uint64_t, BOOL, uint64_t, uint64_t))(*(_QWORD *)v8 + 112))(v8, v10 == 0, 1, v5);
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v13 = __ldaxr(p_shared_owners);
    while (__stlxr(v13 - 1, p_shared_owners));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
}

void sub_2168F2E78(_Unwind_Exception *exception_object)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v4;

  if (v1)
  {
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t __copy_helper_block_e8_32c166_ZTSNSt3__110shared_ptrIZN19QMISMSCommandDriver26sendSetBroadcastConfig3GPPERKNS_6vectorIN3sms19BroadcastConfig3GPPENS_9allocatorIS4_EEEEN10subscriber7SimSlotEE3__2EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c166_ZTSNSt3__110shared_ptrIZN19QMISMSCommandDriver26sendSetBroadcastConfig3GPPERKNS_6vectorIN3sms19BroadcastConfig3GPPENS_9allocatorIS4_EEEEN10subscriber7SimSlotEE3__2EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMISMSCommandDriver::sendSetBroadcastConfig3GPP(std::vector<sms::BroadcastConfig3GPP> const&,subscriber::SimSlot)::$_2,std::allocator<QMISMSCommandDriver::sendSetBroadcastConfig3GPP(std::vector<sms::BroadcastConfig3GPP> const&,subscriber::SimSlot)::$_2>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C6AF0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMISMSCommandDriver::sendSetBroadcastConfig3GPP(std::vector<sms::BroadcastConfig3GPP> const&,subscriber::SimSlot)::$_2,std::allocator<QMISMSCommandDriver::sendSetBroadcastConfig3GPP(std::vector<sms::BroadcastConfig3GPP> const&,subscriber::SimSlot)::$_2>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C6AF0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

_QWORD *qmi::MutableMessageBase::TlvWrapper<wms::tlv::BroadcastConfigInfo3GPP2_Req>::~TlvWrapper(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24D5C6B58;
  v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<wms::tlv::BroadcastConfigInfo3GPP2_Req>::~TlvWrapper(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24D5C6B58;
  v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  JUMPOUT(0x2199FEAC4);
}

unint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::BroadcastConfigInfo3GPP2_Req>::getSize(uint64_t a1)
{
  return tlv::size<wms::tlv::BroadcastConfigInfo3GPP_Req>((_QWORD *)(a1 + 16));
}

_WORD **qmi::MutableMessageBase::TlvWrapper<wms::tlv::BroadcastConfigInfo3GPP2_Req>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _WORD *v4;
  uint64_t v5;
  _WORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_WORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wms::tlv::BroadcastConfigInfo3GPP_Req>((_WORD **)a2, (_DWORD *)(a1 + 16));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

_QWORD *qmi::MutableMessageBase::TlvWrapper<wms::tlv::BroadcastConfigInfo3GPP2_Req>::clone(uint64_t a1)
{
  uint64_t v2;
  _QWORD *v3;
  _BYTE *v4;
  _BYTE *v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;

  v2 = operator new();
  v3 = (_QWORD *)v2;
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)(v2 + 16) = 0;
  *(_QWORD *)v2 = &off_24D5C6B58;
  *(_QWORD *)(v2 + 24) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  v5 = *(_BYTE **)(a1 + 16);
  v4 = *(_BYTE **)(a1 + 24);
  v6 = v4 - v5;
  if (v4 != v5)
  {
    if (0xAAAAAAAAAAAAAAABLL * (v6 >> 1) >= 0x2AAAAAAAAAAAAAABLL)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v7 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wms::tlv::BroadcastConfig3GPP>>(v2 + 32, 0xAAAAAAAAAAAAAAABLL * (v6 >> 1));
    v3[2] = v7;
    v3[4] = &v7[6 * v8];
    memmove(v7, v5, v6 - 1);
    v3[3] = &v7[2 * (v6 >> 1)];
  }
  return v3;
}

void sub_2168F30F8(_Unwind_Exception *a1)
{
  uint64_t v1;
  void **v2;
  void *v4;

  v4 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 24) = v4;
    operator delete(v4);
  }
  MEMORY[0x2199FEAC4](v1, 0x10A1C403082B835);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN19QMISMSCommandDriver27sendSetBroadcastConfig3GPP2ERKNSt3__16vectorIN3sms20BroadcastConfig3GPP2ENS4_9allocatorIS7_EEEEN10subscriber7SimSlotEE3__2EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  uint64_t v3;
  uint64_t v4;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v7;
  uint64_t v8;
  int v9;
  NSObject *v10;
  NSObject *v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  int v14;
  _DWORD v15[2];
  __int16 v16;
  uint64_t v17;
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  v2 = *(_DWORD *)(a1 + 48);
  v3 = **(_QWORD **)(a1 + 32);
  if (v2 - 1 >= 3)
    v4 = 0;
  else
    v4 = v2;
  v5 = *(std::__shared_weak_count **)(v3 + 80);
  if (v5)
  {
    v7 = std::__shared_weak_count::lock(v5);
    if (v7)
    {
      v8 = *(_QWORD *)(v3 + 72);
      if (v8)
      {
        v9 = *(_DWORD *)(a2 + 4);
        if (v9)
        {
          v10 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v3 + 88) + 16))(*(_QWORD *)(v3 + 88), v4);
          if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
          {
            v14 = *(_DWORD *)(a2 + 4);
            v15[0] = 67109378;
            v15[1] = v14;
            v16 = 2080;
            v17 = qmi::asString();
            _os_log_error_impl(&dword_216897000, v10, OS_LOG_TYPE_ERROR, "Error received for sendSetBroadcastConfig 0x%x, %s", (uint8_t *)v15, 0x12u);
          }
        }
        (*(void (**)(uint64_t, BOOL, _QWORD, uint64_t))(*(_QWORD *)v8 + 112))(v8, v9 == 0, 0, v4);
        goto LABEL_14;
      }
    }
  }
  else
  {
    v7 = 0;
  }
  v11 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v15[0]) = 0;
    _os_log_error_impl(&dword_216897000, v11, OS_LOG_TYPE_ERROR, "Failed to get SMS controller", (uint8_t *)v15, 2u);
    if (!v7)
      return;
  }
  else if (!v7)
  {
    return;
  }
LABEL_14:
  p_shared_owners = (unint64_t *)&v7->__shared_owners_;
  do
    v13 = __ldaxr(p_shared_owners);
  while (__stlxr(v13 - 1, p_shared_owners));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
}

void sub_2168F32E0(_Unwind_Exception *exception_object)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v4;

  p_shared_owners = (unint64_t *)&v1->__shared_owners_;
  do
    v4 = __ldaxr(p_shared_owners);
  while (__stlxr(v4 - 1, p_shared_owners));
  if (!v4)
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t __copy_helper_block_e8_32c168_ZTSNSt3__110shared_ptrIZN19QMISMSCommandDriver27sendSetBroadcastConfig3GPP2ERKNS_6vectorIN3sms20BroadcastConfig3GPP2ENS_9allocatorIS4_EEEEN10subscriber7SimSlotEE3__2EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c168_ZTSNSt3__110shared_ptrIZN19QMISMSCommandDriver27sendSetBroadcastConfig3GPP2ERKNS_6vectorIN3sms20BroadcastConfig3GPP2ENS_9allocatorIS4_EEEEN10subscriber7SimSlotEE3__2EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMISMSCommandDriver::sendSetBroadcastConfig3GPP2(std::vector<sms::BroadcastConfig3GPP2> const&,subscriber::SimSlot)::$_2,std::allocator<QMISMSCommandDriver::sendSetBroadcastConfig3GPP2(std::vector<sms::BroadcastConfig3GPP2> const&,subscriber::SimSlot)::$_2>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C6BC0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMISMSCommandDriver::sendSetBroadcastConfig3GPP2(std::vector<sms::BroadcastConfig3GPP2> const&,subscriber::SimSlot)::$_2,std::allocator<QMISMSCommandDriver::sendSetBroadcastConfig3GPP2(std::vector<sms::BroadcastConfig3GPP2> const&,subscriber::SimSlot)::$_2>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C6BC0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::ClientRouter::SendProxy::SendProxy<wms::GetBroadcastConfig::Request>(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v5;

  *(_DWORD *)a1 = a2;
  v5 = operator new();
  *(_QWORD *)v5 = a3;
  *(_QWORD *)(v5 + 8) = QMIServiceMsg::create();
  *(_DWORD *)(v5 + 16) = 25000;
  *(_QWORD *)(v5 + 24) = 0;
  *(_QWORD *)(v5 + 32) = 0;
  *(_QWORD *)(a1 + 8) = v5;
  return a1;
}

void sub_2168F3408(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199FEAC4](v1, 0x10F0C401BA14CC5);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN19QMISMSCommandDriver26sendGetBroadcastConfig3GPPEN10subscriber7SimSlotEE3__1EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  unsigned int v3;
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  std::__shared_weak_count *v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  NSObject **v15;
  uint64_t TlvValue;
  int v17;
  uint64_t v18;
  int v19;
  unint64_t v20;
  NSObject *v21;
  int *v22;
  int *v23;
  unint64_t v24;
  std::__shared_weak_count_vtbl *shared_owners;
  std::__shared_weak_count_vtbl *v26;
  unint64_t v27;
  unint64_t v28;
  uint64_t shared_weak_owners;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  char *v33;
  char *v34;
  char *v35;
  char *v36;
  int v37;
  char v38;
  NSObject *v39;
  unint64_t *p_shared_owners;
  unint64_t v41;
  uint64_t v42;
  std::__shared_weak_count_vtbl *v43;
  int v44;
  std::__shared_weak_count_vtbl *v45;
  int v46;
  std::__shared_weak_count *v47;
  uint64_t v48;
  unint64_t v49;
  std::__shared_weak_count *v50;
  unint64_t *v51;
  unint64_t v52;
  NSObject *v53;
  std::__shared_weak_count *v54;
  unint64_t *v55;
  unint64_t v56;
  std::__shared_weak_count *v57;
  unint64_t *v58;
  unint64_t v59;
  unint64_t v60;
  int v61;
  uint64_t v62;
  unsigned int v63;
  unint64_t v64;
  _WORD v65[12];
  _QWORD *v66;
  std::__shared_weak_count *v67;
  unint64_t v68;
  __int128 buf;
  uint8_t v70[40];
  uint64_t v71;

  v71 = *MEMORY[0x24BDAC8D0];
  v3 = *(_DWORD *)(a1 + 48);
  v4 = **(_QWORD **)(a1 + 32);
  if (v3 - 1 >= 3)
    v5 = 0;
  else
    v5 = v3;
  if (*(_DWORD *)(a2 + 4))
  {
    v6 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v4 + 88) + 16))(*(_QWORD *)(v4 + 88), v5);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      v44 = *(_DWORD *)(a2 + 4);
      *(_DWORD *)v70 = 67109378;
      *(_DWORD *)&v70[4] = v44;
      *(_WORD *)&v70[8] = 2080;
      *(_QWORD *)&v70[10] = qmi::asString();
      _os_log_error_impl(&dword_216897000, v6, OS_LOG_TYPE_ERROR, "Error received for sendGetBroadcastConfig3GPP 0x%x, %s", v70, 0x12u);
    }
    v7 = *(std::__shared_weak_count **)(v4 + 80);
    if (v7)
    {
      v8 = std::__shared_weak_count::lock(v7);
      if (v8)
      {
        v9 = *(_QWORD *)(v4 + 72);
        if (v9)
        {
          *(_QWORD *)v70 = 0;
          *(_QWORD *)&v70[8] = 0;
          (*(void (**)(uint64_t, uint64_t, uint8_t *, uint64_t))(*(_QWORD *)v9 + 120))(v9, 255, v70, v5);
          v10 = *(std::__shared_weak_count **)&v70[8];
          if (*(_QWORD *)&v70[8])
          {
            v11 = (unint64_t *)(*(_QWORD *)&v70[8] + 8);
            do
              v12 = __ldaxr(v11);
            while (__stlxr(v12 - 1, v11));
            if (!v12)
            {
              ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
              std::__shared_weak_count::__release_weak(v10);
            }
          }
LABEL_38:
          p_shared_owners = (unint64_t *)&v8->__shared_owners_;
          do
            v41 = __ldaxr(p_shared_owners);
          while (__stlxr(v41 - 1, p_shared_owners));
          if (!v41)
          {
            ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
            std::__shared_weak_count::__release_weak(v8);
          }
          return;
        }
      }
    }
    else
    {
      v8 = 0;
    }
    v39 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v70 = 0;
      _os_log_error_impl(&dword_216897000, v39, OS_LOG_TYPE_ERROR, "Failed to get SMS controller", v70, 2u);
      if (!v8)
        return;
    }
    else if (!v8)
    {
      return;
    }
    goto LABEL_38;
  }
  qmi::Response<(unsigned short)62,wms::GetBroadcastConfig::ResponseTLVList>::Response((qmi::MessageBase *)v65, (_QWORD *)a2);
  v13 = (std::__shared_weak_count *)operator new(0x30uLL);
  v13->__shared_owners_ = 0;
  v14 = (unint64_t *)&v13->__shared_owners_;
  v13->__shared_weak_owners_ = 0;
  v13->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C6C90;
  v13[1].__vftable = 0;
  v13[1].__shared_owners_ = 0;
  v13[1].__shared_weak_owners_ = 0;
  v66 = &v13[1].__vftable;
  v67 = v13;
  v15 = (NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v4 + 88) + 16))(*(_QWORD *)(v4 + 88), v5);
  TlvValue = qmi::MessageBase::findTlvValue((qmi::MessageBase *)v65);
  v18 = TlvValue;
  if (TlvValue)
  {
    v19 = v17;
    v68 = TlvValue;
    memset(v70, 0, 32);
    tlv::parseV<wms::tlv::BroadcastConfigInfo3GPP_Resp>(&v68, v17, v70);
    v20 = v68;
    if (!v68)
    {
      v42 = 0;
LABEL_54:
      if (*(_QWORD *)&v70[8])
      {
        *(_QWORD *)&v70[16] = *(_QWORD *)&v70[8];
        operator delete(*(void **)&v70[8]);
      }
      if (!v20)
        ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(v65[0], 16, v18, v19);
      goto LABEL_58;
    }
    v64 = v68;
    v61 = v19;
    v62 = v18;
    v63 = v5;
    v21 = *v15;
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 134217984;
      *(_QWORD *)((char *)&buf + 4) = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)&v70[16] - *(_QWORD *)&v70[8]) >> 1);
      _os_log_impl(&dword_216897000, v21, OS_LOG_TYPE_DEFAULT, "#I Received %lu parameters", (uint8_t *)&buf, 0xCu);
    }
    v22 = *(int **)&v70[8];
    v23 = *(int **)&v70[16];
    v24 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)&v70[16] - *(_QWORD *)&v70[8]) >> 1);
    v26 = v13[1].__vftable;
    shared_owners = (std::__shared_weak_count_vtbl *)v13[1].__shared_owners_;
    v27 = 0xAAAAAAAAAAAAAAABLL * (((char *)shared_owners - (char *)v26) >> 1);
    v28 = v24 - v27;
    if (v24 <= v27)
    {
      if (v24 >= v27)
      {
LABEL_49:
        v5 = v63;
        v19 = v61;
        v18 = v62;
LABEL_50:
        if (v22 != v23)
        {
          v45 = v13[1].__vftable;
          do
          {
            v46 = *v22;
            BYTE4(v45->~__shared_weak_count) = *((_BYTE *)v22 + 4);
            LODWORD(v45->~__shared_weak_count) = v46;
            v45 = (std::__shared_weak_count_vtbl *)((char *)v45 + 6);
            v22 = (int *)((char *)v22 + 6);
          }
          while (v22 != v23);
        }
        v42 = v70[0];
        v20 = v64;
        goto LABEL_54;
      }
      v43 = (std::__shared_weak_count_vtbl *)((char *)v26
                                            + 2 * ((uint64_t)(*(_QWORD *)&v70[16] - *(_QWORD *)&v70[8]) >> 1));
    }
    else
    {
      shared_weak_owners = v13[1].__shared_weak_owners_;
      if (0xAAAAAAAAAAAAAAABLL * ((shared_weak_owners - (uint64_t)shared_owners) >> 1) < v28)
      {
        if (v24 > 0x2AAAAAAAAAAAAAAALL)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v30 = 0xAAAAAAAAAAAAAAABLL * ((shared_weak_owners - (uint64_t)v26) >> 1);
        v31 = 0x5555555555555556 * ((shared_weak_owners - (uint64_t)v26) >> 1);
        if (v31 <= v24)
          v31 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)&v70[16] - *(_QWORD *)&v70[8]) >> 1);
        if (v30 >= 0x1555555555555555)
          v32 = 0x2AAAAAAAAAAAAAAALL;
        else
          v32 = v31;
        if (v32 > 0x2AAAAAAAAAAAAAAALL)
          std::__throw_bad_array_new_length[abi:ne180100]();
        v60 = v32;
        v33 = (char *)operator new(6 * v32);
        v34 = &v33[2 * (((char *)shared_owners - (char *)v26) >> 1)];
        v35 = &v33[6 * v24];
        v36 = v34;
        do
        {
          *(_DWORD *)v36 = 0;
          v36[4] = 0;
          v36 += 6;
        }
        while (v36 != v35);
        v5 = v63;
        v18 = v62;
        if (shared_owners != v26)
        {
          do
          {
            v37 = *(_DWORD *)((char *)&shared_owners[-1].__on_zero_shared_weak + 2);
            shared_owners = (std::__shared_weak_count_vtbl *)((char *)shared_owners - 6);
            v38 = BYTE4(shared_owners->~__shared_weak_count);
            *(_DWORD *)(v34 - 6) = v37;
            v34 -= 6;
            v34[4] = v38;
          }
          while (shared_owners != v26);
          shared_owners = v26;
        }
        v13[1].__vftable = (std::__shared_weak_count_vtbl *)v34;
        v13[1].__shared_owners_ = (uint64_t)v35;
        v13[1].__shared_weak_owners_ = (uint64_t)&v33[6 * v60];
        v19 = v61;
        if (shared_owners)
        {
          operator delete(shared_owners);
          v22 = *(int **)&v70[8];
          v23 = *(int **)&v70[16];
        }
        goto LABEL_50;
      }
      v43 = (std::__shared_weak_count_vtbl *)((char *)shared_owners + 6 * v28);
      do
      {
        LODWORD(shared_owners->~__shared_weak_count) = 0;
        BYTE4(shared_owners->~__shared_weak_count) = 0;
        shared_owners = (std::__shared_weak_count_vtbl *)((char *)shared_owners + 6);
      }
      while (shared_owners != v43);
    }
    v13[1].__shared_owners_ = (uint64_t)v43;
    goto LABEL_49;
  }
  v42 = 0;
LABEL_58:
  *(_QWORD *)v70 = 0;
  *(_QWORD *)&v70[8] = 0;
  v47 = *(std::__shared_weak_count **)(v4 + 80);
  if (v47
    && (*(_QWORD *)&v70[8] = std::__shared_weak_count::lock(v47)) != 0
    && (v48 = *(_QWORD *)(v4 + 72), (*(_QWORD *)v70 = v48) != 0))
  {
    *(_QWORD *)&buf = v13 + 1;
    *((_QWORD *)&buf + 1) = v13;
    do
      v49 = __ldxr(v14);
    while (__stxr(v49 + 1, v14));
    (*(void (**)(uint64_t, uint64_t, __int128 *, uint64_t))(*(_QWORD *)v48 + 120))(v48, v42, &buf, v5);
    v50 = (std::__shared_weak_count *)*((_QWORD *)&buf + 1);
    if (*((_QWORD *)&buf + 1))
    {
      v51 = (unint64_t *)(*((_QWORD *)&buf + 1) + 8);
      do
        v52 = __ldaxr(v51);
      while (__stlxr(v52 - 1, v51));
      if (!v52)
      {
        ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
        std::__shared_weak_count::__release_weak(v50);
      }
    }
  }
  else
  {
    v53 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl(&dword_216897000, v53, OS_LOG_TYPE_ERROR, "Failed to get SMS controller", (uint8_t *)&buf, 2u);
    }
  }
  v54 = *(std::__shared_weak_count **)&v70[8];
  if (*(_QWORD *)&v70[8])
  {
    v55 = (unint64_t *)(*(_QWORD *)&v70[8] + 8);
    do
      v56 = __ldaxr(v55);
    while (__stlxr(v56 - 1, v55));
    if (!v56)
    {
      ((void (*)(std::__shared_weak_count *))v54->__on_zero_shared)(v54);
      std::__shared_weak_count::__release_weak(v54);
    }
  }
  v57 = v67;
  if (v67)
  {
    v58 = (unint64_t *)&v67->__shared_owners_;
    do
      v59 = __ldaxr(v58);
    while (__stlxr(v59 - 1, v58));
    if (!v59)
    {
      ((void (*)(std::__shared_weak_count *))v57->__on_zero_shared)(v57);
      std::__shared_weak_count::__release_weak(v57);
    }
  }
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v65);
}

void sub_2168F3A40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,char a23,void *__p,uint64_t a25)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a21);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a23);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a18);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a15);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_32c105_ZTSNSt3__110shared_ptrIZN19QMISMSCommandDriver26sendGetBroadcastConfig3GPPEN10subscriber7SimSlotEE3__1EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c105_ZTSNSt3__110shared_ptrIZN19QMISMSCommandDriver26sendGetBroadcastConfig3GPPEN10subscriber7SimSlotEE3__1EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMISMSCommandDriver::sendGetBroadcastConfig3GPP(subscriber::SimSlot)::$_1,std::allocator<QMISMSCommandDriver::sendGetBroadcastConfig3GPP(subscriber::SimSlot)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C6C40;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMISMSCommandDriver::sendGetBroadcastConfig3GPP(subscriber::SimSlot)::$_1,std::allocator<QMISMSCommandDriver::sendGetBroadcastConfig3GPP(subscriber::SimSlot)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C6C40;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

qmi::MessageBase *qmi::Response<(unsigned short)62,wms::GetBroadcastConfig::ResponseTLVList>::Response(qmi::MessageBase *this, _QWORD *a2)
{
  uint64_t v3;
  unint64_t *v4;
  unint64_t v5;

  *(_QWORD *)this = *a2;
  v3 = a2[2];
  *((_QWORD *)this + 1) = a2[1];
  *((_QWORD *)this + 2) = v3;
  if (v3)
  {
    v4 = (unint64_t *)(v3 + 8);
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }
  qmi::MessageBase::validateMsgId(this);
  return this;
}

void sub_2168F3BD8(_Unwind_Exception *a1)
{
  qmi::MessageBase *v1;

  qmi::MessageBase::~MessageBase(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<std::vector<sms::BroadcastConfig3GPP>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C6C90;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<std::vector<sms::BroadcastConfig3GPP>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C6C90;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void std::__shared_ptr_emplace<std::vector<sms::BroadcastConfig3GPP>>::__on_zero_shared(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(_QWORD *)(a1 + 32) = v2;
    operator delete(v2);
  }
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN19QMISMSCommandDriver27sendGetBroadcastConfig3GPP2EN10subscriber7SimSlotEE3__1EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  unsigned int v3;
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  std::__shared_weak_count *v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  NSObject **v15;
  uint64_t TlvValue;
  int v17;
  uint64_t v18;
  int v19;
  unint64_t v20;
  NSObject *v21;
  int *v22;
  int *v23;
  unint64_t v24;
  std::__shared_weak_count_vtbl *shared_owners;
  std::__shared_weak_count_vtbl *v26;
  unint64_t v27;
  unint64_t v28;
  uint64_t shared_weak_owners;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  char *v33;
  char *v34;
  char *v35;
  char *v36;
  int v37;
  char v38;
  NSObject *v39;
  unint64_t *p_shared_owners;
  unint64_t v41;
  uint64_t v42;
  std::__shared_weak_count_vtbl *v43;
  int v44;
  std::__shared_weak_count_vtbl *v45;
  int v46;
  std::__shared_weak_count *v47;
  uint64_t v48;
  unint64_t v49;
  std::__shared_weak_count *v50;
  unint64_t *v51;
  unint64_t v52;
  NSObject *v53;
  std::__shared_weak_count *v54;
  unint64_t *v55;
  unint64_t v56;
  std::__shared_weak_count *v57;
  unint64_t *v58;
  unint64_t v59;
  unint64_t v60;
  int v61;
  uint64_t v62;
  unsigned int v63;
  unint64_t v64;
  _WORD v65[12];
  _QWORD *v66;
  std::__shared_weak_count *v67;
  unint64_t v68;
  __int128 buf;
  uint8_t v70[40];
  uint64_t v71;

  v71 = *MEMORY[0x24BDAC8D0];
  v3 = *(_DWORD *)(a1 + 48);
  v4 = **(_QWORD **)(a1 + 32);
  if (v3 - 1 >= 3)
    v5 = 0;
  else
    v5 = v3;
  if (*(_DWORD *)(a2 + 4))
  {
    v6 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v4 + 88) + 16))(*(_QWORD *)(v4 + 88), v5);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      v44 = *(_DWORD *)(a2 + 4);
      *(_DWORD *)v70 = 67109378;
      *(_DWORD *)&v70[4] = v44;
      *(_WORD *)&v70[8] = 2080;
      *(_QWORD *)&v70[10] = qmi::asString();
      _os_log_error_impl(&dword_216897000, v6, OS_LOG_TYPE_ERROR, "Error received for sendGetBroadcastConfig3GPP2 0x%x, %s", v70, 0x12u);
    }
    v7 = *(std::__shared_weak_count **)(v4 + 80);
    if (v7)
    {
      v8 = std::__shared_weak_count::lock(v7);
      if (v8)
      {
        v9 = *(_QWORD *)(v4 + 72);
        if (v9)
        {
          *(_QWORD *)v70 = 0;
          *(_QWORD *)&v70[8] = 0;
          (*(void (**)(uint64_t, uint64_t, uint8_t *, uint64_t))(*(_QWORD *)v9 + 128))(v9, 255, v70, v5);
          v10 = *(std::__shared_weak_count **)&v70[8];
          if (*(_QWORD *)&v70[8])
          {
            v11 = (unint64_t *)(*(_QWORD *)&v70[8] + 8);
            do
              v12 = __ldaxr(v11);
            while (__stlxr(v12 - 1, v11));
            if (!v12)
            {
              ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
              std::__shared_weak_count::__release_weak(v10);
            }
          }
LABEL_38:
          p_shared_owners = (unint64_t *)&v8->__shared_owners_;
          do
            v41 = __ldaxr(p_shared_owners);
          while (__stlxr(v41 - 1, p_shared_owners));
          if (!v41)
          {
            ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
            std::__shared_weak_count::__release_weak(v8);
          }
          return;
        }
      }
    }
    else
    {
      v8 = 0;
    }
    v39 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v70 = 0;
      _os_log_error_impl(&dword_216897000, v39, OS_LOG_TYPE_ERROR, "Failed to get SMS controller", v70, 2u);
      if (!v8)
        return;
    }
    else if (!v8)
    {
      return;
    }
    goto LABEL_38;
  }
  qmi::Response<(unsigned short)62,wms::GetBroadcastConfig::ResponseTLVList>::Response((qmi::MessageBase *)v65, (_QWORD *)a2);
  v13 = (std::__shared_weak_count *)operator new(0x30uLL);
  v13->__shared_owners_ = 0;
  v14 = (unint64_t *)&v13->__shared_owners_;
  v13->__shared_weak_owners_ = 0;
  v13->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C6D60;
  v13[1].__vftable = 0;
  v13[1].__shared_owners_ = 0;
  v13[1].__shared_weak_owners_ = 0;
  v66 = &v13[1].__vftable;
  v67 = v13;
  v15 = (NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v4 + 88) + 16))(*(_QWORD *)(v4 + 88), v5);
  TlvValue = qmi::MessageBase::findTlvValue((qmi::MessageBase *)v65);
  v18 = TlvValue;
  if (TlvValue)
  {
    v19 = v17;
    v68 = TlvValue;
    memset(v70, 0, 32);
    tlv::parseV<wms::tlv::BroadcastConfigInfo3GPP2_Resp>(&v68, v17, v70);
    v20 = v68;
    if (!v68)
    {
      v42 = 0;
LABEL_54:
      if (*(_QWORD *)&v70[8])
      {
        *(_QWORD *)&v70[16] = *(_QWORD *)&v70[8];
        operator delete(*(void **)&v70[8]);
      }
      if (!v20)
        ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(v65[0], 17, v18, v19);
      goto LABEL_58;
    }
    v64 = v68;
    v61 = v19;
    v62 = v18;
    v63 = v5;
    v21 = *v15;
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 134217984;
      *(_QWORD *)((char *)&buf + 4) = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)&v70[16] - *(_QWORD *)&v70[8]) >> 1);
      _os_log_impl(&dword_216897000, v21, OS_LOG_TYPE_DEFAULT, "#I Received %lu parameters", (uint8_t *)&buf, 0xCu);
    }
    v22 = *(int **)&v70[8];
    v23 = *(int **)&v70[16];
    v24 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)&v70[16] - *(_QWORD *)&v70[8]) >> 1);
    v26 = v13[1].__vftable;
    shared_owners = (std::__shared_weak_count_vtbl *)v13[1].__shared_owners_;
    v27 = 0xAAAAAAAAAAAAAAABLL * (((char *)shared_owners - (char *)v26) >> 1);
    v28 = v24 - v27;
    if (v24 <= v27)
    {
      if (v24 >= v27)
      {
LABEL_49:
        v5 = v63;
        v19 = v61;
        v18 = v62;
LABEL_50:
        if (v22 != v23)
        {
          v45 = v13[1].__vftable;
          do
          {
            v46 = *v22;
            BYTE4(v45->~__shared_weak_count) = *((_BYTE *)v22 + 4);
            LODWORD(v45->~__shared_weak_count) = v46;
            v45 = (std::__shared_weak_count_vtbl *)((char *)v45 + 6);
            v22 = (int *)((char *)v22 + 6);
          }
          while (v22 != v23);
        }
        v42 = v70[0];
        v20 = v64;
        goto LABEL_54;
      }
      v43 = (std::__shared_weak_count_vtbl *)((char *)v26
                                            + 2 * ((uint64_t)(*(_QWORD *)&v70[16] - *(_QWORD *)&v70[8]) >> 1));
    }
    else
    {
      shared_weak_owners = v13[1].__shared_weak_owners_;
      if (0xAAAAAAAAAAAAAAABLL * ((shared_weak_owners - (uint64_t)shared_owners) >> 1) < v28)
      {
        if (v24 > 0x2AAAAAAAAAAAAAAALL)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v30 = 0xAAAAAAAAAAAAAAABLL * ((shared_weak_owners - (uint64_t)v26) >> 1);
        v31 = 0x5555555555555556 * ((shared_weak_owners - (uint64_t)v26) >> 1);
        if (v31 <= v24)
          v31 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)&v70[16] - *(_QWORD *)&v70[8]) >> 1);
        if (v30 >= 0x1555555555555555)
          v32 = 0x2AAAAAAAAAAAAAAALL;
        else
          v32 = v31;
        if (v32 > 0x2AAAAAAAAAAAAAAALL)
          std::__throw_bad_array_new_length[abi:ne180100]();
        v60 = v32;
        v33 = (char *)operator new(6 * v32);
        v34 = &v33[2 * (((char *)shared_owners - (char *)v26) >> 1)];
        v35 = &v33[6 * v24];
        v36 = v34;
        do
        {
          *(_DWORD *)v36 = 0;
          v36[4] = 0;
          v36 += 6;
        }
        while (v36 != v35);
        v5 = v63;
        v18 = v62;
        if (shared_owners != v26)
        {
          do
          {
            v37 = *(_DWORD *)((char *)&shared_owners[-1].__on_zero_shared_weak + 2);
            shared_owners = (std::__shared_weak_count_vtbl *)((char *)shared_owners - 6);
            v38 = BYTE4(shared_owners->~__shared_weak_count);
            *(_DWORD *)(v34 - 6) = v37;
            v34 -= 6;
            v34[4] = v38;
          }
          while (shared_owners != v26);
          shared_owners = v26;
        }
        v13[1].__vftable = (std::__shared_weak_count_vtbl *)v34;
        v13[1].__shared_owners_ = (uint64_t)v35;
        v13[1].__shared_weak_owners_ = (uint64_t)&v33[6 * v60];
        v19 = v61;
        if (shared_owners)
        {
          operator delete(shared_owners);
          v22 = *(int **)&v70[8];
          v23 = *(int **)&v70[16];
        }
        goto LABEL_50;
      }
      v43 = (std::__shared_weak_count_vtbl *)((char *)shared_owners + 6 * v28);
      do
      {
        LODWORD(shared_owners->~__shared_weak_count) = 0;
        BYTE4(shared_owners->~__shared_weak_count) = 0;
        shared_owners = (std::__shared_weak_count_vtbl *)((char *)shared_owners + 6);
      }
      while (shared_owners != v43);
    }
    v13[1].__shared_owners_ = (uint64_t)v43;
    goto LABEL_49;
  }
  v42 = 0;
LABEL_58:
  *(_QWORD *)v70 = 0;
  *(_QWORD *)&v70[8] = 0;
  v47 = *(std::__shared_weak_count **)(v4 + 80);
  if (v47
    && (*(_QWORD *)&v70[8] = std::__shared_weak_count::lock(v47)) != 0
    && (v48 = *(_QWORD *)(v4 + 72), (*(_QWORD *)v70 = v48) != 0))
  {
    *(_QWORD *)&buf = v13 + 1;
    *((_QWORD *)&buf + 1) = v13;
    do
      v49 = __ldxr(v14);
    while (__stxr(v49 + 1, v14));
    (*(void (**)(uint64_t, uint64_t, __int128 *, uint64_t))(*(_QWORD *)v48 + 128))(v48, v42, &buf, v5);
    v50 = (std::__shared_weak_count *)*((_QWORD *)&buf + 1);
    if (*((_QWORD *)&buf + 1))
    {
      v51 = (unint64_t *)(*((_QWORD *)&buf + 1) + 8);
      do
        v52 = __ldaxr(v51);
      while (__stlxr(v52 - 1, v51));
      if (!v52)
      {
        ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
        std::__shared_weak_count::__release_weak(v50);
      }
    }
  }
  else
  {
    v53 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl(&dword_216897000, v53, OS_LOG_TYPE_ERROR, "Failed to get SMS controller", (uint8_t *)&buf, 2u);
    }
  }
  v54 = *(std::__shared_weak_count **)&v70[8];
  if (*(_QWORD *)&v70[8])
  {
    v55 = (unint64_t *)(*(_QWORD *)&v70[8] + 8);
    do
      v56 = __ldaxr(v55);
    while (__stlxr(v56 - 1, v55));
    if (!v56)
    {
      ((void (*)(std::__shared_weak_count *))v54->__on_zero_shared)(v54);
      std::__shared_weak_count::__release_weak(v54);
    }
  }
  v57 = v67;
  if (v67)
  {
    v58 = (unint64_t *)&v67->__shared_owners_;
    do
      v59 = __ldaxr(v58);
    while (__stlxr(v59 - 1, v58));
    if (!v59)
    {
      ((void (*)(std::__shared_weak_count *))v57->__on_zero_shared)(v57);
      std::__shared_weak_count::__release_weak(v57);
    }
  }
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v65);
}

void sub_2168F425C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,char a23,void *__p,uint64_t a25)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a21);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a23);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a18);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a15);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_32c106_ZTSNSt3__110shared_ptrIZN19QMISMSCommandDriver27sendGetBroadcastConfig3GPP2EN10subscriber7SimSlotEE3__1EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c106_ZTSNSt3__110shared_ptrIZN19QMISMSCommandDriver27sendGetBroadcastConfig3GPP2EN10subscriber7SimSlotEE3__1EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMISMSCommandDriver::sendGetBroadcastConfig3GPP2(subscriber::SimSlot)::$_1,std::allocator<QMISMSCommandDriver::sendGetBroadcastConfig3GPP2(subscriber::SimSlot)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C6D10;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMISMSCommandDriver::sendGetBroadcastConfig3GPP2(subscriber::SimSlot)::$_1,std::allocator<QMISMSCommandDriver::sendGetBroadcastConfig3GPP2(subscriber::SimSlot)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C6D10;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void std::__shared_ptr_emplace<std::vector<sms::BroadcastConfig3GPP2>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C6D60;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<std::vector<sms::BroadcastConfig3GPP2>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C6D60;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void std::__shared_ptr_emplace<std::vector<sms::BroadcastConfig3GPP2>>::__on_zero_shared(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(_QWORD *)(a1 + 32) = v2;
    operator delete(v2);
  }
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN19QMISMSCommandDriver7getSmscEN10subscriber7SimSlotEE3__0EEOS1_OT__block_invoke(uint64_t a1, _QWORD *a2)
{
  unsigned int v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  os_log_t *v9;
  os_log_t *v10;
  int v11;
  NSObject *v12;
  _BOOL8 v13;
  std::__shared_weak_count *v14;
  std::__shared_weak_count *v15;
  unint64_t v16;
  uint64_t TlvValue;
  int v18;
  uint64_t v19;
  int v20;
  unint64_t v21;
  NSObject *v22;
  unint64_t *p_shared_owners;
  unint64_t v24;
  uint64_t v25;
  _QWORD v26[3];
  unint64_t v27;
  std::__shared_weak_count *v28;
  void *v29[2];
  __int128 v30;
  void *v31[2];
  __int128 v32;
  void *v33[2];
  void *v34[2];
  __int128 v35;
  __int128 v36;
  uint64_t v37;
  uint8_t buf[32];
  void *v39;
  char v40;
  void *v41;
  char v42;
  void *__p;
  char v44;
  uint64_t v45;

  v45 = *MEMORY[0x24BDAC8D0];
  v2 = *(_DWORD *)(a1 + 48);
  v3 = **(_QWORD ***)(a1 + 32);
  if (v2 - 1 >= 3)
    v4 = 0;
  else
    v4 = v2;
  v5 = a2[1];
  v26[0] = *a2;
  v26[1] = v5;
  v6 = a2[2];
  v26[2] = v6;
  if (v6)
  {
    v7 = (unint64_t *)(v6 + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  qmi::MessageBase::validateMsgId((qmi::MessageBase *)v26);
  v37 = 0;
  v35 = 0u;
  v36 = 0u;
  *(_OWORD *)v33 = 0u;
  *(_OWORD *)v34 = 0u;
  *(_OWORD *)v31 = 0u;
  v32 = 0u;
  *(_OWORD *)v29 = 0u;
  v30 = 0u;
  CSIPhoneNumber::CSIPhoneNumber((CSIPhoneNumber *)v29);
  v9 = (os_log_t *)(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)v3[11] + 16))(v3[11], v4);
  v10 = v9;
  v11 = HIDWORD(v26[0]);
  if (HIDWORD(v26[0]))
  {
    v12 = *v9;
    if (os_log_type_enabled(*v9, OS_LOG_TYPE_ERROR))
    {
      v25 = qmi::asString();
      *(_DWORD *)buf = 67109378;
      *(_DWORD *)&buf[4] = v11;
      *(_WORD *)&buf[8] = 2080;
      *(_QWORD *)&buf[10] = v25;
      _os_log_error_impl(&dword_216897000, v12, OS_LOG_TYPE_ERROR, "Error received for getSmsc 0x%x, %s", buf, 0x12u);
    }
    goto LABEL_10;
  }
  TlvValue = qmi::MessageBase::findTlvValue((qmi::MessageBase *)v26);
  v19 = TlvValue;
  if (!TlvValue)
  {
LABEL_10:
    v13 = 0;
    goto LABEL_11;
  }
  v20 = v18;
  v27 = TlvValue;
  memset(buf, 0, sizeof(buf));
  tlv::parseV<wms::tlv::SMSCInfo>(&v27, v18, buf);
  v21 = v27;
  if (v27)
    v13 = QMISMSCommandDriver::processSmscInfo(v3[11], v4, buf, (uint64_t)v29);
  else
    v13 = 0;
  if (*(_QWORD *)&buf[8])
  {
    *(_QWORD *)&buf[16] = *(_QWORD *)&buf[8];
    operator delete(*(void **)&buf[8]);
  }
  if (!v21)
    ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(LOWORD(v26[0]), 1, v19, v20);
LABEL_11:
  v27 = 0;
  v28 = 0;
  v14 = (std::__shared_weak_count *)v3[10];
  if (v14)
  {
    v15 = std::__shared_weak_count::lock(v14);
    v28 = v15;
    if (v15)
    {
      v16 = v3[9];
      v27 = v16;
      if (v16)
      {
        CSIPhoneNumber::CSIPhoneNumber((CSIPhoneNumber *)buf, (const CSIPhoneNumber *)v29);
        (*(void (**)(unint64_t, uint64_t, _BOOL8, uint8_t *))(*(_QWORD *)v16 + 56))(v16, v4, v13, buf);
        if (v44 < 0)
          operator delete(__p);
        if (v42 < 0)
          operator delete(v41);
        if (v40 < 0)
          operator delete(v39);
        if ((char)buf[31] < 0)
          operator delete(*(void **)&buf[8]);
        goto LABEL_28;
      }
    }
  }
  else
  {
    v15 = 0;
  }
  v22 = *v10;
  if (os_log_type_enabled(*v10, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl(&dword_216897000, v22, OS_LOG_TYPE_ERROR, "Failed to get Sms controller...", buf, 2u);
    if (!v15)
      goto LABEL_32;
  }
  else if (!v15)
  {
    goto LABEL_32;
  }
LABEL_28:
  p_shared_owners = (unint64_t *)&v15->__shared_owners_;
  do
    v24 = __ldaxr(p_shared_owners);
  while (__stlxr(v24 - 1, p_shared_owners));
  if (!v24)
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
LABEL_32:
  if (SHIBYTE(v35) < 0)
    operator delete(v34[1]);
  if (SHIBYTE(v34[0]) < 0)
    operator delete(v33[0]);
  if (SBYTE7(v32) < 0)
    operator delete(v31[0]);
  if (SHIBYTE(v30) < 0)
    operator delete(v29[1]);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v26);
}

void sub_2168F473C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,void *__p,uint64_t a35)
{
  if (__p)
  {
    a35 = (uint64_t)__p;
    operator delete(__p);
  }
  CSIPhoneNumber::~CSIPhoneNumber(&a15);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a10);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_32c85_ZTSNSt3__110shared_ptrIZN19QMISMSCommandDriver7getSmscEN10subscriber7SimSlotEE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c85_ZTSNSt3__110shared_ptrIZN19QMISMSCommandDriver7getSmscEN10subscriber7SimSlotEE3__0EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMISMSCommandDriver::getSmsc(subscriber::SimSlot)::$_0,std::allocator<QMISMSCommandDriver::getSmsc(subscriber::SimSlot)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C6DE0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMISMSCommandDriver::getSmsc(subscriber::SimSlot)::$_0,std::allocator<QMISMSCommandDriver::getSmsc(subscriber::SimSlot)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C6DE0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::SetAddress>::~TlvWrapper(uint64_t a1)
{
  *(_QWORD *)a1 = off_24D5C6E48;
  if (*(char *)(a1 + 39) < 0)
    operator delete(*(void **)(a1 + 16));
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<wms::tlv::SetAddress>::~TlvWrapper(uint64_t a1)
{
  *(_QWORD *)a1 = off_24D5C6E48;
  if (*(char *)(a1 + 39) < 0)
    operator delete(*(void **)(a1 + 16));
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::SetAddress>::getSize(uint64_t a1)
{
  return tlv::size<wds::tlv::Dnn>(a1 + 16);
}

void *qmi::MutableMessageBase::TlvWrapper<wms::tlv::SetAddress>::write(uint64_t a1, void **a2)
{
  char v3;
  char *v4;
  uint64_t v5;
  void *result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (char *)*a2;
  v5 = (uint64_t)*a2 + 3;
  *a2 = (void *)v5;
  result = tlv::writeV<wds::tlv::Dnn>(a2, (_QWORD *)(a1 + 16));
  v7 = (char *)*a2 - v5;
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::SetAddress>::clone(uint64_t a1)
{
  uint64_t v2;
  std::string *v3;

  v2 = operator new();
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)v2 = off_24D5C6E48;
  v3 = (std::string *)(v2 + 16);
  if (*(char *)(a1 + 39) < 0)
  {
    std::string::__init_copy_ctor_external(v3, *(const std::string::value_type **)(a1 + 16), *(_QWORD *)(a1 + 24));
  }
  else
  {
    *(_OWORD *)&v3->__r_.__value_.__l.__data_ = *(_OWORD *)(a1 + 16);
    *(_QWORD *)(v2 + 32) = *(_QWORD *)(a1 + 32);
  }
  return v2;
}

void sub_2168F4978(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199FEAC4](v1, 0x1093C4081B1C094);
  _Unwind_Resume(a1);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::SetAddressType>::~TlvWrapper(uint64_t a1)
{
  *(_QWORD *)a1 = off_24D5C6E98;
  if (*(char *)(a1 + 39) < 0)
    operator delete(*(void **)(a1 + 16));
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<wms::tlv::SetAddressType>::~TlvWrapper(uint64_t a1)
{
  *(_QWORD *)a1 = off_24D5C6E98;
  if (*(char *)(a1 + 39) < 0)
    operator delete(*(void **)(a1 + 16));
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::SetAddressType>::getSize(uint64_t a1)
{
  return tlv::size<wds::tlv::Dnn>(a1 + 16);
}

void *qmi::MutableMessageBase::TlvWrapper<wms::tlv::SetAddressType>::write(uint64_t a1, void **a2)
{
  char v3;
  char *v4;
  uint64_t v5;
  void *result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (char *)*a2;
  v5 = (uint64_t)*a2 + 3;
  *a2 = (void *)v5;
  result = tlv::writeV<wds::tlv::Dnn>(a2, (_QWORD *)(a1 + 16));
  v7 = (char *)*a2 - v5;
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wms::tlv::SetAddressType>::clone(uint64_t a1)
{
  uint64_t v2;
  std::string *v3;

  v2 = operator new();
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)v2 = off_24D5C6E98;
  v3 = (std::string *)(v2 + 16);
  if (*(char *)(a1 + 39) < 0)
  {
    std::string::__init_copy_ctor_external(v3, *(const std::string::value_type **)(a1 + 16), *(_QWORD *)(a1 + 24));
  }
  else
  {
    *(_OWORD *)&v3->__r_.__value_.__l.__data_ = *(_OWORD *)(a1 + 16);
    *(_QWORD *)(v2 + 32) = *(_QWORD *)(a1 + 32);
  }
  return v2;
}

void sub_2168F4AFC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199FEAC4](v1, 0x1093C4081B1C094);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN19QMISMSCommandDriver7setSmscEN10subscriber7SimSlotERK14CSIPhoneNumberE3__2EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  unsigned int v3;
  uint64_t v4;
  uint64_t v5;
  os_log_t *v6;
  os_log_t *v7;
  int v8;
  NSObject *v9;
  std::__shared_weak_count *v10;
  std::__shared_weak_count *v11;
  uint64_t v12;
  NSObject *v13;
  unint64_t *p_shared_owners;
  unint64_t v15;
  _DWORD v16[2];
  __int16 v17;
  uint64_t v18;
  uint64_t v19;

  v19 = *MEMORY[0x24BDAC8D0];
  v3 = *(_DWORD *)(a1 + 48);
  v4 = **(_QWORD **)(a1 + 32);
  if (v3 - 1 >= 3)
    v5 = 0;
  else
    v5 = v3;
  v6 = (os_log_t *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v4 + 88) + 16))(*(_QWORD *)(v4 + 88), v5);
  v7 = v6;
  v8 = *(_DWORD *)(a2 + 4);
  if (v8)
  {
    v9 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
    {
      v16[0] = 67109378;
      v16[1] = v8;
      v17 = 2080;
      v18 = qmi::asString();
      _os_log_error_impl(&dword_216897000, v9, OS_LOG_TYPE_ERROR, "Error received for getSmsc 0x%x, %s", (uint8_t *)v16, 0x12u);
    }
  }
  v10 = *(std::__shared_weak_count **)(v4 + 80);
  if (v10)
  {
    v11 = std::__shared_weak_count::lock(v10);
    if (v11)
    {
      v12 = *(_QWORD *)(v4 + 72);
      if (v12)
      {
        (*(void (**)(uint64_t, BOOL, uint64_t))(*(_QWORD *)v12 + 64))(v12, v8 == 0, v5);
        goto LABEL_14;
      }
    }
  }
  else
  {
    v11 = 0;
  }
  v13 = *v7;
  if (os_log_type_enabled(*v7, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v16[0]) = 0;
    _os_log_error_impl(&dword_216897000, v13, OS_LOG_TYPE_ERROR, "Failed to get Sms controller...", (uint8_t *)v16, 2u);
    if (!v11)
      return;
  }
  else if (!v11)
  {
    return;
  }
LABEL_14:
  p_shared_owners = (unint64_t *)&v11->__shared_owners_;
  do
    v15 = __ldaxr(p_shared_owners);
  while (__stlxr(v15 - 1, p_shared_owners));
  if (!v15)
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
}

void sub_2168F4CCC(_Unwind_Exception *exception_object)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v4;

  p_shared_owners = (unint64_t *)&v1->__shared_owners_;
  do
    v4 = __ldaxr(p_shared_owners);
  while (__stlxr(v4 - 1, p_shared_owners));
  if (!v4)
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t __copy_helper_block_e8_32c103_ZTSNSt3__110shared_ptrIZN19QMISMSCommandDriver7setSmscEN10subscriber7SimSlotERK14CSIPhoneNumberE3__2EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c103_ZTSNSt3__110shared_ptrIZN19QMISMSCommandDriver7setSmscEN10subscriber7SimSlotERK14CSIPhoneNumberE3__2EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMISMSCommandDriver::setSmsc(subscriber::SimSlot,CSIPhoneNumber const&)::$_2,std::allocator<QMISMSCommandDriver::setSmsc(subscriber::SimSlot,CSIPhoneNumber const&)::$_2>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C6F00;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMISMSCommandDriver::setSmsc(subscriber::SimSlot,CSIPhoneNumber const&)::$_2,std::allocator<QMISMSCommandDriver::setSmsc(subscriber::SimSlot,CSIPhoneNumber const&)::$_2>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C6F00;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3wms14SetSmscAddress8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2168F4E38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN19QMISMSCommandDriver27fetchVoicemailNotificationsEN10subscriber7SimSlotEE3__0EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  uint64_t v3;
  uint64_t v4;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  unsigned __int8 *TlvValue;
  int v14;
  unsigned __int8 *v15;
  int v16;
  unsigned __int8 *v17;
  uint64_t v18;
  uint64_t v19;
  NSObject *v20;
  NSObject *v21;
  unint64_t *p_shared_owners;
  unint64_t v23;
  _QWORD v24[3];
  void *__p;
  void *v26;
  uint64_t v27;
  unsigned __int8 *v28;

  v2 = *(_DWORD *)(a1 + 48);
  v3 = **(_QWORD **)(a1 + 32);
  if (v2 - 1 >= 3)
    v4 = 0;
  else
    v4 = v2;
  if (*(_DWORD *)(a2 + 4))
  {
    v5 = *(std::__shared_weak_count **)(v3 + 80);
    if (v5)
    {
      v6 = std::__shared_weak_count::lock(v5);
      if (v6)
      {
        v7 = *(_QWORD *)(v3 + 72);
        if (v7)
        {
          (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v7 + 144))(v7, v4);
LABEL_34:
          p_shared_owners = (unint64_t *)&v6->__shared_owners_;
          do
            v23 = __ldaxr(p_shared_owners);
          while (__stlxr(v23 - 1, p_shared_owners));
          if (!v23)
          {
            ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
            std::__shared_weak_count::__release_weak(v6);
          }
          return;
        }
      }
    }
    else
    {
      v6 = 0;
    }
    v21 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v3 + 88) + 16))(*(_QWORD *)(v3 + 88), v4);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p) = 0;
      _os_log_error_impl(&dword_216897000, v21, OS_LOG_TYPE_ERROR, "Failed to get Sms controller...", (uint8_t *)&__p, 2u);
      if (!v6)
        return;
    }
    else if (!v6)
    {
      return;
    }
    goto LABEL_34;
  }
  if ((v4 - 1) >= 3)
    v8 = 0;
  else
    v8 = v4;
  v9 = *(_QWORD *)(a2 + 8);
  v24[0] = *(_QWORD *)a2;
  v24[1] = v9;
  v10 = *(_QWORD *)(a2 + 16);
  v24[2] = v10;
  if (v10)
  {
    v11 = (unint64_t *)(v10 + 8);
    do
      v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
  }
  qmi::MessageBase::validateMsgId((qmi::MessageBase *)v24);
  TlvValue = (unsigned __int8 *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)v24);
  v15 = TlvValue;
  if (!TlvValue)
    goto LABEL_25;
  v16 = v14;
  v27 = 0;
  v28 = TlvValue;
  __p = 0;
  v26 = 0;
  tlv::parseV<wms::tlv::MsgWaitingInfo>(&v28, v14, (uint64_t *)&__p);
  v17 = v28;
  if (v28)
  {
    if (v8 - 1 >= 3)
      v18 = 0;
    else
      v18 = v8;
    QMISMSCommandDriver::handleMsgWaitingInfo(v3, v18, (uint64_t *)&__p);
  }
  if (__p)
  {
    v26 = __p;
    operator delete(__p);
  }
  if (!v17
    && (((uint64_t (*)(_QWORD, uint64_t, unsigned __int8 *, _QWORD))*MEMORY[0x24BED8BD0])(LOWORD(v24[0]), 1, v15, v16) & 1) == 0)
  {
LABEL_25:
    if (v8 - 1 >= 3)
      v19 = 0;
    else
      v19 = v8;
    v20 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v3 + 88) + 16))(*(_QWORD *)(v3 + 88), v19);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p) = 0;
      _os_log_error_impl(&dword_216897000, v20, OS_LOG_TYPE_ERROR, "Failed to apply mandatory MsgWaitingInfo tlv to indication", (uint8_t *)&__p, 2u);
    }
  }
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v24);
}

void sub_2168F50B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14)
{
  if (__p)
  {
    a14 = (uint64_t)__p;
    operator delete(__p);
  }
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a10);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_32c106_ZTSNSt3__110shared_ptrIZN19QMISMSCommandDriver27fetchVoicemailNotificationsEN10subscriber7SimSlotEE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c106_ZTSNSt3__110shared_ptrIZN19QMISMSCommandDriver27fetchVoicemailNotificationsEN10subscriber7SimSlotEE3__0EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMISMSCommandDriver::fetchVoicemailNotifications(subscriber::SimSlot)::$_0,std::allocator<QMISMSCommandDriver::fetchVoicemailNotifications(subscriber::SimSlot)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C6FA8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMISMSCommandDriver::fetchVoicemailNotifications(subscriber::SimSlot)::$_0,std::allocator<QMISMSCommandDriver::fetchVoicemailNotifications(subscriber::SimSlot)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C6FA8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN19QMISMSCommandDriver12setRadioModeEbE3__1EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  int v5;
  uint64_t v6;
  uint64_t v7;

  v2 = a2;
  v7 = *MEMORY[0x24BDAC8D0];
  LODWORD(a2) = *(_DWORD *)(a1 + 48);
  v3 = **(_QWORD **)(a1 + 32);
  if (*(_DWORD *)(v2 + 4))
  {
    if ((a2 - 1) >= 3)
      a2 = 0;
    else
      a2 = a2;
    v4 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v3 + 88) + 16))(*(_QWORD *)(v3 + 88), a2);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = 136315138;
      v6 = qmi::asString();
      _os_log_error_impl(&dword_216897000, v4, OS_LOG_TYPE_ERROR, "Radio mode change failed: %s", (uint8_t *)&v5, 0xCu);
    }
  }
  else
  {
    QMISMSCommandDriver::setRoutes(v3, a2);
  }
}

uint64_t __copy_helper_block_e8_32c70_ZTSNSt3__110shared_ptrIZN19QMISMSCommandDriver12setRadioModeEbE3__1EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c70_ZTSNSt3__110shared_ptrIZN19QMISMSCommandDriver12setRadioModeEbE3__1EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMISMSCommandDriver::setRadioMode(BOOL)::$_1,std::allocator<QMISMSCommandDriver::setRadioMode(BOOL)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C7028;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMISMSCommandDriver::setRadioMode(BOOL)::$_1,std::allocator<QMISMSCommandDriver::setRadioMode(BOOL)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C7028;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::setSmsRoutes(subscriber::SimSlot)::$_0>(QMISMSCommandDriver::setSmsRoutes(subscriber::SimSlot)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMISMSCommandDriver::setSmsRoutes(subscriber::SimSlot)::$_0,dispatch_queue_s *::default_delete<QMISMSCommandDriver::setSmsRoutes(subscriber::SimSlot)::$_0>>)::{lambda(void *)#1}::__invoke(uint64_t *a1)
{
  uint64_t v1;
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  unsigned int v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  uint64_t *v10;
  uint64_t v11;

  v1 = *a1;
  v10 = a1;
  v11 = v1;
  v2 = *(std::__shared_weak_count **)(v1 + 24);
  if (v2)
  {
    v3 = *(_QWORD *)v1;
    v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      v5 = v4;
      if (*(_QWORD *)(v1 + 16))
      {
        if ((*(_DWORD *)(v1 + 8) - 1) >= 3)
          v6 = 0;
        else
          v6 = *(_DWORD *)(v1 + 8);
        QMISMSCommandDriver::setRoutes(v3, v6);
      }
      p_shared_owners = (unint64_t *)&v5->__shared_owners_;
      do
        v8 = __ldaxr(p_shared_owners);
      while (__stlxr(v8 - 1, p_shared_owners));
      if (!v8)
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
    }
  }
  std::unique_ptr<QMISMSCommandDriver::setSmsRoutes(subscriber::SimSlot)::$_0,std::default_delete<QMISMSCommandDriver::setSmsRoutes(subscriber::SimSlot)::$_0>>::~unique_ptr[abi:ne180100](&v11);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v10);
}

void sub_2168F53B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v13;

  p_shared_owners = (unint64_t *)&v10->__shared_owners_;
  do
    v13 = __ldaxr(p_shared_owners);
  while (__stlxr(v13 - 1, p_shared_owners));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  std::unique_ptr<QMISMSCommandDriver::setSmsRoutes(subscriber::SimSlot)::$_0,std::default_delete<QMISMSCommandDriver::setSmsRoutes(subscriber::SimSlot)::$_0>>::~unique_ptr[abi:ne180100](&a10);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

uint64_t *std::unique_ptr<QMISMSCommandDriver::setSmsRoutes(subscriber::SimSlot)::$_0,std::default_delete<QMISMSCommandDriver::setSmsRoutes(subscriber::SimSlot)::$_0>>::~unique_ptr[abi:ne180100](uint64_t *a1)
{
  uint64_t v2;
  std::__shared_weak_count *v3;

  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    v3 = *(std::__shared_weak_count **)(v2 + 24);
    if (v3)
      std::__shared_weak_count::__release_weak(v3);
    MEMORY[0x2199FEAC4](v2, 0x1020C405028CB4ALL);
  }
  return a1;
}

BOOL EurekaC2KCallFormatter::isTechnology(uint64_t a1, int a2)
{
  return a2 == 1;
}

void EurekaC2KCallFormatter::createSecondCallDialReq(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v5;
  _OWORD *v6;
  NSObject *v7;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  _QWORD *v26;
  uint64_t v27;
  __int128 *v28;
  uint64_t v29;
  __int128 *v30;
  uint64_t v31;
  void *__p[2];
  char v33;
  uint64_t v34;
  void *v35[51];
  int v36;
  _BYTE v37[24];
  _BYTE *v38;
  __int128 buf;
  _BYTE v40[24];
  _BYTE *v41;
  __int128 v42;
  uint64_t v43;
  int v44;
  void *v45[51];
  _BYTE v46[24];
  _BYTE *v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  uint64_t v53;

  v53 = *MEMORY[0x24BDAC8D0];
  v5 = *(unsigned int *)(a2 + 252);
  *(_QWORD *)(a4 + 48) = 0;
  v6 = (_OWORD *)(a4 + 48);
  *(_OWORD *)a4 = 0u;
  *(_OWORD *)(a4 + 16) = 0u;
  *(_OWORD *)(a4 + 32) = 0u;
  *(_QWORD *)(a4 + 56) = 0;
  *(_DWORD *)(a4 + 48) = 25000;
  v7 = *(NSObject **)(a1 + 8);
  if (!*(_BYTE *)(a2 + 84))
  {
    if (os_log_type_enabled(*(os_log_t *)(a1 + 8), OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl(&dword_216897000, v7, OS_LOG_TYPE_DEFAULT, "#I Sending blank flash to place call on hold and dial out new call", (uint8_t *)&buf, 2u);
    }
    v51 = 0u;
    v52 = 0u;
    v34 = a1;
    CallInfo::CallInfo((CallInfo *)v35, (const CallInfo *)a2);
    v36 = v5;
    *((_QWORD *)&v52 + 1) = 0;
    v11 = operator new(0x1B0uLL);
    *v11 = &off_24D5C7158;
    v11[1] = a1;
    CallInfo::CallInfo((CallInfo *)(v11 + 2), (const CallInfo *)v35);
    *((_DWORD *)v11 + 106) = v36;
    *((_QWORD *)&v52 + 1) = v11;
    CallInfo::~CallInfo(v35);
    v49 = 0u;
    v50 = 0u;
    v43 = a1;
    v44 = v5;
    CallInfo::CallInfo((CallInfo *)v45, (const CallInfo *)a2);
    v12 = v46;
    v13 = *((_QWORD *)&v52 + 1);
    if (*((_QWORD *)&v52 + 1))
    {
      if (*((__int128 **)&v52 + 1) == &v51)
      {
        v47 = v46;
        (*(void (**)(__int128 *, _BYTE *))(v51 + 24))(&v51, v46);
LABEL_11:
        v14 = a3[1];
        *(_QWORD *)&v48 = *a3;
        *((_QWORD *)&v48 + 1) = v14;
        if (v14)
        {
          v15 = (unint64_t *)(v14 + 8);
          do
            v16 = __ldxr(v15);
          while (__stxr(v16 + 1, v15));
        }
        *((_QWORD *)&v50 + 1) = 0;
        v17 = operator new(0x1E0uLL);
        v18 = v43;
        *v17 = &off_24D5C7200;
        v17[1] = v18;
        *((_DWORD *)v17 + 4) = v44;
        CallInfo::CallInfo((CallInfo *)(v17 + 3), (const CallInfo *)v45);
        std::__function::__value_func<void ()(qmi::ResponseBase const&)>::__value_func[abi:ne180100]((uint64_t)(v17 + 54), (uint64_t)v46);
        *((_OWORD *)v17 + 29) = v48;
        v48 = 0uLL;
        *((_QWORD *)&v50 + 1) = v17;
        if (v47 == v46)
        {
          v19 = 4;
        }
        else
        {
          if (!v47)
            goto LABEL_19;
          v19 = 5;
          v12 = v47;
        }
        (*(void (**)(_QWORD *))(*v12 + 8 * v19))(v12);
LABEL_19:
        CallInfo::~CallInfo(v45);
        std::string::basic_string[abi:ne180100]<0>(__p, (char *)&unk_216AC4FCA);
        v20 = *((_QWORD *)&v50 + 1);
        if (*((_QWORD *)&v50 + 1))
        {
          if (*((__int128 **)&v50 + 1) == &v49)
          {
            v38 = v37;
            (*(void (**)(__int128 *, _BYTE *))(v49 + 24))(&v49, v37);
LABEL_24:
            EurekaC2KCallFormatter::createFlashRequest((uint64_t)&buf, *(_QWORD *)(a1 + 16), (uint64_t)__p, (uint64_t)v37, v5);
            std::shared_ptr<qmi::Client::State>::operator=[abi:ne180100](a4, &buf);
            std::__function::__value_func<void ()(qmi::ResponseBase const&)>::operator=[abi:ne180100]((_QWORD *)(a4 + 16), (uint64_t)v40);
            *v6 = v42;
            v21 = v41;
            if (v41 == v40)
            {
              v22 = 4;
              v21 = v40;
            }
            else
            {
              if (!v41)
              {
LABEL_29:
                v23 = (std::__shared_weak_count *)*((_QWORD *)&buf + 1);
                if (*((_QWORD *)&buf + 1))
                {
                  v24 = (unint64_t *)(*((_QWORD *)&buf + 1) + 8);
                  do
                    v25 = __ldaxr(v24);
                  while (__stlxr(v25 - 1, v24));
                  if (!v25)
                  {
                    ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
                    std::__shared_weak_count::__release_weak(v23);
                  }
                }
                v26 = v38;
                if (v38 == v37)
                {
                  v27 = 4;
                  v26 = v37;
                }
                else
                {
                  if (!v38)
                    goto LABEL_39;
                  v27 = 5;
                }
                (*(void (**)(void))(*v26 + 8 * v27))();
LABEL_39:
                if (v33 < 0)
                  operator delete(__p[0]);
                v28 = (__int128 *)*((_QWORD *)&v50 + 1);
                if (*((__int128 **)&v50 + 1) == &v49)
                {
                  v29 = 4;
                  v28 = &v49;
                }
                else
                {
                  if (!*((_QWORD *)&v50 + 1))
                    goto LABEL_46;
                  v29 = 5;
                }
                (*(void (**)(void))(*(_QWORD *)v28 + 8 * v29))();
LABEL_46:
                v30 = (__int128 *)*((_QWORD *)&v52 + 1);
                if (*((__int128 **)&v52 + 1) == &v51)
                {
                  v31 = 4;
                  v30 = &v51;
                }
                else
                {
                  if (!*((_QWORD *)&v52 + 1))
                    goto LABEL_51;
                  v31 = 5;
                }
                (*(void (**)(void))(*(_QWORD *)v30 + 8 * v31))();
                goto LABEL_51;
              }
              v22 = 5;
            }
            (*(void (**)(void))(*v21 + 8 * v22))();
            goto LABEL_29;
          }
          v20 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)&v50 + 1) + 16))(*((_QWORD *)&v50 + 1));
        }
        v38 = (_BYTE *)v20;
        goto LABEL_24;
      }
      v13 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)&v52 + 1) + 16))(*((_QWORD *)&v52 + 1));
    }
    v47 = (_BYTE *)v13;
    goto LABEL_11;
  }
  if (os_log_type_enabled(*(os_log_t *)(a1 + 8), OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf) = 0;
    _os_log_error_impl(&dword_216897000, v7, OS_LOG_TYPE_ERROR, "Should be handled by the command driver. Not doing anything.", (uint8_t *)&buf, 2u);
  }
LABEL_51:
  *(_QWORD *)(a4 + 56) = 500000000;
}

void sub_2168F58A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  EurekaVoiceRequestMessage *v14;
  uint64_t v15;
  _QWORD *v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;

  if (a14 < 0)
    operator delete(__p);
  v17 = *(_QWORD **)(v15 - 136);
  if (v17 == (_QWORD *)(v15 - 160))
  {
    v18 = 4;
    v17 = (_QWORD *)(v15 - 160);
  }
  else
  {
    if (!v17)
      goto LABEL_8;
    v18 = 5;
  }
  (*(void (**)(void))(*v17 + 8 * v18))();
LABEL_8:
  v19 = *(_QWORD **)(v15 - 104);
  if (v19 == (_QWORD *)(v15 - 128))
  {
    v20 = 4;
    v19 = (_QWORD *)(v15 - 128);
  }
  else
  {
    if (!v19)
      goto LABEL_13;
    v20 = 5;
  }
  (*(void (**)(void))(*v19 + 8 * v20))();
LABEL_13:
  EurekaVoiceRequestMessage::~EurekaVoiceRequestMessage(v14);
  _Unwind_Resume(a1);
}

uint64_t EurekaC2KCallFormatter::createSecondCallDialReq(CallInfo,qmi::ClientRouter &)::$_1::~$_1(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 456);
  v2 = *(_QWORD **)(a1 + 448);
  if (v2 == (_QWORD *)(a1 + 424))
  {
    v3 = 4;
    v2 = (_QWORD *)(a1 + 424);
    goto LABEL_5;
  }
  if (v2)
  {
    v3 = 5;
LABEL_5:
    (*(void (**)(void))(*v2 + 8 * v3))();
  }
  CallInfo::~CallInfo((void **)(a1 + 16));
  return a1;
}

void EurekaC2KCallFormatter::createFlashRequest(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  char v8;
  uint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t v11;
  char v12;
  unint64_t v13;
  uint64_t v14;
  const void **v15;
  const void **v16;
  char **v17;
  char *v18;
  _QWORD *v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t *v22;
  _QWORD *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  char *v28;
  uint64_t *v29;
  char *v30;
  char *v31;
  char *v32;
  uint64_t v33;
  char *v34;
  unint64_t v35;
  unint64_t *p_shared_owners;
  unint64_t v37;
  std::__shared_weak_count *v38;
  unint64_t *v39;
  unint64_t v40;
  _QWORD *v41;
  uint64_t v42;
  std::__shared_weak_count *v43;
  unint64_t *v44;
  unint64_t v45;
  uint64_t v46;
  std::__shared_weak_count *v47;
  uint64_t v48;
  std::__shared_weak_count *v49;
  uint64_t v50;
  _BYTE v51[24];
  _BYTE *v52;
  uint64_t v53;

  v53 = *MEMORY[0x24BDAC8D0];
  v8 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 64))(a2, a5);
  v9 = operator new();
  *(_OWORD *)v9 = 0u;
  *(_OWORD *)(v9 + 16) = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v9);
  v48 = v9;
  v50 = v9;
  v10 = (std::__shared_weak_count *)operator new();
  v10->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C7690;
  v10->__shared_owners_ = 0;
  v10->__shared_weak_owners_ = 0;
  v10[1].__vftable = (std::__shared_weak_count_vtbl *)v9;
  v49 = v10;
  *(_BYTE *)qmi::MutableMessageBase::getTLV<vs::tlv::CallIdentifier>((_QWORD *)v9, 1) = v8;
  v11 = *(unsigned __int8 *)(a3 + 23);
  v12 = v11;
  v13 = *(_QWORD *)(a3 + 8);
  if ((v11 & 0x80u) == 0)
    v14 = *(unsigned __int8 *)(a3 + 23);
  else
    v14 = *(_QWORD *)(a3 + 8);
  if (v14)
  {
    v15 = *(const void ***)(v9 + 8);
    v16 = *(const void ***)(v9 + 16);
    v17 = (char **)(v9 + 8);
    if (v15 != v16)
    {
      while (*((_BYTE *)*v15 + 8) != 16)
      {
        if (++v15 == v16)
          goto LABEL_12;
      }
    }
    if (v15 == v16)
    {
LABEL_12:
      v20 = operator new();
      *(_BYTE *)(v20 + 8) = 16;
      *(_QWORD *)v20 = &off_24D5C7720;
      *(_QWORD *)(v20 + 16) = 0;
      v19 = (_QWORD *)(v20 + 16);
      *(_QWORD *)(v20 + 24) = 0;
      *(_QWORD *)(v20 + 32) = 0;
      v21 = *(_QWORD *)(v9 + 24);
      v22 = *(uint64_t **)(v9 + 16);
      if ((unint64_t)v22 >= v21)
      {
        v24 = ((char *)v22 - *v17) >> 3;
        if ((unint64_t)(v24 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v25 = v21 - (_QWORD)*v17;
        v26 = v25 >> 2;
        if (v25 >> 2 <= (unint64_t)(v24 + 1))
          v26 = v24 + 1;
        if ((unint64_t)v25 >= 0x7FFFFFFFFFFFFFF8)
          v27 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v27 = v26;
        if (v27)
          v28 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>(v9 + 24, v27);
        else
          v28 = 0;
        v29 = (uint64_t *)&v28[8 * v24];
        v30 = &v28[8 * v27];
        *v29 = v20;
        v23 = v29 + 1;
        v32 = *(char **)(v9 + 8);
        v31 = *(char **)(v9 + 16);
        if (v31 != v32)
        {
          do
          {
            v33 = *((_QWORD *)v31 - 1);
            v31 -= 8;
            *--v29 = v33;
          }
          while (v31 != v32);
          v31 = *v17;
        }
        *(_QWORD *)(v9 + 8) = v29;
        *(_QWORD *)(v9 + 16) = v23;
        *(_QWORD *)(v9 + 24) = v30;
        if (v31)
          operator delete(v31);
      }
      else
      {
        *v22 = v20;
        v23 = v22 + 1;
      }
      *(_QWORD *)(v9 + 16) = v23;
      v11 = *(unsigned __int8 *)(a3 + 23);
      v13 = *(_QWORD *)(a3 + 8);
      v12 = *(_BYTE *)(a3 + 23);
    }
    else
    {
      if (!v18)
        __cxa_bad_cast();
      v19 = v18 + 16;
    }
    if (v12 >= 0)
      v34 = (char *)a3;
    else
      v34 = *(char **)a3;
    if (v12 >= 0)
      v35 = v11;
    else
      v35 = v13;
    std::vector<unsigned char>::__assign_with_size[abi:ne180100]<std::__wrap_iter<char const*>,std::__wrap_iter<char const*>>(v19, v34, &v34[v35], v35);
    v9 = v48;
    v10 = v49;
  }
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 56) = 0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_DWORD *)(a1 + 48) = 25000;
  v46 = v9;
  v47 = v10;
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      v37 = __ldxr(p_shared_owners);
    while (__stxr(v37 + 1, p_shared_owners));
  }
  std::shared_ptr<QMIDataContextIPActivationLock>::operator=[abi:ne180100]((_QWORD *)a1, &v46);
  v38 = v47;
  if (v47)
  {
    v39 = (unint64_t *)&v47->__shared_owners_;
    do
      v40 = __ldaxr(v39);
    while (__stlxr(v40 - 1, v39));
    if (!v40)
    {
      ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
      std::__shared_weak_count::__release_weak(v38);
    }
  }
  std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100]((uint64_t)v51, a4);
  std::function<void ()(qmi::ResponseBase const&)>::operator=((_QWORD *)(a1 + 16), (uint64_t)v51);
  v41 = v52;
  if (v52 == v51)
  {
    v42 = 4;
    v41 = v51;
  }
  else
  {
    if (!v52)
      goto LABEL_49;
    v42 = 5;
  }
  (*(void (**)(_QWORD *))(*v41 + 8 * v42))(v41);
LABEL_49:
  v43 = v49;
  if (v49)
  {
    v44 = (unint64_t *)&v49->__shared_owners_;
    do
      v45 = __ldaxr(v44);
    while (__stlxr(v45 - 1, v44));
    if (!v45)
    {
      ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
      std::__shared_weak_count::__release_weak(v43);
    }
  }
}

void sub_2168F5DCC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, __int16 *a20)
{
  EurekaVoiceRequestMessage *v20;
  __int16 *v21;
  __int16 *v23;
  uint64_t v24;

  v23 = a20;
  if (a20 == v21)
  {
    v24 = 4;
    v23 = &a15;
  }
  else
  {
    if (!a20)
      goto LABEL_6;
    v24 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v23 + 8 * v24))();
LABEL_6:
  EurekaVoiceRequestMessage::~EurekaVoiceRequestMessage(v20);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

void EurekaVoiceRequestMessage::~EurekaVoiceRequestMessage(EurekaVoiceRequestMessage *this)
{
  char *v2;
  char *v3;
  uint64_t v4;

  v2 = (char *)this + 16;
  v3 = (char *)*((_QWORD *)this + 5);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
  }
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)this);
}

_QWORD *EurekaC2KCallFormatter::createAnswerWaitingHoldOtherReq@<X0>(uint64_t a1@<X0>, const void **a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  _OWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  _QWORD *result;
  uint64_t v19;
  void *__p[2];
  char v21;
  uint64_t v22;
  int v23;
  const void *v24;
  _BYTE v25[24];
  _BYTE *v26;
  __int128 v27;
  _BYTE v28[24];
  _BYTE *v29;
  __int128 v30;
  _QWORD v31[3];
  _QWORD *v32;
  uint64_t v33;

  v33 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)(a4 + 48) = 0;
  v7 = (_OWORD *)(a4 + 48);
  *(_QWORD *)(a4 + 56) = 0;
  *(_OWORD *)(a4 + 16) = 0u;
  *(_OWORD *)(a4 + 32) = 0u;
  *(_OWORD *)a4 = 0u;
  *(_DWORD *)(a4 + 48) = 25000;
  memset(v31, 0, sizeof(v31));
  v22 = a1;
  v23 = a3;
  ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::SharedRef(&v24, a2);
  v32 = 0;
  v8 = operator new(0x20uLL);
  v9 = v22;
  *v8 = &off_24D5C7350;
  v8[1] = v9;
  *((_DWORD *)v8 + 4) = v23;
  v8[3] = v24;
  v24 = 0;
  v32 = v8;
  ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::~SharedRef(&v24);
  std::string::basic_string[abi:ne180100]<0>(__p, (char *)&unk_216AC4FCA);
  v10 = (uint64_t)v32;
  if (!v32)
    goto LABEL_4;
  if (v32 != v31)
  {
    v10 = (*(uint64_t (**)(_QWORD *))(*v32 + 16))(v32);
LABEL_4:
    v26 = (_BYTE *)v10;
    goto LABEL_6;
  }
  v26 = v25;
  (*(void (**)(_QWORD *, _BYTE *))(v31[0] + 24))(v31, v25);
LABEL_6:
  EurekaC2KCallFormatter::createFlashRequest((uint64_t)&v27, *(_QWORD *)(a1 + 16), (uint64_t)__p, (uint64_t)v25, a3);
  std::shared_ptr<qmi::Client::State>::operator=[abi:ne180100](a4, &v27);
  std::__function::__value_func<void ()(qmi::ResponseBase const&)>::operator=[abi:ne180100]((_QWORD *)(a4 + 16), (uint64_t)v28);
  *v7 = v30;
  v11 = v29;
  if (v29 == v28)
  {
    v12 = 4;
    v11 = v28;
    goto LABEL_10;
  }
  if (v29)
  {
    v12 = 5;
LABEL_10:
    (*(void (**)(void))(*v11 + 8 * v12))();
  }
  v13 = (std::__shared_weak_count *)*((_QWORD *)&v27 + 1);
  if (*((_QWORD *)&v27 + 1))
  {
    v14 = (unint64_t *)(*((_QWORD *)&v27 + 1) + 8);
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  v16 = v26;
  if (v26 == v25)
  {
    v17 = 4;
    v16 = v25;
  }
  else
  {
    if (!v26)
      goto LABEL_21;
    v17 = 5;
  }
  (*(void (**)(void))(*v16 + 8 * v17))();
LABEL_21:
  if (v21 < 0)
    operator delete(__p[0]);
  result = v32;
  if (v32 == v31)
  {
    v19 = 4;
    result = v31;
  }
  else
  {
    if (!v32)
      return result;
    v19 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v19))();
}

void sub_2168F60F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22)
{
  EurekaVoiceRequestMessage *v22;
  uint64_t v23;
  _QWORD *v25;
  uint64_t v26;

  if (a15 < 0)
    operator delete(__p);
  v25 = *(_QWORD **)(v23 - 64);
  if (v25 == (_QWORD *)(v23 - 88))
  {
    v26 = 4;
    v25 = (_QWORD *)(v23 - 88);
  }
  else
  {
    if (!v25)
      goto LABEL_8;
    v26 = 5;
  }
  (*(void (**)(void))(*v25 + 8 * v26))();
LABEL_8:
  EurekaVoiceRequestMessage::~EurekaVoiceRequestMessage(v22);
  _Unwind_Resume(a1);
}

_QWORD *EurekaC2KCallFormatter::createSwapReq@<X0>(uint64_t a1@<X0>, const void **a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  _OWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  _QWORD *result;
  uint64_t v19;
  void *__p[2];
  char v21;
  uint64_t v22;
  int v23;
  const void *v24;
  _BYTE v25[24];
  _BYTE *v26;
  __int128 v27;
  _BYTE v28[24];
  _BYTE *v29;
  __int128 v30;
  _QWORD v31[3];
  _QWORD *v32;
  uint64_t v33;

  v33 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)(a4 + 48) = 0;
  v7 = (_OWORD *)(a4 + 48);
  *(_QWORD *)(a4 + 56) = 0;
  *(_OWORD *)(a4 + 16) = 0u;
  *(_OWORD *)(a4 + 32) = 0u;
  *(_OWORD *)a4 = 0u;
  *(_DWORD *)(a4 + 48) = 25000;
  memset(v31, 0, sizeof(v31));
  v22 = a1;
  v23 = a3;
  ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::SharedRef(&v24, a2);
  v32 = 0;
  v8 = operator new(0x20uLL);
  v9 = v22;
  *v8 = &off_24D5C73F8;
  v8[1] = v9;
  *((_DWORD *)v8 + 4) = v23;
  v8[3] = v24;
  v24 = 0;
  v32 = v8;
  ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::~SharedRef(&v24);
  std::string::basic_string[abi:ne180100]<0>(__p, (char *)&unk_216AC4FCA);
  v10 = (uint64_t)v32;
  if (!v32)
    goto LABEL_4;
  if (v32 != v31)
  {
    v10 = (*(uint64_t (**)(_QWORD *))(*v32 + 16))(v32);
LABEL_4:
    v26 = (_BYTE *)v10;
    goto LABEL_6;
  }
  v26 = v25;
  (*(void (**)(_QWORD *, _BYTE *))(v31[0] + 24))(v31, v25);
LABEL_6:
  EurekaC2KCallFormatter::createFlashRequest((uint64_t)&v27, *(_QWORD *)(a1 + 16), (uint64_t)__p, (uint64_t)v25, a3);
  std::shared_ptr<qmi::Client::State>::operator=[abi:ne180100](a4, &v27);
  std::__function::__value_func<void ()(qmi::ResponseBase const&)>::operator=[abi:ne180100]((_QWORD *)(a4 + 16), (uint64_t)v28);
  *v7 = v30;
  v11 = v29;
  if (v29 == v28)
  {
    v12 = 4;
    v11 = v28;
    goto LABEL_10;
  }
  if (v29)
  {
    v12 = 5;
LABEL_10:
    (*(void (**)(void))(*v11 + 8 * v12))();
  }
  v13 = (std::__shared_weak_count *)*((_QWORD *)&v27 + 1);
  if (*((_QWORD *)&v27 + 1))
  {
    v14 = (unint64_t *)(*((_QWORD *)&v27 + 1) + 8);
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  v16 = v26;
  if (v26 == v25)
  {
    v17 = 4;
    v16 = v25;
  }
  else
  {
    if (!v26)
      goto LABEL_21;
    v17 = 5;
  }
  (*(void (**)(void))(*v16 + 8 * v17))();
LABEL_21:
  if (v21 < 0)
    operator delete(__p[0]);
  result = v32;
  if (v32 == v31)
  {
    v19 = 4;
    result = v31;
  }
  else
  {
    if (!v32)
      return result;
    v19 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v19))();
}

void sub_2168F63F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22)
{
  EurekaVoiceRequestMessage *v22;
  uint64_t v23;
  _QWORD *v25;
  uint64_t v26;

  if (a15 < 0)
    operator delete(__p);
  v25 = *(_QWORD **)(v23 - 64);
  if (v25 == (_QWORD *)(v23 - 88))
  {
    v26 = 4;
    v25 = (_QWORD *)(v23 - 88);
  }
  else
  {
    if (!v25)
      goto LABEL_8;
    v26 = 5;
  }
  (*(void (**)(void))(*v25 + 8 * v26))();
LABEL_8:
  EurekaVoiceRequestMessage::~EurekaVoiceRequestMessage(v22);
  _Unwind_Resume(a1);
}

void EurekaC2KCallFormatter::createAnswerWaitingEndActiveReq(uint64_t a1@<X0>, uint64_t a2@<X1>, _OWORD *a3@<X8>)
{
  NSObject *v6;
  uint8_t v7[16];

  v6 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v7 = 0;
    _os_log_impl(&dword_216897000, v6, OS_LOG_TYPE_DEFAULT, "#I Sending end. CDMA ends all calls.", v7, 2u);
  }
  (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 136))(*(_QWORD *)(a1 + 16));
  a3[2] = 0u;
  a3[3] = 0u;
  *a3 = 0u;
  a3[1] = 0u;
  EurekaC2KCallFormatter::createEndcallReq((uint64_t)a3, a1, a2);
}

void EurekaC2KCallFormatter::createEndcallReq(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v3;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  qmi::MutableMessageBase *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  uint64_t v20;
  std::__shared_weak_count *v21;
  uint8_t buf[8];
  std::__shared_weak_count *v23;
  _QWORD v24[3];
  _QWORD *v25;
  uint64_t v26;

  v3 = a3;
  v26 = *MEMORY[0x24BDAC8D0];
  v6 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a2 + 16) + 64))(*(_QWORD *)(a2 + 16), a3);
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 48) = 25000;
  if ((_DWORD)v6 == *MEMORY[0x24BDC39A8])
  {
    v7 = *(NSObject **)(a2 + 8);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_216897000, v7, OS_LOG_TYPE_ERROR, "Invalid traffic channel id. Cannot end call.", buf, 2u);
    }
    return;
  }
  v8 = v6;
  *(_QWORD *)buf = 0;
  v23 = 0;
  v9 = (qmi::MutableMessageBase *)operator new();
  *(_OWORD *)v9 = 0u;
  *((_OWORD *)v9 + 1) = 0u;
  qmi::MutableMessageBase::MutableMessageBase(v9);
  std::shared_ptr<vs::EndCall::Request>::shared_ptr[abi:ne180100]<vs::EndCall::Request,void>(buf, (uint64_t)v9);
  *(_BYTE *)qmi::MutableMessageBase::getTLV<vs::tlv::CallIdentifier>(*(_QWORD **)buf, 1) = v8;
  v20 = *(_QWORD *)buf;
  v21 = v23;
  if (v23)
  {
    p_shared_owners = (unint64_t *)&v23->__shared_owners_;
    do
      v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
  }
  std::shared_ptr<QMIDataContextIPActivationLock>::operator=[abi:ne180100]((_QWORD *)a1, &v20);
  v12 = v21;
  if (v21)
  {
    v13 = (unint64_t *)&v21->__shared_owners_;
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  v24[0] = &off_24D5C77D0;
  v24[1] = a2;
  v24[2] = v3 | (unint64_t)(v8 << 32);
  v25 = v24;
  std::function<void ()(qmi::ResponseBase const&)>::operator=((_QWORD *)(a1 + 16), (uint64_t)v24);
  v15 = v25;
  if (v25 == v24)
  {
    v16 = 4;
    v15 = v24;
    goto LABEL_16;
  }
  if (v25)
  {
    v16 = 5;
LABEL_16:
    (*(void (**)(_QWORD *))(*v15 + 8 * v16))(v15);
  }
  v17 = v23;
  if (v23)
  {
    v18 = (unint64_t *)&v23->__shared_owners_;
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
}

void sub_2168F6768(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, char *a17)
{
  EurekaVoiceRequestMessage *v17;
  char *v18;
  char *v20;
  uint64_t v21;

  v20 = a17;
  if (a17 == v18)
  {
    v21 = 4;
    v20 = &a14;
  }
  else
  {
    if (!a17)
      goto LABEL_6;
    v21 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v20 + 8 * v21))();
LABEL_6:
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  EurekaVoiceRequestMessage::~EurekaVoiceRequestMessage(v17);
  _Unwind_Resume(a1);
}

uint8_t *EurekaC2KCallFormatter::createMergeReq@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  NSObject *v6;
  _QWORD *v7;
  uint64_t v8;
  std::string *v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  uint8_t *result;
  uint64_t v14;
  void *v15[2];
  char v16;
  uint64_t v17;
  void *v18[51];
  std::string __p;
  _BYTE v20[24];
  _BYTE *v21;
  uint8_t buf[16];
  __int128 v23;
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  v6 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_216897000, v6, OS_LOG_TYPE_DEFAULT, "#I Creating msg to create multi party call", buf, 2u);
  }
  *(_OWORD *)buf = 0u;
  v23 = 0u;
  v17 = a1;
  CallInfo::CallInfo((CallInfo *)v18, (const CallInfo *)a2);
  if (*(char *)(a2 + 431) < 0)
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)(a2 + 408), *(_QWORD *)(a2 + 416));
  else
    __p = *(std::string *)(a2 + 408);
  v7 = operator new(0x1C0uLL);
  v8 = v17;
  *v7 = off_24D5C74A0;
  v7[1] = v8;
  CallInfo::CallInfo((CallInfo *)(v7 + 2), (const CallInfo *)v18);
  v9 = (std::string *)(v7 + 53);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    std::string::__init_copy_ctor_external(v9, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
    *((_QWORD *)&v23 + 1) = v7;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
  }
  else
  {
    *(_OWORD *)&v9->__r_.__value_.__l.__data_ = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
    v7[55] = *((_QWORD *)&__p.__r_.__value_.__l + 2);
    *((_QWORD *)&v23 + 1) = v7;
  }
  CallInfo::~CallInfo(v18);
  std::string::basic_string[abi:ne180100]<0>(v15, (char *)&unk_216AC4FCA);
  v10 = *((_QWORD *)&v23 + 1);
  if (!*((_QWORD *)&v23 + 1))
    goto LABEL_13;
  if (*((uint8_t **)&v23 + 1) != buf)
  {
    v10 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)&v23 + 1) + 16))(*((_QWORD *)&v23 + 1));
LABEL_13:
    v21 = (_BYTE *)v10;
    goto LABEL_15;
  }
  v21 = v20;
  (*(void (**)(uint8_t *, _BYTE *))(*(_QWORD *)buf + 24))(buf, v20);
LABEL_15:
  EurekaC2KCallFormatter::createFlashRequest(a3, *(_QWORD *)(a1 + 16), (uint64_t)v15, (uint64_t)v20, *(unsigned int *)(a2 + 252));
  v11 = v21;
  if (v21 == v20)
  {
    v12 = 4;
    v11 = v20;
  }
  else
  {
    if (!v21)
      goto LABEL_20;
    v12 = 5;
  }
  (*(void (**)(void))(*v11 + 8 * v12))();
LABEL_20:
  if (v16 < 0)
    operator delete(v15[0]);
  result = (uint8_t *)*((_QWORD *)&v23 + 1);
  if (*((uint8_t **)&v23 + 1) == buf)
  {
    v14 = 4;
    result = buf;
  }
  else
  {
    if (!*((_QWORD *)&v23 + 1))
      return result;
    v14 = 5;
  }
  return (uint8_t *)(*(uint64_t (**)(void))(*(_QWORD *)result + 8 * v14))();
}

void sub_2168F6A2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  void *v15;
  void **v16;

  CallInfo::~CallInfo(v16);
  operator delete(v15);
  EurekaC2KCallFormatter::createMergeReq(CallOperationContext)::$_0::~$_0((uint64_t)&a15);
  _Unwind_Resume(a1);
}

uint64_t EurekaC2KCallFormatter::createMergeReq(CallOperationContext)::$_0::~$_0(uint64_t a1)
{
  if (*(char *)(a1 + 439) < 0)
    operator delete(*(void **)(a1 + 416));
  CallInfo::~CallInfo((void **)(a1 + 8));
  return a1;
}

void EurekaC2KCallFormatter::createPrivateConversationReq(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  NSObject *v2;
  uint8_t v3[16];

  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(a2 + 56) = 0;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  *(_DWORD *)(a2 + 48) = 25000;
  v2 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)v3 = 0;
    _os_log_error_impl(&dword_216897000, v2, OS_LOG_TYPE_ERROR, "Creating private conversation (unmerge) feature does not exist in CDMA!", v3, 2u);
  }
}

void EurekaC2KCallFormatter::createEndThisCallReq(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  NSObject *v6;
  int v7;
  _DWORD v8[2];
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v6 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    v7 = *(_DWORD *)(a2 + 92);
    v8[0] = 67109120;
    v8[1] = v7;
    _os_log_impl(&dword_216897000, v6, OS_LOG_TYPE_DEFAULT, "#I Sending end call req to end a particular call (TrafficChannel for this call is %u). In C2K, we end all calls.", (uint8_t *)v8, 8u);
  }
  (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 136))(*(_QWORD *)(a1 + 16));
  EurekaC2KCallFormatter::createEndcallReq(a3, a1, *(unsigned int *)(a2 + 252));
}

void EurekaC2KCallFormatter::createSendToVoicemailReq(uint64_t a1@<X0>, const void **a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  _OWORD *v7;
  uint64_t v8;
  __int128 *v10;
  uint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  uint64_t v40;
  uint64_t v41;

  v41 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)(a4 + 48) = 0;
  v7 = (_OWORD *)(a4 + 48);
  *(_QWORD *)(a4 + 56) = 0;
  *(_OWORD *)(a4 + 16) = 0u;
  *(_OWORD *)(a4 + 32) = 0u;
  *(_OWORD *)a4 = 0u;
  *(_DWORD *)(a4 + 48) = 25000;
  v8 = *(_QWORD *)(a1 + 16);
  if (v8 && (*(uint64_t (**)(uint64_t))(*(_QWORD *)v8 + 88))(v8) != 1)
  {
    v40 = 0;
    v38 = 0u;
    v39 = 0u;
    v36 = 0u;
    v37 = 0u;
    v34 = 0u;
    v35 = 0u;
    v32 = 0u;
    v33 = 0u;
    v30 = 0u;
    v31 = 0u;
    v28 = 0u;
    v29 = 0u;
    v26 = 0u;
    v27 = 0u;
    v24 = 0u;
    v25 = 0u;
    v22 = 0u;
    v23 = 0u;
    v20 = 0u;
    v21 = 0u;
    v18 = 0u;
    v19 = 0u;
    v16 = 0u;
    v17 = 0u;
    v15 = 0u;
    CallInfo::CallInfo((CallInfo *)&v15);
    HIDWORD(v30) = a3;
    ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::operator=((const void **)&v15, a2);
    (*(void (**)(_QWORD, __int128 *, _QWORD))(**(_QWORD **)(a1 + 16) + 40))(*(_QWORD *)(a1 + 16), &v15, 0);
    (*(void (**)(_QWORD, _QWORD, uint64_t, uint64_t, uint64_t))(**(_QWORD **)(a1 + 16) + 104))(*(_QWORD *)(a1 + 16), *MEMORY[0x24BDC3DA0], 1, 1, a3);
    CallInfo::~CallInfo((void **)&v15);
    return;
  }
  EurekaC2KCallFormatter::createEndcallReq((uint64_t)&v15, a1, a3);
  std::shared_ptr<qmi::Client::State>::operator=[abi:ne180100](a4, &v15);
  std::__function::__value_func<void ()(qmi::ResponseBase const&)>::operator=[abi:ne180100]((_QWORD *)(a4 + 16), (uint64_t)&v16);
  *v7 = v18;
  v10 = (__int128 *)*((_QWORD *)&v17 + 1);
  if (*((__int128 **)&v17 + 1) == &v16)
  {
    v11 = 4;
    v10 = &v16;
  }
  else
  {
    if (!*((_QWORD *)&v17 + 1))
      goto LABEL_9;
    v11 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v10 + 8 * v11))();
LABEL_9:
  v12 = (std::__shared_weak_count *)*((_QWORD *)&v15 + 1);
  if (*((_QWORD *)&v15 + 1))
  {
    v13 = (unint64_t *)(*((_QWORD *)&v15 + 1) + 8);
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
}

void sub_2168F6E5C(_Unwind_Exception *a1)
{
  EurekaVoiceRequestMessage *v1;

  EurekaVoiceRequestMessage::~EurekaVoiceRequestMessage(v1);
  _Unwind_Resume(a1);
}

double EurekaC2KCallFormatter::createEndHeldReq@<D0>(EurekaC2KCallFormatter *this@<X0>, uint64_t a2@<X8>)
{
  NSObject *v3;
  double result;
  uint8_t v5[16];

  v3 = *((_QWORD *)this + 1);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)v5 = 0;
    _os_log_error_impl(&dword_216897000, v3, OS_LOG_TYPE_ERROR, "Ending a held call not supported in CDMA.", v5, 2u);
  }
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(a2 + 56) = 0;
  result = 0.0;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  *(_DWORD *)(a2 + 48) = 25000;
  return result;
}

void EurekaC2KCallFormatter::createEndAllCallsReq(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  NSObject *v6;
  uint8_t v7[16];

  v6 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v7 = 0;
    _os_log_impl(&dword_216897000, v6, OS_LOG_TYPE_DEFAULT, "#I Sending end call req for End All Calls", v7, 2u);
  }
  EurekaC2KCallFormatter::createEndcallReq(a3, a1, a2);
}

void EurekaC2KCallFormatter::createExplicitCallTransferReq(EurekaC2KCallFormatter *this@<X0>, uint64_t a2@<X8>)
{
  NSObject *v2;
  uint8_t v3[16];

  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(a2 + 56) = 0;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  *(_DWORD *)(a2 + 48) = 25000;
  v2 = *((_QWORD *)this + 1);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)v3 = 0;
    _os_log_error_impl(&dword_216897000, v2, OS_LOG_TYPE_ERROR, "Creating explicit call transfer feature does not exist in CDMA!", v3, 2u);
  }
}

void EurekaC2KCallFormatter::createVoicePrivacyReq(uint64_t a1@<X0>, unsigned int a2@<W1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v8;
  std::__shared_weak_count *v9;
  const void **v10;
  const void **v11;
  char **v12;
  char *v13;
  _BYTE *v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t *v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  char *v23;
  uint64_t *v24;
  char *v25;
  char *v26;
  char *v27;
  uint64_t v28;
  unint64_t *p_shared_owners;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  _QWORD *v34;
  uint64_t v35;
  std::__shared_weak_count *v36;
  unint64_t *v37;
  unint64_t v38;
  uint64_t v39;
  std::__shared_weak_count *v40;
  uint64_t v41;
  std::__shared_weak_count *v42;
  uint64_t v43;
  _QWORD v44[3];
  _QWORD *v45;
  uint64_t v46;

  v46 = *MEMORY[0x24BDAC8D0];
  v8 = operator new();
  *(_OWORD *)v8 = 0u;
  *(_OWORD *)(v8 + 16) = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v8);
  v41 = v8;
  v43 = v8;
  v9 = (std::__shared_weak_count *)operator new();
  v9->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5C7548;
  v9->__shared_owners_ = 0;
  v9->__shared_weak_owners_ = 0;
  v9[1].__vftable = (std::__shared_weak_count_vtbl *)v8;
  v42 = v9;
  v10 = *(const void ***)(v8 + 8);
  v11 = *(const void ***)(v8 + 16);
  v12 = (char **)(v8 + 8);
  if (v10 != v11)
  {
    while (*((_BYTE *)*v10 + 8) != 1)
    {
      if (++v10 == v11)
        goto LABEL_8;
    }
  }
  if (v10 == v11)
  {
LABEL_8:
    v15 = operator new();
    *(_WORD *)(v15 + 8) = 1;
    *(_QWORD *)v15 = &off_24D5C75D8;
    v16 = *(_QWORD *)(v8 + 24);
    v17 = *(uint64_t **)(v8 + 16);
    if ((unint64_t)v17 >= v16)
    {
      v19 = ((char *)v17 - *v12) >> 3;
      if ((unint64_t)(v19 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v20 = v16 - (_QWORD)*v12;
      v21 = v20 >> 2;
      if (v20 >> 2 <= (unint64_t)(v19 + 1))
        v21 = v19 + 1;
      if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFF8)
        v22 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v22 = v21;
      if (v22)
        v23 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>(v8 + 24, v22);
      else
        v23 = 0;
      v24 = (uint64_t *)&v23[8 * v19];
      v25 = &v23[8 * v22];
      *v24 = v15;
      v18 = v24 + 1;
      v27 = *(char **)(v8 + 8);
      v26 = *(char **)(v8 + 16);
      if (v26 != v27)
      {
        do
        {
          v28 = *((_QWORD *)v26 - 1);
          v26 -= 8;
          *--v24 = v28;
        }
        while (v26 != v27);
        v26 = *v12;
      }
      *(_QWORD *)(v8 + 8) = v24;
      *(_QWORD *)(v8 + 16) = v18;
      *(_QWORD *)(v8 + 24) = v25;
      if (v26)
        operator delete(v26);
    }
    else
    {
      *v17 = v15;
      v18 = v17 + 1;
    }
    v14 = (_BYTE *)(v15 + 9);
    *(_QWORD *)(v8 + 16) = v18;
    v8 = v41;
    v9 = v42;
  }
  else
  {
    if (!v13)
      __cxa_bad_cast();
    v14 = v13 + 9;
  }
  *v14 = a2;
  *(_OWORD *)(a4 + 16) = 0u;
  *(_OWORD *)(a4 + 32) = 0u;
  *(_OWORD *)a4 = 0u;
  *(_QWORD *)(a4 + 48) = 0;
  *(_QWORD *)(a4 + 56) = 0;
  *(_DWORD *)(a4 + 48) = 25000;
  v39 = v8;
  v40 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v30 = __ldxr(p_shared_owners);
    while (__stxr(v30 + 1, p_shared_owners));
  }
  std::shared_ptr<QMIDataContextIPActivationLock>::operator=[abi:ne180100]((_QWORD *)a4, &v39);
  v31 = v40;
  if (v40)
  {
    v32 = (unint64_t *)&v40->__shared_owners_;
    do
      v33 = __ldaxr(v32);
    while (__stlxr(v33 - 1, v32));
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
      std::__shared_weak_count::__release_weak(v31);
    }
  }
  v44[0] = &off_24D5C7610;
  v44[1] = a1;
  v44[2] = a2 | (unint64_t)(a3 << 32);
  v45 = v44;
  std::function<void ()(qmi::ResponseBase const&)>::operator=((_QWORD *)(a4 + 16), (uint64_t)v44);
  v34 = v45;
  if (v45 == v44)
  {
    v35 = 4;
    v34 = v44;
  }
  else
  {
    if (!v45)
      goto LABEL_38;
    v35 = 5;
  }
  (*(void (**)(_QWORD *))(*v34 + 8 * v35))(v34);
LABEL_38:
  v36 = v42;
  if (v42)
  {
    v37 = (unint64_t *)&v42->__shared_owners_;
    do
      v38 = __ldaxr(v37);
    while (__stlxr(v38 - 1, v37));
    if (!v38)
    {
      ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
      std::__shared_weak_count::__release_weak(v36);
    }
  }
}

void sub_2168F7340(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, __int16 *a20)
{
  EurekaVoiceRequestMessage *v20;
  __int16 *v21;
  __int16 *v23;
  uint64_t v24;

  v23 = a20;
  if (a20 == v21)
  {
    v24 = 4;
    v23 = &a15;
  }
  else
  {
    if (!a20)
      goto LABEL_6;
    v24 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v23 + 8 * v24))();
LABEL_6:
  EurekaVoiceRequestMessage::~EurekaVoiceRequestMessage(v20);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

uint64_t EurekaC2KCallFormatter::resetCallCapabilities(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  uint8_t v6[16];

  v4 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v6 = 0;
    _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I CDMA: Resetting some of the call capabilities", v6, 2u);
  }
  (*(void (**)(_QWORD, _QWORD, _QWORD, uint64_t))(**(_QWORD **)(a1 + 16) + 112))(*(_QWORD *)(a1 + 16), *MEMORY[0x24BDC3EF8], 0, a2);
  (*(void (**)(_QWORD, _QWORD, _QWORD, uint64_t))(**(_QWORD **)(a1 + 16) + 112))(*(_QWORD *)(a1 + 16), *MEMORY[0x24BDC3ED8], 0, a2);
  (*(void (**)(_QWORD, _QWORD, _QWORD, uint64_t))(**(_QWORD **)(a1 + 16) + 112))(*(_QWORD *)(a1 + 16), *MEMORY[0x24BDC3DB8], 0, a2);
  (*(void (**)(_QWORD, _QWORD, _QWORD, uint64_t))(**(_QWORD **)(a1 + 16) + 112))(*(_QWORD *)(a1 + 16), *MEMORY[0x24BDC3DB0], 0, a2);
  (*(void (**)(_QWORD, _QWORD, _QWORD, uint64_t))(**(_QWORD **)(a1 + 16) + 112))(*(_QWORD *)(a1 + 16), *MEMORY[0x24BDC3DA0], 0, a2);
  return (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 16) + 96))(*(_QWORD *)(a1 + 16), a2);
}

void EurekaC2KCallFormatter::validateTrafficChannelId(uint64_t a1, int a2, uint64_t a3)
{
  int v5;
  int v6;
  std::mutex *ServiceMap;
  int v8;
  int v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  NSObject *v13;
  _QWORD *v14;
  _QWORD *v15;
  void *__p;
  char v17;
  _OWORD v18[4];
  void *v19[2];
  __int128 v20;
  __int128 v21;
  _BYTE v22[144];
  uint64_t v23;
  uint8_t buf[8];
  __int16 v25;
  int v26;
  char v27;
  uint64_t v28;

  v28 = *MEMORY[0x24BDAC8D0];
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 16) + 64))(*(_QWORD *)(a1 + 16), a3);
  if (v5 == *MEMORY[0x24BDC39A8])
    return;
  v6 = v5;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 32));
  ctu::shared_ptr_map_impl<ctu::indexed_by_any_map_hashing_key>::get<GestaltUtilityInterface>(ServiceMap, v18);
  v8 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)&v18[0] + 16))(*(_QWORD *)&v18[0]);
  v9 = v8;
  v10 = (std::__shared_weak_count *)*((_QWORD *)&v18[0] + 1);
  if (!*((_QWORD *)&v18[0] + 1))
    goto LABEL_7;
  v11 = (unint64_t *)(*((_QWORD *)&v18[0] + 1) + 8);
  do
    v12 = __ldaxr(v11);
  while (__stlxr(v12 - 1, v11));
  if (!v12)
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
    if (v9)
    {
LABEL_8:
      if (v6 != a2)
      {
        v23 = 0;
        memset(v22, 0, sizeof(v22));
        v20 = 0u;
        v21 = 0u;
        *(_OWORD *)v19 = 0u;
        memset(v18, 0, sizeof(v18));
        std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v18);
        v13 = *(NSObject **)(a1 + 8);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 67109376;
          *(_DWORD *)&buf[4] = a2;
          v25 = 1024;
          v26 = v6;
          _os_log_error_impl(&dword_216897000, v13, OS_LOG_TYPE_ERROR, "Bad traffic channel id: New: %u  != Existing: %u", buf, 0xEu);
        }
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)"The existing traffic channel id, ", 33);
        v14 = (_QWORD *)std::ostream::operator<<();
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v14, (uint64_t)", mismatches the new traffic channel id, ", 41);
        v15 = (_QWORD *)std::ostream::operator<<();
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v15, (uint64_t)" . Dump logs and reset.", 23);
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v18 + 8, &__p);
        rest::ResetPayload::ResetPayload();
        ctu::rest::event_t<rest::reset_request,rest::ResetPayload>::send();
        if (v27 < 0)
          operator delete(*(void **)buf);
        if (v17 < 0)
          operator delete(__p);
        *(_QWORD *)&v18[0] = *MEMORY[0x24BEDB800];
        *(_QWORD *)((char *)v18 + *(_QWORD *)(*(_QWORD *)&v18[0] - 24)) = *(_QWORD *)(MEMORY[0x24BEDB800] + 24);
        *((_QWORD *)&v18[0] + 1) = MEMORY[0x24BEDB848] + 16;
        if (SHIBYTE(v20) < 0)
          operator delete(v19[1]);
        std::streambuf::~streambuf();
        std::ostream::~ostream();
        MEMORY[0x2199FEA70](v22);
      }
      return;
    }
  }
  else
  {
LABEL_7:
    if (v8)
      goto LABEL_8;
  }
  if (v6 != a2)
    __TUAssertTrigger();
}

void sub_2168F7790(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  uint64_t v16;

  if (*(char *)(v16 - 73) < 0)
    operator delete(*(void **)(v16 - 96));
  if (a15 < 0)
    operator delete(__p);
  std::ostringstream::~ostringstream((uint64_t)&a16);
  _Unwind_Resume(a1);
}

void ctu::rest::event_t<rest::reset_request,rest::ResetPayload>::send()
{
  xpc_object_t object;
  void *__p;
  char v2;
  xpc_object_t v3;

  v3 = 0;
  rest::write_rest_value();
  std::string::basic_string[abi:ne180100]<0>(&__p, "/cc/events/reset_request");
  object = v3;
  v3 = xpc_null_create();
  ctu::RestModule::sendEvent();
  xpc_release(object);
  if (v2 < 0)
    operator delete(__p);
  xpc_release(v3);
}

void sub_2168F7880(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  uint64_t v16;

  xpc_release(object);
  if (a16 < 0)
    operator delete(__p);
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t std::ostringstream::~ostringstream(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = MEMORY[0x24BEDB800];
  v3 = *MEMORY[0x24BEDB800];
  *(_QWORD *)a1 = *MEMORY[0x24BEDB800];
  *(_QWORD *)(a1 + *(_QWORD *)(v3 - 24)) = *(_QWORD *)(v2 + 24);
  *(_QWORD *)(a1 + 8) = MEMORY[0x24BEDB848] + 16;
  if (*(char *)(a1 + 95) < 0)
    operator delete(*(void **)(a1 + 72));
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x2199FEA70](a1 + 112);
  return a1;
}

uint64_t EurekaC2KCallFormatter::shouldValidateCallCollisionScenario(EurekaC2KCallFormatter *this)
{
  return 1;
}

uint64_t EurekaC2KCallFormatter::okToDialTestEmergency(EurekaC2KCallFormatter *this)
{
  return 1;
}

uint64_t EurekaC2KCallFormatter::waitForCallerId(EurekaC2KCallFormatter *this)
{
  return 1;
}

uint64_t EurekaC2KCallFormatter::supportsCallSwapIfMaxCalls(EurekaC2KCallFormatter *this)
{
  return 1;
}

uint64_t EurekaC2KCallFormatter::supportsInBandTones(EurekaC2KCallFormatter *this)
{
  return 1;
}

void EurekaC2KCallFormatter::~EurekaC2KCallFormatter(EurekaC2KCallFormatter *this)
{
  *(_QWORD *)this = &off_24D5C7078;
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)this + 56);
  EurekaCallFormatter::~EurekaCallFormatter(this);
}

{
  *(_QWORD *)this = &off_24D5C7078;
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)this + 56);
  EurekaCallFormatter::~EurekaCallFormatter(this);
  JUMPOUT(0x2199FEAC4);
}

void CallInfo::CallInfo(CallInfo *this, const CallInfo *a2)
{
  const void **v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  std::string *v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;

  v4 = ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::SharedRef((const void **)this, (const void **)a2);
  if (*((char *)a2 + 31) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)(v4 + 1), *((const std::string::value_type **)a2 + 1), *((_QWORD *)a2 + 2));
  }
  else
  {
    v5 = *(_OWORD *)((char *)a2 + 8);
    v4[3] = (const void *)*((_QWORD *)a2 + 3);
    *(_OWORD *)(v4 + 1) = v5;
  }
  if (*((char *)a2 + 55) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)((char *)this + 32), *((const std::string::value_type **)a2 + 4), *((_QWORD *)a2 + 5));
  }
  else
  {
    v6 = *((_OWORD *)a2 + 2);
    *((_QWORD *)this + 6) = *((_QWORD *)a2 + 6);
    *((_OWORD *)this + 2) = v6;
  }
  *(_OWORD *)((char *)this + 56) = *(_OWORD *)((char *)a2 + 56);
  v7 = *(_OWORD *)((char *)a2 + 72);
  v8 = *(_OWORD *)((char *)a2 + 88);
  v9 = *(_OWORD *)((char *)a2 + 104);
  *(_QWORD *)((char *)this + 117) = *(_QWORD *)((char *)a2 + 117);
  *(_OWORD *)((char *)this + 104) = v9;
  *(_OWORD *)((char *)this + 88) = v8;
  *(_OWORD *)((char *)this + 72) = v7;
  if (*((char *)a2 + 151) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)((char *)this + 128), *((const std::string::value_type **)a2 + 16), *((_QWORD *)a2 + 17));
  }
  else
  {
    v10 = *((_OWORD *)a2 + 8);
    *((_QWORD *)this + 18) = *((_QWORD *)a2 + 18);
    *((_OWORD *)this + 8) = v10;
  }
  *((_DWORD *)this + 38) = *((_DWORD *)a2 + 38);
  if (*((char *)a2 + 183) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)((char *)this + 160), *((const std::string::value_type **)a2 + 20), *((_QWORD *)a2 + 21));
  }
  else
  {
    v11 = *((_OWORD *)a2 + 10);
    *((_QWORD *)this + 22) = *((_QWORD *)a2 + 22);
    *((_OWORD *)this + 10) = v11;
  }
  v12 = *(_OWORD *)((char *)a2 + 184);
  *(_OWORD *)((char *)this + 193) = *(_OWORD *)((char *)a2 + 193);
  *(_OWORD *)((char *)this + 184) = v12;
  std::__optional_copy_base<std::vector<unsigned int>,false>::__optional_copy_base[abi:ne180100]((uint64_t)this + 216, (uint64_t)a2 + 216);
  v13 = *(_OWORD *)((char *)a2 + 248);
  *((_BYTE *)this + 264) = *((_BYTE *)a2 + 264);
  *(_OWORD *)((char *)this + 248) = v13;
  if (*((char *)a2 + 295) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)((char *)this + 272), *((const std::string::value_type **)a2 + 34), *((_QWORD *)a2 + 35));
  }
  else
  {
    v14 = *((_OWORD *)a2 + 17);
    *((_QWORD *)this + 36) = *((_QWORD *)a2 + 36);
    *((_OWORD *)this + 17) = v14;
  }
  v15 = (std::string *)((char *)this + 296);
  if (*((char *)a2 + 319) < 0)
  {
    std::string::__init_copy_ctor_external(v15, *((const std::string::value_type **)a2 + 37), *((_QWORD *)a2 + 38));
  }
  else
  {
    v16 = *(_OWORD *)((char *)a2 + 296);
    *((_QWORD *)this + 39) = *((_QWORD *)a2 + 39);
    *(_OWORD *)&v15->__r_.__value_.__l.__data_ = v16;
  }
  v17 = *((_OWORD *)a2 + 21);
  *((_OWORD *)this + 20) = *((_OWORD *)a2 + 20);
  *((_OWORD *)this + 21) = v17;
  v18 = *((_OWORD *)a2 + 22);
  v19 = *((_OWORD *)a2 + 23);
  v20 = *((_OWORD *)a2 + 24);
  *(_QWORD *)((char *)this + 397) = *(_QWORD *)((char *)a2 + 397);
  *((_OWORD *)this + 23) = v19;
  *((_OWORD *)this + 24) = v20;
  *((_OWORD *)this + 22) = v18;
}

void sub_2168F7BC8(_Unwind_Exception *a1)
{
  uint64_t v1;
  void **v2;
  void **v3;
  void **v4;
  void **v5;
  void **v6;
  void **v7;
  void *v9;

  if (*(char *)(v1 + 295) < 0)
    operator delete(*v7);
  if (*(_BYTE *)(v1 + 240))
  {
    v9 = *v6;
    if (*v6)
    {
      *(_QWORD *)(v1 + 224) = v9;
      operator delete(v9);
    }
  }
  if (*(char *)(v1 + 183) < 0)
    operator delete(*v5);
  if (*(char *)(v1 + 151) < 0)
    operator delete(*v4);
  if (*(char *)(v1 + 55) < 0)
    operator delete(*v3);
  if (*(char *)(v1 + 31) < 0)
    operator delete(*v2);
  ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::~SharedRef((const void **)v1);
  _Unwind_Resume(a1);
}

uint64_t std::__optional_copy_base<std::vector<unsigned int>,false>::__optional_copy_base[abi:ne180100](uint64_t a1, uint64_t a2)
{
  *(_BYTE *)a1 = 0;
  *(_BYTE *)(a1 + 24) = 0;
  std::__optional_storage_base<std::vector<unsigned int>,false>::__construct_from[abi:ne180100]<std::__optional_copy_base<std::vector<unsigned int>,false> const&>((_QWORD *)a1, a2);
  return a1;
}

void sub_2168F7CA0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  if (*(_BYTE *)(v1 + 24))
  {
    v3 = *(void **)v1;
    if (*(_QWORD *)v1)
    {
      *(_QWORD *)(v1 + 8) = v3;
      operator delete(v3);
    }
  }
  _Unwind_Resume(exception_object);
}

_QWORD *std::__optional_storage_base<std::vector<unsigned int>,false>::__construct_from[abi:ne180100]<std::__optional_copy_base<std::vector<unsigned int>,false> const&>(_QWORD *result, uint64_t a2)
{
  _QWORD *v2;

  if (*(_BYTE *)(a2 + 24))
  {
    v2 = result;
    *result = 0;
    result[1] = 0;
    result[2] = 0;
    result = std::vector<unsigned int>::__init_with_size[abi:ne180100]<unsigned int *,unsigned int *>(result, *(const void **)a2, *(_QWORD *)(a2 + 8), (uint64_t)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 2);
    *((_BYTE *)v2 + 24) = 1;
  }
  return result;
}

_QWORD *std::vector<unsigned int>::__init_with_size[abi:ne180100]<unsigned int *,unsigned int *>(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<unsigned int>::__vallocate[abi:ne180100](result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_2168F7D68(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<unsigned int>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 62)
    std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::array<unsigned char,4ul>>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[4 * v4];
  return result;
}

const void **ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::~SharedRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

void CallInfo::~CallInfo(void **this)
{
  void *v2;

  if (*((char *)this + 319) < 0)
    operator delete(this[37]);
  if (*((char *)this + 295) < 0)
    operator delete(this[34]);
  if (*((_BYTE *)this + 240))
  {
    v2 = this[27];
    if (v2)
    {
      this[28] = v2;
      operator delete(v2);
    }
  }
  if (*((char *)this + 183) < 0)
    operator delete(this[20]);
  if (*((char *)this + 151) < 0)
    operator delete(this[16]);
  if (*((char *)this + 55) < 0)
    operator delete(this[4]);
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::~SharedRef((const void **)this);
}

_QWORD *std::__function::__value_func<void ()(qmi::ResponseBase const&)>::operator=[abi:ne180100](_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;

  v4 = (_QWORD *)a1[3];
  a1[3] = 0;
  if (v4 == a1)
  {
    v5 = 4;
    v4 = a1;
  }
  else
  {
    if (!v4)
      goto LABEL_6;
    v5 = 5;
  }
  (*(void (**)(void))(*v4 + 8 * v5))();
LABEL_6:
  v6 = *(_QWORD *)(a2 + 24);
  if (v6)
  {
    if (v6 == a2)
    {
      a1[3] = a1;
      (*(void (**)(_QWORD, _QWORD *))(**(_QWORD **)(a2 + 24) + 24))(*(_QWORD *)(a2 + 24), a1);
    }
    else
    {
      a1[3] = v6;
      *(_QWORD *)(a2 + 24) = 0;
    }
  }
  else
  {
    a1[3] = 0;
  }
  return a1;
}

const void **ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::SharedRef(const void **a1, const void **a2)
{
  const void *v3;

  v3 = *a2;
  *a1 = *a2;
  if (v3)
    CFRetain(v3);
  return a1;
}

void CallInfo::CallInfo(CallInfo *this)
{
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  std::string::basic_string[abi:ne180100]<0>((_QWORD *)this + 4, (char *)*MEMORY[0x24BDC3E80]);
  *((_DWORD *)this + 14) = 9;
  *((_BYTE *)this + 60) = 0;
  *((_DWORD *)this + 16) = 1;
  *((_BYTE *)this + 68) = 1;
  *((_QWORD *)this + 9) = 0x400000001;
  *((_QWORD *)this + 10) = 2;
  *((_BYTE *)this + 88) = 0;
  *((_DWORD *)this + 23) = *MEMORY[0x24BDC39A8];
  *((_BYTE *)this + 120) = 0;
  *((_BYTE *)this + 124) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = 0;
  *(_QWORD *)((char *)this + 110) = 0;
  std::string::basic_string[abi:ne180100]<0>((_QWORD *)this + 16, (char *)&unk_216AC4FCA);
  *((_DWORD *)this + 38) = 0;
  std::string::basic_string[abi:ne180100]<0>((_QWORD *)this + 20, (char *)&unk_216AC4FCA);
  *((_DWORD *)this + 46) = 0;
  *((_WORD *)this + 94) = 0;
  *((_DWORD *)this + 48) = 0;
  *((_WORD *)this + 98) = 0;
  *((_DWORD *)this + 50) = 0;
  *((_BYTE *)this + 204) = 0;
  *((_BYTE *)this + 208) = 0;
  *((_BYTE *)this + 216) = 0;
  *((_BYTE *)this + 240) = 0;
  *((_WORD *)this + 124) = 0;
  *((_DWORD *)this + 63) = 1;
  *((_BYTE *)this + 256) = 0;
  *((_DWORD *)this + 65) = 0;
  *((_BYTE *)this + 264) = 0;
  *((_BYTE *)this + 384) = 0;
  *((_BYTE *)this + 392) = 0;
  *((_BYTE *)this + 404) = 0;
  *((_BYTE *)this + 336) = 0;
  *((_OWORD *)this + 19) = 0u;
  *((_OWORD *)this + 20) = 0u;
  *((_OWORD *)this + 17) = 0u;
  *((_OWORD *)this + 18) = 0u;
}

void sub_2168F8068(_Unwind_Exception *a1)
{
  uint64_t v1;
  void **v2;
  void **v3;

  if (*(char *)(v1 + 151) < 0)
    operator delete(*v3);
  if (*(char *)(v1 + 55) < 0)
    operator delete(*v2);
  if (*(char *)(v1 + 31) < 0)
    operator delete(*(void **)(v1 + 8));
  ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::~SharedRef((const void **)v1);
  _Unwind_Resume(a1);
}

const void **ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::operator=(const void **a1, const void **a2)
{
  const void *v3;
  const void *v5;

  if (a1 != a2)
  {
    v5 = 0;
    ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::SharedRef(&v5, a2);
    v3 = *a1;
    *a1 = v5;
    v5 = v3;
    ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::~SharedRef(&v5);
  }
  return a1;
}

_QWORD *std::vector<unsigned char>::__assign_with_size[abi:ne180100]<std::__wrap_iter<char const*>,std::__wrap_iter<char const*>>(_QWORD *result, char *__src, char *a3, unint64_t a4)
{
  char *v6;
  _QWORD *v7;
  unint64_t v8;
  _BYTE *v9;
  uint64_t v10;
  size_t v11;
  _BYTE *v12;
  char v13;
  _BYTE *v14;
  char *v15;
  _BYTE *v16;
  char v17;
  size_t v18;

  v6 = __src;
  v7 = result;
  v8 = result[2];
  v9 = (_BYTE *)*result;
  if (v8 - *result >= a4)
  {
    v14 = (_BYTE *)result[1];
    if (v14 - v9 >= a4)
    {
      v18 = a3 - __src;
      if (a3 != __src)
        result = memmove((void *)*result, __src, v18);
      v12 = &v9[v18];
    }
    else
    {
      v15 = &__src[v14 - v9];
      if (v14 != v9)
      {
        result = memmove((void *)*result, __src, v14 - v9);
        v9 = (_BYTE *)v7[1];
      }
      v12 = v9;
      if (v15 != a3)
      {
        v12 = v9;
        v16 = v9;
        do
        {
          v17 = *v15++;
          *v16++ = v17;
          ++v12;
        }
        while (v15 != a3);
      }
    }
  }
  else
  {
    if (v9)
    {
      result[1] = v9;
      operator delete(v9);
      v8 = 0;
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if ((a4 & 0x8000000000000000) != 0)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = 2 * v8;
    if (2 * v8 <= a4)
      v10 = a4;
    if (v8 >= 0x3FFFFFFFFFFFFFFFLL)
      v11 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    result = std::vector<unsigned char>::__vallocate[abi:ne180100](v7, v11);
    v12 = (_BYTE *)v7[1];
    while (v6 != a3)
    {
      v13 = *v6++;
      *v12++ = v13;
    }
  }
  v7[1] = v12;
  return result;
}

uint64_t std::__function::__func<EurekaC2KCallFormatter::createSecondCallDialReq(CallInfo,qmi::ClientRouter &)::$_0,std::allocator<EurekaC2KCallFormatter::createSecondCallDialReq(CallInfo,qmi::ClientRouter &)::$_0>,void ()(qmi::ResponseBase const&)>::~__func(uint64_t a1)
{
  *(_QWORD *)a1 = &off_24D5C7158;
  CallInfo::~CallInfo((void **)(a1 + 16));
  return a1;
}

void std::__function::__func<EurekaC2KCallFormatter::createSecondCallDialReq(CallInfo,qmi::ClientRouter &)::$_0,std::allocator<EurekaC2KCallFormatter::createSecondCallDialReq(CallInfo,qmi::ClientRouter &)::$_0>,void ()(qmi::ResponseBase const&)>::~__func(uint64_t a1)
{
  *(_QWORD *)a1 = &off_24D5C7158;
  CallInfo::~CallInfo((void **)(a1 + 16));
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<EurekaC2KCallFormatter::createSecondCallDialReq(CallInfo,qmi::ClientRouter &)::$_0,std::allocator<EurekaC2KCallFormatter::createSecondCallDialReq(CallInfo,qmi::ClientRouter &)::$_0>,void ()(qmi::ResponseBase const&)>::__clone(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;

  v2 = operator new(0x1B0uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *v2 = &off_24D5C7158;
  v2[1] = v3;
  CallInfo::CallInfo((CallInfo *)(v2 + 2), (const CallInfo *)(a1 + 16));
  *((_DWORD *)v2 + 106) = *(_DWORD *)(a1 + 424);
  return v2;
}

void sub_2168F8300(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__function::__func<EurekaC2KCallFormatter::createSecondCallDialReq(CallInfo,qmi::ClientRouter &)::$_0,std::allocator<EurekaC2KCallFormatter::createSecondCallDialReq(CallInfo,qmi::ClientRouter &)::$_0>,void ()(qmi::ResponseBase const&)>::__clone(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  v4 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)a2 = &off_24D5C7158;
  *(_QWORD *)(a2 + 8) = v4;
  CallInfo::CallInfo((CallInfo *)(a2 + 16), (const CallInfo *)(a1 + 16));
  *(_DWORD *)(a2 + 424) = *(_DWORD *)(a1 + 424);
}

void std::__function::__func<EurekaC2KCallFormatter::createSecondCallDialReq(CallInfo,qmi::ClientRouter &)::$_0,std::allocator<EurekaC2KCallFormatter::createSecondCallDialReq(CallInfo,qmi::ClientRouter &)::$_0>,void ()(qmi::ResponseBase const&)>::destroy(uint64_t a1)
{
  CallInfo::~CallInfo((void **)(a1 + 16));
}

void std::__function::__func<EurekaC2KCallFormatter::createSecondCallDialReq(CallInfo,qmi::ClientRouter &)::$_0,std::allocator<EurekaC2KCallFormatter::createSecondCallDialReq(CallInfo,qmi::ClientRouter &)::$_0>,void ()(qmi::ResponseBase const&)>::destroy_deallocate(void **a1)
{
  CallInfo::~CallInfo(a1 + 2);
  operator delete(a1);
}

void std::__function::__func<EurekaC2KCallFormatter::createSecondCallDialReq(CallInfo,qmi::ClientRouter &)::$_0,std::allocator<EurekaC2KCallFormatter::createSecondCallDialReq(CallInfo,qmi::ClientRouter &)::$_0>,void ()(qmi::ResponseBase const&)>::operator()(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  int v9;
  uint8_t v10[16];
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  char v14;
  _OWORD v15[5];
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  uint64_t v36;
  _BYTE buf[24];
  void *v38;
  uint64_t *v39;
  uint64_t v40;

  v40 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)(a1 + 8);
  v36 = 0;
  v34 = 0u;
  v35 = 0u;
  v32 = 0u;
  v33 = 0u;
  v30 = 0u;
  v31 = 0u;
  v28 = 0u;
  v29 = 0u;
  v26 = 0u;
  v27 = 0u;
  v24 = 0u;
  v25 = 0u;
  v22 = 0u;
  v23 = 0u;
  v20 = 0u;
  v21 = 0u;
  v18 = 0u;
  v19 = 0u;
  v16 = 0u;
  v17 = 0u;
  memset(v15, 0, sizeof(v15));
  CallInfo::CallInfo((CallInfo *)v15, (const CallInfo *)(a1 + 16));
  v5 = *(NSObject **)(v4 + 8);
  if (*((_DWORD *)a2 + 1))
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v8 = qmi::asString();
      v9 = *((_DWORD *)a2 + 1);
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = v8;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v9;
      _os_log_error_impl(&dword_216897000, v5, OS_LOG_TYPE_ERROR, "Dialing 2nd call failed with error %s (%u)", buf, 0x12u);
    }
    (*(void (**)(_QWORD, _OWORD *))(**(_QWORD **)(v4 + 16) + 16))(*(_QWORD *)(v4 + 16), v15);
  }
  else
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#I Flash for Dial 2nd Call succeeded!", buf, 2u);
    }
    v11 = 0;
    v12 = &v11;
    v13 = 0x2000000000;
    v14 = 0;
    *(_QWORD *)buf = MEMORY[0x24BDAC760];
    *(_QWORD *)&buf[8] = 0x40000000;
    *(_QWORD *)&buf[16] = ___ZZN22EurekaC2KCallFormatter23createSecondCallDialReqE8CallInfoRN3qmi12ClientRouterEENK3__0clERKNS1_12ResponseBaseE_block_invoke;
    v38 = &unk_24D5C71C0;
    v39 = &v11;
    *(_QWORD *)v10 = buf;
    if ((qmi::MessageBase::applyTlv<vs::tlv::CallIdentifier,void({block_pointer})(vs::tlv::CallIdentifier const&)>(a2, 16, (uint64_t)v10) & 1) != 0)
    {
      (*(void (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)v4 + 176))(v4, *((unsigned __int8 *)v12 + 24), *(unsigned int *)(a1 + 424));
      HIDWORD(v16) = *((unsigned __int8 *)v12 + 24);
      (*(void (**)(_QWORD, _OWORD *))(**(_QWORD **)(v4 + 16) + 16))(*(_QWORD *)(v4 + 16), v15);
      (*(void (**)(_QWORD, _OWORD *))(**(_QWORD **)(v4 + 16) + 144))(*(_QWORD *)(v4 + 16), v15);
      (*(void (**)(_QWORD, _OWORD *, _QWORD))(**(_QWORD **)(v4 + 16) + 24))(*(_QWORD *)(v4 + 16), v15, 0);
      (*(void (**)(_QWORD, _QWORD, _QWORD, _QWORD))(**(_QWORD **)(v4 + 16) + 112))(*(_QWORD *)(v4 + 16), *MEMORY[0x24BDC3EF8], 0, *(unsigned int *)(a1 + 424));
      v6 = *MEMORY[0x24BDC3ED8];
      (*(void (**)(_QWORD, _QWORD, _QWORD, _QWORD))(**(_QWORD **)(v4 + 16) + 112))(*(_QWORD *)(v4 + 16), *MEMORY[0x24BDC3ED8], 0, *(unsigned int *)(a1 + 424));
      (*(void (**)(_QWORD, _QWORD, uint64_t, _QWORD))(**(_QWORD **)(v4 + 16) + 112))(*(_QWORD *)(v4 + 16), *MEMORY[0x24BDC3DB8], 1, *(unsigned int *)(a1 + 424));
      (*(void (**)(_QWORD, _QWORD, _QWORD, _QWORD))(**(_QWORD **)(v4 + 16) + 112))(*(_QWORD *)(v4 + 16), *MEMORY[0x24BDC3DA0], 0, *(unsigned int *)(a1 + 424));
      (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)(v4 + 16) + 96))(*(_QWORD *)(v4 + 16), *(unsigned int *)(a1 + 424));
      (*(void (**)(_QWORD, uint64_t, uint64_t, uint64_t, _QWORD))(**(_QWORD **)(v4 + 16) + 104))(*(_QWORD *)(v4 + 16), v6, 1, 1, *(unsigned int *)(a1 + 424));
    }
    else
    {
      v7 = *(NSObject **)(v4 + 8);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)v10 = 0;
        _os_log_error_impl(&dword_216897000, v7, OS_LOG_TYPE_ERROR, "Invalid Flash Message response. Mandatory TLV, CallId, not present", v10, 2u);
      }
    }
    _Block_object_dispose(&v11, 8);
  }
  CallInfo::~CallInfo((void **)v15);
}

void sub_2168F86E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v4;
  va_list va;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  CallInfo::~CallInfo((void **)va1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<EurekaC2KCallFormatter::createSecondCallDialReq(CallInfo,qmi::ClientRouter &)::$_0,std::allocator<EurekaC2KCallFormatter::createSecondCallDialReq(CallInfo,qmi::ClientRouter &)::$_0>,void ()(qmi::ResponseBase const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<EurekaC2KCallFormatter::createSecondCallDialReq(CallInfo,qmi::ClientRouter &)::$_0,std::allocator<EurekaC2KCallFormatter::createSecondCallDialReq(CallInfo,qmi::ClientRouter &)::$_0>,void ()(qmi::ResponseBase const&)>::target_type()
{
}

uint64_t ___ZZN22EurekaC2KCallFormatter23createSecondCallDialReqE8CallInfoRN3qmi12ClientRouterEENK3__0clERKNS1_12ResponseBaseE_block_invoke(uint64_t result, _BYTE *a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = *a2;
  return result;
}

unint64_t qmi::MessageBase::applyTlv<vs::tlv::CallIdentifier,void({block_pointer})(vs::tlv::CallIdentifier const&)>(qmi::MessageBase *a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;
  int v7;
  unint64_t v8;
  int v9;

  result = qmi::MessageBase::findTlvValue(a1);
  if (result)
  {
    v8 = result;
    v9 = v7;
    if (qmi::MessageBase::tryTlv<vs::tlv::CallIdentifier,void({block_pointer})(vs::tlv::CallIdentifier const&)>((uint64_t)a1, result, v7, a3))
    {
      return 1;
    }
    else
    {
      return ((uint64_t (*)(_QWORD, uint64_t, unint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, a2, v8, v9);
    }
  }
  return result;
}

BOOL qmi::MessageBase::tryTlv<vs::tlv::CallIdentifier,void({block_pointer})(vs::tlv::CallIdentifier const&)>(uint64_t a1, unint64_t a2, int a3, uint64_t a4)
{
  unint64_t v5;
  unint64_t v7;

  v7 = a2;
  tlv::parseV<vs::tlv::CallIdentifier>(&v7, a3);
  v5 = v7;
  if (v7)
    (*(void (**)(void))(*(_QWORD *)a4 + 16))();
  return v5 != 0;
}

uint64_t std::__function::__func<EurekaC2KCallFormatter::createSecondCallDialReq(CallInfo,qmi::ClientRouter &)::$_1,std::allocator<EurekaC2KCallFormatter::createSecondCallDialReq(CallInfo,qmi::ClientRouter &)::$_1>,void ()(qmi::ResponseBase const&)>::~__func(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;

  *(_QWORD *)a1 = &off_24D5C7200;
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 464);
  v2 = *(_QWORD **)(a1 + 456);
  if (v2 == (_QWORD *)(a1 + 432))
  {
    v3 = 4;
    v2 = (_QWORD *)(a1 + 432);
    goto LABEL_5;
  }
  if (v2)
  {
    v3 = 5;
LABEL_5:
    (*(void (**)(void))(*v2 + 8 * v3))();
  }
  CallInfo::~CallInfo((void **)(a1 + 24));
  return a1;
}

void std::__function::__func<EurekaC2KCallFormatter::createSecondCallDialReq(CallInfo,qmi::ClientRouter &)::$_1,std::allocator<EurekaC2KCallFormatter::createSecondCallDialReq(CallInfo,qmi::ClientRouter &)::$_1>,void ()(qmi::ResponseBase const&)>::~__func(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;

  *(_QWORD *)a1 = &off_24D5C7200;
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 464);
  v2 = *(_QWORD **)(a1 + 456);
  if (v2 == (_QWORD *)(a1 + 432))
  {
    v3 = 4;
    v2 = (_QWORD *)(a1 + 432);
  }
  else
  {
    if (!v2)
    {
LABEL_6:
      CallInfo::~CallInfo((void **)(a1 + 24));
      JUMPOUT(0x2199FEAC4);
    }
    v3 = 5;
  }
  (*(void (**)(void))(*v2 + 8 * v3))();
  goto LABEL_6;
}

_QWORD *std::__function::__func<EurekaC2KCallFormatter::createSecondCallDialReq(CallInfo,qmi::ClientRouter &)::$_1,std::allocator<EurekaC2KCallFormatter::createSecondCallDialReq(CallInfo,qmi::ClientRouter &)::$_1>,void ()(qmi::ResponseBase const&)>::__clone(uint64_t a1)
{
  uint64_t *v1;
  _QWORD *v2;

  v1 = (uint64_t *)(a1 + 8);
  v2 = operator new(0x1E0uLL);
  *v2 = &off_24D5C7200;
  std::__compressed_pair_elem<EurekaC2KCallFormatter::createSecondCallDialReq(CallInfo,qmi::ClientRouter &)::$_1,0,false>::__compressed_pair_elem[abi:ne180100]<EurekaC2KCallFormatter::createSecondCallDialReq(CallInfo,qmi::ClientRouter &)::$_1 const&,0ul>((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_2168F8984(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<EurekaC2KCallFormatter::createSecondCallDialReq(CallInfo,qmi::ClientRouter &)::$_1,std::allocator<EurekaC2KCallFormatter::createSecondCallDialReq(CallInfo,qmi::ClientRouter &)::$_1>,void ()(qmi::ResponseBase const&)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_24D5C7200;
  return std::__compressed_pair_elem<EurekaC2KCallFormatter::createSecondCallDialReq(CallInfo,qmi::ClientRouter &)::$_1,0,false>::__compressed_pair_elem[abi:ne180100]<EurekaC2KCallFormatter::createSecondCallDialReq(CallInfo,qmi::ClientRouter &)::$_1 const&,0ul>((uint64_t)(a2 + 1), (uint64_t *)(a1 + 8));
}

void std::__function::__func<EurekaC2KCallFormatter::createSecondCallDialReq(CallInfo,qmi::ClientRouter &)::$_1,std::allocator<EurekaC2KCallFormatter::createSecondCallDialReq(CallInfo,qmi::ClientRouter &)::$_1>,void ()(qmi::ResponseBase const&)>::destroy(uint64_t a1)
{
  std::__function::__alloc_func<EurekaC2KCallFormatter::createSecondCallDialReq(CallInfo,qmi::ClientRouter &)::$_1,std::allocator<EurekaC2KCallFormatter::createSecondCallDialReq(CallInfo,qmi::ClientRouter &)::$_1>,void ()(qmi::ResponseBase const&)>::destroy[abi:ne180100](a1 + 8);
}

void std::__function::__func<EurekaC2KCallFormatter::createSecondCallDialReq(CallInfo,qmi::ClientRouter &)::$_1,std::allocator<EurekaC2KCallFormatter::createSecondCallDialReq(CallInfo,qmi::ClientRouter &)::$_1>,void ()(qmi::ResponseBase const&)>::destroy_deallocate(void *a1)
{
  std::__function::__alloc_func<EurekaC2KCallFormatter::createSecondCallDialReq(CallInfo,qmi::ClientRouter &)::$_1,std::allocator<EurekaC2KCallFormatter::createSecondCallDialReq(CallInfo,qmi::ClientRouter &)::$_1>,void ()(qmi::ResponseBase const&)>::destroy[abi:ne180100]((uint64_t)a1 + 8);
  operator delete(a1);
}

void std::__function::__func<EurekaC2KCallFormatter::createSecondCallDialReq(CallInfo,qmi::ClientRouter &)::$_1,std::allocator<EurekaC2KCallFormatter::createSecondCallDialReq(CallInfo,qmi::ClientRouter &)::$_1>,void ()(qmi::ResponseBase const&)>::operator()(uint64_t a1, qmi::MessageBase *a2)
{
  _QWORD *v4;
  NSObject *v5;
  _QWORD *v6;
  uint64_t v7;
  NSObject *v8;
  int v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  __int128 *v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t *p_shared_owners;
  unint64_t v20;
  uint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  uint64_t v25;
  int v26;
  _BYTE v27[8];
  uint64_t v28;
  _QWORD v29[5];
  uint64_t v30;
  uint64_t *v31;
  uint64_t v32;
  char v33;
  _BYTE v34[24];
  _BYTE *v35;
  _BYTE v36[24];
  _BYTE *v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  uint8_t buf[32];
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  uint64_t v66;
  uint64_t v67;

  v67 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD **)(a1 + 8);
  v5 = v4[1];
  if (!*((_DWORD *)a2 + 1))
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#I Flash to place Active call on hold succeeded!", buf, 2u);
    }
    v30 = 0;
    v31 = &v30;
    v32 = 0x2000000000;
    v33 = 0;
    v29[0] = MEMORY[0x24BDAC760];
    v29[1] = 0x40000000;
    v29[2] = ___ZZN22EurekaC2KCallFormatter23createSecondCallDialReqE8CallInfoRN3qmi12ClientRouterEENK3__1clERKNS1_12ResponseBaseE_block_invoke;
    v29[3] = &unk_24D5C7268;
    v29[4] = &v30;
    *(_QWORD *)buf = v29;
    if ((qmi::MessageBase::applyTlv<vs::tlv::CallIdentifier,void({block_pointer})(vs::tlv::CallIdentifier const&)>(a2, 16, (uint64_t)buf) & 1) == 0)
    {
      v8 = v4[1];
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_216897000, v8, OS_LOG_TYPE_ERROR, "Invalid Flash Message response. Mandatory TLV, CallId, not present", buf, 2u);
      }
      goto LABEL_49;
    }
    (*(void (**)(_QWORD *, _QWORD, _QWORD))(*v4 + 176))(v4, *((unsigned __int8 *)v31 + 24), *(unsigned int *)(a1 + 16));
    v66 = 0;
    v64 = 0u;
    v65 = 0u;
    v62 = 0u;
    v63 = 0u;
    v60 = 0u;
    v61 = 0u;
    v58 = 0u;
    v59 = 0u;
    v56 = 0u;
    v57 = 0u;
    v54 = 0u;
    v55 = 0u;
    v52 = 0u;
    v53 = 0u;
    v50 = 0u;
    v51 = 0u;
    v48 = 0u;
    v49 = 0u;
    v46 = 0u;
    v47 = 0u;
    v44 = 0u;
    v45 = 0u;
    v43 = 0u;
    memset(buf, 0, sizeof(buf));
    CallInfo::CallInfo((CallInfo *)buf);
    HIDWORD(v56) = *(_DWORD *)(a1 + 16);
    HIDWORD(v46) = *((unsigned __int8 *)v31 + 24);
    (*(void (**)(_QWORD, uint8_t *))(*(_QWORD *)v4[2] + 32))(v4[2], buf);
    v40 = 0u;
    v41 = 0u;
    v38 = 0u;
    v39 = 0u;
    std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100]((uint64_t)v36, a1 + 432);
    EurekaC2KCallFormatter::createFlashRequest((uint64_t)&v38, v4[2], a1 + 56, (uint64_t)v36, *(unsigned int *)(a1 + 16));
    v6 = v37;
    if (v37 == v36)
    {
      v7 = 4;
      v6 = v36;
    }
    else
    {
      if (!v37)
        goto LABEL_15;
      v7 = 5;
    }
    (*(void (**)(void))(*v6 + 8 * v7))();
LABEL_15:
    if ((*(_DWORD *)(a1 + 16) - 1) >= 3)
      v9 = 0;
    else
      v9 = *(_DWORD *)(a1 + 16);
    v10 = (std::__shared_weak_count *)*((_QWORD *)&v38 + 1);
    if (*((_QWORD *)&v38 + 1))
    {
      v11 = (unint64_t *)(*((_QWORD *)&v38 + 1) + 8);
      do
        v12 = __ldxr(v11);
      while (__stxr(v12 + 1, v11));
    }
    v13 = qmi::ClientRouter::get();
    qmi::ClientRouter::SendProxy::SendProxy<qmi::MutableMessageBase>((uint64_t)v27, v9, v13);
    v14 = &v39;
    v15 = *((_QWORD *)&v40 + 1);
    if (*((_QWORD *)&v40 + 1))
    {
      if (*((__int128 **)&v40 + 1) == &v39)
      {
        v35 = v34;
        (*(void (**)(__int128 *, _BYTE *))(v39 + 24))(&v39, v34);
LABEL_26:
        qmi::ClientRouter::SendProxy::callback<std::function<void ()(qmi::ResponseBase const&)>>((uint64_t)v27, (uint64_t)v34);
        v16 = v35;
        if (v35 == v34)
        {
          v17 = 4;
          v16 = v34;
        }
        else
        {
          if (!v35)
            goto LABEL_31;
          v17 = 5;
        }
        (*(void (**)(void))(*v16 + 8 * v17))();
LABEL_31:
        v18 = v28;
        v28 = 0;
        if (v18)
          std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v28, v18);
        if (v10)
        {
          p_shared_owners = (unint64_t *)&v10->__shared_owners_;
          do
            v20 = __ldaxr(p_shared_owners);
          while (__stlxr(v20 - 1, p_shared_owners));
          if (!v20)
          {
            ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
            std::__shared_weak_count::__release_weak(v10);
          }
        }
        if (*((__int128 **)&v40 + 1) == &v39)
        {
          v21 = 4;
        }
        else
        {
          if (!*((_QWORD *)&v40 + 1))
            goto LABEL_43;
          v21 = 5;
          v14 = (__int128 *)*((_QWORD *)&v40 + 1);
        }
        (*(void (**)(__int128 *))(*(_QWORD *)v14 + 8 * v21))(v14);
LABEL_43:
        v22 = (std::__shared_weak_count *)*((_QWORD *)&v38 + 1);
        if (*((_QWORD *)&v38 + 1))
        {
          v23 = (unint64_t *)(*((_QWORD *)&v38 + 1) + 8);
          do
            v24 = __ldaxr(v23);
          while (__stlxr(v24 - 1, v23));
          if (!v24)
          {
            ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
            std::__shared_weak_count::__release_weak(v22);
          }
        }
        CallInfo::~CallInfo((void **)buf);
LABEL_49:
        _Block_object_dispose(&v30, 8);
        return;
      }
      v15 = (*(uint64_t (**)(void))(**((_QWORD **)&v40 + 1) + 16))();
    }
    v35 = (_BYTE *)v15;
    goto LABEL_26;
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    v25 = qmi::asString();
    v26 = *((_DWORD *)a2 + 1);
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = v25;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v26;
    _os_log_error_impl(&dword_216897000, v5, OS_LOG_TYPE_ERROR, "Placing active call on hold failed with error %s (%u)", buf, 0x12u);
  }
  (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)v4[2] + 16))(v4[2], a1 + 24);
}

void sub_2168F8E34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,std::__shared_weak_count *a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t *a34,uint64_t a35,uint64_t a36,void *a37)
{
  std::__shared_weak_count *v37;
  uint64_t v39;
  unint64_t *p_shared_owners;
  unint64_t v41;
  uint64_t *v42;
  uint64_t v43;
  std::__shared_weak_count *v44;
  unint64_t *v45;
  unint64_t v46;

  v39 = a11;
  a11 = 0;
  if (v39)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&a11, v39);
  if (v37)
  {
    p_shared_owners = (unint64_t *)&v37->__shared_owners_;
    do
      v41 = __ldaxr(p_shared_owners);
    while (__stlxr(v41 - 1, p_shared_owners));
    if (!v41)
    {
      ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
      std::__shared_weak_count::__release_weak(v37);
    }
  }
  v42 = a34;
  if (a34 == &a31)
  {
    v43 = 4;
    v42 = &a31;
  }
  else
  {
    if (!a34)
      goto LABEL_13;
    v43 = 5;
  }
  (*(void (**)(void))(*v42 + 8 * v43))();
LABEL_13:
  v44 = a30;
  if (a30)
  {
    v45 = (unint64_t *)&a30->__shared_owners_;
    do
      v46 = __ldaxr(v45);
    while (__stlxr(v46 - 1, v45));
    if (!v46)
    {
      ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
      std::__shared_weak_count::__release_weak(v44);
    }
  }
  CallInfo::~CallInfo(&a37);
  _Block_object_dispose(&a17, 8);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<EurekaC2KCallFormatter::createSecondCallDialReq(CallInfo,qmi::ClientRouter &)::$_1,std::allocator<EurekaC2KCallFormatter::createSecondCallDialReq(CallInfo,qmi::ClientRouter &)::$_1>,void ()(qmi::ResponseBase const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<EurekaC2KCallFormatter::createSecondCallDialReq(CallInfo,qmi::ClientRouter &)::$_1,std::allocator<EurekaC2KCallFormatter::createSecondCallDialReq(CallInfo,qmi::ClientRouter &)::$_1>,void ()(qmi::ResponseBase const&)>::target_type()
{
}

uint64_t std::__function::__value_func<void ()(qmi::ResponseBase const&)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;

  v3 = (_QWORD *)(a2 + 24);
  v4 = *(_QWORD *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(_QWORD *)(a1 + 24) = a1;
      (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(_QWORD *)(a1 + 24) = v4;
  }
  else
  {
    v3 = (_QWORD *)(a1 + 24);
  }
  *v3 = 0;
  return a1;
}

uint64_t std::__compressed_pair_elem<EurekaC2KCallFormatter::createSecondCallDialReq(CallInfo,qmi::ClientRouter &)::$_1,0,false>::__compressed_pair_elem[abi:ne180100]<EurekaC2KCallFormatter::createSecondCallDialReq(CallInfo,qmi::ClientRouter &)::$_1 const&,0ul>(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;

  v4 = *a2;
  *(_DWORD *)(a1 + 8) = *((_DWORD *)a2 + 2);
  *(_QWORD *)a1 = v4;
  CallInfo::CallInfo((CallInfo *)(a1 + 16), (const CallInfo *)(a2 + 2));
  std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100](a1 + 424, (uint64_t)(a2 + 53));
  v5 = a2[58];
  *(_QWORD *)(a1 + 456) = a2[57];
  *(_QWORD *)(a1 + 464) = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  return a1;
}

void sub_2168F90C4(_Unwind_Exception *a1)
{
  void **v1;

  CallInfo::~CallInfo(v1);
  _Unwind_Resume(a1);
}

void std::__function::__alloc_func<EurekaC2KCallFormatter::createSecondCallDialReq(CallInfo,qmi::ClientRouter &)::$_1,std::allocator<EurekaC2KCallFormatter::createSecondCallDialReq(CallInfo,qmi::ClientRouter &)::$_1>,void ()(qmi::ResponseBase const&)>::destroy[abi:ne180100](uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 456);
  v2 = *(_QWORD **)(a1 + 448);
  if (v2 == (_QWORD *)(a1 + 424))
  {
    v3 = 4;
    v2 = (_QWORD *)(a1 + 424);
    goto LABEL_5;
  }
  if (v2)
  {
    v3 = 5;
LABEL_5:
    (*(void (**)(void))(*v2 + 8 * v3))();
  }
  CallInfo::~CallInfo((void **)(a1 + 16));
}

uint64_t ___ZZN22EurekaC2KCallFormatter23createSecondCallDialReqE8CallInfoRN3qmi12ClientRouterEENK3__1clERKNS1_12ResponseBaseE_block_invoke(uint64_t result, _BYTE *a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = *a2;
  return result;
}

uint64_t qmi::ClientRouter::SendProxy::callback<std::function<void ()(qmi::ResponseBase const&)>>(uint64_t a1, uint64_t a2)
{
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  _QWORD v16[5];
  std::__shared_weak_count *v17;
  uint64_t v18;
  std::__shared_weak_count *v19;
  _QWORD aBlock[5];

  v4 = (std::__shared_weak_count *)operator new(0x38uLL);
  v4->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v4->__shared_owners_;
  v4->__shared_weak_owners_ = 0;
  v4->__vftable = (std::__shared_weak_count_vtbl *)&unk_24D5C72C8;
  v18 = std::__function::__value_func<void ()(qmi::ResponseBase const&)>::__value_func[abi:ne180100]((uint64_t)&v4[1], a2);
  v19 = v4;
  v6 = *(_QWORD *)(a1 + 8);
  v7 = MEMORY[0x24BDAC760];
  v16[0] = MEMORY[0x24BDAC760];
  v16[1] = 1174405120;
  v16[2] = ___ZNO3qmi12ClientRouter9SendProxy8callbackINSt3__18functionIFvRKNS_12ResponseBaseEEEEEEOS1_OT__block_invoke;
  v16[3] = &__block_descriptor_tmp_17_0;
  v16[4] = v18;
  v17 = v4;
  do
    v8 = __ldxr(p_shared_owners);
  while (__stxr(v8 + 1, p_shared_owners));
  aBlock[0] = v7;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_2;
  aBlock[3] = &unk_24D5C7310;
  aBlock[4] = v16;
  *(_QWORD *)(v6 + 32) = _Block_copy(aBlock);
  v9 = v17;
  if (v17)
  {
    v10 = (unint64_t *)&v17->__shared_owners_;
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  v12 = v19;
  if (v19)
  {
    v13 = (unint64_t *)&v19->__shared_owners_;
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  return a1;
}

void sub_2168F92A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  uint64_t v8;
  va_list va;

  va_start(va, a8);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v8);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t qmi::ClientRouter::SendProxy::SendProxy<qmi::MutableMessageBase>(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v5;

  *(_DWORD *)a1 = a2;
  v5 = operator new();
  *(_QWORD *)v5 = a3;
  *(_QWORD *)(v5 + 8) = QMIServiceMsg::create();
  *(_DWORD *)(v5 + 16) = 25000;
  *(_QWORD *)(v5 + 24) = 0;
  *(_QWORD *)(v5 + 32) = 0;
  *(_QWORD *)(a1 + 8) = v5;
  return a1;
}

void sub_2168F9334(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199FEAC4](v1, 0x10F0C401BA14CC5);
  _Unwind_Resume(a1);
}

uint64_t ___ZNO3qmi12ClientRouter9SendProxy8callbackINSt3__18functionIFvRKNS_12ResponseBaseEEEEEEOS1_OT__block_invoke(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 24);
  if (!v1)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 48))(v1);
}

uint64_t __copy_helper_block_e8_32c66_ZTSNSt3__110shared_ptrINS_8functionIFvRKN3qmi12ResponseBaseEEEEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c66_ZTSNSt3__110shared_ptrINS_8functionIFvRKN3qmi12ResponseBaseEEEEEE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<std::function<void ()(qmi::ResponseBase const&)>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_24D5C72C8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<std::function<void ()(qmi::ResponseBase const&)>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_24D5C72C8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__shared_ptr_emplace<std::function<void ()(qmi::ResponseBase const&)>>::__on_zero_shared(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *result;
  uint64_t v3;

  v1 = (_QWORD *)(a1 + 24);
  result = *(_QWORD **)(a1 + 48);
  if (result == v1)
  {
    v3 = 4;
    result = v1;
  }
  else
  {
    if (!result)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

uint64_t std::__function::__func<EurekaC2KCallFormatter::createAnswerWaitingHoldOtherReq(ctu::cf::CFSharedRef<__CFUUID const>,subscriber::SimSlot)::$_0,std::allocator<EurekaC2KCallFormatter::createAnswerWaitingHoldOtherReq(ctu::cf::CFSharedRef<__CFUUID const>,subscriber::SimSlot)::$_0>,void ()(qmi::ResponseBase const&)>::~__func(uint64_t a1)
{
  *(_QWORD *)a1 = &off_24D5C7350;
  ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::~SharedRef((const void **)(a1 + 24));
  return a1;
}

void std::__function::__func<EurekaC2KCallFormatter::createAnswerWaitingHoldOtherReq(ctu::cf::CFSharedRef<__CFUUID const>,subscriber::SimSlot)::$_0,std::allocator<EurekaC2KCallFormatter::createAnswerWaitingHoldOtherReq(ctu::cf::CFSharedRef<__CFUUID const>,subscriber::SimSlot)::$_0>,void ()(qmi::ResponseBase const&)>::~__func(uint64_t a1)
{
  *(_QWORD *)a1 = &off_24D5C7350;
  ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::~SharedRef((const void **)(a1 + 24));
  JUMPOUT(0x2199FEAC4);
}

void *std::__function::__func<EurekaC2KCallFormatter::createAnswerWaitingHoldOtherReq(ctu::cf::CFSharedRef<__CFUUID const>,subscriber::SimSlot)::$_0,std::allocator<EurekaC2KCallFormatter::createAnswerWaitingHoldOtherReq(ctu::cf::CFSharedRef<__CFUUID const>,subscriber::SimSlot)::$_0>,void ()(qmi::ResponseBase const&)>::__clone(uint64_t a1)
{
  void *v2;
  uint64_t v3;

  v2 = operator new(0x20uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)v2 = &off_24D5C7350;
  *((_QWORD *)v2 + 1) = v3;
  *((_DWORD *)v2 + 4) = *(_DWORD *)(a1 + 16);
  ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::SharedRef((const void **)v2 + 3, (const void **)(a1 + 24));
  return v2;
}

const void **std::__function::__func<EurekaC2KCallFormatter::createAnswerWaitingHoldOtherReq(ctu::cf::CFSharedRef<__CFUUID const>,subscriber::SimSlot)::$_0,std::allocator<EurekaC2KCallFormatter::createAnswerWaitingHoldOtherReq(ctu::cf::CFSharedRef<__CFUUID const>,subscriber::SimSlot)::$_0>,void ()(qmi::ResponseBase const&)>::__clone(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  *(_QWORD *)a2 = &off_24D5C7350;
  v2 = *(_QWORD *)(a1 + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(a1 + 16);
  *(_QWORD *)(a2 + 8) = v2;
  return ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::SharedRef((const void **)(a2 + 24), (const void **)(a1 + 24));
}

const void **std::__function::__func<EurekaC2KCallFormatter::createAnswerWaitingHoldOtherReq(ctu::cf::CFSharedRef<__CFUUID const>,subscriber::SimSlot)::$_0,std::allocator<EurekaC2KCallFormatter::createAnswerWaitingHoldOtherReq(ctu::cf::CFSharedRef<__CFUUID const>,subscriber::SimSlot)::$_0>,void ()(qmi::ResponseBase const&)>::destroy(uint64_t a1)
{
  return ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::~SharedRef((const void **)(a1 + 24));
}

void std::__function::__func<EurekaC2KCallFormatter::createAnswerWaitingHoldOtherReq(ctu::cf::CFSharedRef<__CFUUID const>,subscriber::SimSlot)::$_0,std::allocator<EurekaC2KCallFormatter::createAnswerWaitingHoldOtherReq(ctu::cf::CFSharedRef<__CFUUID const>,subscriber::SimSlot)::$_0>,void ()(qmi::ResponseBase const&)>::destroy_deallocate(const void **a1)
{
  ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::~SharedRef(a1 + 3);
  operator delete(a1);
}

void std::__function::__func<EurekaC2KCallFormatter::createAnswerWaitingHoldOtherReq(ctu::cf::CFSharedRef<__CFUUID const>,subscriber::SimSlot)::$_0,std::allocator<EurekaC2KCallFormatter::createAnswerWaitingHoldOtherReq(ctu::cf::CFSharedRef<__CFUUID const>,subscriber::SimSlot)::$_0>,void ()(qmi::ResponseBase const&)>::operator()(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v4;
  int v5;
  NSObject *v6;
  uint64_t v7;
  NSObject *v8;
  _QWORD v9[5];
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  int v13;
  _OWORD v14[5];
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  uint64_t v35;
  uint8_t buf[32];
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  uint64_t v60;
  uint64_t v61;

  v61 = *MEMORY[0x24BDAC8D0];
  if (!*((_DWORD *)a2 + 1))
  {
    v4 = *(_QWORD *)(a1 + 8);
    v35 = 0;
    v33 = 0u;
    v34 = 0u;
    v31 = 0u;
    v32 = 0u;
    v29 = 0u;
    v30 = 0u;
    v27 = 0u;
    v28 = 0u;
    v25 = 0u;
    v26 = 0u;
    v23 = 0u;
    v24 = 0u;
    v21 = 0u;
    v22 = 0u;
    v19 = 0u;
    v20 = 0u;
    v17 = 0u;
    v18 = 0u;
    v15 = 0u;
    v16 = 0u;
    memset(v14, 0, sizeof(v14));
    CallInfo::CallInfo((CallInfo *)v14);
    v10 = 0;
    v11 = &v10;
    v12 = 0x2000000000;
    v13 = *MEMORY[0x24BDC39A8];
    v9[0] = MEMORY[0x24BDAC760];
    v9[1] = 0x40000000;
    v9[2] = ___ZZN22EurekaC2KCallFormatter31createAnswerWaitingHoldOtherReqEN3ctu2cf11CFSharedRefIK8__CFUUIDEEN10subscriber7SimSlotEENK3__0clERKN3qmi12ResponseBaseE_block_invoke;
    v9[3] = &unk_24D5C73B8;
    v9[4] = &v10;
    *(_QWORD *)buf = v9;
    if ((qmi::MessageBase::applyTlv<vs::tlv::CallIdentifier,void({block_pointer})(vs::tlv::CallIdentifier const&)>(a2, 16, (uint64_t)buf) & 1) != 0)
    {
      v5 = *(_DWORD *)(a1 + 16);
      HIDWORD(v15) = *((_DWORD *)v11 + 6);
      HIDWORD(v25) = v5;
      v6 = *(NSObject **)(v4 + 8);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        v7 = subscriber::asString();
        *(_DWORD *)buf = 136315394;
        *(_QWORD *)&buf[4] = v7;
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = HIDWORD(v15);
        _os_log_impl(&dword_216897000, v6, OS_LOG_TYPE_DEFAULT, "#I Call with ID being heold on slot %s: %d", buf, 0x12u);
      }
      (*(void (**)(_QWORD, _OWORD *))(**(_QWORD **)(v4 + 16) + 32))(*(_QWORD *)(v4 + 16), v14);
      v60 = 0;
      v58 = 0u;
      v59 = 0u;
      v56 = 0u;
      v57 = 0u;
      v54 = 0u;
      v55 = 0u;
      v52 = 0u;
      v53 = 0u;
      v50 = 0u;
      v51 = 0u;
      v48 = 0u;
      v49 = 0u;
      v46 = 0u;
      v47 = 0u;
      v44 = 0u;
      v45 = 0u;
      v42 = 0u;
      v43 = 0u;
      v40 = 0u;
      v41 = 0u;
      v38 = 0u;
      v39 = 0u;
      v37 = 0u;
      memset(buf, 0, sizeof(buf));
      CallInfo::CallInfo((CallInfo *)buf);
      ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::operator=((const void **)buf, (const void **)(a1 + 24));
      HIDWORD(v50) = *(_DWORD *)(a1 + 16);
      (*(void (**)(_QWORD, uint8_t *, _QWORD))(**(_QWORD **)(v4 + 16) + 24))(*(_QWORD *)(v4 + 16), buf, 0);
      (*(void (**)(_QWORD, _QWORD, uint64_t, _QWORD))(**(_QWORD **)(v4 + 16) + 112))(*(_QWORD *)(v4 + 16), *MEMORY[0x24BDC3EF8], 1, HIDWORD(v50));
      (*(void (**)(_QWORD, _QWORD, uint64_t, _QWORD))(**(_QWORD **)(v4 + 16) + 112))(*(_QWORD *)(v4 + 16), *MEMORY[0x24BDC3DB8], 1, HIDWORD(v50));
      (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)(v4 + 16) + 96))(*(_QWORD *)(v4 + 16), HIDWORD(v50));
      (*(void (**)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(**(_QWORD **)(v4 + 16) + 104))(*(_QWORD *)(v4 + 16), *MEMORY[0x24BDC3DA0], 0, 0, HIDWORD(v50));
      CallInfo::~CallInfo((void **)buf);
    }
    else
    {
      v8 = *(NSObject **)(v4 + 8);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_216897000, v8, OS_LOG_TYPE_ERROR, "Invalid Flash Message response. Mandatory TLV, CallId, not present", buf, 2u);
      }
    }
    _Block_object_dispose(&v10, 8);
    CallInfo::~CallInfo((void **)v14);
  }
}

void sub_2168F9850(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v8;
  va_list va;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  va_list va1;

  va_start(va1, a7);
  va_start(va, a7);
  v8 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  CallInfo::~CallInfo((void **)va1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<EurekaC2KCallFormatter::createAnswerWaitingHoldOtherReq(ctu::cf::CFSharedRef<__CFUUID const>,subscriber::SimSlot)::$_0,std::allocator<EurekaC2KCallFormatter::createAnswerWaitingHoldOtherReq(ctu::cf::CFSharedRef<__CFUUID const>,subscriber::SimSlot)::$_0>,void ()(qmi::ResponseBase const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<EurekaC2KCallFormatter::createAnswerWaitingHoldOtherReq(ctu::cf::CFSharedRef<__CFUUID const>,subscriber::SimSlot)::$_0,std::allocator<EurekaC2KCallFormatter::createAnswerWaitingHoldOtherReq(ctu::cf::CFSharedRef<__CFUUID const>,subscriber::SimSlot)::$_0>,void ()(qmi::ResponseBase const&)>::target_type()
{
}

uint64_t ___ZZN22EurekaC2KCallFormatter31createAnswerWaitingHoldOtherReqEN3ctu2cf11CFSharedRefIK8__CFUUIDEEN10subscriber7SimSlotEENK3__0clERKN3qmi12ResponseBaseE_block_invoke(uint64_t result, unsigned __int8 *a2)
{
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = *a2;
  return result;
}

uint64_t std::__function::__func<EurekaC2KCallFormatter::createSwapReq(ctu::cf::CFSharedRef<__CFUUID const>,subscriber::SimSlot)::$_0,std::allocator<EurekaC2KCallFormatter::createSwapReq(ctu::cf::CFSharedRef<__CFUUID const>,subscriber::SimSlot)::$_0>,void ()(qmi::ResponseBase const&)>::~__func(uint64_t a1)
{
  *(_QWORD *)a1 = &off_24D5C73F8;
  ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::~SharedRef((const void **)(a1 + 24));
  return a1;
}

void std::__function::__func<EurekaC2KCallFormatter::createSwapReq(ctu::cf::CFSharedRef<__CFUUID const>,subscriber::SimSlot)::$_0,std::allocator<EurekaC2KCallFormatter::createSwapReq(ctu::cf::CFSharedRef<__CFUUID const>,subscriber::SimSlot)::$_0>,void ()(qmi::ResponseBase const&)>::~__func(uint64_t a1)
{
  *(_QWORD *)a1 = &off_24D5C73F8;
  ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::~SharedRef((const void **)(a1 + 24));
  JUMPOUT(0x2199FEAC4);
}

void *std::__function::__func<EurekaC2KCallFormatter::createSwapReq(ctu::cf::CFSharedRef<__CFUUID const>,subscriber::SimSlot)::$_0,std::allocator<EurekaC2KCallFormatter::createSwapReq(ctu::cf::CFSharedRef<__CFUUID const>,subscriber::SimSlot)::$_0>,void ()(qmi::ResponseBase const&)>::__clone(uint64_t a1)
{
  void *v2;
  uint64_t v3;

  v2 = operator new(0x20uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)v2 = &off_24D5C73F8;
  *((_QWORD *)v2 + 1) = v3;
  *((_DWORD *)v2 + 4) = *(_DWORD *)(a1 + 16);
  ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::SharedRef((const void **)v2 + 3, (const void **)(a1 + 24));
  return v2;
}

const void **std::__function::__func<EurekaC2KCallFormatter::createSwapReq(ctu::cf::CFSharedRef<__CFUUID const>,subscriber::SimSlot)::$_0,std::allocator<EurekaC2KCallFormatter::createSwapReq(ctu::cf::CFSharedRef<__CFUUID const>,subscriber::SimSlot)::$_0>,void ()(qmi::ResponseBase const&)>::__clone(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  *(_QWORD *)a2 = &off_24D5C73F8;
  v2 = *(_QWORD *)(a1 + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(a1 + 16);
  *(_QWORD *)(a2 + 8) = v2;
  return ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::SharedRef((const void **)(a2 + 24), (const void **)(a1 + 24));
}

const void **std::__function::__func<EurekaC2KCallFormatter::createSwapReq(ctu::cf::CFSharedRef<__CFUUID const>,subscriber::SimSlot)::$_0,std::allocator<EurekaC2KCallFormatter::createSwapReq(ctu::cf::CFSharedRef<__CFUUID const>,subscriber::SimSlot)::$_0>,void ()(qmi::ResponseBase const&)>::destroy(uint64_t a1)
{
  return ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::~SharedRef((const void **)(a1 + 24));
}

void std::__function::__func<EurekaC2KCallFormatter::createSwapReq(ctu::cf::CFSharedRef<__CFUUID const>,subscriber::SimSlot)::$_0,std::allocator<EurekaC2KCallFormatter::createSwapReq(ctu::cf::CFSharedRef<__CFUUID const>,subscriber::SimSlot)::$_0>,void ()(qmi::ResponseBase const&)>::destroy_deallocate(const void **a1)
{
  ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::~SharedRef(a1 + 3);
  operator delete(a1);
}

void std::__function::__func<EurekaC2KCallFormatter::createSwapReq(ctu::cf::CFSharedRef<__CFUUID const>,subscriber::SimSlot)::$_0,std::allocator<EurekaC2KCallFormatter::createSwapReq(ctu::cf::CFSharedRef<__CFUUID const>,subscriber::SimSlot)::$_0>,void ()(qmi::ResponseBase const&)>::operator()(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v4;
  int v5;
  NSObject *v6;
  _OWORD v7[5];
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  uint64_t v28;
  _QWORD v29[5];
  uint64_t v30;
  uint64_t *v31;
  uint64_t v32;
  int v33;
  _OWORD v34[5];
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  uint64_t v55;

  if (!*((_DWORD *)a2 + 1))
  {
    v4 = *(_QWORD *)(a1 + 8);
    v55 = 0;
    v53 = 0u;
    v54 = 0u;
    v51 = 0u;
    v52 = 0u;
    v49 = 0u;
    v50 = 0u;
    v47 = 0u;
    v48 = 0u;
    v45 = 0u;
    v46 = 0u;
    v43 = 0u;
    v44 = 0u;
    v41 = 0u;
    v42 = 0u;
    v39 = 0u;
    v40 = 0u;
    v37 = 0u;
    v38 = 0u;
    v35 = 0u;
    v36 = 0u;
    memset(v34, 0, sizeof(v34));
    CallInfo::CallInfo((CallInfo *)v34);
    v30 = 0;
    v31 = &v30;
    v32 = 0x2000000000;
    v33 = *MEMORY[0x24BDC39A8];
    v29[0] = MEMORY[0x24BDAC760];
    v29[1] = 0x40000000;
    v29[2] = ___ZZN22EurekaC2KCallFormatter13createSwapReqEN3ctu2cf11CFSharedRefIK8__CFUUIDEEN10subscriber7SimSlotEENK3__0clERKN3qmi12ResponseBaseE_block_invoke;
    v29[3] = &unk_24D5C7460;
    v29[4] = &v30;
    *(_QWORD *)&v7[0] = v29;
    if ((qmi::MessageBase::applyTlv<vs::tlv::CallIdentifier,void({block_pointer})(vs::tlv::CallIdentifier const&)>(a2, 16, (uint64_t)v7) & 1) != 0)
    {
      v5 = *(_DWORD *)(a1 + 16);
      HIDWORD(v35) = *((_DWORD *)v31 + 6);
      HIDWORD(v45) = v5;
      (*(void (**)(_QWORD, _OWORD *, _QWORD))(**(_QWORD **)(v4 + 16) + 24))(*(_QWORD *)(v4 + 16), v34, 0);
      v28 = 0;
      v26 = 0u;
      v27 = 0u;
      v24 = 0u;
      v25 = 0u;
      v22 = 0u;
      v23 = 0u;
      v20 = 0u;
      v21 = 0u;
      v18 = 0u;
      v19 = 0u;
      v16 = 0u;
      v17 = 0u;
      v14 = 0u;
      v15 = 0u;
      v12 = 0u;
      v13 = 0u;
      v10 = 0u;
      v11 = 0u;
      v8 = 0u;
      v9 = 0u;
      memset(v7, 0, sizeof(v7));
      CallInfo::CallInfo((CallInfo *)v7);
      HIDWORD(v18) = *(_DWORD *)(a1 + 16);
      HIDWORD(v8) = *((_DWORD *)v31 + 6);
      ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::operator=((const void **)v7, (const void **)(a1 + 24));
      (*(void (**)(_QWORD, _OWORD *))(**(_QWORD **)(v4 + 16) + 32))(*(_QWORD *)(v4 + 16), v7);
      (*(void (**)(_QWORD, _QWORD, uint64_t, _QWORD))(**(_QWORD **)(v4 + 16) + 112))(*(_QWORD *)(v4 + 16), *MEMORY[0x24BDC3EF8], 1, HIDWORD(v18));
      (*(void (**)(_QWORD, _QWORD, uint64_t, _QWORD))(**(_QWORD **)(v4 + 16) + 112))(*(_QWORD *)(v4 + 16), *MEMORY[0x24BDC3DB8], 1, HIDWORD(v18));
      (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)(v4 + 16) + 96))(*(_QWORD *)(v4 + 16), HIDWORD(v18));
      (*(void (**)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(**(_QWORD **)(v4 + 16) + 104))(*(_QWORD *)(v4 + 16), *MEMORY[0x24BDC3DA0], 0, 0, HIDWORD(v18));
      CallInfo::~CallInfo((void **)v7);
    }
    else
    {
      v6 = *(NSObject **)(v4 + 8);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v7[0]) = 0;
        _os_log_error_impl(&dword_216897000, v6, OS_LOG_TYPE_ERROR, "Invalid Flash Message response. Mandatory TLV, CallId, not present", (uint8_t *)v7, 2u);
      }
    }
    _Block_object_dispose(&v30, 8);
    CallInfo::~CallInfo((void **)v34);
  }
}

void sub_2168F9C84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  char a65;
  void *a69;

  _Block_object_dispose(&a65, 8);
  CallInfo::~CallInfo(&a69);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<EurekaC2KCallFormatter::createSwapReq(ctu::cf::CFSharedRef<__CFUUID const>,subscriber::SimSlot)::$_0,std::allocator<EurekaC2KCallFormatter::createSwapReq(ctu::cf::CFSharedRef<__CFUUID const>,subscriber::SimSlot)::$_0>,void ()(qmi::ResponseBase const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<EurekaC2KCallFormatter::createSwapReq(ctu::cf::CFSharedRef<__CFUUID const>,subscriber::SimSlot)::$_0,std::allocator<EurekaC2KCallFormatter::createSwapReq(ctu::cf::CFSharedRef<__CFUUID const>,subscriber::SimSlot)::$_0>,void ()(qmi::ResponseBase const&)>::target_type()
{
}

uint64_t ___ZZN22EurekaC2KCallFormatter13createSwapReqEN3ctu2cf11CFSharedRefIK8__CFUUIDEEN10subscriber7SimSlotEENK3__0clERKN3qmi12ResponseBaseE_block_invoke(uint64_t result, unsigned __int8 *a2)
{
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = *a2;
  return result;
}

uint64_t std::__function::__func<EurekaC2KCallFormatter::createMergeReq(CallOperationContext)::$_0,std::allocator<EurekaC2KCallFormatter::createMergeReq(CallOperationContext)::$_0>,void ()(qmi::ResponseBase const&)>::~__func(uint64_t a1)
{
  *(_QWORD *)a1 = off_24D5C74A0;
  if (*(char *)(a1 + 447) < 0)
    operator delete(*(void **)(a1 + 424));
  CallInfo::~CallInfo((void **)(a1 + 16));
  return a1;
}

void std::__function::__func<EurekaC2KCallFormatter::createMergeReq(CallOperationContext)::$_0,std::allocator<EurekaC2KCallFormatter::createMergeReq(CallOperationContext)::$_0>,void ()(qmi::ResponseBase const&)>::~__func(uint64_t a1)
{
  *(_QWORD *)a1 = off_24D5C74A0;
  if (*(char *)(a1 + 447) < 0)
    operator delete(*(void **)(a1 + 424));
  CallInfo::~CallInfo((void **)(a1 + 16));
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<EurekaC2KCallFormatter::createMergeReq(CallOperationContext)::$_0,std::allocator<EurekaC2KCallFormatter::createMergeReq(CallOperationContext)::$_0>,void ()(qmi::ResponseBase const&)>::__clone(uint64_t a1)
{
  uint64_t v1;
  _QWORD *v2;

  v1 = a1 + 8;
  v2 = operator new(0x1C0uLL);
  *v2 = off_24D5C74A0;
  std::__compressed_pair_elem<EurekaC2KCallFormatter::createMergeReq(CallOperationContext)::$_0,0,false>::__compressed_pair_elem[abi:ne180100]<EurekaC2KCallFormatter::createMergeReq(CallOperationContext)::$_0 const&,0ul>(v2 + 1, v1);
  return v2;
}

void sub_2168F9DF0(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__function::__func<EurekaC2KCallFormatter::createMergeReq(CallOperationContext)::$_0,std::allocator<EurekaC2KCallFormatter::createMergeReq(CallOperationContext)::$_0>,void ()(qmi::ResponseBase const&)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = off_24D5C74A0;
  return std::__compressed_pair_elem<EurekaC2KCallFormatter::createMergeReq(CallOperationContext)::$_0,0,false>::__compressed_pair_elem[abi:ne180100]<EurekaC2KCallFormatter::createMergeReq(CallOperationContext)::$_0 const&,0ul>(a2 + 1, a1 + 8);
}

void std::__function::__func<EurekaC2KCallFormatter::createMergeReq(CallOperationContext)::$_0,std::allocator<EurekaC2KCallFormatter::createMergeReq(CallOperationContext)::$_0>,void ()(qmi::ResponseBase const&)>::destroy(uint64_t a1)
{
  std::__function::__alloc_func<EurekaC2KCallFormatter::createMergeReq(CallOperationContext)::$_0,std::allocator<EurekaC2KCallFormatter::createMergeReq(CallOperationContext)::$_0>,void ()(qmi::ResponseBase const&)>::destroy[abi:ne180100](a1 + 8);
}

void std::__function::__func<EurekaC2KCallFormatter::createMergeReq(CallOperationContext)::$_0,std::allocator<EurekaC2KCallFormatter::createMergeReq(CallOperationContext)::$_0>,void ()(qmi::ResponseBase const&)>::destroy_deallocate(void *a1)
{
  std::__function::__alloc_func<EurekaC2KCallFormatter::createMergeReq(CallOperationContext)::$_0,std::allocator<EurekaC2KCallFormatter::createMergeReq(CallOperationContext)::$_0>,void ()(qmi::ResponseBase const&)>::destroy[abi:ne180100]((uint64_t)a1 + 8);
  operator delete(a1);
}

void std::__function::__func<EurekaC2KCallFormatter::createMergeReq(CallOperationContext)::$_0,std::allocator<EurekaC2KCallFormatter::createMergeReq(CallOperationContext)::$_0>,void ()(qmi::ResponseBase const&)>::operator()(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v2;
  _QWORD *v3;
  const char *v4;
  size_t v5;
  _QWORD *v6;
  _QWORD *v7;
  NSObject *v8;
  uint64_t v9;
  int v11;
  NSObject *v12;
  void **v13;
  void *v14;
  char v15;
  void *__p[2];
  uint64_t (*v17)(uint64_t, _BYTE *);
  void *v18;
  __int128 *p_buf;
  uint8_t v20[16];
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  uint64_t v45;
  xpc_object_t v46;
  xpc_object_t v47;
  __int128 buf;
  uint64_t v49;
  char v50;
  uint64_t v51;

  v51 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 8);
  if (*((_DWORD *)a2 + 1))
  {
    *(_QWORD *)&v37 = 0;
    v35 = 0u;
    v36 = 0u;
    v33 = 0u;
    v34 = 0u;
    v31 = 0u;
    v32 = 0u;
    v29 = 0u;
    v30 = 0u;
    v27 = 0u;
    v28 = 0u;
    v25 = 0u;
    v26 = 0u;
    v24 = 0u;
    v22 = 0u;
    v23 = 0u;
    *(_OWORD *)v20 = 0u;
    v21 = 0u;
    std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v20);
    v3 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v21, (uint64_t)"Merging calls into conference failed with error ", 48);
    v4 = (const char *)qmi::asString();
    v5 = strlen(v4);
    v6 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v3, (uint64_t)v4, v5);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v6, (uint64_t)" (", 2);
    v7 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v7, (uint64_t)")", 1);
    v8 = *(NSObject **)(v2 + 8);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)&v21 + 8, __p);
      v13 = SHIBYTE(v17) >= 0 ? __p : (void **)__p[0];
      LODWORD(buf) = 136315138;
      *(_QWORD *)((char *)&buf + 4) = v13;
      _os_log_error_impl(&dword_216897000, v8, OS_LOG_TYPE_ERROR, "%s", (uint8_t *)&buf, 0xCu);
      if (SHIBYTE(v17) < 0)
        operator delete(__p[0]);
    }
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)&v21 + 8, &v14);
    RequestDumpStatePayload::RequestDumpStatePayload();
    v47 = 0;
    write_rest_value();
    std::string::basic_string[abi:ne180100]<0>(&buf, "/cc/events/request_dump_state");
    v46 = v47;
    v47 = xpc_null_create();
    ctu::RestModule::sendEvent();
    xpc_release(v46);
    v46 = 0;
    if (SHIBYTE(v49) < 0)
      operator delete((void *)buf);
    xpc_release(v47);
    if (SHIBYTE(v17) < 0)
      operator delete(__p[0]);
    if (v15 < 0)
      operator delete(v14);
    *(_QWORD *)v20 = *MEMORY[0x24BEDB7F0];
    v9 = *(_QWORD *)(MEMORY[0x24BEDB7F0] + 72);
    *(_QWORD *)&v20[*(_QWORD *)(*(_QWORD *)v20 - 24)] = *(_QWORD *)(MEMORY[0x24BEDB7F0] + 64);
    *(_QWORD *)&v21 = v9;
    *((_QWORD *)&v21 + 1) = MEMORY[0x24BEDB848] + 16;
    if (SHIBYTE(v26) < 0)
      operator delete(*((void **)&v25 + 1));
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x2199FEA70](&v28);
  }
  else
  {
    *(_QWORD *)&buf = 0;
    *((_QWORD *)&buf + 1) = &buf;
    v49 = 0x2000000000;
    v50 = 0;
    __p[0] = (void *)MEMORY[0x24BDAC760];
    __p[1] = (void *)0x40000000;
    v17 = ___ZZN22EurekaC2KCallFormatter14createMergeReqE20CallOperationContextENK3__0clERKN3qmi12ResponseBaseE_block_invoke;
    v18 = &unk_24D5C7508;
    p_buf = &buf;
    *(_QWORD *)v20 = __p;
    if ((qmi::MessageBase::applyTlv<vs::tlv::CallIdentifier,void({block_pointer})(vs::tlv::CallIdentifier const&)>(a2, 16, (uint64_t)v20) & 1) != 0)
    {
      (*(void (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)v2 + 176))(v2, *(unsigned __int8 *)(*((_QWORD *)&buf + 1) + 24), *(unsigned int *)(a1 + 268));
      v45 = 0;
      v43 = 0u;
      v44 = 0u;
      v41 = 0u;
      v42 = 0u;
      v39 = 0u;
      v40 = 0u;
      v37 = 0u;
      v38 = 0u;
      v35 = 0u;
      v36 = 0u;
      v33 = 0u;
      v34 = 0u;
      v31 = 0u;
      v32 = 0u;
      v29 = 0u;
      v30 = 0u;
      v27 = 0u;
      v28 = 0u;
      v25 = 0u;
      v26 = 0u;
      v24 = 0u;
      v22 = 0u;
      v23 = 0u;
      *(_OWORD *)v20 = 0u;
      v21 = 0u;
      CallInfo::CallInfo((CallInfo *)v20);
      v11 = *(_DWORD *)(a1 + 268);
      HIDWORD(v25) = *(unsigned __int8 *)(*((_QWORD *)&buf + 1) + 24);
      HIDWORD(v35) = v11;
      (*(void (**)(_QWORD, uint8_t *))(**(_QWORD **)(v2 + 16) + 48))(*(_QWORD *)(v2 + 16), v20);
      (*(void (**)(_QWORD, _QWORD, _QWORD, _QWORD))(**(_QWORD **)(v2 + 16) + 112))(*(_QWORD *)(v2 + 16), *MEMORY[0x24BDC3EF8], 0, HIDWORD(v35));
      (*(void (**)(_QWORD, _QWORD, _QWORD, _QWORD))(**(_QWORD **)(v2 + 16) + 112))(*(_QWORD *)(v2 + 16), *MEMORY[0x24BDC3ED8], 0, HIDWORD(v35));
      (*(void (**)(_QWORD, _QWORD, _QWORD, _QWORD))(**(_QWORD **)(v2 + 16) + 112))(*(_QWORD *)(v2 + 16), *MEMORY[0x24BDC3DA0], 0, HIDWORD(v35));
      (*(void (**)(_QWORD, _QWORD, uint64_t, _QWORD))(**(_QWORD **)(v2 + 16) + 112))(*(_QWORD *)(v2 + 16), *MEMORY[0x24BDC3DB8], 1, HIDWORD(v35));
      (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)(v2 + 16) + 96))(*(_QWORD *)(v2 + 16), HIDWORD(v35));
      CallInfo::~CallInfo((void **)v20);
    }
    else
    {
      v12 = *(NSObject **)(v2 + 8);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)v20 = 0;
        _os_log_error_impl(&dword_216897000, v12, OS_LOG_TYPE_ERROR, "Invalid Flash Message response. Mandatory TLV, CallId, not present", v20, 2u);
      }
    }
    _Block_object_dispose(&buf, 8);
  }
}

void sub_2168FA2E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,void *__p,uint64_t a37,int a38,__int16 a39,char a40,char a41)
{
  uint64_t v41;

  _Block_object_dispose((const void *)(v41 - 96), 8);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<EurekaC2KCallFormatter::createMergeReq(CallOperationContext)::$_0,std::allocator<EurekaC2KCallFormatter::createMergeReq(CallOperationContext)::$_0>,void ()(qmi::ResponseBase const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<EurekaC2KCallFormatter::createMergeReq(CallOperationContext)::$_0,std::allocator<EurekaC2KCallFormatter::createMergeReq(CallOperationContext)::$_0>,void ()(qmi::ResponseBase const&)>::target_type()
{
}

_QWORD *std::__compressed_pair_elem<EurekaC2KCallFormatter::createMergeReq(CallOperationContext)::$_0,0,false>::__compressed_pair_elem[abi:ne180100]<EurekaC2KCallFormatter::createMergeReq(CallOperationContext)::$_0 const&,0ul>(_QWORD *a1, uint64_t a2)
{
  std::string *v4;
  __int128 v5;

  *a1 = *(_QWORD *)a2;
  CallInfo::CallInfo((CallInfo *)(a1 + 1), (const CallInfo *)(a2 + 8));
  v4 = (std::string *)(a1 + 52);
  if (*(char *)(a2 + 439) < 0)
  {
    std::string::__init_copy_ctor_external(v4, *(const std::string::value_type **)(a2 + 416), *(_QWORD *)(a2 + 424));
  }
  else
  {
    v5 = *(_OWORD *)(a2 + 416);
    a1[54] = *(_QWORD *)(a2 + 432);
    *(_OWORD *)&v4->__r_.__value_.__l.__data_ = v5;
  }
  return a1;
}

void sub_2168FA4C8(_Unwind_Exception *a1)
{
  void **v1;

  CallInfo::~CallInfo(v1);
  _Unwind_Resume(a1);
}

void std::__function::__alloc_func<EurekaC2KCallFormatter::createMergeReq(CallOperationContext)::$_0,std::allocator<EurekaC2KCallFormatter::createMergeReq(CallOperationContext)::$_0>,void ()(qmi::ResponseBase const&)>::destroy[abi:ne180100](uint64_t a1)
{
  if (*(char *)(a1 + 439) < 0)
    operator delete(*(void **)(a1 + 416));
  CallInfo::~CallInfo((void **)(a1 + 8));
}

uint64_t ___ZZN22EurekaC2KCallFormatter14createMergeReqE20CallOperationContextENK3__0clERKN3qmi12ResponseBaseE_block_invoke(uint64_t result, _BYTE *a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = *a2;
  return result;
}

uint64_t std::stringbuf::str[abi:ne180100]<std::allocator<char>>@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  uint64_t result;
  unint64_t v4;
  const void *v5;
  size_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;

  result = std::stringbuf::view[abi:ne180100](a1);
  if (v4 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v5 = (const void *)result;
  v6 = v4;
  if (v4 >= 0x17)
  {
    v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17)
      v7 = v4 | 7;
    v8 = v7 + 1;
    v9 = operator new(v7 + 1);
    a2[1] = v6;
    a2[2] = v8 | 0x8000000000000000;
    *a2 = v9;
    a2 = v9;
  }
  else
  {
    *((_BYTE *)a2 + 23) = v4;
    if (!v4)
      goto LABEL_9;
  }
  result = (uint64_t)memmove(a2, v5, v6);
LABEL_9:
  *((_BYTE *)a2 + v6) = 0;
  return result;
}

void std::__shared_ptr_pointer<vs::SetVoicePrivacy::Request *,std::shared_ptr<vs::SetVoicePrivacy::Request>::__shared_ptr_default_delete<vs::SetVoicePrivacy::Request,vs::SetVoicePrivacy::Request>,std::allocator<vs::SetVoicePrivacy::Request>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

qmi::MutableMessageBase *std::__shared_ptr_pointer<vs::SetVoicePrivacy::Request *,std::shared_ptr<vs::SetVoicePrivacy::Request>::__shared_ptr_default_delete<vs::SetVoicePrivacy::Request,vs::SetVoicePrivacy::Request>,std::allocator<vs::SetVoicePrivacy::Request>>::__on_zero_shared(uint64_t a1)
{
  qmi::MutableMessageBase *result;

  result = *(qmi::MutableMessageBase **)(a1 + 24);
  if (result)
  {
    qmi::MutableMessageBase::~MutableMessageBase(result);
    JUMPOUT(0x2199FEAC4);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<vs::SetVoicePrivacy::Request *,std::shared_ptr<vs::SetVoicePrivacy::Request>::__shared_ptr_default_delete<vs::SetVoicePrivacy::Request,vs::SetVoicePrivacy::Request>,std::allocator<vs::SetVoicePrivacy::Request>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

qmi::MutableMessageBase *std::unique_ptr<vs::SetVoicePrivacy::Request>::reset[abi:ne180100](qmi::MutableMessageBase **a1)
{
  qmi::MutableMessageBase *result;

  result = *a1;
  *a1 = 0;
  if (result)
  {
    qmi::MutableMessageBase::~MutableMessageBase(result);
    JUMPOUT(0x2199FEAC4);
  }
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<vs::tlv::VoicePrivacyReqRespInfo>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<vs::tlv::VoicePrivacyReqRespInfo>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<vs::tlv::VoicePrivacyReqRespInfo>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<vs::tlv::VoicePrivacyReqRespInfo>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C75D8;
  return result;
}

void std::__function::__func<EurekaC2KCallFormatter::createVoicePrivacyReq(BOOL,subscriber::SimSlot)::$_0,std::allocator<EurekaC2KCallFormatter::createVoicePrivacyReq(BOOL,subscriber::SimSlot)::$_0>,void ()(qmi::ResponseBase const&)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

__n128 std::__function::__func<EurekaC2KCallFormatter::createVoicePrivacyReq(BOOL,subscriber::SimSlot)::$_0,std::allocator<EurekaC2KCallFormatter::createVoicePrivacyReq(BOOL,subscriber::SimSlot)::$_0>,void ()(qmi::ResponseBase const&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_24D5C7610;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<EurekaC2KCallFormatter::createVoicePrivacyReq(BOOL,subscriber::SimSlot)::$_0,std::allocator<EurekaC2KCallFormatter::createVoicePrivacyReq(BOOL,subscriber::SimSlot)::$_0>,void ()(qmi::ResponseBase const&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_24D5C7610;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<EurekaC2KCallFormatter::createVoicePrivacyReq(BOOL,subscriber::SimSlot)::$_0,std::allocator<EurekaC2KCallFormatter::createVoicePrivacyReq(BOOL,subscriber::SimSlot)::$_0>,void ()(qmi::ResponseBase const&)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  NSObject *v4;
  _DWORD v5[2];
  __int16 v6;
  uint64_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 8);
  v3 = *(_DWORD *)(a2 + 4);
  if (v3)
  {
    v4 = *(NSObject **)(v2 + 8);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5[0] = 67109378;
      v5[1] = v3;
      v6 = 2080;
      v7 = qmi::asString();
      _os_log_error_impl(&dword_216897000, v4, OS_LOG_TYPE_ERROR, "Voice Privacy Response: Error in response with code = 0x %u (%s)", (uint8_t *)v5, 0x12u);
    }
  }
  else
  {
    (*(void (**)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)(v2 + 16) + 120))(*(_QWORD *)(v2 + 16), *(unsigned __int8 *)(a1 + 16), *(unsigned int *)(a1 + 20));
  }
}

uint64_t std::__function::__func<EurekaC2KCallFormatter::createVoicePrivacyReq(BOOL,subscriber::SimSlot)::$_0,std::allocator<EurekaC2KCallFormatter::createVoicePrivacyReq(BOOL,subscriber::SimSlot)::$_0>,void ()(qmi::ResponseBase const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<EurekaC2KCallFormatter::createVoicePrivacyReq(BOOL,subscriber::SimSlot)::$_0,std::allocator<EurekaC2KCallFormatter::createVoicePrivacyReq(BOOL,subscriber::SimSlot)::$_0>,void ()(qmi::ResponseBase const&)>::target_type()
{
}

void std::__shared_ptr_pointer<vs::VoiceSendFlash::Request *,std::shared_ptr<vs::VoiceSendFlash::Request>::__shared_ptr_default_delete<vs::VoiceSendFlash::Request,vs::VoiceSendFlash::Request>,std::allocator<vs::VoiceSendFlash::Request>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

qmi::MutableMessageBase *std::__shared_ptr_pointer<vs::VoiceSendFlash::Request *,std::shared_ptr<vs::VoiceSendFlash::Request>::__shared_ptr_default_delete<vs::VoiceSendFlash::Request,vs::VoiceSendFlash::Request>,std::allocator<vs::VoiceSendFlash::Request>>::__on_zero_shared(uint64_t a1)
{
  qmi::MutableMessageBase *result;

  result = *(qmi::MutableMessageBase **)(a1 + 24);
  if (result)
  {
    qmi::MutableMessageBase::~MutableMessageBase(result);
    JUMPOUT(0x2199FEAC4);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<vs::VoiceSendFlash::Request *,std::shared_ptr<vs::VoiceSendFlash::Request>::__shared_ptr_default_delete<vs::VoiceSendFlash::Request,vs::VoiceSendFlash::Request>,std::allocator<vs::VoiceSendFlash::Request>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t qmi::MutableMessageBase::getTLV<vs::tlv::CallIdentifier>(_QWORD *a1, int a2)
{
  const void **v2;
  const void **v3;
  void *v4;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3)
        return qmi::MutableMessageBase::createTLV<vs::tlv::CallIdentifier>(a1, a2);
    }
  }
  if (v2 == v3)
    return qmi::MutableMessageBase::createTLV<vs::tlv::CallIdentifier>(a1, a2);
  if (!v4)
    __cxa_bad_cast();
  return (uint64_t)v4 + 9;
}

uint64_t qmi::MutableMessageBase::createTLV<vs::tlv::CallIdentifier>(_QWORD *a1, char a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v4 = operator new();
  *(_BYTE *)(v4 + 8) = a2;
  *(_BYTE *)(v4 + 9) = 0;
  *(_QWORD *)v4 = &off_24D5C7868;
  v5 = a1[3];
  v6 = (uint64_t *)a1[2];
  if ((unint64_t)v6 >= v5)
  {
    v8 = a1[1];
    v9 = ((uint64_t)v6 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v5 - v8;
    v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1))
      v11 = v9 + 1;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v12);
    else
      v13 = 0;
    v14 = (uint64_t *)&v13[8 * v9];
    v15 = &v13[8 * v12];
    *v14 = v4;
    v7 = v14 + 1;
    v17 = (char *)a1[1];
    v16 = (char *)a1[2];
    if (v16 != v17)
    {
      do
      {
        v18 = *((_QWORD *)v16 - 1);
        v16 -= 8;
        *--v14 = v18;
      }
      while (v16 != v17);
      v16 = (char *)a1[1];
    }
    a1[1] = v14;
    a1[2] = v7;
    a1[3] = v15;
    if (v16)
      operator delete(v16);
  }
  else
  {
    *v6 = v4;
    v7 = v6 + 1;
  }
  a1[2] = v7;
  return v4 + 9;
}

void qmi::MutableMessageBase::TlvWrapper<vs::tlv::CallIdentifier>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<vs::tlv::CallIdentifier>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<vs::tlv::CallIdentifier>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<vs::tlv::CallIdentifier>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5C7868;
  return result;
}

_QWORD *qmi::MutableMessageBase::TlvWrapper<vs::tlv::Payload>::~TlvWrapper(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24D5C7720;
  v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<vs::tlv::Payload>::~TlvWrapper(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24D5C7720;
  v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<vs::tlv::Payload>::getSize(uint64_t a1)
{
  return tlv::size<vs::tlv::CallingNumber>((_QWORD *)(a1 + 16));
}

void *qmi::MutableMessageBase::TlvWrapper<vs::tlv::Payload>::write(uint64_t a1, void **a2)
{
  char v3;
  char *v4;
  uint64_t v5;
  void *result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (char *)*a2;
  v5 = (uint64_t)*a2 + 3;
  *a2 = (void *)v5;
  result = tlv::writeV<vs::tlv::CallingNumber>(a2, a1 + 16);
  v7 = (char *)*a2 - v5;
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<vs::tlv::Payload>::clone(uint64_t a1)
{
  uint64_t v2;

  v2 = operator new();
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)v2 = &off_24D5C7720;
  *(_QWORD *)(v2 + 24) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 16) = 0;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>((_QWORD *)(v2 + 16), *(const void **)(a1 + 16), *(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 24) - *(_QWORD *)(a1 + 16));
  return v2;
}

void sub_2168FAD3C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199FEAC4](v1, 0x1091C40A3A4EB6ALL);
  _Unwind_Resume(a1);
}

_QWORD *std::shared_ptr<vs::EndCall::Request>::shared_ptr[abi:ne180100]<vs::EndCall::Request,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24D5C7758;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_2168FADC0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<vs::EndCall::Request>::reset[abi:ne180100]((qmi::MutableMessageBase **)va, 0);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<vs::EndCall::Request *,std::shared_ptr<vs::EndCall::Request>::__shared_ptr_default_delete<vs::EndCall::Request,vs::EndCall::Request>,std::allocator<vs::EndCall::Request>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

qmi::MutableMessageBase *std::__shared_ptr_pointer<vs::EndCall::Request *,std::shared_ptr<vs::EndCall::Request>::__shared_ptr_default_delete<vs::EndCall::Request,vs::EndCall::Request>,std::allocator<vs::EndCall::Request>>::__on_zero_shared(uint64_t a1)
{
  qmi::MutableMessageBase *result;

  result = *(qmi::MutableMessageBase **)(a1 + 24);
  if (result)
  {
    qmi::MutableMessageBase::~MutableMessageBase(result);
    JUMPOUT(0x2199FEAC4);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<vs::EndCall::Request *,std::shared_ptr<vs::EndCall::Request>::__shared_ptr_default_delete<vs::EndCall::Request,vs::EndCall::Request>,std::allocator<vs::EndCall::Request>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

qmi::MutableMessageBase *std::unique_ptr<vs::EndCall::Request>::reset[abi:ne180100](qmi::MutableMessageBase **a1, qmi::MutableMessageBase *a2)
{
  qmi::MutableMessageBase *result;

  result = *a1;
  *a1 = a2;
  if (result)
  {
    qmi::MutableMessageBase::~MutableMessageBase(result);
    JUMPOUT(0x2199FEAC4);
  }
  return result;
}

void std::__function::__func<EurekaC2KCallFormatter::createEndcallReq(subscriber::SimSlot)::$_0,std::allocator<EurekaC2KCallFormatter::createEndcallReq(subscriber::SimSlot)::$_0>,void ()(qmi::ResponseBase const&)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

__n128 std::__function::__func<EurekaC2KCallFormatter::createEndcallReq(subscriber::SimSlot)::$_0,std::allocator<EurekaC2KCallFormatter::createEndcallReq(subscriber::SimSlot)::$_0>,void ()(qmi::ResponseBase const&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_24D5C77D0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<EurekaC2KCallFormatter::createEndcallReq(subscriber::SimSlot)::$_0,std::allocator<EurekaC2KCallFormatter::createEndcallReq(subscriber::SimSlot)::$_0>,void ()(qmi::ResponseBase const&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_24D5C77D0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<EurekaC2KCallFormatter::createEndcallReq(subscriber::SimSlot)::$_0,std::allocator<EurekaC2KCallFormatter::createEndcallReq(subscriber::SimSlot)::$_0>,void ()(qmi::ResponseBase const&)>::operator()(uint64_t a1, uint64_t a2)
{
  int v2;
  uint64_t v5;
  NSObject *v6;
  int v7;
  uint64_t v8;
  int v9;
  _OWORD v10[5];
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  uint64_t v31;
  uint64_t v32;

  v32 = *MEMORY[0x24BDAC8D0];
  v2 = *(_DWORD *)(a2 + 4);
  if (v2)
  {
    v5 = *(_QWORD *)(a1 + 8);
    v6 = *(NSObject **)(v5 + 8);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      v8 = qmi::asString();
      v9 = *(_DWORD *)(a2 + 4);
      LODWORD(v10[0]) = 136315394;
      *(_QWORD *)((char *)v10 + 4) = v8;
      WORD6(v10[0]) = 1024;
      *(_DWORD *)((char *)v10 + 14) = v9;
      _os_log_error_impl(&dword_216897000, v6, OS_LOG_TYPE_ERROR, "Ending call(s) failed with error %s (%u)", (uint8_t *)v10, 0x12u);
      v2 = *(_DWORD *)(a2 + 4);
    }
    if (v2 == 41)
    {
      v31 = 0;
      v29 = 0u;
      v30 = 0u;
      v27 = 0u;
      v28 = 0u;
      v25 = 0u;
      v26 = 0u;
      v23 = 0u;
      v24 = 0u;
      v21 = 0u;
      v22 = 0u;
      v19 = 0u;
      v20 = 0u;
      v17 = 0u;
      v18 = 0u;
      v15 = 0u;
      v16 = 0u;
      v13 = 0u;
      v14 = 0u;
      v11 = 0u;
      v12 = 0u;
      memset(v10, 0, sizeof(v10));
      CallInfo::CallInfo((CallInfo *)v10);
      v7 = *(_DWORD *)(a1 + 20);
      HIDWORD(v21) = *(_DWORD *)(a1 + 16);
      HIDWORD(v11) = v7;
      (*(void (**)(_QWORD, _OWORD *, _QWORD))(**(_QWORD **)(v5 + 16) + 40))(*(_QWORD *)(v5 + 16), v10, 0);
      CallInfo::~CallInfo((void **)v10);
    }
  }
}

void sub_2168FB070(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  CallInfo::~CallInfo(&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<EurekaC2KCallFormatter::createEndcallReq(subscriber::SimSlot)::$_0,std::allocator<EurekaC2KCallFormatter::createEndcallReq(subscriber::SimSlot)::$_0>,void ()(qmi::ResponseBase const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<EurekaC2KCallFormatter::createEndcallReq(subscriber::SimSlot)::$_0,std::allocator<EurekaC2KCallFormatter::createEndcallReq(subscriber::SimSlot)::$_0>,void ()(qmi::ResponseBase const&)>::target_type()
{
}

void ctu::shared_ptr_map_impl<ctu::indexed_by_any_map_hashing_key>::get<GestaltUtilityInterface>(std::mutex *this@<X0>, _QWORD *a2@<X8>)
{
  unint64_t v4;
  unsigned __int8 *v5;
  uint64_t v6;
  unsigned int v7;
  _QWORD *v8;
  std::__shared_weak_count *v9;
  uint64_t v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;

  v4 = *(_QWORD *)(MEMORY[0x24BDC3CD0] + 8);
  if ((v4 & 0x8000000000000000) != 0)
  {
    v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    v6 = 5381;
    do
    {
      v4 = v6;
      v7 = *v5++;
      v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(this);
  v16 = v4;
  v8 = std::__hash_table<std::__hash_value_type<unsigned long,std::shared_ptr<void>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::shared_ptr<void>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::shared_ptr<void>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::shared_ptr<void>>>>::find<unsigned long>(&this[1].__m_.__sig, &v16);
  if (v8)
  {
    v10 = v8[3];
    v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      p_shared_owners = (unint64_t *)&v9->__shared_owners_;
      do
        v12 = __ldxr(p_shared_owners);
      while (__stxr(v12 + 1, p_shared_owners));
    }
  }
  else
  {
    v10 = 0;
    v9 = 0;
  }
  std::mutex::unlock(this);
  *a2 = v10;
  a2[1] = v9;
  if (v9)
  {
    v13 = (unint64_t *)&v9->__shared_owners_;
    do
      v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
    do
      v15 = __ldaxr(v13);
    while (__stlxr(v15 - 1, v13));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
}

void sub_2168FB1D0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void QMI_STK_CommandDriver::create(_QWORD *a1@<X0>, dispatch_object_t *a2@<X1>, __int128 *a3@<X2>, uint64_t *a4@<X8>)
{
  uint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  __int128 v12;
  dispatch_object_t object;

  v8 = operator new();
  object = *a2;
  *a2 = 0;
  v12 = *a3;
  *(_QWORD *)a3 = 0;
  *((_QWORD *)a3 + 1) = 0;
  QMI_STK_CommandDriver::QMI_STK_CommandDriver(v8, a1, &object, (uint64_t)&v12);
  *a4 = 0;
  a4[1] = 0;
  std::shared_ptr<QMI_STK_CommandDriver>::shared_ptr[abi:ne180100]<QMI_STK_CommandDriver,std::shared_ptr<QMI_STK_CommandDriver> ctu::SharedSynchronizable<QMI_STK_CommandDriver>::make_shared_ptr<QMI_STK_CommandDriver>(QMI_STK_CommandDriver*)::{lambda(QMI_STK_CommandDriver*)#1},void>(a4, v8);
  v9 = (std::__shared_weak_count *)*((_QWORD *)&v12 + 1);
  if (*((_QWORD *)&v12 + 1))
  {
    v10 = (unint64_t *)(*((_QWORD *)&v12 + 1) + 8);
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  if (object)
    dispatch_release(object);
}

void sub_2168FB2D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9;
  NSObject *v10;
  int v11;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  if (v10)
    dispatch_release(v10);
  if (v11)
    MEMORY[0x2199FEAC4](v9, 0xE1C404BA7A847);
  _Unwind_Resume(a1);
}

uint64_t QMI_STK_CommandDriver::QMI_STK_CommandDriver(uint64_t a1, _QWORD *a2, NSObject **a3, uint64_t a4)
{
  _QWORD *v8;
  NSObject *v9;
  capabilities::ct *v10;
  _QWORD *v11;
  uint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t *v22;
  unint64_t v23;
  _QWORD v25[3];
  _QWORD *v26;
  _BYTE v27[24];
  _BYTE *v28;
  _BYTE v29[24];
  _BYTE *v30;
  uint64_t v31;

  v31 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)a1 = MEMORY[0x24BDC45C8] + 16;
  v8 = (_QWORD *)(a1 + 8);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)v29, (const char *)*MEMORY[0x24BDC3E90], "stk.qmi");
  *v8 = 0;
  v8[1] = 0;
  v9 = *a3;
  *(_QWORD *)(a1 + 24) = *a3;
  if (v9)
    dispatch_retain(v9);
  *(_QWORD *)(a1 + 32) = 0;
  ctu::OsLogLogger::OsLogLogger();
  ctu::OsLogLogger::OsLogLogger();
  MEMORY[0x2199FDF6C](v27);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v29);
  v25[0] = &off_24D5C7DD0;
  v26 = v25;
  v10 = (capabilities::ct *)std::__function::__value_func<char const* const ()(subscriber::HardwareSimSlot)>::__value_func[abi:ne180100]((uint64_t)v27, (uint64_t)v25);
  *(_QWORD *)(a1 + 48) = 0;
  if ((capabilities::ct::supportsGemini(v10) & 1) == 0)
  {
    v11 = (_QWORD *)operator new();
    *v11 = &off_24D5C7E80;
    v11[1] = a1;
    v12 = *(_QWORD *)(a1 + 48);
    *(_QWORD *)(a1 + 48) = v11;
    if (!v12)
      goto LABEL_14;
    (*(void (**)(uint64_t))(*(_QWORD *)v12 + 8))(v12);
  }
  if (!*(_QWORD *)(a1 + 48))
  {
    v13 = (_QWORD *)operator new();
    std::__function::__value_func<char const* const ()(subscriber::HardwareSimSlot)>::__value_func[abi:ne180100]((uint64_t)v29, (uint64_t)v27);
    *v13 = &off_24D5C7ED0;
    detail::createOsLogLoggers();
    detail::createUnknownOsLogLogger();
    v14 = v30;
    if (v30 == v29)
    {
      v15 = 4;
      v14 = v29;
    }
    else
    {
      if (!v30)
        goto LABEL_12;
      v15 = 5;
    }
    (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_12:
    v16 = *(_QWORD *)(a1 + 48);
    *(_QWORD *)(a1 + 48) = v13;
    if (v16)
      (*(void (**)(uint64_t))(*(_QWORD *)v16 + 8))(v16);
  }
LABEL_14:
  v17 = v28;
  if (v28 == v27)
  {
    v18 = 4;
    v17 = v27;
  }
  else
  {
    if (!v28)
      goto LABEL_19;
    v18 = 5;
  }
  (*(void (**)(void))(*v17 + 8 * v18))();
LABEL_19:
  v19 = v26;
  if (v26 == v25)
  {
    v20 = 4;
    v19 = v25;
  }
  else
  {
    if (!v26)
      goto LABEL_24;
    v20 = 5;
  }
  (*(void (**)(void))(*v19 + 8 * v20))();
LABEL_24:
  *(_QWORD *)a1 = &off_24D5C78B0;
  *(_QWORD *)(a1 + 56) = *a2;
  v21 = a2[1];
  *(_QWORD *)(a1 + 64) = v21;
  if (v21)
  {
    v22 = (unint64_t *)(v21 + 8);
    do
      v23 = __ldxr(v22);
    while (__stxr(v23 + 1, v22));
  }
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 104) = *(_OWORD *)a4;
  *(_QWORD *)a4 = 0;
  *(_QWORD *)(a4 + 8) = 0;
  return a1;
}

void sub_2168FB5C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, char a14, uint64_t a15, uint64_t a16, char *a17, char a18, uint64_t a19, uint64_t a20,char *a21)
{
  STK_CommandDriver *v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  char *v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  uint64_t v30;
  char *v31;
  uint64_t v32;

  std::__tree<std::__value_type<subscriber::HardwareSimSlot,ctu::OsLogLogger>,std::__map_value_compare<subscriber::HardwareSimSlot,std::__value_type<subscriber::HardwareSimSlot,ctu::OsLogLogger>,std::less<subscriber::HardwareSimSlot>,true>,std::allocator<std::__value_type<subscriber::HardwareSimSlot,ctu::OsLogLogger>>>::destroy(*(_QWORD **)(v24 + 16));
  v26 = a21;
  if (a21 == &a18)
  {
    v27 = 4;
    v26 = &a18;
  }
  else
  {
    if (!a21)
      goto LABEL_6;
    v27 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v26 + 8 * v27))();
LABEL_6:
  MEMORY[0x2199FEAC4](v24, 0x10A1C40FF1576FELL);
  v28 = *((_QWORD *)v21 + 6);
  *((_QWORD *)v21 + 6) = 0;
  if (v28)
    (*(void (**)(uint64_t))(*(_QWORD *)v28 + 8))(v28);
  v29 = a17;
  if (a17 == &a14)
  {
    v30 = 4;
    v29 = &a14;
  }
  else
  {
    if (!a17)
      goto LABEL_13;
    v30 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v29 + 8 * v30))();
LABEL_13:
  v31 = a13;
  if (a13 == &a10)
  {
    v32 = 4;
    v31 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_18;
    v32 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v31 + 8 * v32))();
LABEL_18:
  MEMORY[0x2199FDF6C](v23);
  ctu::SharedSynchronizable<QMIDataSystemDeterminationManager>::~SharedSynchronizable(v22);
  STK_CommandDriver::~STK_CommandDriver(v21);
  _Unwind_Resume(a1);
}

const char *`anonymous namespace'::sGetLogDomainForSlot(int a1)
{
  if ((a1 - 1) > 2)
    return "stk.qmi.?";
  else
    return off_24D5C9740[a1 - 1];
}

{
  if ((a1 - 1) > 2)
    return "subscr.driver.qmi.?";
  else
    return off_24D5DC360[a1 - 1];
}

void QMI_STK_CommandDriver::start(QMI_STK_CommandDriver *this)
{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  _QWORD *v6;
  NSObject *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v2 = (std::__shared_weak_count *)*((_QWORD *)this + 2);
  if (!v2 || (v3 = *((_QWORD *)this + 1), (v4 = std::__shared_weak_count::lock(v2)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v5 = v4;
  v6 = (_QWORD *)operator new();
  *v6 = this;
  v7 = *((_QWORD *)this + 3);
  p_shared_owners = (unint64_t *)&v5->__shared_owners_;
  do
    v9 = __ldxr(p_shared_owners);
  while (__stxr(v9 + 1, p_shared_owners));
  v10 = (_QWORD *)operator new();
  *v10 = v6;
  v10[1] = v3;
  v10[2] = v5;
  v12 = 0;
  v13 = 0;
  dispatch_async_f(v7, v10, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<QMI_STK_CommandDriver>::execute_wrapped<QMI_STK_CommandDriver::start(void)::$_0>(QMI_STK_CommandDriver::start(void)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMI_STK_CommandDriver::start(void)::$_0,dispatch_queue_s *::default_delete<QMI_STK_CommandDriver::start(void)::$_0>>)::{lambda(void *)#1}::__invoke);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v12);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v13);
  do
    v11 = __ldaxr(p_shared_owners);
  while (__stlxr(v11 - 1, p_shared_owners));
  if (!v11)
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
}

void QMI_STK_CommandDriver::bootstrap(_QWORD *a1, dispatch_object_t *a2)
{
  NSObject *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  _QWORD *v8;
  unint64_t *p_shared_owners;
  NSObject *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
  }
  v4 = (std::__shared_weak_count *)a1[2];
  if (!v4 || (v5 = a1[1], (v6 = std::__shared_weak_count::lock(v4)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v7 = v6;
  v8 = (_QWORD *)operator new();
  *v8 = a1;
  v8[1] = v3;
  p_shared_owners = (unint64_t *)&v7->__shared_owners_;
  v10 = a1[3];
  do
    v11 = __ldxr(p_shared_owners);
  while (__stxr(v11 + 1, p_shared_owners));
  v12 = (_QWORD *)operator new();
  *v12 = v8;
  v12[1] = v5;
  v12[2] = v7;
  v14 = 0;
  v15 = 0;
  dispatch_async_f(v10, v12, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<QMI_STK_CommandDriver>::execute_wrapped<QMI_STK_CommandDriver::bootstrap(dispatch::group_session)::$_0>(QMI_STK_CommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMI_STK_CommandDriver::bootstrap(dispatch::group_session)::$_0,dispatch_queue_s *::default_delete<QMI_STK_CommandDriver::bootstrap(dispatch::group_session)::$_0>>)::{lambda(void *)#1}::__invoke);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v14);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v15);
  do
    v13 = __ldaxr(p_shared_owners);
  while (__stlxr(v13 - 1, p_shared_owners));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
}

void QMI_STK_CommandDriver::shutdown(_QWORD *a1, dispatch_object_t *a2)
{
  NSObject *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  _QWORD *v8;
  unint64_t *p_shared_owners;
  NSObject *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
  }
  v4 = (std::__shared_weak_count *)a1[2];
  if (!v4 || (v5 = a1[1], (v6 = std::__shared_weak_count::lock(v4)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v7 = v6;
  v8 = (_QWORD *)operator new();
  *v8 = a1;
  v8[1] = v3;
  p_shared_owners = (unint64_t *)&v7->__shared_owners_;
  v10 = a1[3];
  do
    v11 = __ldxr(p_shared_owners);
  while (__stxr(v11 + 1, p_shared_owners));
  v12 = (_QWORD *)operator new();
  *v12 = v8;
  v12[1] = v5;
  v12[2] = v7;
  v14 = 0;
  v15 = 0;
  dispatch_async_f(v10, v12, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<QMI_STK_CommandDriver>::execute_wrapped<QMI_STK_CommandDriver::shutdown(dispatch::group_session)::$_0>(QMI_STK_CommandDriver::shutdown(dispatch::group_session)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMI_STK_CommandDriver::shutdown(dispatch::group_session)::$_0,dispatch_queue_s *::default_delete<QMI_STK_CommandDriver::shutdown(dispatch::group_session)::$_0>>)::{lambda(void *)#1}::__invoke);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v14);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v15);
  do
    v13 = __ldaxr(p_shared_owners);
  while (__stlxr(v13 - 1, p_shared_owners));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
}

void `anonymous namespace'::sMakeSetEventReportRegisterRequest(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  char **v5;
  const void **v6;
  const void **v7;
  const void **v8;
  char *v9;
  _DWORD *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  char *v18;
  uint64_t *v19;
  char *v20;
  char *v21;
  char *v22;
  uint64_t v23;
  char *v24;
  _BYTE *v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t *v28;
  _QWORD *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  char *v34;
  uint64_t *v35;
  char *v36;
  char *v37;
  uint64_t v38;
  int v39;
  uint64_t v40;

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  v4 = qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)a1);
  v5 = (char **)(v4 + 8);
  v6 = *(const void ***)(v4 + 8);
  v7 = *(const void ***)(v4 + 16);
  v8 = v6;
  if (v6 != v7)
  {
    v8 = *(const void ***)(v4 + 8);
    while (*((_BYTE *)*v8 + 8) != 17)
    {
      if (++v8 == v7)
        goto LABEL_9;
    }
  }
  if (v8 == v7)
  {
LABEL_9:
    v11 = operator new();
    *(_BYTE *)(v11 + 8) = 17;
    *(_DWORD *)(v11 + 12) = 0;
    v10 = (_DWORD *)(v11 + 12);
    *(_QWORD *)v11 = &off_24D5C7CE8;
    v12 = *(_QWORD *)(a1 + 24);
    v13 = *(uint64_t **)(a1 + 16);
    if ((unint64_t)v13 >= v12)
    {
      v14 = ((char *)v13 - *v5) >> 3;
      if ((unint64_t)(v14 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v15 = v12 - (_QWORD)*v5;
      v16 = v15 >> 2;
      if (v15 >> 2 <= (unint64_t)(v14 + 1))
        v16 = v14 + 1;
      if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF8)
        v17 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v17 = v16;
      if (v17)
        v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>(a1 + 24, v17);
      else
        v18 = 0;
      v19 = (uint64_t *)&v18[8 * v14];
      v20 = &v18[8 * v17];
      *v19 = v11;
      v7 = (const void **)(v19 + 1);
      v22 = *(char **)(a1 + 8);
      v21 = *(char **)(a1 + 16);
      if (v21 != v22)
      {
        do
        {
          v23 = *((_QWORD *)v21 - 1);
          v21 -= 8;
          *--v19 = v23;
        }
        while (v21 != v22);
        v21 = *v5;
      }
      *(_QWORD *)(a1 + 8) = v19;
      *(_QWORD *)(a1 + 16) = v7;
      *(_QWORD *)(a1 + 24) = v20;
      if (v21)
        operator delete(v21);
    }
    else
    {
      *v13 = v11;
      v7 = (const void **)(v13 + 1);
    }
    *(_QWORD *)(a1 + 16) = v7;
    v6 = *(const void ***)(a1 + 8);
  }
  else
  {
    if (!v9)
      __cxa_bad_cast();
    v10 = v9 + 12;
  }
  *v10 = 2093055;
  while (v6 != v7)
  {
    if (*((_BYTE *)*v6 + 8) == 18)
    {
      if (v6 != v7)
      {
        if (!v24)
          __cxa_bad_cast();
        v25 = v24 + 9;
        goto LABEL_50;
      }
      break;
    }
    ++v6;
  }
  v26 = operator new();
  *(_WORD *)(v26 + 8) = 18;
  *(_QWORD *)v26 = &off_24D5C7D38;
  v24 = (char *)(a1 + 24);
  v27 = *(_QWORD *)(a1 + 24);
  v28 = *(uint64_t **)(a1 + 16);
  if ((unint64_t)v28 >= v27)
  {
    v30 = ((char *)v28 - *v5) >> 3;
    if ((unint64_t)(v30 + 1) >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v31 = v27 - (_QWORD)*v5;
    v32 = v31 >> 2;
    if (v31 >> 2 <= (unint64_t)(v30 + 1))
      v32 = v30 + 1;
    if ((unint64_t)v31 >= 0x7FFFFFFFFFFFFFF8)
      v33 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v33 = v32;
    if (v33)
      v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)v24, v33);
    else
      v34 = 0;
    v35 = (uint64_t *)&v34[8 * v30];
    v36 = &v34[8 * v33];
    *v35 = v26;
    v29 = v35 + 1;
    v37 = *(char **)(a1 + 8);
    v24 = *(char **)(a1 + 16);
    if (v24 != v37)
    {
      do
      {
        v38 = *((_QWORD *)v24 - 1);
        v24 -= 8;
        *--v35 = v38;
      }
      while (v24 != v37);
      v24 = *v5;
    }
    *(_QWORD *)(a1 + 8) = v35;
    *(_QWORD *)(a1 + 16) = v29;
    *(_QWORD *)(a1 + 24) = v36;
    if (v24)
      operator delete(v24);
  }
  else
  {
    *v28 = v26;
    v29 = v28 + 1;
  }
  v25 = (_BYTE *)(v26 + 9);
  *(_QWORD *)(a1 + 16) = v29;
LABEL_50:
  if ((a2 & 0xFF00000000) != 0)
  {
    v39 = 1 << ((_DWORD)a2 == 2);
    if ((_DWORD)a2 == 3)
      LOBYTE(v39) = 4;
  }
  else
  {
    v40 = capabilities::ct::supportsGemini((capabilities::ct *)v24);
    if ((v40 & 1) != 0 || (v40 = capabilities::ct::supportsDynamicSID((capabilities::ct *)v40), (_DWORD)v40))
    {
      if (capabilities::ct::supportsHydra((capabilities::ct *)v40))
        LOBYTE(v39) = 7;
      else
        LOBYTE(v39) = 3;
    }
    else
    {
      LOBYTE(v39) = 1;
    }
  }
  *v25 = v39;
}

void sub_2168FBDA8(_Unwind_Exception *a1)
{
  qmi::MutableMessageBase *v1;

  qmi::MutableMessageBase::~MutableMessageBase(v1);
  _Unwind_Resume(a1);
}

void ___ZN21QMI_STK_CommandDriver19setEventReport_syncEv_block_invoke(uint64_t a1, uint64_t a2)
{
  int v2;
  NSObject *v3;
  _BOOL4 v4;
  const char *v5;
  NSObject *v6;
  uint32_t v7;
  _DWORD v8[2];
  __int16 v9;
  uint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v2 = *(_DWORD *)(a2 + 4);
  v3 = *(NSObject **)(*(_QWORD *)(a1 + 32) + 40);
  v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (!v4)
      return;
    v8[0] = 67109378;
    v8[1] = v2;
    v9 = 2080;
    v10 = qmi::asString();
    v5 = "#I Error received in Register for Indications with code %d - %s";
    v6 = v3;
    v7 = 18;
  }
  else
  {
    if (!v4)
      return;
    LOWORD(v8[0]) = 0;
    v5 = "#I Successfully registered for Set Event Report Indications";
    v6 = v3;
    v7 = 2;
  }
  _os_log_impl(&dword_216897000, v6, OS_LOG_TYPE_DEFAULT, v5, (uint8_t *)v8, v7);
}

void QMI_STK_CommandDriver::setFullFunctionEventReport_sync(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5)
{
  const void **v10;
  char *v11;
  int *v12;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  char *v21;
  uint64_t *v22;
  char *v23;
  char *v24;
  char *v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  _QWORD *v29;
  void *v30;
  uint64_t v31;
  uint64_t v32;
  void *aBlock;
  void *__p[2];
  __int128 v35;
  uint8_t buf[8];
  uint64_t v37;
  void (*v38)(uint64_t, QMIServiceMsg *);
  void *v39;
  _QWORD *v40;
  _QWORD v41[5];
  _BYTE v42[24];
  _BYTE *v43;
  uint64_t v44;
  uint64_t v45;

  v45 = *MEMORY[0x24BDAC8D0];
  if (*(_QWORD *)(a1 + 88))
  {
    *(_OWORD *)__p = 0u;
    v35 = 0u;
    v10 = (const void **)__p[1];
    if (__p[1] != (void *)v35)
    {
      while (*((_BYTE *)*v10 + 8) != 19)
      {
        if (++v10 == (const void **)v35)
          goto LABEL_12;
      }
    }
    if (v10 == (const void **)v35)
    {
LABEL_12:
      v14 = operator new();
      v15 = v14;
      *(_BYTE *)(v14 + 8) = 19;
      *(_QWORD *)v14 = &off_24D5C7FF8;
      *(_DWORD *)(v14 + 12) = 0;
      v12 = (int *)(v14 + 12);
      v16 = v35;
      if ((unint64_t)v35 >= *((_QWORD *)&v35 + 1))
      {
        v18 = (uint64_t)(v35 - (unint64_t)__p[1]) >> 3;
        if ((unint64_t)(v18 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v19 = (uint64_t)(*((_QWORD *)&v35 + 1) - (unint64_t)__p[1]) >> 2;
        if (v19 <= v18 + 1)
          v19 = v18 + 1;
        if (*((_QWORD *)&v35 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v20 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v20 = v19;
        if (v20)
          v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v35 + 8, v20);
        else
          v21 = 0;
        v22 = (uint64_t *)&v21[8 * v18];
        v23 = &v21[8 * v20];
        *v22 = v15;
        v17 = v22 + 1;
        v25 = (char *)__p[1];
        v24 = (char *)v35;
        if ((void *)v35 != __p[1])
        {
          do
          {
            v26 = *((_QWORD *)v24 - 1);
            v24 -= 8;
            *--v22 = v26;
          }
          while (v24 != v25);
          v24 = (char *)__p[1];
        }
        __p[1] = v22;
        *(_QWORD *)&v35 = v17;
        *((_QWORD *)&v35 + 1) = v23;
        if (v24)
          operator delete(v24);
      }
      else
      {
        *(_QWORD *)v35 = v14;
        v17 = (_QWORD *)(v16 + 8);
      }
      *(_QWORD *)&v35 = v17;
    }
    else
    {
      if (!v11)
        __cxa_bad_cast();
      v12 = (int *)(v11 + 12);
    }
    if (a3)
      v27 = 2;
    else
      v27 = 0;
    *v12 = v27 | a4;
    v32 = QMIServiceMsg::create();
    v28 = MEMORY[0x24BDAC760];
    v41[0] = MEMORY[0x24BDAC760];
    v41[1] = 1174405120;
    v41[2] = ___ZN21QMI_STK_CommandDriver31setFullFunctionEventReport_syncE14STKSimSlotInfobbNSt3__18functionIFvbbEEE_block_invoke_2;
    v41[3] = &__block_descriptor_tmp_5_0;
    v41[4] = a1;
    v44 = a2;
    v29 = v42;
    std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100]((uint64_t)v42, a5);
    *(_QWORD *)buf = v28;
    v37 = 0x40000000;
    v38 = ___ZNO3qmi6Client9SendProxy8callbackIRKN3cat22SetEventReportRegister8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
    v39 = &unk_24D5C8028;
    v40 = v41;
    v30 = _Block_copy(buf);
    aBlock = v30;
    if (v32)
    {
      qmi::Client::send();
      v30 = aBlock;
    }
    if (v30)
      _Block_release(v30);
    if (v43 == v42)
    {
      v31 = 4;
    }
    else
    {
      if (!v43)
      {
LABEL_41:
        qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
        return;
      }
      v31 = 5;
      v29 = v43;
    }
    (*(void (**)(_QWORD *))(*v29 + 8 * v31))(v29);
    goto LABEL_41;
  }
  v13 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_216897000, v13, OS_LOG_TYPE_DEFAULT, "#I QMI Client Invalid while registering for SetEventReport Indication", buf, 2u);
  }
  std::function<void ()(BOOL,BOOL)>::operator()(a5, 0, 0);
}

void sub_2168FC1EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,_QWORD *a32)
{
  _QWORD *v32;
  uint64_t v34;

  if (a32 == v32)
  {
    v34 = 4;
  }
  else
  {
    if (!a32)
      goto LABEL_6;
    v34 = 5;
    v32 = a32;
  }
  (*(void (**)(_QWORD *))(*v32 + 8 * v34))(v32);
LABEL_6:
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)&a10);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a15);
  _Unwind_Resume(a1);
}

uint64_t std::function<void ()(BOOL,BOOL)>::operator()(uint64_t a1, char a2, char a3)
{
  uint64_t v3;
  char v5;
  char v6;

  v6 = a2;
  v5 = a3;
  v3 = *(_QWORD *)(a1 + 24);
  if (!v3)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, char *, char *))(*(_QWORD *)v3 + 48))(v3, &v6, &v5);
}

uint64_t ___ZN21QMI_STK_CommandDriver31setFullFunctionEventReport_syncE14STKSimSlotInfobbNSt3__18functionIFvbbEEE_block_invoke_2(uint64_t a1, qmi::MessageBase *a2)
{
  os_log_t *v4;
  int v5;
  NSObject *v6;
  _BOOL4 v7;
  uint64_t v9;
  char v10;
  char v11;
  char v12;
  uint64_t TlvValue;
  _QWORD v14[3];

  v14[2] = *MEMORY[0x24BDAC8D0];
  v4 = (os_log_t *)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 32) + 48) + 16))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 48), *(unsigned int *)(a1 + 72));
  v5 = *((_DWORD *)a2 + 1);
  v6 = *v4;
  v7 = os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT);
  if (v5)
  {
    if (v7)
    {
      LODWORD(TlvValue) = 67109378;
      HIDWORD(TlvValue) = v5;
      LOWORD(v14[0]) = 2080;
      *(_QWORD *)((char *)v14 + 2) = qmi::asString();
      _os_log_impl(&dword_216897000, v6, OS_LOG_TYPE_DEFAULT, "#I Error received in Register for Indications with code %d - %s", (uint8_t *)&TlvValue, 0x12u);
    }
    return std::function<void ()(BOOL,BOOL)>::operator()(a1 + 40, 0, 0);
  }
  else
  {
    if (v7)
    {
      LOWORD(TlvValue) = 0;
      _os_log_impl(&dword_216897000, v6, OS_LOG_TYPE_DEFAULT, "#I Successfully registered for Full Function Set Event Report Indications", (uint8_t *)&TlvValue, 2u);
    }
    TlvValue = qmi::MessageBase::findTlvValue(a2);
    v14[0] = v9;
    if (TlvValue
      && (v10 = tlv::parseV<cat::tlv::FullFuncEventReportErrorMask>((unint64_t *)&TlvValue, v9), TlvValue))
    {
      v11 = (v10 & 2) == 0;
      v12 = (v10 & 1) == 0;
    }
    else
    {
      v11 = 1;
      v12 = 1;
    }
    return std::function<void ()(BOOL,BOOL)>::operator()(a1 + 40, v11, v12);
  }
}

uint64_t __copy_helper_block_e8_40c28_ZTSNSt3__18functionIFvbbEEE(uint64_t a1, uint64_t a2)
{
  return std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100](a1 + 40, a2 + 40);
}

_QWORD *__destroy_helper_block_e8_40c28_ZTSNSt3__18functionIFvbbEEE(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *result;
  uint64_t v3;

  v1 = (_QWORD *)(a1 + 40);
  result = *(_QWORD **)(a1 + 64);
  if (result == v1)
  {
    v3 = 4;
    result = v1;
  }
  else
  {
    if (!result)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

uint64_t QMI_STK_CommandDriver::handleSetupCallUserConfirmation_ind(uint64_t a1, uint64_t a2, qmi::MessageBase *a3)
{
  void *v6;
  void *v7;
  int v8;
  int v9;
  uint64_t TlvValue;
  int v11;
  uint64_t v12;
  int v13;
  unint64_t v14;
  int v15;
  os_log_t *v16;
  int v17;
  char v18;
  NSObject *v19;
  uint64_t v20;
  uint64_t v21;
  std::string v23;
  uint64_t v24;
  __int128 v25;
  void *__p[2];
  uint64_t v27;
  uint64_t v28;
  void *v29[2];
  void *v30[4];
  __int128 v31;
  __int128 v32;
  void *v33[2];
  __int128 v34;
  unint64_t v35;
  uint8_t buf[16];
  uint64_t v37;
  void *v38;
  void **v39;
  void *v40;
  void *v41[2];
  __int128 v42;
  void *v43[2];
  __int128 v44;
  void *v45[2];
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  uint64_t v55;
  uint64_t v56;

  v56 = *MEMORY[0x24BDAC8D0];
  v6 = (void *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 48) + 16))(*(_QWORD *)(a1 + 48));
  v32 = 0u;
  v25 = 0u;
  v28 = -1;
  *(_OWORD *)v29 = 0u;
  memset(v30, 0, sizeof(v30));
  v31 = 0u;
  *(_QWORD *)&v32 = 0;
  DWORD2(v32) = -1;
  v24 = MEMORY[0x24BDC4610] + 16;
  getAddress<cat::SetupCall::Indication>((CSIPhoneNumber *)v41, (uint64_t)v6, a3);
  CSIPhoneNumber::getFullNumber((CSIPhoneNumber *)v41);
  *(_OWORD *)__p = *(_OWORD *)buf;
  v27 = v37;
  HIBYTE(v37) = 0;
  buf[0] = 0;
  if (SHIBYTE(v47) < 0)
    operator delete(*((void **)&v46 + 1));
  if (SBYTE7(v46) < 0)
    operator delete(v45[0]);
  if (SBYTE7(v44) < 0)
    operator delete(v43[0]);
  if (SHIBYTE(v42) < 0)
    operator delete(v41[1]);
  *(_QWORD *)buf = 0;
  *(_QWORD *)&buf[8] = buf;
  v37 = 0x2000000000;
  LODWORD(v38) = -1;
  v7 = (void *)MEMORY[0x24BDAC760];
  v41[0] = (void *)MEMORY[0x24BDAC760];
  v41[1] = (void *)0x40000000;
  *(_QWORD *)&v42 = ___Z23getCallSetupRequirementIN3cat9SetupCall10IndicationEE20CallSetupRequirementPKN3ctu11OsLogLoggerERKT__block_invoke;
  *((_QWORD *)&v42 + 1) = &unk_24D5C8A28;
  v43[0] = buf;
  v43[1] = v6;
  v33[0] = v41;
  qmi::MessageBase::applyTlv<cat::tlv::CallSetupRequirement,void({block_pointer}&)(cat::tlv::CallSetupRequirement const&)>(a3, (uint64_t)v33);
  v8 = *(_DWORD *)(*(_QWORD *)&buf[8] + 24);
  _Block_object_dispose(buf, 8);
  LODWORD(v28) = v8;
  *(_QWORD *)buf = 0;
  *(_QWORD *)&buf[8] = buf;
  v37 = 0x2000000000;
  LODWORD(v38) = -1;
  v41[0] = v7;
  v41[1] = (void *)0x40000000;
  *(_QWORD *)&v42 = ___Z20getRedialRequirementIN3cat9SetupCall10IndicationEE17RedialRequirementPKN3ctu11OsLogLoggerERKT__block_invoke;
  *((_QWORD *)&v42 + 1) = &unk_24D5C8A50;
  v43[0] = buf;
  v43[1] = v6;
  v33[0] = v41;
  qmi::MessageBase::applyTlv<cat::tlv::Redial,void({block_pointer}&)(cat::tlv::Redial const&)>(a3, v33);
  v9 = *(_DWORD *)(*(_QWORD *)&buf[8] + 24);
  _Block_object_dispose(buf, 8);
  HIDWORD(v28) = v9;
  getSubaddress<cat::SetupCall::Indication>((std::string *)v41, (uint64_t)v6, a3);
  if (SHIBYTE(v30[0]) < 0)
    operator delete(v29[0]);
  *(_OWORD *)v29 = *(_OWORD *)v41;
  v30[0] = (void *)v42;
  v41[0] = 0;
  v41[1] = v41;
  *(_QWORD *)&v42 = 0x4002000000;
  *((_QWORD *)&v42 + 1) = __Block_byref_object_copy_;
  v43[0] = __Block_byref_object_dispose_;
  v44 = 0uLL;
  v43[1] = 0;
  *(_QWORD *)buf = v7;
  *(_QWORD *)&buf[8] = 0x40000000;
  v37 = (uint64_t)___Z24getUserConfirmationAlphaIN3cat9SetupCall10IndicationEENSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEPKN3ctu11OsLogLoggerERKT__block_invoke;
  v38 = &unk_24D5C8AA0;
  v39 = v41;
  v40 = v6;
  TlvValue = qmi::MessageBase::findTlvValue(a3);
  v12 = TlvValue;
  if (TlvValue)
  {
    v13 = v11;
    v35 = TlvValue;
    *(_OWORD *)v33 = 0u;
    v34 = 0u;
    tlv::parseV<cat::tlv::UserConfirmationAlpha>(&v35, v11, v33);
    v14 = v35;
    if (v35)
      ___Z24getUserConfirmationAlphaIN3cat9SetupCall10IndicationEENSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEPKN3ctu11OsLogLoggerERKT__block_invoke((uint64_t)buf, (unsigned __int8 *)v33);
    if (SHIBYTE(v34) < 0)
    {
      operator delete(v33[1]);
      if (v14)
        goto LABEL_19;
    }
    else if (v14)
    {
      goto LABEL_19;
    }
    ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a3, 64, v12, v13);
  }
LABEL_19:
  if (*((char *)v41[1] + 63) < 0)
    std::string::__init_copy_ctor_external(&v23, *((const std::string::value_type **)v41[1] + 5), *((_QWORD *)v41[1] + 6));
  else
    v23 = *(std::string *)((char *)v41[1] + 40);
  _Block_object_dispose(v41, 8);
  if (SHIBYTE(v44) < 0)
    operator delete(v43[1]);
  if (SHIBYTE(v30[3]) < 0)
    operator delete(v30[1]);
  *(std::string *)&v30[1] = v23;
  getSetupCallDisplayAlpha<cat::SetupCall::Indication>((std::string *)v41, (uint64_t)v6, a3);
  if (SBYTE7(v32) < 0)
    operator delete((void *)v31);
  v31 = *(_OWORD *)v41;
  *(_QWORD *)&v32 = v42;
  *(_QWORD *)buf = 0;
  *(_QWORD *)&buf[8] = buf;
  v37 = 0x2000000000;
  LODWORD(v38) = -1;
  v41[0] = v7;
  v41[1] = (void *)0x40000000;
  *(_QWORD *)&v42 = ___Z15getResponseTypeIN3cat9SetupCall10IndicationEE12ResponseTypePKN3ctu11OsLogLoggerERKT__block_invoke;
  *((_QWORD *)&v42 + 1) = &unk_24D5C8AF0;
  v43[0] = buf;
  v43[1] = v6;
  v33[0] = v41;
  qmi::MessageBase::applyTlv<cat::tlv::ResponseType,void({block_pointer}&)(cat::tlv::ResponseType const&)>(a3, (uint64_t)v33);
  v15 = *(_DWORD *)(*(_QWORD *)&buf[8] + 24);
  _Block_object_dispose(buf, 8);
  DWORD2(v32) = v15;
  if (!v15)
  {
    DWORD2(v32) = 1;
    BYTE12(v32) = 1;
  }
  v16 = (os_log_t *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 48) + 16))(*(_QWORD *)(a1 + 48), a2);
  *(_QWORD *)buf = 0;
  *(_QWORD *)&buf[8] = buf;
  v37 = 0x2000000000;
  LODWORD(v38) = 0;
  v41[0] = v7;
  v41[1] = (void *)0x40000000;
  *(_QWORD *)&v42 = ___Z11getUIMRefIdIN3cat9SetupCall10IndicationEEjPKN3ctu11OsLogLoggerERKT__block_invoke;
  *((_QWORD *)&v42 + 1) = &unk_24D5C8B18;
  v43[0] = buf;
  v43[1] = v16;
  v33[0] = v41;
  qmi::MessageBase::applyTlv<cat::tlv::DecodedHeaderId,void({block_pointer}&)(cat::tlv::DecodedHeaderId const&)>(a3, (uint64_t)v33);
  v17 = *(_DWORD *)(*(_QWORD *)&buf[8] + 24);
  _Block_object_dispose(buf, 8);
  DWORD1(v25) = v17;
  *(_QWORD *)buf = 0;
  *(_QWORD *)&buf[8] = buf;
  v37 = 0x2000000000;
  LOBYTE(v38) = 0;
  v41[0] = v7;
  v41[1] = (void *)0x40000000;
  *(_QWORD *)&v42 = ___Z14getBBSessionIdIN3cat9SetupCall10IndicationEEhPKN3ctu11OsLogLoggerERKT__block_invoke;
  *((_QWORD *)&v42 + 1) = &unk_24D5C8B40;
  v43[0] = buf;
  v43[1] = v16;
  v33[0] = v41;
  qmi::MessageBase::applyTlv<cat::tlv::DecodedHeaderId,void({block_pointer}&)(cat::tlv::DecodedHeaderId const&)>(a3, (uint64_t)v33);
  v18 = *(_BYTE *)(*(_QWORD *)&buf[8] + 24);
  _Block_object_dispose(buf, 8);
  BYTE8(v25) = v18;
  v55 = 0;
  v53 = 0u;
  v54 = 0u;
  v51 = 0u;
  v52 = 0u;
  v49 = 0u;
  v50 = 0u;
  v47 = 0u;
  v48 = 0u;
  *(_OWORD *)v45 = 0u;
  v46 = 0u;
  *(_OWORD *)v43 = 0u;
  v44 = 0u;
  *(_OWORD *)v41 = 0u;
  v42 = 0u;
  SetupCall::SetupCall((uint64_t)&v41[1], (uint64_t)&v24);
  v41[1] = (void *)(MEMORY[0x24BDC4610] + 16);
  LODWORD(v41[0]) = 8;
  v19 = *v16;
  if (os_log_type_enabled(*v16, OS_LOG_TYPE_DEFAULT))
  {
    v20 = asString();
    *(_DWORD *)buf = 136315138;
    *(_QWORD *)&buf[4] = v20;
    _os_log_impl(&dword_216897000, v19, OS_LOG_TYPE_DEFAULT, "#I Sending SIM event with Proactive Command %s", buf, 0xCu);
  }
  v21 = *(_QWORD *)(a1 + 104);
  _ZN5boost7variantINS_6detail7variant13over_sequenceINS_3mpl6l_itemIN4mpl_5long_ILl30EEE4NoneNS5_INS7_ILl29EEE11DisplayTextNS5_INS7_ILl28EEE8GetInkeyNS5_INS7_ILl27EEE8GetInputNS5_INS7_ILl26EEE8PlayToneNS5_INS7_ILl25EEE16SendShortMessageNS5_INS7_ILl24EEE6SendSSNS5_INS7_ILl23EEE8SendUSSDNS5_INS7_ILl22EEE25SetupCallUserConfirmationNS5_INS7_ILl21EEE21SetupCallAlphaDisplayNS5_INS7_ILl20EEE9SetupMenuNS5_INS7_ILl19EEE10SelectItemNS5_INS7_ILl18EEE13SetupIdleTextNS5_INS7_ILl17EEE24ProvideLocalInfoLanguageNS5_INS7_ILl16EEE8SendDTMFNS5_INS7_ILl15EEE20LanguageNotificationNS5_INS7_ILl14EEE22SetupEventUserActivityNS5_INS7_ILl13EEE26SetupEventIdleScreenNotifyNS5_INS7_ILl12EEE30SetupEventLanguageSelectNotifyNS5_INS7_ILl11EEE22SetupEventIMSRegNotifyNS5_INS7_ILl10EEE11OpenChannelNS5_INS7_ILl9EEE12CloseChannelNS5_INS7_ILl8EEE8SendDataNS5_INS7_ILl7EEE11ReceiveDataNS5_INS7_ILl6EEE12RefreshAlphaNS5_INS7_ILl5EEE4fillILi26EENS5_INS7_ILl4EEES1N_ILi27EENS5_INS7_ILl3EEES1N_ILi28EENS5_INS7_ILl2EEES1N_ILi29EENS5_INS7_ILl1EEES1N_ILi30EENS4_5l_endEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEJEEC2ERKS2T_((uint64_t)buf, (uint64_t)v41);
  (*(void (**)(uint64_t, _QWORD, uint8_t *))(*(_QWORD *)v21 + 24))(v21, a2, buf);
  _ZN5boost7variantINS_6detail7variant13over_sequenceINS_3mpl6l_itemIN4mpl_5long_ILl30EEE4NoneNS5_INS7_ILl29EEE11DisplayTextNS5_INS7_ILl28EEE8GetInkeyNS5_INS7_ILl27EEE8GetInputNS5_INS7_ILl26EEE8PlayToneNS5_INS7_ILl25EEE16SendShortMessageNS5_INS7_ILl24EEE6SendSSNS5_INS7_ILl23EEE8SendUSSDNS5_INS7_ILl22EEE25SetupCallUserConfirmationNS5_INS7_ILl21EEE21SetupCallAlphaDisplayNS5_INS7_ILl20EEE9SetupMenuNS5_INS7_ILl19EEE10SelectItemNS5_INS7_ILl18EEE13SetupIdleTextNS5_INS7_ILl17EEE24ProvideLocalInfoLanguageNS5_INS7_ILl16EEE8SendDTMFNS5_INS7_ILl15EEE20LanguageNotificationNS5_INS7_ILl14EEE22SetupEventUserActivityNS5_INS7_ILl13EEE26SetupEventIdleScreenNotifyNS5_INS7_ILl12EEE30SetupEventLanguageSelectNotifyNS5_INS7_ILl11EEE22SetupEventIMSRegNotifyNS5_INS7_ILl10EEE11OpenChannelNS5_INS7_ILl9EEE12CloseChannelNS5_INS7_ILl8EEE8SendDataNS5_INS7_ILl7EEE11ReceiveDataNS5_INS7_ILl6EEE12RefreshAlphaNS5_INS7_ILl5EEE4fillILi26EENS5_INS7_ILl4EEES1N_ILi27EENS5_INS7_ILl3EEES1N_ILi28EENS5_INS7_ILl2EEES1N_ILi29EENS5_INS7_ILl1EEES1N_ILi30EENS4_5l_endEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEJEE15destroy_contentEv(buf);
  _ZN5boost7variantINS_6detail7variant13over_sequenceINS_3mpl6l_itemIN4mpl_5long_ILl30EEE4NoneNS5_INS7_ILl29EEE11DisplayTextNS5_INS7_ILl28EEE8GetInkeyNS5_INS7_ILl27EEE8GetInputNS5_INS7_ILl26EEE8PlayToneNS5_INS7_ILl25EEE16SendShortMessageNS5_INS7_ILl24EEE6SendSSNS5_INS7_ILl23EEE8SendUSSDNS5_INS7_ILl22EEE25SetupCallUserConfirmationNS5_INS7_ILl21EEE21SetupCallAlphaDisplayNS5_INS7_ILl20EEE9SetupMenuNS5_INS7_ILl19EEE10SelectItemNS5_INS7_ILl18EEE13SetupIdleTextNS5_INS7_ILl17EEE24ProvideLocalInfoLanguageNS5_INS7_ILl16EEE8SendDTMFNS5_INS7_ILl15EEE20LanguageNotificationNS5_INS7_ILl14EEE22SetupEventUserActivityNS5_INS7_ILl13EEE26SetupEventIdleScreenNotifyNS5_INS7_ILl12EEE30SetupEventLanguageSelectNotifyNS5_INS7_ILl11EEE22SetupEventIMSRegNotifyNS5_INS7_ILl10EEE11OpenChannelNS5_INS7_ILl9EEE12CloseChannelNS5_INS7_ILl8EEE8SendDataNS5_INS7_ILl7EEE11ReceiveDataNS5_INS7_ILl6EEE12RefreshAlphaNS5_INS7_ILl5EEE4fillILi26EENS5_INS7_ILl4EEES1N_ILi27EENS5_INS7_ILl3EEES1N_ILi28EENS5_INS7_ILl2EEES1N_ILi29EENS5_INS7_ILl1EEES1N_ILi30EENS4_5l_endEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEJEE15destroy_contentEv(v41);
  return MEMORY[0x2199FDD50](&v24);
}

void sub_2168FCA3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  char a68;
  void *a72;
  char a73;

  if (a35 < 0)
    operator delete(__p);
  _Block_object_dispose(&a68, 8);
  if (a73 < 0)
    operator delete(a72);
  MEMORY[0x2199FDD50](&a12);
  _Unwind_Resume(a1);
}

void getAddress<cat::SetupCall::Indication>(CSIPhoneNumber *a1, uint64_t a2, qmi::MessageBase *a3)
{
  _QWORD v6[6];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  __n128 (*v10)(uint64_t, uint64_t);
  void (*v11)(uint64_t);
  void *v12[2];
  __int128 v13;
  void *v14[2];
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  uint64_t v20;
  _QWORD *v21;

  v7 = 0;
  v8 = &v7;
  v9 = 0xB002000000;
  v10 = __Block_byref_object_copy__131;
  v11 = __Block_byref_object_dispose__132;
  *(_OWORD *)v12 = 0u;
  v13 = 0u;
  *(_OWORD *)v14 = 0u;
  v15 = 0u;
  v16 = 0u;
  v17 = 0u;
  v18 = 0u;
  v19 = 0u;
  v20 = 0;
  CSIPhoneNumber::CSIPhoneNumber((CSIPhoneNumber *)v12);
  v6[0] = MEMORY[0x24BDAC760];
  v6[1] = 0x40000000;
  v6[2] = ___Z10getAddressIN3cat9SetupCall10IndicationEE14CSIPhoneNumberPKN3ctu11OsLogLoggerERKT__block_invoke;
  v6[3] = &unk_24D5C8A00;
  v6[4] = &v7;
  v6[5] = a2;
  v21 = v6;
  qmi::MessageBase::applyTlv<cat::tlv::Address,void({block_pointer}&)(cat::tlv::Address const&)>(a3, (uint64_t)&v21);
  CSIPhoneNumber::CSIPhoneNumber(a1, (const CSIPhoneNumber *)(v8 + 5));
  _Block_object_dispose(&v7, 8);
  if (SHIBYTE(v18) < 0)
    operator delete(*((void **)&v17 + 1));
  if (SBYTE7(v17) < 0)
    operator delete((void *)v16);
  if (SBYTE7(v15) < 0)
    operator delete(v14[0]);
  if (SHIBYTE(v13) < 0)
    operator delete(v12[1]);
}

void sub_2168FCC24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  void **v8;
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  CSIPhoneNumber::~CSIPhoneNumber(v8);
  _Unwind_Resume(a1);
}

void getSubaddress<cat::SetupCall::Indication>(std::string *a1, uint64_t a2, qmi::MessageBase *this)
{
  uint64_t TlvValue;
  int v6;
  uint64_t v7;
  int v8;
  unint64_t v9;
  __int128 v10;
  _QWORD v11[6];
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  __n128 (*v15)(uint64_t, uint64_t);
  void (*v16)(uint64_t);
  void *__p;
  uint64_t v18;
  uint64_t v19;
  std::string v20;
  unint64_t v21;

  v12 = 0;
  v13 = &v12;
  v14 = 0x4002000000;
  v15 = __Block_byref_object_copy_;
  v16 = __Block_byref_object_dispose_;
  v18 = 0;
  v19 = 0;
  __p = 0;
  v11[0] = MEMORY[0x24BDAC760];
  v11[1] = 0x40000000;
  v11[2] = ___Z13getSubaddressIN3cat9SetupCall10IndicationEENSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEPKN3ctu11OsLogLoggerERKT__block_invoke;
  v11[3] = &unk_24D5C8A78;
  v11[4] = &v12;
  v11[5] = a2;
  TlvValue = qmi::MessageBase::findTlvValue(this);
  v7 = TlvValue;
  if (!TlvValue)
    goto LABEL_9;
  v8 = v6;
  v21 = TlvValue;
  memset(&v20, 0, sizeof(v20));
  tlv::parseV<cat::tlv::Subaddress>(&v21, v6, &v20);
  v9 = v21;
  if (v21)
    ___Z13getSubaddressIN3cat9SetupCall10IndicationEENSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEPKN3ctu11OsLogLoggerERKT__block_invoke((uint64_t)v11, &v20);
  if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v20.__r_.__value_.__l.__data_);
    if (v9)
      goto LABEL_9;
  }
  else if (v9)
  {
    goto LABEL_9;
  }
  ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)this, 51, v7, v8);
LABEL_9:
  if (*((char *)v13 + 63) < 0)
  {
    std::string::__init_copy_ctor_external(a1, (const std::string::value_type *)v13[5], v13[6]);
  }
  else
  {
    v10 = *(_OWORD *)(v13 + 5);
    a1->__r_.__value_.__r.__words[2] = v13[7];
    *(_OWORD *)&a1->__r_.__value_.__l.__data_ = v10;
  }
  _Block_object_dispose(&v12, 8);
  if (SHIBYTE(v19) < 0)
    operator delete(__p);
}

void sub_2168FCDA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  uint64_t v25;

  if (*(char *)(v25 - 57) < 0)
    operator delete(*(void **)(v25 - 80));
  _Block_object_dispose(&a15, 8);
  if (a25 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

void getSetupCallDisplayAlpha<cat::SetupCall::Indication>(std::string *a1, uint64_t a2, qmi::MessageBase *this)
{
  uint64_t TlvValue;
  int v6;
  uint64_t v7;
  int v8;
  unint64_t v9;
  __int128 v10;
  _QWORD v11[6];
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  __n128 (*v15)(uint64_t, uint64_t);
  void (*v16)(uint64_t);
  void *__p;
  uint64_t v18;
  uint64_t v19;
  __int128 v20;
  __int128 v21;
  unint64_t v22;

  v12 = 0;
  v13 = &v12;
  v14 = 0x4002000000;
  v15 = __Block_byref_object_copy_;
  v16 = __Block_byref_object_dispose_;
  v18 = 0;
  v19 = 0;
  __p = 0;
  v11[0] = MEMORY[0x24BDAC760];
  v11[1] = 0x40000000;
  v11[2] = ___Z24getSetupCallDisplayAlphaIN3cat9SetupCall10IndicationEENSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEPKN3ctu11OsLogLoggerERKT__block_invoke;
  v11[3] = &unk_24D5C8AC8;
  v11[4] = &v12;
  v11[5] = a2;
  TlvValue = qmi::MessageBase::findTlvValue(this);
  v7 = TlvValue;
  if (!TlvValue)
    goto LABEL_9;
  v8 = v6;
  v22 = TlvValue;
  v20 = 0u;
  v21 = 0u;
  tlv::parseV<cat::tlv::SetupCallDisplayAlpha>(&v22, v6, &v20);
  v9 = v22;
  if (v22)
    ___Z24getSetupCallDisplayAlphaIN3cat9SetupCall10IndicationEENSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEPKN3ctu11OsLogLoggerERKT__block_invoke((uint64_t)v11, (unsigned __int8 *)&v20);
  if (SHIBYTE(v21) < 0)
  {
    operator delete(*((void **)&v20 + 1));
    if (v9)
      goto LABEL_9;
  }
  else if (v9)
  {
    goto LABEL_9;
  }
  ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)this, 65, v7, v8);
LABEL_9:
  if (*((char *)v13 + 63) < 0)
  {
    std::string::__init_copy_ctor_external(a1, (const std::string::value_type *)v13[5], v13[6]);
  }
  else
  {
    v10 = *(_OWORD *)(v13 + 5);
    a1->__r_.__value_.__r.__words[2] = v13[7];
    *(_OWORD *)&a1->__r_.__value_.__l.__data_ = v10;
  }
  _Block_object_dispose(&v12, 8);
  if (SHIBYTE(v19) < 0)
    operator delete(__p);
}

void sub_2168FCF40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  uint64_t v25;

  if (*(char *)(v25 - 65) < 0)
    operator delete(*(void **)(v25 - 88));
  _Block_object_dispose(&a15, 8);
  if (a25 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

void QMI_STK_CommandDriver::sendTerminalResponse(uint64_t a1, unsigned int a2, int a3, int a4, int a5, int a6, int a7)
{
  os_log_t *v14;
  char *v15;
  char v16;
  uint64_t v17;
  char *v18;
  void *v19;
  _QWORD v20[6];
  unsigned int v21;
  int v22;
  char v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  void *v28;
  _QWORD v29[5];
  int v30;
  int v31;
  int v32;
  char v33;
  _OWORD v34[2];
  _QWORD aBlock[5];

  v14 = (os_log_t *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 48) + 16))(*(_QWORD *)(a1 + 48));
  {
    memset(v34, 0, sizeof(v34));
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v34);
    v15 = qmi::MutableMessageBase::getTLV<cat::tlv::Slot>(v34, 20);
    if (a2 >= 4)
      v16 = 0;
    else
      v16 = a2;
    *v15 = v16;
    v17 = MEMORY[0x24BDAC760];
    v29[0] = MEMORY[0x24BDAC760];
    v29[1] = 0x40000000;
    v29[2] = ___ZN21QMI_STK_CommandDriver20sendTerminalResponseE14STKSimSlotInfojh16ProactiveCommand20NotificationResponse26SendSessionCompletionEvent_block_invoke;
    v29[3] = &__block_descriptor_tmp_8_1;
    v33 = a4;
    v30 = a3;
    v31 = a5;
    v32 = a6;
    v29[4] = v14;
    v18 = qmi::MutableMessageBase::getTLV<cat::tlv::TerminalResponse>(v34);
    ___ZN21QMI_STK_CommandDriver20sendTerminalResponseE14STKSimSlotInfojh16ProactiveCommand20NotificationResponse26SendSessionCompletionEvent_block_invoke((uint64_t)v29, (uint64_t)v18);
    v24 = a1 + 72;
    v25 = QMIServiceMsg::create();
    v26 = 25000;
    v27 = 0;
    v28 = 0;
    v20[0] = v17;
    v20[1] = 0x40000000;
    v20[2] = ___ZN21QMI_STK_CommandDriver20sendTerminalResponseE14STKSimSlotInfojh16ProactiveCommand20NotificationResponse26SendSessionCompletionEvent_block_invoke_9;
    v20[3] = &__block_descriptor_tmp_10_0;
    v20[4] = a1;
    v20[5] = v14;
    v23 = a4;
    v21 = a2;
    v22 = a7;
    aBlock[0] = v17;
    aBlock[1] = 0x40000000;
    aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_3;
    aBlock[3] = &unk_24D5C7FB0;
    aBlock[4] = v20;
    v19 = _Block_copy(aBlock);
    v28 = v19;
    if (v25)
    {
      qmi::Client::send();
      v19 = v28;
    }
    if (v19)
      _Block_release(v19);
    qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v34);
  }
  else
  {
    QMI_STK_CommandDriver::sendStkSessionEvent(a1, v14, a2, a7, 2, 0);
  }
}

void sub_2168FD160(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)&a17);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a29);
  _Unwind_Resume(a1);
}

BOOL `anonymous namespace'::sValidateSessionId(os_log_t *a1, int a2, int a3)
{
  _BOOL8 v3;
  NSObject *v4;
  uint8_t v6[16];

  v3 = (a2 | a3) != 0;
  if (!(a2 | a3))
  {
    v4 = *a1;
    if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v6 = 0;
      _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I UIM Ref ID and BB Session IDs are 0", v6, 2u);
    }
  }
  return v3;
}

void QMI_STK_CommandDriver::sendStkSessionEvent(uint64_t a1, os_log_t *a2, unsigned int a3, int a4, uint64_t a5, uint64_t a6)
{
  NSObject *v6;
  int v7;
  uint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  if (a4)
  {
    v6 = *a2;
    if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
    {
      v7 = 136315138;
      v8 = asString();
      _os_log_impl(&dword_216897000, v6, OS_LOG_TYPE_DEFAULT, "#I Not sending out the event: %s", (uint8_t *)&v7, 0xCu);
    }
  }
  else
  {
    (*(void (**)(_QWORD, _QWORD, uint64_t, uint64_t))(**(_QWORD **)(a1 + 104) + 32))(*(_QWORD *)(a1 + 104), a3, a5, a6);
  }
}

float ___ZN21QMI_STK_CommandDriver20sendTerminalResponseE14STKSimSlotInfojh16ProactiveCommand20NotificationResponse26SendSessionCompletionEvent_block_invoke(uint64_t a1, uint64_t a2)
{
  int QMINotificationResponse;
  NSObject *v5;
  float result;
  int v7;
  int v8;
  int v9;
  _DWORD v10[2];
  __int16 v11;
  int v12;
  __int16 v13;
  int v14;
  __int16 v15;
  int v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  *(_DWORD *)a2 = *(_DWORD *)(a1 + 40);
  *(_BYTE *)(a2 + 4) = *(_BYTE *)(a1 + 52);
  *(_BYTE *)(a2 + 5) = getQMI_ProactiveCommand_TerminalResponse(*(_DWORD *)(a1 + 44));
  QMINotificationResponse = getQMINotificationResponse(*(_DWORD *)(a1 + 48));
  *(_DWORD *)(a2 + 8) = QMINotificationResponse;
  v5 = **(NSObject ***)(a1 + 32);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    v7 = *(_DWORD *)(a1 + 40);
    v8 = *(unsigned __int8 *)(a1 + 52);
    v9 = *(unsigned __int8 *)(a2 + 5);
    v10[0] = 67109888;
    v10[1] = v7;
    v11 = 1024;
    v12 = v8;
    v13 = 1024;
    v14 = v9;
    v15 = 1024;
    v16 = QMINotificationResponse;
    _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#I Sending Terminal Response to SIM card with UIM Reference ID: %d, Baseband Session ID: %d, Proactive Command: %d, and Notification Response: %d", (uint8_t *)v10, 0x1Au);
  }
  return result;
}

