void sub_216A39C1C(_Unwind_Exception *a1)
{
  void *v2;

  CallInfo::~CallInfo((void **)&STACK[0x450]);
  std::__tree<std::__value_type<AQMThroughputKey,unsigned int>,std::__map_value_compare<AQMThroughputKey,std::__value_type<AQMThroughputKey,unsigned int>,std::less<AQMThroughputKey>,true>,std::allocator<std::__value_type<AQMThroughputKey,unsigned int>>>::destroy((_QWORD *)STACK[0x398]);
  std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::destroy((void **)STACK[0x268]);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&STACK[0x290]);
  _Block_object_dispose(&STACK[0x2C8], 8);
  v2 = (void *)STACK[0x2F0];
  if (STACK[0x2F0])
  {
    STACK[0x2F8] = (unint64_t)v2;
    operator delete(v2);
  }
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__61(_QWORD *a1, uint64_t a2)
{
  __n128 result;

  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 5) = result;
  a1[7] = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a2 + 40) = 0;
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(a2 + 56) = 0;
  return result;
}

void __Block_byref_object_dispose__62(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 40);
  if (v2)
  {
    *(_QWORD *)(a1 + 48) = v2;
    operator delete(v2);
  }
}

uint64_t EurekaCallCommandDriver::validateCallCollisionScenario(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  NSObject *v4;
  unsigned int v5;
  uint64_t result;
  unsigned int v7;
  std::string *v8;
  std::string v9;
  std::string v10;
  void *__p[2];
  char v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  memset(&v10, 0, sizeof(v10));
  if ((unint64_t)(0x6DB6DB6DB6DB6DB7 * (a3 - (_QWORD)a2)) >= 3)
  {
    std::string::__assign_external(&v10, "Cannot have more than two calls happening at the same time in CDMA. Reset.", 0x4AuLL);
LABEL_3:
    v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v8 = &v10;
      if ((v10.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v8 = (std::string *)v10.__r_.__value_.__r.__words[0];
      LODWORD(__p[0]) = 136315138;
      *(void **)((char *)__p + 4) = v8;
      _os_log_error_impl(&dword_216897000, v4, OS_LOG_TYPE_ERROR, "%s", (uint8_t *)__p, 0xCu);
    }
    if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0)
      std::string::__init_copy_ctor_external(&v9, v10.__r_.__value_.__l.__data_, v10.__r_.__value_.__l.__size_);
    else
      v9 = v10;
    rest::ResetPayload::ResetPayload();
    ctu::rest::event_t<rest::reset_request,rest::ResetPayload>::send();
    if (v12 < 0)
      operator delete(__p[0]);
    if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v9.__r_.__value_.__l.__data_);
    if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v10.__r_.__value_.__l.__data_);
    return 0;
  }
  if (a3 - (_QWORD)a2 != 14 || a2[2] | a2[9])
    return 1;
  v5 = a2[1];
  if (v5 > 9 || (result = 1, ((1 << v5) & 0x310) == 0))
  {
    v7 = a2[8];
    if (v7 > 9 || (result = 1, ((1 << v7) & 0x310) == 0))
    {
      std::string::__assign_external(&v10, "CDMA: Two calls active and both are in non-disconnecting or non CC_IN_PROGRESS states. Cannot happen. Reset", 0x6BuLL);
      goto LABEL_3;
    }
  }
  return result;
}

void sub_216A3A0D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a20 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t EurekaCallCommandDriver::getCallCommandDriverType(EurekaCallCommandDriver *this)
{
  return 0;
}

void EurekaCallCommandDriver::setCallCapability(uint64_t a1, char *a2, int a3, int a4, uint64_t a5)
{
  NSObject **v10;
  void **v11;
  void *v12;
  void *v13;
  uint64_t *v14;
  uint64_t *v15;
  NSObject *v16;
  _BOOL4 v17;
  uint64_t v18;
  NSObject *v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  std::__shared_weak_count *v24;
  unint64_t *p_shared_owners;
  unint64_t v26;
  _QWORD v27[6];
  int v28;
  char v29;
  void *aBlock;
  dispatch_object_t object;
  void *__p[2];
  char v33;
  uint64_t v34;
  std::__shared_weak_count *v35;
  uint64_t v36;
  _OWORD *v37;
  _BYTE buf[12];
  char v39;
  uint64_t v40;

  v40 = *MEMORY[0x24BDAC8D0];
  v10 = (NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 112) + 16))(*(_QWORD *)(a1 + 112), a5);
  std::string::basic_string[abi:ne180100]<0>(buf, a2);
  v11 = std::__tree<std::string>::find<std::string>(a1 + 232, (void **)buf);
  if (v39 < 0)
    operator delete(*(void **)buf);
  if ((void **)(a1 + 240) != v11)
  {
    v12 = v11[7];
    if (v12)
    {
      (*(void (**)(void *))(*(_QWORD *)v12 + 16))(v12);
      v13 = v11[7];
      v11[7] = 0;
      if (v13)
        (*(void (**)(void *))(*(_QWORD *)v13 + 8))(v13);
    }
    std::string::basic_string[abi:ne180100]<0>(buf, a2);
    v14 = (uint64_t *)std::__tree<std::string>::find<std::string>(a1 + 232, (void **)buf);
    if ((uint64_t *)(a1 + 240) != v14)
    {
      v15 = v14;
      std::__tree<std::__value_type<std::string,std::unique_ptr<ctu::Timer>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<ctu::Timer>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<ctu::Timer>>>>::__remove_node_pointer((uint64_t **)(a1 + 232), v14);
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::unique_ptr<ctu::Timer>>,0>((uint64_t)(v15 + 4));
      operator delete(v15);
    }
    if (v39 < 0)
      operator delete(*(void **)buf);
  }
  v16 = *v10;
  v17 = os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT);
  if (a3 && a4)
  {
    if (v17)
    {
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = a2;
      _os_log_impl(&dword_216897000, v16, OS_LOG_TYPE_DEFAULT, "#I Will turn on %s after a delay. Creating a timer now.", buf, 0xCu);
    }
    Registry::getTimerService(*(Registry **)(a1 + 48));
    v18 = v34;
    std::string::basic_string[abi:ne180100]<0>(__p, "kDelayForAddMergeButton");
    v19 = *(NSObject **)(a1 + 24);
    object = v19;
    if (v19)
      dispatch_retain(v19);
    v27[0] = MEMORY[0x24BDAC760];
    v27[1] = 0x40000000;
    v27[2] = ___ZN23EurekaCallCommandDriver17setCallCapabilityEPKcbbN10subscriber7SimSlotE_block_invoke;
    v27[3] = &__block_descriptor_tmp_91_1;
    v27[4] = a1;
    v27[5] = a2;
    v29 = a4;
    v28 = a5;
    aBlock = _Block_copy(v27);
    ctu::TimerService::createOneShotTimer(v18, (uint64_t)__p, 1, 15000000, &object, &aBlock);
    std::string::basic_string[abi:ne180100]<0>(buf, a2);
    v37 = buf;
    v20 = std::__tree<std::__value_type<std::string,std::unique_ptr<ctu::Timer>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<ctu::Timer>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<ctu::Timer>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)(a1 + 232), (void **)buf, &v37);
    v21 = v36;
    v36 = 0;
    v22 = v20[7];
    v20[7] = v21;
    if (v22)
      (*(void (**)(uint64_t))(*(_QWORD *)v22 + 8))(v22);
    if (v39 < 0)
      operator delete(*(void **)buf);
    v23 = v36;
    v36 = 0;
    if (v23)
      (*(void (**)(uint64_t))(*(_QWORD *)v23 + 8))(v23);
    if (aBlock)
      _Block_release(aBlock);
    if (object)
      dispatch_release(object);
    if (v33 < 0)
      operator delete(__p[0]);
    v24 = v35;
    if (v35)
    {
      p_shared_owners = (unint64_t *)&v35->__shared_owners_;
      do
        v26 = __ldaxr(p_shared_owners);
      while (__stlxr(v26 - 1, p_shared_owners));
      if (!v26)
      {
        ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
        std::__shared_weak_count::__release_weak(v24);
      }
    }
  }
  else
  {
    if (v17)
    {
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = a2;
      _os_log_impl(&dword_216897000, v16, OS_LOG_TYPE_DEFAULT, "#I Will turn on or off %s immediately!", buf, 0xCu);
    }
    EurekaCallCommandDriver::handleSetCallCapabilityTimerExpired((_QWORD **)a1, a2, a4, a5);
  }
}

void sub_216A3A490(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *aBlock, dispatch_object_t object, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,char a24,uint64_t a25,uint64_t a26)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

void EurekaCallCommandDriver::sendToVoicemail(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  os_log_t *v5;
  uint64_t v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  NSObject *v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t *p_shared_owners;
  unint64_t v22;
  __int128 *v23;
  uint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  _BYTE v31[8];
  uint64_t v32;
  const void *v33;
  uint64_t v34;
  std::__shared_weak_count *v35;
  _BYTE v36[24];
  _BYTE *v37;
  uint8_t buf[16];
  __int128 v39;
  __int128 v40;
  __int128 v41;
  uint64_t v42;

  v42 = *MEMORY[0x24BDAC8D0];
  v4 = *(unsigned int *)(a2 + 252);
  v5 = (os_log_t *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 112) + 16))(*(_QWORD *)(a1 + 112), v4);
  v34 = 0;
  v35 = 0;
  EurekaCallCommandDriver::getPreferredFormatterForSim(&v34, a1, v4);
  v6 = v34;
  if (v34)
  {
    v40 = 0u;
    v41 = 0u;
    *(_OWORD *)buf = 0u;
    v39 = 0u;
    ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::SharedRef(&v33, (const void **)a2);
    (*(void (**)(uint8_t *__return_ptr, uint64_t, const void **, uint64_t))(*(_QWORD *)v6 + 88))(buf, v6, &v33, v4);
    ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::~SharedRef(&v33);
    v8 = *(_QWORD *)buf;
    v7 = *(std::__shared_weak_count **)&buf[8];
    if (!*(_QWORD *)&buf[8])
      goto LABEL_7;
    v9 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
    do
      v11 = __ldaxr(v9);
    while (__stlxr(v11 - 1, v9));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
      if (!v8)
        goto LABEL_34;
    }
    else
    {
LABEL_7:
      if (!v8)
        goto LABEL_34;
    }
    v12 = *(std::__shared_weak_count **)&buf[8];
    if ((v4 - 1) >= 3)
      LODWORD(v4) = 0;
    if (*(_QWORD *)&buf[8])
    {
      v13 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
      do
        v14 = __ldxr(v13);
      while (__stxr(v14 + 1, v13));
    }
    v15 = qmi::ClientRouter::get();
    qmi::ClientRouter::SendProxy::SendProxy<qmi::MutableMessageBase>((uint64_t)v31, v4, v15);
    *(_DWORD *)(v32 + 16) = v41;
    v16 = *((_QWORD *)&v40 + 1);
    if (*((_QWORD *)&v40 + 1))
    {
      if (*((__int128 **)&v40 + 1) == &v39)
      {
        v37 = v36;
        (*(void (**)(void))(**((_QWORD **)&v40 + 1) + 24))();
LABEL_22:
        qmi::ClientRouter::SendProxy::callback<std::function<void ()(qmi::ResponseBase const&)>>((uint64_t)v31, (uint64_t)v36);
        v18 = v37;
        if (v37 == v36)
        {
          v19 = 4;
          v18 = v36;
        }
        else
        {
          if (!v37)
          {
LABEL_27:
            v20 = v32;
            v32 = 0;
            if (v20)
              std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v32, v20);
            if (v12)
            {
              p_shared_owners = (unint64_t *)&v12->__shared_owners_;
              do
                v22 = __ldaxr(p_shared_owners);
              while (__stlxr(v22 - 1, p_shared_owners));
              if (!v22)
              {
                ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
                std::__shared_weak_count::__release_weak(v12);
              }
            }
LABEL_34:
            v23 = (__int128 *)*((_QWORD *)&v40 + 1);
            if (*((__int128 **)&v40 + 1) == &v39)
            {
              v24 = 4;
              v23 = &v39;
            }
            else
            {
              if (!*((_QWORD *)&v40 + 1))
              {
LABEL_39:
                v25 = *(std::__shared_weak_count **)&buf[8];
                if (*(_QWORD *)&buf[8])
                {
                  v26 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
                  do
                    v27 = __ldaxr(v26);
                  while (__stlxr(v27 - 1, v26));
                  if (!v27)
                  {
                    ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
                    std::__shared_weak_count::__release_weak(v25);
                  }
                }
                goto LABEL_44;
              }
              v24 = 5;
            }
            (*(void (**)(void))(*(_QWORD *)v23 + 8 * v24))();
            goto LABEL_39;
          }
          v19 = 5;
        }
        (*(void (**)(void))(*v18 + 8 * v19))();
        goto LABEL_27;
      }
      v16 = (*(uint64_t (**)(void))(**((_QWORD **)&v40 + 1) + 16))();
    }
    v37 = (_BYTE *)v16;
    goto LABEL_22;
  }
  v17 = *v5;
  if (os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl(&dword_216897000, v17, OS_LOG_TYPE_ERROR, "Preferred Formatter is NULL in sendToVoicemail", buf, 2u);
  }
LABEL_44:
  v28 = v35;
  if (v35)
  {
    v29 = (unint64_t *)&v35->__shared_owners_;
    do
      v30 = __ldaxr(v29);
    while (__stlxr(v30 - 1, v29));
    if (!v30)
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
  }
}

void sub_216A3A864(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  va_list va1;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  va_list va2;

  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v5 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v11 = va_arg(va2, _QWORD);
  v13 = va_arg(va2, _QWORD);
  v14 = va_arg(va2, _QWORD);
  v15 = va_arg(va2, _QWORD);
  v16 = va_arg(va2, _QWORD);
  v17 = va_arg(va2, _QWORD);
  v4 = v9;
  v9 = 0;
  if (v4)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v2, v4);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va);
  EurekaVoiceRequestMessage::~EurekaVoiceRequestMessage((EurekaVoiceRequestMessage *)va2);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

_QWORD *__Block_byref_object_copy__66(_QWORD *result, _QWORD *a2)
{
  _QWORD *v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;

  result[5] = a2[5];
  v2 = a2 + 6;
  v3 = a2[6];
  result[6] = v3;
  v4 = result + 6;
  v5 = a2[7];
  result[7] = v5;
  if (v5)
  {
    *(_QWORD *)(v3 + 16) = v4;
    a2[5] = v2;
    *v2 = 0;
    a2[7] = 0;
  }
  else
  {
    result[5] = v4;
  }
  return result;
}

void __Block_byref_object_dispose__67(uint64_t a1)
{
  std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::destroy(*(void ***)(a1 + 48));
}

void ___ZN23EurekaCallCommandDriver26parseRemotePartyNumberNameERKN2vs15VoiceCallStatus10IndicationEN10subscriber7SimSlotE_block_invoke(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v4;
  int v5;
  uint64_t v6;
  __int128 v7;
  int v8;
  int v9;
  std::string *p_p;
  std::string *v11;
  uint64_t **v12;
  std::string __p;
  char v14;

  v2 = a2[1];
  if (*a2 != v2)
  {
    v4 = *a2 + 8;
    do
    {
      v6 = v4 - 8;
      v5 = *(unsigned __int8 *)(v4 - 8);
      v14 = *(_BYTE *)(v4 - 8);
      memset(&__p, 0, sizeof(__p));
      if (*(char *)(v4 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)v4, *(_QWORD *)(v4 + 8));
      }
      else
      {
        v7 = *(_OWORD *)v4;
        __p.__r_.__value_.__r.__words[2] = *(_QWORD *)(v4 + 16);
        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v7;
      }
      v8 = *(unsigned __int8 *)(v4 - 7);
      if (v8 == 1)
        v9 = 1;
      else
        v9 = 2 * (v8 == 2);
      if (v9)
      {
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        {
          __p.__r_.__value_.__l.__size_ = 0;
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        else
        {
          *((_BYTE *)&__p.__r_.__value_.__s + 23) = 0;
          p_p = &__p;
        }
        p_p->__r_.__value_.__s.__data_[0] = 0;
      }
      if (numberContainsAlphabet())
      {
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        {
          __p.__r_.__value_.__l.__size_ = 0;
          v11 = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        else
        {
          *((_BYTE *)&__p.__r_.__value_.__s + 23) = 0;
          v11 = &__p;
        }
        v11->__r_.__value_.__s.__data_[0] = 0;
        v9 = 1;
      }
      v12 = std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), v5, &v14);
      std::string::operator=((std::string *)v12 + 3, &__p);
      *((_DWORD *)v12 + 33) = v5;
      *((_DWORD *)v12 + 30) = v9;
      *((_DWORD *)v12 + 73) = *(_DWORD *)(a1 + 40);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      v4 += 32;
    }
    while (v6 + 32 != v2);
  }
}

void sub_216A3AA80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

__n128 __Block_byref_object_copy__70(_QWORD *a1, uint64_t a2)
{
  __n128 result;

  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 5) = result;
  a1[7] = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a2 + 40) = 0;
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(a2 + 56) = 0;
  return result;
}

void __Block_byref_object_dispose__71(uint64_t a1)
{
  void **v1;

  v1 = (void **)(a1 + 40);
  std::vector<vs::tlv::RemoteNumberListItem>::__destroy_vector::operator()[abi:ne180100](&v1);
}

void ___ZN23EurekaCallCommandDriver26parseRemotePartyNumberNameERKN2vs15VoiceCallStatus10IndicationEN10subscriber7SimSlotE_block_invoke_72(uint64_t a1, __int16 **a2)
{
  uint64_t *v2;
  void **v3;
  uint64_t v4;
  __int16 *v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  __int16 *v16;
  uint64_t v17;
  uint64_t i;

  v2 = *(uint64_t **)(*(_QWORD *)(a1 + 32) + 8);
  v3 = (void **)(v2 + 5);
  if (v2 + 5 != (uint64_t *)a2)
  {
    v5 = *a2;
    v4 = (uint64_t)a2[1];
    v6 = v4 - (_QWORD)*a2;
    v7 = v6 >> 5;
    v8 = v2[7];
    v9 = v2[5];
    if (v6 >> 5 > (unint64_t)((v8 - v9) >> 5))
    {
      if (v9)
      {
        std::vector<vs::tlv::RemoteNumberListItem>::__clear[abi:ne180100](v2 + 5);
        operator delete(*v3);
        v8 = 0;
        *v3 = 0;
        v2[6] = 0;
        v2[7] = 0;
      }
      if (v6 < 0)
        goto LABEL_22;
      v10 = v8 >> 4;
      if (v8 >> 4 <= v7)
        v10 = v6 >> 5;
      v11 = (unint64_t)v8 >= 0x7FFFFFFFFFFFFFE0 ? 0x7FFFFFFFFFFFFFFLL : v10;
      if (v11 >> 59)
LABEL_22:
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v12 = std::__allocate_at_least[abi:ne180100]<std::allocator<vs::tlv::RemoteNumberListItem>>((uint64_t)(v2 + 7), v11);
      v2[5] = (uint64_t)v12;
      v2[6] = (uint64_t)v12;
      v2[7] = (uint64_t)v12 + 32 * v13;
      v14 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<vs::tlv::RemoteNameListItem>,vs::tlv::RemoteNameListItem*,vs::tlv::RemoteNameListItem*,vs::tlv::RemoteNameListItem*>((uint64_t)(v2 + 7), (uint64_t)v5, v4, (uint64_t)v12);
      goto LABEL_15;
    }
    v15 = (v2[6] - v9) >> 5;
    if (v15 < v7)
    {
      v16 = &v5[16 * v15];
      std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,vs::tlv::RemoteNameListItem *,vs::tlv::RemoteNameListItem *,vs::tlv::RemoteNameListItem *,0>(*a2, v16, v9);
      v14 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<vs::tlv::RemoteNameListItem>,vs::tlv::RemoteNameListItem*,vs::tlv::RemoteNameListItem*,vs::tlv::RemoteNameListItem*>((uint64_t)(v2 + 7), (uint64_t)v16, v4, v2[6]);
LABEL_15:
      v2[6] = v14;
      return;
    }
    v17 = std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,vs::tlv::RemoteNameListItem *,vs::tlv::RemoteNameListItem *,vs::tlv::RemoteNameListItem *,0>(*a2, a2[1], v9);
    for (i = v2[6]; i != v17; i -= 32)
    {
      if (*(char *)(i - 1) < 0)
        operator delete(*(void **)(i - 24));
    }
    v2[6] = v17;
  }
}

void sub_216A3ADB8(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v2 + 48) = v1;
  _Unwind_Resume(a1);
}

void sub_216A3ADC0(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v2 + 48) = v1;
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__74(_QWORD *a1, uint64_t a2)
{
  __n128 result;

  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 5) = result;
  a1[7] = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a2 + 40) = 0;
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(a2 + 56) = 0;
  return result;
}

void __Block_byref_object_dispose__75(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 40);
  if (v2)
  {
    *(_QWORD *)(a1 + 48) = v2;
    operator delete(v2);
  }
}

__n128 __Block_byref_object_copy__77(_QWORD *a1, uint64_t a2)
{
  __n128 result;

  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 5) = result;
  a1[7] = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a2 + 40) = 0;
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(a2 + 56) = 0;
  return result;
}

void __Block_byref_object_dispose__78(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 40);
  if (v2)
  {
    *(_QWORD *)(a1 + 48) = v2;
    operator delete(v2);
  }
}

void EurekaCallCommandDriver::sendCallWaitingTone(uint64_t a1, uint64_t a2)
{
  NSObject **v4;
  NSObject *v5;
  NSObject *v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  uint8_t v13[16];
  uint8_t buf[8];
  std::__shared_weak_count *v15;
  uint64_t v16;
  std::__shared_weak_count *v17;

  v4 = (NSObject **)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 112) + 16))(*(_QWORD *)(a1 + 112));
  v16 = 0;
  v17 = 0;
  EurekaCallCommandDriver::getPreferredFormatterForSim(&v16, a1, a2);
  if (v16 && ((*(uint64_t (**)(uint64_t))(*(_QWORD *)v16 + 168))(v16) & 1) == 0)
  {
    *(_QWORD *)buf = 0;
    v15 = 0;
    (*(void (**)(uint8_t *__return_ptr))(**(_QWORD **)(a1 + 120) + 288))(buf);
    if (*(_QWORD *)buf)
    {
      (*(void (**)(_QWORD, uint64_t, uint64_t))(**(_QWORD **)buf + 40))(*(_QWORD *)buf, 7, 3);
    }
    else
    {
      v6 = *v4;
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)v13 = 0;
        _os_log_error_impl(&dword_216897000, v6, OS_LOG_TYPE_ERROR, "Did not get a valid CallAudioDriver", v13, 2u);
      }
    }
    v7 = v15;
    if (v15)
    {
      p_shared_owners = (unint64_t *)&v15->__shared_owners_;
      do
        v9 = __ldaxr(p_shared_owners);
      while (__stlxr(v9 - 1, p_shared_owners));
      if (!v9)
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
    }
  }
  else
  {
    v5 = *v4;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#I Not playing call waiting tones since Network will generate the tones in band", buf, 2u);
    }
  }
  v10 = v17;
  if (v17)
  {
    v11 = (unint64_t *)&v17->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
}

void sub_216A3B240(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v4;
  va_list va;
  uint64_t v6;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

void EurekaCallCommandDriver::sendEndCallAudio(EurekaCallCommandDriver *this, const CallInfo *a2)
{
  os_log_t *v4;
  uint64_t v5;
  uint64_t v6;
  NSObject *v7;
  int CCDisconnectErrorCode;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  uint8_t v12[16];
  uint64_t v13;
  std::__shared_weak_count *v14;

  v4 = (os_log_t *)(*(uint64_t (**)(_QWORD, _QWORD))(**((_QWORD **)this + 14) + 16))(*((_QWORD *)this + 14), *((unsigned int *)a2 + 63));
  v13 = 0;
  v14 = 0;
  (*(void (**)(uint64_t *__return_ptr))(**((_QWORD **)this + 15) + 288))(&v13);
  if (v13)
  {
    if (CallInfo::getCCDisconnectErrorCode(a2) == 28)
    {
      v5 = 3;
      v6 = 4;
    }
    else
    {
      CCDisconnectErrorCode = CallInfo::getCCDisconnectErrorCode(a2);
      if (CCDisconnectErrorCode == 33)
        v6 = 3;
      else
        v6 = 9;
      if (CCDisconnectErrorCode == 33)
        v5 = 8;
      else
        v5 = 3;
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v13 + 40))(v13, v6, v5);
  }
  else
  {
    v7 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v12 = 0;
      _os_log_error_impl(&dword_216897000, v7, OS_LOG_TYPE_ERROR, "Did not get a valid CallAudioDriver", v12, 2u);
    }
  }
  v9 = v14;
  if (v14)
  {
    p_shared_owners = (unint64_t *)&v14->__shared_owners_;
    do
      v11 = __ldaxr(p_shared_owners);
    while (__stlxr(v11 - 1, p_shared_owners));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
}

void sub_216A3B394(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t EurekaCallCommandDriver::areVoiceCallsAllowedRightNow(EurekaCallCommandDriver *this)
{
  if (*((_BYTE *)this + 304))
    return 1;
  else
    return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 15) + 176))(*((_QWORD *)this + 15));
}

void EurekaCallCommandDriver::handleECBMChanged(EurekaCallCommandDriver *this, int a2)
{
  NSObject *v4;
  _BOOL4 v5;
  uint8_t v6[16];
  uint8_t buf[16];

  v4 = *((_QWORD *)this + 5);
  v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (a2)
  {
    if (v5)
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I ECBM mode is enabled!", buf, 2u);
    }
    *((_BYTE *)this + 304) = a2;
  }
  else
  {
    if (v5)
    {
      *(_WORD *)v6 = 0;
      _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I ECBM mode is disabled!", v6, 2u);
    }
    *((_BYTE *)this + 304) = 0;
    (*(void (**)(_QWORD, uint64_t))(**((_QWORD **)this + 15) + 128))(*((_QWORD *)this + 15), 1);
  }
}

void EurekaCallCommandDriver::answerWaitingHoldOther(uint64_t a1, const void **a2)
{
  uint64_t v4;
  uint64_t v5;
  os_log_t *v6;
  uint64_t v7;
  __int128 v8;
  unint64_t *v9;
  unint64_t v10;
  unint64_t v11;
  int v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  NSObject *v18;
  __int128 *v19;
  NSObject *v20;
  uint8_t *v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t *p_shared_owners;
  unint64_t v25;
  __int128 *v26;
  uint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  _BYTE v34[8];
  uint64_t v35;
  const void *v36;
  uint64_t v37;
  std::__shared_weak_count *v38;
  const void *v39;
  const void *v40;
  _OWORD v41[15];
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  uint64_t v52;
  uint8_t buf[4];
  __int128 *v54;
  uint8_t *v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  uint64_t v60;

  v60 = *MEMORY[0x24BDAC8D0];
  v52 = 0;
  v50 = 0u;
  v51 = 0u;
  v48 = 0u;
  v49 = 0u;
  v46 = 0u;
  v47 = 0u;
  v44 = 0u;
  v45 = 0u;
  v42 = 0u;
  v43 = 0u;
  memset(v41, 0, sizeof(v41));
  CallInfo::CallInfo((CallInfo *)v41);
  v4 = *(_QWORD *)(a1 + 120);
  ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::SharedRef(&v40, a2);
  LOBYTE(v4) = (*(uint64_t (**)(uint64_t, const void **, _OWORD *))(*(_QWORD *)v4 + 296))(v4, &v40, v41);
  ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::~SharedRef(&v40);
  if ((v4 & 1) != 0)
  {
    v5 = HIDWORD(v42);
    v6 = (os_log_t *)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 112) + 16))(*(_QWORD *)(a1 + 112), HIDWORD(v42));
    v37 = 0;
    v38 = 0;
    EurekaCallCommandDriver::getPreferredFormatterForSim(&v37, a1, v5);
    v7 = v37;
    if (!v37)
    {
      v20 = *v6;
      if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v56) = 0;
        _os_log_error_impl(&dword_216897000, v20, OS_LOG_TYPE_ERROR, "Preferred Formatter is NULL in answerWaitingHoldOther", (uint8_t *)&v56, 2u);
      }
      goto LABEL_53;
    }
    v58 = 0u;
    v59 = 0u;
    v56 = 0u;
    v57 = 0u;
    ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::SharedRef(&v36, a2);
    (*(void (**)(__int128 *__return_ptr, uint64_t, const void **, uint64_t))(*(_QWORD *)v7 + 32))(&v56, v7, &v36, v5);
    ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::~SharedRef(&v36);
    v8 = v56;
    if (!*((_QWORD *)&v56 + 1))
      goto LABEL_8;
    v9 = (unint64_t *)(*((_QWORD *)&v56 + 1) + 8);
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
    do
      v11 = __ldaxr(v9);
    while (__stlxr(v11 - 1, v9));
    if (!v11)
    {
      (*(void (**)(_QWORD))(**((_QWORD **)&v8 + 1) + 16))(*((_QWORD *)&v8 + 1));
      std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v8 + 1));
      if (!(_QWORD)v8)
        goto LABEL_43;
    }
    else
    {
LABEL_8:
      if (!(_QWORD)v8)
        goto LABEL_43;
    }
    if ((HIDWORD(v42) - 1) >= 3)
      v12 = 0;
    else
      v12 = HIDWORD(v42);
    v13 = (std::__shared_weak_count *)*((_QWORD *)&v56 + 1);
    if (*((_QWORD *)&v56 + 1))
    {
      v14 = (unint64_t *)(*((_QWORD *)&v56 + 1) + 8);
      do
        v15 = __ldxr(v14);
      while (__stxr(v15 + 1, v14));
    }
    v16 = qmi::ClientRouter::get();
    qmi::ClientRouter::SendProxy::SendProxy<qmi::MutableMessageBase>((uint64_t)v34, v12, v16);
    *(_DWORD *)(v35 + 16) = v59;
    v17 = *((_QWORD *)&v58 + 1);
    if (*((_QWORD *)&v58 + 1))
    {
      if (*((__int128 **)&v58 + 1) == &v57)
      {
        v55 = buf;
        (*(void (**)(void))(**((_QWORD **)&v58 + 1) + 24))();
LABEL_31:
        qmi::ClientRouter::SendProxy::callback<std::function<void ()(qmi::ResponseBase const&)>>((uint64_t)v34, (uint64_t)buf);
        v21 = v55;
        if (v55 == buf)
        {
          v22 = 4;
          v21 = buf;
        }
        else
        {
          if (!v55)
          {
LABEL_36:
            v23 = v35;
            v35 = 0;
            if (v23)
              std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v35, v23);
            if (v13)
            {
              p_shared_owners = (unint64_t *)&v13->__shared_owners_;
              do
                v25 = __ldaxr(p_shared_owners);
              while (__stlxr(v25 - 1, p_shared_owners));
              if (!v25)
              {
                ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
                std::__shared_weak_count::__release_weak(v13);
              }
            }
LABEL_43:
            v26 = (__int128 *)*((_QWORD *)&v58 + 1);
            if (*((__int128 **)&v58 + 1) == &v57)
            {
              v27 = 4;
              v26 = &v57;
            }
            else
            {
              if (!*((_QWORD *)&v58 + 1))
              {
LABEL_48:
                v28 = (std::__shared_weak_count *)*((_QWORD *)&v56 + 1);
                if (*((_QWORD *)&v56 + 1))
                {
                  v29 = (unint64_t *)(*((_QWORD *)&v56 + 1) + 8);
                  do
                    v30 = __ldaxr(v29);
                  while (__stlxr(v30 - 1, v29));
                  if (!v30)
                  {
                    ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
                    std::__shared_weak_count::__release_weak(v28);
                  }
                }
LABEL_53:
                v31 = v38;
                if (v38)
                {
                  v32 = (unint64_t *)&v38->__shared_owners_;
                  do
                    v33 = __ldaxr(v32);
                  while (__stlxr(v33 - 1, v32));
                  if (!v33)
                  {
                    ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
                    std::__shared_weak_count::__release_weak(v31);
                  }
                }
                goto LABEL_58;
              }
              v27 = 5;
            }
            (*(void (**)(void))(*(_QWORD *)v26 + 8 * v27))();
            goto LABEL_48;
          }
          v22 = 5;
        }
        (*(void (**)(void))(*(_QWORD *)v21 + 8 * v22))();
        goto LABEL_36;
      }
      v17 = (*(uint64_t (**)(void))(**((_QWORD **)&v58 + 1) + 16))();
    }
    v55 = (uint8_t *)v17;
    goto LABEL_31;
  }
  v18 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::SharedRef(&v39, a2);
    printUuid();
    if ((SBYTE7(v57) & 0x80u) == 0)
      v19 = &v56;
    else
      v19 = (__int128 *)v56;
    *(_DWORD *)buf = 136315138;
    v54 = v19;
    _os_log_error_impl(&dword_216897000, v18, OS_LOG_TYPE_ERROR, "Could not find call with UUID %s when trying to wait-hold", buf, 0xCu);
    if (SBYTE7(v57) < 0)
      operator delete((void *)v56);
    ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::~SharedRef(&v39);
  }
LABEL_58:
  CallInfo::~CallInfo((void **)v41);
}

void sub_216A3B8E4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  va_list va;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  va_list va1;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  va_list va2;

  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v6 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v12 = va_arg(va2, _QWORD);
  v14 = va_arg(va2, _QWORD);
  v15 = va_arg(va2, _QWORD);
  v16 = va_arg(va2, _QWORD);
  v5 = v10;
  v10 = 0;
  if (v5)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v2, v5);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va);
  EurekaVoiceRequestMessage::~EurekaVoiceRequestMessage((EurekaVoiceRequestMessage *)(v3 - 144));
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  CallInfo::~CallInfo((void **)va2);
  _Unwind_Resume(a1);
}

void EurekaCallCommandDriver::answerWaitingEndActive(EurekaCallCommandDriver *this, int *a2)
{
  uint64_t i;
  uint64_t v4;
  unsigned int v5;
  BOOL v6;
  int v7;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  os_log_t *v19;
  __int128 v20;
  unint64_t *v21;
  unint64_t v22;
  unint64_t v23;
  int v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  NSObject *v30;
  _QWORD *v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t *p_shared_owners;
  unint64_t v35;
  __int128 *v36;
  uint64_t v37;
  std::__shared_weak_count *v38;
  unint64_t *v39;
  unint64_t v40;
  std::__shared_weak_count *v41;
  unint64_t *v42;
  unint64_t v43;
  EurekaCallCommandDriver *v45;
  _BYTE v46[8];
  uint64_t v47;
  uint64_t v48;
  std::__shared_weak_count *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  _OWORD v53[2];
  std::string v54[4];
  __int128 v55;
  __int128 v56;
  _BYTE v57[112];
  std::string v58[2];
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  _OWORD v63[2];
  _BYTE v64[24];
  _BYTE *v65;
  __int128 buf;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  uint64_t v70;

  v70 = *MEMORY[0x24BDAC8D0];
  v62 = 0u;
  memset(v63, 0, 24);
  v60 = 0u;
  v61 = 0u;
  v59 = 0u;
  memset(v58, 0, sizeof(v58));
  v56 = 0u;
  memset(v57, 0, sizeof(v57));
  v55 = 0u;
  memset(v54, 0, sizeof(v54));
  memset(v53, 0, sizeof(v53));
  CallInfo::CallInfo((CallInfo *)v53);
  v50 = 0;
  v51 = 0;
  v52 = 0;
  v45 = this;
  (*(void (**)(uint64_t *__return_ptr))(**((_QWORD **)this + 15) + 304))(&v50);
  v4 = v50;
  for (i = v51; v4 != i; v4 += 408)
  {
    v5 = *(unsigned __int8 *)(v4 + 68);
    v6 = v5 > 8;
    v7 = (1 << v5) & 0x114;
    if (v6 || v7 == 0)
    {
      ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::operator=((const void **)v53, (const void **)v4);
      std::string::operator=((std::string *)((char *)v53 + 8), (const std::string *)(v4 + 8));
      std::string::operator=(v54, (const std::string *)(v4 + 32));
      *(_OWORD *)&v54[1].__r_.__value_.__l.__data_ = *(_OWORD *)(v4 + 56);
      v9 = *(_OWORD *)(v4 + 72);
      v10 = *(_OWORD *)(v4 + 88);
      v11 = *(_OWORD *)(v4 + 104);
      *(std::string::size_type *)((char *)&v54[3].__r_.__value_.__r.__words[1] + 5) = *(_QWORD *)(v4 + 117);
      *(_OWORD *)&v54[2].__r_.__value_.__r.__words[1] = v10;
      *(_OWORD *)&v54[3].__r_.__value_.__l.__data_ = v11;
      *(_OWORD *)&v54[1].__r_.__value_.__r.__words[2] = v9;
      std::string::operator=((std::string *)&v55, (const std::string *)(v4 + 128));
      DWORD2(v56) = *(_DWORD *)(v4 + 152);
      std::string::operator=((std::string *)v57, (const std::string *)(v4 + 160));
      v12 = *(_OWORD *)(v4 + 184);
      *(_OWORD *)&v57[33] = *(_OWORD *)(v4 + 193);
      *(_OWORD *)&v57[24] = v12;
      std::__optional_storage_base<std::vector<unsigned int>,false>::__assign_from[abi:ne180100]<std::__optional_copy_assign_base<std::vector<unsigned int>,false> const&>((uint64_t)&v57[56], v4 + 216);
      v13 = *(_OWORD *)(v4 + 248);
      v57[104] = *(_BYTE *)(v4 + 264);
      *(_OWORD *)&v57[88] = v13;
      std::string::operator=(v58, (const std::string *)(v4 + 272));
      std::string::operator=(&v58[1], (const std::string *)(v4 + 296));
      v14 = *(_OWORD *)(v4 + 336);
      v59 = *(_OWORD *)(v4 + 320);
      v60 = v14;
      v15 = *(_OWORD *)(v4 + 352);
      v16 = *(_OWORD *)(v4 + 368);
      v17 = *(_OWORD *)(v4 + 384);
      *(_QWORD *)((char *)v63 + 13) = *(_QWORD *)(v4 + 397);
      v62 = v16;
      v63[0] = v17;
      v61 = v15;
    }
  }
  v18 = *(unsigned int *)&v57[92];
  v19 = (os_log_t *)(*(uint64_t (**)(_QWORD, _QWORD))(**((_QWORD **)v45 + 14) + 16))(*((_QWORD *)v45 + 14), *(unsigned int *)&v57[92]);
  v48 = 0;
  v49 = 0;
  EurekaCallCommandDriver::getPreferredFormatterForSim(&v48, (uint64_t)v45, v18);
  if (v48)
  {
    v68 = 0u;
    v69 = 0u;
    buf = 0u;
    v67 = 0u;
    (*(void (**)(__int128 *__return_ptr, uint64_t, uint64_t))(*(_QWORD *)v48 + 40))(&buf, v48, v18);
    v20 = buf;
    if (!*((_QWORD *)&buf + 1))
      goto LABEL_15;
    v21 = (unint64_t *)(*((_QWORD *)&buf + 1) + 8);
    do
      v22 = __ldxr(v21);
    while (__stxr(v22 + 1, v21));
    do
      v23 = __ldaxr(v21);
    while (__stlxr(v23 - 1, v21));
    if (!v23)
    {
      (*(void (**)(_QWORD))(**((_QWORD **)&v20 + 1) + 16))(*((_QWORD *)&v20 + 1));
      std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v20 + 1));
      if (!(_QWORD)v20)
        goto LABEL_45;
    }
    else
    {
LABEL_15:
      if (!(_QWORD)v20)
        goto LABEL_45;
    }
    if (*a2)
      goto LABEL_45;
    if ((*(_DWORD *)&v57[92] - 1) >= 3)
      v24 = 0;
    else
      v24 = *(_DWORD *)&v57[92];
    v25 = (std::__shared_weak_count *)*((_QWORD *)&buf + 1);
    if (*((_QWORD *)&buf + 1))
    {
      v26 = (unint64_t *)(*((_QWORD *)&buf + 1) + 8);
      do
        v27 = __ldxr(v26);
      while (__stxr(v27 + 1, v26));
    }
    v28 = qmi::ClientRouter::get();
    qmi::ClientRouter::SendProxy::SendProxy<qmi::MutableMessageBase>((uint64_t)v46, v24, v28);
    *(_DWORD *)(v47 + 16) = v69;
    v29 = *((_QWORD *)&v68 + 1);
    if (*((_QWORD *)&v68 + 1))
    {
      if (*((__int128 **)&v68 + 1) == &v67)
      {
        v65 = v64;
        (*(void (**)(_QWORD, _BYTE *))(**((_QWORD **)&v68 + 1) + 24))(*((_QWORD *)&v68 + 1), v64);
LABEL_32:
        qmi::ClientRouter::SendProxy::callback<std::function<void ()(qmi::ResponseBase const&)>>((uint64_t)v46, (uint64_t)v64);
        v31 = v65;
        if (v65 == v64)
        {
          v32 = 4;
          v31 = v64;
        }
        else
        {
          if (!v65)
          {
LABEL_37:
            v33 = v47;
            v47 = 0;
            if (v33)
              std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v47, v33);
            if (v25)
            {
              p_shared_owners = (unint64_t *)&v25->__shared_owners_;
              do
                v35 = __ldaxr(p_shared_owners);
              while (__stlxr(v35 - 1, p_shared_owners));
              if (!v35)
              {
                ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
                std::__shared_weak_count::__release_weak(v25);
              }
            }
            ++*a2;
LABEL_45:
            v36 = (__int128 *)*((_QWORD *)&v68 + 1);
            if (*((__int128 **)&v68 + 1) == &v67)
            {
              v37 = 4;
              v36 = &v67;
            }
            else
            {
              if (!*((_QWORD *)&v68 + 1))
              {
LABEL_50:
                v38 = (std::__shared_weak_count *)*((_QWORD *)&buf + 1);
                if (*((_QWORD *)&buf + 1))
                {
                  v39 = (unint64_t *)(*((_QWORD *)&buf + 1) + 8);
                  do
                    v40 = __ldaxr(v39);
                  while (__stlxr(v40 - 1, v39));
                  if (!v40)
                  {
                    ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
                    std::__shared_weak_count::__release_weak(v38);
                  }
                }
                goto LABEL_55;
              }
              v37 = 5;
            }
            (*(void (**)(void))(*(_QWORD *)v36 + 8 * v37))();
            goto LABEL_50;
          }
          v32 = 5;
        }
        (*(void (**)(void))(*v31 + 8 * v32))();
        goto LABEL_37;
      }
      v29 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)&v68 + 1) + 16))(*((_QWORD *)&v68 + 1));
    }
    v65 = (_BYTE *)v29;
    goto LABEL_32;
  }
  v30 = *v19;
  if (os_log_type_enabled(*v19, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf) = 0;
    _os_log_error_impl(&dword_216897000, v30, OS_LOG_TYPE_ERROR, "Preferred Formatter is NULL in answerWaitingEndActive", (uint8_t *)&buf, 2u);
  }
LABEL_55:
  v41 = v49;
  if (v49)
  {
    v42 = (unint64_t *)&v49->__shared_owners_;
    do
      v43 = __ldaxr(v42);
    while (__stlxr(v43 - 1, v42));
    if (!v43)
    {
      ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
      std::__shared_weak_count::__release_weak(v41);
    }
  }
  *(_QWORD *)&buf = &v50;
  std::vector<CallInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)&buf);
  CallInfo::~CallInfo((void **)v53);
}

void sub_216A3BEB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,void *a27)
{
  uint64_t v27;
  uint64_t v28;
  uint64_t v30;

  v30 = a21;
  a21 = 0;
  if (v30)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v27, v30);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a18);
  EurekaVoiceRequestMessage::~EurekaVoiceRequestMessage((EurekaVoiceRequestMessage *)(v28 - 176));
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a22);
  *(_QWORD *)(v28 - 176) = &a24;
  std::vector<CallInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)(v28 - 176));
  CallInfo::~CallInfo(&a27);
  _Unwind_Resume(a1);
}

void EurekaCallCommandDriver::answerIncomingCall(uint64_t a1, unsigned int *a2)
{
  uint64_t v4;
  os_log_t *v5;
  uint64_t v6;
  __int128 v7;
  unint64_t *v8;
  unint64_t v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  NSObject *v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t *p_shared_owners;
  unint64_t v21;
  __int128 *v22;
  uint64_t v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  _BYTE v30[8];
  uint64_t v31;
  void *v32[51];
  uint64_t v33;
  std::__shared_weak_count *v34;
  _BYTE v35[24];
  _BYTE *v36;
  __int128 buf;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  uint64_t v41;

  v41 = *MEMORY[0x24BDAC8D0];
  v4 = a2[63];
  v5 = (os_log_t *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 112) + 16))(*(_QWORD *)(a1 + 112), v4);
  v33 = 0;
  v34 = 0;
  EurekaCallCommandDriver::getPreferredFormatterForSim(&v33, a1, v4);
  v6 = v33;
  if (v33)
  {
    v39 = 0u;
    v40 = 0u;
    buf = 0u;
    v38 = 0u;
    CallInfo::CallInfo((CallInfo *)v32, (const CallInfo *)a2);
    (*(void (**)(__int128 *__return_ptr, uint64_t, void **))(*(_QWORD *)v6 + 48))(&buf, v6, v32);
    CallInfo::~CallInfo(v32);
    v7 = buf;
    if (!*((_QWORD *)&buf + 1))
      goto LABEL_7;
    v8 = (unint64_t *)(*((_QWORD *)&buf + 1) + 8);
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
    do
      v10 = __ldaxr(v8);
    while (__stlxr(v10 - 1, v8));
    if (!v10)
    {
      (*(void (**)(_QWORD))(**((_QWORD **)&v7 + 1) + 16))(*((_QWORD *)&v7 + 1));
      std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v7 + 1));
      if (!(_QWORD)v7)
        goto LABEL_34;
    }
    else
    {
LABEL_7:
      if (!(_QWORD)v7)
        goto LABEL_34;
    }
    v11 = (std::__shared_weak_count *)*((_QWORD *)&buf + 1);
    if ((v4 - 1) >= 3)
      LODWORD(v4) = 0;
    if (*((_QWORD *)&buf + 1))
    {
      v12 = (unint64_t *)(*((_QWORD *)&buf + 1) + 8);
      do
        v13 = __ldxr(v12);
      while (__stxr(v13 + 1, v12));
    }
    v14 = qmi::ClientRouter::get();
    qmi::ClientRouter::SendProxy::SendProxy<qmi::MutableMessageBase>((uint64_t)v30, v4, v14);
    v15 = *((_QWORD *)&v39 + 1);
    if (*((_QWORD *)&v39 + 1))
    {
      if (*((__int128 **)&v39 + 1) == &v38)
      {
        v36 = v35;
        (*(void (**)(_QWORD, _BYTE *))(**((_QWORD **)&v39 + 1) + 24))(*((_QWORD *)&v39 + 1), v35);
LABEL_22:
        qmi::ClientRouter::SendProxy::callback<std::function<void ()(qmi::ResponseBase const&)>>((uint64_t)v30, (uint64_t)v35);
        v17 = v36;
        if (v36 == v35)
        {
          v18 = 4;
          v17 = v35;
        }
        else
        {
          if (!v36)
          {
LABEL_27:
            v19 = v31;
            v31 = 0;
            if (v19)
              std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v31, v19);
            if (v11)
            {
              p_shared_owners = (unint64_t *)&v11->__shared_owners_;
              do
                v21 = __ldaxr(p_shared_owners);
              while (__stlxr(v21 - 1, p_shared_owners));
              if (!v21)
              {
                ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
                std::__shared_weak_count::__release_weak(v11);
              }
            }
LABEL_34:
            v22 = (__int128 *)*((_QWORD *)&v39 + 1);
            if (*((__int128 **)&v39 + 1) == &v38)
            {
              v23 = 4;
              v22 = &v38;
            }
            else
            {
              if (!*((_QWORD *)&v39 + 1))
              {
LABEL_39:
                v24 = (std::__shared_weak_count *)*((_QWORD *)&buf + 1);
                if (*((_QWORD *)&buf + 1))
                {
                  v25 = (unint64_t *)(*((_QWORD *)&buf + 1) + 8);
                  do
                    v26 = __ldaxr(v25);
                  while (__stlxr(v26 - 1, v25));
                  if (!v26)
                  {
                    ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
                    std::__shared_weak_count::__release_weak(v24);
                  }
                }
                goto LABEL_44;
              }
              v23 = 5;
            }
            (*(void (**)(void))(*(_QWORD *)v22 + 8 * v23))();
            goto LABEL_39;
          }
          v18 = 5;
        }
        (*(void (**)(void))(*v17 + 8 * v18))();
        goto LABEL_27;
      }
      v15 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)&v39 + 1) + 16))(*((_QWORD *)&v39 + 1));
    }
    v36 = (_BYTE *)v15;
    goto LABEL_22;
  }
  v16 = *v5;
  if (os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf) = 0;
    _os_log_error_impl(&dword_216897000, v16, OS_LOG_TYPE_ERROR, "Preferred Formatter is NULL in answerIncomingCall", (uint8_t *)&buf, 2u);
  }
LABEL_44:
  v27 = v34;
  if (v34)
  {
    v28 = (unint64_t *)&v34->__shared_owners_;
    do
      v29 = __ldaxr(v28);
    while (__stlxr(v29 - 1, v28));
    if (!v29)
    {
      ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
      std::__shared_weak_count::__release_weak(v27);
    }
  }
}

void sub_216A3C290(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  uint64_t v13;
  uint64_t v15;

  v15 = a13;
  a13 = 0;
  if (v15)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&a13, v15);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a10);
  EurekaVoiceRequestMessage::~EurekaVoiceRequestMessage((EurekaVoiceRequestMessage *)(v13 - 128));
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v13 - 176);
  _Unwind_Resume(a1);
}

void EurekaCallCommandDriver::mergeCalls(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  os_log_t *v5;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  uint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  unint64_t *p_shared_owners;
  unint64_t v23;
  __int128 *v24;
  uint64_t v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  std::__shared_weak_count *v29;
  unint64_t *v30;
  unint64_t v31;
  _BYTE v32[8];
  uint64_t v33;
  void *v34[51];
  std::string __p;
  uint64_t v36;
  std::__shared_weak_count *v37;
  _BYTE v38[24];
  _BYTE *v39;
  uint8_t buf[16];
  __int128 v41;
  __int128 v42;
  __int128 v43;
  uint64_t v44;

  v44 = *MEMORY[0x24BDAC8D0];
  v4 = *(unsigned int *)(a2 + 252);
  v5 = (os_log_t *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 112) + 16))(*(_QWORD *)(a1 + 112), v4);
  v36 = 0;
  v37 = 0;
  EurekaCallCommandDriver::getPreferredFormatterForSim(&v36, a1, v4);
  v6 = v36;
  if (v36)
  {
    v42 = 0u;
    v43 = 0u;
    *(_OWORD *)buf = 0u;
    v41 = 0u;
    CallInfo::CallInfo((CallInfo *)v34, (const CallInfo *)a2);
    if (*(char *)(a2 + 431) < 0)
      std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)(a2 + 408), *(_QWORD *)(a2 + 416));
    else
      __p = *(std::string *)(a2 + 408);
    (*(void (**)(uint8_t *__return_ptr, uint64_t, void **))(*(_QWORD *)v6 + 72))(buf, v6, v34);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    CallInfo::~CallInfo(v34);
    v10 = *(_QWORD *)buf;
    v9 = *(std::__shared_weak_count **)&buf[8];
    if (!*(_QWORD *)&buf[8])
      goto LABEL_14;
    v11 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
    do
      v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
    do
      v13 = __ldaxr(v11);
    while (__stlxr(v13 - 1, v11));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
      if (!v10)
        goto LABEL_39;
    }
    else
    {
LABEL_14:
      if (!v10)
        goto LABEL_39;
    }
    v14 = *(std::__shared_weak_count **)&buf[8];
    if ((v4 - 1) >= 3)
      LODWORD(v4) = 0;
    if (*(_QWORD *)&buf[8])
    {
      v15 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
      do
        v16 = __ldxr(v15);
      while (__stxr(v16 + 1, v15));
    }
    v17 = qmi::ClientRouter::get();
    qmi::ClientRouter::SendProxy::SendProxy<qmi::MutableMessageBase>((uint64_t)v32, v4, v17);
    *(_DWORD *)(v33 + 16) = v43;
    v18 = *((_QWORD *)&v42 + 1);
    if (*((_QWORD *)&v42 + 1))
    {
      if (*((__int128 **)&v42 + 1) == &v41)
      {
        v39 = v38;
        (*(void (**)(_QWORD, _BYTE *))(**((_QWORD **)&v42 + 1) + 24))(*((_QWORD *)&v42 + 1), v38);
LABEL_27:
        qmi::ClientRouter::SendProxy::callback<std::function<void ()(qmi::ResponseBase const&)>>((uint64_t)v32, (uint64_t)v38);
        v20 = v39;
        if (v39 == v38)
        {
          v21 = 4;
          v20 = v38;
        }
        else
        {
          if (!v39)
          {
LABEL_32:
            v8 = v33;
            v33 = 0;
            if (v8)
              std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v33, v8);
            if (v14)
            {
              p_shared_owners = (unint64_t *)&v14->__shared_owners_;
              do
                v23 = __ldaxr(p_shared_owners);
              while (__stlxr(v23 - 1, p_shared_owners));
              if (!v23)
              {
                ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
                std::__shared_weak_count::__release_weak(v14);
              }
            }
LABEL_39:
            v24 = (__int128 *)*((_QWORD *)&v42 + 1);
            if (*((__int128 **)&v42 + 1) == &v41)
            {
              v25 = 4;
              v24 = &v41;
            }
            else
            {
              if (!*((_QWORD *)&v42 + 1))
              {
LABEL_44:
                v26 = *(std::__shared_weak_count **)&buf[8];
                if (*(_QWORD *)&buf[8])
                {
                  v27 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
                  do
                    v28 = __ldaxr(v27);
                  while (__stlxr(v28 - 1, v27));
                  if (!v28)
                  {
                    ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
                    std::__shared_weak_count::__release_weak(v26);
                  }
                }
                goto LABEL_49;
              }
              v25 = 5;
            }
            (*(void (**)(__int128 *, uint64_t))(*(_QWORD *)v24 + 8 * v25))(v24, v8);
            goto LABEL_44;
          }
          v21 = 5;
        }
        (*(void (**)(_QWORD *, uint64_t))(*v20 + 8 * v21))(v20, v19);
        goto LABEL_32;
      }
      v18 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)&v42 + 1) + 16))(*((_QWORD *)&v42 + 1));
    }
    v39 = (_BYTE *)v18;
    goto LABEL_27;
  }
  v7 = *v5;
  if (os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl(&dword_216897000, v7, OS_LOG_TYPE_ERROR, "Preferred Formatter is NULL in mergeCalls", buf, 2u);
  }
LABEL_49:
  v29 = v37;
  if (v37)
  {
    v30 = (unint64_t *)&v37->__shared_owners_;
    do
      v31 = __ldaxr(v30);
    while (__stlxr(v31 - 1, v30));
    if (!v31)
    {
      ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
      std::__shared_weak_count::__release_weak(v29);
    }
  }
}

void sub_216A3C69C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  uint64_t v5;
  va_list va;

  va_start(va, a5);
  CallInfo::~CallInfo((void **)va);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v5 - 176);
  _Unwind_Resume(a1);
}

void CallOperationContext::~CallOperationContext(void **this)
{
  if (*((char *)this + 431) < 0)
    operator delete(this[51]);
  CallInfo::~CallInfo(this);
}

void EurekaCallCommandDriver::createPrivateConversation(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  os_log_t *v5;
  NSObject *v6;
  uint64_t v7;
  NSObject *v8;
  std::__shared_weak_count *v9;
  uint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  NSObject *v19;
  uint64_t v20;
  uint64_t v21;
  uint8_t *v22;
  uint64_t v23;
  unint64_t *p_shared_owners;
  unint64_t v25;
  __int128 *v26;
  uint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  _BYTE v34[8];
  uint64_t v35;
  void *v36[51];
  std::string __p;
  uint64_t v38;
  std::__shared_weak_count *v39;
  uint8_t v40[24];
  uint8_t *v41;
  uint8_t buf[16];
  __int128 v43;
  __int128 v44;
  __int128 v45;
  uint64_t v46;

  v46 = *MEMORY[0x24BDAC8D0];
  v4 = *(unsigned int *)(a2 + 252);
  v5 = (os_log_t *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 112) + 16))(*(_QWORD *)(a1 + 112), v4);
  v6 = *v5;
  if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_216897000, v6, OS_LOG_TYPE_DEFAULT, "#I Creating a private conversation.", buf, 2u);
  }
  v38 = 0;
  v39 = 0;
  EurekaCallCommandDriver::getPreferredFormatterForSim(&v38, a1, v4);
  v7 = v38;
  if (v38)
  {
    v44 = 0u;
    v45 = 0u;
    *(_OWORD *)buf = 0u;
    v43 = 0u;
    CallInfo::CallInfo((CallInfo *)v36, (const CallInfo *)a2);
    if (*(char *)(a2 + 431) < 0)
      std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)(a2 + 408), *(_QWORD *)(a2 + 416));
    else
      __p = *(std::string *)(a2 + 408);
    (*(void (**)(uint8_t *__return_ptr, uint64_t, void **))(*(_QWORD *)v7 + 80))(buf, v7, v36);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    CallInfo::~CallInfo(v36);
    v10 = *(_QWORD *)buf;
    v9 = *(std::__shared_weak_count **)&buf[8];
    if (!*(_QWORD *)&buf[8])
      goto LABEL_16;
    v11 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
    do
      v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
    do
      v13 = __ldaxr(v11);
    while (__stlxr(v13 - 1, v11));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
      if (v10)
      {
LABEL_17:
        v14 = *(std::__shared_weak_count **)&buf[8];
        if ((v4 - 1) >= 3)
          LODWORD(v4) = 0;
        if (*(_QWORD *)&buf[8])
        {
          v15 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
          do
            v16 = __ldxr(v15);
          while (__stxr(v16 + 1, v15));
        }
        v17 = qmi::ClientRouter::get();
        qmi::ClientRouter::SendProxy::SendProxy<qmi::MutableMessageBase>((uint64_t)v34, v4, v17);
        *(_DWORD *)(v35 + 16) = v45;
        v18 = *((_QWORD *)&v44 + 1);
        if (*((_QWORD *)&v44 + 1))
        {
          if (*((__int128 **)&v44 + 1) == &v43)
          {
            v41 = v40;
            (*(void (**)(_QWORD, uint8_t *))(**((_QWORD **)&v44 + 1) + 24))(*((_QWORD *)&v44 + 1), v40);
LABEL_30:
            qmi::ClientRouter::SendProxy::callback<std::function<void ()(qmi::ResponseBase const&)>>((uint64_t)v34, (uint64_t)v40);
            v22 = v41;
            if (v41 == v40)
            {
              v23 = 4;
              v22 = v40;
            }
            else
            {
              if (!v41)
              {
LABEL_35:
                v20 = v35;
                v35 = 0;
                if (v20)
                  std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v35, v20);
                if (v14)
                {
                  p_shared_owners = (unint64_t *)&v14->__shared_owners_;
                  do
                    v25 = __ldaxr(p_shared_owners);
                  while (__stlxr(v25 - 1, p_shared_owners));
                  if (!v25)
                  {
                    ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
                    std::__shared_weak_count::__release_weak(v14);
                  }
                }
                goto LABEL_42;
              }
              v23 = 5;
            }
            (*(void (**)(uint8_t *, uint64_t))(*(_QWORD *)v22 + 8 * v23))(v22, v21);
            goto LABEL_35;
          }
          v18 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)&v44 + 1) + 16))(*((_QWORD *)&v44 + 1));
        }
        v41 = (uint8_t *)v18;
        goto LABEL_30;
      }
    }
    else
    {
LABEL_16:
      if (v10)
        goto LABEL_17;
    }
    v19 = *v5;
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v40 = 0;
      _os_log_error_impl(&dword_216897000, v19, OS_LOG_TYPE_ERROR, "Failed to create private conversation!", v40, 2u);
    }
LABEL_42:
    v26 = (__int128 *)*((_QWORD *)&v44 + 1);
    if (*((__int128 **)&v44 + 1) == &v43)
    {
      v27 = 4;
      v26 = &v43;
    }
    else
    {
      if (!*((_QWORD *)&v44 + 1))
      {
LABEL_47:
        v28 = *(std::__shared_weak_count **)&buf[8];
        if (*(_QWORD *)&buf[8])
        {
          v29 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
          do
            v30 = __ldaxr(v29);
          while (__stlxr(v30 - 1, v29));
          if (!v30)
          {
            ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
            std::__shared_weak_count::__release_weak(v28);
          }
        }
        goto LABEL_52;
      }
      v27 = 5;
    }
    (*(void (**)(__int128 *, uint64_t))(*(_QWORD *)v26 + 8 * v27))(v26, v20);
    goto LABEL_47;
  }
  v8 = *v5;
  if (os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl(&dword_216897000, v8, OS_LOG_TYPE_ERROR, "Preferred Formatter is NULL in createPrivateConversation", buf, 2u);
  }
LABEL_52:
  v31 = v39;
  if (v39)
  {
    v32 = (unint64_t *)&v39->__shared_owners_;
    do
      v33 = __ldaxr(v32);
    while (__stlxr(v33 - 1, v32));
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
      std::__shared_weak_count::__release_weak(v31);
    }
  }
}

void sub_216A3CB64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  uint64_t v5;
  va_list va;

  va_start(va, a5);
  CallInfo::~CallInfo((void **)va);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v5 - 192);
  _Unwind_Resume(a1);
}

void EurekaCallCommandDriver::holdUnHoldActiveCall(uint64_t a1, const void **a2)
{
  uint64_t v4;
  uint64_t v5;
  os_log_t *v6;
  uint64_t v7;
  __int128 v8;
  unint64_t *v9;
  unint64_t v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  NSObject *v17;
  __int128 *v18;
  NSObject *v19;
  uint8_t *v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t *p_shared_owners;
  unint64_t v24;
  __int128 *v25;
  uint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  _BYTE v33[8];
  uint64_t v34;
  const void *v35;
  uint64_t v36;
  std::__shared_weak_count *v37;
  const void *v38;
  const void *v39;
  _OWORD v40[15];
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  uint64_t v51;
  uint8_t buf[4];
  __int128 *v53;
  uint8_t *v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  uint64_t v59;

  v59 = *MEMORY[0x24BDAC8D0];
  v51 = 0;
  v49 = 0u;
  v50 = 0u;
  v47 = 0u;
  v48 = 0u;
  v45 = 0u;
  v46 = 0u;
  v43 = 0u;
  v44 = 0u;
  v41 = 0u;
  v42 = 0u;
  memset(v40, 0, sizeof(v40));
  CallInfo::CallInfo((CallInfo *)v40);
  v4 = *(_QWORD *)(a1 + 120);
  ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::SharedRef(&v39, a2);
  LOBYTE(v4) = (*(uint64_t (**)(uint64_t, const void **, _OWORD *))(*(_QWORD *)v4 + 296))(v4, &v39, v40);
  ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::~SharedRef(&v39);
  if ((v4 & 1) != 0)
  {
    v5 = HIDWORD(v41);
    v6 = (os_log_t *)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 112) + 16))(*(_QWORD *)(a1 + 112), HIDWORD(v41));
    v36 = 0;
    v37 = 0;
    EurekaCallCommandDriver::getPreferredFormatterForSim(&v36, a1, v5);
    v7 = v36;
    if (!v36)
    {
      v19 = *v6;
      if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v55) = 0;
        _os_log_error_impl(&dword_216897000, v19, OS_LOG_TYPE_ERROR, "Preferred Formatter is NULL in holdUnHoldActiveCall", (uint8_t *)&v55, 2u);
      }
      goto LABEL_52;
    }
    v57 = 0u;
    v58 = 0u;
    v55 = 0u;
    v56 = 0u;
    ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::SharedRef(&v35, a2);
    (*(void (**)(__int128 *__return_ptr, uint64_t, const void **, uint64_t))(*(_QWORD *)v7 + 32))(&v55, v7, &v35, v5);
    ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::~SharedRef(&v35);
    v8 = v55;
    if (!*((_QWORD *)&v55 + 1))
      goto LABEL_8;
    v9 = (unint64_t *)(*((_QWORD *)&v55 + 1) + 8);
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
    do
      v11 = __ldaxr(v9);
    while (__stlxr(v11 - 1, v9));
    if (!v11)
    {
      (*(void (**)(_QWORD))(**((_QWORD **)&v8 + 1) + 16))(*((_QWORD *)&v8 + 1));
      std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v8 + 1));
      if (!(_QWORD)v8)
        goto LABEL_42;
    }
    else
    {
LABEL_8:
      if (!(_QWORD)v8)
        goto LABEL_42;
    }
    v12 = (std::__shared_weak_count *)*((_QWORD *)&v55 + 1);
    if ((v5 - 1) >= 3)
      LODWORD(v5) = 0;
    if (*((_QWORD *)&v55 + 1))
    {
      v13 = (unint64_t *)(*((_QWORD *)&v55 + 1) + 8);
      do
        v14 = __ldxr(v13);
      while (__stxr(v14 + 1, v13));
    }
    v15 = qmi::ClientRouter::get();
    qmi::ClientRouter::SendProxy::SendProxy<qmi::MutableMessageBase>((uint64_t)v33, v5, v15);
    *(_DWORD *)(v34 + 16) = v58;
    v16 = *((_QWORD *)&v57 + 1);
    if (*((_QWORD *)&v57 + 1))
    {
      if (*((__int128 **)&v57 + 1) == &v56)
      {
        v54 = buf;
        (*(void (**)(void))(**((_QWORD **)&v57 + 1) + 24))();
LABEL_30:
        qmi::ClientRouter::SendProxy::callback<std::function<void ()(qmi::ResponseBase const&)>>((uint64_t)v33, (uint64_t)buf);
        v20 = v54;
        if (v54 == buf)
        {
          v21 = 4;
          v20 = buf;
        }
        else
        {
          if (!v54)
          {
LABEL_35:
            v22 = v34;
            v34 = 0;
            if (v22)
              std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v34, v22);
            if (v12)
            {
              p_shared_owners = (unint64_t *)&v12->__shared_owners_;
              do
                v24 = __ldaxr(p_shared_owners);
              while (__stlxr(v24 - 1, p_shared_owners));
              if (!v24)
              {
                ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
                std::__shared_weak_count::__release_weak(v12);
              }
            }
LABEL_42:
            v25 = (__int128 *)*((_QWORD *)&v57 + 1);
            if (*((__int128 **)&v57 + 1) == &v56)
            {
              v26 = 4;
              v25 = &v56;
            }
            else
            {
              if (!*((_QWORD *)&v57 + 1))
              {
LABEL_47:
                v27 = (std::__shared_weak_count *)*((_QWORD *)&v55 + 1);
                if (*((_QWORD *)&v55 + 1))
                {
                  v28 = (unint64_t *)(*((_QWORD *)&v55 + 1) + 8);
                  do
                    v29 = __ldaxr(v28);
                  while (__stlxr(v29 - 1, v28));
                  if (!v29)
                  {
                    ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
                    std::__shared_weak_count::__release_weak(v27);
                  }
                }
LABEL_52:
                v30 = v37;
                if (v37)
                {
                  v31 = (unint64_t *)&v37->__shared_owners_;
                  do
                    v32 = __ldaxr(v31);
                  while (__stlxr(v32 - 1, v31));
                  if (!v32)
                  {
                    ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
                    std::__shared_weak_count::__release_weak(v30);
                  }
                }
                goto LABEL_57;
              }
              v26 = 5;
            }
            (*(void (**)(void))(*(_QWORD *)v25 + 8 * v26))();
            goto LABEL_47;
          }
          v21 = 5;
        }
        (*(void (**)(void))(*(_QWORD *)v20 + 8 * v21))();
        goto LABEL_35;
      }
      v16 = (*(uint64_t (**)(void))(**((_QWORD **)&v57 + 1) + 16))();
    }
    v54 = (uint8_t *)v16;
    goto LABEL_30;
  }
  v17 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
  {
    ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::SharedRef(&v38, a2);
    printUuid();
    if ((SBYTE7(v56) & 0x80u) == 0)
      v18 = &v55;
    else
      v18 = (__int128 *)v55;
    *(_DWORD *)buf = 136315138;
    v53 = v18;
    _os_log_error_impl(&dword_216897000, v17, OS_LOG_TYPE_ERROR, "Could not find call with UUID %s when trying to hold/unhold", buf, 0xCu);
    if (SBYTE7(v56) < 0)
      operator delete((void *)v55);
    ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::~SharedRef(&v38);
  }
LABEL_57:
  CallInfo::~CallInfo((void **)v40);
}

void sub_216A3D064(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  va_list va;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  va_list va1;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  va_list va2;

  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v6 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v12 = va_arg(va2, _QWORD);
  v14 = va_arg(va2, _QWORD);
  v15 = va_arg(va2, _QWORD);
  v16 = va_arg(va2, _QWORD);
  v5 = v10;
  v10 = 0;
  if (v5)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v2, v5);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va);
  EurekaVoiceRequestMessage::~EurekaVoiceRequestMessage((EurekaVoiceRequestMessage *)(v3 - 144));
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  CallInfo::~CallInfo((void **)va2);
  _Unwind_Resume(a1);
}

void EurekaCallCommandDriver::swapCalls(uint64_t a1, const void **a2)
{
  uint64_t v4;
  uint64_t v5;
  os_log_t *v6;
  uint64_t v7;
  __int128 v8;
  unint64_t *v9;
  unint64_t v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  NSObject *v17;
  __int128 *v18;
  NSObject *v19;
  uint8_t *v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t *p_shared_owners;
  unint64_t v24;
  __int128 *v25;
  uint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  _BYTE v33[8];
  uint64_t v34;
  const void *v35;
  uint64_t v36;
  std::__shared_weak_count *v37;
  const void *v38;
  const void *v39;
  _OWORD v40[15];
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  uint64_t v51;
  uint8_t buf[4];
  __int128 *v53;
  uint8_t *v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  uint64_t v59;

  v59 = *MEMORY[0x24BDAC8D0];
  v51 = 0;
  v49 = 0u;
  v50 = 0u;
  v47 = 0u;
  v48 = 0u;
  v45 = 0u;
  v46 = 0u;
  v43 = 0u;
  v44 = 0u;
  v41 = 0u;
  v42 = 0u;
  memset(v40, 0, sizeof(v40));
  CallInfo::CallInfo((CallInfo *)v40);
  v4 = *(_QWORD *)(a1 + 120);
  ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::SharedRef(&v39, a2);
  LOBYTE(v4) = (*(uint64_t (**)(uint64_t, const void **, _OWORD *))(*(_QWORD *)v4 + 296))(v4, &v39, v40);
  ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::~SharedRef(&v39);
  if ((v4 & 1) != 0)
  {
    v5 = HIDWORD(v41);
    v6 = (os_log_t *)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 112) + 16))(*(_QWORD *)(a1 + 112), HIDWORD(v41));
    v36 = 0;
    v37 = 0;
    EurekaCallCommandDriver::getPreferredFormatterForSim(&v36, a1, v5);
    v7 = v36;
    if (!v36)
    {
      v19 = *v6;
      if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v55) = 0;
        _os_log_error_impl(&dword_216897000, v19, OS_LOG_TYPE_ERROR, "Preferred Formatter is NULL in swapCalls", (uint8_t *)&v55, 2u);
      }
      goto LABEL_52;
    }
    v57 = 0u;
    v58 = 0u;
    v55 = 0u;
    v56 = 0u;
    ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::SharedRef(&v35, a2);
    (*(void (**)(__int128 *__return_ptr, uint64_t, const void **, uint64_t))(*(_QWORD *)v7 + 64))(&v55, v7, &v35, v5);
    ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::~SharedRef(&v35);
    v8 = v55;
    if (!*((_QWORD *)&v55 + 1))
      goto LABEL_8;
    v9 = (unint64_t *)(*((_QWORD *)&v55 + 1) + 8);
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
    do
      v11 = __ldaxr(v9);
    while (__stlxr(v11 - 1, v9));
    if (!v11)
    {
      (*(void (**)(_QWORD))(**((_QWORD **)&v8 + 1) + 16))(*((_QWORD *)&v8 + 1));
      std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v8 + 1));
      if (!(_QWORD)v8)
        goto LABEL_42;
    }
    else
    {
LABEL_8:
      if (!(_QWORD)v8)
        goto LABEL_42;
    }
    v12 = (std::__shared_weak_count *)*((_QWORD *)&v55 + 1);
    if ((v5 - 1) >= 3)
      LODWORD(v5) = 0;
    if (*((_QWORD *)&v55 + 1))
    {
      v13 = (unint64_t *)(*((_QWORD *)&v55 + 1) + 8);
      do
        v14 = __ldxr(v13);
      while (__stxr(v14 + 1, v13));
    }
    v15 = qmi::ClientRouter::get();
    qmi::ClientRouter::SendProxy::SendProxy<qmi::MutableMessageBase>((uint64_t)v33, v5, v15);
    *(_DWORD *)(v34 + 16) = v58;
    v16 = *((_QWORD *)&v57 + 1);
    if (*((_QWORD *)&v57 + 1))
    {
      if (*((__int128 **)&v57 + 1) == &v56)
      {
        v54 = buf;
        (*(void (**)(void))(**((_QWORD **)&v57 + 1) + 24))();
LABEL_30:
        qmi::ClientRouter::SendProxy::callback<std::function<void ()(qmi::ResponseBase const&)>>((uint64_t)v33, (uint64_t)buf);
        v20 = v54;
        if (v54 == buf)
        {
          v21 = 4;
          v20 = buf;
        }
        else
        {
          if (!v54)
          {
LABEL_35:
            v22 = v34;
            v34 = 0;
            if (v22)
              std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v34, v22);
            if (v12)
            {
              p_shared_owners = (unint64_t *)&v12->__shared_owners_;
              do
                v24 = __ldaxr(p_shared_owners);
              while (__stlxr(v24 - 1, p_shared_owners));
              if (!v24)
              {
                ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
                std::__shared_weak_count::__release_weak(v12);
              }
            }
LABEL_42:
            v25 = (__int128 *)*((_QWORD *)&v57 + 1);
            if (*((__int128 **)&v57 + 1) == &v56)
            {
              v26 = 4;
              v25 = &v56;
            }
            else
            {
              if (!*((_QWORD *)&v57 + 1))
              {
LABEL_47:
                v27 = (std::__shared_weak_count *)*((_QWORD *)&v55 + 1);
                if (*((_QWORD *)&v55 + 1))
                {
                  v28 = (unint64_t *)(*((_QWORD *)&v55 + 1) + 8);
                  do
                    v29 = __ldaxr(v28);
                  while (__stlxr(v29 - 1, v28));
                  if (!v29)
                  {
                    ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
                    std::__shared_weak_count::__release_weak(v27);
                  }
                }
LABEL_52:
                v30 = v37;
                if (v37)
                {
                  v31 = (unint64_t *)&v37->__shared_owners_;
                  do
                    v32 = __ldaxr(v31);
                  while (__stlxr(v32 - 1, v31));
                  if (!v32)
                  {
                    ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
                    std::__shared_weak_count::__release_weak(v30);
                  }
                }
                goto LABEL_57;
              }
              v26 = 5;
            }
            (*(void (**)(void))(*(_QWORD *)v25 + 8 * v26))();
            goto LABEL_47;
          }
          v21 = 5;
        }
        (*(void (**)(void))(*(_QWORD *)v20 + 8 * v21))();
        goto LABEL_35;
      }
      v16 = (*(uint64_t (**)(void))(**((_QWORD **)&v57 + 1) + 16))();
    }
    v54 = (uint8_t *)v16;
    goto LABEL_30;
  }
  v17 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
  {
    ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::SharedRef(&v38, a2);
    printUuid();
    if ((SBYTE7(v56) & 0x80u) == 0)
      v18 = &v55;
    else
      v18 = (__int128 *)v55;
    *(_DWORD *)buf = 136315138;
    v53 = v18;
    _os_log_error_impl(&dword_216897000, v17, OS_LOG_TYPE_ERROR, "Could not find call with UUID %s when trying to swap", buf, 0xCu);
    if (SBYTE7(v56) < 0)
      operator delete((void *)v55);
    ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::~SharedRef(&v38);
  }
LABEL_57:
  CallInfo::~CallInfo((void **)v40);
}

void sub_216A3D57C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  va_list va;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  va_list va1;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  va_list va2;

  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v6 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v12 = va_arg(va2, _QWORD);
  v14 = va_arg(va2, _QWORD);
  v15 = va_arg(va2, _QWORD);
  v16 = va_arg(va2, _QWORD);
  v5 = v10;
  v10 = 0;
  if (v5)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v2, v5);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va);
  EurekaVoiceRequestMessage::~EurekaVoiceRequestMessage((EurekaVoiceRequestMessage *)(v3 - 144));
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  CallInfo::~CallInfo((void **)va2);
  _Unwind_Resume(a1);
}

void EurekaCallCommandDriver::endHeldCalls(EurekaCallCommandDriver *this)
{
  uint64_t v2;
  unsigned int v3;
  BOOL v4;
  int v5;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;
  os_log_t *v17;
  uint64_t v18;
  std::__shared_weak_count *v19;
  uint64_t v20;
  unint64_t *v21;
  unint64_t v22;
  unint64_t v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  NSObject *v29;
  uint64_t v30;
  _QWORD *v31;
  uint64_t v32;
  unint64_t *p_shared_owners;
  unint64_t v34;
  __int128 *v35;
  uint64_t v36;
  std::__shared_weak_count *v37;
  unint64_t *v38;
  unint64_t v39;
  std::__shared_weak_count *v40;
  unint64_t *v41;
  unint64_t v42;
  _BYTE v43[8];
  uint64_t v44;
  uint64_t v45;
  std::__shared_weak_count *v46;
  _OWORD v47[2];
  std::string v48[4];
  __int128 v49;
  __int128 v50;
  _BYTE v51[112];
  std::string v52[2];
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  _BYTE v57[24];
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  _BYTE v61[24];
  _BYTE *v62;
  uint8_t buf[16];
  __int128 v64;
  __int128 v65;
  __int128 v66;
  uint64_t v67;

  v67 = *MEMORY[0x24BDAC8D0];
  v58 = 0;
  v59 = 0;
  v60 = 0;
  (*(void (**)(uint64_t *__return_ptr))(**((_QWORD **)this + 15) + 312))(&v58);
  v56 = 0u;
  memset(v57, 0, sizeof(v57));
  v54 = 0u;
  v55 = 0u;
  v53 = 0u;
  memset(v52, 0, sizeof(v52));
  v50 = 0u;
  memset(v51, 0, sizeof(v51));
  v49 = 0u;
  memset(v48, 0, sizeof(v48));
  memset(v47, 0, sizeof(v47));
  CallInfo::CallInfo((CallInfo *)v47);
  v2 = v58;
  if (v58 != v59)
  {
    while (1)
    {
      v3 = *(unsigned __int8 *)(v2 + 68);
      v4 = v3 > 8;
      v5 = (1 << v3) & 0x114;
      if (v4 || v5 == 0)
        break;
      v2 += 408;
      if (v2 == v59)
        goto LABEL_9;
    }
    ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::operator=((const void **)v47, (const void **)v2);
    std::string::operator=((std::string *)((char *)v47 + 8), (const std::string *)(v2 + 8));
    std::string::operator=(v48, (const std::string *)(v2 + 32));
    *(_OWORD *)&v48[1].__r_.__value_.__l.__data_ = *(_OWORD *)(v2 + 56);
    v7 = *(_OWORD *)(v2 + 72);
    v8 = *(_OWORD *)(v2 + 88);
    v9 = *(_OWORD *)(v2 + 104);
    *(std::string::size_type *)((char *)&v48[3].__r_.__value_.__r.__words[1] + 5) = *(_QWORD *)(v2 + 117);
    *(_OWORD *)&v48[3].__r_.__value_.__l.__data_ = v9;
    *(_OWORD *)&v48[2].__r_.__value_.__r.__words[1] = v8;
    *(_OWORD *)&v48[1].__r_.__value_.__r.__words[2] = v7;
    std::string::operator=((std::string *)&v49, (const std::string *)(v2 + 128));
    DWORD2(v50) = *(_DWORD *)(v2 + 152);
    std::string::operator=((std::string *)v51, (const std::string *)(v2 + 160));
    v10 = *(_OWORD *)(v2 + 184);
    *(_OWORD *)&v51[33] = *(_OWORD *)(v2 + 193);
    *(_OWORD *)&v51[24] = v10;
    std::__optional_storage_base<std::vector<unsigned int>,false>::__assign_from[abi:ne180100]<std::__optional_copy_assign_base<std::vector<unsigned int>,false> const&>((uint64_t)&v51[56], v2 + 216);
    v11 = *(_OWORD *)(v2 + 248);
    v51[104] = *(_BYTE *)(v2 + 264);
    *(_OWORD *)&v51[88] = v11;
    std::string::operator=(v52, (const std::string *)(v2 + 272));
    std::string::operator=(&v52[1], (const std::string *)(v2 + 296));
    v12 = *(_OWORD *)(v2 + 352);
    v13 = *(_OWORD *)(v2 + 368);
    v14 = *(_OWORD *)(v2 + 384);
    *(_QWORD *)&v57[13] = *(_QWORD *)(v2 + 397);
    v15 = *(_OWORD *)(v2 + 336);
    v53 = *(_OWORD *)(v2 + 320);
    v54 = v15;
    v56 = v13;
    *(_OWORD *)v57 = v14;
    v55 = v12;
  }
LABEL_9:
  v16 = *(unsigned int *)&v51[92];
  v17 = (os_log_t *)(*(uint64_t (**)(_QWORD, _QWORD))(**((_QWORD **)this + 14) + 16))(*((_QWORD *)this + 14), *(unsigned int *)&v51[92]);
  v45 = 0;
  v46 = 0;
  EurekaCallCommandDriver::getPreferredFormatterForSim(&v45, (uint64_t)this, v16);
  if (v45)
  {
    v65 = 0u;
    v66 = 0u;
    *(_OWORD *)buf = 0u;
    v64 = 0u;
    (*(void (**)(uint8_t *__return_ptr))(*(_QWORD *)v45 + 96))(buf);
    v20 = *(_QWORD *)buf;
    v19 = *(std::__shared_weak_count **)&buf[8];
    if (!*(_QWORD *)&buf[8])
      goto LABEL_15;
    v21 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
    do
      v22 = __ldxr(v21);
    while (__stxr(v22 + 1, v21));
    do
      v23 = __ldaxr(v21);
    while (__stlxr(v23 - 1, v21));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
      if (!v20)
        goto LABEL_42;
    }
    else
    {
LABEL_15:
      if (!v20)
        goto LABEL_42;
    }
    v24 = *(std::__shared_weak_count **)&buf[8];
    if ((v16 - 1) >= 3)
      LODWORD(v16) = 0;
    if (*(_QWORD *)&buf[8])
    {
      v25 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
      do
        v26 = __ldxr(v25);
      while (__stxr(v26 + 1, v25));
    }
    v27 = qmi::ClientRouter::get();
    qmi::ClientRouter::SendProxy::SendProxy<qmi::MutableMessageBase>((uint64_t)v43, v16, v27);
    *(_DWORD *)(v44 + 16) = v66;
    v28 = *((_QWORD *)&v65 + 1);
    if (*((_QWORD *)&v65 + 1))
    {
      if (*((__int128 **)&v65 + 1) == &v64)
      {
        v62 = v61;
        (*(void (**)(_QWORD, _BYTE *))(**((_QWORD **)&v65 + 1) + 24))(*((_QWORD *)&v65 + 1), v61);
LABEL_30:
        qmi::ClientRouter::SendProxy::callback<std::function<void ()(qmi::ResponseBase const&)>>((uint64_t)v43, (uint64_t)v61);
        v31 = v62;
        if (v62 == v61)
        {
          v32 = 4;
          v31 = v61;
        }
        else
        {
          if (!v62)
          {
LABEL_35:
            v18 = v44;
            v44 = 0;
            if (v18)
              std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v44, v18);
            if (v24)
            {
              p_shared_owners = (unint64_t *)&v24->__shared_owners_;
              do
                v34 = __ldaxr(p_shared_owners);
              while (__stlxr(v34 - 1, p_shared_owners));
              if (!v34)
              {
                ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
                std::__shared_weak_count::__release_weak(v24);
              }
            }
LABEL_42:
            v35 = (__int128 *)*((_QWORD *)&v65 + 1);
            if (*((__int128 **)&v65 + 1) == &v64)
            {
              v36 = 4;
              v35 = &v64;
            }
            else
            {
              if (!*((_QWORD *)&v65 + 1))
              {
LABEL_47:
                v37 = *(std::__shared_weak_count **)&buf[8];
                if (*(_QWORD *)&buf[8])
                {
                  v38 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
                  do
                    v39 = __ldaxr(v38);
                  while (__stlxr(v39 - 1, v38));
                  if (!v39)
                  {
                    ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
                    std::__shared_weak_count::__release_weak(v37);
                  }
                }
                goto LABEL_52;
              }
              v36 = 5;
            }
            (*(void (**)(__int128 *, uint64_t))(*(_QWORD *)v35 + 8 * v36))(v35, v18);
            goto LABEL_47;
          }
          v32 = 5;
        }
        (*(void (**)(_QWORD *, uint64_t))(*v31 + 8 * v32))(v31, v30);
        goto LABEL_35;
      }
      v28 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)&v65 + 1) + 16))(*((_QWORD *)&v65 + 1));
    }
    v62 = (_BYTE *)v28;
    goto LABEL_30;
  }
  v29 = *v17;
  if (os_log_type_enabled(*v17, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl(&dword_216897000, v29, OS_LOG_TYPE_ERROR, "Preferred Formatter is NULL in endHeldCalls", buf, 2u);
  }
LABEL_52:
  v40 = v46;
  if (v46)
  {
    v41 = (unint64_t *)&v46->__shared_owners_;
    do
      v42 = __ldaxr(v41);
    while (__stlxr(v42 - 1, v41));
    if (!v42)
    {
      ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
      std::__shared_weak_count::__release_weak(v40);
    }
  }
  CallInfo::~CallInfo((void **)v47);
  *(_QWORD *)&v47[0] = &v58;
  std::vector<CallInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)v47);
}

void sub_216A3DAEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, void *a15)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t v18;

  v18 = a12;
  a12 = 0;
  if (v18)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v15, v18);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  EurekaVoiceRequestMessage::~EurekaVoiceRequestMessage((EurekaVoiceRequestMessage *)(v16 - 128));
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  CallInfo::~CallInfo(&a15);
  a15 = (void *)(v16 - 184);
  std::vector<CallInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)&a15);
  _Unwind_Resume(a1);
}

void EurekaCallCommandDriver::endCallDueToSRVCC(uint64_t a1, const CallInfo *a2)
{
  unsigned int v3;
  os_log_t *v4;
  NSObject *v5;
  int v6;
  uint64_t v7;
  _BYTE *v8;
  uint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  uint64_t v12;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  uint64_t v20;
  char v21[8];
  uint64_t v22;
  _QWORD v23[4];
  void *v24[51];
  _QWORD v25[6];
  std::__shared_weak_count *v26;
  _QWORD aBlock[5];
  uint8_t buf[8];
  uint64_t v29;
  void (*v30)(uint64_t, uint64_t);
  void *v31;
  _QWORD *v32;
  std::__shared_weak_count *v33;
  uint64_t v34;

  v34 = *MEMORY[0x24BDAC8D0];
  v3 = *((_DWORD *)a2 + 63);
  v4 = (os_log_t *)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 112) + 16))(*(_QWORD *)(a1 + 112), v3);
  v5 = *v4;
  if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
  {
    v6 = *((_DWORD *)a2 + 23);
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v6;
    _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#I Ending call due to handover: %d", buf, 8u);
  }
  memset(v25, 0, 32);
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v25);
  v7 = MEMORY[0x24BDAC760];
  v23[0] = MEMORY[0x24BDAC760];
  v23[1] = 1174405120;
  v23[2] = ___ZN23EurekaCallCommandDriver17endCallDueToSRVCCE8CallInfo_block_invoke;
  v23[3] = &__block_descriptor_tmp_88_0;
  CallInfo::CallInfo((CallInfo *)v24, a2);
  v8 = (_BYTE *)qmi::MutableMessageBase::getTLV<vs::tlv::CallIdentifier>(v25, 1);
  ___ZN23EurekaCallCommandDriver17endCallDueToSRVCCE8CallInfo_block_invoke((uint64_t)v23, v8);
  if (v3 - 1 >= 3)
    v3 = 0;
  v9 = qmi::ClientRouter::get();
  qmi::ClientRouter::SendProxy::SendProxy<vs::EndCall::Request>((uint64_t)v21, v3, v9);
  v10 = (std::__shared_weak_count *)operator new(0x20uLL);
  v10->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v10->__shared_owners_;
  v10->__shared_weak_owners_ = 0;
  v10[1].__vftable = (std::__shared_weak_count_vtbl *)v4;
  v10->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E4888;
  v25[5] = v10 + 1;
  v26 = v10;
  v12 = v22;
  *(_QWORD *)buf = v7;
  v29 = 1174405120;
  v30 = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN23EurekaCallCommandDriver17endCallDueToSRVCCE8CallInfoE3__0EEOS1_OT__block_invoke;
  v31 = &__block_descriptor_tmp_182_1;
  v32 = &v10[1].__vftable;
  v33 = v10;
  do
    v13 = __ldxr(p_shared_owners);
  while (__stxr(v13 + 1, p_shared_owners));
  aBlock[0] = v7;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKN2vs7EndCall8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke_0;
  aBlock[3] = &unk_24D5E48D0;
  aBlock[4] = buf;
  *(_QWORD *)(v12 + 32) = _Block_copy(aBlock);
  v14 = v33;
  if (v33)
  {
    v15 = (unint64_t *)&v33->__shared_owners_;
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
  v17 = v26;
  if (v26)
  {
    v18 = (unint64_t *)&v26->__shared_owners_;
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
  v20 = v22;
  v22 = 0;
  if (v20)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v22, v20);
  CallInfo::~CallInfo(v24);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v25);
}

void sub_216A3DE58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  void **v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v15;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v12);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v13 - 200);
  v15 = a11;
  a11 = 0;
  if (v15)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&a11, v15);
  CallInfo::~CallInfo(v11);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)(v13 - 240));
  _Unwind_Resume(a1);
}

uint64_t ___ZN23EurekaCallCommandDriver17endCallDueToSRVCCE8CallInfo_block_invoke(uint64_t result, _BYTE *a2)
{
  *a2 = *(_DWORD *)(result + 124);
  return result;
}

uint64_t ___ZN23EurekaCallCommandDriver11endThisCallE8CallInfo_block_invoke(uint64_t result, _BYTE *a2)
{
  *a2 = *(_DWORD *)(result + 124);
  return result;
}

void EurekaCallCommandDriver::endAllCalls(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  unsigned int v5;
  BOOL v6;
  int v7;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  os_log_t *v18;
  __int128 v19;
  std::__shared_weak_count *v20;
  unint64_t *p_shared_owners;
  unint64_t v22;
  __int128 *v23;
  uint64_t *v24;
  uint64_t v25;
  NSObject *v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  std::__shared_weak_count *v30;
  uint64_t v31;
  unint64_t *v32;
  unint64_t v33;
  unint64_t v34;
  std::__shared_weak_count *v35;
  unint64_t *v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  __int128 *v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t *v44;
  unint64_t v45;
  uint64_t v46;
  std::__shared_weak_count *v47;
  unint64_t *v48;
  unint64_t v49;
  std::__shared_weak_count *v50;
  unint64_t *v51;
  unint64_t v52;
  _BYTE v53[8];
  uint64_t v54;
  uint64_t v55;
  std::__shared_weak_count *v56;
  _OWORD v57[2];
  std::string v58[4];
  __int128 v59;
  __int128 v60;
  _BYTE v61[112];
  std::string v62[2];
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  _BYTE v67[24];
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  __int128 v71;
  uint64_t v72;
  __int128 *v73;
  uint64_t *v74;
  __int128 v75;
  uint8_t buf[16];
  __int128 v77;
  __int128 v78;
  __int128 v79;
  uint64_t v80;

  v80 = *MEMORY[0x24BDAC8D0];
  v68 = 0;
  v69 = 0;
  v70 = 0;
  (*(void (**)(uint64_t *__return_ptr))(**(_QWORD **)(a1 + 120) + 328))(&v68);
  v66 = 0u;
  memset(v67, 0, sizeof(v67));
  v64 = 0u;
  v65 = 0u;
  v63 = 0u;
  memset(v62, 0, sizeof(v62));
  v60 = 0u;
  memset(v61, 0, sizeof(v61));
  v59 = 0u;
  memset(v58, 0, sizeof(v58));
  memset(v57, 0, sizeof(v57));
  CallInfo::CallInfo((CallInfo *)v57);
  v4 = v68;
  if (v68 != v69)
  {
    while (1)
    {
      v5 = *(unsigned __int8 *)(v4 + 68);
      v6 = v5 > 8;
      v7 = (1 << v5) & 0x114;
      if (v6 || v7 == 0)
        break;
      v4 += 408;
      if (v4 == v69)
        goto LABEL_9;
    }
    ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::operator=((const void **)v57, (const void **)v4);
    std::string::operator=((std::string *)((char *)v57 + 8), (const std::string *)(v4 + 8));
    std::string::operator=(v58, (const std::string *)(v4 + 32));
    *(_OWORD *)&v58[1].__r_.__value_.__l.__data_ = *(_OWORD *)(v4 + 56);
    v9 = *(_OWORD *)(v4 + 72);
    v10 = *(_OWORD *)(v4 + 88);
    v11 = *(_OWORD *)(v4 + 104);
    *(std::string::size_type *)((char *)&v58[3].__r_.__value_.__r.__words[1] + 5) = *(_QWORD *)(v4 + 117);
    *(_OWORD *)&v58[3].__r_.__value_.__l.__data_ = v11;
    *(_OWORD *)&v58[2].__r_.__value_.__r.__words[1] = v10;
    *(_OWORD *)&v58[1].__r_.__value_.__r.__words[2] = v9;
    std::string::operator=((std::string *)&v59, (const std::string *)(v4 + 128));
    DWORD2(v60) = *(_DWORD *)(v4 + 152);
    std::string::operator=((std::string *)v61, (const std::string *)(v4 + 160));
    v12 = *(_OWORD *)(v4 + 184);
    *(_OWORD *)&v61[33] = *(_OWORD *)(v4 + 193);
    *(_OWORD *)&v61[24] = v12;
    std::__optional_storage_base<std::vector<unsigned int>,false>::__assign_from[abi:ne180100]<std::__optional_copy_assign_base<std::vector<unsigned int>,false> const&>((uint64_t)&v61[56], v4 + 216);
    v13 = *(_OWORD *)(v4 + 248);
    v61[104] = *(_BYTE *)(v4 + 264);
    *(_OWORD *)&v61[88] = v13;
    std::string::operator=(v62, (const std::string *)(v4 + 272));
    std::string::operator=(&v62[1], (const std::string *)(v4 + 296));
    v14 = *(_OWORD *)(v4 + 352);
    v15 = *(_OWORD *)(v4 + 368);
    v16 = *(_OWORD *)(v4 + 384);
    *(_QWORD *)&v67[13] = *(_QWORD *)(v4 + 397);
    v17 = *(_OWORD *)(v4 + 336);
    v63 = *(_OWORD *)(v4 + 320);
    v64 = v17;
    v66 = v15;
    *(_OWORD *)v67 = v16;
    v65 = v14;
  }
LABEL_9:
  v55 = 0;
  v56 = 0;
  EurekaCallCommandDriver::getPreferredFormatterForSim(&v55, a1, a2);
  v18 = (os_log_t *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 112) + 16))(*(_QWORD *)(a1 + 112), a2);
  if (v55)
  {
    v79 = 0x61A8uLL;
    v77 = 0u;
    v78 = 0u;
    *(_OWORD *)buf = 0u;
    (*(void (**)(__int128 *__return_ptr, uint64_t, uint64_t))(*(_QWORD *)v55 + 104))(&v71, v55, a2);
    v19 = v71;
    v71 = 0uLL;
    v20 = *(std::__shared_weak_count **)&buf[8];
    *(_OWORD *)buf = v19;
    if (v20)
    {
      p_shared_owners = (unint64_t *)&v20->__shared_owners_;
      do
        v22 = __ldaxr(p_shared_owners);
      while (__stlxr(v22 - 1, p_shared_owners));
      if (!v22)
      {
        ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
        std::__shared_weak_count::__release_weak(v20);
      }
    }
    v23 = &v77;
    std::__function::__value_func<void ()(qmi::ResponseBase const&)>::operator=[abi:ne180100](&v77, (uint64_t)&v72);
    v79 = v75;
    v24 = v74;
    if (v74 == &v72)
    {
      v25 = 4;
      v24 = &v72;
    }
    else
    {
      if (!v74)
      {
LABEL_22:
        v27 = (std::__shared_weak_count *)*((_QWORD *)&v71 + 1);
        if (*((_QWORD *)&v71 + 1))
        {
          v28 = (unint64_t *)(*((_QWORD *)&v71 + 1) + 8);
          do
            v29 = __ldaxr(v28);
          while (__stlxr(v29 - 1, v28));
          if (!v29)
          {
            ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
            std::__shared_weak_count::__release_weak(v27);
          }
        }
        v31 = *(_QWORD *)buf;
        v30 = *(std::__shared_weak_count **)&buf[8];
        if (!*(_QWORD *)&buf[8])
          goto LABEL_32;
        v32 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
        do
          v33 = __ldxr(v32);
        while (__stxr(v33 + 1, v32));
        do
          v34 = __ldaxr(v32);
        while (__stlxr(v34 - 1, v32));
        if (!v34)
        {
          ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
          std::__shared_weak_count::__release_weak(v30);
          if (!v31)
            goto LABEL_57;
        }
        else
        {
LABEL_32:
          if (!v31)
            goto LABEL_57;
        }
        v35 = *(std::__shared_weak_count **)&buf[8];
        if ((a2 - 1) >= 3)
          LODWORD(a2) = 0;
        if (*(_QWORD *)&buf[8])
        {
          v36 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
          do
            v37 = __ldxr(v36);
          while (__stxr(v37 + 1, v36));
        }
        v38 = qmi::ClientRouter::get();
        qmi::ClientRouter::SendProxy::SendProxy<qmi::MutableMessageBase>((uint64_t)v53, a2, v38);
        *(_DWORD *)(v54 + 16) = v79;
        v39 = *((_QWORD *)&v78 + 1);
        if (*((_QWORD *)&v78 + 1))
        {
          if (*((__int128 **)&v78 + 1) == &v77)
          {
            v73 = &v71;
            (*(void (**)(__int128 *, __int128 *))(v77 + 24))(&v77, &v71);
LABEL_45:
            qmi::ClientRouter::SendProxy::callback<std::function<void ()(qmi::ResponseBase const&)>>((uint64_t)v53, (uint64_t)&v71);
            v41 = v73;
            if (v73 == &v71)
            {
              v42 = 4;
              v41 = &v71;
            }
            else
            {
              if (!v73)
              {
LABEL_50:
                v43 = v54;
                v54 = 0;
                if (v43)
                  std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v54, v43);
                if (v35)
                {
                  v44 = (unint64_t *)&v35->__shared_owners_;
                  do
                    v45 = __ldaxr(v44);
                  while (__stlxr(v45 - 1, v44));
                  if (!v45)
                  {
                    ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
                    std::__shared_weak_count::__release_weak(v35);
                  }
                }
LABEL_57:
                if (*((__int128 **)&v78 + 1) == &v77)
                {
                  v46 = 4;
                }
                else
                {
                  if (!*((_QWORD *)&v78 + 1))
                  {
LABEL_62:
                    v47 = *(std::__shared_weak_count **)&buf[8];
                    if (*(_QWORD *)&buf[8])
                    {
                      v48 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
                      do
                        v49 = __ldaxr(v48);
                      while (__stlxr(v49 - 1, v48));
                      if (!v49)
                      {
                        ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
                        std::__shared_weak_count::__release_weak(v47);
                      }
                    }
                    goto LABEL_67;
                  }
                  v46 = 5;
                  v23 = (__int128 *)*((_QWORD *)&v78 + 1);
                }
                (*(void (**)(__int128 *))(*(_QWORD *)v23 + 8 * v46))(v23);
                goto LABEL_62;
              }
              v42 = 5;
            }
            (*(void (**)(__int128 *, uint64_t))(*(_QWORD *)v41 + 8 * v42))(v41, v40);
            goto LABEL_50;
          }
          v39 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)&v78 + 1) + 16))(*((_QWORD *)&v78 + 1));
        }
        v73 = (__int128 *)v39;
        goto LABEL_45;
      }
      v25 = 5;
    }
    (*(void (**)(void))(*v24 + 8 * v25))();
    goto LABEL_22;
  }
  v26 = *v18;
  if (os_log_type_enabled(*v18, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl(&dword_216897000, v26, OS_LOG_TYPE_ERROR, "Preferred Formatter is NULL in endAllCalls", buf, 2u);
  }
LABEL_67:
  v50 = v56;
  if (v56)
  {
    v51 = (unint64_t *)&v56->__shared_owners_;
    do
      v52 = __ldaxr(v51);
    while (__stlxr(v52 - 1, v51));
    if (!v52)
    {
      ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
      std::__shared_weak_count::__release_weak(v50);
    }
  }
  CallInfo::~CallInfo((void **)v57);
  *(_QWORD *)&v57[0] = &v68;
  std::vector<CallInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)v57);
}

void sub_216A3E464(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, void *a15)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t v18;

  v18 = a12;
  a12 = 0;
  if (v18)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v15, v18);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  EurekaVoiceRequestMessage::~EurekaVoiceRequestMessage((EurekaVoiceRequestMessage *)(v16 - 128));
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  CallInfo::~CallInfo(&a15);
  a15 = (void *)(v16 - 216);
  std::vector<CallInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)&a15);
  _Unwind_Resume(a1);
}

void EurekaCallCommandDriver::createExplicitCallTransfer(uint64_t a1, uint64_t a2)
{
  NSObject **v4;
  __int128 v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  __int128 *v9;
  uint64_t *v10;
  uint64_t v11;
  NSObject *v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  uint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  unint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t *v31;
  unint64_t v32;
  uint64_t v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  std::__shared_weak_count *v37;
  unint64_t *v38;
  unint64_t v39;
  _BYTE v40[8];
  uint64_t v41;
  uint64_t v42;
  std::__shared_weak_count *v43;
  __int128 v44;
  uint64_t v45;
  __int128 *v46;
  uint64_t *v47;
  __int128 v48;
  uint8_t buf[16];
  __int128 v50;
  __int128 v51;
  __int128 v52;
  uint64_t v53;

  v53 = *MEMORY[0x24BDAC8D0];
  v4 = (NSObject **)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 112) + 16))(*(_QWORD *)(a1 + 112));
  v42 = 0;
  v43 = 0;
  EurekaCallCommandDriver::getPreferredFormatterForSim(&v42, a1, a2);
  if (v42)
  {
    v50 = 0u;
    v51 = 0u;
    *(_OWORD *)buf = 0u;
    v52 = 0x61A8uLL;
    (*(void (**)(__int128 *__return_ptr))(*(_QWORD *)v42 + 112))(&v44);
    v5 = v44;
    v44 = 0uLL;
    v6 = *(std::__shared_weak_count **)&buf[8];
    *(_OWORD *)buf = v5;
    if (v6)
    {
      p_shared_owners = (unint64_t *)&v6->__shared_owners_;
      do
        v8 = __ldaxr(p_shared_owners);
      while (__stlxr(v8 - 1, p_shared_owners));
      if (!v8)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
    v9 = &v50;
    std::__function::__value_func<void ()(qmi::ResponseBase const&)>::operator=[abi:ne180100](&v50, (uint64_t)&v45);
    v52 = v48;
    v10 = v47;
    if (v47 == &v45)
    {
      v11 = 4;
      v10 = &v45;
    }
    else
    {
      if (!v47)
      {
LABEL_14:
        v13 = (std::__shared_weak_count *)*((_QWORD *)&v44 + 1);
        if (*((_QWORD *)&v44 + 1))
        {
          v14 = (unint64_t *)(*((_QWORD *)&v44 + 1) + 8);
          do
            v15 = __ldaxr(v14);
          while (__stlxr(v15 - 1, v14));
          if (!v15)
          {
            ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
            std::__shared_weak_count::__release_weak(v13);
          }
        }
        v17 = *(_QWORD *)buf;
        v16 = *(std::__shared_weak_count **)&buf[8];
        if (!*(_QWORD *)&buf[8])
          goto LABEL_24;
        v18 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
        do
          v19 = __ldxr(v18);
        while (__stxr(v19 + 1, v18));
        do
          v20 = __ldaxr(v18);
        while (__stlxr(v20 - 1, v18));
        if (!v20)
        {
          ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
          std::__shared_weak_count::__release_weak(v16);
          if (!v17)
            goto LABEL_49;
        }
        else
        {
LABEL_24:
          if (!v17)
            goto LABEL_49;
        }
        v21 = *(std::__shared_weak_count **)&buf[8];
        if ((a2 - 1) >= 3)
          LODWORD(a2) = 0;
        if (*(_QWORD *)&buf[8])
        {
          v22 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
          do
            v23 = __ldxr(v22);
          while (__stxr(v23 + 1, v22));
        }
        v24 = qmi::ClientRouter::get();
        qmi::ClientRouter::SendProxy::SendProxy<qmi::MutableMessageBase>((uint64_t)v40, a2, v24);
        *(_DWORD *)(v41 + 16) = v52;
        v26 = *((_QWORD *)&v51 + 1);
        if (*((_QWORD *)&v51 + 1))
        {
          if (*((__int128 **)&v51 + 1) == &v50)
          {
            v46 = &v44;
            (*(void (**)(__int128 *, __int128 *))(v50 + 24))(&v50, &v44);
LABEL_37:
            qmi::ClientRouter::SendProxy::callback<std::function<void ()(qmi::ResponseBase const&)>>((uint64_t)v40, (uint64_t)&v44);
            v28 = v46;
            if (v46 == &v44)
            {
              v29 = 4;
              v28 = &v44;
            }
            else
            {
              if (!v46)
              {
LABEL_42:
                v30 = v41;
                v41 = 0;
                if (v30)
                  std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v41, v30);
                if (v21)
                {
                  v31 = (unint64_t *)&v21->__shared_owners_;
                  do
                    v32 = __ldaxr(v31);
                  while (__stlxr(v32 - 1, v31));
                  if (!v32)
                  {
                    ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
                    std::__shared_weak_count::__release_weak(v21);
                  }
                }
LABEL_49:
                if (*((__int128 **)&v51 + 1) == &v50)
                {
                  v33 = 4;
                }
                else
                {
                  if (!*((_QWORD *)&v51 + 1))
                  {
LABEL_54:
                    v34 = *(std::__shared_weak_count **)&buf[8];
                    if (*(_QWORD *)&buf[8])
                    {
                      v35 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
                      do
                        v36 = __ldaxr(v35);
                      while (__stlxr(v36 - 1, v35));
                      if (!v36)
                      {
                        ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
                        std::__shared_weak_count::__release_weak(v34);
                      }
                    }
                    goto LABEL_59;
                  }
                  v33 = 5;
                  v9 = (__int128 *)*((_QWORD *)&v51 + 1);
                }
                (*(void (**)(__int128 *))(*(_QWORD *)v9 + 8 * v33))(v9);
                goto LABEL_54;
              }
              v29 = 5;
            }
            (*(void (**)(__int128 *, uint64_t))(*(_QWORD *)v28 + 8 * v29))(v28, v27);
            goto LABEL_42;
          }
          v26 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)&v51 + 1) + 16))(*((_QWORD *)&v51 + 1), v25);
        }
        v46 = (__int128 *)v26;
        goto LABEL_37;
      }
      v11 = 5;
    }
    (*(void (**)(void))(*v10 + 8 * v11))();
    goto LABEL_14;
  }
  v12 = *v4;
  if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl(&dword_216897000, v12, OS_LOG_TYPE_ERROR, "Preferred Formatter is NULL in createExplicitCallTransfer", buf, 2u);
  }
LABEL_59:
  v37 = v43;
  if (v43)
  {
    v38 = (unint64_t *)&v43->__shared_owners_;
    do
      v39 = __ldaxr(v38);
    while (__stlxr(v39 - 1, v38));
    if (!v39)
    {
      ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
      std::__shared_weak_count::__release_weak(v37);
    }
  }
}

void sub_216A3E910(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23)
{
  uint64_t v23;
  uint64_t v25;

  v25 = a12;
  a12 = 0;
  if (v25)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v23, v25);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  EurekaVoiceRequestMessage::~EurekaVoiceRequestMessage((EurekaVoiceRequestMessage *)&a23);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  _Unwind_Resume(a1);
}

uint64_t EurekaCallCommandDriver::getAllCallCapabilities@<X0>(uint64_t result@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  BOOL v6;
  uint64_t *v7;

  v3 = *(_QWORD *)(result + 288);
  if (v3)
  {
    v4 = result + 288;
    do
    {
      v5 = *(_DWORD *)(v3 + 32);
      v6 = v5 < a2;
      if (v5 >= a2)
        v7 = (uint64_t *)v3;
      else
        v7 = (uint64_t *)(v3 + 8);
      if (!v6)
        v4 = v3;
      v3 = *v7;
    }
    while (*v7);
    if (v4 != result + 288 && *(_DWORD *)(v4 + 32) <= a2)
      return std::map<char const*,int>::map[abi:ne180100]((uint64_t)a3, (_QWORD *)(v4 + 40));
  }
  a3[2] = 0;
  a3[1] = 0;
  *a3 = a3 + 1;
  return result;
}

void EurekaCallCommandDriver::enableVoicePrivacy(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  unsigned int v7;
  BOOL v8;
  int v9;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  NSObject **v20;
  uint64_t v21;
  NSObject *v22;
  uint64_t v23;
  uint64_t v24;
  std::__shared_weak_count *v25;
  uint64_t v26;
  unint64_t *v27;
  unint64_t v28;
  unint64_t v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  _QWORD *v36;
  uint64_t v37;
  unint64_t *p_shared_owners;
  unint64_t v39;
  __int128 *v40;
  uint64_t v41;
  std::__shared_weak_count *v42;
  unint64_t *v43;
  unint64_t v44;
  std::__shared_weak_count *v45;
  unint64_t *v46;
  unint64_t v47;
  _BYTE v48[8];
  uint64_t v49;
  uint64_t v50;
  std::__shared_weak_count *v51;
  _OWORD v52[2];
  std::string v53[4];
  __int128 v54;
  __int128 v55;
  _BYTE v56[112];
  std::string v57[2];
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  _BYTE v62[24];
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  _BYTE v66[24];
  _BYTE *v67;
  uint8_t buf[16];
  __int128 v69;
  __int128 v70;
  __int128 v71;
  uint64_t v72;

  v72 = *MEMORY[0x24BDAC8D0];
  v63 = 0;
  v64 = 0;
  v65 = 0;
  (*(void (**)(uint64_t *__return_ptr))(**(_QWORD **)(a1 + 120) + 320))(&v63);
  v61 = 0u;
  memset(v62, 0, sizeof(v62));
  v59 = 0u;
  v60 = 0u;
  v58 = 0u;
  memset(v57, 0, sizeof(v57));
  v55 = 0u;
  memset(v56, 0, sizeof(v56));
  v54 = 0u;
  memset(v53, 0, sizeof(v53));
  memset(v52, 0, sizeof(v52));
  CallInfo::CallInfo((CallInfo *)v52);
  v6 = v63;
  if (v63 != v64)
  {
    while (1)
    {
      v7 = *(unsigned __int8 *)(v6 + 68);
      v8 = v7 > 8;
      v9 = (1 << v7) & 0x114;
      if (v8 || v9 == 0)
        break;
      v6 += 408;
      if (v6 == v64)
        goto LABEL_9;
    }
    ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::operator=((const void **)v52, (const void **)v6);
    std::string::operator=((std::string *)((char *)v52 + 8), (const std::string *)(v6 + 8));
    std::string::operator=(v53, (const std::string *)(v6 + 32));
    *(_OWORD *)&v53[1].__r_.__value_.__l.__data_ = *(_OWORD *)(v6 + 56);
    v11 = *(_OWORD *)(v6 + 72);
    v12 = *(_OWORD *)(v6 + 88);
    v13 = *(_OWORD *)(v6 + 104);
    *(std::string::size_type *)((char *)&v53[3].__r_.__value_.__r.__words[1] + 5) = *(_QWORD *)(v6 + 117);
    *(_OWORD *)&v53[3].__r_.__value_.__l.__data_ = v13;
    *(_OWORD *)&v53[2].__r_.__value_.__r.__words[1] = v12;
    *(_OWORD *)&v53[1].__r_.__value_.__r.__words[2] = v11;
    std::string::operator=((std::string *)&v54, (const std::string *)(v6 + 128));
    DWORD2(v55) = *(_DWORD *)(v6 + 152);
    std::string::operator=((std::string *)v56, (const std::string *)(v6 + 160));
    v14 = *(_OWORD *)(v6 + 184);
    *(_OWORD *)&v56[33] = *(_OWORD *)(v6 + 193);
    *(_OWORD *)&v56[24] = v14;
    std::__optional_storage_base<std::vector<unsigned int>,false>::__assign_from[abi:ne180100]<std::__optional_copy_assign_base<std::vector<unsigned int>,false> const&>((uint64_t)&v56[56], v6 + 216);
    v15 = *(_OWORD *)(v6 + 248);
    v56[104] = *(_BYTE *)(v6 + 264);
    *(_OWORD *)&v56[88] = v15;
    std::string::operator=(v57, (const std::string *)(v6 + 272));
    std::string::operator=(&v57[1], (const std::string *)(v6 + 296));
    v16 = *(_OWORD *)(v6 + 352);
    v17 = *(_OWORD *)(v6 + 368);
    v18 = *(_OWORD *)(v6 + 384);
    *(_QWORD *)&v62[13] = *(_QWORD *)(v6 + 397);
    v19 = *(_OWORD *)(v6 + 336);
    v58 = *(_OWORD *)(v6 + 320);
    v59 = v19;
    v61 = v17;
    *(_OWORD *)v62 = v18;
    v60 = v16;
  }
LABEL_9:
  v20 = (NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 112) + 16))(*(_QWORD *)(a1 + 112), a3);
  v50 = 0;
  v51 = 0;
  EurekaCallCommandDriver::getPreferredFormatterForSim(&v50, a1, a3);
  v21 = v50;
  v22 = *v20;
  if (v50)
  {
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      v23 = CSIBOOLAsString();
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = v23;
      _os_log_impl(&dword_216897000, v22, OS_LOG_TYPE_DEFAULT, "#I Setting voice privacy to %s", buf, 0xCu);
    }
    v70 = 0u;
    v71 = 0u;
    *(_OWORD *)buf = 0u;
    v69 = 0u;
    (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v21 + 120))(buf, v21, a2, a3);
    v26 = *(_QWORD *)buf;
    v25 = *(std::__shared_weak_count **)&buf[8];
    if (!*(_QWORD *)&buf[8])
      goto LABEL_17;
    v27 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
    do
      v28 = __ldxr(v27);
    while (__stxr(v28 + 1, v27));
    do
      v29 = __ldaxr(v27);
    while (__stlxr(v29 - 1, v27));
    if (!v29)
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
      if (!v26)
        goto LABEL_44;
    }
    else
    {
LABEL_17:
      if (!v26)
        goto LABEL_44;
    }
    v30 = *(std::__shared_weak_count **)&buf[8];
    if ((a3 - 1) >= 3)
      LODWORD(a3) = 0;
    if (*(_QWORD *)&buf[8])
    {
      v31 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
      do
        v32 = __ldxr(v31);
      while (__stxr(v32 + 1, v31));
    }
    v33 = qmi::ClientRouter::get();
    qmi::ClientRouter::SendProxy::SendProxy<qmi::MutableMessageBase>((uint64_t)v48, a3, v33);
    v34 = *((_QWORD *)&v70 + 1);
    if (*((_QWORD *)&v70 + 1))
    {
      if (*((__int128 **)&v70 + 1) == &v69)
      {
        v67 = v66;
        (*(void (**)(_QWORD, _BYTE *))(**((_QWORD **)&v70 + 1) + 24))(*((_QWORD *)&v70 + 1), v66);
LABEL_32:
        qmi::ClientRouter::SendProxy::callback<std::function<void ()(qmi::ResponseBase const&)>>((uint64_t)v48, (uint64_t)v66);
        v36 = v67;
        if (v67 == v66)
        {
          v37 = 4;
          v36 = v66;
        }
        else
        {
          if (!v67)
          {
LABEL_37:
            v24 = v49;
            v49 = 0;
            if (v24)
              std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v49, v24);
            if (v30)
            {
              p_shared_owners = (unint64_t *)&v30->__shared_owners_;
              do
                v39 = __ldaxr(p_shared_owners);
              while (__stlxr(v39 - 1, p_shared_owners));
              if (!v39)
              {
                ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
                std::__shared_weak_count::__release_weak(v30);
              }
            }
LABEL_44:
            v40 = (__int128 *)*((_QWORD *)&v70 + 1);
            if (*((__int128 **)&v70 + 1) == &v69)
            {
              v41 = 4;
              v40 = &v69;
            }
            else
            {
              if (!*((_QWORD *)&v70 + 1))
              {
LABEL_49:
                v42 = *(std::__shared_weak_count **)&buf[8];
                if (*(_QWORD *)&buf[8])
                {
                  v43 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
                  do
                    v44 = __ldaxr(v43);
                  while (__stlxr(v44 - 1, v43));
                  if (!v44)
                  {
                    ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
                    std::__shared_weak_count::__release_weak(v42);
                  }
                }
                goto LABEL_54;
              }
              v41 = 5;
            }
            (*(void (**)(__int128 *, uint64_t))(*(_QWORD *)v40 + 8 * v41))(v40, v24);
            goto LABEL_49;
          }
          v37 = 5;
        }
        (*(void (**)(_QWORD *, uint64_t))(*v36 + 8 * v37))(v36, v35);
        goto LABEL_37;
      }
      v34 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)&v70 + 1) + 16))(*((_QWORD *)&v70 + 1));
    }
    v67 = (_BYTE *)v34;
    goto LABEL_32;
  }
  if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl(&dword_216897000, v22, OS_LOG_TYPE_ERROR, "Preferred Formatter is NULL in enableVoicePrivacy", buf, 2u);
  }
LABEL_54:
  v45 = v51;
  if (v51)
  {
    v46 = (unint64_t *)&v51->__shared_owners_;
    do
      v47 = __ldaxr(v46);
    while (__stlxr(v47 - 1, v46));
    if (!v47)
    {
      ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
      std::__shared_weak_count::__release_weak(v45);
    }
  }
  CallInfo::~CallInfo((void **)v52);
  *(_QWORD *)&v52[0] = &v63;
  std::vector<CallInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)v52);
}

void sub_216A3EF08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, void *a15)
{
  uint64_t v15;
  uint64_t v17;

  v17 = a12;
  a12 = 0;
  if (v17)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&a12, v17);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  EurekaVoiceRequestMessage::~EurekaVoiceRequestMessage((EurekaVoiceRequestMessage *)(v15 - 144));
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  CallInfo::~CallInfo(&a15);
  a15 = (void *)(v15 - 200);
  std::vector<CallInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)&a15);
  _Unwind_Resume(a1);
}

uint64_t EurekaCallCommandDriver::reportDisconnectStats(EurekaCallCommandDriver *this, const CallInfo *a2)
{
  uint64_t v2;
  int v3;
  _DWORD *v4;
  int v5;
  BOOL v6;
  uint64_t *v7;
  uint64_t v8;

  v2 = *((_QWORD *)this + 40);
  if (!v2)
    goto LABEL_11;
  v3 = *((_DWORD *)a2 + 63);
  v4 = (_DWORD *)((char *)this + 320);
  do
  {
    v5 = *(_DWORD *)(v2 + 28);
    v6 = v5 < v3;
    if (v5 >= v3)
      v7 = (uint64_t *)v2;
    else
      v7 = (uint64_t *)(v2 + 8);
    if (!v6)
      v4 = (_DWORD *)v2;
    v2 = *v7;
  }
  while (*v7);
  if (v4 != (_DWORD *)((char *)this + 320) && v3 >= v4[7])
    v8 = v4[8];
  else
LABEL_11:
    v8 = 11;
  return (*(uint64_t (**)(_QWORD, const CallInfo *, uint64_t))(**((_QWORD **)this + 15) + 344))(*((_QWORD *)this + 15), a2, v8);
}

void EurekaCallCommandDriver::resetCallRelatedState(uint64_t a1, uint64_t a2)
{
  os_log_t *v4;
  NSObject *v5;
  NSObject *v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  std::__shared_weak_count *v14;
  uint8_t buf[8];
  std::__shared_weak_count *v16;

  v4 = (os_log_t *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 112) + 16))(*(_QWORD *)(a1 + 112));
  v5 = *v4;
  if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#I Resetting call related state!", buf, 2u);
  }
  EurekaCallCommandDriver::resetCallCapabilities(a1, a2);
  if (*(_BYTE *)(a1 + 184))
  {
    v6 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_216897000, v6, OS_LOG_TYPE_DEFAULT, "#I Call ended somehow, there is a busy tone being played. Ending it.", buf, 2u);
    }
    *(_QWORD *)buf = 0;
    v16 = 0;
    (*(void (**)(uint8_t *__return_ptr))(**(_QWORD **)(a1 + 120) + 288))(buf);
    if (*(_QWORD *)buf)
    {
      (*(void (**)(uint64_t *__return_ptr))(**(_QWORD **)(a1 + 120) + 288))(&v13);
      (*(void (**)(uint64_t))(*(_QWORD *)v13 + 48))(v13);
      v7 = v14;
      if (v14)
      {
        p_shared_owners = (unint64_t *)&v14->__shared_owners_;
        do
          v9 = __ldaxr(p_shared_owners);
        while (__stlxr(v9 - 1, p_shared_owners));
        if (!v9)
        {
          ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
          std::__shared_weak_count::__release_weak(v7);
        }
      }
    }
    *(_BYTE *)(a1 + 184) = 0;
    v10 = v16;
    if (v16)
    {
      v11 = (unint64_t *)&v16->__shared_owners_;
      do
        v12 = __ldaxr(v11);
      while (__stlxr(v12 - 1, v11));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
  }
}

void sub_216A3F1AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

void EurekaCallCommandDriver::resetCallCapabilities(uint64_t a1, uint64_t a2)
{
  os_log_t *v4;
  uint64_t *v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t *v10;
  BOOL v11;
  uint64_t *v12;
  NSObject *v13;
  std::__shared_weak_count *v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  __int16 v17[8];
  uint64_t v18;
  std::__shared_weak_count *v19;

  v4 = (os_log_t *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 112) + 16))(*(_QWORD *)(a1 + 112));
  v5 = *(uint64_t **)(a1 + 232);
  v6 = (uint64_t *)(a1 + 240);
  if (v5 != (uint64_t *)(a1 + 240))
  {
    do
    {
      v7 = v5[7];
      if (v7)
      {
        (*(void (**)(uint64_t))(*(_QWORD *)v7 + 16))(v7);
        v8 = v5[7];
        v5[7] = 0;
        if (v8)
          (*(void (**)(uint64_t))(*(_QWORD *)v8 + 8))(v8);
      }
      v9 = (uint64_t *)v5[1];
      if (v9)
      {
        do
        {
          v10 = v9;
          v9 = (uint64_t *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          v10 = (uint64_t *)v5[2];
          v11 = *v10 == (_QWORD)v5;
          v5 = v10;
        }
        while (!v11);
      }
      v5 = v10;
    }
    while (v10 != v6);
    v5 = *(uint64_t **)(a1 + 232);
  }
  if (v5 != v6)
  {
    do
    {
      v12 = std::__tree<std::__value_type<std::string,std::unique_ptr<ctu::Timer>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<ctu::Timer>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<ctu::Timer>>>>::__remove_node_pointer((uint64_t **)(a1 + 232), v5);
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::unique_ptr<ctu::Timer>>,0>((uint64_t)(v5 + 4));
      operator delete(v5);
      v5 = v12;
    }
    while (v6 != v12);
  }
  v18 = 0;
  v19 = 0;
  EurekaCallCommandDriver::getPreferredFormatterForSim(&v18, a1, a2);
  if (v18)
  {
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v18 + 136))(v18, a2);
  }
  else
  {
    v13 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_ERROR))
    {
      v17[0] = 0;
      _os_log_error_impl(&dword_216897000, v13, OS_LOG_TYPE_ERROR, "Preferred Formatter is NULL. Can't reset all call capabilities.", (uint8_t *)v17, 2u);
    }
  }
  v14 = v19;
  if (v19)
  {
    p_shared_owners = (unint64_t *)&v19->__shared_owners_;
    do
      v16 = __ldaxr(p_shared_owners);
    while (__stlxr(v16 - 1, p_shared_owners));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
}

void sub_216A3F37C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN23EurekaCallCommandDriver17setCallCapabilityEPKcbbN10subscriber7SimSlotE_block_invoke(uint64_t a1)
{
  return EurekaCallCommandDriver::handleSetCallCapabilityTimerExpired(*(_QWORD ***)(a1 + 32), *(char **)(a1 + 40), *(_BYTE *)(a1 + 52), *(unsigned int *)(a1 + 48));
}

uint64_t EurekaCallCommandDriver::handleSetCallCapabilityTimerExpired(_QWORD **a1, char *a2, char a3, uint64_t a4)
{
  NSObject *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t result;
  int v12;
  _OWORD *v13;
  _BYTE buf[12];
  char v15;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  v8 = *(NSObject **)(*(uint64_t (**)(_QWORD *, uint64_t))(*a1[14] + 16))(a1[14], a4);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315138;
    *(_QWORD *)&buf[4] = a2;
    _os_log_impl(&dword_216897000, v8, OS_LOG_TYPE_DEFAULT, "#I Call Capabilities, %s, timer exipred!", buf, 0xCu);
  }
  std::string::basic_string[abi:ne180100]<0>(buf, a2);
  v13 = buf;
  v9 = std::__tree<std::__value_type<std::string,std::unique_ptr<ctu::Timer>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<ctu::Timer>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<ctu::Timer>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(a1 + 29, (void **)buf, &v13);
  v10 = v9[7];
  v9[7] = 0;
  if (v10)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 8))(v10);
  if (v15 < 0)
  {
    operator delete(*(void **)buf);
    if ((a3 & 1) != 0)
      goto LABEL_7;
LABEL_10:
    v12 = 0;
    goto LABEL_11;
  }
  if ((a3 & 1) == 0)
    goto LABEL_10;
LABEL_7:
  result = EurekaCallCommandDriver::findCallCapability((uint64_t)a1, (unint64_t)a2, a4);
  if ((_DWORD)result)
    return result;
  v12 = 1;
LABEL_11:
  EurekaCallCommandDriver::setCallCapability((uint64_t)a1, (unint64_t)a2, v12, a4);
  return (*(uint64_t (**)(_QWORD *, uint64_t))(*a1[15] + 192))(a1[15], a4);
}

void sub_216A3F50C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void EurekaCallCommandDriver::startOTASP(EurekaCallCommandDriver *this)
{
  NSObject *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  uint64_t v10;
  std::__shared_weak_count *v11;
  uint8_t buf[16];

  v2 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_216897000, v2, OS_LOG_TYPE_DEFAULT, "#I User requseted to start a non-visual OTASP!", buf, 2u);
  }
  v3 = *((_QWORD *)this + 27);
  v4 = (std::__shared_weak_count *)*((_QWORD *)this + 18);
  v10 = *((_QWORD *)this + 17);
  v11 = v4;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  (*(void (**)(uint64_t, uint64_t *, uint64_t))(*(_QWORD *)v3 + 40))(v3, &v10, 1);
  v7 = v11;
  if (v11)
  {
    v8 = (unint64_t *)&v11->__shared_owners_;
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
}

void sub_216A3F600(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void EurekaCallCommandDriver::sendDTMFDigits(EurekaCallCommandDriver *a1, char **a2, int *a3)
{
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  char *v9;
  char *v10;
  char v11;
  uint64_t v12;
  std::__shared_weak_count *v13;

  (*(void (**)(_QWORD *, _QWORD))(**((_QWORD **)a1 + 14) + 16))(*((_QWORD **)a1 + 14), a3[63]);
  if (EurekaCallCommandDriver::findCallCapability((uint64_t)a1, *MEMORY[0x24BDC3EF0], a3[63]))
  {
    EurekaCallCommandDriver::sendVoiceBurstDtmfReq((uint64_t)a1, a2, (uint64_t)a3);
  }
  else
  {
    v9 = *a2;
    v10 = a2[1];
    while (v9 != v10)
    {
      v11 = *v9++;
      EurekaCallCommandDriver::sendStartContDtmfReq(a1, v11, (const CallInfo *)a3);
      EurekaCallCommandDriver::sendStopContDtmfReq(a1, (const CallInfo *)a3);
    }
  }
  v12 = 0;
  v13 = 0;
  (*(void (**)(uint64_t *__return_ptr))(**((_QWORD **)a1 + 15) + 288))(&v12);
  if (v12)
    (*(void (**)(uint64_t, char **, uint64_t))(*(_QWORD *)v12 + 56))(v12, a2, 1);
  v6 = v13;
  if (v13)
  {
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

void sub_216A3F728(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void EurekaCallCommandDriver::sendVoiceBurstDtmfReq(uint64_t a1, char **a2, uint64_t a3)
{
  uint64_t v5;
  const void **v6;
  char *v7;
  _BYTE *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  char *v16;
  uint64_t *v17;
  char *v18;
  char *v19;
  char *v20;
  uint64_t v21;
  char **v22;
  uint64_t v23;
  uint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *p_shared_owners;
  uint64_t v27;
  unint64_t v28;
  std::__shared_weak_count *v29;
  unint64_t *v30;
  unint64_t v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  void *__p[2];
  __int128 v38;
  _QWORD v39[5];
  std::__shared_weak_count *v40;
  _QWORD *v41;
  std::__shared_weak_count *v42;
  _QWORD aBlock[5];

  v5 = (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 112) + 16))(*(_QWORD *)(a1 + 112), *(unsigned int *)(a3 + 252));
  *(_OWORD *)__p = 0u;
  v38 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  v6 = (const void **)__p[1];
  if (__p[1] != (void *)v38)
  {
    while (*((_BYTE *)*v6 + 8) != 1)
    {
      if (++v6 == (const void **)v38)
        goto LABEL_8;
    }
  }
  if (v6 == (const void **)v38)
  {
LABEL_8:
    v9 = operator new();
    v10 = v9;
    *(_BYTE *)(v9 + 8) = 1;
    *(_QWORD *)v9 = &off_24D5E4998;
    *(_BYTE *)(v9 + 16) = 0;
    v8 = (_BYTE *)(v9 + 16);
    *(_QWORD *)(v9 + 32) = 0;
    *(_QWORD *)(v9 + 40) = 0;
    *(_QWORD *)(v9 + 24) = 0;
    v11 = v38;
    if ((unint64_t)v38 >= *((_QWORD *)&v38 + 1))
    {
      v13 = (uint64_t)(v38 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v13 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v14 = (uint64_t)(*((_QWORD *)&v38 + 1) - (unint64_t)__p[1]) >> 2;
      if (v14 <= v13 + 1)
        v14 = v13 + 1;
      if (*((_QWORD *)&v38 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v15 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v15 = v14;
      if (v15)
        v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v38 + 8, v15);
      else
        v16 = 0;
      v17 = (uint64_t *)&v16[8 * v13];
      v18 = &v16[8 * v15];
      *v17 = v10;
      v12 = v17 + 1;
      v20 = (char *)__p[1];
      v19 = (char *)v38;
      if ((void *)v38 != __p[1])
      {
        do
        {
          v21 = *((_QWORD *)v19 - 1);
          v19 -= 8;
          *--v17 = v21;
        }
        while (v19 != v20);
        v19 = (char *)__p[1];
      }
      __p[1] = v17;
      *(_QWORD *)&v38 = v12;
      *((_QWORD *)&v38 + 1) = v18;
      if (v19)
        operator delete(v19);
    }
    else
    {
      *(_QWORD *)v38 = v9;
      v12 = (_QWORD *)(v11 + 8);
    }
    *(_QWORD *)&v38 = v12;
  }
  else
  {
    if (!v7)
      __cxa_bad_cast();
    v8 = v7 + 16;
  }
  *v8 = *(_DWORD *)(a3 + 92);
  v22 = (char **)(v8 + 8);
  if (v22 != a2)
    std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(v22, *a2, a2[1], a2[1] - *a2);
  v23 = qmi::ClientRouter::get();
  v24 = operator new();
  *(_QWORD *)v24 = v23;
  *(_QWORD *)(v24 + 8) = QMIServiceMsg::create();
  *(_DWORD *)(v24 + 16) = 25000;
  *(_QWORD *)(v24 + 24) = 0;
  *(_QWORD *)(v24 + 32) = 0;
  v36 = v24;
  v25 = (std::__shared_weak_count *)operator new(0x20uLL);
  v25->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v25->__shared_owners_;
  v25->__shared_weak_owners_ = 0;
  v25->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E4A00;
  v25[1].__vftable = (std::__shared_weak_count_vtbl *)v5;
  v41 = &v25[1].__vftable;
  v42 = v25;
  v27 = MEMORY[0x24BDAC760];
  v39[0] = MEMORY[0x24BDAC760];
  v39[1] = 1174405120;
  v39[2] = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN23EurekaCallCommandDriver21sendVoiceBurstDtmfReqERKNSt3__16vectorIhNS4_9allocatorIhEEEERK8CallInfoE3__0EEOS1_OT__block_invoke;
  v39[3] = &__block_descriptor_tmp_185_1;
  v39[4] = v25 + 1;
  v40 = v25;
  do
    v28 = __ldxr(p_shared_owners);
  while (__stxr(v28 + 1, p_shared_owners));
  aBlock[0] = v27;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_26;
  aBlock[3] = &unk_24D5E3190;
  aBlock[4] = v39;
  *(_QWORD *)(v24 + 32) = _Block_copy(aBlock);
  v29 = v40;
  if (v40)
  {
    v30 = (unint64_t *)&v40->__shared_owners_;
    do
      v31 = __ldaxr(v30);
    while (__stlxr(v31 - 1, v30));
    if (!v31)
    {
      ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
      std::__shared_weak_count::__release_weak(v29);
    }
  }
  v32 = v42;
  if (v42)
  {
    v33 = (unint64_t *)&v42->__shared_owners_;
    do
      v34 = __ldaxr(v33);
    while (__stlxr(v34 - 1, v33));
    if (!v34)
    {
      ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
      std::__shared_weak_count::__release_weak(v32);
    }
  }
  v35 = v36;
  v36 = 0;
  if (v35)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v36, v35);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
}

void sub_216A3FAD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;
  va_list va;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v6 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v4);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  if (a3)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v3, a3);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

void EurekaCallCommandDriver::sendStartContDtmfReq(EurekaCallCommandDriver *this, char a2, const CallInfo *a3)
{
  uint64_t v5;
  const void **v6;
  char *v7;
  _BYTE *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  char *v16;
  uint64_t *v17;
  char *v18;
  char *v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  std::__shared_weak_count *v24;
  unint64_t *p_shared_owners;
  uint64_t v26;
  unint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;
  void *__p[2];
  __int128 v37;
  _QWORD v38[5];
  std::__shared_weak_count *v39;
  _QWORD *v40;
  std::__shared_weak_count *v41;
  _QWORD aBlock[5];

  v5 = (*(uint64_t (**)(_QWORD, _QWORD))(**((_QWORD **)this + 14) + 16))(*((_QWORD *)this + 14), *((unsigned int *)a3 + 63));
  *(_OWORD *)__p = 0u;
  v37 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  v6 = (const void **)__p[1];
  if (__p[1] != (void *)v37)
  {
    while (*((_BYTE *)*v6 + 8) != 1)
    {
      if (++v6 == (const void **)v37)
        goto LABEL_8;
    }
  }
  if (v6 == (const void **)v37)
  {
LABEL_8:
    v9 = operator new();
    v10 = v9;
    *(_WORD *)(v9 + 8) = 1;
    *(_QWORD *)v9 = &off_24D5E4A68;
    *(_BYTE *)(v9 + 10) = 0;
    v11 = v37;
    if ((unint64_t)v37 >= *((_QWORD *)&v37 + 1))
    {
      v13 = (uint64_t)(v37 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v13 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v14 = (uint64_t)(*((_QWORD *)&v37 + 1) - (unint64_t)__p[1]) >> 2;
      if (v14 <= v13 + 1)
        v14 = v13 + 1;
      if (*((_QWORD *)&v37 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v15 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v15 = v14;
      if (v15)
        v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v37 + 8, v15);
      else
        v16 = 0;
      v17 = (uint64_t *)&v16[8 * v13];
      v18 = &v16[8 * v15];
      *v17 = v10;
      v12 = v17 + 1;
      v20 = (char *)__p[1];
      v19 = (char *)v37;
      if ((void *)v37 != __p[1])
      {
        do
        {
          v21 = *((_QWORD *)v19 - 1);
          v19 -= 8;
          *--v17 = v21;
        }
        while (v19 != v20);
        v19 = (char *)__p[1];
      }
      __p[1] = v17;
      *(_QWORD *)&v37 = v12;
      *((_QWORD *)&v37 + 1) = v18;
      if (v19)
        operator delete(v19);
    }
    else
    {
      *(_QWORD *)v37 = v9;
      v12 = (_QWORD *)(v11 + 8);
    }
    v8 = (_BYTE *)(v10 + 9);
    *(_QWORD *)&v37 = v12;
  }
  else
  {
    if (!v7)
      __cxa_bad_cast();
    v8 = v7 + 9;
  }
  *v8 = *((_DWORD *)a3 + 23);
  v8[1] = a2;
  v22 = qmi::ClientRouter::get();
  v23 = operator new();
  *(_QWORD *)v23 = v22;
  *(_QWORD *)(v23 + 8) = QMIServiceMsg::create();
  *(_DWORD *)(v23 + 16) = 25000;
  *(_QWORD *)(v23 + 24) = 0;
  *(_QWORD *)(v23 + 32) = 0;
  v35 = v23;
  v24 = (std::__shared_weak_count *)operator new(0x20uLL);
  v24->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v24->__shared_owners_;
  v24->__shared_weak_owners_ = 0;
  v24->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E4AD0;
  v24[1].__vftable = (std::__shared_weak_count_vtbl *)v5;
  v40 = &v24[1].__vftable;
  v41 = v24;
  v26 = MEMORY[0x24BDAC760];
  v38[0] = MEMORY[0x24BDAC760];
  v38[1] = 1174405120;
  v38[2] = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN23EurekaCallCommandDriver20sendStartContDtmfReqEhRK8CallInfoE3__0EEOS1_OT__block_invoke;
  v38[3] = &__block_descriptor_tmp_186_1;
  v38[4] = v24 + 1;
  v39 = v24;
  do
    v27 = __ldxr(p_shared_owners);
  while (__stxr(v27 + 1, p_shared_owners));
  aBlock[0] = v26;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_26;
  aBlock[3] = &unk_24D5E3190;
  aBlock[4] = v38;
  *(_QWORD *)(v23 + 32) = _Block_copy(aBlock);
  v28 = v39;
  if (v39)
  {
    v29 = (unint64_t *)&v39->__shared_owners_;
    do
      v30 = __ldaxr(v29);
    while (__stlxr(v30 - 1, v29));
    if (!v30)
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
  }
  v31 = v41;
  if (v41)
  {
    v32 = (unint64_t *)&v41->__shared_owners_;
    do
      v33 = __ldaxr(v32);
    while (__stlxr(v33 - 1, v32));
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
      std::__shared_weak_count::__release_weak(v31);
    }
  }
  v34 = v35;
  v35 = 0;
  if (v34)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v35, v34);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
}

void sub_216A3FEB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;
  va_list va;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v6 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v4);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  if (a3)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v3, a3);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

void EurekaCallCommandDriver::sendStopContDtmfReq(EurekaCallCommandDriver *this, const CallInfo *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  uint64_t v8;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _OWORD v18[2];
  _QWORD v19[5];
  std::__shared_weak_count *v20;
  _QWORD *v21;
  std::__shared_weak_count *v22;
  _QWORD aBlock[5];

  v3 = (*(uint64_t (**)(_QWORD, _QWORD))(**((_QWORD **)this + 14) + 16))(*((_QWORD *)this + 14), *((unsigned int *)a2 + 63));
  memset(v18, 0, sizeof(v18));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v18);
  *(_BYTE *)qmi::MutableMessageBase::getTLV<vs::tlv::CallIdentifier>(v18, 1) = *((_DWORD *)a2 + 23);
  v4 = qmi::ClientRouter::get();
  v5 = operator new();
  *(_QWORD *)v5 = v4;
  *(_QWORD *)(v5 + 8) = QMIServiceMsg::create();
  *(_DWORD *)(v5 + 16) = 25000;
  *(_QWORD *)(v5 + 24) = 0;
  *(_QWORD *)(v5 + 32) = 0;
  v17 = v5;
  v6 = (std::__shared_weak_count *)operator new(0x20uLL);
  v6->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v6->__shared_owners_;
  v6->__shared_weak_owners_ = 0;
  v6->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E4B50;
  v6[1].__vftable = (std::__shared_weak_count_vtbl *)v3;
  v21 = &v6[1].__vftable;
  v22 = v6;
  v8 = MEMORY[0x24BDAC760];
  v19[0] = MEMORY[0x24BDAC760];
  v19[1] = 1174405120;
  v19[2] = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN23EurekaCallCommandDriver19sendStopContDtmfReqERK8CallInfoE3__0EEOS1_OT__block_invoke;
  v19[3] = &__block_descriptor_tmp_187_0;
  v19[4] = v6 + 1;
  v20 = v6;
  do
    v9 = __ldxr(p_shared_owners);
  while (__stxr(v9 + 1, p_shared_owners));
  aBlock[0] = v8;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_26;
  aBlock[3] = &unk_24D5E3190;
  aBlock[4] = v19;
  *(_QWORD *)(v5 + 32) = _Block_copy(aBlock);
  v10 = v20;
  if (v20)
  {
    v11 = (unint64_t *)&v20->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  v13 = v22;
  if (v22)
  {
    v14 = (unint64_t *)&v22->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  v16 = v17;
  v17 = 0;
  if (v16)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v17, v16);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v18);
}

void sub_216A40138(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  va_list va;

  va_start(va, a3);
  v6 = v4;
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v6);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v5 - 88);
  if (a3)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v3, a3);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

void EurekaCallCommandDriver::startDTMFTone(EurekaCallCommandDriver *a1, int a2, int *a3, int a4)
{
  NSObject *v8;
  int v9;
  _BYTE *v10;
  void *__p;
  void *v12;
  _BYTE *v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v8 = *(NSObject **)(*(uint64_t (**)(_QWORD *, _QWORD))(**((_QWORD **)a1 + 14) + 16))(*((_QWORD **)a1 + 14), a3[63]);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(__p) = 67109120;
    HIDWORD(__p) = a2;
    _os_log_impl(&dword_216897000, v8, OS_LOG_TYPE_DEFAULT, "#I Sending single DTMF char = %d", (uint8_t *)&__p, 8u);
  }
  v9 = EurekaCallCommandDriver::findCallCapability((uint64_t)a1, *MEMORY[0x24BDC3EF0], a3[63]);
  if (a4 || !v9)
  {
    EurekaCallCommandDriver::sendStartContDtmfReq(a1, a2, (const CallInfo *)a3);
  }
  else
  {
    v10 = operator new(1uLL);
    *v10 = a2;
    __p = v10;
    v13 = v10 + 1;
    v12 = v10 + 1;
    EurekaCallCommandDriver::sendVoiceBurstDtmfReq((uint64_t)a1, (char **)&__p, (uint64_t)a3);
    if (__p)
    {
      v12 = __p;
      operator delete(__p);
    }
  }
}

void sub_216A402F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void EurekaCallCommandDriver::stopDTMFTone(EurekaCallCommandDriver *a1, const CallInfo *a2, int a3)
{
  unsigned int v6;
  NSObject **v7;
  int v8;
  NSObject *v9;
  uint8_t v10[16];

  v6 = *((_DWORD *)a2 + 63);
  v7 = (NSObject **)(*(uint64_t (**)(_QWORD *, _QWORD))(**((_QWORD **)a1 + 14) + 16))(*((_QWORD **)a1 + 14), v6);
  v8 = EurekaCallCommandDriver::findCallCapability((uint64_t)a1, *MEMORY[0x24BDC3EF0], v6);
  if (a3 || !v8)
  {
    v9 = *v7;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v10 = 0;
      _os_log_impl(&dword_216897000, v9, OS_LOG_TYPE_DEFAULT, "#I Stop DTMF", v10, 2u);
    }
    EurekaCallCommandDriver::sendStopContDtmfReq(a1, a2);
  }
}

uint64_t EurekaCallCommandDriver::isMMIUSSDSupported(uint64_t a1, uint64_t a2)
{
  NSObject **v4;
  std::mutex *ServiceMap;
  std::mutex *v6;
  unint64_t v7;
  unsigned __int8 *v8;
  uint64_t v9;
  unsigned int v10;
  _QWORD *v11;
  std::__shared_weak_count *v12;
  uint64_t v13;
  unint64_t *p_shared_owners;
  unint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t *v21;
  unint64_t v22;
  NSObject *v23;
  uint8_t buf[8];
  std::__shared_weak_count *v26;
  unint64_t v27;

  v4 = (NSObject **)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 112) + 16))(*(_QWORD *)(a1 + 112));
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
  v6 = ServiceMap;
  v7 = *(_QWORD *)(MEMORY[0x24BDC3C78] + 8);
  if ((v7 & 0x8000000000000000) != 0)
  {
    v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    v9 = 5381;
    do
    {
      v7 = v9;
      v10 = *v8++;
      v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  *(_QWORD *)buf = 0;
  v26 = 0;
  std::mutex::lock(ServiceMap);
  v27 = v7;
  v11 = std::__hash_table<std::__hash_value_type<unsigned long,std::shared_ptr<void>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::shared_ptr<void>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::shared_ptr<void>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::shared_ptr<void>>>>::find<unsigned long>(&v6[1].__m_.__sig, &v27);
  if (v11)
  {
    v13 = v11[3];
    v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      p_shared_owners = (unint64_t *)&v12->__shared_owners_;
      do
        v15 = __ldxr(p_shared_owners);
      while (__stxr(v15 + 1, p_shared_owners));
    }
  }
  else
  {
    v13 = 0;
    v12 = 0;
  }
  *(_QWORD *)buf = v13;
  v26 = v12;
  std::mutex::unlock(v6);
  if (v12)
  {
    v16 = (unint64_t *)&v12->__shared_owners_;
    do
      v17 = __ldxr(v16);
    while (__stxr(v17 + 1, v16));
    do
      v18 = __ldaxr(v16);
    while (__stlxr(v18 - 1, v16));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  v19 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v13 + 408))(v13, a2);
  v20 = v19;
  if (!v12)
    goto LABEL_20;
  v21 = (unint64_t *)&v12->__shared_owners_;
  do
    v22 = __ldaxr(v21);
  while (__stlxr(v22 - 1, v21));
  if (!v22)
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
    if ((v20 & 1) != 0)
      return v20;
  }
  else
  {
LABEL_20:
    if ((v19 & 1) != 0)
      return v20;
  }
  v23 = *v4;
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_216897000, v23, OS_LOG_TYPE_DEFAULT, "#I We are CDMA technology; USSD is not supported",
      buf,
      2u);
  }
  return v20;
}

void sub_216A40590(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t EurekaCallCommandDriver::isUSSDFeatureSupportedByDriver()
{
  return 1;
}

uint64_t EurekaCallCommandDriver::supportsCallSwapWhenMax(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  uint64_t v7;
  std::__shared_weak_count *v8;

  v7 = 0;
  v8 = 0;
  EurekaCallCommandDriver::getPreferredFormatterForSim(&v7, a1, a2);
  if (v7)
    v2 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 160))(v7);
  else
    v2 = 0;
  v3 = v8;
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  return v2;
}

void sub_216A40650(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void EurekaCallCommandDriver::dumpState(NSObject **this)
{
  NSObject *v2;
  unsigned int *v3;
  unsigned int *v4;
  uint64_t (*v5)(_QWORD);
  char **v6;
  uint64_t v7;
  os_log_t *v8;
  uint64_t v9;
  os_log_t v10;
  _BOOL4 v11;
  uint64_t v12;
  NSObject *v13;
  const char *v14;
  uint32_t v15;
  char *v16;
  char **v17;
  int v18;
  BOOL v19;
  char **v20;
  NSObject *v21;
  _OWORD *v22;
  NSObject *v23;
  int v24;
  uint64_t v25;
  _QWORD *v26;
  _OWORD *v27;
  BOOL v28;
  std::__shared_weak_count *v29;
  unint64_t *p_shared_owners;
  unint64_t v31;
  unsigned int *v32;
  unsigned int *v33;
  uint64_t v34;
  std::__shared_weak_count *v35;
  uint8_t v36[4];
  uint64_t v37;
  __int16 v38;
  int v39;
  __int128 v40;
  uint64_t v41;
  __int128 buf;
  uint64_t (*v43)(_QWORD);
  uint64_t v44;

  v44 = *MEMORY[0x24BDAC8D0];
  CallCommandDriver::dumpState((CallCommandDriver *)this);
  v2 = this[5];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 136315138;
    *(_QWORD *)((char *)&buf + 4) = CSIBOOLAsString();
    _os_log_impl(&dword_216897000, v2, OS_LOG_TYPE_DEFAULT, "#I In ECBM Mode: %s", (uint8_t *)&buf, 0xCu);
  }
  subscriber::makeSimSlotRange();
  v3 = (unsigned int *)*((_QWORD *)&buf + 1);
  v4 = (unsigned int *)buf;
  if ((_QWORD)buf != *((_QWORD *)&buf + 1))
  {
    v5 = v43;
    while ((v5(*v4) & 1) == 0)
    {
      if (++v4 == v3)
      {
        v4 = v3;
        break;
      }
    }
    v33 = (unsigned int *)*((_QWORD *)&buf + 1);
    if (v4 != *((unsigned int **)&buf + 1))
    {
      v6 = (char **)(this + 36);
      do
      {
        v7 = *v4;
        v8 = (os_log_t *)(*((uint64_t (**)(NSObject *, uint64_t))this[14]->isa + 2))(this[14], v7);
        v34 = 0;
        v35 = 0;
        EurekaCallCommandDriver::getPreferredFormatterForSim(&v34, (uint64_t)this, v7);
        v9 = v34;
        v10 = *v8;
        v11 = os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT);
        if (v9)
        {
          if (v11)
          {
            v12 = *(_QWORD *)(v9 + 48);
            LODWORD(v40) = 136315138;
            *(_QWORD *)((char *)&v40 + 4) = v12;
            v13 = v10;
            v14 = "#I Preferred Formatter: %s";
            v15 = 12;
LABEL_15:
            _os_log_impl(&dword_216897000, v13, OS_LOG_TYPE_DEFAULT, v14, (uint8_t *)&v40, v15);
          }
        }
        else if (v11)
        {
          LOWORD(v40) = 0;
          v13 = v10;
          v14 = "#I Preferred Formatter is NULL";
          v15 = 2;
          goto LABEL_15;
        }
        v16 = *v6;
        if (*v6)
        {
          v17 = (char **)(this + 36);
          do
          {
            v18 = *((_DWORD *)v16 + 8);
            v19 = v18 < (int)v7;
            if (v18 >= (int)v7)
              v20 = (char **)v16;
            else
              v20 = (char **)(v16 + 8);
            if (!v19)
              v17 = (char **)v16;
            v16 = *v20;
          }
          while (*v20);
          if (v17 != v6 && (int)v7 >= *((_DWORD *)v17 + 8))
          {
            v40 = 0uLL;
            v41 = 0;
            std::map<char const*,int>::map[abi:ne180100]((uint64_t)&v40, v17 + 5);
            v21 = *v8;
            if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)v36 = 0;
              _os_log_impl(&dword_216897000, v21, OS_LOG_TYPE_DEFAULT, "#I Call Capabilities:", v36, 2u);
            }
            v22 = (_OWORD *)v40;
            if ((__int128 *)v40 != (__int128 *)((char *)&v40 + 8))
            {
              do
              {
                v23 = *v8;
                if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
                {
                  v24 = *((_DWORD *)v22 + 10);
                  v25 = *((_QWORD *)v22 + 4);
                  *(_DWORD *)v36 = 136315394;
                  v37 = v25;
                  v38 = 1024;
                  v39 = v24;
                  _os_log_impl(&dword_216897000, v23, OS_LOG_TYPE_DEFAULT, "#I \t%s = %d", v36, 0x12u);
                }
                v26 = (_QWORD *)*((_QWORD *)v22 + 1);
                if (v26)
                {
                  do
                  {
                    v27 = v26;
                    v26 = (_QWORD *)*v26;
                  }
                  while (v26);
                }
                else
                {
                  do
                  {
                    v27 = (_OWORD *)*((_QWORD *)v22 + 2);
                    v28 = *(_QWORD *)v27 == (_QWORD)v22;
                    v22 = v27;
                  }
                  while (!v28);
                }
                v22 = v27;
              }
              while (v27 != (__int128 *)((char *)&v40 + 8));
            }
            std::__tree<std::__value_type<std::pair<Technology,Type>,InputThreshold>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,InputThreshold>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,InputThreshold>>>::destroy((uint64_t)&v40, *((_QWORD **)&v40 + 1));
          }
        }
        v29 = v35;
        if (v35)
        {
          p_shared_owners = (unint64_t *)&v35->__shared_owners_;
          do
            v31 = __ldaxr(p_shared_owners);
          while (__stlxr(v31 - 1, p_shared_owners));
          if (!v31)
          {
            ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
            std::__shared_weak_count::__release_weak(v29);
          }
        }
        v32 = v4 + 1;
        v4 = v3;
        if (v32 != v3)
        {
          v4 = v32;
          while ((v5(*v4) & 1) == 0)
          {
            if (++v4 == v3)
            {
              v4 = v3;
              break;
            }
          }
        }
      }
      while (v4 != v33);
    }
  }
}

void sub_216A409EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t EurekaCallCommandDriver::start(EurekaCallCommandDriver *this)
{
  qmi::ClientRouter::start();
  qmi::ClientRouter::start();
  return qmi::ClientRouter::start();
}

uint64_t EurekaCallCommandDriver::bootstrap(_QWORD *a1, NSObject **a2)
{
  NSObject *v3;
  NSObject *v4;
  void **v5;
  uint64_t v6;
  uint64_t (***v7)();
  uint64_t v8;
  __int128 *v9;
  uint64_t v10;
  __int128 *v11;
  uint64_t v12;
  __int128 *v13;
  uint64_t v14;
  uint8_t *v15;
  uint64_t v16;
  uint8_t *v17;
  uint64_t v18;
  uint8_t *v19;
  uint64_t v20;
  uint8_t *v21;
  uint64_t v22;
  uint8_t *v23;
  uint64_t v24;
  uint8_t *v25;
  uint64_t v26;
  uint8_t *v27;
  uint64_t v28;
  uint8_t *v29;
  uint64_t v30;
  void *v31;
  std::__shared_weak_count *v32;
  uint64_t v33;
  std::__shared_weak_count *v34;
  std::__shared_weak_count *v35;
  NSObject *v36;
  NSObject *v37;
  unint64_t *p_shared_weak_owners;
  unint64_t v39;
  _QWORD *v40;
  unint64_t v41;
  uint64_t v42;
  char *v43;
  void *v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  char *i;
  char *v52;
  void *v53;
  __int128 v54;
  __int128 v55;
  uint64_t *v56;
  pthread_mutex_t *v57;
  uint64_t v58;
  unsigned int v59;
  uint64_t v60;
  unsigned int v61;
  uint64_t *v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t *v65;
  uint64_t v66;
  uint64_t *v67;
  _QWORD *v68;
  uint64_t v69;
  _QWORD *v70;
  _QWORD *v71;
  _QWORD *v72;
  uint64_t v73;
  _QWORD *v74;
  uint64_t v75;
  uint64_t v76;
  _QWORD *v77;
  unsigned int *v78;
  unsigned int v79;
  _QWORD *v80;
  char v81;
  _QWORD *v82;
  _QWORD *v83;
  _QWORD *v84;
  _QWORD *v85;
  _QWORD *v86;
  BOOL v87;
  uint64_t v88;
  uint64_t **v89;
  _QWORD *v90;
  __int128 v91;
  _QWORD *v92;
  _QWORD *v93;
  _QWORD *v94;
  uint64_t v95;
  uint64_t v96;
  _QWORD *v97;
  _QWORD *v98;
  _QWORD *v99;
  _QWORD *v100;
  uint64_t v101;
  _QWORD *v102;
  _QWORD *v103;
  _QWORD *v104;
  _QWORD *v105;
  uint64_t v106;
  uint64_t v107;
  unsigned int *v108;
  unsigned int v109;
  _QWORD *v110;
  uint64_t v111;
  unint64_t v112;
  uint64_t v113;
  uint64_t *v114;
  uint64_t v115;
  uint64_t v116;
  char *v117;
  char *v118;
  unint64_t v119;
  char *v120;
  uint64_t v121;
  uint64_t v122;
  unint64_t v123;
  _QWORD *v124;
  uint64_t v125;
  uint64_t v126;
  unsigned int *v127;
  unsigned int v128;
  _QWORD *v129;
  uint64_t v130;
  uint64_t *v131;
  _QWORD *v132;
  uint64_t *v133;
  _BOOL4 v134;
  _QWORD *v135;
  uint64_t v136;
  uint64_t v137;
  char v138;
  uint64_t *v139;
  _QWORD *v140;
  _QWORD *v141;
  unsigned int *v142;
  unsigned int v143;
  uint64_t v144;
  _QWORD *v145;
  uint64_t *v146;
  _BOOL4 v147;
  _QWORD *v148;
  uint64_t **v149;
  _OWORD *v150;
  uint64_t v151;
  __int128 v152;
  unsigned int *v153;
  unsigned int v154;
  unsigned int v155;
  unint64_t *p_shared_owners;
  unint64_t v157;
  _OWORD *v158;
  uint64_t v159;
  uint8_t *v160;
  uint64_t v161;
  _QWORD *v162;
  uint8_t *v163;
  uint64_t v164;
  uint8_t *v165;
  uint64_t v166;
  uint64_t result;
  unsigned int *v168;
  unsigned int *v169;
  uint64_t (*v170)(_QWORD);
  unsigned int *v171;
  unsigned int *v172;
  const char *v173;
  int v174;
  const char *v175;
  const char *v176;
  uint64_t *v177;
  uint64_t v178;
  _QWORD *v179;
  _QWORD *v180;
  const void *v181;
  _QWORD *v182;
  std::__shared_weak_count *v183;
  void *v184;
  NSObject *group;
  __int128 v186;
  dispatch_object_t object[2];
  NSObject *v188[2];
  NSObject *v189[2];
  NSObject *v190[2];
  NSObject *v191[2];
  __int128 v192;
  __int128 *v193;
  __int128 v194;
  __int128 *v195;
  uint64_t (**aBlock)();
  uint64_t v197;
  uint64_t (*v198)(_QWORD *);
  uint64_t (***p_aBlock)();
  _QWORD *v200;
  uint64_t (*v201)(EurekaCallCommandDriver *);
  uint64_t v202;
  void *__p[4];
  __int128 v204;
  uint64_t v205;
  __int128 v206;
  _QWORD *v207;
  __int128 *v208;
  uint8_t buf[32];
  __int128 v210;
  __int128 v211;
  __int128 v212;
  __int128 v213;
  __int128 v214;
  __int128 v215;
  __int128 v216;
  __int128 v217;
  __int128 v218;
  __int128 v219;
  uint64_t v220;

  v220 = *MEMORY[0x24BDAC8D0];
  v3 = *a2;
  group = *a2;
  if (*a2)
  {
    dispatch_retain(v3);
    dispatch_group_enter(v3);
  }
  CallCommandDriver::bootstrap();
  if (group)
  {
    dispatch_group_leave(group);
    dispatch_release(group);
  }
  v4 = a1[5];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I Eureka base class registering for QMI indications", buf, 2u);
  }
  __p[0] = &off_24D5E3530;
  __p[1] = a1;
  __p[3] = __p;
  qmi::ClientRouter::setHandler();
  v5 = (void **)__p[3];
  if (__p[3] == __p)
  {
    v6 = 4;
    v5 = __p;
  }
  else
  {
    if (!__p[3])
      goto LABEL_12;
    v6 = 5;
  }
  (*((void (**)(void))*v5 + v6))();
LABEL_12:
  aBlock = &off_24D5E35B0;
  v197 = (uint64_t)a1;
  p_aBlock = &aBlock;
  qmi::ClientRouter::setHandler();
  v7 = p_aBlock;
  if (p_aBlock == &aBlock)
  {
    v8 = 4;
    v7 = &aBlock;
  }
  else
  {
    if (!p_aBlock)
      goto LABEL_17;
    v8 = 5;
  }
  (*v7)[v8]();
LABEL_17:
  *(_QWORD *)&v206 = &off_24D5E3630;
  *((_QWORD *)&v206 + 1) = a1;
  v208 = &v206;
  qmi::ClientRouter::setHandler();
  v9 = v208;
  if (v208 == &v206)
  {
    v10 = 4;
    v9 = &v206;
  }
  else
  {
    if (!v208)
      goto LABEL_22;
    v10 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v9 + 8 * v10))();
LABEL_22:
  *(_QWORD *)&v194 = &off_24D5E36B0;
  *((_QWORD *)&v194 + 1) = a1;
  v195 = &v194;
  qmi::ClientRouter::setHandler();
  v11 = v195;
  if (v195 == &v194)
  {
    v12 = 4;
    v11 = &v194;
  }
  else
  {
    if (!v195)
      goto LABEL_27;
    v12 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v11 + 8 * v12))();
LABEL_27:
  *(_QWORD *)&v192 = &off_24D5E3730;
  *((_QWORD *)&v192 + 1) = a1;
  v193 = &v192;
  qmi::ClientRouter::setHandler();
  v13 = v193;
  if (v193 == &v192)
  {
    v14 = 4;
    v13 = &v192;
  }
  else
  {
    if (!v193)
      goto LABEL_32;
    v14 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v13 + 8 * v14))();
LABEL_32:
  *(_QWORD *)buf = &off_24D5E37B0;
  *(_QWORD *)&buf[8] = a1;
  *(_QWORD *)&buf[24] = buf;
  qmi::ClientRouter::setIndHandlerInternal();
  v15 = *(uint8_t **)&buf[24];
  if (*(uint8_t **)&buf[24] == buf)
  {
    v16 = 4;
    v15 = buf;
  }
  else
  {
    if (!*(_QWORD *)&buf[24])
      goto LABEL_37;
    v16 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v15 + 8 * v16))();
LABEL_37:
  qmi::ClientRouter::setIndShouldWake((qmi::ClientRouter *)(a1 + 17));
  *(_QWORD *)buf = &off_24D5E3830;
  *(_QWORD *)&buf[8] = a1;
  *(_QWORD *)&buf[24] = buf;
  qmi::ClientRouter::setIndHandlerInternal();
  v17 = *(uint8_t **)&buf[24];
  if (*(uint8_t **)&buf[24] == buf)
  {
    v18 = 4;
    v17 = buf;
  }
  else
  {
    if (!*(_QWORD *)&buf[24])
      goto LABEL_42;
    v18 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v17 + 8 * v18))();
LABEL_42:
  qmi::ClientRouter::setIndShouldWake((qmi::ClientRouter *)(a1 + 17));
  *(_QWORD *)buf = &off_24D5E38B0;
  *(_QWORD *)&buf[8] = a1;
  *(_QWORD *)&buf[24] = buf;
  qmi::ClientRouter::setIndHandlerInternal();
  v19 = *(uint8_t **)&buf[24];
  if (*(uint8_t **)&buf[24] == buf)
  {
    v20 = 4;
    v19 = buf;
  }
  else
  {
    if (!*(_QWORD *)&buf[24])
      goto LABEL_47;
    v20 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v19 + 8 * v20))();
LABEL_47:
  qmi::ClientRouter::setIndShouldWake((qmi::ClientRouter *)(a1 + 17));
  *(_QWORD *)buf = &off_24D5E3930;
  *(_QWORD *)&buf[8] = a1;
  *(_QWORD *)&buf[24] = buf;
  qmi::ClientRouter::setIndHandlerInternal();
  v21 = *(uint8_t **)&buf[24];
  if (*(uint8_t **)&buf[24] == buf)
  {
    v22 = 4;
    v21 = buf;
  }
  else
  {
    if (!*(_QWORD *)&buf[24])
      goto LABEL_52;
    v22 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v21 + 8 * v22))();
LABEL_52:
  qmi::ClientRouter::setIndShouldWake((qmi::ClientRouter *)(a1 + 17));
  *(_QWORD *)buf = &off_24D5E39B0;
  *(_QWORD *)&buf[8] = a1;
  *(_QWORD *)&buf[24] = buf;
  qmi::ClientRouter::setIndHandlerInternal();
  v23 = *(uint8_t **)&buf[24];
  if (*(uint8_t **)&buf[24] == buf)
  {
    v24 = 4;
    v23 = buf;
  }
  else
  {
    if (!*(_QWORD *)&buf[24])
      goto LABEL_57;
    v24 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v23 + 8 * v24))();
LABEL_57:
  *(_QWORD *)buf = &off_24D5E3A30;
  *(_QWORD *)&buf[8] = a1;
  *(_QWORD *)&buf[24] = buf;
  qmi::ClientRouter::setIndHandlerInternal();
  v25 = *(uint8_t **)&buf[24];
  if (*(uint8_t **)&buf[24] == buf)
  {
    v26 = 4;
    v25 = buf;
  }
  else
  {
    if (!*(_QWORD *)&buf[24])
      goto LABEL_62;
    v26 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v25 + 8 * v26))();
LABEL_62:
  *(_QWORD *)buf = &off_24D5E3AB0;
  *(_QWORD *)&buf[8] = a1;
  *(_QWORD *)&buf[24] = buf;
  qmi::ClientRouter::setIndHandlerInternal();
  v27 = *(uint8_t **)&buf[24];
  if (*(uint8_t **)&buf[24] == buf)
  {
    v28 = 4;
    v27 = buf;
  }
  else
  {
    if (!*(_QWORD *)&buf[24])
      goto LABEL_67;
    v28 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v27 + 8 * v28))();
LABEL_67:
  *(_QWORD *)buf = &off_24D5E3B30;
  *(_QWORD *)&buf[8] = a1;
  *(_QWORD *)&buf[24] = buf;
  qmi::ClientRouter::setIndHandlerInternal();
  v29 = *(uint8_t **)&buf[24];
  if (*(uint8_t **)&buf[24] == buf)
  {
    v30 = 4;
    v29 = buf;
    goto LABEL_71;
  }
  if (*(_QWORD *)&buf[24])
  {
    v30 = 5;
LABEL_71:
    (*(void (**)(void))(*(_QWORD *)v29 + 8 * v30))();
  }
  aBlock = (uint64_t (**)())MEMORY[0x24BDAC760];
  v197 = 0x40000000;
  v198 = ___ZN3ctu20SharedSynchronizableI17CallCommandDriverE13connect_eventIN5event11EventLoggerIFvvENS4_14CSIEventLoggerEEE23EurekaCallCommandDrivervJEEEDTcl7connectfp_cvNSt3__110shared_ptrIS1_EE_EcvP16dispatch_queue_s_EcvPFT1_DpT2_ELi0EEERT_MT0_FSF_SH_E_block_invoke;
  p_aBlock = (uint64_t (***)())&__block_descriptor_tmp_141_0;
  v200 = a1 + 1;
  v201 = EurekaCallCommandDriver::handleNotRegistered;
  v202 = 0;
  v31 = _Block_copy(&aBlock);
  v32 = (std::__shared_weak_count *)a1[2];
  if (!v32 || (v33 = a1[1], (v34 = std::__shared_weak_count::lock(v32)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v35 = v34;
  v36 = a1[3];
  object[0] = v36;
  if (v31)
  {
    v37 = _Block_copy(v31);
    v36 = object[0];
  }
  else
  {
    v37 = 0;
  }
  object[1] = v37;
  dispatch_retain(v36);
  memset(__p, 0, sizeof(__p));
  ctu::DispatchSlot<dispatch::block<void({block_pointer})(void)>>::DispatchSlot(v188, v36, v37);
  ctu::DispatchSlot<dispatch::block<void({block_pointer})(void)>>::DispatchSlot(v189, v188[0], v188[1]);
  ctu::DispatchSlot<dispatch::block<void({block_pointer})(void)>>::DispatchSlot(v190, v189[0], v189[1]);
  *(_QWORD *)&v206 = 0;
  ctu::DispatchSlot<dispatch::block<void({block_pointer})(void)>>::DispatchSlot(v191, v190[0], v190[1]);
  ctu::DispatchSlot<dispatch::block<void({block_pointer})(void)>>::DispatchSlot((NSObject **)&v192, v191[0], v191[1]);
  ctu::DispatchSlot<dispatch::block<void({block_pointer})(void)>>::DispatchSlot((NSObject **)&v194, v192, *((void **)&v192 + 1));
  ctu::DispatchSlot<dispatch::block<void({block_pointer})(void)>>::DispatchSlot((NSObject **)buf, v194, *((void **)&v194 + 1));
  ctu::DispatchSlot<dispatch::block<void({block_pointer})(void)>>::DispatchSlot((NSObject **)&v206 + 1, *(NSObject **)buf, *(void **)&buf[8]);
  ctu::DispatchSlot<dispatch::block<void({block_pointer})(void)>>::~DispatchSlot((uint64_t)buf);
  ctu::DispatchSlot<dispatch::block<void({block_pointer})(void)>>::~DispatchSlot((uint64_t)&v194);
  ctu::DispatchSlot<dispatch::block<void({block_pointer})(void)>>::~DispatchSlot((uint64_t)&v192);
  *(_QWORD *)&v206 = &boost::function0<void>::assign_to<ctu::DispatchSlot<dispatch::block<void({block_pointer})(void)>>>(ctu::DispatchSlot<dispatch::block<void({block_pointer})(void)>>)::stored_vtable;
  ctu::DispatchSlot<dispatch::block<void({block_pointer})(void)>>::~DispatchSlot((uint64_t)v191);
  ctu::DispatchSlot<dispatch::block<void({block_pointer})(void)>>::~DispatchSlot((uint64_t)v190);
  memset(buf, 0, sizeof(buf));
  boost::function0<void>::move_assign((uint64_t)buf, (uint64_t *)&v206);
  boost::function0<void>::move_assign((uint64_t)&v206, (uint64_t *)&__p[3]);
  boost::function0<void>::move_assign((uint64_t)&__p[3], (uint64_t *)buf);
  v182 = a1 + 42;
  boost::function0<void>::~function0((uint64_t *)buf);
  boost::function0<void>::~function0((uint64_t *)&v206);
  ctu::DispatchSlot<dispatch::block<void({block_pointer})(void)>>::~DispatchSlot((uint64_t)v189);
  ctu::DispatchSlot<dispatch::block<void({block_pointer})(void)>>::~DispatchSlot((uint64_t)v188);
  p_shared_weak_owners = (unint64_t *)&v35->__shared_weak_owners_;
  do
    v39 = __ldxr(p_shared_weak_owners);
  while (__stxr(v39 + 1, p_shared_weak_owners));
  v183 = v35;
  v40 = (_QWORD *)operator new();
  *v40 = &off_24D5E3F28;
  v40[1] = v33;
  v40[2] = v35;
  do
    v41 = __ldxr(p_shared_weak_owners);
  while (__stxr(v41 + 1, p_shared_weak_owners));
  *(_QWORD *)&v194 = v40;
  v42 = boost::scoped_ptr<boost::signals2::detail::foreign_weak_ptr_impl_base>::operator->((uint64_t *)&v194);
  *((_QWORD *)&v206 + 1) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v42 + 32))(v42);
  LODWORD(v206) = 2;
  v43 = (char *)__p[1];
  if (__p[1] >= __p[2])
  {
    v45 = 0xAAAAAAAAAAAAAAABLL * (((char *)__p[1] - (char *)__p[0]) >> 3);
    if (v45 + 1 > 0xAAAAAAAAAAAAAAALL)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v46 = 0x5555555555555556 * (((char *)__p[2] - (char *)__p[0]) >> 3);
    if (v46 <= v45 + 1)
      v46 = v45 + 1;
    if (0xAAAAAAAAAAAAAAABLL * (((char *)__p[2] - (char *)__p[0]) >> 3) >= 0x555555555555555)
      v47 = 0xAAAAAAAAAAAAAAALL;
    else
      v47 = v46;
    *(_QWORD *)&v210 = &__p[2];
    if (v47)
      v47 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>>>(v47);
    else
      v48 = 0;
    *(_QWORD *)buf = v47;
    *(_QWORD *)&buf[8] = v47 + 24 * v45;
    *(_QWORD *)&buf[16] = *(_QWORD *)&buf[8];
    *(_QWORD *)&buf[24] = v47 + 24 * v48;
    boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>::variant(*(uint64_t *)&buf[8], (uint64_t)&v206);
    v49 = 0;
    v50 = *(_QWORD *)&buf[8];
    *(_QWORD *)&buf[16] += 24;
    v52 = (char *)__p[0];
    for (i = (char *)__p[1];
          &i[v49] != v52;
          boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>::variant(v49 + v50, (uint64_t)&i[v49]))
    {
      v49 -= 24;
    }
    v53 = __p[2];
    v184 = *(void **)&buf[16];
    v54 = *(_OWORD *)&buf[16];
    v55 = *(_OWORD *)__p;
    __p[0] = (void *)(v50 + v49);
    *(_OWORD *)&buf[8] = v55;
    *(_OWORD *)&__p[1] = v54;
    *(_QWORD *)&buf[24] = v53;
    *(_QWORD *)buf = v55;
    std::__split_buffer<boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>>::~__split_buffer((uint64_t)buf);
    v44 = v184;
  }
  else
  {
    boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>::variant((uint64_t)__p[1], (uint64_t)&v206);
    v44 = v43 + 24;
  }
  __p[1] = v44;
  boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>::destroy_content((uint64_t)&v206);
  if ((_QWORD)v194)
    (*(void (**)(_QWORD))(*(_QWORD *)v194 + 8))(v194);
  std::__shared_weak_count::__release_weak(v35);
  v56 = *(uint64_t **)(MEMORY[0x24BDC3980] + 8);
  if (!v56)
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  v218 = 0u;
  v219 = 0u;
  v216 = 0u;
  v217 = 0u;
  v214 = 0u;
  v215 = 0u;
  v212 = 0u;
  v213 = 0u;
  v210 = 0u;
  v211 = 0u;
  memset(buf, 0, sizeof(buf));
  v57 = (pthread_mutex_t *)boost::shared_ptr<boost::signals2::mutex>::operator*(v56 + 3);
  boost::signals2::detail::garbage_collecting_lock<boost::signals2::mutex>::garbage_collecting_lock(buf, v57);
  v194 = 0uLL;
  v58 = v56[1];
  v181 = v31;
  if (!v58 || (v59 = atomic_load((unsigned int *)(v58 + 8)), v59 != 1))
  {
    v66 = operator new();
    v67 = (uint64_t *)*v56;
    if (!*v56)
      __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
    v68 = (_QWORD *)v66;
    v178 = *v56;
    v179 = a1;
    v69 = *v67;
    boost::shared_ptr<boost::signals2::detail::grouped_list<int,std::less<int>,boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>>>::operator*(*v67);
    v180 = v68;
    v70 = (_QWORD *)operator new();
    v71 = v70;
    v177 = v56;
    *v70 = v70;
    v70[1] = v70;
    v70[2] = 0;
    v72 = *(_QWORD **)(v69 + 8);
    if (v72 != (_QWORD *)v69)
    {
      v73 = 0;
      v74 = v70;
      do
      {
        v76 = v72[2];
        v75 = v72[3];
        v77 = operator new(0x20uLL);
        v77[2] = v76;
        v77[3] = v75;
        if (v75)
        {
          v78 = (unsigned int *)(v75 + 8);
          do
            v79 = __ldxr(v78);
          while (__stxr(v79 + 1, v78));
          v74 = (_QWORD *)*v71;
          v73 = v71[2];
        }
        *v77 = v74;
        v77[1] = v71;
        v74[1] = v77;
        *v71 = v77;
        v71[2] = ++v73;
        v72 = (_QWORD *)v72[1];
        v74 = v77;
      }
      while (v72 != (_QWORD *)v69);
    }
    v71[5] = 0;
    v71[4] = 0;
    v80 = v71 + 4;
    v81 = *(_BYTE *)(v69 + 48);
    v71[3] = v71 + 4;
    *((_BYTE *)v71 + 48) = v81;
    v82 = *(_QWORD **)(v69 + 24);
    v83 = (_QWORD *)(v69 + 32);
    if (v82 == (_QWORD *)(v69 + 32))
    {
LABEL_136:
      *((_BYTE *)v71 + 56) = *(_BYTE *)(v69 + 56);
      if (v82 != v83)
      {
        v94 = (_QWORD *)v71[3];
        v95 = v71[1];
        do
        {
          if (v94 == v80)
            __assert_rtn("grouped_list", "slot_groups.hpp", 80, "this_map_it != _group_map.end()");
          v94[6] = v95;
          v96 = v69;
          if (v82 != v83)
            v96 = v82[6];
          v97 = (_QWORD *)v82[1];
          v98 = v97;
          v99 = v82;
          if (v97)
          {
            do
            {
              v100 = v98;
              v98 = (_QWORD *)*v98;
            }
            while (v98);
          }
          else
          {
            do
            {
              v100 = (_QWORD *)v99[2];
              v87 = *v100 == (_QWORD)v99;
              v99 = v100;
            }
            while (!v87);
          }
          v101 = v69;
          if (v100 != v83)
            v101 = v100[6];
          while (v96 != v101)
          {
            v96 = *(_QWORD *)(v96 + 8);
            v95 = *(_QWORD *)(v95 + 8);
          }
          if (v97)
          {
            do
            {
              v102 = v97;
              v97 = (_QWORD *)*v97;
            }
            while (v97);
          }
          else
          {
            do
            {
              v102 = (_QWORD *)v82[2];
              v87 = *v102 == (_QWORD)v82;
              v82 = v102;
            }
            while (!v87);
          }
          v103 = (_QWORD *)v94[1];
          if (v103)
          {
            do
            {
              v104 = v103;
              v103 = (_QWORD *)*v103;
            }
            while (v103);
          }
          else
          {
            do
            {
              v104 = (_QWORD *)v94[2];
              v87 = *v104 == (_QWORD)v94;
              v94 = v104;
            }
            while (!v87);
          }
          v82 = v102;
          v94 = v104;
        }
        while (v102 != v83);
      }
      *v180 = v71;
      v180[1] = 0;
      v105 = (_QWORD *)operator new();
      v105[1] = 0x100000001;
      *v105 = &off_24D5E3D00;
      v105[2] = v71;
      v106 = v180[1];
      v180[1] = v105;
      *(_QWORD *)&v206 = v106;
      boost::detail::shared_count::~shared_count((unsigned int **)&v206);
      v56 = v177;
      v180[2] = *(_QWORD *)(v178 + 16);
      v107 = *(_QWORD *)(v178 + 24);
      v180[3] = v107;
      if (v107)
      {
        v108 = (unsigned int *)(v107 + 8);
        do
          v109 = __ldxr(v108);
        while (__stxr(v109 + 1, v108));
      }
      a1 = v179;
      if ((_QWORD *)*v177 != v180)
      {
        v206 = (unint64_t)v180;
        v110 = (_QWORD *)operator new();
        v110[1] = 0x100000001;
        *v110 = &off_24D5E3CA0;
        v110[2] = v180;
        v111 = *((_QWORD *)&v206 + 1);
        *((_QWORD *)&v206 + 1) = v110;
        *(_QWORD *)&v192 = v111;
        boost::detail::shared_count::~shared_count((unsigned int **)&v192);
        v112 = v206;
        v113 = v177[1];
        *(_QWORD *)&v206 = *v177;
        *(_OWORD *)v177 = __PAIR128__(*((unint64_t *)&v206 + 1), v112);
        *((_QWORD *)&v206 + 1) = v113;
        boost::detail::shared_count::~shared_count((unsigned int **)&v206 + 1);
        v114 = (uint64_t *)boost::shared_ptr<boost::signals2::detail::signal_impl<void ()(void),boost::signals2::optional_last_value<void>,int,std::less<int>,boost::function<void ()(void)>,boost::function<void ()(boost::signals2::connection const&)>,boost::signals2::mutex>::invocation_state>::operator->(*v177);
        *(_QWORD *)&v206 = *(_QWORD *)(boost::shared_ptr<boost::signals2::detail::grouped_list<int,std::less<int>,boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>>>::operator*(*v114)
                                     + 8);
        boost::signals2::detail::signal_impl<void ()(void),boost::signals2::optional_last_value<void>,int,std::less<int>,boost::function<void ()(void)>,boost::function<void ()(boost::signals2::connection const&)>,boost::signals2::mutex>::nolock_cleanup_connections_from(v177, buf, (uint64_t **)&v206, 0);
        goto LABEL_166;
      }
      v173 = "p == 0 || p != px";
      v174 = 734;
      v175 = "shared_ptr.hpp";
      v176 = "reset";
LABEL_254:
      __assert_rtn(v176, v175, v174, v173);
    }
    while (1)
    {
      *(_QWORD *)&v206 = 0;
      v84 = (_QWORD *)*v80;
      if ((_QWORD *)v71[3] == v80)
      {
        v86 = v71 + 4;
      }
      else
      {
        v85 = v71 + 4;
        if (v84)
        {
          do
          {
            v86 = v84;
            v84 = (_QWORD *)v84[1];
          }
          while (v84);
        }
        else
        {
          do
          {
            v86 = (_QWORD *)v85[2];
            v87 = *v86 == (_QWORD)v85;
            v85 = v86;
          }
          while (v87);
        }
        if (!boost::signals2::detail::group_key_less<int,std::less<int>>::operator()((uint64_t)(v71 + 6), (uint64_t)(v86 + 4), (uint64_t)(v82 + 4)))
        {
          v89 = (uint64_t **)std::__tree<std::__value_type<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,std::__list_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>,void *>>,std::__map_value_compare<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,std::__value_type<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,std::__list_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>,void *>>,boost::signals2::detail::group_key_less<int,std::less<int>>,false>,std::allocator<std::__value_type<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,std::__list_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>,void *>>>>::__find_equal<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>>((uint64_t)(v71 + 3), &v206, (uint64_t)(v82 + 4));
          goto LABEL_126;
        }
        v84 = (_QWORD *)*v80;
      }
      v88 = (uint64_t)(v71 + 4);
      v89 = (uint64_t **)(v71 + 4);
      if (!v84)
        goto LABEL_128;
      *(_QWORD *)&v206 = v86;
      v89 = (uint64_t **)(v86 + 1);
LABEL_126:
      if (!*v89)
      {
        v88 = v206;
LABEL_128:
        v90 = operator new(0x38uLL);
        v91 = *((_OWORD *)v82 + 2);
        v90[6] = v82[6];
        *((_OWORD *)v90 + 2) = v91;
        std::__tree<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::less<unsigned short>,true>,std::allocator<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>>>::__insert_node_at((uint64_t **)v71 + 3, v88, v89, v90);
      }
      v92 = (_QWORD *)v82[1];
      if (v92)
      {
        do
        {
          v93 = v92;
          v92 = (_QWORD *)*v92;
        }
        while (v92);
      }
      else
      {
        do
        {
          v93 = (_QWORD *)v82[2];
          v87 = *v93 == (_QWORD)v82;
          v82 = v93;
        }
        while (!v87);
      }
      v82 = v93;
      if (v93 == v83)
      {
        v82 = *(_QWORD **)(v69 + 24);
        goto LABEL_136;
      }
    }
  }
  v60 = v56[1];
  if (!v60 || (v61 = atomic_load((unsigned int *)(v60 + 8)), v61 != 1))
  {
    v173 = "_shared_state.unique()";
    v174 = 461;
    v175 = "signal_template.hpp";
    v176 = "nolock_cleanup_connections";
    goto LABEL_254;
  }
  v62 = (uint64_t *)boost::shared_ptr<boost::signals2::detail::signal_impl<void ()(void),boost::signals2::optional_last_value<void>,int,std::less<int>,boost::function<void ()(void)>,boost::function<void ()(boost::signals2::connection const&)>,boost::signals2::mutex>::invocation_state>::operator->(*v56);
  v63 = boost::shared_ptr<boost::signals2::detail::grouped_list<int,std::less<int>,boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>>>::operator*(*v62);
  v64 = v56[2];
  if (v64 == v63)
  {
    v65 = (uint64_t *)boost::shared_ptr<boost::signals2::detail::signal_impl<void ()(void),boost::signals2::optional_last_value<void>,int,std::less<int>,boost::function<void ()(void)>,boost::function<void ()(boost::signals2::connection const&)>,boost::signals2::mutex>::invocation_state>::operator->(*v56);
    v64 = *(_QWORD *)(boost::shared_ptr<boost::signals2::detail::grouped_list<int,std::less<int>,boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>>>::operator*(*v65)
                    + 8);
  }
  *(_QWORD *)&v206 = v64;
  boost::signals2::detail::signal_impl<void ()(void),boost::signals2::optional_last_value<void>,int,std::less<int>,boost::function<void ()(void)>,boost::function<void ()(boost::signals2::connection const&)>,boost::signals2::mutex>::nolock_cleanup_connections_from(v56, buf, (uint64_t **)&v206, 2);
LABEL_166:
  v115 = operator new();
  *(_QWORD *)(v115 + 8) = 0;
  *(_QWORD *)(v115 + 16) = 0;
  *(_BYTE *)(v115 + 24) = 1;
  *(_DWORD *)(v115 + 28) = 1;
  *(_QWORD *)v115 = &off_24D5E3D60;
  v116 = operator new();
  *(_QWORD *)v116 = 0;
  *(_QWORD *)(v116 + 8) = 0;
  *(_QWORD *)(v116 + 16) = 0;
  v117 = (char *)__p[0];
  v118 = (char *)__p[1];
  *(_QWORD *)&v206 = v116;
  if (__p[1] != __p[0])
  {
    v119 = 0xAAAAAAAAAAAAAAABLL * (((char *)__p[1] - (char *)__p[0]) >> 3);
    *((_QWORD *)&v206 + 1) = 0;
    if (v119 > 0xAAAAAAAAAAAAAAALL)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v120 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>>>(v119);
    v121 = 0;
    *(_QWORD *)v116 = v120;
    *(_QWORD *)(v116 + 8) = v120;
    *(_QWORD *)(v116 + 16) = &v120[24 * v122];
    do
    {
      boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>::variant((uint64_t)&v120[v121], (uint64_t)&v117[v121]);
      v121 += 24;
    }
    while (&v117[v121] != v118);
    *(_QWORD *)(v116 + 8) = &v120[v121];
  }
  *(_QWORD *)(v116 + 24) = 0;
  v123 = (unint64_t)__p[3];
  if (__p[3])
  {
    *(void **)(v116 + 24) = __p[3];
    if ((v123 & 1) != 0)
    {
      *(_OWORD *)(v116 + 32) = v204;
      *(_QWORD *)(v116 + 48) = v205;
    }
    else
    {
      (*(void (**)(__int128 *, uint64_t, _QWORD))(v123 & 0xFFFFFFFFFFFFFFFELL))(&v204, v116 + 32, 0);
    }
  }
  *(_QWORD *)(v115 + 40) = 0;
  *(_QWORD *)(v115 + 32) = v116;
  v124 = (_QWORD *)operator new();
  v124[1] = 0x100000001;
  *v124 = &off_24D5E3E08;
  v124[2] = v116;
  v125 = *(_QWORD *)(v115 + 40);
  *(_QWORD *)(v115 + 40) = v124;
  *(_QWORD *)&v206 = v125;
  boost::detail::shared_count::~shared_count((unsigned int **)&v206);
  *(_QWORD *)(v115 + 48) = v56[3];
  v126 = v56[4];
  *(_QWORD *)(v115 + 56) = v126;
  if (v126)
  {
    v127 = (unsigned int *)(v126 + 8);
    do
      v128 = __ldxr(v127);
    while (__stxr(v128 + 1, v127));
  }
  *(_DWORD *)(v115 + 64) = 0;
  *(_BYTE *)(v115 + 68) = 0;
  v194 = (unint64_t)v115;
  v129 = (_QWORD *)operator new();
  v129[1] = 0x100000001;
  *v129 = &off_24D5E3E68;
  v129[2] = v115;
  *((_QWORD *)&v194 + 1) = v129;
  *(_QWORD *)&v206 = 0;
  boost::detail::shared_count::~shared_count((unsigned int **)&v206);
  *(_QWORD *)((char *)&v192 + 4) = 0;
  LODWORD(v192) = 2;
  v130 = *(_QWORD *)boost::shared_ptr<boost::signals2::detail::signal_impl<void ()(void),boost::signals2::optional_last_value<void>,int,std::less<int>,boost::function<void ()(void)>,boost::function<void ()(boost::signals2::connection const&)>,boost::signals2::mutex>::invocation_state>::operator->(*v56);
  boost::shared_ptr<boost::signals2::detail::grouped_list<int,std::less<int>,boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>>>::operator*(v130);
  v131 = (uint64_t *)(v130 + 32);
  if ((_DWORD)v192 == 2 || (v132 = (_QWORD *)*v131) == 0)
  {
    v138 = 1;
    v136 = *((_QWORD *)&v194 + 1);
    v137 = v194;
  }
  else
  {
    v133 = (uint64_t *)(v130 + 32);
    do
    {
      v134 = boost::signals2::detail::group_key_less<int,std::less<int>>::operator()(v130 + 48, (uint64_t)&v192, (uint64_t)(v132 + 4));
      v135 = v132 + 1;
      if (v134)
      {
        v135 = v132;
        v133 = v132;
      }
      v132 = (_QWORD *)*v135;
    }
    while (*v135);
    v136 = *((_QWORD *)&v194 + 1);
    v137 = v194;
    if (v133 != v131)
    {
      v138 = 0;
      v139 = (uint64_t *)v133[6];
      goto LABEL_188;
    }
    v138 = 1;
  }
  v133 = (uint64_t *)(v130 + 32);
  v139 = (uint64_t *)v130;
LABEL_188:
  v140 = operator new(0x20uLL);
  v141 = v140;
  v140[2] = v137;
  v140[3] = v136;
  if (v136)
  {
    v142 = (unsigned int *)(v136 + 8);
    do
      v143 = __ldxr(v142);
    while (__stxr(v143 + 1, v142));
  }
  v144 = *v139;
  *(_QWORD *)(v144 + 8) = v140;
  *v140 = v144;
  *v139 = (uint64_t)v140;
  v140[1] = v139;
  ++*(_QWORD *)(v130 + 16);
  if ((v138 & 1) == 0
    && boost::signals2::detail::grouped_list<int,std::less<int>,boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>>::weakly_equivalent(v130, (uint64_t)&v192, (uint64_t)(v133 + 4)))
  {
    std::__tree<std::__value_type<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,std::__list_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>,void *>>,std::__map_value_compare<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,std::__value_type<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,std::__list_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>,void *>>,boost::signals2::detail::group_key_less<int,std::less<int>>,false>,std::allocator<std::__value_type<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,std::__list_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>,void *>>>>::__remove_node_pointer((uint64_t **)(v130 + 24), v133);
    operator delete(v133);
  }
  v145 = (_QWORD *)*v131;
  if (!*v131)
    goto LABEL_201;
  v146 = (uint64_t *)(v130 + 32);
  do
  {
    v147 = boost::signals2::detail::group_key_less<int,std::less<int>>::operator()(v130 + 48, (uint64_t)(v145 + 4), (uint64_t)&v192);
    v148 = v145 + 1;
    if (!v147)
    {
      v148 = v145;
      v146 = v145;
    }
    v145 = (_QWORD *)*v148;
  }
  while (*v148);
  if (v146 == v131
    || !boost::signals2::detail::grouped_list<int,std::less<int>,boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>>::weakly_equivalent(v130, (uint64_t)(v146 + 4), (uint64_t)&v192))
  {
LABEL_201:
    *(_QWORD *)&v206 = v192;
    DWORD2(v206) = DWORD2(v192);
    v207 = v141;
    v191[0] = 0;
    v149 = (uint64_t **)std::__tree<std::__value_type<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,std::__list_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>,void *>>,std::__map_value_compare<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,std::__value_type<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,std::__list_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>,void *>>,boost::signals2::detail::group_key_less<int,std::less<int>>,false>,std::allocator<std::__value_type<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,std::__list_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>,void *>>>>::__find_equal<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>>(v130 + 24, v191, (uint64_t)&v206);
    if (!*v149)
    {
      v150 = operator new(0x38uLL);
      v150[2] = v206;
      *((_QWORD *)v150 + 6) = v207;
      std::__tree<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::less<unsigned short>,true>,std::allocator<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>>>::__insert_node_at((uint64_t **)(v130 + 24), (uint64_t)v191[0], v149, (uint64_t *)v150);
    }
  }
  v151 = boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>::operator->(v194);
  *(_DWORD *)(v151 + 64) = v192;
  *(_QWORD *)(v151 + 68) = *(_QWORD *)((char *)&v192 + 4);
  v152 = v194;
  v206 = v194;
  if (*((_QWORD *)&v194 + 1))
  {
    v153 = (unsigned int *)(*((_QWORD *)&v194 + 1) + 12);
    do
      v154 = __ldxr(v153);
    while (__stxr(v154 + 1, v153));
    do
      v155 = __ldxr(v153);
    while (__stxr(v155 + 1, v153));
  }
  v186 = v152;
  boost::detail::weak_count::~weak_count((unsigned int **)&v206 + 1);
  boost::detail::shared_count::~shared_count((unsigned int **)&v194 + 1);
  boost::signals2::mutex::unlock(*((pthread_mutex_t **)&v219 + 1));
  boost::signals2::detail::auto_buffer<boost::shared_ptr<void>,boost::signals2::detail::store_n_objects<10u>,boost::signals2::detail::default_grow_policy,std::allocator<boost::shared_ptr<void>>>::auto_buffer_destroy(buf);
  boost::function0<void>::~function0((uint64_t *)&__p[3]);
  *(_QWORD *)buf = __p;
  std::vector<boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
  ctu::DispatchSlot<dispatch::block<void({block_pointer})(void)>>::~DispatchSlot((uint64_t)object);
  p_shared_owners = (unint64_t *)&v183->__shared_owners_;
  do
    v157 = __ldaxr(p_shared_owners);
  while (__stlxr(v157 - 1, p_shared_owners));
  if (!v157)
  {
    ((void (*)(std::__shared_weak_count *))v183->__on_zero_shared)(v183);
    std::__shared_weak_count::__release_weak(v183);
    if (!v181)
      goto LABEL_214;
    goto LABEL_213;
  }
  if (v181)
LABEL_213:
    _Block_release(v181);
LABEL_214:
  v158 = operator new(0x20uLL);
  v158[1] = v186;
  v186 = 0uLL;
  *(_QWORD *)buf = 0;
  *(_QWORD *)&buf[8] = 0;
  boost::detail::weak_count::~weak_count((unsigned int **)&buf[8]);
  v159 = a1[42];
  *(_QWORD *)v158 = v159;
  *((_QWORD *)v158 + 1) = v182;
  *(_QWORD *)(v159 + 8) = v158;
  a1[42] = v158;
  ++a1[44];
  boost::detail::weak_count::~weak_count((unsigned int **)&v186 + 1);
  std::string::basic_string[abi:ne180100]<0>(__p, "/cc/props/calls_active_in_settings");
  *(_QWORD *)buf = &off_24D5E3FD8;
  *(_QWORD *)&buf[8] = (char *)a1 + 305;
  *(_QWORD *)&buf[24] = buf;
  ctu::RestModule::observeProperty();
  v160 = *(uint8_t **)&buf[24];
  if (*(uint8_t **)&buf[24] == buf)
  {
    v161 = 4;
    v160 = buf;
  }
  else
  {
    if (!*(_QWORD *)&buf[24])
      goto LABEL_219;
    v161 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v160 + 8 * v161))();
LABEL_219:
  if (SHIBYTE(__p[2]) < 0)
    operator delete(__p[0]);
  std::string::basic_string[abi:ne180100]<0>(__p, "/cc/props/rat");
  v162 = operator new(0x28uLL);
  *v162 = &off_24D5E4058;
  v162[1] = a1 + 39;
  v162[2] = a1;
  v162[3] = EurekaCallCommandDriver::handleRegistered;
  v162[4] = 0;
  *(_QWORD *)&buf[24] = v162;
  ctu::RestModule::observeProperty();
  v163 = *(uint8_t **)&buf[24];
  if (*(uint8_t **)&buf[24] == buf)
  {
    v164 = 4;
    v163 = buf;
  }
  else
  {
    if (!*(_QWORD *)&buf[24])
      goto LABEL_226;
    v164 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v163 + 8 * v164))();
LABEL_226:
  if (SHIBYTE(__p[2]) < 0)
    operator delete(__p[0]);
  std::string::basic_string[abi:ne180100]<0>(__p, "/cc/props/device_types");
  *(_QWORD *)buf = &off_24D5E40D8;
  *(_QWORD *)&buf[8] = a1 + 32;
  *(_QWORD *)&buf[24] = buf;
  ctu::RestModule::observeProperty();
  v165 = *(uint8_t **)&buf[24];
  if (*(uint8_t **)&buf[24] == buf)
  {
    v166 = 4;
    v165 = buf;
  }
  else
  {
    if (!*(_QWORD *)&buf[24])
      goto LABEL_233;
    v166 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v165 + 8 * v166))();
LABEL_233:
  if (SHIBYTE(__p[2]) < 0)
    operator delete(__p[0]);
  result = subscriber::makeSimSlotRange();
  v169 = *(unsigned int **)buf;
  v168 = *(unsigned int **)&buf[8];
  if (*(_QWORD *)buf != *(_QWORD *)&buf[8])
  {
    v170 = *(uint64_t (**)(_QWORD))&buf[16];
    while (1)
    {
      result = v170(*v169);
      if ((result & 1) != 0)
        break;
      if (++v169 == v168)
      {
        v169 = v168;
        break;
      }
    }
    v171 = *(unsigned int **)&buf[8];
LABEL_241:
    while (v169 != v171)
    {
      result = EurekaCallCommandDriver::fillUpDefaultCallCapabilities((uint64_t)a1, *v169);
      v172 = v169 + 1;
      v169 = v168;
      if (v172 != v168)
      {
        v169 = v172;
        while (1)
        {
          result = v170(*v169);
          if ((result & 1) != 0)
            break;
          if (++v169 == v168)
          {
            v169 = v168;
            goto LABEL_241;
          }
        }
      }
    }
  }
  return result;
}

void sub_216A41F7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,char a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,char a61)
{
  uint64_t v61;
  uint64_t v62;

  if (a2)
  {
    a57 = v61;
    std::vector<boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a57);
    MEMORY[0x2199FEAC4](v61, 0x10E2C40015BD3E7);
    *(_QWORD *)v62 = off_24D5E3DC8;
    boost::detail::weak_count::~weak_count((unsigned int **)(v62 + 16));
    MEMORY[0x2199FEAC4](v62, 0x10A1C4004CC96CELL);
    boost::signals2::detail::garbage_collecting_lock<boost::signals2::mutex>::~garbage_collecting_lock((uint64_t)&a61);
    boost::signals2::slot<void ()(void),boost::function<void ()(void)>>::~slot((uint64_t)&a49);
    ctu::DispatchSlot<dispatch::block<void({block_pointer})(void)>>::~DispatchSlot((uint64_t)&a24);
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_216A41F8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,char a57,uint64_t a58,uint64_t a59,uint64_t a60,char a61)
{
  if (a2)
  {
    std::__split_buffer<boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>>::~__split_buffer((uint64_t)&a61);
    boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>::destroy_content((uint64_t)&a57);
    if (a38)
      (*(void (**)(uint64_t))(*(_QWORD *)a38 + 8))(a38);
    std::__shared_weak_count::__release_weak(a16);
    JUMPOUT(0x216A42444);
  }
  _Unwind_Resume(a1);
}

void sub_216A41F98(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  JUMPOUT(0x216A4230CLL);
}

void sub_216A41FB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a2)
  {
    __cxa_begin_catch(a1);
    boost::checked_delete<boost::signals2::detail::signal_impl<void ()(subscriber::SimSlot,subscriber::SimCard),boost::signals2::optional_last_value<void>,int,std::less<int>,boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>,boost::function<void ()(boost::signals2::connection const&,subscriber::SimSlot,subscriber::SimCard)>,boost::signals2::mutex>::invocation_state>(a12);
    __cxa_rethrow();
  }
  _Unwind_Resume(a1);
}

void sub_216A41FD0(_Unwind_Exception *a1, int a2)
{
  unsigned int **v2;

  if (a2)
  {
    __cxa_end_catch();
    boost::detail::shared_count::~shared_count(v2);
    JUMPOUT(0x216A4243CLL);
  }
  _Unwind_Resume(a1);
}

void sub_216A41FE8(_Unwind_Exception *a1, int a2)
{
  uint64_t v2;

  if (a2)
  {
    __cxa_begin_catch(a1);
    boost::checked_delete<boost::signals2::detail::grouped_list<int,std::less<int>,boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>>>(v2);
    __cxa_rethrow();
  }
  _Unwind_Resume(a1);
}

void sub_216A42008(_Unwind_Exception *a1, int a2)
{
  unsigned int **v2;

  if (a2)
  {
    __cxa_end_catch();
    boost::detail::shared_count::~shared_count(v2);
    JUMPOUT(0x216A42438);
  }
  _Unwind_Resume(a1);
}

void sub_216A42034(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  JUMPOUT(0x216A4230CLL);
}

void sub_216A42040(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,void *__p,uint64_t a50,int a51,__int16 a52,char a53,char a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  char a64;
  uint64_t a67;
  uint64_t v67;
  _QWORD *v69;
  uint64_t v70;

  v69 = (_QWORD *)a67;
  if (a67 == v67)
  {
    v70 = 4;
    v69 = &a64;
  }
  else
  {
    if (!a67)
      goto LABEL_6;
    v70 = 5;
  }
  (*(void (**)(void))(*v69 + 8 * v70))();
LABEL_6:
  if (a54 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

void sub_216A420A4(_Unwind_Exception *a1)
{
  unsigned int **v1;

  boost::detail::weak_count::~weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_216A420BC(_Unwind_Exception *a1, int a2)
{
  uint64_t v2;

  if (a2)
  {
    __cxa_begin_catch(a1);
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
    __cxa_rethrow();
  }
  _Unwind_Resume(a1);
}

void sub_216A420E4(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    __cxa_end_catch();
    JUMPOUT(0x216A42340);
  }
  _Unwind_Resume(a1);
}

void sub_216A420F8(_Unwind_Exception *a1, int a2)
{
  uint64_t v2;

  if (a2)
  {
    __cxa_begin_catch(a1);
    boost::checked_delete<boost::signals2::slot<void ()(void),boost::function<void ()(void)>>>(v2);
    __cxa_rethrow();
  }
  _Unwind_Resume(a1);
}

void sub_216A42118(_Unwind_Exception *a1, int a2)
{
  unsigned int **v2;

  if (a2)
  {
    __cxa_end_catch();
    boost::detail::shared_count::~shared_count(v2);
    JUMPOUT(0x216A4238CLL);
  }
  _Unwind_Resume(a1);
}

void sub_216A42134(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  JUMPOUT(0x216A4238CLL);
}

void sub_216A42140(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  JUMPOUT(0x216A42444);
}

void sub_216A4214C(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  JUMPOUT(0x216A42314);
}

void sub_216A42158(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  JUMPOUT(0x216A42328);
}

void sub_216A42168(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,char a61,uint64_t a62,uint64_t a63)
{
  char *a64;
  char *v64;
  char *v66;
  uint64_t v67;

  v66 = a64;
  if (a64 == v64)
  {
    v67 = 4;
    v66 = &a61;
  }
  else
  {
    if (!a64)
      goto LABEL_6;
    v67 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v66 + 8 * v67))();
LABEL_6:
  _Unwind_Resume(a1);
}

void sub_216A42254(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, dispatch_group_t group)
{
  if (group)
  {
    dispatch_group_leave(group);
    dispatch_release(group);
  }
  _Unwind_Resume(a1);
}

void sub_216A42274(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57)
{
  uint64_t v57;
  _QWORD *v58;

  if (a2)
  {
    std::vector<boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>>::__destroy_vector::operator()[abi:ne180100](&a57);
    MEMORY[0x2199FEAC4](v57, 0x10E2C40015BD3E7);
    *v58 = off_24D5E3DC8;
    boost::detail::weak_count::~weak_count((boost::detail::weak_count *)(v58 + 2));
    JUMPOUT(0x216A42438);
  }
  _Unwind_Resume(a1);
}

void sub_216A42288(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,char a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,void **a61)
{
  uint64_t *v61;

  if (a2)
  {
    boost::function0<void>::~function0((uint64_t *)&a61);
    boost::function0<void>::~function0(&a57);
    ctu::DispatchSlot<dispatch::block<void({block_pointer})(void)>>::~DispatchSlot((uint64_t)&a28);
    ctu::DispatchSlot<dispatch::block<void({block_pointer})(void)>>::~DispatchSlot((uint64_t)&a26);
    boost::function0<void>::~function0(v61);
    a61 = (void **)&a49;
    std::vector<boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>>::__destroy_vector::operator()[abi:ne180100](&a61);
    JUMPOUT(0x216A4244CLL);
  }
  _Unwind_Resume(a1);
}

void sub_216A422D0(_Unwind_Exception *a1, int a2)
{
  unsigned int **v2;

  if (a2)
  {
    std::__list_imp<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>>::clear(v2);
    MEMORY[0x2199FEAC4](v2, 0x1020C40A2524F59);
    JUMPOUT(0x216A42424);
  }
  _Unwind_Resume(a1);
}

void sub_216A422E0(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61)
{
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;

  if (a2)
  {
    if (v62 != -24)
    {
      v63 = v62 + 24;
      do
      {
        boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>::destroy_content(v61 + v63);
        v63 += 24;
      }
      while (v63);
    }
    std::__split_buffer<boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>>::~__split_buffer((uint64_t)&a61);
    boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>::destroy_content((uint64_t)&a57);
    if (a38)
      (*(void (**)(uint64_t))(*(_QWORD *)a38 + 8))(a38);
    std::__shared_weak_count::__release_weak(a16);
    JUMPOUT(0x216A42444);
  }
  _Unwind_Resume(a1);
}

void sub_216A42334(_Unwind_Exception *a1, int a2)
{
  if (a2)
    JUMPOUT(0x216A4233CLL);
  _Unwind_Resume(a1);
}

void sub_216A42348(_Unwind_Exception *a1, int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  if (a2)
  {
    for (; v2; v2 -= 24)
      boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>::destroy_content(v3 - 24 + v2);
    *(_QWORD *)(v4 + 8) = v3;
    JUMPOUT(0x216A4236CLL);
  }
  _Unwind_Resume(a1);
}

void sub_216A423B8(_Unwind_Exception *a1, int a2)
{
  _QWORD **v2;

  if (a2)
  {
    std::__tree<std::__value_type<AQMThroughputKey,unsigned int>,std::__map_value_compare<AQMThroughputKey,std::__value_type<AQMThroughputKey,unsigned int>,std::less<AQMThroughputKey>,true>,std::allocator<std::__value_type<AQMThroughputKey,unsigned int>>>::destroy(*v2);
    JUMPOUT(0x216A42404);
  }
  _Unwind_Resume(a1);
}

void sub_216A423C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_216A423D4(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  JUMPOUT(0x216A4243CLL);
}

void sub_216A423E0(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  JUMPOUT(0x216A42454);
}

void sub_216A423EC(uint64_t a1, int a2)
{
  _QWORD *v2;

  if (!a2)
    JUMPOUT(0x216A423F4);
  std::__tree<std::__value_type<AQMThroughputKey,unsigned int>,std::__map_value_compare<AQMThroughputKey,std::__value_type<AQMThroughputKey,unsigned int>,std::less<AQMThroughputKey>,true>,std::allocator<std::__value_type<AQMThroughputKey,unsigned int>>>::destroy(*v2);
  JUMPOUT(0x216A42404);
}

uint64_t EurekaCallCommandDriver::shutdown(uint64_t a1, NSObject **a2)
{
  NSObject *v3;
  _QWORD *v4;
  unsigned int *v5;
  unsigned int *v6;
  unsigned int v7;
  unsigned int v8;
  char v9;
  boost::signals2::detail::connection_body_base *v10;
  NSObject *group;
  unsigned int *v13;

  v3 = *a2;
  group = *a2;
  if (*a2)
  {
    dispatch_retain(v3);
    dispatch_group_enter(v3);
  }
  CallCommandDriver::shutdown();
  if (group)
  {
    dispatch_group_leave(group);
    dispatch_release(group);
  }
  v4 = *(_QWORD **)(a1 + 344);
  if (v4 == (_QWORD *)(a1 + 336))
    goto LABEL_20;
  do
  {
    v5 = (unsigned int *)v4[3];
    v13 = v5;
    if (!v5)
      goto LABEL_19;
    v6 = v5 + 2;
    v7 = v5[2];
    do
    {
      if (!v7)
      {
        v13 = 0;
        goto LABEL_19;
      }
      v8 = __ldxr(v6);
      if (v8 == v7)
      {
        if (!__stxr(v7 + 1, v6))
        {
          v9 = 1;
          goto LABEL_15;
        }
      }
      else
      {
        __clrex();
      }
      v9 = 0;
LABEL_15:
      v7 = v8;
    }
    while ((v9 & 1) == 0);
    v10 = (boost::signals2::detail::connection_body_base *)v4[2];
    if (v10)
      boost::signals2::detail::connection_body_base::disconnect(v10);
LABEL_19:
    boost::detail::shared_count::~shared_count(&v13);
    v4 = (_QWORD *)v4[1];
  }
  while (v4 != (_QWORD *)(a1 + 336));
LABEL_20:
  std::__list_imp<boost::signals2::connection>::clear((unsigned int **)(a1 + 336));
  qmi::ClientRouter::stop();
  qmi::ClientRouter::stop();
  return qmi::ClientRouter::stop();
}

void sub_216A42580(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_group_t group)
{
  if (group)
  {
    dispatch_group_leave(group);
    dispatch_release(group);
  }
  _Unwind_Resume(exception_object);
}

void EurekaCallCommandDriver::updateWifiCallStatus(uint64_t a1, int *a2, uint64_t a3, int a4)
{
  os_log_t *v6;
  const void **v7;
  const void **v8;
  const void **v9;
  NSObject *v10;
  char *v11;
  _BYTE *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  char *v19;
  const void **v20;
  char *v21;
  char *v22;
  char *v23;
  const void *v24;
  char *v25;
  BOOL *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  _QWORD *v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  char *v34;
  uint64_t *v35;
  char *v36;
  char *v37;
  char *v38;
  uint64_t v39;
  int v40;
  NSObject *v41;
  uint64_t v42;
  uint64_t v43;
  std::__shared_weak_count *v44;
  unint64_t *p_shared_owners;
  uint64_t v46;
  unint64_t v47;
  std::__shared_weak_count *v48;
  unint64_t *v49;
  unint64_t v50;
  std::__shared_weak_count *v51;
  unint64_t *v52;
  unint64_t v53;
  uint64_t v54;
  uint64_t v55;
  void *__p[2];
  __int128 v57;
  _QWORD *v58;
  std::__shared_weak_count *v59;
  _QWORD aBlock[5];
  uint8_t buf[8];
  uint64_t v62;
  void (*v63)(uint64_t, uint64_t);
  void *v64;
  _QWORD *v65;
  std::__shared_weak_count *v66;
  uint64_t v67;

  v67 = *MEMORY[0x24BDAC8D0];
  v6 = (os_log_t *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 112) + 16))(*(_QWORD *)(a1 + 112), a3);
  if ((capabilities::ct::shouldSendWiFiCallStatus((capabilities::ct *)v6) & 1) != 0)
  {
    *(_OWORD *)__p = 0u;
    v57 = 0u;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
    v7 = (const void **)__p[1];
    v8 = (const void **)v57;
    v9 = (const void **)__p[1];
    if (__p[1] != (void *)v57)
    {
      v9 = (const void **)__p[1];
      while (*((_BYTE *)*v9 + 8) != 16)
      {
        if (++v9 == (const void **)v57)
          goto LABEL_12;
      }
    }
    if (v9 == (const void **)v57)
    {
LABEL_12:
      v13 = operator new();
      v14 = v13;
      *(_WORD *)(v13 + 8) = 16;
      *(_QWORD *)v13 = &off_24D5E4BB8;
      v15 = v57;
      if ((unint64_t)v57 >= *((_QWORD *)&v57 + 1))
      {
        v16 = (uint64_t)(v57 - (unint64_t)__p[1]) >> 3;
        if ((unint64_t)(v16 + 1) >> 61)
          goto LABEL_71;
        v17 = (uint64_t)(*((_QWORD *)&v57 + 1) - (unint64_t)__p[1]) >> 2;
        if (v17 <= v16 + 1)
          v17 = v16 + 1;
        if (*((_QWORD *)&v57 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v18 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v18 = v17;
        if (v18)
          v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v57 + 8, v18);
        else
          v19 = 0;
        v20 = (const void **)&v19[8 * v16];
        v21 = &v19[8 * v18];
        *v20 = (const void *)v14;
        v8 = v20 + 1;
        v23 = (char *)__p[1];
        v22 = (char *)v57;
        if ((void *)v57 != __p[1])
        {
          do
          {
            v24 = (const void *)*((_QWORD *)v22 - 1);
            v22 -= 8;
            *--v20 = v24;
          }
          while (v22 != v23);
          v22 = (char *)__p[1];
        }
        __p[1] = v20;
        *(_QWORD *)&v57 = v8;
        *((_QWORD *)&v57 + 1) = v21;
        if (v22)
          operator delete(v22);
      }
      else
      {
        *(_QWORD *)v57 = v13;
        v8 = (const void **)(v15 + 8);
      }
      v12 = (_BYTE *)(v14 + 9);
      *(_QWORD *)&v57 = v8;
      v7 = (const void **)__p[1];
    }
    else
    {
      if (!v11)
        goto LABEL_72;
      v12 = v11 + 9;
    }
    *v12 = a4;
    while (1)
    {
      if (v7 == v8)
        goto LABEL_36;
      if (*((_BYTE *)*v7 + 8) == 17)
        break;
      ++v7;
    }
    if (v7 != v8)
    {
      if (v25)
      {
        v26 = (BOOL *)(v25 + 9);
LABEL_53:
        v40 = *a2;
        *v26 = *a2 == 0;
        v41 = *v6;
        if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 67109376;
          *(_DWORD *)&buf[4] = v40;
          LOWORD(v62) = 1024;
          *(_DWORD *)((char *)&v62 + 2) = a4;
          _os_log_impl(&dword_216897000, v41, OS_LOG_TYPE_DEFAULT, "#I Sending wifi call status to BB: status: %d isWifiSupported: %d", buf, 0xEu);
        }
        v42 = qmi::ClientRouter::get();
        v43 = operator new();
        *(_QWORD *)v43 = v42;
        *(_QWORD *)(v43 + 8) = QMIServiceMsg::create();
        *(_DWORD *)(v43 + 16) = 25000;
        *(_QWORD *)(v43 + 24) = 0;
        *(_QWORD *)(v43 + 32) = 0;
        v55 = v43;
        v44 = (std::__shared_weak_count *)operator new(0x20uLL);
        v44->__shared_owners_ = 0;
        p_shared_owners = (unint64_t *)&v44->__shared_owners_;
        v44->__shared_weak_owners_ = 0;
        v44->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E4C70;
        v44[1].__vftable = (std::__shared_weak_count_vtbl *)v6;
        v58 = &v44[1].__vftable;
        v59 = v44;
        v46 = MEMORY[0x24BDAC760];
        *(_QWORD *)buf = MEMORY[0x24BDAC760];
        v62 = 1174405120;
        v63 = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZNK23EurekaCallCommandDriver20updateWifiCallStatusERK9CallStateN10subscriber7SimSlotEbE3__0EEOS1_OT__block_invoke;
        v64 = &__block_descriptor_tmp_188_1;
        v65 = &v44[1].__vftable;
        v66 = v44;
        do
          v47 = __ldxr(p_shared_owners);
        while (__stxr(v47 + 1, p_shared_owners));
        aBlock[0] = v46;
        aBlock[1] = 0x40000000;
        aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_26;
        aBlock[3] = &unk_24D5E3190;
        aBlock[4] = buf;
        *(_QWORD *)(v43 + 32) = _Block_copy(aBlock);
        v48 = v66;
        if (v66)
        {
          v49 = (unint64_t *)&v66->__shared_owners_;
          do
            v50 = __ldaxr(v49);
          while (__stlxr(v50 - 1, v49));
          if (!v50)
          {
            ((void (*)(std::__shared_weak_count *))v48->__on_zero_shared)(v48);
            std::__shared_weak_count::__release_weak(v48);
          }
        }
        v51 = v59;
        if (v59)
        {
          v52 = (unint64_t *)&v59->__shared_owners_;
          do
            v53 = __ldaxr(v52);
          while (__stlxr(v53 - 1, v52));
          if (!v53)
          {
            ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
            std::__shared_weak_count::__release_weak(v51);
          }
        }
        v54 = v55;
        v55 = 0;
        if (v54)
          std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v55, v54);
        qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
        return;
      }
LABEL_72:
      __cxa_bad_cast();
    }
LABEL_36:
    v27 = operator new();
    v28 = v27;
    *(_WORD *)(v27 + 8) = 17;
    *(_QWORD *)v27 = &off_24D5E4C08;
    v29 = v57;
    if ((unint64_t)v57 < *((_QWORD *)&v57 + 1))
    {
      *(_QWORD *)v57 = v27;
      v30 = (_QWORD *)(v29 + 8);
LABEL_52:
      v26 = (BOOL *)(v28 + 9);
      *(_QWORD *)&v57 = v30;
      goto LABEL_53;
    }
    v31 = (uint64_t)(v57 - (unint64_t)__p[1]) >> 3;
    if (!((unint64_t)(v31 + 1) >> 61))
    {
      v32 = (uint64_t)(*((_QWORD *)&v57 + 1) - (unint64_t)__p[1]) >> 2;
      if (v32 <= v31 + 1)
        v32 = v31 + 1;
      if (*((_QWORD *)&v57 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v33 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v33 = v32;
      if (v33)
        v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v57 + 8, v33);
      else
        v34 = 0;
      v35 = (uint64_t *)&v34[8 * v31];
      v36 = &v34[8 * v33];
      *v35 = v28;
      v30 = v35 + 1;
      v38 = (char *)__p[1];
      v37 = (char *)v57;
      if ((void *)v57 != __p[1])
      {
        do
        {
          v39 = *((_QWORD *)v37 - 1);
          v37 -= 8;
          *--v35 = v39;
        }
        while (v37 != v38);
        v37 = (char *)__p[1];
      }
      __p[1] = v35;
      *(_QWORD *)&v57 = v30;
      *((_QWORD *)&v57 + 1) = v36;
      if (v37)
        operator delete(v37);
      goto LABEL_52;
    }
LABEL_71:
    std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
  }
  v10 = *v6;
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl(&dword_216897000, v10, OS_LOG_TYPE_ERROR, "Failed to send wifi call status to BB as fNASClient is not ready! Returning.", buf, 2u);
  }
}

void sub_216A42B24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;
  va_list va;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v6 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v4);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  if (a3)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v3, a3);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

void EurekaCallCommandDriver::sendImsCallStatusToBaseband(uint64_t a1, int a2, uint64_t a3, uint64_t a4, char a5)
{
  int v8;
  int v9;
  int v10;
  NSObject *v11;
  const char *v12;
  NSObject *v13;
  uint32_t v14;
  capabilities::ct *v15;
  int v16;
  NSObject *v17;
  std::mutex *ServiceMap;
  std::mutex *v19;
  uint64_t v20;
  unsigned __int8 *v21;
  uint64_t v22;
  unsigned int v23;
  _QWORD *v24;
  std::__shared_weak_count *v25;
  uint64_t v26;
  unint64_t *p_shared_owners;
  unint64_t v28;
  unint64_t *v29;
  unint64_t v30;
  unint64_t v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  NSObject *v35;
  const char *v36;
  NSObject *v37;
  uint64_t v38;
  const char *v39;
  const char *v40;
  const char *v41;
  uint64_t v42;
  const void **v43;
  const void **v44;
  const void **v45;
  char *v46;
  int *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  unint64_t v52;
  unint64_t v53;
  char *v54;
  const void **v55;
  char *v56;
  char *v57;
  char *v58;
  const void *v59;
  _WORD *v60;
  _QWORD *v61;
  char v62;
  _WORD *v63;
  uint64_t v64;
  uint64_t v65;
  unint64_t v66;
  unint64_t v67;
  char *v68;
  const void **v69;
  char *v70;
  _WORD *v71;
  const void *v72;
  const void **i;
  _BYTE *v74;
  _WORD *v75;
  uint64_t v76;
  _QWORD *v77;
  uint64_t v78;
  unint64_t v79;
  unint64_t v80;
  char *v81;
  char *v82;
  char *v83;
  _WORD *v84;
  uint64_t v85;
  uint64_t v86;
  capabilities::ct *v87;
  const void **v88;
  _BYTE *v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  _QWORD *v93;
  uint64_t v94;
  unint64_t v95;
  unint64_t v96;
  char *v97;
  uint64_t *v98;
  char *v99;
  char *v100;
  char *v101;
  uint64_t v102;
  const void **v103;
  BOOL *v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  _QWORD *v108;
  uint64_t v109;
  unint64_t v110;
  unint64_t v111;
  char *v112;
  uint64_t *v113;
  char *v114;
  char *v115;
  char *v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  std::__shared_weak_count *v120;
  unint64_t *v121;
  unint64_t v122;
  std::__shared_weak_count *v123;
  unint64_t *v124;
  unint64_t v125;
  std::__shared_weak_count *v126;
  unint64_t *v127;
  unint64_t v128;
  uint64_t v129;
  std::__shared_weak_count *v130;
  unint64_t *v131;
  unint64_t v132;
  char v133;
  int v134;
  uint64_t v135;
  _QWORD v136[2];
  uint64_t (*v137)(uint64_t, BOOL *);
  void *v138;
  int v139;
  _QWORD v140[2];
  uint64_t (*v141)(uint64_t, _BYTE *);
  void *v142;
  char v143;
  void *__p[2];
  __int128 v145;
  uint64_t v146;
  std::__shared_weak_count *v147;
  void *v148;
  uint64_t v149;
  uint64_t v150;
  _QWORD *v151;
  std::__shared_weak_count *v152;
  uint64_t aBlock;
  uint64_t v154;
  void (*v155)(uint64_t, QMIServiceMsg *);
  void *v156;
  _BYTE *v157;
  _BYTE buf[24];
  void *v159;
  _QWORD *v160;
  std::__shared_weak_count *v161;
  uint64_t v162;

  v162 = *MEMORY[0x24BDAC8D0];
  if ((a2 - 3) < 2)
  {
    v10 = 1;
LABEL_8:
    v8 = 1;
    v9 = 1;
    goto LABEL_9;
  }
  if (a2 == 1)
  {
    v10 = 0;
    goto LABEL_8;
  }
  v8 = 0;
  v9 = 0;
  v10 = 0;
  if (a2 == 2)
  {
    v11 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = asString();
      v12 = "#N *** IMS call state notification to BB: Dropping the request for %s as it is not supported.";
      v13 = v11;
      v14 = 12;
LABEL_13:
      _os_log_impl(&dword_216897000, v13, OS_LOG_TYPE_DEFAULT, v12, buf, v14);
      return;
    }
    return;
  }
LABEL_9:
  v15 = (capabilities::ct *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 112) + 16))(*(_QWORD *)(a1 + 112), a3);
  v16 = capabilities::ct::supports5G(v15);
  if ((v10 & 1) != 0 || !v16)
  {
    v134 = v8;
    v148 = 0;
    v149 = 0;
    v150 = 0;
    PersonalityIdFromSlotId();
    v133 = a5;
    v146 = 0;
    v147 = 0;
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
    v19 = ServiceMap;
    v20 = *(_QWORD *)(MEMORY[0x24BDC3D20] + 8);
    if (v20 < 0)
    {
      v21 = (unsigned __int8 *)(v20 & 0x7FFFFFFFFFFFFFFFLL);
      v22 = 5381;
      do
      {
        v20 = v22;
        v23 = *v21++;
        v22 = (33 * v22) ^ v23;
      }
      while (v23);
    }
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = 0;
    std::mutex::lock(ServiceMap);
    __p[0] = (void *)v20;
    v24 = std::__hash_table<std::__hash_value_type<unsigned long,std::shared_ptr<void>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::shared_ptr<void>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::shared_ptr<void>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::shared_ptr<void>>>>::find<unsigned long>(&v19[1].__m_.__sig, (unint64_t *)__p);
    if (v24)
    {
      v26 = v24[3];
      v25 = (std::__shared_weak_count *)v24[4];
      if (v25)
      {
        p_shared_owners = (unint64_t *)&v25->__shared_owners_;
        do
          v28 = __ldxr(p_shared_owners);
        while (__stxr(v28 + 1, p_shared_owners));
      }
    }
    else
    {
      v26 = 0;
      v25 = 0;
    }
    *(_QWORD *)buf = v26;
    *(_QWORD *)&buf[8] = v25;
    std::mutex::unlock(v19);
    aBlock = v26;
    v154 = (uint64_t)v25;
    if (v25)
    {
      v29 = (unint64_t *)&v25->__shared_owners_;
      do
        v30 = __ldxr(v29);
      while (__stxr(v30 + 1, v29));
      do
        v31 = __ldaxr(v29);
      while (__stlxr(v31 - 1, v29));
      if (!v31)
      {
        ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
        std::__shared_weak_count::__release_weak(v25);
      }
    }
    (*(void (**)(uint64_t *__return_ptr, uint64_t, void **))(*(_QWORD *)aBlock + 40))(&v146, aBlock, &v148);
    v32 = (std::__shared_weak_count *)v154;
    if (v154)
    {
      v33 = (unint64_t *)(v154 + 8);
      do
        v34 = __ldaxr(v33);
      while (__stlxr(v34 - 1, v33));
      if (!v34)
      {
        ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
        std::__shared_weak_count::__release_weak(v32);
      }
    }
    if (v146 && (*(unsigned int (**)(uint64_t))(*(_QWORD *)v146 + 216))(v146))
    {
      v35 = *(NSObject **)v15;
      if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
      {
        v36 = nas::asString(v9);
        *(_DWORD *)buf = 136315138;
        *(_QWORD *)&buf[4] = v36;
        _os_log_impl(&dword_216897000, v35, OS_LOG_TYPE_DEFAULT, "#I Active pseudo-VoLTE call. Not sending IMS call state notification to BB: %s", buf, 0xCu);
      }
LABEL_190:
      v130 = v147;
      if (v147)
      {
        v131 = (unint64_t *)&v147->__shared_owners_;
        do
          v132 = __ldaxr(v131);
        while (__stlxr(v132 - 1, v131));
        if (!v132)
        {
          ((void (*)(std::__shared_weak_count *))v130->__on_zero_shared)(v130);
          std::__shared_weak_count::__release_weak(v130);
        }
      }
      if (SHIBYTE(v150) < 0)
        operator delete(v148);
      return;
    }
    v37 = *(NSObject **)v15;
    if (os_log_type_enabled(*(os_log_t *)v15, OS_LOG_TYPE_DEFAULT))
    {
      v38 = HIBYTE(v150);
      if (v150 < 0)
        v38 = v149;
      v39 = (const char *)&v148;
      if (v150 < 0)
        v39 = (const char *)v148;
      if (v38)
        v40 = v39;
      else
        v40 = "<invalid>";
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = v40;
      _os_log_impl(&dword_216897000, v37, OS_LOG_TYPE_DEFAULT, "#I IMS config is not found or IMS status update to baseband is not blocked for personalityId: %s!", buf, 0xCu);
      v37 = *(NSObject **)v15;
    }
    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
    {
      v41 = nas::asString(v9);
      v42 = CSIBOOLAsString();
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = v41;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = v42;
      _os_log_impl(&dword_216897000, v37, OS_LOG_TYPE_DEFAULT, "#N *** IMS call state notification to BB: Sending IMS Call Status: %s. Is is to end RAT selection: %s.", buf, 0x16u);
    }
    *(_OWORD *)__p = 0u;
    v145 = 0u;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
    v44 = (const void **)__p[1];
    v43 = (const void **)v145;
    v45 = (const void **)__p[1];
    if (__p[1] != (void *)v145)
    {
      v45 = (const void **)__p[1];
      while (*((_BYTE *)*v45 + 8) != 1)
      {
        if (++v45 == (const void **)v145)
          goto LABEL_57;
      }
    }
    if (v45 == (const void **)v145)
    {
LABEL_57:
      v48 = operator new();
      v49 = v48;
      *(_BYTE *)(v48 + 8) = 1;
      *(_QWORD *)v48 = &off_24D5E4CD8;
      *(_DWORD *)(v48 + 12) = 0;
      v47 = (int *)(v48 + 12);
      v50 = v145;
      if ((unint64_t)v145 >= *((_QWORD *)&v145 + 1))
      {
        v51 = (uint64_t)(v145 - (unint64_t)__p[1]) >> 3;
        if ((unint64_t)(v51 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v52 = (uint64_t)(*((_QWORD *)&v145 + 1) - (unint64_t)__p[1]) >> 2;
        if (v52 <= v51 + 1)
          v52 = v51 + 1;
        if (*((_QWORD *)&v145 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v53 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v53 = v52;
        if (v53)
          v54 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v145 + 8, v53);
        else
          v54 = 0;
        v55 = (const void **)&v54[8 * v51];
        v56 = &v54[8 * v53];
        *v55 = (const void *)v49;
        v43 = v55 + 1;
        v58 = (char *)__p[1];
        v57 = (char *)v145;
        if ((void *)v145 != __p[1])
        {
          do
          {
            v59 = (const void *)*((_QWORD *)v57 - 1);
            v57 -= 8;
            *--v55 = v59;
          }
          while (v57 != v58);
          v57 = (char *)__p[1];
        }
        __p[1] = v55;
        *(_QWORD *)&v145 = v43;
        *((_QWORD *)&v145 + 1) = v56;
        if (v57)
          operator delete(v57);
      }
      else
      {
        *(_QWORD *)v145 = v48;
        v43 = (const void **)(v50 + 8);
      }
      *(_QWORD *)&v145 = v43;
      v44 = (const void **)__p[1];
    }
    else
    {
      if (!v46)
        __cxa_bad_cast();
      v47 = (int *)(v46 + 12);
    }
    *v47 = v9;
    while (v44 != v43)
    {
      if (*((_BYTE *)*v44 + 8) == 16)
      {
        if (v44 != v43)
        {
          if (!v60)
            __cxa_bad_cast();
          v61 = v60 + 8;
          v62 = v133;
          goto LABEL_98;
        }
        break;
      }
      ++v44;
    }
    v60 = (_WORD *)operator new();
    v62 = v133;
    v63 = v60;
    *((_BYTE *)v60 + 8) = 16;
    *(_QWORD *)v60 = &off_24D5E4D28;
    *((_QWORD *)v60 + 2) = 0;
    v61 = v60 + 8;
    v64 = v145;
    if ((unint64_t)v145 >= *((_QWORD *)&v145 + 1))
    {
      v65 = (uint64_t)(v145 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v65 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v66 = (uint64_t)(*((_QWORD *)&v145 + 1) - (unint64_t)__p[1]) >> 2;
      if (v66 <= v65 + 1)
        v66 = v65 + 1;
      if (*((_QWORD *)&v145 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v67 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v67 = v66;
      if (v67)
        v68 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v145 + 8, v67);
      else
        v68 = 0;
      v69 = (const void **)&v68[8 * v65];
      v70 = &v68[8 * v67];
      *v69 = v63;
      v43 = v69 + 1;
      v71 = __p[1];
      v60 = (_WORD *)v145;
      if ((void *)v145 != __p[1])
      {
        do
        {
          v72 = (const void *)*((_QWORD *)v60 - 1);
          v60 -= 4;
          *--v69 = v72;
        }
        while (v60 != v71);
        v60 = __p[1];
      }
      __p[1] = v69;
      *(_QWORD *)&v145 = v43;
      *((_QWORD *)&v145 + 1) = v70;
      if (v60)
        operator delete(v60);
    }
    else
    {
      *(_QWORD *)v145 = v60;
      v43 = (const void **)(v64 + 8);
    }
    *(_QWORD *)&v145 = v43;
LABEL_98:
    *v61 = 1;
    if (v10)
    {
      for (i = (const void **)__p[1]; i != v43; ++i)
      {
        if (*((_BYTE *)*i + 8) == 17)
        {
          if (i != v43)
          {
            if (!v60)
              __cxa_bad_cast();
            v74 = (char *)v60 + 9;
            goto LABEL_123;
          }
          break;
        }
      }
      v60 = (_WORD *)operator new();
      v75 = v60;
      v60[4] = 17;
      *(_QWORD *)v60 = &off_24D5E4D78;
      v76 = v145;
      if ((unint64_t)v145 >= *((_QWORD *)&v145 + 1))
      {
        v78 = (uint64_t)(v145 - (unint64_t)__p[1]) >> 3;
        if ((unint64_t)(v78 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v79 = (uint64_t)(*((_QWORD *)&v145 + 1) - (unint64_t)__p[1]) >> 2;
        if (v79 <= v78 + 1)
          v79 = v78 + 1;
        if (*((_QWORD *)&v145 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v80 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v80 = v79;
        if (v80)
          v81 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v145 + 8, v80);
        else
          v81 = 0;
        v82 = &v81[8 * v78];
        v83 = &v81[8 * v80];
        *(_QWORD *)v82 = v75;
        v77 = v82 + 8;
        v84 = __p[1];
        v60 = (_WORD *)v145;
        if ((void *)v145 != __p[1])
        {
          do
          {
            v85 = *((_QWORD *)v60 - 1);
            v60 -= 4;
            *((_QWORD *)v82 - 1) = v85;
            v82 -= 8;
          }
          while (v60 != v84);
          v60 = __p[1];
        }
        __p[1] = v82;
        *(_QWORD *)&v145 = v77;
        *((_QWORD *)&v145 + 1) = v83;
        if (v60)
          operator delete(v60);
      }
      else
      {
        *(_QWORD *)v145 = v60;
        v77 = (_QWORD *)(v76 + 8);
      }
      v74 = (char *)v75 + 9;
      *(_QWORD *)&v145 = v77;
LABEL_123:
      *v74 = 12;
    }
    v86 = MEMORY[0x24BDAC760];
    if (!v134)
    {
LABEL_175:
      v118 = qmi::ClientRouter::get();
      v119 = operator new();
      *(_QWORD *)v119 = v118;
      *(_QWORD *)(v119 + 8) = QMIServiceMsg::create();
      *(_DWORD *)(v119 + 16) = 25000;
      *(_QWORD *)(v119 + 24) = 0;
      *(_QWORD *)(v119 + 32) = 0;
      v135 = v119;
      v120 = (std::__shared_weak_count *)operator new(0x20uLL);
      v120->__shared_owners_ = 0;
      v121 = (unint64_t *)&v120->__shared_owners_;
      v120->__shared_weak_owners_ = 0;
      v120->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E4E80;
      v120[1].__vftable = (std::__shared_weak_count_vtbl *)v15;
      v151 = &v120[1].__vftable;
      v152 = v120;
      *(_QWORD *)buf = v86;
      *(_QWORD *)&buf[8] = 1174405120;
      *(_QWORD *)&buf[16] = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZNK23EurekaCallCommandDriver27sendImsCallStatusToBasebandE13CallIMSStatusN10subscriber7SimSlotEbbE3__3EEOS1_OT__block_invoke;
      v159 = &__block_descriptor_tmp_189;
      v160 = &v120[1].__vftable;
      v161 = v120;
      do
        v122 = __ldxr(v121);
      while (__stxr(v122 + 1, v121));
      aBlock = v86;
      v154 = 0x40000000;
      v155 = ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas20ImsStateNotification8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
      v156 = &unk_24D5E4EC8;
      v157 = buf;
      *(_QWORD *)(v119 + 32) = _Block_copy(&aBlock);
      v123 = v161;
      if (v161)
      {
        v124 = (unint64_t *)&v161->__shared_owners_;
        do
          v125 = __ldaxr(v124);
        while (__stlxr(v125 - 1, v124));
        if (!v125)
        {
          ((void (*)(std::__shared_weak_count *))v123->__on_zero_shared)(v123);
          std::__shared_weak_count::__release_weak(v123);
        }
      }
      v126 = v152;
      if (v152)
      {
        v127 = (unint64_t *)&v152->__shared_owners_;
        do
          v128 = __ldaxr(v127);
        while (__stlxr(v128 - 1, v127));
        if (!v128)
        {
          ((void (*)(std::__shared_weak_count *))v126->__on_zero_shared)(v126);
          std::__shared_weak_count::__release_weak(v126);
        }
      }
      v129 = v135;
      v135 = 0;
      if (v129)
        std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v135, v129);
      qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
      goto LABEL_190;
    }
    v87 = (capabilities::ct *)capabilities::ct::supportsNASCallEndReason((capabilities::ct *)v60);
    if ((_DWORD)v87)
    {
      v140[0] = v86;
      v140[1] = 0x40000000;
      v141 = ___ZNK23EurekaCallCommandDriver27sendImsCallStatusToBasebandE13CallIMSStatusN10subscriber7SimSlotEbb_block_invoke;
      v142 = &__block_descriptor_tmp_101_3;
      v143 = v62;
      v88 = (const void **)__p[1];
      if (__p[1] != (void *)v145)
      {
        while (*((_BYTE *)*v88 + 8) != 10)
        {
          if (++v88 == (const void **)v145)
            goto LABEL_133;
        }
      }
      if (v88 == (const void **)v145)
      {
LABEL_133:
        v90 = operator new();
        v91 = v90;
        *(_WORD *)(v90 + 8) = 10;
        *(_QWORD *)v90 = &off_24D5E4DC8;
        v92 = v145;
        if ((unint64_t)v145 >= *((_QWORD *)&v145 + 1))
        {
          v94 = (uint64_t)(v145 - (unint64_t)__p[1]) >> 3;
          if ((unint64_t)(v94 + 1) >> 61)
            goto LABEL_204;
          v95 = (uint64_t)(*((_QWORD *)&v145 + 1) - (unint64_t)__p[1]) >> 2;
          if (v95 <= v94 + 1)
            v95 = v94 + 1;
          if (*((_QWORD *)&v145 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
            v96 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v96 = v95;
          if (v96)
            v97 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v145 + 8, v96);
          else
            v97 = 0;
          v98 = (uint64_t *)&v97[8 * v94];
          v99 = &v97[8 * v96];
          *v98 = v91;
          v93 = v98 + 1;
          v101 = (char *)__p[1];
          v100 = (char *)v145;
          if ((void *)v145 != __p[1])
          {
            do
            {
              v102 = *((_QWORD *)v100 - 1);
              v100 -= 8;
              *--v98 = v102;
            }
            while (v100 != v101);
            v100 = (char *)__p[1];
          }
          __p[1] = v98;
          *(_QWORD *)&v145 = v93;
          *((_QWORD *)&v145 + 1) = v99;
          if (v100)
            operator delete(v100);
        }
        else
        {
          *(_QWORD *)v145 = v90;
          v93 = (_QWORD *)(v92 + 8);
        }
        *(_QWORD *)&v145 = v93;
        v87 = (capabilities::ct *)v141((uint64_t)v140, (_BYTE *)(v91 + 9));
      }
      else
      {
        if (!v89)
          goto LABEL_201;
        v87 = (capabilities::ct *)___ZNK23EurekaCallCommandDriver27sendImsCallStatusToBasebandE13CallIMSStatusN10subscriber7SimSlotEbb_block_invoke((uint64_t)v140, v89 + 9);
      }
    }
    if (!capabilities::ct::supportsCSFBFastSAReturn(v87))
      goto LABEL_175;
    v136[0] = v86;
    v136[1] = 0x40000000;
    v137 = ___ZNK23EurekaCallCommandDriver27sendImsCallStatusToBasebandE13CallIMSStatusN10subscriber7SimSlotEbb_block_invoke_2;
    v138 = &__block_descriptor_tmp_103_2;
    v139 = a2;
    v103 = (const void **)__p[1];
    if (__p[1] != (void *)v145)
    {
      while (*((_BYTE *)*v103 + 8) != 20)
      {
        if (++v103 == (const void **)v145)
          goto LABEL_158;
      }
    }
    if (v103 != (const void **)v145)
    {
      if (v104)
      {
        ___ZNK23EurekaCallCommandDriver27sendImsCallStatusToBasebandE13CallIMSStatusN10subscriber7SimSlotEbb_block_invoke_2((uint64_t)v136, v104 + 9);
        goto LABEL_175;
      }
LABEL_201:
      __cxa_bad_cast();
    }
LABEL_158:
    v105 = operator new();
    v106 = v105;
    *(_WORD *)(v105 + 8) = 20;
    *(_QWORD *)v105 = &off_24D5E4E18;
    v107 = v145;
    if ((unint64_t)v145 < *((_QWORD *)&v145 + 1))
    {
      *(_QWORD *)v145 = v105;
      v108 = (_QWORD *)(v107 + 8);
LABEL_174:
      *(_QWORD *)&v145 = v108;
      v137((uint64_t)v136, (BOOL *)(v106 + 9));
      goto LABEL_175;
    }
    v109 = (uint64_t)(v145 - (unint64_t)__p[1]) >> 3;
    if (!((unint64_t)(v109 + 1) >> 61))
    {
      v110 = (uint64_t)(*((_QWORD *)&v145 + 1) - (unint64_t)__p[1]) >> 2;
      if (v110 <= v109 + 1)
        v110 = v109 + 1;
      if (*((_QWORD *)&v145 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v111 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v111 = v110;
      if (v111)
        v112 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v145 + 8, v111);
      else
        v112 = 0;
      v113 = (uint64_t *)&v112[8 * v109];
      v114 = &v112[8 * v111];
      *v113 = v106;
      v108 = v113 + 1;
      v116 = (char *)__p[1];
      v115 = (char *)v145;
      if ((void *)v145 != __p[1])
      {
        do
        {
          v117 = *((_QWORD *)v115 - 1);
          v115 -= 8;
          *--v113 = v117;
        }
        while (v115 != v116);
        v115 = (char *)__p[1];
      }
      __p[1] = v113;
      *(_QWORD *)&v145 = v108;
      *((_QWORD *)&v145 + 1) = v114;
      if (v115)
        operator delete(v115);
      goto LABEL_174;
    }
LABEL_204:
    std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
  }
  v17 = *(NSObject **)v15;
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    v12 = "#N *** IMS call state notification to BB: Dropping the request as it is handled by IPT on device that supports 5G.";
    v13 = v17;
    v14 = 2;
    goto LABEL_13;
  }
}

void sub_216A438AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34,char a35,uint64_t a36,char a37)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a27);
  if (a34 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

uint64_t ___ZNK23EurekaCallCommandDriver27sendImsCallStatusToBasebandE13CallIMSStatusN10subscriber7SimSlotEbb_block_invoke(uint64_t result, _BYTE *a2)
{
  *a2 = *(_BYTE *)(result + 32);
  return result;
}

uint64_t ___ZNK23EurekaCallCommandDriver27sendImsCallStatusToBasebandE13CallIMSStatusN10subscriber7SimSlotEbb_block_invoke_2(uint64_t result, BOOL *a2)
{
  *a2 = *(_DWORD *)(result + 32) != 4;
  return result;
}

void EurekaCallCommandDriver::selectCallRat(EurekaCallCommandDriver *this, const CallInfo *a2)
{
  NSObject *v4;
  const void **v5;
  const void **v6;
  const void **v7;
  char *v8;
  _WORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  char *v16;
  const void **v17;
  char *v18;
  char *v19;
  char *v20;
  const void *v21;
  char *v22;
  _QWORD *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  char *v31;
  uint64_t *v32;
  char *v33;
  char *v34;
  char *v35;
  uint64_t v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  _QWORD *v40;
  unint64_t *v41;
  uint64_t v42;
  unint64_t v43;
  std::__shared_weak_count *v44;
  unint64_t *p_shared_owners;
  unint64_t v46;
  std::__shared_weak_count *v47;
  unint64_t *v48;
  unint64_t v49;
  uint64_t v50;
  uint64_t v51;
  void *__p[2];
  __int128 v53;
  uint8_t buf[8];
  uint64_t v55;
  void (*v56)(uint64_t, uint64_t);
  void *v57;
  char *v58;
  std::__shared_weak_count *v59;
  char *v60;
  std::__shared_weak_count *v61;
  _QWORD aBlock[5];

  if (capabilities::ct::supports5G(this))
  {
    v4 = *((_QWORD *)this + 5);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I Re-selecting LTE as the current RAT", buf, 2u);
    }
    *(_OWORD *)__p = 0u;
    v53 = 0u;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
    v5 = (const void **)__p[1];
    v6 = (const void **)v53;
    v7 = (const void **)__p[1];
    if (__p[1] != (void *)v53)
    {
      v7 = (const void **)__p[1];
      while (*((_BYTE *)*v7 + 8) != 1)
      {
        if (++v7 == (const void **)v53)
          goto LABEL_12;
      }
    }
    if (v7 == (const void **)v53)
    {
LABEL_12:
      v10 = operator new();
      v11 = v10;
      *(_BYTE *)(v10 + 8) = 1;
      *(_QWORD *)v10 = &off_24D5E4F10;
      *(_WORD *)(v10 + 10) = 0;
      v9 = (_WORD *)(v10 + 10);
      v12 = v53;
      if ((unint64_t)v53 >= *((_QWORD *)&v53 + 1))
      {
        v13 = (uint64_t)(v53 - (unint64_t)__p[1]) >> 3;
        if ((unint64_t)(v13 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v14 = (uint64_t)(*((_QWORD *)&v53 + 1) - (unint64_t)__p[1]) >> 2;
        if (v14 <= v13 + 1)
          v14 = v13 + 1;
        if (*((_QWORD *)&v53 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v15 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v15 = v14;
        if (v15)
          v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v53 + 8, v15);
        else
          v16 = 0;
        v17 = (const void **)&v16[8 * v13];
        v18 = &v16[8 * v15];
        *v17 = (const void *)v11;
        v6 = v17 + 1;
        v20 = (char *)__p[1];
        v19 = (char *)v53;
        if ((void *)v53 != __p[1])
        {
          do
          {
            v21 = (const void *)*((_QWORD *)v19 - 1);
            v19 -= 8;
            *--v17 = v21;
          }
          while (v19 != v20);
          v19 = (char *)__p[1];
        }
        __p[1] = v17;
        *(_QWORD *)&v53 = v6;
        *((_QWORD *)&v53 + 1) = v18;
        if (v19)
          operator delete(v19);
      }
      else
      {
        *(_QWORD *)v53 = v10;
        v6 = (const void **)(v12 + 8);
      }
      *(_QWORD *)&v53 = v6;
      v5 = (const void **)__p[1];
    }
    else
    {
      if (!v8)
        __cxa_bad_cast();
      v9 = v8 + 10;
    }
    *v9 = 16;
    while (v5 != v6)
    {
      if (*((_BYTE *)*v5 + 8) == 2)
      {
        if (v5 != v6)
        {
          if (!v22)
            __cxa_bad_cast();
          v23 = v22 + 16;
          goto LABEL_53;
        }
        break;
      }
      ++v5;
    }
    v24 = operator new();
    v25 = v24;
    *(_BYTE *)(v24 + 8) = 2;
    *(_QWORD *)v24 = &off_24D5E4F60;
    *(_QWORD *)(v24 + 16) = 0;
    v23 = (_QWORD *)(v24 + 16);
    v26 = v53;
    if ((unint64_t)v53 >= *((_QWORD *)&v53 + 1))
    {
      v28 = (uint64_t)(v53 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v28 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v29 = (uint64_t)(*((_QWORD *)&v53 + 1) - (unint64_t)__p[1]) >> 2;
      if (v29 <= v28 + 1)
        v29 = v28 + 1;
      if (*((_QWORD *)&v53 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v30 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v30 = v29;
      if (v30)
        v31 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v53 + 8, v30);
      else
        v31 = 0;
      v32 = (uint64_t *)&v31[8 * v28];
      v33 = &v31[8 * v30];
      *v32 = v25;
      v27 = v32 + 1;
      v35 = (char *)__p[1];
      v34 = (char *)v53;
      if ((void *)v53 != __p[1])
      {
        do
        {
          v36 = *((_QWORD *)v34 - 1);
          v34 -= 8;
          *--v32 = v36;
        }
        while (v34 != v35);
        v34 = (char *)__p[1];
      }
      __p[1] = v32;
      *(_QWORD *)&v53 = v27;
      *((_QWORD *)&v53 + 1) = v33;
      if (v34)
        operator delete(v34);
    }
    else
    {
      *(_QWORD *)v53 = v24;
      v27 = (_QWORD *)(v26 + 8);
    }
    *(_QWORD *)&v53 = v27;
LABEL_53:
    *v23 = 1;
    v37 = *((_DWORD *)a2 + 63);
    v38 = qmi::ClientRouter::get();
    v39 = operator new();
    *(_QWORD *)v39 = v38;
    *(_QWORD *)(v39 + 8) = QMIServiceMsg::create();
    *(_DWORD *)(v39 + 16) = 25000;
    *(_QWORD *)(v39 + 24) = 0;
    *(_QWORD *)(v39 + 32) = 0;
    v51 = v39;
    v40 = operator new(0x28uLL);
    v40[1] = 0;
    v41 = v40 + 1;
    v40[2] = 0;
    *v40 = &off_24D5E4FC8;
    v40[3] = this;
    *((_DWORD *)v40 + 8) = v37;
    v60 = (char *)(v40 + 3);
    v61 = (std::__shared_weak_count *)v40;
    v42 = MEMORY[0x24BDAC760];
    *(_QWORD *)buf = MEMORY[0x24BDAC760];
    v55 = 1174405120;
    v56 = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZNK23EurekaCallCommandDriver13selectCallRatERK8CallInfoE3__2EEOS1_OT__block_invoke;
    v57 = &__block_descriptor_tmp_191_1;
    v58 = (char *)(v40 + 3);
    v59 = (std::__shared_weak_count *)v40;
    do
      v43 = __ldxr(v41);
    while (__stxr(v43 + 1, v41));
    aBlock[0] = v42;
    aBlock[1] = 0x40000000;
    aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_26;
    aBlock[3] = &unk_24D5E3190;
    aBlock[4] = buf;
    *(_QWORD *)(v39 + 32) = _Block_copy(aBlock);
    v44 = v59;
    if (v59)
    {
      p_shared_owners = (unint64_t *)&v59->__shared_owners_;
      do
        v46 = __ldaxr(p_shared_owners);
      while (__stlxr(v46 - 1, p_shared_owners));
      if (!v46)
      {
        ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
        std::__shared_weak_count::__release_weak(v44);
      }
    }
    v47 = v61;
    if (v61)
    {
      v48 = (unint64_t *)&v61->__shared_owners_;
      do
        v49 = __ldaxr(v48);
      while (__stlxr(v49 - 1, v48));
      if (!v49)
      {
        ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
        std::__shared_weak_count::__release_weak(v47);
      }
    }
    v50 = v51;
    v51 = 0;
    if (v50)
      std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v51, v50);
    qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
  }
}

void sub_216A43EA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;
  va_list va;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v6 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v4);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  if (a3)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v3, a3);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

void EurekaCallCommandDriver::~EurekaCallCommandDriver(unsigned int **this)
{
  EurekaCallCommandDriver::~EurekaCallCommandDriver(this);
  JUMPOUT(0x2199FEAC4);
}

{
  unsigned int *v2;

  std::__list_imp<boost::signals2::connection>::clear(this + 42);
  std::__tree<std::__value_type<std::pair<Technology,Type>,InputThreshold>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,InputThreshold>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,InputThreshold>>>::destroy((uint64_t)(this + 39), this[40]);
  std::__tree<std::__value_type<subscriber::SimSlot,std::map<char const*,int>>,std::__map_value_compare<subscriber::SimSlot,std::__value_type<subscriber::SimSlot,std::map<char const*,int>>,std::less<subscriber::SimSlot>,true>,std::allocator<std::__value_type<subscriber::SimSlot,std::map<char const*,int>>>>::destroy((uint64_t)(this + 35), this[36]);
  std::__tree<std::__value_type<std::pair<Technology,Type>,InputThreshold>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,InputThreshold>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,InputThreshold>>>::destroy((uint64_t)(this + 32), this[33]);
  std::__tree<std::__value_type<std::string,std::unique_ptr<ctu::Timer>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<ctu::Timer>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<ctu::Timer>>>>::destroy((uint64_t)(this + 29), this[30]);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)(this + 27));
  std::__tree<std::__value_type<subscriber::SimSlot,std::shared_ptr<EurekaCallFormatter>>,std::__map_value_compare<subscriber::SimSlot,std::__value_type<subscriber::SimSlot,std::shared_ptr<EurekaCallFormatter>>,std::less<subscriber::SimSlot>,true>,std::allocator<std::__value_type<subscriber::SimSlot,std::shared_ptr<EurekaCallFormatter>>>>::destroy((uint64_t)(this + 24), this[25]);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)(this + 21));
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)(this + 19));
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)(this + 17));
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)(this + 15));
  v2 = this[14];
  this[14] = 0;
  if (v2)
    (*(void (**)(unsigned int *))(*(_QWORD *)v2 + 8))(v2);
  CallCommandDriver::~CallCommandDriver((CallCommandDriver *)this);
}

void std::__list_imp<boost::signals2::connection>::clear(unsigned int **a1)
{
  unsigned int *v2;
  unsigned int **v3;
  unsigned int *v4;
  unsigned int **v5;

  if (a1[2])
  {
    v2 = *a1;
    v3 = (unsigned int **)a1[1];
    v4 = *v3;
    *((_QWORD *)v4 + 1) = *((_QWORD *)*a1 + 1);
    **((_QWORD **)v2 + 1) = v4;
    a1[2] = 0;
    if (v3 != a1)
    {
      do
      {
        v5 = (unsigned int **)v3[1];
        boost::detail::weak_count::~weak_count(v3 + 3);
        operator delete(v3);
        v3 = v5;
      }
      while (v5 != a1);
    }
  }
}

void std::vector<CallInfo>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  void **v2;
  void **v4;
  void *v5;

  v1 = *a1;
  v2 = (void **)**a1;
  if (v2)
  {
    v4 = (void **)v1[1];
    v5 = v2;
    if (v4 != v2)
    {
      do
        CallInfo::~CallInfo(v4 - 51);
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void boost::detail::weak_count::~weak_count(unsigned int **this)
{
  unsigned int *v1;
  unsigned int *v2;
  unsigned int v3;
  unsigned int v4;

  v1 = *this;
  if (v1)
  {
    v2 = v1 + 3;
    do
    {
      v3 = __ldaxr(v2);
      v4 = v3 - 1;
    }
    while (__stlxr(v4, v2));
    if (!v4)
      (*(void (**)(unsigned int *))(*(_QWORD *)v1 + 24))(v1);
  }
}

uint64_t std::__function::__func<EurekaCallCommandDriver::dial(CallInfo)::$_0::operator() const(void)::{lambda(vs::VoiceDialCall::Response const&)#1},std::allocator<EurekaCallCommandDriver::dial(CallInfo)::$_0::operator() const(void)::{lambda(vs::VoiceDialCall::Response const&)#1}>,void ()(vs::VoiceDialCall::Response const&)>::~__func(uint64_t a1)
{
  *(_QWORD *)a1 = &off_24D5E2FF8;
  CallInfo::~CallInfo((void **)(a1 + 16));
  return a1;
}

void std::__function::__func<EurekaCallCommandDriver::dial(CallInfo)::$_0::operator() const(void)::{lambda(vs::VoiceDialCall::Response const&)#1},std::allocator<EurekaCallCommandDriver::dial(CallInfo)::$_0::operator() const(void)::{lambda(vs::VoiceDialCall::Response const&)#1}>,void ()(vs::VoiceDialCall::Response const&)>::~__func(uint64_t a1)
{
  *(_QWORD *)a1 = &off_24D5E2FF8;
  CallInfo::~CallInfo((void **)(a1 + 16));
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<EurekaCallCommandDriver::dial(CallInfo)::$_0::operator() const(void)::{lambda(vs::VoiceDialCall::Response const&)#1},std::allocator<EurekaCallCommandDriver::dial(CallInfo)::$_0::operator() const(void)::{lambda(vs::VoiceDialCall::Response const&)#1}>,void ()(vs::VoiceDialCall::Response const&)>::__clone(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;

  v2 = operator new(0x1B0uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *v2 = &off_24D5E2FF8;
  v2[1] = v3;
  CallInfo::CallInfo((CallInfo *)(v2 + 2), (const CallInfo *)(a1 + 16));
  *((_DWORD *)v2 + 106) = *(_DWORD *)(a1 + 424);
  return v2;
}

void sub_216A44154(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__function::__func<EurekaCallCommandDriver::dial(CallInfo)::$_0::operator() const(void)::{lambda(vs::VoiceDialCall::Response const&)#1},std::allocator<EurekaCallCommandDriver::dial(CallInfo)::$_0::operator() const(void)::{lambda(vs::VoiceDialCall::Response const&)#1}>,void ()(vs::VoiceDialCall::Response const&)>::__clone(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  v4 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)a2 = &off_24D5E2FF8;
  *(_QWORD *)(a2 + 8) = v4;
  CallInfo::CallInfo((CallInfo *)(a2 + 16), (const CallInfo *)(a1 + 16));
  *(_DWORD *)(a2 + 424) = *(_DWORD *)(a1 + 424);
}

void std::__function::__func<EurekaCallCommandDriver::dial(CallInfo)::$_0::operator() const(void)::{lambda(vs::VoiceDialCall::Response const&)#1},std::allocator<EurekaCallCommandDriver::dial(CallInfo)::$_0::operator() const(void)::{lambda(vs::VoiceDialCall::Response const&)#1}>,void ()(vs::VoiceDialCall::Response const&)>::destroy(uint64_t a1)
{
  CallInfo::~CallInfo((void **)(a1 + 16));
}

void std::__function::__func<EurekaCallCommandDriver::dial(CallInfo)::$_0::operator() const(void)::{lambda(vs::VoiceDialCall::Response const&)#1},std::allocator<EurekaCallCommandDriver::dial(CallInfo)::$_0::operator() const(void)::{lambda(vs::VoiceDialCall::Response const&)#1}>,void ()(vs::VoiceDialCall::Response const&)>::destroy_deallocate(void **a1)
{
  CallInfo::~CallInfo(a1 + 2);
  operator delete(a1);
}

const void **std::__function::__func<EurekaCallCommandDriver::dial(CallInfo)::$_0::operator() const(void)::{lambda(vs::VoiceDialCall::Response const&)#1},std::allocator<EurekaCallCommandDriver::dial(CallInfo)::$_0::operator() const(void)::{lambda(vs::VoiceDialCall::Response const&)#1}>,void ()(vs::VoiceDialCall::Response const&)>::operator()(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v4;
  const void *v6;

  v4 = *(_QWORD *)(a1 + 8);
  ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::SharedRef(&v6, (const void **)(a1 + 16));
  EurekaCallCommandDriver::handleNormalVoiceDialResp(v4, a2, &v6, *(unsigned int *)(a1 + 424));
  return ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::~SharedRef(&v6);
}

void sub_216A44238(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::~SharedRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<EurekaCallCommandDriver::dial(CallInfo)::$_0::operator() const(void)::{lambda(vs::VoiceDialCall::Response const&)#1},std::allocator<EurekaCallCommandDriver::dial(CallInfo)::$_0::operator() const(void)::{lambda(vs::VoiceDialCall::Response const&)#1}>,void ()(vs::VoiceDialCall::Response const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<EurekaCallCommandDriver::dial(CallInfo)::$_0::operator() const(void)::{lambda(vs::VoiceDialCall::Response const&)#1},std::allocator<EurekaCallCommandDriver::dial(CallInfo)::$_0::operator() const(void)::{lambda(vs::VoiceDialCall::Response const&)#1}>,void ()(vs::VoiceDialCall::Response const&)>::target_type()
{
}

_QWORD *std::vector<vs::tlv::CallListItem>::__init_with_size[abi:ne180100]<vs::tlv::CallListItem*,vs::tlv::CallListItem*>(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<PlmnPriorityData>::__vallocate[abi:ne180100](result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_216A442F0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<vs::tlv::RemoteNameListItem>,vs::tlv::RemoteNameListItem*,vs::tlv::RemoteNameListItem*,vs::tlv::RemoteNameListItem*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  __int128 *v6;
  __int16 v7;
  uint64_t v8;
  std::string *v9;
  __int128 v10;
  _QWORD v12[3];
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v4 = a4;
  v14 = a4;
  v15 = a4;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  v13 = 0;
  if (a2 != a3)
  {
    v6 = (__int128 *)(a2 + 8);
    do
    {
      v8 = (uint64_t)v6 - 8;
      v7 = *((_WORD *)v6 - 4);
      *(_BYTE *)(v4 + 2) = *((_BYTE *)v6 - 6);
      *(_WORD *)v4 = v7;
      v9 = (std::string *)(v4 + 8);
      if (*((char *)v6 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(v9, *(const std::string::value_type **)v6, *((_QWORD *)v6 + 1));
        v4 = v15;
      }
      else
      {
        v10 = *v6;
        *(_QWORD *)(v4 + 24) = *((_QWORD *)v6 + 2);
        *(_OWORD *)&v9->__r_.__value_.__l.__data_ = v10;
      }
      v4 += 32;
      v15 = v4;
      v6 += 2;
    }
    while (v8 + 32 != a3);
  }
  LOBYTE(v13) = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<cat::tlv::Item>,cat::tlv::Item*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return v4;
}

void sub_216A443C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<cat::tlv::Item>,cat::tlv::Item*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,vs::tlv::RemoteNameListItem *,vs::tlv::RemoteNameListItem *,vs::tlv::RemoteNameListItem *,0>(__int16 *a1, __int16 *a2, uint64_t a3)
{
  __int16 *v5;
  __int16 v6;

  if (a1 != a2)
  {
    v5 = a1;
    do
    {
      v6 = *v5;
      *(_BYTE *)(a3 + 2) = *((_BYTE *)v5 + 2);
      *(_WORD *)a3 = v6;
      std::string::operator=((std::string *)(a3 + 8), (const std::string *)(v5 + 4));
      a3 += 32;
      v5 += 16;
    }
    while (v5 != a2);
  }
  return a3;
}

void std::__optional_storage_base<std::vector<unsigned int>,false>::__assign_from[abi:ne180100]<std::__optional_copy_assign_base<std::vector<unsigned int>,false> const&>(uint64_t a1, uint64_t a2)
{
  void *v3;

  if (*(unsigned __int8 *)(a1 + 24) == *(unsigned __int8 *)(a2 + 24))
  {
    if (a1 != a2)
    {
      if (*(_BYTE *)(a1 + 24))
        std::vector<wds::tlv::DestPortRangeInfo>::__assign_with_size[abi:ne180100]<wds::tlv::DestPortRangeInfo*,wds::tlv::DestPortRangeInfo*>((char *)a1, *(char **)a2, *(_QWORD *)(a2 + 8), (uint64_t)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 2);
    }
  }
  else if (*(_BYTE *)(a1 + 24))
  {
    v3 = *(void **)a1;
    if (*(_QWORD *)a1)
    {
      *(_QWORD *)(a1 + 8) = v3;
      operator delete(v3);
    }
    *(_BYTE *)(a1 + 24) = 0;
  }
  else
  {
    *(_QWORD *)a1 = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    std::vector<unsigned int>::__init_with_size[abi:ne180100]<unsigned int *,unsigned int *>((_QWORD *)a1, *(const void **)a2, *(_QWORD *)(a2 + 8), (uint64_t)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 2);
    *(_BYTE *)(a1 + 24) = 1;
  }
}

void SimInstanceLoggable<EurekaCallCommandDriver,ctu::OsLogLogger,subscriber::SimSlot>::~SimInstanceLoggable()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t SimInstanceLoggable<EurekaCallCommandDriver,ctu::OsLogLogger,subscriber::SimSlot>::getLoggerForSlot(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8) + 40;
}

void std::__tree<std::__value_type<subscriber::SimSlot,std::shared_ptr<EurekaCallFormatter>>,std::__map_value_compare<subscriber::SimSlot,std::__value_type<subscriber::SimSlot,std::shared_ptr<EurekaCallFormatter>>,std::less<subscriber::SimSlot>,true>,std::allocator<std::__value_type<subscriber::SimSlot,std::shared_ptr<EurekaCallFormatter>>>>::destroy(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<subscriber::SimSlot,std::shared_ptr<EurekaCallFormatter>>,std::__map_value_compare<subscriber::SimSlot,std::__value_type<subscriber::SimSlot,std::shared_ptr<EurekaCallFormatter>>,std::less<subscriber::SimSlot>,true>,std::allocator<std::__value_type<subscriber::SimSlot,std::shared_ptr<EurekaCallFormatter>>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<subscriber::SimSlot,std::shared_ptr<EurekaCallFormatter>>,std::__map_value_compare<subscriber::SimSlot,std::__value_type<subscriber::SimSlot,std::shared_ptr<EurekaCallFormatter>>,std::less<subscriber::SimSlot>,true>,std::allocator<std::__value_type<subscriber::SimSlot,std::shared_ptr<EurekaCallFormatter>>>>::destroy(a1, a2[1]);
    std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)(a2 + 5));
    operator delete(a2);
  }
}

void std::__tree<std::__value_type<std::string,std::unique_ptr<ctu::Timer>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<ctu::Timer>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<ctu::Timer>>>>::destroy(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<std::string,std::unique_ptr<ctu::Timer>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<ctu::Timer>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<ctu::Timer>>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<std::string,std::unique_ptr<ctu::Timer>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<ctu::Timer>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<ctu::Timer>>>>::destroy(a1, a2[1]);
    std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::unique_ptr<ctu::Timer>>,0>((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

void std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::unique_ptr<ctu::Timer>>,0>(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 24) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
}

void std::__tree<std::__value_type<subscriber::SimSlot,std::map<char const*,int>>,std::__map_value_compare<subscriber::SimSlot,std::__value_type<subscriber::SimSlot,std::map<char const*,int>>,std::less<subscriber::SimSlot>,true>,std::allocator<std::__value_type<subscriber::SimSlot,std::map<char const*,int>>>>::destroy(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<subscriber::SimSlot,std::map<char const*,int>>,std::__map_value_compare<subscriber::SimSlot,std::__value_type<subscriber::SimSlot,std::map<char const*,int>>,std::less<subscriber::SimSlot>,true>,std::allocator<std::__value_type<subscriber::SimSlot,std::map<char const*,int>>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<subscriber::SimSlot,std::map<char const*,int>>,std::__map_value_compare<subscriber::SimSlot,std::__value_type<subscriber::SimSlot,std::map<char const*,int>>,std::less<subscriber::SimSlot>,true>,std::allocator<std::__value_type<subscriber::SimSlot,std::map<char const*,int>>>>::destroy(a1, a2[1]);
    std::__tree<std::__value_type<std::pair<Technology,Type>,InputThreshold>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,InputThreshold>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,InputThreshold>>>::destroy((uint64_t)(a2 + 5), (_QWORD *)a2[6]);
    operator delete(a2);
  }
}

void qmi::MutableMessageBase::TlvWrapper<vs::tlv::VoiceIndRegCallEventsNotify>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<vs::tlv::VoiceIndRegCallEventsNotify>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<vs::tlv::VoiceIndRegCallEventsNotify>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<vs::tlv::VoiceIndRegCallEventsNotify>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E30E0;
  return result;
}

uint64_t qmi::ClientRouter::SendProxy::SendProxy<vs::SendVoiceIndRegister::Request>(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v5;

  *(_DWORD *)a1 = a2;
  v5 = operator new();
  *(_QWORD *)v5 = a3;
  *(_QWORD *)(v5 + 8) = QMIServiceMsg::create();
  *(_DWORD *)(v5 + 16) = 25000;
  *(_QWORD *)(v5 + 24) = 0;
  *(_QWORD *)(v5 + 32) = 0;
  *(_QWORD *)(a1 + 8) = v5;
  return a1;
}

void sub_216A447FC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199FEAC4](v1, 0x10F0C401BA14CC5);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN23EurekaCallCommandDriver25sendVSIndRegisterReq_syncENS_16SubscriptionTypeEE3__1EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  int v2;
  NSObject *v3;
  _DWORD v4[2];
  __int16 v5;
  uint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v2 = *(_DWORD *)(a2 + 4);
  if (v2)
  {
    v3 = ***(NSObject ****)(a1 + 32);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      v4[0] = 67109378;
      v4[1] = v2;
      v5 = 2080;
      v6 = qmi::asString();
      _os_log_error_impl(&dword_216897000, v3, OS_LOG_TYPE_ERROR, "Error in response while unregistering for voice events on USSD client. With code = 0x%x (%s)", (uint8_t *)v4, 0x12u);
    }
  }
}

uint64_t __copy_helper_block_e8_32c110_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver25sendVSIndRegisterReq_syncEN3qmi16SubscriptionTypeEE3__1EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c110_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver25sendVSIndRegisterReq_syncEN3qmi16SubscriptionTypeEE3__1EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::sendVSIndRegisterReq_sync(qmi::SubscriptionType)::$_1,std::allocator<EurekaCallCommandDriver::sendVSIndRegisterReq_sync(qmi::SubscriptionType)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E3148;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::sendVSIndRegisterReq_sync(qmi::SubscriptionType)::$_1,std::allocator<EurekaCallCommandDriver::sendVSIndRegisterReq_sync(qmi::SubscriptionType)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E3148;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void qmi::MutableMessageBase::TlvWrapper<vs::tlv::HandoverEventEnable>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<vs::tlv::HandoverEventEnable>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<vs::tlv::HandoverEventEnable>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<vs::tlv::HandoverEventEnable>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E31D8;
  return result;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN23EurekaCallCommandDriver25sendVSIndRegisterReq_syncENS_16SubscriptionTypeEE3__3EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  int v2;
  NSObject *v3;
  _DWORD v4[2];
  __int16 v5;
  uint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v2 = *(_DWORD *)(a2 + 4);
  if (v2)
  {
    v3 = ***(NSObject ****)(a1 + 32);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      v4[0] = 67109378;
      v4[1] = v2;
      v5 = 2080;
      v6 = qmi::asString();
      _os_log_impl(&dword_216897000, v3, OS_LOG_TYPE_DEFAULT, "#I Error in response while registering for Handover Events. With code = 0x%x (%s)", (uint8_t *)v4, 0x12u);
    }
  }
}

uint64_t __copy_helper_block_e8_32c110_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver25sendVSIndRegisterReq_syncEN3qmi16SubscriptionTypeEE3__3EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c110_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver25sendVSIndRegisterReq_syncEN3qmi16SubscriptionTypeEE3__3EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::sendVSIndRegisterReq_sync(qmi::SubscriptionType)::$_3,std::allocator<EurekaCallCommandDriver::sendVSIndRegisterReq_sync(qmi::SubscriptionType)::$_3>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E3240;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::sendVSIndRegisterReq_sync(qmi::SubscriptionType)::$_3,std::allocator<EurekaCallCommandDriver::sendVSIndRegisterReq_sync(qmi::SubscriptionType)::$_3>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E3240;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN23EurekaCallCommandDriver23bindVSSubscription_syncENS_16SubscriptionTypeEE3__0EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t *v2;
  uint64_t v3;
  unsigned int v5;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  int v9;
  unsigned int v10;
  uint64_t v11;
  os_log_t *v12;
  NSObject *v13;
  const void **v14;
  char *v15;
  _BYTE *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  char *v24;
  uint64_t *v25;
  char *v26;
  char *v27;
  char *v28;
  uint64_t v29;
  uint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *p_shared_owners;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  std::__shared_weak_count *v36;
  unint64_t *v37;
  unint64_t v38;
  unint64_t v39;
  uint64_t v40;
  NSObject *v41;
  const void **v42;
  char *v43;
  _BYTE *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  _QWORD *v48;
  uint64_t v49;
  unint64_t v50;
  unint64_t v51;
  char *v52;
  uint64_t *v53;
  char *v54;
  char *v55;
  char *v56;
  uint64_t v57;
  uint64_t v58;
  std::__shared_weak_count *v59;
  unint64_t *v60;
  uint64_t v61;
  unint64_t v62;
  std::__shared_weak_count *v63;
  unint64_t *v64;
  unint64_t v65;
  unint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  void *__p[2];
  __int128 v71;
  uint64_t aBlock;
  uint64_t v73;
  void (*v74)(uint64_t, uint64_t);
  void *v75;
  _BYTE *v76;
  _BYTE buf[24];
  void *v78;
  std::__shared_weak_count *v79;
  std::__shared_weak_count *v80;
  uint64_t v81;

  v81 = *MEMORY[0x24BDAC8D0];
  v2 = *(uint64_t **)(a1 + 32);
  v3 = *v2;
  if (*(_DWORD *)(a2 + 4))
  {
    v5 = *((_DWORD *)v2 + 2);
    v6 = v5 - 1 >= 3 ? 0 : v5;
    v7 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v3 + 112) + 16))(*(_QWORD *)(v3 + 112), v6);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      v8 = qmi::asString();
      v9 = *(_DWORD *)(a2 + 4);
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = v8;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v9;
      _os_log_impl(&dword_216897000, v7, OS_LOG_TYPE_DEFAULT, "#N Error binding VS subscription: %s (0x%x)", buf, 0x12u);
    }
  }
  v10 = *((_DWORD *)v2 + 2);
  if (v10 - 1 >= 3)
    v11 = 0;
  else
    v11 = v10;
  v12 = (os_log_t *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v3 + 112) + 16))(*(_QWORD *)(v3 + 112), v11);
  v13 = *v12;
  if (os_log_type_enabled(*v12, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_216897000, v13, OS_LOG_TYPE_DEFAULT, "#I Sending VS indication registration requests", buf, 2u);
  }
  *(_OWORD *)__p = 0u;
  v71 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  v14 = (const void **)__p[1];
  if (__p[1] != (void *)v71)
  {
    while (*((_BYTE *)*v14 + 8) != 19)
    {
      if (++v14 == (const void **)v71)
        goto LABEL_19;
    }
  }
  if (v14 == (const void **)v71)
  {
LABEL_19:
    v17 = operator new();
    v18 = v17;
    *(_WORD *)(v17 + 8) = 19;
    *(_QWORD *)v17 = &off_24D5E30E0;
    v19 = v71;
    if ((unint64_t)v71 >= *((_QWORD *)&v71 + 1))
    {
      v21 = (uint64_t)(v71 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v21 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v22 = (uint64_t)(*((_QWORD *)&v71 + 1) - (unint64_t)__p[1]) >> 2;
      if (v22 <= v21 + 1)
        v22 = v21 + 1;
      if (*((_QWORD *)&v71 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v23 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v23 = v22;
      if (v23)
        v24 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v71 + 8, v23);
      else
        v24 = 0;
      v25 = (uint64_t *)&v24[8 * v21];
      v26 = &v24[8 * v23];
      *v25 = v18;
      v20 = v25 + 1;
      v28 = (char *)__p[1];
      v27 = (char *)v71;
      if ((void *)v71 != __p[1])
      {
        do
        {
          v29 = *((_QWORD *)v27 - 1);
          v27 -= 8;
          *--v25 = v29;
        }
        while (v27 != v28);
        v27 = (char *)__p[1];
      }
      __p[1] = v25;
      *(_QWORD *)&v71 = v20;
      *((_QWORD *)&v71 + 1) = v26;
      if (v27)
        operator delete(v27);
    }
    else
    {
      *(_QWORD *)v71 = v17;
      v20 = (_QWORD *)(v19 + 8);
    }
    v16 = (_BYTE *)(v18 + 9);
    *(_QWORD *)&v71 = v20;
  }
  else
  {
    if (!v15)
      __cxa_bad_cast();
    v16 = v15 + 9;
  }
  *v16 = 0;
  v30 = qmi::ClientRouter::get();
  qmi::ClientRouter::SendProxy::SendProxy<vs::SendVoiceIndRegister::Request>((uint64_t)&v68, v10, v30);
  v31 = (std::__shared_weak_count *)operator new(0x20uLL);
  v31->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v31->__shared_owners_;
  v31->__shared_weak_owners_ = 0;
  v31[1].__vftable = (std::__shared_weak_count_vtbl *)v12;
  v31->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E3148;
  v33 = v69;
  v34 = MEMORY[0x24BDAC760];
  *(_QWORD *)buf = MEMORY[0x24BDAC760];
  *(_QWORD *)&buf[8] = 1174405120;
  *(_QWORD *)&buf[16] = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN23EurekaCallCommandDriver25sendVSIndRegisterReq_syncENS_16SubscriptionTypeEE3__1EEOS1_OT__block_invoke;
  v78 = &__block_descriptor_tmp_130_5;
  v79 = v31 + 1;
  v80 = v31;
  do
    v35 = __ldxr(p_shared_owners);
  while (__stxr(v35 + 1, p_shared_owners));
  aBlock = v34;
  v73 = 0x40000000;
  v74 = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_26;
  v75 = &unk_24D5E3190;
  v76 = buf;
  *(_QWORD *)(v33 + 32) = _Block_copy(&aBlock);
  v36 = v80;
  if (v80)
  {
    v37 = (unint64_t *)&v80->__shared_owners_;
    do
      v38 = __ldaxr(v37);
    while (__stlxr(v38 - 1, v37));
    if (!v38)
    {
      ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
      std::__shared_weak_count::__release_weak(v36);
    }
  }
  do
    v39 = __ldaxr(p_shared_owners);
  while (__stlxr(v39 - 1, p_shared_owners));
  if (!v39)
  {
    ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
    std::__shared_weak_count::__release_weak(v31);
  }
  v40 = v69;
  v69 = 0;
  if (v40)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v69, v40);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
  v41 = *v12;
  if (os_log_type_enabled(*v12, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_216897000, v41, OS_LOG_TYPE_DEFAULT, "#I Registering for handover events.", buf, 2u);
  }
  *(_OWORD *)__p = 0u;
  v71 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  v42 = (const void **)__p[1];
  if (__p[1] != (void *)v71)
  {
    while (*((_BYTE *)*v42 + 8) != 20)
    {
      if (++v42 == (const void **)v71)
        goto LABEL_57;
    }
  }
  if (v42 == (const void **)v71)
  {
LABEL_57:
    v45 = operator new();
    v46 = v45;
    *(_WORD *)(v45 + 8) = 20;
    *(_QWORD *)v45 = &off_24D5E31D8;
    v47 = v71;
    if ((unint64_t)v71 >= *((_QWORD *)&v71 + 1))
    {
      v49 = (uint64_t)(v71 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v49 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v50 = (uint64_t)(*((_QWORD *)&v71 + 1) - (unint64_t)__p[1]) >> 2;
      if (v50 <= v49 + 1)
        v50 = v49 + 1;
      if (*((_QWORD *)&v71 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v51 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v51 = v50;
      if (v51)
        v52 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v71 + 8, v51);
      else
        v52 = 0;
      v53 = (uint64_t *)&v52[8 * v49];
      v54 = &v52[8 * v51];
      *v53 = v46;
      v48 = v53 + 1;
      v56 = (char *)__p[1];
      v55 = (char *)v71;
      if ((void *)v71 != __p[1])
      {
        do
        {
          v57 = *((_QWORD *)v55 - 1);
          v55 -= 8;
          *--v53 = v57;
        }
        while (v55 != v56);
        v55 = (char *)__p[1];
      }
      __p[1] = v53;
      *(_QWORD *)&v71 = v48;
      *((_QWORD *)&v71 + 1) = v54;
      if (v55)
        operator delete(v55);
    }
    else
    {
      *(_QWORD *)v71 = v45;
      v48 = (_QWORD *)(v47 + 8);
    }
    v44 = (_BYTE *)(v46 + 9);
    *(_QWORD *)&v71 = v48;
  }
  else
  {
    if (!v43)
      __cxa_bad_cast();
    v44 = v43 + 9;
  }
  *v44 = 1;
  v58 = qmi::ClientRouter::get();
  qmi::ClientRouter::SendProxy::SendProxy<vs::SendVoiceIndRegister::Request>((uint64_t)&v68, v10, v58);
  v59 = (std::__shared_weak_count *)operator new(0x20uLL);
  v59->__shared_owners_ = 0;
  v60 = (unint64_t *)&v59->__shared_owners_;
  v59->__shared_weak_owners_ = 0;
  v59->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E3240;
  v59[1].__vftable = (std::__shared_weak_count_vtbl *)v12;
  v61 = v69;
  *(_QWORD *)buf = v34;
  *(_QWORD *)&buf[8] = 1174405120;
  *(_QWORD *)&buf[16] = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN23EurekaCallCommandDriver25sendVSIndRegisterReq_syncENS_16SubscriptionTypeEE3__3EEOS1_OT__block_invoke;
  v78 = &__block_descriptor_tmp_132;
  v79 = v59 + 1;
  v80 = v59;
  do
    v62 = __ldxr(v60);
  while (__stxr(v62 + 1, v60));
  aBlock = v34;
  v73 = 0x40000000;
  v74 = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_26;
  v75 = &unk_24D5E3190;
  v76 = buf;
  *(_QWORD *)(v61 + 32) = _Block_copy(&aBlock);
  v63 = v80;
  if (v80)
  {
    v64 = (unint64_t *)&v80->__shared_owners_;
    do
      v65 = __ldaxr(v64);
    while (__stlxr(v65 - 1, v64));
    if (!v65)
    {
      ((void (*)(std::__shared_weak_count *))v63->__on_zero_shared)(v63);
      std::__shared_weak_count::__release_weak(v63);
    }
  }
  do
    v66 = __ldaxr(v60);
  while (__stlxr(v66 - 1, v60));
  if (!v66)
  {
    ((void (*)(std::__shared_weak_count *))v59->__on_zero_shared)(v59);
    std::__shared_weak_count::__release_weak(v59);
  }
  v67 = v69;
  v69 = 0;
  if (v67)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v69, v67);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
}

void sub_216A4522C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,std::__shared_weak_count *a26)
{
  std::__shared_weak_count *v26;
  unint64_t *v27;
  std::__shared_weak_count *v29;
  unint64_t *p_shared_owners;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;

  v29 = a26;
  if (a26)
  {
    p_shared_owners = (unint64_t *)&a26->__shared_owners_;
    do
      v31 = __ldaxr(p_shared_owners);
    while (__stlxr(v31 - 1, p_shared_owners));
    if (!v31)
    {
      ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
      std::__shared_weak_count::__release_weak(v29);
    }
  }
  do
    v32 = __ldaxr(v27);
  while (__stlxr(v32 - 1, v27));
  if (!v32)
  {
    ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
    std::__shared_weak_count::__release_weak(v26);
  }
  v33 = a10;
  a10 = 0;
  if (v33)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&a10, v33);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a11);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_32c108_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver23bindVSSubscription_syncEN3qmi16SubscriptionTypeEE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c108_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver23bindVSSubscription_syncEN3qmi16SubscriptionTypeEE3__0EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::bindVSSubscription_sync(qmi::SubscriptionType)::$_0,std::allocator<EurekaCallCommandDriver::bindVSSubscription_sync(qmi::SubscriptionType)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E32C0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::bindVSSubscription_sync(qmi::SubscriptionType)::$_0,std::allocator<EurekaCallCommandDriver::bindVSSubscription_sync(qmi::SubscriptionType)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E32C0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN2vs16BindSubscription8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke_0(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BYTE v3[24];

  v2 = *(_QWORD *)(a1 + 32);
  cast_message_type<vs::BindSubscription::Response const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_216A45408(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN23EurekaCallCommandDriver24bindNASSubscription_syncENS_16SubscriptionTypeEE3__0EEOS1_OT__block_invoke(_BOOL8 a1, uint64_t a2)
{
  uint64_t *v2;
  uint64_t v3;
  unsigned int v5;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  int v9;
  int v10;
  const void **v11;
  char *v12;
  _BYTE *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  char *v21;
  uint64_t *v22;
  char *v23;
  char *v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *p_shared_owners;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  std::__shared_weak_count *v33;
  unint64_t *v34;
  unint64_t v35;
  unint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  void *__p[2];
  __int128 v41;
  _QWORD aBlock[5];
  _BYTE buf[24];
  void *v44;
  std::__shared_weak_count *v45;
  std::__shared_weak_count *v46;
  uint64_t v47;

  v47 = *MEMORY[0x24BDAC8D0];
  v2 = *(uint64_t **)(a1 + 32);
  v3 = *v2;
  if (*(_DWORD *)(a2 + 4))
  {
    v5 = *((_DWORD *)v2 + 2);
    v6 = v5 - 1 >= 3 ? 0 : v5;
    v7 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v3 + 112) + 16))(*(_QWORD *)(v3 + 112), v6);
    a1 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
    if (a1)
    {
      v8 = qmi::asString();
      v9 = *(_DWORD *)(a2 + 4);
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = v8;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v9;
      _os_log_impl(&dword_216897000, v7, OS_LOG_TYPE_DEFAULT, "#N Error binding NAS subscription: %s (0x%x)", buf, 0x12u);
    }
  }
  v10 = *((_DWORD *)v2 + 2);
  if (capabilities::ct::supports5G((capabilities::ct *)a1))
  {
    *(_OWORD *)__p = 0u;
    v41 = 0u;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
    v11 = (const void **)__p[1];
    if (__p[1] != (void *)v41)
    {
      while (*((_BYTE *)*v11 + 8) != 63)
      {
        if (++v11 == (const void **)v41)
          goto LABEL_15;
      }
    }
    if (v11 == (const void **)v41)
    {
LABEL_15:
      v14 = operator new();
      v15 = v14;
      *(_WORD *)(v14 + 8) = 63;
      *(_QWORD *)v14 = &off_24D5E3478;
      v16 = v41;
      if ((unint64_t)v41 >= *((_QWORD *)&v41 + 1))
      {
        v18 = (uint64_t)(v41 - (unint64_t)__p[1]) >> 3;
        if ((unint64_t)(v18 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v19 = (uint64_t)(*((_QWORD *)&v41 + 1) - (unint64_t)__p[1]) >> 2;
        if (v19 <= v18 + 1)
          v19 = v18 + 1;
        if (*((_QWORD *)&v41 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v20 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v20 = v19;
        if (v20)
          v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v41 + 8, v20);
        else
          v21 = 0;
        v22 = (uint64_t *)&v21[8 * v18];
        v23 = &v21[8 * v20];
        *v22 = v15;
        v17 = v22 + 1;
        v25 = (char *)__p[1];
        v24 = (char *)v41;
        if ((void *)v41 != __p[1])
        {
          do
          {
            v26 = *((_QWORD *)v24 - 1);
            v24 -= 8;
            *--v22 = v26;
          }
          while (v24 != v25);
          v24 = (char *)__p[1];
        }
        __p[1] = v22;
        *(_QWORD *)&v41 = v17;
        *((_QWORD *)&v41 + 1) = v23;
        if (v24)
          operator delete(v24);
      }
      else
      {
        *(_QWORD *)v41 = v14;
        v17 = (_QWORD *)(v16 + 8);
      }
      v13 = (_BYTE *)(v15 + 9);
      *(_QWORD *)&v41 = v17;
    }
    else
    {
      if (!v12)
        __cxa_bad_cast();
      v13 = v12 + 9;
    }
    *v13 = 1;
    v27 = qmi::ClientRouter::get();
    qmi::ClientRouter::SendProxy::SendProxy<nas::IndicationRegister::Request>((uint64_t)&v38, v10, v27);
    v28 = (std::__shared_weak_count *)operator new(0x28uLL);
    v28->__shared_owners_ = 0;
    p_shared_owners = (unint64_t *)&v28->__shared_owners_;
    v28->__shared_weak_owners_ = 0;
    v28->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E34E0;
    v28[1].__vftable = (std::__shared_weak_count_vtbl *)v3;
    LODWORD(v28[1].__shared_owners_) = v10;
    v30 = v39;
    v31 = MEMORY[0x24BDAC760];
    *(_QWORD *)buf = MEMORY[0x24BDAC760];
    *(_QWORD *)&buf[8] = 1174405120;
    *(_QWORD *)&buf[16] = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN23EurekaCallCommandDriver26sendNASIndRegisterReq_syncENS_16SubscriptionTypeEE3__0EEOS1_OT__block_invoke;
    v44 = &__block_descriptor_tmp_138_0;
    v45 = v28 + 1;
    v46 = v28;
    do
      v32 = __ldxr(p_shared_owners);
    while (__stxr(v32 + 1, p_shared_owners));
    aBlock[0] = v31;
    aBlock[1] = 0x40000000;
    aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_26;
    aBlock[3] = &unk_24D5E3190;
    aBlock[4] = buf;
    *(_QWORD *)(v30 + 32) = _Block_copy(aBlock);
    v33 = v46;
    if (v46)
    {
      v34 = (unint64_t *)&v46->__shared_owners_;
      do
        v35 = __ldaxr(v34);
      while (__stlxr(v35 - 1, v34));
      if (!v35)
      {
        ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
        std::__shared_weak_count::__release_weak(v33);
      }
    }
    do
      v36 = __ldaxr(p_shared_owners);
    while (__stlxr(v36 - 1, p_shared_owners));
    if (!v36)
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
    v37 = v39;
    v39 = 0;
    if (v37)
      std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v39, v37);
    qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
  }
}

void sub_216A457D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,std::__shared_weak_count *a26)
{
  std::__shared_weak_count *v26;
  unint64_t *v27;
  std::__shared_weak_count *v29;
  unint64_t *p_shared_owners;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;

  v29 = a26;
  if (a26)
  {
    p_shared_owners = (unint64_t *)&a26->__shared_owners_;
    do
      v31 = __ldaxr(p_shared_owners);
    while (__stlxr(v31 - 1, p_shared_owners));
    if (!v31)
    {
      ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
      std::__shared_weak_count::__release_weak(v29);
    }
  }
  do
    v32 = __ldaxr(v27);
  while (__stlxr(v32 - 1, v27));
  if (!v32)
  {
    ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
    std::__shared_weak_count::__release_weak(v26);
  }
  v33 = a10;
  a10 = 0;
  if (v33)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&a10, v33);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a11);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_32c109_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver24bindNASSubscription_syncEN3qmi16SubscriptionTypeEE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c109_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver24bindNASSubscription_syncEN3qmi16SubscriptionTypeEE3__0EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::bindNASSubscription_sync(qmi::SubscriptionType)::$_0,std::allocator<EurekaCallCommandDriver::bindNASSubscription_sync(qmi::SubscriptionType)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E3368;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::bindNASSubscription_sync(qmi::SubscriptionType)::$_0,std::allocator<EurekaCallCommandDriver::bindNASSubscription_sync(qmi::SubscriptionType)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E3368;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas16BindSubscription8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke_5(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BYTE v3[24];

  v2 = *(_QWORD *)(a1 + 32);
  cast_message_type<nas::BindSubscription::Response const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_216A45940(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN23EurekaCallCommandDriver27bindVsUSSDSubscription_syncENS_16SubscriptionTypeEE3__0EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t *v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  __int16 v12;
  int v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)(a2 + 4))
  {
    v3 = *(uint64_t **)(a1 + 32);
    v4 = *v3;
    v5 = *((_DWORD *)v3 + 2);
    if (v5 - 1 >= 3)
      v6 = 0;
    else
      v6 = v5;
    v7 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v4 + 112) + 16))(*(_QWORD *)(v4 + 112), v6);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      v8 = qmi::asString();
      v9 = *(_DWORD *)(a2 + 4);
      v10 = 136315394;
      v11 = v8;
      v12 = 1024;
      v13 = v9;
      _os_log_impl(&dword_216897000, v7, OS_LOG_TYPE_DEFAULT, "#N Error binding NAS subscription: %s (0x%x)", (uint8_t *)&v10, 0x12u);
    }
  }
}

uint64_t __copy_helper_block_e8_32c112_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver27bindVsUSSDSubscription_syncEN3qmi16SubscriptionTypeEE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c112_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver27bindVsUSSDSubscription_syncEN3qmi16SubscriptionTypeEE3__0EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::bindVsUSSDSubscription_sync(qmi::SubscriptionType)::$_0,std::allocator<EurekaCallCommandDriver::bindVsUSSDSubscription_sync(qmi::SubscriptionType)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E3410;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::bindVsUSSDSubscription_sync(qmi::SubscriptionType)::$_0,std::allocator<EurekaCallCommandDriver::bindVsUSSDSubscription_sync(qmi::SubscriptionType)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E3410;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::CallReadyInd>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::CallReadyInd>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<nas::tlv::CallReadyInd>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::CallReadyInd>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E3478;
  return result;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN23EurekaCallCommandDriver26sendNASIndRegisterReq_syncENS_16SubscriptionTypeEE3__0EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t *v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;
  os_log_t *v7;
  int v8;
  NSObject *v9;
  _DWORD v10[2];
  __int16 v11;
  uint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v3 = *(uint64_t **)(a1 + 32);
  v4 = *v3;
  v5 = *((_DWORD *)v3 + 2);
  if (v5 - 1 >= 3)
    v6 = 0;
  else
    v6 = v5;
  v7 = (os_log_t *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v4 + 112) + 16))(*(_QWORD *)(v4 + 112), v6);
  v8 = *(_DWORD *)(a2 + 4);
  if (v8)
  {
    v9 = *v7;
    if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
    {
      v10[0] = 67109378;
      v10[1] = v8;
      v11 = 2080;
      v12 = qmi::asString();
      _os_log_impl(&dword_216897000, v9, OS_LOG_TYPE_DEFAULT, "#N Register for NAS indications failed: Error in response with code %d (%s)", (uint8_t *)v10, 0x12u);
    }
  }
}

uint64_t __copy_helper_block_e8_32c111_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver26sendNASIndRegisterReq_syncEN3qmi16SubscriptionTypeEE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c111_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver26sendNASIndRegisterReq_syncEN3qmi16SubscriptionTypeEE3__0EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::sendNASIndRegisterReq_sync(qmi::SubscriptionType)::$_0,std::allocator<EurekaCallCommandDriver::sendNASIndRegisterReq_sync(qmi::SubscriptionType)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E34E0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::sendNASIndRegisterReq_sync(qmi::SubscriptionType)::$_0,std::allocator<EurekaCallCommandDriver::sendNASIndRegisterReq_sync(qmi::SubscriptionType)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E34E0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void std::__function::__func<EurekaCallCommandDriver::registerForQMIIndications(void)::$_0,std::allocator<EurekaCallCommandDriver::registerForQMIIndications(void)::$_0>,void ()(qmi::SubscriptionType)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<EurekaCallCommandDriver::registerForQMIIndications(void)::$_0,std::allocator<EurekaCallCommandDriver::registerForQMIIndications(void)::$_0>,void ()(qmi::SubscriptionType)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5E3530;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<EurekaCallCommandDriver::registerForQMIIndications(void)::$_0,std::allocator<EurekaCallCommandDriver::registerForQMIIndications(void)::$_0>,void ()(qmi::SubscriptionType)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5E3530;
  a2[1] = v2;
  return result;
}

void std::__function::__func<EurekaCallCommandDriver::registerForQMIIndications(void)::$_0,std::allocator<EurekaCallCommandDriver::registerForQMIIndications(void)::$_0>,void ()(qmi::SubscriptionType)>::operator()(uint64_t a1, unsigned int *a2)
{
  unsigned int v2;
  uint64_t v3;
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _OWORD v19[2];
  uint8_t buf[8];
  uint64_t v21;
  void (*v22)(uint64_t, uint64_t);
  void *v23;
  std::__shared_weak_count *v24;
  std::__shared_weak_count *v25;
  _QWORD aBlock[5];

  v2 = *a2;
  v3 = *(_QWORD *)(a1 + 8);
  if (*a2 - 1 >= 3)
    v4 = 0;
  else
    v4 = v2;
  v5 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v3 + 112) + 16))(*(_QWORD *)(v3 + 112), v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#I Eureka CallCommandDriver VSClient started", buf, 2u);
  }
  memset(v19, 0, sizeof(v19));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v19);
  *(_BYTE *)qmi::MutableMessageBase::getTLV<vs::tlv::SubscriptionType>(v19, 1) = v2 == 2;
  v6 = qmi::ClientRouter::get();
  qmi::ClientRouter::SendProxy::SendProxy<vs::BindSubscription::Request>((uint64_t)&v17, v2, v6);
  v7 = (std::__shared_weak_count *)operator new(0x28uLL);
  v7->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v7->__shared_owners_;
  v7->__shared_weak_owners_ = 0;
  v7->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E32C0;
  v7[1].__vftable = (std::__shared_weak_count_vtbl *)v3;
  LODWORD(v7[1].__shared_owners_) = v2;
  v9 = v18;
  v10 = MEMORY[0x24BDAC760];
  *(_QWORD *)buf = MEMORY[0x24BDAC760];
  v21 = 1174405120;
  v22 = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN23EurekaCallCommandDriver23bindVSSubscription_syncENS_16SubscriptionTypeEE3__0EEOS1_OT__block_invoke;
  v23 = &__block_descriptor_tmp_133_0;
  v24 = v7 + 1;
  v25 = v7;
  do
    v11 = __ldxr(p_shared_owners);
  while (__stxr(v11 + 1, p_shared_owners));
  aBlock[0] = v10;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKN2vs16BindSubscription8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke_0;
  aBlock[3] = &unk_24D5E3308;
  aBlock[4] = buf;
  *(_QWORD *)(v9 + 32) = _Block_copy(aBlock);
  v12 = v25;
  if (v25)
  {
    v13 = (unint64_t *)&v25->__shared_owners_;
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  do
    v15 = __ldaxr(p_shared_owners);
  while (__stlxr(v15 - 1, p_shared_owners));
  if (!v15)
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  v16 = v18;
  v18 = 0;
  if (v16)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v18, v16);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v19);
}

void sub_216A45F28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20)
{
  std::__shared_weak_count *v20;
  unint64_t *v21;
  std::__shared_weak_count *v23;
  unint64_t *p_shared_owners;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;

  v23 = a20;
  if (a20)
  {
    p_shared_owners = (unint64_t *)&a20->__shared_owners_;
    do
      v25 = __ldaxr(p_shared_owners);
    while (__stlxr(v25 - 1, p_shared_owners));
    if (!v25)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }
  do
    v26 = __ldaxr(v21);
  while (__stlxr(v26 - 1, v21));
  if (!v26)
  {
    ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
    std::__shared_weak_count::__release_weak(v20);
  }
  v27 = a10;
  a10 = 0;
  if (v27)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&a10, v27);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a11);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<EurekaCallCommandDriver::registerForQMIIndications(void)::$_0,std::allocator<EurekaCallCommandDriver::registerForQMIIndications(void)::$_0>,void ()(qmi::SubscriptionType)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<EurekaCallCommandDriver::registerForQMIIndications(void)::$_0,std::allocator<EurekaCallCommandDriver::registerForQMIIndications(void)::$_0>,void ()(qmi::SubscriptionType)>::target_type()
{
}

void std::__function::__func<EurekaCallCommandDriver::registerForQMIIndications(void)::$_1,std::allocator<EurekaCallCommandDriver::registerForQMIIndications(void)::$_1>,void ()(qmi::SubscriptionType)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<EurekaCallCommandDriver::registerForQMIIndications(void)::$_1,std::allocator<EurekaCallCommandDriver::registerForQMIIndications(void)::$_1>,void ()(qmi::SubscriptionType)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5E35B0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<EurekaCallCommandDriver::registerForQMIIndications(void)::$_1,std::allocator<EurekaCallCommandDriver::registerForQMIIndications(void)::$_1>,void ()(qmi::SubscriptionType)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5E35B0;
  a2[1] = v2;
  return result;
}

void std::__function::__func<EurekaCallCommandDriver::registerForQMIIndications(void)::$_1,std::allocator<EurekaCallCommandDriver::registerForQMIIndications(void)::$_1>,void ()(qmi::SubscriptionType)>::operator()(uint64_t a1, _DWORD *a2)
{
  uint64_t v2;
  NSObject *v3;
  uint8_t v4[16];

  if ((*a2 - 1) >= 3)
    v2 = 0;
  else
    v2 = *a2;
  v3 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(*(_QWORD *)(a1 + 8) + 112) + 16))(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 112), v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v4 = 0;
    _os_log_impl(&dword_216897000, v3, OS_LOG_TYPE_DEFAULT, "#I Eureka CallCommandDriver VSClient stopped", v4, 2u);
  }
}

uint64_t std::__function::__func<EurekaCallCommandDriver::registerForQMIIndications(void)::$_1,std::allocator<EurekaCallCommandDriver::registerForQMIIndications(void)::$_1>,void ()(qmi::SubscriptionType)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<EurekaCallCommandDriver::registerForQMIIndications(void)::$_1,std::allocator<EurekaCallCommandDriver::registerForQMIIndications(void)::$_1>,void ()(qmi::SubscriptionType)>::target_type()
{
}

void std::__function::__func<EurekaCallCommandDriver::registerForQMIIndications(void)::$_2,std::allocator<EurekaCallCommandDriver::registerForQMIIndications(void)::$_2>,void ()(qmi::SubscriptionType)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<EurekaCallCommandDriver::registerForQMIIndications(void)::$_2,std::allocator<EurekaCallCommandDriver::registerForQMIIndications(void)::$_2>,void ()(qmi::SubscriptionType)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5E3630;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<EurekaCallCommandDriver::registerForQMIIndications(void)::$_2,std::allocator<EurekaCallCommandDriver::registerForQMIIndications(void)::$_2>,void ()(qmi::SubscriptionType)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5E3630;
  a2[1] = v2;
  return result;
}

void std::__function::__func<EurekaCallCommandDriver::registerForQMIIndications(void)::$_2,std::allocator<EurekaCallCommandDriver::registerForQMIIndications(void)::$_2>,void ()(qmi::SubscriptionType)>::operator()(uint64_t a1, _DWORD *a2)
{
  uint64_t v2;
  NSObject *v3;
  uint8_t v4[16];

  if ((*a2 - 1) >= 3)
    v2 = 0;
  else
    v2 = *a2;
  v3 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(*(_QWORD *)(a1 + 8) + 112) + 16))(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 112), v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v4 = 0;
    _os_log_impl(&dword_216897000, v3, OS_LOG_TYPE_DEFAULT, "#I Eureka CallCommandDriver VSClient server error", v4, 2u);
  }
}

uint64_t std::__function::__func<EurekaCallCommandDriver::registerForQMIIndications(void)::$_2,std::allocator<EurekaCallCommandDriver::registerForQMIIndications(void)::$_2>,void ()(qmi::SubscriptionType)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<EurekaCallCommandDriver::registerForQMIIndications(void)::$_2,std::allocator<EurekaCallCommandDriver::registerForQMIIndications(void)::$_2>,void ()(qmi::SubscriptionType)>::target_type()
{
}

void std::__function::__func<EurekaCallCommandDriver::registerForQMIIndications(void)::$_3,std::allocator<EurekaCallCommandDriver::registerForQMIIndications(void)::$_3>,void ()(qmi::SubscriptionType)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<EurekaCallCommandDriver::registerForQMIIndications(void)::$_3,std::allocator<EurekaCallCommandDriver::registerForQMIIndications(void)::$_3>,void ()(qmi::SubscriptionType)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5E36B0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<EurekaCallCommandDriver::registerForQMIIndications(void)::$_3,std::allocator<EurekaCallCommandDriver::registerForQMIIndications(void)::$_3>,void ()(qmi::SubscriptionType)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5E36B0;
  a2[1] = v2;
  return result;
}

void std::__function::__func<EurekaCallCommandDriver::registerForQMIIndications(void)::$_3,std::allocator<EurekaCallCommandDriver::registerForQMIIndications(void)::$_3>,void ()(qmi::SubscriptionType)>::operator()(uint64_t a1, unsigned int *a2)
{
  unsigned int v2;
  uint64_t v3;
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _OWORD v19[2];
  uint8_t buf[8];
  uint64_t v21;
  void (*v22)(_BOOL8, uint64_t);
  void *v23;
  std::__shared_weak_count *v24;
  std::__shared_weak_count *v25;
  _QWORD aBlock[5];

  v2 = *a2;
  v3 = *(_QWORD *)(a1 + 8);
  if (*a2 - 1 >= 3)
    v4 = 0;
  else
    v4 = v2;
  v5 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v3 + 112) + 16))(*(_QWORD *)(v3 + 112), v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#I Eureka CallCommandDriver NAS Client started", buf, 2u);
  }
  memset(v19, 0, sizeof(v19));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v19);
  *(_BYTE *)qmi::MutableMessageBase::getTLV<nas::tlv::SubType>(v19, 1) = v2 == 2;
  v6 = qmi::ClientRouter::get();
  qmi::ClientRouter::SendProxy::SendProxy<nas::BindSubscription::Request>((uint64_t)&v17, v2, v6);
  v7 = (std::__shared_weak_count *)operator new(0x28uLL);
  v7->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v7->__shared_owners_;
  v7->__shared_weak_owners_ = 0;
  v7->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E3368;
  v7[1].__vftable = (std::__shared_weak_count_vtbl *)v3;
  LODWORD(v7[1].__shared_owners_) = v2;
  v9 = v18;
  v10 = MEMORY[0x24BDAC760];
  *(_QWORD *)buf = MEMORY[0x24BDAC760];
  v21 = 1174405120;
  v22 = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN23EurekaCallCommandDriver24bindNASSubscription_syncENS_16SubscriptionTypeEE3__0EEOS1_OT__block_invoke;
  v23 = &__block_descriptor_tmp_135_0;
  v24 = v7 + 1;
  v25 = v7;
  do
    v11 = __ldxr(p_shared_owners);
  while (__stxr(v11 + 1, p_shared_owners));
  aBlock[0] = v10;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas16BindSubscription8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke_5;
  aBlock[3] = &unk_24D5E33B0;
  aBlock[4] = buf;
  *(_QWORD *)(v9 + 32) = _Block_copy(aBlock);
  v12 = v25;
  if (v25)
  {
    v13 = (unint64_t *)&v25->__shared_owners_;
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  do
    v15 = __ldaxr(p_shared_owners);
  while (__stlxr(v15 - 1, p_shared_owners));
  if (!v15)
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  v16 = v18;
  v18 = 0;
  if (v16)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v18, v16);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v19);
}

void sub_216A464E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20)
{
  std::__shared_weak_count *v20;
  unint64_t *v21;
  std::__shared_weak_count *v23;
  unint64_t *p_shared_owners;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;

  v23 = a20;
  if (a20)
  {
    p_shared_owners = (unint64_t *)&a20->__shared_owners_;
    do
      v25 = __ldaxr(p_shared_owners);
    while (__stlxr(v25 - 1, p_shared_owners));
    if (!v25)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }
  do
    v26 = __ldaxr(v21);
  while (__stlxr(v26 - 1, v21));
  if (!v26)
  {
    ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
    std::__shared_weak_count::__release_weak(v20);
  }
  v27 = a10;
  a10 = 0;
  if (v27)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&a10, v27);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a11);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<EurekaCallCommandDriver::registerForQMIIndications(void)::$_3,std::allocator<EurekaCallCommandDriver::registerForQMIIndications(void)::$_3>,void ()(qmi::SubscriptionType)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<EurekaCallCommandDriver::registerForQMIIndications(void)::$_3,std::allocator<EurekaCallCommandDriver::registerForQMIIndications(void)::$_3>,void ()(qmi::SubscriptionType)>::target_type()
{
}

void std::__function::__func<EurekaCallCommandDriver::registerForQMIIndications(void)::$_4,std::allocator<EurekaCallCommandDriver::registerForQMIIndications(void)::$_4>,void ()(qmi::SubscriptionType)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<EurekaCallCommandDriver::registerForQMIIndications(void)::$_4,std::allocator<EurekaCallCommandDriver::registerForQMIIndications(void)::$_4>,void ()(qmi::SubscriptionType)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5E3730;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<EurekaCallCommandDriver::registerForQMIIndications(void)::$_4,std::allocator<EurekaCallCommandDriver::registerForQMIIndications(void)::$_4>,void ()(qmi::SubscriptionType)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5E3730;
  a2[1] = v2;
  return result;
}

void std::__function::__func<EurekaCallCommandDriver::registerForQMIIndications(void)::$_4,std::allocator<EurekaCallCommandDriver::registerForQMIIndications(void)::$_4>,void ()(qmi::SubscriptionType)>::operator()(uint64_t a1, unsigned int *a2)
{
  unsigned int v2;
  uint64_t v3;
  uint64_t v4;
  NSObject *v5;
  _BOOL8 v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _OWORD v20[2];
  uint8_t buf[8];
  uint64_t v22;
  void (*v23)(uint64_t, uint64_t);
  void *v24;
  std::__shared_weak_count *v25;
  std::__shared_weak_count *v26;
  _QWORD aBlock[5];

  v2 = *a2;
  v3 = *(_QWORD *)(a1 + 8);
  if (*a2 - 1 >= 3)
    v4 = 0;
  else
    v4 = v2;
  v5 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v3 + 112) + 16))(*(_QWORD *)(v3 + 112), v4);
  v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (v6)
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#I Eureka CallCommandDriver USSD Client started", buf, 2u);
  }
  if (capabilities::ct::supports5G((capabilities::ct *)v6))
  {
    memset(v20, 0, sizeof(v20));
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v20);
    *(_BYTE *)qmi::MutableMessageBase::getTLV<vs::tlv::SubscriptionType>(v20, 1) = v2 == 2;
    v7 = qmi::ClientRouter::get();
    qmi::ClientRouter::SendProxy::SendProxy<vs::BindSubscription::Request>((uint64_t)&v18, v2, v7);
    v8 = (std::__shared_weak_count *)operator new(0x28uLL);
    v8->__shared_owners_ = 0;
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    v8->__shared_weak_owners_ = 0;
    v8->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E3410;
    v8[1].__vftable = (std::__shared_weak_count_vtbl *)v3;
    LODWORD(v8[1].__shared_owners_) = v2;
    v10 = v19;
    v11 = MEMORY[0x24BDAC760];
    *(_QWORD *)buf = MEMORY[0x24BDAC760];
    v22 = 1174405120;
    v23 = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN23EurekaCallCommandDriver27bindVsUSSDSubscription_syncENS_16SubscriptionTypeEE3__0EEOS1_OT__block_invoke;
    v24 = &__block_descriptor_tmp_137_0;
    v25 = v8 + 1;
    v26 = v8;
    do
      v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
    aBlock[0] = v11;
    aBlock[1] = 0x40000000;
    aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKN2vs16BindSubscription8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke_0;
    aBlock[3] = &unk_24D5E3308;
    aBlock[4] = buf;
    *(_QWORD *)(v10 + 32) = _Block_copy(aBlock);
    v13 = v26;
    if (v26)
    {
      v14 = (unint64_t *)&v26->__shared_owners_;
      do
        v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }
    do
      v16 = __ldaxr(p_shared_owners);
    while (__stlxr(v16 - 1, p_shared_owners));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
    v17 = v19;
    v19 = 0;
    if (v17)
      std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v19, v17);
    qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v20);
  }
}

void sub_216A46848(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20)
{
  std::__shared_weak_count *v20;
  unint64_t *v21;
  std::__shared_weak_count *v23;
  unint64_t *p_shared_owners;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;

  v23 = a20;
  if (a20)
  {
    p_shared_owners = (unint64_t *)&a20->__shared_owners_;
    do
      v25 = __ldaxr(p_shared_owners);
    while (__stlxr(v25 - 1, p_shared_owners));
    if (!v25)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }
  do
    v26 = __ldaxr(v21);
  while (__stlxr(v26 - 1, v21));
  if (!v26)
  {
    ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
    std::__shared_weak_count::__release_weak(v20);
  }
  v27 = a10;
  a10 = 0;
  if (v27)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&a10, v27);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a11);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<EurekaCallCommandDriver::registerForQMIIndications(void)::$_4,std::allocator<EurekaCallCommandDriver::registerForQMIIndications(void)::$_4>,void ()(qmi::SubscriptionType)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<EurekaCallCommandDriver::registerForQMIIndications(void)::$_4,std::allocator<EurekaCallCommandDriver::registerForQMIIndications(void)::$_4>,void ()(qmi::SubscriptionType)>::target_type()
{
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_5>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_5 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_5 &&,QMIServiceMsg const)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_5>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_5 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_5 &&,QMIServiceMsg const)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5E37B0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_5>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_5 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_5 &&,QMIServiceMsg const)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5E37B0;
  a2[1] = v2;
  return result;
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_5>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_5 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_5 &&,QMIServiceMsg const)>::operator()(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  uint64_t v4;
  _BYTE v5[24];

  v4 = *a2;
  cast_message_type<vs::VoiceCallStatus::Indication const&>::cast(a3, (qmi::MessageBase *)v5);
  EurekaCallCommandDriver::handleVoiceAllCallStatusIndication(*(_QWORD *)(a1 + 8), v4, (qmi::MessageBase *)v5);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v5);
}

void sub_216A469E8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_5>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_5 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_5 &&,QMIServiceMsg const)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_5>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_5 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_5 &&,QMIServiceMsg const)>::target_type()
{
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_6>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_6 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_6 &&,QMIServiceMsg const)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_6>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_6 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_6 &&,QMIServiceMsg const)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5E3830;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_6>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_6 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_6 &&,QMIServiceMsg const)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5E3830;
  a2[1] = v2;
  return result;
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_6>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_6 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_6 &&,QMIServiceMsg const)>::operator()(uint64_t a1, _DWORD *a2, QMIServiceMsg *this)
{
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;
  os_log_t *v8;
  char *v9;
  uint64_t TlvValue;
  int v11;
  uint64_t v12;
  int v13;
  NSObject *v14;
  NSObject *v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  unint64_t v20;
  uint8_t *v21;
  _BYTE *v22;
  char *v23;
  int v24;
  char *v25;
  int v26;
  char *v27;
  char *v28;
  int v29;
  char *v30;
  int v31;
  char *v32;
  uint8_t *v33;
  _BYTE *v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  int v38;
  int v39;
  int v40;
  NSObject *v41;
  NSObject *v42;
  int v43;
  NSObject *v44;
  uint64_t v45;
  int v46;
  uint64_t v47;
  int v48;
  uint64_t v49;
  NSObject *v50;
  NSObject *v51;
  uint64_t v52;
  char v53;
  std::__shared_weak_count *v54;
  unint64_t *p_shared_owners;
  unint64_t v56;
  NSObject *v57;
  _WORD v58[12];
  uint64_t v59;
  uint64_t *v60;
  uint64_t v61;
  char v62;
  uint64_t v63;
  uint64_t *v64;
  uint64_t v65;
  char v66;
  char *v67[2];
  uint64_t (*v68)(uint64_t, uint64_t *);
  void *v69;
  uint64_t *v70;
  uint64_t v71;
  uint64_t *v72;
  uint64_t v73;
  char v74;
  char *v75[2];
  double (*v76)(uint64_t, char **);
  void *v77;
  uint8_t *v78;
  unint64_t v79[2];
  double (*v80)(uint64_t, char **);
  void *v81;
  uint8_t *v82;
  _QWORD v83[2];
  std::string *(*v84)(uint64_t, uint64_t);
  void *v85;
  uint64_t *v86;
  uint8_t *v87;
  uint64_t v88;
  uint64_t *v89;
  uint64_t v90;
  char v91;
  uint8_t v92[8];
  uint8_t *v93;
  uint64_t v94;
  __n128 (*v95)(uint64_t, uint64_t);
  void (*v96)(uint64_t);
  void *v97[2];
  uint64_t v98;
  uint8_t buf[8];
  uint8_t *v100;
  uint64_t v101;
  __n128 (*v102)(uint64_t, uint64_t);
  void (*v103)(uint64_t);
  void *v104[2];
  uint64_t v105;
  _QWORD v106[2];
  uint64_t (*v107)(uint64_t, unsigned __int8 *);
  void *v108;
  uint8_t *v109;
  _QWORD v110[5];
  uint64_t v111;
  uint64_t *v112;
  uint64_t v113;
  char v114;
  void *__p[2];
  __int128 v116;
  std::string v117[2];
  __int128 v118;
  __int128 v119;
  __int128 v120;
  __int128 v121;
  __int128 v122;
  __int128 v123;
  __int128 v124;
  __int128 v125;
  __int128 v126;
  __int128 v127;
  __int128 v128;
  __int128 v129;
  __int128 v130;
  __int128 v131;
  __int128 v132;
  __int128 v133;
  __int128 v134;
  __int128 v135;
  __int128 v136;
  __int128 v137;
  uint64_t v138;
  __int16 v139;
  char v140;
  uint8_t v141[8];
  std::__shared_weak_count *v142;
  uint8_t v143[16];
  __int128 v144;
  uint64_t *v145;
  uint64_t *v146;
  uint64_t v147;

  v147 = *MEMORY[0x24BDAC8D0];
  LODWORD(v4) = *a2;
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p[1] = 0;
    __p[0] = 0;
    *(_QWORD *)&v116 = 0;
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v58, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v58);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v58);
  }
  v6 = *(_QWORD *)(a1 + 8);
  v138 = 0;
  v136 = 0u;
  v137 = 0u;
  v134 = 0u;
  v135 = 0u;
  v132 = 0u;
  v133 = 0u;
  v130 = 0u;
  v131 = 0u;
  v128 = 0u;
  v129 = 0u;
  v126 = 0u;
  v127 = 0u;
  v124 = 0u;
  v125 = 0u;
  v122 = 0u;
  v123 = 0u;
  v120 = 0u;
  v121 = 0u;
  v118 = 0u;
  v119 = 0u;
  v116 = 0u;
  memset(v117, 0, sizeof(v117));
  *(_OWORD *)__p = 0u;
  CallInfo::CallInfo((CallInfo *)__p);
  if ((v4 - 1) >= 3)
    v7 = 0;
  else
    v7 = v4;
  v8 = (os_log_t *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v6 + 112) + 16))(*(_QWORD *)(v6 + 112), v7);
  if ((v4 - 1) >= 3)
    v4 = 0;
  else
    v4 = v4;
  v111 = 0;
  v112 = &v111;
  v113 = 0x2000000000;
  v114 = 0;
  v9 = (char *)MEMORY[0x24BDAC760];
  v110[0] = MEMORY[0x24BDAC760];
  v110[1] = 0x40000000;
  v110[2] = ___ZN23EurekaCallCommandDriver28handleVoiceInfoRecIndicationEN3qmi16SubscriptionTypeERKN2vs12VoiceInfoRec10IndicationE_block_invoke;
  v110[3] = &unk_24D5E2C78;
  v110[4] = &v111;
  *(_QWORD *)buf = v110;
  if ((qmi::MessageBase::applyTlv<vs::tlv::CallIdentifier,void({block_pointer})(vs::tlv::CallIdentifier const&)>((qmi::MessageBase *)v58, 1, (uint64_t)buf) & 1) != 0)
  {
    HIDWORD(v118) = *((unsigned __int8 *)v112 + 24);
    HIDWORD(v128) = v4;
    if (!CallCommandDriver::carrierSupportsCallingTimewithFWIM())
      goto LABEL_27;
    *(_QWORD *)buf = 0;
    v100 = buf;
    v101 = 0x2000000000;
    LOWORD(v102) = 0;
    v106[0] = v9;
    v106[1] = 0x40000000;
    v107 = ___ZN23EurekaCallCommandDriver28handleVoiceInfoRecIndicationEN3qmi16SubscriptionTypeERKN2vs12VoiceInfoRec10IndicationE_block_invoke_43;
    v108 = &unk_24D5E2CA0;
    v109 = buf;
    TlvValue = qmi::MessageBase::findTlvValue((qmi::MessageBase *)v58);
    v12 = TlvValue;
    if (TlvValue)
    {
      v13 = v11;
      *(_QWORD *)v92 = TlvValue;
      LODWORD(v83[0]) = tlv::parseV<vs::tlv::LineControl>((_BYTE **)v92, v11);
      if (*(_QWORD *)v92)
      {
        v107((uint64_t)v106, (unsigned __int8 *)v83);
        goto LABEL_22;
      }
      if (((unsigned int (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(v58[0], 29, v12, v13))
      {
LABEL_22:
        if (*((_WORD *)v100 + 12))
        {
          v15 = *v8;
          if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)v92 = 0;
            _os_log_impl(&dword_216897000, v15, OS_LOG_TYPE_DEFAULT, "#I Telling the call to go active now that we got correct TLV (polarity)", v92, 2u);
          }
          (*(void (**)(_QWORD, void **))(**(_QWORD **)(v6 + 120) + 56))(*(_QWORD *)(v6 + 120), __p);
        }
      }
    }
    _Block_object_dispose(buf, 8);
LABEL_27:
    *(_QWORD *)buf = 0;
    v100 = buf;
    v101 = 0x4002000000;
    v102 = __Block_byref_object_copy__8;
    v103 = __Block_byref_object_dispose__8;
    v104[1] = 0;
    v105 = 0;
    v104[0] = 0;
    std::string::basic_string[abi:ne180100]<0>(v104, (char *)&unk_216AC4FCA);
    *(_QWORD *)v92 = 0;
    v93 = v92;
    v94 = 0x4002000000;
    v95 = __Block_byref_object_copy__8;
    v96 = __Block_byref_object_dispose__8;
    v97[1] = 0;
    v98 = 0;
    v97[0] = 0;
    std::string::basic_string[abi:ne180100]<0>(v97, (char *)&unk_216AC4FCA);
    v88 = 0;
    v89 = &v88;
    v90 = 0x2000000000;
    v91 = 2;
    v83[0] = v9;
    v83[1] = 0x40000000;
    v84 = ___ZN23EurekaCallCommandDriver28handleVoiceInfoRecIndicationEN3qmi16SubscriptionTypeERKN2vs12VoiceInfoRec10IndicationE_block_invoke_46;
    v85 = &unk_24D5E2CC8;
    v86 = &v88;
    v87 = buf;
    v16 = qmi::MessageBase::findTlvValue((qmi::MessageBase *)v58);
    v18 = v16;
    if (!v16)
    {
LABEL_35:
      if (numberContainsAlphabet())
      {
        *((_BYTE *)v89 + 24) = 1;
        v21 = v100;
        if ((char)v100[63] < 0)
        {
          *((_QWORD *)v100 + 6) = 0;
          v22 = (_BYTE *)*((_QWORD *)v21 + 5);
        }
        else
        {
          v22 = v100 + 40;
          v100[63] = 0;
        }
        *v22 = 0;
      }
      v79[0] = (unint64_t)v9;
      v79[1] = 0x40000000;
      v80 = ___ZN23EurekaCallCommandDriver28handleVoiceInfoRecIndicationEN3qmi16SubscriptionTypeERKN2vs12VoiceInfoRec10IndicationE_block_invoke_2;
      v81 = &unk_24D5E2CF0;
      v82 = v92;
      v23 = (char *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)v58);
      v25 = v23;
      if (v23)
      {
        v26 = v24;
        v75[0] = v23;
        memset(v143, 0, sizeof(v143));
        *(_QWORD *)&v144 = 0;
        tlv::parseV<vs::tlv::CallerName>(v75, v24, v143);
        v27 = v75[0];
        if (v75[0])
          v80((uint64_t)v79, (char **)v143);
        if (*(_QWORD *)v143)
        {
          *(_QWORD *)&v143[8] = *(_QWORD *)v143;
          operator delete(*(void **)v143);
        }
        if (!v27)
          ((void (*)(_QWORD, uint64_t, char *, _QWORD))*MEMORY[0x24BED8BD0])(v58[0], 20, v25, v26);
      }
      v75[0] = v9;
      v75[1] = (char *)0x40000000;
      v76 = ___ZN23EurekaCallCommandDriver28handleVoiceInfoRecIndicationEN3qmi16SubscriptionTypeERKN2vs12VoiceInfoRec10IndicationE_block_invoke_3;
      v77 = &unk_24D5E2D18;
      v78 = v92;
      v28 = (char *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)v58);
      v30 = v28;
      if (v28)
      {
        v31 = v29;
        v67[0] = v28;
        memset(v143, 0, sizeof(v143));
        *(_QWORD *)&v144 = 0;
        tlv::parseV<vs::tlv::DisplayBuffer>(v67, v29, v143);
        v32 = v67[0];
        if (v67[0])
          v76((uint64_t)v75, (char **)v143);
        if (*(_QWORD *)v143)
        {
          *(_QWORD *)&v143[8] = *(_QWORD *)v143;
          operator delete(*(void **)v143);
        }
        if (!v32)
          ((void (*)(_QWORD, uint64_t, char *, _QWORD))*MEMORY[0x24BED8BD0])(v58[0], 18, v30, v31);
      }
      if (*((_BYTE *)v89 + 24))
      {
        v33 = v100;
        if ((char)v100[63] < 0)
        {
          *((_QWORD *)v100 + 6) = 0;
          v34 = (_BYTE *)*((_QWORD *)v33 + 5);
        }
        else
        {
          v34 = v100 + 40;
          v100[63] = 0;
        }
        *v34 = 0;
      }
      std::string::operator=(v117, (const std::string *)(v100 + 40));
      std::string::operator=((std::string *)&__p[1], (const std::string *)(v93 + 40));
      LODWORD(v118) = *((unsigned __int8 *)v89 + 24);
      v71 = 0;
      v72 = &v71;
      v73 = 0x2000000000;
      v74 = 0;
      v67[0] = v9;
      v67[1] = (char *)0x40000000;
      v68 = (uint64_t (*)(uint64_t, uint64_t *))___ZN23EurekaCallCommandDriver28handleVoiceInfoRecIndicationEN3qmi16SubscriptionTypeERKN2vs12VoiceInfoRec10IndicationE_block_invoke_4;
      v69 = &unk_24D5E2D40;
      v70 = &v71;
      v35 = qmi::MessageBase::findTlvValue((qmi::MessageBase *)v58);
      v37 = v35;
      if (v35)
      {
        v38 = v36;
        *(_QWORD *)v143 = v35;
        LOBYTE(v63) = tlv::parseV<vs::tlv::CallWaitingInfo>((unint64_t *)v143, v36);
        if (*(_QWORD *)v143)
          v68((uint64_t)v67, &v63);
        else
          ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(v58[0], 21, v37, v38);
      }
      if (!*((_BYTE *)v72 + 24))
        goto LABEL_69;
      v39 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v6 + 120) + 224))(*(_QWORD *)(v6 + 120), v4);
      v40 = *((unsigned __int8 *)v112 + 24);
      if (v39 != v40)
      {
        v50 = *v8;
        if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)v143 = 67109376;
          *(_DWORD *)&v143[4] = v40;
          *(_WORD *)&v143[8] = 1024;
          *(_DWORD *)&v143[10] = v39;
          _os_log_impl(&dword_216897000, v50, OS_LOG_TYPE_DEFAULT, "#I Got a traffic channel id, %d, that does not match the one we have, %d. Dropping the Voice Info Record indication.", v143, 0xEu);
        }
        goto LABEL_97;
      }
      if (*((_BYTE *)v72 + 24))
      {
        v41 = *v8;
        if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)v143 = 67109120;
          *(_DWORD *)&v143[4] = v39;
          _os_log_impl(&dword_216897000, v41, OS_LOG_TYPE_DEFAULT, "#I --->BB Incoming VoiceInfoRecord Indication: WAITING for %d", v143, 8u);
        }
        (*(void (**)(_QWORD, void **, uint64_t))(**(_QWORD **)(v6 + 120) + 96))(*(_QWORD *)(v6 + 120), __p, 22000);
      }
      else
      {
LABEL_69:
        v42 = *v8;
        if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
        {
          v43 = *((unsigned __int8 *)v112 + 24);
          *(_DWORD *)v143 = 67109120;
          *(_DWORD *)&v143[4] = v43;
          _os_log_impl(&dword_216897000, v42, OS_LOG_TYPE_DEFAULT, "#I --->BB Incoming VoiceInfoRecord Indication: Caller Id for %d", v143, 8u);
        }
        if ((v18 & 1) == 0)
        {
          v44 = *v8;
          if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)v143 = 0;
            _os_log_impl(&dword_216897000, v44, OS_LOG_TYPE_DEFAULT, "#I There is no caller id information but we are setting caller id to Unknown/kUnavailable since this indication came", v143, 2u);
          }
        }
        (*(void (**)(_QWORD, void **))(**(_QWORD **)(v6 + 120) + 200))(*(_QWORD *)(v6 + 120), __p);
      }
      v63 = 0;
      v64 = &v63;
      v65 = 0x2000000000;
      v66 = -1;
      v59 = 0;
      v60 = &v59;
      v61 = 0x2000000000;
      v62 = -1;
      *(_QWORD *)v143 = v9;
      *(_QWORD *)&v143[8] = 0x40000000;
      *(_QWORD *)&v144 = ___ZN23EurekaCallCommandDriver28handleVoiceInfoRecIndicationEN3qmi16SubscriptionTypeERKN2vs12VoiceInfoRec10IndicationE_block_invoke_52;
      *((_QWORD *)&v144 + 1) = &unk_24D5E2D68;
      v145 = &v59;
      v146 = &v63;
      v45 = qmi::MessageBase::findTlvValue((qmi::MessageBase *)v58);
      v47 = v45;
      if (v45)
      {
        v48 = v46;
        *(_QWORD *)v141 = v45;
        v49 = tlv::parseV<vs::tlv::SignalInfo>((_BYTE **)v141, v46);
        v139 = v49;
        v140 = BYTE2(v49);
        if (*(_QWORD *)v141)
        {
          ((void (*)(uint8_t *, __int16 *))v144)(v143, &v139);
LABEL_81:
          if (!*((_BYTE *)v60 + 24) && *((_BYTE *)v64 + 24) == 6)
          {
            v51 = *v8;
            if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)v141 = 0;
              _os_log_impl(&dword_216897000, v51, OS_LOG_TYPE_DEFAULT, "#I Carrier provided busy signal info. Playing that busy tone", v141, 2u);
              v52 = *((unsigned __int8 *)v64 + 24);
              v53 = 0;
              switch(*((_BYTE *)v64 + 24))
              {
                case 0:
                case 1:
                case 2:
                  break;
                case 4:
                  v53 = 0;
                  v52 = 3;
                  break;
                case 6:
                  goto LABEL_86;
                case 7:
                  v53 = 0;
                  v52 = 5;
                  break;
                case 8:
                  v53 = 0;
                  v52 = 6;
                  break;
                case 9:
                  v53 = 0;
                  v52 = 7;
                  break;
                default:
                  v57 = *(NSObject **)(v6 + 40);
                  if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)v141 = 67109120;
                    *(_DWORD *)&v141[4] = v52;
                    _os_log_impl(&dword_216897000, v57, OS_LOG_TYPE_DEFAULT, "#I QMI does not support tone id sent by network, %d", v141, 8u);
                  }
                  v52 = 10;
                  v53 = 1;
                  break;
              }
            }
            else
            {
LABEL_86:
              v53 = 0;
              v52 = 4;
            }
            *(_QWORD *)v141 = 0;
            v142 = 0;
            (*(void (**)(uint8_t *__return_ptr))(**(_QWORD **)(v6 + 120) + 288))(v141);
            if ((v53 & 1) == 0)
            {
              if (*(_QWORD *)v141)
                (*(void (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)v141 + 40))(*(_QWORD *)v141, v52, 0);
              *(_BYTE *)(v6 + 184) = 1;
            }
            v54 = v142;
            if (v142)
            {
              p_shared_owners = (unint64_t *)&v142->__shared_owners_;
              do
                v56 = __ldaxr(p_shared_owners);
              while (__stlxr(v56 - 1, p_shared_owners));
              if (!v56)
              {
                ((void (*)(std::__shared_weak_count *))v54->__on_zero_shared)(v54);
                std::__shared_weak_count::__release_weak(v54);
              }
            }
          }
          goto LABEL_96;
        }
        if (((unsigned int (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(v58[0], 16, v47, v48))
        {
          goto LABEL_81;
        }
      }
LABEL_96:
      _Block_object_dispose(&v59, 8);
      _Block_object_dispose(&v63, 8);
LABEL_97:
      _Block_object_dispose(&v71, 8);
      _Block_object_dispose(&v88, 8);
      _Block_object_dispose(v92, 8);
      if (SHIBYTE(v98) < 0)
        operator delete(v97[0]);
      _Block_object_dispose(buf, 8);
      if (SHIBYTE(v105) < 0)
        operator delete(v104[0]);
      goto LABEL_101;
    }
    v19 = v17;
    v79[0] = v16;
    *(_OWORD *)v143 = 0u;
    v144 = 0u;
    tlv::parseV<vs::tlv::CallerIdInfo>(v79, v17, v143);
    v20 = v79[0];
    if (v79[0])
      v84((uint64_t)v83, (uint64_t)v143);
    if (SHIBYTE(v144) < 0)
    {
      operator delete(*(void **)&v143[8]);
      if (v20)
        goto LABEL_32;
    }
    else if (v20)
    {
LABEL_32:
      LOBYTE(v18) = 1;
      goto LABEL_35;
    }
    LOBYTE(v18) = ((uint64_t (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(v58[0], 17, v18, v19);
    goto LABEL_35;
  }
  v14 = *v8;
  if (os_log_type_enabled(*v8, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl(&dword_216897000, v14, OS_LOG_TYPE_ERROR, "Invalid Voice Info Record indication. Mandatory TLV, CallId, not present", buf, 2u);
  }
LABEL_101:
  _Block_object_dispose(&v111, 8);
  CallInfo::~CallInfo(__p);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v58);
}

void sub_216A475F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45,uint64_t a46,uint64_t a47,uint64_t a48,char a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,void *__p,uint64_t a55,int a56,__int16 a57,char a58,char a59,char a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  void *a65;
  char a70;
  uint64_t v70;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v70 - 192);
  _Block_object_dispose(&a12, 8);
  _Block_object_dispose(&a16, 8);
  _Block_object_dispose(&a25, 8);
  _Block_object_dispose(&a45, 8);
  _Block_object_dispose(&a49, 8);
  if (a59 < 0)
    operator delete(__p);
  _Block_object_dispose(&a60, 8);
  if (a70 < 0)
    operator delete(a65);
  _Block_object_dispose(&STACK[0x210], 8);
  CallInfo::~CallInfo((void **)&STACK[0x230]);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_6>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_6 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_6 &&,QMIServiceMsg const)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_6>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_6 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_6 &&,QMIServiceMsg const)>::target_type()
{
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_7>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_7 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_7 &&,QMIServiceMsg const)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_7>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_7 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_7 &&,QMIServiceMsg const)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5E38B0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_7>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_7 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_7 &&,QMIServiceMsg const)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5E38B0;
  a2[1] = v2;
  return result;
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_7>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_7 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_7 &&,QMIServiceMsg const)>::operator()(uint64_t a1, unsigned int *a2, QMIServiceMsg *this)
{
  uint64_t v4;
  uint64_t v6;
  unsigned __int8 *TlvValue;
  int v8;
  unsigned __int8 *v9;
  int v10;
  unsigned __int8 *v11;
  uint64_t v12;
  unint64_t *v13;
  unint64_t *v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  _WORD v19[12];
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  char v23;
  uint64_t v24;
  uint64_t *v25;
  uint64_t v26;
  char v27;
  void *__p[2];
  __int128 v29;
  unsigned __int8 *v30;

  v4 = *a2;
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p[0] = 0;
    __p[1] = 0;
    *(_QWORD *)&v29 = 0;
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v19, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v19);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v19);
  }
  v6 = *(_QWORD *)(a1 + 8);
  v24 = 0;
  v25 = &v24;
  v26 = 0x2000000000;
  v27 = *MEMORY[0x24BDC39A8];
  v20 = 0;
  v21 = &v20;
  v22 = 0x2000000000;
  v23 = -1;
  TlvValue = (unsigned __int8 *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)v19);
  v9 = TlvValue;
  if (TlvValue)
  {
    v10 = v8;
    v30 = TlvValue;
    *(_OWORD *)__p = 0u;
    v29 = 0u;
    tlv::parseV<vs::tlv::OtaspStatus>(&v30, v8, __p);
    v11 = v30;
    if (v30)
    {
      *((_BYTE *)v25 + 24) = __p[0];
      *((_BYTE *)v21 + 24) = BYTE1(__p[0]);
    }
    if (__p[1])
    {
      *(void **)&v29 = __p[1];
      operator delete(__p[1]);
    }
    if (!v11)
      ((void (*)(_QWORD, uint64_t, unsigned __int8 *, _QWORD))*MEMORY[0x24BED8BD0])(v19[0], 1, v9, v10);
  }
  v12 = *(_QWORD *)(v6 + 216);
  v13 = *(unint64_t **)(v6 + 144);
  __p[0] = *(void **)(v6 + 136);
  __p[1] = v13;
  if (v13)
  {
    v14 = v13 + 1;
    do
      v15 = __ldxr(v14);
    while (__stxr(v15 + 1, v14));
  }
  (*(void (**)(uint64_t, uint64_t, void **, _QWORD, _QWORD))(*(_QWORD *)v12 + 72))(v12, v4, __p, *((unsigned __int8 *)v25 + 24), *((unsigned __int8 *)v21 + 24));
  v16 = (std::__shared_weak_count *)__p[1];
  if (__p[1])
  {
    v17 = (unint64_t *)((char *)__p[1] + 8);
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
  _Block_object_dispose(&v20, 8);
  _Block_object_dispose(&v24, 8);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v19);
}

void sub_216A47A28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a10);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_7>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_7 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_7 &&,QMIServiceMsg const)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_7>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_7 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_7 &&,QMIServiceMsg const)>::target_type()
{
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_8>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_8 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_8 &&,QMIServiceMsg const)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_8>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_8 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_8 &&,QMIServiceMsg const)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5E3930;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_8>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_8 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_8 &&,QMIServiceMsg const)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5E3930;
  a2[1] = v2;
  return result;
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_8>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_8 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_8 &&,QMIServiceMsg const)>::operator()(uint64_t a1, int *a2, QMIServiceMsg *this)
{
  int v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD v17[3];
  void *__p;
  uint64_t v19;
  void (*v20)(uint64_t);
  void *v21;
  uint64_t v22;
  _QWORD v23[3];
  int v24;

  v4 = *a2;
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v19 = 0;
    v20 = 0;
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)&v14, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)&v14);
    if (__p)
    {
      v19 = (uint64_t)__p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)&v14);
  }
  v6 = *(_QWORD *)(a1 + 8);
  v7 = v14;
  v8 = v15;
  v17[0] = v14;
  v17[1] = v15;
  v9 = v16;
  v17[2] = v16;
  if (v16)
  {
    v10 = (unint64_t *)(v16 + 8);
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }
  __p = (void *)MEMORY[0x24BDAC760];
  v19 = 1174405120;
  v20 = ___ZN23EurekaCallCommandDriver29handleVoiceHandoverIndicationEN3qmi16SubscriptionTypeEN2vs13VoiceHandover10IndicationE_block_invoke;
  v21 = &__block_descriptor_tmp_55_8;
  v24 = v4;
  v22 = v6;
  v23[0] = v7;
  v23[1] = v8;
  v23[2] = v9;
  if (v9)
  {
    v12 = (unint64_t *)(v9 + 8);
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }
  ctu::SharedSynchronizable<CallCommandDriver>::execute_wrapped((uint64_t *)(v6 + 8), (uint64_t)&__p);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v23);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v17);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&v14);
}

void sub_216A47CCC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a10);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_8>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_8 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_8 &&,QMIServiceMsg const)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_8>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_8 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_8 &&,QMIServiceMsg const)>::target_type()
{
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_9>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_9 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_9 &&,QMIServiceMsg const)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_9>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_9 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_9 &&,QMIServiceMsg const)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5E39B0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_9>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_9 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_9 &&,QMIServiceMsg const)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5E39B0;
  a2[1] = v2;
  return result;
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_9>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_9 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_9 &&,QMIServiceMsg const)>::operator()(uint64_t a1, int *a2, QMIServiceMsg *this)
{
  int v4;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  NSObject **v11;
  uint64_t v12;
  void *TlvValue;
  int v14;
  void *v15;
  int v16;
  int v17;
  uint64_t v18;
  NSObject *v19;
  std::string *v20;
  const char *v21;
  _QWORD v22[2];
  uint64_t v23;
  _QWORD v24[3];
  _QWORD v25[6];
  std::string v26;
  __n128 (*v27)(uint64_t, uint64_t);
  void (*v28)(uint64_t);
  void *v29;
  uint64_t v30;
  uint64_t v31;
  std::string v32;
  _QWORD v33[6];
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  int v37;
  void *__p;
  void *p_p;
  uint64_t v40;
  __n128 (*v41)(uint64_t, uint64_t);
  void (*v42)(uint64_t);
  void *v43;
  uint64_t v44;
  uint64_t v45;
  _QWORD v46[2];
  uint64_t (*v47)(uint64_t, std::string *);
  void *v48;
  uint64_t *v49;
  uint64_t v50;
  uint64_t *v51;
  uint64_t v52;
  char v53;
  _BYTE buf[12];
  __int16 v55;
  const char *v56;
  uint64_t v57;

  v57 = *MEMORY[0x24BDAC8D0];
  v4 = *a2;
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    p_p = 0;
    v40 = 0;
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v22, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v22);
    if (__p)
    {
      p_p = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v22);
  }
  v6 = *(_QWORD *)(a1 + 8);
  v24[0] = v22[0];
  v24[1] = v22[1];
  v24[2] = v23;
  if (v23)
  {
    v7 = (unint64_t *)(v23 + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  switch(v4)
  {
    case 3:
      v9 = 3;
      v10 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v6 + 112) + 16))(*(_QWORD *)(v6 + 112), 3);
      goto LABEL_17;
    case 2:
      v9 = 2;
      v10 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v6 + 112) + 16))(*(_QWORD *)(v6 + 112), 2);
      goto LABEL_17;
    case 1:
      v9 = 1;
      v10 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v6 + 112) + 16))(*(_QWORD *)(v6 + 112), 1);
LABEL_17:
      v11 = (NSObject **)v10;
      goto LABEL_19;
  }
  v11 = (NSObject **)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(v6 + 112) + 16))(*(_QWORD *)(v6 + 112), 0);
  v9 = 0;
LABEL_19:
  v50 = 0;
  v51 = &v50;
  v52 = 0x2000000000;
  v12 = MEMORY[0x24BDAC760];
  v53 = 0;
  v46[0] = MEMORY[0x24BDAC760];
  v46[1] = 0x40000000;
  v47 = (uint64_t (*)(uint64_t, std::string *))___ZN23EurekaCallCommandDriver25handleVoiceUSSDIndicationEN3qmi16SubscriptionTypeEN2vs9VoiceUSSD10IndicationE_block_invoke;
  v48 = &unk_24D5E2A68;
  v49 = &v50;
  TlvValue = (void *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)v24);
  v15 = TlvValue;
  if (TlvValue)
  {
    v16 = v14;
    __p = TlvValue;
    LODWORD(v26.__r_.__value_.__l.__data_) = tlv::parseV<vs::tlv::NotificationType>((unint64_t *)&__p, v14);
    if (__p)
      v47((uint64_t)v46, &v26);
    else
      ((void (*)(_QWORD, uint64_t, void *, _QWORD))*MEMORY[0x24BED8BD0])(LOWORD(v24[0]), 1, v15, v16);
  }
  __p = 0;
  p_p = &__p;
  v40 = 0x4002000000;
  v41 = __Block_byref_object_copy__8;
  v42 = __Block_byref_object_dispose__8;
  v44 = 0;
  v45 = 0;
  v43 = 0;
  v34 = 0;
  v35 = &v34;
  v36 = 0x2000000000;
  v37 = 0;
  v33[0] = v12;
  v33[1] = 0x40000000;
  v33[2] = ___ZN23EurekaCallCommandDriver25handleVoiceUSSDIndicationEN3qmi16SubscriptionTypeEN2vs9VoiceUSSD10IndicationE_block_invoke_4;
  v33[3] = &unk_24D5E2A90;
  v33[4] = &v34;
  v33[5] = &__p;
  v26.__r_.__value_.__r.__words[0] = (std::string::size_type)v33;
  v17 = qmi::MessageBase::applyTlv<vs::tlv::USSInfo,void({block_pointer})(vs::tlv::USSInfo const&)>((qmi::MessageBase *)v24, 16, (uint64_t)&v26);
  memset(&v32, 0, sizeof(v32));
  if (v17)
  {
    v32 = v26;
  }
  v26.__r_.__value_.__r.__words[0] = 0;
  v26.__r_.__value_.__l.__size_ = (std::string::size_type)&v26;
  v26.__r_.__value_.__r.__words[2] = 0x4002000000;
  v27 = __Block_byref_object_copy__8;
  v28 = __Block_byref_object_dispose__8;
  v30 = 0;
  v31 = 0;
  v29 = 0;
  v25[0] = v12;
  v25[1] = 0x40000000;
  v25[2] = ___ZN23EurekaCallCommandDriver25handleVoiceUSSDIndicationEN3qmi16SubscriptionTypeEN2vs9VoiceUSSD10IndicationE_block_invoke_2;
  v25[3] = &unk_24D5E2AB8;
  v25[4] = &v26;
  v25[5] = v11;
  *(_QWORD *)buf = v25;
  if (qmi::MessageBase::applyTlv<vs::tlv::UTF16Data,void({block_pointer})(vs::tlv::UTF16Data const&)>((qmi::MessageBase *)v24, 17, (uint64_t)buf))
  {
    std::string::operator=(&v32, (const std::string *)(v26.__r_.__value_.__l.__size_ + 40));
    v18 = 1;
  }
  else
  {
    v18 = 0;
  }
  v19 = *v11;
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    v20 = &v32;
    if ((v32.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      v20 = (std::string *)v32.__r_.__value_.__r.__words[0];
    if (*((_BYTE *)v51 + 24))
      v21 = "needed";
    else
      v21 = "not needed";
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = v20;
    v55 = 2080;
    v56 = v21;
    _os_log_impl(&dword_216897000, v19, OS_LOG_TYPE_DEFAULT, "#I Received Voice USSD Indication with \"%s\" and user response %s", buf, 0x16u);
  }
  (*(void (**)(_QWORD, _QWORD, std::string *, uint64_t, uint64_t, uint64_t))(**(_QWORD **)(v6 + 120) + 144))(*(_QWORD *)(v6 + 120), *((unsigned __int8 *)v51 + 24), &v32, v18, 1, v9);
  _Block_object_dispose(&v26, 8);
  if (SHIBYTE(v31) < 0)
    operator delete(v29);
  if (SHIBYTE(v32.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v32.__r_.__value_.__l.__data_);
  _Block_object_dispose(&v34, 8);
  _Block_object_dispose(&__p, 8);
  if (SHIBYTE(v45) < 0)
    operator delete(v43);
  _Block_object_dispose(&v50, 8);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v24);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v22);
}

void sub_216A48258(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,char a44,uint64_t a45,uint64_t a46,uint64_t a47,void *a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,void *__p,uint64_t a54,int a55,__int16 a56,char a57,char a58)
{
  uint64_t v58;

  _Block_object_dispose(&a44, 8);
  _Block_object_dispose(&a48, 8);
  if (a58 < 0)
    operator delete(__p);
  _Block_object_dispose((const void *)(v58 - 160), 8);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a12);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_9>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_9 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_9 &&,QMIServiceMsg const)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_9>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_9 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_9 &&,QMIServiceMsg const)>::target_type()
{
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_10>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_10 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_10 &&,QMIServiceMsg const)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_10>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_10 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_10 &&,QMIServiceMsg const)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5E3A30;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_10>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_10 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_10 &&,QMIServiceMsg const)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5E3A30;
  a2[1] = v2;
  return result;
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_10>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_10 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_10 &&,QMIServiceMsg const)>::operator()(uint64_t a1, unsigned int *a2, QMIServiceMsg *this)
{
  unsigned int v4;
  uint64_t v6;
  NSObject *v7;
  _BYTE v8[24];
  void *__p;
  void *v10;
  uint64_t v11;

  v4 = *a2;
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v10 = 0;
    v11 = 0;
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v8, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v8);
    if (__p)
    {
      v10 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v8);
  }
  if (v4 - 1 >= 3)
    v6 = 0;
  else
    v6 = v4;
  v7 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(*(_QWORD *)(a1 + 8) + 112) + 16))(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 112), v6);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p) = 0;
    _os_log_impl(&dword_216897000, v7, OS_LOG_TYPE_DEFAULT, "#N Received a USSD release indication that BB is terminating the USSD Session", (uint8_t *)&__p, 2u);
  }
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v8);
}

void sub_216A484F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a10);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_10>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_10 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_10 &&,QMIServiceMsg const)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_10>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_10 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_10 &&,QMIServiceMsg const)>::target_type()
{
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_11>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_11 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_11 &&,QMIServiceMsg const)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_11>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_11 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_11 &&,QMIServiceMsg const)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5E3AB0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_11>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_11 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_11 &&,QMIServiceMsg const)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5E3AB0;
  a2[1] = v2;
  return result;
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_11>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_11 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_11 &&,QMIServiceMsg const)>::operator()(uint64_t a1, int *a2, QMIServiceMsg *this)
{
  int v4;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  os_log_t *v11;
  uint64_t v12;
  uint64_t TlvValue;
  int v14;
  uint64_t v15;
  int v16;
  int v17;
  NSObject *v18;
  uint64_t *v19;
  uint64_t v20;
  NSObject *v21;
  std::string *p_p;
  _QWORD v23[2];
  uint64_t v24;
  _QWORD v25[3];
  _QWORD v26[6];
  std::string v27;
  __n128 (*v28)(uint64_t, uint64_t);
  void (*v29)(uint64_t);
  void *v30;
  uint64_t v31;
  uint64_t v32;
  _QWORD v33[6];
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  int v37;
  std::string __p;
  _QWORD v39[2];
  uint64_t (*v40)(uint64_t, std::string *);
  void *v41;
  uint64_t *v42;
  uint64_t v43;
  uint64_t *v44;
  uint64_t v45;
  __int16 v46;
  uint64_t v47;
  uint64_t *v48;
  uint64_t v49;
  char v50;
  uint8_t buf[16];
  uint8_t v52[8];
  uint64_t v53;
  uint64_t v54;
  __n128 (*v55)(uint64_t, uint64_t);
  void (*v56)(uint64_t);
  os_log_t *v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;

  v60 = *MEMORY[0x24BDAC8D0];
  v4 = *a2;
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    *(_QWORD *)v52 = 0;
    v53 = 0;
    v54 = 0;
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v23, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v23);
    if (*(_QWORD *)v52)
    {
      v53 = *(_QWORD *)v52;
      operator delete(*(void **)v52);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v23);
  }
  v6 = *(_QWORD *)(a1 + 8);
  v25[0] = v23[0];
  v25[1] = v23[1];
  v25[2] = v24;
  if (v24)
  {
    v7 = (unint64_t *)(v24 + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  switch(v4)
  {
    case 3:
      v9 = 3;
      v10 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v6 + 112) + 16))(*(_QWORD *)(v6 + 112), 3);
      goto LABEL_17;
    case 2:
      v9 = 2;
      v10 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v6 + 112) + 16))(*(_QWORD *)(v6 + 112), 2);
      goto LABEL_17;
    case 1:
      v9 = 1;
      v10 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v6 + 112) + 16))(*(_QWORD *)(v6 + 112), 1);
LABEL_17:
      v11 = (os_log_t *)v10;
      goto LABEL_19;
  }
  v11 = (os_log_t *)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(v6 + 112) + 16))(*(_QWORD *)(v6 + 112), 0);
  v9 = 0;
LABEL_19:
  v47 = 0;
  v48 = &v47;
  v49 = 0x2000000000;
  v50 = 0;
  v43 = 0;
  v44 = &v43;
  v45 = 0x2000000000;
  v12 = MEMORY[0x24BDAC760];
  v46 = 0;
  v39[0] = MEMORY[0x24BDAC760];
  v39[1] = 0x40000000;
  v40 = (uint64_t (*)(uint64_t, std::string *))___ZN23EurekaCallCommandDriver35handleOriginateUSSDNoWaitIndicationEN3qmi16SubscriptionTypeEN2vs19OriginateUSSDNoWait10IndicationE_block_invoke;
  v41 = &unk_24D5E2AE0;
  v42 = &v43;
  TlvValue = qmi::MessageBase::findTlvValue((qmi::MessageBase *)v25);
  v15 = TlvValue;
  if (TlvValue)
  {
    v16 = v14;
    *(_QWORD *)v52 = TlvValue;
    LOWORD(v27.__r_.__value_.__l.__data_) = tlv::parseV<vs::tlv::Error>((unint64_t *)v52, v14);
    if (*(_QWORD *)v52)
      v40((uint64_t)v39, &v27);
    else
      ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(LOWORD(v25[0]), 16, v15, v16);
  }
  memset(&__p, 0, sizeof(__p));
  std::string::basic_string[abi:ne180100]<0>(&__p, (char *)&unk_216AC4FCA);
  v17 = *((unsigned __int16 *)v44 + 12);
  if (*((_WORD *)v44 + 12))
  {
    v18 = *v11;
    if (os_log_type_enabled(*v11, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v52 = 67109120;
      *(_DWORD *)&v52[4] = v17;
      _os_log_error_impl(&dword_216897000, v18, OS_LOG_TYPE_ERROR, "Send USSD failed with error code: %d", v52, 8u);
    }
    *(_QWORD *)v52 = v12;
    v53 = 0x40000000;
    v54 = (uint64_t)___ZN23EurekaCallCommandDriver35handleOriginateUSSDNoWaitIndicationEN3qmi16SubscriptionTypeEN2vs19OriginateUSSDNoWait10IndicationE_block_invoke_15;
    v55 = (__n128 (*)(uint64_t, uint64_t))&unk_24D5E2B58;
    v56 = (void (*)(uint64_t))&v47;
    v57 = v11;
    v27.__r_.__value_.__r.__words[0] = (std::string::size_type)v52;
    qmi::MessageBase::applyTlv<vs::tlv::FailureCause,void({block_pointer})(vs::tlv::FailureCause const&)>((qmi::MessageBase *)v25, 17, (uint64_t)&v27);
    v19 = v48;
    v20 = 0;
    if (*((_WORD *)v44 + 12) == 4)
      *((_BYTE *)v48 + 24) = 1;
  }
  else
  {
    *(_QWORD *)v52 = 0;
    v53 = (uint64_t)v52;
    v54 = 0x4002000000;
    v55 = __Block_byref_object_copy__8;
    v56 = __Block_byref_object_dispose__8;
    v58 = 0;
    v59 = 0;
    v57 = 0;
    v34 = 0;
    v35 = &v34;
    v36 = 0x2000000000;
    v37 = 0;
    v33[0] = v12;
    v33[1] = 0x40000000;
    v33[2] = ___ZN23EurekaCallCommandDriver35handleOriginateUSSDNoWaitIndicationEN3qmi16SubscriptionTypeEN2vs19OriginateUSSDNoWait10IndicationE_block_invoke_2;
    v33[3] = &unk_24D5E2B08;
    v33[4] = &v34;
    v33[5] = v52;
    v27.__r_.__value_.__r.__words[0] = (std::string::size_type)v33;
    if (qmi::MessageBase::applyTlv<vs::tlv::USSInfo,void({block_pointer})(vs::tlv::USSInfo const&)>((qmi::MessageBase *)v25, 18, (uint64_t)&v27))
    {
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      __p = v27;
    }
    v27.__r_.__value_.__r.__words[0] = 0;
    v27.__r_.__value_.__l.__size_ = (std::string::size_type)&v27;
    v27.__r_.__value_.__r.__words[2] = 0x4002000000;
    v28 = __Block_byref_object_copy__8;
    v29 = __Block_byref_object_dispose__8;
    v31 = 0;
    v32 = 0;
    v30 = 0;
    v26[0] = v12;
    v26[1] = 0x40000000;
    v26[2] = ___ZN23EurekaCallCommandDriver35handleOriginateUSSDNoWaitIndicationEN3qmi16SubscriptionTypeEN2vs19OriginateUSSDNoWait10IndicationE_block_invoke_3;
    v26[3] = &unk_24D5E2B30;
    v26[4] = &v27;
    v26[5] = v11;
    *(_QWORD *)buf = v26;
    if (qmi::MessageBase::applyTlv<vs::tlv::UTF16Data,void({block_pointer})(vs::tlv::UTF16Data const&)>((qmi::MessageBase *)v25, 20, (uint64_t)buf))
    {
      std::string::operator=(&__p, (const std::string *)(v27.__r_.__value_.__l.__size_ + 40));
      v20 = 1;
    }
    else
    {
      v20 = 0;
    }
    *((_BYTE *)v48 + 24) = 1;
    v21 = *v11;
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      p_p = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = p_p;
      _os_log_impl(&dword_216897000, v21, OS_LOG_TYPE_DEFAULT, "#I BB returned success for USSD Send Message with reply \"%s\"", buf, 0xCu);
    }
    _Block_object_dispose(&v27, 8);
    if (SHIBYTE(v32) < 0)
      operator delete(v30);
    _Block_object_dispose(&v34, 8);
    _Block_object_dispose(v52, 8);
    if (SHIBYTE(v59) < 0)
      operator delete(v57);
    v19 = v48;
  }
  (*(void (**)(_QWORD, _QWORD, std::string *, uint64_t, _QWORD, uint64_t))(**(_QWORD **)(v6 + 120) + 144))(*(_QWORD *)(v6 + 120), 0, &__p, v20, *((unsigned __int8 *)v19 + 24), v9);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  _Block_object_dispose(&v43, 8);
  _Block_object_dispose(&v47, 8);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v25);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v23);
}

void sub_216A48B58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,char a38,uint64_t a39,uint64_t a40,uint64_t a41,void *a42,uint64_t a43,int a44,__int16 a45,char a46,char a47)
{
  uint64_t v47;

  _Block_object_dispose(&a21, 8);
  if (a31 < 0)
    operator delete(__p);
  _Block_object_dispose(&a38, 8);
  _Block_object_dispose((const void *)(v47 - 176), 8);
  if (*(char *)(v47 - 113) < 0)
    operator delete(*(void **)(v47 - 136));
  if (a47 < 0)
    operator delete(a42);
  _Block_object_dispose((const void *)(v47 - 256), 8);
  _Block_object_dispose((const void *)(v47 - 224), 8);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a12);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_11>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_11 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_11 &&,QMIServiceMsg const)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_11>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_11 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_11 &&,QMIServiceMsg const)>::target_type()
{
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_12>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_12 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_12 &&,QMIServiceMsg const)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_12>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_12 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_12 &&,QMIServiceMsg const)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5E3B30;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_12>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_12 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_12 &&,QMIServiceMsg const)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5E3B30;
  a2[1] = v2;
  return result;
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_12>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_12 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_12 &&,QMIServiceMsg const)>::operator()(uint64_t a1, unsigned int *a2, QMIServiceMsg *this)
{
  unsigned int v4;
  uint64_t v6;
  uint64_t v7;
  capabilities::ct *v8;
  void *TlvValue;
  int v10;
  void *v11;
  int v12;
  unsigned __int8 v13;
  NSObject *v14;
  const char *v15;
  uint64_t v16;
  NSObject *v17;
  _WORD v18[12];
  void *__p[2];
  __int128 v20;
  _QWORD v21[3];
  int v22;
  char v23;
  int v24;
  char v25;
  uint64_t v26;
  uint64_t v27;
  char v28;
  int v29;
  uint64_t v30;
  _QWORD v31[2];
  char v32;
  char v33;
  _QWORD v34[3];
  int v35;
  _QWORD v36[3];
  int v37;
  __int16 v38;
  int v39;
  __int16 v40;
  int v41;
  char v42;
  char v43;
  char v44;
  char v45;
  __int16 v46;
  int v47;
  char v48;
  int v49;
  char v50;
  __int128 v51;
  __int128 v52;
  _BYTE v53[29];
  int v54;
  char v55;
  char v56;
  char v57;
  uint64_t v58;

  v58 = *MEMORY[0x24BDAC8D0];
  v4 = *a2;
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p[0] = 0;
    __p[1] = 0;
    *(_QWORD *)&v20 = 0;
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v18, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v18);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v18);
  }
  v6 = *(_QWORD *)(a1 + 8);
  if (v4 - 1 >= 3)
    v7 = 0;
  else
    v7 = v4;
  v8 = (capabilities::ct *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v6 + 112) + 16))(*(_QWORD *)(v6 + 112), v7);
  if ((capabilities::ct::supports5G(v8) & 1) != 0)
  {
    TlvValue = (void *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)v18);
    v11 = TlvValue;
    if (TlvValue)
    {
      v12 = v10;
      __p[0] = TlvValue;
      v13 = tlv::parseV<nas::tlv::SysMode>((unint64_t *)__p, v10);
      if (__p[0])
      {
LABEL_16:
        v14 = *(NSObject **)v8;
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          v15 = nas::asString(v13);
          LODWORD(__p[0]) = 136315394;
          *(void **)((char *)__p + 4) = (void *)v15;
          WORD2(__p[1]) = 256;
          BYTE6(__p[1]) = v13;
          _os_log_impl(&dword_216897000, v14, OS_LOG_TYPE_DEFAULT, "#I BB notified call ready with sys mode: %s(%hhu)", (uint8_t *)__p, 0xFu);
        }
        v16 = *(_QWORD *)(v6 + 120);
        *(_OWORD *)__p = 0u;
        v20 = 0u;
        std::string::basic_string[abi:ne180100]<0>(v21, (char *)*MEMORY[0x24BDC3E80]);
        v22 = 9;
        v23 = 0;
        v24 = 1;
        v25 = 1;
        v26 = 0x400000001;
        v27 = 2;
        v28 = 0;
        v29 = *MEMORY[0x24BDC39A8];
        v32 = 0;
        v33 = 0;
        v30 = 0;
        v31[0] = 0;
        *(_QWORD *)((char *)v31 + 6) = 0;
        std::string::basic_string[abi:ne180100]<0>(v34, (char *)&unk_216AC4FCA);
        v35 = 0;
        std::string::basic_string[abi:ne180100]<0>(v36, (char *)&unk_216AC4FCA);
        v37 = 0;
        v38 = 0;
        v39 = 0;
        v40 = 0;
        v41 = 0;
        v42 = 0;
        v43 = 0;
        v44 = 0;
        v45 = 0;
        v46 = 0;
        v47 = v7;
        v48 = 0;
        v49 = 0;
        v50 = 0;
        v51 = 0u;
        v52 = 0u;
        memset(v53, 0, sizeof(v53));
        v54 = 1;
        v55 = 0;
        v56 = 0;
        v57 = 0;
        (*(void (**)(uint64_t, void **, BOOL))(*(_QWORD *)v16 + 368))(v16, __p, v13 == 8);
        CallInfo::~CallInfo(__p);
        goto LABEL_21;
      }
      ((void (*)(_QWORD, uint64_t, void *, _QWORD))*MEMORY[0x24BED8BD0])(v18[0], 1, v11, v12);
    }
    v13 = 8;
    goto LABEL_16;
  }
  v17 = *(NSObject **)v8;
  if (os_log_type_enabled(*(os_log_t *)v8, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p[0]) = 0;
    _os_log_impl(&dword_216897000, v17, OS_LOG_TYPE_DEFAULT, "#I Dropping the call ready indication!", (uint8_t *)__p, 2u);
  }
LABEL_21:
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v18);
}

void sub_216A49038(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void *a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *__p,uint64_t a36,int a37,__int16 a38,char a39,char a40)
{
  CallInfo::~CallInfo(&a13);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a10);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_12>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_12 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_12 &&,QMIServiceMsg const)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<EurekaCallCommandDriver::registerForQMIIndications(void)::$_12>(unsigned short,EurekaCallCommandDriver::registerForQMIIndications(void)::$_12 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(EurekaCallCommandDriver::registerForQMIIndications(void)::$_12 &&,QMIServiceMsg const)>::target_type()
{
}

uint64_t qmi::MutableMessageBase::TlvWrapper<vs::tlv::CallConfigList>::~TlvWrapper(uint64_t a1)
{
  void **v3;

  *(_QWORD *)a1 = off_24D5E3BC8;
  v3 = (void **)(a1 + 16);
  std::vector<vs::tlv::CallConfigItem>::__destroy_vector::operator()[abi:ne180100](&v3);
  return a1;
}

{
  void **v3;

  *(_QWORD *)a1 = off_24D5E3BC8;
  v3 = (void **)(a1 + 16);
  std::vector<vs::tlv::CallConfigItem>::__destroy_vector::operator()[abi:ne180100](&v3);
  return MEMORY[0x2199FEAC4](a1, 0x10A1C403082B835);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<vs::tlv::CallConfigList>::getSize(uint64_t a1)
{
  return tlv::size<vs::tlv::CallConfigList>((uint64_t *)(a1 + 16));
}

_BYTE *qmi::MutableMessageBase::TlvWrapper<vs::tlv::CallConfigList>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE *result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<vs::tlv::CallConfigList>((_BYTE **)a2, (_DWORD *)(a1 + 16));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<vs::tlv::CallConfigList>::clone(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  char *v6;
  uint64_t v7;
  __int128 *v8;
  char *v9;
  __int128 v10;
  std::string *v11;
  __int128 v12;
  uint64_t v13;
  _QWORD v15[3];
  uint64_t v16;
  char *v17;
  char *v18;

  v2 = operator new();
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)v2 = off_24D5E3BC8;
  *(_QWORD *)(v2 + 16) = 0;
  *(_QWORD *)(v2 + 24) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  v4 = *(_QWORD *)(a1 + 16);
  v3 = *(_QWORD *)(a1 + 24);
  if (v3 != v4)
  {
    v5 = 0xAAAAAAAAAAAAAAABLL * ((v3 - v4) >> 4);
    if (v5 >= 0x555555555555556)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::AppInfo>>(v2 + 32, v5);
    *(_QWORD *)(v2 + 16) = v6;
    *(_QWORD *)(v2 + 24) = v6;
    *(_QWORD *)(v2 + 32) = &v6[48 * v7];
    v17 = v6;
    v18 = v6;
    v15[0] = v2 + 32;
    v15[1] = &v17;
    v15[2] = &v18;
    v16 = 0;
    v8 = (__int128 *)(v4 + 24);
    v9 = v6;
    do
    {
      v10 = *(__int128 *)((char *)v8 - 24);
      *((_DWORD *)v9 + 4) = *((_DWORD *)v8 - 2);
      *(_OWORD *)v9 = v10;
      v11 = (std::string *)(v9 + 24);
      if (*((char *)v8 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(v11, *(const std::string::value_type **)v8, *((_QWORD *)v8 + 1));
        v9 = v18;
      }
      else
      {
        v12 = *v8;
        *((_QWORD *)v9 + 5) = *((_QWORD *)v8 + 2);
        *(_OWORD *)&v11->__r_.__value_.__l.__data_ = v12;
      }
      v13 = (uint64_t)v8 - 24;
      v9 += 48;
      v18 = v9;
      v8 += 3;
    }
    while (v13 + 48 != v3);
    LOBYTE(v16) = 1;
    std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<vs::tlv::CallConfigItem>,vs::tlv::CallConfigItem*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v15);
    *(_QWORD *)(v2 + 24) = v9;
  }
  return v2;
}

void sub_216A4937C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  uint64_t v9;

  std::vector<vs::tlv::CallConfigItem>::__destroy_vector::operator()[abi:ne180100](&a9);
  MEMORY[0x2199FEAC4](v9, 0x10A1C403082B835);
  _Unwind_Resume(a1);
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<vs::tlv::CallConfigItem>,vs::tlv::CallConfigItem*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  uint64_t v3;
  uint64_t i;

  if (!*(_BYTE *)(a1 + 24))
  {
    v3 = **(_QWORD **)(a1 + 8);
    for (i = **(_QWORD **)(a1 + 16); i != v3; i -= 48)
    {
      if (*(char *)(i - 1) < 0)
        operator delete(*(void **)(i - 24));
    }
  }
  return a1;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN23EurekaCallCommandDriver19sendSRVCCCallConfigEN10subscriber7SimSlotEE3__1EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  int v2;
  NSObject *v3;
  _DWORD v4[2];
  __int16 v5;
  uint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v2 = *(_DWORD *)(a2 + 4);
  v3 = ***(NSObject ****)(a1 + 32);
  if (v2)
  {
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      v4[0] = 67109378;
      v4[1] = v2;
      v5 = 2080;
      v6 = qmi::asString();
      _os_log_error_impl(&dword_216897000, v3, OS_LOG_TYPE_ERROR, "Error in response when sending call context during handover. Code = 0x%x (%s)", (uint8_t *)v4, 0x12u);
    }
  }
  else if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v4[0]) = 0;
    _os_log_impl(&dword_216897000, v3, OS_LOG_TYPE_DEFAULT, "#I Successfully sent call context for handover", (uint8_t *)v4, 2u);
  }
}

uint64_t __copy_helper_block_e8_32c102_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver19sendSRVCCCallConfigEN10subscriber7SimSlotEE3__1EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c102_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver19sendSRVCCCallConfigEN10subscriber7SimSlotEE3__1EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::sendSRVCCCallConfig(subscriber::SimSlot)::$_1,std::allocator<EurekaCallCommandDriver::sendSRVCCCallConfig(subscriber::SimSlot)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E3C30;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::sendSRVCCCallConfig(subscriber::SimSlot)::$_1,std::allocator<EurekaCallCommandDriver::sendSRVCCCallConfig(subscriber::SimSlot)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E3C30;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

uint64_t ___ZN3ctu20SharedSynchronizableI17CallCommandDriverE13connect_eventIN5event11EventLoggerIFvvENS4_14CSIEventLoggerEEE23EurekaCallCommandDrivervJEEEDTcl7connectfp_cvNSt3__110shared_ptrIS1_EE_EcvP16dispatch_queue_s_EcvPFT1_DpT2_ELi0EEERT_MT0_FSF_SH_E_block_invoke(_QWORD *a1)
{
  uint64_t (*v1)(_QWORD *);
  uint64_t v2;
  _QWORD *v3;

  v1 = (uint64_t (*)(_QWORD *))a1[5];
  v2 = a1[6];
  v3 = (_QWORD *)(a1[4] + (v2 >> 1) - 8);
  if ((v2 & 1) != 0)
    v1 = *(uint64_t (**)(_QWORD *))(*v3 + v1);
  return v1(v3);
}

uint64_t boost::signals2::slot<void ()(void),boost::function<void ()(void)>>::~slot(uint64_t a1)
{
  void **v3;

  boost::function0<void>::~function0((uint64_t *)(a1 + 24));
  v3 = (void **)a1;
  std::vector<boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>>::__destroy_vector::operator()[abi:ne180100](&v3);
  return a1;
}

uint64_t boost::shared_ptr<boost::signals2::detail::signal_impl<void ()(void),boost::signals2::optional_last_value<void>,int,std::less<int>,boost::function<void ()(void)>,boost::function<void ()(boost::signals2::connection const&)>,boost::signals2::mutex>::invocation_state>::operator->(uint64_t result)
{
  if (!result)
    __assert_rtn("operator->", "shared_ptr.hpp", 786, "px != 0");
  return result;
}

uint64_t boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>::operator->(uint64_t result)
{
  if (!result)
    __assert_rtn("operator->", "shared_ptr.hpp", 786, "px != 0");
  return result;
}

uint64_t boost::signals2::detail::signal_impl<void ()(void),boost::signals2::optional_last_value<void>,int,std::less<int>,boost::function<void ()(void)>,boost::function<void ()(boost::signals2::connection const&)>,boost::signals2::mutex>::nolock_cleanup_connections_from(uint64_t *a1, _QWORD *a2, uint64_t **a3, int a4)
{
  uint64_t v4;
  unsigned int v5;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t result;
  unsigned int v11;
  unsigned int v12;
  uint64_t *v13;
  uint64_t v14;
  boost::signals2::slot_base *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t *v21;
  _BOOL4 v22;
  _QWORD *v23;
  _QWORD *v24;
  uint64_t v25;
  uint64_t *v26;
  _BOOL4 v27;
  _QWORD *v28;
  void **v29;
  _QWORD *v30;
  uint64_t **v31;
  int v32;
  uint64_t v33;
  uint64_t *v34;
  BOOL v35;
  unsigned int v36;
  uint64_t v38;
  uint64_t **v39;
  uint64_t v40;

  v4 = a1[1];
  if (!v4 || (v5 = atomic_load((unsigned int *)(v4 + 8)), v5 != 1))
    __assert_rtn("nolock_cleanup_connections_from", "signal_template.hpp", 436, "_shared_state.unique()");
  v8 = *a3;
  v9 = (uint64_t *)boost::shared_ptr<boost::signals2::detail::signal_impl<void ()(void),boost::signals2::optional_last_value<void>,int,std::less<int>,boost::function<void ()(void)>,boost::function<void ()(boost::signals2::connection const&)>,boost::signals2::mutex>::invocation_state>::operator->(*a1);
  result = boost::shared_ptr<boost::signals2::detail::grouped_list<int,std::less<int>,boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>>>::operator*(*v9);
  if ((uint64_t *)result != v8)
  {
    v11 = 0;
    v12 = a4 - 1;
    v13 = v8;
    v36 = v12;
    do
    {
      v14 = v13[2];
      boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>::operator->(v14);
      v15 = *(boost::signals2::slot_base **)(v14 + 32);
      if (v15 && boost::signals2::slot_base::expired(v15) && *(_BYTE *)(v14 + 24))
      {
        *(_BYTE *)(v14 + 24) = 0;
        boost::signals2::detail::connection_body_base::dec_slot_refcount<boost::signals2::mutex>((_DWORD *)v14, a2);
      }
      if (*(_BYTE *)(boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>::operator->(v13[2])
                    + 24))
      {
        v8 = (uint64_t *)v13[1];
      }
      else
      {
        v16 = *(_QWORD *)boost::shared_ptr<boost::signals2::detail::signal_impl<void ()(void),boost::signals2::optional_last_value<void>,int,std::less<int>,boost::function<void ()(void)>,boost::function<void ()(boost::signals2::connection const&)>,boost::signals2::mutex>::invocation_state>::operator->(*a1);
        boost::shared_ptr<boost::signals2::detail::grouped_list<int,std::less<int>,boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>>>::operator*(v16);
        v17 = boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>::operator->(v13[2]);
        if (v13 == (uint64_t *)v16)
          __assert_rtn("erase", "slot_groups.hpp", 148, "it != _list.end()");
        v18 = (uint64_t *)(v16 + 32);
        v19 = *(_QWORD **)(v16 + 32);
        if (!v19)
          goto LABEL_41;
        v20 = v17 + 64;
        v39 = (uint64_t **)(v16 + 24);
        v21 = (uint64_t *)(v16 + 32);
        do
        {
          v22 = boost::signals2::detail::group_key_less<int,std::less<int>>::operator()(v16 + 48, (uint64_t)(v19 + 4), v20);
          v23 = v19 + 1;
          if (!v22)
          {
            v23 = v19;
            v21 = v19;
          }
          v19 = (_QWORD *)*v23;
        }
        while (*v23);
        if (v21 == v18)
LABEL_41:
          __assert_rtn("erase", "slot_groups.hpp", 150, "map_it != _group_map.end()");
        if (!boost::signals2::detail::grouped_list<int,std::less<int>,boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>>::weakly_equivalent(v16, (uint64_t)(v21 + 4), v20))__assert_rtn("erase", "slot_groups.hpp", 151, "weakly_equivalent(map_it->first, key)");
        if ((uint64_t *)v21[6] == v13)
        {
          v38 = v13[1];
          v24 = (_QWORD *)*v18;
          v25 = v16;
          if (*v18)
          {
            v26 = (uint64_t *)(v16 + 32);
            do
            {
              v27 = boost::signals2::detail::group_key_less<int,std::less<int>>::operator()(v16 + 48, v20, (uint64_t)(v24 + 4));
              v28 = v24 + 1;
              if (v27)
              {
                v28 = v24;
                v26 = v24;
              }
              v24 = (_QWORD *)*v28;
            }
            while (*v28);
            v25 = v16;
            if (v26 != v18)
              v25 = v26[6];
          }
          if (v38 == v25)
          {
            std::__tree<std::__value_type<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,std::__list_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>,void *>>,std::__map_value_compare<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,std::__value_type<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,std::__list_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>,void *>>,boost::signals2::detail::group_key_less<int,std::less<int>>,false>,std::allocator<std::__value_type<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,std::__list_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>,void *>>>>::__remove_node_pointer(v39, v21);
            operator delete(v21);
            v12 = v36;
          }
          else
          {
            v40 = 0;
            v29 = (void **)std::__tree<std::__value_type<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,std::__list_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>,void *>>,std::__map_value_compare<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,std::__value_type<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,std::__list_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>,void *>>,boost::signals2::detail::group_key_less<int,std::less<int>>,false>,std::allocator<std::__value_type<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,std::__list_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>,void *>>>>::__find_equal<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>>((uint64_t)v39, &v40, v20);
            v30 = *v29;
            v12 = v36;
            if (!*v29)
            {
              v31 = (uint64_t **)v29;
              v30 = operator new(0x38uLL);
              v32 = *(_DWORD *)(v20 + 8);
              v30[4] = *(_QWORD *)v20;
              *((_DWORD *)v30 + 10) = v32;
              v30[6] = 0;
              std::__tree<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::less<unsigned short>,true>,std::allocator<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>>>::__insert_node_at(v39, v40, v31, v30);
            }
            v30[6] = v38;
          }
        }
        v33 = *v13;
        v8 = (uint64_t *)v13[1];
        *(_QWORD *)(v33 + 8) = v8;
        *(_QWORD *)v13[1] = v33;
        --*(_QWORD *)(v16 + 16);
        boost::detail::shared_count::~shared_count((unsigned int **)v13 + 3);
        operator delete(v13);
      }
      ++v11;
      v34 = (uint64_t *)boost::shared_ptr<boost::signals2::detail::signal_impl<void ()(void),boost::signals2::optional_last_value<void>,int,std::less<int>,boost::function<void ()(void)>,boost::function<void ()(boost::signals2::connection const&)>,boost::signals2::mutex>::invocation_state>::operator->(*a1);
      result = boost::shared_ptr<boost::signals2::detail::grouped_list<int,std::less<int>,boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>>>::operator*(*v34);
      v35 = v8 != (uint64_t *)result && v12 >= v11;
      v13 = v8;
    }
    while (v35);
  }
  a1[2] = (uint64_t)v8;
  return result;
}

void boost::detail::sp_counted_impl_p<boost::signals2::detail::signal_impl<void ()(void),boost::signals2::optional_last_value<void>,int,std::less<int>,boost::function<void ()(void)>,boost::function<void ()(boost::signals2::connection const&)>,boost::signals2::mutex>::invocation_state>::~sp_counted_impl_p()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t boost::detail::sp_counted_impl_p<boost::signals2::detail::signal_impl<void ()(void),boost::signals2::optional_last_value<void>,int,std::less<int>,boost::function<void ()(void)>,boost::function<void ()(boost::signals2::connection const&)>,boost::signals2::mutex>::invocation_state>::dispose(uint64_t result)
{
  uint64_t v1;

  v1 = *(_QWORD *)(result + 16);
  if (v1)
  {
    boost::detail::shared_count::~shared_count((unsigned int **)(v1 + 24));
    boost::detail::shared_count::~shared_count((unsigned int **)(v1 + 8));
    JUMPOUT(0x2199FEAC4);
  }
  return result;
}

uint64_t boost::detail::sp_counted_impl_p<boost::signals2::detail::signal_impl<void ()(void),boost::signals2::optional_last_value<void>,int,std::less<int>,boost::function<void ()(void)>,boost::function<void ()(boost::signals2::connection const&)>,boost::signals2::mutex>::invocation_state>::get_deleter()
{
  return 0;
}

uint64_t boost::detail::sp_counted_impl_p<boost::signals2::detail::signal_impl<void ()(void),boost::signals2::optional_last_value<void>,int,std::less<int>,boost::function<void ()(void)>,boost::function<void ()(boost::signals2::connection const&)>,boost::signals2::mutex>::invocation_state>::get_local_deleter()
{
  return 0;
}

uint64_t boost::detail::sp_counted_impl_p<boost::signals2::detail::signal_impl<void ()(void),boost::signals2::optional_last_value<void>,int,std::less<int>,boost::function<void ()(void)>,boost::function<void ()(boost::signals2::connection const&)>,boost::signals2::mutex>::invocation_state>::get_untyped_deleter()
{
  return 0;
}

void boost::detail::sp_counted_impl_p<boost::signals2::detail::grouped_list<int,std::less<int>,boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>>>::~sp_counted_impl_p()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t boost::detail::sp_counted_impl_p<boost::signals2::detail::grouped_list<int,std::less<int>,boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>>>::dispose(uint64_t result)
{
  uint64_t v1;

  v1 = *(_QWORD *)(result + 16);
  if (v1)
  {
    std::__tree<std::__value_type<AQMThroughputKey,unsigned int>,std::__map_value_compare<AQMThroughputKey,std::__value_type<AQMThroughputKey,unsigned int>,std::less<AQMThroughputKey>,true>,std::allocator<std::__value_type<AQMThroughputKey,unsigned int>>>::destroy(*(_QWORD **)(v1 + 32));
    std::__list_imp<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>>::clear((unsigned int **)v1);
    JUMPOUT(0x2199FEAC4);
  }
  return result;
}

uint64_t boost::detail::sp_counted_impl_p<boost::signals2::detail::grouped_list<int,std::less<int>,boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>>>::get_deleter()
{
  return 0;
}

uint64_t boost::detail::sp_counted_impl_p<boost::signals2::detail::grouped_list<int,std::less<int>,boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>>>::get_local_deleter()
{
  return 0;
}

uint64_t boost::detail::sp_counted_impl_p<boost::signals2::detail::grouped_list<int,std::less<int>,boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>>>::get_untyped_deleter()
{
  return 0;
}

uint64_t boost::shared_ptr<boost::signals2::slot<void ()(void),boost::function<void ()(void)>>>::operator*(uint64_t result)
{
  if (!result)
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  return result;
}

BOOL boost::signals2::detail::grouped_list<int,std::less<int>,boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>>::weakly_equivalent(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;

  v5 = a1 + 56;
  return !boost::signals2::detail::group_key_less<int,std::less<int>>::operator()(a1 + 56, a2, a3)
      && !boost::signals2::detail::group_key_less<int,std::less<int>>::operator()(v5, a3, a2);
}

uint64_t *std::__tree<std::__value_type<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,std::__list_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>,void *>>,std::__map_value_compare<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,std::__value_type<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,std::__list_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>,void *>>,boost::signals2::detail::group_key_less<int,std::less<int>>,false>,std::allocator<std::__value_type<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,std::__list_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>,void *>>>>::__remove_node_pointer(uint64_t **a1, uint64_t *a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t *v4;
  BOOL v5;
  uint64_t *v6;

  v2 = (uint64_t *)a2[1];
  if (v2)
  {
    do
    {
      v3 = v2;
      v2 = (uint64_t *)*v2;
    }
    while (v2);
  }
  else
  {
    v4 = a2;
    do
    {
      v3 = (uint64_t *)v4[2];
      v5 = *v3 == (_QWORD)v4;
      v4 = v3;
    }
    while (!v5);
  }
  if (*a1 == a2)
    *a1 = v3;
  v6 = a1[1];
  a1[2] = (uint64_t *)((char *)a1[2] - 1);
  return std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(v6, a2);
}

void boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>::~connection_body(uint64_t a1)
{
  boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>::~connection_body(a1);
  JUMPOUT(0x2199FEAC4);
}

BOOL boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>::connected(uint64_t a1)
{
  pthread_mutex_t *v2;
  _DWORD **v3;
  _DWORD *i;
  int v5;
  _OWORD v7[11];
  __int128 v8;
  _BYTE v9[24];
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v8 = 0u;
  memset(v7, 0, sizeof(v7));
  v2 = (pthread_mutex_t *)boost::shared_ptr<boost::signals2::mutex>::operator*((uint64_t *)(a1 + 48));
  boost::signals2::detail::garbage_collecting_lock<boost::signals2::mutex>::garbage_collecting_lock(v7, v2);
  v3 = *(_DWORD ***)(a1 + 32);
  if (v3)
  {
    for (i = *v3;
          i != *(_DWORD **)(boost::shared_ptr<boost::signals2::slot<void ()(void),boost::function<void ()(void)>>>::operator*((uint64_t)v3)
                          + 8);
          i += 6)
    {
      memset(v9, 0, sizeof(v9));
      boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>::apply_visitor<boost::signals2::detail::lock_weak_ptr_visitor const>(i, (uint64_t)v9);
      if (boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>::apply_visitor<boost::signals2::detail::expired_weak_ptr_visitor const>((uint64_t)i))
      {
        if (*(_BYTE *)(a1 + 24))
        {
          *(_BYTE *)(a1 + 24) = 0;
          boost::signals2::detail::connection_body_base::dec_slot_refcount<boost::signals2::mutex>((_DWORD *)a1, v7);
        }
        boost::variant<boost::shared_ptr<void>,boost::signals2::detail::foreign_void_shared_ptr>::destroy_content((uint64_t)v9);
        break;
      }
      boost::variant<boost::shared_ptr<void>,boost::signals2::detail::foreign_void_shared_ptr>::destroy_content((uint64_t)v9);
      v3 = *(_DWORD ***)(a1 + 32);
    }
  }
  v5 = *(unsigned __int8 *)(a1 + 24);
  boost::signals2::mutex::unlock(*((pthread_mutex_t **)&v8 + 1));
  boost::signals2::detail::auto_buffer<boost::shared_ptr<void>,boost::signals2::detail::store_n_objects<10u>,boost::signals2::detail::default_grow_policy,std::allocator<boost::shared_ptr<void>>>::auto_buffer_destroy(v7);
  return v5 != 0;
}

void sub_216A49C98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v3;
  va_list va;

  va_start(va, a3);
  boost::variant<boost::shared_ptr<void>,boost::signals2::detail::foreign_void_shared_ptr>::destroy_content(v3 - 64);
  boost::signals2::detail::garbage_collecting_lock<boost::signals2::mutex>::~garbage_collecting_lock((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>::lock(uint64_t a1)
{
  pthread_mutex_t *v1;

  v1 = (pthread_mutex_t *)boost::shared_ptr<boost::signals2::mutex>::operator->(*(_QWORD *)(a1 + 48));
  return boost::signals2::mutex::lock(v1);
}

uint64_t boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>::unlock(uint64_t a1)
{
  pthread_mutex_t *v1;

  v1 = (pthread_mutex_t *)boost::shared_ptr<boost::signals2::mutex>::operator->(*(_QWORD *)(a1 + 48));
  return boost::signals2::mutex::unlock(v1);
}

void boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>::release_slot(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  __int128 *v2;
  uint64_t v3;
  uint64_t v4;
  unsigned int *v5;
  unsigned int v6;
  __int128 v7;
  __int128 v8;

  v3 = *(_QWORD *)(a1 + 32);
  v4 = *(_QWORD *)(a1 + 40);
  v2 = (__int128 *)(a1 + 32);
  *a2 = v3;
  a2[1] = v4;
  if (v4)
  {
    v5 = (unsigned int *)(v4 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
    v7 = *v2;
  }
  else
  {
    *((_QWORD *)&v7 + 1) = 0;
  }
  *(_QWORD *)v2 = 0;
  *((_QWORD *)v2 + 1) = 0;
  *((_QWORD *)&v8 + 1) = *((_QWORD *)&v7 + 1);
  boost::detail::shared_count::~shared_count((unsigned int **)&v8 + 1);
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>>>(unint64_t a1)
{
  if (a1 >= 0xAAAAAAAAAAAAAABLL)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(24 * a1);
}

uint64_t boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>::variant(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  unsigned int *v5;
  unsigned int v6;
  uint64_t v7;
  unsigned int *v8;
  unsigned int v9;
  uint64_t v10;

  switch(*(_DWORD *)a2 ^ (*(int *)a2 >> 31))
  {
    case 0:
      v4 = *(_QWORD *)(a2 + 16);
      *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
      *(_QWORD *)(a1 + 16) = v4;
      if (v4)
      {
        v5 = (unsigned int *)(v4 + 12);
        do
          v6 = __ldxr(v5);
        while (__stxr(v6 + 1, v5));
      }
      break;
    case 1:
      v7 = *(_QWORD *)(a2 + 16);
      *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
      *(_QWORD *)(a1 + 16) = v7;
      if (v7)
      {
        v8 = (unsigned int *)(v7 + 12);
        do
          v9 = __ldxr(v8);
        while (__stxr(v9 + 1, v8));
      }
      break;
    case 2:
      v10 = boost::scoped_ptr<boost::signals2::detail::foreign_weak_ptr_impl_base>::operator->((uint64_t *)(a2 + 8));
      *(_QWORD *)(a1 + 8) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v10 + 32))(v10);
      break;
    default:
      boost::detail::variant::forced_return<void>();
  }
  *(_DWORD *)a1 = *(_DWORD *)a2 ^ (*(int *)a2 >> 31);
  return a1;
}

{
  uint64_t *v3;
  int v4;
  uint64_t v6;

  v3 = (uint64_t *)(a2 + 8);
  switch(*(_DWORD *)a2 ^ (*(int *)a2 >> 31))
  {
    case 0:
      v4 = 0;
      *(_OWORD *)(a1 + 8) = *(_OWORD *)v3;
      *v3 = 0;
      *(_QWORD *)(a2 + 16) = 0;
      break;
    case 1:
      *(_OWORD *)(a1 + 8) = *(_OWORD *)v3;
      *v3 = 0;
      *(_QWORD *)(a2 + 16) = 0;
      v4 = 1;
      break;
    case 2:
      v6 = boost::scoped_ptr<boost::signals2::detail::foreign_weak_ptr_impl_base>::operator->(v3);
      *(_QWORD *)(a1 + 8) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 32))(v6);
      v4 = *(_DWORD *)a2 ^ (*(int *)a2 >> 31);
      break;
    default:
      boost::detail::variant::forced_return<void>();
  }
  *(_DWORD *)a1 = v4;
  return a1;
}

void boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>::destroy_content(uint64_t a1)
{
  unsigned int v1;
  uint64_t v2;

  v1 = *(_DWORD *)a1 ^ (*(int *)a1 >> 31);
  if (v1 == 2)
  {
    v2 = *(_QWORD *)(a1 + 8);
    if (v2)
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  }
  else
  {
    if (v1 > 1)
      boost::detail::variant::forced_return<void>();
    boost::detail::weak_count::~weak_count((unsigned int **)(a1 + 16));
  }
}

void std::vector<boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 24;
        boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>::destroy_content(v4);
      }
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t boost::checked_delete<boost::signals2::slot<void ()(void),boost::function<void ()(void)>>>(uint64_t result)
{
  void **v1;
  void **v2;

  if (result)
  {
    v1 = (void **)result;
    boost::function0<void>::~function0((uint64_t *)(result + 24));
    v2 = v1;
    std::vector<boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>>::__destroy_vector::operator()[abi:ne180100](&v2);
    JUMPOUT(0x2199FEAC4);
  }
  return result;
}

void boost::detail::sp_counted_impl_p<boost::signals2::slot<void ()(void),boost::function<void ()(void)>>>::~sp_counted_impl_p()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t boost::detail::sp_counted_impl_p<boost::signals2::slot<void ()(void),boost::function<void ()(void)>>>::dispose(uint64_t result)
{
  uint64_t v1;
  void **v2;

  v1 = *(_QWORD *)(result + 16);
  if (v1)
  {
    boost::function0<void>::~function0((uint64_t *)(v1 + 24));
    v2 = (void **)v1;
    std::vector<boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>>::__destroy_vector::operator()[abi:ne180100](&v2);
    JUMPOUT(0x2199FEAC4);
  }
  return result;
}

uint64_t boost::detail::sp_counted_impl_p<boost::signals2::slot<void ()(void),boost::function<void ()(void)>>>::get_deleter()
{
  return 0;
}

uint64_t boost::detail::sp_counted_impl_p<boost::signals2::slot<void ()(void),boost::function<void ()(void)>>>::get_local_deleter()
{
  return 0;
}

uint64_t boost::detail::sp_counted_impl_p<boost::signals2::slot<void ()(void),boost::function<void ()(void)>>>::get_untyped_deleter()
{
  return 0;
}

uint64_t boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>::~connection_body(uint64_t a1)
{
  *(_QWORD *)a1 = &off_24D5E3D60;
  boost::detail::shared_count::~shared_count((unsigned int **)(a1 + 56));
  boost::detail::shared_count::~shared_count((unsigned int **)(a1 + 40));
  *(_QWORD *)a1 = off_24D5E3DC8;
  boost::detail::weak_count::~weak_count((unsigned int **)(a1 + 16));
  return a1;
}

uint64_t boost::shared_ptr<boost::signals2::mutex>::operator->(uint64_t result)
{
  if (!result)
    __assert_rtn("operator->", "shared_ptr.hpp", 786, "px != 0");
  return result;
}

void boost::detail::sp_counted_impl_p<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>::~sp_counted_impl_p()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t boost::detail::sp_counted_impl_p<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>::dispose(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 16);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t boost::detail::sp_counted_impl_p<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>::get_deleter()
{
  return 0;
}

uint64_t boost::detail::sp_counted_impl_p<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>::get_local_deleter()
{
  return 0;
}

uint64_t boost::detail::sp_counted_impl_p<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>::get_untyped_deleter()
{
  return 0;
}

uint64_t boost::shared_ptr<boost::signals2::detail::grouped_list<int,std::less<int>,boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(void),boost::function<void ()(void)>>,boost::signals2::mutex>>>>::operator*(uint64_t result)
{
  if (!result)
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  return result;
}

NSObject **ctu::DispatchSlot<dispatch::block<void({block_pointer})(void)>>::DispatchSlot(NSObject **a1, NSObject *a2, void *aBlock)
{
  NSObject *v4;

  *a1 = a2;
  if (aBlock)
  {
    v4 = _Block_copy(aBlock);
    a2 = *a1;
  }
  else
  {
    v4 = 0;
  }
  a1[1] = v4;
  dispatch_retain(a2);
  return a1;
}

uint64_t boost::detail::function::functor_manager<ctu::DispatchSlot<dispatch::block<void({block_pointer})(void)>>>::manage(uint64_t result, NSObject **a2, unsigned int a3)
{
  uint64_t v5;
  uint64_t v6;

  if (a3 == 4)
    goto LABEL_2;
  v5 = result;
  if (a3 > 1)
  {
    if (a3 != 3)
    {
      if (a3 != 2)
      {
LABEL_2:
        *((_WORD *)a2 + 4) = 0;
        return result;
      }
      v6 = (uint64_t)a2;
      return ctu::DispatchSlot<dispatch::block<void({block_pointer})(void)>>::~DispatchSlot(v6);
    }
    result = (uint64_t)(*a2)[1].isa & 0x7FFFFFFFFFFFFFFFLL;
    if (result == ((unint64_t)"N3ctu12DispatchSlotIN8dispatch5blockIU13block_pointerFvvEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
      || (result = strcmp((const char *)result, (const char *)((unint64_t)"N3ctu12DispatchSlotIN8dispatch5blockIU13block_pointerFvvEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !(_DWORD)result))
    {
      *a2 = v5;
    }
    else
    {
      *a2 = 0;
    }
  }
  else
  {
    result = (uint64_t)ctu::DispatchSlot<dispatch::block<void({block_pointer})(void)>>::DispatchSlot(a2, *(NSObject **)result, *(void **)(result + 8));
    if (a3 == 1)
    {
      v6 = v5;
      return ctu::DispatchSlot<dispatch::block<void({block_pointer})(void)>>::~DispatchSlot(v6);
    }
  }
  return result;
}

void boost::detail::function::void_function_obj_invoker0<ctu::DispatchSlot<dispatch::block<void({block_pointer})(void)>>,void>::invoke(uint64_t a1)
{
  const void *v1;
  NSObject *v2;
  void *v3;
  const void *v4;
  void *v5;
  const void *v6;
  void *v7;
  const void *v8;
  void *v9;
  const void *v10;
  void *v11;
  const void *v12;
  void *v13;
  const void *v14;
  char v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t (**v18)();
  uint64_t (**v19)();
  __int128 v20;
  uint64_t v21;
  _QWORD block[5];

  v2 = *(NSObject **)a1;
  v1 = *(const void **)(a1 + 8);
  if (!v1)
  {
    v4 = 0;
    goto LABEL_10;
  }
  v3 = _Block_copy(v1);
  v4 = v3;
  if (!v3)
  {
LABEL_10:
    v15 = 1;
LABEL_11:
    v19 = boost::function0<void>::assign_to<dispatch::block<void({block_pointer})(void)>>(dispatch::block<void({block_pointer})(void)>)::stored_vtable;
    *(_QWORD *)&v20 = 0;
    goto LABEL_21;
  }
  v5 = _Block_copy(v3);
  v6 = v5;
  if (!v5)
  {
    v15 = 0;
    goto LABEL_11;
  }
  v7 = _Block_copy(v5);
  v8 = v7;
  if (v7)
  {
    v9 = _Block_copy(v7);
    v10 = v9;
    if (v9)
    {
      v11 = _Block_copy(v9);
      v12 = v11;
      if (v11)
      {
        v13 = _Block_copy(v11);
        v14 = v13;
        if (v13)
        {
          *(_QWORD *)&v20 = _Block_copy(v13);
          _Block_release(v14);
        }
        else
        {
          *(_QWORD *)&v20 = 0;
        }
        _Block_release(v12);
      }
      else
      {
        *(_QWORD *)&v20 = 0;
      }
      _Block_release(v10);
    }
    else
    {
      *(_QWORD *)&v20 = 0;
    }
    v19 = boost::function0<void>::assign_to<dispatch::block<void({block_pointer})(void)>>(dispatch::block<void({block_pointer})(void)>)::stored_vtable;
    _Block_release(v8);
  }
  else
  {
    v19 = boost::function0<void>::assign_to<dispatch::block<void({block_pointer})(void)>>(dispatch::block<void({block_pointer})(void)>)::stored_vtable;
    *(_QWORD *)&v20 = 0;
  }
  _Block_release(v6);
  v15 = 0;
LABEL_21:
  v16 = operator new();
  v17 = v16;
  *(_QWORD *)v16 = 0;
  v18 = v19;
  if (v19)
  {
    *(_QWORD *)v16 = v19;
    if ((v18 & 1) != 0)
    {
      *(_OWORD *)(v16 + 8) = v20;
      *(_QWORD *)(v16 + 24) = v21;
    }
    else
    {
      (*(void (**)(__int128 *, uint64_t, _QWORD))((unint64_t)v18 & 0xFFFFFFFFFFFFFFFELL))(&v20, v16 + 8, 0);
    }
  }
  block[0] = MEMORY[0x24BDAC760];
  block[1] = 0x40000000;
  block[2] = ___Z13execute_blockP16dispatch_queue_sRKN5boost8functionIFvvEEE_block_invoke;
  block[3] = &__block_descriptor_tmp_158;
  block[4] = v17;
  dispatch_async(v2, block);
  boost::function0<void>::~function0((uint64_t *)&v19);
  if ((v15 & 1) == 0)
    _Block_release(v4);
}

void sub_216A4A440(_Unwind_Exception *a1, uint64_t a2, ...)
{
  const void *v2;
  uint64_t v3;
  char v4;
  va_list va;

  va_start(va, a2);
  MEMORY[0x2199FEAC4](v3, 0x10E2C406E9A86C3);
  boost::function0<void>::~function0((uint64_t *)va);
  if ((v4 & 1) == 0)
    _Block_release(v2);
  _Unwind_Resume(a1);
}

void sub_216A4A528(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::runtime_error a9)
{
  std::runtime_error::~runtime_error(&a9);
  _Unwind_Resume(a1);
}

void boost::detail::function::functor_manager<dispatch::block<void({block_pointer})(void)>>::manage(void **a1, _WORD *a2, unsigned int a3)
{
  void *v6;
  void *v7;
  const char *v8;

  if (a3 == 4)
    goto LABEL_2;
  if (a3 > 1)
  {
    if (a3 == 3)
    {
      v8 = (const char *)(*(_QWORD *)(*(_QWORD *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL);
      if (v8 == (const char *)((unint64_t)"N8dispatch5blockIU13block_pointerFvvEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || !strcmp(v8, (const char *)((unint64_t)"N8dispatch5blockIU13block_pointerFvvEEE" & 0x7FFFFFFFFFFFFFFFLL)))
      {
        *(_QWORD *)a2 = a1;
      }
      else
      {
        *(_QWORD *)a2 = 0;
      }
    }
    else
    {
      if (a3 != 2)
      {
LABEL_2:
        a2[4] = 0;
        return;
      }
      v7 = *(void **)a2;
      if (*(_QWORD *)a2)
LABEL_9:
        _Block_release(v7);
    }
  }
  else
  {
    v6 = *a1;
    if (*a1)
      v6 = _Block_copy(v6);
    *(_QWORD *)a2 = v6;
    if (a3 == 1)
    {
      v7 = *a1;
      if (*a1)
        goto LABEL_9;
    }
  }
}

uint64_t boost::detail::function::void_function_obj_invoker0<dispatch::block<void({block_pointer})(void)>,void>::invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)a1 + 16))();
}

uint64_t boost::function0<void>::move_assign(uint64_t result, uint64_t *a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t (*v6)(uint64_t, uint64_t, uint64_t);
  __int128 v7;

  if (a2 != (uint64_t *)result)
  {
    v2 = a2;
    v3 = (uint64_t *)result;
    v4 = *a2;
    if (*a2)
    {
      *(_QWORD *)result = v4;
      if ((v4 & 1) != 0)
      {
        v7 = *(_OWORD *)(a2 + 1);
        *(_QWORD *)(result + 24) = a2[3];
        *(_OWORD *)(result + 8) = v7;
      }
      else
      {
        result = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v4 & 0xFFFFFFFFFFFFFFFELL))(a2 + 1, result + 8, 1);
      }
    }
    else
    {
      v5 = *(_QWORD *)result;
      if (!*(_QWORD *)result)
        return result;
      if ((v5 & 1) == 0)
      {
        v6 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v5 & 0xFFFFFFFFFFFFFFFELL);
        if (v6)
          result = v6(result + 8, result + 8, 2);
      }
      v2 = v3;
    }
    *v2 = 0;
  }
  return result;
}

void sub_216A4A6B8(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_rethrow();
}

void sub_216A4A6C8(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t *boost::function0<void>::~function0(uint64_t *a1)
{
  uint64_t v2;
  void (*v3)(uint64_t *, uint64_t *, uint64_t);

  v2 = *a1;
  if (*a1)
  {
    if ((v2 & 1) == 0)
    {
      v3 = *(void (**)(uint64_t *, uint64_t *, uint64_t))(v2 & 0xFFFFFFFFFFFFFFFELL);
      if (v3)
        v3(a1 + 1, a1 + 1, 2);
    }
    *a1 = 0;
  }
  return a1;
}

uint64_t std::__split_buffer<boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 24;
    boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>::destroy_content(i - 24);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

_QWORD *boost::signals2::detail::foreign_weak_ptr_impl<std::weak_ptr<CallCommandDriver>>::~foreign_weak_ptr_impl(_QWORD *a1)
{
  std::__shared_weak_count *v2;

  *a1 = &off_24D5E3F28;
  v2 = (std::__shared_weak_count *)a1[2];
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  return a1;
}

void boost::signals2::detail::foreign_weak_ptr_impl<std::weak_ptr<CallCommandDriver>>::~foreign_weak_ptr_impl(_QWORD *a1)
{
  std::__shared_weak_count *v1;

  *a1 = &off_24D5E3F28;
  v1 = (std::__shared_weak_count *)a1[2];
  if (v1)
    std::__shared_weak_count::__release_weak(v1);
  JUMPOUT(0x2199FEAC4);
}

void boost::signals2::detail::foreign_weak_ptr_impl<std::weak_ptr<CallCommandDriver>>::lock(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  uint64_t v6;
  _QWORD *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  unint64_t v10;

  v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    v5 = std::__shared_weak_count::lock(v4);
    if (v5)
    {
      v6 = *(_QWORD *)(a1 + 8);
      goto LABEL_6;
    }
  }
  else
  {
    v5 = 0;
  }
  v6 = 0;
LABEL_6:
  v7 = (_QWORD *)operator new();
  *v7 = &off_24D5E3F88;
  v7[1] = v6;
  v7[2] = v5;
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
    *a2 = v7;
    do
      v10 = __ldaxr(p_shared_owners);
    while (__stlxr(v10 - 1, p_shared_owners));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  else
  {
    *a2 = v7;
  }
}

void sub_216A4A978(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

BOOL boost::signals2::detail::foreign_weak_ptr_impl<std::weak_ptr<CallCommandDriver>>::expired(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 16);
  return !v1 || *(_QWORD *)(v1 + 8) == -1;
}

_QWORD *boost::signals2::detail::foreign_weak_ptr_impl<std::weak_ptr<CallCommandDriver>>::clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;

  result = (_QWORD *)operator new();
  v4 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16);
  *result = &off_24D5E3F28;
  result[1] = v4;
  result[2] = v3;
  if (v3)
  {
    v5 = (unint64_t *)(v3 + 16);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  return result;
}

_QWORD *boost::signals2::detail::foreign_shared_ptr_impl<std::shared_ptr<CallCommandDriver>>::~foreign_shared_ptr_impl(_QWORD *a1)
{
  *a1 = &off_24D5E3F88;
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)(a1 + 1));
  return a1;
}

void boost::signals2::detail::foreign_shared_ptr_impl<std::shared_ptr<CallCommandDriver>>::~foreign_shared_ptr_impl(_QWORD *a1)
{
  *a1 = &off_24D5E3F88;
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)(a1 + 1));
  JUMPOUT(0x2199FEAC4);
}

_QWORD *boost::signals2::detail::foreign_shared_ptr_impl<std::shared_ptr<CallCommandDriver>>::clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;

  result = (_QWORD *)operator new();
  v4 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16);
  *result = &off_24D5E3F88;
  result[1] = v4;
  result[2] = v3;
  if (v3)
  {
    v5 = (unint64_t *)(v3 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  return result;
}

uint64_t ctu::DispatchSlot<dispatch::block<void({block_pointer})(void)>>::~DispatchSlot(uint64_t a1)
{
  const void *v2;

  dispatch_release(*(dispatch_object_t *)a1);
  v2 = *(const void **)(a1 + 8);
  if (v2)
    _Block_release(v2);
  return a1;
}

void std::__function::__func<ctu::rest::property_sink_t<calls_active_in_settings>::bind(ctu::RestModule &)::{lambda(xpc::object const&)#1},std::allocator<ctu::rest::property_sink_t<calls_active_in_settings>::bind(ctu::RestModule &)::{lambda(xpc::object const&)#1}>,void ()(xpc::object)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<ctu::rest::property_sink_t<calls_active_in_settings>::bind(ctu::RestModule &)::{lambda(xpc::object const&)#1},std::allocator<ctu::rest::property_sink_t<calls_active_in_settings>::bind(ctu::RestModule &)::{lambda(xpc::object const&)#1}>,void ()(xpc::object)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5E3FD8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<ctu::rest::property_sink_t<calls_active_in_settings>::bind(ctu::RestModule &)::{lambda(xpc::object const&)#1},std::allocator<ctu::rest::property_sink_t<calls_active_in_settings>::bind(ctu::RestModule &)::{lambda(xpc::object const&)#1}>,void ()(xpc::object)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5E3FD8;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<ctu::rest::property_sink_t<calls_active_in_settings>::bind(ctu::RestModule &)::{lambda(xpc::object const&)#1},std::allocator<ctu::rest::property_sink_t<calls_active_in_settings>::bind(ctu::RestModule &)::{lambda(xpc::object const&)#1}>,void ()(xpc::object)>::operator()(uint64_t a1)
{
  _BYTE *v1;
  uint64_t result;

  v1 = *(_BYTE **)(a1 + 8);
  result = xpc::dyn_cast_or_default();
  *v1 = result;
  return result;
}

uint64_t std::__function::__func<ctu::rest::property_sink_t<calls_active_in_settings>::bind(ctu::RestModule &)::{lambda(xpc::object const&)#1},std::allocator<ctu::rest::property_sink_t<calls_active_in_settings>::bind(ctu::RestModule &)::{lambda(xpc::object const&)#1}>,void ()(xpc::object)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<ctu::rest::property_sink_t<calls_active_in_settings>::bind(ctu::RestModule &)::{lambda(xpc::object const&)#1},std::allocator<ctu::rest::property_sink_t<calls_active_in_settings>::bind(ctu::RestModule &)::{lambda(xpc::object const&)#1}>,void ()(xpc::object)>::target_type()
{
}

void std::__function::__func<void ctu::rest::property_sink_t<rest::rats>::bind_impl<void (EurekaCallCommandDriver::*&)(std::map<subscriber::SimSlot,RadioAccessTechnology> const&),EurekaCallCommandDriver>(ctu::RestModule &,EurekaCallCommandDriver *,void (EurekaCallCommandDriver::*&)(std::map<subscriber::SimSlot,RadioAccessTechnology> const&) &&,std::integral_constant<BOOL,false>)::{lambda(xpc::object const&)#1},std::allocator<xpc::object const&>,void ()(xpc)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

__n128 std::__function::__func<void ctu::rest::property_sink_t<rest::rats>::bind_impl<void (EurekaCallCommandDriver::*&)(std::map<subscriber::SimSlot,RadioAccessTechnology> const&),EurekaCallCommandDriver>(ctu::RestModule &,EurekaCallCommandDriver *,void (EurekaCallCommandDriver::*&)(std::map<subscriber::SimSlot,RadioAccessTechnology> const&) &&,std::integral_constant<BOOL,false>)::{lambda(xpc::object const&)#1},std::allocator<xpc::object const&>,void ()(xpc)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x28uLL);
  *(_QWORD *)v2 = &off_24D5E4058;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 std::__function::__func<void ctu::rest::property_sink_t<rest::rats>::bind_impl<void (EurekaCallCommandDriver::*&)(std::map<subscriber::SimSlot,RadioAccessTechnology> const&),EurekaCallCommandDriver>(ctu::RestModule &,EurekaCallCommandDriver *,void (EurekaCallCommandDriver::*&)(std::map<subscriber::SimSlot,RadioAccessTechnology> const&) &&,std::integral_constant<BOOL,false>)::{lambda(xpc::object const&)#1},std::allocator<xpc::object const&>,void ()(xpc)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_24D5E4058;
  result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<void ctu::rest::property_sink_t<rest::rats>::bind_impl<void (EurekaCallCommandDriver::*&)(std::map<subscriber::SimSlot,RadioAccessTechnology> const&),EurekaCallCommandDriver>(ctu::RestModule &,EurekaCallCommandDriver *,void (EurekaCallCommandDriver::*&)(std::map<subscriber::SimSlot,RadioAccessTechnology> const&) &&,std::integral_constant<BOOL,false>)::{lambda(xpc::object const&)#1},std::allocator<xpc::object const&>,void ()(xpc)>::operator()(_QWORD *a1, _QWORD *a2)
{
  uint64_t v3;
  _QWORD *v4;
  uint64_t **v5;
  xpc_object_t v6;
  uint64_t v7;
  void *count;
  xpc_object_t v9;
  size_t v10;
  xpc_object_t v11;
  uint64_t v12;
  uint64_t v13;
  xpc_object_t v14;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t **v22;
  uint64_t **v23;
  int v24;
  uint64_t *v25;
  void (*v27)(_QWORD *, uint64_t **);
  uint64_t v28;
  _QWORD *v29;
  uint64_t *v30;
  _QWORD *v31;
  xpc_object_t v33;
  xpc_object_t v34;
  uint64_t v35;
  xpc_object_t v36;
  size_t index;
  xpc_object_t object;
  const char *v39;
  xpc_object_t v40;
  xpc_object_t v41;
  int v42;

  v3 = a1[1];
  v5 = (uint64_t **)(v3 + 8);
  v4 = *(_QWORD **)(v3 + 8);
  v30 = *(uint64_t **)v3;
  v31 = v4;
  if (*(_QWORD *)(v3 + 16))
  {
    v4[2] = &v31;
    *(_QWORD *)v3 = v5;
    *v5 = 0;
    *(_QWORD *)(v3 + 16) = 0;
  }
  else
  {
    v30 = (uint64_t *)&v31;
  }
  v6 = (xpc_object_t)*a2;
  v7 = MEMORY[0x24BDACF78];
  if (*a2 && MEMORY[0x2199FEDD0](*a2) == v7)
    xpc_retain(v6);
  else
    v6 = xpc_null_create();
  std::__tree<std::__value_type<std::pair<Technology,Type>,InputThreshold>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,InputThreshold>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,InputThreshold>>>::destroy(v3, *(_QWORD **)(v3 + 8));
  *(_QWORD *)(v3 + 8) = 0;
  *(_QWORD *)(v3 + 16) = 0;
  *(_QWORD *)v3 = v5;
  if (MEMORY[0x2199FEDD0](v6) == v7)
  {
    object = v6;
    if (v6)
      xpc_retain(v6);
    else
      object = xpc_null_create();
    xpc::array::iterator::iterator(&v36, &object, 0);
    xpc_release(object);
    object = v6;
    if (v6)
      xpc_retain(v6);
    else
      object = xpc_null_create();
    if (MEMORY[0x2199FEDD0](v6) == v7)
      count = (void *)xpc_array_get_count(v6);
    else
      count = 0;
    xpc::array::iterator::iterator(&v34, &object, count);
    xpc_release(object);
    v9 = v36;
    v10 = index;
    if (index != v35 || v36 != v34)
    {
      while (1)
      {
        v33 = 0;
        xpc::array::object_proxy::operator xpc::dict(&v33, v9, v10);
        v11 = v33;
        v12 = MEMORY[0x2199FEDD0](v33);
        v13 = MEMORY[0x24BDACFA0];
        if (v12 == MEMORY[0x24BDACFA0])
          break;
LABEL_54:
        xpc_release(v33);
        v9 = v36;
        v10 = index + 1;
        index = v10;
        if (v10 == v35 && v36 == v34)
          goto LABEL_59;
      }
      if (v11)
      {
        xpc_retain(v11);
        v41 = v11;
      }
      else
      {
        v11 = xpc_null_create();
        v41 = v11;
        if (!v11)
        {
          v14 = xpc_null_create();
          v11 = 0;
          goto LABEL_28;
        }
      }
      if (MEMORY[0x2199FEDD0](v11) == v13)
      {
        xpc_retain(v11);
        v14 = v41;
        goto LABEL_29;
      }
      v14 = xpc_null_create();
LABEL_28:
      v41 = v14;
LABEL_29:
      if (MEMORY[0x2199FEDD0](v14) == v13)
      {
        object = &v41;
        v39 = "first";
        xpc::dict::object_proxy::operator xpc::object((uint64_t)&object, &v40);
        v17 = MEMORY[0x2199FEDD0](v40);
        v18 = MEMORY[0x24BDACFF0];
        v19 = MEMORY[0x24BDACF80];
        if (v17 == MEMORY[0x24BDACFF0])
        {
          v42 = 0;
          ctu::rest::detail::read_enum_string_value();
          v16 = v42;
        }
        else if (v17 == MEMORY[0x24BDACF80] || v17 == MEMORY[0x24BDACFD0] || v17 == MEMORY[0x24BDACFF8])
        {
          v16 = xpc::dyn_cast_or_default();
        }
        else
        {
          v16 = 0;
        }
        xpc_release(v40);
        object = &v41;
        v39 = "second";
        xpc::dict::object_proxy::operator xpc::object((uint64_t)&object, &v40);
        v20 = MEMORY[0x2199FEDD0](v40);
        if (v20 == v18)
        {
          v42 = 0;
          ctu::rest::detail::read_enum_string_value();
          v15 = v42;
        }
        else if (v20 == v19 || v20 == MEMORY[0x24BDACFD0] || v20 == MEMORY[0x24BDACFF8])
        {
          v15 = xpc::dyn_cast_or_default();
        }
        else
        {
          v15 = 0;
        }
        xpc_release(v40);
      }
      else
      {
        v15 = 0;
        v16 = 0;
      }
      xpc_release(v41);
      xpc_release(v11);
      v21 = *v5;
      v22 = (uint64_t **)(v3 + 8);
      v23 = (uint64_t **)(v3 + 8);
      if (*v5)
      {
        while (1)
        {
          while (1)
          {
            v23 = (uint64_t **)v21;
            v24 = *((_DWORD *)v21 + 7);
            if (v24 <= v16)
              break;
            v21 = *v23;
            v22 = v23;
            if (!*v23)
              goto LABEL_53;
          }
          if (v24 >= v16)
            break;
          v21 = v23[1];
          if (!v21)
          {
            v22 = v23 + 1;
            goto LABEL_53;
          }
        }
      }
      else
      {
LABEL_53:
        v25 = (uint64_t *)operator new(0x28uLL);
        *((_DWORD *)v25 + 7) = v16;
        *((_DWORD *)v25 + 8) = v15;
        std::__tree<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::less<unsigned short>,true>,std::allocator<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>>>::__insert_node_at((uint64_t **)v3, (uint64_t)v23, v22, v25);
      }
      goto LABEL_54;
    }
LABEL_59:
    xpc_release(v9);
    xpc_release(v36);
  }
  xpc_release(v6);
  v27 = (void (*)(_QWORD *, uint64_t **))a1[3];
  v28 = a1[4];
  v29 = (_QWORD *)(a1[2] + (v28 >> 1));
  if ((v28 & 1) != 0)
    v27 = *(void (**)(_QWORD *, uint64_t **))(*v29 + v27);
  v27(v29, &v30);
  std::__tree<std::__value_type<std::pair<Technology,Type>,InputThreshold>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,InputThreshold>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,InputThreshold>>>::destroy((uint64_t)&v30, v31);
}

void sub_216A4B094(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, _QWORD *a11, uint64_t a12, xpc_object_t a13, xpc_object_t a14, uint64_t a15, xpc_object_t a16, uint64_t a17, xpc_object_t object, uint64_t a19, xpc_object_t a20)
{
  void *v20;

  xpc_release(object);
  object = 0;
  xpc_release(a16);
  xpc_release(v20);
  std::__tree<std::__value_type<std::pair<Technology,Type>,InputThreshold>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,InputThreshold>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,InputThreshold>>>::destroy((uint64_t)&a10, a11);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<void ctu::rest::property_sink_t<rest::rats>::bind_impl<void (EurekaCallCommandDriver::*&)(std::map<subscriber::SimSlot,RadioAccessTechnology> const&),EurekaCallCommandDriver>(ctu::RestModule &,EurekaCallCommandDriver *,void (EurekaCallCommandDriver::*&)(std::map<subscriber::SimSlot,RadioAccessTechnology> const&) &&,std::integral_constant<BOOL,false>)::{lambda(xpc::object const&)#1},std::allocator<xpc::object const&>,void ()(xpc)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void ctu::rest::property_sink_t<rest::rats>::bind_impl<void (EurekaCallCommandDriver::*&)(std::map<subscriber::SimSlot,RadioAccessTechnology> const&),EurekaCallCommandDriver>(ctu::RestModule &,EurekaCallCommandDriver *,void (EurekaCallCommandDriver::*&)(std::map<subscriber::SimSlot,RadioAccessTechnology> const&) &&,std::integral_constant<BOOL,false>)::{lambda(xpc::object const&)#1},std::allocator<xpc::object const&>,void ()(xpc)>::target_type()
{
}

void xpc::array::object_proxy::operator xpc::dict(_QWORD *a1, xpc_object_t xarray, size_t index)
{
  xpc_object_t value;
  xpc_object_t v5;
  xpc_object_t v6;

  value = xpc_array_get_value(xarray, index);
  if (value)
  {
    v5 = value;
    xpc_retain(value);
    *a1 = v5;
  }
  else
  {
    v5 = xpc_null_create();
    *a1 = v5;
    if (!v5)
    {
      v6 = xpc_null_create();
      v5 = 0;
      goto LABEL_8;
    }
  }
  if (MEMORY[0x2199FEDD0](v5) != MEMORY[0x24BDACFA0])
  {
    v6 = xpc_null_create();
LABEL_8:
    *a1 = v6;
    goto LABEL_9;
  }
  xpc_retain(v5);
LABEL_9:
  xpc_release(v5);
}

void std::__function::__func<ctu::rest::property_sink_t<rest::device_types>::bind(ctu::RestModule &)::{lambda(xpc::object const&)#1},std::allocator<ctu::rest::property_sink_t<rest::device_types>::bind(ctu::RestModule &)::{lambda(xpc::object const&)#1}>,void ()(xpc::object)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<ctu::rest::property_sink_t<rest::device_types>::bind(ctu::RestModule &)::{lambda(xpc::object const&)#1},std::allocator<ctu::rest::property_sink_t<rest::device_types>::bind(ctu::RestModule &)::{lambda(xpc::object const&)#1}>,void ()(xpc::object)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5E40D8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<ctu::rest::property_sink_t<rest::device_types>::bind(ctu::RestModule &)::{lambda(xpc::object const&)#1},std::allocator<ctu::rest::property_sink_t<rest::device_types>::bind(ctu::RestModule &)::{lambda(xpc::object const&)#1}>,void ()(xpc::object)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5E40D8;
  a2[1] = v2;
  return result;
}

void std::__function::__func<ctu::rest::property_sink_t<rest::device_types>::bind(ctu::RestModule &)::{lambda(xpc::object const&)#1},std::allocator<ctu::rest::property_sink_t<rest::device_types>::bind(ctu::RestModule &)::{lambda(xpc::object const&)#1}>,void ()(xpc::object)>::operator()(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;
  xpc_object_t v3;
  uint64_t v4;
  uint64_t **v5;
  void *count;
  xpc_object_t v7;
  size_t v8;
  xpc_object_t v9;
  uint64_t v10;
  uint64_t v11;
  xpc_object_t v12;
  int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t **v20;
  uint64_t **v21;
  int v22;
  uint64_t *v23;
  xpc_object_t v25;
  xpc_object_t v26;
  uint64_t v27;
  xpc_object_t v28;
  size_t index;
  xpc_object_t object;
  const char *v31;
  xpc_object_t v32;
  xpc_object_t v33;
  int v34;

  v2 = *(_QWORD *)(a1 + 8);
  v3 = (xpc_object_t)*a2;
  v4 = MEMORY[0x24BDACF78];
  if (*a2 && MEMORY[0x2199FEDD0](*a2) == v4)
    xpc_retain(v3);
  else
    v3 = xpc_null_create();
  v5 = (uint64_t **)(v2 + 8);
  std::__tree<std::__value_type<std::pair<Technology,Type>,InputThreshold>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,InputThreshold>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,InputThreshold>>>::destroy(v2, *(_QWORD **)(v2 + 8));
  *(_QWORD *)v2 = v2 + 8;
  *(_QWORD *)(v2 + 16) = 0;
  *(_QWORD *)(v2 + 8) = 0;
  if (MEMORY[0x2199FEDD0](v3) == v4)
  {
    object = v3;
    if (v3)
      xpc_retain(v3);
    else
      object = xpc_null_create();
    xpc::array::iterator::iterator(&v28, &object, 0);
    xpc_release(object);
    object = v3;
    if (v3)
      xpc_retain(v3);
    else
      object = xpc_null_create();
    if (MEMORY[0x2199FEDD0](v3) == v4)
      count = (void *)xpc_array_get_count(v3);
    else
      count = 0;
    xpc::array::iterator::iterator(&v26, &object, count);
    xpc_release(object);
    v7 = v28;
    v8 = index;
    if (index != v27 || v28 != v26)
    {
      while (1)
      {
        v25 = 0;
        xpc::array::object_proxy::operator xpc::dict(&v25, v7, v8);
        v9 = v25;
        v10 = MEMORY[0x2199FEDD0](v25);
        v11 = MEMORY[0x24BDACFA0];
        if (v10 == MEMORY[0x24BDACFA0])
          break;
LABEL_51:
        xpc_release(v25);
        v7 = v28;
        v8 = index + 1;
        index = v8;
        if (v8 == v27 && v28 == v26)
          goto LABEL_56;
      }
      if (v9)
      {
        xpc_retain(v9);
        v33 = v9;
      }
      else
      {
        v9 = xpc_null_create();
        v33 = v9;
        if (!v9)
        {
          v12 = xpc_null_create();
          v9 = 0;
          goto LABEL_25;
        }
      }
      if (MEMORY[0x2199FEDD0](v9) == v11)
      {
        xpc_retain(v9);
        v12 = v33;
        goto LABEL_26;
      }
      v12 = xpc_null_create();
LABEL_25:
      v33 = v12;
LABEL_26:
      if (MEMORY[0x2199FEDD0](v12) == v11)
      {
        object = &v33;
        v31 = "first";
        xpc::dict::object_proxy::operator xpc::object((uint64_t)&object, &v32);
        v15 = MEMORY[0x2199FEDD0](v32);
        v16 = MEMORY[0x24BDACFF0];
        v17 = MEMORY[0x24BDACF80];
        if (v15 == MEMORY[0x24BDACFF0])
        {
          v34 = 0;
          ctu::rest::detail::read_enum_string_value();
          v14 = v34;
        }
        else if (v15 == MEMORY[0x24BDACF80] || v15 == MEMORY[0x24BDACFD0] || v15 == MEMORY[0x24BDACFF8])
        {
          v14 = xpc::dyn_cast_or_default();
        }
        else
        {
          v14 = 0;
        }
        xpc_release(v32);
        object = &v33;
        v31 = "second";
        xpc::dict::object_proxy::operator xpc::object((uint64_t)&object, &v32);
        v18 = MEMORY[0x2199FEDD0](v32);
        if (v18 == v16)
        {
          v34 = 0;
          ctu::rest::detail::read_enum_string_value();
          v13 = v34;
        }
        else if (v18 == v17 || v18 == MEMORY[0x24BDACFD0] || v18 == MEMORY[0x24BDACFF8])
        {
          v13 = xpc::dyn_cast_or_default();
        }
        else
        {
          v13 = 0;
        }
        xpc_release(v32);
      }
      else
      {
        v13 = 0;
        v14 = 0;
      }
      xpc_release(v33);
      xpc_release(v9);
      v19 = *v5;
      v20 = (uint64_t **)(v2 + 8);
      v21 = (uint64_t **)(v2 + 8);
      if (*v5)
      {
        while (1)
        {
          while (1)
          {
            v21 = (uint64_t **)v19;
            v22 = *((_DWORD *)v19 + 7);
            if (v22 <= v14)
              break;
            v19 = *v21;
            v20 = v21;
            if (!*v21)
              goto LABEL_50;
          }
          if (v22 >= v14)
            break;
          v19 = v21[1];
          if (!v19)
          {
            v20 = v21 + 1;
            goto LABEL_50;
          }
        }
      }
      else
      {
LABEL_50:
        v23 = (uint64_t *)operator new(0x28uLL);
        *((_DWORD *)v23 + 7) = v14;
        *((_DWORD *)v23 + 8) = v13;
        std::__tree<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::less<unsigned short>,true>,std::allocator<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>>>::__insert_node_at((uint64_t **)v2, (uint64_t)v21, v20, v23);
      }
      goto LABEL_51;
    }
LABEL_56:
    xpc_release(v7);
    xpc_release(v28);
  }
  xpc_release(v3);
}

void sub_216A4B690(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t a9, xpc_object_t a10, uint64_t a11, xpc_object_t a12, uint64_t a13, xpc_object_t object, uint64_t a15, xpc_object_t a16, xpc_object_t a17)
{
  void *v17;

  xpc_release(object);
  xpc_release(a12);
  xpc_release(v17);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<ctu::rest::property_sink_t<rest::device_types>::bind(ctu::RestModule &)::{lambda(xpc::object const&)#1},std::allocator<ctu::rest::property_sink_t<rest::device_types>::bind(ctu::RestModule &)::{lambda(xpc::object const&)#1}>,void ()(xpc::object)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<ctu::rest::property_sink_t<rest::device_types>::bind(ctu::RestModule &)::{lambda(xpc::object const&)#1},std::allocator<ctu::rest::property_sink_t<rest::device_types>::bind(ctu::RestModule &)::{lambda(xpc::object const&)#1}>,void ()(xpc::object)>::target_type()
{
}

uint64_t qmi::MessageBase::applyTlv<vs::tlv::USSInfo,void({block_pointer})(vs::tlv::USSInfo const&)>(qmi::MessageBase *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  int v7;
  uint64_t v8;
  int v9;
  unint64_t v10;
  void *__p[2];
  __int128 v12;
  unint64_t v13;

  result = qmi::MessageBase::findTlvValue(a1);
  if (result)
  {
    v8 = result;
    v9 = v7;
    v13 = result;
    *(_OWORD *)__p = 0u;
    v12 = 0u;
    tlv::parseV<vs::tlv::USSInfo>(&v13, v7, __p);
    v10 = v13;
    if (v13)
      (*(void (**)(void))(*(_QWORD *)a3 + 16))();
    if (__p[1])
    {
      *(void **)&v12 = __p[1];
      operator delete(__p[1]);
    }
    if (v10)
      return 1;
    else
      return ((uint64_t (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, a2, v8, v9);
  }
  return result;
}

void sub_216A4B87C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t qmi::MessageBase::applyTlv<vs::tlv::UTF16Data,void({block_pointer})(vs::tlv::UTF16Data const&)>(qmi::MessageBase *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  int v7;
  uint64_t v8;
  int v9;
  unint64_t v10;
  void *__p;
  void *v12;
  uint64_t v13;
  unint64_t v14;

  result = qmi::MessageBase::findTlvValue(a1);
  if (result)
  {
    v8 = result;
    v9 = v7;
    v13 = 0;
    v14 = result;
    __p = 0;
    v12 = 0;
    tlv::parseV<vs::tlv::UTF16Data>(&v14, v7, (uint64_t)&__p);
    v10 = v14;
    if (v14)
      (*(void (**)(void))(*(_QWORD *)a3 + 16))();
    if (__p)
    {
      v12 = __p;
      operator delete(__p);
    }
    if (v10)
      return 1;
    else
      return ((uint64_t (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, a2, v8, v9);
  }
  return result;
}

void sub_216A4B95C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

unint64_t qmi::MessageBase::applyTlv<vs::tlv::FailureCause,void({block_pointer})(vs::tlv::FailureCause const&)>(qmi::MessageBase *a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;
  int v7;
  unint64_t v8;
  int v9;

  result = qmi::MessageBase::findTlvValue(a1);
  if (result)
  {
    v8 = result;
    v9 = v7;
    if (qmi::MessageBase::tryTlv<vs::tlv::FailureCause,void({block_pointer})(vs::tlv::FailureCause const&)>((uint64_t)a1, result, v7, a3))
    {
      return 1;
    }
    else
    {
      return ((uint64_t (*)(_QWORD, uint64_t, unint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, a2, v8, v9);
    }
  }
  return result;
}

BOOL qmi::MessageBase::tryTlv<vs::tlv::FailureCause,void({block_pointer})(vs::tlv::FailureCause const&)>(uint64_t a1, unint64_t a2, int a3, uint64_t a4)
{
  unint64_t v5;
  unint64_t v7;

  v7 = a2;
  tlv::parseV<vs::tlv::FailureCause>(&v7, a3);
  v5 = v7;
  if (v7)
    (*(void (**)(void))(*(_QWORD *)a4 + 16))();
  return v5 != 0;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN23EurekaCallCommandDriver17cancelUssdSessionEN10subscriber7SimSlotEE3__0EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  os_log_t *v2;
  NSObject *v3;
  uint64_t v5;
  int v6;
  int v7;
  uint64_t v8;
  __int16 v9;
  int v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v2 = **(os_log_t ***)(a1 + 32);
  v3 = *v2;
  if (*(_DWORD *)(a2 + 4))
  {
    if (os_log_type_enabled(*v2, OS_LOG_TYPE_ERROR))
    {
      v5 = qmi::asString();
      v6 = *(_DWORD *)(a2 + 4);
      v7 = 136315394;
      v8 = v5;
      v9 = 1024;
      v10 = v6;
      _os_log_error_impl(&dword_216897000, v3, OS_LOG_TYPE_ERROR, "USSD Session cancelling failed with error code %s (0x%x)", (uint8_t *)&v7, 0x12u);
    }
  }
  else if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v7) = 0;
    _os_log_impl(&dword_216897000, v3, OS_LOG_TYPE_DEFAULT, "#N USSD Session successfully cancelled", (uint8_t *)&v7, 2u);
  }
}

uint64_t __copy_helper_block_e8_32c100_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver17cancelUssdSessionEN10subscriber7SimSlotEE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c100_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver17cancelUssdSessionEN10subscriber7SimSlotEE3__0EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::cancelUssdSession(subscriber::SimSlot)::$_0,std::allocator<EurekaCallCommandDriver::cancelUssdSession(subscriber::SimSlot)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E4188;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::cancelUssdSession(subscriber::SimSlot)::$_0,std::allocator<EurekaCallCommandDriver::cancelUssdSession(subscriber::SimSlot)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E4188;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN2vs10CancelUSSD8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A4BC94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

char *qmi::MutableMessageBase::getTLV<vs::tlv::USSInfo>(_QWORD *a1)
{
  const void **v2;
  const void **v3;
  char **v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  v4 = (char **)(a1 + 1);
  if (v2 != v3)
  {
    while (*((_BYTE *)*v2 + 8) != 1)
    {
      if (++v2 == v3)
        goto LABEL_8;
    }
  }
  if (v2 == v3)
  {
LABEL_8:
    v7 = operator new();
    *(_BYTE *)(v7 + 8) = 1;
    *(_QWORD *)v7 = &off_24D5E4218;
    *(_DWORD *)(v7 + 16) = 0;
    v6 = v7 + 16;
    *(_QWORD *)(v7 + 32) = 0;
    *(_QWORD *)(v7 + 40) = 0;
    *(_QWORD *)(v7 + 24) = 0;
    v8 = a1[3];
    v9 = (uint64_t *)a1[2];
    if ((unint64_t)v9 >= v8)
    {
      v11 = ((char *)v9 - *v4) >> 3;
      if ((unint64_t)(v11 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v12 = v8 - (_QWORD)*v4;
      v13 = v12 >> 2;
      if (v12 >> 2 <= (unint64_t)(v11 + 1))
        v13 = v11 + 1;
      if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
        v14 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v14 = v13;
      if (v14)
        v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v14);
      else
        v15 = 0;
      v16 = (uint64_t *)&v15[8 * v11];
      v17 = &v15[8 * v14];
      *v16 = v7;
      v10 = v16 + 1;
      v19 = (char *)a1[1];
      v18 = (char *)a1[2];
      if (v18 != v19)
      {
        do
        {
          v20 = *((_QWORD *)v18 - 1);
          v18 -= 8;
          *--v16 = v20;
        }
        while (v18 != v19);
        v18 = *v4;
      }
      a1[1] = v16;
      a1[2] = v10;
      a1[3] = v17;
      if (v18)
        operator delete(v18);
    }
    else
    {
      *v9 = v7;
      v10 = v9 + 1;
    }
    a1[2] = v10;
  }
  else
  {
    if (!v5)
      __cxa_bad_cast();
    return v5 + 16;
  }
  return (char *)v6;
}

_QWORD *qmi::MutableMessageBase::TlvWrapper<vs::tlv::USSInfo>::~TlvWrapper(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24D5E4218;
  v2 = (void *)a1[3];
  if (v2)
  {
    a1[4] = v2;
    operator delete(v2);
  }
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<vs::tlv::USSInfo>::~TlvWrapper(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24D5E4218;
  v2 = (void *)a1[3];
  if (v2)
  {
    a1[4] = v2;
    operator delete(v2);
  }
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<vs::tlv::USSInfo>::getSize(uint64_t a1)
{
  return tlv::size<vs::tlv::USSInfo>(a1 + 16);
}

void *qmi::MutableMessageBase::TlvWrapper<vs::tlv::USSInfo>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  void *result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<vs::tlv::USSInfo>((_BYTE **)a2, a1 + 16);
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<vs::tlv::USSInfo>::clone(uint64_t a1)
{
  uint64_t v2;

  v2 = operator new();
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)v2 = &off_24D5E4218;
  *(_DWORD *)(v2 + 16) = *(_DWORD *)(a1 + 16);
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 40) = 0;
  *(_QWORD *)(v2 + 24) = 0;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>((_QWORD *)(v2 + 24), *(const void **)(a1 + 24), *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 32) - *(_QWORD *)(a1 + 24));
  return v2;
}

void sub_216A4BFAC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199FEAC4](v1, 0x1091C40970CA704);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN23EurekaCallCommandDriver17sendUSSDProcedureENSt3__112basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEEN10subscriber7SimSlotEE3__0EEOS1_OT__block_invoke(uint64_t a1, _QWORD *a2)
{
  uint64_t *v2;
  uint64_t v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  NSObject *v10;
  uint64_t v11;
  _QWORD v12[3];
  _BYTE buf[12];
  __int16 v14;
  int v15;
  char v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v2 = *(uint64_t **)(a1 + 32);
  v3 = *v2;
  v4 = *((_DWORD *)v2 + 2) - 1;
  v5 = a2[1];
  v12[0] = *a2;
  v12[1] = v5;
  v6 = a2[2];
  v12[2] = v6;
  if (v6)
  {
    v7 = (unint64_t *)(v6 + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  if (v4 >= 3)
    v4 = -1;
  if (v4 < 3)
    v9 = v4 + 1;
  else
    v9 = 0;
  v10 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v3 + 112) + 16))(*(_QWORD *)(v3 + 112), v9);
  if (HIDWORD(v12[0]))
  {
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = qmi::asString();
      v14 = 1024;
      v15 = HIDWORD(v12[0]);
      _os_log_error_impl(&dword_216897000, v10, OS_LOG_TYPE_ERROR, "Send USSD failed with error code %s (0x%x)", buf, 0x12u);
    }
  }
  else if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_216897000, v10, OS_LOG_TYPE_DEFAULT, "#I Successfully started USSD session from BB", buf, 2u);
  }
  v11 = *(_QWORD *)(v3 + 120);
  std::string::basic_string[abi:ne180100]<0>(buf, (char *)&unk_216AC4FCA);
  (*(void (**)(uint64_t, _BYTE *, BOOL, BOOL))(*(_QWORD *)v11 + 152))(v11, buf, HIDWORD(v12[0]) != 0, HIDWORD(v12[0]) == 0);
  if (v16 < 0)
    operator delete(*(void **)buf);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v12);
}

void sub_216A4C168(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
    operator delete(__p);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a10);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_32c158_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver17sendUSSDProcedureENS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEN10subscriber7SimSlotEE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c158_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver17sendUSSDProcedureENS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEN10subscriber7SimSlotEE3__0EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::sendUSSDProcedure(std::string,subscriber::SimSlot)::$_0,std::allocator<EurekaCallCommandDriver::sendUSSDProcedure(std::string,subscriber::SimSlot)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E4280;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::sendUSSDProcedure(std::string,subscriber::SimSlot)::$_0,std::allocator<EurekaCallCommandDriver::sendUSSDProcedure(std::string,subscriber::SimSlot)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E4280;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN2vs19OriginateUSSDNoWait8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A4C2C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN23EurekaCallCommandDriver17sendUSSDUserReplyENSt3__112basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEEN10subscriber7SimSlotEE3__0EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t *v2;
  NSObject *v3;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  uint64_t v9;
  __int16 v10;
  int v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v2 = *(uint64_t **)(a1 + 32);
  v3 = *(NSObject **)v2[1];
  if (*(_DWORD *)(a2 + 4))
  {
    v5 = *v2;
    if (os_log_type_enabled(*(os_log_t *)v2[1], OS_LOG_TYPE_ERROR))
    {
      v6 = qmi::asString();
      v7 = *(_DWORD *)(a2 + 4);
      v8 = 136315394;
      v9 = v6;
      v10 = 1024;
      v11 = v7;
      _os_log_error_impl(&dword_216897000, v3, OS_LOG_TYPE_ERROR, "USSD Answer failed with error code %s (0x%x). Cancelling USSD Session.", (uint8_t *)&v8, 0x12u);
    }
    (*(void (**)(_QWORD))(**(_QWORD **)(v5 + 120) + 208))(*(_QWORD *)(v5 + 120));
  }
  else if (os_log_type_enabled(*(os_log_t *)v2[1], OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v8) = 0;
    _os_log_impl(&dword_216897000, v3, OS_LOG_TYPE_DEFAULT, "#N USSD Answer successfully completed", (uint8_t *)&v8, 2u);
  }
}

uint64_t __copy_helper_block_e8_32c158_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver17sendUSSDUserReplyENS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEN10subscriber7SimSlotEE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c158_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver17sendUSSDUserReplyENS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEN10subscriber7SimSlotEE3__0EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::sendUSSDUserReply(std::string,subscriber::SimSlot)::$_0,std::allocator<EurekaCallCommandDriver::sendUSSDUserReply(std::string,subscriber::SimSlot)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E4328;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::sendUSSDUserReply(std::string,subscriber::SimSlot)::$_0,std::allocator<EurekaCallCommandDriver::sendUSSDUserReply(std::string,subscriber::SimSlot)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E4328;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN2vs10AnswerUSSD8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A4C550(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void std::allocate_shared[abi:ne180100]<EurekaC2KCallFormatter,std::allocator<EurekaC2KCallFormatter>,std::shared_ptr<Registry const> const&,dispatch::queue const&,std::shared_ptr<EurekaCallCommandDriver::DelegateBase> &,void>(_QWORD *a1, Registry **a2, dispatch_object_t *a3, uint64_t a4, std::__shared_weak_count *a5)
{
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  unint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  std::__shared_weak_count *v22;
  NSObject *v23;
  void *__p;
  char v25;
  uint64_t v26[2];

  v10 = operator new(0x60uLL);
  v11 = v10;
  v10[1] = 0;
  v10[2] = 0;
  *v10 = &off_24D5E43A0;
  v12 = v10 + 3;
  if (a5)
  {
    p_shared_owners = (unint64_t *)&a5->__shared_owners_;
    do
      v14 = __ldxr(p_shared_owners);
    while (__stxr(v14 + 1, p_shared_owners));
    do
      v15 = __ldxr(p_shared_owners);
    while (__stxr(v15 + 1, p_shared_owners));
  }
  v26[0] = a4;
  v26[1] = (uint64_t)a5;
  EurekaCallFormatter::EurekaCallFormatter<EurekaCallCommandDriver::DelegateBase>(v10 + 3, a2, (uint64_t)"EurekaC2KCallFormatter", v26);
  if (a5)
  {
    v16 = (unint64_t *)&a5->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))a5->__on_zero_shared)(a5);
      std::__shared_weak_count::__release_weak(a5);
    }
  }
  v11[3] = &off_24D5C7078;
  std::string::basic_string[abi:ne180100]<0>(&__p, (char *)v11[9]);
  v23 = *a3;
  if (*a3)
    dispatch_retain(*a3);
  ctu::RestModule::RestModule();
  if (v23)
    dispatch_release(v23);
  if (v25 < 0)
    operator delete(__p);
  Registry::createRestModuleOneTimeUseConnection(*a2);
  ctu::RestModule::connect();
  if (v22)
  {
    v18 = (unint64_t *)&v22->__shared_owners_;
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)())v22->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v22);
    }
  }
  if (a5)
  {
    v20 = (unint64_t *)&a5->__shared_owners_;
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))a5->__on_zero_shared)(a5);
      std::__shared_weak_count::__release_weak(a5);
    }
  }
  *a1 = v12;
  a1[1] = v11;
}

void sub_216A4C770(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12, uint64_t a13, dispatch_object_t object, dispatch_object_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22)
{
  std::__shared_weak_count *v22;
  EurekaCallFormatter *v23;
  uint64_t v24;
  void *v26;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a12);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v24);
  EurekaCallFormatter::~EurekaCallFormatter(v23);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a10);
  std::__shared_weak_count::~__shared_weak_count(v22);
  operator delete(v26);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<EurekaC2KCallFormatter>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E43A0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<EurekaC2KCallFormatter>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E43A0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

uint64_t std::__shared_ptr_emplace<EurekaC2KCallFormatter>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

_QWORD *EurekaCallFormatter::EurekaCallFormatter<EurekaCallCommandDriver::DelegateBase>(_QWORD *a1, _QWORD *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  unint64_t v17;
  _QWORD *v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  unint64_t *v22;
  unint64_t v23;
  _BYTE v25[16];
  _BYTE v26[8];

  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)v25, (const char *)*MEMORY[0x24BDC3E90], (const char *)*MEMORY[0x24BDC3DD0]);
  ctu::OsLogLogger::OsLogLogger();
  ctu::OsLogLogger::OsLogLogger();
  MEMORY[0x2199FDF6C](v26);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v25);
  *a1 = off_24D5D3780;
  a1[2] = 0;
  a1[3] = 0;
  a1[4] = *a2;
  v8 = a2[1];
  a1[5] = v8;
  if (v8)
  {
    v9 = (unint64_t *)(v8 + 8);
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }
  a1[6] = a3;
  v11 = (_QWORD *)operator new();
  v12 = v11;
  v13 = *a4;
  v14 = (std::__shared_weak_count *)a4[1];
  if (v14)
  {
    p_shared_owners = (unint64_t *)&v14->__shared_owners_;
    do
      v16 = __ldxr(p_shared_owners);
    while (__stxr(v16 + 1, p_shared_owners));
    *v11 = &off_24D5E4468;
    v11[1] = v13;
    v11[2] = v14;
    do
      v17 = __ldxr(p_shared_owners);
    while (__stxr(v17 + 1, p_shared_owners));
  }
  else
  {
    *v11 = &off_24D5E4468;
    v11[1] = v13;
    v11[2] = 0;
  }
  v18 = (_QWORD *)operator new();
  *v18 = &off_24D5E43F0;
  v18[1] = 0;
  v18[2] = 0;
  v18[3] = v12;
  v19 = (std::__shared_weak_count *)a1[3];
  a1[2] = v12;
  a1[3] = v18;
  if (v19)
  {
    v20 = (unint64_t *)&v19->__shared_owners_;
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }
  if (v14)
  {
    v22 = (unint64_t *)&v14->__shared_owners_;
    do
      v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
  return a1;
}

void sub_216A4CA34(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  va_list va;

  va_start(va, a2);
  (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v4);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v3);
  MEMORY[0x2199FDF6C](v2);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<EurekaCallFormatter::FormatterDelegate<EurekaCallCommandDriver::DelegateBase> *,std::shared_ptr<EurekaCallFormatter::DelegateBase>::__shared_ptr_default_delete<EurekaCallFormatter::DelegateBase,EurekaCallFormatter::FormatterDelegate<EurekaCallCommandDriver::DelegateBase>>,std::allocator<EurekaCallFormatter::FormatterDelegate<EurekaCallCommandDriver::DelegateBase>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

uint64_t std::__shared_ptr_pointer<EurekaCallFormatter::FormatterDelegate<EurekaCallCommandDriver::DelegateBase> *,std::shared_ptr<EurekaCallFormatter::DelegateBase>::__shared_ptr_default_delete<EurekaCallFormatter::DelegateBase,EurekaCallFormatter::FormatterDelegate<EurekaCallCommandDriver::DelegateBase>>,std::allocator<EurekaCallFormatter::FormatterDelegate<EurekaCallCommandDriver::DelegateBase>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t std::__shared_ptr_pointer<EurekaCallFormatter::FormatterDelegate<EurekaCallCommandDriver::DelegateBase> *,std::shared_ptr<EurekaCallFormatter::DelegateBase>::__shared_ptr_default_delete<EurekaCallFormatter::DelegateBase,EurekaCallFormatter::FormatterDelegate<EurekaCallCommandDriver::DelegateBase>>,std::allocator<EurekaCallFormatter::FormatterDelegate<EurekaCallCommandDriver::DelegateBase>>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

_QWORD *EurekaCallFormatter::FormatterDelegate<EurekaCallCommandDriver::DelegateBase>::~FormatterDelegate(_QWORD *a1)
{
  *a1 = &off_24D5E4468;
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)(a1 + 1));
  return a1;
}

void EurekaCallFormatter::FormatterDelegate<EurekaCallCommandDriver::DelegateBase>::~FormatterDelegate(_QWORD *a1)
{
  *a1 = &off_24D5E4468;
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)(a1 + 1));
  JUMPOUT(0x2199FEAC4);
}

uint64_t EurekaCallFormatter::FormatterDelegate<EurekaCallCommandDriver::DelegateBase>::handleVoiceDialCallResp(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 16))(result);
  return result;
}

uint64_t EurekaCallFormatter::FormatterDelegate<EurekaCallCommandDriver::DelegateBase>::handleCallActiveInd(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 48))(result);
  return result;
}

uint64_t EurekaCallFormatter::FormatterDelegate<EurekaCallCommandDriver::DelegateBase>::handleCallHeldInd(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 104))(result);
  return result;
}

uint64_t EurekaCallFormatter::FormatterDelegate<EurekaCallCommandDriver::DelegateBase>::handleCallEndInd(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)result + 64))(result, a2, 0);
  return result;
}

uint64_t EurekaCallFormatter::FormatterDelegate<EurekaCallCommandDriver::DelegateBase>::handleMergedCalls(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 112))(result);
  return result;
}

uint64_t EurekaCallFormatter::FormatterDelegate<EurekaCallCommandDriver::DelegateBase>::handleMergeCallsFailed(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 120))(result);
  return result;
}

uint64_t EurekaCallFormatter::FormatterDelegate<EurekaCallCommandDriver::DelegateBase>::getTrafficChannelId(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 8);
  if (v1)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 224))(v1);
  else
    return *MEMORY[0x24BDC39A8];
}

uint64_t EurekaCallFormatter::FormatterDelegate<EurekaCallCommandDriver::DelegateBase>::handleCallHoldFailure(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 232))(result);
  return result;
}

uint64_t EurekaCallFormatter::FormatterDelegate<EurekaCallCommandDriver::DelegateBase>::handleCallAnswerFailure(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 240))(result);
  return result;
}

uint64_t EurekaCallFormatter::FormatterDelegate<EurekaCallCommandDriver::DelegateBase>::getNumberOfCurrentCalls(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 248))(result);
  return result;
}

uint64_t EurekaCallFormatter::FormatterDelegate<EurekaCallCommandDriver::DelegateBase>::notifyCallCapabilities(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 192))(result);
  return result;
}

uint64_t EurekaCallFormatter::FormatterDelegate<EurekaCallCommandDriver::DelegateBase>::setCallCapability(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 256))(result);
  return result;
}

{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 264))(result);
  return result;
}

uint64_t EurekaCallFormatter::FormatterDelegate<EurekaCallCommandDriver::DelegateBase>::handleVoicePrivacySet(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 272))(result);
  return result;
}

uint64_t EurekaCallFormatter::FormatterDelegate<EurekaCallCommandDriver::DelegateBase>::handlePrivateConversation(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 136))(result);
  return result;
}

uint64_t EurekaCallFormatter::FormatterDelegate<EurekaCallCommandDriver::DelegateBase>::setExpectDisconnectionOnAllCalls(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 280))(result);
  return result;
}

uint64_t EurekaCallFormatter::FormatterDelegate<EurekaCallCommandDriver::DelegateBase>::handleCallDialedAndMediaInitializedInd(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 32))(result);
  return result;
}

uint64_t EurekaCallFormatter::FormatterDelegate<EurekaCallCommandDriver::DelegateBase>::handleCallDialedInd(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 24))(result);
  return result;
}

void std::allocate_shared[abi:ne180100]<EurekaGSMCallFormatter,std::allocator<EurekaGSMCallFormatter>,std::shared_ptr<Registry const> const&,dispatch::queue const&,std::shared_ptr<EurekaCallCommandDriver::DelegateBase> &,void>(_QWORD *a1, _QWORD *a2, uint64_t a3, std::__shared_weak_count *a4)
{
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  uint64_t v18[2];

  v8 = operator new(0x50uLL);
  v9 = v8;
  v8[1] = 0;
  v8[2] = 0;
  *v8 = &off_24D5E4530;
  v10 = v8 + 3;
  if (a4)
  {
    p_shared_owners = (unint64_t *)&a4->__shared_owners_;
    do
      v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
    do
      v13 = __ldxr(p_shared_owners);
    while (__stxr(v13 + 1, p_shared_owners));
  }
  v18[0] = a3;
  v18[1] = (uint64_t)a4;
  EurekaCallFormatter::EurekaCallFormatter<EurekaCallCommandDriver::DelegateBase>(v8 + 3, a2, (uint64_t)"EurekaGSMCallFormatter", v18);
  if (a4)
  {
    v14 = (unint64_t *)&a4->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))a4->__on_zero_shared)(a4);
      std::__shared_weak_count::__release_weak(a4);
    }
  }
  *v10 = &off_24D5C9DF8;
  if (a4)
  {
    v16 = (unint64_t *)&a4->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))a4->__on_zero_shared)(a4);
      std::__shared_weak_count::__release_weak(a4);
    }
  }
  *a1 = v10;
  a1[1] = v9;
}

void sub_216A4CE6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::__shared_weak_count *v11;
  void *v13;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::__shared_weak_count::~__shared_weak_count(v11);
  operator delete(v13);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<EurekaGSMCallFormatter>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E4530;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<EurekaGSMCallFormatter>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E4530;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

uint64_t std::__shared_ptr_emplace<EurekaGSMCallFormatter>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void ctu::SharedSynchronizable<CallCommandDriver>::execute_wrapped(uint64_t *a1, uint64_t a2)
{
  std::__shared_weak_count *v3;
  uint64_t v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  NSObject *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t v14;
  _QWORD block[6];
  std::__shared_weak_count *v16;

  v3 = (std::__shared_weak_count *)a1[1];
  if (!v3 || (v5 = *a1, (v6 = std::__shared_weak_count::lock(v3)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v7 = v6;
  v8 = a1[2];
  block[0] = MEMORY[0x24BDAC760];
  block[1] = 1174405120;
  block[2] = ___ZNK3ctu20SharedSynchronizableI17CallCommandDriverE15execute_wrappedEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_24D5E4578;
  block[5] = v5;
  v16 = v7;
  p_shared_owners = (unint64_t *)&v7->__shared_owners_;
  do
    v10 = __ldxr(p_shared_owners);
  while (__stxr(v10 + 1, p_shared_owners));
  block[4] = a2;
  dispatch_async(v8, block);
  v11 = v16;
  if (v16)
  {
    v12 = (unint64_t *)&v16->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  do
    v14 = __ldaxr(p_shared_owners);
  while (__stlxr(v14 - 1, p_shared_owners));
  if (!v14)
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
}

uint64_t ___ZNK3ctu20SharedSynchronizableI17CallCommandDriverE15execute_wrappedEU13block_pointerFvvE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t __copy_helper_block_e8_40c46_ZTSNSt3__110shared_ptrIK17CallCommandDriverEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 48) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_40c46_ZTSNSt3__110shared_ptrIK17CallCommandDriverEE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 40);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN23EurekaCallCommandDriver4dialE8CallInfoE3__1EEOS1_OT__block_invoke(uint64_t a1, uint64_t *a2)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  int64_t v7;
  uint64_t v8;
  dispatch_time_t v9;
  NSObject *v10;
  std::__shared_weak_count *v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD block[3];
  _QWORD *v27;
  uint64_t v28;
  uint64_t v29;
  std::__shared_weak_count *v30;
  _BYTE v31[24];
  _BYTE *v32;
  __int128 v33;
  _QWORD v34[4];

  v34[3] = *MEMORY[0x24BDAC8D0];
  v2 = *(uint64_t **)(a1 + 32);
  v3 = a2[1];
  v23 = *a2;
  v24 = v3;
  v4 = a2[2];
  v25 = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  v7 = v2[9];
  if (!v7)
  {
    std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100]((uint64_t)block, (uint64_t)(v2 + 4));
    if (!v27)
      std::__throw_bad_function_call[abi:ne180100]();
    (*(void (**)(_QWORD *, uint64_t *))(*v27 + 48))(v27, &v23);
    v18 = v27;
    if (v27 == block)
    {
      v19 = 4;
      v18 = block;
    }
    else
    {
      if (!v27)
        goto LABEL_27;
      v19 = 5;
    }
    (*(void (**)(void))(*v18 + 8 * v19))();
    goto LABEL_27;
  }
  v8 = *v2;
  v9 = dispatch_time(0, v7);
  v10 = *(NSObject **)(v8 + 24);
  block[0] = MEMORY[0x24BDAC760];
  block[1] = 1174405120;
  block[2] = ___ZZN23EurekaCallCommandDriver4dialE8CallInfoENK3__1clEN3qmi12ResponseBaseE_block_invoke;
  v27 = &__block_descriptor_tmp_177_0;
  v28 = v2[1];
  v29 = v2[2];
  v11 = (std::__shared_weak_count *)v2[3];
  v30 = v11;
  if (v11)
  {
    p_shared_owners = (unint64_t *)&v11->__shared_owners_;
    do
      v13 = __ldxr(p_shared_owners);
    while (__stxr(v13 + 1, p_shared_owners));
  }
  std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100]((uint64_t)v31, (uint64_t)(v2 + 4));
  v33 = *((_OWORD *)v2 + 4);
  v34[0] = v23;
  v34[1] = v24;
  v34[2] = v25;
  if (v25)
  {
    v14 = (unint64_t *)(v25 + 8);
    do
      v15 = __ldxr(v14);
    while (__stxr(v15 + 1, v14));
  }
  dispatch_after(v9, v10, block);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v34);
  v16 = v32;
  if (v32 == v31)
  {
    v17 = 4;
    v16 = v31;
    goto LABEL_19;
  }
  if (v32)
  {
    v17 = 5;
LABEL_19:
    (*(void (**)(void))(*v16 + 8 * v17))();
  }
  v20 = v30;
  if (v30)
  {
    v21 = (unint64_t *)&v30->__shared_owners_;
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
LABEL_27:
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&v23);
}

void sub_216A4D25C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_32c73_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver4dialE8CallInfoE3__1EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c73_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver4dialE8CallInfoE3__1EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::dial(CallInfo)::$_1,std::allocator<EurekaCallCommandDriver::dial(CallInfo)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E45E8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::dial(CallInfo)::$_1,std::allocator<EurekaCallCommandDriver::dial(CallInfo)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E45E8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

uint64_t std::__shared_ptr_emplace<EurekaCallCommandDriver::dial(CallInfo)::$_1,std::allocator<EurekaCallCommandDriver::dial(CallInfo)::$_1>>::__on_zero_shared(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  v2 = (_QWORD *)(a1 + 56);
  v3 = *(_QWORD **)(a1 + 80);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 40);
}

void ___ZNO3qmi6Client9SendProxy8callbackINS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A4D41C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_216A4D534(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  _Unwind_Resume(exception_object);
}

uint64_t __copy_helper_block_e8_40c31_ZTS25EurekaVoiceRequestMessage104c25_ZTSKN3qmi12ResponseBaseE(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  uint64_t result;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;

  v4 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 48) = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  result = std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100](a1 + 56, a2 + 56);
  *(_OWORD *)(a1 + 88) = *(_OWORD *)(a2 + 88);
  *(_QWORD *)(a1 + 104) = *(_QWORD *)(a2 + 104);
  v8 = *(_QWORD *)(a2 + 120);
  *(_QWORD *)(a1 + 112) = *(_QWORD *)(a2 + 112);
  *(_QWORD *)(a1 + 120) = v8;
  if (v8)
  {
    v9 = (unint64_t *)(v8 + 8);
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }
  return result;
}

void sub_216A4D600(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

uint64_t __destroy_helper_block_e8_40c31_ZTS25EurekaVoiceRequestMessage104c25_ZTSKN3qmi12ResponseBaseE(_QWORD *a1)
{
  _QWORD *v2;
  uint64_t v3;

  qmi::MessageBase::~MessageBase((qmi::MessageBase *)(a1 + 13));
  v2 = (_QWORD *)a1[10];
  if (v2 == a1 + 7)
  {
    v3 = 4;
    v2 = a1 + 7;
    goto LABEL_5;
  }
  if (v2)
  {
    v3 = 5;
LABEL_5:
    (*(void (**)(void))(*v2 + 8 * v3))();
  }
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)(a1 + 5));
}

uint64_t std::__function::__func<EurekaCallCommandDriver::dial(CallInfo)::$_2,std::allocator<EurekaCallCommandDriver::dial(CallInfo)::$_2>,void ()(vs::VoiceDialCall::Response const&)>::~__func(uint64_t a1)
{
  *(_QWORD *)a1 = &off_24D5E4690;
  CallInfo::~CallInfo((void **)(a1 + 16));
  return a1;
}

void std::__function::__func<EurekaCallCommandDriver::dial(CallInfo)::$_2,std::allocator<EurekaCallCommandDriver::dial(CallInfo)::$_2>,void ()(vs::VoiceDialCall::Response const&)>::~__func(uint64_t a1)
{
  *(_QWORD *)a1 = &off_24D5E4690;
  CallInfo::~CallInfo((void **)(a1 + 16));
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<EurekaCallCommandDriver::dial(CallInfo)::$_2,std::allocator<EurekaCallCommandDriver::dial(CallInfo)::$_2>,void ()(vs::VoiceDialCall::Response const&)>::__clone(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;

  v2 = operator new(0x1B0uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *v2 = &off_24D5E4690;
  v2[1] = v3;
  CallInfo::CallInfo((CallInfo *)(v2 + 2), (const CallInfo *)(a1 + 16));
  *((_DWORD *)v2 + 106) = *(_DWORD *)(a1 + 424);
  return v2;
}

void sub_216A4D728(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__function::__func<EurekaCallCommandDriver::dial(CallInfo)::$_2,std::allocator<EurekaCallCommandDriver::dial(CallInfo)::$_2>,void ()(vs::VoiceDialCall::Response const&)>::__clone(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  v4 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)a2 = &off_24D5E4690;
  *(_QWORD *)(a2 + 8) = v4;
  CallInfo::CallInfo((CallInfo *)(a2 + 16), (const CallInfo *)(a1 + 16));
  *(_DWORD *)(a2 + 424) = *(_DWORD *)(a1 + 424);
}

void std::__function::__func<EurekaCallCommandDriver::dial(CallInfo)::$_2,std::allocator<EurekaCallCommandDriver::dial(CallInfo)::$_2>,void ()(vs::VoiceDialCall::Response const&)>::destroy(uint64_t a1)
{
  CallInfo::~CallInfo((void **)(a1 + 16));
}

void std::__function::__func<EurekaCallCommandDriver::dial(CallInfo)::$_2,std::allocator<EurekaCallCommandDriver::dial(CallInfo)::$_2>,void ()(vs::VoiceDialCall::Response const&)>::destroy_deallocate(void **a1)
{
  CallInfo::~CallInfo(a1 + 2);
  operator delete(a1);
}

const void **std::__function::__func<EurekaCallCommandDriver::dial(CallInfo)::$_2,std::allocator<EurekaCallCommandDriver::dial(CallInfo)::$_2>,void ()(vs::VoiceDialCall::Response const&)>::operator()(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v4;
  const void *v6;

  v4 = *(_QWORD *)(a1 + 8);
  ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::SharedRef(&v6, (const void **)(a1 + 16));
  EurekaCallCommandDriver::handleNormalVoiceDialResp(v4, a2, &v6, *(unsigned int *)(a1 + 424));
  return ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::~SharedRef(&v6);
}

void sub_216A4D80C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::~SharedRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<EurekaCallCommandDriver::dial(CallInfo)::$_2,std::allocator<EurekaCallCommandDriver::dial(CallInfo)::$_2>,void ()(vs::VoiceDialCall::Response const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<EurekaCallCommandDriver::dial(CallInfo)::$_2,std::allocator<EurekaCallCommandDriver::dial(CallInfo)::$_2>,void ()(vs::VoiceDialCall::Response const&)>::target_type()
{
}

void qmi::MutableMessageBase::TlvWrapper<vs::tlv::EmergencyCategory>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<vs::tlv::EmergencyCategory>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<vs::tlv::EmergencyCategory>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<vs::tlv::EmergencyCategory>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E4728;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<vs::tlv::ClirType>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<vs::tlv::ClirType>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<vs::tlv::ClirType>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<vs::tlv::ClirType>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E4778;
  return result;
}

uint64_t ___ZNO3qmi12ClientRouter9SendProxy8callbackIRNSt3__18functionIFvRKN2vs13VoiceDialCall8ResponseEEEEEEOS1_OT__block_invoke(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 24);
  if (!v1)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 48))(v1);
}

uint64_t __copy_helper_block_e8_32c75_ZTSNSt3__110shared_ptrINS_8functionIFvRKN2vs13VoiceDialCall8ResponseEEEEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c75_ZTSNSt3__110shared_ptrINS_8functionIFvRKN2vs13VoiceDialCall8ResponseEEEEEE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<std::function<void ()(vs::VoiceDialCall::Response const&)>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E47E0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<std::function<void ()(vs::VoiceDialCall::Response const&)>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E47E0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__shared_ptr_emplace<std::function<void ()(vs::VoiceDialCall::Response const&)>>::__on_zero_shared(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *result;
  uint64_t v3;

  v1 = (_QWORD *)(a1 + 24);
  result = *(_QWORD **)(a1 + 48);
  if (result == v1)
  {
    v3 = 4;
    result = v1;
  }
  else
  {
    if (!result)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN2vs13VoiceDialCall8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke_0(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BYTE v3[24];

  v2 = *(_QWORD *)(a1 + 32);
  cast_message_type<vs::VoiceDialCall::Response const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_216A4DAFC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<CallCommandDriver>::execute_wrapped<EurekaCallCommandDriver::updateCallInfoFromSRVCC(CallInfo const&)::$_0>(EurekaCallCommandDriver::updateCallInfoFromSRVCC(CallInfo const&)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<EurekaCallCommandDriver::updateCallInfoFromSRVCC(CallInfo const&)::$_0,dispatch_queue_s *::default_delete<EurekaCallCommandDriver::updateCallInfoFromSRVCC(CallInfo const&)::$_0>>)::{lambda(void *)#1}::__invoke(uint64_t *a1)
{
  uint64_t v1;
  uint64_t *v3;
  uint64_t v4;

  v1 = *a1;
  v3 = a1;
  v4 = v1;
  (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(*(_QWORD *)v1 + 120) + 168))(*(_QWORD *)(*(_QWORD *)v1 + 120), v1 + 8);
  std::unique_ptr<EurekaCallCommandDriver::updateCallInfoFromSRVCC(CallInfo const&)::$_0,std::default_delete<EurekaCallCommandDriver::updateCallInfoFromSRVCC(CallInfo const&)::$_0>>::~unique_ptr[abi:ne180100](&v4);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v3);
}

void sub_216A4DB5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  std::unique_ptr<EurekaCallCommandDriver::updateCallInfoFromSRVCC(CallInfo const&)::$_0,std::default_delete<EurekaCallCommandDriver::updateCallInfoFromSRVCC(CallInfo const&)::$_0>>::~unique_ptr[abi:ne180100](&a10);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

uint64_t *std::unique_ptr<EurekaCallCommandDriver::updateCallInfoFromSRVCC(CallInfo const&)::$_0,std::default_delete<EurekaCallCommandDriver::updateCallInfoFromSRVCC(CallInfo const&)::$_0>>::~unique_ptr[abi:ne180100](uint64_t *a1)
{
  uint64_t v2;

  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    CallInfo::~CallInfo((void **)(v2 + 8));
    MEMORY[0x2199FEAC4](v2, 0x1072C402A3CAFC1);
  }
  return a1;
}

void std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::destroy(void **a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::destroy(*a1);
    std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::destroy(a1[1]);
    CallInfo::~CallInfo(a1 + 5);
    operator delete(a1);
  }
}

uint64_t **std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>(uint64_t **a1, unsigned __int8 a2, char *a3)
{
  uint64_t *v5;
  uint64_t **v6;
  uint64_t **v7;
  uint64_t **v8;
  unsigned int v9;
  char *v10;
  _QWORD v12[2];
  uint64_t v13;

  v6 = a1 + 1;
  v5 = a1[1];
  v7 = a1 + 1;
  v8 = a1 + 1;
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v8 = (uint64_t **)v5;
        v9 = *((unsigned __int8 *)v5 + 32);
        if (v9 <= a2)
          break;
        v5 = *v8;
        v7 = v8;
        if (!*v8)
          goto LABEL_8;
      }
      if (v9 >= a2)
        break;
      v5 = v8[1];
      if (!v5)
      {
        v7 = v8 + 1;
        goto LABEL_8;
      }
    }
  }
  else
  {
LABEL_8:
    v13 = 0;
    v10 = (char *)operator new(0x1C0uLL);
    v12[0] = v10;
    v12[1] = v6;
    v10[32] = *a3;
    *(_OWORD *)(v10 + 56) = 0u;
    *(_OWORD *)(v10 + 72) = 0u;
    *(_OWORD *)(v10 + 88) = 0u;
    *(_OWORD *)(v10 + 104) = 0u;
    *(_OWORD *)(v10 + 120) = 0u;
    *(_OWORD *)(v10 + 136) = 0u;
    *(_OWORD *)(v10 + 152) = 0u;
    *(_OWORD *)(v10 + 168) = 0u;
    *(_OWORD *)(v10 + 184) = 0u;
    *(_OWORD *)(v10 + 200) = 0u;
    *(_OWORD *)(v10 + 216) = 0u;
    *(_OWORD *)(v10 + 232) = 0u;
    *(_OWORD *)(v10 + 248) = 0u;
    *(_OWORD *)(v10 + 40) = 0u;
    *((_QWORD *)v10 + 55) = 0;
    *(_OWORD *)(v10 + 296) = 0u;
    *(_OWORD *)(v10 + 312) = 0u;
    *(_OWORD *)(v10 + 328) = 0u;
    *(_OWORD *)(v10 + 344) = 0u;
    *(_OWORD *)(v10 + 360) = 0u;
    *(_OWORD *)(v10 + 376) = 0u;
    *(_OWORD *)(v10 + 392) = 0u;
    *(_OWORD *)(v10 + 408) = 0u;
    *(_OWORD *)(v10 + 424) = 0u;
    *(_OWORD *)(v10 + 264) = 0u;
    *(_OWORD *)(v10 + 280) = 0u;
    CallInfo::CallInfo((CallInfo *)(v10 + 40));
    LOBYTE(v13) = 1;
    std::__tree<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::less<unsigned short>,true>,std::allocator<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>>>::__insert_node_at(a1, (uint64_t)v8, v7, (uint64_t *)v10);
    v12[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<unsigned char,CallInfo>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<unsigned char,CallInfo>,void *>>>>::reset[abi:ne180100]((uint64_t)v12);
    return (uint64_t **)v10;
  }
  return v8;
}

void sub_216A4DD44(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__tree_node<std::__value_type<unsigned char,CallInfo>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<unsigned char,CallInfo>,void *>>>>::reset[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::unique_ptr<std::__tree_node<std::__value_type<unsigned char,CallInfo>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<unsigned char,CallInfo>,void *>>>>::reset[abi:ne180100](uint64_t a1)
{
  void **v1;

  v1 = *(void ***)a1;
  *(_QWORD *)a1 = 0;
  if (v1)
  {
    if (*(_BYTE *)(a1 + 16))
      CallInfo::~CallInfo(v1 + 5);
    operator delete(v1);
  }
}

_QWORD *std::__tree<std::__value_type<unsigned char,BOOL>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,BOOL>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,BOOL>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>(uint64_t **a1, unsigned __int8 a2, _BYTE *a3)
{
  unsigned __int8 *v5;
  uint64_t **v6;
  _QWORD *v7;
  unsigned int v8;
  _QWORD *v9;
  uint64_t *v10;
  uint64_t *v11;

  v6 = a1 + 1;
  v5 = (unsigned __int8 *)a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v7 = v5;
        v8 = v5[25];
        if (v8 <= a2)
          break;
        v5 = (unsigned __int8 *)*v7;
        v6 = (uint64_t **)v7;
        if (!*v7)
          goto LABEL_9;
      }
      if (v8 >= a2)
        break;
      v5 = (unsigned __int8 *)v7[1];
      if (!v5)
      {
        v6 = (uint64_t **)(v7 + 1);
        goto LABEL_9;
      }
    }
  }
  else
  {
    v7 = a1 + 1;
LABEL_9:
    v9 = v7;
    v7 = operator new(0x20uLL);
    *((_BYTE *)v7 + 25) = *a3;
    *((_BYTE *)v7 + 26) = 0;
    *v7 = 0;
    v7[1] = 0;
    v7[2] = v9;
    *v6 = v7;
    v10 = (uint64_t *)**a1;
    v11 = v7;
    if (v10)
    {
      *a1 = v10;
      v11 = *v6;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN23EurekaCallCommandDriver17endCallDueToSRVCCE8CallInfoE3__0EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  NSObject *v2;
  int v3;
  uint64_t v4;
  uint64_t v5;

  v5 = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)(a2 + 4))
  {
    v2 = ***(NSObject ****)(a1 + 32);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      v3 = 136315138;
      v4 = qmi::asString();
      _os_log_error_impl(&dword_216897000, v2, OS_LOG_TYPE_ERROR, "Got error when trying to end call due to handover. Error: %s", (uint8_t *)&v3, 0xCu);
    }
  }
}

uint64_t __copy_helper_block_e8_32c87_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver17endCallDueToSRVCCE8CallInfoE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c87_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver17endCallDueToSRVCCE8CallInfoE3__0EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::endCallDueToSRVCC(CallInfo)::$_0,std::allocator<EurekaCallCommandDriver::endCallDueToSRVCC(CallInfo)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E4888;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::endCallDueToSRVCC(CallInfo)::$_0,std::allocator<EurekaCallCommandDriver::endCallDueToSRVCC(CallInfo)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E4888;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN2vs7EndCall8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke_0(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BYTE v3[24];

  v2 = *(_QWORD *)(a1 + 32);
  cast_message_type<vs::EndCall::Response const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_216A4DFD8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN23EurekaCallCommandDriver11endThisCallE8CallInfoE3__0EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  int v2;
  uint64_t *v4;
  uint64_t v5;
  NSObject *v6;
  int v7;
  uint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v2 = *(_DWORD *)(a2 + 4);
  if (v2)
  {
    v4 = *(uint64_t **)(a1 + 32);
    v5 = *v4;
    v6 = *(NSObject **)v4[52];
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      v7 = 136315138;
      v8 = qmi::asString();
      _os_log_error_impl(&dword_216897000, v6, OS_LOG_TYPE_ERROR, "Got error when trying to end specific call. Error: %s", (uint8_t *)&v7, 0xCu);
      v2 = *(_DWORD *)(a2 + 4);
    }
    if (v2 == 41)
      (*(void (**)(_QWORD, uint64_t *, _QWORD))(**(_QWORD **)(v5 + 120) + 64))(*(_QWORD *)(v5 + 120), v4 + 1, 0);
  }
}

uint64_t __copy_helper_block_e8_32c81_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver11endThisCallE8CallInfoE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c81_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver11endThisCallE8CallInfoE3__0EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::endThisCall(CallInfo)::$_0,std::allocator<EurekaCallCommandDriver::endThisCall(CallInfo)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E4930;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::endThisCall(CallInfo)::$_0,std::allocator<EurekaCallCommandDriver::endThisCall(CallInfo)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E4930;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::endThisCall(CallInfo)::$_0,std::allocator<EurekaCallCommandDriver::endThisCall(CallInfo)::$_0>>::__on_zero_shared(uint64_t a1)
{
  CallInfo::~CallInfo((void **)(a1 + 32));
}

uint64_t std::map<char const*,int>::map[abi:ne180100](uint64_t a1, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  unint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  BOOL v11;
  uint64_t **v12;
  uint64_t **v13;
  uint64_t *v14;
  unint64_t v15;
  uint64_t *v16;
  _QWORD *v17;
  _QWORD *v18;

  *(_QWORD *)(a1 + 8) = 0;
  v3 = (_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = a1 + 8;
  v4 = a2 + 1;
  v5 = (_QWORD *)*a2;
  if ((_QWORD *)*a2 != a2 + 1)
  {
    do
    {
      v6 = v5[4];
      v7 = *(_QWORD *)(a1 + 8);
      v8 = v3;
      if (*(_QWORD **)a1 == v3)
        goto LABEL_8;
      v9 = *(_QWORD **)(a1 + 8);
      v10 = v3;
      if (v7)
      {
        do
        {
          v8 = v9;
          v9 = (_QWORD *)v9[1];
        }
        while (v9);
      }
      else
      {
        do
        {
          v8 = (_QWORD *)v10[2];
          v11 = *v8 == (_QWORD)v10;
          v10 = v8;
        }
        while (v11);
      }
      if (v8[4] < v6)
      {
LABEL_8:
        if (v7)
          v12 = (uint64_t **)v8;
        else
          v12 = (uint64_t **)v3;
        if (v7)
          v13 = (uint64_t **)(v8 + 1);
        else
          v13 = (uint64_t **)v3;
        if (*v13)
          goto LABEL_25;
      }
      else
      {
        v13 = (uint64_t **)v3;
        v12 = (uint64_t **)v3;
        if (v7)
        {
          v14 = *(uint64_t **)(a1 + 8);
          while (1)
          {
            while (1)
            {
              v12 = (uint64_t **)v14;
              v15 = v14[4];
              if (v15 <= v6)
                break;
              v14 = *v12;
              v13 = v12;
              if (!*v12)
                goto LABEL_24;
            }
            if (v15 >= v6)
              goto LABEL_25;
            v14 = v12[1];
            if (!v14)
            {
              v13 = v12 + 1;
              break;
            }
          }
        }
      }
LABEL_24:
      v16 = (uint64_t *)operator new(0x30uLL);
      *((_OWORD *)v16 + 2) = *((_OWORD *)v5 + 2);
      std::__tree<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::less<unsigned short>,true>,std::allocator<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>>>::__insert_node_at((uint64_t **)a1, (uint64_t)v12, v13, v16);
LABEL_25:
      v17 = (_QWORD *)v5[1];
      if (v17)
      {
        do
        {
          v18 = v17;
          v17 = (_QWORD *)*v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          v18 = (_QWORD *)v5[2];
          v11 = *v18 == (_QWORD)v5;
          v5 = v18;
        }
        while (!v11);
      }
      v5 = v18;
    }
    while (v18 != v4);
  }
  return a1;
}

void sub_216A4E2B4(_Unwind_Exception *a1)
{
  uint64_t v1;
  _QWORD *v2;

  std::__tree<std::__value_type<std::pair<Technology,Type>,InputThreshold>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,InputThreshold>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,InputThreshold>>>::destroy(v1, v2);
  _Unwind_Resume(a1);
}

uint64_t *std::__tree<std::__value_type<std::string,std::unique_ptr<ctu::Timer>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<ctu::Timer>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<ctu::Timer>>>>::__remove_node_pointer(uint64_t **a1, uint64_t *a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t *v4;
  BOOL v5;
  uint64_t *v6;

  v2 = (uint64_t *)a2[1];
  if (v2)
  {
    do
    {
      v3 = v2;
      v2 = (uint64_t *)*v2;
    }
    while (v2);
  }
  else
  {
    v4 = a2;
    do
    {
      v3 = (uint64_t *)v4[2];
      v5 = *v3 == (_QWORD)v4;
      v4 = v3;
    }
    while (!v5);
  }
  if (*a1 == a2)
    *a1 = v3;
  v6 = a1[1];
  a1[2] = (uint64_t *)((char *)a1[2] - 1);
  std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(v6, a2);
  return v3;
}

uint64_t *std::__tree<std::__value_type<std::string,std::unique_ptr<ctu::Timer>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<ctu::Timer>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<ctu::Timer>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(uint64_t **a1, void **a2, _OWORD **a3)
{
  uint64_t *v5;
  uint64_t **v6;
  uint64_t **v8;
  _QWORD *v9;
  uint64_t *v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t *v14;

  v6 = a1 + 1;
  v5 = a1[1];
  if (!v5)
  {
    v8 = a1 + 1;
LABEL_9:
    v10 = (uint64_t *)operator new(0x40uLL);
    v11 = *a3;
    v12 = *((_QWORD *)*a3 + 2);
    *((_OWORD *)v10 + 2) = **a3;
    v10[6] = v12;
    *v11 = 0;
    v11[1] = 0;
    v11[2] = 0;
    v10[7] = 0;
    *v10 = 0;
    v10[1] = 0;
    v10[2] = (uint64_t)v8;
    *v6 = v10;
    v13 = (uint64_t *)**a1;
    v14 = v10;
    if (v13)
    {
      *a1 = v13;
      v14 = *v6;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v14);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
    return v10;
  }
  while (1)
  {
    while (1)
    {
      v8 = (uint64_t **)v5;
      v9 = v5 + 4;
      if ((std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(a2, (void **)v5 + 4) & 0x80) == 0)
        break;
      v5 = *v8;
      v6 = v8;
      if (!*v8)
        goto LABEL_9;
    }
    if ((std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(v9, a2) & 0x80) == 0)
      break;
    v6 = v8 + 1;
    v5 = v8[1];
    if (!v5)
      goto LABEL_9;
  }
  v10 = *v6;
  if (!*v6)
    goto LABEL_9;
  return v10;
}

_QWORD *qmi::MutableMessageBase::TlvWrapper<vs::tlv::BurstDtmfInfo>::~TlvWrapper(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24D5E4998;
  v2 = (void *)a1[3];
  if (v2)
  {
    a1[4] = v2;
    operator delete(v2);
  }
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<vs::tlv::BurstDtmfInfo>::~TlvWrapper(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24D5E4998;
  v2 = (void *)a1[3];
  if (v2)
  {
    a1[4] = v2;
    operator delete(v2);
  }
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<vs::tlv::BurstDtmfInfo>::getSize(uint64_t a1)
{
  return tlv::size<vs::tlv::USSInfo>(a1 + 16);
}

void *qmi::MutableMessageBase::TlvWrapper<vs::tlv::BurstDtmfInfo>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  void *result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<vs::tlv::BurstDtmfInfo>((_BYTE **)a2, a1 + 16);
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<vs::tlv::BurstDtmfInfo>::clone(uint64_t a1)
{
  uint64_t v2;

  v2 = operator new();
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)v2 = &off_24D5E4998;
  *(_BYTE *)(v2 + 16) = *(_BYTE *)(a1 + 16);
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 40) = 0;
  *(_QWORD *)(v2 + 24) = 0;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>((_QWORD *)(v2 + 24), *(const void **)(a1 + 24), *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 32) - *(_QWORD *)(a1 + 24));
  return v2;
}

void sub_216A4E590(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199FEAC4](v1, 0x1091C40AD8DF7F0);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN23EurekaCallCommandDriver21sendVoiceBurstDtmfReqERKNSt3__16vectorIhNS4_9allocatorIhEEEERK8CallInfoE3__0EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  NSObject *v3;
  uint64_t v4;
  int v5;
  int v6;
  uint64_t v7;
  __int16 v8;
  int v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)(a2 + 4))
  {
    v3 = ***(NSObject ****)(a1 + 32);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      v4 = qmi::asString();
      v5 = *(_DWORD *)(a2 + 4);
      v6 = 136315394;
      v7 = v4;
      v8 = 1024;
      v9 = v5;
      _os_log_error_impl(&dword_216897000, v3, OS_LOG_TYPE_ERROR, "Sending remote audio burst DTMF failed with error %s (%d)", (uint8_t *)&v6, 0x12u);
    }
  }
}

uint64_t __copy_helper_block_e8_32c126_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver21sendVoiceBurstDtmfReqERKNS_6vectorIhNS_9allocatorIhEEEERK8CallInfoE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c126_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver21sendVoiceBurstDtmfReqERKNS_6vectorIhNS_9allocatorIhEEEERK8CallInfoE3__0EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::sendVoiceBurstDtmfReq(std::vector<unsigned char> const&,CallInfo const&)::$_0,std::allocator<EurekaCallCommandDriver::sendVoiceBurstDtmfReq(std::vector<unsigned char> const&,CallInfo const&)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E4A00;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::sendVoiceBurstDtmfReq(std::vector<unsigned char> const&,CallInfo const&)::$_0,std::allocator<EurekaCallCommandDriver::sendVoiceBurstDtmfReq(std::vector<unsigned char> const&,CallInfo const&)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E4A00;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void qmi::MutableMessageBase::TlvWrapper<vs::tlv::DtmfDigit>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<vs::tlv::DtmfDigit>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_PcoMcc>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<vs::tlv::DtmfDigit>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::ProfileIdentifer>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<vs::tlv::DtmfDigit>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E4A68;
  *(_WORD *)(result + 9) = *(_WORD *)(a1 + 9);
  return result;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN23EurekaCallCommandDriver20sendStartContDtmfReqEhRK8CallInfoE3__0EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  NSObject *v3;
  uint64_t v4;
  int v5;
  int v6;
  uint64_t v7;
  __int16 v8;
  int v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)(a2 + 4))
  {
    v3 = ***(NSObject ****)(a1 + 32);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      v4 = qmi::asString();
      v5 = *(_DWORD *)(a2 + 4);
      v6 = 136315394;
      v7 = v4;
      v8 = 1024;
      v9 = v5;
      _os_log_error_impl(&dword_216897000, v3, OS_LOG_TYPE_ERROR, "Sending dtmf digit failed with error %s (%d)", (uint8_t *)&v6, 0x12u);
    }
  }
}

uint64_t __copy_helper_block_e8_32c93_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver20sendStartContDtmfReqEhRK8CallInfoE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c93_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver20sendStartContDtmfReqEhRK8CallInfoE3__0EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::sendStartContDtmfReq(unsigned char,CallInfo const&)::$_0,std::allocator<EurekaCallCommandDriver::sendStartContDtmfReq(unsigned char,CallInfo const&)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E4AD0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::sendStartContDtmfReq(unsigned char,CallInfo const&)::$_0,std::allocator<EurekaCallCommandDriver::sendStartContDtmfReq(unsigned char,CallInfo const&)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E4AD0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN23EurekaCallCommandDriver19sendStopContDtmfReqERK8CallInfoE3__0EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  NSObject *v3;
  uint64_t v4;
  int v5;
  int v6;
  uint64_t v7;
  __int16 v8;
  int v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)(a2 + 4))
  {
    v3 = ***(NSObject ****)(a1 + 32);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      v4 = qmi::asString();
      v5 = *(_DWORD *)(a2 + 4);
      v6 = 136315394;
      v7 = v4;
      v8 = 1024;
      v9 = v5;
      _os_log_error_impl(&dword_216897000, v3, OS_LOG_TYPE_ERROR, "Sending stop DTMF audio failed with error %s (%d)", (uint8_t *)&v6, 0x12u);
    }
  }
}

uint64_t __copy_helper_block_e8_32c91_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver19sendStopContDtmfReqERK8CallInfoE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c91_ZTSNSt3__110shared_ptrIZN23EurekaCallCommandDriver19sendStopContDtmfReqERK8CallInfoE3__0EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::sendStopContDtmfReq(CallInfo const&)::$_0,std::allocator<EurekaCallCommandDriver::sendStopContDtmfReq(CallInfo const&)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E4B50;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::sendStopContDtmfReq(CallInfo const&)::$_0,std::allocator<EurekaCallCommandDriver::sendStopContDtmfReq(CallInfo const&)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E4B50;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::WiFiCallSupport>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::WiFiCallSupport>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<nas::tlv::WiFiCallSupport>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::WiFiCallSupport>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E4BB8;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::WiFiCallState>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::WiFiCallState>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<nas::tlv::WiFiCallState>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::WiFiCallState>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E4C08;
  return result;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZNK23EurekaCallCommandDriver20updateWifiCallStatusERK9CallStateN10subscriber7SimSlotEbE3__0EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  os_log_t *v2;
  NSObject *v3;
  uint64_t v5;
  int v6;
  int v7;
  uint64_t v8;
  __int16 v9;
  int v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v2 = **(os_log_t ***)(a1 + 32);
  v3 = *v2;
  if (*(_DWORD *)(a2 + 4))
  {
    if (os_log_type_enabled(*v2, OS_LOG_TYPE_ERROR))
    {
      v5 = qmi::asString();
      v6 = *(_DWORD *)(a2 + 4);
      v7 = 136315394;
      v8 = v5;
      v9 = 1024;
      v10 = v6;
      _os_log_error_impl(&dword_216897000, v3, OS_LOG_TYPE_ERROR, "Send WiFi call status info failed: %s (%d)", (uint8_t *)&v7, 0x12u);
    }
  }
  else if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v7) = 0;
    _os_log_impl(&dword_216897000, v3, OS_LOG_TYPE_DEFAULT, "#I Send WiFi call status info was successful", (uint8_t *)&v7, 2u);
  }
}

uint64_t __copy_helper_block_e8_32c117_ZTSNSt3__110shared_ptrIZNK23EurekaCallCommandDriver20updateWifiCallStatusERK9CallStateN10subscriber7SimSlotEbE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c117_ZTSNSt3__110shared_ptrIZNK23EurekaCallCommandDriver20updateWifiCallStatusERK9CallStateN10subscriber7SimSlotEbE3__0EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::updateWifiCallStatus(CallState const&,subscriber::SimSlot,BOOL)::$_0,std::allocator<EurekaCallCommandDriver::updateWifiCallStatus(CallState const&,subscriber::SimSlot,BOOL)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E4C70;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::updateWifiCallStatus(CallState const&,subscriber::SimSlot,BOOL)::$_0,std::allocator<EurekaCallCommandDriver::updateWifiCallStatus(CallState const&,subscriber::SimSlot,BOOL)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E4C70;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::CallState>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::CallState>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

_DWORD **qmi::MutableMessageBase::TlvWrapper<nas::tlv::CallState>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _DWORD *v4;
  uint64_t v5;
  _DWORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_DWORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::PktDataHandle>((_DWORD **)a2, (_DWORD *)(a1 + 12));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::CallState>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E4CD8;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a1 + 12);
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::CallType>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::CallType>::getSize()
{
  return tlv::size<wds::tlv::ProfileTypeMask>();
}

_QWORD **qmi::MutableMessageBase::TlvWrapper<nas::tlv::CallType>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _QWORD *v4;
  uint64_t v5;
  _QWORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_QWORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::ProfileTypeMask>((_QWORD **)a2, (_QWORD *)(a1 + 16));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::CallType>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E4D28;
  *(_QWORD *)(result + 16) = *(_QWORD *)(a1 + 16);
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::ImsSystemMode>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::ImsSystemMode>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<nas::tlv::ImsSystemMode>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::ImsSystemMode>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E4D78;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::CallEndReason>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::CallEndReason>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<nas::tlv::CallEndReason>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::CallEndReason>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E4DC8;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::CallTermination>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::CallTermination>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<nas::tlv::CallTermination>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::CallTermination>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E4E18;
  return result;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZNK23EurekaCallCommandDriver27sendImsCallStatusToBasebandE13CallIMSStatusN10subscriber7SimSlotEbbE3__3EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  NSObject *v3;
  uint64_t v4;
  int v5;
  int v6;
  uint64_t v7;
  __int16 v8;
  int v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)(a2 + 4))
  {
    v3 = ***(NSObject ****)(a1 + 32);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      v4 = qmi::asString();
      v5 = *(_DWORD *)(a2 + 4);
      v6 = 136315394;
      v7 = v4;
      v8 = 1024;
      v9 = v5;
      _os_log_error_impl(&dword_216897000, v3, OS_LOG_TYPE_ERROR, "IMS call status update failed with error code %s (%d)", (uint8_t *)&v6, 0x12u);
    }
  }
}

uint64_t __copy_helper_block_e8_32c128_ZTSNSt3__110shared_ptrIZNK23EurekaCallCommandDriver27sendImsCallStatusToBasebandE13CallIMSStatusN10subscriber7SimSlotEbbE3__3EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c128_ZTSNSt3__110shared_ptrIZNK23EurekaCallCommandDriver27sendImsCallStatusToBasebandE13CallIMSStatusN10subscriber7SimSlotEbbE3__3EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::sendImsCallStatusToBaseband(CallIMSStatus,subscriber::SimSlot,BOOL,BOOL)::$_3,std::allocator<EurekaCallCommandDriver::sendImsCallStatusToBaseband(CallIMSStatus,subscriber::SimSlot,BOOL,BOOL)::$_3>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E4E80;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::sendImsCallStatusToBaseband(CallIMSStatus,subscriber::SimSlot,BOOL,BOOL)::$_3,std::allocator<EurekaCallCommandDriver::sendImsCallStatusToBaseband(CallIMSStatus,subscriber::SimSlot,BOOL,BOOL)::$_3>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E4E80;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas20ImsStateNotification8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A4F300(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::CallModePreference>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::CallModePreference>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_PcoMcc>();
}

_WORD **qmi::MutableMessageBase::TlvWrapper<nas::tlv::CallModePreference>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _WORD *v4;
  uint64_t v5;
  _WORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_WORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::Profile3GPP_PcoMcc>((_WORD **)a2, (_WORD *)(a1 + 10));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::CallModePreference>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E4F10;
  *(_WORD *)(result + 10) = *(_WORD *)(a1 + 10);
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::PrefCallType>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::PrefCallType>::getSize()
{
  return tlv::size<wds::tlv::ProfileTypeMask>();
}

_QWORD **qmi::MutableMessageBase::TlvWrapper<nas::tlv::PrefCallType>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _QWORD *v4;
  uint64_t v5;
  _QWORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_QWORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::ProfileTypeMask>((_QWORD **)a2, (_QWORD *)(a1 + 16));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::PrefCallType>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E4F60;
  *(_QWORD *)(result + 16) = *(_QWORD *)(a1 + 16);
  return result;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZNK23EurekaCallCommandDriver13selectCallRatERK8CallInfoE3__2EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  os_log_t *v3;
  NSObject *v4;
  uint64_t v5;
  int v6;
  int v7;
  uint64_t v8;
  __int16 v9;
  int v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v3 = (os_log_t *)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(**(_QWORD **)(a1 + 32) + 112) + 16))(*(_QWORD *)(**(_QWORD **)(a1 + 32) + 112), *(unsigned int *)(*(_QWORD *)(a1 + 32) + 8));
  if (*(_DWORD *)(a2 + 4))
  {
    v4 = *v3;
    if (os_log_type_enabled(*v3, OS_LOG_TYPE_ERROR))
    {
      v5 = qmi::asString();
      v6 = *(_DWORD *)(a2 + 4);
      v7 = 136315394;
      v8 = v5;
      v9 = 1024;
      v10 = v6;
      _os_log_error_impl(&dword_216897000, v4, OS_LOG_TYPE_ERROR, "Call preference update failed with error code %s (%d)", (uint8_t *)&v7, 0x12u);
    }
  }
}

uint64_t __copy_helper_block_e8_32c86_ZTSNSt3__110shared_ptrIZNK23EurekaCallCommandDriver13selectCallRatERK8CallInfoE3__2EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c86_ZTSNSt3__110shared_ptrIZNK23EurekaCallCommandDriver13selectCallRatERK8CallInfoE3__2EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::selectCallRat(CallInfo const&)::$_2,std::allocator<EurekaCallCommandDriver::selectCallRat(CallInfo const&)::$_2>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E4FC8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::selectCallRat(CallInfo const&)::$_2,std::allocator<EurekaCallCommandDriver::selectCallRat(CallInfo const&)::$_2>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E4FC8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void QMINetworkListCommandDriver::create(uint64_t a1@<X0>, NSObject **a2@<X1>, _QWORD *a3@<X2>, uint64_t *a4@<X8>)
{
  uint64_t v8;
  NSObject *v9;
  dispatch_object_t v10;

  v8 = operator new();
  v9 = *a2;
  v10 = v9;
  if (v9)
    dispatch_retain(v9);
  QMINetworkListCommandDriver::QMINetworkListCommandDriver(v8, a1, &v10, a3);
  *a4 = 0;
  a4[1] = 0;
  std::shared_ptr<QMINetworkListCommandDriver>::shared_ptr[abi:ne180100]<QMINetworkListCommandDriver,std::shared_ptr<QMINetworkListCommandDriver> ctu::SharedSynchronizable<NetworkListCommandDriver>::make_shared_ptr<QMINetworkListCommandDriver>(QMINetworkListCommandDriver*)::{lambda(QMINetworkListCommandDriver*)#1},void>(a4, v8);
  if (v9)
    dispatch_release(v9);
}

void sub_216A4F6E0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  NSObject *v2;
  int v3;

  if (v2)
    dispatch_release(v2);
  if (v3)
    MEMORY[0x2199FEAC4](v1, 0xF1C408BA644E3);
  _Unwind_Resume(exception_object);
}

uint64_t QMINetworkListCommandDriver::QMINetworkListCommandDriver(uint64_t a1, uint64_t a2, dispatch_object_t *a3, _QWORD *a4)
{
  capabilities::ct *v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  NSObject *object;
  _QWORD v22[3];
  _QWORD *v23;
  _BYTE v24[24];
  _BYTE *v25;
  _BYTE v26[24];
  _BYTE *v27;
  uint64_t v28;

  v28 = *MEMORY[0x24BDAC8D0];
  object = *a3;
  if (*a3)
    dispatch_retain(*a3);
  NetworkListCommandDriver::NetworkListCommandDriver();
  if (object)
    dispatch_release(object);
  v22[0] = &unk_24D5CCF40;
  v23 = v22;
  v6 = (capabilities::ct *)std::__function::__value_func<char const* const ()(subscriber::SimSlot)>::__value_func[abi:ne180100]((uint64_t)v24, (uint64_t)v22);
  *(_QWORD *)(a1 + 88) = 0;
  if ((capabilities::ct::supportsGemini(v6) & 1) == 0)
  {
    v7 = (_QWORD *)operator new();
    *v7 = &off_24D5E5140;
    v7[1] = a1;
    v8 = *(_QWORD *)(a1 + 88);
    *(_QWORD *)(a1 + 88) = v7;
    if (!v8)
      goto LABEL_16;
    (*(void (**)(uint64_t))(*(_QWORD *)v8 + 8))(v8);
  }
  if (!*(_QWORD *)(a1 + 88))
  {
    v9 = (_QWORD *)operator new();
    std::__function::__value_func<char const* const ()(subscriber::SimSlot)>::__value_func[abi:ne180100]((uint64_t)v26, (uint64_t)v24);
    SimInstanceLoggerDefault<ctu::OsLogLogger,subscriber::SimSlot,std::function<char const* const ()(subscriber::SimSlot)>>::SimInstanceLoggerDefault(v9);
    v10 = v27;
    if (v27 == v26)
    {
      v11 = 4;
      v10 = v26;
    }
    else
    {
      if (!v27)
        goto LABEL_14;
      v11 = 5;
    }
    (*(void (**)(void))(*v10 + 8 * v11))();
LABEL_14:
    v12 = *(_QWORD *)(a1 + 88);
    *(_QWORD *)(a1 + 88) = v9;
    if (v12)
      (*(void (**)(uint64_t))(*(_QWORD *)v12 + 8))(v12);
  }
LABEL_16:
  v13 = v25;
  if (v25 == v24)
  {
    v14 = 4;
    v13 = v24;
  }
  else
  {
    if (!v25)
      goto LABEL_21;
    v14 = 5;
  }
  (*(void (**)(void))(*v13 + 8 * v14))();
LABEL_21:
  v15 = v23;
  if (v23 == v22)
  {
    v16 = 4;
    v15 = v22;
  }
  else
  {
    if (!v23)
      goto LABEL_26;
    v16 = 5;
  }
  (*(void (**)(void))(*v15 + 8 * v16))();
LABEL_26:
  *(_QWORD *)a1 = &off_24D5E5018;
  qmi::ClientRouter::ClientRouter((qmi::ClientRouter *)(a1 + 96), *(os_log_s **)(a1 + 40));
  *(_QWORD *)(a1 + 112) = 0;
  *(_QWORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 128) = 0;
  *(_QWORD *)(a1 + 136) = *a4;
  v17 = a4[1];
  *(_QWORD *)(a1 + 144) = v17;
  if (v17)
  {
    v18 = (unint64_t *)(v17 + 8);
    do
      v19 = __ldxr(v18);
    while (__stxr(v19 + 1, v18));
  }
  ctu::enable_make_unique<qmi::NotifyHelper>::make_unique<std::shared_ptr<Registry const> const&>((uint64_t *)(a1 + 152));
  return a1;
}

void sub_216A4F97C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, char a14, uint64_t a15, uint64_t a16, char *a17, char a18, uint64_t a19, uint64_t a20,char *a21)
{
  NetworkListCommandDriver *v21;
  uint64_t v22;
  char *v23;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;

  v25 = a21;
  if (a21 == v23)
  {
    v26 = 4;
    v25 = &a18;
  }
  else
  {
    if (!a21)
      goto LABEL_6;
    v26 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v25 + 8 * v26))();
LABEL_6:
  MEMORY[0x2199FEAC4](v22, 0x10A1C40FF1576FELL);
  v27 = *((_QWORD *)v21 + 11);
  *((_QWORD *)v21 + 11) = 0;
  if (v27)
    (*(void (**)(uint64_t))(*(_QWORD *)v27 + 8))(v27);
  v28 = a17;
  if (a17 == &a14)
  {
    v29 = 4;
    v28 = &a14;
  }
  else
  {
    if (!a17)
      goto LABEL_13;
    v29 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v28 + 8 * v29))();
LABEL_13:
  v30 = a13;
  if (a13 == &a10)
  {
    v31 = 4;
    v30 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_18;
    v31 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v30 + 8 * v31))();
LABEL_18:
  NetworkListCommandDriver::~NetworkListCommandDriver(v21);
  _Unwind_Resume(a1);
}

void sub_216A4FA9C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object)
{
  if (object)
    dispatch_release(object);
  JUMPOUT(0x216A4FA94);
}

void QMINetworkListCommandDriver::bootstrap(_QWORD *a1, dispatch_object_t *a2, uint64_t *a3)
{
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  std::__shared_weak_count *v12;
  std::__shared_weak_count *v13;
  _QWORD *v14;
  unint64_t *p_shared_owners;
  NSObject *v16;
  unint64_t v17;
  _QWORD *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;

  v5 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v5);
  }
  v6 = *a3;
  v7 = a3[1];
  if (v7)
  {
    v8 = (unint64_t *)(v7 + 8);
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  v10 = (std::__shared_weak_count *)a1[2];
  if (!v10 || (v11 = a1[1], (v12 = std::__shared_weak_count::lock(v10)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v13 = v12;
  v14 = (_QWORD *)operator new();
  *v14 = a1;
  v14[1] = v5;
  v14[2] = v6;
  v14[3] = v7;
  p_shared_owners = (unint64_t *)&v13->__shared_owners_;
  v16 = a1[3];
  do
    v17 = __ldxr(p_shared_owners);
  while (__stxr(v17 + 1, p_shared_owners));
  v18 = (_QWORD *)operator new();
  *v18 = v14;
  v18[1] = v11;
  v18[2] = v13;
  v20 = 0;
  v21 = 0;
  dispatch_async_f(v16, v18, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<NetworkListCommandDriver>::execute_wrapped<QMINetworkListCommandDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkListCommandDriverDelegateInterface>)::$_0>(QMINetworkListCommandDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkListCommandDriverDelegateInterface>)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMINetworkListCommandDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkListCommandDriverDelegateInterface>)::$_0,std::default_delete<QMINetworkListCommandDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkListCommandDriverDelegateInterface>)::$_0>>)::{lambda(void *)#1}::__invoke);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v20);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v21);
  do
    v19 = __ldaxr(p_shared_owners);
  while (__stlxr(v19 - 1, p_shared_owners));
  if (!v19)
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
}

void QMINetworkListCommandDriver::start(QMINetworkListCommandDriver *this)
{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  _QWORD *v6;
  NSObject *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v2 = (std::__shared_weak_count *)*((_QWORD *)this + 2);
  if (!v2 || (v3 = *((_QWORD *)this + 1), (v4 = std::__shared_weak_count::lock(v2)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v5 = v4;
  v6 = (_QWORD *)operator new();
  *v6 = this;
  v7 = *((_QWORD *)this + 3);
  p_shared_owners = (unint64_t *)&v5->__shared_owners_;
  do
    v9 = __ldxr(p_shared_owners);
  while (__stxr(v9 + 1, p_shared_owners));
  v10 = (_QWORD *)operator new();
  *v10 = v6;
  v10[1] = v3;
  v10[2] = v5;
  v12 = 0;
  v13 = 0;
  dispatch_async_f(v7, v10, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<NetworkListCommandDriver>::execute_wrapped<QMINetworkListCommandDriver::start(void)::$_0>(QMINetworkListCommandDriver::start(void)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMINetworkListCommandDriver::start(void)::$_0,dispatch_queue_s *::default_delete<QMINetworkListCommandDriver::start(void)::$_0>>)::{lambda(void *)#1}::__invoke);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v12);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v13);
  do
    v11 = __ldaxr(p_shared_owners);
  while (__stlxr(v11 - 1, p_shared_owners));
  if (!v11)
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
}

void QMINetworkListCommandDriver::shutdown(_QWORD *a1, dispatch_object_t *a2)
{
  NSObject *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  _QWORD *v8;
  unint64_t *p_shared_owners;
  NSObject *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
  }
  v4 = (std::__shared_weak_count *)a1[2];
  if (!v4 || (v5 = a1[1], (v6 = std::__shared_weak_count::lock(v4)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v7 = v6;
  v8 = (_QWORD *)operator new();
  *v8 = a1;
  v8[1] = v3;
  p_shared_owners = (unint64_t *)&v7->__shared_owners_;
  v10 = a1[3];
  do
    v11 = __ldxr(p_shared_owners);
  while (__stxr(v11 + 1, p_shared_owners));
  v12 = (_QWORD *)operator new();
  *v12 = v8;
  v12[1] = v5;
  v12[2] = v7;
  v14 = 0;
  v15 = 0;
  dispatch_async_f(v10, v12, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<NetworkListCommandDriver>::execute_wrapped<QMINetworkListCommandDriver::shutdown(dispatch::group_session)::$_0>(QMINetworkListCommandDriver::shutdown(dispatch::group_session)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMINetworkListCommandDriver::shutdown(dispatch::group_session)::$_0,dispatch_queue_s *::default_delete<QMINetworkListCommandDriver::shutdown(dispatch::group_session)::$_0>>)::{lambda(void *)#1}::__invoke);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v14);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v15);
  do
    v13 = __ldaxr(p_shared_owners);
  while (__stlxr(v13 - 1, p_shared_owners));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
}

void QMINetworkListCommandDriver::~QMINetworkListCommandDriver(qmi::NotifyHelper **this)
{
  qmi::NotifyHelper *v2;
  qmi::NotifyHelper *v3;

  *this = (qmi::NotifyHelper *)&off_24D5E5018;
  std::unique_ptr<qmi::NotifyHelper>::reset[abi:ne180100](this + 19, 0);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)(this + 17));
  v2 = this[14];
  if (v2)
  {
    this[15] = v2;
    operator delete(v2);
  }
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)(this + 12));
  v3 = this[11];
  this[11] = 0;
  if (v3)
    (*(void (**)(qmi::NotifyHelper *))(*(_QWORD *)v3 + 8))(v3);
  NetworkListCommandDriver::~NetworkListCommandDriver((NetworkListCommandDriver *)this);
}

{
  QMINetworkListCommandDriver::~QMINetworkListCommandDriver(this);
  JUMPOUT(0x2199FEAC4);
}

void QMINetworkListCommandDriver::performNetworkScan(_QWORD *a1, int a2, char a3)
{
  std::__shared_weak_count *v4;
  uint64_t v7;
  std::__shared_weak_count *v8;
  std::__shared_weak_count *v9;
  uint64_t v10;
  unint64_t *p_shared_owners;
  NSObject *v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v4 = (std::__shared_weak_count *)a1[2];
  if (!v4 || (v7 = a1[1], (v8 = std::__shared_weak_count::lock(v4)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v9 = v8;
  v10 = operator new();
  *(_QWORD *)v10 = a1;
  *(_DWORD *)(v10 + 8) = a2;
  *(_BYTE *)(v10 + 12) = a3;
  p_shared_owners = (unint64_t *)&v9->__shared_owners_;
  v12 = a1[3];
  do
    v13 = __ldxr(p_shared_owners);
  while (__stxr(v13 + 1, p_shared_owners));
  v14 = (_QWORD *)operator new();
  *v14 = v10;
  v14[1] = v7;
  v14[2] = v9;
  v16 = 0;
  v17 = 0;
  dispatch_async_f(v12, v14, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<NetworkListCommandDriver>::execute_wrapped<QMINetworkListCommandDriver::performNetworkScan(subscriber::SimSlot,unsigned char)::$_0>(QMINetworkListCommandDriver::performNetworkScan(subscriber::SimSlot,unsigned char)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMINetworkListCommandDriver::performNetworkScan(subscriber::SimSlot,unsigned char)::$_0,dispatch_queue_s *::default_delete<QMINetworkListCommandDriver::performNetworkScan(subscriber::SimSlot,unsigned char)::$_0>>)::{lambda(void *)#1}::__invoke);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v16);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v17);
  do
    v15 = __ldaxr(p_shared_owners);
  while (__stlxr(v15 - 1, p_shared_owners));
  if (!v15)
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
}

void QMINetworkListCommandDriver::applyNetworkSelection(_QWORD *a1, unsigned int a2, unsigned int a3, NetworkListOperator *a4, char a5, int a6)
{
  std::__shared_weak_count *v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  NSObject *v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  _QWORD *v15;
  unint64_t v16;
  __int128 v17;
  uint64_t v18;
  std::string v19;
  void *v20;
  char v21;
  void *v22;
  char v23;
  void *__p;
  char v25;
  uint64_t v26;
  uint64_t v27;

  *(_QWORD *)&v17 = a1;
  *((_QWORD *)&v17 + 1) = __PAIR64__(a3, a2);
  LOBYTE(v18) = a5;
  HIDWORD(v18) = a6;
  NetworkListOperator::NetworkListOperator(&v19, a4);
  v7 = (std::__shared_weak_count *)a1[2];
  if (!v7 || (v8 = a1[1], (v9 = std::__shared_weak_count::lock(v7)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v10 = v9;
  v11 = operator new();
  *(_OWORD *)v11 = v17;
  *(_QWORD *)(v11 + 16) = v18;
  NetworkListOperator::NetworkListOperator((std::string *)(v11 + 24), (const NetworkListOperator *)&v19);
  v12 = a1[3];
  p_shared_owners = (unint64_t *)&v10->__shared_owners_;
  do
    v14 = __ldxr(p_shared_owners);
  while (__stxr(v14 + 1, p_shared_owners));
  v15 = (_QWORD *)operator new();
  *v15 = v11;
  v15[1] = v8;
  v15[2] = v10;
  v26 = 0;
  v27 = 0;
  dispatch_async_f(v12, v15, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<NetworkListCommandDriver>::execute_wrapped<QMINetworkListCommandDriver::applyNetworkSelection(subscriber::SimSlot,NetworkSelectionMode,NetworkListOperator,unsigned char,CarrierSelectionAllowedReason)::$_0>(QMINetworkListCommandDriver::applyNetworkSelection(subscriber::SimSlot,NetworkSelectionMode,NetworkListOperator,unsigned char,CarrierSelectionAllowedReason)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMINetworkListCommandDriver::applyNetworkSelection(subscriber::SimSlot,NetworkSelectionMode,NetworkListOperator,unsigned char,CarrierSelectionAllowedReason)::$_0,dispatch_queue_s *::default_delete<QMINetworkListCommandDriver::applyNetworkSelection(subscriber::SimSlot,NetworkSelectionMode,NetworkListOperator,unsigned char,CarrierSelectionAllowedReason)::$_0>>)::{lambda(void *)#1}::__invoke);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v26);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v27);
  do
    v16 = __ldaxr(p_shared_owners);
  while (__stlxr(v16 - 1, p_shared_owners));
  if (!v16)
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  if (v25 < 0)
    operator delete(__p);
  if (v23 < 0)
    operator delete(v22);
  if (v21 < 0)
    operator delete(v20);
  if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v19.__r_.__value_.__l.__data_);
}

void QMINetworkListCommandDriver::applySelection_sync(uint64_t a1, int a2, int a3, const NetworkListOperator *a4, NSObject **a5)
{
  capabilities::ct *v10;
  uint64_t v11;
  const void **v12;
  const void **v13;
  char *v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  char *v20;
  _BYTE *v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  _QWORD *v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  char *v33;
  uint64_t *v34;
  char *v35;
  char *v36;
  char *v37;
  uint64_t v38;
  char v39;
  const void **v40;
  char *v41;
  char *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  _QWORD *v46;
  uint64_t v47;
  unint64_t v48;
  unint64_t v49;
  char *v50;
  uint64_t *v51;
  char *v52;
  char *v53;
  char *v54;
  uint64_t v55;
  unsigned __int16 *v56;
  unsigned __int16 *v57;
  char isThreeDigit;
  NSObject *v59;
  int v60;
  int v61;
  int v62;
  uint64_t v63;
  const void **v64;
  char *v65;
  _BYTE *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  _QWORD *v70;
  uint64_t v71;
  unint64_t v72;
  unint64_t v73;
  char *v74;
  uint64_t *v75;
  char *v76;
  char *v77;
  char *v78;
  uint64_t v79;
  const void **v80;
  char *v81;
  _BYTE *v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  _QWORD *v86;
  uint64_t v87;
  unint64_t v88;
  unint64_t v89;
  char *v90;
  uint64_t *v91;
  char *v92;
  char *v93;
  char *v94;
  uint64_t v95;
  const void **v96;
  char *v97;
  _DWORD *v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  _QWORD *v102;
  uint64_t v103;
  unint64_t v104;
  unint64_t v105;
  char *v106;
  uint64_t *v107;
  char *v108;
  char *v109;
  char *v110;
  uint64_t v111;
  int v112;
  uint64_t v113;
  uint64_t v114;
  NSObject *v115;
  _QWORD *v116;
  unint64_t *v117;
  uint64_t v118;
  unint64_t v119;
  std::__shared_weak_count *v120;
  unint64_t *v121;
  unint64_t v122;
  unint64_t *v123;
  unint64_t v124;
  NSObject *v125;
  uint64_t v126;
  uint64_t *v127;
  char *v128;
  char *v129;
  char *v130;
  uint64_t v131;
  NSObject *v132;
  int IntValue;
  int IntegerWidth;
  int v135;
  uint64_t v136;
  uint64_t v137;
  NSObject *v138;
  int v139;
  _QWORD *v140;
  unint64_t *v141;
  uint64_t v142;
  uint64_t v143;
  unint64_t v144;
  std::__shared_weak_count *v145;
  unint64_t *v146;
  unint64_t v147;
  std::__shared_weak_count *v148;
  unint64_t *v149;
  unint64_t v150;
  NSObject *v151;
  char *v152;
  void *v153;
  char v154;
  std::string v155;
  void *v156;
  char *v157;
  void *v158;
  void *v159;
  char v160;
  char v161;
  void *v162;
  void *v163;
  char v164;
  void *v165;
  void *v166;
  char v167;
  char v168;
  void *v169[2];
  __int128 v170;
  uint64_t aBlock;
  void *__p;
  void *v173;
  void *v174;
  std::string *v175;
  uint8_t buf[8];
  NSObject *v177;
  _BYTE v178[14];
  char v179;
  uint8_t v180[4];
  int v181;
  uint64_t v182;
  int v183;
  __int16 v184;
  uint64_t v185;
  uint64_t v186;

  v186 = *MEMORY[0x24BDAC8D0];
  v10 = (capabilities::ct *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 88) + 16))(*(_QWORD *)(a1 + 88));
  if (capabilities::ct::supports5G(v10))
  {
    *(_OWORD *)v169 = 0uLL;
    v170 = 0uLL;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v169);
    LODWORD(v155.__r_.__value_.__l.__data_) = a3;
    NetworkListOperator::NetworkListOperator((std::string *)&v155.__r_.__value_.__r.__words[1], a4);
    v11 = qmi::MutableMessageBase::getTLV<nas::tlv::NetworkSelectionPreference>(v169, 22);
    *(_BYTE *)v11 = a3 == 1;
    if (a3 == 1)
    {
      NetworkListOperator::getMCC((NetworkListOperator *)&v155.__r_.__value_.__r.__words[1]);
      *(_WORD *)(v11 + 2) = MCC::getIntValue((MCC *)&aBlock);
      if (SHIBYTE(v174) < 0)
        operator delete(__p);
      NetworkListOperator::getMNC((NetworkListOperator *)&v155.__r_.__value_.__r.__words[1]);
      *(_WORD *)(v11 + 4) = MCC::getIntValue((MCC *)&aBlock);
      if (SHIBYTE(v174) < 0)
        operator delete(__p);
    }
    if (v168 < 0)
      operator delete(v166);
    if (SHIBYTE(v165) < 0)
      operator delete(v163);
    if (v161 < 0)
      operator delete(v159);
    if (SHIBYTE(v156) < 0)
      operator delete((void *)v155.__r_.__value_.__l.__size_);
    if (a3 == 1)
    {
      v12 = (const void **)v169[1];
      if (v169[1] != (void *)v170)
      {
        while (*((_BYTE *)*v12 + 8) != 23)
        {
          if (++v12 == (const void **)v170)
            goto LABEL_40;
        }
      }
      if (v12 == (const void **)v170)
      {
LABEL_40:
        v26 = operator new();
        v27 = v26;
        *(_WORD *)(v26 + 8) = 23;
        *(_QWORD *)v26 = &off_24D5E5780;
        v28 = v170;
        if ((unint64_t)v170 >= *((_QWORD *)&v170 + 1))
        {
          v30 = (uint64_t)(v170 - (unint64_t)v169[1]) >> 3;
          if ((unint64_t)(v30 + 1) >> 61)
            std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
          v31 = (uint64_t)(*((_QWORD *)&v170 + 1) - (unint64_t)v169[1]) >> 2;
          if (v31 <= v30 + 1)
            v31 = v30 + 1;
          if (*((_QWORD *)&v170 + 1) - (unint64_t)v169[1] >= 0x7FFFFFFFFFFFFFF8)
            v32 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v32 = v31;
          if (v32)
            v33 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v170 + 8, v32);
          else
            v33 = 0;
          v75 = (uint64_t *)&v33[8 * v30];
          v76 = &v33[8 * v32];
          *v75 = v27;
          v29 = v75 + 1;
          v78 = (char *)v169[1];
          v77 = (char *)v170;
          if ((void *)v170 != v169[1])
          {
            do
            {
              v79 = *((_QWORD *)v77 - 1);
              v77 -= 8;
              *--v75 = v79;
            }
            while (v77 != v78);
            v77 = (char *)v169[1];
          }
          v169[1] = v75;
          *(_QWORD *)&v170 = v29;
          *((_QWORD *)&v170 + 1) = v76;
          if (v77)
            operator delete(v77);
        }
        else
        {
          *(_QWORD *)v170 = v26;
          v29 = (_QWORD *)(v28 + 8);
        }
        v21 = (_BYTE *)(v27 + 9);
        *(_QWORD *)&v170 = v29;
      }
      else
      {
        if (!v20)
          __cxa_bad_cast();
        v21 = v20 + 9;
      }
      *v21 = 0;
      NetworkListOperator::NetworkListOperator(&v155, a4);
      v80 = (const void **)v169[1];
      if (v169[1] != (void *)v170)
      {
        while (*((_BYTE *)*v80 + 8) != 26)
        {
          if (++v80 == (const void **)v170)
            goto LABEL_126;
        }
      }
      if (v80 == (const void **)v170)
      {
LABEL_126:
        v83 = operator new();
        v84 = v83;
        *(_WORD *)(v83 + 8) = 26;
        *(_QWORD *)v83 = &off_24D5E57D0;
        v85 = v170;
        if ((unint64_t)v170 >= *((_QWORD *)&v170 + 1))
        {
          v87 = (uint64_t)(v170 - (unint64_t)v169[1]) >> 3;
          if ((unint64_t)(v87 + 1) >> 61)
            std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
          v88 = (uint64_t)(*((_QWORD *)&v170 + 1) - (unint64_t)v169[1]) >> 2;
          if (v88 <= v87 + 1)
            v88 = v87 + 1;
          if (*((_QWORD *)&v170 + 1) - (unint64_t)v169[1] >= 0x7FFFFFFFFFFFFFF8)
            v89 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v89 = v88;
          if (v89)
            v90 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v170 + 8, v89);
          else
            v90 = 0;
          v91 = (uint64_t *)&v90[8 * v87];
          v92 = &v90[8 * v89];
          *v91 = v84;
          v86 = v91 + 1;
          v94 = (char *)v169[1];
          v93 = (char *)v170;
          if ((void *)v170 != v169[1])
          {
            do
            {
              v95 = *((_QWORD *)v93 - 1);
              v93 -= 8;
              *--v91 = v95;
            }
            while (v93 != v94);
            v93 = (char *)v169[1];
          }
          v169[1] = v91;
          *(_QWORD *)&v170 = v86;
          *((_QWORD *)&v170 + 1) = v92;
          if (v93)
            operator delete(v93);
        }
        else
        {
          *(_QWORD *)v170 = v83;
          v86 = (_QWORD *)(v85 + 8);
        }
        v82 = (_BYTE *)(v84 + 9);
        *(_QWORD *)&v170 = v86;
      }
      else
      {
        if (!v81)
          __cxa_bad_cast();
        v82 = v81 + 9;
      }
      NetworkListOperator::getMNC((NetworkListOperator *)&v155);
      *v82 = MNC::isThreeDigit((MNC *)&aBlock);
      if (SHIBYTE(v174) < 0)
        operator delete(__p);
      if (v167 < 0)
        operator delete(v165);
      if (v164 < 0)
        operator delete(v162);
      if (v160 < 0)
        operator delete(v158);
      if (SHIBYTE(v155.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v155.__r_.__value_.__l.__data_);
      if (NetworkListOperator::getRAT(a4) != 11)
      {
        NetworkListOperator::NetworkListOperator(&v155, a4);
        v96 = (const void **)v169[1];
        if (v169[1] != (void *)v170)
        {
          while (*((_BYTE *)*v96 + 8) != 34)
          {
            if (++v96 == (const void **)v170)
              goto LABEL_161;
          }
        }
        if (v96 == (const void **)v170)
        {
LABEL_161:
          v99 = operator new();
          v100 = v99;
          *(_BYTE *)(v99 + 8) = 34;
          *(_QWORD *)v99 = &off_24D5E5820;
          *(_DWORD *)(v99 + 12) = -1;
          v98 = (_DWORD *)(v99 + 12);
          v101 = v170;
          if ((unint64_t)v170 >= *((_QWORD *)&v170 + 1))
          {
            v103 = (uint64_t)(v170 - (unint64_t)v169[1]) >> 3;
            if ((unint64_t)(v103 + 1) >> 61)
              std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
            v104 = (uint64_t)(*((_QWORD *)&v170 + 1) - (unint64_t)v169[1]) >> 2;
            if (v104 <= v103 + 1)
              v104 = v103 + 1;
            if (*((_QWORD *)&v170 + 1) - (unint64_t)v169[1] >= 0x7FFFFFFFFFFFFFF8)
              v105 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v105 = v104;
            if (v105)
              v106 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v170 + 8, v105);
            else
              v106 = 0;
            v127 = (uint64_t *)&v106[8 * v103];
            v128 = &v106[8 * v105];
            *v127 = v100;
            v102 = v127 + 1;
            v130 = (char *)v169[1];
            v129 = (char *)v170;
            if ((void *)v170 != v169[1])
            {
              do
              {
                v131 = *((_QWORD *)v129 - 1);
                v129 -= 8;
                *--v127 = v131;
              }
              while (v129 != v130);
              v129 = (char *)v169[1];
            }
            v169[1] = v127;
            *(_QWORD *)&v170 = v102;
            *((_QWORD *)&v170 + 1) = v128;
            if (v129)
              operator delete(v129);
          }
          else
          {
            *(_QWORD *)v170 = v99;
            v102 = (_QWORD *)(v101 + 8);
          }
          *(_QWORD *)&v170 = v102;
        }
        else
        {
          if (!v97)
            __cxa_bad_cast();
          v98 = v97 + 12;
        }
        *v98 = NetworkListOperator::getRAT((NetworkListOperator *)&v155);
        if (v167 < 0)
          operator delete(v165);
        if (v164 < 0)
          operator delete(v162);
        if (v160 < 0)
          operator delete(v158);
        if (SHIBYTE(v155.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v155.__r_.__value_.__l.__data_);
      }
      v132 = *(NSObject **)v10;
      if (os_log_type_enabled(v132, OS_LOG_TYPE_DEFAULT))
      {
        NetworkListOperator::getMCC(a4);
        IntValue = MCC::getIntValue((MCC *)&v155);
        NetworkListOperator::getMNC(a4);
        IntegerWidth = MNC::getIntegerWidth((MNC *)&aBlock);
        NetworkListOperator::getMNC(a4);
        v135 = MCC::getIntValue((MCC *)buf);
        NetworkListOperator::getMNC(a4);
        MNC::isThreeDigit((MNC *)&v152);
        v136 = CSIBOOLAsString();
        *(_DWORD *)v180 = 67109890;
        v181 = IntValue;
        LOWORD(v182) = 1024;
        *(_DWORD *)((char *)&v182 + 2) = IntegerWidth;
        HIWORD(v182) = 1024;
        v183 = v135;
        v184 = 2080;
        v185 = v136;
        _os_log_impl(&dword_216897000, v132, OS_LOG_TYPE_DEFAULT, "#I Network MCC: %03d, MNC: %0.*d is a 3-digit MNC: %s", v180, 0x1Eu);
        if (v154 < 0)
          operator delete(v153);
        if (v179 < 0)
          operator delete(v177);
        if (SHIBYTE(v174) < 0)
          operator delete(__p);
        if (SHIBYTE(v156) < 0)
          operator delete((void *)v155.__r_.__value_.__l.__size_);
      }
    }
    if ((a2 - 1) >= 3)
      a2 = 0;
    v137 = qmi::ClientRouter::get();
    qmi::ClientRouter::SendProxy::SendProxy<nas::SetSystemSelectionPreference::Request>((uint64_t)v180, a2, v137);
    v138 = *a5;
    *(_QWORD *)buf = a1;
    v177 = v138;
    if (v138)
    {
      dispatch_retain(v138);
      dispatch_group_enter(v138);
    }
    *(_DWORD *)v178 = a3;
    v139 = *(_DWORD *)v180;
    v140 = operator new(0x30uLL);
    v140[1] = 0;
    v141 = v140 + 1;
    v140[2] = 0;
    *v140 = &off_24D5E5888;
    v140[3] = a1;
    v140[4] = v138;
    v177 = 0;
    *((_DWORD *)v140 + 10) = a3;
    v152 = (char *)(v140 + 3);
    v153 = v140;
    v142 = v182;
    v143 = MEMORY[0x24BDAC760];
    v155.__r_.__value_.__r.__words[0] = MEMORY[0x24BDAC760];
    v155.__r_.__value_.__l.__size_ = 1174405120;
    v155.__r_.__value_.__r.__words[2] = (std::string::size_type)___ZNO3qmi12ClientRouter9SendProxy8callbackIZN27QMINetworkListCommandDriver19applySelection_syncEN10subscriber7SimSlotE20NetworkSelectionMode19NetworkListOperatorN8dispatch13group_sessionEE3__5EEOS1_OT__block_invoke;
    v156 = &__block_descriptor_tmp_18_19;
    v157 = (char *)(v140 + 3);
    v158 = v140;
    do
      v144 = __ldxr(v141);
    while (__stxr(v144 + 1, v141));
    LODWORD(v159) = v139;
    aBlock = v143;
    __p = (void *)0x40000000;
    v173 = ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas28SetSystemSelectionPreference8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
    v174 = &unk_24D5E58D0;
    v175 = &v155;
    *(_QWORD *)(v142 + 32) = _Block_copy(&aBlock);
    v145 = (std::__shared_weak_count *)v158;
    if (v158)
    {
      v146 = (unint64_t *)((char *)v158 + 8);
      do
        v147 = __ldaxr(v146);
      while (__stlxr(v147 - 1, v146));
      if (!v147)
      {
        ((void (*)(std::__shared_weak_count *))v145->__on_zero_shared)(v145);
        std::__shared_weak_count::__release_weak(v145);
      }
    }
    v148 = (std::__shared_weak_count *)v153;
    if (v153)
    {
      v149 = (unint64_t *)((char *)v153 + 8);
      do
        v150 = __ldaxr(v149);
      while (__stlxr(v150 - 1, v149));
      if (!v150)
      {
        ((void (*)(std::__shared_weak_count *))v148->__on_zero_shared)(v148);
        std::__shared_weak_count::__release_weak(v148);
      }
    }
    v151 = v177;
    if (v177)
    {
      dispatch_group_leave(v177);
      dispatch_release(v151);
    }
    v126 = v182;
    v182 = 0;
    if (v126)
LABEL_246:
      std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v182, v126);
  }
  else
  {
    *(_OWORD *)v169 = 0uLL;
    v170 = 0uLL;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v169);
    v13 = (const void **)v169[1];
    if (v169[1] != (void *)v170)
    {
      while (*((_BYTE *)*v13 + 8) != 1)
      {
        if (++v13 == (const void **)v170)
          goto LABEL_27;
      }
    }
    if (v13 == (const void **)v170)
    {
LABEL_27:
      v16 = operator new();
      v17 = v16;
      *(_WORD *)(v16 + 8) = 1;
      *(_QWORD *)v16 = &off_24D5E5918;
      v18 = v170;
      if ((unint64_t)v170 >= *((_QWORD *)&v170 + 1))
      {
        v22 = (uint64_t)(v170 - (unint64_t)v169[1]) >> 3;
        if ((unint64_t)(v22 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v23 = (uint64_t)(*((_QWORD *)&v170 + 1) - (unint64_t)v169[1]) >> 2;
        if (v23 <= v22 + 1)
          v23 = v22 + 1;
        if (*((_QWORD *)&v170 + 1) - (unint64_t)v169[1] >= 0x7FFFFFFFFFFFFFF8)
          v24 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v24 = v23;
        if (v24)
          v25 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v170 + 8, v24);
        else
          v25 = 0;
        v34 = (uint64_t *)&v25[8 * v22];
        v35 = &v25[8 * v24];
        *v34 = v17;
        v19 = v34 + 1;
        v37 = (char *)v169[1];
        v36 = (char *)v170;
        if ((void *)v170 != v169[1])
        {
          do
          {
            v38 = *((_QWORD *)v36 - 1);
            v36 -= 8;
            *--v34 = v38;
          }
          while (v36 != v37);
          v36 = (char *)v169[1];
        }
        v169[1] = v34;
        *(_QWORD *)&v170 = v19;
        *((_QWORD *)&v170 + 1) = v35;
        if (v36)
          operator delete(v36);
      }
      else
      {
        *(_QWORD *)v170 = v16;
        v19 = (_QWORD *)(v18 + 8);
      }
      v15 = (char *)(v17 + 9);
      *(_QWORD *)&v170 = v19;
    }
    else
    {
      if (!v14)
        __cxa_bad_cast();
      v15 = v14 + 9;
    }
    if (a3 == 1)
      v39 = 2;
    else
      v39 = 1;
    *v15 = v39;
    if (a3 == 1)
    {
      NetworkListOperator::getMCC(a4);
      NetworkListOperator::getMNC(a4);
      v40 = (const void **)v169[1];
      if (v169[1] != (void *)v170)
      {
        while (*((_BYTE *)*v40 + 8) != 16)
        {
          if (++v40 == (const void **)v170)
            goto LABEL_68;
        }
      }
      if (v40 == (const void **)v170)
      {
LABEL_68:
        v43 = operator new();
        v44 = v43;
        *(_BYTE *)(v43 + 8) = 16;
        *(_QWORD *)v43 = &off_24D5E5968;
        *(_DWORD *)(v43 + 10) = 0;
        v42 = (char *)(v43 + 10);
        *(_BYTE *)(v43 + 14) = 0;
        v45 = v170;
        if ((unint64_t)v170 >= *((_QWORD *)&v170 + 1))
        {
          v47 = (uint64_t)(v170 - (unint64_t)v169[1]) >> 3;
          if ((unint64_t)(v47 + 1) >> 61)
            std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
          v48 = (uint64_t)(*((_QWORD *)&v170 + 1) - (unint64_t)v169[1]) >> 2;
          if (v48 <= v47 + 1)
            v48 = v47 + 1;
          if (*((_QWORD *)&v170 + 1) - (unint64_t)v169[1] >= 0x7FFFFFFFFFFFFFF8)
            v49 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v49 = v48;
          if (v49)
            v50 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v170 + 8, v49);
          else
            v50 = 0;
          v51 = (uint64_t *)&v50[8 * v47];
          v52 = &v50[8 * v49];
          *v51 = v44;
          v46 = v51 + 1;
          v54 = (char *)v169[1];
          v53 = (char *)v170;
          if ((void *)v170 != v169[1])
          {
            do
            {
              v55 = *((_QWORD *)v53 - 1);
              v53 -= 8;
              *--v51 = v55;
            }
            while (v53 != v54);
            v53 = (char *)v169[1];
          }
          v169[1] = v51;
          *(_QWORD *)&v170 = v46;
          *((_QWORD *)&v170 + 1) = v52;
          if (v53)
            operator delete(v53);
        }
        else
        {
          *(_QWORD *)v170 = v43;
          v46 = (_QWORD *)(v45 + 8);
        }
        *(_QWORD *)&v170 = v46;
      }
      else
      {
        if (!v41)
          __cxa_bad_cast();
        v42 = v41 + 10;
      }
      *(_WORD *)v42 = MCC::getIntValue((MCC *)&v155);
      *((_WORD *)v42 + 1) = MCC::getIntValue((MCC *)&aBlock);
      v42[4] = -1;
      v56 = *(unsigned __int16 **)(a1 + 112);
      v57 = *(unsigned __int16 **)(a1 + 120);
      if (v56 == v57)
        goto LABEL_92;
      while (MCC::getIntValue((MCC *)&v155) != *v56
           || MCC::getIntValue((MCC *)&aBlock) != v56[1])
      {
        v56 += 3;
        if (v56 == v57)
        {
          v56 = v57;
          break;
        }
      }
      if (v56 == *(unsigned __int16 **)(a1 + 120))
LABEL_92:
        isThreeDigit = MNC::isThreeDigit((MNC *)&aBlock);
      else
        isThreeDigit = *((_BYTE *)v56 + 4) != 0;
      v59 = *(NSObject **)v10;
      if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
      {
        v60 = MCC::getIntValue((MCC *)&v155);
        v61 = MNC::getIntegerWidth((MNC *)&aBlock);
        v62 = MCC::getIntValue((MCC *)&aBlock);
        v63 = CSIBOOLAsString();
        *(_DWORD *)buf = 67109890;
        *(_DWORD *)&buf[4] = v60;
        LOWORD(v177) = 1024;
        *(_DWORD *)((char *)&v177 + 2) = v61;
        HIWORD(v177) = 1024;
        *(_DWORD *)v178 = v62;
        *(_WORD *)&v178[4] = 2080;
        *(_QWORD *)&v178[6] = v63;
        _os_log_impl(&dword_216897000, v59, OS_LOG_TYPE_DEFAULT, "#I Network MCC: %03d, MNC: %0.*d is a 3-digit MNC: %s", buf, 0x1Eu);
      }
      v64 = (const void **)v169[1];
      if (v169[1] != (void *)v170)
      {
        while (*((_BYTE *)*v64 + 8) != 18)
        {
          if (++v64 == (const void **)v170)
            goto LABEL_102;
        }
      }
      if (v64 == (const void **)v170)
      {
LABEL_102:
        v67 = operator new();
        v68 = v67;
        *(_WORD *)(v67 + 8) = 18;
        *(_QWORD *)v67 = &off_24D5E59B8;
        v69 = v170;
        if ((unint64_t)v170 >= *((_QWORD *)&v170 + 1))
        {
          v71 = (uint64_t)(v170 - (unint64_t)v169[1]) >> 3;
          if ((unint64_t)(v71 + 1) >> 61)
            std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
          v72 = (uint64_t)(*((_QWORD *)&v170 + 1) - (unint64_t)v169[1]) >> 2;
          if (v72 <= v71 + 1)
            v72 = v71 + 1;
          if (*((_QWORD *)&v170 + 1) - (unint64_t)v169[1] >= 0x7FFFFFFFFFFFFFF8)
            v73 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v73 = v72;
          if (v73)
            v74 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v170 + 8, v73);
          else
            v74 = 0;
          v107 = (uint64_t *)&v74[8 * v71];
          v108 = &v74[8 * v73];
          *v107 = v68;
          v70 = v107 + 1;
          v110 = (char *)v169[1];
          v109 = (char *)v170;
          if ((void *)v170 != v169[1])
          {
            do
            {
              v111 = *((_QWORD *)v109 - 1);
              v109 -= 8;
              *--v107 = v111;
            }
            while (v109 != v110);
            v109 = (char *)v169[1];
          }
          v169[1] = v107;
          *(_QWORD *)&v170 = v70;
          *((_QWORD *)&v170 + 1) = v108;
          if (v109)
            operator delete(v109);
        }
        else
        {
          *(_QWORD *)v170 = v67;
          v70 = (_QWORD *)(v69 + 8);
        }
        v66 = (_BYTE *)(v68 + 9);
        *(_QWORD *)&v170 = v70;
      }
      else
      {
        if (!v65)
          __cxa_bad_cast();
        v66 = v65 + 9;
      }
      *v66 = isThreeDigit;
      if (SHIBYTE(v174) < 0)
        operator delete(__p);
      if (SHIBYTE(v156) < 0)
        operator delete((void *)v155.__r_.__value_.__l.__size_);
    }
    if ((a2 - 1) >= 3)
      v112 = 0;
    else
      v112 = a2;
    v113 = qmi::ClientRouter::get();
    *(_DWORD *)v180 = v112;
    v114 = operator new();
    *(_QWORD *)v114 = v113;
    *(_QWORD *)(v114 + 8) = QMIServiceMsg::create();
    *(_DWORD *)(v114 + 16) = 25000;
    *(_QWORD *)(v114 + 24) = 0;
    *(_QWORD *)(v114 + 32) = 0;
    v182 = v114;
    *(_QWORD *)buf = a1;
    LODWORD(v177) = a3;
    *(_QWORD *)v178 = *a5;
    v115 = *(NSObject **)v178;
    if (*(_QWORD *)v178)
    {
      dispatch_retain(*(dispatch_object_t *)v178);
      dispatch_group_enter(v115);
    }
    v116 = operator new(0x30uLL);
    v116[1] = 0;
    v117 = v116 + 1;
    v116[2] = 0;
    *v116 = &off_24D5E5A20;
    *((_DWORD *)v116 + 8) = (_DWORD)v177;
    v116[3] = *(_QWORD *)buf;
    v116[5] = v115;
    *(_QWORD *)v178 = 0;
    v152 = (char *)(v116 + 3);
    v153 = v116;
    v118 = MEMORY[0x24BDAC760];
    v155.__r_.__value_.__r.__words[0] = MEMORY[0x24BDAC760];
    v155.__r_.__value_.__l.__size_ = 1174405120;
    v155.__r_.__value_.__r.__words[2] = (std::string::size_type)___ZNO3qmi12ClientRouter9SendProxy8callbackIZN27QMINetworkListCommandDriver19applySelection_syncEN10subscriber7SimSlotE20NetworkSelectionMode19NetworkListOperatorN8dispatch13group_sessionEE3__9EEOS1_OT__block_invoke;
    v156 = &__block_descriptor_tmp_20_17;
    v157 = (char *)(v116 + 3);
    v158 = v116;
    do
      v119 = __ldxr(v117);
    while (__stxr(v119 + 1, v117));
    LODWORD(v159) = v112;
    aBlock = v118;
    __p = (void *)0x40000000;
    v173 = ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas23InitiateNetworkRegister8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
    v174 = &unk_24D5E5A68;
    v175 = &v155;
    *(_QWORD *)(v114 + 32) = _Block_copy(&aBlock);
    v120 = (std::__shared_weak_count *)v158;
    if (v158)
    {
      v121 = (unint64_t *)((char *)v158 + 8);
      do
        v122 = __ldaxr(v121);
      while (__stlxr(v122 - 1, v121));
      if (!v122)
      {
        ((void (*)(std::__shared_weak_count *))v120->__on_zero_shared)(v120);
        std::__shared_weak_count::__release_weak(v120);
      }
    }
    if (v153)
    {
      v123 = (unint64_t *)((char *)v153 + 8);
      do
        v124 = __ldaxr(v123);
      while (__stlxr(v124 - 1, v123));
      if (!v124)
      {
        (*(void (**)(void *))(*(_QWORD *)v153 + 16))(v153);
        std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v153);
      }
    }
    v125 = *(NSObject **)v178;
    if (*(_QWORD *)v178)
    {
      dispatch_group_leave(*(dispatch_group_t *)v178);
      dispatch_release(v125);
    }
    v126 = v182;
    v182 = 0;
    if (v126)
      goto LABEL_246;
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v169);
}

void sub_216A51204(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,void *__p,uint64_t a44,int a45,__int16 a46,char a47,char a48)
{
  uint64_t v48;

  if (*(char *)(v48 - 145) < 0)
    operator delete(*(void **)(v48 - 168));
  if (a48 < 0)
    operator delete(__p);
  if (a22 < 0)
    operator delete(a17);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a37);
  _Unwind_Resume(a1);
}

uint64_t QMINetworkListCommandDriver::applySelection_sync(subscriber::SimSlot,NetworkSelectionMode,NetworkListOperator,dispatch::group_session)::$_1::~$_1(uint64_t a1)
{
  if (*(char *)(a1 + 127) < 0)
    operator delete(*(void **)(a1 + 104));
  if (*(char *)(a1 + 103) < 0)
    operator delete(*(void **)(a1 + 80));
  if (*(char *)(a1 + 71) < 0)
    operator delete(*(void **)(a1 + 48));
  if (*(char *)(a1 + 31) < 0)
    operator delete(*(void **)(a1 + 8));
  return a1;
}

uint64_t QMINetworkListCommandDriver::applySelection_sync(subscriber::SimSlot,NetworkSelectionMode,NetworkListOperator,dispatch::group_session)::$_3::~$_3(uint64_t a1)
{
  if (*(char *)(a1 + 119) < 0)
    operator delete(*(void **)(a1 + 96));
  if (*(char *)(a1 + 95) < 0)
    operator delete(*(void **)(a1 + 72));
  if (*(char *)(a1 + 63) < 0)
    operator delete(*(void **)(a1 + 40));
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t QMINetworkListCommandDriver::applySelection_sync(subscriber::SimSlot,NetworkSelectionMode,NetworkListOperator,dispatch::group_session)::$_9::~$_9(uint64_t a1)
{
  NSObject *v2;
  NSObject *v3;

  v2 = *(NSObject **)(a1 + 16);
  if (v2)
  {
    dispatch_group_leave(v2);
    v3 = *(NSObject **)(a1 + 16);
    if (v3)
      dispatch_release(v3);
  }
  return a1;
}

void QMINetworkListCommandDriver::handleInitiateNetworkRegisterResp_sync(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v5;
  os_log_t *v6;
  int v7;
  NSObject *v8;
  uint64_t v9;
  int v10;
  std::__shared_weak_count *v11;
  unint64_t *p_shared_owners;
  uint64_t v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  _QWORD *v21;
  std::__shared_weak_count *v22;
  _BYTE buf[18];
  __int16 v24;
  uint64_t v25;
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  if (a2 - 1 >= 3)
    v5 = 0;
  else
    v5 = a2;
  v6 = (os_log_t *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 88) + 16))(*(_QWORD *)(a1 + 88), v5);
  v7 = *(_DWORD *)(a3 + 4);
  if (!v7)
    goto LABEL_9;
  v8 = *v6;
  if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
  {
    v9 = asString();
    v10 = *(_DWORD *)(a3 + 4);
    *(_DWORD *)buf = 136315650;
    *(_QWORD *)&buf[4] = v9;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v10;
    v24 = 2080;
    v25 = qmi::asString();
    _os_log_impl(&dword_216897000, v8, OS_LOG_TYPE_DEFAULT, "#N Network register initiate (%s) failed with error: %d (%s)", buf, 0x1Cu);
    v7 = *(_DWORD *)(a3 + 4);
  }
  if (v7 == 26)
  {
LABEL_9:
    v11 = (std::__shared_weak_count *)operator new(0x20uLL);
    v11->__shared_owners_ = 0;
    p_shared_owners = (unint64_t *)&v11->__shared_owners_;
    v11->__shared_weak_owners_ = 0;
    v11->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E5A98;
    NetworkListSelectionResult::NetworkListSelectionResult();
    *(_QWORD *)buf = v11 + 1;
    *(_QWORD *)&buf[8] = v11;
    v13 = *(_QWORD *)(a1 + 48);
    v21 = &v11[1].__vftable;
    v22 = v11;
    do
      v14 = __ldxr(p_shared_owners);
    while (__stxr(v14 + 1, p_shared_owners));
    (*(void (**)(uint64_t, uint64_t, _QWORD **))(*(_QWORD *)v13 + 40))(v13, v5, &v21);
    v15 = v22;
    if (v22)
    {
      v16 = (unint64_t *)&v22->__shared_owners_;
      do
        v17 = __ldaxr(v16);
      while (__stlxr(v17 - 1, v16));
      if (!v17)
      {
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v15);
      }
    }
    v18 = *(std::__shared_weak_count **)&buf[8];
    if (*(_QWORD *)&buf[8])
    {
      v19 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
      do
        v20 = __ldaxr(v19);
      while (__stlxr(v20 - 1, v19));
      if (!v20)
      {
        ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
        std::__shared_weak_count::__release_weak(v18);
      }
    }
  }
  else
  {
    *(_QWORD *)buf = 0;
    NetworkListCommandDriverResponseError::NetworkListCommandDriverResponseError();
    (*(void (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(a1 + 48) + 24))(*(_QWORD *)(a1 + 48), v5, *(_QWORD *)buf);
  }
}

void sub_216A51718(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

void QMINetworkListCommandDriver::getNetworkSelectionSetting(_QWORD *a1, int a2)
{
  std::__shared_weak_count *v3;
  uint64_t v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  unint64_t *p_shared_owners;
  NSObject *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v3 = (std::__shared_weak_count *)a1[2];
  if (!v3 || (v5 = a1[1], (v6 = std::__shared_weak_count::lock(v3)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v7 = v6;
  v8 = operator new();
  *(_QWORD *)v8 = a1;
  *(_DWORD *)(v8 + 8) = a2;
  p_shared_owners = (unint64_t *)&v7->__shared_owners_;
  v10 = a1[3];
  do
    v11 = __ldxr(p_shared_owners);
  while (__stxr(v11 + 1, p_shared_owners));
  v12 = (_QWORD *)operator new();
  *v12 = v8;
  v12[1] = v5;
  v12[2] = v7;
  v14 = 0;
  v15 = 0;
  dispatch_async_f(v10, v12, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<NetworkListCommandDriver>::execute_wrapped<QMINetworkListCommandDriver::getNetworkSelectionSetting(subscriber::SimSlot)::$_0>(QMINetworkListCommandDriver::getNetworkSelectionSetting(subscriber::SimSlot)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMINetworkListCommandDriver::getNetworkSelectionSetting(subscriber::SimSlot)::$_0,dispatch_queue_s *::default_delete<QMINetworkListCommandDriver::getNetworkSelectionSetting(subscriber::SimSlot)::$_0>>)::{lambda(void *)#1}::__invoke);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v14);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v15);
  do
    v13 = __ldaxr(p_shared_owners);
  while (__stlxr(v13 - 1, p_shared_owners));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
}

void QMINetworkListCommandDriver::dumpState(QMINetworkListCommandDriver *this)
{
  unsigned __int16 *v1;
  unsigned __int16 *i;
  NSObject *v4;
  int v5;
  int v6;
  int v7;
  uint64_t v8;
  uint8_t buf[4];
  int v10;
  __int16 v11;
  int v12;
  __int16 v13;
  int v14;
  __int16 v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v1 = (unsigned __int16 *)*((_QWORD *)this + 14);
  for (i = (unsigned __int16 *)*((_QWORD *)this + 15); v1 != i; v1 += 3)
  {
    v4 = *((_QWORD *)this + 5);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      v5 = *v1;
      if (*((_BYTE *)v1 + 4))
        v6 = 3;
      else
        v6 = 2;
      v7 = v1[1];
      v8 = CSIBOOLAsString();
      *(_DWORD *)buf = 67109890;
      v10 = v5;
      v11 = 1024;
      v12 = v6;
      v13 = 1024;
      v14 = v7;
      v15 = 2080;
      v16 = v8;
      _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I MCC: %03d MNC: %0.*d three digit: %s", buf, 0x1Eu);
    }
  }
}

void NetworkListOperator::NetworkListOperator(std::string *this, const NetworkListOperator *a2)
{
  __int128 v4;
  std::string *v5;
  __int128 v6;

  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v4 = *(_OWORD *)a2;
    this->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v4;
  }
  LODWORD(this[1].__r_.__value_.__l.__data_) = *((_DWORD *)a2 + 6);
  MCC::MCC();
  MCC::MCC((MCC *)&this[2].__r_.__value_.__r.__words[2], (const NetworkListOperator *)((char *)a2 + 64));
  v5 = this + 4;
  if (*((char *)a2 + 119) < 0)
  {
    std::string::__init_copy_ctor_external(v5, *((const std::string::value_type **)a2 + 12), *((_QWORD *)a2 + 13));
  }
  else
  {
    v6 = *((_OWORD *)a2 + 6);
    this[4].__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 14);
    *(_OWORD *)&v5->__r_.__value_.__l.__data_ = v6;
  }
  *(_OWORD *)&this[5].__r_.__value_.__l.__data_ = *(_OWORD *)((char *)a2 + 120);
}

void sub_216A51A1C(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 95) < 0)
    operator delete(*(void **)(v1 + 72));
  if (*(char *)(v1 + 63) < 0)
    operator delete(*(void **)(v1 + 40));
  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

_BYTE *std::__optional_copy_base<MCCAndMNC,false>::__optional_copy_base[abi:ne180100](_BYTE *a1, uint64_t a2)
{
  *a1 = 0;
  a1[64] = 0;
  if (*(_BYTE *)(a2 + 64))
  {
    MCC::MCC();
    MCC::MCC((MCC *)(a1 + 32), (const MCC *)(a2 + 32));
    a1[64] = 1;
  }
  return a1;
}

void sub_216A51AB8(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 + 31) < 0)
    operator delete(*(void **)(v1 + 8));
  std::__optional_destruct_base<MCCAndMNC,false>::~__optional_destruct_base[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

uint64_t std::__optional_destruct_base<MCCAndMNC,false>::~__optional_destruct_base[abi:ne180100](uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    if (*(char *)(a1 + 63) < 0)
      operator delete(*(void **)(a1 + 40));
    if (*(char *)(a1 + 31) < 0)
      operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

uint64_t *std::shared_ptr<QMINetworkListCommandDriver>::shared_ptr[abi:ne180100]<QMINetworkListCommandDriver,std::shared_ptr<QMINetworkListCommandDriver> ctu::SharedSynchronizable<NetworkListCommandDriver>::make_shared_ptr<QMINetworkListCommandDriver>(QMINetworkListCommandDriver*)::{lambda(QMINetworkListCommandDriver*)#1},void>(uint64_t *a1, uint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24D5E50E0;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = (uint64_t)v4;
  if (a2)
    v5 = (_QWORD *)(a2 + 8);
  else
    v5 = 0;
  std::shared_ptr<QMIDataSystemDeterminationManager>::__enable_weak_this[abi:ne180100]<QMIDataSystemDeterminationManager,QMIDataSystemDeterminationManager,void>((uint64_t)a1, v5, a2);
  return a1;
}

void sub_216A51B98(void *a1)
{
  dispatch_queue_t *v1;

  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)std::shared_ptr<QMINetworkListCommandDriver> ctu::SharedSynchronizable<NetworkListCommandDriver>::make_shared_ptr<QMINetworkListCommandDriver>(QMINetworkListCommandDriver*)::{lambda(QMINetworkListCommandDriver*)#1}::operator() const(QMINetworkListCommandDriver*)::{lambda(void *)#1}::__invoke);
  __cxa_rethrow();
}

void sub_216A51BB8(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<QMINetworkListCommandDriver *,std::shared_ptr<QMINetworkListCommandDriver> ctu::SharedSynchronizable<NetworkListCommandDriver>::make_shared_ptr<QMINetworkListCommandDriver>(QMINetworkListCommandDriver*)::{lambda(QMINetworkListCommandDriver *)#1},std::allocator<QMINetworkListCommandDriver>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void std::__shared_ptr_pointer<QMINetworkListCommandDriver *,std::shared_ptr<QMINetworkListCommandDriver> ctu::SharedSynchronizable<NetworkListCommandDriver>::make_shared_ptr<QMINetworkListCommandDriver>(QMINetworkListCommandDriver*)::{lambda(QMINetworkListCommandDriver *)#1},std::allocator<QMINetworkListCommandDriver>>::__on_zero_shared(uint64_t a1)
{
  dispatch_barrier_async_f(*(dispatch_queue_t *)(*(_QWORD *)(a1 + 24) + 24), *(void **)(a1 + 24), (dispatch_function_t)std::shared_ptr<QMINetworkListCommandDriver> ctu::SharedSynchronizable<NetworkListCommandDriver>::make_shared_ptr<QMINetworkListCommandDriver>(QMINetworkListCommandDriver*)::{lambda(QMINetworkListCommandDriver*)#1}::operator() const(QMINetworkListCommandDriver*)::{lambda(void *)#1}::__invoke);
}

uint64_t std::__shared_ptr_pointer<QMINetworkListCommandDriver *,std::shared_ptr<QMINetworkListCommandDriver> ctu::SharedSynchronizable<NetworkListCommandDriver>::make_shared_ptr<QMINetworkListCommandDriver>(QMINetworkListCommandDriver*)::{lambda(QMINetworkListCommandDriver *)#1},std::allocator<QMINetworkListCommandDriver>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t std::shared_ptr<QMINetworkListCommandDriver> ctu::SharedSynchronizable<NetworkListCommandDriver>::make_shared_ptr<QMINetworkListCommandDriver>(QMINetworkListCommandDriver*)::{lambda(QMINetworkListCommandDriver*)#1}::operator() const(QMINetworkListCommandDriver*)::{lambda(void *)#1}::__invoke(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

void SimInstanceLoggable<QMINetworkListCommandDriver,ctu::OsLogLogger,subscriber::SimSlot>::~SimInstanceLoggable()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t SimInstanceLoggable<QMINetworkListCommandDriver,ctu::OsLogLogger,subscriber::SimSlot>::getLoggerForSlot(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8) + 40;
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<NetworkListCommandDriver>::execute_wrapped<QMINetworkListCommandDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkListCommandDriverDelegateInterface>)::$_0>(QMINetworkListCommandDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkListCommandDriverDelegateInterface>)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMINetworkListCommandDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkListCommandDriverDelegateInterface>)::$_0,std::default_delete<QMINetworkListCommandDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkListCommandDriverDelegateInterface>)::$_0>>)::{lambda(void *)#1}::__invoke(_QWORD **a1)
{
  _QWORD *v1;
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  _DWORD *v11;
  char *v12;
  std::__shared_weak_count *v13;
  uint64_t v14;
  std::__shared_weak_count *v15;
  std::__shared_weak_count *v16;
  unint64_t *p_shared_weak_owners;
  unint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  NSObject *v21;
  std::__shared_weak_count *v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  unint64_t *v26;
  unint64_t v27;
  unint64_t *v28;
  unint64_t v29;
  unint64_t *v30;
  unint64_t v31;
  _DWORD *v32;
  __int128 *p_buf;
  uint64_t v34;
  void **v35;
  uint64_t v36;
  void **v37;
  uint64_t v38;
  __int128 *v39;
  uint64_t v40;
  __int128 *v41;
  uint64_t v42;
  __int128 *v43;
  uint64_t v44;
  _QWORD **v46;
  _QWORD *v47;
  _DWORD *v48;
  _DWORD *v49;
  uint64_t (*v50)(_QWORD);
  __int128 v51;
  __int128 v52;
  uint64_t v53;
  std::__shared_weak_count *v54;
  dispatch_object_t object;
  void *__p[2];
  char v57;
  void **v58;
  void *v59;
  uint64_t v60;
  __int128 v61;
  __int128 buf;
  __int128 v63;
  uint64_t v64;

  v64 = *MEMORY[0x24BDAC8D0];
  v1 = *a1;
  v46 = a1;
  v47 = v1;
  v2 = *v1;
  v3 = *(NSObject **)(*v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl(&dword_216897000, v3, OS_LOG_TYPE_DEFAULT, "#I Bootstraping", (uint8_t *)&buf, 2u);
  }
  v5 = v1[2];
  v4 = v1[3];
  if (v4)
  {
    v6 = (unint64_t *)(v4 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  v8 = *(std::__shared_weak_count **)(v2 + 56);
  *(_QWORD *)(v2 + 48) = v5;
  *(_QWORD *)(v2 + 56) = v4;
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v10 = __ldaxr(p_shared_owners);
    while (__stlxr(v10 - 1, p_shared_owners));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  subscriber::makeSimSlotRange();
  v11 = v48;
  if (v48 != v49)
  {
    while ((v50(*v11) & 1) == 0)
    {
      if (++v11 == v49)
      {
        v11 = v49;
        break;
      }
    }
    while (v11 != v49)
    {
      if (*v11 == 1)
      {
        v12 = "QMINetworkListCommandDriver.1";
      }
      else if (*v11 == 2)
      {
        v12 = "QMINetworkListCommandDriver.2";
      }
      else
      {
        v12 = 0;
      }
      v13 = *(std::__shared_weak_count **)(v2 + 16);
      if (!v13 || (v14 = *(_QWORD *)(v2 + 8), (v15 = std::__shared_weak_count::lock(v13)) == 0))
        std::__throw_bad_weak_ptr[abi:ne180100]();
      v16 = v15;
      p_shared_weak_owners = (unint64_t *)&v15->__shared_weak_owners_;
      do
        v18 = __ldxr(p_shared_weak_owners);
      while (__stxr(v18 + 1, p_shared_weak_owners));
      v19 = (unint64_t *)&v15->__shared_owners_;
      do
        v20 = __ldaxr(v19);
      while (__stlxr(v20 - 1, v19));
      if (!v20)
      {
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v16);
      }
      Registry::getServerConnection(*(Registry **)(v2 + 64));
      buf = 0u;
      v63 = 0u;
      std::string::basic_string[abi:ne180100]<0>(&v59, v12);
      v21 = *(NSObject **)(v2 + 24);
      object = v21;
      if (v21)
        dispatch_retain(v21);
      std::string::basic_string[abi:ne180100]<0>(__p, "registration");
      v53 = 0;
      v54 = 0;
      v22 = std::__shared_weak_count::lock(v16);
      if (v22)
      {
        v23 = v22;
        v24 = (unint64_t *)&v22->__shared_weak_owners_;
        do
          v25 = __ldxr(v24);
        while (__stxr(v25 + 1, v24));
        v53 = v14;
        v54 = v22;
        std::__shared_weak_count::__release_weak(v16);
        v26 = (unint64_t *)&v23->__shared_owners_;
        do
          v27 = __ldaxr(v26);
        while (__stlxr(v27 - 1, v26));
        if (v27)
          goto LABEL_40;
        ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
        v16 = v23;
      }
      else
      {
        v53 = 0;
        v54 = 0;
      }
      std::__shared_weak_count::__release_weak(v16);
LABEL_40:
      v52 = v51;
      v51 = 0uLL;
      qmi::Client::createWithQueueLocal();
      if (*((_QWORD *)&v52 + 1))
      {
        v28 = (unint64_t *)(*((_QWORD *)&v52 + 1) + 8);
        do
          v29 = __ldaxr(v28);
        while (__stlxr(v29 - 1, v28));
        if (!v29)
        {
          (*(void (**)(_QWORD))(**((_QWORD **)&v52 + 1) + 16))(*((_QWORD *)&v52 + 1));
          std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v52 + 1));
        }
      }
      if (v54)
        std::__shared_weak_count::__release_weak(v54);
      if (v57 < 0)
        operator delete(__p[0]);
      if (object)
        dispatch_release(object);
      if (SBYTE7(v61) < 0)
        operator delete(v59);
      v59 = 0;
      v60 = 0;
      v61 = v63;
      v63 = 0uLL;
      qmi::ClientRouter::addClient();
      qmi::Client::~Client((qmi::Client *)&v59);
      qmi::ClientRouter::get();
      qmi::Client::~Client((qmi::Client *)&buf);
      if (*((_QWORD *)&v51 + 1))
      {
        v30 = (unint64_t *)(*((_QWORD *)&v51 + 1) + 8);
        do
          v31 = __ldaxr(v30);
        while (__stlxr(v31 - 1, v30));
        if (!v31)
        {
          (*(void (**)(_QWORD))(**((_QWORD **)&v51 + 1) + 16))(*((_QWORD *)&v51 + 1));
          std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v51 + 1));
        }
      }
      v32 = v11 + 1;
      v11 = v49;
      if (v32 != v49)
      {
        v11 = v32;
        while ((v50(*v11) & 1) == 0)
        {
          if (++v11 == v49)
          {
            v11 = v49;
            break;
          }
        }
      }
    }
  }
  *(_QWORD *)&buf = &off_24D5E5180;
  *((_QWORD *)&buf + 1) = v2;
  *((_QWORD *)&v63 + 1) = &buf;
  qmi::ClientRouter::setHandler();
  p_buf = (__int128 *)*((_QWORD *)&v63 + 1);
  if (*((__int128 **)&v63 + 1) == &buf)
  {
    v34 = 4;
    p_buf = &buf;
  }
  else
  {
    if (!*((_QWORD *)&v63 + 1))
      goto LABEL_69;
    v34 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)p_buf + 8 * v34))();
LABEL_69:
  v59 = &off_24D5E5200;
  v60 = v2;
  *((_QWORD *)&v61 + 1) = &v59;
  qmi::ClientRouter::setHandler();
  v35 = (void **)*((_QWORD *)&v61 + 1);
  if (*((void ***)&v61 + 1) == &v59)
  {
    v36 = 4;
    v35 = &v59;
  }
  else
  {
    if (!*((_QWORD *)&v61 + 1))
      goto LABEL_74;
    v36 = 5;
  }
  (*((void (**)(void))*v35 + v36))();
LABEL_74:
  __p[0] = &off_24D5E5280;
  __p[1] = (void *)v2;
  v58 = __p;
  qmi::ClientRouter::setHandler();
  v37 = v58;
  if (v58 == __p)
  {
    v38 = 4;
    v37 = __p;
  }
  else
  {
    if (!v58)
      goto LABEL_79;
    v38 = 5;
  }
  (*((void (**)(void))*v37 + v38))();
LABEL_79:
  *(_QWORD *)&buf = &off_24D5E5300;
  *((_QWORD *)&buf + 1) = v2;
  *((_QWORD *)&v63 + 1) = &buf;
  qmi::ClientRouter::setIndHandlerInternal();
  v39 = (__int128 *)*((_QWORD *)&v63 + 1);
  if (*((__int128 **)&v63 + 1) == &buf)
  {
    v40 = 4;
    v39 = &buf;
  }
  else
  {
    if (!*((_QWORD *)&v63 + 1))
      goto LABEL_84;
    v40 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v39 + 8 * v40))();
LABEL_84:
  qmi::ClientRouter::setIndShouldWake((qmi::ClientRouter *)(v2 + 96));
  *(_QWORD *)&buf = &off_24D5E5380;
  *((_QWORD *)&buf + 1) = v2;
  *((_QWORD *)&v63 + 1) = &buf;
  qmi::ClientRouter::setIndHandlerInternal();
  v41 = (__int128 *)*((_QWORD *)&v63 + 1);
  if (*((__int128 **)&v63 + 1) == &buf)
  {
    v42 = 4;
    v41 = &buf;
  }
  else
  {
    if (!*((_QWORD *)&v63 + 1))
      goto LABEL_89;
    v42 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v41 + 8 * v42))();
LABEL_89:
  qmi::ClientRouter::setIndShouldWake((qmi::ClientRouter *)(v2 + 96));
  *(_QWORD *)&buf = &off_24D5E5400;
  *((_QWORD *)&buf + 1) = v2;
  *((_QWORD *)&v63 + 1) = &buf;
  qmi::ClientRouter::setIndHandlerInternal();
  v43 = (__int128 *)*((_QWORD *)&v63 + 1);
  if (*((__int128 **)&v63 + 1) == &buf)
  {
    v44 = 4;
    v43 = &buf;
    goto LABEL_93;
  }
  if (*((_QWORD *)&v63 + 1))
  {
    v44 = 5;
LABEL_93:
    (*(void (**)(void))(*(_QWORD *)v43 + 8 * v44))();
  }
  qmi::ClientRouter::setIndShouldWake((qmi::ClientRouter *)(v2 + 96));
  std::unique_ptr<QMIEnhancedLQMCommandDriver::bootstrap(dispatch::group_session,std::shared_ptr<EnhancedLQMCommandDriverDelegateInterface>)::$_0,std::default_delete<QMIEnhancedLQMCommandDriver::bootstrap(dispatch::group_session,std::shared_ptr<EnhancedLQMCommandDriverDelegateInterface>)::$_0>>::~unique_ptr[abi:ne180100]((uint64_t *)&v47);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v46);
}

void sub_216A522AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,std::__shared_weak_count *a23,dispatch_object_t object,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,void *__p,uint64_t a33,int a34,__int16 a35,char a36,char a37,uint64_t a38)
{
  _QWORD *v38;
  uint64_t v39;
  _QWORD *v41;
  uint64_t v42;

  v41 = *(_QWORD **)(v39 - 120);
  if (v41 == v38)
  {
    v42 = 4;
    v41 = (_QWORD *)(v39 - 144);
  }
  else
  {
    if (!v41)
      goto LABEL_6;
    v42 = 5;
  }
  (*(void (**)(void))(*v41 + 8 * v42))();
LABEL_6:
  std::unique_ptr<QMIEnhancedLQMCommandDriver::bootstrap(dispatch::group_session,std::shared_ptr<EnhancedLQMCommandDriverDelegateInterface>)::$_0,std::default_delete<QMIEnhancedLQMCommandDriver::bootstrap(dispatch::group_session,std::shared_ptr<EnhancedLQMCommandDriverDelegateInterface>)::$_0>>::~unique_ptr[abi:ne180100](&a13);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&a12);
  _Unwind_Resume(a1);
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<NetworkListCommandDriver>::execute_wrapped<QMINetworkListCommandDriver::start(void)::$_0>(QMINetworkListCommandDriver::start(void)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMINetworkListCommandDriver::start(void)::$_0,dispatch_queue_s *::default_delete<QMINetworkListCommandDriver::start(void)::$_0>>)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  uint64_t v4;
  uint8_t buf[16];

  v4 = a1;
  v1 = *(_QWORD *)a1;
  v2 = *(NSObject **)(**(_QWORD **)a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_216897000, v2, OS_LOG_TYPE_DEFAULT, "#I Starting", buf, 2u);
  }
  qmi::ClientRouter::start();
  MEMORY[0x2199FEAC4](v1, 0x20C4093837F09);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v4);
}

void sub_216A524B4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  va_list va;

  va_start(va, a2);
  MEMORY[0x2199FEAC4](v2, 0x20C4093837F09);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<NetworkListCommandDriver>::execute_wrapped<QMINetworkListCommandDriver::shutdown(dispatch::group_session)::$_0>(QMINetworkListCommandDriver::shutdown(dispatch::group_session)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMINetworkListCommandDriver::shutdown(dispatch::group_session)::$_0,dispatch_queue_s *::default_delete<QMINetworkListCommandDriver::shutdown(dispatch::group_session)::$_0>>)::{lambda(void *)#1}::__invoke(uint64_t *a1)
{
  uint64_t v1;
  NSObject *v2;
  uint64_t *v4;
  uint64_t v5;
  uint8_t buf[16];

  v1 = *a1;
  v4 = a1;
  v5 = v1;
  v2 = *(NSObject **)(*(_QWORD *)v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_216897000, v2, OS_LOG_TYPE_DEFAULT, "#I Shutting down", buf, 2u);
  }
  qmi::ClientRouter::stop();
  std::unique_ptr<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0,std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>>::~unique_ptr[abi:ne180100](&v5);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v4);
}

void sub_216A52564(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  std::unique_ptr<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0,std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>>::~unique_ptr[abi:ne180100](&a10);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

void std::__function::__func<QMINetworkListCommandDriver::registerEvents_sync(void)::$_0,std::allocator<QMINetworkListCommandDriver::registerEvents_sync(void)::$_0>,void ()(qmi::SubscriptionType)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<QMINetworkListCommandDriver::registerEvents_sync(void)::$_0,std::allocator<QMINetworkListCommandDriver::registerEvents_sync(void)::$_0>,void ()(qmi::SubscriptionType)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5E5180;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<QMINetworkListCommandDriver::registerEvents_sync(void)::$_0,std::allocator<QMINetworkListCommandDriver::registerEvents_sync(void)::$_0>,void ()(qmi::SubscriptionType)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5E5180;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<QMINetworkListCommandDriver::registerEvents_sync(void)::$_0,std::allocator<QMINetworkListCommandDriver::registerEvents_sync(void)::$_0>,void ()(qmi::SubscriptionType)>::operator()(capabilities::ct *a1, int *a2)
{
  int v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  uint64_t v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  const void **v16;
  char *v17;
  _BYTE *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  char *v26;
  uint64_t *v27;
  char *v28;
  char *v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  std::__shared_weak_count *v33;
  unint64_t *v34;
  uint64_t v35;
  unint64_t v36;
  std::__shared_weak_count *v37;
  unint64_t *v38;
  unint64_t v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t result;
  uint64_t v43;
  uint64_t v44;
  void *__p[2];
  __int128 v46;
  uint64_t v47;
  uint64_t v48;
  void (*v49)(uint64_t, uint64_t);
  void *v50;
  std::__shared_weak_count *v51;
  std::__shared_weak_count *v52;
  uint64_t aBlock;
  uint64_t v54;
  void (*v55)(uint64_t, uint64_t);
  void *v56;
  uint64_t *v57;

  v2 = *a2;
  v3 = *((_QWORD *)a1 + 1);
  v4 = capabilities::ct::supportsGemini(a1);
  v5 = MEMORY[0x24BDAC760];
  if (v4)
  {
    *(_OWORD *)__p = 0u;
    v46 = 0u;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
    *(_BYTE *)qmi::MutableMessageBase::getTLV<nas::tlv::SubType>(__p, 1) = v2 == 2;
    v6 = qmi::ClientRouter::get();
    qmi::ClientRouter::SendProxy::SendProxy<nas::BindSubscription::Request>((uint64_t)&v43, v2, v6);
    v7 = (std::__shared_weak_count *)operator new(0x28uLL);
    v7->__shared_owners_ = 0;
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    v7->__shared_weak_owners_ = 0;
    v7->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E54B0;
    v7[1].__vftable = (std::__shared_weak_count_vtbl *)v3;
    LODWORD(v7[1].__shared_owners_) = v2;
    v9 = v44;
    v47 = v5;
    v48 = 1174405120;
    v49 = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN27QMINetworkListCommandDriver21bindSubscription_syncENS_16SubscriptionTypeEE3__0EEOS1_OT__block_invoke;
    v50 = &__block_descriptor_tmp_37;
    v51 = v7 + 1;
    v52 = v7;
    do
      v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
    aBlock = v5;
    v54 = 0x40000000;
    v55 = ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas16BindSubscription8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke_6;
    v56 = &unk_24D5E54F8;
    v57 = &v47;
    *(_QWORD *)(v9 + 32) = _Block_copy(&aBlock);
    v11 = v52;
    if (v52)
    {
      v12 = (unint64_t *)&v52->__shared_owners_;
      do
        v13 = __ldaxr(v12);
      while (__stlxr(v13 - 1, v12));
      if (!v13)
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
    }
    do
      v14 = __ldaxr(p_shared_owners);
    while (__stlxr(v14 - 1, p_shared_owners));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
    v15 = v44;
    v44 = 0;
    if (v15)
      std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v44, v15);
    qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
  }
  *(_OWORD *)__p = 0u;
  v46 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  *(_BYTE *)qmi::MutableMessageBase::getTLV<nas::tlv::ServingSysEvents>(__p, 19) = 0;
  *(_BYTE *)qmi::MutableMessageBase::getTLV<nas::tlv::SysInfoEvents>(__p, 24) = 0;
  v16 = (const void **)__p[1];
  if (__p[1] != (void *)v46)
  {
    while (*((unsigned __int8 *)*v16 + 8) != 209)
    {
      if (++v16 == (const void **)v46)
        goto LABEL_22;
    }
  }
  if (v16 == (const void **)v46)
  {
LABEL_22:
    v19 = operator new();
    v20 = v19;
    *(_WORD *)(v19 + 8) = 209;
    *(_QWORD *)v19 = &off_24D5E5540;
    v21 = v46;
    if ((unint64_t)v46 >= *((_QWORD *)&v46 + 1))
    {
      v23 = (uint64_t)(v46 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v23 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v24 = (uint64_t)(*((_QWORD *)&v46 + 1) - (unint64_t)__p[1]) >> 2;
      if (v24 <= v23 + 1)
        v24 = v23 + 1;
      if (*((_QWORD *)&v46 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v25 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v25 = v24;
      if (v25)
        v26 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v46 + 8, v25);
      else
        v26 = 0;
      v27 = (uint64_t *)&v26[8 * v23];
      v28 = &v26[8 * v25];
      *v27 = v20;
      v22 = v27 + 1;
      v30 = (char *)__p[1];
      v29 = (char *)v46;
      if ((void *)v46 != __p[1])
      {
        do
        {
          v31 = *((_QWORD *)v29 - 1);
          v29 -= 8;
          *--v27 = v31;
        }
        while (v29 != v30);
        v29 = (char *)__p[1];
      }
      __p[1] = v27;
      *(_QWORD *)&v46 = v22;
      *((_QWORD *)&v46 + 1) = v28;
      if (v29)
        operator delete(v29);
    }
    else
    {
      *(_QWORD *)v46 = v19;
      v22 = (_QWORD *)(v21 + 8);
    }
    v18 = (_BYTE *)(v20 + 9);
    *(_QWORD *)&v46 = v22;
  }
  else
  {
    if (!v17)
      __cxa_bad_cast();
    v18 = v17 + 9;
  }
  *v18 = 1;
  v32 = qmi::ClientRouter::get();
  qmi::ClientRouter::SendProxy::SendProxy<nas::IndicationRegister::Request>((uint64_t)&v43, v2, v32);
  v33 = (std::__shared_weak_count *)operator new(0x28uLL);
  v33->__shared_owners_ = 0;
  v34 = (unint64_t *)&v33->__shared_owners_;
  v33->__shared_weak_owners_ = 0;
  v33->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E55A8;
  v33[1].__vftable = (std::__shared_weak_count_vtbl *)v3;
  LODWORD(v33[1].__shared_owners_) = v2;
  v35 = v44;
  v47 = v5;
  v48 = 1174405120;
  v49 = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN27QMINetworkListCommandDriver27sendIndRegisterRequest_syncENS_16SubscriptionTypeEE3__3EEOS1_OT__block_invoke;
  v50 = &__block_descriptor_tmp_14_15;
  v51 = v33 + 1;
  v52 = v33;
  do
    v36 = __ldxr(v34);
  while (__stxr(v36 + 1, v34));
  aBlock = v5;
  v54 = 0x40000000;
  v55 = ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas18IndicationRegister8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke_3;
  v56 = &unk_24D5E55F0;
  v57 = &v47;
  *(_QWORD *)(v35 + 32) = _Block_copy(&aBlock);
  v37 = v52;
  if (v52)
  {
    v38 = (unint64_t *)&v52->__shared_owners_;
    do
      v39 = __ldaxr(v38);
    while (__stlxr(v39 - 1, v38));
    if (!v39)
    {
      ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
      std::__shared_weak_count::__release_weak(v37);
    }
  }
  do
    v40 = __ldaxr(v34);
  while (__stlxr(v40 - 1, v34));
  if (!v40)
  {
    ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
    std::__shared_weak_count::__release_weak(v33);
  }
  v41 = v44;
  v44 = 0;
  if (v41)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v44, v41);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
  result = qmi::NotifyHelper::shouldNotifyStart(*(_QWORD **)(v3 + 152));
  if ((_DWORD)result)
    return (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v3 + 48) + 16))(*(_QWORD *)(v3 + 48), 1);
  return result;
}

void sub_216A52AC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21)
{
  std::__shared_weak_count *v21;
  unint64_t *v22;
  std::__shared_weak_count *v24;
  unint64_t *p_shared_owners;
  unint64_t v26;
  unint64_t v27;
  uint64_t v28;

  v24 = a21;
  if (a21)
  {
    p_shared_owners = (unint64_t *)&a21->__shared_owners_;
    do
      v26 = __ldaxr(p_shared_owners);
    while (__stlxr(v26 - 1, p_shared_owners));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
  }
  do
    v27 = __ldaxr(v22);
  while (__stlxr(v27 - 1, v22));
  if (!v27)
  {
    ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
    std::__shared_weak_count::__release_weak(v21);
  }
  v28 = a10;
  a10 = 0;
  if (v28)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&a10, v28);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a11);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<QMINetworkListCommandDriver::registerEvents_sync(void)::$_0,std::allocator<QMINetworkListCommandDriver::registerEvents_sync(void)::$_0>,void ()(qmi::SubscriptionType)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<QMINetworkListCommandDriver::registerEvents_sync(void)::$_0,std::allocator<QMINetworkListCommandDriver::registerEvents_sync(void)::$_0>,void ()(qmi::SubscriptionType)>::target_type()
{
}

void std::__function::__func<QMINetworkListCommandDriver::registerEvents_sync(void)::$_1,std::allocator<QMINetworkListCommandDriver::registerEvents_sync(void)::$_1>,void ()(qmi::SubscriptionType)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<QMINetworkListCommandDriver::registerEvents_sync(void)::$_1,std::allocator<QMINetworkListCommandDriver::registerEvents_sync(void)::$_1>,void ()(qmi::SubscriptionType)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5E5200;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<QMINetworkListCommandDriver::registerEvents_sync(void)::$_1,std::allocator<QMINetworkListCommandDriver::registerEvents_sync(void)::$_1>,void ()(qmi::SubscriptionType)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5E5200;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<QMINetworkListCommandDriver::registerEvents_sync(void)::$_1,std::allocator<QMINetworkListCommandDriver::registerEvents_sync(void)::$_1>,void ()(qmi::SubscriptionType)>::operator()(uint64_t a1)
{
  uint64_t v1;
  uint64_t result;

  v1 = *(_QWORD *)(a1 + 8);
  result = qmi::NotifyHelper::shouldNotifyStop(*(unint64_t ***)(v1 + 152));
  if ((_DWORD)result)
    return (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(v1 + 48) + 16))(*(_QWORD *)(v1 + 48), 0);
  return result;
}

uint64_t std::__function::__func<QMINetworkListCommandDriver::registerEvents_sync(void)::$_1,std::allocator<QMINetworkListCommandDriver::registerEvents_sync(void)::$_1>,void ()(qmi::SubscriptionType)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<QMINetworkListCommandDriver::registerEvents_sync(void)::$_1,std::allocator<QMINetworkListCommandDriver::registerEvents_sync(void)::$_1>,void ()(qmi::SubscriptionType)>::target_type()
{
}

void std::__function::__func<QMINetworkListCommandDriver::registerEvents_sync(void)::$_2,std::allocator<QMINetworkListCommandDriver::registerEvents_sync(void)::$_2>,void ()(qmi::SubscriptionType)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<QMINetworkListCommandDriver::registerEvents_sync(void)::$_2,std::allocator<QMINetworkListCommandDriver::registerEvents_sync(void)::$_2>,void ()(qmi::SubscriptionType)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5E5280;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<QMINetworkListCommandDriver::registerEvents_sync(void)::$_2,std::allocator<QMINetworkListCommandDriver::registerEvents_sync(void)::$_2>,void ()(qmi::SubscriptionType)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5E5280;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<QMINetworkListCommandDriver::registerEvents_sync(void)::$_2,std::allocator<QMINetworkListCommandDriver::registerEvents_sync(void)::$_2>,void ()(qmi::SubscriptionType)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<QMINetworkListCommandDriver::registerEvents_sync(void)::$_2,std::allocator<QMINetworkListCommandDriver::registerEvents_sync(void)::$_2>,void ()(qmi::SubscriptionType)>::target_type()
{
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkListCommandDriver::registerIndications_sync(void)::$_0>(unsigned short,QMINetworkListCommandDriver::registerIndications_sync(void)::$_0 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMINetworkListCommandDriver::registerIndications_sync(void)::$_0 &&,QMIServiceMsg const)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkListCommandDriver::registerIndications_sync(void)::$_0>(unsigned short,QMINetworkListCommandDriver::registerIndications_sync(void)::$_0 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMINetworkListCommandDriver::registerIndications_sync(void)::$_0 &&,QMIServiceMsg const)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5E5300;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkListCommandDriver::registerIndications_sync(void)::$_0>(unsigned short,QMINetworkListCommandDriver::registerIndications_sync(void)::$_0 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMINetworkListCommandDriver::registerIndications_sync(void)::$_0 &&,QMIServiceMsg const)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5E5300;
  a2[1] = v2;
  return result;
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkListCommandDriver::registerIndications_sync(void)::$_0>(unsigned short,QMINetworkListCommandDriver::registerIndications_sync(void)::$_0 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMINetworkListCommandDriver::registerIndications_sync(void)::$_0 &&,QMIServiceMsg const)>::operator()(uint64_t a1, unsigned int *a2, QMIServiceMsg *this)
{
  unsigned int v4;
  uint64_t v6;
  uint64_t v7;
  os_log_t *v8;
  uint64_t TlvValue;
  int v10;
  uint64_t v11;
  int v12;
  unint64_t v13;
  NSObject *v14;
  int IntValue;
  int IntegerWidth;
  int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int v21;
  unint64_t v22;
  NSObject *v23;
  int v24;
  int v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  _WORD v29[12];
  void *v30[2];
  __int128 v31;
  void *__p[2];
  __int128 v33;
  __int128 v34;
  __int128 v35;
  uint64_t v36;
  int v37;
  __int16 v38;
  uint64_t v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  void *v44;
  char v45;
  __int128 buf;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  uint64_t v50;
  uint64_t v51;

  v51 = *MEMORY[0x24BDAC8D0];
  v4 = *a2;
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p[0] = 0;
    __p[1] = 0;
    *(_QWORD *)&v33 = 0;
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v29, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v29);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v29);
  }
  v6 = *(_QWORD *)(a1 + 8);
  if (v4 - 1 >= 3)
    v7 = 0;
  else
    v7 = v4;
  v8 = (os_log_t *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v6 + 88) + 16))(*(_QWORD *)(v6 + 88), v7);
  v36 = 0;
  v34 = 0u;
  v35 = 0u;
  *(_OWORD *)__p = 0u;
  v33 = 0u;
  TlvValue = qmi::MessageBase::findTlvValue((qmi::MessageBase *)v29);
  v11 = TlvValue;
  if (TlvValue)
  {
    v12 = v10;
    *(_QWORD *)&v40 = TlvValue;
    v13 = tlv::parseV<nas::tlv::ManuallySelectedPLMN>((unint64_t *)&v40, v10);
    LODWORD(v39) = v13;
    WORD2(v39) = WORD2(v13);
    if ((_QWORD)v40)
    {
      v42 = 0u;
      v43 = 0u;
      MCC::MCC((MCC *)&v42);
      *(_OWORD *)v30 = 0u;
      v31 = 0u;
      MNC::MNC((MNC *)v30);
      convertMccAndMnc((unsigned __int8 *)&v39, (unsigned __int8 *)&v39 + 3, (const MCC *)&v42, (const MNC *)v30);
      v14 = *v8;
      if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
      {
        IntValue = MCC::getIntValue((MCC *)&v42);
        IntegerWidth = MNC::getIntegerWidth((MNC *)v30);
        v17 = MCC::getIntValue((MCC *)v30);
        LODWORD(buf) = 67109632;
        DWORD1(buf) = IntValue;
        WORD4(buf) = 1024;
        *(_DWORD *)((char *)&buf + 10) = IntegerWidth;
        HIWORD(buf) = 1024;
        LODWORD(v47) = v17;
        _os_log_impl(&dword_216897000, v14, OS_LOG_TYPE_DEFAULT, "#I Manually selected PLMN %03d-%0.*d", (uint8_t *)&buf, 0x14u);
      }
      MEMORY[0x2199FE380](&buf, &v42, v30);
      std::optional<MCCAndMNC>::operator=[abi:ne180100]<MCCAndMNC,void>((uint64_t)__p, (uint64_t)&buf);
      if (SHIBYTE(v49) < 0)
        operator delete(*((void **)&v48 + 1));
      if (SHIBYTE(v47) < 0)
        operator delete(*((void **)&buf + 1));
      if (SHIBYTE(v31) < 0)
        operator delete(v30[1]);
      if (SHIBYTE(v43) < 0)
        operator delete(*((void **)&v42 + 1));
    }
    else
    {
      ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(v29[0], 16, v11, v12);
    }
  }
  v50 = 0;
  v48 = 0u;
  v49 = 0u;
  buf = 0u;
  v47 = 0u;
  v18 = qmi::MessageBase::findTlvValue((qmi::MessageBase *)v29);
  v20 = v18;
  if (v18)
  {
    v21 = v19;
    v39 = v18;
    v22 = tlv::parseV<nas::tlv::BasebandSelectedPLMN>((unint64_t *)&v39, v19);
    v37 = v22;
    v38 = WORD2(v22);
    if (v39)
    {
      *(_OWORD *)v30 = 0u;
      v31 = 0u;
      MCC::MCC((MCC *)v30);
      v40 = 0u;
      v41 = 0u;
      MNC::MNC((MNC *)&v40);
      convertMccAndMnc((unsigned __int8 *)&v37, (unsigned __int8 *)&v37 + 3, (const MCC *)v30, (const MNC *)&v40);
      v23 = *v8;
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        v24 = MCC::getIntValue((MCC *)v30);
        v25 = MNC::getIntegerWidth((MNC *)&v40);
        v26 = MCC::getIntValue((MCC *)&v40);
        LODWORD(v42) = 67109632;
        DWORD1(v42) = v24;
        WORD4(v42) = 1024;
        *(_DWORD *)((char *)&v42 + 10) = v25;
        HIWORD(v42) = 1024;
        LODWORD(v43) = v26;
        _os_log_impl(&dword_216897000, v23, OS_LOG_TYPE_DEFAULT, "#I Baseband selected PLMN %03d-%0.*d", (uint8_t *)&v42, 0x14u);
      }
      MEMORY[0x2199FE380](&v42, v30, &v40);
      std::optional<MCCAndMNC>::operator=[abi:ne180100]<MCCAndMNC,void>((uint64_t)&buf, (uint64_t)&v42);
      if (v45 < 0)
        operator delete(v44);
      if (SHIBYTE(v43) < 0)
        operator delete(*((void **)&v42 + 1));
      if (SHIBYTE(v41) < 0)
        operator delete(*((void **)&v40 + 1));
      if (SHIBYTE(v31) < 0)
        operator delete(v30[1]);
    }
    else
    {
      ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(v29[0], 17, v20, v21);
    }
  }
  v27 = *(_QWORD *)(v6 + 48);
  if (v4 - 1 >= 3)
    v28 = 0;
  else
    v28 = v4;
  std::__optional_copy_base<MCCAndMNC,false>::__optional_copy_base[abi:ne180100](&v42, (uint64_t)__p);
  std::__optional_copy_base<MCCAndMNC,false>::__optional_copy_base[abi:ne180100](v30, (uint64_t)&buf);
  (*(void (**)(uint64_t, uint64_t, __int128 *, void **))(*(_QWORD *)v27 + 48))(v27, v28, &v42, v30);
  std::__optional_destruct_base<MCCAndMNC,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)v30);
  std::__optional_destruct_base<MCCAndMNC,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&v42);
  std::__optional_destruct_base<MCCAndMNC,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&buf);
  std::__optional_destruct_base<MCCAndMNC,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)__p);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v29);
}

void sub_216A532A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,void *a39,uint64_t a40,int a41,__int16 a42,char a43,char a44,char a45,void *a46,uint64_t a47,int a48,__int16 a49,char a50,char a51,uint64_t a52,void *__p,uint64_t a54,int a55,__int16 a56,char a57,char a58)
{
  uint64_t v58;

  if (a58 < 0)
    operator delete(__p);
  if (a51 < 0)
    operator delete(a46);
  if (a44 < 0)
    operator delete(a39);
  if (a19 < 0)
    operator delete(a14);
  std::__optional_destruct_base<MCCAndMNC,false>::~__optional_destruct_base[abi:ne180100](v58 - 160);
  std::__optional_destruct_base<MCCAndMNC,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&a26);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a10);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkListCommandDriver::registerIndications_sync(void)::$_0>(unsigned short,QMINetworkListCommandDriver::registerIndications_sync(void)::$_0 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMINetworkListCommandDriver::registerIndications_sync(void)::$_0 &&,QMIServiceMsg const)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkListCommandDriver::registerIndications_sync(void)::$_0>(unsigned short,QMINetworkListCommandDriver::registerIndications_sync(void)::$_0 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMINetworkListCommandDriver::registerIndications_sync(void)::$_0 &&,QMIServiceMsg const)>::target_type()
{
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkListCommandDriver::registerIndications_sync(void)::$_1>(unsigned short,QMINetworkListCommandDriver::registerIndications_sync(void)::$_1 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMINetworkListCommandDriver::registerIndications_sync(void)::$_1 &&,QMIServiceMsg const)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkListCommandDriver::registerIndications_sync(void)::$_1>(unsigned short,QMINetworkListCommandDriver::registerIndications_sync(void)::$_1 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMINetworkListCommandDriver::registerIndications_sync(void)::$_1 &&,QMIServiceMsg const)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5E5380;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkListCommandDriver::registerIndications_sync(void)::$_1>(unsigned short,QMINetworkListCommandDriver::registerIndications_sync(void)::$_1 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMINetworkListCommandDriver::registerIndications_sync(void)::$_1 &&,QMIServiceMsg const)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5E5380;
  a2[1] = v2;
  return result;
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkListCommandDriver::registerIndications_sync(void)::$_1>(unsigned short,QMINetworkListCommandDriver::registerIndications_sync(void)::$_1 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMINetworkListCommandDriver::registerIndications_sync(void)::$_1 &&,QMIServiceMsg const)>::operator()(uint64_t a1, unsigned int *a2, QMIServiceMsg *this)
{
  unsigned int v4;
  uint64_t v6;
  void *TlvValue;
  int v8;
  void *v9;
  int v10;
  BOOL v11;
  uint64_t v12;
  uint64_t v13;
  _WORD v14[12];
  void *__p;
  void *v16;
  uint64_t v17;

  v4 = *a2;
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v16 = 0;
    v17 = 0;
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v14, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v14);
    if (__p)
    {
      v16 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v14);
  }
  v6 = *(_QWORD *)(a1 + 8);
  TlvValue = (void *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)v14);
  v9 = TlvValue;
  if (TlvValue)
  {
    v10 = v8;
    __p = TlvValue;
    v11 = tlv::parseV<nas::tlv::PlmnMode>((unint64_t *)&__p, v8);
    if (__p)
    {
      if (v4 - 1 >= 3)
        v12 = 0;
      else
        v12 = v4;
      if (v11)
        v13 = 2;
      else
        v13 = 1;
      (*(void (**)(_QWORD, uint64_t, uint64_t))(**(_QWORD **)(v6 + 48) + 56))(*(_QWORD *)(v6 + 48), v12, v13);
    }
    else
    {
      ((void (*)(_QWORD, uint64_t, void *, _QWORD))*MEMORY[0x24BED8BD0])(v14[0], 16, v9, v10);
    }
  }
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v14);
}

void sub_216A535DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkListCommandDriver::registerIndications_sync(void)::$_1>(unsigned short,QMINetworkListCommandDriver::registerIndications_sync(void)::$_1 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMINetworkListCommandDriver::registerIndications_sync(void)::$_1 &&,QMIServiceMsg const)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkListCommandDriver::registerIndications_sync(void)::$_1>(unsigned short,QMINetworkListCommandDriver::registerIndications_sync(void)::$_1 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMINetworkListCommandDriver::registerIndications_sync(void)::$_1 &&,QMIServiceMsg const)>::target_type()
{
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkListCommandDriver::registerIndications_sync(void)::$_2>(unsigned short,QMINetworkListCommandDriver::registerIndications_sync(void)::$_2 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMINetworkListCommandDriver::registerIndications_sync(void)::$_2 &&,QMIServiceMsg const)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkListCommandDriver::registerIndications_sync(void)::$_2>(unsigned short,QMINetworkListCommandDriver::registerIndications_sync(void)::$_2 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMINetworkListCommandDriver::registerIndications_sync(void)::$_2 &&,QMIServiceMsg const)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5E5400;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkListCommandDriver::registerIndications_sync(void)::$_2>(unsigned short,QMINetworkListCommandDriver::registerIndications_sync(void)::$_2 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMINetworkListCommandDriver::registerIndications_sync(void)::$_2 &&,QMIServiceMsg const)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5E5400;
  a2[1] = v2;
  return result;
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkListCommandDriver::registerIndications_sync(void)::$_2>(unsigned short,QMINetworkListCommandDriver::registerIndications_sync(void)::$_2 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMINetworkListCommandDriver::registerIndications_sync(void)::$_2 &&,QMIServiceMsg const)>::operator()(uint64_t a1, unsigned int *a2, QMIServiceMsg *this)
{
  unsigned int v4;
  uint64_t v6;
  std::__shared_weak_count *v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t TlvValue;
  int v11;
  unsigned __int16 v12;
  unsigned __int16 v13;
  NSObject *v14;
  const char *v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  unsigned int *v21;
  unsigned int *v22;
  char *v23;
  char *v24;
  char *v25;
  int v26;
  int v27;
  char *v28;
  uint64_t v29;
  unint64_t v30;
  unint64_t v31;
  char *v32;
  char *v33;
  int v34;
  NSObject *v35;
  unsigned __int16 *v36;
  int v37;
  unsigned __int16 *v38;
  int v39;
  uint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unsigned int v43;
  uint64_t v44;
  NSObject *v45;
  void **v46;
  uint64_t v47;
  uint64_t v48;
  std::__shared_weak_count *v49;
  uint64_t v51;
  uint64_t v52;
  unint64_t *p_shared_owners;
  unint64_t v54;
  std::__shared_weak_count *v55;
  unint64_t *v56;
  unint64_t v57;
  unint64_t *v58;
  unint64_t v59;
  int v60;
  uint64_t v61;
  uint64_t v62;
  unsigned int v63;
  unsigned int v64;
  uint64_t v65;
  uint64_t v66;
  unsigned int v67;
  unsigned int v68;
  std::__shared_weak_count *v69;
  os_log_t *v70;
  _WORD v71[12];
  std::__shared_weak_count *v72;
  std::__shared_weak_count *v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  unsigned __int16 *v77;
  char v78[8];
  void *__p;
  char v80;
  char v81[8];
  void *v82;
  char v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  void *v88[2];
  uint64_t v89;
  _BYTE buf[32];
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  uint64_t v97;
  uint64_t v98;

  v98 = *MEMORY[0x24BDAC8D0];
  v4 = *a2;
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    memset(buf, 0, 24);
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v71, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v71);
    if (*(_QWORD *)buf)
    {
      *(_QWORD *)&buf[8] = *(_QWORD *)buf;
      operator delete(*(void **)buf);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v71);
  }
  v6 = *(_QWORD *)(a1 + 8);
  v7 = (std::__shared_weak_count *)operator new(0x38uLL);
  v7->__shared_owners_ = 0;
  v7->__shared_weak_owners_ = 0;
  v7->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E5B90;
  v7[1].std::__shared_count = 0u;
  *(_OWORD *)&v7[1].__shared_weak_owners_ = 0u;
  v69 = v7 + 1;
  v72 = v7 + 1;
  v73 = v7;
  v8 = v4 - 1;
  if (v4 - 1 >= 3)
    v9 = 0;
  else
    v9 = v4;
  v70 = (os_log_t *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v6 + 88) + 16))(*(_QWORD *)(v6 + 88), v9);
  TlvValue = qmi::MessageBase::findTlvValue((qmi::MessageBase *)v71);
  if (TlvValue)
  {
    *(_QWORD *)&v84 = TlvValue;
    v12 = tlv::parseV<nas::tlv::ScanStatus>((unint64_t *)&v84, v11);
    if (!(_QWORD)v84)
    {
      v35 = *v70;
      if (os_log_type_enabled(*v70, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_216897000, v35, OS_LOG_TYPE_ERROR, "Did not find incremental scan status TLV", buf, 2u);
      }
      goto LABEL_96;
    }
    v13 = v12;
    v14 = *v70;
    if (os_log_type_enabled(*v70, OS_LOG_TYPE_DEFAULT))
    {
      v15 = nas::asString(v13);
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = v15;
      _os_log_impl(&dword_216897000, v14, OS_LOG_TYPE_DEFAULT, "#I Incremental scan status: %s", buf, 0xCu);
    }
    NetworkListScanResult::setState();
  }
  v16 = qmi::MessageBase::findTlvValue((qmi::MessageBase *)v71);
  v18 = v16;
  if (!v16)
  {
    v23 = 0;
    v28 = 0;
    goto LABEL_48;
  }
  v19 = v17;
  *(_QWORD *)&v84 = v16;
  memset(buf, 0, 24);
  tlv::parseV<nas::tlv::NetworkNameSourceList>((unsigned __int8 **)&v84, v17, (std::vector<unsigned int> *)buf);
  v20 = v84;
  v60 = v19;
  v61 = v18;
  if (!(_QWORD)v84)
  {
    v62 = 0;
    v63 = v4 - 1;
    v65 = v6;
    v67 = v4;
    v23 = 0;
    v28 = 0;
    goto LABEL_44;
  }
  v22 = *(unsigned int **)buf;
  v21 = *(unsigned int **)&buf[8];
  if (*(_QWORD *)buf != *(_QWORD *)&buf[8])
  {
    v62 = v84;
    v63 = v4 - 1;
    v65 = v6;
    v67 = v4;
    v23 = 0;
    v24 = 0;
    v25 = 0;
    do
    {
      v26 = nas::convert(*v22);
      v27 = v26;
      if (v24 >= v25)
      {
        v29 = (v24 - v23) >> 2;
        v30 = v29 + 1;
        if ((unint64_t)(v29 + 1) >> 62)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        if ((v25 - v23) >> 1 > v30)
          v30 = (v25 - v23) >> 1;
        if ((unint64_t)(v25 - v23) >= 0x7FFFFFFFFFFFFFFCLL)
          v31 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v31 = v30;
        if (v31)
        {
          if (v31 >> 62)
            std::__throw_bad_array_new_length[abi:ne180100]();
          v32 = (char *)operator new(4 * v31);
        }
        else
        {
          v32 = 0;
        }
        v33 = &v32[4 * v29];
        *(_DWORD *)v33 = v27;
        v28 = v33 + 4;
        while (v24 != v23)
        {
          v34 = *((_DWORD *)v24 - 1);
          v24 -= 4;
          *((_DWORD *)v33 - 1) = v34;
          v33 -= 4;
        }
        v25 = &v32[4 * v31];
        if (v23)
          operator delete(v23);
        v23 = v33;
      }
      else
      {
        *(_DWORD *)v24 = v26;
        v28 = v24 + 4;
      }
      ++v22;
      v24 = v28;
    }
    while (v22 != v21);
LABEL_44:
    v22 = *(unsigned int **)buf;
    v4 = v67;
    v6 = v65;
    v8 = v63;
    v20 = v62;
    if (!*(_QWORD *)buf)
      goto LABEL_46;
    goto LABEL_45;
  }
  v23 = 0;
  v28 = 0;
  if (*(_QWORD *)buf)
  {
LABEL_45:
    *(_QWORD *)&buf[8] = v22;
    operator delete(v22);
  }
LABEL_46:
  if (!v20)
    ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(v71[0], 18, v61, v60);
LABEL_48:
  v36 = (unsigned __int16 *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)v71);
  v38 = v36;
  if (v36)
  {
    v39 = v37;
    v76 = 0;
    v77 = v36;
    v74 = 0;
    v75 = 0;
    tlv::parseV<nas::tlv::IncrementalNetworkInfo>(&v77, v37, &v74);
    if (v77)
    {
      v40 = v74;
      if (v75 == v74)
      {
        *(_QWORD *)buf = &v74;
        std::vector<nas::tlv::IncrementalNetworkInterfaceItem>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
      }
      else
      {
        v64 = v8;
        v68 = v4;
        v41 = 0;
        v66 = v6;
        v42 = (v28 - v23) >> 2;
        v43 = 1;
        do
        {
          v88[0] = 0;
          v88[1] = 0;
          v89 = 0;
          createPLMN();
          if (v42 <= v41)
          {
            v45 = *v70;
            v44 = 0;
            if (os_log_type_enabled(*v70, OS_LOG_TYPE_DEFAULT))
            {
              v46 = v88;
              if (v89 < 0)
                v46 = (void **)v88[0];
              *(_DWORD *)buf = 67109634;
              *(_DWORD *)&buf[4] = v43;
              *(_WORD *)&buf[8] = 2048;
              *(_QWORD *)&buf[10] = 0xCCCCCCCCCCCCCCCDLL * ((v75 - v74) >> 3);
              *(_WORD *)&buf[18] = 2082;
              *(_QWORD *)&buf[20] = v46;
              _os_log_impl(&dword_216897000, v45, OS_LOG_TYPE_DEFAULT, "#N Could not find network name source for interface %d of %ld: %{public}s", buf, 0x1Cu);
              v44 = 0;
            }
          }
          else
          {
            v44 = *(unsigned int *)&v23[4 * v41];
          }
          v86 = 0u;
          v87 = 0u;
          v84 = 0u;
          v85 = 0u;
          MEMORY[0x2199FE38C](&v84, v88);
          v97 = 0;
          v95 = 0u;
          v96 = 0u;
          v93 = 0u;
          v94 = 0u;
          v91 = 0u;
          v92 = 0u;
          memset(buf, 0, sizeof(buf));
          v47 = v40 + 40 * v41;
          v48 = *(unsigned int *)(v47 + 8);
          MCCAndMNC::getMcc((MCCAndMNC *)&v84);
          MCCAndMNC::getMnc((MCCAndMNC *)&v84);
          MEMORY[0x2199FDAEC](buf, v47 + 16, v48, v81, v78, v44);
          if (v80 < 0)
            operator delete(__p);
          if (v83 < 0)
            operator delete(v82);
          v49 = v72;
          NetworkListScanResult::addOperator();
          if (SBYTE7(v96) < 0)
            operator delete((void *)v95);
          if (SHIBYTE(v94) < 0)
            operator delete(*((void **)&v93 + 1));
          if (SHIBYTE(v92) < 0)
            operator delete(*((void **)&v91 + 1));
          if ((buf[23] & 0x80000000) != 0)
            operator delete(*(void **)buf);
          if (SHIBYTE(v87) < 0)
            operator delete(*((void **)&v86 + 1));
          if (SHIBYTE(v85) < 0)
            operator delete(*((void **)&v84 + 1));
          if (SHIBYTE(v89) < 0)
            operator delete(v88[0]);
          v41 = v43;
          v40 = v74;
        }
        while (0xCCCCCCCCCCCCCCCDLL * ((v75 - v74) >> 3) > v43++);
        v69 = v49;
        *(_QWORD *)buf = &v74;
        std::vector<nas::tlv::IncrementalNetworkInterfaceItem>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
        v4 = v68;
        v6 = v66;
        v8 = v64;
      }
    }
    else
    {
      *(_QWORD *)buf = &v74;
      std::vector<nas::tlv::IncrementalNetworkInterfaceItem>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
      ((void (*)(_QWORD, uint64_t, unsigned __int16 *, _QWORD))*MEMORY[0x24BED8BD0])(v71[0], 16, v38, v39);
    }
  }
  v51 = *(_QWORD *)(v6 + 48);
  if (v8 >= 3)
    v52 = 0;
  else
    v52 = v4;
  *(_QWORD *)buf = v69;
  *(_QWORD *)&buf[8] = v73;
  if (v73)
  {
    p_shared_owners = (unint64_t *)&v73->__shared_owners_;
    do
      v54 = __ldxr(p_shared_owners);
    while (__stxr(v54 + 1, p_shared_owners));
  }
  (*(void (**)(uint64_t, uint64_t, _BYTE *))(*(_QWORD *)v51 + 32))(v51, v52, buf);
  v55 = *(std::__shared_weak_count **)&buf[8];
  if (*(_QWORD *)&buf[8])
  {
    v56 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
    do
      v57 = __ldaxr(v56);
    while (__stlxr(v57 - 1, v56));
    if (!v57)
    {
      ((void (*)(std::__shared_weak_count *))v55->__on_zero_shared)(v55);
      std::__shared_weak_count::__release_weak(v55);
    }
  }
  if (v23)
    operator delete(v23);
  v7 = v73;
  if (v73)
  {
LABEL_96:
    v58 = (unint64_t *)&v7->__shared_owners_;
    do
      v59 = __ldaxr(v58);
    while (__stlxr(v59 - 1, v58));
    if (!v59)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v71);
}

void sub_216A53E3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,void *a42,uint64_t a43,int a44,__int16 a45,char a46,char a47,uint64_t a48,void *a49,uint64_t a50,int a51,__int16 a52,char a53,char a54,uint64_t a55,void *__p,uint64_t a57,int a58,__int16 a59,char a60,char a61)
{
  uint64_t v61;
  void *v63;

  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a18);
  v63 = *(void **)(v61 - 240);
  if (v63)
  {
    *(_QWORD *)(v61 - 232) = v63;
    operator delete(v63);
  }
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkListCommandDriver::registerIndications_sync(void)::$_2>(unsigned short,QMINetworkListCommandDriver::registerIndications_sync(void)::$_2 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMINetworkListCommandDriver::registerIndications_sync(void)::$_2 &&,QMIServiceMsg const)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkListCommandDriver::registerIndications_sync(void)::$_2>(unsigned short,QMINetworkListCommandDriver::registerIndications_sync(void)::$_2 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMINetworkListCommandDriver::registerIndications_sync(void)::$_2 &&,QMIServiceMsg const)>::target_type()
{
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN27QMINetworkListCommandDriver21bindSubscription_syncENS_16SubscriptionTypeEE3__0EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t *v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;
  os_log_t *v7;
  NSObject *v8;
  uint64_t v9;
  int v10;
  int v11;
  uint64_t v12;
  __int16 v13;
  int v14;
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v3 = *(uint64_t **)(a1 + 32);
  v4 = *v3;
  v5 = *((_DWORD *)v3 + 2);
  if (v5 - 1 >= 3)
    v6 = 0;
  else
    v6 = v5;
  v7 = (os_log_t *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v4 + 88) + 16))(*(_QWORD *)(v4 + 88), v6);
  if (*(_DWORD *)(a2 + 4))
  {
    v8 = *v7;
    if (os_log_type_enabled(*v7, OS_LOG_TYPE_ERROR))
    {
      v9 = qmi::asString();
      v10 = *(_DWORD *)(a2 + 4);
      v11 = 136315394;
      v12 = v9;
      v13 = 1024;
      v14 = v10;
      _os_log_error_impl(&dword_216897000, v8, OS_LOG_TYPE_ERROR, "Error binding subscription: %s (0x%x)", (uint8_t *)&v11, 0x12u);
    }
  }
}

uint64_t __copy_helper_block_e8_32c110_ZTSNSt3__110shared_ptrIZN27QMINetworkListCommandDriver21bindSubscription_syncEN3qmi16SubscriptionTypeEE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c110_ZTSNSt3__110shared_ptrIZN27QMINetworkListCommandDriver21bindSubscription_syncEN3qmi16SubscriptionTypeEE3__0EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMINetworkListCommandDriver::bindSubscription_sync(qmi::SubscriptionType)::$_0,std::allocator<QMINetworkListCommandDriver::bindSubscription_sync(qmi::SubscriptionType)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E54B0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkListCommandDriver::bindSubscription_sync(qmi::SubscriptionType)::$_0,std::allocator<QMINetworkListCommandDriver::bindSubscription_sync(qmi::SubscriptionType)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E54B0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas16BindSubscription8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke_6(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BYTE v3[24];

  v2 = *(_QWORD *)(a1 + 32);
  cast_message_type<nas::BindSubscription::Response const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_216A5419C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::ManualModeEvents>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::ManualModeEvents>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<nas::tlv::ManualModeEvents>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::ManualModeEvents>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E5540;
  return result;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN27QMINetworkListCommandDriver27sendIndRegisterRequest_syncENS_16SubscriptionTypeEE3__3EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t *v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;
  NSObject **v7;
  int v8;
  NSObject *v9;
  NSObject *v10;
  _DWORD v11[2];
  __int16 v12;
  uint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v3 = *(uint64_t **)(a1 + 32);
  v4 = *v3;
  v5 = *((_DWORD *)v3 + 2);
  if (v5 - 1 >= 3)
    v6 = 0;
  else
    v6 = v5;
  v7 = (NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v4 + 88) + 16))(*(_QWORD *)(v4 + 88), v6);
  v8 = *(_DWORD *)(a2 + 4);
  v9 = *v7;
  v10 = *v7;
  if (v8)
  {
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      v11[0] = 67109378;
      v11[1] = v8;
      v12 = 2080;
      v13 = qmi::asString();
      _os_log_error_impl(&dword_216897000, v9, OS_LOG_TYPE_ERROR, "Register for indications failed: Error in response with code %d (%s)", (uint8_t *)v11, 0x12u);
    }
  }
  else if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v11[0]) = 0;
    _os_log_impl(&dword_216897000, v9, OS_LOG_TYPE_DEFAULT, "#I Register for indications succeeded", (uint8_t *)v11, 2u);
  }
}

uint64_t __copy_helper_block_e8_32c116_ZTSNSt3__110shared_ptrIZN27QMINetworkListCommandDriver27sendIndRegisterRequest_syncEN3qmi16SubscriptionTypeEE3__3EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c116_ZTSNSt3__110shared_ptrIZN27QMINetworkListCommandDriver27sendIndRegisterRequest_syncEN3qmi16SubscriptionTypeEE3__3EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMINetworkListCommandDriver::sendIndRegisterRequest_sync(qmi::SubscriptionType)::$_3,std::allocator<QMINetworkListCommandDriver::sendIndRegisterRequest_sync(qmi::SubscriptionType)::$_3>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E55A8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkListCommandDriver::sendIndRegisterRequest_sync(qmi::SubscriptionType)::$_3,std::allocator<QMINetworkListCommandDriver::sendIndRegisterRequest_sync(qmi::SubscriptionType)::$_3>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E55A8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas18IndicationRegister8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke_3(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BYTE v3[24];

  v2 = *(_QWORD *)(a1 + 32);
  cast_message_type<nas::IndicationRegister::Response const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_216A54440(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<NetworkListCommandDriver>::execute_wrapped<QMINetworkListCommandDriver::performNetworkScan(subscriber::SimSlot,unsigned char)::$_0>(QMINetworkListCommandDriver::performNetworkScan(subscriber::SimSlot,unsigned char)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMINetworkListCommandDriver::performNetworkScan(subscriber::SimSlot,unsigned char)::$_0,dispatch_queue_s *::default_delete<QMINetworkListCommandDriver::performNetworkScan(subscriber::SimSlot,unsigned char)::$_0>>)::{lambda(void *)#1}::__invoke(std::__shared_weak_count_vtbl ***a1)
{
  std::__shared_weak_count_vtbl **v1;
  std::__shared_weak_count_vtbl *v2;
  int v3;
  const void **v4;
  char *v5;
  _BYTE *v6;
  char *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  uint64_t v17;
  char v18;
  uint64_t v19;
  uint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *p_shared_owners;
  uint64_t v23;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  unint64_t v28;
  uint64_t v29;
  std::__shared_weak_count_vtbl ***v31;
  int v32;
  uint64_t v33;
  void *__p[2];
  __int128 v35;
  _QWORD v36[5];
  std::__shared_weak_count *v37;
  int v38;
  _QWORD aBlock[5];

  v31 = a1;
  v1 = *a1;
  v2 = **a1;
  v2[3].~__shared_weak_count = v2[2].__on_zero_shared_weak;
  if ((*((_DWORD *)v1 + 2) - 1) >= 3)
    v3 = 0;
  else
    v3 = *((_DWORD *)v1 + 2);
  *(_OWORD *)__p = 0u;
  v35 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  v4 = (const void **)__p[1];
  if (__p[1] != (void *)v35)
  {
    while (*((_BYTE *)*v4 + 8) != 16)
    {
      if (++v4 == (const void **)v35)
        goto LABEL_11;
    }
  }
  if (v4 == (const void **)v35)
  {
LABEL_11:
    v5 = (char *)operator new();
    v7 = v5;
    *((_WORD *)v5 + 4) = 16;
    *(_QWORD *)v5 = &off_24D5E5638;
    v8 = v35;
    if ((unint64_t)v35 >= *((_QWORD *)&v35 + 1))
    {
      v10 = (uint64_t)(v35 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v10 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v11 = (uint64_t)(*((_QWORD *)&v35 + 1) - (unint64_t)__p[1]) >> 2;
      if (v11 <= v10 + 1)
        v11 = v10 + 1;
      if (*((_QWORD *)&v35 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v12 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v12 = v11;
      if (v12)
        v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v35 + 8, v12);
      else
        v13 = 0;
      v14 = &v13[8 * v10];
      v15 = &v13[8 * v12];
      *(_QWORD *)v14 = v7;
      v9 = v14 + 8;
      v16 = (char *)__p[1];
      v5 = (char *)v35;
      if ((void *)v35 != __p[1])
      {
        do
        {
          v17 = *((_QWORD *)v5 - 1);
          v5 -= 8;
          *((_QWORD *)v14 - 1) = v17;
          v14 -= 8;
        }
        while (v5 != v16);
        v5 = (char *)__p[1];
      }
      __p[1] = v14;
      *(_QWORD *)&v35 = v9;
      *((_QWORD *)&v35 + 1) = v15;
      if (v5)
        operator delete(v5);
    }
    else
    {
      *(_QWORD *)v35 = v5;
      v9 = (_QWORD *)(v8 + 8);
    }
    v6 = v7 + 9;
    *(_QWORD *)&v35 = v9;
  }
  else
  {
    if (!v5)
      __cxa_bad_cast();
    v6 = v5 + 9;
  }
  *v6 = 0;
  v18 = *((_BYTE *)v1 + 12);
  if ((v18 & 1) != 0)
  {
    v5 = nas::operator|=(v6, 1);
    v18 = *((_BYTE *)v1 + 12);
  }
  if ((v18 & 2) != 0)
  {
    v5 = nas::operator|=(v6, 2);
    v18 = *((_BYTE *)v1 + 12);
  }
  if ((v18 & 0x10) != 0)
  {
    v5 = nas::operator|=(v6, 4);
    v18 = *((_BYTE *)v1 + 12);
  }
  if ((v18 & 0x20) != 0)
    v5 = nas::operator|=(v6, 8);
  if (capabilities::ct::supports5G((capabilities::ct *)v5) && (*((_BYTE *)v1 + 12) & 0x40) != 0)
    nas::operator|=(v6, 16);
  v19 = qmi::ClientRouter::get();
  v32 = v3;
  v20 = operator new();
  *(_QWORD *)v20 = v19;
  *(_QWORD *)(v20 + 8) = QMIServiceMsg::create();
  *(_DWORD *)(v20 + 16) = 25000;
  *(_QWORD *)(v20 + 24) = 0;
  *(_QWORD *)(v20 + 32) = 0;
  v33 = v20;
  v21 = (std::__shared_weak_count *)operator new(0x20uLL);
  v21->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v21->__shared_owners_;
  v21->__shared_weak_owners_ = 0;
  v21->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E56A0;
  v21[1].__vftable = v2;
  v23 = MEMORY[0x24BDAC760];
  v36[0] = MEMORY[0x24BDAC760];
  v36[1] = 1174405120;
  v36[2] = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZZN27QMINetworkListCommandDriver18performNetworkScanEN10subscriber7SimSlotEhENK3__0clEvEUlNS_16SubscriptionTypeERKN3nas29PerformIncrementalNetworkScan8ResponseEE_EEOS1_OT__block_invoke;
  v36[3] = &__block_descriptor_tmp_16_17;
  v36[4] = v21 + 1;
  v37 = v21;
  do
    v24 = __ldxr(p_shared_owners);
  while (__stxr(v24 + 1, p_shared_owners));
  v38 = v3;
  aBlock[0] = v23;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas29PerformIncrementalNetworkScan8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
  aBlock[3] = &unk_24D5E56E8;
  aBlock[4] = v36;
  *(_QWORD *)(v20 + 32) = _Block_copy(aBlock);
  v25 = v37;
  if (v37)
  {
    v26 = (unint64_t *)&v37->__shared_owners_;
    do
      v27 = __ldaxr(v26);
    while (__stlxr(v27 - 1, v26));
    if (!v27)
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }
  do
    v28 = __ldaxr(p_shared_owners);
  while (__stlxr(v28 - 1, p_shared_owners));
  if (!v28)
  {
    ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
    std::__shared_weak_count::__release_weak(v21);
  }
  v29 = v33;
  v33 = 0;
  if (v29)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v33, v29);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
  MEMORY[0x2199FEAC4](v1, 0x1020C4034E03FFCLL);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v31);
}

void sub_216A54824(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22)
{
  uint64_t v22;
  uint64_t v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  std::__shared_weak_count *v27;
  unint64_t *p_shared_owners;
  unint64_t v29;
  unint64_t v30;
  uint64_t v31;

  v27 = a22;
  if (a22)
  {
    p_shared_owners = (unint64_t *)&a22->__shared_owners_;
    do
      v29 = __ldaxr(p_shared_owners);
    while (__stlxr(v29 - 1, p_shared_owners));
    if (!v29)
    {
      ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
      std::__shared_weak_count::__release_weak(v27);
    }
  }
  do
    v30 = __ldaxr(v25);
  while (__stlxr(v30 - 1, v25));
  if (!v30)
  {
    ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
    std::__shared_weak_count::__release_weak(v24);
  }
  v31 = a12;
  a12 = 0;
  if (v31)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v23, v31);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a13);
  MEMORY[0x2199FEAC4](v22, 0x1020C4034E03FFCLL);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&a10);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkTypesToScan>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkTypesToScan>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkTypesToScan>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkTypesToScan>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E5638;
  return result;
}

uint64_t __copy_helper_block_e8_32c190_ZTSNSt3__110shared_ptrIZZN27QMINetworkListCommandDriver18performNetworkScanEN10subscriber7SimSlotEhENK3__0clEvEUlN3qmi16SubscriptionTypeERKN3nas29PerformIncrementalNetworkScan8ResponseEE_EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void __destroy_helper_block_e8_32c190_ZTSNSt3__110shared_ptrIZZN27QMINetworkListCommandDriver18performNetworkScanEN10subscriber7SimSlotEhENK3__0clEvEUlN3qmi16SubscriptionTypeERKN3nas29PerformIncrementalNetworkScan8ResponseEE_EE(uint64_t a1)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v3;

  v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1)
  {
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      v3 = __ldaxr(p_shared_owners);
    while (__stlxr(v3 - 1, p_shared_owners));
    if (!v3)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

void std::__shared_ptr_emplace<QMINetworkListCommandDriver::performNetworkScan(subscriber::SimSlot,unsigned char)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::PerformIncrementalNetworkScan::Response const&)#1},std::allocator<QMINetworkListCommandDriver::performNetworkScan(subscriber::SimSlot,unsigned char)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::PerformIncrementalNetworkScan::Response const&)#1}>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E56A0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkListCommandDriver::performNetworkScan(subscriber::SimSlot,unsigned char)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::PerformIncrementalNetworkScan::Response const&)#1},std::allocator<QMINetworkListCommandDriver::performNetworkScan(subscriber::SimSlot,unsigned char)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::PerformIncrementalNetworkScan::Response const&)#1}>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E56A0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas29PerformIncrementalNetworkScan8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A54C64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<NetworkListCommandDriver>::execute_wrapped<QMINetworkListCommandDriver::applyNetworkSelection(subscriber::SimSlot,NetworkSelectionMode,NetworkListOperator,unsigned char,CarrierSelectionAllowedReason)::$_0>(QMINetworkListCommandDriver::applyNetworkSelection(subscriber::SimSlot,NetworkSelectionMode,NetworkListOperator,unsigned char,CarrierSelectionAllowedReason)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMINetworkListCommandDriver::applyNetworkSelection(subscriber::SimSlot,NetworkSelectionMode,NetworkListOperator,unsigned char,CarrierSelectionAllowedReason)::$_0,dispatch_queue_s *::default_delete<QMINetworkListCommandDriver::applyNetworkSelection(subscriber::SimSlot,NetworkSelectionMode,NetworkListOperator,unsigned char,CarrierSelectionAllowedReason)::$_0>>)::{lambda(void *)#1}::__invoke(uint64_t *a1)
{
  uint64_t v1;
  _QWORD **v2;
  NSObject *v3;
  int v4;
  char v5;
  int v6;
  os_log_t *v7;
  os_log_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const __CFBoolean *v12;
  int v13;
  NSObject *v14;
  uint64_t v15;
  std::string *v16;
  int v17;
  NSObject *v18;
  _BOOL4 v19;
  NSObject *v20;
  NSObject *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v25;
  uint64_t v26;
  uint64_t *v27;
  uint64_t v28;
  BOOL *v29;
  std::string buf;
  void *v31;
  char v32;
  void *v33;
  char v34;
  void *__p;
  char v36;
  _BYTE v37[12];
  uint64_t v38;

  v38 = *MEMORY[0x24BDAC8D0];
  v1 = *a1;
  v27 = a1;
  v28 = v1;
  v2 = *(_QWORD ***)v1;
  v3 = *(NSObject **)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(*(_QWORD *)v1 + 88) + 16))(*(_QWORD *)(*(_QWORD *)v1 + 88), *(unsigned int *)(v1 + 8));
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = asString();
    _os_log_impl(&dword_216897000, v3, OS_LOG_TYPE_DEFAULT, "#I Request is to set the network selection mode to %s", (uint8_t *)&buf, 0xCu);
  }
  v4 = *(_DWORD *)(v1 + 12);
  v5 = *(_BYTE *)(v1 + 16);
  v6 = *(_DWORD *)(v1 + 20);
  v7 = (os_log_t *)(*(uint64_t (**)(_QWORD *, _QWORD))(*v2[11] + 16))(v2[11], *(unsigned int *)(v1 + 8));
  v8 = v7;
  if (v6 == 3)
  {
    v29 = 0;
    v9 = *MEMORY[0x24BDC3E98];
    v10 = *MEMORY[0x24BDC3E88];
    v11 = *MEMORY[0x24BDBD570];
    v26 = *MEMORY[0x24BDBD590];
    (*(void (**)(std::string *__return_ptr, _QWORD *, _QWORD, _QWORD))(*v2[17] + 40))(&buf, v2[17], *MEMORY[0x24BDC3E98], *MEMORY[0x24BDC3E88]);
    v25 = v10;
    ctu::cf::CFSharedRef<__CFBoolean const>::CFSharedRef<void const,void>(&v29, (CFTypeRef *)&buf.__r_.__value_.__l.__data_);
    ctu::SharedRef<void const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,void const>::~SharedRef((const void **)&buf.__r_.__value_.__l.__data_);
    buf.__r_.__value_.__s.__data_[0] = 0;
    ctu::cf::assign((ctu::cf *)&buf, v29, v12);
    v13 = buf.__r_.__value_.__s.__data_[0];
    v14 = *v8;
    if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
    {
      v15 = CSIBOOLAsString();
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v15;
      _os_log_impl(&dword_216897000, v14, OS_LOG_TYPE_DEFAULT, "#I Device currently locked for GWL for manual selection status: %s", (uint8_t *)&buf, 0xCu);
      v14 = *v8;
    }
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      ratSelectionAsStr();
      v16 = (buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
          ? &buf
          : (std::string *)buf.__r_.__value_.__r.__words[0];
      *(_DWORD *)v37 = 136446210;
      *(_QWORD *)&v37[4] = v16;
      _os_log_impl(&dword_216897000, v14, OS_LOG_TYPE_DEFAULT, "#I Current RAT Selection %{public}s", v37, 0xCu);
      if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
        operator delete(buf.__r_.__value_.__l.__data_);
    }
    if (v4 == 1)
    {
      v17 = v5 & 0xC;
      v18 = *v8;
      v19 = os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT);
      if (v17)
      {
        if (v19)
        {
          LOWORD(buf.__r_.__value_.__l.__data_) = 0;
          _os_log_impl(&dword_216897000, v18, OS_LOG_TYPE_DEFAULT, "#I CDMA is present and BB supports scan with CH mode, not removing CDMA", (uint8_t *)&buf, 2u);
        }
        (*(void (**)(_QWORD *, uint64_t, _QWORD, uint64_t, uint64_t, uint64_t))(*v2[17] + 16))(v2[17], v9, *MEMORY[0x24BDBD270], v25, v26, v11);
      }
      else if (v19)
      {
        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
        _os_log_impl(&dword_216897000, v18, OS_LOG_TYPE_DEFAULT, "#I CDMA is not present, no need to change mode preference", (uint8_t *)&buf, 2u);
      }
    }
    else if (v13)
    {
      v21 = *v8;
      if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
        _os_log_impl(&dword_216897000, v21, OS_LOG_TYPE_DEFAULT, "#I Requested mode is not manual, GWL lock status is still true, resetting it", (uint8_t *)&buf, 2u);
      }
      (*(void (**)(_QWORD *, uint64_t, _QWORD, uint64_t, uint64_t, uint64_t))(*v2[17] + 16))(v2[17], v9, *MEMORY[0x24BDBD268], v25, v26, v11);
    }
    ctu::SharedRef<__CFBoolean const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFBoolean const>::~SharedRef((const void **)&v29);
  }
  else
  {
    v20 = *v7;
    if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_impl(&dword_216897000, v20, OS_LOG_TYPE_DEFAULT, "#I CDMA roaming not supported", (uint8_t *)&buf, 2u);
    }
  }
  v22 = *(unsigned int *)(v1 + 8);
  v23 = *(unsigned int *)(v1 + 12);
  NetworkListOperator::NetworkListOperator(&buf, (const NetworkListOperator *)(v1 + 24));
  *(_QWORD *)v37 = 0;
  ((void (*)(_QWORD **, uint64_t, uint64_t, std::string *, _BYTE *))(*v2)[8])(v2, v22, v23, &buf, v37);
  if (*(_QWORD *)v37)
  {
    dispatch_group_leave(*(dispatch_group_t *)v37);
    if (*(_QWORD *)v37)
      dispatch_release(*(dispatch_object_t *)v37);
  }
  if (v36 < 0)
    operator delete(__p);
  if (v34 < 0)
    operator delete(v33);
  if (v32 < 0)
    operator delete(v31);
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
    operator delete(buf.__r_.__value_.__l.__data_);
  std::unique_ptr<QMINetworkListCommandDriver::applyNetworkSelection(subscriber::SimSlot,NetworkSelectionMode,NetworkListOperator,unsigned char,CarrierSelectionAllowedReason)::$_0,std::default_delete<QMINetworkListCommandDriver::applyNetworkSelection(subscriber::SimSlot,NetworkSelectionMode,NetworkListOperator,unsigned char,CarrierSelectionAllowedReason)::$_0>>::~unique_ptr[abi:ne180100](&v28);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v27);
}

void sub_216A550EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, const void *a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,void *__p,uint64_t a37,int a38,__int16 a39,char a40,char a41)
{
  ctu::SharedRef<__CFBoolean const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFBoolean const>::~SharedRef(&a14);
  std::unique_ptr<QMINetworkListCommandDriver::applyNetworkSelection(subscriber::SimSlot,NetworkSelectionMode,NetworkListOperator,unsigned char,CarrierSelectionAllowedReason)::$_0,std::default_delete<QMINetworkListCommandDriver::applyNetworkSelection(subscriber::SimSlot,NetworkSelectionMode,NetworkListOperator,unsigned char,CarrierSelectionAllowedReason)::$_0>>::~unique_ptr[abi:ne180100](&a13);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&a12);
  _Unwind_Resume(a1);
}

uint64_t *std::unique_ptr<QMINetworkListCommandDriver::applyNetworkSelection(subscriber::SimSlot,NetworkSelectionMode,NetworkListOperator,unsigned char,CarrierSelectionAllowedReason)::$_0,std::default_delete<QMINetworkListCommandDriver::applyNetworkSelection(subscriber::SimSlot,NetworkSelectionMode,NetworkListOperator,unsigned char,CarrierSelectionAllowedReason)::$_0>>::~unique_ptr[abi:ne180100](uint64_t *a1)
{
  uint64_t v2;

  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    if (*(char *)(v2 + 143) < 0)
      operator delete(*(void **)(v2 + 120));
    if (*(char *)(v2 + 119) < 0)
      operator delete(*(void **)(v2 + 96));
    if (*(char *)(v2 + 87) < 0)
      operator delete(*(void **)(v2 + 64));
    if (*(char *)(v2 + 47) < 0)
      operator delete(*(void **)(v2 + 24));
    MEMORY[0x2199FEAC4](v2, 0x1072C40E83DF3DCLL);
  }
  return a1;
}

uint64_t qmi::MutableMessageBase::getTLV<nas::tlv::NetworkSelectionPreference>(_QWORD *a1, int a2)
{
  const void **v2;
  const void **v3;
  void *v4;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3)
        return qmi::MutableMessageBase::createTLV<nas::tlv::NetworkSelectionPreference>(a1, a2);
    }
  }
  if (v2 == v3)
    return qmi::MutableMessageBase::createTLV<nas::tlv::NetworkSelectionPreference>(a1, a2);
  if (!v4)
    __cxa_bad_cast();
  return (uint64_t)v4 + 10;
}

uint64_t qmi::MutableMessageBase::createTLV<nas::tlv::NetworkSelectionPreference>(_QWORD *a1, char a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v4 = operator new();
  *(_BYTE *)(v4 + 8) = a2;
  *(_QWORD *)v4 = &unk_24D5E5730;
  *(_BYTE *)(v4 + 10) = 0;
  *(_DWORD *)(v4 + 12) = 0;
  v5 = a1[3];
  v6 = (uint64_t *)a1[2];
  if ((unint64_t)v6 >= v5)
  {
    v8 = a1[1];
    v9 = ((uint64_t)v6 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v5 - v8;
    v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1))
      v11 = v9 + 1;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v12);
    else
      v13 = 0;
    v14 = (uint64_t *)&v13[8 * v9];
    v15 = &v13[8 * v12];
    *v14 = v4;
    v7 = v14 + 1;
    v17 = (char *)a1[1];
    v16 = (char *)a1[2];
    if (v16 != v17)
    {
      do
      {
        v18 = *((_QWORD *)v16 - 1);
        v16 -= 8;
        *--v14 = v18;
      }
      while (v16 != v17);
      v16 = (char *)a1[1];
    }
    a1[1] = v14;
    a1[2] = v7;
    a1[3] = v15;
    if (v16)
      operator delete(v16);
  }
  else
  {
    *v6 = v4;
    v7 = v6 + 1;
  }
  a1[2] = v7;
  return v4 + 10;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkSelectionPreference>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkSelectionPreference>::getSize()
{
  return tlv::size<wms::tlv::MemoryStorageIdentification>();
}

uint64_t *qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkSelectionPreference>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t *result;
  uint64_t v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = *a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<nas::tlv::NetworkSelectionPreference>(a2, a1 + 10);
  v7 = *a2 - v5;
  *(_BYTE *)v4 = v3;
  *(_WORD *)(v4 + 1) = v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkSelectionPreference>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &unk_24D5E5730;
  *(_DWORD *)(result + 10) = *(_DWORD *)(a1 + 10);
  *(_WORD *)(result + 14) = *(_WORD *)(a1 + 14);
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkSelectionChangeDuration>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkSelectionChangeDuration>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkSelectionChangeDuration>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkSelectionChangeDuration>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E5780;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkSelectionPreferenceMNC>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkSelectionPreferenceMNC>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkSelectionPreferenceMNC>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkSelectionPreferenceMNC>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E57D0;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkSelectionPreferenceRAT>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkSelectionPreferenceRAT>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_ProfileIdentifier>();
}

char *qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkSelectionPreferenceRAT>::write(uint64_t a1, char **a2)
{
  char v3;
  char *v4;
  uint64_t v5;
  char *result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = *a2;
  v5 = (uint64_t)(*a2 + 3);
  *a2 = (char *)v5;
  result = tlv::writeV<nas::tlv::NetworkSelectionPreferenceRAT>(a2, (int *)(a1 + 12));
  v7 = &(*a2)[-v5];
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkSelectionPreferenceRAT>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E5820;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a1 + 12);
  return result;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN27QMINetworkListCommandDriver19applySelection_syncEN10subscriber7SimSlotE20NetworkSelectionMode19NetworkListOperatorN8dispatch13group_sessionEE3__5EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  QMINetworkListCommandDriver::handleInitiateNetworkRegisterResp_sync(**(_QWORD **)(a1 + 32), *(_DWORD *)(a1 + 48), a2);
}

uint64_t __copy_helper_block_e8_32c175_ZTSNSt3__110shared_ptrIZN27QMINetworkListCommandDriver19applySelection_syncEN10subscriber7SimSlotE20NetworkSelectionMode19NetworkListOperatorN8dispatch13group_sessionEE3__5EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c175_ZTSNSt3__110shared_ptrIZN27QMINetworkListCommandDriver19applySelection_syncEN10subscriber7SimSlotE20NetworkSelectionMode19NetworkListOperatorN8dispatch13group_sessionEE3__5EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMINetworkListCommandDriver::applySelection_sync(subscriber::SimSlot,NetworkSelectionMode,NetworkListOperator,dispatch::group_session)::$_5,std::allocator<QMINetworkListCommandDriver::applySelection_sync(subscriber::SimSlot,NetworkSelectionMode,NetworkListOperator,dispatch::group_session)::$_5>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E5888;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkListCommandDriver::applySelection_sync(subscriber::SimSlot,NetworkSelectionMode,NetworkListOperator,dispatch::group_session)::$_5,std::allocator<QMINetworkListCommandDriver::applySelection_sync(subscriber::SimSlot,NetworkSelectionMode,NetworkListOperator,dispatch::group_session)::$_5>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E5888;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void std::__shared_ptr_emplace<QMINetworkListCommandDriver::applySelection_sync(subscriber::SimSlot,NetworkSelectionMode,NetworkListOperator,dispatch::group_session)::$_5,std::allocator<QMINetworkListCommandDriver::applySelection_sync(subscriber::SimSlot,NetworkSelectionMode,NetworkListOperator,dispatch::group_session)::$_5>>::__on_zero_shared(uint64_t a1)
{
  NSObject *v2;
  NSObject *v3;

  v2 = *(NSObject **)(a1 + 32);
  if (v2)
  {
    dispatch_group_leave(v2);
    v3 = *(NSObject **)(a1 + 32);
    if (v3)
      dispatch_release(v3);
  }
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas28SetSystemSelectionPreference8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BYTE v3[24];

  v2 = *(_QWORD *)(a1 + 32);
  cast_message_type<nas::SetSystemSelectionPreference::Response const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_216A557D8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void cast_message_type<nas::SetSystemSelectionPreference::Response const&>::cast(uint64_t a1@<X0>, qmi::ResponseBase *a2@<X8>)
{
  if (*(_DWORD *)(a1 + 40) != 1 || *(_WORD *)(a1 + 44) == 3)
  {
    QMIServiceMsg::serialize((QMIServiceMsg *)a1);
    qmi::Response<(unsigned short)51,nas::SetSystemSelectionPreference::ResponseTLVList>::Response(a2, 0);
  }
  else
  {
    QMIServiceMsg::getNewError((QMIServiceMsg *)a1);
    qmi::Response<(unsigned short)51,nas::SetSystemSelectionPreference::ResponseTLVList>::Response((uint64_t)a2);
  }
}

void sub_216A55878(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t qmi::Response<(unsigned short)51,nas::SetSystemSelectionPreference::ResponseTLVList>::Response(uint64_t a1)
{
  qmi::MessageBase *v2;

  v2 = (qmi::MessageBase *)qmi::MessageBase::MessageBase();
  qmi::MessageBase::validateMsgId(v2);
  return a1;
}

void sub_216A558C0(_Unwind_Exception *a1)
{
  qmi::MessageBase *v1;

  qmi::MessageBase::~MessageBase(v1);
  _Unwind_Resume(a1);
}

qmi::ResponseBase *qmi::Response<(unsigned short)51,nas::SetSystemSelectionPreference::ResponseTLVList>::Response(qmi::ResponseBase *a1, const void *a2)
{
  qmi::MessageBase *v3;

  v3 = (qmi::MessageBase *)qmi::ResponseBase::ResponseBase(a1, a2);
  qmi::MessageBase::validateMsgId(v3);
  return a1;
}

void sub_216A55900(_Unwind_Exception *a1)
{
  qmi::MessageBase *v1;

  qmi::MessageBase::~MessageBase(v1);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::RegisterAction>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::RegisterAction>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<nas::tlv::RegisterAction>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::RegisterAction>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E5918;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::ManualNetworkRegisterInformation>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::ManualNetworkRegisterInformation>::getSize()
{
  return tlv::size<wms::tlv::MemoryStorageIdentification>();
}

uint64_t *qmi::MutableMessageBase::TlvWrapper<nas::tlv::ManualNetworkRegisterInformation>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t *result;
  uint64_t v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = *a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<nas::tlv::ManualNetworkRegisterInformation>(a2, a1 + 10);
  v7 = *a2 - v5;
  *(_BYTE *)v4 = v3;
  *(_WORD *)(v4 + 1) = v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::ManualNetworkRegisterInformation>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E5968;
  *(_DWORD *)(result + 10) = *(_DWORD *)(a1 + 10);
  *(_WORD *)(result + 14) = *(_WORD *)(a1 + 14);
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::MNCDigitIncludeStatus>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::MNCDigitIncludeStatus>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<nas::tlv::MNCDigitIncludeStatus>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::MNCDigitIncludeStatus>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E59B8;
  return result;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN27QMINetworkListCommandDriver19applySelection_syncEN10subscriber7SimSlotE20NetworkSelectionMode19NetworkListOperatorN8dispatch13group_sessionEE3__9EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  QMINetworkListCommandDriver::handleInitiateNetworkRegisterResp_sync(**(_QWORD **)(a1 + 32), *(_DWORD *)(a1 + 48), a2);
}

uint64_t __copy_helper_block_e8_32c175_ZTSNSt3__110shared_ptrIZN27QMINetworkListCommandDriver19applySelection_syncEN10subscriber7SimSlotE20NetworkSelectionMode19NetworkListOperatorN8dispatch13group_sessionEE3__9EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c175_ZTSNSt3__110shared_ptrIZN27QMINetworkListCommandDriver19applySelection_syncEN10subscriber7SimSlotE20NetworkSelectionMode19NetworkListOperatorN8dispatch13group_sessionEE3__9EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMINetworkListCommandDriver::applySelection_sync(subscriber::SimSlot,NetworkSelectionMode,NetworkListOperator,dispatch::group_session)::$_9,std::allocator<QMINetworkListCommandDriver::applySelection_sync(subscriber::SimSlot,NetworkSelectionMode,NetworkListOperator,dispatch::group_session)::$_9>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E5A20;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkListCommandDriver::applySelection_sync(subscriber::SimSlot,NetworkSelectionMode,NetworkListOperator,dispatch::group_session)::$_9,std::allocator<QMINetworkListCommandDriver::applySelection_sync(subscriber::SimSlot,NetworkSelectionMode,NetworkListOperator,dispatch::group_session)::$_9>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E5A20;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void std::__shared_ptr_emplace<QMINetworkListCommandDriver::applySelection_sync(subscriber::SimSlot,NetworkSelectionMode,NetworkListOperator,dispatch::group_session)::$_9,std::allocator<QMINetworkListCommandDriver::applySelection_sync(subscriber::SimSlot,NetworkSelectionMode,NetworkListOperator,dispatch::group_session)::$_9>>::__on_zero_shared(uint64_t a1)
{
  NSObject *v2;
  NSObject *v3;

  v2 = *(NSObject **)(a1 + 40);
  if (v2)
  {
    dispatch_group_leave(v2);
    v3 = *(NSObject **)(a1 + 40);
    if (v3)
      dispatch_release(v3);
  }
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas23InitiateNetworkRegister8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A55CE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<NetworkListSelectionResult>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E5A98;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<NetworkListSelectionResult>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E5A98;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

uint64_t std::optional<MCCAndMNC>::operator=[abi:ne180100]<MCCAndMNC,void>(uint64_t a1, uint64_t a2)
{
  MCC *v3;
  const MCC *v4;

  v3 = (MCC *)(a1 + 32);
  v4 = (const MCC *)(a2 + 32);
  if (*(_BYTE *)(a1 + 64))
  {
    MCC::operator=();
    MCC::operator=();
  }
  else
  {
    MCC::MCC();
    MCC::MCC(v3, v4);
    *(_BYTE *)(a1 + 64) = 1;
  }
  return a1;
}

void sub_216A55DD0(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 31) < 0)
    operator delete(*(void **)(v1 + 8));
  _Unwind_Resume(exception_object);
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<NetworkListCommandDriver>::execute_wrapped<QMINetworkListCommandDriver::getNetworkSelectionSetting(subscriber::SimSlot)::$_0>(QMINetworkListCommandDriver::getNetworkSelectionSetting(subscriber::SimSlot)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMINetworkListCommandDriver::getNetworkSelectionSetting(subscriber::SimSlot)::$_0,dispatch_queue_s *::default_delete<QMINetworkListCommandDriver::getNetworkSelectionSetting(subscriber::SimSlot)::$_0>>)::{lambda(void *)#1}::__invoke(uint64_t **a1)
{
  uint64_t *v1;
  uint64_t v2;
  os_log_t *v3;
  NSObject *v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  uint64_t v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t **v18;
  int v19;
  uint64_t v20;
  _OWORD v21[2];
  uint8_t buf[8];
  uint64_t v23;
  void (*v24)(uint64_t, qmi::MessageBase *);
  void *v25;
  std::__shared_weak_count *v26;
  std::__shared_weak_count *v27;
  int v28;
  _QWORD aBlock[5];

  v18 = a1;
  v1 = *a1;
  v2 = **a1;
  memset(v21, 0, sizeof(v21));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v21);
  v3 = (os_log_t *)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(v2 + 88) + 16))(*(_QWORD *)(v2 + 88), *((unsigned int *)v1 + 2));
  v4 = *v3;
  if (os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I Requesting current network selection setting in baseband", buf, 2u);
  }
  if ((*((_DWORD *)v1 + 2) - 1) >= 3)
    v5 = 0;
  else
    v5 = *((_DWORD *)v1 + 2);
  v6 = qmi::ClientRouter::get();
  v19 = v5;
  v7 = operator new();
  *(_QWORD *)v7 = v6;
  *(_QWORD *)(v7 + 8) = QMIServiceMsg::create();
  *(_DWORD *)(v7 + 16) = 25000;
  *(_QWORD *)(v7 + 24) = 0;
  *(_QWORD *)(v7 + 32) = 0;
  v20 = v7;
  v8 = (std::__shared_weak_count *)operator new(0x28uLL);
  v8->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v8->__shared_owners_;
  v8->__shared_weak_owners_ = 0;
  v8->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E5B18;
  v8[1].__vftable = (std::__shared_weak_count_vtbl *)v2;
  v8[1].__shared_owners_ = (uint64_t)v3;
  v10 = MEMORY[0x24BDAC760];
  *(_QWORD *)buf = MEMORY[0x24BDAC760];
  v23 = 1174405120;
  v24 = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZZN27QMINetworkListCommandDriver26getNetworkSelectionSettingEN10subscriber7SimSlotEENK3__0clEvEUlNS_16SubscriptionTypeERKN3nas14GetPlmnModeBit8ResponseEE_EEOS1_OT__block_invoke;
  v25 = &__block_descriptor_tmp_22_15;
  v26 = v8 + 1;
  v27 = v8;
  do
    v11 = __ldxr(p_shared_owners);
  while (__stxr(v11 + 1, p_shared_owners));
  v28 = v5;
  aBlock[0] = v10;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas14GetPlmnModeBit8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
  aBlock[3] = &unk_24D5E5B60;
  aBlock[4] = buf;
  *(_QWORD *)(v7 + 32) = _Block_copy(aBlock);
  v12 = v27;
  if (v27)
  {
    v13 = (unint64_t *)&v27->__shared_owners_;
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  do
    v15 = __ldaxr(p_shared_owners);
  while (__stlxr(v15 - 1, p_shared_owners));
  if (!v15)
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
  v16 = v20;
  v20 = 0;
  if (v16)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v20, v16);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v21);
  MEMORY[0x2199FEAC4](v1, 0x1020C403A5D3213);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v18);
}

void sub_216A5604C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22)
{
  uint64_t v22;
  uint64_t v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  std::__shared_weak_count *v27;
  unint64_t *p_shared_owners;
  unint64_t v29;
  unint64_t v30;
  uint64_t v31;

  v27 = a22;
  if (a22)
  {
    p_shared_owners = (unint64_t *)&a22->__shared_owners_;
    do
      v29 = __ldaxr(p_shared_owners);
    while (__stlxr(v29 - 1, p_shared_owners));
    if (!v29)
    {
      ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
      std::__shared_weak_count::__release_weak(v27);
    }
  }
  do
    v30 = __ldaxr(v25);
  while (__stlxr(v30 - 1, v25));
  if (!v30)
  {
    ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
    std::__shared_weak_count::__release_weak(v24);
  }
  v31 = a12;
  a12 = 0;
  if (v31)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v23, v31);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a13);
  MEMORY[0x2199FEAC4](v22, 0x1020C403A5D3213);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&a10);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZZN27QMINetworkListCommandDriver26getNetworkSelectionSettingEN10subscriber7SimSlotEENK3__0clEvEUlNS_16SubscriptionTypeERKN3nas14GetPlmnModeBit8ResponseEE_EEOS1_OT__block_invoke(uint64_t a1, qmi::MessageBase *this)
{
  uint64_t *v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  NSObject *v8;
  uint64_t TlvValue;
  int v10;
  uint64_t v11;
  int v12;
  BOOL v13;
  uint64_t v14;
  uint64_t v15;
  __int16 v16;
  uint64_t v17;
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  v3 = *(uint64_t **)(a1 + 32);
  v4 = *(_DWORD *)(a1 + 48);
  v5 = *v3;
  if (v4 - 1 >= 3)
    v6 = 0;
  else
    v6 = v4;
  v7 = *((_DWORD *)this + 1);
  if (v7)
  {
    v8 = *(NSObject **)v3[1];
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      LODWORD(v15) = 67109378;
      HIDWORD(v15) = v7;
      v16 = 2080;
      v17 = qmi::asString();
      _os_log_error_impl(&dword_216897000, v8, OS_LOG_TYPE_ERROR, "PLMN mode bit request failed: Error in response with code %d (%s)", (uint8_t *)&v15, 0x12u);
      v7 = *((_DWORD *)this + 1);
    }
    if (v7 == 80)
      (*(void (**)(_QWORD, uint64_t, uint64_t))(**(_QWORD **)(v5 + 48) + 56))(*(_QWORD *)(v5 + 48), v6, 3);
  }
  else
  {
    TlvValue = qmi::MessageBase::findTlvValue(this);
    if (TlvValue)
    {
      v11 = TlvValue;
      v12 = v10;
      v15 = TlvValue;
      v13 = tlv::parseV<nas::tlv::PlmnMode>((unint64_t *)&v15, v10);
      if (v15)
      {
        if (v13)
          v14 = 2;
        else
          v14 = 1;
        (*(void (**)(_QWORD, uint64_t, uint64_t))(**(_QWORD **)(v5 + 48) + 56))(*(_QWORD *)(v5 + 48), v6, v14);
      }
      else
      {
        ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)this, 16, v11, v12);
      }
    }
  }
}

uint64_t __copy_helper_block_e8_32c182_ZTSNSt3__110shared_ptrIZZN27QMINetworkListCommandDriver26getNetworkSelectionSettingEN10subscriber7SimSlotEENK3__0clEvEUlN3qmi16SubscriptionTypeERKN3nas14GetPlmnModeBit8ResponseEE_EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void __destroy_helper_block_e8_32c182_ZTSNSt3__110shared_ptrIZZN27QMINetworkListCommandDriver26getNetworkSelectionSettingEN10subscriber7SimSlotEENK3__0clEvEUlN3qmi16SubscriptionTypeERKN3nas14GetPlmnModeBit8ResponseEE_EE(uint64_t a1)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v3;

  v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1)
  {
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      v3 = __ldaxr(p_shared_owners);
    while (__stlxr(v3 - 1, p_shared_owners));
    if (!v3)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

void std::__shared_ptr_emplace<QMINetworkListCommandDriver::getNetworkSelectionSetting(subscriber::SimSlot)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::GetPlmnModeBit::Response const&)#1},std::allocator<QMINetworkListCommandDriver::getNetworkSelectionSetting(subscriber::SimSlot)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::GetPlmnModeBit::Response const&)#1}>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E5B18;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkListCommandDriver::getNetworkSelectionSetting(subscriber::SimSlot)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::GetPlmnModeBit::Response const&)#1},std::allocator<QMINetworkListCommandDriver::getNetworkSelectionSetting(subscriber::SimSlot)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::GetPlmnModeBit::Response const&)#1}>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E5B18;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas14GetPlmnModeBit8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A5643C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<NetworkListScanResult>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E5B90;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<NetworkListScanResult>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E5B90;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void std::__shared_ptr_emplace<NetworkListScanResult>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  void *v4;

  v1 = *(_QWORD *)(a1 + 24);
  if (v1)
  {
    v3 = *(_QWORD *)(a1 + 32);
    v4 = *(void **)(a1 + 24);
    if (v3 != v1)
    {
      do
      {
        if (*(char *)(v3 - 17) < 0)
          operator delete(*(void **)(v3 - 40));
        if (*(char *)(v3 - 41) < 0)
          operator delete(*(void **)(v3 - 64));
        if (*(char *)(v3 - 73) < 0)
          operator delete(*(void **)(v3 - 96));
        if (*(char *)(v3 - 113) < 0)
          operator delete(*(void **)(v3 - 136));
        v3 -= 136;
      }
      while (v3 != v1);
      v4 = *(void **)(a1 + 24);
    }
    *(_QWORD *)(a1 + 32) = v1;
    operator delete(v4);
  }
}

void disableNasServingSystemIndications(uint64_t a1, qmi::Client *a2)
{
  void *v4;
  _QWORD v5[6];
  uint64_t v6;
  int v7;
  uint64_t v8;
  void *v9;
  _OWORD v10[2];
  _QWORD aBlock[5];

  if (*((_QWORD *)a2 + 2) && qmi::Client::getSvcType(a2) == 3)
  {
    memset(v10, 0, sizeof(v10));
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v10);
    *(_BYTE *)qmi::MutableMessageBase::getTLV<nas::tlv::ServingSysEvents>(v10, 19) = 0;
    v5[5] = a2;
    v6 = QMIServiceMsg::create();
    v7 = 25000;
    v8 = 0;
    v9 = 0;
    v5[0] = MEMORY[0x24BDAC760];
    v5[1] = 0x40000000;
    v5[2] = ___Z34disableNasServingSystemIndicationsPKN3ctu11OsLogLoggerEN3qmi6ClientE_block_invoke_2;
    v5[3] = &__block_descriptor_tmp_3_2;
    v5[4] = a1;
    aBlock[0] = MEMORY[0x24BDAC760];
    aBlock[1] = 0x40000000;
    aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_27;
    aBlock[3] = &unk_24D5E5BF8;
    aBlock[4] = v5;
    v4 = _Block_copy(aBlock);
    v9 = v4;
    if (v6)
    {
      qmi::Client::send();
      v4 = v9;
    }
    if (v4)
      _Block_release(v4);
    qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v10);
  }
}

void sub_216A56668(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  uint64_t v7;
  va_list va;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  va_list va1;

  va_start(va1, a6);
  va_start(va, a6);
  v7 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)va);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va1);
  _Unwind_Resume(a1);
}

void ___Z34disableNasServingSystemIndicationsPKN3ctu11OsLogLoggerEN3qmi6ClientE_block_invoke_2(uint64_t a1, uint64_t a2)
{
  int v2;
  NSObject *v3;
  _DWORD v4[2];
  __int16 v5;
  uint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v2 = *(_DWORD *)(a2 + 4);
  if (v2)
  {
    v3 = **(NSObject ***)(a1 + 32);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      v4[0] = 67109378;
      v4[1] = v2;
      v5 = 2080;
      v6 = qmi::asString();
      _os_log_error_impl(&dword_216897000, v3, OS_LOG_TYPE_ERROR, "Error in response to disabling serving system indications with code = 0x%x (%s)", (uint8_t *)v4, 0x12u);
    }
  }
}

void dataModesFromSysMode(capabilities::ct *a1@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  NSObject *v5;
  _BYTE v6[12];
  __int16 v7;
  unsigned int v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  switch(a2)
  {
    case 1u:
      *(_DWORD *)v6 = 10;
      std::vector<DataMode>::__assign_with_size[abi:ne180100]<DataMode const*,DataMode const*>((char *)a3, v6, (uint64_t)&v6[4], 1uLL);
      break;
    case 2u:
      *(_DWORD *)v6 = 13;
      std::vector<DataMode>::__assign_with_size[abi:ne180100]<DataMode const*,DataMode const*>((char *)a3, v6, (uint64_t)&v6[4], 1uLL);
      break;
    case 4u:
      *(_QWORD *)v6 = 0x200000001;
      std::vector<DataMode>::__assign_with_size[abi:ne180100]<DataMode const*,DataMode const*>((char *)a3, v6, (uint64_t)&v6[8], 2uLL);
      break;
    case 5u:
    case 9u:
      *(_QWORD *)v6 = 0x400000003;
      *(_DWORD *)&v6[8] = 5;
      std::vector<DataMode>::__assign_with_size[abi:ne180100]<DataMode const*,DataMode const*>((char *)a3, v6, (uint64_t)&v7, 3uLL);
      break;
    case 8u:
      if (capabilities::ct::supports5G(a1))
      {
        *(_QWORD *)v6 = 0x100000000ELL;
        std::vector<DataMode>::__assign_with_size[abi:ne180100]<DataMode const*,DataMode const*>((char *)a3, v6, (uint64_t)&v6[8], 2uLL);
      }
      else
      {
        *(_DWORD *)v6 = 14;
        std::vector<DataMode>::__assign_with_size[abi:ne180100]<DataMode const*,DataMode const*>((char *)a3, v6, (uint64_t)&v6[4], 1uLL);
      }
      break;
    case 0xCu:
      *(_DWORD *)v6 = 17;
      std::vector<DataMode>::__assign_with_size[abi:ne180100]<DataMode const*,DataMode const*>((char *)a3, v6, (uint64_t)&v6[4], 1uLL);
      break;
    default:
      v5 = *(NSObject **)a1;
      if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)v6 = 136315394;
        *(_QWORD *)&v6[4] = nas::asString(a2);
        v7 = 1024;
        v8 = a2;
        _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#N IMS Pref status response has invalid Data Mode mask: %s (0x%x)", v6, 0x12u);
      }
      break;
  }
}

void sub_216A56948(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<DataMode>::__assign_with_size[abi:ne180100]<DataMode const*,DataMode const*>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  void **v12;
  char *v13;
  _BYTE *v14;
  unint64_t v15;
  char *v16;
  size_t v17;
  void *v18;
  char *v19;

  v7 = result;
  v8 = *((_QWORD *)result + 2);
  v9 = *(char **)result;
  if (a4 > (v8 - *(_QWORD *)result) >> 2)
  {
    if (v9)
    {
      *((_QWORD *)result + 1) = v9;
      operator delete(v9);
      v8 = 0;
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    v10 = v8 >> 1;
    if (v8 >> 1 <= a4)
      v10 = a4;
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFFCLL)
      v11 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    result = std::vector<unsigned int>::__vallocate[abi:ne180100](v7, v11);
    v13 = (char *)v7[1];
    v12 = (void **)(v7 + 1);
    v9 = v13;
LABEL_15:
    v17 = a3 - (_QWORD)__src;
    if (v17)
    {
      v18 = v9;
      v19 = __src;
      goto LABEL_17;
    }
    goto LABEL_18;
  }
  v12 = (void **)(result + 8);
  v14 = (_BYTE *)*((_QWORD *)result + 1);
  v15 = (v14 - v9) >> 2;
  if (v15 >= a4)
    goto LABEL_15;
  v16 = &__src[4 * v15];
  if (v14 != v9)
  {
    result = (char *)memmove(*(void **)result, __src, v14 - v9);
    v9 = (char *)*v12;
  }
  v17 = a3 - (_QWORD)v16;
  if (v17)
  {
    v18 = v9;
    v19 = v16;
LABEL_17:
    result = (char *)memmove(v18, v19, v17);
  }
LABEL_18:
  *v12 = &v9[v17];
  return result;
}

void Mav7SignalStrengthCommandDriver::create(_QWORD *a1@<X0>, NSObject **a2@<X1>, std::__shared_weak_count **a3@<X8>)
{
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  std::__shared_weak_count *v8;
  NSObject *v9;
  std::__shared_weak_count *v10;
  unint64_t v11;
  unint64_t *p_shared_weak_owners;
  unint64_t v13;
  unint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t v17;
  dispatch_object_t object;

  v6 = (std::__shared_weak_count *)operator new(0x80uLL);
  v6->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v6->__shared_owners_;
  v6->__shared_weak_owners_ = 0;
  v6->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E5DE8;
  v8 = v6 + 1;
  v9 = *a2;
  *a2 = 0;
  object = v9;
  Mav7SignalStrengthCommandDriver::Mav7SignalStrengthCommandDriver(&v6[1].__vftable, a1, &object);
  if (object)
    dispatch_release(object);
  v6[1].__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E5E38;
  v6[1].__shared_owners_ = (uint64_t)&unk_24D5E5EB8;
  v10 = (std::__shared_weak_count *)v6[2].__vftable;
  if (v10)
  {
    if (v10->__shared_owners_ != -1)
      goto LABEL_16;
    do
      v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
    p_shared_weak_owners = (unint64_t *)&v6->__shared_weak_owners_;
    do
      v13 = __ldxr(p_shared_weak_owners);
    while (__stxr(v13 + 1, p_shared_weak_owners));
    v6[1].__shared_weak_owners_ = (uint64_t)v8;
    v6[2].__vftable = (std::__shared_weak_count_vtbl *)v6;
    std::__shared_weak_count::__release_weak(v10);
  }
  else
  {
    do
      v14 = __ldxr(p_shared_owners);
    while (__stxr(v14 + 1, p_shared_owners));
    v15 = (unint64_t *)&v6->__shared_weak_owners_;
    do
      v16 = __ldxr(v15);
    while (__stxr(v16 + 1, v15));
    v6[1].__shared_weak_owners_ = (uint64_t)v8;
    v6[2].__vftable = (std::__shared_weak_count_vtbl *)v6;
  }
  do
    v17 = __ldaxr(p_shared_owners);
  while (__stlxr(v17 - 1, p_shared_owners));
  if (!v17)
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
LABEL_16:
  *a3 = v8;
  a3[1] = v6;
}

void sub_216A56BBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object)
{
  std::__shared_weak_count *v10;
  void *v12;

  if (object)
    dispatch_release(object);
  std::__shared_weak_count::~__shared_weak_count(v10);
  operator delete(v12);
  _Unwind_Resume(a1);
}

_QWORD *Mav7SignalStrengthCommandDriver::Mav7SignalStrengthCommandDriver(_QWORD *a1, _QWORD *a2, dispatch_object_t *a3)
{
  dispatch_object_t object;

  object = *a3;
  *a3 = 0;
  QMISignalStrengthCommandDriver::QMISignalStrengthCommandDriver((uint64_t)a1, a2, &object);
  if (object)
    dispatch_release(object);
  *a1 = &off_24D5E5CB0;
  a1[1] = &unk_24D5E5D30;
  return a1;
}

void sub_216A56C38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object)
{
  if (object)
    dispatch_release(object);
  _Unwind_Resume(exception_object);
}

void Mav7SignalStrengthCommandDriver::start(Mav7SignalStrengthCommandDriver *this)
{
  _QWORD *v2;
  NSObject *v3;
  uint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  _QWORD *v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  uint64_t v14;
  uint64_t v15;

  v12 = 0;
  v13 = 0;
  std::shared_ptr<AttachApnCommandDriver>::shared_ptr[abi:ne180100]<AttachApnCommandDriver,void>(&v12, (_QWORD *)this + 2);
  v2 = (_QWORD *)operator new();
  *v2 = this;
  v3 = *((_QWORD *)this + 4);
  v4 = v12;
  v5 = v13;
  if (v13)
  {
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  v8 = (_QWORD *)operator new();
  *v8 = v2;
  v8[1] = v4;
  v8[2] = v5;
  v14 = 0;
  v15 = 0;
  dispatch_async_f(v3, v8, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<QMISignalStrengthCommandDriver>::execute_wrapped<Mav7SignalStrengthCommandDriver::start(void)::$_0>(Mav7SignalStrengthCommandDriver::start(void)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<Mav7SignalStrengthCommandDriver::start(void)::$_0,dispatch_queue_s *::default_delete<Mav7SignalStrengthCommandDriver::start(void)::$_0>>)::{lambda(void *)#1}::__invoke);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v14);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v15);
  v9 = v13;
  if (v13)
  {
    v10 = (unint64_t *)&v13->__shared_owners_;
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
}

void Mav7SignalStrengthCommandDriver::registered(uint64_t a1, QMIVirtualClient **a2)
{
  NSObject *v4;
  QMIVirtualClient *v5;
  QMIVirtualClient *v6;
  unint64_t *v7;
  unint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  _QWORD v14[5];
  _OWORD v15[2];
  QMIVirtualClient *v16[2];
  _QWORD v17[6];
  uint64_t v18;
  int v19;
  uint64_t v20;
  void *aBlock;
  uint8_t buf[8];
  uint64_t v23;
  void (*v24)(uint64_t, uint64_t);
  void *v25;
  _QWORD *v26;

  v4 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I Mav7SignalStrengthCommandDriver Registered", buf, 2u);
  }
  v5 = *a2;
  v6 = a2[1];
  v16[0] = v5;
  v16[1] = v6;
  if (v6)
  {
    v7 = (unint64_t *)((char *)v6 + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  QMISignalStrengthCommandDriver::registered(a1, v16);
  if (v6)
  {
    v9 = (unint64_t *)((char *)v6 + 8);
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      (*(void (**)(QMIVirtualClient *))(*(_QWORD *)v6 + 16))(v6);
      std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v6);
    }
  }
  memset(v15, 0, sizeof(v15));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v15);
  *(_BYTE *)qmi::MutableMessageBase::getTLV<nas::tlv::SigInfoEvents>(v15, 25) = 1;
  v11 = *(_QWORD *)(a1 + 72);
  v12 = MEMORY[0x24BDAC760];
  v14[0] = MEMORY[0x24BDAC760];
  v14[1] = 0x40000000;
  v14[2] = ___ZN31Mav7SignalStrengthCommandDriver10registeredENSt3__110shared_ptrI16QMIVirtualClientEE_block_invoke_2;
  v14[3] = &__block_descriptor_tmp_3_3;
  v14[4] = a1;
  if (!*(_BYTE *)(v11 + 72) || !*(_QWORD *)(v11 + 56))
    __TUAssertTrigger();
  v17[5] = v11 + 40;
  v18 = QMIServiceMsg::create();
  v19 = 25000;
  v20 = 0;
  aBlock = 0;
  v17[0] = v12;
  v17[1] = 0x40000000;
  v17[2] = ___ZN16QMIVirtualClient4sendIN3nas18IndicationRegister7RequestEU13block_pointerFvRKNS2_8ResponseEEEEvRKT_T0__block_invoke;
  v17[3] = &unk_24D5E5FD0;
  v17[4] = v14;
  *(_QWORD *)buf = v12;
  v23 = 0x40000000;
  v24 = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_28;
  v25 = &unk_24D5E5FF8;
  v26 = v17;
  v13 = _Block_copy(buf);
  aBlock = v13;
  if (v18)
  {
    qmi::Client::send();
    v13 = aBlock;
  }
  if (v13)
    _Block_release(v13);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v15);
}

void sub_216A56F3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)&a26);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a15);
  _Unwind_Resume(a1);
}

void ___ZN31Mav7SignalStrengthCommandDriver10registeredENSt3__110shared_ptrI16QMIVirtualClientEE_block_invoke_2(uint64_t a1, uint64_t a2)
{
  int v2;
  NSObject *v3;
  _DWORD v4[2];
  __int16 v5;
  uint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v2 = *(_DWORD *)(a2 + 4);
  if (v2)
  {
    v3 = *(NSObject **)(*(_QWORD *)(a1 + 32) + 48);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      v4[0] = 67109378;
      v4[1] = v2;
      v5 = 2080;
      v6 = qmi::asString();
      _os_log_impl(&dword_216897000, v3, OS_LOG_TYPE_DEFAULT, "#E :registered: Error registering for Sig Info events = 0x%x (%s)", (uint8_t *)v4, 0x12u);
    }
  }
}

void `non-virtual thunk to'Mav7SignalStrengthCommandDriver::registered(uint64_t a1, QMIVirtualClient **a2)
{
  Mav7SignalStrengthCommandDriver::registered(a1 - 8, a2);
}

void Mav7SignalStrengthCommandDriver::sendNewThresholds(uint64_t a1, uint64_t *a2, int a3)
{
  uint64_t v6;
  uint64_t v7;
  void *v8;
  _QWORD v9[5];
  int v10;
  _OWORD v11[2];
  _QWORD v12[6];
  uint64_t v13;
  int v14;
  uint64_t v15;
  void *v16;
  _QWORD aBlock[5];

  memset(v11, 0, sizeof(v11));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v11);
  prepareThresholds(v11);
  populateThresholds(*a2, v11);
  *(_BYTE *)qmi::MutableMessageBase::getTLV<nas::tlv::LinkQualityIndicator>(v11, 160) = 1;
  v6 = *(_QWORD *)(a1 + 72);
  v7 = MEMORY[0x24BDAC760];
  v9[0] = MEMORY[0x24BDAC760];
  v9[1] = 0x40000000;
  v9[2] = ___ZN31Mav7SignalStrengthCommandDriver17sendNewThresholdsENSt3__110shared_ptrIK15InputThresholdsEE21SignalStrengthCmdType_block_invoke_2;
  v9[3] = &__block_descriptor_tmp_7_13;
  v9[4] = a1;
  v10 = a3;
  if (!*(_BYTE *)(v6 + 72) || !*(_QWORD *)(v6 + 56))
    __TUAssertTrigger();
  v12[5] = v6 + 40;
  v13 = QMIServiceMsg::create();
  v14 = 25000;
  v15 = 0;
  v16 = 0;
  v12[0] = v7;
  v12[1] = 0x40000000;
  v12[2] = ___ZN16QMIVirtualClient4sendIN3nas14ConfigSigInfo27RequestEU13block_pointerFvRKNS2_8ResponseEEEEvRKT_T0__block_invoke;
  v12[3] = &unk_24D5E6020;
  v12[4] = v9;
  aBlock[0] = v7;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_28;
  aBlock[3] = &unk_24D5E5FF8;
  aBlock[4] = v12;
  v8 = _Block_copy(aBlock);
  v16 = v8;
  if (v13)
  {
    qmi::Client::send();
    v8 = v16;
  }
  if (v8)
    _Block_release(v8);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v11);
}

void sub_216A571A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v8;
  va_list va;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  va_list va1;

  va_start(va1, a7);
  va_start(va, a7);
  v8 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  v18 = va_arg(va1, _QWORD);
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)va1);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN31Mav7SignalStrengthCommandDriver17sendNewThresholdsENSt3__110shared_ptrIK15InputThresholdsEE21SignalStrengthCmdType_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  int v4;
  NSObject *v5;
  _BOOL4 v6;
  int v8;
  void (*v9)(void);
  _DWORD v10[2];
  __int16 v11;
  uint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 + 32);
  v4 = *(_DWORD *)(a2 + 4);
  v5 = *(NSObject **)(v3 + 48);
  v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (!v4)
  {
    if (v6)
    {
      LOWORD(v10[0]) = 0;
      _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#I sendNewThresholds: Updated thresholds", (uint8_t *)v10, 2u);
    }
    v8 = *(_DWORD *)(a1 + 40);
    if (v8 == 1)
    {
      v9 = *(void (**)(void))(**(_QWORD **)(v3 + 88) + 16);
    }
    else
    {
      if (v8)
        return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v3 + 104))(v3, 1);
      v9 = *(void (**)(void))(**(_QWORD **)(v3 + 88) + 16);
    }
    v9();
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v3 + 104))(v3, 1);
  }
  if (v6)
  {
    v10[0] = 67109378;
    v10[1] = v4;
    v11 = 2080;
    v12 = qmi::asString();
    _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#E sendNewThresholds: Error in response with code = 0x%x (%s)", (uint8_t *)v10, 0x12u);
  }
  return (*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(v3 + 88) + 24))(*(_QWORD *)(v3 + 88), 1, *(unsigned int *)(a1 + 40));
}

void Mav7SignalStrengthCommandDriver::sendGetSignalStrength(Mav7SignalStrengthCommandDriver *this, char a2)
{
  uint64_t v4;
  uint64_t v5;
  void *v6;
  _QWORD v7[5];
  char v8;
  _OWORD v9[2];
  _QWORD v10[6];
  uint64_t v11;
  int v12;
  uint64_t v13;
  void *v14;
  _QWORD aBlock[5];

  memset(v9, 0, sizeof(v9));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v9);
  v4 = *((_QWORD *)this + 9);
  v5 = MEMORY[0x24BDAC760];
  v7[0] = MEMORY[0x24BDAC760];
  v7[1] = 0x40000000;
  v7[2] = ___ZN31Mav7SignalStrengthCommandDriver21sendGetSignalStrengthEb_block_invoke;
  v7[3] = &__block_descriptor_tmp_8_16;
  v7[4] = this;
  v8 = a2;
  if (!*(_BYTE *)(v4 + 72) || !*(_QWORD *)(v4 + 56))
    __TUAssertTrigger();
  v10[5] = v4 + 40;
  v11 = QMIServiceMsg::create();
  v12 = 25000;
  v13 = 0;
  v14 = 0;
  v10[0] = v5;
  v10[1] = 0x40000000;
  v10[2] = ___ZN16QMIVirtualClient4sendIN3nas10GetSigInfo7RequestEU13block_pointerFvRKNS2_8ResponseEEEEvRKT_T0__block_invoke;
  v10[3] = &unk_24D5E60C8;
  v10[4] = v7;
  aBlock[0] = v5;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_28;
  aBlock[3] = &unk_24D5E5FF8;
  aBlock[4] = v10;
  v6 = _Block_copy(aBlock);
  v14 = v6;
  if (v11)
  {
    qmi::Client::send();
    v6 = v14;
  }
  if (v6)
    _Block_release(v6);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v9);
}

void sub_216A57468(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v8;
  va_list va;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  va_list va1;

  va_start(va1, a7);
  va_start(va, a7);
  v8 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  v18 = va_arg(va1, _QWORD);
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)va1);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

void ___ZN31Mav7SignalStrengthCommandDriver21sendGetSignalStrengthEb_block_invoke(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v3;
  int v4;
  NSObject *v6;
  uint64_t v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  char v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  _QWORD v18[5];
  _QWORD v19[5];
  _QWORD v20[5];
  uint64_t v21;
  std::__shared_weak_count *v22;
  uint64_t v23;
  std::__shared_weak_count *v24;
  uint8_t *v25;
  uint8_t buf[8];
  __int128 v27;
  void *v28;
  uint64_t v29;
  char v30;
  uint64_t v31;

  v31 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 + 32);
  v4 = *((_DWORD *)a2 + 1);
  if (v4)
  {
    v6 = *(NSObject **)(v3 + 48);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109378;
      *(_DWORD *)&buf[4] = v4;
      LOWORD(v27) = 2080;
      *(_QWORD *)((char *)&v27 + 2) = qmi::asString();
      _os_log_impl(&dword_216897000, v6, OS_LOG_TYPE_DEFAULT, "#E sendGetSignalStrength: Error in response with code = 0x%x (%s)", buf, 0x12u);
      v4 = *((_DWORD *)a2 + 1);
    }
    if (!*(_BYTE *)(a1 + 40) && v4 != 74)
      (*(void (**)(_QWORD, uint64_t, uint64_t))(**(_QWORD **)(v3 + 88) + 24))(*(_QWORD *)(v3 + 88), 1, 3);
  }
  else
  {
    v23 = 0;
    v24 = 0;
    parseInputs(a2, &v23);
    if (*(_QWORD *)(v23 + 16))
    {
      v7 = *(_QWORD *)(v3 + 88);
      v21 = v23;
      v22 = v24;
      if (v24)
      {
        p_shared_owners = (unint64_t *)&v24->__shared_owners_;
        do
          v9 = __ldxr(p_shared_owners);
        while (__stxr(v9 + 1, p_shared_owners));
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(_QWORD *)v7 + 32))(v7, 1, &v21);
      v10 = v22;
      if (v22)
      {
        v11 = (unint64_t *)&v22->__shared_owners_;
        do
          v12 = __ldaxr(v11);
        while (__stlxr(v12 - 1, v11));
        if (!v12)
        {
          ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
          std::__shared_weak_count::__release_weak(v10);
        }
      }
    }
    v13 = MEMORY[0x24BDAC760];
    v20[0] = MEMORY[0x24BDAC760];
    v20[1] = 0x40000000;
    v20[2] = ___ZN31Mav7SignalStrengthCommandDriver13handleSigInfoIN3nas10GetSigInfo8ResponseEEEvRKT__block_invoke;
    v20[3] = &__block_descriptor_tmp_24_13;
    v20[4] = v3;
    *(_QWORD *)buf = v20;
    qmi::MessageBase::applyTlv<nas::tlv::LinkQuality,void({block_pointer}&)(nas::tlv::LinkQuality const&)>(a2, (uint64_t)buf);
    v19[0] = v13;
    v19[1] = 0x40000000;
    v19[2] = ___ZN31Mav7SignalStrengthCommandDriver13handleSigInfoIN3nas10GetSigInfo8ResponseEEEvRKT__block_invoke_2;
    v19[3] = &__block_descriptor_tmp_25_10;
    v19[4] = v3;
    *(_QWORD *)buf = v19;
    qmi::MessageBase::applyTlv<nas::tlv::DataLinkQuality,void({block_pointer}&)(nas::tlv::DataLinkQuality const&)>(a2, (uint64_t)buf);
    v18[0] = v13;
    v18[1] = 0x40000000;
    v18[2] = ___ZN31Mav7SignalStrengthCommandDriver13handleSigInfoIN3nas10GetSigInfo8ResponseEEEvRKT__block_invoke_3;
    v18[3] = &__block_descriptor_tmp_26_9;
    v18[4] = v3;
    *(_QWORD *)buf = v18;
    v14 = qmi::MessageBase::applyTlv<nas::tlv::EnhancedVoiceLinkQuality,void({block_pointer}&)(nas::tlv::EnhancedVoiceLinkQuality const&)>(a2, (uint64_t)buf);
    v25 = buf;
    *(_QWORD *)buf = v13;
    *(_QWORD *)&v27 = 0x40000000;
    *((_QWORD *)&v27 + 1) = ___ZN31Mav7SignalStrengthCommandDriver13handleSigInfoIN3nas10GetSigInfo8ResponseEEEvRKT__block_invoke_4;
    v28 = &__block_descriptor_tmp_27_11;
    v29 = v3;
    v30 = v14;
    qmi::MessageBase::applyTlv<nas::tlv::VoiceLinkQuality,void({block_pointer}&)(nas::tlv::VoiceLinkQuality const&)>(a2, (uint64_t)&v25);
    v15 = v24;
    if (v24)
    {
      v16 = (unint64_t *)&v24->__shared_owners_;
      do
        v17 = __ldaxr(v16);
      while (__stlxr(v17 - 1, v16));
      if (!v17)
      {
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v15);
      }
    }
  }
}

void sub_216A57738(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,std::__shared_weak_count *a25,uint64_t a26,std::__shared_weak_count *a27)
{
  unint64_t *p_shared_owners;
  unint64_t v29;
  unint64_t *v30;
  unint64_t v31;

  if (a25)
  {
    p_shared_owners = (unint64_t *)&a25->__shared_owners_;
    do
      v29 = __ldaxr(p_shared_owners);
    while (__stlxr(v29 - 1, p_shared_owners));
    if (!v29)
    {
      ((void (*)(std::__shared_weak_count *))a25->__on_zero_shared)(a25);
      std::__shared_weak_count::__release_weak(a25);
    }
  }
  if (a27)
  {
    v30 = (unint64_t *)&a27->__shared_owners_;
    do
      v31 = __ldaxr(v30);
    while (__stlxr(v31 - 1, v30));
    if (!v31)
    {
      ((void (*)(std::__shared_weak_count *))a27->__on_zero_shared)(a27);
      std::__shared_weak_count::__release_weak(a27);
    }
  }
  _Unwind_Resume(exception_object);
}

void Mav7SignalStrengthCommandDriver::~Mav7SignalStrengthCommandDriver(Mav7SignalStrengthCommandDriver *this)
{
  QMISignalStrengthCommandDriver::~QMISignalStrengthCommandDriver(this);
  JUMPOUT(0x2199FEAC4);
}

void `non-virtual thunk to'Mav7SignalStrengthCommandDriver::~Mav7SignalStrengthCommandDriver(Mav7SignalStrengthCommandDriver *this)
{
  QMISignalStrengthCommandDriver::~QMISignalStrengthCommandDriver((Mav7SignalStrengthCommandDriver *)((char *)this - 8));
}

{
  QMISignalStrengthCommandDriver::~QMISignalStrengthCommandDriver((Mav7SignalStrengthCommandDriver *)((char *)this - 8));
  JUMPOUT(0x2199FEAC4);
}

void std::__shared_ptr_emplace<Mav7SignalStrengthCommandDriver::create(std::shared_ptr<Registry const> const&,dispatch::queue)::MakeSharedEnabler,std::allocator<Mav7SignalStrengthCommandDriver::create(std::shared_ptr<Registry const> const&,dispatch::queue)::MakeSharedEnabler>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E5DE8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<Mav7SignalStrengthCommandDriver::create(std::shared_ptr<Registry const> const&,dispatch::queue)::MakeSharedEnabler,std::allocator<Mav7SignalStrengthCommandDriver::create(std::shared_ptr<Registry const> const&,dispatch::queue)::MakeSharedEnabler>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E5DE8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

uint64_t std::__shared_ptr_emplace<Mav7SignalStrengthCommandDriver::create(std::shared_ptr<Registry const> const&,dispatch::queue)::MakeSharedEnabler,std::allocator<Mav7SignalStrengthCommandDriver::create(std::shared_ptr<Registry const> const&,dispatch::queue)::MakeSharedEnabler>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void Mav7SignalStrengthCommandDriver::create(std::shared_ptr<Registry const> const&,dispatch::queue)::MakeSharedEnabler::~MakeSharedEnabler(QMISignalStrengthCommandDriver *a1)
{
  QMISignalStrengthCommandDriver::~QMISignalStrengthCommandDriver(a1);
  JUMPOUT(0x2199FEAC4);
}

void `non-virtual thunk to'Mav7SignalStrengthCommandDriver::create(std::shared_ptr<Registry const> const&,dispatch::queue)::MakeSharedEnabler::~MakeSharedEnabler(uint64_t a1)
{
  QMISignalStrengthCommandDriver::~QMISignalStrengthCommandDriver((QMISignalStrengthCommandDriver *)(a1 - 8));
}

{
  QMISignalStrengthCommandDriver::~QMISignalStrengthCommandDriver((QMISignalStrengthCommandDriver *)(a1 - 8));
  JUMPOUT(0x2199FEAC4);
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<QMISignalStrengthCommandDriver>::execute_wrapped<Mav7SignalStrengthCommandDriver::start(void)::$_0>(Mav7SignalStrengthCommandDriver::start(void)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<Mav7SignalStrengthCommandDriver::start(void)::$_0,dispatch_queue_s *::default_delete<Mav7SignalStrengthCommandDriver::start(void)::$_0>>)::{lambda(void *)#1}::__invoke(uint64_t **a1)
{
  uint64_t *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  std::__shared_weak_count *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  BOOL v18;
  uint64_t *v19;
  uint64_t *v20;
  uint64_t **v21;
  uint64_t *v22;
  uint64_t v23;
  unint64_t *v24;
  unint64_t v25;
  unint64_t *p_shared_owners;
  unint64_t v27;
  uint64_t **v29;
  _QWORD v30[5];
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unsigned __int16 v35;
  _QWORD aBlock[5];
  uint64_t v37;
  std::__shared_weak_count *v38;
  unsigned __int16 *v39;

  v29 = a1;
  v1 = *a1;
  v2 = **a1;
  v3 = *(_QWORD *)(v2 + 72);
  v4 = MEMORY[0x24BDAC760];
  v30[0] = MEMORY[0x24BDAC760];
  v30[1] = 0x40000000;
  v30[2] = ___ZZN31Mav7SignalStrengthCommandDriver5startEvENK3__0clEv_block_invoke;
  v30[3] = &__block_descriptor_tmp_9_9;
  v30[4] = v2;
  v5 = *(std::__shared_weak_count **)(v3 + 8);
  if (v5)
  {
    v5 = std::__shared_weak_count::lock(v5);
    v38 = v5;
    if (v5)
    {
      v13 = v5;
      v37 = *(_QWORD *)v3;
      v14 = v37;
      if (v37)
      {
        v31 = v3 + 88;
        v32 = 1;
        MEMORY[0x2199FDF3C](v3 + 88, v6, v7, v8, v9, v10, v11, v12);
        v15 = *(_QWORD *)(v3 + 24);
        if (v15)
        {
          v16 = v3 + 24;
          do
          {
            v17 = *(unsigned __int16 *)(v15 + 32);
            v18 = v17 >= 0x51;
            if (v17 >= 0x51)
              v19 = (uint64_t *)v15;
            else
              v19 = (uint64_t *)(v15 + 8);
            if (v18)
              v16 = v15;
            v15 = *v19;
          }
          while (*v19);
          if (v16 != v3 + 24 && *(unsigned __int16 *)(v16 + 32) <= 0x51u)
            __TUAssertTrigger();
        }
        aBlock[0] = v4;
        aBlock[1] = 0x40000000;
        aBlock[2] = ___ZN16QMIVirtualClient26registerUnsolicitedHandlerIN3nas7SigInfo10IndicationEEEvU13block_pointerFvRKT_E_block_invoke;
        aBlock[3] = &unk_24D5E5F28;
        aBlock[4] = v30;
        v20 = (uint64_t *)_Block_copy(aBlock);
        v35 = 81;
        v39 = &v35;
        v21 = std::__tree<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::less<unsigned short>,true>,std::allocator<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>>>::__emplace_unique_key_args<unsigned short,std::piecewise_construct_t const&,std::tuple<unsigned short &&>,std::tuple<>>((uint64_t **)(v3 + 16), &v35, (uint64_t)&std::piecewise_construct, &v39);
        v22 = v21[5];
        v21[5] = v20;
        if (v22)
          _Block_release(v22);
        std::unique_lock<ctu::UnfairLock>::~unique_lock[abi:ne180100]((uint64_t)&v31);
        v31 = 0;
        v32 = 0;
        v23 = *(_QWORD *)(v3 + 64);
        v33 = *(_QWORD *)(v3 + 56);
        v34 = v23;
        if (v23)
        {
          v24 = (unint64_t *)(v23 + 8);
          do
            v25 = __ldxr(v24);
          while (__stxr(v25 + 1, v24));
        }
        QMIClientPool::registerUnsolicitedHandler(v14, (uint64_t)&v31, v3, 0x51u);
        qmi::Client::~Client((qmi::Client *)&v31);
      }
      p_shared_owners = (unint64_t *)&v13->__shared_owners_;
      do
        v27 = __ldaxr(p_shared_owners);
      while (__stlxr(v27 - 1, p_shared_owners));
      if (!v27)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }
  }
  if (capabilities::ct::supportsEcoDataMode((capabilities::ct *)v5))
    QMIVirtualClient::addToPowerMode(*(QMIVirtualClient **)(v2 + 72));
  MEMORY[0x2199FEAC4](v1, 0x20C4093837F09);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v29);
}

void sub_216A57AE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  uint64_t v15;
  uint64_t v16;

  std::unique_lock<ctu::UnfairLock>::~unique_lock[abi:ne180100]((uint64_t)&a15);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v16 - 112);
  MEMORY[0x2199FEAC4](v15, 0x20C4093837F09);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

void ___ZZN31Mav7SignalStrengthCommandDriver5startEvENK3__0clEv_block_invoke(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  char v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  _QWORD v18[3];
  _QWORD v19[5];
  char v20;
  _QWORD v21[5];
  _QWORD v22[5];
  _QWORD v23[5];
  uint64_t v24;
  std::__shared_weak_count *v25;
  uint64_t v26;
  std::__shared_weak_count *v27;
  _QWORD *v28;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = a2[1];
  v18[0] = *a2;
  v18[1] = v3;
  v4 = a2[2];
  v18[2] = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  v26 = 0;
  v27 = 0;
  parseInputs((qmi::MessageBase *)v18, &v26);
  if (*(_QWORD *)(v26 + 16))
  {
    v7 = *(_QWORD *)(v2 + 88);
    v24 = v26;
    v25 = v27;
    if (v27)
    {
      p_shared_owners = (unint64_t *)&v27->__shared_owners_;
      do
        v9 = __ldxr(p_shared_owners);
      while (__stxr(v9 + 1, p_shared_owners));
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(_QWORD *)v7 + 32))(v7, 1, &v24);
    v10 = v25;
    if (v25)
    {
      v11 = (unint64_t *)&v25->__shared_owners_;
      do
        v12 = __ldaxr(v11);
      while (__stlxr(v12 - 1, v11));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
  }
  v13 = MEMORY[0x24BDAC760];
  v23[0] = MEMORY[0x24BDAC760];
  v23[1] = 0x40000000;
  v23[2] = ___ZN31Mav7SignalStrengthCommandDriver13handleSigInfoIN3nas7SigInfo10IndicationEEEvRKT__block_invoke;
  v23[3] = &__block_descriptor_tmp_13_17;
  v23[4] = v2;
  v19[0] = v23;
  qmi::MessageBase::applyTlv<nas::tlv::LinkQuality,void({block_pointer}&)(nas::tlv::LinkQuality const&)>((qmi::MessageBase *)v18, (uint64_t)v19);
  v22[0] = v13;
  v22[1] = 0x40000000;
  v22[2] = ___ZN31Mav7SignalStrengthCommandDriver13handleSigInfoIN3nas7SigInfo10IndicationEEEvRKT__block_invoke_2;
  v22[3] = &__block_descriptor_tmp_15_24;
  v22[4] = v2;
  v19[0] = v22;
  qmi::MessageBase::applyTlv<nas::tlv::DataLinkQuality,void({block_pointer}&)(nas::tlv::DataLinkQuality const&)>((qmi::MessageBase *)v18, (uint64_t)v19);
  v21[0] = v13;
  v21[1] = 0x40000000;
  v21[2] = ___ZN31Mav7SignalStrengthCommandDriver13handleSigInfoIN3nas7SigInfo10IndicationEEEvRKT__block_invoke_3;
  v21[3] = &__block_descriptor_tmp_16_18;
  v21[4] = v2;
  v19[0] = v21;
  v14 = qmi::MessageBase::applyTlv<nas::tlv::EnhancedVoiceLinkQuality,void({block_pointer}&)(nas::tlv::EnhancedVoiceLinkQuality const&)>((qmi::MessageBase *)v18, (uint64_t)v19);
  v19[0] = v13;
  v19[1] = 0x40000000;
  v19[2] = ___ZN31Mav7SignalStrengthCommandDriver13handleSigInfoIN3nas7SigInfo10IndicationEEEvRKT__block_invoke_4;
  v19[3] = &__block_descriptor_tmp_18_20;
  v19[4] = v2;
  v20 = v14;
  v28 = v19;
  qmi::MessageBase::applyTlv<nas::tlv::VoiceLinkQuality,void({block_pointer}&)(nas::tlv::VoiceLinkQuality const&)>((qmi::MessageBase *)v18, (uint64_t)&v28);
  v15 = v27;
  if (v27)
  {
    v16 = (unint64_t *)&v27->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v18);
}

void sub_216A57D70(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  va_list va;

  va_start(va, a2);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v2 - 88);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v2 - 72);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void ___ZN16QMIVirtualClient26registerUnsolicitedHandlerIN3nas7SigInfo10IndicationEEEvU13block_pointerFvRKT_E_block_invoke(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  _QWORD v7[3];

  v2 = *(_QWORD *)(a1 + 32);
  v3 = a2[1];
  v7[0] = *a2;
  v7[1] = v3;
  v4 = a2[2];
  v7[2] = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  qmi::MessageBase::validateMsgId((qmi::MessageBase *)v7);
  (*(void (**)(uint64_t, _QWORD *))(v2 + 16))(v2, v7);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v7);
}

void sub_216A57E18(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN31Mav7SignalStrengthCommandDriver13handleSigInfoIN3nas7SigInfo10IndicationEEEvRKT__block_invoke(uint64_t a1, _BYTE *a2)
{
  uint64_t v2;

  if (*a2 == 1)
    v2 = 100;
  else
    v2 = 50;
  return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(**(_QWORD **)(*(_QWORD *)(a1 + 32) + 88) + 40))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 88), 1, v2);
}

uint64_t ___ZN31Mav7SignalStrengthCommandDriver13handleSigInfoIN3nas7SigInfo10IndicationEEEvRKT__block_invoke_2(uint64_t a1, unsigned __int8 *a2)
{
  int v2;
  unsigned int v3;
  uint64_t v4;

  v2 = *a2;
  if (v2 == 100)
    v3 = 100;
  else
    v3 = 50;
  if (v2 == 10)
    v4 = 10;
  else
    v4 = v3;
  return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(**(_QWORD **)(*(_QWORD *)(a1 + 32) + 88) + 40))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 88), 1, v4);
}

void ___ZN31Mav7SignalStrengthCommandDriver13handleSigInfoIN3nas7SigInfo10IndicationEEEvRKT__block_invoke_3(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  void *__p;
  void *v4;
  uint64_t v5;

  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 88);
  v4 = 0;
  v5 = 0;
  __p = 0;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(&__p, *(const void **)a2, *(_QWORD *)(a2 + 8), *(_QWORD *)(a2 + 8) - *(_QWORD *)a2);
  (*(void (**)(uint64_t, uint64_t, void **))(*(_QWORD *)v2 + 56))(v2, 1, &__p);
  if (__p)
  {
    v4 = __p;
    operator delete(__p);
  }
}

void sub_216A57F08(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t ___ZN31Mav7SignalStrengthCommandDriver13handleSigInfoIN3nas7SigInfo10IndicationEEEvRKT__block_invoke_4(uint64_t result, unsigned __int8 *a2)
{
  int v2;
  unsigned int v3;
  uint64_t v4;

  if (!*(_BYTE *)(result + 40))
  {
    v2 = *a2;
    if (v2 == 100)
      v3 = 100;
    else
      v3 = 50;
    if (v2 == 10)
      v4 = 10;
    else
      v4 = v3;
    return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(**(_QWORD **)(*(_QWORD *)(result + 32) + 88) + 48))(*(_QWORD *)(*(_QWORD *)(result + 32) + 88), 1, v4);
  }
  return result;
}

uint64_t qmi::MessageBase::applyTlv<nas::tlv::LinkQuality,void({block_pointer}&)(nas::tlv::LinkQuality const&)>(qmi::MessageBase *a1, uint64_t a2)
{
  uint64_t result;
  int v5;
  uint64_t v6;
  int v7;
  char v8;
  uint64_t v9;

  result = qmi::MessageBase::findTlvValue(a1);
  if (result)
  {
    v6 = result;
    v7 = v5;
    v9 = result;
    v8 = tlv::parseV<nas::tlv::LinkQuality>((unint64_t *)&v9, v5);
    if (v9)
      return (*(uint64_t (**)(void))(*(_QWORD *)a2 + 16))();
    else
      return ((uint64_t (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, 160, v6, v7);
  }
  return result;
}

uint64_t qmi::MessageBase::applyTlv<nas::tlv::DataLinkQuality,void({block_pointer}&)(nas::tlv::DataLinkQuality const&)>(qmi::MessageBase *a1, uint64_t a2)
{
  uint64_t result;
  int v5;
  uint64_t v6;
  int v7;
  char v8;
  uint64_t v9;

  result = qmi::MessageBase::findTlvValue(a1);
  if (result)
  {
    v6 = result;
    v7 = v5;
    v9 = result;
    v8 = tlv::parseV<nas::tlv::DataLinkQuality>((unint64_t *)&v9, v5);
    if (v9)
      return (*(uint64_t (**)(void))(*(_QWORD *)a2 + 16))();
    else
      return ((uint64_t (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, 162, v6, v7);
  }
  return result;
}

uint64_t qmi::MessageBase::applyTlv<nas::tlv::EnhancedVoiceLinkQuality,void({block_pointer}&)(nas::tlv::EnhancedVoiceLinkQuality const&)>(qmi::MessageBase *a1, uint64_t a2)
{
  uint64_t result;
  int v5;
  uint64_t v6;
  int v7;
  char *v8;
  void *__p;
  void *v10;
  uint64_t v11;
  char *v12;

  result = qmi::MessageBase::findTlvValue(a1);
  if (result)
  {
    v6 = result;
    v7 = v5;
    v11 = 0;
    v12 = (char *)result;
    __p = 0;
    v10 = 0;
    tlv::parseV<nas::tlv::EnhancedVoiceLinkQuality>(&v12, v5, &__p);
    v8 = v12;
    if (v12)
      (*(void (**)(void))(*(_QWORD *)a2 + 16))();
    if (__p)
    {
      v10 = __p;
      operator delete(__p);
    }
    if (v8)
      return 1;
    else
      return ((uint64_t (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, 164, v6, v7);
  }
  return result;
}

void sub_216A5816C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t qmi::MessageBase::applyTlv<nas::tlv::VoiceLinkQuality,void({block_pointer}&)(nas::tlv::VoiceLinkQuality const&)>(qmi::MessageBase *a1, uint64_t a2)
{
  uint64_t result;
  int v5;
  uint64_t v6;
  int v7;
  char v8;
  uint64_t v9;

  result = qmi::MessageBase::findTlvValue(a1);
  if (result)
  {
    v6 = result;
    v7 = v5;
    v9 = result;
    v8 = tlv::parseV<nas::tlv::VoiceLinkQuality>((unint64_t *)&v9, v5);
    if (v9)
      return (*(uint64_t (**)(void))(*(_QWORD *)a2 + 16))();
    else
      return ((uint64_t (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, 163, v6, v7);
  }
  return result;
}

void ___ZN16QMIVirtualClient4sendIN3nas18IndicationRegister7RequestEU13block_pointerFvRKNS2_8ResponseEEEEvRKT_T0__block_invoke(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  _QWORD v7[3];

  v2 = *(_QWORD *)(a1 + 32);
  v3 = a2[1];
  v7[0] = *a2;
  v7[1] = v3;
  v4 = a2[2];
  v7[2] = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  qmi::MessageBase::validateMsgId((qmi::MessageBase *)v7);
  (*(void (**)(uint64_t, _QWORD *))(v2 + 16))(v2, v7);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v7);
}

void sub_216A58294(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void ___ZN16QMIVirtualClient4sendIN3nas14ConfigSigInfo27RequestEU13block_pointerFvRKNS2_8ResponseEEEEvRKT_T0__block_invoke(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  _QWORD v7[3];

  v2 = *(_QWORD *)(a1 + 32);
  v3 = a2[1];
  v7[0] = *a2;
  v7[1] = v3;
  v4 = a2[2];
  v7[2] = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  qmi::MessageBase::validateMsgId((qmi::MessageBase *)v7);
  (*(void (**)(uint64_t, _QWORD *))(v2 + 16))(v2, v7);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v7);
}

void sub_216A5831C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN31Mav7SignalStrengthCommandDriver13handleSigInfoIN3nas10GetSigInfo8ResponseEEEvRKT__block_invoke(uint64_t a1, _BYTE *a2)
{
  uint64_t v2;

  if (*a2 == 1)
    v2 = 100;
  else
    v2 = 50;
  return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(**(_QWORD **)(*(_QWORD *)(a1 + 32) + 88) + 40))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 88), 1, v2);
}

uint64_t ___ZN31Mav7SignalStrengthCommandDriver13handleSigInfoIN3nas10GetSigInfo8ResponseEEEvRKT__block_invoke_2(uint64_t a1, unsigned __int8 *a2)
{
  int v2;
  unsigned int v3;
  uint64_t v4;

  v2 = *a2;
  if (v2 == 100)
    v3 = 100;
  else
    v3 = 50;
  if (v2 == 10)
    v4 = 10;
  else
    v4 = v3;
  return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(**(_QWORD **)(*(_QWORD *)(a1 + 32) + 88) + 40))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 88), 1, v4);
}

void ___ZN31Mav7SignalStrengthCommandDriver13handleSigInfoIN3nas10GetSigInfo8ResponseEEEvRKT__block_invoke_3(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  void *__p;
  void *v4;
  uint64_t v5;

  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 88);
  v4 = 0;
  v5 = 0;
  __p = 0;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(&__p, *(const void **)a2, *(_QWORD *)(a2 + 8), *(_QWORD *)(a2 + 8) - *(_QWORD *)a2);
  (*(void (**)(uint64_t, uint64_t, void **))(*(_QWORD *)v2 + 56))(v2, 1, &__p);
  if (__p)
  {
    v4 = __p;
    operator delete(__p);
  }
}

void sub_216A5840C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t ___ZN31Mav7SignalStrengthCommandDriver13handleSigInfoIN3nas10GetSigInfo8ResponseEEEvRKT__block_invoke_4(uint64_t result, unsigned __int8 *a2)
{
  int v2;
  unsigned int v3;
  uint64_t v4;

  if (!*(_BYTE *)(result + 40))
  {
    v2 = *a2;
    if (v2 == 100)
      v3 = 100;
    else
      v3 = 50;
    if (v2 == 10)
      v4 = 10;
    else
      v4 = v3;
    return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(**(_QWORD **)(*(_QWORD *)(result + 32) + 88) + 48))(*(_QWORD *)(*(_QWORD *)(result + 32) + 88), 1, v4);
  }
  return result;
}

void ___ZN16QMIVirtualClient4sendIN3nas10GetSigInfo7RequestEU13block_pointerFvRKNS2_8ResponseEEEEvRKT_T0__block_invoke(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  _QWORD v7[3];

  v2 = *(_QWORD *)(a1 + 32);
  v3 = a2[1];
  v7[0] = *a2;
  v7[1] = v3;
  v4 = a2[2];
  v7[2] = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  qmi::MessageBase::validateMsgId((qmi::MessageBase *)v7);
  (*(void (**)(uint64_t, _QWORD *))(v2 + 16))(v2, v7);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v7);
}

void sub_216A584E4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

double QMIDMSCommandDriver::create@<D0>(uint64_t a1@<X0>, dispatch_object_t *a2@<X1>, _OWORD *a3@<X8>)
{
  uint64_t v6;
  __int128 v7;
  _QWORD *v8;
  unint64_t *v9;
  unint64_t v10;
  _OWORD *v11;
  NSObject *v12;
  uint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  _QWORD *v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  double result;
  __int128 v22;
  uint64_t v23;
  std::__shared_weak_count *v24;
  uint64_t v25;
  uint64_t v26;

  v6 = operator new();
  QMIDMSCommandDriver::QMIDMSCommandDriver(v6, a1, a2);
  v22 = 0uLL;
  std::shared_ptr<QMIDMSCommandDriver>::shared_ptr[abi:ne180100]<QMIDMSCommandDriver,std::shared_ptr<QMIDMSCommandDriver> ctu::SharedSynchronizable<DMSCommandDriver>::make_shared_ptr<QMIDMSCommandDriver>(QMIDMSCommandDriver*)::{lambda(QMIDMSCommandDriver*)#1},void>((uint64_t *)&v22, v6);
  v7 = v22;
  v8 = (_QWORD *)(v22 + 8);
  if (*((_QWORD *)&v22 + 1))
  {
    v9 = (unint64_t *)(*((_QWORD *)&v22 + 1) + 8);
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }
  v23 = 0;
  v24 = 0;
  std::shared_ptr<AttachApnCommandDriver>::shared_ptr[abi:ne180100]<AttachApnCommandDriver,void>(&v23, v8);
  v11 = (_OWORD *)operator new();
  *v11 = v7;
  v12 = *(NSObject **)(v7 + 24);
  v13 = v23;
  v14 = v24;
  if (v24)
  {
    p_shared_owners = (unint64_t *)&v24->__shared_owners_;
    do
      v16 = __ldxr(p_shared_owners);
    while (__stxr(v16 + 1, p_shared_owners));
  }
  v17 = (_QWORD *)operator new();
  *v17 = v11;
  v17[1] = v13;
  v17[2] = v14;
  v25 = 0;
  v26 = 0;
  dispatch_async_f(v12, v17, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<DMSCommandDriver>::execute_wrapped<QMIDMSCommandDriver::create(std::shared_ptr<Registry const> const&,dispatch::queue)::$_0>(QMIDMSCommandDriver::create(std::shared_ptr<Registry const> const&,dispatch::queue)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIDMSCommandDriver::create(std::shared_ptr<Registry const> const&,dispatch::queue)::$_0,std::default_delete<QMIDMSCommandDriver::create(std::shared_ptr<Registry const> const&,dispatch::queue)::$_0>>)::{lambda(void *)#1}::__invoke);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v25);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v26);
  v18 = v24;
  if (v24)
  {
    v19 = (unint64_t *)&v24->__shared_owners_;
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
  result = *(double *)&v22;
  *a3 = v22;
  return result;
}

void sub_216A58668(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199FEAC4](v1, 0x10E1C40A140B717);
  _Unwind_Resume(a1);
}

uint64_t QMIDMSCommandDriver::QMIDMSCommandDriver(uint64_t a1, uint64_t a2, dispatch_object_t *a3)
{
  _QWORD *v5;
  uint64_t v6;
  NSObject *object;
  _QWORD v9[3];
  _QWORD *v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  object = *a3;
  if (*a3)
    dispatch_retain(*a3);
  DMSCommandDriver::DMSCommandDriver();
  if (object)
    dispatch_release(object);
  v9[0] = &unk_24D5CCF40;
  v10 = v9;
  QmiSimInstanceLogger<QMIDMSCommandDriver,ctu::OsLogLogger,subscriber::SimSlot,std::function<char const* const ()(subscriber::SimSlot)>>::QmiSimInstanceLogger((capabilities::ct *)(a1 + 248), a2, (uint64_t)v9);
  v5 = v10;
  if (v10 == v9)
  {
    v6 = 4;
    v5 = v9;
    goto LABEL_9;
  }
  if (v10)
  {
    v6 = 5;
LABEL_9:
    (*(void (**)(void))(*v5 + 8 * v6))();
  }
  *(_QWORD *)a1 = &off_24D5E60F8;
  qmi::ClientRouter::ClientRouter((qmi::ClientRouter *)(a1 + 256), *(os_log_s **)(a1 + 40));
  return a1;
}

void sub_216A5879C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, char a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  DMSCommandDriver *v13;
  uint64_t *v14;
  uint64_t *v15;
  uint64_t v17;

  v15 = v14;
  v17 = *v15;
  *v15 = 0;
  if (v17)
    (*(void (**)(uint64_t))(*(_QWORD *)v17 + 8))(v17);
  DMSCommandDriver::~DMSCommandDriver(v13);
  _Unwind_Resume(a1);
}

capabilities::ct *QmiSimInstanceLogger<QMIDMSCommandDriver,ctu::OsLogLogger,subscriber::SimSlot,std::function<char const* const ()(subscriber::SimSlot)>>::QmiSimInstanceLogger(capabilities::ct *a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v5;
  uint64_t v6;
  _BYTE v8[24];
  _BYTE *v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  std::__function::__value_func<char const* const ()(subscriber::SimSlot)>::__value_func[abi:ne180100]((uint64_t)v8, a3);
  SimInstanceLogger<QMIDMSCommandDriver,ctu::OsLogLogger,subscriber::SimSlot,std::function<char const* const ()(subscriber::SimSlot)>>::SimInstanceLogger(a1, a2, (uint64_t)v8);
  v5 = v9;
  if (v9 == v8)
  {
    v6 = 4;
    v5 = v8;
    goto LABEL_5;
  }
  if (v9)
  {
    v6 = 5;
LABEL_5:
    (*(void (**)(void))(*v5 + 8 * v6))();
  }
  return a1;
}

void sub_216A588E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v13;
  char *v15;
  uint64_t v16;

  v15 = a13;
  if (a13 == v13)
  {
    v16 = 4;
    v15 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v16 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v15 + 8 * v16))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t QMIDMSCommandDriver::start(QMIDMSCommandDriver *this)
{
  DMSCommandDriver::start(this);
  return qmi::ClientRouter::start();
}

uint64_t QMIDMSCommandDriver::stop(QMIDMSCommandDriver *this)
{
  qmi::ClientRouter::stop();
  return DMSCommandDriver::stop(this);
}

void QMIDMSCommandDriver::setupRequestsAndIndications_sync(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  const void **v5;
  char *v6;
  _BYTE *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  unint64_t *v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t *p_shared_owners;
  unint64_t v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  void *__p[2];
  __int128 v37;
  unsigned int v38;
  _QWORD v39[5];
  std::__shared_weak_count *v40;
  char *v41;
  std::__shared_weak_count *v42;
  _QWORD aBlock[5];

  v38 = 255;
  if (subscriber::isSet())
    subscriber::clearFlag();
  if (subscriber::isSet())
    subscriber::clearFlag();
  if (subscriber::isSet())
    subscriber::clearFlag();
  if (subscriber::isSet())
    subscriber::clearFlag();
  if (a2 - 1 >= 3)
    v4 = 0;
  else
    v4 = a2;
  (*(void (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)a1 + 40))(a1, v4, v38);
  *(_OWORD *)__p = 0u;
  v37 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  v5 = (const void **)__p[1];
  if (__p[1] != (void *)v37)
  {
    while (*((_BYTE *)*v5 + 8) != 23)
    {
      if (++v5 == (const void **)v37)
        goto LABEL_19;
    }
  }
  if (v5 == (const void **)v37)
  {
LABEL_19:
    v8 = operator new();
    v9 = v8;
    *(_WORD *)(v8 + 8) = 23;
    *(_QWORD *)v8 = &off_24D5E64B8;
    v10 = v37;
    if ((unint64_t)v37 >= *((_QWORD *)&v37 + 1))
    {
      v12 = (uint64_t)(v37 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v12 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v13 = (uint64_t)(*((_QWORD *)&v37 + 1) - (unint64_t)__p[1]) >> 2;
      if (v13 <= v12 + 1)
        v13 = v12 + 1;
      if (*((_QWORD *)&v37 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v14 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v14 = v13;
      if (v14)
        v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v37 + 8, v14);
      else
        v15 = 0;
      v16 = (uint64_t *)&v15[8 * v12];
      v17 = &v15[8 * v14];
      *v16 = v9;
      v11 = v16 + 1;
      v19 = (char *)__p[1];
      v18 = (char *)v37;
      if ((void *)v37 != __p[1])
      {
        do
        {
          v20 = *((_QWORD *)v18 - 1);
          v18 -= 8;
          *--v16 = v20;
        }
        while (v18 != v19);
        v18 = (char *)__p[1];
      }
      __p[1] = v16;
      *(_QWORD *)&v37 = v11;
      *((_QWORD *)&v37 + 1) = v17;
      if (v18)
        operator delete(v18);
    }
    else
    {
      *(_QWORD *)v37 = v8;
      v11 = (_QWORD *)(v10 + 8);
    }
    v7 = (_BYTE *)(v9 + 9);
    *(_QWORD *)&v37 = v11;
  }
  else
  {
    if (!v6)
      __cxa_bad_cast();
    v7 = v6 + 9;
  }
  *v7 = 1;
  v21 = qmi::ClientRouter::get();
  qmi::ClientRouter::SendProxy::SendProxy<dms::SetEventReport::Request>((uint64_t)&v34, a2, v21);
  v22 = operator new(0x28uLL);
  v22[1] = 0;
  v23 = v22 + 1;
  v22[2] = 0;
  *v22 = &off_24D5E6520;
  v22[3] = a1;
  *((_DWORD *)v22 + 8) = a2;
  v41 = (char *)(v22 + 3);
  v42 = (std::__shared_weak_count *)v22;
  v24 = v35;
  v25 = MEMORY[0x24BDAC760];
  v39[0] = MEMORY[0x24BDAC760];
  v39[1] = 1174405120;
  v39[2] = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN19QMIDMSCommandDriver32setupRequestsAndIndications_syncENS_16SubscriptionTypeEE3__0EEOS1_OT__block_invoke;
  v39[3] = &__block_descriptor_tmp_19_19;
  v39[4] = v22 + 3;
  v40 = (std::__shared_weak_count *)v22;
  do
    v26 = __ldxr(v23);
  while (__stxr(v26 + 1, v23));
  aBlock[0] = v25;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_29;
  aBlock[3] = &unk_24D5E6568;
  aBlock[4] = v39;
  *(_QWORD *)(v24 + 32) = _Block_copy(aBlock);
  v27 = v40;
  if (v40)
  {
    p_shared_owners = (unint64_t *)&v40->__shared_owners_;
    do
      v29 = __ldaxr(p_shared_owners);
    while (__stlxr(v29 - 1, p_shared_owners));
    if (!v29)
    {
      ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
      std::__shared_weak_count::__release_weak(v27);
    }
  }
  v30 = v42;
  if (v42)
  {
    v31 = (unint64_t *)&v42->__shared_owners_;
    do
      v32 = __ldaxr(v31);
    while (__stlxr(v32 - 1, v31));
    if (!v32)
    {
      ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
      std::__shared_weak_count::__release_weak(v30);
    }
  }
  v33 = v35;
  v35 = 0;
  if (v33)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v35, v33);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
}

void sub_216A58D14(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  va_list va;
  uint64_t v7;
  va_list va1;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  va_list va2;

  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v5 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v7 = va_arg(va2, _QWORD);
  v9 = va_arg(va2, _QWORD);
  v10 = va_arg(va2, _QWORD);
  v11 = va_arg(va2, _QWORD);
  v12 = va_arg(va2, _QWORD);
  v13 = va_arg(va2, _QWORD);
  v14 = va_arg(va2, _QWORD);
  v15 = va_arg(va2, _QWORD);
  v16 = va_arg(va2, _QWORD);
  v17 = va_arg(va2, _QWORD);
  v18 = va_arg(va2, _QWORD);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v2);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va2);
  v4 = v5;
  v5 = 0;
  if (v4)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)va, v4);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va1);
  _Unwind_Resume(a1);
}

void QMIDMSCommandDriver::get(std::__shared_weak_count_vtbl *a1, uint64_t a2, int a3)
{
  int v6;
  uint64_t v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  uint64_t v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  uint64_t v23;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  unint64_t v28;
  uint64_t v29;
  __int128 v30;
  __int128 v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  void (*v36)(uint64_t, qmi::MessageBase *);
  void *v37;
  std::__shared_weak_count *v38;
  std::__shared_weak_count *v39;
  uint64_t aBlock;
  uint64_t v41;
  void (*v42)(uint64_t, QMIServiceMsg *);
  void *v43;
  uint64_t *v44;

  if (subscriber::isSet())
  {
    if ((a2 - 1) >= 3)
      v6 = 0;
    else
      v6 = a2;
    v30 = 0u;
    v31 = 0u;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)&v30);
    v7 = qmi::ClientRouter::get();
    v32 = v6;
    v8 = operator new();
    *(_QWORD *)v8 = v7;
    *(_QWORD *)(v8 + 8) = QMIServiceMsg::create();
    *(_DWORD *)(v8 + 16) = 25000;
    *(_QWORD *)(v8 + 24) = 0;
    *(_QWORD *)(v8 + 32) = 0;
    v33 = v8;
    v9 = (std::__shared_weak_count *)operator new(0x28uLL);
    v9->__shared_owners_ = 0;
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    v9->__shared_weak_owners_ = 0;
    v9->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E65C8;
    v9[1].__vftable = a1;
    LODWORD(v9[1].__shared_owners_) = a2;
    HIDWORD(v9[1].__shared_owners_) = a3;
    v11 = MEMORY[0x24BDAC760];
    v34 = MEMORY[0x24BDAC760];
    v35 = 1174405120;
    v36 = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN19QMIDMSCommandDriver18querySerialNumbersEN10subscriber7SimSlotEN16DMSCommandDriver11InformationEE3__0EEOS1_OT__block_invoke;
    v37 = &__block_descriptor_tmp_21_12;
    v38 = v9 + 1;
    v39 = v9;
    do
      v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
    aBlock = v11;
    v41 = 0x40000000;
    v42 = ___ZNO3qmi6Client9SendProxy8callbackIRKN3dms22GetDeviceSerialNumbers8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
    v43 = &unk_24D5E6610;
    v44 = &v34;
    *(_QWORD *)(v8 + 32) = _Block_copy(&aBlock);
    v13 = v39;
    if (v39)
    {
      v14 = (unint64_t *)&v39->__shared_owners_;
      do
        v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }
    do
      v16 = __ldaxr(p_shared_owners);
    while (__stlxr(v16 - 1, p_shared_owners));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
    v17 = v33;
    v33 = 0;
    if (v17)
      std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v33, v17);
    qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&v30);
  }
  if (subscriber::isSet())
    (*((void (**)(std::__shared_weak_count_vtbl *, uint64_t))a1->~__shared_weak_count + 9))(a1, a2);
  if (subscriber::isSet())
  {
    if ((a2 - 1) >= 3)
      v18 = 0;
    else
      v18 = a2;
    v30 = 0u;
    v31 = 0u;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)&v30);
    v19 = qmi::ClientRouter::get();
    v32 = v18;
    v20 = operator new();
    *(_QWORD *)v20 = v19;
    *(_QWORD *)(v20 + 8) = QMIServiceMsg::create();
    *(_DWORD *)(v20 + 16) = 25000;
    *(_QWORD *)(v20 + 24) = 0;
    *(_QWORD *)(v20 + 32) = 0;
    v33 = v20;
    v21 = (std::__shared_weak_count *)operator new(0x28uLL);
    v21->__shared_owners_ = 0;
    v22 = (unint64_t *)&v21->__shared_owners_;
    v21->__shared_weak_owners_ = 0;
    v21->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E6798;
    v21[1].__vftable = a1;
    LODWORD(v21[1].__shared_owners_) = a2;
    HIDWORD(v21[1].__shared_owners_) = a3;
    v23 = MEMORY[0x24BDAC760];
    v34 = MEMORY[0x24BDAC760];
    v35 = 1174405120;
    v36 = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN19QMIDMSCommandDriver11queryMSISDNEN10subscriber7SimSlotEN16DMSCommandDriver11InformationEE3__0EEOS1_OT__block_invoke;
    v37 = &__block_descriptor_tmp_32_8;
    v38 = v21 + 1;
    v39 = v21;
    do
      v24 = __ldxr(v22);
    while (__stxr(v24 + 1, v22));
    aBlock = v23;
    v41 = 0x40000000;
    v42 = ___ZNO3qmi6Client9SendProxy8callbackIRKN3dms9GetMSISDN8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
    v43 = &unk_24D5E67E0;
    v44 = &v34;
    *(_QWORD *)(v20 + 32) = _Block_copy(&aBlock);
    v25 = v39;
    if (v39)
    {
      v26 = (unint64_t *)&v39->__shared_owners_;
      do
        v27 = __ldaxr(v26);
      while (__stlxr(v27 - 1, v26));
      if (!v27)
      {
        ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
        std::__shared_weak_count::__release_weak(v25);
      }
    }
    do
      v28 = __ldaxr(v22);
    while (__stlxr(v28 - 1, v22));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
    v29 = v33;
    v33 = 0;
    if (v29)
      std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v33, v29);
    qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&v30);
  }
}

void sub_216A59134(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21)
{
  uint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  std::__shared_weak_count *v25;
  unint64_t *p_shared_owners;
  unint64_t v27;
  unint64_t v28;
  uint64_t v29;

  v25 = a21;
  if (a21)
  {
    p_shared_owners = (unint64_t *)&a21->__shared_owners_;
    do
      v27 = __ldaxr(p_shared_owners);
    while (__stlxr(v27 - 1, p_shared_owners));
    if (!v27)
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }
  do
    v28 = __ldaxr(v23);
  while (__stlxr(v28 - 1, v23));
  if (!v28)
  {
    ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
    std::__shared_weak_count::__release_weak(v22);
  }
  v29 = a15;
  a15 = 0;
  if (v29)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v21, v29);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a9);
  _Unwind_Resume(a1);
}

void QMIDMSCommandDriver::queryPRLVersion(uint64_t a1, int a2)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  unint64_t *v8;
  uint64_t v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  uint64_t v17;
  _OWORD v18[2];
  int v19;
  uint64_t v20;
  _QWORD v21[5];
  std::__shared_weak_count *v22;
  char *v23;
  std::__shared_weak_count *v24;
  _QWORD aBlock[5];

  if ((a2 - 1) >= 3)
    v4 = 0;
  else
    v4 = a2;
  memset(v18, 0, sizeof(v18));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v18);
  v5 = qmi::ClientRouter::get();
  v19 = v4;
  v6 = operator new();
  *(_QWORD *)v6 = v5;
  *(_QWORD *)(v6 + 8) = QMIServiceMsg::create();
  *(_DWORD *)(v6 + 16) = 25000;
  *(_QWORD *)(v6 + 24) = 0;
  *(_QWORD *)(v6 + 32) = 0;
  v20 = v6;
  v7 = operator new(0x28uLL);
  v7[1] = 0;
  v8 = v7 + 1;
  v7[2] = 0;
  *v7 = &off_24D5E66F0;
  v7[3] = a1;
  *((_DWORD *)v7 + 8) = a2;
  v23 = (char *)(v7 + 3);
  v24 = (std::__shared_weak_count *)v7;
  v9 = MEMORY[0x24BDAC760];
  v21[0] = MEMORY[0x24BDAC760];
  v21[1] = 1174405120;
  v21[2] = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN19QMIDMSCommandDriver15queryPRLVersionEN10subscriber7SimSlotEE3__0EEOS1_OT__block_invoke;
  v21[3] = &__block_descriptor_tmp_28_13;
  v21[4] = v7 + 3;
  v22 = (std::__shared_weak_count *)v7;
  do
    v10 = __ldxr(v8);
  while (__stxr(v10 + 1, v8));
  aBlock[0] = v9;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3dms17GetCurrentPRLInfo8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
  aBlock[3] = &unk_24D5E6738;
  aBlock[4] = v21;
  *(_QWORD *)(v6 + 32) = _Block_copy(aBlock);
  v11 = v22;
  if (v22)
  {
    p_shared_owners = (unint64_t *)&v22->__shared_owners_;
    do
      v13 = __ldaxr(p_shared_owners);
    while (__stlxr(v13 - 1, p_shared_owners));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  v14 = v24;
  if (v24)
  {
    v15 = (unint64_t *)&v24->__shared_owners_;
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
  v17 = v20;
  v20 = 0;
  if (v17)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v20, v17);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v18);
}

void sub_216A59444(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22)
{
  uint64_t v22;
  uint64_t v23;
  uint64_t v25;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v23);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a22);
  v25 = a15;
  a15 = 0;
  if (v25)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v22, v25);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a9);
  _Unwind_Resume(a1);
}

void QMIDMSCommandDriver::started(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  NSObject *v4;
  _BOOL8 v5;
  _DWORD *v6;
  int v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _OWORD v21[2];
  uint8_t buf[8];
  uint64_t v23;
  void (*v24)(uint64_t, uint64_t);
  void *v25;
  std::__shared_weak_count *v26;
  std::__shared_weak_count *v27;
  _QWORD aBlock[5];

  v2 = a2;
  if ((a2 - 1) >= 3)
    a2 = 0;
  else
    a2 = a2;
  v4 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 248) + 16))(*(_QWORD *)(a1 + 248), a2);
  v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (v5)
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I DMS client started", buf, 2u);
  }
  if (capabilities::ct::supportsGemini((capabilities::ct *)v5))
  {
    memset(v21, 0, sizeof(v21));
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v21);
    v6 = (_DWORD *)qmi::MutableMessageBase::getTLV<dms::tlv::SubscriptionType>(v21, 1);
    if (v2 == 2)
      v7 = 2;
    else
      v7 = 1;
    *v6 = v7;
    v8 = qmi::ClientRouter::get();
    qmi::ClientRouter::SendProxy::SendProxy<dms::BindSubscription::Request>((uint64_t)&v19, v2, v8);
    v9 = (std::__shared_weak_count *)operator new(0x28uLL);
    v9->__shared_owners_ = 0;
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    v9->__shared_weak_owners_ = 0;
    v9->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E6428;
    v9[1].__vftable = (std::__shared_weak_count_vtbl *)a1;
    LODWORD(v9[1].__shared_owners_) = v2;
    v11 = v20;
    v12 = MEMORY[0x24BDAC760];
    *(_QWORD *)buf = MEMORY[0x24BDAC760];
    v23 = 1174405120;
    v24 = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN19QMIDMSCommandDriver21bindSubscription_syncENS_16SubscriptionTypeEE3__0EEOS1_OT__block_invoke;
    v25 = &__block_descriptor_tmp_16_19;
    v26 = v9 + 1;
    v27 = v9;
    do
      v13 = __ldxr(p_shared_owners);
    while (__stxr(v13 + 1, p_shared_owners));
    aBlock[0] = v12;
    aBlock[1] = 0x40000000;
    aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3dms16BindSubscription8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke_0;
    aBlock[3] = &unk_24D5E6470;
    aBlock[4] = buf;
    *(_QWORD *)(v11 + 32) = _Block_copy(aBlock);
    v14 = v27;
    if (v27)
    {
      v15 = (unint64_t *)&v27->__shared_owners_;
      do
        v16 = __ldaxr(v15);
      while (__stlxr(v16 - 1, v15));
      if (!v16)
      {
        ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
        std::__shared_weak_count::__release_weak(v14);
      }
    }
    do
      v17 = __ldaxr(p_shared_owners);
    while (__stlxr(v17 - 1, p_shared_owners));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
    v18 = v20;
    v20 = 0;
    if (v18)
      std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v20, v18);
    qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v21);
  }
  else
  {
    QMIDMSCommandDriver::setupRequestsAndIndications_sync(a1, v2);
  }
}

void sub_216A596D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20)
{
  std::__shared_weak_count *v20;
  unint64_t *v21;
  std::__shared_weak_count *v23;
  unint64_t *p_shared_owners;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;

  v23 = a20;
  if (a20)
  {
    p_shared_owners = (unint64_t *)&a20->__shared_owners_;
    do
      v25 = __ldaxr(p_shared_owners);
    while (__stlxr(v25 - 1, p_shared_owners));
    if (!v25)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }
  do
    v26 = __ldaxr(v21);
  while (__stlxr(v26 - 1, v21));
  if (!v26)
  {
    ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
    std::__shared_weak_count::__release_weak(v20);
  }
  v27 = a10;
  a10 = 0;
  if (v27)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&a10, v27);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a11);
  _Unwind_Resume(a1);
}

uint64_t QMIDMSCommandDriver::stopped(uint64_t a1, uint64_t a2)
{
  NSObject *v2;
  uint8_t v4[16];

  if ((a2 - 1) >= 3)
    a2 = 0;
  else
    a2 = a2;
  v2 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 248) + 16))(*(_QWORD *)(a1 + 248), a2);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v4 = 0;
    _os_log_impl(&dword_216897000, v2, OS_LOG_TYPE_DEFAULT, "#I DMS client stopped", v4, 2u);
  }
  DMSCommandDriver::clearMin();
  return DMSCommandDriver::clearPrlVersion();
}

void QMIDMSCommandDriver::~QMIDMSCommandDriver(QMIDMSCommandDriver *this)
{
  uint64_t v2;

  *(_QWORD *)this = &off_24D5E60F8;
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)this + 256);
  v2 = *((_QWORD *)this + 31);
  *((_QWORD *)this + 31) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  DMSCommandDriver::~DMSCommandDriver(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = &off_24D5E60F8;
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)this + 256);
  v2 = *((_QWORD *)this + 31);
  *((_QWORD *)this + 31) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  DMSCommandDriver::~DMSCommandDriver(this);
  JUMPOUT(0x2199FEAC4);
}

uint64_t *std::shared_ptr<QMIDMSCommandDriver>::shared_ptr[abi:ne180100]<QMIDMSCommandDriver,std::shared_ptr<QMIDMSCommandDriver> ctu::SharedSynchronizable<DMSCommandDriver>::make_shared_ptr<QMIDMSCommandDriver>(QMIDMSCommandDriver*)::{lambda(QMIDMSCommandDriver*)#1},void>(uint64_t *a1, uint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24D5E61B8;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = (uint64_t)v4;
  if (a2)
    v5 = (_QWORD *)(a2 + 8);
  else
    v5 = 0;
  std::shared_ptr<QMIDataSystemDeterminationManager>::__enable_weak_this[abi:ne180100]<QMIDataSystemDeterminationManager,QMIDataSystemDeterminationManager,void>((uint64_t)a1, v5, a2);
  return a1;
}

void sub_216A5993C(void *a1)
{
  dispatch_queue_t *v1;

  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)std::shared_ptr<QMIDMSCommandDriver> ctu::SharedSynchronizable<DMSCommandDriver>::make_shared_ptr<QMIDMSCommandDriver>(QMIDMSCommandDriver*)::{lambda(QMIDMSCommandDriver*)#1}::operator() const(QMIDMSCommandDriver*)::{lambda(void *)#1}::__invoke);
  __cxa_rethrow();
}

void sub_216A5995C(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<QMIDMSCommandDriver *,std::shared_ptr<QMIDMSCommandDriver> ctu::SharedSynchronizable<DMSCommandDriver>::make_shared_ptr<QMIDMSCommandDriver>(QMIDMSCommandDriver*)::{lambda(QMIDMSCommandDriver *)#1},std::allocator<QMIDMSCommandDriver>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void std::__shared_ptr_pointer<QMIDMSCommandDriver *,std::shared_ptr<QMIDMSCommandDriver> ctu::SharedSynchronizable<DMSCommandDriver>::make_shared_ptr<QMIDMSCommandDriver>(QMIDMSCommandDriver*)::{lambda(QMIDMSCommandDriver *)#1},std::allocator<QMIDMSCommandDriver>>::__on_zero_shared(uint64_t a1)
{
  dispatch_barrier_async_f(*(dispatch_queue_t *)(*(_QWORD *)(a1 + 24) + 24), *(void **)(a1 + 24), (dispatch_function_t)std::shared_ptr<QMIDMSCommandDriver> ctu::SharedSynchronizable<DMSCommandDriver>::make_shared_ptr<QMIDMSCommandDriver>(QMIDMSCommandDriver*)::{lambda(QMIDMSCommandDriver*)#1}::operator() const(QMIDMSCommandDriver*)::{lambda(void *)#1}::__invoke);
}

uint64_t std::__shared_ptr_pointer<QMIDMSCommandDriver *,std::shared_ptr<QMIDMSCommandDriver> ctu::SharedSynchronizable<DMSCommandDriver>::make_shared_ptr<QMIDMSCommandDriver>(QMIDMSCommandDriver*)::{lambda(QMIDMSCommandDriver *)#1},std::allocator<QMIDMSCommandDriver>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t std::shared_ptr<QMIDMSCommandDriver> ctu::SharedSynchronizable<DMSCommandDriver>::make_shared_ptr<QMIDMSCommandDriver>(QMIDMSCommandDriver*)::{lambda(QMIDMSCommandDriver*)#1}::operator() const(QMIDMSCommandDriver*)::{lambda(void *)#1}::__invoke(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<DMSCommandDriver>::execute_wrapped<QMIDMSCommandDriver::create(std::shared_ptr<Registry const> const&,dispatch::queue)::$_0>(QMIDMSCommandDriver::create(std::shared_ptr<Registry const> const&,dispatch::queue)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIDMSCommandDriver::create(std::shared_ptr<Registry const> const&,dispatch::queue)::$_0,std::default_delete<QMIDMSCommandDriver::create(std::shared_ptr<Registry const> const&,dispatch::queue)::$_0>>)::{lambda(void *)#1}::__invoke(_QWORD ***a1)
{
  _QWORD **v1;
  _QWORD *v2;
  _DWORD *v3;
  char *v4;
  std::__shared_weak_count *v5;
  uint64_t v6;
  std::__shared_weak_count *v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_weak_owners;
  unint64_t v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  NSObject *v13;
  std::__shared_weak_count *v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  unint64_t *v22;
  unint64_t v23;
  _DWORD *v24;
  void **v25;
  uint64_t v26;
  void **v27;
  uint64_t v28;
  __int128 *v29;
  uint64_t v30;
  Registry **v32;
  _QWORD ***v33;
  _QWORD **v34;
  _DWORD *v35;
  _DWORD *v36;
  uint64_t (*v37)(_QWORD);
  __int128 v38;
  __int128 v39;
  uint64_t v40;
  std::__shared_weak_count *v41;
  dispatch_object_t object;
  void *__p[2];
  char v44;
  void **v45;
  void *v46;
  _QWORD *v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  uint64_t v51;

  v51 = *MEMORY[0x24BDAC8D0];
  v1 = *a1;
  v33 = a1;
  v34 = v1;
  v2 = *v1;
  v32 = (Registry **)(*v1 + 9);
  subscriber::makeSimSlotRange();
  v3 = v35;
  if (v35 != v36)
  {
    while ((v37(*v3) & 1) == 0)
    {
      if (++v3 == v36)
      {
        v3 = v36;
        break;
      }
    }
    while (v3 != v36)
    {
      if (*v3 == 1)
      {
        v4 = "QMIDMSCommandDriver.1";
      }
      else if (*v3 == 2)
      {
        v4 = "QMIDMSCommandDriver.2";
      }
      else
      {
        v4 = "QMIDMSCommandDriver.?";
      }
      v5 = (std::__shared_weak_count *)v2[2];
      if (!v5 || (v6 = v2[1], (v7 = std::__shared_weak_count::lock(v5)) == 0))
        std::__throw_bad_weak_ptr[abi:ne180100]();
      v8 = v7;
      p_shared_weak_owners = (unint64_t *)&v7->__shared_weak_owners_;
      do
        v10 = __ldxr(p_shared_weak_owners);
      while (__stxr(v10 + 1, p_shared_weak_owners));
      p_shared_owners = (unint64_t *)&v7->__shared_owners_;
      do
        v12 = __ldaxr(p_shared_owners);
      while (__stlxr(v12 - 1, p_shared_owners));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v8);
      }
      Registry::getServerConnection(*v32);
      v49 = 0u;
      v50 = 0u;
      std::string::basic_string[abi:ne180100]<0>(&v46, v4);
      v13 = v2[3];
      object = v13;
      if (v13)
        dispatch_retain(v13);
      std::string::basic_string[abi:ne180100]<0>(__p, "dms");
      v40 = 0;
      v41 = 0;
      v14 = std::__shared_weak_count::lock(v8);
      if (v14)
      {
        v15 = v14;
        v16 = (unint64_t *)&v14->__shared_weak_owners_;
        do
          v17 = __ldxr(v16);
        while (__stxr(v17 + 1, v16));
        v40 = v6;
        v41 = v14;
        std::__shared_weak_count::__release_weak(v8);
        v18 = (unint64_t *)&v15->__shared_owners_;
        do
          v19 = __ldaxr(v18);
        while (__stlxr(v19 - 1, v18));
        if (v19)
          goto LABEL_30;
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        v8 = v15;
      }
      else
      {
        v40 = 0;
        v41 = 0;
      }
      std::__shared_weak_count::__release_weak(v8);
LABEL_30:
      v39 = v38;
      v38 = 0uLL;
      qmi::Client::createWithQueueLocal();
      if (*((_QWORD *)&v39 + 1))
      {
        v20 = (unint64_t *)(*((_QWORD *)&v39 + 1) + 8);
        do
          v21 = __ldaxr(v20);
        while (__stlxr(v21 - 1, v20));
        if (!v21)
        {
          (*(void (**)(_QWORD))(**((_QWORD **)&v39 + 1) + 16))(*((_QWORD *)&v39 + 1));
          std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v39 + 1));
        }
      }
      if (v41)
        std::__shared_weak_count::__release_weak(v41);
      if (v44 < 0)
        operator delete(__p[0]);
      if (object)
        dispatch_release(object);
      if (SBYTE7(v48) < 0)
        operator delete(v46);
      v46 = 0;
      v47 = 0;
      v48 = v50;
      v50 = 0uLL;
      qmi::ClientRouter::addClient();
      qmi::Client::~Client((qmi::Client *)&v46);
      qmi::ClientRouter::get();
      qmi::Client::~Client((qmi::Client *)&v49);
      if (*((_QWORD *)&v38 + 1))
      {
        v22 = (unint64_t *)(*((_QWORD *)&v38 + 1) + 8);
        do
          v23 = __ldaxr(v22);
        while (__stlxr(v23 - 1, v22));
        if (!v23)
        {
          (*(void (**)(_QWORD))(**((_QWORD **)&v38 + 1) + 16))(*((_QWORD *)&v38 + 1));
          std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v38 + 1));
        }
      }
      v24 = v3 + 1;
      v3 = v36;
      if (v24 != v36)
      {
        v3 = v24;
        while ((v37(*v3) & 1) == 0)
        {
          if (++v3 == v36)
          {
            v3 = v36;
            break;
          }
        }
      }
    }
  }
  v46 = &off_24D5E6258;
  v47 = v2;
  *((_QWORD *)&v48 + 1) = &v46;
  qmi::ClientRouter::setHandler();
  v25 = (void **)*((_QWORD *)&v48 + 1);
  if (*((void ***)&v48 + 1) == &v46)
  {
    v26 = 4;
    v25 = &v46;
  }
  else
  {
    if (!*((_QWORD *)&v48 + 1))
      goto LABEL_59;
    v26 = 5;
  }
  (*((void (**)(void))*v25 + v26))();
LABEL_59:
  __p[0] = &off_24D5E62D8;
  __p[1] = v2;
  v45 = __p;
  qmi::ClientRouter::setHandler();
  v27 = v45;
  if (v45 == __p)
  {
    v28 = 4;
    v27 = __p;
  }
  else
  {
    if (!v45)
      goto LABEL_64;
    v28 = 5;
  }
  (*((void (**)(void))*v27 + v28))();
LABEL_64:
  *(_QWORD *)&v49 = &off_24D5E6358;
  *((_QWORD *)&v49 + 1) = v2;
  *((_QWORD *)&v50 + 1) = &v49;
  qmi::ClientRouter::setIndHandlerInternal();
  v29 = (__int128 *)*((_QWORD *)&v50 + 1);
  if (*((__int128 **)&v50 + 1) == &v49)
  {
    v30 = 4;
    v29 = &v49;
    goto LABEL_68;
  }
  if (*((_QWORD *)&v50 + 1))
  {
    v30 = 5;
LABEL_68:
    (*(void (**)(void))(*(_QWORD *)v29 + 8 * v30))();
  }
  qmi::ClientRouter::setIndShouldWake((qmi::ClientRouter *)(v2 + 32));
  std::unique_ptr<Mav20PreferredNetworksFactoryCommandDriver::create(std::shared_ptr<Registry const>,dispatch::queue)::$_0,std::default_delete<Mav20PreferredNetworksFactoryCommandDriver::create(std::shared_ptr<Registry const>,dispatch::queue)::$_0>>::~unique_ptr[abi:ne180100]((uint64_t *)&v34);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v33);
}

void sub_216A59E94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,std::__shared_weak_count *a23,dispatch_object_t object,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,void *__p,uint64_t a33,int a34,__int16 a35,char a36,char a37,uint64_t a38)
{
  _QWORD *v38;
  uint64_t v39;
  _QWORD *v41;
  uint64_t v42;

  v41 = *(_QWORD **)(v39 - 120);
  if (v41 == v38)
  {
    v42 = 4;
    v41 = (_QWORD *)(v39 - 144);
  }
  else
  {
    if (!v41)
      goto LABEL_6;
    v42 = 5;
  }
  (*(void (**)(void))(*v41 + 8 * v42))();
LABEL_6:
  std::unique_ptr<Mav20PreferredNetworksFactoryCommandDriver::create(std::shared_ptr<Registry const>,dispatch::queue)::$_0,std::default_delete<Mav20PreferredNetworksFactoryCommandDriver::create(std::shared_ptr<Registry const>,dispatch::queue)::$_0>>::~unique_ptr[abi:ne180100](&a13);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&a12);
  _Unwind_Resume(a1);
}

capabilities::ct *SimInstanceLogger<QMIDMSCommandDriver,ctu::OsLogLogger,subscriber::SimSlot,std::function<char const* const ()(subscriber::SimSlot)>>::SimInstanceLogger(capabilities::ct *a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  _BYTE v12[24];
  _BYTE *v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)a1 = 0;
  if ((capabilities::ct::supportsGemini(a1) & 1) == 0)
  {
    v5 = (_QWORD *)operator new();
    v6 = *(_QWORD *)a1;
    *(_QWORD *)a1 = v5;
    *v5 = &off_24D5E6218;
    v5[1] = (char *)a1 - 248;
    if (!v6)
      return a1;
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
  }
  if (*(_QWORD *)a1)
    return a1;
  v7 = (_QWORD *)operator new();
  std::__function::__value_func<char const* const ()(subscriber::SimSlot)>::__value_func[abi:ne180100]((uint64_t)v12, a3);
  SimInstanceLoggerDefault<ctu::OsLogLogger,subscriber::SimSlot,std::function<char const* const ()(subscriber::SimSlot)>>::SimInstanceLoggerDefault(v7);
  v8 = v13;
  if (v13 == v12)
  {
    v9 = 4;
    v8 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_10;
    v9 = 5;
  }
  (*(void (**)(void))(*v8 + 8 * v9))();
LABEL_10:
  v10 = *(_QWORD *)a1;
  *(_QWORD *)a1 = v7;
  if (v10)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 8))(v10);
  return a1;
}

void sub_216A5A134(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  uint64_t *v13;
  uint64_t v14;
  char *v15;
  char *v17;
  uint64_t v18;
  uint64_t v19;

  v17 = a13;
  if (a13 == v15)
  {
    v18 = 4;
    v17 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v18 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v17 + 8 * v18))();
LABEL_6:
  MEMORY[0x2199FEAC4](v14, 0x10A1C40FF1576FELL);
  v19 = *v13;
  *v13 = 0;
  if (v19)
    (*(void (**)(uint64_t))(*(_QWORD *)v19 + 8))(v19);
  _Unwind_Resume(a1);
}

void SimInstanceLoggable<QMIDMSCommandDriver,ctu::OsLogLogger,subscriber::SimSlot>::~SimInstanceLoggable()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t SimInstanceLoggable<QMIDMSCommandDriver,ctu::OsLogLogger,subscriber::SimSlot>::getLoggerForSlot(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8) + 40;
}

void std::__function::__func<QMIDMSCommandDriver::init_sync(void)::$_0,std::allocator<QMIDMSCommandDriver::init_sync(void)::$_0>,void ()(qmi::SubscriptionType)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<QMIDMSCommandDriver::init_sync(void)::$_0,std::allocator<QMIDMSCommandDriver::init_sync(void)::$_0>,void ()(qmi::SubscriptionType)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5E6258;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<QMIDMSCommandDriver::init_sync(void)::$_0,std::allocator<QMIDMSCommandDriver::init_sync(void)::$_0>,void ()(qmi::SubscriptionType)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5E6258;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<QMIDMSCommandDriver::init_sync(void)::$_0,std::allocator<QMIDMSCommandDriver::init_sync(void)::$_0>,void ()(qmi::SubscriptionType)>::operator()(uint64_t a1, unsigned int *a2)
{
  return (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 8) + 56))(*(_QWORD *)(a1 + 8), *a2);
}

uint64_t std::__function::__func<QMIDMSCommandDriver::init_sync(void)::$_0,std::allocator<QMIDMSCommandDriver::init_sync(void)::$_0>,void ()(qmi::SubscriptionType)>::target(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else
    return 0;
}

void *std::__function::__func<QMIDMSCommandDriver::init_sync(void)::$_0,std::allocator<QMIDMSCommandDriver::init_sync(void)::$_0>,void ()(qmi::SubscriptionType)>::target_type()
{
}

void std::__function::__func<QMIDMSCommandDriver::init_sync(void)::$_1,std::allocator<QMIDMSCommandDriver::init_sync(void)::$_1>,void ()(qmi::SubscriptionType)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<QMIDMSCommandDriver::init_sync(void)::$_1,std::allocator<QMIDMSCommandDriver::init_sync(void)::$_1>,void ()(qmi::SubscriptionType)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5E62D8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<QMIDMSCommandDriver::init_sync(void)::$_1,std::allocator<QMIDMSCommandDriver::init_sync(void)::$_1>,void ()(qmi::SubscriptionType)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5E62D8;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<QMIDMSCommandDriver::init_sync(void)::$_1,std::allocator<QMIDMSCommandDriver::init_sync(void)::$_1>,void ()(qmi::SubscriptionType)>::operator()(uint64_t a1, unsigned int *a2)
{
  return (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 8) + 64))(*(_QWORD *)(a1 + 8), *a2);
}

uint64_t std::__function::__func<QMIDMSCommandDriver::init_sync(void)::$_1,std::allocator<QMIDMSCommandDriver::init_sync(void)::$_1>,void ()(qmi::SubscriptionType)>::target(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else
    return 0;
}

void *std::__function::__func<QMIDMSCommandDriver::init_sync(void)::$_1,std::allocator<QMIDMSCommandDriver::init_sync(void)::$_1>,void ()(qmi::SubscriptionType)>::target_type()
{
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMIDMSCommandDriver::init_sync(void)::$_3>(unsigned short,QMIDMSCommandDriver::init_sync(void)::$_3 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMIDMSCommandDriver::init_sync(void)::$_3 &&,QMIServiceMsg const)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMIDMSCommandDriver::init_sync(void)::$_3>(unsigned short,QMIDMSCommandDriver::init_sync(void)::$_3 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMIDMSCommandDriver::init_sync(void)::$_3 &&,QMIServiceMsg const)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5E6358;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMIDMSCommandDriver::init_sync(void)::$_3>(unsigned short,QMIDMSCommandDriver::init_sync(void)::$_3 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMIDMSCommandDriver::init_sync(void)::$_3 &&,QMIServiceMsg const)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5E6358;
  a2[1] = v2;
  return result;
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMIDMSCommandDriver::init_sync(void)::$_3>(unsigned short,QMIDMSCommandDriver::init_sync(void)::$_3 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMIDMSCommandDriver::init_sync(void)::$_3 &&,QMIServiceMsg const)>::operator()(uint64_t a1, unsigned int *a2, QMIServiceMsg *this)
{
  unsigned int v4;
  uint64_t v6;
  uint64_t v7;
  os_log_t *v8;
  int v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t TlvValue;
  int v13;
  uint64_t v14;
  int v15;
  _WORD v16[2];
  int v17;
  char v18;
  uint64_t v19;
  void *__p;
  __int128 v21;
  void *v22;
  uint64_t v23;
  os_log_t *v24;
  unsigned int v25;
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  v4 = *a2;
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v21 = 0uLL;
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v16, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v16);
    if (__p)
    {
      *(_QWORD *)&v21 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v16);
  }
  v6 = *(_QWORD *)(a1 + 8);
  if (v4 - 1 >= 3)
    v7 = 0;
  else
    v7 = v4;
  v8 = (os_log_t *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v6 + 248) + 16))(*(_QWORD *)(v6 + 248), v7);
  v9 = v17;
  if (v17)
  {
    v10 = *v8;
    if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
    {
      v11 = qmi::asString();
      LODWORD(__p) = 67109378;
      HIDWORD(__p) = v9;
      LOWORD(v21) = 2080;
      *(_QWORD *)((char *)&v21 + 2) = v11;
      _os_log_impl(&dword_216897000, v10, OS_LOG_TYPE_DEFAULT, "#N handleSetEventReportInd returned error=0x%04x (%s)", (uint8_t *)&__p, 0x12u);
    }
  }
  else
  {
    __p = (void *)MEMORY[0x24BDAC760];
    *(_QWORD *)&v21 = 0x40000000;
    *((_QWORD *)&v21 + 1) = ___ZZN19QMIDMSCommandDriver9init_syncEvENK3__3clEN3qmi16SubscriptionTypeERKN3dms11EventReport10IndicationE_block_invoke;
    v22 = &__block_descriptor_tmp_13_18;
    v23 = v6;
    v24 = v8;
    v25 = v4;
    TlvValue = qmi::MessageBase::findTlvValue((qmi::MessageBase *)v16);
    v14 = TlvValue;
    if (TlvValue)
    {
      v15 = v13;
      v19 = TlvValue;
      v18 = tlv::parseV<dms::tlv::PRLInitNotification>((unint64_t *)&v19, v13);
      if (v19)
        ___ZZN19QMIDMSCommandDriver9init_syncEvENK3__3clEN3qmi16SubscriptionTypeERKN3dms11EventReport10IndicationE_block_invoke((uint64_t)&__p, &v18);
      else
        ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(v16[0], 23, v14, v15);
    }
  }
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v16);
}

void sub_216A5A5C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a10);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMIDMSCommandDriver::init_sync(void)::$_3>(unsigned short,QMIDMSCommandDriver::init_sync(void)::$_3 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMIDMSCommandDriver::init_sync(void)::$_3 &&,QMIServiceMsg const)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMIDMSCommandDriver::init_sync(void)::$_3>(unsigned short,QMIDMSCommandDriver::init_sync(void)::$_3 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(QMIDMSCommandDriver::init_sync(void)::$_3 &&,QMIServiceMsg const)>::target_type()
{
}

uint64_t ___ZZN19QMIDMSCommandDriver9init_syncEvENK3__3clEN3qmi16SubscriptionTypeERKN3dms11EventReport10IndicationE_block_invoke(uint64_t result, _BYTE *a2)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  unsigned int v5;
  uint64_t v6;
  uint8_t v7[16];

  if (*a2 == 1)
  {
    v2 = result;
    v3 = *(_QWORD *)(result + 32);
    v4 = **(NSObject ***)(result + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v7 = 0;
      _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I PRL available", v7, 2u);
    }
    v5 = *(_DWORD *)(v2 + 48);
    if (v5 - 1 >= 3)
      v6 = 0;
    else
      v6 = v5;
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v3 + 40))(v3, v6, 128);
  }
  return result;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN19QMIDMSCommandDriver21bindSubscription_syncENS_16SubscriptionTypeEE3__0EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;
  os_log_t *v7;
  NSObject *v8;
  uint64_t v9;
  int v10;
  int v11;
  uint64_t v12;
  __int16 v13;
  int v14;
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 + 32);
  v4 = *(_QWORD *)v3;
  v5 = *(_DWORD *)(v3 + 8);
  if (v5 - 1 >= 3)
    v6 = 0;
  else
    v6 = v5;
  v7 = (os_log_t *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v4 + 248) + 16))(*(_QWORD *)(v4 + 248), v6);
  if (*(_DWORD *)(a2 + 4))
  {
    v8 = *v7;
    if (os_log_type_enabled(*v7, OS_LOG_TYPE_ERROR))
    {
      v9 = qmi::asString();
      v10 = *(_DWORD *)(a2 + 4);
      v11 = 136315394;
      v12 = v9;
      v13 = 1024;
      v14 = v10;
      _os_log_error_impl(&dword_216897000, v8, OS_LOG_TYPE_ERROR, "Error binding subscription: %s (0x%x)", (uint8_t *)&v11, 0x12u);
    }
  }
  else
  {
    QMIDMSCommandDriver::setupRequestsAndIndications_sync(v4, *(_DWORD *)(v3 + 8));
  }
}

uint64_t __copy_helper_block_e8_32c102_ZTSNSt3__110shared_ptrIZN19QMIDMSCommandDriver21bindSubscription_syncEN3qmi16SubscriptionTypeEE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c102_ZTSNSt3__110shared_ptrIZN19QMIDMSCommandDriver21bindSubscription_syncEN3qmi16SubscriptionTypeEE3__0EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMIDMSCommandDriver::bindSubscription_sync(qmi::SubscriptionType)::$_0,std::allocator<QMIDMSCommandDriver::bindSubscription_sync(qmi::SubscriptionType)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E6428;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMIDMSCommandDriver::bindSubscription_sync(qmi::SubscriptionType)::$_0,std::allocator<QMIDMSCommandDriver::bindSubscription_sync(qmi::SubscriptionType)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E6428;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3dms16BindSubscription8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke_0(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BYTE v3[24];

  v2 = *(_QWORD *)(a1 + 32);
  cast_message_type<dms::BindSubscription::Response const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_216A5A8C8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<dms::tlv::ReportPRLInitialized>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<dms::tlv::ReportPRLInitialized>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<dms::tlv::ReportPRLInitialized>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<dms::tlv::ReportPRLInitialized>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E64B8;
  return result;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN19QMIDMSCommandDriver32setupRequestsAndIndications_syncENS_16SubscriptionTypeEE3__0EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t *v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;
  NSObject *v7;
  int v8;
  _DWORD v9[2];
  __int16 v10;
  uint64_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)(a2 + 4))
  {
    v3 = *(uint64_t **)(a1 + 32);
    v4 = *v3;
    v5 = *((_DWORD *)v3 + 2);
    if (v5 - 1 >= 3)
      v6 = 0;
    else
      v6 = v5;
    v7 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v4 + 248) + 16))(*(_QWORD *)(v4 + 248), v6);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      v8 = *(_DWORD *)(a2 + 4);
      v9[0] = 67109378;
      v9[1] = v8;
      v10 = 2080;
      v11 = qmi::asString();
      _os_log_impl(&dword_216897000, v7, OS_LOG_TYPE_DEFAULT, "#N Failed to register for PRL Init report with error=0x%04x (%s)", (uint8_t *)v9, 0x12u);
    }
  }
}

uint64_t __copy_helper_block_e8_32c113_ZTSNSt3__110shared_ptrIZN19QMIDMSCommandDriver32setupRequestsAndIndications_syncEN3qmi16SubscriptionTypeEE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c113_ZTSNSt3__110shared_ptrIZN19QMIDMSCommandDriver32setupRequestsAndIndications_syncEN3qmi16SubscriptionTypeEE3__0EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMIDMSCommandDriver::setupRequestsAndIndications_sync(qmi::SubscriptionType)::$_0,std::allocator<QMIDMSCommandDriver::setupRequestsAndIndications_sync(qmi::SubscriptionType)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E6520;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMIDMSCommandDriver::setupRequestsAndIndications_sync(qmi::SubscriptionType)::$_0,std::allocator<QMIDMSCommandDriver::setupRequestsAndIndications_sync(qmi::SubscriptionType)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E6520;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN19QMIDMSCommandDriver18querySerialNumbersEN10subscriber7SimSlotEN16DMSCommandDriver11InformationEE3__0EEOS1_OT__block_invoke(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t *v3;
  uint64_t v4;
  NSObject *v5;
  int v6;
  uint64_t TlvValue;
  int v8;
  uint64_t v9;
  int v10;
  std::string::size_type v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  std::string::size_type v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  std::string::size_type v21;
  std::string::value_type *v22;
  int v23;
  std::string::value_type *v24;
  int v25;
  std::string::value_type *v26;
  std::string __p;
  void *v28;
  uint64_t v29;
  int v30;
  xpc_object_t object;
  _QWORD v32[2];
  void (*v33)(uint64_t, uint64_t);
  void *v34;
  uint64_t v35;
  _QWORD v36[2];
  void (*v37)(uint64_t, uint64_t);
  void *v38;
  uint64_t v39;
  std::string v40;
  std::string::value_type *v41;
  std::string buf;
  void *v43;
  uint64_t v44;
  int v45;
  uint64_t v46;

  v46 = *MEMORY[0x24BDAC8D0];
  v3 = *(uint64_t **)(a1 + 32);
  v4 = *v3;
  if (*((_DWORD *)a2 + 1))
  {
    v5 = *(NSObject **)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(v4 + 248) + 16))(*(_QWORD *)(v4 + 248), *((unsigned int *)v3 + 2));
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *((_DWORD *)a2 + 1);
      LODWORD(buf.__r_.__value_.__l.__data_) = 67109378;
      HIDWORD(buf.__r_.__value_.__r.__words[0]) = v6;
      LOWORD(buf.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 2) = qmi::asString();
      _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#N GetDeviceSerialNumbers returned error=0x%04x (%s)", (uint8_t *)&buf, 0x12u);
    }
  }
  else
  {
    if (subscriber::isSet())
    {
      v36[0] = MEMORY[0x24BDAC760];
      v36[1] = 0x40000000;
      v37 = ___ZZN19QMIDMSCommandDriver18querySerialNumbersEN10subscriber7SimSlotEN16DMSCommandDriver11InformationEENK3__0clERKN3dms22GetDeviceSerialNumbers8ResponseE_block_invoke;
      v38 = &__block_descriptor_tmp_23_12;
      v39 = v4;
      TlvValue = qmi::MessageBase::findTlvValue(a2);
      if (TlvValue)
      {
        v9 = TlvValue;
        v10 = v8;
        __p.__r_.__value_.__r.__words[0] = TlvValue;
        memset(&buf, 0, sizeof(buf));
        tlv::parseV<dms::tlv::ESN>(&__p.__r_.__value_.__l.__data_, v8, &buf);
        v11 = __p.__r_.__value_.__r.__words[0];
        if (__p.__r_.__value_.__r.__words[0])
          v37((uint64_t)v36, (uint64_t)&buf);
        if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
          operator delete(buf.__r_.__value_.__l.__data_);
        if (!v11)
          ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 16, v9, v10);
      }
    }
    if (subscriber::isSet())
    {
      v32[0] = MEMORY[0x24BDAC760];
      v32[1] = 0x40000000;
      v33 = ___ZZN19QMIDMSCommandDriver18querySerialNumbersEN10subscriber7SimSlotEN16DMSCommandDriver11InformationEENK3__0clERKN3dms22GetDeviceSerialNumbers8ResponseE_block_invoke_2;
      v34 = &__block_descriptor_tmp_25_11;
      v35 = v4;
      v12 = qmi::MessageBase::findTlvValue(a2);
      v14 = v12;
      if (!v12)
        goto LABEL_20;
      v15 = v13;
      __p.__r_.__value_.__r.__words[0] = v12;
      memset(&buf, 0, sizeof(buf));
      tlv::parseV<dms::tlv::MEID>(&__p.__r_.__value_.__l.__data_, v13, &buf);
      v16 = __p.__r_.__value_.__r.__words[0];
      if (__p.__r_.__value_.__r.__words[0])
        v33((uint64_t)v32, (uint64_t)&buf);
      if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
        operator delete(buf.__r_.__value_.__l.__data_);
      if (!v16
        && (((uint64_t (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 18, v14, v15) & 1) == 0)
      {
LABEL_20:
        object = xpc_string_create((const char *)&unk_216AC4FCA);
        if (!object)
          object = xpc_null_create();
        DMSCommandDriver::setMeid();
        xpc_release(object);
        object = 0;
      }
    }
    if (subscriber::isSet())
    {
      buf.__r_.__value_.__r.__words[0] = MEMORY[0x24BDAC760];
      buf.__r_.__value_.__l.__size_ = 0x40000000;
      buf.__r_.__value_.__r.__words[2] = (std::string::size_type)___ZZN19QMIDMSCommandDriver18querySerialNumbersEN10subscriber7SimSlotEN16DMSCommandDriver11InformationEENK3__0clERKN3dms22GetDeviceSerialNumbers8ResponseE_block_invoke_3;
      v43 = &__block_descriptor_tmp_26_10;
      v44 = v4;
      v45 = *((_DWORD *)v3 + 2);
      v17 = qmi::MessageBase::findTlvValue(a2);
      v19 = v17;
      if (v17)
      {
        v20 = v18;
        v40.__r_.__value_.__r.__words[0] = v17;
        memset(&__p, 0, sizeof(__p));
        tlv::parseV<dms::tlv::IMEI>(&v40.__r_.__value_.__l.__data_, v18, &__p);
        v21 = v40.__r_.__value_.__r.__words[0];
        if (v40.__r_.__value_.__r.__words[0])
          ___ZZN19QMIDMSCommandDriver18querySerialNumbersEN10subscriber7SimSlotEN16DMSCommandDriver11InformationEENK3__0clERKN3dms22GetDeviceSerialNumbers8ResponseE_block_invoke_3((uint64_t)&buf, (uint64_t)&__p);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
        if (!v21)
          ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 17, v19, v20);
      }
    }
    if (subscriber::isSet())
    {
      __p.__r_.__value_.__r.__words[0] = MEMORY[0x24BDAC760];
      __p.__r_.__value_.__l.__size_ = 0x40000000;
      __p.__r_.__value_.__r.__words[2] = (std::string::size_type)___ZZN19QMIDMSCommandDriver18querySerialNumbersEN10subscriber7SimSlotEN16DMSCommandDriver11InformationEENK3__0clERKN3dms22GetDeviceSerialNumbers8ResponseE_block_invoke_4;
      v28 = &__block_descriptor_tmp_27_12;
      v29 = v4;
      v30 = *((_DWORD *)v3 + 2);
      v22 = (std::string::value_type *)qmi::MessageBase::findTlvValue(a2);
      v24 = v22;
      if (v22)
      {
        v25 = v23;
        v41 = v22;
        memset(&v40, 0, sizeof(v40));
        tlv::parseV<dms::tlv::IMEISVN>(&v41, v23, &v40);
        v26 = v41;
        if (v41)
          ___ZZN19QMIDMSCommandDriver18querySerialNumbersEN10subscriber7SimSlotEN16DMSCommandDriver11InformationEENK3__0clERKN3dms22GetDeviceSerialNumbers8ResponseE_block_invoke_4((uint64_t)&__p, (uint64_t)&v40);
        if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v40.__r_.__value_.__l.__data_);
        if (!v26)
          ((void (*)(_QWORD, uint64_t, std::string::value_type *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 19, v24, v25);
      }
    }
  }
}

void sub_216A5AF28(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, xpc_object_t object, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

uint64_t __copy_helper_block_e8_32c130_ZTSNSt3__110shared_ptrIZN19QMIDMSCommandDriver18querySerialNumbersEN10subscriber7SimSlotEN16DMSCommandDriver11InformationEE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c130_ZTSNSt3__110shared_ptrIZN19QMIDMSCommandDriver18querySerialNumbersEN10subscriber7SimSlotEN16DMSCommandDriver11InformationEE3__0EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMIDMSCommandDriver::querySerialNumbers(subscriber::SimSlot,DMSCommandDriver::Information)::$_0,std::allocator<QMIDMSCommandDriver::querySerialNumbers(subscriber::SimSlot,DMSCommandDriver::Information)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E65C8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMIDMSCommandDriver::querySerialNumbers(subscriber::SimSlot,DMSCommandDriver::Information)::$_0,std::allocator<QMIDMSCommandDriver::querySerialNumbers(subscriber::SimSlot,DMSCommandDriver::Information)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E65C8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3dms22GetDeviceSerialNumbers8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A5B0D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ___ZZN19QMIDMSCommandDriver18querySerialNumbersEN10subscriber7SimSlotEN16DMSCommandDriver11InformationEENK3__0clERKN3dms22GetDeviceSerialNumbers8ResponseE_block_invoke(uint64_t a1, uint64_t a2)
{
  const char *v2;
  xpc_object_t object;
  xpc_object_t v4;
  void *__p;
  char v6;

  if (*(char *)(a2 + 23) >= 0)
    v2 = (const char *)a2;
  else
    v2 = *(const char **)a2;
  object = xpc_string_create(v2);
  if (!object)
    object = xpc_null_create();
  subscriber::setFlagIf();
  std::string::basic_string[abi:ne180100]<0>(&__p, "/cc/device_info/esn");
  v4 = object;
  if (object)
    xpc_retain(object);
  else
    v4 = xpc_null_create();
  ctu::RestModule::setProperty();
  xpc_release(v4);
  if (v6 < 0)
    operator delete(__p);
  xpc_release(object);
}

void sub_216A5B1D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t a10, xpc_object_t object, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  xpc_release(object);
  if (a17 < 0)
    operator delete(__p);
  xpc_release(a10);
  _Unwind_Resume(a1);
}

void ___ZZN19QMIDMSCommandDriver18querySerialNumbersEN10subscriber7SimSlotEN16DMSCommandDriver11InformationEENK3__0clERKN3dms22GetDeviceSerialNumbers8ResponseE_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  const char *v3;
  uint64_t v4;
  xpc_object_t v5;
  xpc_object_t object;

  v2 = *(unsigned __int8 *)(a2 + 23);
  if ((v2 & 0x80u) == 0)
    v3 = (const char *)a2;
  else
    v3 = *(const char **)a2;
  if ((v2 & 0x80u) != 0)
    v2 = *(_QWORD *)(a2 + 8);
  if (!v2)
    goto LABEL_15;
  v4 = 0;
  while (v3[v4] == 48)
  {
    if (v2 == ++v4)
      goto LABEL_15;
  }
  if (v4 == -1)
  {
LABEL_15:
    v5 = xpc_string_create((const char *)&unk_216AC4FCA);
    if (!v5)
      v5 = xpc_null_create();
    DMSCommandDriver::setMeid();
    xpc_release(v5);
  }
  else
  {
    object = xpc_string_create(v3);
    if (!object)
      object = xpc_null_create();
    DMSCommandDriver::setMeid();
    xpc_release(object);
  }
}

void sub_216A5B2EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t a9, xpc_object_t object)
{
  xpc_release(object);
  _Unwind_Resume(a1);
}

void ___ZZN19QMIDMSCommandDriver18querySerialNumbersEN10subscriber7SimSlotEN16DMSCommandDriver11InformationEENK3__0clERKN3dms22GetDeviceSerialNumbers8ResponseE_block_invoke_3(uint64_t a1, uint64_t a2)
{
  std::string __p;

  if (*(char *)(a2 + 23) < 0)
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
  else
    __p = *(std::string *)a2;
  DMSCommandDriver::setImei();
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
}

void sub_216A5B39C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void ___ZZN19QMIDMSCommandDriver18querySerialNumbersEN10subscriber7SimSlotEN16DMSCommandDriver11InformationEENK3__0clERKN3dms22GetDeviceSerialNumbers8ResponseE_block_invoke_4(uint64_t a1, uint64_t a2)
{
  std::string __p;

  if (*(char *)(a2 + 23) < 0)
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
  else
    __p = *(std::string *)a2;
  DMSCommandDriver::setImeiSvn();
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
}

void sub_216A5B42C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN19QMIDMSCommandDriver15queryPRLVersionEN10subscriber7SimSlotEE3__0EEOS1_OT__block_invoke(uint64_t a1, qmi::MessageBase *this)
{
  NSObject *v3;
  int v4;
  uint64_t TlvValue;
  int v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  __int16 v10;
  uint64_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  if (*((_DWORD *)this + 1))
  {
    v3 = *(NSObject **)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(**(_QWORD **)(a1 + 32) + 248) + 16))(*(_QWORD *)(**(_QWORD **)(a1 + 32) + 248), *(unsigned int *)(*(_QWORD *)(a1 + 32) + 8));
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      v4 = *((_DWORD *)this + 1);
      LODWORD(v9) = 67109378;
      HIDWORD(v9) = v4;
      v10 = 2080;
      v11 = qmi::asString();
      _os_log_impl(&dword_216897000, v3, OS_LOG_TYPE_DEFAULT, "#N GetCurrentPRLInfo returned error=0x%04x (%s)", (uint8_t *)&v9, 0x12u);
    }
  }
  else
  {
    TlvValue = qmi::MessageBase::findTlvValue(this);
    if (TlvValue)
    {
      v7 = TlvValue;
      v8 = v6;
      v9 = TlvValue;
      tlv::parseV<dms::tlv::PRLVersion>((unint64_t *)&v9, v6);
      if (v9)
        DMSCommandDriver::setPrlVersion();
      else
        ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)this, 16, v7, v8);
    }
  }
}

uint64_t __copy_helper_block_e8_32c94_ZTSNSt3__110shared_ptrIZN19QMIDMSCommandDriver15queryPRLVersionEN10subscriber7SimSlotEE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c94_ZTSNSt3__110shared_ptrIZN19QMIDMSCommandDriver15queryPRLVersionEN10subscriber7SimSlotEE3__0EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMIDMSCommandDriver::queryPRLVersion(subscriber::SimSlot)::$_0,std::allocator<QMIDMSCommandDriver::queryPRLVersion(subscriber::SimSlot)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E66F0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMIDMSCommandDriver::queryPRLVersion(subscriber::SimSlot)::$_0,std::allocator<QMIDMSCommandDriver::queryPRLVersion(subscriber::SimSlot)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E66F0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3dms17GetCurrentPRLInfo8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A5B6C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN19QMIDMSCommandDriver11queryMSISDNEN10subscriber7SimSlotEN16DMSCommandDriver11InformationEE3__0EEOS1_OT__block_invoke(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t *v3;
  uint64_t v4;
  NSObject *v5;
  int v6;
  std::string::value_type *TlvValue;
  int v8;
  std::string::value_type *v9;
  int v10;
  std::string::value_type *v11;
  std::string __p;
  std::string::value_type *v13;
  uint8_t buf[8];
  __int128 v15;
  void *v16;
  uint64_t v17;
  int v18;
  uint64_t v19;

  v19 = *MEMORY[0x24BDAC8D0];
  v3 = *(uint64_t **)(a1 + 32);
  v4 = *v3;
  if (*((_DWORD *)a2 + 1))
  {
    v5 = *(NSObject **)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(v4 + 248) + 16))(*(_QWORD *)(v4 + 248), *((unsigned int *)v3 + 2));
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *((_DWORD *)a2 + 1);
      *(_DWORD *)buf = 67109378;
      *(_DWORD *)&buf[4] = v6;
      LOWORD(v15) = 2080;
      *(_QWORD *)((char *)&v15 + 2) = qmi::asString();
      _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#N GetMSISDN returned error=0x%04x (%s)", buf, 0x12u);
    }
  }
  else if (subscriber::isSet())
  {
    *(_QWORD *)buf = MEMORY[0x24BDAC760];
    *(_QWORD *)&v15 = 0x40000000;
    *((_QWORD *)&v15 + 1) = ___ZZN19QMIDMSCommandDriver11queryMSISDNEN10subscriber7SimSlotEN16DMSCommandDriver11InformationEENK3__0clERKN3dms9GetMSISDN8ResponseE_block_invoke;
    v16 = &__block_descriptor_tmp_34_12;
    v17 = v4;
    v18 = *((_DWORD *)v3 + 2);
    TlvValue = (std::string::value_type *)qmi::MessageBase::findTlvValue(a2);
    if (!TlvValue)
      goto LABEL_12;
    v9 = TlvValue;
    v10 = v8;
    v13 = TlvValue;
    memset(&__p, 0, sizeof(__p));
    tlv::parseV<dms::tlv::TLVMIN>(&v13, v8, &__p);
    v11 = v13;
    if (v13)
      ___ZZN19QMIDMSCommandDriver11queryMSISDNEN10subscriber7SimSlotEN16DMSCommandDriver11InformationEENK3__0clERKN3dms9GetMSISDN8ResponseE_block_invoke((uint64_t)buf, (uint64_t)&__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    if (!v11
      && (((uint64_t (*)(_QWORD, uint64_t, std::string::value_type *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 16, v9, v10) & 1) == 0)
    {
LABEL_12:
      memset(&__p, 0, sizeof(__p));
      DMSCommandDriver::setMin();
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
}

void sub_216A5B8D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t __copy_helper_block_e8_32c123_ZTSNSt3__110shared_ptrIZN19QMIDMSCommandDriver11queryMSISDNEN10subscriber7SimSlotEN16DMSCommandDriver11InformationEE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c123_ZTSNSt3__110shared_ptrIZN19QMIDMSCommandDriver11queryMSISDNEN10subscriber7SimSlotEN16DMSCommandDriver11InformationEE3__0EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMIDMSCommandDriver::queryMSISDN(subscriber::SimSlot,DMSCommandDriver::Information)::$_0,std::allocator<QMIDMSCommandDriver::queryMSISDN(subscriber::SimSlot,DMSCommandDriver::Information)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E6798;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMIDMSCommandDriver::queryMSISDN(subscriber::SimSlot,DMSCommandDriver::Information)::$_0,std::allocator<QMIDMSCommandDriver::queryMSISDN(subscriber::SimSlot,DMSCommandDriver::Information)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E6798;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3dms9GetMSISDN8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A5BA2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ___ZZN19QMIDMSCommandDriver11queryMSISDNEN10subscriber7SimSlotEN16DMSCommandDriver11InformationEENK3__0clERKN3dms9GetMSISDN8ResponseE_block_invoke(uint64_t a1, uint64_t a2)
{
  std::string __p;

  if (*(char *)(a2 + 23) < 0)
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
  else
    __p = *(std::string *)a2;
  DMSCommandDriver::setMin();
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
}

void sub_216A5BAE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_WORD *prepareThresholds(_QWORD *a1)
{
  _WORD *result;

  *(_WORD *)qmi::MutableMessageBase::getTLV<nas::tlv::GsmRssiDelta>(a1, 29) = -1;
  *(_WORD *)qmi::MutableMessageBase::getTLV<nas::tlv::WcdmaRssiDelta>(a1, 31) = -1;
  *(_WORD *)qmi::MutableMessageBase::getTLV<nas::tlv::WcdmaEcioDelta>(a1, 33) = -1;
  *(_WORD *)qmi::MutableMessageBase::getTLV<nas::tlv::CdmaRssiDelta>(a1, 17) = -1;
  *(_WORD *)qmi::MutableMessageBase::getTLV<nas::tlv::HdrRssiDelta>(a1, 21) = -1;
  *(_WORD *)qmi::MutableMessageBase::getTLV<nas::tlv::CdmaEcioDelta>(a1, 19) = -1;
  *(_WORD *)qmi::MutableMessageBase::getTLV<nas::tlv::HdrSinrDelta>(a1, 25) = -1;
  *(_WORD *)qmi::MutableMessageBase::getTLV<nas::tlv::LteRssiDelta>(a1, 35) = -1;
  *(_WORD *)qmi::MutableMessageBase::getTLV<nas::tlv::LteRsrqDelta>(a1, 39) = -1;
  *(_WORD *)qmi::MutableMessageBase::getTLV<nas::tlv::LteRsrpDelta>(a1, 41) = -1;
  *(_WORD *)qmi::MutableMessageBase::getTLV<nas::tlv::LteSnrDelta>(a1, 37) = -1;
  *(_WORD *)qmi::MutableMessageBase::getTLV<nas::tlv::TDSCDMAEcioDelta>(a1, 162) = -1;
  *(_WORD *)qmi::MutableMessageBase::getTLV<nas::tlv::TDSCDMARscpDelta>(a1, 161) = -1;
  *(_WORD *)qmi::MutableMessageBase::getTLV<nas::tlv::NrSnrDelta>(a1, 52) = -1;
  *(_WORD *)qmi::MutableMessageBase::getTLV<nas::tlv::NrRsrpDelta>(a1, 54) = -1;
  result = (_WORD *)qmi::MutableMessageBase::getTLV<nas::tlv::NrRsrqDelta>(a1, 57);
  *result = -1;
  return result;
}

uint64_t populateThresholds(uint64_t result, _QWORD *a2)
{
  _QWORD *v2;
  _QWORD *v3;
  int v5;
  double v6;
  int v7;
  _QWORD *v8;
  _QWORD *v9;
  BOOL v10;

  v2 = *(_QWORD **)(result + 8);
  v3 = (_QWORD *)(result + 16);
  if (v2 != (_QWORD *)(result + 16))
  {
    while (1)
    {
      v5 = *((_DWORD *)v2 + 9);
      v6 = fmax(*((double *)v2 + 6), 1.0);
      switch(*((_DWORD *)v2 + 8))
      {
        case 0:
          if (v5 == 4)
          {
            result = qmi::MutableMessageBase::getTLV<nas::tlv::WcdmaEcioDelta>(a2, 33);
            goto LABEL_29;
          }
          if (!v5)
          {
            v7 = (int)(v6 * 10.0 + 0.5);
            *(_WORD *)qmi::MutableMessageBase::getTLV<nas::tlv::GsmRssiDelta>(a2, 29) = v7;
            result = qmi::MutableMessageBase::getTLV<nas::tlv::WcdmaRssiDelta>(a2, 31);
            goto LABEL_10;
          }
          goto LABEL_30;
        case 1:
          switch(v5)
          {
            case 6:
              result = qmi::MutableMessageBase::getTLV<nas::tlv::HdrSinrDelta>(a2, 25);
              goto LABEL_29;
            case 1:
              result = qmi::MutableMessageBase::getTLV<nas::tlv::CdmaEcioDelta>(a2, 19);
              goto LABEL_29;
            case 0:
              v7 = (int)(v6 * 10.0 + 0.5);
              *(_WORD *)qmi::MutableMessageBase::getTLV<nas::tlv::CdmaRssiDelta>(a2, 17) = v7;
              result = qmi::MutableMessageBase::getTLV<nas::tlv::HdrRssiDelta>(a2, 21);
LABEL_10:
              *(_WORD *)result = v7;
              break;
          }
          goto LABEL_30;
        case 2:
          switch(v5)
          {
            case 0:
              result = qmi::MutableMessageBase::getTLV<nas::tlv::LteRssiDelta>(a2, 35);
              goto LABEL_29;
            case 6:
              result = qmi::MutableMessageBase::getTLV<nas::tlv::LteSnrDelta>(a2, 37);
              goto LABEL_29;
            case 7:
              result = qmi::MutableMessageBase::getTLV<nas::tlv::LteRsrpDelta>(a2, 41);
              goto LABEL_29;
            case 8:
              result = qmi::MutableMessageBase::getTLV<nas::tlv::LteRsrqDelta>(a2, 39);
              goto LABEL_29;
            default:
              goto LABEL_30;
          }
          goto LABEL_30;
        case 3:
          if (v5 == 3)
          {
            result = qmi::MutableMessageBase::getTLV<nas::tlv::TDSCDMARscpDelta>(a2, 161);
            goto LABEL_29;
          }
          if (v5 == 1)
          {
            result = qmi::MutableMessageBase::getTLV<nas::tlv::TDSCDMAEcioDelta>(a2, 162);
            goto LABEL_29;
          }
          goto LABEL_30;
        case 4:
          switch(v5)
          {
            case 6:
              result = qmi::MutableMessageBase::getTLV<nas::tlv::NrSnrDelta>(a2, 52);
              goto LABEL_29;
            case 7:
              result = qmi::MutableMessageBase::getTLV<nas::tlv::NrRsrpDelta>(a2, 54);
              goto LABEL_29;
            case 8:
              result = qmi::MutableMessageBase::getTLV<nas::tlv::NrRsrqDelta>(a2, 57);
LABEL_29:
              *(_WORD *)result = (int)(v6 * 10.0 + 0.5);
              break;
          }
LABEL_30:
          v8 = (_QWORD *)v2[1];
          if (v8)
          {
            do
            {
              v9 = v8;
              v8 = (_QWORD *)*v8;
            }
            while (v8);
          }
          else
          {
            do
            {
              v9 = (_QWORD *)v2[2];
              v10 = *v9 == (_QWORD)v2;
              v2 = v9;
            }
            while (!v10);
          }
          v2 = v9;
          if (v9 == v3)
            return result;
          break;
        default:
          goto LABEL_30;
      }
    }
  }
  return result;
}

uint64_t parseInputs@<X0>(qmi::MessageBase *a1@<X0>, _QWORD *a2@<X8>)
{
  _QWORD *v4;
  uint64_t **v5;
  _WORD *TlvValue;
  int v7;
  _WORD *v8;
  int v9;
  char v10;
  _WORD *v11;
  int v12;
  _WORD *v13;
  int v14;
  int v15;
  int v16;
  _WORD *v17;
  int v18;
  _WORD *v19;
  int v20;
  int v21;
  int v22;
  _WORD *v23;
  int v24;
  _WORD *v25;
  int v26;
  uint64_t v27;
  unsigned __int8 v28;
  _WORD *v29;
  int v30;
  _WORD *v31;
  int v32;
  unint64_t v33;
  unint64_t v34;
  _WORD *v35;
  int v36;
  _WORD *v37;
  int v38;
  int v39;
  int v40;
  _WORD *v41;
  int v42;
  _WORD *v43;
  int v44;
  int v45;
  int v46;
  uint64_t result;
  int v48;
  uint64_t v49;
  int v50;
  __int16 v51;
  __int16 v52;
  _WORD *v53;
  uint64_t v54;

  *a2 = 0;
  a2[1] = 0;
  v4 = operator new(0x30uLL);
  v4[1] = 0;
  v4[2] = 0;
  *v4 = &off_24D5E6D30;
  v4[5] = 0;
  a2[1] = v4;
  v4[4] = 0;
  v4[3] = v4 + 4;
  v5 = (uint64_t **)(v4 + 3);
  *a2 = v4 + 3;
  TlvValue = (_WORD *)qmi::MessageBase::findTlvValue(a1);
  v8 = TlvValue;
  if (TlvValue)
  {
    v9 = v7;
    v53 = TlvValue;
    v10 = tlv::parseV<nas::tlv::GsmSigInfo>((_BYTE **)&v53, v7);
    if (v53)
    {
      v54 = 0;
      *((double *)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 0, 0, (uint64_t **)&v54)+ 5) = (double)v10;
    }
    else
    {
      ((void (*)(_QWORD, uint64_t, _WORD *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, 18, v8, v9);
    }
  }
  v11 = (_WORD *)qmi::MessageBase::findTlvValue(a1);
  v13 = v11;
  if (v11)
  {
    v14 = v12;
    v53 = v11;
    v15 = tlv::parseV<nas::tlv::WCdmaSigInfo>((_BYTE **)&v53, v12);
    if (v53)
    {
      v16 = v15;
      v54 = 0;
      *((double *)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 0, 0, (uint64_t **)&v54)+ 5) = (double)(char)v15;
      v54 = 0x400000000;
      *((double *)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 0, 4, (uint64_t **)&v54)+ 5) = (double)(v16 >> 16) * -0.5;
    }
    else
    {
      ((void (*)(_QWORD, uint64_t, _WORD *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, 19, v13, v14);
    }
  }
  v17 = (_WORD *)qmi::MessageBase::findTlvValue(a1);
  v19 = v17;
  if (v17)
  {
    v20 = v18;
    v53 = v17;
    v21 = tlv::parseV<nas::tlv::CdmaSigInfo>((_BYTE **)&v53, v18);
    if (v53)
    {
      v22 = v21;
      v54 = 1;
      *((double *)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 1, 0, (uint64_t **)&v54)+ 5) = (double)(char)v21;
      v54 = 0x100000001;
      *((double *)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 1, 1, (uint64_t **)&v54)+ 5) = (double)(v22 >> 16) * -0.5;
    }
    else
    {
      ((void (*)(_QWORD, uint64_t, _WORD *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, 16, v19, v20);
    }
  }
  v23 = (_WORD *)qmi::MessageBase::findTlvValue(a1);
  v25 = v23;
  if (v23)
  {
    v26 = v24;
    v53 = v23;
    v27 = tlv::parseV<nas::tlv::HdrSigInfo>((char **)&v53, v24);
    if (v53)
    {
      v28 = BYTE4(v27);
      v54 = 0x500000001;
      *((double *)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 1, 5, (uint64_t **)&v54)+ 5) = (double)(char)v27;
      v54 = 0x600000001;
      *((double *)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 1, 6, (uint64_t **)&v54)+ 5) = (double)v28;
    }
    else
    {
      ((void (*)(_QWORD, uint64_t, _WORD *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, 17, v25, v26);
    }
  }
  v29 = (_WORD *)qmi::MessageBase::findTlvValue(a1);
  v31 = v29;
  if (v29)
  {
    v32 = v30;
    v53 = v29;
    v33 = tlv::parseV<nas::tlv::LteSigInfo>((_BYTE **)&v53, v30);
    if (v53)
    {
      v34 = v33;
      v54 = 2;
      *((double *)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 2, 0, (uint64_t **)&v54)+ 5) = (double)(char)v33;
      v54 = 0x700000002;
      *((double *)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 2, 7, (uint64_t **)&v54)+ 5) = (double)((int)v34 >> 16);
      v54 = 0x800000002;
      *((double *)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 2, 8, (uint64_t **)&v54)+ 5) = (double)SBYTE1(v34);
      v54 = 0x600000002;
      *((double *)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 2, 6, (uint64_t **)&v54)+ 5) = (double)SWORD2(v34) / 10.0;
    }
    else
    {
      ((void (*)(_QWORD, uint64_t, _WORD *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, 20, v31, v32);
    }
  }
  v35 = (_WORD *)qmi::MessageBase::findTlvValue(a1);
  v37 = v35;
  if (v35)
  {
    v38 = v36;
    v53 = v35;
    v39 = tlv::parseV<nas::tlv::TDSCDMASigInfo>((_BYTE **)&v53, v36);
    if (v53)
    {
      v40 = v39;
      v54 = 0x300000003;
      *((double *)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 3, 3, (uint64_t **)&v54)+ 5) = (double)(char)v39;
      v54 = 0x100000003;
      *((double *)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 3, 1, (uint64_t **)&v54)+ 5) = (double)(v40 >> 16) * -0.5;
    }
    else
    {
      ((void (*)(_QWORD, uint64_t, _WORD *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, 161, v37, v38);
    }
  }
  v41 = (_WORD *)qmi::MessageBase::findTlvValue(a1);
  v43 = v41;
  if (v41)
  {
    v44 = v42;
    v53 = v41;
    v45 = tlv::parseV<nas::tlv::NrSigInfo>(&v53, v42);
    if (v53)
    {
      v46 = v45;
      v54 = 0x700000004;
      *((double *)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 4, 7, (uint64_t **)&v54)+ 5) = (double)(__int16)v45;
      v54 = 0x600000004;
      *((double *)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 4, 6, (uint64_t **)&v54)+ 5) = (double)(v46 >> 16) / 10.0;
    }
    else
    {
      ((void (*)(_QWORD, uint64_t, _WORD *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, 23, v43, v44);
    }
  }
  result = qmi::MessageBase::findTlvValue(a1);
  v49 = result;
  if (result)
  {
    v50 = v48;
    v53 = (_WORD *)result;
    v51 = tlv::parseV<nas::tlv::NrSigInfoExt>(&v53, v48);
    if (v53)
    {
      v52 = v51;
      v54 = 0x800000004;
      result = (uint64_t)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 4, 8, (uint64_t **)&v54);
      *(double *)(result + 40) = (double)v52;
    }
    else
    {
      return ((uint64_t (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, 24, v49, v50);
    }
  }
  return result;
}

{
  _QWORD *v4;
  uint64_t **v5;
  _WORD *TlvValue;
  int v7;
  _WORD *v8;
  int v9;
  char v10;
  _WORD *v11;
  int v12;
  _WORD *v13;
  int v14;
  int v15;
  int v16;
  _WORD *v17;
  int v18;
  _WORD *v19;
  int v20;
  int v21;
  int v22;
  _WORD *v23;
  int v24;
  _WORD *v25;
  int v26;
  uint64_t v27;
  unsigned __int8 v28;
  _WORD *v29;
  int v30;
  _WORD *v31;
  int v32;
  unint64_t v33;
  unint64_t v34;
  _WORD *v35;
  int v36;
  _WORD *v37;
  int v38;
  int v39;
  int v40;
  _WORD *v41;
  int v42;
  _WORD *v43;
  int v44;
  int v45;
  int v46;
  uint64_t result;
  int v48;
  uint64_t v49;
  int v50;
  __int16 v51;
  __int16 v52;
  _WORD *v53;
  uint64_t v54;

  *a2 = 0;
  a2[1] = 0;
  v4 = operator new(0x30uLL);
  v4[1] = 0;
  v4[2] = 0;
  *v4 = &off_24D5E6D30;
  v4[5] = 0;
  a2[1] = v4;
  v4[4] = 0;
  v4[3] = v4 + 4;
  v5 = (uint64_t **)(v4 + 3);
  *a2 = v4 + 3;
  TlvValue = (_WORD *)qmi::MessageBase::findTlvValue(a1);
  v8 = TlvValue;
  if (TlvValue)
  {
    v9 = v7;
    v53 = TlvValue;
    v10 = tlv::parseV<nas::tlv::GsmSigInfo>((_BYTE **)&v53, v7);
    if (v53)
    {
      v54 = 0;
      *((double *)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 0, 0, (uint64_t **)&v54)+ 5) = (double)v10;
    }
    else
    {
      ((void (*)(_QWORD, uint64_t, _WORD *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, 18, v8, v9);
    }
  }
  v11 = (_WORD *)qmi::MessageBase::findTlvValue(a1);
  v13 = v11;
  if (v11)
  {
    v14 = v12;
    v53 = v11;
    v15 = tlv::parseV<nas::tlv::WCdmaSigInfo>((_BYTE **)&v53, v12);
    if (v53)
    {
      v16 = v15;
      v54 = 0;
      *((double *)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 0, 0, (uint64_t **)&v54)+ 5) = (double)(char)v15;
      v54 = 0x400000000;
      *((double *)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 0, 4, (uint64_t **)&v54)+ 5) = (double)(v16 >> 16) * -0.5;
    }
    else
    {
      ((void (*)(_QWORD, uint64_t, _WORD *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, 19, v13, v14);
    }
  }
  v17 = (_WORD *)qmi::MessageBase::findTlvValue(a1);
  v19 = v17;
  if (v17)
  {
    v20 = v18;
    v53 = v17;
    v21 = tlv::parseV<nas::tlv::CdmaSigInfo>((_BYTE **)&v53, v18);
    if (v53)
    {
      v22 = v21;
      v54 = 1;
      *((double *)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 1, 0, (uint64_t **)&v54)+ 5) = (double)(char)v21;
      v54 = 0x100000001;
      *((double *)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 1, 1, (uint64_t **)&v54)+ 5) = (double)(v22 >> 16) * -0.5;
    }
    else
    {
      ((void (*)(_QWORD, uint64_t, _WORD *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, 16, v19, v20);
    }
  }
  v23 = (_WORD *)qmi::MessageBase::findTlvValue(a1);
  v25 = v23;
  if (v23)
  {
    v26 = v24;
    v53 = v23;
    v27 = tlv::parseV<nas::tlv::HdrSigInfo>((char **)&v53, v24);
    if (v53)
    {
      v28 = BYTE4(v27);
      v54 = 0x500000001;
      *((double *)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 1, 5, (uint64_t **)&v54)+ 5) = (double)(char)v27;
      v54 = 0x600000001;
      *((double *)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 1, 6, (uint64_t **)&v54)+ 5) = (double)v28;
    }
    else
    {
      ((void (*)(_QWORD, uint64_t, _WORD *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, 17, v25, v26);
    }
  }
  v29 = (_WORD *)qmi::MessageBase::findTlvValue(a1);
  v31 = v29;
  if (v29)
  {
    v32 = v30;
    v53 = v29;
    v33 = tlv::parseV<nas::tlv::LteSigInfo>((_BYTE **)&v53, v30);
    if (v53)
    {
      v34 = v33;
      v54 = 2;
      *((double *)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 2, 0, (uint64_t **)&v54)+ 5) = (double)(char)v33;
      v54 = 0x700000002;
      *((double *)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 2, 7, (uint64_t **)&v54)+ 5) = (double)((int)v34 >> 16);
      v54 = 0x800000002;
      *((double *)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 2, 8, (uint64_t **)&v54)+ 5) = (double)SBYTE1(v34);
      v54 = 0x600000002;
      *((double *)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 2, 6, (uint64_t **)&v54)+ 5) = (double)SWORD2(v34) / 10.0;
    }
    else
    {
      ((void (*)(_QWORD, uint64_t, _WORD *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, 20, v31, v32);
    }
  }
  v35 = (_WORD *)qmi::MessageBase::findTlvValue(a1);
  v37 = v35;
  if (v35)
  {
    v38 = v36;
    v53 = v35;
    v39 = tlv::parseV<nas::tlv::TDSCDMASigInfo>((_BYTE **)&v53, v36);
    if (v53)
    {
      v40 = v39;
      v54 = 0x300000003;
      *((double *)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 3, 3, (uint64_t **)&v54)+ 5) = (double)(char)v39;
      v54 = 0x100000003;
      *((double *)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 3, 1, (uint64_t **)&v54)+ 5) = (double)(v40 >> 16) * -0.5;
    }
    else
    {
      ((void (*)(_QWORD, uint64_t, _WORD *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, 161, v37, v38);
    }
  }
  v41 = (_WORD *)qmi::MessageBase::findTlvValue(a1);
  v43 = v41;
  if (v41)
  {
    v44 = v42;
    v53 = v41;
    v45 = tlv::parseV<nas::tlv::NrSigInfo>(&v53, v42);
    if (v53)
    {
      v46 = v45;
      v54 = 0x700000004;
      *((double *)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 4, 7, (uint64_t **)&v54)+ 5) = (double)(__int16)v45;
      v54 = 0x600000004;
      *((double *)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 4, 6, (uint64_t **)&v54)+ 5) = (double)(v46 >> 16) / 10.0;
    }
    else
    {
      ((void (*)(_QWORD, uint64_t, _WORD *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, 23, v43, v44);
    }
  }
  result = qmi::MessageBase::findTlvValue(a1);
  v49 = result;
  if (result)
  {
    v50 = v48;
    v53 = (_WORD *)result;
    v51 = tlv::parseV<nas::tlv::NrSigInfoExt>(&v53, v48);
    if (v53)
    {
      v52 = v51;
      v54 = 0x800000004;
      result = (uint64_t)std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(v5, 4, 8, (uint64_t **)&v54);
      *(double *)(result + 40) = (double)v52;
    }
    else
    {
      return ((uint64_t (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, 24, v49, v50);
    }
  }
  return result;
}

void sub_216A5C44C(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void sub_216A5CA60(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

uint64_t qmi::MutableMessageBase::getTLV<nas::tlv::GsmRssiDelta>(_QWORD *a1, int a2)
{
  const void **v2;
  const void **v3;
  void *v4;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3)
        return qmi::MutableMessageBase::createTLV<nas::tlv::GsmRssiDelta>(a1, a2);
    }
  }
  if (v2 == v3)
    return qmi::MutableMessageBase::createTLV<nas::tlv::GsmRssiDelta>(a1, a2);
  if (!v4)
    __cxa_bad_cast();
  return (uint64_t)v4 + 10;
}

uint64_t qmi::MutableMessageBase::createTLV<nas::tlv::GsmRssiDelta>(_QWORD *a1, char a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v4 = operator new();
  *(_BYTE *)(v4 + 8) = a2;
  *(_WORD *)(v4 + 10) = 0;
  *(_QWORD *)v4 = &off_24D5E6848;
  v5 = a1[3];
  v6 = (uint64_t *)a1[2];
  if ((unint64_t)v6 >= v5)
  {
    v8 = a1[1];
    v9 = ((uint64_t)v6 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v5 - v8;
    v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1))
      v11 = v9 + 1;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v12);
    else
      v13 = 0;
    v14 = (uint64_t *)&v13[8 * v9];
    v15 = &v13[8 * v12];
    *v14 = v4;
    v7 = v14 + 1;
    v17 = (char *)a1[1];
    v16 = (char *)a1[2];
    if (v16 != v17)
    {
      do
      {
        v18 = *((_QWORD *)v16 - 1);
        v16 -= 8;
        *--v14 = v18;
      }
      while (v16 != v17);
      v16 = (char *)a1[1];
    }
    a1[1] = v14;
    a1[2] = v7;
    a1[3] = v15;
    if (v16)
      operator delete(v16);
  }
  else
  {
    *v6 = v4;
    v7 = v6 + 1;
  }
  a1[2] = v7;
  return v4 + 10;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::GsmRssiDelta>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::GsmRssiDelta>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_OperatorReservedPcoId>();
}

_WORD *qmi::MutableMessageBase::TlvWrapper<nas::tlv::GsmRssiDelta>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _WORD *v4;
  uint64_t v5;
  _WORD *result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_WORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::Profile3GPP_OperatorReservedPcoId>((_WORD **)a2, (_WORD *)(a1 + 10));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::GsmRssiDelta>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E6848;
  *(_WORD *)(result + 10) = *(_WORD *)(a1 + 10);
  return result;
}

uint64_t qmi::MutableMessageBase::getTLV<nas::tlv::WcdmaRssiDelta>(_QWORD *a1, int a2)
{
  const void **v2;
  const void **v3;
  void *v4;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3)
        return qmi::MutableMessageBase::createTLV<nas::tlv::WcdmaRssiDelta>(a1, a2);
    }
  }
  if (v2 == v3)
    return qmi::MutableMessageBase::createTLV<nas::tlv::WcdmaRssiDelta>(a1, a2);
  if (!v4)
    __cxa_bad_cast();
  return (uint64_t)v4 + 10;
}

uint64_t qmi::MutableMessageBase::createTLV<nas::tlv::WcdmaRssiDelta>(_QWORD *a1, char a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v4 = operator new();
  *(_BYTE *)(v4 + 8) = a2;
  *(_WORD *)(v4 + 10) = 0;
  *(_QWORD *)v4 = &off_24D5E6898;
  v5 = a1[3];
  v6 = (uint64_t *)a1[2];
  if ((unint64_t)v6 >= v5)
  {
    v8 = a1[1];
    v9 = ((uint64_t)v6 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v5 - v8;
    v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1))
      v11 = v9 + 1;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v12);
    else
      v13 = 0;
    v14 = (uint64_t *)&v13[8 * v9];
    v15 = &v13[8 * v12];
    *v14 = v4;
    v7 = v14 + 1;
    v17 = (char *)a1[1];
    v16 = (char *)a1[2];
    if (v16 != v17)
    {
      do
      {
        v18 = *((_QWORD *)v16 - 1);
        v16 -= 8;
        *--v14 = v18;
      }
      while (v16 != v17);
      v16 = (char *)a1[1];
    }
    a1[1] = v14;
    a1[2] = v7;
    a1[3] = v15;
    if (v16)
      operator delete(v16);
  }
  else
  {
    *v6 = v4;
    v7 = v6 + 1;
  }
  a1[2] = v7;
  return v4 + 10;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::WcdmaRssiDelta>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::WcdmaRssiDelta>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_OperatorReservedPcoId>();
}

_WORD *qmi::MutableMessageBase::TlvWrapper<nas::tlv::WcdmaRssiDelta>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _WORD *v4;
  uint64_t v5;
  _WORD *result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_WORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::Profile3GPP_OperatorReservedPcoId>((_WORD **)a2, (_WORD *)(a1 + 10));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::WcdmaRssiDelta>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E6898;
  *(_WORD *)(result + 10) = *(_WORD *)(a1 + 10);
  return result;
}

uint64_t qmi::MutableMessageBase::getTLV<nas::tlv::WcdmaEcioDelta>(_QWORD *a1, int a2)
{
  const void **v2;
  const void **v3;
  void *v4;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3)
        return qmi::MutableMessageBase::createTLV<nas::tlv::WcdmaEcioDelta>(a1, a2);
    }
  }
  if (v2 == v3)
    return qmi::MutableMessageBase::createTLV<nas::tlv::WcdmaEcioDelta>(a1, a2);
  if (!v4)
    __cxa_bad_cast();
  return (uint64_t)v4 + 10;
}

uint64_t qmi::MutableMessageBase::createTLV<nas::tlv::WcdmaEcioDelta>(_QWORD *a1, char a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v4 = operator new();
  *(_BYTE *)(v4 + 8) = a2;
  *(_WORD *)(v4 + 10) = 0;
  *(_QWORD *)v4 = &off_24D5E68E8;
  v5 = a1[3];
  v6 = (uint64_t *)a1[2];
  if ((unint64_t)v6 >= v5)
  {
    v8 = a1[1];
    v9 = ((uint64_t)v6 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v5 - v8;
    v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1))
      v11 = v9 + 1;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v12);
    else
      v13 = 0;
    v14 = (uint64_t *)&v13[8 * v9];
    v15 = &v13[8 * v12];
    *v14 = v4;
    v7 = v14 + 1;
    v17 = (char *)a1[1];
    v16 = (char *)a1[2];
    if (v16 != v17)
    {
      do
      {
        v18 = *((_QWORD *)v16 - 1);
        v16 -= 8;
        *--v14 = v18;
      }
      while (v16 != v17);
      v16 = (char *)a1[1];
    }
    a1[1] = v14;
    a1[2] = v7;
    a1[3] = v15;
    if (v16)
      operator delete(v16);
  }
  else
  {
    *v6 = v4;
    v7 = v6 + 1;
  }
  a1[2] = v7;
  return v4 + 10;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::WcdmaEcioDelta>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::WcdmaEcioDelta>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_OperatorReservedPcoId>();
}

_WORD *qmi::MutableMessageBase::TlvWrapper<nas::tlv::WcdmaEcioDelta>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _WORD *v4;
  uint64_t v5;
  _WORD *result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_WORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::Profile3GPP_OperatorReservedPcoId>((_WORD **)a2, (_WORD *)(a1 + 10));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::WcdmaEcioDelta>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E68E8;
  *(_WORD *)(result + 10) = *(_WORD *)(a1 + 10);
  return result;
}

uint64_t qmi::MutableMessageBase::getTLV<nas::tlv::CdmaRssiDelta>(_QWORD *a1, int a2)
{
  const void **v2;
  const void **v3;
  void *v4;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3)
        return qmi::MutableMessageBase::createTLV<nas::tlv::CdmaRssiDelta>(a1, a2);
    }
  }
  if (v2 == v3)
    return qmi::MutableMessageBase::createTLV<nas::tlv::CdmaRssiDelta>(a1, a2);
  if (!v4)
    __cxa_bad_cast();
  return (uint64_t)v4 + 10;
}

uint64_t qmi::MutableMessageBase::createTLV<nas::tlv::CdmaRssiDelta>(_QWORD *a1, char a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v4 = operator new();
  *(_BYTE *)(v4 + 8) = a2;
  *(_WORD *)(v4 + 10) = 0;
  *(_QWORD *)v4 = &off_24D5E6938;
  v5 = a1[3];
  v6 = (uint64_t *)a1[2];
  if ((unint64_t)v6 >= v5)
  {
    v8 = a1[1];
    v9 = ((uint64_t)v6 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v5 - v8;
    v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1))
      v11 = v9 + 1;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v12);
    else
      v13 = 0;
    v14 = (uint64_t *)&v13[8 * v9];
    v15 = &v13[8 * v12];
    *v14 = v4;
    v7 = v14 + 1;
    v17 = (char *)a1[1];
    v16 = (char *)a1[2];
    if (v16 != v17)
    {
      do
      {
        v18 = *((_QWORD *)v16 - 1);
        v16 -= 8;
        *--v14 = v18;
      }
      while (v16 != v17);
      v16 = (char *)a1[1];
    }
    a1[1] = v14;
    a1[2] = v7;
    a1[3] = v15;
    if (v16)
      operator delete(v16);
  }
  else
  {
    *v6 = v4;
    v7 = v6 + 1;
  }
  a1[2] = v7;
  return v4 + 10;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::CdmaRssiDelta>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::CdmaRssiDelta>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_OperatorReservedPcoId>();
}

_WORD *qmi::MutableMessageBase::TlvWrapper<nas::tlv::CdmaRssiDelta>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _WORD *v4;
  uint64_t v5;
  _WORD *result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_WORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::Profile3GPP_OperatorReservedPcoId>((_WORD **)a2, (_WORD *)(a1 + 10));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::CdmaRssiDelta>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E6938;
  *(_WORD *)(result + 10) = *(_WORD *)(a1 + 10);
  return result;
}

uint64_t qmi::MutableMessageBase::getTLV<nas::tlv::HdrRssiDelta>(_QWORD *a1, int a2)
{
  const void **v2;
  const void **v3;
  void *v4;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3)
        return qmi::MutableMessageBase::createTLV<nas::tlv::HdrRssiDelta>(a1, a2);
    }
  }
  if (v2 == v3)
    return qmi::MutableMessageBase::createTLV<nas::tlv::HdrRssiDelta>(a1, a2);
  if (!v4)
    __cxa_bad_cast();
  return (uint64_t)v4 + 10;
}

uint64_t qmi::MutableMessageBase::createTLV<nas::tlv::HdrRssiDelta>(_QWORD *a1, char a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v4 = operator new();
  *(_BYTE *)(v4 + 8) = a2;
  *(_WORD *)(v4 + 10) = 0;
  *(_QWORD *)v4 = &off_24D5E6988;
  v5 = a1[3];
  v6 = (uint64_t *)a1[2];
  if ((unint64_t)v6 >= v5)
  {
    v8 = a1[1];
    v9 = ((uint64_t)v6 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v5 - v8;
    v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1))
      v11 = v9 + 1;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v12);
    else
      v13 = 0;
    v14 = (uint64_t *)&v13[8 * v9];
    v15 = &v13[8 * v12];
    *v14 = v4;
    v7 = v14 + 1;
    v17 = (char *)a1[1];
    v16 = (char *)a1[2];
    if (v16 != v17)
    {
      do
      {
        v18 = *((_QWORD *)v16 - 1);
        v16 -= 8;
        *--v14 = v18;
      }
      while (v16 != v17);
      v16 = (char *)a1[1];
    }
    a1[1] = v14;
    a1[2] = v7;
    a1[3] = v15;
    if (v16)
      operator delete(v16);
  }
  else
  {
    *v6 = v4;
    v7 = v6 + 1;
  }
  a1[2] = v7;
  return v4 + 10;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::HdrRssiDelta>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::HdrRssiDelta>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_OperatorReservedPcoId>();
}

_WORD *qmi::MutableMessageBase::TlvWrapper<nas::tlv::HdrRssiDelta>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _WORD *v4;
  uint64_t v5;
  _WORD *result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_WORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::Profile3GPP_OperatorReservedPcoId>((_WORD **)a2, (_WORD *)(a1 + 10));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::HdrRssiDelta>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E6988;
  *(_WORD *)(result + 10) = *(_WORD *)(a1 + 10);
  return result;
}

uint64_t qmi::MutableMessageBase::getTLV<nas::tlv::CdmaEcioDelta>(_QWORD *a1, int a2)
{
  const void **v2;
  const void **v3;
  void *v4;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3)
        return qmi::MutableMessageBase::createTLV<nas::tlv::CdmaEcioDelta>(a1, a2);
    }
  }
  if (v2 == v3)
    return qmi::MutableMessageBase::createTLV<nas::tlv::CdmaEcioDelta>(a1, a2);
  if (!v4)
    __cxa_bad_cast();
  return (uint64_t)v4 + 10;
}

uint64_t qmi::MutableMessageBase::createTLV<nas::tlv::CdmaEcioDelta>(_QWORD *a1, char a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v4 = operator new();
  *(_BYTE *)(v4 + 8) = a2;
  *(_WORD *)(v4 + 10) = 0;
  *(_QWORD *)v4 = &off_24D5E69D8;
  v5 = a1[3];
  v6 = (uint64_t *)a1[2];
  if ((unint64_t)v6 >= v5)
  {
    v8 = a1[1];
    v9 = ((uint64_t)v6 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v5 - v8;
    v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1))
      v11 = v9 + 1;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v12);
    else
      v13 = 0;
    v14 = (uint64_t *)&v13[8 * v9];
    v15 = &v13[8 * v12];
    *v14 = v4;
    v7 = v14 + 1;
    v17 = (char *)a1[1];
    v16 = (char *)a1[2];
    if (v16 != v17)
    {
      do
      {
        v18 = *((_QWORD *)v16 - 1);
        v16 -= 8;
        *--v14 = v18;
      }
      while (v16 != v17);
      v16 = (char *)a1[1];
    }
    a1[1] = v14;
    a1[2] = v7;
    a1[3] = v15;
    if (v16)
      operator delete(v16);
  }
  else
  {
    *v6 = v4;
    v7 = v6 + 1;
  }
  a1[2] = v7;
  return v4 + 10;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::CdmaEcioDelta>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::CdmaEcioDelta>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_OperatorReservedPcoId>();
}

_WORD *qmi::MutableMessageBase::TlvWrapper<nas::tlv::CdmaEcioDelta>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _WORD *v4;
  uint64_t v5;
  _WORD *result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_WORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::Profile3GPP_OperatorReservedPcoId>((_WORD **)a2, (_WORD *)(a1 + 10));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::CdmaEcioDelta>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E69D8;
  *(_WORD *)(result + 10) = *(_WORD *)(a1 + 10);
  return result;
}

uint64_t qmi::MutableMessageBase::getTLV<nas::tlv::HdrSinrDelta>(_QWORD *a1, int a2)
{
  const void **v2;
  const void **v3;
  void *v4;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3)
        return qmi::MutableMessageBase::createTLV<nas::tlv::HdrSinrDelta>(a1, a2);
    }
  }
  if (v2 == v3)
    return qmi::MutableMessageBase::createTLV<nas::tlv::HdrSinrDelta>(a1, a2);
  if (!v4)
    __cxa_bad_cast();
  return (uint64_t)v4 + 10;
}

uint64_t qmi::MutableMessageBase::createTLV<nas::tlv::HdrSinrDelta>(_QWORD *a1, char a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v4 = operator new();
  *(_BYTE *)(v4 + 8) = a2;
  *(_WORD *)(v4 + 10) = 0;
  *(_QWORD *)v4 = &off_24D5E6A28;
  v5 = a1[3];
  v6 = (uint64_t *)a1[2];
  if ((unint64_t)v6 >= v5)
  {
    v8 = a1[1];
    v9 = ((uint64_t)v6 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v5 - v8;
    v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1))
      v11 = v9 + 1;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v12);
    else
      v13 = 0;
    v14 = (uint64_t *)&v13[8 * v9];
    v15 = &v13[8 * v12];
    *v14 = v4;
    v7 = v14 + 1;
    v17 = (char *)a1[1];
    v16 = (char *)a1[2];
    if (v16 != v17)
    {
      do
      {
        v18 = *((_QWORD *)v16 - 1);
        v16 -= 8;
        *--v14 = v18;
      }
      while (v16 != v17);
      v16 = (char *)a1[1];
    }
    a1[1] = v14;
    a1[2] = v7;
    a1[3] = v15;
    if (v16)
      operator delete(v16);
  }
  else
  {
    *v6 = v4;
    v7 = v6 + 1;
  }
  a1[2] = v7;
  return v4 + 10;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::HdrSinrDelta>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::HdrSinrDelta>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_OperatorReservedPcoId>();
}

_WORD *qmi::MutableMessageBase::TlvWrapper<nas::tlv::HdrSinrDelta>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _WORD *v4;
  uint64_t v5;
  _WORD *result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_WORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::Profile3GPP_OperatorReservedPcoId>((_WORD **)a2, (_WORD *)(a1 + 10));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::HdrSinrDelta>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E6A28;
  *(_WORD *)(result + 10) = *(_WORD *)(a1 + 10);
  return result;
}

uint64_t qmi::MutableMessageBase::getTLV<nas::tlv::LteRssiDelta>(_QWORD *a1, int a2)
{
  const void **v2;
  const void **v3;
  void *v4;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3)
        return qmi::MutableMessageBase::createTLV<nas::tlv::LteRssiDelta>(a1, a2);
    }
  }
  if (v2 == v3)
    return qmi::MutableMessageBase::createTLV<nas::tlv::LteRssiDelta>(a1, a2);
  if (!v4)
    __cxa_bad_cast();
  return (uint64_t)v4 + 10;
}

uint64_t qmi::MutableMessageBase::createTLV<nas::tlv::LteRssiDelta>(_QWORD *a1, char a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v4 = operator new();
  *(_BYTE *)(v4 + 8) = a2;
  *(_WORD *)(v4 + 10) = 0;
  *(_QWORD *)v4 = &off_24D5E6A78;
  v5 = a1[3];
  v6 = (uint64_t *)a1[2];
  if ((unint64_t)v6 >= v5)
  {
    v8 = a1[1];
    v9 = ((uint64_t)v6 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v5 - v8;
    v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1))
      v11 = v9 + 1;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v12);
    else
      v13 = 0;
    v14 = (uint64_t *)&v13[8 * v9];
    v15 = &v13[8 * v12];
    *v14 = v4;
    v7 = v14 + 1;
    v17 = (char *)a1[1];
    v16 = (char *)a1[2];
    if (v16 != v17)
    {
      do
      {
        v18 = *((_QWORD *)v16 - 1);
        v16 -= 8;
        *--v14 = v18;
      }
      while (v16 != v17);
      v16 = (char *)a1[1];
    }
    a1[1] = v14;
    a1[2] = v7;
    a1[3] = v15;
    if (v16)
      operator delete(v16);
  }
  else
  {
    *v6 = v4;
    v7 = v6 + 1;
  }
  a1[2] = v7;
  return v4 + 10;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::LteRssiDelta>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::LteRssiDelta>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_OperatorReservedPcoId>();
}

_WORD *qmi::MutableMessageBase::TlvWrapper<nas::tlv::LteRssiDelta>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _WORD *v4;
  uint64_t v5;
  _WORD *result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_WORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::Profile3GPP_OperatorReservedPcoId>((_WORD **)a2, (_WORD *)(a1 + 10));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::LteRssiDelta>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E6A78;
  *(_WORD *)(result + 10) = *(_WORD *)(a1 + 10);
  return result;
}

uint64_t qmi::MutableMessageBase::getTLV<nas::tlv::LteRsrqDelta>(_QWORD *a1, int a2)
{
  const void **v2;
  const void **v3;
  void *v4;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3)
        return qmi::MutableMessageBase::createTLV<nas::tlv::LteRsrqDelta>(a1, a2);
    }
  }
  if (v2 == v3)
    return qmi::MutableMessageBase::createTLV<nas::tlv::LteRsrqDelta>(a1, a2);
  if (!v4)
    __cxa_bad_cast();
  return (uint64_t)v4 + 10;
}

uint64_t qmi::MutableMessageBase::createTLV<nas::tlv::LteRsrqDelta>(_QWORD *a1, char a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v4 = operator new();
  *(_BYTE *)(v4 + 8) = a2;
  *(_WORD *)(v4 + 10) = 0;
  *(_QWORD *)v4 = &off_24D5E6AC8;
  v5 = a1[3];
  v6 = (uint64_t *)a1[2];
  if ((unint64_t)v6 >= v5)
  {
    v8 = a1[1];
    v9 = ((uint64_t)v6 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v5 - v8;
    v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1))
      v11 = v9 + 1;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v12);
    else
      v13 = 0;
    v14 = (uint64_t *)&v13[8 * v9];
    v15 = &v13[8 * v12];
    *v14 = v4;
    v7 = v14 + 1;
    v17 = (char *)a1[1];
    v16 = (char *)a1[2];
    if (v16 != v17)
    {
      do
      {
        v18 = *((_QWORD *)v16 - 1);
        v16 -= 8;
        *--v14 = v18;
      }
      while (v16 != v17);
      v16 = (char *)a1[1];
    }
    a1[1] = v14;
    a1[2] = v7;
    a1[3] = v15;
    if (v16)
      operator delete(v16);
  }
  else
  {
    *v6 = v4;
    v7 = v6 + 1;
  }
  a1[2] = v7;
  return v4 + 10;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::LteRsrqDelta>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::LteRsrqDelta>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_OperatorReservedPcoId>();
}

_WORD *qmi::MutableMessageBase::TlvWrapper<nas::tlv::LteRsrqDelta>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _WORD *v4;
  uint64_t v5;
  _WORD *result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_WORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::Profile3GPP_OperatorReservedPcoId>((_WORD **)a2, (_WORD *)(a1 + 10));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::LteRsrqDelta>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E6AC8;
  *(_WORD *)(result + 10) = *(_WORD *)(a1 + 10);
  return result;
}

uint64_t qmi::MutableMessageBase::getTLV<nas::tlv::LteRsrpDelta>(_QWORD *a1, int a2)
{
  const void **v2;
  const void **v3;
  void *v4;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3)
        return qmi::MutableMessageBase::createTLV<nas::tlv::LteRsrpDelta>(a1, a2);
    }
  }
  if (v2 == v3)
    return qmi::MutableMessageBase::createTLV<nas::tlv::LteRsrpDelta>(a1, a2);
  if (!v4)
    __cxa_bad_cast();
  return (uint64_t)v4 + 10;
}

uint64_t qmi::MutableMessageBase::createTLV<nas::tlv::LteRsrpDelta>(_QWORD *a1, char a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v4 = operator new();
  *(_BYTE *)(v4 + 8) = a2;
  *(_WORD *)(v4 + 10) = 0;
  *(_QWORD *)v4 = &off_24D5E6B18;
  v5 = a1[3];
  v6 = (uint64_t *)a1[2];
  if ((unint64_t)v6 >= v5)
  {
    v8 = a1[1];
    v9 = ((uint64_t)v6 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v5 - v8;
    v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1))
      v11 = v9 + 1;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v12);
    else
      v13 = 0;
    v14 = (uint64_t *)&v13[8 * v9];
    v15 = &v13[8 * v12];
    *v14 = v4;
    v7 = v14 + 1;
    v17 = (char *)a1[1];
    v16 = (char *)a1[2];
    if (v16 != v17)
    {
      do
      {
        v18 = *((_QWORD *)v16 - 1);
        v16 -= 8;
        *--v14 = v18;
      }
      while (v16 != v17);
      v16 = (char *)a1[1];
    }
    a1[1] = v14;
    a1[2] = v7;
    a1[3] = v15;
    if (v16)
      operator delete(v16);
  }
  else
  {
    *v6 = v4;
    v7 = v6 + 1;
  }
  a1[2] = v7;
  return v4 + 10;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::LteRsrpDelta>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::LteRsrpDelta>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_OperatorReservedPcoId>();
}

_WORD *qmi::MutableMessageBase::TlvWrapper<nas::tlv::LteRsrpDelta>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _WORD *v4;
  uint64_t v5;
  _WORD *result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_WORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::Profile3GPP_OperatorReservedPcoId>((_WORD **)a2, (_WORD *)(a1 + 10));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::LteRsrpDelta>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E6B18;
  *(_WORD *)(result + 10) = *(_WORD *)(a1 + 10);
  return result;
}

uint64_t qmi::MutableMessageBase::getTLV<nas::tlv::LteSnrDelta>(_QWORD *a1, int a2)
{
  const void **v2;
  const void **v3;
  void *v4;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3)
        return qmi::MutableMessageBase::createTLV<nas::tlv::LteSnrDelta>(a1, a2);
    }
  }
  if (v2 == v3)
    return qmi::MutableMessageBase::createTLV<nas::tlv::LteSnrDelta>(a1, a2);
  if (!v4)
    __cxa_bad_cast();
  return (uint64_t)v4 + 10;
}

uint64_t qmi::MutableMessageBase::createTLV<nas::tlv::LteSnrDelta>(_QWORD *a1, char a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v4 = operator new();
  *(_BYTE *)(v4 + 8) = a2;
  *(_WORD *)(v4 + 10) = 0;
  *(_QWORD *)v4 = &off_24D5E6B68;
  v5 = a1[3];
  v6 = (uint64_t *)a1[2];
  if ((unint64_t)v6 >= v5)
  {
    v8 = a1[1];
    v9 = ((uint64_t)v6 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v5 - v8;
    v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1))
      v11 = v9 + 1;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v12);
    else
      v13 = 0;
    v14 = (uint64_t *)&v13[8 * v9];
    v15 = &v13[8 * v12];
    *v14 = v4;
    v7 = v14 + 1;
    v17 = (char *)a1[1];
    v16 = (char *)a1[2];
    if (v16 != v17)
    {
      do
      {
        v18 = *((_QWORD *)v16 - 1);
        v16 -= 8;
        *--v14 = v18;
      }
      while (v16 != v17);
      v16 = (char *)a1[1];
    }
    a1[1] = v14;
    a1[2] = v7;
    a1[3] = v15;
    if (v16)
      operator delete(v16);
  }
  else
  {
    *v6 = v4;
    v7 = v6 + 1;
  }
  a1[2] = v7;
  return v4 + 10;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::LteSnrDelta>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::LteSnrDelta>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_OperatorReservedPcoId>();
}

_WORD *qmi::MutableMessageBase::TlvWrapper<nas::tlv::LteSnrDelta>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _WORD *v4;
  uint64_t v5;
  _WORD *result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_WORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::Profile3GPP_OperatorReservedPcoId>((_WORD **)a2, (_WORD *)(a1 + 10));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::LteSnrDelta>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E6B68;
  *(_WORD *)(result + 10) = *(_WORD *)(a1 + 10);
  return result;
}

uint64_t qmi::MutableMessageBase::getTLV<nas::tlv::TDSCDMAEcioDelta>(_QWORD *a1, int a2)
{
  const void **v2;
  const void **v3;
  void *v4;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3)
        return qmi::MutableMessageBase::createTLV<nas::tlv::TDSCDMAEcioDelta>(a1, a2);
    }
  }
  if (v2 == v3)
    return qmi::MutableMessageBase::createTLV<nas::tlv::TDSCDMAEcioDelta>(a1, a2);
  if (!v4)
    __cxa_bad_cast();
  return (uint64_t)v4 + 10;
}

uint64_t qmi::MutableMessageBase::createTLV<nas::tlv::TDSCDMAEcioDelta>(_QWORD *a1, char a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v4 = operator new();
  *(_BYTE *)(v4 + 8) = a2;
  *(_WORD *)(v4 + 10) = 0;
  *(_QWORD *)v4 = &off_24D5E6BB8;
  v5 = a1[3];
  v6 = (uint64_t *)a1[2];
  if ((unint64_t)v6 >= v5)
  {
    v8 = a1[1];
    v9 = ((uint64_t)v6 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v5 - v8;
    v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1))
      v11 = v9 + 1;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v12);
    else
      v13 = 0;
    v14 = (uint64_t *)&v13[8 * v9];
    v15 = &v13[8 * v12];
    *v14 = v4;
    v7 = v14 + 1;
    v17 = (char *)a1[1];
    v16 = (char *)a1[2];
    if (v16 != v17)
    {
      do
      {
        v18 = *((_QWORD *)v16 - 1);
        v16 -= 8;
        *--v14 = v18;
      }
      while (v16 != v17);
      v16 = (char *)a1[1];
    }
    a1[1] = v14;
    a1[2] = v7;
    a1[3] = v15;
    if (v16)
      operator delete(v16);
  }
  else
  {
    *v6 = v4;
    v7 = v6 + 1;
  }
  a1[2] = v7;
  return v4 + 10;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::TDSCDMAEcioDelta>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::TDSCDMAEcioDelta>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_OperatorReservedPcoId>();
}

_WORD *qmi::MutableMessageBase::TlvWrapper<nas::tlv::TDSCDMAEcioDelta>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _WORD *v4;
  uint64_t v5;
  _WORD *result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_WORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::Profile3GPP_OperatorReservedPcoId>((_WORD **)a2, (_WORD *)(a1 + 10));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::TDSCDMAEcioDelta>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E6BB8;
  *(_WORD *)(result + 10) = *(_WORD *)(a1 + 10);
  return result;
}

uint64_t qmi::MutableMessageBase::getTLV<nas::tlv::TDSCDMARscpDelta>(_QWORD *a1, int a2)
{
  const void **v2;
  const void **v3;
  void *v4;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3)
        return qmi::MutableMessageBase::createTLV<nas::tlv::TDSCDMARscpDelta>(a1, a2);
    }
  }
  if (v2 == v3)
    return qmi::MutableMessageBase::createTLV<nas::tlv::TDSCDMARscpDelta>(a1, a2);
  if (!v4)
    __cxa_bad_cast();
  return (uint64_t)v4 + 10;
}

uint64_t qmi::MutableMessageBase::createTLV<nas::tlv::TDSCDMARscpDelta>(_QWORD *a1, char a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v4 = operator new();
  *(_BYTE *)(v4 + 8) = a2;
  *(_WORD *)(v4 + 10) = 0;
  *(_QWORD *)v4 = &off_24D5E6C08;
  v5 = a1[3];
  v6 = (uint64_t *)a1[2];
  if ((unint64_t)v6 >= v5)
  {
    v8 = a1[1];
    v9 = ((uint64_t)v6 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v5 - v8;
    v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1))
      v11 = v9 + 1;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v12);
    else
      v13 = 0;
    v14 = (uint64_t *)&v13[8 * v9];
    v15 = &v13[8 * v12];
    *v14 = v4;
    v7 = v14 + 1;
    v17 = (char *)a1[1];
    v16 = (char *)a1[2];
    if (v16 != v17)
    {
      do
      {
        v18 = *((_QWORD *)v16 - 1);
        v16 -= 8;
        *--v14 = v18;
      }
      while (v16 != v17);
      v16 = (char *)a1[1];
    }
    a1[1] = v14;
    a1[2] = v7;
    a1[3] = v15;
    if (v16)
      operator delete(v16);
  }
  else
  {
    *v6 = v4;
    v7 = v6 + 1;
  }
  a1[2] = v7;
  return v4 + 10;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::TDSCDMARscpDelta>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::TDSCDMARscpDelta>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_OperatorReservedPcoId>();
}

_WORD *qmi::MutableMessageBase::TlvWrapper<nas::tlv::TDSCDMARscpDelta>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _WORD *v4;
  uint64_t v5;
  _WORD *result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_WORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::Profile3GPP_OperatorReservedPcoId>((_WORD **)a2, (_WORD *)(a1 + 10));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::TDSCDMARscpDelta>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E6C08;
  *(_WORD *)(result + 10) = *(_WORD *)(a1 + 10);
  return result;
}

uint64_t qmi::MutableMessageBase::getTLV<nas::tlv::NrSnrDelta>(_QWORD *a1, int a2)
{
  const void **v2;
  const void **v3;
  void *v4;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3)
        return qmi::MutableMessageBase::createTLV<nas::tlv::NrSnrDelta>(a1, a2);
    }
  }
  if (v2 == v3)
    return qmi::MutableMessageBase::createTLV<nas::tlv::NrSnrDelta>(a1, a2);
  if (!v4)
    __cxa_bad_cast();
  return (uint64_t)v4 + 10;
}

uint64_t qmi::MutableMessageBase::createTLV<nas::tlv::NrSnrDelta>(_QWORD *a1, char a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v4 = operator new();
  *(_BYTE *)(v4 + 8) = a2;
  *(_WORD *)(v4 + 10) = 0;
  *(_QWORD *)v4 = &off_24D5E6C58;
  v5 = a1[3];
  v6 = (uint64_t *)a1[2];
  if ((unint64_t)v6 >= v5)
  {
    v8 = a1[1];
    v9 = ((uint64_t)v6 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v5 - v8;
    v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1))
      v11 = v9 + 1;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v12);
    else
      v13 = 0;
    v14 = (uint64_t *)&v13[8 * v9];
    v15 = &v13[8 * v12];
    *v14 = v4;
    v7 = v14 + 1;
    v17 = (char *)a1[1];
    v16 = (char *)a1[2];
    if (v16 != v17)
    {
      do
      {
        v18 = *((_QWORD *)v16 - 1);
        v16 -= 8;
        *--v14 = v18;
      }
      while (v16 != v17);
      v16 = (char *)a1[1];
    }
    a1[1] = v14;
    a1[2] = v7;
    a1[3] = v15;
    if (v16)
      operator delete(v16);
  }
  else
  {
    *v6 = v4;
    v7 = v6 + 1;
  }
  a1[2] = v7;
  return v4 + 10;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::NrSnrDelta>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::NrSnrDelta>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_OperatorReservedPcoId>();
}

_WORD *qmi::MutableMessageBase::TlvWrapper<nas::tlv::NrSnrDelta>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _WORD *v4;
  uint64_t v5;
  _WORD *result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_WORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::Profile3GPP_OperatorReservedPcoId>((_WORD **)a2, (_WORD *)(a1 + 10));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::NrSnrDelta>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E6C58;
  *(_WORD *)(result + 10) = *(_WORD *)(a1 + 10);
  return result;
}

uint64_t qmi::MutableMessageBase::getTLV<nas::tlv::NrRsrpDelta>(_QWORD *a1, int a2)
{
  const void **v2;
  const void **v3;
  void *v4;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3)
        return qmi::MutableMessageBase::createTLV<nas::tlv::NrRsrpDelta>(a1, a2);
    }
  }
  if (v2 == v3)
    return qmi::MutableMessageBase::createTLV<nas::tlv::NrRsrpDelta>(a1, a2);
  if (!v4)
    __cxa_bad_cast();
  return (uint64_t)v4 + 10;
}

uint64_t qmi::MutableMessageBase::createTLV<nas::tlv::NrRsrpDelta>(_QWORD *a1, char a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v4 = operator new();
  *(_BYTE *)(v4 + 8) = a2;
  *(_WORD *)(v4 + 10) = 0;
  *(_QWORD *)v4 = &off_24D5E6CA8;
  v5 = a1[3];
  v6 = (uint64_t *)a1[2];
  if ((unint64_t)v6 >= v5)
  {
    v8 = a1[1];
    v9 = ((uint64_t)v6 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v5 - v8;
    v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1))
      v11 = v9 + 1;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v12);
    else
      v13 = 0;
    v14 = (uint64_t *)&v13[8 * v9];
    v15 = &v13[8 * v12];
    *v14 = v4;
    v7 = v14 + 1;
    v17 = (char *)a1[1];
    v16 = (char *)a1[2];
    if (v16 != v17)
    {
      do
      {
        v18 = *((_QWORD *)v16 - 1);
        v16 -= 8;
        *--v14 = v18;
      }
      while (v16 != v17);
      v16 = (char *)a1[1];
    }
    a1[1] = v14;
    a1[2] = v7;
    a1[3] = v15;
    if (v16)
      operator delete(v16);
  }
  else
  {
    *v6 = v4;
    v7 = v6 + 1;
  }
  a1[2] = v7;
  return v4 + 10;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::NrRsrpDelta>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::NrRsrpDelta>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_OperatorReservedPcoId>();
}

_WORD *qmi::MutableMessageBase::TlvWrapper<nas::tlv::NrRsrpDelta>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _WORD *v4;
  uint64_t v5;
  _WORD *result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_WORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::Profile3GPP_OperatorReservedPcoId>((_WORD **)a2, (_WORD *)(a1 + 10));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::NrRsrpDelta>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E6CA8;
  *(_WORD *)(result + 10) = *(_WORD *)(a1 + 10);
  return result;
}

uint64_t qmi::MutableMessageBase::getTLV<nas::tlv::NrRsrqDelta>(_QWORD *a1, int a2)
{
  const void **v2;
  const void **v3;
  void *v4;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3)
        return qmi::MutableMessageBase::createTLV<nas::tlv::NrRsrqDelta>(a1, a2);
    }
  }
  if (v2 == v3)
    return qmi::MutableMessageBase::createTLV<nas::tlv::NrRsrqDelta>(a1, a2);
  if (!v4)
    __cxa_bad_cast();
  return (uint64_t)v4 + 10;
}

uint64_t qmi::MutableMessageBase::createTLV<nas::tlv::NrRsrqDelta>(_QWORD *a1, char a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v4 = operator new();
  *(_BYTE *)(v4 + 8) = a2;
  *(_WORD *)(v4 + 10) = 0;
  *(_QWORD *)v4 = &off_24D5E6CF8;
  v5 = a1[3];
  v6 = (uint64_t *)a1[2];
  if ((unint64_t)v6 >= v5)
  {
    v8 = a1[1];
    v9 = ((uint64_t)v6 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v5 - v8;
    v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1))
      v11 = v9 + 1;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v12);
    else
      v13 = 0;
    v14 = (uint64_t *)&v13[8 * v9];
    v15 = &v13[8 * v12];
    *v14 = v4;
    v7 = v14 + 1;
    v17 = (char *)a1[1];
    v16 = (char *)a1[2];
    if (v16 != v17)
    {
      do
      {
        v18 = *((_QWORD *)v16 - 1);
        v16 -= 8;
        *--v14 = v18;
      }
      while (v16 != v17);
      v16 = (char *)a1[1];
    }
    a1[1] = v14;
    a1[2] = v7;
    a1[3] = v15;
    if (v16)
      operator delete(v16);
  }
  else
  {
    *v6 = v4;
    v7 = v6 + 1;
  }
  a1[2] = v7;
  return v4 + 10;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::NrRsrqDelta>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::NrRsrqDelta>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_OperatorReservedPcoId>();
}

_WORD *qmi::MutableMessageBase::TlvWrapper<nas::tlv::NrRsrqDelta>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _WORD *v4;
  uint64_t v5;
  _WORD *result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_WORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::Profile3GPP_OperatorReservedPcoId>((_WORD **)a2, (_WORD *)(a1 + 10));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::NrRsrqDelta>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E6CF8;
  *(_WORD *)(result + 10) = *(_WORD *)(a1 + 10);
  return result;
}

void std::__shared_ptr_emplace<Inputs>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E6D30;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<Inputs>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E6D30;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void std::__shared_ptr_emplace<Inputs>::__on_zero_shared(uint64_t a1)
{
  std::__tree<std::__value_type<AQMThroughputKey,unsigned int>,std::__map_value_compare<AQMThroughputKey,std::__value_type<AQMThroughputKey,unsigned int>,std::less<AQMThroughputKey>,true>,std::allocator<std::__value_type<AQMThroughputKey,unsigned int>>>::destroy(*(_QWORD **)(a1 + 32));
}

uint64_t **std::__tree<std::__value_type<std::pair<Technology,Type>,double>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,double>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,double>>>::__emplace_unique_key_args<std::pair<Technology,Type>,std::piecewise_construct_t const&,std::tuple<std::pair<Technology,Type>&&>,std::tuple<>>(uint64_t **a1, int a2, int a3, uint64_t **a4)
{
  uint64_t *v6;
  uint64_t **v7;
  uint64_t **v8;
  int v9;
  int v10;
  BOOL v11;
  char v12;
  char v13;
  uint64_t *v14;
  uint64_t *v15;
  uint64_t *v16;

  v7 = a1 + 1;
  v6 = a1[1];
  if (!v6)
  {
    v8 = a1 + 1;
    goto LABEL_21;
  }
  do
  {
    while (1)
    {
      v8 = (uint64_t **)v6;
      v9 = *((_DWORD *)v6 + 8);
      if (v9 == a2)
        break;
      if (v9 <= a2)
      {
        if (v9 >= a2)
          v13 = 1;
        else
          v13 = -1;
        if ((v13 & 0x80) == 0)
          return v8;
        goto LABEL_18;
      }
LABEL_12:
      v6 = *v8;
      v7 = v8;
      if (!*v8)
        goto LABEL_21;
    }
    v10 = *((_DWORD *)v8 + 9);
    v11 = v10 == a3;
    if (v10 > a3)
      goto LABEL_12;
    if (v10 >= a3)
      v12 = 1;
    else
      v12 = -1;
    if (v11)
      v12 = 0;
    if ((v12 & 0x80) == 0)
      return v8;
LABEL_18:
    v6 = v8[1];
  }
  while (v6);
  v7 = v8 + 1;
LABEL_21:
  v14 = (uint64_t *)v8;
  v8 = (uint64_t **)operator new(0x30uLL);
  v8[4] = *a4;
  v8[5] = 0;
  *v8 = 0;
  v8[1] = 0;
  v8[2] = v14;
  *v7 = (uint64_t *)v8;
  v15 = (uint64_t *)**a1;
  v16 = (uint64_t *)v8;
  if (v15)
  {
    *a1 = v15;
    v16 = *v7;
  }
  std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v16);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return v8;
}

uint64_t ctu::enable_make_unique<qmi::NotifyHelper>::make_unique<std::shared_ptr<Registry const> const&>@<X0>(uint64_t *a1@<X8>)
{
  uint64_t v2;
  unsigned int v3;
  uint64_t result;

  v2 = operator new();
  v3 = subscriber::expectedSimCount();
  result = boost::dynamic_bitset<unsigned long,std::allocator<unsigned long>>::dynamic_bitset(v2, v3, 0);
  *a1 = v2;
  return result;
}

void sub_216A5F1BC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199FEAC4](v1, 0x1010C4044AD791CLL);
  _Unwind_Resume(a1);
}

void qmi::NotifyHelper::~NotifyHelper(qmi::NotifyHelper *this)
{
  void *v2;

  if (!boost::dynamic_bitset<unsigned long,std::allocator<unsigned long>>::m_check_invariants((uint64_t *)this))
    __assert_rtn("~dynamic_bitset", "dynamic_bitset.hpp", 702, "m_check_invariants()");
  v2 = *(void **)this;
  if (*(_QWORD *)this)
  {
    *((_QWORD *)this + 1) = v2;
    operator delete(v2);
  }
}

uint64_t qmi::NotifyHelper::shouldNotifyStart(_QWORD *a1)
{
  unsigned int v3;

  if ((boost::dynamic_bitset<unsigned long,std::allocator<unsigned long>>::all((uint64_t)a1) & 1) != 0)
    return 0;
  v3 = subscriber::simSlotAsInstance();
  boost::dynamic_bitset<unsigned long,std::allocator<unsigned long>>::set(a1, v3, 1);
  return boost::dynamic_bitset<unsigned long,std::allocator<unsigned long>>::all((uint64_t)a1);
}

uint64_t boost::dynamic_bitset<unsigned long,std::allocator<unsigned long>>::all(uint64_t a1)
{
  char *v1;
  char *v2;
  uint64_t v3;
  uint64_t v4;
  char *v5;
  uint64_t v6;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;

  if (*(_QWORD *)(a1 + 24))
  {
    v1 = *(char **)a1;
    v2 = *(char **)(a1 + 8);
    v3 = *(_QWORD *)(a1 + 24) & 0x3FLL;
    if (v3)
    {
      v4 = ((v2 - v1) >> 3) - 1;
      if ((v2 - v1) >> 3 != 1)
      {
        v5 = *(char **)a1;
        do
        {
          v6 = *(_QWORD *)v5;
          v5 += 8;
          if (v6 != -1)
            return 0;
        }
        while (--v4);
      }
      if (v2 == v1)
        __assert_rtn("m_highest_block", "dynamic_bitset.hpp", 2025, "size() > 0 && num_blocks() > 0");
      if (*((_QWORD *)v2 - 1) != ~(-1 << v3))
        return 0;
    }
    else
    {
      v8 = v2 - v1;
      if (v8)
      {
        v9 = v8 >> 3;
        if (v9 <= 1)
          v9 = 1;
        while (1)
        {
          v10 = *(_QWORD *)v1;
          v1 += 8;
          if (v10 != -1)
            break;
          if (!--v9)
            return 1;
        }
        return 0;
      }
    }
  }
  return 1;
}

uint64_t qmi::NotifyHelper::shouldNotifyStop(unint64_t **a1)
{
  unint64_t *v1;
  uint64_t v2;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unsigned int v7;
  unint64_t *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  _QWORD *v13;
  _QWORD *v15;
  uint64_t v16;

  v1 = *a1;
  v2 = (char *)a1[1] - (char *)*a1;
  if (!v2)
    return 0;
  v4 = v2 >> 3;
  if (v4 <= 1)
    v5 = 1;
  else
    v5 = v4;
  v6 = *v1;
  if (!*v1)
  {
    v15 = v1 + 1;
    v16 = v5 - 1;
    while (v16 != v6)
    {
      if (v15[v6++])
      {
        if (v6 < v4)
          goto LABEL_6;
        return 0;
      }
    }
    return 0;
  }
LABEL_6:
  v7 = subscriber::simSlotAsInstance();
  boost::dynamic_bitset<unsigned long,std::allocator<unsigned long>>::reset(a1, v7);
  v8 = *a1;
  v9 = (char *)a1[1] - (char *)*a1;
  if (!v9)
    return 1;
  v10 = v9 >> 3;
  v11 = v10 <= 1 ? 1 : v10;
  v12 = *v8;
  if (*v8)
    return 0;
  v13 = v8 + 1;
  while (v11 - 1 != v12)
  {
    if (v13[v12++])
      return v12 >= v10;
  }
  v12 = v11;
  return v12 >= v10;
}

void QMIActivationCommandDriver::create(uint64_t a1@<X0>, NSObject **a2@<X1>, _OWORD *a3@<X8>)
{
  _QWORD *v6;
  NSObject *v7;
  NSObject *v8;
  __int128 v9;

  v6 = (_QWORD *)operator new();
  v7 = *a2;
  v8 = v7;
  if (v7)
    dispatch_retain(v7);
  QMIMav13ActivationCommandDriver::QMIMav13ActivationCommandDriver(v6, a1, &v8);
  v9 = 0uLL;
  std::shared_ptr<QMIMav13ActivationCommandDriver>::shared_ptr[abi:ne180100]<QMIMav13ActivationCommandDriver,std::shared_ptr<QMIMav13ActivationCommandDriver> ctu::SharedSynchronizable<ActivationCommandDriver>::make_shared_ptr<QMIMav13ActivationCommandDriver>(QMIMav13ActivationCommandDriver*)::{lambda(QMIMav13ActivationCommandDriver*)#1},void>((uint64_t *)&v9, (uint64_t)v6);
  *a3 = v9;
  v9 = 0uLL;
  if (v7)
    dispatch_release(v7);
}

void sub_216A5F4E0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  NSObject *v2;
  int v3;

  if (v2)
    dispatch_release(v2);
  if (v3)
    MEMORY[0x2199FEAC4](v1, 0xF1C40497CDD23);
  _Unwind_Resume(exception_object);
}

uint64_t QMIActivationCommandDriver::bootstrap(uint64_t a1, uint64_t a2, __int128 *a3)
{
  NSObject *v5;
  NSObject *v6;
  unint64_t *p_shared_weak_owners;
  unint64_t v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  std::__shared_weak_count *v15;
  uint64_t v16;
  std::__shared_weak_count *v17;
  uint64_t v18;
  std::__shared_weak_count *v19;
  void *__p;
  char v21;
  dispatch_object_t v22;
  void *v23;
  char v24;
  uint8_t buf[16];
  __int128 v26;

  v5 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#I Initializing legacy command driver", buf, 2u);
  }
  std::shared_ptr<qmi::Client::State>::operator=[abi:ne180100](a1 + 48, a3);
  std::string::basic_string[abi:ne180100]<0>(&v23, "Activation: BSP Service");
  v6 = *(NSObject **)(a1 + 24);
  v22 = v6;
  if (v6)
    dispatch_retain(v6);
  std::string::basic_string[abi:ne180100]<0>(&__p, "bsp");
  std::shared_ptr<AttachApnCommandDriver>::shared_ptr[abi:ne180100]<AttachApnCommandDriver,void>(&v16, (_QWORD *)(a1 + 8));
  v18 = v16;
  v19 = v17;
  if (v17)
  {
    p_shared_weak_owners = (unint64_t *)&v17->__shared_weak_owners_;
    do
      v8 = __ldxr(p_shared_weak_owners);
    while (__stxr(v8 + 1, p_shared_weak_owners));
  }
  Registry::getServerConnection(*(Registry **)(a1 + 64));
  qmi::Client::createWithQueueLocal();
  std::shared_ptr<qmi::Client::State>::operator=[abi:ne180100](a1 + 104, &v26);
  qmi::Client::~Client((qmi::Client *)buf);
  if (v15)
  {
    p_shared_owners = (unint64_t *)&v15->__shared_owners_;
    do
      v10 = __ldaxr(p_shared_owners);
    while (__stlxr(v10 - 1, p_shared_owners));
    if (!v10)
    {
      ((void (*)())v15->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  if (v19)
    std::__shared_weak_count::__release_weak(v19);
  v11 = v17;
  if (v17)
  {
    v12 = (unint64_t *)&v17->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  if (v21 < 0)
    operator delete(__p);
  if (v22)
    dispatch_release(v22);
  if (v24 < 0)
    operator delete(v23);
  qmi::Client::setHandler();
  qmi::Client::setHandler();
  return qmi::Client::set((qmi::Client *)(a1 + 88), (const char *)*MEMORY[0x24BED1E38]);
}

void sub_216A5F768(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,std::__shared_weak_count *a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  uint64_t v31;
  NSObject *v33;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a20);
  if (a25)
    std::__shared_weak_count::__release_weak(a25);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a22);
  if (a31 < 0)
    operator delete(__p);
  v33 = *(NSObject **)(v31 - 112);
  if (v33)
    dispatch_release(v33);
  if (*(char *)(v31 - 81) < 0)
    operator delete(*(void **)(v31 - 104));
  _Unwind_Resume(a1);
}

uint64_t ___ZN26QMIActivationCommandDriver9bootstrapEN8dispatch13group_sessionENSt3__110shared_ptrI40ActivationCommandDriverDelegateInterfaceEE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(*(_QWORD *)(a1 + 32) + 48) + 16))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 48), 1);
}

uint64_t ___ZN26QMIActivationCommandDriver9bootstrapEN8dispatch13group_sessionENSt3__110shared_ptrI40ActivationCommandDriverDelegateInterfaceEE_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 32) + 48) + 16))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 48), 0);
}

uint64_t QMIActivationCommandDriver::start(QMIActivationCommandDriver *this)
{
  return qmi::Client::start((QMIActivationCommandDriver *)((char *)this + 88));
}

uint64_t QMIActivationCommandDriver::stop(uint64_t a1)
{
  return qmi::Client::stop((qmi::Client *)(a1 + 88));
}

uint64_t QMIActivationCommandDriver::QMIActivationCommandDriver(uint64_t a1, uint64_t a2, dispatch_object_t *a3)
{
  NSObject *object;

  object = *a3;
  if (*a3)
    dispatch_retain(*a3);
  ActivationCommandDriver::ActivationCommandDriver();
  if (object)
    dispatch_release(object);
  *(_QWORD *)a1 = &off_24D5E6DC0;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  return a1;
}

void sub_216A5F898(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object)
{
  if (object)
    dispatch_release(object);
  _Unwind_Resume(exception_object);
}

void QMIActivationCommandDriver::~QMIActivationCommandDriver(QMIActivationCommandDriver *this)
{
  *(_QWORD *)this = &off_24D5E6DC0;
  qmi::Client::~Client((QMIActivationCommandDriver *)((char *)this + 88));
  ActivationCommandDriver::~ActivationCommandDriver(this);
}

{
  *(_QWORD *)this = &off_24D5E6DC0;
  qmi::Client::~Client((QMIActivationCommandDriver *)((char *)this + 88));
  ActivationCommandDriver::~ActivationCommandDriver(this);
  JUMPOUT(0x2199FEAC4);
}

BOOL QMIActivationCommandDriver::issueActivationTicket(uint64_t a1, char **a2)
{
  char *v4;
  char *v5;
  NSObject *v6;
  _BOOL4 v7;
  char **v8;
  void *v9;
  _QWORD v11[6];
  uint64_t v12;
  int v13;
  uint64_t v14;
  void *aBlock;
  _OWORD v16[2];
  uint8_t buf[8];
  uint64_t v18;
  void (*v19)(uint64_t, QMIServiceMsg *);
  void *v20;
  _QWORD *v21;

  v4 = *a2;
  v5 = a2[1];
  v6 = *(NSObject **)(a1 + 40);
  v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
  if (v4 == v5)
  {
    if (v7)
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_216897000, v6, OS_LOG_TYPE_DEFAULT, "#N Cannot issue empty activation ticket!", buf, 2u);
    }
    (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 48) + 16))(*(_QWORD *)(a1 + 48), 0);
  }
  else
  {
    if (v7)
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_216897000, v6, OS_LOG_TYPE_DEFAULT, "#I issuing postponement ticket", buf, 2u);
    }
    memset(v16, 0, sizeof(v16));
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v16);
    v8 = (char **)qmi::MutableMessageBase::getTLV<bsp::tlv::ActivationManifest>(v16, 1);
    if (v8 != a2)
      std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(v8, *a2, a2[1], a2[1] - *a2);
    v11[5] = a1 + 88;
    v12 = QMIServiceMsg::create();
    v14 = 0;
    aBlock = 0;
    v13 = 60000;
    v11[0] = MEMORY[0x24BDAC760];
    v11[1] = 0x40000000;
    v11[2] = ___ZN26QMIActivationCommandDriver21issueActivationTicketERKNSt3__16vectorIhNS0_9allocatorIhEEEE_block_invoke_2;
    v11[3] = &__block_descriptor_tmp_10_13;
    v11[4] = a1;
    *(_QWORD *)buf = MEMORY[0x24BDAC760];
    v18 = 0x40000000;
    v19 = ___ZNO3qmi6Client9SendProxy8callbackIRKN3bsp22SendActivationManifest8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
    v20 = &unk_24D5E6F08;
    v21 = v11;
    v9 = _Block_copy(buf);
    aBlock = v9;
    if (v12)
    {
      qmi::Client::send();
      v9 = aBlock;
    }
    if (v9)
      _Block_release(v9);
    qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v16);
  }
  return v4 != v5;
}

void sub_216A5FACC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  uint64_t v7;
  va_list va;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  va_list va1;

  va_start(va1, a6);
  va_start(va, a6);
  v7 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)va);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va1);
  _Unwind_Resume(a1);
}

void ___ZN26QMIActivationCommandDriver21issueActivationTicketERKNSt3__16vectorIhNS0_9allocatorIhEEEE_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  int v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  os_log_t *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  NSObject *v14;
  const char *v15;
  _QWORD v16[3];
  _QWORD v17[5];
  _QWORD v18[5];
  _QWORD v19[5];
  _QWORD v20[5];
  _QWORD v21[5];
  _QWORD v22[5];
  _QWORD v23[5];
  _QWORD v24[5];
  _QWORD v25[5];
  _QWORD v26[5];
  _QWORD v27[5];
  _QWORD v28[5];
  _QWORD v29[5];
  _QWORD v30[5];
  _QWORD *v31;
  uint8_t v32[8];
  uint64_t v33;
  void *v34;
  void *v35;
  uint64_t v36;
  void **v37;
  void *__p;
  void *v39;
  void *v40;
  uint8_t buf[4];
  uint64_t v42;
  void *v43[3];
  char v44;
  void *v45;
  void *v46;
  char v47;
  void *v48;
  _BYTE v49[19];
  char v50;
  char v51;
  char v52;
  uint64_t v53;

  v53 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 + 32);
  v4 = *(_DWORD *)(a2 + 4);
  if (v4)
  {
    v5 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315138;
      v42 = qmi::asString();
      _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#N Unable to send activation manifest: %s", buf, 0xCu);
      v4 = *(_DWORD *)(a2 + 4);
    }
    if (v4 == 65537)
    {
      v6 = 0x100000001;
    }
    else if (qmi::isInternalError())
    {
      v6 = 0x400000001;
    }
    else
    {
      v6 = 1;
    }
    (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(v3 + 48) + 24))(*(_QWORD *)(v3 + 48), v6);
    return;
  }
  bzero(buf, 0x210uLL);
  MEMORY[0x2199FD78C](buf);
  v7 = MEMORY[0x24BDAC760];
  v18[0] = MEMORY[0x24BDAC760];
  v18[1] = 0x40000000;
  v18[2] = ___ZL21parseActivationStatusIN3bsp22SendActivationManifest8ResponseEEN5boost8optionalIN23ActivationCommandDriver13ResponseErrorEEEPKN3ctu11OsLogLoggerER14ActivationInfoRKT__block_invoke;
  v18[3] = &__block_descriptor_tmp_22_18;
  v18[4] = buf;
  *(_QWORD *)v32 = v18;
  v8 = (os_log_t *)(v3 + 40);
  if ((qmi::MessageBase::applyTlv<bsp::tlv::ActivationProvisioningStatus,void({block_pointer}&)(bsp::tlv::ActivationProvisioningStatus const&)>((qmi::MessageBase *)a2, v32) & 1) != 0)
  {
    v17[0] = v7;
    v17[1] = 0x40000000;
    v17[2] = ___ZL21parseActivationStatusIN3bsp22SendActivationManifest8ResponseEEN5boost8optionalIN23ActivationCommandDriver13ResponseErrorEEEPKN3ctu11OsLogLoggerER14ActivationInfoRKT__block_invoke_23;
    v17[3] = &__block_descriptor_tmp_25_12;
    v17[4] = buf;
    *(_QWORD *)v32 = v17;
    if ((qmi::MessageBase::applyTlv<bsp::tlv::ActivationInfo,void({block_pointer}&)(bsp::tlv::ActivationInfo const&)>((qmi::MessageBase *)a2, (uint64_t)v32) & 1) != 0)
    {
      v9 = *(_QWORD *)(a2 + 8);
      v16[0] = *(_QWORD *)a2;
      v16[1] = v9;
      v10 = *(_QWORD *)(a2 + 16);
      v16[2] = v10;
      if (v10)
      {
        v11 = (unint64_t *)(v10 + 8);
        do
          v12 = __ldxr(v11);
        while (__stxr(v12 + 1, v11));
      }
      v30[0] = v7;
      v30[1] = 0x40000000;
      v30[2] = ___ZL17parseOptionalTLVsIN3bsp22SendActivationManifest8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke;
      v30[3] = &__block_descriptor_tmp_26_11;
      v30[4] = v43;
      *(_QWORD *)v32 = v30;
      qmi::MessageBase::applyTlv<bsp::tlv::ActivationRootManifestHash,void({block_pointer}&)(bsp::tlv::ActivationRootManifestHash const&)>((qmi::MessageBase *)v16, (uint64_t)v32);
      v29[0] = v7;
      v29[1] = 0x40000000;
      v29[2] = ___ZL17parseOptionalTLVsIN3bsp22SendActivationManifest8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_2;
      v29[3] = &__block_descriptor_tmp_27_13;
      v29[4] = v43;
      *(_QWORD *)v32 = v29;
      qmi::MessageBase::applyTlv<bsp::tlv::ActivationPublicKeyHash,void({block_pointer}&)(bsp::tlv::ActivationPublicKeyHash const&)>((qmi::MessageBase *)v16, 7, (uint64_t)v32);
      v28[0] = v7;
      v28[1] = 0x40000000;
      v28[2] = ___ZL17parseOptionalTLVsIN3bsp22SendActivationManifest8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_3;
      v28[3] = &__block_descriptor_tmp_28_14;
      v28[4] = v43;
      *(_QWORD *)v32 = v28;
      qmi::MessageBase::applyTlv<bsp::tlv::ActivationFactoryKeyHash,void({block_pointer}&)(bsp::tlv::ActivationFactoryKeyHash const&)>((qmi::MessageBase *)v16, 16, (uint64_t)v32);
      v27[0] = v7;
      v27[1] = 0x40000000;
      v27[2] = ___ZL17parseOptionalTLVsIN3bsp22SendActivationManifest8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_4;
      v27[3] = &__block_descriptor_tmp_29_6;
      v27[4] = buf;
      *(_QWORD *)v32 = v27;
      qmi::MessageBase::applyTlv<bsp::tlv::ActivationImei,void({block_pointer}&)(bsp::tlv::ActivationImei const&)>((qmi::MessageBase *)v16, 17, (uint64_t)v32);
      v26[0] = v7;
      v26[1] = 0x40000000;
      v26[2] = ___ZL17parseOptionalTLVsIN3bsp22SendActivationManifest8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_5;
      v26[3] = &__block_descriptor_tmp_30_9;
      v26[4] = v43;
      *(_QWORD *)v32 = v26;
      qmi::MessageBase::applyTlv<bsp::tlv::ActivationMeid,void({block_pointer}&)(bsp::tlv::ActivationMeid const&)>((qmi::MessageBase *)v16, 18, v32);
      v25[0] = v7;
      v25[1] = 0x40000000;
      v25[2] = ___ZL17parseOptionalTLVsIN3bsp22SendActivationManifest8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_6;
      v25[3] = &__block_descriptor_tmp_31_5;
      v25[4] = v49;
      *(_QWORD *)v32 = v25;
      qmi::MessageBase::applyTlv<bsp::tlv::ActivationImsi,void({block_pointer}&)(bsp::tlv::ActivationImsi const&)>((qmi::MessageBase *)v16, (uint64_t)v32);
      *(_QWORD *)v32 = v7;
      v33 = 0x40000000;
      v34 = ___ZL17parseOptionalTLVsIN3bsp22SendActivationManifest8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_7;
      v35 = &__block_descriptor_tmp_33_11;
      v36 = v3 + 40;
      v37 = &v48;
      v24[0] = v32;
      qmi::MessageBase::applyTlv<bsp::tlv::ActivationType,void({block_pointer}&)(bsp::tlv::ActivationType const&)>((qmi::MessageBase *)v16, (uint64_t)v24);
      v24[0] = v7;
      v24[1] = 0x40000000;
      v24[2] = ___ZL17parseOptionalTLVsIN3bsp22SendActivationManifest8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_34;
      v24[3] = &__block_descriptor_tmp_35_9;
      v24[4] = v49;
      v23[0] = v24;
      qmi::MessageBase::applyTlv<bsp::tlv::ActivationIccid,void({block_pointer}&)(bsp::tlv::ActivationIccid const&)>((qmi::MessageBase *)v16, (uint64_t)v23);
      v23[0] = v7;
      v23[1] = 0x40000000;
      v23[2] = ___ZL17parseOptionalTLVsIN3bsp22SendActivationManifest8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_2_36;
      v23[3] = &__block_descriptor_tmp_37_12;
      v23[4] = v49;
      v22[0] = v23;
      qmi::MessageBase::applyTlv<bsp::tlv::ActivationGid1,void({block_pointer}&)(bsp::tlv::ActivationGid1 const&)>((qmi::MessageBase *)v16, (uint64_t)v22);
      v22[0] = v7;
      v22[1] = 0x40000000;
      v22[2] = ___ZL17parseOptionalTLVsIN3bsp22SendActivationManifest8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_3_38;
      v22[3] = &__block_descriptor_tmp_39_10;
      v22[4] = v49;
      v21[0] = v22;
      qmi::MessageBase::applyTlv<bsp::tlv::ActivationGid2,void({block_pointer}&)(bsp::tlv::ActivationGid2 const&)>((qmi::MessageBase *)v16, (uint64_t)v21);
      v21[0] = v7;
      v21[1] = 0x40000000;
      v21[2] = ___ZL17parseOptionalTLVsIN3bsp22SendActivationManifest8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_4_40;
      v21[3] = &__block_descriptor_tmp_42_10;
      v21[4] = buf;
      v20[0] = v21;
      qmi::MessageBase::applyTlv<bsp::tlv::ActivationVersion,void({block_pointer}&)(bsp::tlv::ActivationVersion const&)>((qmi::MessageBase *)v16, 23, (uint64_t)v20);
      v20[0] = v7;
      v20[1] = 0x40000000;
      v20[2] = ___ZL17parseOptionalTLVsIN3bsp22SendActivationManifest8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_5_43;
      v20[3] = &__block_descriptor_tmp_45_8;
      v20[4] = buf;
      v19[0] = v20;
      qmi::MessageBase::applyTlv<bsp::tlv::ActivationMode,void({block_pointer}&)(bsp::tlv::ActivationMode const&)>((qmi::MessageBase *)v16, 25, (uint64_t)v19);
      v19[0] = v7;
      v19[1] = 0x40000000;
      v19[2] = ___ZL17parseOptionalTLVsIN3bsp22SendActivationManifest8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_6_46;
      v19[3] = &__block_descriptor_tmp_48_10;
      v19[4] = buf;
      v31 = v19;
      qmi::MessageBase::applyTlv<bsp::tlv::ActivationFactoryDebug,void({block_pointer}&)(bsp::tlv::ActivationFactoryDebug const&)>((qmi::MessageBase *)v16, 26, (uint64_t)&v31);
      v51 = v50;
      v52 = v50;
      v47 = v44;
      qmi::MessageBase::~MessageBase((qmi::MessageBase *)v16);
      v13 = *(_QWORD *)(v3 + 48);
      ActivationInfo::ActivationInfo((ActivationInfo *)v32, (const ActivationInfo *)buf);
      (*(void (**)(uint64_t, uint8_t *))(*(_QWORD *)v13 + 40))(v13, v32);
      UMTSProvisioningInfo::~UMTSProvisioningInfo(&v40);
      if (__p)
      {
        v39 = __p;
        operator delete(__p);
      }
      if (v34)
      {
        v35 = v34;
        operator delete(v34);
      }
      goto LABEL_25;
    }
    v14 = *v8;
    if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v32 = 0;
      v15 = "#I Missing activation info TLV!";
      goto LABEL_23;
    }
  }
  else
  {
    v14 = *v8;
    if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v32 = 0;
      v15 = "#N Missing activation provisioning status TLV!";
LABEL_23:
      _os_log_impl(&dword_216897000, v14, OS_LOG_TYPE_DEFAULT, v15, v32, 2u);
    }
  }
  (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(v3 + 48) + 24))(*(_QWORD *)(v3 + 48), 0x200000001);
LABEL_25:
  UMTSProvisioningInfo::~UMTSProvisioningInfo(&v48);
  if (v45)
  {
    v46 = v45;
    operator delete(v45);
  }
  if (v43[0])
  {
    v43[1] = v43[0];
    operator delete(v43[0]);
  }
}

void sub_216A600DC(_Unwind_Exception *a1)
{
  uint64_t v1;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  UMTSProvisioningInfo::~UMTSProvisioningInfo((void **)(v1 + 96));
  v3 = (void *)STACK[0x280];
  if (STACK[0x280])
  {
    STACK[0x288] = (unint64_t)v3;
    operator delete(v3);
  }
  v4 = (void *)STACK[0x260];
  if (STACK[0x260])
  {
    STACK[0x268] = (unint64_t)v4;
    operator delete(v4);
  }
  UMTSProvisioningInfo::~UMTSProvisioningInfo((void **)&STACK[0x4C0]);
  v5 = (void *)STACK[0x490];
  if (STACK[0x490])
  {
    STACK[0x498] = (unint64_t)v5;
    operator delete(v5);
  }
  v6 = (void *)STACK[0x470];
  if (STACK[0x470])
  {
    STACK[0x478] = (unint64_t)v6;
    operator delete(v6);
  }
  _Unwind_Resume(a1);
}

void QMIActivationCommandDriver::queryActivationStatus(QMIActivationCommandDriver *this)
{
  NSObject *v2;
  uint64_t v3;
  void *v4;
  void *v5;
  _QWORD v6[5];
  _OWORD v7[2];
  _QWORD v8[5];
  char *v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  void *aBlock;
  uint8_t v14[32];
  uint8_t buf[8];
  uint64_t v16;
  void *v17;
  void *v18;
  _QWORD *v19;

  v2 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_216897000, v2, OS_LOG_TYPE_DEFAULT, "#I Asking baseband for postponement state", buf, 2u);
  }
  memset(v14, 0, sizeof(v14));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v14);
  v9 = (char *)this + 88;
  v10 = QMIServiceMsg::create();
  v11 = 25000;
  v12 = 0;
  aBlock = 0;
  v3 = MEMORY[0x24BDAC760];
  v8[0] = MEMORY[0x24BDAC760];
  v8[1] = 0x40000000;
  v8[2] = ___ZN26QMIActivationCommandDriver21queryActivationStatusEv_block_invoke;
  v8[3] = &__block_descriptor_tmp_11_14;
  v8[4] = this;
  *(_QWORD *)buf = MEMORY[0x24BDAC760];
  v16 = 0x40000000;
  v17 = ___ZNO3qmi6Client9SendProxy8callbackIRKN3bsp21GetChipIdSerialNumber8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke_0;
  v18 = &unk_24D5E6F30;
  v19 = v8;
  v4 = _Block_copy(buf);
  aBlock = v4;
  if (v10)
  {
    qmi::Client::send();
    v4 = aBlock;
  }
  if (v4)
    _Block_release(v4);
  memset(v7, 0, sizeof(v7));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v7);
  v9 = (char *)this + 88;
  v10 = QMIServiceMsg::create();
  v11 = 25000;
  v12 = 0;
  aBlock = 0;
  v6[0] = v3;
  v6[1] = 0x40000000;
  v6[2] = ___ZN26QMIActivationCommandDriver21queryActivationStatusEv_block_invoke_2;
  v6[3] = &__block_descriptor_tmp_12_18;
  v6[4] = this;
  *(_QWORD *)buf = v3;
  v16 = 0x40000000;
  v17 = ___ZNO3qmi6Client9SendProxy8callbackIRKN3bsp18GetActivationState8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
  v18 = &unk_24D5E6F58;
  v19 = v6;
  v5 = _Block_copy(buf);
  aBlock = v5;
  if (v10)
  {
    qmi::Client::send();
    v5 = aBlock;
  }
  if (v5)
    _Block_release(v5);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v7);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v14);
}

void sub_216A60334(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v7;
  uint64_t v9;
  va_list va;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  va_list va1;

  va_start(va1, a7);
  va_start(va, a7);
  v9 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  v18 = va_arg(va1, _QWORD);
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)va1);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)(v7 - 128));
  _Unwind_Resume(a1);
}

void ___ZN26QMIActivationCommandDriver21queryActivationStatusEv_block_invoke(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v2;
  NSObject *v3;
  NSObject *v4;
  uint8_t v5[16];
  __int128 buf;
  void (*v7)(uint64_t, int *);
  void *v8;
  uint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)a2 + 1))
  {
    v3 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 136315138;
      *(_QWORD *)((char *)&buf + 4) = qmi::asString();
      _os_log_impl(&dword_216897000, v3, OS_LOG_TYPE_DEFAULT, "#N Unable to get chip id and serial number: %s", (uint8_t *)&buf, 0xCu);
    }
    (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)(v2 + 48) + 24))(*(_QWORD *)(v2 + 48), 0);
  }
  else
  {
    *(_QWORD *)&buf = MEMORY[0x24BDAC760];
    *((_QWORD *)&buf + 1) = 0x40000000;
    v7 = ___ZN26QMIActivationCommandDriver35handleChipIdAndSerialNumberResponseERKN3bsp21GetChipIdSerialNumber8ResponseE_block_invoke;
    v8 = &__block_descriptor_tmp_15_25;
    v9 = v2;
    *(_QWORD *)v5 = &buf;
    if ((qmi::MessageBase::applyTlv<bsp::tlv::ChipInformation,void({block_pointer}&)(bsp::tlv::ChipInformation const&)>(a2, 1, v5) & 1) == 0)
    {
      v4 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)v5 = 0;
        _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#N Missing chip id and serial number", v5, 2u);
      }
    }
  }
}

void ___ZN26QMIActivationCommandDriver21queryActivationStatusEv_block_invoke_2(uint64_t a1, unsigned __int16 *a2)
{
  uint64_t v3;
  int v4;
  NSObject *v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t TlvValue;
  int v9;
  uint64_t v10;
  int v11;
  _BYTE *v12;
  uint64_t v13;
  os_log_t *v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  char v19;
  uint64_t v20;
  NSObject *v21;
  const char *v22;
  _QWORD v23[2];
  _QWORD *(*v24)(uint64_t, uint64_t);
  void *v25;
  uint8_t *v26;
  _QWORD v27[3];
  _QWORD v28[5];
  _QWORD v29[5];
  _QWORD v30[5];
  _QWORD v31[5];
  _QWORD v32[5];
  _QWORD v33[5];
  _QWORD v34[5];
  _QWORD v35[5];
  _QWORD v36[5];
  _QWORD v37[5];
  _QWORD v38[5];
  _QWORD v39[5];
  _QWORD v40[5];
  unint64_t v41[5];
  _QWORD *v42;
  uint8_t v43[8];
  uint64_t v44;
  __int128 v45;
  uint64_t v46;
  _BYTE *v47;
  void *__p;
  void *v49;
  void *v50;
  uint8_t buf[8];
  __int128 v52;
  __n128 (*v53)(uint64_t, uint64_t);
  void (*v54)(uint64_t);
  _BYTE v55[16];
  void *v56;
  void *v57;
  void *v58;
  void *v59;
  void *v60[55];

  v60[54] = *(void **)MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 + 32);
  v4 = *((_DWORD *)a2 + 1);
  if (v4)
  {
    v5 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109378;
      *(_DWORD *)&buf[4] = v4;
      LOWORD(v52) = 2080;
      *(_QWORD *)((char *)&v52 + 2) = qmi::asString();
      _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#N Unable to get baseband postponement state: %d (%s)", buf, 0x12u);
      v4 = *((_DWORD *)a2 + 1);
    }
    if (v4 == 65537)
    {
      v6 = 0x100000001;
    }
    else if (qmi::isInternalError())
    {
      v6 = 0x400000001;
    }
    else
    {
      v6 = 1;
    }
    (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(v3 + 48) + 24))(*(_QWORD *)(v3 + 48), v6);
    return;
  }
  *(_QWORD *)buf = 0;
  *(_QWORD *)&v52 = buf;
  *((_QWORD *)&v52 + 1) = 0x23802000000;
  v53 = __Block_byref_object_copy__9;
  v54 = __Block_byref_object_dispose__9;
  bzero(v55, 0x210uLL);
  MEMORY[0x2199FD78C](v55);
  v7 = MEMORY[0x24BDAC760];
  v23[0] = MEMORY[0x24BDAC760];
  v23[1] = 0x40000000;
  v24 = ___ZN26QMIActivationCommandDriver29handleActivationStateResponseERKN3bsp18GetActivationState8ResponseE_block_invoke;
  v25 = &unk_24D5E6E60;
  v26 = buf;
  TlvValue = qmi::MessageBase::findTlvValue((qmi::MessageBase *)a2);
  v10 = TlvValue;
  if (TlvValue)
  {
    v11 = v9;
    v41[0] = TlvValue;
    v44 = 0;
    *(_QWORD *)v43 = 0;
    *(_DWORD *)((char *)&v45 + 7) = 0;
    *(_QWORD *)&v45 = 0;
    tlv::parseV<bsp::tlv::ActivationProvisioningInfo>(v41, v9, (uint64_t)v43);
    if (v41[0])
      v24((uint64_t)v23, (uint64_t)v43);
    else
      ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*a2, 5, v10, v11);
  }
  v12 = (_BYTE *)v52;
  v13 = v52 + 40;
  v29[0] = v7;
  v29[1] = 0x40000000;
  v29[2] = ___ZL21parseActivationStatusIN3bsp18GetActivationState8ResponseEEN5boost8optionalIN23ActivationCommandDriver13ResponseErrorEEEPKN3ctu11OsLogLoggerER14ActivationInfoRKT__block_invoke;
  v29[3] = &__block_descriptor_tmp_51_8;
  v29[4] = v52 + 40;
  *(_QWORD *)v43 = v29;
  v14 = (os_log_t *)(v3 + 40);
  if ((qmi::MessageBase::applyTlv<bsp::tlv::ActivationProvisioningStatus,void({block_pointer}&)(bsp::tlv::ActivationProvisioningStatus const&)>((qmi::MessageBase *)a2, v43) & 1) != 0)
  {
    v28[0] = v7;
    v28[1] = 0x40000000;
    v28[2] = ___ZL21parseActivationStatusIN3bsp18GetActivationState8ResponseEEN5boost8optionalIN23ActivationCommandDriver13ResponseErrorEEEPKN3ctu11OsLogLoggerER14ActivationInfoRKT__block_invoke_53;
    v28[3] = &__block_descriptor_tmp_54_7;
    v28[4] = v13;
    *(_QWORD *)v43 = v28;
    if ((qmi::MessageBase::applyTlv<bsp::tlv::ActivationInfo,void({block_pointer}&)(bsp::tlv::ActivationInfo const&)>((qmi::MessageBase *)a2, (uint64_t)v43) & 1) != 0)
    {
      v15 = *((_QWORD *)a2 + 1);
      v27[0] = *(_QWORD *)a2;
      v27[1] = v15;
      v16 = *((_QWORD *)a2 + 2);
      v27[2] = v16;
      if (v16)
      {
        v17 = (unint64_t *)(v16 + 8);
        do
          v18 = __ldxr(v17);
        while (__stxr(v18 + 1, v17));
      }
      v41[0] = v7;
      v41[1] = 0x40000000;
      v41[2] = (unint64_t)___ZL17parseOptionalTLVsIN3bsp18GetActivationState8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke;
      v41[3] = (unint64_t)&__block_descriptor_tmp_56_6;
      v41[4] = (unint64_t)(v12 + 56);
      *(_QWORD *)v43 = v41;
      qmi::MessageBase::applyTlv<bsp::tlv::ActivationRootManifestHash,void({block_pointer}&)(bsp::tlv::ActivationRootManifestHash const&)>((qmi::MessageBase *)v27, (uint64_t)v43);
      v40[0] = v7;
      v40[1] = 0x40000000;
      v40[2] = ___ZL17parseOptionalTLVsIN3bsp18GetActivationState8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_2;
      v40[3] = &__block_descriptor_tmp_57_6;
      v40[4] = v12 + 56;
      *(_QWORD *)v43 = v40;
      qmi::MessageBase::applyTlv<bsp::tlv::ActivationPublicKeyHash,void({block_pointer}&)(bsp::tlv::ActivationPublicKeyHash const&)>((qmi::MessageBase *)v27, 7, (uint64_t)v43);
      v39[0] = v7;
      v39[1] = 0x40000000;
      v39[2] = ___ZL17parseOptionalTLVsIN3bsp18GetActivationState8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_3;
      v39[3] = &__block_descriptor_tmp_58_5;
      v39[4] = v12 + 56;
      *(_QWORD *)v43 = v39;
      qmi::MessageBase::applyTlv<bsp::tlv::ActivationFactoryKeyHash,void({block_pointer}&)(bsp::tlv::ActivationFactoryKeyHash const&)>((qmi::MessageBase *)v27, 16, (uint64_t)v43);
      v38[0] = v7;
      v38[1] = 0x40000000;
      v38[2] = ___ZL17parseOptionalTLVsIN3bsp18GetActivationState8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_4;
      v38[3] = &__block_descriptor_tmp_59_8;
      v38[4] = v13;
      *(_QWORD *)v43 = v38;
      qmi::MessageBase::applyTlv<bsp::tlv::ActivationImei,void({block_pointer}&)(bsp::tlv::ActivationImei const&)>((qmi::MessageBase *)v27, 17, (uint64_t)v43);
      v37[0] = v7;
      v37[1] = 0x40000000;
      v37[2] = ___ZL17parseOptionalTLVsIN3bsp18GetActivationState8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_5;
      v37[3] = &__block_descriptor_tmp_60_7;
      v37[4] = v12 + 56;
      *(_QWORD *)v43 = v37;
      qmi::MessageBase::applyTlv<bsp::tlv::ActivationMeid,void({block_pointer}&)(bsp::tlv::ActivationMeid const&)>((qmi::MessageBase *)v27, 18, v43);
      v36[0] = v7;
      v36[1] = 0x40000000;
      v36[2] = ___ZL17parseOptionalTLVsIN3bsp18GetActivationState8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_6;
      v36[3] = &__block_descriptor_tmp_61_7;
      v36[4] = v12 + 144;
      *(_QWORD *)v43 = v36;
      qmi::MessageBase::applyTlv<bsp::tlv::ActivationImsi,void({block_pointer}&)(bsp::tlv::ActivationImsi const&)>((qmi::MessageBase *)v27, (uint64_t)v43);
      *(_QWORD *)v43 = v7;
      v44 = 0x40000000;
      *(_QWORD *)&v45 = ___ZL17parseOptionalTLVsIN3bsp18GetActivationState8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_7;
      *((_QWORD *)&v45 + 1) = &__block_descriptor_tmp_63_3;
      v46 = v3 + 40;
      v47 = v12 + 136;
      v35[0] = v43;
      qmi::MessageBase::applyTlv<bsp::tlv::ActivationType,void({block_pointer}&)(bsp::tlv::ActivationType const&)>((qmi::MessageBase *)v27, (uint64_t)v35);
      v35[0] = v7;
      v35[1] = 0x40000000;
      v35[2] = ___ZL17parseOptionalTLVsIN3bsp18GetActivationState8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_64;
      v35[3] = &__block_descriptor_tmp_65_6;
      v35[4] = v12 + 144;
      v34[0] = v35;
      qmi::MessageBase::applyTlv<bsp::tlv::ActivationIccid,void({block_pointer}&)(bsp::tlv::ActivationIccid const&)>((qmi::MessageBase *)v27, (uint64_t)v34);
      v34[0] = v7;
      v34[1] = 0x40000000;
      v34[2] = ___ZL17parseOptionalTLVsIN3bsp18GetActivationState8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_2_66;
      v34[3] = &__block_descriptor_tmp_67_9;
      v34[4] = v12 + 144;
      v33[0] = v34;
      qmi::MessageBase::applyTlv<bsp::tlv::ActivationGid1,void({block_pointer}&)(bsp::tlv::ActivationGid1 const&)>((qmi::MessageBase *)v27, (uint64_t)v33);
      v33[0] = v7;
      v33[1] = 0x40000000;
      v33[2] = ___ZL17parseOptionalTLVsIN3bsp18GetActivationState8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_3_68;
      v33[3] = &__block_descriptor_tmp_69_6;
      v33[4] = v12 + 144;
      v32[0] = v33;
      qmi::MessageBase::applyTlv<bsp::tlv::ActivationGid2,void({block_pointer}&)(bsp::tlv::ActivationGid2 const&)>((qmi::MessageBase *)v27, (uint64_t)v32);
      v32[0] = v7;
      v32[1] = 0x40000000;
      v32[2] = ___ZL17parseOptionalTLVsIN3bsp18GetActivationState8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_4_70;
      v32[3] = &__block_descriptor_tmp_71_4;
      v32[4] = v13;
      v31[0] = v32;
      qmi::MessageBase::applyTlv<bsp::tlv::ActivationVersion,void({block_pointer}&)(bsp::tlv::ActivationVersion const&)>((qmi::MessageBase *)v27, 23, (uint64_t)v31);
      v31[0] = v7;
      v31[1] = 0x40000000;
      v31[2] = ___ZL17parseOptionalTLVsIN3bsp18GetActivationState8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_5_72;
      v31[3] = &__block_descriptor_tmp_73_6;
      v31[4] = v13;
      v30[0] = v31;
      qmi::MessageBase::applyTlv<bsp::tlv::ActivationMode,void({block_pointer}&)(bsp::tlv::ActivationMode const&)>((qmi::MessageBase *)v27, 25, (uint64_t)v30);
      v30[0] = v7;
      v30[1] = 0x40000000;
      v30[2] = ___ZL17parseOptionalTLVsIN3bsp18GetActivationState8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_6_74;
      v30[3] = &__block_descriptor_tmp_75_5;
      v30[4] = v13;
      v42 = v30;
      qmi::MessageBase::applyTlv<bsp::tlv::ActivationFactoryDebug,void({block_pointer}&)(bsp::tlv::ActivationFactoryDebug const&)>((qmi::MessageBase *)v27, 26, (uint64_t)&v42);
      v19 = v12[163];
      v12[312] = v19;
      v12[496] = v19;
      v12[128] = v12[80];
      qmi::MessageBase::~MessageBase((qmi::MessageBase *)v27);
      v20 = *(_QWORD *)(v3 + 48);
      ActivationInfo::ActivationInfo((ActivationInfo *)v43, (const ActivationInfo *)(v52 + 40));
      (*(void (**)(uint64_t, uint8_t *))(*(_QWORD *)v20 + 40))(v20, v43);
      UMTSProvisioningInfo::~UMTSProvisioningInfo(&v50);
      if (__p)
      {
        v49 = __p;
        operator delete(__p);
      }
      if ((_QWORD)v45)
      {
        *((_QWORD *)&v45 + 1) = v45;
        operator delete((void *)v45);
      }
      goto LABEL_29;
    }
    v21 = *v14;
    if (os_log_type_enabled(*v14, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v43 = 0;
      v22 = "#I Missing activation info TLV!";
      goto LABEL_27;
    }
  }
  else
  {
    v21 = *v14;
    if (os_log_type_enabled(*v14, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v43 = 0;
      v22 = "#N Missing activation provisioning status TLV!";
LABEL_27:
      _os_log_impl(&dword_216897000, v21, OS_LOG_TYPE_DEFAULT, v22, v43, 2u);
    }
  }
  (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(v3 + 48) + 24))(*(_QWORD *)(v3 + 48), 0x200000001);
LABEL_29:
  _Block_object_dispose(buf, 8);
  UMTSProvisioningInfo::~UMTSProvisioningInfo(v60);
  if (v58)
  {
    v59 = v58;
    operator delete(v58);
  }
  if (v56)
  {
    v57 = v56;
    operator delete(v56);
  }
}

void sub_216A60B94(_Unwind_Exception *a1)
{
  uint64_t v1;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  UMTSProvisioningInfo::~UMTSProvisioningInfo((void **)(v1 + 96));
  v3 = (void *)STACK[0x2B0];
  if (STACK[0x2B0])
  {
    STACK[0x2B8] = (unint64_t)v3;
    operator delete(v3);
  }
  v4 = (void *)STACK[0x290];
  if (STACK[0x290])
  {
    STACK[0x298] = (unint64_t)v4;
    operator delete(v4);
  }
  _Block_object_dispose(&STACK[0x490], 8);
  UMTSProvisioningInfo::~UMTSProvisioningInfo((void **)&STACK[0x518]);
  v5 = (void *)STACK[0x4E8];
  if (STACK[0x4E8])
  {
    STACK[0x4F0] = (unint64_t)v5;
    operator delete(v5);
  }
  v6 = (void *)STACK[0x4C8];
  if (STACK[0x4C8])
  {
    STACK[0x4D0] = (unint64_t)v6;
    operator delete(v6);
  }
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__9(uint64_t a1, uint64_t a2)
{
  __int128 v2;
  __int128 v3;
  __int128 v4;
  uint64_t v5;
  __int128 v6;
  uint64_t v7;
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;
  __n128 result;
  __int128 v13;
  __int128 v14;

  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 56) = 0;
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
  *(_QWORD *)(a2 + 64) = 0;
  *(_QWORD *)(a2 + 72) = 0;
  *(_QWORD *)(a2 + 56) = 0;
  *(_BYTE *)(a1 + 80) = *(_BYTE *)(a2 + 80);
  *(_QWORD *)(a1 + 88) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 104) = 0;
  *(_OWORD *)(a1 + 88) = *(_OWORD *)(a2 + 88);
  *(_QWORD *)(a1 + 104) = *(_QWORD *)(a2 + 104);
  *(_QWORD *)(a2 + 88) = 0;
  *(_QWORD *)(a2 + 96) = 0;
  *(_QWORD *)(a2 + 104) = 0;
  *(_BYTE *)(a1 + 112) = *(_BYTE *)(a2 + 112);
  *(_QWORD *)(a1 + 120) = *(_QWORD *)(a2 + 120);
  *(_BYTE *)(a1 + 128) = *(_BYTE *)(a2 + 128);
  *(_WORD *)(a1 + 136) = *(_WORD *)(a2 + 136);
  v2 = *(_OWORD *)(a2 + 144);
  *(_DWORD *)(a1 + 160) = *(_DWORD *)(a2 + 160);
  *(_OWORD *)(a1 + 144) = v2;
  *(_QWORD *)(a1 + 176) = 0;
  *(_QWORD *)(a1 + 184) = 0;
  *(_QWORD *)(a1 + 168) = 0;
  *(_OWORD *)(a1 + 168) = *(_OWORD *)(a2 + 168);
  *(_QWORD *)(a1 + 184) = *(_QWORD *)(a2 + 184);
  *(_QWORD *)(a2 + 176) = 0;
  *(_QWORD *)(a2 + 184) = 0;
  *(_QWORD *)(a2 + 168) = 0;
  *(_BYTE *)(a1 + 192) = *(_BYTE *)(a2 + 192);
  *(_QWORD *)(a1 + 200) = 0;
  *(_QWORD *)(a1 + 208) = 0;
  *(_QWORD *)(a1 + 216) = 0;
  *(_OWORD *)(a1 + 200) = *(_OWORD *)(a2 + 200);
  *(_QWORD *)(a1 + 216) = *(_QWORD *)(a2 + 216);
  *(_QWORD *)(a2 + 200) = 0;
  *(_QWORD *)(a2 + 208) = 0;
  *(_QWORD *)(a2 + 216) = 0;
  *(_BYTE *)(a1 + 224) = *(_BYTE *)(a2 + 224);
  v3 = *(_OWORD *)(a2 + 232);
  *(_QWORD *)(a1 + 248) = *(_QWORD *)(a2 + 248);
  *(_OWORD *)(a1 + 232) = v3;
  *(_QWORD *)(a2 + 240) = 0;
  *(_QWORD *)(a2 + 248) = 0;
  *(_QWORD *)(a2 + 232) = 0;
  *(_BYTE *)(a1 + 256) = *(_BYTE *)(a2 + 256);
  v4 = *(_OWORD *)(a2 + 264);
  *(_QWORD *)(a1 + 280) = *(_QWORD *)(a2 + 280);
  *(_OWORD *)(a1 + 264) = v4;
  *(_QWORD *)(a2 + 272) = 0;
  *(_QWORD *)(a2 + 280) = 0;
  *(_QWORD *)(a2 + 264) = 0;
  *(_BYTE *)(a1 + 288) = *(_BYTE *)(a2 + 288);
  v5 = *(_QWORD *)(a2 + 296);
  *(_WORD *)(a1 + 304) = *(_WORD *)(a2 + 304);
  *(_QWORD *)(a1 + 296) = v5;
  *(_BYTE *)(a1 + 312) = *(_BYTE *)(a2 + 312);
  v6 = *(_OWORD *)(a2 + 320);
  *(_DWORD *)(a1 + 336) = *(_DWORD *)(a2 + 336);
  *(_OWORD *)(a1 + 320) = v6;
  *(_QWORD *)(a1 + 352) = 0;
  *(_QWORD *)(a1 + 360) = 0;
  *(_QWORD *)(a1 + 344) = 0;
  v7 = *(_QWORD *)(a2 + 352);
  *(_QWORD *)(a1 + 344) = *(_QWORD *)(a2 + 344);
  *(_QWORD *)(a1 + 352) = v7;
  *(_QWORD *)(a1 + 360) = *(_QWORD *)(a2 + 360);
  *(_QWORD *)(a2 + 352) = 0;
  *(_QWORD *)(a2 + 360) = 0;
  *(_QWORD *)(a2 + 344) = 0;
  *(_BYTE *)(a1 + 368) = *(_BYTE *)(a2 + 368);
  *(_QWORD *)(a1 + 384) = 0;
  *(_QWORD *)(a1 + 392) = 0;
  *(_QWORD *)(a1 + 376) = 0;
  v8 = *(_QWORD *)(a2 + 384);
  *(_QWORD *)(a1 + 376) = *(_QWORD *)(a2 + 376);
  *(_QWORD *)(a1 + 384) = v8;
  *(_QWORD *)(a1 + 392) = *(_QWORD *)(a2 + 392);
  *(_QWORD *)(a2 + 384) = 0;
  *(_QWORD *)(a2 + 392) = 0;
  *(_QWORD *)(a2 + 376) = 0;
  *(_BYTE *)(a1 + 400) = *(_BYTE *)(a2 + 400);
  v9 = *(_OWORD *)(a2 + 408);
  *(_QWORD *)(a1 + 424) = *(_QWORD *)(a2 + 424);
  *(_OWORD *)(a1 + 408) = v9;
  *(_QWORD *)(a2 + 416) = 0;
  *(_QWORD *)(a2 + 424) = 0;
  *(_QWORD *)(a2 + 408) = 0;
  *(_BYTE *)(a1 + 432) = *(_BYTE *)(a2 + 432);
  v10 = *(_OWORD *)(a2 + 440);
  *(_QWORD *)(a1 + 456) = *(_QWORD *)(a2 + 456);
  *(_OWORD *)(a1 + 440) = v10;
  *(_QWORD *)(a2 + 448) = 0;
  *(_QWORD *)(a2 + 456) = 0;
  *(_QWORD *)(a2 + 440) = 0;
  *(_BYTE *)(a1 + 464) = *(_BYTE *)(a2 + 464);
  v11 = *(_QWORD *)(a2 + 472);
  *(_WORD *)(a1 + 480) = *(_WORD *)(a2 + 480);
  *(_QWORD *)(a1 + 472) = v11;
  *(_BYTE *)(a1 + 488) = *(_BYTE *)(a2 + 488);
  *(_BYTE *)(a1 + 496) = *(_BYTE *)(a2 + 496);
  result = *(__n128 *)(a2 + 504);
  v13 = *(_OWORD *)(a2 + 520);
  v14 = *(_OWORD *)(a2 + 536);
  *(_OWORD *)(a1 + 549) = *(_OWORD *)(a2 + 549);
  *(_OWORD *)(a1 + 520) = v13;
  *(_OWORD *)(a1 + 536) = v14;
  *(__n128 *)(a1 + 504) = result;
  return result;
}

void __Block_byref_object_dispose__9(uint64_t a1)
{
  void *v2;
  void *v3;

  UMTSProvisioningInfo::~UMTSProvisioningInfo((void **)(a1 + 136));
  v2 = *(void **)(a1 + 88);
  if (v2)
  {
    *(_QWORD *)(a1 + 96) = v2;
    operator delete(v2);
  }
  v3 = *(void **)(a1 + 56);
  if (v3)
  {
    *(_QWORD *)(a1 + 64) = v3;
    operator delete(v3);
  }
}

void ___ZN26QMIActivationCommandDriver35handleChipIdAndSerialNumberResponseERKN3bsp21GetChipIdSerialNumber8ResponseE_block_invoke(uint64_t a1, int *a2)
{
  uint64_t v3;
  NSObject *v4;
  const void *v5;
  uint64_t v6;
  _BYTE *v7;
  unint64_t v9;
  char v10;
  uint64_t v12;
  uint64_t v13;
  void *__p;
  void *v15;
  uint64_t v16;
  char v17;
  int __src;
  uint8_t buf[16];
  __int128 v20;
  uint64_t v21;

  v3 = *(_QWORD *)(a1 + 32);
  v4 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I Reading chip id and serial number", buf, 2u);
  }
  v21 = 0;
  *(_OWORD *)buf = 0u;
  v20 = 0u;
  ChipInformation::ChipInformation((ChipInformation *)buf);
  __src = *a2;
  std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(&buf[8], (char *)&__src, (char *)buf, 4uLL);
  v5 = *(const void **)&buf[8];
  v6 = v20;
  v7 = (_BYTE *)(v20 - 1);
  if (*(_QWORD *)&buf[8] != (_QWORD)v20 && (unint64_t)v7 > *(_QWORD *)&buf[8])
  {
    v9 = *(_QWORD *)&buf[8] + 1;
    do
    {
      v10 = *(_BYTE *)(v9 - 1);
      *(_BYTE *)(v9 - 1) = *v7;
      *v7-- = v10;
    }
    while (v9++ < (unint64_t)v7);
    v5 = *(const void **)&buf[8];
    v6 = v20;
  }
  LOBYTE(v21) = 1;
  *(_DWORD *)buf = a2[1];
  buf[4] = 1;
  v12 = *(_QWORD *)(v3 + 48);
  v13 = *(_QWORD *)buf;
  __p = 0;
  v15 = 0;
  v16 = 0;
  std::vector<char>::__init_with_size[abi:ne180100]<char *,char *>(&__p, v5, v6, v6 - (_QWORD)v5);
  v17 = v21;
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v12 + 32))(v12, &v13);
  if (__p)
  {
    v15 = __p;
    operator delete(__p);
  }
  if (*(_QWORD *)&buf[8])
  {
    *(_QWORD *)&v20 = *(_QWORD *)&buf[8];
    operator delete(*(void **)&buf[8]);
  }
}

void sub_216A61048(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17)
{
  if (__p)
    operator delete(__p);
  if (a16)
    operator delete(a16);
  _Unwind_Resume(exception_object);
}

uint64_t *std::shared_ptr<QMIMav13ActivationCommandDriver>::shared_ptr[abi:ne180100]<QMIMav13ActivationCommandDriver,std::shared_ptr<QMIMav13ActivationCommandDriver> ctu::SharedSynchronizable<ActivationCommandDriver>::make_shared_ptr<QMIMav13ActivationCommandDriver>(QMIMav13ActivationCommandDriver*)::{lambda(QMIMav13ActivationCommandDriver*)#1},void>(uint64_t *a1, uint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24D5E6EB0;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = (uint64_t)v4;
  if (a2)
    v5 = (_QWORD *)(a2 + 8);
  else
    v5 = 0;
  std::shared_ptr<QMIDataSystemDeterminationManager>::__enable_weak_this[abi:ne180100]<QMIDataSystemDeterminationManager,QMIDataSystemDeterminationManager,void>((uint64_t)a1, v5, a2);
  return a1;
}

void sub_216A610E8(void *a1)
{
  dispatch_queue_t *v1;

  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)std::shared_ptr<QMIMav13ActivationCommandDriver> ctu::SharedSynchronizable<ActivationCommandDriver>::make_shared_ptr<QMIMav13ActivationCommandDriver>(QMIMav13ActivationCommandDriver*)::{lambda(QMIMav13ActivationCommandDriver*)#1}::operator() const(QMIMav13ActivationCommandDriver*)::{lambda(void *)#1}::__invoke);
  __cxa_rethrow();
}

void sub_216A61108(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<QMIMav13ActivationCommandDriver *,std::shared_ptr<QMIMav13ActivationCommandDriver> ctu::SharedSynchronizable<ActivationCommandDriver>::make_shared_ptr<QMIMav13ActivationCommandDriver>(QMIMav13ActivationCommandDriver*)::{lambda(QMIMav13ActivationCommandDriver *)#1},std::allocator<QMIMav13ActivationCommandDriver>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void std::__shared_ptr_pointer<QMIMav13ActivationCommandDriver *,std::shared_ptr<QMIMav13ActivationCommandDriver> ctu::SharedSynchronizable<ActivationCommandDriver>::make_shared_ptr<QMIMav13ActivationCommandDriver>(QMIMav13ActivationCommandDriver*)::{lambda(QMIMav13ActivationCommandDriver *)#1},std::allocator<QMIMav13ActivationCommandDriver>>::__on_zero_shared(uint64_t a1)
{
  dispatch_barrier_async_f(*(dispatch_queue_t *)(*(_QWORD *)(a1 + 24) + 24), *(void **)(a1 + 24), (dispatch_function_t)std::shared_ptr<QMIMav13ActivationCommandDriver> ctu::SharedSynchronizable<ActivationCommandDriver>::make_shared_ptr<QMIMav13ActivationCommandDriver>(QMIMav13ActivationCommandDriver*)::{lambda(QMIMav13ActivationCommandDriver*)#1}::operator() const(QMIMav13ActivationCommandDriver*)::{lambda(void *)#1}::__invoke);
}

uint64_t std::__shared_ptr_pointer<QMIMav13ActivationCommandDriver *,std::shared_ptr<QMIMav13ActivationCommandDriver> ctu::SharedSynchronizable<ActivationCommandDriver>::make_shared_ptr<QMIMav13ActivationCommandDriver>(QMIMav13ActivationCommandDriver*)::{lambda(QMIMav13ActivationCommandDriver *)#1},std::allocator<QMIMav13ActivationCommandDriver>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t std::shared_ptr<QMIMav13ActivationCommandDriver> ctu::SharedSynchronizable<ActivationCommandDriver>::make_shared_ptr<QMIMav13ActivationCommandDriver>(QMIMav13ActivationCommandDriver*)::{lambda(QMIMav13ActivationCommandDriver*)#1}::operator() const(QMIMav13ActivationCommandDriver*)::{lambda(void *)#1}::__invoke(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3bsp22SendActivationManifest8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A61268(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3bsp21GetChipIdSerialNumber8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke_0(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BYTE v3[24];

  v2 = *(_QWORD *)(a1 + 32);
  cast_message_type<bsp::GetChipIdSerialNumber::Response const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_216A612F0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3bsp18GetActivationState8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A613C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

uint64_t ___ZL21parseActivationStatusIN3bsp22SendActivationManifest8ResponseEEN5boost8optionalIN23ActivationCommandDriver13ResponseErrorEEEPKN3ctu11OsLogLoggerER14ActivationInfoRKT__block_invoke(uint64_t result, unsigned __int16 *a2)
{
  uint64_t v2;
  int v3;
  char v4;

  v2 = *(_QWORD *)(result + 32);
  v3 = *((unsigned __int8 *)a2 + 2);
  *(_DWORD *)v2 = *a2;
  *(_DWORD *)(v2 + 4) = v3;
  if (*((_DWORD *)a2 + 1))
    v4 = 1;
  else
    v4 = 2;
  *(_BYTE *)(v2 + 8) = v4;
  *(_BYTE *)(v2 + 12) = 1;
  return result;
}

uint64_t ___ZL21parseActivationStatusIN3bsp22SendActivationManifest8ResponseEEN5boost8optionalIN23ActivationCommandDriver13ResponseErrorEEEPKN3ctu11OsLogLoggerER14ActivationInfoRKT__block_invoke_23(uint64_t result, _WORD *a2)
{
  uint64_t v2;
  unsigned int v3;

  v2 = *(_QWORD *)(result + 32);
  *(_WORD *)(v2 + 258) = *a2;
  v3 = (unsigned __int16)a2[1];
  *(_WORD *)(v2 + 256) = v3;
  *(_BYTE *)(v2 + 260) = 1;
  *(_BYTE *)(v2 + 272) = 1;
  if (v3 >= 0x3E8)
    return __TUAssertTrigger();
  return result;
}

uint64_t qmi::MessageBase::applyTlv<bsp::tlv::ActivationProvisioningStatus,void({block_pointer}&)(bsp::tlv::ActivationProvisioningStatus const&)>(qmi::MessageBase *a1, _QWORD *a2)
{
  uint64_t result;
  int v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;

  result = qmi::MessageBase::findTlvValue(a1);
  if (result)
  {
    v6 = result;
    v7 = v5;
    v9 = result;
    v8 = tlv::parseV<bsp::tlv::ActivationProvisioningStatus>((unint64_t *)&v9, v5);
    if (v9)
    {
      (*(void (**)(_QWORD))(*a2 + 16))(*a2);
      return 1;
    }
    else
    {
      return ((uint64_t (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, 3, v6, v7);
    }
  }
  return result;
}

uint64_t qmi::MessageBase::applyTlv<bsp::tlv::ActivationInfo,void({block_pointer}&)(bsp::tlv::ActivationInfo const&)>(qmi::MessageBase *a1, uint64_t a2)
{
  uint64_t result;
  int v5;
  uint64_t v6;
  ActivationInfo *v7;
  uint64_t v8;
  int v9;
  int v10;
  __int16 v11;
  uint64_t v12;
  int v13;
  __int16 v14;
  bsp::tlv *v15;

  result = qmi::MessageBase::findTlvValue(a1);
  if (result)
  {
    v8 = result;
    v9 = v5;
    v15 = (bsp::tlv *)result;
    v12 = tlv::parseV<bsp::tlv::ActivationInfo>(&v15, v5, v6, v7);
    v13 = v10;
    v14 = v11;
    if (v15)
    {
      (*(void (**)(void))(*(_QWORD *)a2 + 16))();
      return 1;
    }
    else
    {
      return ((uint64_t (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, 4, v8, v9);
    }
  }
  return result;
}

uint64_t ___ZL17parseOptionalTLVsIN3bsp22SendActivationManifest8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_4(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t result;

  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 464) = *(_QWORD *)a2;
  result = ActivationCommandDriver::parseImei((ActivationCommandDriver *)(*(_QWORD *)(a1 + 32) + 464), a2);
  *(_BYTE *)(*(_QWORD *)(a1 + 32) + 472) = 1;
  return result;
}

uint64_t ___ZL17parseOptionalTLVsIN3bsp22SendActivationManifest8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_5(uint64_t result, int *a2)
{
  uint64_t v2;
  int v3;
  __int16 v4;

  v2 = *(_QWORD *)(result + 32);
  v3 = *a2;
  v4 = *((_WORD *)a2 + 2);
  *(_BYTE *)(v2 + 70) = *((_BYTE *)a2 + 6);
  *(_WORD *)(v2 + 68) = v4;
  *(_DWORD *)(v2 + 64) = v3;
  *(_BYTE *)(*(_QWORD *)(result + 32) + 71) = 1;
  return result;
}

uint64_t ___ZL17parseOptionalTLVsIN3bsp22SendActivationManifest8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_6(uint64_t result, _QWORD *a2)
{
  **(_QWORD **)(result + 32) = *a2;
  *(_BYTE *)(*(_QWORD *)(result + 32) + 8) = 1;
  return result;
}

void ___ZL17parseOptionalTLVsIN3bsp22SendActivationManifest8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_7(uint64_t a1, unsigned __int16 *a2)
{
  NSObject *v4;
  BOOL *v5;
  uint8_t v6[16];

  v4 = **(NSObject ***)(a1 + 32);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v6 = 0;
    _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I OQC activation mode detected, overriding IMSI", v6, 2u);
  }
  v5 = *(BOOL **)(a1 + 40);
  *v5 = *a2 == 1;
  v5[1] = 1;
}

uint64_t ___ZL17parseOptionalTLVsIN3bsp22SendActivationManifest8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_4_40(uint64_t result, _DWORD *a2)
{
  *(_DWORD *)(*(_QWORD *)(result + 32) + 482) = *a2;
  *(_BYTE *)(*(_QWORD *)(result + 32) + 486) = 1;
  return result;
}

uint64_t ___ZL17parseOptionalTLVsIN3bsp22SendActivationManifest8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_5_43(uint64_t result, unsigned __int8 *a2)
{
  int v2;
  uint64_t v3;

  v2 = *a2;
  if ((v2 - 1) <= 1)
  {
    v3 = *(_QWORD *)(result + 32);
    *(_DWORD *)(v3 + 488) = v2;
    *(_BYTE *)(v3 + 492) = 1;
  }
  return result;
}

uint64_t ___ZL17parseOptionalTLVsIN3bsp22SendActivationManifest8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_6_46(uint64_t result, unsigned __int8 *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 32);
  *(_DWORD *)(v2 + 496) = *a2;
  *(_BYTE *)(v2 + 500) = 1;
  return result;
}

void qmi::MessageBase::applyTlv<bsp::tlv::ActivationRootManifestHash,void({block_pointer}&)(bsp::tlv::ActivationRootManifestHash const&)>(qmi::MessageBase *a1, uint64_t a2)
{
  uint64_t TlvValue;
  int v5;
  uint64_t v6;
  int v7;
  unint64_t v8;
  unint64_t v9;
  __int128 v10;
  void *__p[2];
  __int128 v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  TlvValue = qmi::MessageBase::findTlvValue(a1);
  if (TlvValue)
  {
    v6 = TlvValue;
    v7 = v5;
    v9 = TlvValue;
    *(_OWORD *)__p = 0u;
    v12 = 0u;
    v10 = 0u;
    tlv::parseV<bsp::tlv::ActivationRootManifestHash>(&v9, v5, &v10);
    v8 = v9;
    if (v9)
      (*(void (**)(void))(*(_QWORD *)a2 + 16))();
    if (__p[1])
    {
      *(void **)&v12 = __p[1];
      operator delete(__p[1]);
    }
    if (!v8)
      ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, 6, v6, v7);
  }
}

void sub_216A619D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t qmi::MessageBase::applyTlv<bsp::tlv::ActivationImsi,void({block_pointer}&)(bsp::tlv::ActivationImsi const&)>(qmi::MessageBase *a1, uint64_t a2)
{
  uint64_t result;
  int v5;
  uint64_t v6;
  int v7;
  unint64_t v8[3];

  v8[2] = *MEMORY[0x24BDAC8D0];
  result = qmi::MessageBase::findTlvValue(a1);
  if (result)
  {
    v6 = result;
    v7 = v5;
    v8[0] = result;
    v8[1] = tlv::parseV<bsp::tlv::ActivationImsi>(v8, v5);
    if (v8[0])
      return (*(uint64_t (**)(void))(*(_QWORD *)a2 + 16))();
    else
      return ((uint64_t (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, 19, v6, v7);
  }
  return result;
}

uint64_t qmi::MessageBase::applyTlv<bsp::tlv::ActivationType,void({block_pointer}&)(bsp::tlv::ActivationType const&)>(qmi::MessageBase *a1, uint64_t a2)
{
  uint64_t result;
  int v5;
  uint64_t v6;
  int v7;
  __int16 v8;
  uint64_t v9;

  result = qmi::MessageBase::findTlvValue(a1);
  if (result)
  {
    v6 = result;
    v7 = v5;
    v9 = result;
    v8 = tlv::parseV<bsp::tlv::ActivationType>((unint64_t *)&v9, v5);
    if (v9)
      return (*(uint64_t (**)(void))(*(_QWORD *)a2 + 16))();
    else
      return ((uint64_t (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, 24, v6, v7);
  }
  return result;
}

void qmi::MessageBase::applyTlv<bsp::tlv::ActivationIccid,void({block_pointer}&)(bsp::tlv::ActivationIccid const&)>(qmi::MessageBase *a1, uint64_t a2)
{
  char *TlvValue;
  int v5;
  char *v6;
  int v7;
  char *v8;
  void *__p;
  void *v10;
  uint64_t v11;
  char *v12;

  TlvValue = (char *)qmi::MessageBase::findTlvValue(a1);
  if (TlvValue)
  {
    v6 = TlvValue;
    v7 = v5;
    v11 = 0;
    v12 = TlvValue;
    __p = 0;
    v10 = 0;
    tlv::parseV<bsp::tlv::ActivationIccid>(&v12, v5, &__p);
    v8 = v12;
    if (v12)
      (*(void (**)(void))(*(_QWORD *)a2 + 16))();
    if (__p)
    {
      v10 = __p;
      operator delete(__p);
    }
    if (!v8)
      ((void (*)(_QWORD, uint64_t, char *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, 22, v6, v7);
  }
}

void sub_216A61C30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void qmi::MessageBase::applyTlv<bsp::tlv::ActivationGid1,void({block_pointer}&)(bsp::tlv::ActivationGid1 const&)>(qmi::MessageBase *a1, uint64_t a2)
{
  char *TlvValue;
  int v5;
  char *v6;
  int v7;
  char *v8;
  void *__p;
  void *v10;
  uint64_t v11;
  char *v12;

  TlvValue = (char *)qmi::MessageBase::findTlvValue(a1);
  if (TlvValue)
  {
    v6 = TlvValue;
    v7 = v5;
    v11 = 0;
    v12 = TlvValue;
    __p = 0;
    v10 = 0;
    tlv::parseV<bsp::tlv::ActivationGid1>(&v12, v5, &__p);
    v8 = v12;
    if (v12)
      (*(void (**)(void))(*(_QWORD *)a2 + 16))();
    if (__p)
    {
      v10 = __p;
      operator delete(__p);
    }
    if (!v8)
      ((void (*)(_QWORD, uint64_t, char *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, 20, v6, v7);
  }
}

void sub_216A61D0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void qmi::MessageBase::applyTlv<bsp::tlv::ActivationGid2,void({block_pointer}&)(bsp::tlv::ActivationGid2 const&)>(qmi::MessageBase *a1, uint64_t a2)
{
  char *TlvValue;
  int v5;
  char *v6;
  int v7;
  char *v8;
  void *__p;
  void *v10;
  uint64_t v11;
  char *v12;

  TlvValue = (char *)qmi::MessageBase::findTlvValue(a1);
  if (TlvValue)
  {
    v6 = TlvValue;
    v7 = v5;
    v11 = 0;
    v12 = TlvValue;
    __p = 0;
    v10 = 0;
    tlv::parseV<bsp::tlv::ActivationGid2>(&v12, v5, &__p);
    v8 = v12;
    if (v12)
      (*(void (**)(void))(*(_QWORD *)a2 + 16))();
    if (__p)
    {
      v10 = __p;
      operator delete(__p);
    }
    if (!v8)
      ((void (*)(_QWORD, uint64_t, char *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, 21, v6, v7);
  }
}

void sub_216A61DE8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t ___ZL21parseActivationStatusIN3bsp18GetActivationState8ResponseEEN5boost8optionalIN23ActivationCommandDriver13ResponseErrorEEEPKN3ctu11OsLogLoggerER14ActivationInfoRKT__block_invoke(uint64_t result, unsigned __int16 *a2)
{
  uint64_t v2;
  int v3;
  char v4;

  v2 = *(_QWORD *)(result + 32);
  v3 = *((unsigned __int8 *)a2 + 2);
  *(_DWORD *)v2 = *a2;
  *(_DWORD *)(v2 + 4) = v3;
  if (*((_DWORD *)a2 + 1))
    v4 = 1;
  else
    v4 = 2;
  *(_BYTE *)(v2 + 8) = v4;
  *(_BYTE *)(v2 + 12) = 1;
  return result;
}

uint64_t ___ZL21parseActivationStatusIN3bsp18GetActivationState8ResponseEEN5boost8optionalIN23ActivationCommandDriver13ResponseErrorEEEPKN3ctu11OsLogLoggerER14ActivationInfoRKT__block_invoke_53(uint64_t result, _WORD *a2)
{
  uint64_t v2;
  unsigned int v3;

  v2 = *(_QWORD *)(result + 32);
  *(_WORD *)(v2 + 258) = *a2;
  v3 = (unsigned __int16)a2[1];
  *(_WORD *)(v2 + 256) = v3;
  *(_BYTE *)(v2 + 260) = 1;
  *(_BYTE *)(v2 + 272) = 1;
  if (v3 >= 0x3E8)
    return __TUAssertTrigger();
  return result;
}

uint64_t ___ZL17parseOptionalTLVsIN3bsp18GetActivationState8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_4(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t result;

  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 464) = *(_QWORD *)a2;
  result = ActivationCommandDriver::parseImei((ActivationCommandDriver *)(*(_QWORD *)(a1 + 32) + 464), a2);
  *(_BYTE *)(*(_QWORD *)(a1 + 32) + 472) = 1;
  return result;
}

uint64_t ___ZL17parseOptionalTLVsIN3bsp18GetActivationState8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_5(uint64_t result, int *a2)
{
  uint64_t v2;
  int v3;
  __int16 v4;

  v2 = *(_QWORD *)(result + 32);
  v3 = *a2;
  v4 = *((_WORD *)a2 + 2);
  *(_BYTE *)(v2 + 70) = *((_BYTE *)a2 + 6);
  *(_WORD *)(v2 + 68) = v4;
  *(_DWORD *)(v2 + 64) = v3;
  *(_BYTE *)(*(_QWORD *)(result + 32) + 71) = 1;
  return result;
}

uint64_t ___ZL17parseOptionalTLVsIN3bsp18GetActivationState8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_6(uint64_t result, _QWORD *a2)
{
  **(_QWORD **)(result + 32) = *a2;
  *(_BYTE *)(*(_QWORD *)(result + 32) + 8) = 1;
  return result;
}

void ___ZL17parseOptionalTLVsIN3bsp18GetActivationState8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_7(uint64_t a1, unsigned __int16 *a2)
{
  NSObject *v4;
  BOOL *v5;
  uint8_t v6[16];

  v4 = **(NSObject ***)(a1 + 32);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v6 = 0;
    _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I OQC activation mode detected, overriding IMSI", v6, 2u);
  }
  v5 = *(BOOL **)(a1 + 40);
  *v5 = *a2 == 1;
  v5[1] = 1;
}

uint64_t ___ZL17parseOptionalTLVsIN3bsp18GetActivationState8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_4_70(uint64_t result, _DWORD *a2)
{
  *(_DWORD *)(*(_QWORD *)(result + 32) + 482) = *a2;
  *(_BYTE *)(*(_QWORD *)(result + 32) + 486) = 1;
  return result;
}

uint64_t ___ZL17parseOptionalTLVsIN3bsp18GetActivationState8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_5_72(uint64_t result, unsigned __int8 *a2)
{
  int v2;
  uint64_t v3;

  v2 = *a2;
  if ((v2 - 1) <= 1)
  {
    v3 = *(_QWORD *)(result + 32);
    *(_DWORD *)(v3 + 488) = v2;
    *(_BYTE *)(v3 + 492) = 1;
  }
  return result;
}

uint64_t ___ZL17parseOptionalTLVsIN3bsp18GetActivationState8ResponseEEvPKN3ctu11OsLogLoggerER14ActivationInfoT__block_invoke_6_74(uint64_t result, unsigned __int8 *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 32);
  *(_DWORD *)(v2 + 496) = *a2;
  *(_BYTE *)(v2 + 500) = 1;
  return result;
}

uint64_t QMISuppServicesCommandDriver::mapQMIErrorToCSI(QMISuppServicesCommandDriver *this, int a2)
{
  NSObject *v4;
  NSObject *v5;
  NSObject *v7;
  _DWORD v8[2];
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v4 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v8[0] = 67109120;
    v8[1] = a2;
    _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I Failure cause provided in the response %d", (uint8_t *)v8, 8u);
  }
  if ((a2 - 129) >= 2)
  {
    if (a2)
    {
      v7 = *((_QWORD *)this + 5);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v8[0]) = 0;
        _os_log_impl(&dword_216897000, v7, OS_LOG_TYPE_DEFAULT, "#I Unknown Error", (uint8_t *)v8, 2u);
      }
    }
    return 1;
  }
  else
  {
    v5 = *((_QWORD *)this + 5);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v8[0]) = 0;
      _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#I Mapping to Incorrect Password", (uint8_t *)v8, 2u);
    }
    return 42;
  }
}

void QMISuppServicesCommandDriver::create(uint64_t a1@<X0>, dispatch_object_t *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v6;
  NSObject *v7;
  dispatch_object_t v8;

  v6 = operator new();
  v8 = *a2;
  v7 = v8;
  *a2 = 0;
  QMISuppServicesCommandDriver::QMISuppServicesCommandDriver(v6, a1, &v8);
  *a3 = 0;
  a3[1] = 0;
  std::shared_ptr<QMISuppServicesCommandDriver>::shared_ptr[abi:ne180100]<QMISuppServicesCommandDriver,std::shared_ptr<QMISuppServicesCommandDriver> ctu::SharedSynchronizable<SuppServicesCommandDriver>::make_shared_ptr<QMISuppServicesCommandDriver>(QMISuppServicesCommandDriver*)::{lambda(QMISuppServicesCommandDriver*)#1},void>(a3, v6);
  if (v7)
    dispatch_release(v7);
}

void sub_216A6235C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  NSObject *v2;
  int v3;

  if (v2)
    dispatch_release(v2);
  if (v3)
    MEMORY[0x2199FEAC4](v1, 0x10E1C40A824EF22);
  _Unwind_Resume(exception_object);
}

uint64_t QMISuppServicesCommandDriver::QMISuppServicesCommandDriver(uint64_t a1, uint64_t a2, dispatch_object_t *a3)
{
  capabilities::ct *v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  NSObject *object;
  _QWORD v17[3];
  _QWORD *v18;
  _BYTE v19[24];
  _BYTE *v20;
  _BYTE v21[24];
  _BYTE *v22;
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  object = *a3;
  if (*a3)
    dispatch_retain(*a3);
  SuppServicesCommandDriver::SuppServicesCommandDriver();
  if (object)
    dispatch_release(object);
  v17[0] = &unk_24D5CCF40;
  v18 = v17;
  v4 = (capabilities::ct *)std::__function::__value_func<char const* const ()(subscriber::SimSlot)>::__value_func[abi:ne180100]((uint64_t)v19, (uint64_t)v17);
  *(_QWORD *)(a1 + 80) = 0;
  if ((capabilities::ct::supportsGemini(v4) & 1) == 0)
  {
    v5 = (_QWORD *)operator new();
    *v5 = &off_24D5E7748;
    v5[1] = a1;
    v6 = *(_QWORD *)(a1 + 80);
    *(_QWORD *)(a1 + 80) = v5;
    if (!v6)
      goto LABEL_16;
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
  }
  if (!*(_QWORD *)(a1 + 80))
  {
    v7 = (_QWORD *)operator new();
    std::__function::__value_func<char const* const ()(subscriber::SimSlot)>::__value_func[abi:ne180100]((uint64_t)v21, (uint64_t)v19);
    SimInstanceLoggerDefault<ctu::OsLogLogger,subscriber::SimSlot,std::function<char const* const ()(subscriber::SimSlot)>>::SimInstanceLoggerDefault(v7);
    v8 = v22;
    if (v22 == v21)
    {
      v9 = 4;
      v8 = v21;
    }
    else
    {
      if (!v22)
        goto LABEL_14;
      v9 = 5;
    }
    (*(void (**)(void))(*v8 + 8 * v9))();
LABEL_14:
    v10 = *(_QWORD *)(a1 + 80);
    *(_QWORD *)(a1 + 80) = v7;
    if (v10)
      (*(void (**)(uint64_t))(*(_QWORD *)v10 + 8))(v10);
  }
LABEL_16:
  v11 = v20;
  if (v20 == v19)
  {
    v12 = 4;
    v11 = v19;
  }
  else
  {
    if (!v20)
      goto LABEL_21;
    v12 = 5;
  }
  (*(void (**)(void))(*v11 + 8 * v12))();
LABEL_21:
  v13 = v18;
  if (v18 == v17)
  {
    v14 = 4;
    v13 = v17;
    goto LABEL_25;
  }
  if (v18)
  {
    v14 = 5;
LABEL_25:
    (*(void (**)(void))(*v13 + 8 * v14))();
  }
  *(_QWORD *)a1 = &off_24D5E7360;
  *(_BYTE *)(a1 + 88) = 15;
  *(_QWORD *)(a1 + 96) = 0;
  qmi::ClientRouter::ClientRouter((qmi::ClientRouter *)(a1 + 104), *(os_log_s **)(a1 + 40));
  return a1;
}

void sub_216A625A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, char a14, uint64_t a15, uint64_t a16, char *a17, char a18, uint64_t a19, uint64_t a20,char *a21)
{
  SuppServicesCommandDriver *v21;
  uint64_t v22;
  char *v23;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;

  v25 = a21;
  if (a21 == v23)
  {
    v26 = 4;
    v25 = &a18;
  }
  else
  {
    if (!a21)
      goto LABEL_6;
    v26 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v25 + 8 * v26))();
LABEL_6:
  MEMORY[0x2199FEAC4](v22, 0x10A1C40FF1576FELL);
  v27 = *((_QWORD *)v21 + 10);
  *((_QWORD *)v21 + 10) = 0;
  if (v27)
    (*(void (**)(uint64_t))(*(_QWORD *)v27 + 8))(v27);
  v28 = a17;
  if (a17 == &a14)
  {
    v29 = 4;
    v28 = &a14;
  }
  else
  {
    if (!a17)
      goto LABEL_13;
    v29 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v28 + 8 * v29))();
LABEL_13:
  v30 = a13;
  if (a13 == &a10)
  {
    v31 = 4;
    v30 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_18;
    v31 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v30 + 8 * v31))();
LABEL_18:
  SuppServicesCommandDriver::~SuppServicesCommandDriver(v21);
  _Unwind_Resume(a1);
}

void sub_216A626AC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object)
{
  if (object)
    dispatch_release(object);
  JUMPOUT(0x216A626A4);
}

void QMISuppServicesCommandDriver::~QMISuppServicesCommandDriver(QMISuppServicesCommandDriver *this)
{
  NSObject *v2;
  uint64_t v3;

  *(_QWORD *)this = &off_24D5E7360;
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)this + 104);
  v2 = *((_QWORD *)this + 12);
  if (v2)
    dispatch_release(v2);
  v3 = *((_QWORD *)this + 10);
  *((_QWORD *)this + 10) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  SuppServicesCommandDriver::~SuppServicesCommandDriver(this);
}

{
  QMISuppServicesCommandDriver::~QMISuppServicesCommandDriver(this);
  JUMPOUT(0x2199FEAC4);
}

const char *QMISuppServicesCommandDriver::getName(QMISuppServicesCommandDriver *this)
{
  return "QMISuppServicesCommandDriver";
}

const char *QMISuppServicesCommandDriver::getTransportName(QMISuppServicesCommandDriver *this)
{
  return "Baseband";
}

void QMISuppServicesCommandDriver::bootstrap(_QWORD *a1, uint64_t *a2, dispatch_object_t *a3)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  NSObject *v8;
  std::__shared_weak_count *v9;
  uint64_t v10;
  std::__shared_weak_count *v11;
  std::__shared_weak_count *v12;
  _QWORD *v13;
  unint64_t *p_shared_owners;
  NSObject *v15;
  unint64_t v16;
  _QWORD *v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;

  v4 = *a2;
  v5 = a2[1];
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  v8 = *a3;
  if (*a3)
  {
    dispatch_retain(*a3);
    dispatch_group_enter(v8);
  }
  v9 = (std::__shared_weak_count *)a1[2];
  if (!v9 || (v10 = a1[1], (v11 = std::__shared_weak_count::lock(v9)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v12 = v11;
  v13 = (_QWORD *)operator new();
  *v13 = a1;
  v13[1] = v4;
  v13[2] = v5;
  v13[3] = v8;
  p_shared_owners = (unint64_t *)&v12->__shared_owners_;
  v15 = a1[3];
  do
    v16 = __ldxr(p_shared_owners);
  while (__stxr(v16 + 1, p_shared_owners));
  v17 = (_QWORD *)operator new();
  *v17 = v13;
  v17[1] = v10;
  v17[2] = v12;
  v19 = 0;
  v20 = 0;
  dispatch_async_f(v15, v17, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<SuppServicesCommandDriver>::execute_wrapped<QMISuppServicesCommandDriver::bootstrap(std::shared_ptr<SuppServicesDriverEventHandlerInterface>,dispatch::group_session)::$_0>(QMISuppServicesCommandDriver::bootstrap(std::shared_ptr<SuppServicesDriverEventHandlerInterface>,dispatch::group_session)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMISuppServicesCommandDriver::bootstrap(std::shared_ptr<SuppServicesDriverEventHandlerInterface>,dispatch::group_session)::$_0,std::default_delete<QMISuppServicesCommandDriver::bootstrap(std::shared_ptr<SuppServicesDriverEventHandlerInterface>,dispatch::group_session)::$_0>>)::{lambda(void *)#1}::__invoke);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v19);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v20);
  do
    v18 = __ldaxr(p_shared_owners);
  while (__stlxr(v18 - 1, p_shared_owners));
  if (!v18)
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
  }
}

void QMISuppServicesCommandDriver::start(QMISuppServicesCommandDriver *this)
{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  _QWORD *v6;
  NSObject *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v2 = (std::__shared_weak_count *)*((_QWORD *)this + 2);
  if (!v2 || (v3 = *((_QWORD *)this + 1), (v4 = std::__shared_weak_count::lock(v2)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v5 = v4;
  v6 = (_QWORD *)operator new();
  *v6 = this;
  v7 = *((_QWORD *)this + 3);
  p_shared_owners = (unint64_t *)&v5->__shared_owners_;
  do
    v9 = __ldxr(p_shared_owners);
  while (__stxr(v9 + 1, p_shared_owners));
  v10 = (_QWORD *)operator new();
  *v10 = v6;
  v10[1] = v3;
  v10[2] = v5;
  v12 = 0;
  v13 = 0;
  dispatch_async_f(v7, v10, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<SuppServicesCommandDriver>::execute_wrapped<QMISuppServicesCommandDriver::start(void)::$_0>(QMISuppServicesCommandDriver::start(void)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMISuppServicesCommandDriver::start(void)::$_0,dispatch_queue_s *::default_delete<QMISuppServicesCommandDriver::start(void)::$_0>>)::{lambda(void *)#1}::__invoke);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v12);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v13);
  do
    v11 = __ldaxr(p_shared_owners);
  while (__stlxr(v11 - 1, p_shared_owners));
  if (!v11)
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
}

uint64_t QMISuppServicesCommandDriver::stop()
{
  return qmi::ClientRouter::stop();
}

void QMISuppServicesCommandDriver::setAutoAnswerMode(uint64_t a1, int a2, char a3)
{
  const void **v6;
  char *v7;
  _BYTE *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  char *v16;
  uint64_t *v17;
  char *v18;
  char *v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _QWORD *v24;
  unint64_t *v25;
  uint64_t v26;
  unint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *p_shared_owners;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;
  void *__p[2];
  __int128 v37;
  _QWORD v38[5];
  std::__shared_weak_count *v39;
  char *v40;
  std::__shared_weak_count *v41;
  _QWORD aBlock[5];

  *(_OWORD *)__p = 0u;
  v37 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  v6 = (const void **)__p[1];
  if (__p[1] != (void *)v37)
  {
    while (*((_BYTE *)*v6 + 8) != 16)
    {
      if (++v6 == (const void **)v37)
        goto LABEL_8;
    }
  }
  if (v6 == (const void **)v37)
  {
LABEL_8:
    v9 = operator new();
    v10 = v9;
    *(_WORD *)(v9 + 8) = 16;
    *(_QWORD *)v9 = &off_24D5E78C8;
    v11 = v37;
    if ((unint64_t)v37 >= *((_QWORD *)&v37 + 1))
    {
      v13 = (uint64_t)(v37 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v13 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v14 = (uint64_t)(*((_QWORD *)&v37 + 1) - (unint64_t)__p[1]) >> 2;
      if (v14 <= v13 + 1)
        v14 = v13 + 1;
      if (*((_QWORD *)&v37 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v15 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v15 = v14;
      if (v15)
        v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v37 + 8, v15);
      else
        v16 = 0;
      v17 = (uint64_t *)&v16[8 * v13];
      v18 = &v16[8 * v15];
      *v17 = v10;
      v12 = v17 + 1;
      v20 = (char *)__p[1];
      v19 = (char *)v37;
      if ((void *)v37 != __p[1])
      {
        do
        {
          v21 = *((_QWORD *)v19 - 1);
          v19 -= 8;
          *--v17 = v21;
        }
        while (v19 != v20);
        v19 = (char *)__p[1];
      }
      __p[1] = v17;
      *(_QWORD *)&v37 = v12;
      *((_QWORD *)&v37 + 1) = v18;
      if (v19)
        operator delete(v19);
    }
    else
    {
      *(_QWORD *)v37 = v9;
      v12 = (_QWORD *)(v11 + 8);
    }
    v8 = (_BYTE *)(v10 + 9);
    *(_QWORD *)&v37 = v12;
  }
  else
  {
    if (!v7)
      __cxa_bad_cast();
    v8 = v7 + 9;
  }
  *v8 = a3;
  v22 = qmi::ClientRouter::get();
  v23 = operator new();
  *(_QWORD *)v23 = v22;
  *(_QWORD *)(v23 + 8) = QMIServiceMsg::create();
  *(_QWORD *)(v23 + 24) = 0;
  *(_QWORD *)(v23 + 32) = 0;
  v35 = v23;
  *(_DWORD *)(v23 + 16) = 120000;
  v24 = operator new(0x28uLL);
  v24[1] = 0;
  v25 = v24 + 1;
  v24[2] = 0;
  *v24 = &off_24D5E7930;
  v24[3] = a1;
  *((_DWORD *)v24 + 8) = a2;
  v40 = (char *)(v24 + 3);
  v41 = (std::__shared_weak_count *)v24;
  v26 = MEMORY[0x24BDAC760];
  v38[0] = MEMORY[0x24BDAC760];
  v38[1] = 1174405120;
  v38[2] = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMISuppServicesCommandDriver17setAutoAnswerModeEN10subscriber7SimSlotEbE3__0EEOS1_OT__block_invoke;
  v38[3] = &__block_descriptor_tmp_71_5;
  v38[4] = v24 + 3;
  v39 = (std::__shared_weak_count *)v24;
  do
    v27 = __ldxr(v25);
  while (__stxr(v27 + 1, v25));
  aBlock[0] = v26;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_30;
  aBlock[3] = &unk_24D5E7978;
  aBlock[4] = v38;
  *(_QWORD *)(v23 + 32) = _Block_copy(aBlock);
  v28 = v39;
  if (v39)
  {
    p_shared_owners = (unint64_t *)&v39->__shared_owners_;
    do
      v30 = __ldaxr(p_shared_owners);
    while (__stlxr(v30 - 1, p_shared_owners));
    if (!v30)
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
  }
  v31 = v41;
  if (v41)
  {
    v32 = (unint64_t *)&v41->__shared_owners_;
    do
      v33 = __ldaxr(v32);
    while (__stlxr(v33 - 1, v32));
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
      std::__shared_weak_count::__release_weak(v31);
    }
  }
  v34 = v35;
  v35 = 0;
  if (v34)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v35, v34);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
}

void sub_216A62D24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;
  va_list va;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v6 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v3);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  if (a3)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v4, a3);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

uint64_t QMISuppServicesCommandDriver::fetchCallForwarding(uint64_t a1, uint64_t a2, unsigned int a3, int a4)
{
  char *v8;
  char v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  unint64_t *v14;
  uint64_t v15;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *p_shared_owners;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v25;
  _OWORD v26[2];
  uint8_t buf[8];
  uint64_t v28;
  void (*v29)(uint64_t, _QWORD *);
  void *v30;
  char *v31;
  std::__shared_weak_count *v32;
  char *v33;
  std::__shared_weak_count *v34;
  _QWORD aBlock[5];

  memset(v26, 0, sizeof(v26));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v26);
  v8 = qmi::MutableMessageBase::getTLV<vs::tlv::Reason>(v26);
  if (a3 < 6)
    v9 = a3 + 1;
  else
    v9 = 0;
  *v8 = v9;
  if (a4)
  {
    *qmi::MutableMessageBase::getTLV<vs::tlv::ServiceClass>(v26) = a4;
  }
  else
  {
    v10 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 80) + 16))(*(_QWORD *)(a1 + 80), a2);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_216897000, v10, OS_LOG_TYPE_DEFAULT, "#I Call class is not available, not setting it", buf, 2u);
    }
  }
  v11 = qmi::ClientRouter::get();
  v12 = operator new();
  *(_QWORD *)v12 = v11;
  *(_QWORD *)(v12 + 8) = QMIServiceMsg::create();
  *(_QWORD *)(v12 + 24) = 0;
  *(_QWORD *)(v12 + 32) = 0;
  v25 = v12;
  *(_DWORD *)(v12 + 16) = 120000;
  v13 = operator new(0x30uLL);
  v13[1] = 0;
  v14 = v13 + 1;
  v13[2] = 0;
  *v13 = &off_24D5E7A78;
  v13[3] = a1;
  *((_DWORD *)v13 + 8) = a2;
  *((_DWORD *)v13 + 9) = a3;
  *((_DWORD *)v13 + 10) = a4;
  v33 = (char *)(v13 + 3);
  v34 = (std::__shared_weak_count *)v13;
  v15 = MEMORY[0x24BDAC760];
  *(_QWORD *)buf = MEMORY[0x24BDAC760];
  v28 = 1174405120;
  v29 = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMISuppServicesCommandDriver19fetchCallForwardingEN10subscriber7SimSlotE22CTCallForwardingReasonjE3__0EEOS1_OT__block_invoke;
  v30 = &__block_descriptor_tmp_73_7;
  v31 = (char *)(v13 + 3);
  v32 = (std::__shared_weak_count *)v13;
  do
    v16 = __ldxr(v14);
  while (__stxr(v16 + 1, v14));
  aBlock[0] = v15;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_30;
  aBlock[3] = &unk_24D5E7978;
  aBlock[4] = buf;
  *(_QWORD *)(v12 + 32) = _Block_copy(aBlock);
  v17 = v32;
  if (v32)
  {
    p_shared_owners = (unint64_t *)&v32->__shared_owners_;
    do
      v19 = __ldaxr(p_shared_owners);
    while (__stlxr(v19 - 1, p_shared_owners));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
  v20 = v34;
  if (v34)
  {
    v21 = (unint64_t *)&v34->__shared_owners_;
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
  v23 = v25;
  v25 = 0;
  if (v23)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v25, v23);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v26);
  return 1;
}

void sub_216A63010(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

void ___ZN28QMISuppServicesCommandDriver28handleCallForwardingResponseEN10subscriber7SimSlotERKN2vs14CallForwarding8ResponseE22CTCallForwardingReasonj_block_invoke(uint64_t a1, _WORD *a2)
{
  NSObject *v4;
  uint8_t v5[16];

  v4 = *(NSObject **)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 40) + 80) + 16))(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 80), *(unsigned int *)(a1 + 48));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v5 = 0;
    _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I Failure cause is present in the response", v5, 2u);
  }
  *(_WORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *a2;
}

__n128 __Block_byref_object_copy__10(uint64_t a1, uint64_t a2)
{
  __n128 result;

  result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 40) = result;
  *(_QWORD *)(a2 + 40) = 0;
  *(_QWORD *)(a2 + 48) = 0;
  return result;
}

uint64_t __Block_byref_object_dispose__10(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 40);
}

void ___ZN28QMISuppServicesCommandDriver28handleCallForwardingResponseEN10subscriber7SimSlotERKN2vs14CallForwarding8ResponseE22CTCallForwardingReasonj_block_invoke_10(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  std::__shared_weak_count *v4;
  uint64_t *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  __int16 v18;
  char v19;
  __int128 v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  std::string *v25;
  __int128 v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  uint64_t v31;
  _BYTE *v32;
  uint64_t v33;
  char *v34;
  std::string *v35;
  __int128 v36;
  char *v37;
  uint64_t v38;
  uint64_t v39;
  __int16 v40;
  char v41;
  __int128 v42;
  uint64_t v43;
  uint64_t v44;
  unint64_t *v45;
  unint64_t v46;
  std::__shared_weak_count *v47;
  void *__p[4];
  uint64_t v49;
  _BYTE *v50;
  uint64_t v51;
  char *v52;
  char *v53;
  uint64_t *v54;

  v3 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v5 = *(uint64_t **)(v3 + 40);
  v4 = *(std::__shared_weak_count **)(v3 + 48);
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  v47 = v4;
  v8 = *a2;
  v9 = a2[1];
  std::vector<vs::tlv::ServiceParam>::__clear[abi:ne180100](v5);
  v10 = 0xCCCCCCCCCCCCCCCDLL * ((a2[1] - *a2) >> 3);
  v11 = *v5;
  if (0xCCCCCCCCCCCCCCCDLL * ((v5[2] - *v5) >> 3) < v10)
  {
    if (v10 > 0x666666666666666)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v12 = v5[1];
    v54 = v5 + 2;
    v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<SelectionItem>>(v10);
    v16 = *v5;
    v15 = v5[1];
    if (v15 == *v5)
    {
      v21 = v5[1];
      v17 = &v13[v12 - v11];
    }
    else
    {
      v17 = &v13[v12 - v11];
      do
      {
        v18 = *(_WORD *)(v15 - 40);
        v15 -= 40;
        v19 = *(_BYTE *)(v15 + 2);
        *((_WORD *)v17 - 20) = v18;
        v17 -= 40;
        v17[2] = v19;
        v20 = *(_OWORD *)(v15 + 8);
        *((_QWORD *)v17 + 3) = *(_QWORD *)(v15 + 24);
        *(_OWORD *)(v17 + 8) = v20;
        *(_QWORD *)(v15 + 16) = 0;
        *(_QWORD *)(v15 + 24) = 0;
        *(_QWORD *)(v15 + 8) = 0;
        v17[32] = *(_BYTE *)(v15 + 32);
      }
      while (v15 != v16);
      v21 = *v5;
      v15 = v5[1];
    }
    *v5 = (uint64_t)v17;
    v50 = (_BYTE *)v21;
    v51 = v21;
    v5[1] = (uint64_t)&v13[v12 - v11];
    v52 = (char *)v15;
    v22 = v5[2];
    v5[2] = (uint64_t)&v13[40 * v14];
    v53 = (char *)v22;
    std::__split_buffer<CallForwardServiceParameter>::~__split_buffer((uint64_t)&v50);
  }
  for (; v8 != v9; v8 += 40)
  {
    v49 = 0;
    memset(__p, 0, sizeof(__p));
    *(_WORD *)((char *)__p + 1) = *(_WORD *)v8;
    std::string::operator=((std::string *)&__p[1], (const std::string *)(v8 + 8));
    LOBYTE(v49) = *(_BYTE *)(v8 + 32);
    v23 = v5[1];
    v24 = v5[2];
    if (v23 >= v24)
    {
      v27 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v23 - *v5) >> 3);
      v28 = v27 + 1;
      if (v27 + 1 > 0x666666666666666)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v29 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v24 - *v5) >> 3);
      if (2 * v29 > v28)
        v28 = 2 * v29;
      if (v29 >= 0x333333333333333)
        v30 = 0x666666666666666;
      else
        v30 = v28;
      v54 = v5 + 2;
      if (v30)
      {
        v32 = std::__allocate_at_least[abi:ne180100]<std::allocator<SelectionItem>>(v30);
      }
      else
      {
        v32 = 0;
        v31 = 0;
      }
      v34 = &v32[40 * v27];
      v50 = v32;
      v51 = (uint64_t)v34;
      v52 = v34;
      v53 = &v32[40 * v31];
      v34[2] = BYTE2(__p[0]);
      *(_WORD *)v34 = __p[0];
      v35 = (std::string *)(v34 + 8);
      if (SHIBYTE(__p[3]) < 0)
      {
        std::string::__init_copy_ctor_external(v35, (const std::string::value_type *)__p[1], (std::string::size_type)__p[2]);
        v34 = (char *)v51;
        v37 = v52;
      }
      else
      {
        v36 = *(_OWORD *)&__p[1];
        *((void **)v34 + 3) = __p[3];
        *(_OWORD *)&v35->__r_.__value_.__l.__data_ = v36;
        v37 = &v32[40 * v27];
      }
      v32[40 * v27 + 32] = v49;
      v39 = *v5;
      v38 = v5[1];
      if (v38 == *v5)
      {
        v43 = v5[1];
      }
      else
      {
        do
        {
          v40 = *(_WORD *)(v38 - 40);
          v38 -= 40;
          v41 = *(_BYTE *)(v38 + 2);
          *((_WORD *)v34 - 20) = v40;
          v34 -= 40;
          v34[2] = v41;
          v42 = *(_OWORD *)(v38 + 8);
          *((_QWORD *)v34 + 3) = *(_QWORD *)(v38 + 24);
          *(_OWORD *)(v34 + 8) = v42;
          *(_QWORD *)(v38 + 16) = 0;
          *(_QWORD *)(v38 + 24) = 0;
          *(_QWORD *)(v38 + 8) = 0;
          v34[32] = *(_BYTE *)(v38 + 32);
        }
        while (v38 != v39);
        v43 = *v5;
        v38 = v5[1];
      }
      v33 = (uint64_t)(v37 + 40);
      *v5 = (uint64_t)v34;
      v50 = (_BYTE *)v43;
      v51 = v43;
      v5[1] = (uint64_t)(v37 + 40);
      v52 = (char *)v38;
      v44 = v5[2];
      v5[2] = (uint64_t)v53;
      v53 = (char *)v44;
      std::__split_buffer<CallForwardServiceParameter>::~__split_buffer((uint64_t)&v50);
    }
    else
    {
      *(_BYTE *)(v23 + 2) = BYTE2(__p[0]);
      *(_WORD *)v23 = __p[0];
      v25 = (std::string *)(v23 + 8);
      if (SHIBYTE(__p[3]) < 0)
      {
        std::string::__init_copy_ctor_external(v25, (const std::string::value_type *)__p[1], (std::string::size_type)__p[2]);
      }
      else
      {
        v26 = *(_OWORD *)&__p[1];
        *(void **)(v23 + 24) = __p[3];
        *(_OWORD *)&v25->__r_.__value_.__l.__data_ = v26;
      }
      *(_BYTE *)(v23 + 32) = v49;
      v33 = v23 + 40;
      v5[1] = v23 + 40;
    }
    v5[1] = v33;
    if (SHIBYTE(__p[3]) < 0)
      operator delete(__p[1]);
  }
  if (v47)
  {
    v45 = (unint64_t *)&v47->__shared_owners_;
    do
      v46 = __ldaxr(v45);
    while (__stlxr(v46 - 1, v45));
    if (!v46)
    {
      ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
      std::__shared_weak_count::__release_weak(v47);
    }
  }
}

void sub_216A634F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,char a21)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

uint64_t QMISuppServicesCommandDriver::setCallForwarding(uint64_t a1, uint64_t a2, int a3, CSIPhoneNumber *a4, unsigned int a5, int a6, int a7, int a8)
{
  char *v15;
  char v16;
  char v17;
  std::string::size_type v18;
  char *v19;
  NSObject *v20;
  const void **v21;
  char *v22;
  std::string *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  char *v31;
  uint64_t *v32;
  char *v33;
  char *v34;
  char *v35;
  uint64_t v36;
  const void **v37;
  char *v38;
  _BYTE *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  _QWORD *v43;
  uint64_t v44;
  unint64_t v45;
  unint64_t v46;
  char *v47;
  uint64_t *v48;
  char *v49;
  char *v50;
  char *v51;
  uint64_t v52;
  int v53;
  uint64_t v54;
  uint64_t v55;
  _QWORD *v56;
  unint64_t *v57;
  unint64_t v58;
  std::__shared_weak_count *v59;
  unint64_t *p_shared_owners;
  unint64_t v61;
  std::__shared_weak_count *v62;
  unint64_t *v63;
  unint64_t v64;
  uint64_t v65;
  char v68[8];
  uint64_t v69;
  _QWORD v70[2];
  void (*v71)(uint64_t, std::string *);
  void *v72;
  std::string v73;
  _QWORD v74[4];
  int v75;
  void *__p[2];
  __int128 v77;
  std::string buf;
  void *v79;
  char *v80;
  std::__shared_weak_count *v81;
  char *v82;
  std::__shared_weak_count *v83;
  _QWORD aBlock[6];

  *(_OWORD *)__p = 0u;
  v77 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  v15 = qmi::MutableMessageBase::getTLV<vs::tlv::SupsService>(__p);
  if (a3)
    v16 = 3;
  else
    v16 = 4;
  *v15 = v16;
  if (a5 < 6)
    v17 = a5 + 1;
  else
    v17 = 0;
  v15[1] = v17;
  v18 = MEMORY[0x24BDAC760];
  if (a6)
  {
    v74[0] = MEMORY[0x24BDAC760];
    v74[1] = 0x40000000;
    v74[2] = ___ZN28QMISuppServicesCommandDriver17setCallForwardingEN10subscriber7SimSlotEbRK14CSIPhoneNumber22CTCallForwardingReasonjh12MmiProcedure_block_invoke_2;
    v74[3] = &__block_descriptor_tmp_15_26;
    v75 = a6;
    v19 = qmi::MutableMessageBase::getTLV<vs::tlv::ServiceClass>(__p);
    ___ZN28QMISuppServicesCommandDriver17setCallForwardingEN10subscriber7SimSlotEbRK14CSIPhoneNumber22CTCallForwardingReasonjh12MmiProcedure_block_invoke_2((uint64_t)v74, v19);
  }
  else
  {
    v20 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 80) + 16))(*(_QWORD *)(a1 + 80), a2);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_impl(&dword_216897000, v20, OS_LOG_TYPE_DEFAULT, "#I Not including the service class as it is unknown", (uint8_t *)&buf, 2u);
    }
  }
  if (a3)
  {
    memset(&buf, 0, sizeof(buf));
    CSIPhoneNumber::getFullNumber(a4);
    v70[0] = v18;
    v70[1] = 1174405120;
    v71 = ___ZN28QMISuppServicesCommandDriver17setCallForwardingEN10subscriber7SimSlotEbRK14CSIPhoneNumber22CTCallForwardingReasonjh12MmiProcedure_block_invoke_16;
    v72 = &__block_descriptor_tmp_18_23;
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
      std::string::__init_copy_ctor_external(&v73, buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_);
    else
      v73 = buf;
    v21 = (const void **)__p[1];
    if (__p[1] != (void *)v77)
    {
      while (*((_BYTE *)*v21 + 8) != 18)
      {
        if (++v21 == (const void **)v77)
          goto LABEL_22;
      }
    }
    if (v21 == (const void **)v77)
    {
LABEL_22:
      v24 = operator new();
      v25 = v24;
      *(_BYTE *)(v24 + 8) = 18;
      *(_QWORD *)(v24 + 16) = 0;
      v23 = (std::string *)(v24 + 16);
      *(_QWORD *)v24 = off_24D5E7BA8;
      *(_QWORD *)(v24 + 24) = 0;
      *(_QWORD *)(v24 + 32) = 0;
      v26 = v77;
      if ((unint64_t)v77 >= *((_QWORD *)&v77 + 1))
      {
        v28 = (uint64_t)(v77 - (unint64_t)__p[1]) >> 3;
        if ((unint64_t)(v28 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v29 = (uint64_t)(*((_QWORD *)&v77 + 1) - (unint64_t)__p[1]) >> 2;
        if (v29 <= v28 + 1)
          v29 = v28 + 1;
        if (*((_QWORD *)&v77 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v30 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v30 = v29;
        if (v30)
          v31 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v77 + 8, v30);
        else
          v31 = 0;
        v32 = (uint64_t *)&v31[8 * v28];
        v33 = &v31[8 * v30];
        *v32 = v25;
        v27 = v32 + 1;
        v35 = (char *)__p[1];
        v34 = (char *)v77;
        if ((void *)v77 != __p[1])
        {
          do
          {
            v36 = *((_QWORD *)v34 - 1);
            v34 -= 8;
            *--v32 = v36;
          }
          while (v34 != v35);
          v34 = (char *)__p[1];
        }
        __p[1] = v32;
        *(_QWORD *)&v77 = v27;
        *((_QWORD *)&v77 + 1) = v33;
        if (v34)
          operator delete(v34);
      }
      else
      {
        *(_QWORD *)v77 = v24;
        v27 = (_QWORD *)(v26 + 8);
      }
      *(_QWORD *)&v77 = v27;
    }
    else
    {
      if (!v22)
        __cxa_bad_cast();
      v23 = (std::string *)(v22 + 16);
    }
    v71((uint64_t)v70, v23);
    if (a7)
    {
      v37 = (const void **)__p[1];
      if (__p[1] != (void *)v77)
      {
        while (*((_BYTE *)*v37 + 8) != 19)
        {
          if (++v37 == (const void **)v77)
            goto LABEL_47;
        }
      }
      if (v37 == (const void **)v77)
      {
LABEL_47:
        v40 = operator new();
        v41 = v40;
        *(_WORD *)(v40 + 8) = 19;
        *(_QWORD *)v40 = &off_24D5E7BF8;
        v42 = v77;
        if ((unint64_t)v77 >= *((_QWORD *)&v77 + 1))
        {
          v44 = (uint64_t)(v77 - (unint64_t)__p[1]) >> 3;
          if ((unint64_t)(v44 + 1) >> 61)
            std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
          v45 = (uint64_t)(*((_QWORD *)&v77 + 1) - (unint64_t)__p[1]) >> 2;
          if (v45 <= v44 + 1)
            v45 = v44 + 1;
          if (*((_QWORD *)&v77 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
            v46 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v46 = v45;
          if (v46)
            v47 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v77 + 8, v46);
          else
            v47 = 0;
          v48 = (uint64_t *)&v47[8 * v44];
          v49 = &v47[8 * v46];
          *v48 = v41;
          v43 = v48 + 1;
          v51 = (char *)__p[1];
          v50 = (char *)v77;
          if ((void *)v77 != __p[1])
          {
            do
            {
              v52 = *((_QWORD *)v50 - 1);
              v50 -= 8;
              *--v48 = v52;
            }
            while (v50 != v51);
            v50 = (char *)__p[1];
          }
          __p[1] = v48;
          *(_QWORD *)&v77 = v43;
          *((_QWORD *)&v77 + 1) = v49;
          if (v50)
            operator delete(v50);
        }
        else
        {
          *(_QWORD *)v77 = v40;
          v43 = (_QWORD *)(v42 + 8);
        }
        v39 = (_BYTE *)(v41 + 9);
        *(_QWORD *)&v77 = v43;
      }
      else
      {
        if (!v38)
          __cxa_bad_cast();
        v39 = v38 + 9;
      }
      *v39 = a7;
    }
    if (SHIBYTE(v73.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v73.__r_.__value_.__l.__data_);
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
      operator delete(buf.__r_.__value_.__l.__data_);
  }
  if ((a2 - 1) >= 3)
    v53 = 0;
  else
    v53 = a2;
  v54 = qmi::ClientRouter::get();
  qmi::ClientRouter::SendProxy::SendProxy<vs::SetSupsService::Request>((uint64_t)v68, v53, v54);
  v55 = v69;
  *(_DWORD *)(v69 + 16) = 120000;
  v56 = operator new(0x38uLL);
  v56[1] = 0;
  v57 = v56 + 1;
  v56[2] = 0;
  *v56 = &off_24D5E7C60;
  v56[3] = a1;
  *((_DWORD *)v56 + 8) = a2;
  *((_DWORD *)v56 + 9) = a5;
  *((_DWORD *)v56 + 10) = a6;
  *((_BYTE *)v56 + 44) = a3;
  *((_DWORD *)v56 + 12) = a8;
  v82 = (char *)(v56 + 3);
  v83 = (std::__shared_weak_count *)v56;
  buf.__r_.__value_.__r.__words[0] = v18;
  buf.__r_.__value_.__l.__size_ = 1174405120;
  buf.__r_.__value_.__r.__words[2] = (std::string::size_type)___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMISuppServicesCommandDriver17setCallForwardingEN10subscriber7SimSlotEbRK14CSIPhoneNumber22CTCallForwardingReasonjh12MmiProcedureE3__0EEOS1_OT__block_invoke;
  v79 = &__block_descriptor_tmp_74_6;
  v80 = (char *)(v56 + 3);
  v81 = (std::__shared_weak_count *)v56;
  do
    v58 = __ldxr(v57);
  while (__stxr(v58 + 1, v57));
  aBlock[0] = v18;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKN2vs14SetSupsService8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
  aBlock[3] = &unk_24D5E7CA8;
  aBlock[4] = &buf;
  *(_QWORD *)(v55 + 32) = _Block_copy(aBlock);
  v59 = v81;
  if (v81)
  {
    p_shared_owners = (unint64_t *)&v81->__shared_owners_;
    do
      v61 = __ldaxr(p_shared_owners);
    while (__stlxr(v61 - 1, p_shared_owners));
    if (!v61)
    {
      ((void (*)(std::__shared_weak_count *))v59->__on_zero_shared)(v59);
      std::__shared_weak_count::__release_weak(v59);
    }
  }
  v62 = v83;
  if (v83)
  {
    v63 = (unint64_t *)&v83->__shared_owners_;
    do
      v64 = __ldaxr(v63);
    while (__stlxr(v64 - 1, v63));
    if (!v64)
    {
      ((void (*)(std::__shared_weak_count *))v62->__on_zero_shared)(v62);
      std::__shared_weak_count::__release_weak(v62);
    }
  }
  v65 = v69;
  v69 = 0;
  if (v65)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v69, v65);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
  return 1;
}

void sub_216A63B50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,void *__p,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
  if (a37 < 0)
    operator delete(__p);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a28);
  _Unwind_Resume(a1);
}

uint64_t ___ZN28QMISuppServicesCommandDriver17setCallForwardingEN10subscriber7SimSlotEbRK14CSIPhoneNumber22CTCallForwardingReasonjh12MmiProcedure_block_invoke_2(uint64_t result, _BYTE *a2)
{
  *a2 = *(_DWORD *)(result + 32);
  return result;
}

void ___ZN28QMISuppServicesCommandDriver17setCallForwardingEN10subscriber7SimSlotEbRK14CSIPhoneNumber22CTCallForwardingReasonjh12MmiProcedure_block_invoke_16(uint64_t a1, std::string *this)
{
  std::string::value_type *v3;
  std::string::size_type v4;

  if (*(char *)(a1 + 55) < 0)
  {
    v3 = *(std::string::value_type **)(a1 + 32);
    v4 = *(_QWORD *)(a1 + 40);
  }
  else
  {
    v3 = (std::string::value_type *)(a1 + 32);
    v4 = *(unsigned __int8 *)(a1 + 55);
  }
  std::string::__assign_trivial[abi:ne180100]<unsigned char const*,unsigned char const*>(this, v3, &v3[v4], v4);
}

uint64_t QMISuppServicesCommandDriver::activateCallForwarding(uint64_t a1, uint64_t a2, int a3, unsigned int a4, int a5, int a6)
{
  char *v12;
  char v13;
  char v14;
  NSObject *v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  unint64_t *v20;
  uint64_t v21;
  unint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t *p_shared_owners;
  unint64_t v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v31;
  uint64_t v32;
  _OWORD v33[2];
  uint8_t buf[8];
  uint64_t v35;
  void (*v36)(uint64_t, qmi::MessageBase *);
  void *v37;
  char *v38;
  std::__shared_weak_count *v39;
  char *v40;
  std::__shared_weak_count *v41;
  _QWORD aBlock[5];

  memset(v33, 0, sizeof(v33));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v33);
  v12 = qmi::MutableMessageBase::getTLV<vs::tlv::SupsService>(v33);
  if (a3)
    v13 = 1;
  else
    v13 = 2;
  *v12 = v13;
  if (a4 < 6)
    v14 = a4 + 1;
  else
    v14 = 0;
  v12[1] = v14;
  if (a5)
  {
    *qmi::MutableMessageBase::getTLV<vs::tlv::ServiceClass>(v33) = a5;
  }
  else
  {
    v15 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 80) + 16))(*(_QWORD *)(a1 + 80), a2);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_216897000, v15, OS_LOG_TYPE_DEFAULT, "#I Call class is not provided, not including in the message", buf, 2u);
    }
  }
  if ((a2 - 1) >= 3)
    v16 = 0;
  else
    v16 = a2;
  v17 = qmi::ClientRouter::get();
  qmi::ClientRouter::SendProxy::SendProxy<vs::SetSupsService::Request>((uint64_t)&v31, v16, v17);
  v18 = v32;
  *(_DWORD *)(v32 + 16) = 120000;
  v19 = operator new(0x38uLL);
  v19[1] = 0;
  v20 = v19 + 1;
  v19[2] = 0;
  v19[3] = a1;
  *v19 = &off_24D5E7D30;
  *((_DWORD *)v19 + 8) = a2;
  *((_DWORD *)v19 + 9) = a4;
  *((_DWORD *)v19 + 10) = a5;
  *((_BYTE *)v19 + 44) = a3;
  *((_DWORD *)v19 + 12) = a6;
  v40 = (char *)(v19 + 3);
  v41 = (std::__shared_weak_count *)v19;
  v21 = MEMORY[0x24BDAC760];
  *(_QWORD *)buf = MEMORY[0x24BDAC760];
  v35 = 1174405120;
  v36 = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMISuppServicesCommandDriver22activateCallForwardingEN10subscriber7SimSlotEb22CTCallForwardingReasonj12MmiProcedureE3__0EEOS1_OT__block_invoke;
  v37 = &__block_descriptor_tmp_77_2;
  v38 = (char *)(v19 + 3);
  v39 = (std::__shared_weak_count *)v19;
  do
    v22 = __ldxr(v20);
  while (__stxr(v22 + 1, v20));
  aBlock[0] = v21;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKN2vs14SetSupsService8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
  aBlock[3] = &unk_24D5E7CA8;
  aBlock[4] = buf;
  *(_QWORD *)(v18 + 32) = _Block_copy(aBlock);
  v23 = v39;
  if (v39)
  {
    p_shared_owners = (unint64_t *)&v39->__shared_owners_;
    do
      v25 = __ldaxr(p_shared_owners);
    while (__stlxr(v25 - 1, p_shared_owners));
    if (!v25)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }
  v26 = v41;
  if (v41)
  {
    v27 = (unint64_t *)&v41->__shared_owners_;
    do
      v28 = __ldaxr(v27);
    while (__stlxr(v28 - 1, v27));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
      std::__shared_weak_count::__release_weak(v26);
    }
  }
  v29 = v32;
  v32 = 0;
  if (v29)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v32, v29);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v33);
  return 1;
}

void sub_216A63E90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

uint64_t QMISuppServicesCommandDriver::fetchCallBarring(uint64_t a1, uint64_t a2, unsigned int a3, int a4)
{
  NSObject *v8;
  char *v9;
  char v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  unint64_t *v14;
  uint64_t v15;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *p_shared_owners;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v25;
  _OWORD v26[2];
  uint8_t buf[8];
  uint64_t v28;
  void (*v29)(uint64_t, _QWORD *);
  void *v30;
  char *v31;
  std::__shared_weak_count *v32;
  char *v33;
  std::__shared_weak_count *v34;
  _QWORD aBlock[5];

  memset(v26, 0, sizeof(v26));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v26);
  if (a4)
  {
    *qmi::MutableMessageBase::getTLV<vs::tlv::ServiceClass>(v26) = a4;
  }
  else
  {
    v8 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 80) + 16))(*(_QWORD *)(a1 + 80), a2);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_216897000, v8, OS_LOG_TYPE_DEFAULT, "#I Call class is not provided, not including in the message", buf, 2u);
    }
  }
  v9 = qmi::MutableMessageBase::getTLV<vs::tlv::Reason>(v26);
  if (a3 > 8)
    v10 = 0;
  else
    v10 = asc_216ABC1EF[a3];
  *v9 = v10;
  v11 = qmi::ClientRouter::get();
  v12 = operator new();
  *(_QWORD *)v12 = v11;
  *(_QWORD *)(v12 + 8) = QMIServiceMsg::create();
  *(_QWORD *)(v12 + 24) = 0;
  *(_QWORD *)(v12 + 32) = 0;
  v25 = v12;
  *(_DWORD *)(v12 + 16) = 120000;
  v13 = operator new(0x30uLL);
  v13[1] = 0;
  v14 = v13 + 1;
  v13[2] = 0;
  *v13 = &off_24D5E7DD8;
  v13[3] = a1;
  *((_DWORD *)v13 + 8) = a2;
  *((_DWORD *)v13 + 9) = a3;
  *((_DWORD *)v13 + 10) = a4;
  v33 = (char *)(v13 + 3);
  v34 = (std::__shared_weak_count *)v13;
  v15 = MEMORY[0x24BDAC760];
  *(_QWORD *)buf = MEMORY[0x24BDAC760];
  v28 = 1174405120;
  v29 = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMISuppServicesCommandDriver16fetchCallBarringEN10subscriber7SimSlotE21CTCallBarringFacilityjE3__0EEOS1_OT__block_invoke;
  v30 = &__block_descriptor_tmp_79_3;
  v31 = (char *)(v13 + 3);
  v32 = (std::__shared_weak_count *)v13;
  do
    v16 = __ldxr(v14);
  while (__stxr(v16 + 1, v14));
  aBlock[0] = v15;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_30;
  aBlock[3] = &unk_24D5E7978;
  aBlock[4] = buf;
  *(_QWORD *)(v12 + 32) = _Block_copy(aBlock);
  v17 = v32;
  if (v32)
  {
    p_shared_owners = (unint64_t *)&v32->__shared_owners_;
    do
      v19 = __ldaxr(p_shared_owners);
    while (__stlxr(v19 - 1, p_shared_owners));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
  v20 = v34;
  if (v34)
  {
    v21 = (unint64_t *)&v34->__shared_owners_;
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
  v23 = v25;
  v25 = 0;
  if (v23)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v25, v23);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v26);
  return 1;
}

void sub_216A64174(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

void ___ZN28QMISuppServicesCommandDriver25handleCallBarringInfo_resEN10subscriber7SimSlotE21CTCallBarringFacilityjRKN2vs14GetCallBarring8ResponseE_block_invoke(uint64_t a1, _WORD *a2)
{
  NSObject *v4;
  uint8_t v5[16];

  v4 = *(NSObject **)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 40) + 80) + 16))(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 80), *(unsigned int *)(a1 + 48));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v5 = 0;
    _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I Failure cause is present in the response", v5, 2u);
  }
  *(_WORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *a2;
}

uint64_t ___ZN28QMISuppServicesCommandDriver25handleCallBarringInfo_resEN10subscriber7SimSlotE21CTCallBarringFacilityjRKN2vs14GetCallBarring8ResponseE_block_invoke_28(uint64_t result, _BYTE *a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = *a2;
  return result;
}

BOOL QMISuppServicesCommandDriver::setCallBarring(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5, char a6, int a7)
{
  uint64_t v9;
  char *v15;
  uint64_t v16;
  NSObject *v17;
  NSObject *v18;
  _BOOL4 v19;
  const void **v20;
  char *v21;
  _BYTE *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  char *v30;
  uint64_t *v31;
  char *v32;
  char *v33;
  char *v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  _QWORD *v39;
  unint64_t *v40;
  unint64_t v41;
  std::__shared_weak_count *v42;
  unint64_t *p_shared_owners;
  unint64_t v44;
  std::__shared_weak_count *v45;
  unint64_t *v46;
  unint64_t v47;
  uint64_t v48;
  char v50[8];
  uint64_t v51;
  _QWORD v52[5];
  _QWORD v53[5];
  int v54;
  char v55;
  void *__p[2];
  __int128 v57;
  uint8_t buf[8];
  uint64_t v59;
  void (*v60)(uint64_t, qmi::MessageBase *);
  void *v61;
  char *v62;
  std::__shared_weak_count *v63;
  char *v64;
  std::__shared_weak_count *v65;
  _QWORD aBlock[6];

  if (*(char *)(a5 + 23) >= 0)
    v9 = *(unsigned __int8 *)(a5 + 23);
  else
    v9 = *(_QWORD *)(a5 + 8);
  if (v9 == 4)
  {
    *(_OWORD *)__p = 0u;
    v57 = 0u;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
    v53[0] = MEMORY[0x24BDAC760];
    v53[1] = 0x40000000;
    v53[2] = ___ZN28QMISuppServicesCommandDriver14setCallBarringEN10subscriber7SimSlotE21CTCallBarringFacilityjRKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEb12MmiProcedure_block_invoke;
    v53[3] = &__block_descriptor_tmp_31_6;
    v53[4] = a1;
    v55 = a6;
    v54 = a3;
    v15 = qmi::MutableMessageBase::getTLV<vs::tlv::SupsService>(__p);
    ___ZN28QMISuppServicesCommandDriver14setCallBarringEN10subscriber7SimSlotE21CTCallBarringFacilityjRKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEb12MmiProcedure_block_invoke((uint64_t)v53, v15);
    if (a4)
    {
      *qmi::MutableMessageBase::getTLV<vs::tlv::ServiceClass>(__p) = a4;
      v16 = MEMORY[0x24BDAC760];
    }
    else
    {
      v18 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 80) + 16))(*(_QWORD *)(a1 + 80), a2);
      v19 = os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT);
      v16 = MEMORY[0x24BDAC760];
      if (v19)
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_216897000, v18, OS_LOG_TYPE_DEFAULT, "#I Call class is not provided, not including in the message", buf, 2u);
      }
    }
    v52[0] = v16;
    v52[1] = 0x40000000;
    v52[2] = ___ZN28QMISuppServicesCommandDriver14setCallBarringEN10subscriber7SimSlotE21CTCallBarringFacilityjRKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEb12MmiProcedure_block_invoke_33;
    v52[3] = &__block_descriptor_tmp_34_13;
    v52[4] = a5;
    v20 = (const void **)__p[1];
    if (__p[1] != (void *)v57)
    {
      while (*((_BYTE *)*v20 + 8) != 17)
      {
        if (++v20 == (const void **)v57)
          goto LABEL_18;
      }
    }
    if (v20 == (const void **)v57)
    {
LABEL_18:
      v23 = operator new();
      v24 = v23;
      *(_BYTE *)(v23 + 8) = 17;
      *(_QWORD *)v23 = &off_24D5E7E40;
      *(_DWORD *)(v23 + 9) = 0;
      v22 = (_BYTE *)(v23 + 9);
      v25 = v57;
      if ((unint64_t)v57 >= *((_QWORD *)&v57 + 1))
      {
        v27 = (uint64_t)(v57 - (unint64_t)__p[1]) >> 3;
        if ((unint64_t)(v27 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v28 = (uint64_t)(*((_QWORD *)&v57 + 1) - (unint64_t)__p[1]) >> 2;
        if (v28 <= v27 + 1)
          v28 = v27 + 1;
        if (*((_QWORD *)&v57 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v29 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v29 = v28;
        if (v29)
          v30 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v57 + 8, v29);
        else
          v30 = 0;
        v31 = (uint64_t *)&v30[8 * v27];
        v32 = &v30[8 * v29];
        *v31 = v24;
        v26 = v31 + 1;
        v34 = (char *)__p[1];
        v33 = (char *)v57;
        if ((void *)v57 != __p[1])
        {
          do
          {
            v35 = *((_QWORD *)v33 - 1);
            v33 -= 8;
            *--v31 = v35;
          }
          while (v33 != v34);
          v33 = (char *)__p[1];
        }
        __p[1] = v31;
        *(_QWORD *)&v57 = v26;
        *((_QWORD *)&v57 + 1) = v32;
        if (v33)
          operator delete(v33);
      }
      else
      {
        *(_QWORD *)v57 = v23;
        v26 = (_QWORD *)(v25 + 8);
      }
      *(_QWORD *)&v57 = v26;
      v16 = MEMORY[0x24BDAC760];
    }
    else
    {
      if (!v21)
        __cxa_bad_cast();
      v22 = v21 + 9;
    }
    ___ZN28QMISuppServicesCommandDriver14setCallBarringEN10subscriber7SimSlotE21CTCallBarringFacilityjRKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEb12MmiProcedure_block_invoke_33((uint64_t)v52, v22);
    if ((a2 - 1) >= 3)
      v36 = 0;
    else
      v36 = a2;
    v37 = qmi::ClientRouter::get();
    qmi::ClientRouter::SendProxy::SendProxy<vs::SetSupsService::Request>((uint64_t)v50, v36, v37);
    v38 = v51;
    *(_DWORD *)(v51 + 16) = 120000;
    v39 = operator new(0x38uLL);
    v39[1] = 0;
    v40 = v39 + 1;
    v39[2] = 0;
    *v39 = &off_24D5E7EA8;
    v39[3] = a1;
    *((_DWORD *)v39 + 8) = a2;
    *((_DWORD *)v39 + 9) = a3;
    *((_DWORD *)v39 + 10) = a4;
    *((_BYTE *)v39 + 44) = a6;
    *((_DWORD *)v39 + 12) = a7;
    v64 = (char *)(v39 + 3);
    v65 = (std::__shared_weak_count *)v39;
    *(_QWORD *)buf = v16;
    v59 = 1174405120;
    v60 = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMISuppServicesCommandDriver14setCallBarringEN10subscriber7SimSlotE21CTCallBarringFacilityjRKNSt3__112basic_stringIcNS7_11char_traitsIcEENS7_9allocatorIcEEEEb12MmiProcedureE3__0EEOS1_OT__block_invoke;
    v61 = &__block_descriptor_tmp_80_3;
    v62 = (char *)(v39 + 3);
    v63 = (std::__shared_weak_count *)v39;
    do
      v41 = __ldxr(v40);
    while (__stxr(v41 + 1, v40));
    aBlock[0] = v16;
    aBlock[1] = 0x40000000;
    aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKN2vs14SetSupsService8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
    aBlock[3] = &unk_24D5E7CA8;
    aBlock[4] = buf;
    *(_QWORD *)(v38 + 32) = _Block_copy(aBlock);
    v42 = v63;
    if (v63)
    {
      p_shared_owners = (unint64_t *)&v63->__shared_owners_;
      do
        v44 = __ldaxr(p_shared_owners);
      while (__stlxr(v44 - 1, p_shared_owners));
      if (!v44)
      {
        ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
        std::__shared_weak_count::__release_weak(v42);
      }
    }
    v45 = v65;
    if (v65)
    {
      v46 = (unint64_t *)&v65->__shared_owners_;
      do
        v47 = __ldaxr(v46);
      while (__stlxr(v47 - 1, v46));
      if (!v47)
      {
        ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
        std::__shared_weak_count::__release_weak(v45);
      }
    }
    v48 = v51;
    v51 = 0;
    if (v48)
      std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v51, v48);
    qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
  }
  else
  {
    v17 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 80) + 16))(*(_QWORD *)(a1 + 80), a2);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_216897000, v17, OS_LOG_TYPE_ERROR, "SetCallBarringStatus:: Password must be of length 4", buf, 2u);
    }
  }
  return v9 == 4;
}

void sub_216A64748(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_list va;

  va_start(va, a15);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN28QMISuppServicesCommandDriver14setCallBarringEN10subscriber7SimSlotE21CTCallBarringFacilityjRKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEb12MmiProcedure_block_invoke(uint64_t result, char *a2)
{
  char v2;
  uint64_t v3;
  char v4;

  if (*(_BYTE *)(result + 44))
    v2 = 1;
  else
    v2 = 2;
  *a2 = v2;
  v3 = *(int *)(result + 40);
  if (v3 > 8)
    v4 = 0;
  else
    v4 = asc_216ABC1EF[v3];
  a2[1] = v4;
  return result;
}

uint64_t ___ZN28QMISuppServicesCommandDriver14setCallBarringEN10subscriber7SimSlotE21CTCallBarringFacilityjRKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEb12MmiProcedure_block_invoke_33(uint64_t result, _BYTE *a2)
{
  uint64_t **v2;
  uint64_t *v3;
  uint64_t *v4;
  uint64_t *v5;

  v2 = *(uint64_t ***)(result + 32);
  if (*((char *)v2 + 23) < 0)
    v2 = (uint64_t **)*v2;
  *a2 = *(_BYTE *)v2;
  v3 = *(uint64_t **)(result + 32);
  if (*((char *)v3 + 23) < 0)
    v3 = (uint64_t *)*v3;
  a2[1] = *((_BYTE *)v3 + 1);
  v4 = *(uint64_t **)(result + 32);
  if (*((char *)v4 + 23) < 0)
    v4 = (uint64_t *)*v4;
  a2[2] = *((_BYTE *)v4 + 2);
  v5 = *(uint64_t **)(result + 32);
  if (*((char *)v5 + 23) < 0)
    v5 = (uint64_t *)*v5;
  a2[3] = *((_BYTE *)v5 + 3);
  return result;
}

BOOL QMISuppServicesCommandDriver::setCallBarringPassword(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  uint64_t v8;
  uint64_t v10;
  uint64_t v12;
  uint64_t v15;
  const void **v16;
  NSObject *v17;
  _BOOL8 result;
  char *v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t v27;
  char *v28;
  uint64_t *v29;
  char *v30;
  char *v31;
  char *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  _QWORD *v36;
  unint64_t *v37;
  unint64_t v38;
  std::__shared_weak_count *v39;
  unint64_t *p_shared_owners;
  unint64_t v41;
  std::__shared_weak_count *v42;
  unint64_t *v43;
  unint64_t v44;
  uint64_t v45;
  uint64_t v46;
  _QWORD v47[8];
  int v48;
  void *__p[2];
  __int128 v50;
  uint8_t buf[8];
  uint64_t v52;
  void (*v53)(uint64_t, qmi::MessageBase *);
  void *v54;
  char *v55;
  std::__shared_weak_count *v56;
  char *v57;
  std::__shared_weak_count *v58;
  _QWORD aBlock[5];

  v6 = a2;
  v8 = *(unsigned __int8 *)(a4 + 23);
  if ((v8 & 0x80u) != 0)
    v8 = *(_QWORD *)(a4 + 8);
  if (v8 != 4)
    goto LABEL_14;
  v10 = *(unsigned __int8 *)(a5 + 23);
  if ((v10 & 0x80u) != 0)
    v10 = *(_QWORD *)(a5 + 8);
  if (v10 != 4)
    goto LABEL_14;
  v12 = *(unsigned __int8 *)(a6 + 23);
  if ((v12 & 0x80u) != 0)
    v12 = *(_QWORD *)(a6 + 8);
  if (v12 == 4)
  {
    *(_OWORD *)__p = 0u;
    v50 = 0u;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
    v15 = MEMORY[0x24BDAC760];
    v47[0] = MEMORY[0x24BDAC760];
    v47[1] = 0x40000000;
    v47[2] = ___ZN28QMISuppServicesCommandDriver22setCallBarringPasswordEN10subscriber7SimSlotE21CTCallBarringFacilityRKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEESB_SB__block_invoke;
    v47[3] = &__block_descriptor_tmp_35_10;
    v48 = a3;
    v47[4] = a1;
    v47[5] = a4;
    v47[6] = a5;
    v47[7] = a6;
    v16 = (const void **)__p[1];
    if (__p[1] != (void *)v50)
    {
      while (*((_BYTE *)*v16 + 8) != 1)
      {
        if (++v16 == (const void **)v50)
          goto LABEL_20;
      }
    }
    if (v16 == (const void **)v50)
    {
LABEL_20:
      v21 = operator new();
      v22 = v21;
      *(_BYTE *)(v21 + 8) = 1;
      *(_QWORD *)v21 = &off_24D5E7F38;
      *(_QWORD *)(v21 + 9) = 0;
      v20 = (char *)(v21 + 9);
      *(_QWORD *)(v21 + 14) = 0;
      v23 = v50;
      if ((unint64_t)v50 >= *((_QWORD *)&v50 + 1))
      {
        v25 = (uint64_t)(v50 - (unint64_t)__p[1]) >> 3;
        if ((unint64_t)(v25 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v26 = (uint64_t)(*((_QWORD *)&v50 + 1) - (unint64_t)__p[1]) >> 2;
        if (v26 <= v25 + 1)
          v26 = v25 + 1;
        if (*((_QWORD *)&v50 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v27 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v27 = v26;
        if (v27)
          v28 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v50 + 8, v27);
        else
          v28 = 0;
        v29 = (uint64_t *)&v28[8 * v25];
        v30 = &v28[8 * v27];
        *v29 = v22;
        v24 = v29 + 1;
        v32 = (char *)__p[1];
        v31 = (char *)v50;
        if ((void *)v50 != __p[1])
        {
          do
          {
            v33 = *((_QWORD *)v31 - 1);
            v31 -= 8;
            *--v29 = v33;
          }
          while (v31 != v32);
          v31 = (char *)__p[1];
        }
        __p[1] = v29;
        *(_QWORD *)&v50 = v24;
        *((_QWORD *)&v50 + 1) = v30;
        if (v31)
          operator delete(v31);
      }
      else
      {
        *(_QWORD *)v50 = v21;
        v24 = (_QWORD *)(v23 + 8);
      }
      *(_QWORD *)&v50 = v24;
    }
    else
    {
      if (!v19)
        __cxa_bad_cast();
      v20 = v19 + 9;
    }
    ___ZN28QMISuppServicesCommandDriver22setCallBarringPasswordEN10subscriber7SimSlotE21CTCallBarringFacilityRKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEESB_SB__block_invoke((uint64_t)v47, v20);
    v34 = qmi::ClientRouter::get();
    v35 = operator new();
    *(_QWORD *)v35 = v34;
    *(_QWORD *)(v35 + 8) = QMIServiceMsg::create();
    *(_QWORD *)(v35 + 24) = 0;
    *(_QWORD *)(v35 + 32) = 0;
    v46 = v35;
    *(_DWORD *)(v35 + 16) = 120000;
    v36 = operator new(0x28uLL);
    v36[1] = 0;
    v37 = v36 + 1;
    v36[2] = 0;
    *v36 = &off_24D5E7FA0;
    v36[3] = a1;
    *((_DWORD *)v36 + 8) = v6;
    *((_DWORD *)v36 + 9) = a3;
    v57 = (char *)(v36 + 3);
    v58 = (std::__shared_weak_count *)v36;
    *(_QWORD *)buf = v15;
    v52 = 1174405120;
    v53 = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMISuppServicesCommandDriver22setCallBarringPasswordEN10subscriber7SimSlotE21CTCallBarringFacilityRKNSt3__112basic_stringIcNS7_11char_traitsIcEENS7_9allocatorIcEEEESF_SF_E3__0EEOS1_OT__block_invoke;
    v54 = &__block_descriptor_tmp_82_2;
    v55 = (char *)(v36 + 3);
    v56 = (std::__shared_weak_count *)v36;
    do
      v38 = __ldxr(v37);
    while (__stxr(v38 + 1, v37));
    aBlock[0] = v15;
    aBlock[1] = 0x40000000;
    aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKN2vs22SetCallBarringPassword8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
    aBlock[3] = &unk_24D5E7FE8;
    aBlock[4] = buf;
    *(_QWORD *)(v35 + 32) = _Block_copy(aBlock);
    v39 = v56;
    if (v56)
    {
      p_shared_owners = (unint64_t *)&v56->__shared_owners_;
      do
        v41 = __ldaxr(p_shared_owners);
      while (__stlxr(v41 - 1, p_shared_owners));
      if (!v41)
      {
        ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
        std::__shared_weak_count::__release_weak(v39);
      }
    }
    v42 = v58;
    if (v58)
    {
      v43 = (unint64_t *)&v58->__shared_owners_;
      do
        v44 = __ldaxr(v43);
      while (__stlxr(v44 - 1, v43));
      if (!v44)
      {
        ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
        std::__shared_weak_count::__release_weak(v42);
      }
    }
    v45 = v46;
    v46 = 0;
    if (v45)
      std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v46, v45);
    qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
    return 1;
  }
  else
  {
LABEL_14:
    v17 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 80) + 16))(*(_QWORD *)(a1 + 80), a2);
    result = os_log_type_enabled(v17, OS_LOG_TYPE_ERROR);
    if (result)
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_216897000, v17, OS_LOG_TYPE_ERROR, "setCallBarringPassword:: Password must be of length 4", buf, 2u);
      return 0;
    }
  }
  return result;
}

void sub_216A64C98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  va_list va;

  va_start(va, a13);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v13);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v15 - 152);
  if (a4)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v14, a4);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN28QMISuppServicesCommandDriver22setCallBarringPasswordEN10subscriber7SimSlotE21CTCallBarringFacilityRKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEESB_SB__block_invoke(uint64_t result, char *a2)
{
  uint64_t v2;
  char v3;
  uint64_t v4;
  _BYTE *v5;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t *v8;

  v2 = *(int *)(result + 64);
  if (v2 > 8)
    v3 = 0;
  else
    v3 = asc_216ABC1EF[v2];
  v4 = 0;
  *a2 = v3;
  v5 = a2 + 5;
  do
  {
    v6 = *(uint64_t **)(result + 40);
    if (*((char *)v6 + 23) < 0)
      v6 = (uint64_t *)*v6;
    v5[v4 - 4] = *((_BYTE *)v6 + v4);
    v7 = *(uint64_t **)(result + 48);
    if (*((char *)v7 + 23) < 0)
      v7 = (uint64_t *)*v7;
    v5[v4] = *((_BYTE *)v7 + v4);
    v8 = *(uint64_t **)(result + 56);
    if (*((char *)v8 + 23) < 0)
      v8 = (uint64_t *)*v8;
    v5[v4 + 4] = *((_BYTE *)v8 + v4);
    ++v4;
  }
  while (v4 != 4);
  return result;
}

uint64_t QMISuppServicesCommandDriver::fetchCallWaiting(uint64_t a1, int a2, int a3)
{
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  unint64_t *v9;
  uint64_t v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v20;
  _OWORD v21[2];
  _QWORD v22[5];
  std::__shared_weak_count *v23;
  char *v24;
  std::__shared_weak_count *v25;
  _QWORD aBlock[5];

  memset(v21, 0, sizeof(v21));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v21);
  if (SuppServicesCommandDriver::supportsCallWaitingServiceClass())
    *qmi::MutableMessageBase::getTLV<vs::tlv::ServiceClass>(v21) = a3;
  v6 = qmi::ClientRouter::get();
  v7 = operator new();
  *(_QWORD *)v7 = v6;
  *(_QWORD *)(v7 + 8) = QMIServiceMsg::create();
  *(_QWORD *)(v7 + 24) = 0;
  *(_QWORD *)(v7 + 32) = 0;
  v20 = v7;
  *(_DWORD *)(v7 + 16) = 120000;
  v8 = operator new(0x28uLL);
  v8[1] = 0;
  v9 = v8 + 1;
  v8[2] = 0;
  *v8 = &off_24D5E8070;
  v8[3] = a1;
  *((_DWORD *)v8 + 8) = a2;
  *((_DWORD *)v8 + 9) = a3;
  v24 = (char *)(v8 + 3);
  v25 = (std::__shared_weak_count *)v8;
  v10 = MEMORY[0x24BDAC760];
  v22[0] = MEMORY[0x24BDAC760];
  v22[1] = 1174405120;
  v22[2] = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMISuppServicesCommandDriver16fetchCallWaitingEN10subscriber7SimSlotEjE3__0EEOS1_OT__block_invoke;
  v22[3] = &__block_descriptor_tmp_85_0;
  v22[4] = v8 + 3;
  v23 = (std::__shared_weak_count *)v8;
  do
    v11 = __ldxr(v9);
  while (__stxr(v11 + 1, v9));
  aBlock[0] = v10;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_30;
  aBlock[3] = &unk_24D5E7978;
  aBlock[4] = v22;
  *(_QWORD *)(v7 + 32) = _Block_copy(aBlock);
  v12 = v23;
  if (v23)
  {
    p_shared_owners = (unint64_t *)&v23->__shared_owners_;
    do
      v14 = __ldaxr(p_shared_owners);
    while (__stlxr(v14 - 1, p_shared_owners));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  v15 = v25;
  if (v25)
  {
    v16 = (unint64_t *)&v25->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  v18 = v20;
  v20 = 0;
  if (v18)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v20, v18);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v21);
  return 1;
}

void sub_216A64FA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;
  va_list va;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v6 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v4);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  if (a3)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v3, a3);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

void ___ZN28QMISuppServicesCommandDriver25handleCallWaitingResponseEN10subscriber7SimSlotERKN2vs14GetCallWaiting8ResponseEj_block_invoke(uint64_t a1, _WORD *a2)
{
  NSObject *v4;
  uint8_t v5[16];

  v4 = *(NSObject **)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 40) + 80) + 16))(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 80), *(unsigned int *)(a1 + 48));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v5 = 0;
    _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I Failure cause is present in the response", v5, 2u);
  }
  *(_WORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *a2;
}

__n128 __Block_byref_object_copy__38(uint64_t a1, uint64_t a2)
{
  __n128 result;

  result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 40) = result;
  *(_QWORD *)(a2 + 40) = 0;
  *(_QWORD *)(a2 + 48) = 0;
  return result;
}

uint64_t __Block_byref_object_dispose__39(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 40);
}

uint64_t ___ZN28QMISuppServicesCommandDriver25handleCallWaitingResponseEN10subscriber7SimSlotERKN2vs14GetCallWaiting8ResponseEj_block_invoke_40(uint64_t result, _BYTE *a2)
{
  **(_BYTE **)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 40) = *a2;
  return result;
}

uint64_t QMISuppServicesCommandDriver::setCallWaiting(uint64_t a1, uint64_t a2, int a3, int a4, int a5)
{
  char *v10;
  char v11;
  NSObject *v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  unint64_t *v17;
  uint64_t v18;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *p_shared_owners;
  unint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v28;
  uint64_t v29;
  _OWORD v30[2];
  uint8_t buf[8];
  uint64_t v32;
  void (*v33)(uint64_t, qmi::MessageBase *);
  void *v34;
  char *v35;
  std::__shared_weak_count *v36;
  char *v37;
  std::__shared_weak_count *v38;
  _QWORD aBlock[5];

  memset(v30, 0, sizeof(v30));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v30);
  v10 = qmi::MutableMessageBase::getTLV<vs::tlv::SupsService>(v30);
  if (a3)
    v11 = 1;
  else
    v11 = 2;
  *v10 = v11;
  v10[1] = *(_BYTE *)(a1 + 88);
  if (a4)
  {
    *qmi::MutableMessageBase::getTLV<vs::tlv::ServiceClass>(v30) = a4;
  }
  else
  {
    v12 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 80) + 16))(*(_QWORD *)(a1 + 80), a2);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_216897000, v12, OS_LOG_TYPE_DEFAULT, "#I Not setting service class as it is unknown", buf, 2u);
    }
  }
  if ((a2 - 1) >= 3)
    v13 = 0;
  else
    v13 = a2;
  v14 = qmi::ClientRouter::get();
  qmi::ClientRouter::SendProxy::SendProxy<vs::SetSupsService::Request>((uint64_t)&v28, v13, v14);
  v15 = v29;
  *(_DWORD *)(v29 + 16) = 120000;
  v16 = operator new(0x30uLL);
  v16[1] = 0;
  v17 = v16 + 1;
  v16[2] = 0;
  *v16 = &off_24D5E8168;
  v16[3] = a1;
  *((_DWORD *)v16 + 8) = a2;
  *((_DWORD *)v16 + 9) = a4;
  *((_DWORD *)v16 + 10) = a5;
  *((_BYTE *)v16 + 44) = a3;
  v37 = (char *)(v16 + 3);
  v38 = (std::__shared_weak_count *)v16;
  v18 = MEMORY[0x24BDAC760];
  *(_QWORD *)buf = MEMORY[0x24BDAC760];
  v32 = 1174405120;
  v33 = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMISuppServicesCommandDriver14setCallWaitingEN10subscriber7SimSlotEbj12MmiProcedureE3__0EEOS1_OT__block_invoke;
  v34 = &__block_descriptor_tmp_86_3;
  v35 = (char *)(v16 + 3);
  v36 = (std::__shared_weak_count *)v16;
  do
    v19 = __ldxr(v17);
  while (__stxr(v19 + 1, v17));
  aBlock[0] = v18;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKN2vs14SetSupsService8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
  aBlock[3] = &unk_24D5E7CA8;
  aBlock[4] = buf;
  *(_QWORD *)(v15 + 32) = _Block_copy(aBlock);
  v20 = v36;
  if (v36)
  {
    p_shared_owners = (unint64_t *)&v36->__shared_owners_;
    do
      v22 = __ldaxr(p_shared_owners);
    while (__stlxr(v22 - 1, p_shared_owners));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
  v23 = v38;
  if (v38)
  {
    v24 = (unint64_t *)&v38->__shared_owners_;
    do
      v25 = __ldaxr(v24);
    while (__stlxr(v25 - 1, v24));
    if (!v25)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }
  v26 = v29;
  v29 = 0;
  if (v26)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v29, v26);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v30);
  return 1;
}

void sub_216A65350(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

uint64_t QMISuppServicesCommandDriver::fetchCLIR(uint64_t a1, int a2)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  unint64_t *v7;
  uint64_t v8;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v18;
  _OWORD v19[2];
  _QWORD v20[5];
  std::__shared_weak_count *v21;
  char *v22;
  std::__shared_weak_count *v23;
  _QWORD aBlock[5];

  memset(v19, 0, sizeof(v19));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v19);
  v4 = qmi::ClientRouter::get();
  v5 = operator new();
  *(_QWORD *)v5 = v4;
  *(_QWORD *)(v5 + 8) = QMIServiceMsg::create();
  *(_QWORD *)(v5 + 24) = 0;
  *(_QWORD *)(v5 + 32) = 0;
  v18 = v5;
  *(_DWORD *)(v5 + 16) = 120000;
  v6 = operator new(0x28uLL);
  v6[1] = 0;
  v7 = v6 + 1;
  v6[2] = 0;
  *v6 = &off_24D5E8210;
  v6[3] = a1;
  *((_DWORD *)v6 + 8) = a2;
  v22 = (char *)(v6 + 3);
  v23 = (std::__shared_weak_count *)v6;
  v8 = MEMORY[0x24BDAC760];
  v20[0] = MEMORY[0x24BDAC760];
  v20[1] = 1174405120;
  v20[2] = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMISuppServicesCommandDriver9fetchCLIREN10subscriber7SimSlotEE3__0EEOS1_OT__block_invoke;
  v20[3] = &__block_descriptor_tmp_88_1;
  v20[4] = v6 + 3;
  v21 = (std::__shared_weak_count *)v6;
  do
    v9 = __ldxr(v7);
  while (__stxr(v9 + 1, v7));
  aBlock[0] = v8;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_30;
  aBlock[3] = &unk_24D5E7978;
  aBlock[4] = v20;
  *(_QWORD *)(v5 + 32) = _Block_copy(aBlock);
  v10 = v21;
  if (v21)
  {
    p_shared_owners = (unint64_t *)&v21->__shared_owners_;
    do
      v12 = __ldaxr(p_shared_owners);
    while (__stlxr(v12 - 1, p_shared_owners));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  v13 = v23;
  if (v23)
  {
    v14 = (unint64_t *)&v23->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  v16 = v18;
  v18 = 0;
  if (v16)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v18, v16);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v19);
  return 1;
}

void sub_216A65594(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  va_list va;

  va_start(va, a3);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v4);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v5 - 88);
  if (a3)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v3, a3);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN28QMISuppServicesCommandDriver18handleCLIRResponseEN10subscriber7SimSlotERKN2vs7GetCLIR8ResponseE_block_invoke(uint64_t result, _WORD *a2)
{
  *(_WORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = *a2;
  return result;
}

__n128 __Block_byref_object_copy__45(uint64_t a1, uint64_t a2)
{
  __n128 result;

  result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 40) = result;
  *(_QWORD *)(a2 + 40) = 0;
  *(_QWORD *)(a2 + 48) = 0;
  return result;
}

uint64_t __Block_byref_object_dispose__46(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 40);
}

uint64_t ___ZN28QMISuppServicesCommandDriver18handleCLIRResponseEN10subscriber7SimSlotERKN2vs7GetCLIR8ResponseE_block_invoke_47(uint64_t result, _BYTE *a2)
{
  **(_BYTE **)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 40) = *a2;
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 40) + 1) = a2[1];
  return result;
}

uint64_t QMISuppServicesCommandDriver::setCLIR(uint64_t a1)
{
  NSObject *v1;
  uint8_t v3[16];

  v1 = *(NSObject **)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 80) + 16))(*(_QWORD *)(a1 + 80));
  if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)v3 = 0;
    _os_log_error_impl(&dword_216897000, v1, OS_LOG_TYPE_ERROR, "setCLIR not supported", v3, 2u);
  }
  return 0;
}

uint64_t QMISuppServicesCommandDriver::fetchCLIP(uint64_t a1, int a2)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  unint64_t *v7;
  uint64_t v8;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v18;
  _OWORD v19[2];
  _QWORD v20[5];
  std::__shared_weak_count *v21;
  char *v22;
  std::__shared_weak_count *v23;
  _QWORD aBlock[5];

  memset(v19, 0, sizeof(v19));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v19);
  v4 = qmi::ClientRouter::get();
  v5 = operator new();
  *(_QWORD *)v5 = v4;
  *(_QWORD *)(v5 + 8) = QMIServiceMsg::create();
  *(_QWORD *)(v5 + 24) = 0;
  *(_QWORD *)(v5 + 32) = 0;
  v18 = v5;
  *(_DWORD *)(v5 + 16) = 120000;
  v6 = operator new(0x28uLL);
  v6[1] = 0;
  v7 = v6 + 1;
  v6[2] = 0;
  *v6 = &off_24D5E8308;
  v6[3] = a1;
  *((_DWORD *)v6 + 8) = a2;
  v22 = (char *)(v6 + 3);
  v23 = (std::__shared_weak_count *)v6;
  v8 = MEMORY[0x24BDAC760];
  v20[0] = MEMORY[0x24BDAC760];
  v20[1] = 1174405120;
  v20[2] = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMISuppServicesCommandDriver9fetchCLIPEN10subscriber7SimSlotEE3__0EEOS1_OT__block_invoke;
  v20[3] = &__block_descriptor_tmp_89_1;
  v20[4] = v6 + 3;
  v21 = (std::__shared_weak_count *)v6;
  do
    v9 = __ldxr(v7);
  while (__stxr(v9 + 1, v7));
  aBlock[0] = v8;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_30;
  aBlock[3] = &unk_24D5E7978;
  aBlock[4] = v20;
  *(_QWORD *)(v5 + 32) = _Block_copy(aBlock);
  v10 = v21;
  if (v21)
  {
    p_shared_owners = (unint64_t *)&v21->__shared_owners_;
    do
      v12 = __ldaxr(p_shared_owners);
    while (__stlxr(v12 - 1, p_shared_owners));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  v13 = v23;
  if (v23)
  {
    v14 = (unint64_t *)&v23->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  v16 = v18;
  v18 = 0;
  if (v16)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v18, v16);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v19);
  return 1;
}

void sub_216A658BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  va_list va;

  va_start(va, a3);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v4);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v5 - 88);
  if (a3)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v3, a3);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

void ___ZN28QMISuppServicesCommandDriver18handleCLIPResponseEN10subscriber7SimSlotERKN2vs7GetCLIP8ResponseE_block_invoke(uint64_t a1, _WORD *a2)
{
  NSObject *v4;
  uint8_t v5[16];

  v4 = *(NSObject **)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 40) + 80) + 16))(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 80), *(unsigned int *)(a1 + 48));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v5 = 0;
    _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I Failure cause is present in the response", v5, 2u);
  }
  *(_WORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *a2;
}

__n128 __Block_byref_object_copy__51(uint64_t a1, uint64_t a2)
{
  __n128 result;

  result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 40) = result;
  *(_QWORD *)(a2 + 40) = 0;
  *(_QWORD *)(a2 + 48) = 0;
  return result;
}

uint64_t __Block_byref_object_dispose__52(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 40);
}

uint64_t ___ZN28QMISuppServicesCommandDriver18handleCLIPResponseEN10subscriber7SimSlotERKN2vs7GetCLIP8ResponseE_block_invoke_53(uint64_t result, _BYTE *a2)
{
  **(_BYTE **)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 40) = *a2;
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 40) + 1) = a2[1];
  return result;
}

uint64_t QMISuppServicesCommandDriver::setCLIP(uint64_t a1)
{
  NSObject *v1;
  uint8_t v3[16];

  v1 = *(NSObject **)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 80) + 16))(*(_QWORD *)(a1 + 80));
  if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)v3 = 0;
    _os_log_error_impl(&dword_216897000, v1, OS_LOG_TYPE_ERROR, "setCLIP not supported", v3, 2u);
  }
  return 0;
}

uint64_t QMISuppServicesCommandDriver::fetchCOLR(uint64_t a1, int a2)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  unint64_t *v7;
  uint64_t v8;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v18;
  _OWORD v19[2];
  _QWORD v20[5];
  std::__shared_weak_count *v21;
  char *v22;
  std::__shared_weak_count *v23;
  _QWORD aBlock[5];

  memset(v19, 0, sizeof(v19));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v19);
  v4 = qmi::ClientRouter::get();
  v5 = operator new();
  *(_QWORD *)v5 = v4;
  *(_QWORD *)(v5 + 8) = QMIServiceMsg::create();
  *(_DWORD *)(v5 + 16) = 25000;
  *(_QWORD *)(v5 + 24) = 0;
  *(_QWORD *)(v5 + 32) = 0;
  v18 = v5;
  v6 = operator new(0x28uLL);
  v6[1] = 0;
  v7 = v6 + 1;
  v6[2] = 0;
  *v6 = &off_24D5E8400;
  v6[3] = a1;
  *((_DWORD *)v6 + 8) = a2;
  v22 = (char *)(v6 + 3);
  v23 = (std::__shared_weak_count *)v6;
  v8 = MEMORY[0x24BDAC760];
  v20[0] = MEMORY[0x24BDAC760];
  v20[1] = 1174405120;
  v20[2] = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMISuppServicesCommandDriver9fetchCOLREN10subscriber7SimSlotEE3__0EEOS1_OT__block_invoke;
  v20[3] = &__block_descriptor_tmp_90_1;
  v20[4] = v6 + 3;
  v21 = (std::__shared_weak_count *)v6;
  do
    v9 = __ldxr(v7);
  while (__stxr(v9 + 1, v7));
  aBlock[0] = v8;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_30;
  aBlock[3] = &unk_24D5E7978;
  aBlock[4] = v20;
  *(_QWORD *)(v5 + 32) = _Block_copy(aBlock);
  v10 = v21;
  if (v21)
  {
    p_shared_owners = (unint64_t *)&v21->__shared_owners_;
    do
      v12 = __ldaxr(p_shared_owners);
    while (__stlxr(v12 - 1, p_shared_owners));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  v13 = v23;
  if (v23)
  {
    v14 = (unint64_t *)&v23->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  v16 = v18;
  v18 = 0;
  if (v16)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v18, v16);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v19);
  return 1;
}

void sub_216A65C60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  va_list va;

  va_start(va, a3);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v4);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v5 - 88);
  if (a3)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v3, a3);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

uint64_t QMISuppServicesCommandDriver::fetchCNAP(uint64_t a1, int a2)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  unint64_t *v7;
  uint64_t v8;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v18;
  _OWORD v19[2];
  _QWORD v20[5];
  std::__shared_weak_count *v21;
  char *v22;
  std::__shared_weak_count *v23;
  _QWORD aBlock[5];

  memset(v19, 0, sizeof(v19));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v19);
  v4 = qmi::ClientRouter::get();
  v5 = operator new();
  *(_QWORD *)v5 = v4;
  *(_QWORD *)(v5 + 8) = QMIServiceMsg::create();
  *(_DWORD *)(v5 + 16) = 25000;
  *(_QWORD *)(v5 + 24) = 0;
  *(_QWORD *)(v5 + 32) = 0;
  v18 = v5;
  v6 = operator new(0x28uLL);
  v6[1] = 0;
  v7 = v6 + 1;
  v6[2] = 0;
  *v6 = &off_24D5E8520;
  v6[3] = a1;
  *((_DWORD *)v6 + 8) = a2;
  v22 = (char *)(v6 + 3);
  v23 = (std::__shared_weak_count *)v6;
  v8 = MEMORY[0x24BDAC760];
  v20[0] = MEMORY[0x24BDAC760];
  v20[1] = 1174405120;
  v20[2] = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMISuppServicesCommandDriver9fetchCNAPEN10subscriber7SimSlotEE3__0EEOS1_OT__block_invoke;
  v20[3] = &__block_descriptor_tmp_96_2;
  v20[4] = v6 + 3;
  v21 = (std::__shared_weak_count *)v6;
  do
    v9 = __ldxr(v7);
  while (__stxr(v9 + 1, v7));
  aBlock[0] = v8;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_30;
  aBlock[3] = &unk_24D5E7978;
  aBlock[4] = v20;
  *(_QWORD *)(v5 + 32) = _Block_copy(aBlock);
  v10 = v21;
  if (v21)
  {
    p_shared_owners = (unint64_t *)&v21->__shared_owners_;
    do
      v12 = __ldaxr(p_shared_owners);
    while (__stlxr(v12 - 1, p_shared_owners));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  v13 = v23;
  if (v23)
  {
    v14 = (unint64_t *)&v23->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  v16 = v18;
  v18 = 0;
  if (v16)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v18, v16);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v19);
  return 1;
}

void sub_216A65EB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  va_list va;

  va_start(va, a3);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v4);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v5 - 88);
  if (a3)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v3, a3);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN28QMISuppServicesCommandDriver18handleCNAPResponseEN10subscriber7SimSlotERKN2vs7GetCNAP8ResponseE_block_invoke(uint64_t result, _WORD *a2)
{
  *(_WORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = *a2;
  return result;
}

__n128 __Block_byref_object_copy__56(uint64_t a1, uint64_t a2)
{
  __n128 result;

  result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 40) = result;
  *(_QWORD *)(a2 + 40) = 0;
  *(_QWORD *)(a2 + 48) = 0;
  return result;
}

uint64_t __Block_byref_object_dispose__57(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 40);
}

uint64_t std::__split_buffer<CallForwardServiceParameter>::~__split_buffer(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v3 = *(_QWORD *)(a1 + 8);
  v2 = *(_QWORD *)(a1 + 16);
  if (v2 != v3)
  {
    do
    {
      v4 = v2 - 40;
      *(_QWORD *)(a1 + 16) = v2 - 40;
      if (*(char *)(v2 - 9) < 0)
      {
        operator delete(*(void **)(v2 - 32));
        v4 = *(_QWORD *)(a1 + 16);
      }
      v2 = v4;
    }
    while (v4 != v3);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t *std::shared_ptr<QMISuppServicesCommandDriver>::shared_ptr[abi:ne180100]<QMISuppServicesCommandDriver,std::shared_ptr<QMISuppServicesCommandDriver> ctu::SharedSynchronizable<SuppServicesCommandDriver>::make_shared_ptr<QMISuppServicesCommandDriver>(QMISuppServicesCommandDriver*)::{lambda(QMISuppServicesCommandDriver*)#1},void>(uint64_t *a1, uint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24D5E76E8;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = (uint64_t)v4;
  if (a2)
    v5 = (_QWORD *)(a2 + 8);
  else
    v5 = 0;
  std::shared_ptr<QMIDataSystemDeterminationManager>::__enable_weak_this[abi:ne180100]<QMIDataSystemDeterminationManager,QMIDataSystemDeterminationManager,void>((uint64_t)a1, v5, a2);
  return a1;
}

void sub_216A66020(void *a1)
{
  dispatch_queue_t *v1;

  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)std::shared_ptr<QMISuppServicesCommandDriver> ctu::SharedSynchronizable<SuppServicesCommandDriver>::make_shared_ptr<QMISuppServicesCommandDriver>(QMISuppServicesCommandDriver*)::{lambda(QMISuppServicesCommandDriver*)#1}::operator() const(QMISuppServicesCommandDriver*)::{lambda(void *)#1}::__invoke);
  __cxa_rethrow();
}

void sub_216A66040(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<QMISuppServicesCommandDriver *,std::shared_ptr<QMISuppServicesCommandDriver> ctu::SharedSynchronizable<SuppServicesCommandDriver>::make_shared_ptr<QMISuppServicesCommandDriver>(QMISuppServicesCommandDriver*)::{lambda(QMISuppServicesCommandDriver *)#1},std::allocator<QMISuppServicesCommandDriver>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void std::__shared_ptr_pointer<QMISuppServicesCommandDriver *,std::shared_ptr<QMISuppServicesCommandDriver> ctu::SharedSynchronizable<SuppServicesCommandDriver>::make_shared_ptr<QMISuppServicesCommandDriver>(QMISuppServicesCommandDriver*)::{lambda(QMISuppServicesCommandDriver *)#1},std::allocator<QMISuppServicesCommandDriver>>::__on_zero_shared(uint64_t a1)
{
  dispatch_barrier_async_f(*(dispatch_queue_t *)(*(_QWORD *)(a1 + 24) + 24), *(void **)(a1 + 24), (dispatch_function_t)std::shared_ptr<QMISuppServicesCommandDriver> ctu::SharedSynchronizable<SuppServicesCommandDriver>::make_shared_ptr<QMISuppServicesCommandDriver>(QMISuppServicesCommandDriver*)::{lambda(QMISuppServicesCommandDriver*)#1}::operator() const(QMISuppServicesCommandDriver*)::{lambda(void *)#1}::__invoke);
}

uint64_t std::__shared_ptr_pointer<QMISuppServicesCommandDriver *,std::shared_ptr<QMISuppServicesCommandDriver> ctu::SharedSynchronizable<SuppServicesCommandDriver>::make_shared_ptr<QMISuppServicesCommandDriver>(QMISuppServicesCommandDriver*)::{lambda(QMISuppServicesCommandDriver *)#1},std::allocator<QMISuppServicesCommandDriver>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t std::shared_ptr<QMISuppServicesCommandDriver> ctu::SharedSynchronizable<SuppServicesCommandDriver>::make_shared_ptr<QMISuppServicesCommandDriver>(QMISuppServicesCommandDriver*)::{lambda(QMISuppServicesCommandDriver*)#1}::operator() const(QMISuppServicesCommandDriver*)::{lambda(void *)#1}::__invoke(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

void SimInstanceLoggable<QMISuppServicesCommandDriver,ctu::OsLogLogger,subscriber::SimSlot>::~SimInstanceLoggable()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t SimInstanceLoggable<QMISuppServicesCommandDriver,ctu::OsLogLogger,subscriber::SimSlot>::getLoggerForSlot(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8) + 40;
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<SuppServicesCommandDriver>::execute_wrapped<QMISuppServicesCommandDriver::bootstrap(std::shared_ptr<SuppServicesDriverEventHandlerInterface>,dispatch::group_session)::$_0>(QMISuppServicesCommandDriver::bootstrap(std::shared_ptr<SuppServicesDriverEventHandlerInterface>,dispatch::group_session)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMISuppServicesCommandDriver::bootstrap(std::shared_ptr<SuppServicesDriverEventHandlerInterface>,dispatch::group_session)::$_0,std::default_delete<QMISuppServicesCommandDriver::bootstrap(std::shared_ptr<SuppServicesDriverEventHandlerInterface>,dispatch::group_session)::$_0>>)::{lambda(void *)#1}::__invoke(_QWORD **a1)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  uint64_t SimSlotRange;
  _DWORD *v11;
  char *v12;
  std::__shared_weak_count *v13;
  uint64_t v14;
  std::__shared_weak_count *v15;
  std::__shared_weak_count *v16;
  NSObject *v17;
  unint64_t *p_shared_weak_owners;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  unint64_t *v23;
  unint64_t v24;
  unint64_t *v25;
  unint64_t v26;
  _DWORD *v27;
  __int128 *v28;
  uint64_t v29;
  _QWORD **v31;
  _QWORD *v32;
  _DWORD *v33;
  _DWORD *v34;
  uint64_t (*v35)(_QWORD);
  __int128 v36;
  void *v37[2];
  __int128 v38;
  __int128 v39;
  uint64_t v40;
  std::__shared_weak_count *v41;
  void *__p;
  char v43;
  dispatch_object_t v44;
  __int128 v45;
  __int128 v46;
  uint64_t v47;

  v47 = *MEMORY[0x24BDAC8D0];
  v1 = *a1;
  v31 = a1;
  v32 = v1;
  v3 = *v1;
  v2 = v1[1];
  v4 = v1[2];
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  v7 = *(std::__shared_weak_count **)(v3 + 72);
  *(_QWORD *)(v3 + 64) = v2;
  *(_QWORD *)(v3 + 72) = v4;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  SimSlotRange = subscriber::makeSimSlotRange();
  v11 = v33;
  if (v33 != v34)
  {
    while (1)
    {
      SimSlotRange = v35(*v11);
      if ((SimSlotRange & 1) != 0)
        break;
      if (++v11 == v34)
      {
        v11 = v34;
        break;
      }
    }
    while (v11 != v34)
    {
      if (*v11 == 1)
      {
        v12 = "SuppServices.1";
      }
      else if (*v11 == 2)
      {
        v12 = "SuppServices.2";
      }
      else
      {
        v12 = 0;
      }
      v13 = *(std::__shared_weak_count **)(v3 + 16);
      if (!v13 || (v14 = *(_QWORD *)(v3 + 8), (v15 = std::__shared_weak_count::lock(v13)) == 0))
        std::__throw_bad_weak_ptr[abi:ne180100]();
      v16 = v15;
      Registry::getServerConnection(*(Registry **)(v3 + 48));
      v45 = 0u;
      v46 = 0u;
      std::string::basic_string[abi:ne180100]<0>(v37, v12);
      v17 = *(NSObject **)(v3 + 24);
      v44 = v17;
      if (v17)
        dispatch_retain(v17);
      std::string::basic_string[abi:ne180100]<0>(&__p, "supp");
      v40 = v14;
      v41 = v16;
      p_shared_weak_owners = (unint64_t *)&v16->__shared_weak_owners_;
      do
        v19 = __ldxr(p_shared_weak_owners);
      while (__stxr(v19 + 1, p_shared_weak_owners));
      v39 = v36;
      v36 = 0uLL;
      qmi::Client::createWithQueueLocal();
      v20 = (std::__shared_weak_count *)*((_QWORD *)&v39 + 1);
      if (*((_QWORD *)&v39 + 1))
      {
        v21 = (unint64_t *)(*((_QWORD *)&v39 + 1) + 8);
        do
          v22 = __ldaxr(v21);
        while (__stlxr(v22 - 1, v21));
        if (!v22)
        {
          ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
          std::__shared_weak_count::__release_weak(v20);
        }
      }
      if (v41)
        std::__shared_weak_count::__release_weak(v41);
      if (v43 < 0)
        operator delete(__p);
      if (v44)
        dispatch_release(v44);
      if (SBYTE7(v38) < 0)
        operator delete(v37[0]);
      v37[0] = 0;
      v37[1] = 0;
      v38 = v46;
      v46 = 0uLL;
      qmi::ClientRouter::addClient();
      qmi::Client::~Client((qmi::Client *)v37);
      qmi::ClientRouter::get();
      qmi::Client::~Client((qmi::Client *)&v45);
      if (*((_QWORD *)&v36 + 1))
      {
        v23 = (unint64_t *)(*((_QWORD *)&v36 + 1) + 8);
        do
          v24 = __ldaxr(v23);
        while (__stlxr(v24 - 1, v23));
        if (!v24)
        {
          (*(void (**)(_QWORD))(**((_QWORD **)&v36 + 1) + 16))(*((_QWORD *)&v36 + 1));
          std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v36 + 1));
        }
      }
      v25 = (unint64_t *)&v16->__shared_owners_;
      do
        v26 = __ldaxr(v25);
      while (__stlxr(v26 - 1, v25));
      if (!v26)
      {
        ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
        std::__shared_weak_count::__release_weak(v16);
      }
      v27 = v11 + 1;
      v11 = v34;
      if (v27 != v34)
      {
        v11 = v27;
        while (1)
        {
          SimSlotRange = v35(*v11);
          if ((SimSlotRange & 1) != 0)
            break;
          if (++v11 == v34)
          {
            v11 = v34;
            break;
          }
        }
      }
    }
  }
  if (capabilities::ct::supportsGemini((capabilities::ct *)SimSlotRange))
  {
    *(_QWORD *)&v45 = &off_24D5E7788;
    *((_QWORD *)&v45 + 1) = v3;
    *((_QWORD *)&v46 + 1) = &v45;
    qmi::ClientRouter::setHandler();
    v28 = (__int128 *)*((_QWORD *)&v46 + 1);
    if (*((__int128 **)&v46 + 1) == &v45)
    {
      v29 = 4;
      v28 = &v45;
      goto LABEL_58;
    }
    if (*((_QWORD *)&v46 + 1))
    {
      v29 = 5;
LABEL_58:
      (*(void (**)(void))(*(_QWORD *)v28 + 8 * v29))();
    }
  }
  std::unique_ptr<QMISuppServicesCommandDriver::bootstrap(std::shared_ptr<SuppServicesDriverEventHandlerInterface>,dispatch::group_session)::$_0,std::default_delete<QMISuppServicesCommandDriver::bootstrap(std::shared_ptr<SuppServicesDriverEventHandlerInterface>,dispatch::group_session)::$_0>>::~unique_ptr[abi:ne180100]((uint64_t *)&v32);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v31);
}

void sub_216A664E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,std::__shared_weak_count *a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  _QWORD *v35;
  uint64_t v36;
  _QWORD *v38;
  uint64_t v39;

  v38 = *(_QWORD **)(v36 - 120);
  if (v38 == v35)
  {
    v39 = 4;
    v38 = (_QWORD *)(v36 - 144);
  }
  else
  {
    if (!v38)
      goto LABEL_6;
    v39 = 5;
  }
  (*(void (**)(void))(*v38 + 8 * v39))();
LABEL_6:
  std::unique_ptr<QMISuppServicesCommandDriver::bootstrap(std::shared_ptr<SuppServicesDriverEventHandlerInterface>,dispatch::group_session)::$_0,std::default_delete<QMISuppServicesCommandDriver::bootstrap(std::shared_ptr<SuppServicesDriverEventHandlerInterface>,dispatch::group_session)::$_0>>::~unique_ptr[abi:ne180100](&a13);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&a12);
  _Unwind_Resume(a1);
}

uint64_t *std::unique_ptr<QMISuppServicesCommandDriver::bootstrap(std::shared_ptr<SuppServicesDriverEventHandlerInterface>,dispatch::group_session)::$_0,std::default_delete<QMISuppServicesCommandDriver::bootstrap(std::shared_ptr<SuppServicesDriverEventHandlerInterface>,dispatch::group_session)::$_0>>::~unique_ptr[abi:ne180100](uint64_t *a1)
{
  uint64_t v2;
  NSObject *v3;
  NSObject *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;

  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    v3 = *(NSObject **)(v2 + 24);
    if (v3)
    {
      dispatch_group_leave(v3);
      v4 = *(NSObject **)(v2 + 24);
      if (v4)
        dispatch_release(v4);
    }
    v5 = *(std::__shared_weak_count **)(v2 + 16);
    if (v5)
    {
      p_shared_owners = (unint64_t *)&v5->__shared_owners_;
      do
        v7 = __ldaxr(p_shared_owners);
      while (__stlxr(v7 - 1, p_shared_owners));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
    }
    MEMORY[0x2199FEAC4](v2, 0x20C40DC1BFBCFLL);
  }
  return a1;
}

void _ZNSt3__110__function6__funcIZZN28QMISuppServicesCommandDriver9bootstrapENS_10shared_ptrI39SuppServicesDriverEventHandlerInterfaceEEN8dispatch13group_sessionEENK3__0clEvEUlT_E0_NS_9allocatorISA_EEFvN3qmi16SubscriptionTypeEEED0Ev()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *_ZNKSt3__110__function6__funcIZZN28QMISuppServicesCommandDriver9bootstrapENS_10shared_ptrI39SuppServicesDriverEventHandlerInterfaceEEN8dispatch13group_sessionEENK3__0clEvEUlT_E0_NS_9allocatorISA_EEFvN3qmi16SubscriptionTypeEEE7__cloneEv(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5E7788;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZZN28QMISuppServicesCommandDriver9bootstrapENS_10shared_ptrI39SuppServicesDriverEventHandlerInterfaceEEN8dispatch13group_sessionEENK3__0clEvEUlT_E0_NS_9allocatorISA_EEFvN3qmi16SubscriptionTypeEEE7__cloneEPNS0_6__baseISF_EE(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5E7788;
  a2[1] = v2;
  return result;
}

void _ZNSt3__110__function6__funcIZZN28QMISuppServicesCommandDriver9bootstrapENS_10shared_ptrI39SuppServicesDriverEventHandlerInterfaceEEN8dispatch13group_sessionEENK3__0clEvEUlT_E0_NS_9allocatorISA_EEFvN3qmi16SubscriptionTypeEEEclEOSE_(uint64_t a1, int *a2)
{
  int v2;
  std::__shared_weak_count_vtbl *v3;
  uint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _OWORD v17[2];
  _QWORD v18[5];
  std::__shared_weak_count *v19;
  _QWORD aBlock[5];

  v2 = *a2;
  v3 = *(std::__shared_weak_count_vtbl **)(a1 + 8);
  memset(v17, 0, sizeof(v17));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v17);
  *(_BYTE *)qmi::MutableMessageBase::getTLV<vs::tlv::SubscriptionType>(v17, 1) = v2 == 2;
  v4 = qmi::ClientRouter::get();
  qmi::ClientRouter::SendProxy::SendProxy<vs::BindSubscription::Request>((uint64_t)&v15, v2, v4);
  v5 = (std::__shared_weak_count *)operator new(0x28uLL);
  v5->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v5->__shared_owners_;
  v5->__shared_weak_owners_ = 0;
  v5->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E7838;
  v5[1].__vftable = v3;
  LODWORD(v5[1].__shared_owners_) = v2;
  v7 = v16;
  v8 = MEMORY[0x24BDAC760];
  v18[0] = MEMORY[0x24BDAC760];
  v18[1] = 1174405120;
  v18[2] = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMISuppServicesCommandDriver21bindSubscription_syncENS_16SubscriptionTypeEE3__0EEOS1_OT__block_invoke;
  v18[3] = &__block_descriptor_tmp_69_7;
  v18[4] = v5 + 1;
  v19 = v5;
  do
    v9 = __ldxr(p_shared_owners);
  while (__stxr(v9 + 1, p_shared_owners));
  aBlock[0] = v8;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKN2vs16BindSubscription8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke_1;
  aBlock[3] = &unk_24D5E7880;
  aBlock[4] = v18;
  *(_QWORD *)(v7 + 32) = _Block_copy(aBlock);
  v10 = v19;
  if (v19)
  {
    v11 = (unint64_t *)&v19->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  do
    v13 = __ldaxr(p_shared_owners);
  while (__stlxr(v13 - 1, p_shared_owners));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  v14 = v16;
  v16 = 0;
  if (v14)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v16, v14);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v17);
}

void sub_216A668D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21)
{
  std::__shared_weak_count *v21;
  unint64_t *v22;
  std::__shared_weak_count *v24;
  unint64_t *p_shared_owners;
  unint64_t v26;
  unint64_t v27;
  uint64_t v28;

  v24 = a21;
  if (a21)
  {
    p_shared_owners = (unint64_t *)&a21->__shared_owners_;
    do
      v26 = __ldaxr(p_shared_owners);
    while (__stlxr(v26 - 1, p_shared_owners));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
  }
  do
    v27 = __ldaxr(v22);
  while (__stlxr(v27 - 1, v22));
  if (!v27)
  {
    ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
    std::__shared_weak_count::__release_weak(v21);
  }
  v28 = a10;
  a10 = 0;
  if (v28)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&a10, v28);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a11);
  _Unwind_Resume(a1);
}

uint64_t _ZNKSt3__110__function6__funcIZZN28QMISuppServicesCommandDriver9bootstrapENS_10shared_ptrI39SuppServicesDriverEventHandlerInterfaceEEN8dispatch13group_sessionEENK3__0clEvEUlT_E0_NS_9allocatorISA_EEFvN3qmi16SubscriptionTypeEEE6targetERKSt9type_info(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](a2, (uint64_t)&_ZTIZZN28QMISuppServicesCommandDriver9bootstrapENSt3__110shared_ptrI39SuppServicesDriverEventHandlerInterfaceEEN8dispatch13group_sessionEENK3__0clEvEUlT_E0_))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *_ZNKSt3__110__function6__funcIZZN28QMISuppServicesCommandDriver9bootstrapENS_10shared_ptrI39SuppServicesDriverEventHandlerInterfaceEEN8dispatch13group_sessionEENK3__0clEvEUlT_E0_NS_9allocatorISA_EEFvN3qmi16SubscriptionTypeEEE11target_typeEv()
{
  return &_ZTIZZN28QMISuppServicesCommandDriver9bootstrapENSt3__110shared_ptrI39SuppServicesDriverEventHandlerInterfaceEEN8dispatch13group_sessionEENK3__0clEvEUlT_E0_;
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<SuppServicesCommandDriver>::execute_wrapped<QMISuppServicesCommandDriver::start(void)::$_0>(QMISuppServicesCommandDriver::start(void)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMISuppServicesCommandDriver::start(void)::$_0,dispatch_queue_s *::default_delete<QMISuppServicesCommandDriver::start(void)::$_0>>)::{lambda(void *)#1}::__invoke(_QWORD *a1)
{
  uint64_t v1;
  _QWORD *v3;

  v3 = a1;
  v1 = *a1;
  qmi::ClientRouter::start();
  MEMORY[0x2199FEAC4](v1, 0x60C4044C4A2DFLL);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v3);
}

void sub_216A66A1C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  va_list va;

  va_start(va, a2);
  MEMORY[0x2199FEAC4](v2, 0x60C4044C4A2DFLL);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMISuppServicesCommandDriver21bindSubscription_syncENS_16SubscriptionTypeEE3__0EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t *v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  __int16 v12;
  int v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)(a2 + 4))
  {
    v3 = *(uint64_t **)(a1 + 32);
    v4 = *v3;
    v5 = *((_DWORD *)v3 + 2);
    if (v5 - 1 >= 3)
      v6 = 0;
    else
      v6 = v5;
    v7 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v4 + 80) + 16))(*(_QWORD *)(v4 + 80), v6);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      v8 = qmi::asString();
      v9 = *(_DWORD *)(a2 + 4);
      v10 = 136315394;
      v11 = v8;
      v12 = 1024;
      v13 = v9;
      _os_log_error_impl(&dword_216897000, v7, OS_LOG_TYPE_ERROR, "Error binding subscription: %s (0x%x)", (uint8_t *)&v10, 0x12u);
    }
  }
}

uint64_t __copy_helper_block_e8_32c111_ZTSNSt3__110shared_ptrIZN28QMISuppServicesCommandDriver21bindSubscription_syncEN3qmi16SubscriptionTypeEE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c111_ZTSNSt3__110shared_ptrIZN28QMISuppServicesCommandDriver21bindSubscription_syncEN3qmi16SubscriptionTypeEE3__0EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMISuppServicesCommandDriver::bindSubscription_sync(qmi::SubscriptionType)::$_0,std::allocator<QMISuppServicesCommandDriver::bindSubscription_sync(qmi::SubscriptionType)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E7838;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMISuppServicesCommandDriver::bindSubscription_sync(qmi::SubscriptionType)::$_0,std::allocator<QMISuppServicesCommandDriver::bindSubscription_sync(qmi::SubscriptionType)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E7838;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN2vs16BindSubscription8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke_1(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BYTE v3[24];

  v2 = *(_QWORD *)(a1 + 32);
  cast_message_type<vs::BindSubscription::Response const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_216A66BE8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<vs::tlv::AutoAnswer>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<vs::tlv::AutoAnswer>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<vs::tlv::AutoAnswer>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<vs::tlv::AutoAnswer>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E78C8;
  return result;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMISuppServicesCommandDriver17setAutoAnswerModeEN10subscriber7SimSlotEbE3__0EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  NSObject *v3;
  int v4;
  _DWORD v5[2];
  __int16 v6;
  uint64_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)(a2 + 4))
  {
    v3 = *(NSObject **)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(**(_QWORD **)(a1 + 32) + 80) + 16))(*(_QWORD *)(**(_QWORD **)(a1 + 32) + 80), *(unsigned int *)(*(_QWORD *)(a1 + 32) + 8));
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      v4 = *(_DWORD *)(a2 + 4);
      v5[0] = 67109378;
      v5[1] = v4;
      v6 = 2080;
      v7 = qmi::asString();
      _os_log_error_impl(&dword_216897000, v3, OS_LOG_TYPE_ERROR, "setAutoAnswerMode::Response returned error 0x%x (%s)", (uint8_t *)v5, 0x12u);
    }
  }
}

uint64_t __copy_helper_block_e8_32c106_ZTSNSt3__110shared_ptrIZN28QMISuppServicesCommandDriver17setAutoAnswerModeEN10subscriber7SimSlotEbE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c106_ZTSNSt3__110shared_ptrIZN28QMISuppServicesCommandDriver17setAutoAnswerModeEN10subscriber7SimSlotEbE3__0EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMISuppServicesCommandDriver::setAutoAnswerMode(subscriber::SimSlot,BOOL)::$_0,std::allocator<QMISuppServicesCommandDriver::setAutoAnswerMode(subscriber::SimSlot,BOOL)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E7930;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMISuppServicesCommandDriver::setAutoAnswerMode(subscriber::SimSlot,BOOL)::$_0,std::allocator<QMISuppServicesCommandDriver::setAutoAnswerMode(subscriber::SimSlot,BOOL)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E7930;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

char *qmi::MutableMessageBase::getTLV<vs::tlv::Reason>(_QWORD *a1)
{
  const void **v2;
  const void **v3;
  char **v4;
  char *v5;
  char *result;
  uint64_t v7;
  unint64_t v8;
  uint64_t *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  v4 = (char **)(a1 + 1);
  if (v2 != v3)
  {
    while (*((_BYTE *)*v2 + 8) != 1)
    {
      if (++v2 == v3)
        goto LABEL_8;
    }
  }
  if (v2 == v3)
  {
LABEL_8:
    v7 = operator new();
    *(_WORD *)(v7 + 8) = 1;
    *(_QWORD *)v7 = &off_24D5E79C0;
    v8 = a1[3];
    v9 = (uint64_t *)a1[2];
    if ((unint64_t)v9 >= v8)
    {
      v11 = ((char *)v9 - *v4) >> 3;
      if ((unint64_t)(v11 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v12 = v8 - (_QWORD)*v4;
      v13 = v12 >> 2;
      if (v12 >> 2 <= (unint64_t)(v11 + 1))
        v13 = v11 + 1;
      if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
        v14 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v14 = v13;
      if (v14)
        v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v14);
      else
        v15 = 0;
      v16 = (uint64_t *)&v15[8 * v11];
      v17 = &v15[8 * v14];
      *v16 = v7;
      v10 = v16 + 1;
      v19 = (char *)a1[1];
      v18 = (char *)a1[2];
      if (v18 != v19)
      {
        do
        {
          v20 = *((_QWORD *)v18 - 1);
          v18 -= 8;
          *--v16 = v20;
        }
        while (v18 != v19);
        v18 = *v4;
      }
      a1[1] = v16;
      a1[2] = v10;
      a1[3] = v17;
      if (v18)
        operator delete(v18);
    }
    else
    {
      *v9 = v7;
      v10 = v9 + 1;
    }
    result = (char *)(v7 + 9);
    a1[2] = v10;
  }
  else
  {
    if (!v5)
      __cxa_bad_cast();
    return v5 + 9;
  }
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<vs::tlv::Reason>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<vs::tlv::Reason>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<vs::tlv::Reason>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<vs::tlv::Reason>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E79C0;
  return result;
}

char *qmi::MutableMessageBase::getTLV<vs::tlv::ServiceClass>(_QWORD *a1)
{
  const void **v2;
  const void **v3;
  char **v4;
  char *v5;
  char *result;
  uint64_t v7;
  unint64_t v8;
  uint64_t *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  v4 = (char **)(a1 + 1);
  if (v2 != v3)
  {
    while (*((_BYTE *)*v2 + 8) != 16)
    {
      if (++v2 == v3)
        goto LABEL_8;
    }
  }
  if (v2 == v3)
  {
LABEL_8:
    v7 = operator new();
    *(_WORD *)(v7 + 8) = 16;
    *(_QWORD *)v7 = &off_24D5E7A10;
    v8 = a1[3];
    v9 = (uint64_t *)a1[2];
    if ((unint64_t)v9 >= v8)
    {
      v11 = ((char *)v9 - *v4) >> 3;
      if ((unint64_t)(v11 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v12 = v8 - (_QWORD)*v4;
      v13 = v12 >> 2;
      if (v12 >> 2 <= (unint64_t)(v11 + 1))
        v13 = v11 + 1;
      if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
        v14 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v14 = v13;
      if (v14)
        v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v14);
      else
        v15 = 0;
      v16 = (uint64_t *)&v15[8 * v11];
      v17 = &v15[8 * v14];
      *v16 = v7;
      v10 = v16 + 1;
      v19 = (char *)a1[1];
      v18 = (char *)a1[2];
      if (v18 != v19)
      {
        do
        {
          v20 = *((_QWORD *)v18 - 1);
          v18 -= 8;
          *--v16 = v20;
        }
        while (v18 != v19);
        v18 = *v4;
      }
      a1[1] = v16;
      a1[2] = v10;
      a1[3] = v17;
      if (v18)
        operator delete(v18);
    }
    else
    {
      *v9 = v7;
      v10 = v9 + 1;
    }
    result = (char *)(v7 + 9);
    a1[2] = v10;
  }
  else
  {
    if (!v5)
      __cxa_bad_cast();
    return v5 + 9;
  }
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<vs::tlv::ServiceClass>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<vs::tlv::ServiceClass>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<vs::tlv::ServiceClass>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<vs::tlv::ServiceClass>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E7A10;
  return result;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMISuppServicesCommandDriver19fetchCallForwardingEN10subscriber7SimSlotE22CTCallForwardingReasonjE3__0EEOS1_OT__block_invoke(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  std::__shared_weak_count *v15;
  std::__shared_weak_count *v16;
  unint64_t *p_shared_owners;
  unint64_t v18;
  unsigned __int8 *TlvValue;
  int v20;
  unsigned __int8 *v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t *v25;
  unint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  int v33;
  uint64_t v34;
  _QWORD v35[3];
  void **v36;
  uint64_t v37;
  uint64_t v38;
  void *v39;
  uint64_t *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  __n128 (*v45)(uint64_t, uint64_t);
  uint64_t (*v46)(uint64_t);
  uint64_t v47;
  std::__shared_weak_count *v48;
  unsigned __int8 *v49;
  uint8_t *v50;
  uint8_t buf[8];
  __int128 v52;
  uint64_t v53;

  v53 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(_QWORD *)v2;
  v4 = *(unsigned int *)(v2 + 8);
  v5 = a2[1];
  v35[0] = *a2;
  v35[1] = v5;
  v6 = a2[2];
  v35[2] = v6;
  if (v6)
  {
    v7 = (unint64_t *)(v6 + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  qmi::MessageBase::validateMsgId((qmi::MessageBase *)v35);
  v9 = *(unsigned int *)(v2 + 12);
  v10 = *(unsigned int *)(v2 + 16);
  if (HIDWORD(v35[0]))
  {
    v36 = 0;
    v37 = (uint64_t)&v36;
    v38 = 0x2000000000;
    LOWORD(v39) = 0;
    v42 = MEMORY[0x24BDAC760];
    v43 = 0x40000000;
    v44 = (uint64_t)___ZN28QMISuppServicesCommandDriver28handleCallForwardingResponseEN10subscriber7SimSlotERKN2vs14CallForwarding8ResponseE22CTCallForwardingReasonj_block_invoke;
    v45 = (__n128 (*)(uint64_t, uint64_t))&unk_24D5E7418;
    LODWORD(v48) = v4;
    v46 = (uint64_t (*)(uint64_t))&v36;
    v47 = v3;
    *(_QWORD *)buf = &v42;
    qmi::MessageBase::applyTlv<vs::tlv::FailureCause,void({block_pointer})(vs::tlv::FailureCause const&)>((qmi::MessageBase *)v35, 17, (uint64_t)buf);
    v11 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v3 + 80) + 16))(*(_QWORD *)(v3 + 80), v4);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      v33 = HIDWORD(v35[0]);
      v34 = qmi::asString();
      *(_DWORD *)buf = 67109378;
      *(_DWORD *)&buf[4] = v33;
      LOWORD(v52) = 2080;
      *(_QWORD *)((char *)&v52 + 2) = v34;
      _os_log_error_impl(&dword_216897000, v11, OS_LOG_TYPE_ERROR, "CallForwarding::Response returned error 0x%x (%s)", buf, 0x12u);
    }
    v12 = *(_QWORD *)(v3 + 64);
    v13 = QMISuppServicesCommandDriver::mapQMIErrorToCSI((QMISuppServicesCommandDriver *)v3, *(unsigned __int16 *)(v37 + 24));
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)v12 + 24))(v12, v4, v9, v10, v13, 0);
    _Block_object_dispose(&v36, 8);
  }
  else
  {
    v42 = 0;
    v43 = (uint64_t)&v42;
    v44 = 0x3802000000;
    v45 = __Block_byref_object_copy__10;
    v46 = __Block_byref_object_dispose__10;
    v47 = 0;
    v48 = 0;
    v14 = operator new();
    *(_QWORD *)v14 = 0;
    *(_QWORD *)(v14 + 8) = 0;
    *(_QWORD *)(v14 + 16) = 0;
    v36 = (void **)v14;
    v15 = (std::__shared_weak_count *)operator new();
    v15->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E7AC8;
    v15->__shared_owners_ = 0;
    v15->__shared_weak_owners_ = 0;
    v15[1].__vftable = (std::__shared_weak_count_vtbl *)v14;
    v36 = 0;
    std::unique_ptr<std::vector<CallForwardServiceParameter>>::reset[abi:ne180100](&v36);
    v16 = v48;
    v47 = v14;
    v48 = v15;
    if (v16)
    {
      p_shared_owners = (unint64_t *)&v16->__shared_owners_;
      do
        v18 = __ldaxr(p_shared_owners);
      while (__stlxr(v18 - 1, p_shared_owners));
      if (!v18)
      {
        ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
        std::__shared_weak_count::__release_weak(v16);
      }
    }
    v36 = (void **)MEMORY[0x24BDAC760];
    v37 = 0x40000000;
    v38 = (uint64_t)___ZN28QMISuppServicesCommandDriver28handleCallForwardingResponseEN10subscriber7SimSlotERKN2vs14CallForwarding8ResponseE22CTCallForwardingReasonj_block_invoke_10;
    v39 = &unk_24D5E7440;
    v40 = &v42;
    v41 = v3;
    TlvValue = (unsigned __int8 *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)v35);
    v21 = TlvValue;
    if (TlvValue)
    {
      v22 = v20;
      v49 = TlvValue;
      *(_QWORD *)buf = 0;
      v52 = 0uLL;
      tlv::parseV<vs::tlv::ServiceParams>(&v49, v20, (uint64_t *)buf);
      if (v49)
      {
        ___ZN28QMISuppServicesCommandDriver28handleCallForwardingResponseEN10subscriber7SimSlotERKN2vs14CallForwarding8ResponseE22CTCallForwardingReasonj_block_invoke_10((uint64_t)&v36, (uint64_t *)buf);
        v50 = buf;
        std::vector<vs::tlv::ServiceParam>::__destroy_vector::operator()[abi:ne180100]((void ***)&v50);
      }
      else
      {
        v50 = buf;
        std::vector<vs::tlv::ServiceParam>::__destroy_vector::operator()[abi:ne180100]((void ***)&v50);
        ((void (*)(_QWORD, uint64_t, unsigned __int8 *, _QWORD))*MEMORY[0x24BED8BD0])(LOWORD(v35[0]), 16, v21, v22);
      }
    }
    v23 = *(_QWORD *)(v3 + 64);
    v24 = *(_QWORD *)(v43 + 48);
    *(_QWORD *)buf = *(_QWORD *)(v43 + 40);
    *(_QWORD *)&v52 = v24;
    if (v24)
    {
      v25 = (unint64_t *)(v24 + 8);
      do
        v26 = __ldxr(v25);
      while (__stxr(v26 + 1, v25));
    }
    (*(void (**)(uint64_t, uint64_t, uint8_t *, uint64_t, uint64_t))(*(_QWORD *)v23 + 16))(v23, v4, buf, v9, v10);
    v27 = (std::__shared_weak_count *)v52;
    if ((_QWORD)v52)
    {
      v28 = (unint64_t *)(v52 + 8);
      do
        v29 = __ldaxr(v28);
      while (__stlxr(v29 - 1, v28));
      if (!v29)
      {
        ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
        std::__shared_weak_count::__release_weak(v27);
      }
    }
    _Block_object_dispose(&v42, 8);
    v30 = v48;
    if (v48)
    {
      v31 = (unint64_t *)&v48->__shared_owners_;
      do
        v32 = __ldaxr(v31);
      while (__stlxr(v32 - 1, v31));
      if (!v32)
      {
        ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
        std::__shared_weak_count::__release_weak(v30);
      }
    }
  }
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v35);
}

void sub_216A67688(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18)
{
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  *(_QWORD *)(v20 - 120) = v18;
  std::vector<vs::tlv::ServiceParam>::__destroy_vector::operator()[abi:ne180100]((void ***)(v20 - 120));
  _Block_object_dispose(&a18, 8);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v19 + 40);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_32c132_ZTSNSt3__110shared_ptrIZN28QMISuppServicesCommandDriver19fetchCallForwardingEN10subscriber7SimSlotE22CTCallForwardingReasonjE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c132_ZTSNSt3__110shared_ptrIZN28QMISuppServicesCommandDriver19fetchCallForwardingEN10subscriber7SimSlotE22CTCallForwardingReasonjE3__0EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMISuppServicesCommandDriver::fetchCallForwarding(subscriber::SimSlot,CTCallForwardingReason,unsigned int)::$_0,std::allocator<QMISuppServicesCommandDriver::fetchCallForwarding(subscriber::SimSlot,CTCallForwardingReason,unsigned int)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E7A78;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMISuppServicesCommandDriver::fetchCallForwarding(subscriber::SimSlot,CTCallForwardingReason,unsigned int)::$_0,std::allocator<QMISuppServicesCommandDriver::fetchCallForwarding(subscriber::SimSlot,CTCallForwardingReason,unsigned int)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E7A78;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void std::__shared_ptr_pointer<std::vector<CallForwardServiceParameter> *,std::shared_ptr<std::vector<CallForwardServiceParameter>>::__shared_ptr_default_delete<std::vector<CallForwardServiceParameter>,std::vector<CallForwardServiceParameter>>,std::allocator<std::vector<CallForwardServiceParameter>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

uint64_t std::__shared_ptr_pointer<std::vector<CallForwardServiceParameter> *,std::shared_ptr<std::vector<CallForwardServiceParameter>>::__shared_ptr_default_delete<std::vector<CallForwardServiceParameter>,std::vector<CallForwardServiceParameter>>,std::allocator<std::vector<CallForwardServiceParameter>>>::__on_zero_shared(uint64_t result)
{
  void **v1;

  if (*(_QWORD *)(result + 24))
  {
    v1 = *(void ***)(result + 24);
    std::vector<vs::tlv::ServiceParam>::__destroy_vector::operator()[abi:ne180100](&v1);
    JUMPOUT(0x2199FEAC4);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<std::vector<CallForwardServiceParameter> *,std::shared_ptr<std::vector<CallForwardServiceParameter>>::__shared_ptr_default_delete<std::vector<CallForwardServiceParameter>,std::vector<CallForwardServiceParameter>>,std::allocator<std::vector<CallForwardServiceParameter>>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void ***std::unique_ptr<std::vector<CallForwardServiceParameter>>::reset[abi:ne180100](void ***result)
{
  void **v1;
  void **v2;

  v1 = *result;
  *result = 0;
  if (v1)
  {
    v2 = v1;
    std::vector<vs::tlv::ServiceParam>::__destroy_vector::operator()[abi:ne180100](&v2);
    JUMPOUT(0x2199FEAC4);
  }
  return result;
}

char *qmi::MutableMessageBase::getTLV<vs::tlv::SupsService>(_QWORD *a1)
{
  const void **v2;
  const void **v3;
  char **v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  v4 = (char **)(a1 + 1);
  if (v2 != v3)
  {
    while (*((_BYTE *)*v2 + 8) != 1)
    {
      if (++v2 == v3)
        goto LABEL_8;
    }
  }
  if (v2 == v3)
  {
LABEL_8:
    v7 = operator new();
    *(_BYTE *)(v7 + 8) = 1;
    *(_WORD *)(v7 + 9) = 0;
    v6 = v7 + 9;
    *(_QWORD *)v7 = &off_24D5E7B58;
    v8 = a1[3];
    v9 = (uint64_t *)a1[2];
    if ((unint64_t)v9 >= v8)
    {
      v11 = ((char *)v9 - *v4) >> 3;
      if ((unint64_t)(v11 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v12 = v8 - (_QWORD)*v4;
      v13 = v12 >> 2;
      if (v12 >> 2 <= (unint64_t)(v11 + 1))
        v13 = v11 + 1;
      if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
        v14 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v14 = v13;
      if (v14)
        v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v14);
      else
        v15 = 0;
      v16 = (uint64_t *)&v15[8 * v11];
      v17 = &v15[8 * v14];
      *v16 = v7;
      v10 = v16 + 1;
      v19 = (char *)a1[1];
      v18 = (char *)a1[2];
      if (v18 != v19)
      {
        do
        {
          v20 = *((_QWORD *)v18 - 1);
          v18 -= 8;
          *--v16 = v20;
        }
        while (v18 != v19);
        v18 = *v4;
      }
      a1[1] = v16;
      a1[2] = v10;
      a1[3] = v17;
      if (v18)
        operator delete(v18);
    }
    else
    {
      *v9 = v7;
      v10 = v9 + 1;
    }
    a1[2] = v10;
  }
  else
  {
    if (!v5)
      __cxa_bad_cast();
    return v5 + 9;
  }
  return (char *)v6;
}

void qmi::MutableMessageBase::TlvWrapper<vs::tlv::SupsService>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<vs::tlv::SupsService>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_PcoMcc>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<vs::tlv::SupsService>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::ProfileIdentifer>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<vs::tlv::SupsService>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E7B58;
  *(_WORD *)(result + 9) = *(_WORD *)(a1 + 9);
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<vs::tlv::CallFwdingNumber>::~TlvWrapper(uint64_t a1)
{
  *(_QWORD *)a1 = off_24D5E7BA8;
  if (*(char *)(a1 + 39) < 0)
    operator delete(*(void **)(a1 + 16));
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<vs::tlv::CallFwdingNumber>::~TlvWrapper(uint64_t a1)
{
  *(_QWORD *)a1 = off_24D5E7BA8;
  if (*(char *)(a1 + 39) < 0)
    operator delete(*(void **)(a1 + 16));
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<vs::tlv::CallFwdingNumber>::getSize(uint64_t a1)
{
  return tlv::size<wds::tlv::Dnn>(a1 + 16);
}

void *qmi::MutableMessageBase::TlvWrapper<vs::tlv::CallFwdingNumber>::write(uint64_t a1, void **a2)
{
  char v3;
  char *v4;
  uint64_t v5;
  void *result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (char *)*a2;
  v5 = (uint64_t)*a2 + 3;
  *a2 = (void *)v5;
  result = tlv::writeV<wds::tlv::Dnn>(a2, (_QWORD *)(a1 + 16));
  v7 = (char *)*a2 - v5;
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<vs::tlv::CallFwdingNumber>::clone(uint64_t a1)
{
  uint64_t v2;
  std::string *v3;

  v2 = operator new();
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)v2 = off_24D5E7BA8;
  v3 = (std::string *)(v2 + 16);
  if (*(char *)(a1 + 39) < 0)
  {
    std::string::__init_copy_ctor_external(v3, *(const std::string::value_type **)(a1 + 16), *(_QWORD *)(a1 + 24));
  }
  else
  {
    *(_OWORD *)&v3->__r_.__value_.__l.__data_ = *(_OWORD *)(a1 + 16);
    *(_QWORD *)(v2 + 32) = *(_QWORD *)(a1 + 32);
  }
  return v2;
}

void sub_216A67C48(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199FEAC4](v1, 0x1093C4081B1C094);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<vs::tlv::NoReplyTimer>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<vs::tlv::NoReplyTimer>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<vs::tlv::NoReplyTimer>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<vs::tlv::NoReplyTimer>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E7BF8;
  return result;
}

uint64_t qmi::ClientRouter::SendProxy::SendProxy<vs::SetSupsService::Request>(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v5;

  *(_DWORD *)a1 = a2;
  v5 = operator new();
  *(_QWORD *)v5 = a3;
  *(_QWORD *)(v5 + 8) = QMIServiceMsg::create();
  *(_DWORD *)(v5 + 16) = 25000;
  *(_QWORD *)(v5 + 24) = 0;
  *(_QWORD *)(v5 + 32) = 0;
  *(_QWORD *)(a1 + 8) = v5;
  return a1;
}

void sub_216A67D9C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199FEAC4](v1, 0x10F0C401BA14CC5);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMISuppServicesCommandDriver17setCallForwardingEN10subscriber7SimSlotEbRK14CSIPhoneNumber22CTCallForwardingReasonjh12MmiProcedureE3__0EEOS1_OT__block_invoke(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t *v2;
  uint64_t v3;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  _QWORD v14[6];
  int v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  __int16 v19;
  uint8_t buf[8];
  __int16 v21;
  uint64_t v22;
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  v2 = *(uint64_t **)(a1 + 32);
  v3 = *v2;
  if (*((_DWORD *)a2 + 1))
  {
    v16 = 0;
    v17 = &v16;
    v18 = 0x2000000000;
    v19 = 0;
    v14[0] = MEMORY[0x24BDAC760];
    v14[1] = 0x40000000;
    v14[2] = ___ZZN28QMISuppServicesCommandDriver17setCallForwardingEN10subscriber7SimSlotEbRK14CSIPhoneNumber22CTCallForwardingReasonjh12MmiProcedureENK3__0clERKN2vs14SetSupsService8ResponseE_block_invoke;
    v14[3] = &unk_24D5E7CD0;
    v14[5] = v3;
    v15 = *((_DWORD *)v2 + 2);
    v14[4] = &v16;
    *(_QWORD *)buf = v14;
    qmi::MessageBase::applyTlv<vs::tlv::FailureCause,void({block_pointer})(vs::tlv::FailureCause const&)>(a2, 16, (uint64_t)buf);
    v5 = *(NSObject **)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(v3 + 80) + 16))(*(_QWORD *)(v3 + 80), *((unsigned int *)v2 + 2));
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v12 = *((_DWORD *)a2 + 1);
      v13 = qmi::asString();
      *(_DWORD *)buf = 67109378;
      *(_DWORD *)&buf[4] = v12;
      v21 = 2080;
      v22 = v13;
      _os_log_error_impl(&dword_216897000, v5, OS_LOG_TYPE_ERROR, "SetSupsService::Response returned error 0x%x (%s)", buf, 0x12u);
    }
    v6 = *(_QWORD *)(v3 + 64);
    v7 = *((unsigned int *)v2 + 2);
    v8 = *((unsigned int *)v2 + 3);
    v9 = *((unsigned int *)v2 + 4);
    v10 = *((unsigned int *)v2 + 6);
    v11 = QMISuppServicesCommandDriver::mapQMIErrorToCSI((QMISuppServicesCommandDriver *)v3, *((unsigned __int16 *)v17 + 12));
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)v6 + 40))(v6, v7, v8, v9, v10, v11, 0);
    _Block_object_dispose(&v16, 8);
  }
  else
  {
    (*(void (**)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(**(_QWORD **)(v3 + 64) + 32))(*(_QWORD *)(v3 + 64), *((unsigned int *)v2 + 2), *((unsigned int *)v2 + 3), *((unsigned int *)v2 + 4), *((unsigned __int8 *)v2 + 20), *((unsigned int *)v2 + 6));
  }
}

void sub_216A67FB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_32c164_ZTSNSt3__110shared_ptrIZN28QMISuppServicesCommandDriver17setCallForwardingEN10subscriber7SimSlotEbRK14CSIPhoneNumber22CTCallForwardingReasonjh12MmiProcedureE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c164_ZTSNSt3__110shared_ptrIZN28QMISuppServicesCommandDriver17setCallForwardingEN10subscriber7SimSlotEbRK14CSIPhoneNumber22CTCallForwardingReasonjh12MmiProcedureE3__0EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMISuppServicesCommandDriver::setCallForwarding(subscriber::SimSlot,BOOL,CSIPhoneNumber const&,CTCallForwardingReason,unsigned int,unsigned char,MmiProcedure)::$_0,std::allocator<QMISuppServicesCommandDriver::setCallForwarding(subscriber::SimSlot,BOOL,CSIPhoneNumber const&,CTCallForwardingReason,unsigned int,unsigned char,MmiProcedure)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E7C60;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMISuppServicesCommandDriver::setCallForwarding(subscriber::SimSlot,BOOL,CSIPhoneNumber const&,CTCallForwardingReason,unsigned int,unsigned char,MmiProcedure)::$_0,std::allocator<QMISuppServicesCommandDriver::setCallForwarding(subscriber::SimSlot,BOOL,CSIPhoneNumber const&,CTCallForwardingReason,unsigned int,unsigned char,MmiProcedure)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E7C60;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN2vs14SetSupsService8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A68108(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ___ZZN28QMISuppServicesCommandDriver17setCallForwardingEN10subscriber7SimSlotEbRK14CSIPhoneNumber22CTCallForwardingReasonjh12MmiProcedureENK3__0clERKN2vs14SetSupsService8ResponseE_block_invoke(uint64_t a1, _WORD *a2)
{
  NSObject *v4;
  uint8_t v5[16];

  v4 = *(NSObject **)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 40) + 80) + 16))(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 80), *(unsigned int *)(a1 + 48));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v5 = 0;
    _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I Failure cause is present in the response", v5, 2u);
  }
  *(_WORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *a2;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMISuppServicesCommandDriver22activateCallForwardingEN10subscriber7SimSlotEb22CTCallForwardingReasonj12MmiProcedureE3__0EEOS1_OT__block_invoke(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t *v2;
  uint64_t v3;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  _QWORD v14[6];
  int v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  __int16 v19;
  uint8_t buf[8];
  __int16 v21;
  uint64_t v22;
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  v2 = *(uint64_t **)(a1 + 32);
  v3 = *v2;
  if (*((_DWORD *)a2 + 1))
  {
    v16 = 0;
    v17 = &v16;
    v18 = 0x2000000000;
    v19 = 0;
    v14[0] = MEMORY[0x24BDAC760];
    v14[1] = 0x40000000;
    v14[2] = ___ZZN28QMISuppServicesCommandDriver22activateCallForwardingEN10subscriber7SimSlotEb22CTCallForwardingReasonj12MmiProcedureENK3__0clERKN2vs14SetSupsService8ResponseE_block_invoke;
    v14[3] = &unk_24D5E7D78;
    v14[5] = v3;
    v15 = *((_DWORD *)v2 + 2);
    v14[4] = &v16;
    *(_QWORD *)buf = v14;
    qmi::MessageBase::applyTlv<vs::tlv::FailureCause,void({block_pointer})(vs::tlv::FailureCause const&)>(a2, 16, (uint64_t)buf);
    v5 = *(NSObject **)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(v3 + 80) + 16))(*(_QWORD *)(v3 + 80), *((unsigned int *)v2 + 2));
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v12 = *((_DWORD *)a2 + 1);
      v13 = qmi::asString();
      *(_DWORD *)buf = 67109378;
      *(_DWORD *)&buf[4] = v12;
      v21 = 2080;
      v22 = v13;
      _os_log_error_impl(&dword_216897000, v5, OS_LOG_TYPE_ERROR, "SetSupsService::Response returned error 0x%x (%s)", buf, 0x12u);
    }
    v6 = *(_QWORD *)(v3 + 64);
    v7 = *((unsigned int *)v2 + 2);
    v8 = *((unsigned int *)v2 + 3);
    v9 = *((unsigned int *)v2 + 4);
    v10 = *((unsigned int *)v2 + 6);
    v11 = QMISuppServicesCommandDriver::mapQMIErrorToCSI((QMISuppServicesCommandDriver *)v3, *((unsigned __int16 *)v17 + 12));
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)v6 + 40))(v6, v7, v8, v9, v10, v11, 0);
    _Block_object_dispose(&v16, 8);
  }
  else
  {
    (*(void (**)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(**(_QWORD **)(v3 + 64) + 32))(*(_QWORD *)(v3 + 64), *((unsigned int *)v2 + 2), *((unsigned int *)v2 + 3), *((unsigned int *)v2 + 4), *((unsigned __int8 *)v2 + 20), *((unsigned int *)v2 + 6));
  }
}

void sub_216A683D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_32c150_ZTSNSt3__110shared_ptrIZN28QMISuppServicesCommandDriver22activateCallForwardingEN10subscriber7SimSlotEb22CTCallForwardingReasonj12MmiProcedureE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c150_ZTSNSt3__110shared_ptrIZN28QMISuppServicesCommandDriver22activateCallForwardingEN10subscriber7SimSlotEb22CTCallForwardingReasonj12MmiProcedureE3__0EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMISuppServicesCommandDriver::activateCallForwarding(subscriber::SimSlot,BOOL,CTCallForwardingReason,unsigned int,MmiProcedure)::$_0,std::allocator<QMISuppServicesCommandDriver::activateCallForwarding(subscriber::SimSlot,BOOL,CTCallForwardingReason,unsigned int,MmiProcedure)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E7D30;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMISuppServicesCommandDriver::activateCallForwarding(subscriber::SimSlot,BOOL,CTCallForwardingReason,unsigned int,MmiProcedure)::$_0,std::allocator<QMISuppServicesCommandDriver::activateCallForwarding(subscriber::SimSlot,BOOL,CTCallForwardingReason,unsigned int,MmiProcedure)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E7D30;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void ___ZZN28QMISuppServicesCommandDriver22activateCallForwardingEN10subscriber7SimSlotEb22CTCallForwardingReasonj12MmiProcedureENK3__0clERKN2vs14SetSupsService8ResponseE_block_invoke(uint64_t a1, _WORD *a2)
{
  NSObject *v4;
  uint8_t v5[16];

  v4 = *(NSObject **)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 40) + 80) + 16))(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 80), *(unsigned int *)(a1 + 48));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v5 = 0;
    _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I Failure cause is present in the response", v5, 2u);
  }
  *(_WORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *a2;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMISuppServicesCommandDriver16fetchCallBarringEN10subscriber7SimSlotE21CTCallBarringFacilityjE3__0EEOS1_OT__block_invoke(uint64_t a1, _QWORD *a2)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  NSObject *v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  _QWORD v16[3];
  uint64_t v17;
  uint64_t v18;
  void *v19;
  void *v20;
  uint64_t *v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  uint64_t *v25;
  uint64_t v26;
  __int16 v27;
  uint8_t buf[8];
  __int16 v29;
  uint64_t v30;
  uint64_t v31;

  v31 = *MEMORY[0x24BDAC8D0];
  v2 = *(uint64_t **)(a1 + 32);
  v3 = *v2;
  v5 = *((unsigned int *)v2 + 2);
  v4 = *((unsigned int *)v2 + 3);
  v6 = *((unsigned int *)v2 + 4);
  v7 = a2[1];
  v16[0] = *a2;
  v16[1] = v7;
  v8 = a2[2];
  v16[2] = v8;
  if (v8)
  {
    v9 = (unint64_t *)(v8 + 8);
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }
  qmi::MessageBase::validateMsgId((qmi::MessageBase *)v16);
  if (HIDWORD(v16[0]))
  {
    v24 = 0;
    v25 = &v24;
    v26 = 0x2000000000;
    v27 = 0;
    v17 = MEMORY[0x24BDAC760];
    v18 = 0x40000000;
    v19 = ___ZN28QMISuppServicesCommandDriver25handleCallBarringInfo_resEN10subscriber7SimSlotE21CTCallBarringFacilityjRKN2vs14GetCallBarring8ResponseE_block_invoke;
    v20 = &unk_24D5E74B8;
    v23 = v5;
    v21 = &v24;
    v22 = v3;
    *(_QWORD *)buf = &v17;
    qmi::MessageBase::applyTlv<vs::tlv::FailureCause,void({block_pointer})(vs::tlv::FailureCause const&)>((qmi::MessageBase *)v16, 17, (uint64_t)buf);
    v11 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v3 + 80) + 16))(*(_QWORD *)(v3 + 80), v5);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      v14 = HIDWORD(v16[0]);
      v15 = qmi::asString();
      *(_DWORD *)buf = 67109378;
      *(_DWORD *)&buf[4] = v14;
      v29 = 2080;
      v30 = v15;
      _os_log_error_impl(&dword_216897000, v11, OS_LOG_TYPE_ERROR, "fetchCallBarring::Response returned error 0x%x (%s)", buf, 0x12u);
    }
    v12 = *(_QWORD *)(v3 + 64);
    v13 = QMISuppServicesCommandDriver::mapQMIErrorToCSI((QMISuppServicesCommandDriver *)v3, *((unsigned __int16 *)v25 + 12));
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)v12 + 56))(v12, v5, v4, v6, v13, 0);
  }
  else
  {
    v24 = 0;
    v25 = &v24;
    v26 = 0x2000000000;
    LOBYTE(v27) = 0;
    v17 = MEMORY[0x24BDAC760];
    v18 = 0x40000000;
    v19 = ___ZN28QMISuppServicesCommandDriver25handleCallBarringInfo_resEN10subscriber7SimSlotE21CTCallBarringFacilityjRKN2vs14GetCallBarring8ResponseE_block_invoke_28;
    v20 = &unk_24D5E74E0;
    v21 = &v24;
    *(_QWORD *)buf = &v17;
    qmi::MessageBase::applyTlv<vs::tlv::ServiceClass,void({block_pointer})(vs::tlv::ServiceClass const&)>((qmi::MessageBase *)v16, (uint64_t)buf);
    (*(void (**)(_QWORD, uint64_t, uint64_t, uint64_t, _QWORD))(**(_QWORD **)(v3 + 64) + 48))(*(_QWORD *)(v3 + 64), v5, v4, v6, *((unsigned __int8 *)v25 + 24));
  }
  _Block_object_dispose(&v24, 8);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v16);
}

void sub_216A68750(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  _Block_object_dispose(&a19, 8);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_32c128_ZTSNSt3__110shared_ptrIZN28QMISuppServicesCommandDriver16fetchCallBarringEN10subscriber7SimSlotE21CTCallBarringFacilityjE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c128_ZTSNSt3__110shared_ptrIZN28QMISuppServicesCommandDriver16fetchCallBarringEN10subscriber7SimSlotE21CTCallBarringFacilityjE3__0EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMISuppServicesCommandDriver::fetchCallBarring(subscriber::SimSlot,CTCallBarringFacility,unsigned int)::$_0,std::allocator<QMISuppServicesCommandDriver::fetchCallBarring(subscriber::SimSlot,CTCallBarringFacility,unsigned int)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E7DD8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMISuppServicesCommandDriver::fetchCallBarring(subscriber::SimSlot,CTCallBarringFacility,unsigned int)::$_0,std::allocator<QMISuppServicesCommandDriver::fetchCallBarring(subscriber::SimSlot,CTCallBarringFacility,unsigned int)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E7DD8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MessageBase::applyTlv<vs::tlv::ServiceClass,void({block_pointer})(vs::tlv::ServiceClass const&)>(qmi::MessageBase *a1, uint64_t a2)
{
  uint64_t result;
  int v5;
  uint64_t v6;
  int v7;
  char v8;
  uint64_t v9;

  result = qmi::MessageBase::findTlvValue(a1);
  if (result)
  {
    v6 = result;
    v7 = v5;
    v9 = result;
    v8 = tlv::parseV<vs::tlv::ServiceClass>((unint64_t *)&v9, v5);
    if (v9)
      return (*(uint64_t (**)(void))(*(_QWORD *)a2 + 16))();
    else
      return ((uint64_t (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, 16, v6, v7);
  }
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<vs::tlv::CallBarringPasswd>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<vs::tlv::CallBarringPasswd>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

_DWORD **qmi::MutableMessageBase::TlvWrapper<vs::tlv::CallBarringPasswd>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _DWORD *v4;
  uint64_t v5;
  _DWORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_DWORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::PktDataHandle>((_DWORD **)a2, (_DWORD *)(a1 + 9));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<vs::tlv::CallBarringPasswd>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E7E40;
  *(_DWORD *)(result + 9) = *(_DWORD *)(a1 + 9);
  return result;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMISuppServicesCommandDriver14setCallBarringEN10subscriber7SimSlotE21CTCallBarringFacilityjRKNSt3__112basic_stringIcNS7_11char_traitsIcEENS7_9allocatorIcEEEEb12MmiProcedureE3__0EEOS1_OT__block_invoke(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t *v2;
  uint64_t v3;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  _QWORD v14[6];
  int v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  __int16 v19;
  uint8_t buf[8];
  __int16 v21;
  uint64_t v22;
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  v2 = *(uint64_t **)(a1 + 32);
  v3 = *v2;
  if (*((_DWORD *)a2 + 1))
  {
    v16 = 0;
    v17 = &v16;
    v18 = 0x2000000000;
    v19 = 0;
    v14[0] = MEMORY[0x24BDAC760];
    v14[1] = 0x40000000;
    v14[2] = ___ZZN28QMISuppServicesCommandDriver14setCallBarringEN10subscriber7SimSlotE21CTCallBarringFacilityjRKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEb12MmiProcedureENK3__0clERKN2vs14SetSupsService8ResponseE_block_invoke;
    v14[3] = &unk_24D5E7EF0;
    v14[5] = v3;
    v15 = *((_DWORD *)v2 + 2);
    v14[4] = &v16;
    *(_QWORD *)buf = v14;
    qmi::MessageBase::applyTlv<vs::tlv::FailureCause,void({block_pointer})(vs::tlv::FailureCause const&)>(a2, 16, (uint64_t)buf);
    v5 = *(NSObject **)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(v3 + 80) + 16))(*(_QWORD *)(v3 + 80), *((unsigned int *)v2 + 2));
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v12 = *((_DWORD *)a2 + 1);
      v13 = qmi::asString();
      *(_DWORD *)buf = 67109378;
      *(_DWORD *)&buf[4] = v12;
      v21 = 2080;
      v22 = v13;
      _os_log_error_impl(&dword_216897000, v5, OS_LOG_TYPE_ERROR, "SetSupsService::Response returned error 0x%x (%s)", buf, 0x12u);
    }
    v6 = *(_QWORD *)(v3 + 64);
    v7 = *((unsigned int *)v2 + 2);
    v8 = *((unsigned int *)v2 + 3);
    v9 = *((unsigned int *)v2 + 4);
    v10 = *((unsigned int *)v2 + 6);
    v11 = QMISuppServicesCommandDriver::mapQMIErrorToCSI((QMISuppServicesCommandDriver *)v3, *((unsigned __int16 *)v17 + 12));
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)v6 + 72))(v6, v7, v8, v9, v10, v11, 0);
    _Block_object_dispose(&v16, 8);
  }
  else
  {
    (*(void (**)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(**(_QWORD **)(v3 + 64) + 64))(*(_QWORD *)(v3 + 64), *((unsigned int *)v2 + 2), *((unsigned int *)v2 + 3), *((unsigned int *)v2 + 4), *((unsigned __int8 *)v2 + 20), *((unsigned int *)v2 + 6));
  }
}

void sub_216A68B58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_32c201_ZTSNSt3__110shared_ptrIZN28QMISuppServicesCommandDriver14setCallBarringEN10subscriber7SimSlotE21CTCallBarringFacilityjRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEb12MmiProcedureE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c201_ZTSNSt3__110shared_ptrIZN28QMISuppServicesCommandDriver14setCallBarringEN10subscriber7SimSlotE21CTCallBarringFacilityjRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEb12MmiProcedureE3__0EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMISuppServicesCommandDriver::setCallBarring(subscriber::SimSlot,CTCallBarringFacility,unsigned int,std::string const&,BOOL,MmiProcedure)::$_0,std::allocator<QMISuppServicesCommandDriver::setCallBarring(subscriber::SimSlot,CTCallBarringFacility,unsigned int,std::string const&,BOOL,MmiProcedure)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E7EA8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMISuppServicesCommandDriver::setCallBarring(subscriber::SimSlot,CTCallBarringFacility,unsigned int,std::string const&,BOOL,MmiProcedure)::$_0,std::allocator<QMISuppServicesCommandDriver::setCallBarring(subscriber::SimSlot,CTCallBarringFacility,unsigned int,std::string const&,BOOL,MmiProcedure)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E7EA8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void ___ZZN28QMISuppServicesCommandDriver14setCallBarringEN10subscriber7SimSlotE21CTCallBarringFacilityjRKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEb12MmiProcedureENK3__0clERKN2vs14SetSupsService8ResponseE_block_invoke(uint64_t a1, _WORD *a2)
{
  NSObject *v4;
  uint8_t v5[16];

  v4 = *(NSObject **)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 40) + 80) + 16))(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 80), *(unsigned int *)(a1 + 48));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v5 = 0;
    _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I Failure cause is present in the response", v5, 2u);
  }
  *(_WORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *a2;
}

void qmi::MutableMessageBase::TlvWrapper<vs::tlv::CallBarringPassword>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<vs::tlv::CallBarringPassword>::getSize()
{
  return tlv::size<vs::tlv::CallBarringPassword>();
}

uint64_t *qmi::MutableMessageBase::TlvWrapper<vs::tlv::CallBarringPassword>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t *result;
  uint64_t v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = *a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<vs::tlv::CallBarringPassword>(a2, a1 + 9);
  v7 = *a2 - v5;
  *(_BYTE *)v4 = v3;
  *(_WORD *)(v4 + 1) = v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<vs::tlv::CallBarringPassword>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E7F38;
  *(_QWORD *)(result + 9) = *(_QWORD *)(a1 + 9);
  *(_QWORD *)(result + 14) = *(_QWORD *)(a1 + 14);
  return result;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMISuppServicesCommandDriver22setCallBarringPasswordEN10subscriber7SimSlotE21CTCallBarringFacilityRKNSt3__112basic_stringIcNS7_11char_traitsIcEENS7_9allocatorIcEEEESF_SF_E3__0EEOS1_OT__block_invoke(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t *v2;
  uint64_t v3;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  _QWORD v12[6];
  int v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  __int16 v17;
  uint8_t buf[8];
  __int16 v19;
  uint64_t v20;
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  v2 = *(uint64_t **)(a1 + 32);
  v3 = *v2;
  if (*((_DWORD *)a2 + 1))
  {
    v14 = 0;
    v15 = &v14;
    v16 = 0x2000000000;
    v17 = 0;
    v12[0] = MEMORY[0x24BDAC760];
    v12[1] = 0x40000000;
    v12[2] = ___ZZN28QMISuppServicesCommandDriver22setCallBarringPasswordEN10subscriber7SimSlotE21CTCallBarringFacilityRKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEESB_SB_ENK3__0clERKN2vs22SetCallBarringPassword8ResponseE_block_invoke;
    v12[3] = &unk_24D5E8010;
    v12[5] = v3;
    v13 = *((_DWORD *)v2 + 2);
    v12[4] = &v14;
    *(_QWORD *)buf = v12;
    qmi::MessageBase::applyTlv<vs::tlv::FailureCause,void({block_pointer})(vs::tlv::FailureCause const&)>(a2, 16, (uint64_t)buf);
    v5 = *(NSObject **)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(v3 + 80) + 16))(*(_QWORD *)(v3 + 80), *((unsigned int *)v2 + 2));
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v10 = *((_DWORD *)a2 + 1);
      v11 = qmi::asString();
      *(_DWORD *)buf = 67109378;
      *(_DWORD *)&buf[4] = v10;
      v19 = 2080;
      v20 = v11;
      _os_log_error_impl(&dword_216897000, v5, OS_LOG_TYPE_ERROR, "setCallBarringPassword::Response returned error 0x%x (%s)", buf, 0x12u);
    }
    v6 = *(_QWORD *)(v3 + 64);
    v7 = *((unsigned int *)v2 + 2);
    v8 = *((unsigned int *)v2 + 3);
    v9 = QMISuppServicesCommandDriver::mapQMIErrorToCSI((QMISuppServicesCommandDriver *)v3, *((unsigned __int16 *)v15 + 12));
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v6 + 88))(v6, v7, v8, v9);
    _Block_object_dispose(&v14, 8);
  }
  else
  {
    (*(void (**)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)(v3 + 64) + 80))(*(_QWORD *)(v3 + 64), *((unsigned int *)v2 + 2), *((unsigned int *)v2 + 3));
  }
}

void sub_216A68F1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_32c199_ZTSNSt3__110shared_ptrIZN28QMISuppServicesCommandDriver22setCallBarringPasswordEN10subscriber7SimSlotE21CTCallBarringFacilityRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEESC_SC_E3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c199_ZTSNSt3__110shared_ptrIZN28QMISuppServicesCommandDriver22setCallBarringPasswordEN10subscriber7SimSlotE21CTCallBarringFacilityRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEESC_SC_E3__0EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMISuppServicesCommandDriver::setCallBarringPassword(subscriber::SimSlot,CTCallBarringFacility,std::string const&,std::string const&,std::string const&)::$_0,std::allocator<QMISuppServicesCommandDriver::setCallBarringPassword(subscriber::SimSlot,CTCallBarringFacility,std::string const&,std::string const&,std::string const&)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E7FA0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMISuppServicesCommandDriver::setCallBarringPassword(subscriber::SimSlot,CTCallBarringFacility,std::string const&,std::string const&,std::string const&)::$_0,std::allocator<QMISuppServicesCommandDriver::setCallBarringPassword(subscriber::SimSlot,CTCallBarringFacility,std::string const&,std::string const&,std::string const&)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E7FA0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN2vs22SetCallBarringPassword8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A69070(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ___ZZN28QMISuppServicesCommandDriver22setCallBarringPasswordEN10subscriber7SimSlotE21CTCallBarringFacilityRKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEESB_SB_ENK3__0clERKN2vs22SetCallBarringPassword8ResponseE_block_invoke(uint64_t a1, _WORD *a2)
{
  NSObject *v4;
  uint8_t v5[16];

  v4 = *(NSObject **)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 40) + 80) + 16))(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 80), *(unsigned int *)(a1 + 48));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v5 = 0;
    _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I Failure cause is present in the response", v5, 2u);
  }
  *(_WORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *a2;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMISuppServicesCommandDriver16fetchCallWaitingEN10subscriber7SimSlotEjE3__0EEOS1_OT__block_invoke(uint64_t a1, _QWORD *a2)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  std::__shared_weak_count_vtbl *v13;
  std::__shared_weak_count *v14;
  std::__shared_weak_count *v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  int v28;
  uint64_t v29;
  _QWORD v30[3];
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  void *v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  __n128 (*v39)(uint64_t, uint64_t);
  uint64_t (*v40)(uint64_t);
  std::__shared_weak_count_vtbl *v41;
  std::__shared_weak_count *v42;
  uint8_t buf[8];
  _QWORD v44[3];

  v44[2] = *MEMORY[0x24BDAC8D0];
  v2 = *(uint64_t **)(a1 + 32);
  v3 = *v2;
  v4 = *((unsigned int *)v2 + 2);
  v5 = a2[1];
  v30[0] = *a2;
  v30[1] = v5;
  v6 = a2[2];
  v30[2] = v6;
  if (v6)
  {
    v7 = (unint64_t *)(v6 + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  qmi::MessageBase::validateMsgId((qmi::MessageBase *)v30);
  v9 = *((unsigned int *)v2 + 3);
  if (HIDWORD(v30[0]))
  {
    v31 = 0;
    v32 = (uint64_t)&v31;
    v33 = 0x2000000000;
    LOWORD(v34) = 0;
    v36 = MEMORY[0x24BDAC760];
    v37 = 0x40000000;
    v38 = (uint64_t)___ZN28QMISuppServicesCommandDriver25handleCallWaitingResponseEN10subscriber7SimSlotERKN2vs14GetCallWaiting8ResponseEj_block_invoke;
    v39 = (__n128 (*)(uint64_t, uint64_t))&unk_24D5E7568;
    LODWORD(v42) = v4;
    v40 = (uint64_t (*)(uint64_t))&v31;
    v41 = (std::__shared_weak_count_vtbl *)v3;
    *(_QWORD *)buf = &v36;
    qmi::MessageBase::applyTlv<vs::tlv::FailureCause,void({block_pointer})(vs::tlv::FailureCause const&)>((qmi::MessageBase *)v30, 17, (uint64_t)buf);
    v10 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v3 + 80) + 16))(*(_QWORD *)(v3 + 80), v4);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      v28 = HIDWORD(v30[0]);
      v29 = qmi::asString();
      *(_DWORD *)buf = 67109378;
      *(_DWORD *)&buf[4] = v28;
      LOWORD(v44[0]) = 2080;
      *(_QWORD *)((char *)v44 + 2) = v29;
      _os_log_error_impl(&dword_216897000, v10, OS_LOG_TYPE_ERROR, "GetCallWaiting::Response returned error 0x%x (%s)", buf, 0x12u);
    }
    v11 = *(_QWORD *)(v3 + 64);
    v12 = QMISuppServicesCommandDriver::mapQMIErrorToCSI((QMISuppServicesCommandDriver *)v3, *(unsigned __int16 *)(v32 + 24));
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)v11 + 104))(v11, v4, v9, v12, 0);
    _Block_object_dispose(&v31, 8);
  }
  else
  {
    v36 = 0;
    v37 = (uint64_t)&v36;
    v38 = 0x3802000000;
    v39 = __Block_byref_object_copy__38;
    v40 = __Block_byref_object_dispose__39;
    v41 = 0;
    v42 = 0;
    v13 = (std::__shared_weak_count_vtbl *)operator new();
    LOBYTE(v13->~__shared_weak_count) = 0;
    v14 = (std::__shared_weak_count *)operator new();
    v14->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E80C0;
    v14->__shared_owners_ = 0;
    v14->__shared_weak_owners_ = 0;
    v14[1].__vftable = v13;
    v15 = v42;
    v41 = v13;
    v42 = v14;
    if (v15)
    {
      p_shared_owners = (unint64_t *)&v15->__shared_owners_;
      do
        v17 = __ldaxr(p_shared_owners);
      while (__stlxr(v17 - 1, p_shared_owners));
      if (!v17)
      {
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v15);
      }
    }
    v31 = MEMORY[0x24BDAC760];
    v32 = 0x40000000;
    v33 = (uint64_t)___ZN28QMISuppServicesCommandDriver25handleCallWaitingResponseEN10subscriber7SimSlotERKN2vs14GetCallWaiting8ResponseEj_block_invoke_40;
    v34 = &unk_24D5E7590;
    v35 = &v36;
    *(_QWORD *)buf = &v31;
    qmi::MessageBase::applyTlv<vs::tlv::ServiceClass,void({block_pointer})(vs::tlv::ServiceClass const&)>((qmi::MessageBase *)v30, (uint64_t)buf);
    v18 = *(_QWORD *)(v3 + 64);
    v19 = *(_QWORD *)(v37 + 48);
    *(_QWORD *)buf = *(_QWORD *)(v37 + 40);
    v44[0] = v19;
    if (v19)
    {
      v20 = (unint64_t *)(v19 + 8);
      do
        v21 = __ldxr(v20);
      while (__stxr(v21 + 1, v20));
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint8_t *))(*(_QWORD *)v18 + 96))(v18, v4, v9, buf);
    v22 = (std::__shared_weak_count *)v44[0];
    if (v44[0])
    {
      v23 = (unint64_t *)(v44[0] + 8);
      do
        v24 = __ldaxr(v23);
      while (__stlxr(v24 - 1, v23));
      if (!v24)
      {
        ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
        std::__shared_weak_count::__release_weak(v22);
      }
    }
    _Block_object_dispose(&v36, 8);
    v25 = v42;
    if (v42)
    {
      v26 = (unint64_t *)&v42->__shared_owners_;
      do
        v27 = __ldaxr(v26);
      while (__stlxr(v27 - 1, v26));
      if (!v27)
      {
        ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
        std::__shared_weak_count::__release_weak(v25);
      }
    }
  }
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v30);
}

void sub_216A694C8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v5 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v3 - 80);
  _Block_object_dispose(va1, 8);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v2 + 40);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_32c105_ZTSNSt3__110shared_ptrIZN28QMISuppServicesCommandDriver16fetchCallWaitingEN10subscriber7SimSlotEjE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c105_ZTSNSt3__110shared_ptrIZN28QMISuppServicesCommandDriver16fetchCallWaitingEN10subscriber7SimSlotEjE3__0EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMISuppServicesCommandDriver::fetchCallWaiting(subscriber::SimSlot,unsigned int)::$_0,std::allocator<QMISuppServicesCommandDriver::fetchCallWaiting(subscriber::SimSlot,unsigned int)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E8070;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMISuppServicesCommandDriver::fetchCallWaiting(subscriber::SimSlot,unsigned int)::$_0,std::allocator<QMISuppServicesCommandDriver::fetchCallWaiting(subscriber::SimSlot,unsigned int)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E8070;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void std::__shared_ptr_pointer<CallWaitingSettingsModel *,std::shared_ptr<CallWaitingSettingsModel>::__shared_ptr_default_delete<CallWaitingSettingsModel,CallWaitingSettingsModel>,std::allocator<CallWaitingSettingsModel>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

uint64_t std::__shared_ptr_pointer<CallWaitingSettingsModel *,std::shared_ptr<CallWaitingSettingsModel>::__shared_ptr_default_delete<CallWaitingSettingsModel,CallWaitingSettingsModel>,std::allocator<CallWaitingSettingsModel>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    JUMPOUT(0x2199FEAC4);
  return result;
}

uint64_t std::__shared_ptr_pointer<CallWaitingSettingsModel *,std::shared_ptr<CallWaitingSettingsModel>::__shared_ptr_default_delete<CallWaitingSettingsModel,CallWaitingSettingsModel>,std::allocator<CallWaitingSettingsModel>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMISuppServicesCommandDriver14setCallWaitingEN10subscriber7SimSlotEbj12MmiProcedureE3__0EEOS1_OT__block_invoke(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t *v2;
  uint64_t v3;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  _QWORD v13[6];
  int v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  __int16 v18;
  uint8_t buf[8];
  __int16 v20;
  uint64_t v21;
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  v2 = *(uint64_t **)(a1 + 32);
  v3 = *v2;
  if (*((_DWORD *)a2 + 1))
  {
    v15 = 0;
    v16 = &v15;
    v17 = 0x2000000000;
    v18 = 0;
    v13[0] = MEMORY[0x24BDAC760];
    v13[1] = 0x40000000;
    v13[2] = ___ZZN28QMISuppServicesCommandDriver14setCallWaitingEN10subscriber7SimSlotEbj12MmiProcedureENK3__0clERKN2vs14SetSupsService8ResponseE_block_invoke;
    v13[3] = &unk_24D5E81B0;
    v13[5] = v3;
    v14 = *((_DWORD *)v2 + 2);
    v13[4] = &v15;
    *(_QWORD *)buf = v13;
    qmi::MessageBase::applyTlv<vs::tlv::FailureCause,void({block_pointer})(vs::tlv::FailureCause const&)>(a2, 16, (uint64_t)buf);
    v5 = *(NSObject **)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(v3 + 80) + 16))(*(_QWORD *)(v3 + 80), *((unsigned int *)v2 + 2));
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v11 = *((_DWORD *)a2 + 1);
      v12 = qmi::asString();
      *(_DWORD *)buf = 67109378;
      *(_DWORD *)&buf[4] = v11;
      v20 = 2080;
      v21 = v12;
      _os_log_error_impl(&dword_216897000, v5, OS_LOG_TYPE_ERROR, "SetSupsService::Response returned error 0x%x (%s)", buf, 0x12u);
    }
    v6 = *(_QWORD *)(v3 + 64);
    v7 = *((unsigned int *)v2 + 2);
    v8 = *((unsigned int *)v2 + 3);
    v9 = *((unsigned int *)v2 + 4);
    v10 = QMISuppServicesCommandDriver::mapQMIErrorToCSI((QMISuppServicesCommandDriver *)v3, *((unsigned __int16 *)v16 + 12));
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)v6 + 120))(v6, v7, v8, v9, v10, 0);
    _Block_object_dispose(&v15, 8);
  }
  else
  {
    (*(void (**)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(**(_QWORD **)(v3 + 64) + 112))(*(_QWORD *)(v3 + 64), *((unsigned int *)v2 + 2), *((unsigned int *)v2 + 3), *((unsigned int *)v2 + 4), *((unsigned __int8 *)v2 + 20));
  }
}

void sub_216A69834(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_32c118_ZTSNSt3__110shared_ptrIZN28QMISuppServicesCommandDriver14setCallWaitingEN10subscriber7SimSlotEbj12MmiProcedureE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c118_ZTSNSt3__110shared_ptrIZN28QMISuppServicesCommandDriver14setCallWaitingEN10subscriber7SimSlotEbj12MmiProcedureE3__0EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMISuppServicesCommandDriver::setCallWaiting(subscriber::SimSlot,BOOL,unsigned int,MmiProcedure)::$_0,std::allocator<QMISuppServicesCommandDriver::setCallWaiting(subscriber::SimSlot,BOOL,unsigned int,MmiProcedure)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E8168;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMISuppServicesCommandDriver::setCallWaiting(subscriber::SimSlot,BOOL,unsigned int,MmiProcedure)::$_0,std::allocator<QMISuppServicesCommandDriver::setCallWaiting(subscriber::SimSlot,BOOL,unsigned int,MmiProcedure)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E8168;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void ___ZZN28QMISuppServicesCommandDriver14setCallWaitingEN10subscriber7SimSlotEbj12MmiProcedureENK3__0clERKN2vs14SetSupsService8ResponseE_block_invoke(uint64_t a1, _WORD *a2)
{
  NSObject *v4;
  uint8_t v5[16];

  v4 = *(NSObject **)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 40) + 80) + 16))(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 80), *(unsigned int *)(a1 + 48));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v5 = 0;
    _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I Failure cause is present in the response", v5, 2u);
  }
  *(_WORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *a2;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMISuppServicesCommandDriver9fetchCLIREN10subscriber7SimSlotEE3__0EEOS1_OT__block_invoke(uint64_t a1, _QWORD *a2)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  NSObject *v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t (*v13)(uint64_t, uint64_t, uint64_t);
  NSObject *v14;
  uint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *p_shared_owners;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  std::__shared_weak_count_vtbl *v22;
  std::__shared_weak_count *v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  uint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  NSObject *v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  uint64_t v41;
  _QWORD v42[3];
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  void *v46;
  uint8_t *v47;
  uint64_t v48;
  std::__shared_weak_count *v49;
  uint8_t v50[8];
  std::__shared_weak_count *v51;
  uint8_t buf[8];
  __int128 v53;
  __n128 (*v54)(uint64_t, uint64_t);
  uint64_t (*v55)(uint64_t);
  std::__shared_weak_count_vtbl *v56;
  std::__shared_weak_count *v57;
  uint64_t v58;

  v58 = *MEMORY[0x24BDAC8D0];
  v2 = *(uint64_t **)(a1 + 32);
  v3 = *v2;
  v4 = *((unsigned int *)v2 + 2);
  v5 = a2[1];
  v42[0] = *a2;
  v42[1] = v5;
  v6 = a2[2];
  v42[2] = v6;
  if (v6)
  {
    v7 = (unint64_t *)(v6 + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  qmi::MessageBase::validateMsgId((qmi::MessageBase *)v42);
  if (HIDWORD(v42[0]))
  {
    v9 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v3 + 80) + 16))(*(_QWORD *)(v3 + 80), v4);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      v40 = HIDWORD(v42[0]);
      v41 = qmi::asString();
      *(_DWORD *)buf = 67109378;
      *(_DWORD *)&buf[4] = v40;
      LOWORD(v53) = 2080;
      *(_QWORD *)((char *)&v53 + 2) = v41;
      _os_log_error_impl(&dword_216897000, v9, OS_LOG_TYPE_ERROR, "GetCLIR::Response returned error 0x%x (%s)", buf, 0x12u);
    }
    v43 = 0;
    v44 = (uint64_t)&v43;
    v45 = 0x2000000000;
    LOWORD(v46) = 0;
    *(_QWORD *)buf = MEMORY[0x24BDAC760];
    *(_QWORD *)&v53 = 0x40000000;
    *((_QWORD *)&v53 + 1) = ___ZN28QMISuppServicesCommandDriver18handleCLIRResponseEN10subscriber7SimSlotERKN2vs7GetCLIR8ResponseE_block_invoke;
    v54 = (__n128 (*)(uint64_t, uint64_t))&unk_24D5E75B8;
    v55 = (uint64_t (*)(uint64_t))&v43;
    *(_QWORD *)v50 = buf;
    v11 = qmi::MessageBase::applyTlv<vs::tlv::FailureCause,void({block_pointer})(vs::tlv::FailureCause const&)>((qmi::MessageBase *)v42, 17, (uint64_t)v50);
    v12 = *(_QWORD *)(v3 + 80);
    v13 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v12 + 16);
    if (v11)
    {
      v14 = *(NSObject **)v13(v12, v4, v10);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)v50 = 0;
        _os_log_error_impl(&dword_216897000, v14, OS_LOG_TYPE_ERROR, "Failure cause is present in the response, sending event", v50, 2u);
      }
      *(_QWORD *)v50 = 0;
      v51 = 0;
      v15 = *(_QWORD *)(v3 + 64);
      v48 = 0;
      v49 = 0;
      (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(_QWORD *)v15 + 136))(v15, v4, &v48);
      v16 = v49;
      if (v49)
      {
        p_shared_owners = (unint64_t *)&v49->__shared_owners_;
        do
          v18 = __ldaxr(p_shared_owners);
        while (__stlxr(v18 - 1, p_shared_owners));
        if (!v18)
        {
          ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
          std::__shared_weak_count::__release_weak(v16);
        }
      }
      v19 = v51;
      if (v51)
      {
        v20 = (unint64_t *)&v51->__shared_owners_;
        do
          v21 = __ldaxr(v20);
        while (__stlxr(v21 - 1, v20));
        if (!v21)
        {
          ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
          std::__shared_weak_count::__release_weak(v19);
        }
      }
    }
    else
    {
      v37 = *(NSObject **)v13(v12, v4, v10);
      if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)v50 = 0;
        _os_log_error_impl(&dword_216897000, v37, OS_LOG_TYPE_ERROR, "Failure cause is not present in the response, sending CLIR fetch error", v50, 2u);
      }
      v38 = *(_QWORD *)(v3 + 64);
      v39 = QMISuppServicesCommandDriver::mapQMIErrorToCSI((QMISuppServicesCommandDriver *)v3, *(unsigned __int16 *)(v44 + 24));
      (*(void (**)(uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)v38 + 144))(v38, v4, v39, 0);
    }
    _Block_object_dispose(&v43, 8);
  }
  else
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&v53 = buf;
    *((_QWORD *)&v53 + 1) = 0x3802000000;
    v54 = __Block_byref_object_copy__45;
    v55 = __Block_byref_object_dispose__46;
    v56 = 0;
    v57 = 0;
    v22 = (std::__shared_weak_count_vtbl *)operator new();
    LOWORD(v22->~__shared_weak_count) = 0;
    v23 = (std::__shared_weak_count *)operator new();
    v23->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E8260;
    v23->__shared_owners_ = 0;
    v23->__shared_weak_owners_ = 0;
    v23[1].__vftable = v22;
    v24 = v57;
    v56 = v22;
    v57 = v23;
    if (v24)
    {
      v25 = (unint64_t *)&v24->__shared_owners_;
      do
        v26 = __ldaxr(v25);
      while (__stlxr(v26 - 1, v25));
      if (!v26)
      {
        ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
        std::__shared_weak_count::__release_weak(v24);
      }
    }
    v43 = MEMORY[0x24BDAC760];
    v44 = 0x40000000;
    v45 = (uint64_t)___ZN28QMISuppServicesCommandDriver18handleCLIRResponseEN10subscriber7SimSlotERKN2vs7GetCLIR8ResponseE_block_invoke_47;
    v46 = &unk_24D5E75E0;
    v47 = buf;
    *(_QWORD *)v50 = &v43;
    qmi::MessageBase::applyTlv<vs::tlv::SuppServiceStatus,void({block_pointer})(vs::tlv::SuppServiceStatus const&)>((qmi::MessageBase *)v42, (uint64_t)v50);
    v27 = *(_QWORD *)(v3 + 64);
    v28 = *(std::__shared_weak_count **)(v53 + 48);
    *(_QWORD *)v50 = *(_QWORD *)(v53 + 40);
    v51 = v28;
    if (v28)
    {
      v29 = (unint64_t *)&v28->__shared_owners_;
      do
        v30 = __ldxr(v29);
      while (__stxr(v30 + 1, v29));
    }
    (*(void (**)(uint64_t, uint64_t, uint8_t *))(*(_QWORD *)v27 + 136))(v27, v4, v50);
    v31 = v51;
    if (v51)
    {
      v32 = (unint64_t *)&v51->__shared_owners_;
      do
        v33 = __ldaxr(v32);
      while (__stlxr(v33 - 1, v32));
      if (!v33)
      {
        ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
        std::__shared_weak_count::__release_weak(v31);
      }
    }
    _Block_object_dispose(buf, 8);
    v34 = v57;
    if (v57)
    {
      v35 = (unint64_t *)&v57->__shared_owners_;
      do
        v36 = __ldaxr(v35);
      while (__stlxr(v36 - 1, v35));
      if (!v36)
      {
        ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
        std::__shared_weak_count::__release_weak(v34);
      }
    }
  }
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v42);
}

void sub_216A69E0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  _Block_object_dispose(&a12, 8);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_32c96_ZTSNSt3__110shared_ptrIZN28QMISuppServicesCommandDriver9fetchCLIREN10subscriber7SimSlotEE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c96_ZTSNSt3__110shared_ptrIZN28QMISuppServicesCommandDriver9fetchCLIREN10subscriber7SimSlotEE3__0EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMISuppServicesCommandDriver::fetchCLIR(subscriber::SimSlot)::$_0,std::allocator<QMISuppServicesCommandDriver::fetchCLIR(subscriber::SimSlot)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E8210;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMISuppServicesCommandDriver::fetchCLIR(subscriber::SimSlot)::$_0,std::allocator<QMISuppServicesCommandDriver::fetchCLIR(subscriber::SimSlot)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E8210;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void std::__shared_ptr_pointer<CLIRSettingsModel *,std::shared_ptr<CLIRSettingsModel>::__shared_ptr_default_delete<CLIRSettingsModel,CLIRSettingsModel>,std::allocator<CLIRSettingsModel>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

uint64_t std::__shared_ptr_pointer<CLIRSettingsModel *,std::shared_ptr<CLIRSettingsModel>::__shared_ptr_default_delete<CLIRSettingsModel,CLIRSettingsModel>,std::allocator<CLIRSettingsModel>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    JUMPOUT(0x2199FEAC4);
  return result;
}

uint64_t std::__shared_ptr_pointer<CLIRSettingsModel *,std::shared_ptr<CLIRSettingsModel>::__shared_ptr_default_delete<CLIRSettingsModel,CLIRSettingsModel>,std::allocator<CLIRSettingsModel>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t qmi::MessageBase::applyTlv<vs::tlv::SuppServiceStatus,void({block_pointer})(vs::tlv::SuppServiceStatus const&)>(qmi::MessageBase *a1, uint64_t a2)
{
  uint64_t result;
  int v5;
  uint64_t v6;
  int v7;
  __int16 v8;
  uint64_t v9;

  result = qmi::MessageBase::findTlvValue(a1);
  if (result)
  {
    v6 = result;
    v7 = v5;
    v9 = result;
    v8 = tlv::parseV<vs::tlv::SuppServiceStatus>((unint64_t *)&v9, v5);
    if (v9)
      return (*(uint64_t (**)(void))(*(_QWORD *)a2 + 16))();
    else
      return ((uint64_t (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, 16, v6, v7);
  }
  return result;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMISuppServicesCommandDriver9fetchCLIPEN10subscriber7SimSlotEE3__0EEOS1_OT__block_invoke(uint64_t a1, _QWORD *a2)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  std::__shared_weak_count_vtbl *v12;
  std::__shared_weak_count *v13;
  std::__shared_weak_count *v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  int v27;
  uint64_t v28;
  _QWORD v29[3];
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  void *v33;
  uint64_t *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  __n128 (*v38)(uint64_t, uint64_t);
  uint64_t (*v39)(uint64_t);
  std::__shared_weak_count_vtbl *v40;
  std::__shared_weak_count *v41;
  uint8_t buf[8];
  _QWORD v43[3];

  v43[2] = *MEMORY[0x24BDAC8D0];
  v2 = *(uint64_t **)(a1 + 32);
  v3 = *v2;
  v4 = *((unsigned int *)v2 + 2);
  v5 = a2[1];
  v29[0] = *a2;
  v29[1] = v5;
  v6 = a2[2];
  v29[2] = v6;
  if (v6)
  {
    v7 = (unint64_t *)(v6 + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  qmi::MessageBase::validateMsgId((qmi::MessageBase *)v29);
  if (HIDWORD(v29[0]))
  {
    v30 = 0;
    v31 = (uint64_t)&v30;
    v32 = 0x2000000000;
    LOWORD(v33) = 0;
    v35 = MEMORY[0x24BDAC760];
    v36 = 0x40000000;
    v37 = (uint64_t)___ZN28QMISuppServicesCommandDriver18handleCLIPResponseEN10subscriber7SimSlotERKN2vs7GetCLIP8ResponseE_block_invoke;
    v38 = (__n128 (*)(uint64_t, uint64_t))&unk_24D5E7608;
    LODWORD(v41) = v4;
    v39 = (uint64_t (*)(uint64_t))&v30;
    v40 = (std::__shared_weak_count_vtbl *)v3;
    *(_QWORD *)buf = &v35;
    qmi::MessageBase::applyTlv<vs::tlv::FailureCause,void({block_pointer})(vs::tlv::FailureCause const&)>((qmi::MessageBase *)v29, 17, (uint64_t)buf);
    v9 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v3 + 80) + 16))(*(_QWORD *)(v3 + 80), v4);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      v27 = HIDWORD(v29[0]);
      v28 = qmi::asString();
      *(_DWORD *)buf = 67109378;
      *(_DWORD *)&buf[4] = v27;
      LOWORD(v43[0]) = 2080;
      *(_QWORD *)((char *)v43 + 2) = v28;
      _os_log_error_impl(&dword_216897000, v9, OS_LOG_TYPE_ERROR, "GetCLIP::Response returned error 0x%x (%s)", buf, 0x12u);
    }
    v10 = *(_QWORD *)(v3 + 64);
    v11 = QMISuppServicesCommandDriver::mapQMIErrorToCSI((QMISuppServicesCommandDriver *)v3, *(unsigned __int16 *)(v31 + 24));
    (*(void (**)(uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)v10 + 176))(v10, v4, v11, 0);
    _Block_object_dispose(&v30, 8);
  }
  else
  {
    v35 = 0;
    v36 = (uint64_t)&v35;
    v37 = 0x3802000000;
    v38 = __Block_byref_object_copy__51;
    v39 = __Block_byref_object_dispose__52;
    v40 = 0;
    v41 = 0;
    v12 = (std::__shared_weak_count_vtbl *)operator new();
    LOWORD(v12->~__shared_weak_count) = 0;
    v13 = (std::__shared_weak_count *)operator new();
    v13->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E8358;
    v13->__shared_owners_ = 0;
    v13->__shared_weak_owners_ = 0;
    v13[1].__vftable = v12;
    v14 = v41;
    v40 = v12;
    v41 = v13;
    if (v14)
    {
      p_shared_owners = (unint64_t *)&v14->__shared_owners_;
      do
        v16 = __ldaxr(p_shared_owners);
      while (__stlxr(v16 - 1, p_shared_owners));
      if (!v16)
      {
        ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
        std::__shared_weak_count::__release_weak(v14);
      }
    }
    v30 = MEMORY[0x24BDAC760];
    v31 = 0x40000000;
    v32 = (uint64_t)___ZN28QMISuppServicesCommandDriver18handleCLIPResponseEN10subscriber7SimSlotERKN2vs7GetCLIP8ResponseE_block_invoke_53;
    v33 = &unk_24D5E7630;
    v34 = &v35;
    *(_QWORD *)buf = &v30;
    qmi::MessageBase::applyTlv<vs::tlv::SuppServiceStatus,void({block_pointer})(vs::tlv::SuppServiceStatus const&)>((qmi::MessageBase *)v29, (uint64_t)buf);
    v17 = *(_QWORD *)(v3 + 64);
    v18 = *(_QWORD *)(v36 + 48);
    *(_QWORD *)buf = *(_QWORD *)(v36 + 40);
    v43[0] = v18;
    if (v18)
    {
      v19 = (unint64_t *)(v18 + 8);
      do
        v20 = __ldxr(v19);
      while (__stxr(v20 + 1, v19));
    }
    (*(void (**)(uint64_t, uint64_t, uint8_t *))(*(_QWORD *)v17 + 168))(v17, v4, buf);
    v21 = (std::__shared_weak_count *)v43[0];
    if (v43[0])
    {
      v22 = (unint64_t *)(v43[0] + 8);
      do
        v23 = __ldaxr(v22);
      while (__stlxr(v23 - 1, v22));
      if (!v23)
      {
        ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
        std::__shared_weak_count::__release_weak(v21);
      }
    }
    _Block_object_dispose(&v35, 8);
    v24 = v41;
    if (v41)
    {
      v25 = (unint64_t *)&v41->__shared_owners_;
      do
        v26 = __ldaxr(v25);
      while (__stlxr(v26 - 1, v25));
      if (!v26)
      {
        ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
        std::__shared_weak_count::__release_weak(v24);
      }
    }
  }
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v29);
}

void sub_216A6A3C0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v5 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v3 - 80);
  _Block_object_dispose(va1, 8);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v2 + 40);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_32c96_ZTSNSt3__110shared_ptrIZN28QMISuppServicesCommandDriver9fetchCLIPEN10subscriber7SimSlotEE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c96_ZTSNSt3__110shared_ptrIZN28QMISuppServicesCommandDriver9fetchCLIPEN10subscriber7SimSlotEE3__0EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMISuppServicesCommandDriver::fetchCLIP(subscriber::SimSlot)::$_0,std::allocator<QMISuppServicesCommandDriver::fetchCLIP(subscriber::SimSlot)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E8308;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMISuppServicesCommandDriver::fetchCLIP(subscriber::SimSlot)::$_0,std::allocator<QMISuppServicesCommandDriver::fetchCLIP(subscriber::SimSlot)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E8308;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void std::__shared_ptr_pointer<CLIPSettingsModel *,std::shared_ptr<CLIPSettingsModel>::__shared_ptr_default_delete<CLIPSettingsModel,CLIPSettingsModel>,std::allocator<CLIPSettingsModel>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

uint64_t std::__shared_ptr_pointer<CLIPSettingsModel *,std::shared_ptr<CLIPSettingsModel>::__shared_ptr_default_delete<CLIPSettingsModel,CLIPSettingsModel>,std::allocator<CLIPSettingsModel>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    JUMPOUT(0x2199FEAC4);
  return result;
}

uint64_t std::__shared_ptr_pointer<CLIPSettingsModel *,std::shared_ptr<CLIPSettingsModel>::__shared_ptr_default_delete<CLIPSettingsModel,CLIPSettingsModel>,std::allocator<CLIPSettingsModel>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMISuppServicesCommandDriver9fetchCOLREN10subscriber7SimSlotEE3__0EEOS1_OT__block_invoke(uint64_t a1, _QWORD *a2)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  NSObject *v9;
  int v10;
  uint64_t (*v11)(void);
  NSObject *v12;
  uint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  std::__shared_weak_count_vtbl *v20;
  std::__shared_weak_count *v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  uint64_t TlvValue;
  int v26;
  uint64_t v27;
  int v28;
  __int16 v29;
  NSObject *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t *v34;
  unint64_t *v35;
  unint64_t v36;
  std::__shared_weak_count *v37;
  unint64_t *v38;
  unint64_t v39;
  std::__shared_weak_count *v40;
  unint64_t *v41;
  unint64_t v42;
  int v43;
  uint64_t v44;
  _QWORD v45[3];
  uint64_t v46;
  std::__shared_weak_count *v47;
  uint8_t buf[8];
  std::__shared_weak_count *v49;
  uint64_t v50;
  unint64_t *v51;
  uint64_t v52;
  __int16 v53;
  uint8_t v54[8];
  __int128 v55;
  __n128 (*v56)(uint64_t, uint64_t);
  uint64_t (*v57)(uint64_t);
  std::__shared_weak_count_vtbl *v58;
  std::__shared_weak_count *v59;
  uint64_t v60;

  v60 = *MEMORY[0x24BDAC8D0];
  v2 = *(uint64_t **)(a1 + 32);
  v3 = *v2;
  v4 = *((unsigned int *)v2 + 2);
  v5 = a2[1];
  v45[0] = *a2;
  v45[1] = v5;
  v6 = a2[2];
  v45[2] = v6;
  if (v6)
  {
    v7 = (unint64_t *)(v6 + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  qmi::MessageBase::validateMsgId((qmi::MessageBase *)v45);
  if (HIDWORD(v45[0]))
  {
    v9 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v3 + 80) + 16))(*(_QWORD *)(v3 + 80), v4);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      v43 = HIDWORD(v45[0]);
      v44 = qmi::asString();
      *(_DWORD *)v54 = 67109378;
      *(_DWORD *)&v54[4] = v43;
      LOWORD(v55) = 2080;
      *(_QWORD *)((char *)&v55 + 2) = v44;
      _os_log_error_impl(&dword_216897000, v9, OS_LOG_TYPE_ERROR, "GetCOLR::Response returned error 0x%x (%s)", v54, 0x12u);
    }
    v50 = 0;
    v51 = (unint64_t *)&v50;
    v52 = 0x2000000000;
    v53 = 0;
    *(_QWORD *)v54 = MEMORY[0x24BDAC760];
    *(_QWORD *)&v55 = 0x40000000;
    *((_QWORD *)&v55 + 1) = ___ZN28QMISuppServicesCommandDriver18handleCOLRResponseIN2vs7GetCOLR8ResponseEEEvN10subscriber7SimSlotERKT__block_invoke;
    v56 = (__n128 (*)(uint64_t, uint64_t))&unk_24D5E8448;
    LODWORD(v59) = v4;
    v57 = (uint64_t (*)(uint64_t))&v50;
    v58 = (std::__shared_weak_count_vtbl *)v3;
    *(_QWORD *)buf = v54;
    v10 = qmi::MessageBase::applyTlv<vs::tlv::FailureCause,void({block_pointer}&)(vs::tlv::FailureCause const&)>((qmi::MessageBase *)v45, (uint64_t)buf);
    v11 = *(uint64_t (**)(void))(**(_QWORD **)(v3 + 80) + 16);
    if (v10)
    {
      v12 = *(NSObject **)v11();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_216897000, v12, OS_LOG_TYPE_DEFAULT, "#I Failure cause is present in the response, sending event", buf, 2u);
      }
      *(_QWORD *)buf = 0;
      v49 = 0;
      v13 = *(_QWORD *)(v3 + 64);
      v46 = 0;
      v47 = 0;
      (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(_QWORD *)v13 + 200))(v13, v4, &v46);
      v14 = v47;
      if (v47)
      {
        p_shared_owners = (unint64_t *)&v47->__shared_owners_;
        do
          v16 = __ldaxr(p_shared_owners);
        while (__stlxr(v16 - 1, p_shared_owners));
        if (!v16)
        {
          ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
          std::__shared_weak_count::__release_weak(v14);
        }
      }
      v17 = v49;
      if (v49)
      {
        v18 = (unint64_t *)&v49->__shared_owners_;
        do
          v19 = __ldaxr(v18);
        while (__stlxr(v19 - 1, v18));
        if (!v19)
        {
          ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
          std::__shared_weak_count::__release_weak(v17);
        }
      }
    }
    else
    {
      v30 = *(NSObject **)v11();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_216897000, v30, OS_LOG_TYPE_ERROR, "Failure cause is not present in the response, sending COLR fetch error", buf, 2u);
      }
      v31 = *(_QWORD *)(v3 + 64);
      v32 = QMISuppServicesCommandDriver::mapQMIErrorToCSI((QMISuppServicesCommandDriver *)v3, *((unsigned __int16 *)v51 + 12));
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v31 + 208))(v31, v4, v32);
    }
    _Block_object_dispose(&v50, 8);
  }
  else
  {
    *(_QWORD *)v54 = 0;
    *(_QWORD *)&v55 = v54;
    *((_QWORD *)&v55 + 1) = 0x3802000000;
    v56 = __Block_byref_object_copy__92;
    v57 = __Block_byref_object_dispose__93;
    v58 = 0;
    v59 = 0;
    v20 = (std::__shared_weak_count_vtbl *)operator new();
    LOWORD(v20->~__shared_weak_count) = 0;
    v21 = (std::__shared_weak_count *)operator new();
    v21->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E8478;
    v21->__shared_owners_ = 0;
    v21->__shared_weak_owners_ = 0;
    v21[1].__vftable = v20;
    v22 = v59;
    v58 = v20;
    v59 = v21;
    if (v22)
    {
      v23 = (unint64_t *)&v22->__shared_owners_;
      do
        v24 = __ldaxr(v23);
      while (__stlxr(v24 - 1, v23));
      if (!v24)
      {
        ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
        std::__shared_weak_count::__release_weak(v22);
      }
    }
    TlvValue = qmi::MessageBase::findTlvValue((qmi::MessageBase *)v45);
    v27 = TlvValue;
    if (TlvValue)
    {
      v28 = v26;
      v50 = TlvValue;
      v29 = tlv::parseV<vs::tlv::SuppServiceStatus>((unint64_t *)&v50, v26);
      if (v50)
        **(_WORD **)(v55 + 40) = v29;
      else
        ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(LOWORD(v45[0]), 16, v27, v28);
    }
    v33 = *(_QWORD *)(v3 + 64);
    v34 = *(unint64_t **)(v55 + 48);
    v50 = *(_QWORD *)(v55 + 40);
    v51 = v34;
    if (v34)
    {
      v35 = v34 + 1;
      do
        v36 = __ldxr(v35);
      while (__stxr(v36 + 1, v35));
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(_QWORD *)v33 + 200))(v33, v4, &v50);
    v37 = (std::__shared_weak_count *)v51;
    if (v51)
    {
      v38 = v51 + 1;
      do
        v39 = __ldaxr(v38);
      while (__stlxr(v39 - 1, v38));
      if (!v39)
      {
        ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
        std::__shared_weak_count::__release_weak(v37);
      }
    }
    _Block_object_dispose(v54, 8);
    v40 = v59;
    if (v59)
    {
      v41 = (unint64_t *)&v59->__shared_owners_;
      do
        v42 = __ldaxr(v41);
      while (__stlxr(v42 - 1, v41));
      if (!v42)
      {
        ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
        std::__shared_weak_count::__release_weak(v40);
      }
    }
  }
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v45);
}

void sub_216A6AA0C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3;
  va_list va;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  v5 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  _Block_object_dispose(va1, 8);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_32c96_ZTSNSt3__110shared_ptrIZN28QMISuppServicesCommandDriver9fetchCOLREN10subscriber7SimSlotEE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c96_ZTSNSt3__110shared_ptrIZN28QMISuppServicesCommandDriver9fetchCOLREN10subscriber7SimSlotEE3__0EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMISuppServicesCommandDriver::fetchCOLR(subscriber::SimSlot)::$_0,std::allocator<QMISuppServicesCommandDriver::fetchCOLR(subscriber::SimSlot)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E8400;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMISuppServicesCommandDriver::fetchCOLR(subscriber::SimSlot)::$_0,std::allocator<QMISuppServicesCommandDriver::fetchCOLR(subscriber::SimSlot)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E8400;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void ___ZN28QMISuppServicesCommandDriver18handleCOLRResponseIN2vs7GetCOLR8ResponseEEEvN10subscriber7SimSlotERKT__block_invoke(uint64_t a1, _WORD *a2)
{
  NSObject *v4;
  uint8_t v5[16];

  v4 = *(NSObject **)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 40) + 80) + 16))(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 80), *(unsigned int *)(a1 + 48));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v5 = 0;
    _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I Failure cause is present in the response", v5, 2u);
  }
  *(_WORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *a2;
}

__n128 __Block_byref_object_copy__92(uint64_t a1, uint64_t a2)
{
  __n128 result;

  result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 40) = result;
  *(_QWORD *)(a2 + 40) = 0;
  *(_QWORD *)(a2 + 48) = 0;
  return result;
}

uint64_t __Block_byref_object_dispose__93(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 40);
}

uint64_t qmi::MessageBase::applyTlv<vs::tlv::FailureCause,void({block_pointer}&)(vs::tlv::FailureCause const&)>(qmi::MessageBase *a1, uint64_t a2)
{
  uint64_t result;
  int v5;
  uint64_t v6;
  int v7;
  __int16 v8;
  uint64_t v9;

  result = qmi::MessageBase::findTlvValue(a1);
  if (result)
  {
    v6 = result;
    v7 = v5;
    v9 = result;
    v8 = tlv::parseV<vs::tlv::FailureCause>((unint64_t *)&v9, v5);
    if (v9)
    {
      (*(void (**)(void))(*(_QWORD *)a2 + 16))();
      return 1;
    }
    else
    {
      return ((uint64_t (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, 17, v6, v7);
    }
  }
  return result;
}

void std::__shared_ptr_pointer<COLRSettingsModel *,std::shared_ptr<COLRSettingsModel>::__shared_ptr_default_delete<COLRSettingsModel,COLRSettingsModel>,std::allocator<COLRSettingsModel>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

uint64_t std::__shared_ptr_pointer<COLRSettingsModel *,std::shared_ptr<COLRSettingsModel>::__shared_ptr_default_delete<COLRSettingsModel,COLRSettingsModel>,std::allocator<COLRSettingsModel>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    JUMPOUT(0x2199FEAC4);
  return result;
}

uint64_t std::__shared_ptr_pointer<COLRSettingsModel *,std::shared_ptr<COLRSettingsModel>::__shared_ptr_default_delete<COLRSettingsModel,COLRSettingsModel>,std::allocator<COLRSettingsModel>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMISuppServicesCommandDriver9fetchCNAPEN10subscriber7SimSlotEE3__0EEOS1_OT__block_invoke(uint64_t a1, _QWORD *a2)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  _WORD *v12;
  std::__shared_weak_count *v13;
  uint64_t TlvValue;
  int v15;
  uint64_t v16;
  int v17;
  __int16 v18;
  uint64_t v19;
  unint64_t *v20;
  unint64_t *v21;
  unint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  std::__shared_weak_count *v26;
  unint64_t *p_shared_owners;
  unint64_t v28;
  int v29;
  uint64_t v30;
  _QWORD v31[3];
  uint64_t v32;
  unint64_t *v33;
  uint64_t v34;
  __int16 v35;
  uint8_t *v36;
  uint8_t buf[8];
  __int128 v38;
  __n128 (*v39)(uint64_t, uint64_t);
  uint64_t (*v40)(uint64_t);
  _WORD *v41;
  std::__shared_weak_count *v42;
  uint64_t v43;

  v43 = *MEMORY[0x24BDAC8D0];
  v2 = *(uint64_t **)(a1 + 32);
  v3 = *v2;
  v4 = *((unsigned int *)v2 + 2);
  v5 = a2[1];
  v31[0] = *a2;
  v31[1] = v5;
  v6 = a2[2];
  v31[2] = v6;
  if (v6)
  {
    v7 = (unint64_t *)(v6 + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  qmi::MessageBase::validateMsgId((qmi::MessageBase *)v31);
  if (HIDWORD(v31[0]))
  {
    v9 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v3 + 80) + 16))(*(_QWORD *)(v3 + 80), v4);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      v29 = HIDWORD(v31[0]);
      v30 = qmi::asString();
      *(_DWORD *)buf = 67109378;
      *(_DWORD *)&buf[4] = v29;
      LOWORD(v38) = 2080;
      *(_QWORD *)((char *)&v38 + 2) = v30;
      _os_log_error_impl(&dword_216897000, v9, OS_LOG_TYPE_ERROR, "GetCNAP::Response returned error 0x%x (%s)", buf, 0x12u);
    }
    v32 = 0;
    v33 = (unint64_t *)&v32;
    v34 = 0x2000000000;
    v35 = 0;
    *(_QWORD *)&v38 = 0x40000000;
    *((_QWORD *)&v38 + 1) = ___ZN28QMISuppServicesCommandDriver18handleCNAPResponseEN10subscriber7SimSlotERKN2vs7GetCNAP8ResponseE_block_invoke;
    v39 = (__n128 (*)(uint64_t, uint64_t))&unk_24D5E7658;
    v40 = (uint64_t (*)(uint64_t))&v32;
    v36 = buf;
    *(_QWORD *)buf = MEMORY[0x24BDAC760];
    qmi::MessageBase::applyTlv<vs::tlv::FailureCause,void({block_pointer}&)(vs::tlv::FailureCause const&)>((qmi::MessageBase *)v31, (uint64_t)&v36);
    v10 = *(_QWORD *)(v3 + 64);
    v11 = QMISuppServicesCommandDriver::mapQMIErrorToCSI((QMISuppServicesCommandDriver *)v3, *((unsigned __int16 *)v33 + 12));
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v10 + 224))(v10, v4, v11);
    _Block_object_dispose(&v32, 8);
  }
  else
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&v38 = buf;
    *((_QWORD *)&v38 + 1) = 0x3802000000;
    v39 = __Block_byref_object_copy__56;
    v40 = __Block_byref_object_dispose__57;
    v41 = 0;
    v42 = 0;
    v12 = (_WORD *)operator new();
    *v12 = 0;
    v41 = v12;
    v13 = (std::__shared_weak_count *)operator new();
    v13->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E8570;
    v13->__shared_owners_ = 0;
    v13->__shared_weak_owners_ = 0;
    v13[1].__vftable = (std::__shared_weak_count_vtbl *)v12;
    v42 = v13;
    TlvValue = qmi::MessageBase::findTlvValue((qmi::MessageBase *)v31);
    v16 = TlvValue;
    if (TlvValue)
    {
      v17 = v15;
      v32 = TlvValue;
      v18 = tlv::parseV<vs::tlv::CnapResponse>((unint64_t *)&v32, v15);
      if (v32)
        **(_WORD **)(v38 + 40) = v18;
      else
        ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(LOWORD(v31[0]), 16, v16, v17);
    }
    v19 = *(_QWORD *)(v3 + 64);
    v20 = *(unint64_t **)(v38 + 48);
    v32 = *(_QWORD *)(v38 + 40);
    v33 = v20;
    if (v20)
    {
      v21 = v20 + 1;
      do
        v22 = __ldxr(v21);
      while (__stxr(v22 + 1, v21));
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(_QWORD *)v19 + 216))(v19, v4, &v32);
    v23 = (std::__shared_weak_count *)v33;
    if (v33)
    {
      v24 = v33 + 1;
      do
        v25 = __ldaxr(v24);
      while (__stlxr(v25 - 1, v24));
      if (!v25)
      {
        ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
        std::__shared_weak_count::__release_weak(v23);
      }
    }
    _Block_object_dispose(buf, 8);
    v26 = v42;
    if (v42)
    {
      p_shared_owners = (unint64_t *)&v42->__shared_owners_;
      do
        v28 = __ldaxr(p_shared_owners);
      while (__stlxr(v28 - 1, p_shared_owners));
      if (!v28)
      {
        ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
        std::__shared_weak_count::__release_weak(v26);
      }
    }
  }
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v31);
}

void sub_216A6B048(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  uint64_t v17;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a12);
  _Block_object_dispose(&a17, 8);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v17 + 40);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_32c96_ZTSNSt3__110shared_ptrIZN28QMISuppServicesCommandDriver9fetchCNAPEN10subscriber7SimSlotEE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c96_ZTSNSt3__110shared_ptrIZN28QMISuppServicesCommandDriver9fetchCNAPEN10subscriber7SimSlotEE3__0EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMISuppServicesCommandDriver::fetchCNAP(subscriber::SimSlot)::$_0,std::allocator<QMISuppServicesCommandDriver::fetchCNAP(subscriber::SimSlot)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E8520;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMISuppServicesCommandDriver::fetchCNAP(subscriber::SimSlot)::$_0,std::allocator<QMISuppServicesCommandDriver::fetchCNAP(subscriber::SimSlot)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E8520;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void std::__shared_ptr_pointer<CNAPSettingsModel *,std::shared_ptr<CNAPSettingsModel>::__shared_ptr_default_delete<CNAPSettingsModel,CNAPSettingsModel>,std::allocator<CNAPSettingsModel>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

uint64_t std::__shared_ptr_pointer<CNAPSettingsModel *,std::shared_ptr<CNAPSettingsModel>::__shared_ptr_default_delete<CNAPSettingsModel,CNAPSettingsModel>,std::allocator<CNAPSettingsModel>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    JUMPOUT(0x2199FEAC4);
  return result;
}

uint64_t std::__shared_ptr_pointer<CNAPSettingsModel *,std::shared_ptr<CNAPSettingsModel>::__shared_ptr_default_delete<CNAPSettingsModel,CNAPSettingsModel>,std::allocator<CNAPSettingsModel>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t dfs::tlv::writeField(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)a1 = *(_BYTE *)a2;
  *(_QWORD *)(a1 + 1) = *(_QWORD *)(a2 + 8);
  *(_DWORD *)(a1 + 9) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a1 + 13) = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(a1 + 17) = *(_DWORD *)(a2 + 24);
  *(_DWORD *)(a1 + 21) = *(_DWORD *)(a2 + 28);
  *(_BYTE *)(a1 + 25) = *(_BYTE *)(a2 + 32);
  *(_BYTE *)(a1 + 26) = *(_BYTE *)(a2 + 33);
  *(_QWORD *)(a1 + 27) = *(_QWORD *)(a2 + 40);
  *(_OWORD *)(a1 + 35) = *(_OWORD *)(a2 + 48);
  *(_BYTE *)(a1 + 51) = *(_BYTE *)(a2 + 64);
  *(_OWORD *)(a1 + 52) = *(_OWORD *)(a2 + 65);
  *(_BYTE *)(a1 + 68) = *(_BYTE *)(a2 + 81);
  *(_BYTE *)(a1 + 69) = *(_BYTE *)(a2 + 82);
  *(_BYTE *)(a1 + 70) = *(_BYTE *)(a2 + 83);
  *(_DWORD *)(a1 + 71) = *(_DWORD *)(a2 + 84);
  return a1 + 75;
}

{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(_QWORD *)(a1 + 4) = *(_QWORD *)(a2 + 8);
  *(_WORD *)(a1 + 12) = *(_WORD *)(a2 + 16);
  *(_WORD *)(a1 + 14) = *(_WORD *)(a2 + 18);
  *(_WORD *)(a1 + 16) = *(_WORD *)(a2 + 20);
  *(_WORD *)(a1 + 18) = *(_WORD *)(a2 + 22);
  *(_QWORD *)(a1 + 20) = *(_QWORD *)(a2 + 24);
  *(_WORD *)(a1 + 28) = *(_WORD *)(a2 + 32);
  *(_WORD *)(a1 + 30) = *(_WORD *)(a2 + 34);
  *(_WORD *)(a1 + 32) = *(_WORD *)(a2 + 36);
  *(_WORD *)(a1 + 34) = *(_WORD *)(a2 + 38);
  *(_QWORD *)(a1 + 36) = *(_QWORD *)(a2 + 40);
  *(_BYTE *)(a1 + 44) = *(_BYTE *)(a2 + 48);
  *(_BYTE *)(a1 + 45) = *(_BYTE *)(a2 + 49);
  *(_QWORD *)(a1 + 46) = *(_QWORD *)(a2 + 56);
  *(_DWORD *)(a1 + 54) = *(_DWORD *)(a2 + 64);
  *(_QWORD *)(a1 + 58) = *(_QWORD *)(a2 + 72);
  *(_DWORD *)(a1 + 66) = *(_DWORD *)(a2 + 80);
  return a1 + 70;
}

_DWORD *dfs::tlv::parseField(_DWORD *a1, const unsigned __int8 *a2, _DWORD *a3)
{
  _DWORD *result;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 4uLL);
  *a3 = *a1;
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 1), a2, 4uLL);
  a3[1] = a1[1];
  tlv::throwIfNotEnoughBytes((unint64_t)(a1 + 2), a2, 4uLL);
  result = a1 + 3;
  a3[2] = a1[2];
  return result;
}

_DWORD *dfs::tlv::parseField(unsigned __int8 *a1, const unsigned __int8 *a2, _QWORD *a3)
{
  _DWORD *v6;
  unsigned int v7;
  _DWORD *v8;
  _DWORD *v9;
  _DWORD *result;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  v7 = *a1;
  v6 = a1 + 1;
  std::vector<dfs::tlv::LLFilterStatusInfo>::resize(a3, v7);
  v8 = (_DWORD *)*a3;
  v9 = (_DWORD *)a3[1];
  while (1)
  {
    result = v6;
    if (v8 == v9)
      break;
    v6 = dfs::tlv::parseField(v6, a2, v8);
    v8 += 3;
  }
  return result;
}

unsigned __int8 *tlv::parseV<dfs::tlv::LLFilterStatusList>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  unsigned __int8 *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = (unsigned __int8 *)dfs::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = result;
  return result;
}

void sub_216A6B3F4(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x216A6B3E8);
}

void sub_216A6B404(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

unint64_t dfs::tlv::parseField(unsigned __int8 *a1, const unsigned __int8 *a2, uint64_t *a3)
{
  unint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;

  tlv::throwIfNotEnoughBytes((unint64_t)a1, a2, 1uLL);
  v7 = *a1;
  v6 = (unint64_t)(a1 + 1);
  std::vector<wds::tlv::Ipv4AddrInfo>::resize((uint64_t)a3, v7);
  v9 = *a3;
  v8 = a3[1];
  while (v9 != v8)
  {
    tlv::throwIfNotEnoughBytes(v6, a2, 2uLL);
    *(_WORD *)v9 = *(_WORD *)v6;
    tlv::throwIfNotEnoughBytes(v6 + 2, a2, 4uLL);
    *(_DWORD *)(v9 + 4) = *(_DWORD *)(v6 + 2);
    v6 += 6;
    v9 += 8;
  }
  return v6;
}

unint64_t tlv::parseV<dfs::tlv::LLFilterHandlesList>@<X0>(unsigned __int8 **a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  unint64_t result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  result = dfs::tlv::parseField(*a1, &(*a1)[a2], a3);
  *a1 = (unsigned __int8 *)result;
  return result;
}

void sub_216A6B4E8(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x216A6B4DCLL);
}

void sub_216A6B4F8(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_BYTE **tlv::writeV<dfs::tlv::IPv4SrcAddrFiltersList>(_BYTE **result, _DWORD *a2)
{
  _BYTE *v2;
  _BYTE *v3;
  uint64_t v4;
  uint64_t v5;

  v2 = *result;
  *v2 = -85 * ((a2[2] - *a2) >> 2);
  v3 = v2 + 1;
  v4 = *(_QWORD *)a2;
  v5 = *((_QWORD *)a2 + 1);
  while (v4 != v5)
  {
    *(_WORD *)v3 = *(_WORD *)v4;
    *(_DWORD *)(v3 + 2) = *(_DWORD *)(v4 + 4);
    *(_DWORD *)(v3 + 6) = *(_DWORD *)(v4 + 8);
    v3 += 10;
    v4 += 12;
  }
  *result = v3;
  return result;
}

_BYTE **tlv::writeV<dfs::tlv::IPv6SrcAddrFiltersList>(_BYTE **result, _DWORD *a2)
{
  _BYTE *v2;
  _BYTE *v3;
  uint64_t v4;
  uint64_t v5;
  _BYTE *v6;

  v2 = *result;
  *v2 = -51 * ((a2[2] - *a2) >> 2);
  v3 = v2 + 1;
  v4 = *(_QWORD *)a2;
  v5 = *((_QWORD *)a2 + 1);
  if (*(_QWORD *)a2 == v5)
  {
    v6 = v3;
  }
  else
  {
    do
    {
      *(_WORD *)v3 = *(_WORD *)v4;
      *(_OWORD *)(v3 + 2) = *(_OWORD *)(v4 + 2);
      v6 = v3 + 19;
      v3[18] = *(_BYTE *)(v4 + 18);
      v4 += 20;
      v3 += 19;
    }
    while (v4 != v5);
  }
  *result = v6;
  return result;
}

_BYTE **tlv::writeV<dfs::tlv::TosFiltersList>(_BYTE **result, _DWORD *a2)
{
  _BYTE *v2;
  _BYTE *v3;
  uint64_t v4;
  uint64_t v5;
  _BYTE *v6;

  v2 = *result;
  *v2 = (a2[2] - *a2) >> 2;
  v3 = v2 + 1;
  v4 = *(_QWORD *)a2;
  v5 = *((_QWORD *)a2 + 1);
  if (*(_QWORD *)a2 == v5)
  {
    v6 = v3;
  }
  else
  {
    do
    {
      *(_WORD *)v3 = *(_WORD *)v4;
      v3[2] = *(_BYTE *)(v4 + 2);
      v6 = v3 + 4;
      v3[3] = *(_BYTE *)(v4 + 3);
      v4 += 4;
      v3 += 4;
    }
    while (v4 != v5);
  }
  *result = v6;
  return result;
}

_BYTE **tlv::writeV<dfs::tlv::UdpSrcPortFiltersList>(_BYTE **result, _DWORD *a2)
{
  _BYTE *v2;
  _WORD *v3;
  _WORD *v4;
  _WORD *v5;

  v2 = *result;
  *v2 = -85 * ((a2[2] - *a2) >> 1);
  v3 = v2 + 1;
  v4 = *(_WORD **)a2;
  v5 = (_WORD *)*((_QWORD *)a2 + 1);
  while (v4 != v5)
  {
    *v3 = *v4;
    v3[1] = v4[1];
    v3[2] = v4[2];
    v3 += 3;
    v4 += 3;
  }
  *result = v3;
  return result;
}

uint64_t tlv::parseV<dfs::tlv::LLFilterCapability>(unint64_t *a1, int a2)
{
  unsigned int *v3;
  const unsigned __int8 *v4;
  unsigned int v5;
  uint64_t v6;

  v3 = (unsigned int *)*a1;
  v4 = (const unsigned __int8 *)(*a1 + a2);
  tlv::throwIfNotEnoughBytes(*a1, v4, 4uLL);
  v5 = *v3;
  tlv::throwIfNotEnoughBytes((unint64_t)(v3 + 1), v4, 4uLL);
  v6 = v3[1];
  *a1 = (unint64_t)(v3 + 2);
  return (v6 << 32) | v5;
}

void sub_216A6B704(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
  JUMPOUT(0x216A6B6ECLL);
}

uint64_t dfs::tlv::writeField(_BYTE *a1, _DWORD *a2)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *a1 = -93 * ((a2[2] - *a2) >> 4);
  result = (uint64_t)(a1 + 1);
  v3 = *(_QWORD *)a2;
  v4 = *((_QWORD *)a2 + 1);
  while (v3 != v4)
  {
    v5 = dfs::tlv::writeField(result, v3);
    result = dfs::tlv::writeField(v5, v3 + 88);
    v3 += 176;
  }
  return result;
}

void std::vector<dfs::tlv::LLFilterStatusInfo>::resize(_QWORD *a1, unint64_t a2)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;

  v2 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a1[1] - *a1) >> 2);
  v3 = a2 >= v2;
  v4 = a2 - v2;
  if (v4 != 0 && v3)
  {
    std::vector<dfs::tlv::LLFilterStatusInfo>::__append((uint64_t)a1, v4);
  }
  else if (!v3)
  {
    a1[1] = *a1 + 12 * a2;
  }
}

void std::vector<dfs::tlv::LLFilterStatusInfo>::__append(uint64_t a1, unint64_t a2)
{
  uint64_t v4;
  _DWORD *v5;
  _DWORD *v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  char *v11;
  size_t v12;
  char *v13;
  char *v14;
  size_t v15;
  char *v16;
  uint64_t v17;
  int v18;

  v5 = *(_DWORD **)(a1 + 8);
  v4 = *(_QWORD *)(a1 + 16);
  if (0xAAAAAAAAAAAAAAABLL * ((v4 - (uint64_t)v5) >> 2) >= a2)
  {
    if (a2)
    {
      v12 = 12 * ((12 * a2 - 12) / 0xC) + 12;
      bzero(*(void **)(a1 + 8), v12);
      v5 = (_DWORD *)((char *)v5 + v12);
    }
    *(_QWORD *)(a1 + 8) = v5;
  }
  else
  {
    v6 = *(_DWORD **)a1;
    v7 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v5 - *(_QWORD *)a1) >> 2);
    v8 = v7 + a2;
    if (v7 + a2 > 0x1555555555555555)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v9 = 0xAAAAAAAAAAAAAAABLL * ((v4 - (uint64_t)v6) >> 2);
    if (2 * v9 > v8)
      v8 = 2 * v9;
    if (v9 >= 0xAAAAAAAAAAAAAAALL)
      v10 = 0x1555555555555555;
    else
      v10 = v8;
    if (v10)
    {
      if (v10 > 0x1555555555555555)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v11 = (char *)operator new(12 * v10);
    }
    else
    {
      v11 = 0;
    }
    v13 = &v11[12 * v7];
    v14 = &v11[12 * v10];
    v15 = 12 * ((12 * a2 - 12) / 0xC) + 12;
    bzero(v13, v15);
    v16 = &v13[v15];
    if (v5 != v6)
    {
      do
      {
        v17 = *(_QWORD *)(v5 - 3);
        v5 -= 3;
        v18 = v5[2];
        *(_QWORD *)(v13 - 12) = v17;
        v13 -= 12;
        *((_DWORD *)v13 + 2) = v18;
      }
      while (v5 != v6);
      v5 = *(_DWORD **)a1;
    }
    *(_QWORD *)a1 = v13;
    *(_QWORD *)(a1 + 8) = v16;
    *(_QWORD *)(a1 + 16) = v14;
    if (v5)
      operator delete(v5);
  }
}

double QMINetworkRegistrationDriver::create@<D0>(uint64_t a1@<X0>, NSObject **a2@<X1>, _OWORD *a3@<X8>)
{
  uint64_t v6;
  NSObject *v7;
  __int128 v8;
  _QWORD *v9;
  unint64_t *v10;
  unint64_t v11;
  _OWORD *v12;
  NSObject *v13;
  uint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  _QWORD *v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  double result;
  dispatch_object_t v23;
  __int128 v24;
  uint64_t v25;
  std::__shared_weak_count *v26;
  uint64_t v27;
  uint64_t v28;

  v6 = operator new();
  v7 = *a2;
  v23 = v7;
  if (v7)
    dispatch_retain(v7);
  v24 = 0uLL;
  QMINetworkRegistrationDriver::QMINetworkRegistrationDriver(v6, a1, &v23);
  v24 = 0uLL;
  std::shared_ptr<QMINetworkRegistrationDriver>::shared_ptr[abi:ne180100]<QMINetworkRegistrationDriver,std::shared_ptr<QMINetworkRegistrationDriver> ctu::SharedSynchronizable<NetworkRegistrationDriver>::make_shared_ptr<QMINetworkRegistrationDriver>(QMINetworkRegistrationDriver*)::{lambda(QMINetworkRegistrationDriver*)#1},void>((uint64_t *)&v24, v6);
  if (v7)
    dispatch_release(v7);
  v8 = v24;
  v9 = (_QWORD *)(v24 + 8);
  if (*((_QWORD *)&v24 + 1))
  {
    v10 = (unint64_t *)(*((_QWORD *)&v24 + 1) + 8);
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }
  v25 = 0;
  v26 = 0;
  std::shared_ptr<AttachApnCommandDriver>::shared_ptr[abi:ne180100]<AttachApnCommandDriver,void>(&v25, v9);
  v12 = (_OWORD *)operator new();
  *v12 = v8;
  v13 = *(NSObject **)(v8 + 24);
  v14 = v25;
  v15 = v26;
  if (v26)
  {
    p_shared_owners = (unint64_t *)&v26->__shared_owners_;
    do
      v17 = __ldxr(p_shared_owners);
    while (__stxr(v17 + 1, p_shared_owners));
  }
  v18 = (_QWORD *)operator new();
  *v18 = v12;
  v18[1] = v14;
  v18[2] = v15;
  v27 = 0;
  v28 = 0;
  dispatch_async_f(v13, v18, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<NetworkRegistrationDriver>::execute_wrapped<QMINetworkRegistrationDriver::create(std::shared_ptr<Registry const> const&,dispatch::workloop)::$_0>(QMINetworkRegistrationDriver::create(std::shared_ptr<Registry const> const&,dispatch::workloop)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMINetworkRegistrationDriver::create(std::shared_ptr<Registry const> const&,dispatch::workloop)::$_0,std::default_delete<QMINetworkRegistrationDriver::create(std::shared_ptr<Registry const> const&,dispatch::workloop)::$_0>>)::{lambda(void *)#1}::__invoke);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v27);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v28);
  v19 = v26;
  if (v26)
  {
    v20 = (unint64_t *)&v26->__shared_owners_;
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }
  result = *(double *)&v24;
  *a3 = v24;
  return result;
}

void sub_216A6BADC(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  NSObject *v2;
  int v3;

  if (v2)
    dispatch_release(v2);
  if (v3)
    MEMORY[0x2199FEAC4](v1, 0xF1C40B0401646);
  _Unwind_Resume(exception_object);
}

uint64_t QMINetworkRegistrationDriver::QMINetworkRegistrationDriver(uint64_t a1, uint64_t a2, dispatch_object_t *a3)
{
  capabilities::ct *v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  NSObject *object;
  _QWORD v17[3];
  _QWORD *v18;
  _BYTE v19[24];
  _BYTE *v20;
  _BYTE v21[24];
  _BYTE *v22;
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  object = *a3;
  if (*a3)
    dispatch_retain(*a3);
  NetworkRegistrationDriver::NetworkRegistrationDriver();
  if (object)
    dispatch_release(object);
  v17[0] = &unk_24D5CCF40;
  v18 = v17;
  v4 = (capabilities::ct *)std::__function::__value_func<char const* const ()(subscriber::SimSlot)>::__value_func[abi:ne180100]((uint64_t)v19, (uint64_t)v17);
  *(_QWORD *)(a1 + 88) = 0;
  if ((capabilities::ct::supportsGemini(v4) & 1) == 0)
  {
    v5 = (_QWORD *)operator new();
    *v5 = &off_24D5E89F8;
    v5[1] = a1;
    v6 = *(_QWORD *)(a1 + 88);
    *(_QWORD *)(a1 + 88) = v5;
    if (!v6)
      goto LABEL_16;
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
  }
  if (!*(_QWORD *)(a1 + 88))
  {
    v7 = (_QWORD *)operator new();
    std::__function::__value_func<char const* const ()(subscriber::SimSlot)>::__value_func[abi:ne180100]((uint64_t)v21, (uint64_t)v19);
    SimInstanceLoggerDefault<ctu::OsLogLogger,subscriber::SimSlot,std::function<char const* const ()(subscriber::SimSlot)>>::SimInstanceLoggerDefault(v7);
    v8 = v22;
    if (v22 == v21)
    {
      v9 = 4;
      v8 = v21;
    }
    else
    {
      if (!v22)
        goto LABEL_14;
      v9 = 5;
    }
    (*(void (**)(void))(*v8 + 8 * v9))();
LABEL_14:
    v10 = *(_QWORD *)(a1 + 88);
    *(_QWORD *)(a1 + 88) = v7;
    if (v10)
      (*(void (**)(uint64_t))(*(_QWORD *)v10 + 8))(v10);
  }
LABEL_16:
  v11 = v20;
  if (v20 == v19)
  {
    v12 = 4;
    v11 = v19;
  }
  else
  {
    if (!v20)
      goto LABEL_21;
    v12 = 5;
  }
  (*(void (**)(void))(*v11 + 8 * v12))();
LABEL_21:
  v13 = v18;
  if (v18 == v17)
  {
    v14 = 4;
    v13 = v17;
    goto LABEL_25;
  }
  if (v18)
  {
    v14 = 5;
LABEL_25:
    (*(void (**)(void))(*v13 + 8 * v14))();
  }
  *(_QWORD *)a1 = &off_24D5E85E8;
  ctu::enable_make_unique<qmi::NotifyHelper>::make_unique<std::shared_ptr<Registry const> const&>((uint64_t *)(a1 + 96));
  qmi::ClientRouter::ClientRouter((qmi::ClientRouter *)(a1 + 104), *(os_log_s **)(a1 + 40));
  return a1;
}

void sub_216A6BD34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, char a14, uint64_t a15, uint64_t a16, char *a17, char a18, uint64_t a19, uint64_t a20,char *a21)
{
  NetworkRegistrationDriver *v21;
  uint64_t v22;
  char *v23;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;

  v25 = a21;
  if (a21 == v23)
  {
    v26 = 4;
    v25 = &a18;
  }
  else
  {
    if (!a21)
      goto LABEL_6;
    v26 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v25 + 8 * v26))();
LABEL_6:
  MEMORY[0x2199FEAC4](v22, 0x10A1C40FF1576FELL);
  v27 = *((_QWORD *)v21 + 11);
  *((_QWORD *)v21 + 11) = 0;
  if (v27)
    (*(void (**)(uint64_t))(*(_QWORD *)v27 + 8))(v27);
  v28 = a17;
  if (a17 == &a14)
  {
    v29 = 4;
    v28 = &a14;
  }
  else
  {
    if (!a17)
      goto LABEL_13;
    v29 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v28 + 8 * v29))();
LABEL_13:
  v30 = a13;
  if (a13 == &a10)
  {
    v31 = 4;
    v30 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_18;
    v31 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v30 + 8 * v31))();
LABEL_18:
  NetworkRegistrationDriver::~NetworkRegistrationDriver(v21);
  _Unwind_Resume(a1);
}

void sub_216A6BE40(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object)
{
  if (object)
    dispatch_release(object);
  JUMPOUT(0x216A6BE38);
}

void QMINetworkRegistrationDriver::~QMINetworkRegistrationDriver(qmi::NotifyHelper **this)
{
  qmi::NotifyHelper *v2;

  *this = (qmi::NotifyHelper *)&off_24D5E85E8;
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)(this + 13));
  std::unique_ptr<qmi::NotifyHelper>::reset[abi:ne180100](this + 12, 0);
  v2 = this[11];
  this[11] = 0;
  if (v2)
    (*(void (**)(qmi::NotifyHelper *))(*(_QWORD *)v2 + 8))(v2);
  NetworkRegistrationDriver::~NetworkRegistrationDriver((NetworkRegistrationDriver *)this);
}

{
  QMINetworkRegistrationDriver::~QMINetworkRegistrationDriver(this);
  JUMPOUT(0x2199FEAC4);
}

void QMINetworkRegistrationDriver::sendIndRegisterReq_sync(uint64_t a1, uint64_t a2)
{
  int v2;
  os_log_t *v4;
  const void **v5;
  char *v6;
  _BYTE *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;
  const void **v21;
  const void **v22;
  const void **v23;
  char *v24;
  _BYTE *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  unint64_t v31;
  char *v32;
  const void **v33;
  char *v34;
  char *v35;
  char *v36;
  const void *v37;
  char *v38;
  _BYTE *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  _QWORD *v43;
  uint64_t v44;
  unint64_t v45;
  unint64_t v46;
  char *v47;
  uint64_t *v48;
  char *v49;
  char *v50;
  char *v51;
  uint64_t v52;
  std::mutex *ServiceMap;
  uint64_t v54;
  std::__shared_weak_count *v55;
  unint64_t *v56;
  unint64_t v57;
  char *v58;
  unint64_t *p_shared_owners;
  unint64_t v60;
  NSObject *v61;
  std::__shared_weak_count *v62;
  unint64_t *v63;
  unint64_t v64;
  const void **v65;
  char *v66;
  _BYTE *v67;
  char *v68;
  uint64_t v69;
  _QWORD *v70;
  uint64_t v71;
  unint64_t v72;
  unint64_t v73;
  char *v74;
  char *v75;
  char *v76;
  char *v77;
  uint64_t v78;
  uint64_t v79;
  const void **v80;
  const void **v81;
  const void **v82;
  char *v83;
  _BYTE *v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  unint64_t v89;
  unint64_t v90;
  char *v91;
  const void **v92;
  char *v93;
  char *v94;
  char *v95;
  const void *v96;
  char *v97;
  _BYTE *v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  unint64_t v103;
  unint64_t v104;
  char *v105;
  const void **v106;
  char *v107;
  char *v108;
  char *v109;
  const void *v110;
  const void **i;
  char *v112;
  _BYTE *v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  unint64_t v118;
  unint64_t v119;
  char *v120;
  const void **v121;
  char *v122;
  char *v123;
  char *v124;
  const void *v125;
  const void **j;
  char *v127;
  _WORD *v128;
  char *v129;
  uint64_t v130;
  _QWORD *v131;
  uint64_t v132;
  unint64_t v133;
  unint64_t v134;
  char *v135;
  char *v136;
  char *v137;
  char *v138;
  uint64_t v139;
  char *v140;
  const void **v141;
  _BYTE *v142;
  char *v143;
  uint64_t v144;
  _QWORD *v145;
  uint64_t v146;
  unint64_t v147;
  unint64_t v148;
  char *v149;
  char *v150;
  char *v151;
  char *v152;
  uint64_t v153;
  char *v154;
  const void **v155;
  _BYTE *v156;
  char *v157;
  uint64_t v158;
  _QWORD *v159;
  uint64_t v160;
  unint64_t v161;
  unint64_t v162;
  char *v163;
  char *v164;
  char *v165;
  char *v166;
  uint64_t v167;
  const void **v168;
  char *v169;
  _BYTE *v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  _QWORD *v174;
  uint64_t v175;
  unint64_t v176;
  unint64_t v177;
  char *v178;
  uint64_t *v179;
  char *v180;
  char *v181;
  char *v182;
  uint64_t v183;
  NSObject *v184;
  uint64_t v185;
  std::__shared_weak_count *v186;
  unint64_t *v187;
  uint64_t v188;
  uint64_t v189;
  unint64_t v190;
  std::__shared_weak_count *v191;
  unint64_t *v192;
  unint64_t v193;
  std::__shared_weak_count *v194;
  unint64_t *v195;
  unint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  void *__p[2];
  __int128 v201;
  uint8_t v202[8];
  uint64_t v203;
  void (*v204)(uint64_t, uint64_t);
  void *v205;
  _QWORD *v206;
  std::__shared_weak_count *v207;
  _QWORD *v208;
  std::__shared_weak_count *v209;
  uint8_t buf[8];
  uint64_t v211;
  void (*v212)(uint64_t, uint64_t);
  void *v213;
  uint8_t *v214;

  v2 = a2;
  if ((a2 - 1) >= 3)
    a2 = 0;
  else
    a2 = a2;
  v4 = (os_log_t *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 88) + 16))(*(_QWORD *)(a1 + 88), a2);
  *(_OWORD *)__p = 0u;
  v201 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  *(_BYTE *)qmi::MutableMessageBase::getTLV<nas::tlv::SystemSelectionPreference>(__p, 16) = 1;
  v5 = (const void **)__p[1];
  if (__p[1] != (void *)v201)
  {
    while (*((_BYTE *)*v5 + 8) != 35)
    {
      if (++v5 == (const void **)v201)
        goto LABEL_11;
    }
  }
  if (v5 == (const void **)v201)
  {
LABEL_11:
    v8 = operator new();
    v9 = v8;
    *(_WORD *)(v8 + 8) = 35;
    *(_QWORD *)v8 = &off_24D5E8AF8;
    v10 = v201;
    if ((unint64_t)v201 >= *((_QWORD *)&v201 + 1))
    {
      v12 = (uint64_t)(v201 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v12 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v13 = (uint64_t)(*((_QWORD *)&v201 + 1) - (unint64_t)__p[1]) >> 2;
      if (v13 <= v12 + 1)
        v13 = v12 + 1;
      if (*((_QWORD *)&v201 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v14 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v14 = v13;
      if (v14)
        v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v201 + 8, v14);
      else
        v15 = 0;
      v16 = (uint64_t *)&v15[8 * v12];
      v17 = &v15[8 * v14];
      *v16 = v9;
      v11 = v16 + 1;
      v19 = (char *)__p[1];
      v18 = (char *)v201;
      if ((void *)v201 != __p[1])
      {
        do
        {
          v20 = *((_QWORD *)v18 - 1);
          v18 -= 8;
          *--v16 = v20;
        }
        while (v18 != v19);
        v18 = (char *)__p[1];
      }
      __p[1] = v16;
      *(_QWORD *)&v201 = v11;
      *((_QWORD *)&v201 + 1) = v17;
      if (v18)
        operator delete(v18);
    }
    else
    {
      *(_QWORD *)v201 = v8;
      v11 = (_QWORD *)(v10 + 8);
    }
    v7 = (_BYTE *)(v9 + 9);
    *(_QWORD *)&v201 = v11;
  }
  else
  {
    if (!v6)
      __cxa_bad_cast();
    v7 = v6 + 9;
  }
  *v7 = 1;
  *(_BYTE *)qmi::MutableMessageBase::getTLV<nas::tlv::ServingSysEvents>(__p, 19) = 0;
  *(_BYTE *)qmi::MutableMessageBase::getTLV<nas::tlv::SysInfoEvents>(__p, 24) = 1;
  v21 = (const void **)__p[1];
  v22 = (const void **)v201;
  v23 = (const void **)__p[1];
  if (__p[1] != (void *)v201)
  {
    v23 = (const void **)__p[1];
    while (*((_BYTE *)*v23 + 8) != 30)
    {
      if (++v23 == (const void **)v201)
        goto LABEL_36;
    }
  }
  if (v23 == (const void **)v201)
  {
LABEL_36:
    v26 = operator new();
    v27 = v26;
    *(_WORD *)(v26 + 8) = 30;
    *(_QWORD *)v26 = &off_24D5E8B48;
    v28 = v201;
    if ((unint64_t)v201 >= *((_QWORD *)&v201 + 1))
    {
      v29 = (uint64_t)(v201 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v29 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v30 = (uint64_t)(*((_QWORD *)&v201 + 1) - (unint64_t)__p[1]) >> 2;
      if (v30 <= v29 + 1)
        v30 = v29 + 1;
      if (*((_QWORD *)&v201 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v31 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v31 = v30;
      if (v31)
        v32 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v201 + 8, v31);
      else
        v32 = 0;
      v33 = (const void **)&v32[8 * v29];
      v34 = &v32[8 * v31];
      *v33 = (const void *)v27;
      v22 = v33 + 1;
      v36 = (char *)__p[1];
      v35 = (char *)v201;
      if ((void *)v201 != __p[1])
      {
        do
        {
          v37 = (const void *)*((_QWORD *)v35 - 1);
          v35 -= 8;
          *--v33 = v37;
        }
        while (v35 != v36);
        v35 = (char *)__p[1];
      }
      __p[1] = v33;
      *(_QWORD *)&v201 = v22;
      *((_QWORD *)&v201 + 1) = v34;
      if (v35)
        operator delete(v35);
    }
    else
    {
      *(_QWORD *)v201 = v26;
      v22 = (const void **)(v28 + 8);
    }
    v25 = (_BYTE *)(v27 + 9);
    *(_QWORD *)&v201 = v22;
    v21 = (const void **)__p[1];
  }
  else
  {
    if (!v24)
      __cxa_bad_cast();
    v25 = v24 + 9;
  }
  *v25 = 1;
  while (v21 != v22)
  {
    if (*((_BYTE *)*v21 + 8) == 23)
    {
      if (v21 != v22)
      {
        if (!v38)
          __cxa_bad_cast();
        v39 = v38 + 9;
        goto LABEL_77;
      }
      break;
    }
    ++v21;
  }
  v40 = operator new();
  v41 = v40;
  *(_WORD *)(v40 + 8) = 23;
  *(_QWORD *)v40 = &off_24D5E8B98;
  v42 = v201;
  if ((unint64_t)v201 >= *((_QWORD *)&v201 + 1))
  {
    v44 = (uint64_t)(v201 - (unint64_t)__p[1]) >> 3;
    if ((unint64_t)(v44 + 1) >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v45 = (uint64_t)(*((_QWORD *)&v201 + 1) - (unint64_t)__p[1]) >> 2;
    if (v45 <= v44 + 1)
      v45 = v44 + 1;
    if (*((_QWORD *)&v201 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
      v46 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v46 = v45;
    if (v46)
      v47 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v201 + 8, v46);
    else
      v47 = 0;
    v48 = (uint64_t *)&v47[8 * v44];
    v49 = &v47[8 * v46];
    *v48 = v41;
    v43 = v48 + 1;
    v51 = (char *)__p[1];
    v50 = (char *)v201;
    if ((void *)v201 != __p[1])
    {
      do
      {
        v52 = *((_QWORD *)v50 - 1);
        v50 -= 8;
        *--v48 = v52;
      }
      while (v50 != v51);
      v50 = (char *)__p[1];
    }
    __p[1] = v48;
    *(_QWORD *)&v201 = v43;
    *((_QWORD *)&v201 + 1) = v49;
    if (v50)
      operator delete(v50);
  }
  else
  {
    *(_QWORD *)v201 = v40;
    v43 = (_QWORD *)(v42 + 8);
  }
  v39 = (_BYTE *)(v41 + 9);
  *(_QWORD *)&v201 = v43;
LABEL_77:
  *v39 = 1;
  *(_QWORD *)v202 = 0;
  v203 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
  ctu::shared_ptr_map_impl<ctu::indexed_by_any_map_hashing_key>::get<TimeHandlerInterface>(v202, ServiceMap);
  v54 = *(_QWORD *)v202;
  if (*(_QWORD *)v202)
  {
    v55 = (std::__shared_weak_count *)v203;
    *(_QWORD *)buf = *(_QWORD *)v202;
    v211 = v203;
    if (v203)
    {
      v56 = (unint64_t *)(v203 + 8);
      do
        v57 = __ldxr(v56);
      while (__stxr(v57 + 1, v56));
    }
    v58 = qmi::MutableMessageBase::getTLV<nas::tlv::NetworkTimeCachePeriod>(__p);
    *(_DWORD *)v58 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v54 + 80))(v54);
    if (v55)
    {
      p_shared_owners = (unint64_t *)&v55->__shared_owners_;
      do
        v60 = __ldaxr(p_shared_owners);
      while (__stlxr(v60 - 1, p_shared_owners));
      if (!v60)
      {
        ((void (*)(std::__shared_weak_count *))v55->__on_zero_shared)(v55);
        std::__shared_weak_count::__release_weak(v55);
      }
    }
  }
  else
  {
    v61 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_216897000, v61, OS_LOG_TYPE_DEFAULT, "#N Could not get TimeHandlerInterface to set network time cache period", buf, 2u);
    }
  }
  v62 = (std::__shared_weak_count *)v203;
  if (v203)
  {
    v63 = (unint64_t *)(v203 + 8);
    do
      v64 = __ldaxr(v63);
    while (__stlxr(v64 - 1, v63));
    if (!v64)
    {
      ((void (*)(std::__shared_weak_count *))v62->__on_zero_shared)(v62);
      std::__shared_weak_count::__release_weak(v62);
    }
  }
  v65 = (const void **)__p[1];
  if (__p[1] != (void *)v201)
  {
    while (*((_BYTE *)*v65 + 8) != 37)
    {
      if (++v65 == (const void **)v201)
        goto LABEL_100;
    }
  }
  if (v65 == (const void **)v201)
  {
LABEL_100:
    v66 = (char *)operator new();
    v68 = v66;
    *((_WORD *)v66 + 4) = 37;
    *(_QWORD *)v66 = &off_24D5E8C38;
    v69 = v201;
    if ((unint64_t)v201 >= *((_QWORD *)&v201 + 1))
    {
      v71 = (uint64_t)(v201 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v71 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v72 = (uint64_t)(*((_QWORD *)&v201 + 1) - (unint64_t)__p[1]) >> 2;
      if (v72 <= v71 + 1)
        v72 = v71 + 1;
      if (*((_QWORD *)&v201 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v73 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v73 = v72;
      if (v73)
        v74 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v201 + 8, v73);
      else
        v74 = 0;
      v75 = &v74[8 * v71];
      v76 = &v74[8 * v73];
      *(_QWORD *)v75 = v68;
      v70 = v75 + 8;
      v77 = (char *)__p[1];
      v66 = (char *)v201;
      if ((void *)v201 != __p[1])
      {
        do
        {
          v78 = *((_QWORD *)v66 - 1);
          v66 -= 8;
          *((_QWORD *)v75 - 1) = v78;
          v75 -= 8;
        }
        while (v66 != v77);
        v66 = (char *)__p[1];
      }
      __p[1] = v75;
      *(_QWORD *)&v201 = v70;
      *((_QWORD *)&v201 + 1) = v76;
      if (v66)
        operator delete(v66);
    }
    else
    {
      *(_QWORD *)v201 = v66;
      v70 = (_QWORD *)(v69 + 8);
    }
    v67 = v68 + 9;
    *(_QWORD *)&v201 = v70;
  }
  else
  {
    if (!v66)
      __cxa_bad_cast();
    v67 = v66 + 9;
  }
  *v67 = 1;
  v79 = capabilities::ct::supportsVoLTE((capabilities::ct *)v66);
  if ((v79 & 1) != 0 || (capabilities::ct::supportsSMSIMSStack((capabilities::ct *)v79) & 1) != 0)
  {
    v80 = (const void **)__p[1];
    v81 = (const void **)v201;
    v82 = (const void **)__p[1];
    if (__p[1] != (void *)v201)
    {
      v82 = (const void **)__p[1];
      while (*((_BYTE *)*v82 + 8) != 41)
      {
        if (++v82 == (const void **)v201)
          goto LABEL_127;
      }
    }
    if (v82 == (const void **)v201)
    {
LABEL_127:
      v85 = operator new();
      v86 = v85;
      *(_WORD *)(v85 + 8) = 41;
      *(_QWORD *)v85 = &off_24D5E8C88;
      v87 = v201;
      if ((unint64_t)v201 >= *((_QWORD *)&v201 + 1))
      {
        v88 = (uint64_t)(v201 - (unint64_t)__p[1]) >> 3;
        if ((unint64_t)(v88 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v89 = (uint64_t)(*((_QWORD *)&v201 + 1) - (unint64_t)__p[1]) >> 2;
        if (v89 <= v88 + 1)
          v89 = v88 + 1;
        if (*((_QWORD *)&v201 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v90 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v90 = v89;
        if (v90)
          v91 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v201 + 8, v90);
        else
          v91 = 0;
        v92 = (const void **)&v91[8 * v88];
        v93 = &v91[8 * v90];
        *v92 = (const void *)v86;
        v81 = v92 + 1;
        v95 = (char *)__p[1];
        v94 = (char *)v201;
        if ((void *)v201 != __p[1])
        {
          do
          {
            v96 = (const void *)*((_QWORD *)v94 - 1);
            v94 -= 8;
            *--v92 = v96;
          }
          while (v94 != v95);
          v94 = (char *)__p[1];
        }
        __p[1] = v92;
        *(_QWORD *)&v201 = v81;
        *((_QWORD *)&v201 + 1) = v93;
        if (v94)
          operator delete(v94);
      }
      else
      {
        *(_QWORD *)v201 = v85;
        v81 = (const void **)(v87 + 8);
      }
      v84 = (_BYTE *)(v86 + 9);
      *(_QWORD *)&v201 = v81;
      v80 = (const void **)__p[1];
    }
    else
    {
      if (!v83)
        __cxa_bad_cast();
      v84 = v83 + 9;
    }
    *v84 = 1;
    while (v80 != v81)
    {
      if (*((_BYTE *)*v80 + 8) == 38)
      {
        if (v80 != v81)
        {
          if (!v97)
            __cxa_bad_cast();
          v98 = v97 + 9;
          goto LABEL_169;
        }
        break;
      }
      ++v80;
    }
    v99 = operator new();
    v100 = v99;
    *(_WORD *)(v99 + 8) = 38;
    *(_QWORD *)v99 = &off_24D5E8CD8;
    v101 = v201;
    if ((unint64_t)v201 >= *((_QWORD *)&v201 + 1))
    {
      v102 = (uint64_t)(v201 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v102 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v103 = (uint64_t)(*((_QWORD *)&v201 + 1) - (unint64_t)__p[1]) >> 2;
      if (v103 <= v102 + 1)
        v103 = v102 + 1;
      if (*((_QWORD *)&v201 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v104 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v104 = v103;
      if (v104)
        v105 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v201 + 8, v104);
      else
        v105 = 0;
      v106 = (const void **)&v105[8 * v102];
      v107 = &v105[8 * v104];
      *v106 = (const void *)v100;
      v81 = v106 + 1;
      v109 = (char *)__p[1];
      v108 = (char *)v201;
      if ((void *)v201 != __p[1])
      {
        do
        {
          v110 = (const void *)*((_QWORD *)v108 - 1);
          v108 -= 8;
          *--v106 = v110;
        }
        while (v108 != v109);
        v108 = (char *)__p[1];
      }
      __p[1] = v106;
      *(_QWORD *)&v201 = v81;
      *((_QWORD *)&v201 + 1) = v107;
      if (v108)
        operator delete(v108);
    }
    else
    {
      *(_QWORD *)v201 = v99;
      v81 = (const void **)(v101 + 8);
    }
    v98 = (_BYTE *)(v100 + 9);
    *(_QWORD *)&v201 = v81;
LABEL_169:
    *v98 = 1;
    for (i = (const void **)__p[1]; i != v81; ++i)
    {
      if (*((_BYTE *)*i + 8) == 43)
      {
        if (i != v81)
        {
          if (!v112)
            __cxa_bad_cast();
          v113 = v112 + 9;
          goto LABEL_193;
        }
        break;
      }
    }
    v114 = operator new();
    v115 = v114;
    *(_WORD *)(v114 + 8) = 43;
    *(_QWORD *)v114 = &off_24D5E8D28;
    v116 = v201;
    if ((unint64_t)v201 >= *((_QWORD *)&v201 + 1))
    {
      v117 = (uint64_t)(v201 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v117 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v118 = (uint64_t)(*((_QWORD *)&v201 + 1) - (unint64_t)__p[1]) >> 2;
      if (v118 <= v117 + 1)
        v118 = v117 + 1;
      if (*((_QWORD *)&v201 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v119 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v119 = v118;
      if (v119)
        v120 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v201 + 8, v119);
      else
        v120 = 0;
      v121 = (const void **)&v120[8 * v117];
      v122 = &v120[8 * v119];
      *v121 = (const void *)v115;
      v81 = v121 + 1;
      v124 = (char *)__p[1];
      v123 = (char *)v201;
      if ((void *)v201 != __p[1])
      {
        do
        {
          v125 = (const void *)*((_QWORD *)v123 - 1);
          v123 -= 8;
          *--v121 = v125;
        }
        while (v123 != v124);
        v123 = (char *)__p[1];
      }
      __p[1] = v121;
      *(_QWORD *)&v201 = v81;
      *((_QWORD *)&v201 + 1) = v122;
      if (v123)
        operator delete(v123);
    }
    else
    {
      *(_QWORD *)v201 = v114;
      v81 = (const void **)(v116 + 8);
    }
    v113 = (_BYTE *)(v115 + 9);
    *(_QWORD *)&v201 = v81;
LABEL_193:
    *v113 = 1;
  }
  else
  {
    v81 = (const void **)v201;
  }
  for (j = (const void **)__p[1]; j != v81; ++j)
  {
    if (*((_BYTE *)*j + 8) == 33)
    {
      if (j != v81)
      {
        if (!v127)
          __cxa_bad_cast();
        v128 = v127 + 9;
        goto LABEL_218;
      }
      break;
    }
  }
  v127 = (char *)operator new();
  v129 = v127;
  *((_WORD *)v127 + 4) = 33;
  *(_QWORD *)v127 = &off_24D5E8D78;
  v127[10] = 0;
  v130 = v201;
  if ((unint64_t)v201 >= *((_QWORD *)&v201 + 1))
  {
    v132 = (uint64_t)(v201 - (unint64_t)__p[1]) >> 3;
    if ((unint64_t)(v132 + 1) >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v133 = (uint64_t)(*((_QWORD *)&v201 + 1) - (unint64_t)__p[1]) >> 2;
    if (v133 <= v132 + 1)
      v133 = v132 + 1;
    if (*((_QWORD *)&v201 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
      v134 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v134 = v133;
    if (v134)
      v135 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v201 + 8, v134);
    else
      v135 = 0;
    v136 = &v135[8 * v132];
    v137 = &v135[8 * v134];
    *(_QWORD *)v136 = v129;
    v131 = v136 + 8;
    v138 = (char *)__p[1];
    v127 = (char *)v201;
    if ((void *)v201 != __p[1])
    {
      do
      {
        v139 = *((_QWORD *)v127 - 1);
        v127 -= 8;
        *((_QWORD *)v136 - 1) = v139;
        v136 -= 8;
      }
      while (v127 != v138);
      v127 = (char *)__p[1];
    }
    __p[1] = v136;
    *(_QWORD *)&v201 = v131;
    *((_QWORD *)&v201 + 1) = v137;
    if (v127)
      operator delete(v127);
  }
  else
  {
    *(_QWORD *)v201 = v127;
    v131 = (_QWORD *)(v130 + 8);
  }
  v128 = v129 + 9;
  *(_QWORD *)&v201 = v131;
LABEL_218:
  *v128 = 1;
  v140 = (char *)capabilities::ct::supports5G((capabilities::ct *)v127);
  if ((_DWORD)v140)
  {
    v141 = (const void **)__p[1];
    if (__p[1] != (void *)v201)
    {
      while (*((_BYTE *)*v141 + 8) != 75)
      {
        if (++v141 == (const void **)v201)
          goto LABEL_226;
      }
    }
    if (v141 == (const void **)v201)
    {
LABEL_226:
      v140 = (char *)operator new();
      v143 = v140;
      *((_WORD *)v140 + 4) = 75;
      *(_QWORD *)v140 = &off_24D5E8DC8;
      v144 = v201;
      if ((unint64_t)v201 >= *((_QWORD *)&v201 + 1))
      {
        v146 = (uint64_t)(v201 - (unint64_t)__p[1]) >> 3;
        if ((unint64_t)(v146 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v147 = (uint64_t)(*((_QWORD *)&v201 + 1) - (unint64_t)__p[1]) >> 2;
        if (v147 <= v146 + 1)
          v147 = v146 + 1;
        if (*((_QWORD *)&v201 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v148 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v148 = v147;
        if (v148)
          v149 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v201 + 8, v148);
        else
          v149 = 0;
        v150 = &v149[8 * v146];
        v151 = &v149[8 * v148];
        *(_QWORD *)v150 = v143;
        v145 = v150 + 8;
        v152 = (char *)__p[1];
        v140 = (char *)v201;
        if ((void *)v201 != __p[1])
        {
          do
          {
            v153 = *((_QWORD *)v140 - 1);
            v140 -= 8;
            *((_QWORD *)v150 - 1) = v153;
            v150 -= 8;
          }
          while (v140 != v152);
          v140 = (char *)__p[1];
        }
        __p[1] = v150;
        *(_QWORD *)&v201 = v145;
        *((_QWORD *)&v201 + 1) = v151;
        if (v140)
          operator delete(v140);
      }
      else
      {
        *(_QWORD *)v201 = v140;
        v145 = (_QWORD *)(v144 + 8);
      }
      v142 = v143 + 9;
      *(_QWORD *)&v201 = v145;
    }
    else
    {
      if (!v140)
        __cxa_bad_cast();
      v142 = v140 + 9;
    }
    *v142 = 1;
  }
  v154 = (char *)capabilities::ct::supportsPrivateNetwork((capabilities::ct *)v140);
  if ((_DWORD)v154)
  {
    v155 = (const void **)__p[1];
    if (__p[1] != (void *)v201)
    {
      while (*((unsigned __int8 *)*v155 + 8) != 210)
      {
        if (++v155 == (const void **)v201)
          goto LABEL_252;
      }
    }
    if (v155 == (const void **)v201)
    {
LABEL_252:
      v154 = (char *)operator new();
      v157 = v154;
      *((_WORD *)v154 + 4) = 210;
      *(_QWORD *)v154 = &off_24D5E8E18;
      v158 = v201;
      if ((unint64_t)v201 >= *((_QWORD *)&v201 + 1))
      {
        v160 = (uint64_t)(v201 - (unint64_t)__p[1]) >> 3;
        if ((unint64_t)(v160 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v161 = (uint64_t)(*((_QWORD *)&v201 + 1) - (unint64_t)__p[1]) >> 2;
        if (v161 <= v160 + 1)
          v161 = v160 + 1;
        if (*((_QWORD *)&v201 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v162 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v162 = v161;
        if (v162)
          v163 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v201 + 8, v162);
        else
          v163 = 0;
        v164 = &v163[8 * v160];
        v165 = &v163[8 * v162];
        *(_QWORD *)v164 = v157;
        v159 = v164 + 8;
        v166 = (char *)__p[1];
        v154 = (char *)v201;
        if ((void *)v201 != __p[1])
        {
          do
          {
            v167 = *((_QWORD *)v154 - 1);
            v154 -= 8;
            *((_QWORD *)v164 - 1) = v167;
            v164 -= 8;
          }
          while (v154 != v166);
          v154 = (char *)__p[1];
        }
        __p[1] = v164;
        *(_QWORD *)&v201 = v159;
        *((_QWORD *)&v201 + 1) = v165;
        if (v154)
          operator delete(v154);
      }
      else
      {
        *(_QWORD *)v201 = v154;
        v159 = (_QWORD *)(v158 + 8);
      }
      v156 = v157 + 9;
      *(_QWORD *)&v201 = v159;
    }
    else
    {
      if (!v154)
        __cxa_bad_cast();
      v156 = v154 + 9;
    }
    *v156 = 1;
  }
  if (capabilities::ct::supportsStewie((capabilities::ct *)v154))
  {
    v168 = (const void **)__p[1];
    if (__p[1] != (void *)v201)
    {
      while (*((_BYTE *)*v168 + 8) != 74)
      {
        if (++v168 == (const void **)v201)
          goto LABEL_278;
      }
    }
    if (v168 == (const void **)v201)
    {
LABEL_278:
      v171 = operator new();
      v172 = v171;
      *(_WORD *)(v171 + 8) = 74;
      *(_QWORD *)v171 = &off_24D5E8E68;
      v173 = v201;
      if ((unint64_t)v201 >= *((_QWORD *)&v201 + 1))
      {
        v175 = (uint64_t)(v201 - (unint64_t)__p[1]) >> 3;
        if ((unint64_t)(v175 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v176 = (uint64_t)(*((_QWORD *)&v201 + 1) - (unint64_t)__p[1]) >> 2;
        if (v176 <= v175 + 1)
          v176 = v175 + 1;
        if (*((_QWORD *)&v201 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v177 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v177 = v176;
        if (v177)
          v178 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v201 + 8, v177);
        else
          v178 = 0;
        v179 = (uint64_t *)&v178[8 * v175];
        v180 = &v178[8 * v177];
        *v179 = v172;
        v174 = v179 + 1;
        v182 = (char *)__p[1];
        v181 = (char *)v201;
        if ((void *)v201 != __p[1])
        {
          do
          {
            v183 = *((_QWORD *)v181 - 1);
            v181 -= 8;
            *--v179 = v183;
          }
          while (v181 != v182);
          v181 = (char *)__p[1];
        }
        __p[1] = v179;
        *(_QWORD *)&v201 = v174;
        *((_QWORD *)&v201 + 1) = v180;
        if (v181)
          operator delete(v181);
      }
      else
      {
        *(_QWORD *)v201 = v171;
        v174 = (_QWORD *)(v173 + 8);
      }
      v170 = (_BYTE *)(v172 + 9);
      *(_QWORD *)&v201 = v174;
    }
    else
    {
      if (!v169)
        __cxa_bad_cast();
      v170 = v169 + 9;
    }
    *v170 = 1;
  }
  v184 = *v4;
  if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v202 = 0;
    _os_log_impl(&dword_216897000, v184, OS_LOG_TYPE_DEFAULT, "#I Sending register for NAS indications", v202, 2u);
  }
  v185 = qmi::ClientRouter::get();
  qmi::ClientRouter::SendProxy::SendProxy<nas::IndicationRegister::Request>((uint64_t)&v198, v2, v185);
  v186 = (std::__shared_weak_count *)operator new(0x20uLL);
  v186->__shared_owners_ = 0;
  v187 = (unint64_t *)&v186->__shared_owners_;
  v186->__shared_weak_owners_ = 0;
  v186->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E8ED0;
  v186[1].__vftable = (std::__shared_weak_count_vtbl *)v4;
  v208 = &v186[1].__vftable;
  v209 = v186;
  v188 = v199;
  v189 = MEMORY[0x24BDAC760];
  *(_QWORD *)v202 = MEMORY[0x24BDAC760];
  v203 = 1174405120;
  v204 = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver23sendIndRegisterReq_syncENS_16SubscriptionTypeEE4__15EEOS1_OT__block_invoke;
  v205 = &__block_descriptor_tmp_18_24;
  v206 = &v186[1].__vftable;
  v207 = v186;
  do
    v190 = __ldxr(v187);
  while (__stxr(v190 + 1, v187));
  *(_QWORD *)buf = v189;
  v211 = 0x40000000;
  v212 = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_31;
  v213 = &unk_24D5E8898;
  v214 = v202;
  *(_QWORD *)(v188 + 32) = _Block_copy(buf);
  v191 = v207;
  if (v207)
  {
    v192 = (unint64_t *)&v207->__shared_owners_;
    do
      v193 = __ldaxr(v192);
    while (__stlxr(v193 - 1, v192));
    if (!v193)
    {
      ((void (*)(std::__shared_weak_count *))v191->__on_zero_shared)(v191);
      std::__shared_weak_count::__release_weak(v191);
    }
  }
  v194 = v209;
  if (v209)
  {
    v195 = (unint64_t *)&v209->__shared_owners_;
    do
      v196 = __ldaxr(v195);
    while (__stlxr(v196 - 1, v195));
    if (!v196)
    {
      ((void (*)(std::__shared_weak_count *))v194->__on_zero_shared)(v194);
      std::__shared_weak_count::__release_weak(v194);
    }
  }
  v197 = v199;
  v199 = 0;
  if (v197)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v199, v197);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
}

void sub_216A6D10C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

void QMINetworkRegistrationDriver::getImsPreferenceInfo_sync(uint64_t a1, uint64_t a2)
{
  int v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  unint64_t *v8;
  uint64_t v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _OWORD v19[2];
  _QWORD v20[5];
  std::__shared_weak_count *v21;
  char *v22;
  std::__shared_weak_count *v23;
  _QWORD aBlock[5];

  v2 = a2;
  if ((a2 - 1) >= 3)
    a2 = 0;
  else
    a2 = a2;
  v4 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 88) + 16))(*(_QWORD *)(a1 + 88), a2);
  memset(v19, 0, sizeof(v19));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v19);
  v5 = qmi::ClientRouter::get();
  v6 = operator new();
  *(_QWORD *)v6 = v5;
  *(_QWORD *)(v6 + 8) = QMIServiceMsg::create();
  *(_DWORD *)(v6 + 16) = 25000;
  *(_QWORD *)(v6 + 24) = 0;
  *(_QWORD *)(v6 + 32) = 0;
  v18 = v6;
  v7 = operator new(0x30uLL);
  v7[1] = 0;
  v8 = v7 + 1;
  v7[2] = 0;
  *v7 = &off_24D5EA1A8;
  v7[3] = a1;
  *((_DWORD *)v7 + 8) = v2;
  v7[5] = v4;
  v22 = (char *)(v7 + 3);
  v23 = (std::__shared_weak_count *)v7;
  v9 = MEMORY[0x24BDAC760];
  v20[0] = MEMORY[0x24BDAC760];
  v20[1] = 1174405120;
  v20[2] = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver25getImsPreferenceInfo_syncENS_16SubscriptionTypeEE3__0EEOS1_OT__block_invoke;
  v20[3] = &__block_descriptor_tmp_65_7;
  v20[4] = v7 + 3;
  v21 = (std::__shared_weak_count *)v7;
  do
    v10 = __ldxr(v8);
  while (__stxr(v10 + 1, v8));
  aBlock[0] = v9;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas20GetImsPreferenceInfo8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
  aBlock[3] = &unk_24D5EA1F0;
  aBlock[4] = v20;
  *(_QWORD *)(v6 + 32) = _Block_copy(aBlock);
  v11 = v21;
  if (v21)
  {
    p_shared_owners = (unint64_t *)&v21->__shared_owners_;
    do
      v13 = __ldaxr(p_shared_owners);
    while (__stlxr(v13 - 1, p_shared_owners));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  v14 = v23;
  if (v23)
  {
    v15 = (unint64_t *)&v23->__shared_owners_;
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
  v17 = v18;
  v18 = 0;
  if (v17)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v18, v17);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v19);
}

void sub_216A6D3B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;
  va_list va;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v6 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v4);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  if (a3)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v3, a3);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

void QMINetworkRegistrationDriver::setEmergencyMode(QMINetworkRegistrationDriver *this, char a2)
{
  const void **v4;
  char *v5;
  _BYTE *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  char *v14;
  uint64_t *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  unint64_t *v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  std::__shared_weak_count *v26;
  unint64_t *p_shared_owners;
  unint64_t v28;
  std::__shared_weak_count *v29;
  unint64_t *v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  void *__p[2];
  __int128 v36;
  _QWORD v37[5];
  std::__shared_weak_count *v38;
  char *v39;
  std::__shared_weak_count *v40;
  _QWORD aBlock[5];

  *(_OWORD *)__p = 0u;
  v36 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  v4 = (const void **)__p[1];
  if (__p[1] != (void *)v36)
  {
    while (*((_BYTE *)*v4 + 8) != 16)
    {
      if (++v4 == (const void **)v36)
        goto LABEL_8;
    }
  }
  if (v4 == (const void **)v36)
  {
LABEL_8:
    v7 = operator new();
    v8 = v7;
    *(_WORD *)(v7 + 8) = 16;
    *(_QWORD *)v7 = &off_24D5E8F38;
    v9 = v36;
    if ((unint64_t)v36 >= *((_QWORD *)&v36 + 1))
    {
      v11 = (uint64_t)(v36 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v11 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v12 = (uint64_t)(*((_QWORD *)&v36 + 1) - (unint64_t)__p[1]) >> 2;
      if (v12 <= v11 + 1)
        v12 = v11 + 1;
      if (*((_QWORD *)&v36 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v13 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v13 = v12;
      if (v13)
        v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v36 + 8, v13);
      else
        v14 = 0;
      v15 = (uint64_t *)&v14[8 * v11];
      v16 = &v14[8 * v13];
      *v15 = v8;
      v10 = v15 + 1;
      v18 = (char *)__p[1];
      v17 = (char *)v36;
      if ((void *)v36 != __p[1])
      {
        do
        {
          v19 = *((_QWORD *)v17 - 1);
          v17 -= 8;
          *--v15 = v19;
        }
        while (v17 != v18);
        v17 = (char *)__p[1];
      }
      __p[1] = v15;
      *(_QWORD *)&v36 = v10;
      *((_QWORD *)&v36 + 1) = v16;
      if (v17)
        operator delete(v17);
    }
    else
    {
      *(_QWORD *)v36 = v7;
      v10 = (_QWORD *)(v9 + 8);
    }
    v6 = (_BYTE *)(v8 + 9);
    *(_QWORD *)&v36 = v10;
  }
  else
  {
    if (!v5)
      __cxa_bad_cast();
    v6 = v5 + 9;
  }
  *v6 = a2;
  v20 = qmi::ClientRouter::get();
  qmi::ClientRouter::SendProxy::SendProxy<nas::SetSystemSelectionPreference::Request>((uint64_t)&v33, 1, v20);
  v21 = operator new(0x28uLL);
  v21[1] = 0;
  v22 = v21 + 1;
  v21[2] = 0;
  *v21 = &off_24D5E8FA0;
  v21[3] = this;
  *((_BYTE *)v21 + 32) = a2;
  v39 = (char *)(v21 + 3);
  v40 = (std::__shared_weak_count *)v21;
  v23 = v34;
  v24 = MEMORY[0x24BDAC760];
  v37[0] = MEMORY[0x24BDAC760];
  v37[1] = 1174405120;
  v37[2] = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver16setEmergencyModeEbE3__1EEOS1_OT__block_invoke;
  v37[3] = &__block_descriptor_tmp_19_21;
  v37[4] = v21 + 3;
  v38 = (std::__shared_weak_count *)v21;
  do
    v25 = __ldxr(v22);
  while (__stxr(v25 + 1, v22));
  aBlock[0] = v24;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_31;
  aBlock[3] = &unk_24D5E8898;
  aBlock[4] = v37;
  *(_QWORD *)(v23 + 32) = _Block_copy(aBlock);
  v26 = v38;
  if (v38)
  {
    p_shared_owners = (unint64_t *)&v38->__shared_owners_;
    do
      v28 = __ldaxr(p_shared_owners);
    while (__stlxr(v28 - 1, p_shared_owners));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
      std::__shared_weak_count::__release_weak(v26);
    }
  }
  v29 = v40;
  if (v40)
  {
    v30 = (unint64_t *)&v40->__shared_owners_;
    do
      v31 = __ldaxr(v30);
    while (__stlxr(v31 - 1, v30));
    if (!v31)
    {
      ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
      std::__shared_weak_count::__release_weak(v29);
    }
  }
  v32 = v34;
  v34 = 0;
  if (v32)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v34, v32);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
}

void sub_216A6D72C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  va_list va;
  uint64_t v7;
  va_list va1;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  va_list va2;

  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v5 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v7 = va_arg(va2, _QWORD);
  v9 = va_arg(va2, _QWORD);
  v10 = va_arg(va2, _QWORD);
  v11 = va_arg(va2, _QWORD);
  v12 = va_arg(va2, _QWORD);
  v13 = va_arg(va2, _QWORD);
  v14 = va_arg(va2, _QWORD);
  v15 = va_arg(va2, _QWORD);
  v16 = va_arg(va2, _QWORD);
  v17 = va_arg(va2, _QWORD);
  v18 = va_arg(va2, _QWORD);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v2);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va2);
  v4 = v5;
  v5 = 0;
  if (v4)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)va, v4);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va1);
  _Unwind_Resume(a1);
}

uint64_t QMINetworkRegistrationDriver::enable2G(capabilities::ct *a1, int a2, char a3)
{
  uint64_t v6;
  const void **v7;
  char *v8;
  _BYTE *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  char *v17;
  uint64_t *v18;
  char *v19;
  char *v20;
  char *v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  _QWORD *v25;
  unint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  std::__shared_weak_count *v30;
  unint64_t *p_shared_owners;
  unint64_t v32;
  std::__shared_weak_count *v33;
  unint64_t *v34;
  unint64_t v35;
  uint64_t v36;
  uint64_t v38;
  uint64_t v39;
  void *__p[2];
  __int128 v41;
  _QWORD v42[5];
  std::__shared_weak_count *v43;
  char *v44;
  std::__shared_weak_count *v45;
  _QWORD aBlock[5];

  v6 = capabilities::ct::supportsBB2GMitigation(a1);
  if ((_DWORD)v6)
  {
    *(_OWORD *)__p = 0u;
    v41 = 0u;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
    v7 = (const void **)__p[1];
    if (__p[1] != (void *)v41)
    {
      while (*((unsigned __int8 *)*v7 + 8) != 167)
      {
        if (++v7 == (const void **)v41)
          goto LABEL_9;
      }
    }
    if (v7 == (const void **)v41)
    {
LABEL_9:
      v10 = operator new();
      v11 = v10;
      *(_WORD *)(v10 + 8) = 167;
      *(_QWORD *)v10 = &off_24D5E9008;
      v12 = v41;
      if ((unint64_t)v41 >= *((_QWORD *)&v41 + 1))
      {
        v14 = (uint64_t)(v41 - (unint64_t)__p[1]) >> 3;
        if ((unint64_t)(v14 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v15 = (uint64_t)(*((_QWORD *)&v41 + 1) - (unint64_t)__p[1]) >> 2;
        if (v15 <= v14 + 1)
          v15 = v14 + 1;
        if (*((_QWORD *)&v41 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v16 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v16 = v15;
        if (v16)
          v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v41 + 8, v16);
        else
          v17 = 0;
        v18 = (uint64_t *)&v17[8 * v14];
        v19 = &v17[8 * v16];
        *v18 = v11;
        v13 = v18 + 1;
        v21 = (char *)__p[1];
        v20 = (char *)v41;
        if ((void *)v41 != __p[1])
        {
          do
          {
            v22 = *((_QWORD *)v20 - 1);
            v20 -= 8;
            *--v18 = v22;
          }
          while (v20 != v21);
          v20 = (char *)__p[1];
        }
        __p[1] = v18;
        *(_QWORD *)&v41 = v13;
        *((_QWORD *)&v41 + 1) = v19;
        if (v20)
          operator delete(v20);
      }
      else
      {
        *(_QWORD *)v41 = v10;
        v13 = (_QWORD *)(v12 + 8);
      }
      v9 = (_BYTE *)(v11 + 9);
      *(_QWORD *)&v41 = v13;
    }
    else
    {
      if (!v8)
        __cxa_bad_cast();
      v9 = v8 + 9;
    }
    *v9 = a3;
    if ((a2 - 1) >= 3)
      v23 = 0;
    else
      v23 = a2;
    v24 = qmi::ClientRouter::get();
    qmi::ClientRouter::SendProxy::SendProxy<nas::SetSystemSelectionPreference::Request>((uint64_t)&v38, v23, v24);
    v25 = operator new(0x28uLL);
    v25[1] = 0;
    v26 = v25 + 1;
    v25[2] = 0;
    v25[3] = a1;
    *v25 = &off_24D5E9070;
    *((_DWORD *)v25 + 8) = a2;
    *((_BYTE *)v25 + 36) = a3;
    v44 = (char *)(v25 + 3);
    v45 = (std::__shared_weak_count *)v25;
    v27 = v39;
    v28 = MEMORY[0x24BDAC760];
    v42[0] = MEMORY[0x24BDAC760];
    v42[1] = 1174405120;
    v42[2] = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver8enable2GEN10subscriber7SimSlotEb16SetMaxRateSourceE3__1EEOS1_OT__block_invoke;
    v42[3] = &__block_descriptor_tmp_20_20;
    v42[4] = v25 + 3;
    v43 = (std::__shared_weak_count *)v25;
    do
      v29 = __ldxr(v26);
    while (__stxr(v29 + 1, v26));
    aBlock[0] = v28;
    aBlock[1] = 0x40000000;
    aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_31;
    aBlock[3] = &unk_24D5E8898;
    aBlock[4] = v42;
    *(_QWORD *)(v27 + 32) = _Block_copy(aBlock);
    v30 = v43;
    if (v43)
    {
      p_shared_owners = (unint64_t *)&v43->__shared_owners_;
      do
        v32 = __ldaxr(p_shared_owners);
      while (__stlxr(v32 - 1, p_shared_owners));
      if (!v32)
      {
        ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
        std::__shared_weak_count::__release_weak(v30);
      }
    }
    v33 = v45;
    if (v45)
    {
      v34 = (unint64_t *)&v45->__shared_owners_;
      do
        v35 = __ldaxr(v34);
      while (__stlxr(v35 - 1, v34));
      if (!v35)
      {
        ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
        std::__shared_weak_count::__release_weak(v33);
      }
    }
    v36 = v39;
    v39 = 0;
    if (v36)
      std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v39, v36);
    qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
  }
  return v6;
}

void sub_216A6DAB0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  va_list va;
  uint64_t v7;
  va_list va1;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  va_list va2;

  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v5 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v7 = va_arg(va2, _QWORD);
  v9 = va_arg(va2, _QWORD);
  v10 = va_arg(va2, _QWORD);
  v11 = va_arg(va2, _QWORD);
  v12 = va_arg(va2, _QWORD);
  v13 = va_arg(va2, _QWORD);
  v14 = va_arg(va2, _QWORD);
  v15 = va_arg(va2, _QWORD);
  v16 = va_arg(va2, _QWORD);
  v17 = va_arg(va2, _QWORD);
  v18 = va_arg(va2, _QWORD);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v2);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va2);
  v4 = v5;
  v5 = 0;
  if (v4)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)va, v4);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va1);
  _Unwind_Resume(a1);
}

uint64_t QMINetworkRegistrationDriver::enable3G(uint64_t a1, int a2, char a3, char a4)
{
  const void **v8;
  char *v9;
  _BYTE *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  char *v18;
  uint64_t *v19;
  char *v20;
  char *v21;
  char *v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  _QWORD *v26;
  unint64_t *v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *p_shared_owners;
  unint64_t v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  uint64_t v37;
  uint64_t v39;
  uint64_t v40;
  void *__p[2];
  __int128 v42;
  _QWORD v43[5];
  std::__shared_weak_count *v44;
  char *v45;
  std::__shared_weak_count *v46;
  _QWORD aBlock[5];

  *(_OWORD *)__p = 0u;
  v42 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  v8 = (const void **)__p[1];
  if (__p[1] != (void *)v42)
  {
    while (*((_BYTE *)*v8 + 8) != 50)
    {
      if (++v8 == (const void **)v42)
        goto LABEL_8;
    }
  }
  if (v8 == (const void **)v42)
  {
LABEL_8:
    v11 = operator new();
    v12 = v11;
    *(_WORD *)(v11 + 8) = 50;
    *(_QWORD *)v11 = &off_24D5E90D8;
    v13 = v42;
    if ((unint64_t)v42 >= *((_QWORD *)&v42 + 1))
    {
      v15 = (uint64_t)(v42 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v15 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v16 = (uint64_t)(*((_QWORD *)&v42 + 1) - (unint64_t)__p[1]) >> 2;
      if (v16 <= v15 + 1)
        v16 = v15 + 1;
      if (*((_QWORD *)&v42 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v17 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v17 = v16;
      if (v17)
        v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v42 + 8, v17);
      else
        v18 = 0;
      v19 = (uint64_t *)&v18[8 * v15];
      v20 = &v18[8 * v17];
      *v19 = v12;
      v14 = v19 + 1;
      v22 = (char *)__p[1];
      v21 = (char *)v42;
      if ((void *)v42 != __p[1])
      {
        do
        {
          v23 = *((_QWORD *)v21 - 1);
          v21 -= 8;
          *--v19 = v23;
        }
        while (v21 != v22);
        v21 = (char *)__p[1];
      }
      __p[1] = v19;
      *(_QWORD *)&v42 = v14;
      *((_QWORD *)&v42 + 1) = v20;
      if (v21)
        operator delete(v21);
    }
    else
    {
      *(_QWORD *)v42 = v11;
      v14 = (_QWORD *)(v13 + 8);
    }
    v10 = (_BYTE *)(v12 + 9);
    *(_QWORD *)&v42 = v14;
  }
  else
  {
    if (!v9)
      __cxa_bad_cast();
    v10 = v9 + 9;
  }
  *v10 = a3;
  if ((a2 - 1) >= 3)
    v24 = 0;
  else
    v24 = a2;
  v25 = qmi::ClientRouter::get();
  qmi::ClientRouter::SendProxy::SendProxy<nas::SetSystemSelectionPreference::Request>((uint64_t)&v39, v24, v25);
  v26 = operator new(0x28uLL);
  v26[1] = 0;
  v27 = v26 + 1;
  v26[2] = 0;
  v26[3] = a1;
  *v26 = &off_24D5E9140;
  *((_DWORD *)v26 + 8) = a2;
  *((_BYTE *)v26 + 36) = a4;
  v45 = (char *)(v26 + 3);
  v46 = (std::__shared_weak_count *)v26;
  v28 = v40;
  v29 = MEMORY[0x24BDAC760];
  v43[0] = MEMORY[0x24BDAC760];
  v43[1] = 1174405120;
  v43[2] = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver8enable3GEN10subscriber7SimSlotEb16SetMaxRateSourceE3__1EEOS1_OT__block_invoke;
  v43[3] = &__block_descriptor_tmp_21_13;
  v43[4] = v26 + 3;
  v44 = (std::__shared_weak_count *)v26;
  do
    v30 = __ldxr(v27);
  while (__stxr(v30 + 1, v27));
  aBlock[0] = v29;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_31;
  aBlock[3] = &unk_24D5E8898;
  aBlock[4] = v43;
  *(_QWORD *)(v28 + 32) = _Block_copy(aBlock);
  v31 = v44;
  if (v44)
  {
    p_shared_owners = (unint64_t *)&v44->__shared_owners_;
    do
      v33 = __ldaxr(p_shared_owners);
    while (__stlxr(v33 - 1, p_shared_owners));
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
      std::__shared_weak_count::__release_weak(v31);
    }
  }
  v34 = v46;
  if (v46)
  {
    v35 = (unint64_t *)&v46->__shared_owners_;
    do
      v36 = __ldaxr(v35);
    while (__stlxr(v36 - 1, v35));
    if (!v36)
    {
      ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
      std::__shared_weak_count::__release_weak(v34);
    }
  }
  v37 = v40;
  v40 = 0;
  if (v37)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v40, v37);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
  return 1;
}

void sub_216A6DE2C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  va_list va;
  uint64_t v7;
  va_list va1;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  va_list va2;

  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v5 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v7 = va_arg(va2, _QWORD);
  v9 = va_arg(va2, _QWORD);
  v10 = va_arg(va2, _QWORD);
  v11 = va_arg(va2, _QWORD);
  v12 = va_arg(va2, _QWORD);
  v13 = va_arg(va2, _QWORD);
  v14 = va_arg(va2, _QWORD);
  v15 = va_arg(va2, _QWORD);
  v16 = va_arg(va2, _QWORD);
  v17 = va_arg(va2, _QWORD);
  v18 = va_arg(va2, _QWORD);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v2);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va2);
  v4 = v5;
  v5 = 0;
  if (v4)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)va, v4);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va1);
  _Unwind_Resume(a1);
}

uint64_t QMINetworkRegistrationDriver::enableLTE(uint64_t a1, int a2, char a3, unsigned int a4)
{
  os_log_t *v8;
  const void **v9;
  const void **v10;
  const void **v11;
  char *v12;
  _BYTE *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  char *v20;
  const void **v21;
  char *v22;
  char *v23;
  char *v24;
  const void *v25;
  char *v26;
  _DWORD *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  uint64_t v32;
  unint64_t v33;
  unint64_t v34;
  char *v35;
  uint64_t *v36;
  char *v37;
  char *v38;
  char *v39;
  uint64_t v40;
  NSObject *v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  uint64_t v45;
  _QWORD *v46;
  unint64_t *v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  std::__shared_weak_count *v51;
  unint64_t *p_shared_owners;
  unint64_t v53;
  std::__shared_weak_count *v54;
  unint64_t *v55;
  unint64_t v56;
  uint64_t v57;
  uint64_t v59;
  uint64_t v60;
  void *__p[2];
  __int128 v62;
  char *v63;
  std::__shared_weak_count *v64;
  _QWORD aBlock[5];
  _BYTE buf[24];
  void *v67;
  char *v68;
  std::__shared_weak_count *v69;
  uint64_t v70;

  v70 = *MEMORY[0x24BDAC8D0];
  v8 = (os_log_t *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 88) + 16))(*(_QWORD *)(a1 + 88));
  *(_OWORD *)__p = 0u;
  v62 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  v9 = (const void **)__p[1];
  v10 = (const void **)v62;
  v11 = (const void **)__p[1];
  if (__p[1] != (void *)v62)
  {
    v11 = (const void **)__p[1];
    while (*((_BYTE *)*v11 + 8) != 49)
    {
      if (++v11 == (const void **)v62)
        goto LABEL_9;
    }
  }
  if (v11 == (const void **)v62)
  {
LABEL_9:
    v14 = operator new();
    v15 = v14;
    *(_WORD *)(v14 + 8) = 49;
    *(_QWORD *)v14 = &off_24D5E91A8;
    v16 = v62;
    if ((unint64_t)v62 >= *((_QWORD *)&v62 + 1))
    {
      v17 = (uint64_t)(v62 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v17 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v18 = (uint64_t)(*((_QWORD *)&v62 + 1) - (unint64_t)__p[1]) >> 2;
      if (v18 <= v17 + 1)
        v18 = v17 + 1;
      if (*((_QWORD *)&v62 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v19 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v19 = v18;
      if (v19)
        v20 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v62 + 8, v19);
      else
        v20 = 0;
      v21 = (const void **)&v20[8 * v17];
      v22 = &v20[8 * v19];
      *v21 = (const void *)v15;
      v10 = v21 + 1;
      v24 = (char *)__p[1];
      v23 = (char *)v62;
      if ((void *)v62 != __p[1])
      {
        do
        {
          v25 = (const void *)*((_QWORD *)v23 - 1);
          v23 -= 8;
          *--v21 = v25;
        }
        while (v23 != v24);
        v23 = (char *)__p[1];
      }
      __p[1] = v21;
      *(_QWORD *)&v62 = v10;
      *((_QWORD *)&v62 + 1) = v22;
      if (v23)
        operator delete(v23);
    }
    else
    {
      *(_QWORD *)v62 = v14;
      v10 = (const void **)(v16 + 8);
    }
    v13 = (_BYTE *)(v15 + 9);
    *(_QWORD *)&v62 = v10;
    v9 = (const void **)__p[1];
  }
  else
  {
    if (!v12)
      __cxa_bad_cast();
    v13 = v12 + 9;
  }
  *v13 = a3;
  while (v9 != v10)
  {
    if (*((unsigned __int8 *)*v9 + 8) == 160)
    {
      if (v9 != v10)
      {
        if (!v26)
          __cxa_bad_cast();
        v27 = v26 + 12;
        goto LABEL_50;
      }
      break;
    }
    ++v9;
  }
  v28 = operator new();
  v29 = v28;
  *(_BYTE *)(v28 + 8) = -96;
  *(_QWORD *)v28 = &off_24D5E91F8;
  *(_DWORD *)(v28 + 12) = 0;
  v27 = (_DWORD *)(v28 + 12);
  v30 = v62;
  if ((unint64_t)v62 >= *((_QWORD *)&v62 + 1))
  {
    v32 = (uint64_t)(v62 - (unint64_t)__p[1]) >> 3;
    if ((unint64_t)(v32 + 1) >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v33 = (uint64_t)(*((_QWORD *)&v62 + 1) - (unint64_t)__p[1]) >> 2;
    if (v33 <= v32 + 1)
      v33 = v32 + 1;
    if (*((_QWORD *)&v62 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
      v34 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v34 = v33;
    if (v34)
      v35 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v62 + 8, v34);
    else
      v35 = 0;
    v36 = (uint64_t *)&v35[8 * v32];
    v37 = &v35[8 * v34];
    *v36 = v29;
    v31 = v36 + 1;
    v39 = (char *)__p[1];
    v38 = (char *)v62;
    if ((void *)v62 != __p[1])
    {
      do
      {
        v40 = *((_QWORD *)v38 - 1);
        v38 -= 8;
        *--v36 = v40;
      }
      while (v38 != v39);
      v38 = (char *)__p[1];
    }
    __p[1] = v36;
    *(_QWORD *)&v62 = v31;
    *((_QWORD *)&v62 + 1) = v37;
    if (v38)
      operator delete(v38);
  }
  else
  {
    *(_QWORD *)v62 = v28;
    v31 = (_QWORD *)(v30 + 8);
  }
  *(_QWORD *)&v62 = v31;
LABEL_50:
  v41 = *v8;
  if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
  {
    v42 = CSIBOOLAsString();
    v43 = asString();
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = v42;
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = v43;
    _os_log_impl(&dword_216897000, v41, OS_LOG_TYPE_DEFAULT, "#I Informing baseband the Enable LTE [%s] update reason: %s", buf, 0x16u);
  }
  if (a4 <= 3)
    *v27 = dword_216AC1034[(char)a4];
  if ((a2 - 1) >= 3)
    v44 = 0;
  else
    v44 = a2;
  v45 = qmi::ClientRouter::get();
  qmi::ClientRouter::SendProxy::SendProxy<nas::SetSystemSelectionPreference::Request>((uint64_t)&v59, v44, v45);
  v46 = operator new(0x30uLL);
  v46[1] = 0;
  v47 = v46 + 1;
  v46[2] = 0;
  *v46 = &off_24D5E9260;
  v46[3] = a1;
  *((_DWORD *)v46 + 8) = a2;
  *((_BYTE *)v46 + 36) = a4;
  v46[5] = v8;
  v63 = (char *)(v46 + 3);
  v64 = (std::__shared_weak_count *)v46;
  v48 = v60;
  v49 = MEMORY[0x24BDAC760];
  *(_QWORD *)buf = MEMORY[0x24BDAC760];
  *(_QWORD *)&buf[8] = 1174405120;
  *(_QWORD *)&buf[16] = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver9enableLTEEN10subscriber7SimSlotEb16SetMaxRateSourceE3__2EEOS1_OT__block_invoke;
  v67 = &__block_descriptor_tmp_22_19;
  v68 = (char *)(v46 + 3);
  v69 = (std::__shared_weak_count *)v46;
  do
    v50 = __ldxr(v47);
  while (__stxr(v50 + 1, v47));
  aBlock[0] = v49;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_31;
  aBlock[3] = &unk_24D5E8898;
  aBlock[4] = buf;
  *(_QWORD *)(v48 + 32) = _Block_copy(aBlock);
  v51 = v69;
  if (v69)
  {
    p_shared_owners = (unint64_t *)&v69->__shared_owners_;
    do
      v53 = __ldaxr(p_shared_owners);
    while (__stlxr(v53 - 1, p_shared_owners));
    if (!v53)
    {
      ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
      std::__shared_weak_count::__release_weak(v51);
    }
  }
  v54 = v64;
  if (v64)
  {
    v55 = (unint64_t *)&v64->__shared_owners_;
    do
      v56 = __ldaxr(v55);
    while (__stlxr(v56 - 1, v55));
    if (!v56)
    {
      ((void (*)(std::__shared_weak_count *))v54->__on_zero_shared)(v54);
      std::__shared_weak_count::__release_weak(v54);
    }
  }
  v57 = v60;
  v60 = 0;
  if (v57)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v60, v57);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
  return 1;
}

void sub_216A6E3C8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  va_list va;
  uint64_t v7;
  va_list va1;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  va_list va2;

  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v5 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v7 = va_arg(va2, _QWORD);
  v9 = va_arg(va2, _QWORD);
  v10 = va_arg(va2, _QWORD);
  v11 = va_arg(va2, _QWORD);
  v12 = va_arg(va2, _QWORD);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v2);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va2);
  v4 = v5;
  v5 = 0;
  if (v4)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)va, v4);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va1);
  _Unwind_Resume(a1);
}

uint64_t QMINetworkRegistrationDriver::enable5G(uint64_t a1, int a2, int a3, unsigned int a4, char a5)
{
  uint64_t v9;
  const void **v10;
  char *v11;
  BOOL *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  char *v20;
  uint64_t *v21;
  char *v22;
  char *v23;
  char *v24;
  uint64_t v25;
  char *updated;
  const void **v27;
  char *v28;
  _BYTE *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  _QWORD *v33;
  uint64_t v34;
  unint64_t v35;
  unint64_t v36;
  char *v37;
  uint64_t *v38;
  char *v39;
  char *v40;
  char *v41;
  uint64_t v42;
  uint64_t v43;
  _QWORD *v44;
  unint64_t *v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t v48;
  std::__shared_weak_count *v49;
  unint64_t *p_shared_owners;
  unint64_t v51;
  std::__shared_weak_count *v52;
  unint64_t *v53;
  unint64_t v54;
  uint64_t v55;
  uint64_t v57;
  uint64_t v58;
  void *__p[2];
  __int128 v60;
  _QWORD v61[5];
  std::__shared_weak_count *v62;
  char *v63;
  std::__shared_weak_count *v64;
  _QWORD aBlock[5];

  v9 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 88) + 16))(*(_QWORD *)(a1 + 88));
  *(_OWORD *)__p = 0u;
  v60 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  v10 = (const void **)__p[1];
  if (__p[1] != (void *)v60)
  {
    while (*((unsigned __int8 *)*v10 + 8) != 165)
    {
      if (++v10 == (const void **)v60)
        goto LABEL_8;
    }
  }
  if (v10 == (const void **)v60)
  {
LABEL_8:
    v13 = operator new();
    v14 = v13;
    *(_WORD *)(v13 + 8) = 165;
    *(_QWORD *)v13 = &off_24D5E92C8;
    v15 = v60;
    if ((unint64_t)v60 >= *((_QWORD *)&v60 + 1))
    {
      v17 = (uint64_t)(v60 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v17 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v18 = (uint64_t)(*((_QWORD *)&v60 + 1) - (unint64_t)__p[1]) >> 2;
      if (v18 <= v17 + 1)
        v18 = v17 + 1;
      if (*((_QWORD *)&v60 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v19 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v19 = v18;
      if (v19)
        v20 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v60 + 8, v19);
      else
        v20 = 0;
      v21 = (uint64_t *)&v20[8 * v17];
      v22 = &v20[8 * v19];
      *v21 = v14;
      v16 = v21 + 1;
      v24 = (char *)__p[1];
      v23 = (char *)v60;
      if ((void *)v60 != __p[1])
      {
        do
        {
          v25 = *((_QWORD *)v23 - 1);
          v23 -= 8;
          *--v21 = v25;
        }
        while (v23 != v24);
        v23 = (char *)__p[1];
      }
      __p[1] = v21;
      *(_QWORD *)&v60 = v16;
      *((_QWORD *)&v60 + 1) = v22;
      if (v23)
        operator delete(v23);
    }
    else
    {
      *(_QWORD *)v60 = v13;
      v16 = (_QWORD *)(v15 + 8);
    }
    v12 = (BOOL *)(v14 + 9);
    *(_QWORD *)&v60 = v16;
  }
  else
  {
    if (!v11)
      __cxa_bad_cast();
    v12 = (BOOL *)(v11 + 9);
  }
  *v12 = a3 != 0;
  updated = qmi::MutableMessageBase::getTLV<nas::tlv::EnableNrUpdateReason>(__p);
  if (a4 <= 3)
    *(_DWORD *)updated = dword_216AC1034[(char)a4];
  v27 = (const void **)__p[1];
  if (__p[1] != (void *)v60)
  {
    while (*((unsigned __int8 *)*v27 + 8) != 166)
    {
      if (++v27 == (const void **)v60)
        goto LABEL_34;
    }
  }
  if (v27 == (const void **)v60)
  {
LABEL_34:
    v30 = operator new();
    v31 = v30;
    *(_BYTE *)(v30 + 8) = -90;
    *(_QWORD *)v30 = &off_24D5E9368;
    *(_BYTE *)(v30 + 10) = 0;
    v29 = (_BYTE *)(v30 + 10);
    *(_DWORD *)(v30 + 12) = 0;
    v32 = v60;
    if ((unint64_t)v60 >= *((_QWORD *)&v60 + 1))
    {
      v34 = (uint64_t)(v60 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v34 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v35 = (uint64_t)(*((_QWORD *)&v60 + 1) - (unint64_t)__p[1]) >> 2;
      if (v35 <= v34 + 1)
        v35 = v34 + 1;
      if (*((_QWORD *)&v60 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v36 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v36 = v35;
      if (v36)
        v37 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v60 + 8, v36);
      else
        v37 = 0;
      v38 = (uint64_t *)&v37[8 * v34];
      v39 = &v37[8 * v36];
      *v38 = v31;
      v33 = v38 + 1;
      v41 = (char *)__p[1];
      v40 = (char *)v60;
      if ((void *)v60 != __p[1])
      {
        do
        {
          v42 = *((_QWORD *)v40 - 1);
          v40 -= 8;
          *--v38 = v42;
        }
        while (v40 != v41);
        v40 = (char *)__p[1];
      }
      __p[1] = v38;
      *(_QWORD *)&v60 = v33;
      *((_QWORD *)&v60 + 1) = v39;
      if (v40)
        operator delete(v40);
    }
    else
    {
      *(_QWORD *)v60 = v30;
      v33 = (_QWORD *)(v32 + 8);
    }
    *(_QWORD *)&v60 = v33;
  }
  else
  {
    if (!v28)
      __cxa_bad_cast();
    v29 = v28 + 10;
  }
  *v29 = a5;
  if ((a2 - 1) >= 3)
    a2 = 0;
  v43 = qmi::ClientRouter::get();
  qmi::ClientRouter::SendProxy::SendProxy<nas::SetSystemSelectionPreference::Request>((uint64_t)&v57, a2, v43);
  v44 = operator new(0x28uLL);
  v44[1] = 0;
  v45 = v44 + 1;
  v44[2] = 0;
  *v44 = &off_24D5E93D0;
  v44[3] = v9;
  *((_DWORD *)v44 + 8) = a3;
  v63 = (char *)(v44 + 3);
  v64 = (std::__shared_weak_count *)v44;
  v46 = v58;
  v47 = MEMORY[0x24BDAC760];
  v61[0] = MEMORY[0x24BDAC760];
  v61[1] = 1174405120;
  v61[2] = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver8enable5GEN10subscriber7SimSlotEj16SetMaxRateSourcebE3__3EEOS1_OT__block_invoke;
  v61[3] = &__block_descriptor_tmp_23_13;
  v61[4] = v44 + 3;
  v62 = (std::__shared_weak_count *)v44;
  do
    v48 = __ldxr(v45);
  while (__stxr(v48 + 1, v45));
  aBlock[0] = v47;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_31;
  aBlock[3] = &unk_24D5E8898;
  aBlock[4] = v61;
  *(_QWORD *)(v46 + 32) = _Block_copy(aBlock);
  v49 = v62;
  if (v62)
  {
    p_shared_owners = (unint64_t *)&v62->__shared_owners_;
    do
      v51 = __ldaxr(p_shared_owners);
    while (__stlxr(v51 - 1, p_shared_owners));
    if (!v51)
    {
      ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
      std::__shared_weak_count::__release_weak(v49);
    }
  }
  v52 = v64;
  if (v64)
  {
    v53 = (unint64_t *)&v64->__shared_owners_;
    do
      v54 = __ldaxr(v53);
    while (__stlxr(v54 - 1, v53));
    if (!v54)
    {
      ((void (*)(std::__shared_weak_count *))v52->__on_zero_shared)(v52);
      std::__shared_weak_count::__release_weak(v52);
    }
  }
  v55 = v58;
  v58 = 0;
  if (v55)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v58, v55);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
  return 1;
}

void sub_216A6E8F4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  va_list va;
  uint64_t v7;
  va_list va1;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  va_list va2;

  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v5 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v7 = va_arg(va2, _QWORD);
  v9 = va_arg(va2, _QWORD);
  v10 = va_arg(va2, _QWORD);
  v11 = va_arg(va2, _QWORD);
  v12 = va_arg(va2, _QWORD);
  v13 = va_arg(va2, _QWORD);
  v14 = va_arg(va2, _QWORD);
  v15 = va_arg(va2, _QWORD);
  v16 = va_arg(va2, _QWORD);
  v17 = va_arg(va2, _QWORD);
  v18 = va_arg(va2, _QWORD);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v2);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va2);
  v4 = v5;
  v5 = 0;
  if (v4)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)va, v4);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va1);
  _Unwind_Resume(a1);
}

uint64_t QMINetworkRegistrationDriver::enable5GStandalone(uint64_t a1, int a2, int a3, unsigned int a4)
{
  uint64_t v7;
  char *updated;
  uint64_t v9;
  _QWORD *v10;
  unint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v23;
  uint64_t v24;
  _OWORD v25[2];
  _QWORD v26[5];
  std::__shared_weak_count *v27;
  char *v28;
  std::__shared_weak_count *v29;
  _QWORD aBlock[5];

  v7 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 88) + 16))(*(_QWORD *)(a1 + 88));
  memset(v25, 0, sizeof(v25));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v25);
  *(_DWORD *)qmi::MutableMessageBase::getTLV<nas::tlv::NRDisableMode>(v25) = a3 ^ 1;
  updated = qmi::MutableMessageBase::getTLV<nas::tlv::EnableNrUpdateReason>(v25);
  if (a4 <= 3)
    *(_DWORD *)updated = dword_216AC1034[(char)a4];
  if ((a2 - 1) >= 3)
    a2 = 0;
  v9 = qmi::ClientRouter::get();
  qmi::ClientRouter::SendProxy::SendProxy<nas::SetSystemSelectionPreference::Request>((uint64_t)&v23, a2, v9);
  v10 = operator new(0x28uLL);
  v10[1] = 0;
  v11 = v10 + 1;
  v10[2] = 0;
  *v10 = &off_24D5E94A0;
  v10[3] = v7;
  *((_BYTE *)v10 + 32) = a3;
  v28 = (char *)(v10 + 3);
  v29 = (std::__shared_weak_count *)v10;
  v12 = v24;
  v13 = MEMORY[0x24BDAC760];
  v26[0] = MEMORY[0x24BDAC760];
  v26[1] = 1174405120;
  v26[2] = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver18enable5GStandaloneEN10subscriber7SimSlotEb16SetMaxRateSourceE3__2EEOS1_OT__block_invoke;
  v26[3] = &__block_descriptor_tmp_26_12;
  v26[4] = v10 + 3;
  v27 = (std::__shared_weak_count *)v10;
  do
    v14 = __ldxr(v11);
  while (__stxr(v14 + 1, v11));
  aBlock[0] = v13;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_31;
  aBlock[3] = &unk_24D5E8898;
  aBlock[4] = v26;
  *(_QWORD *)(v12 + 32) = _Block_copy(aBlock);
  v15 = v27;
  if (v27)
  {
    p_shared_owners = (unint64_t *)&v27->__shared_owners_;
    do
      v17 = __ldaxr(p_shared_owners);
    while (__stlxr(v17 - 1, p_shared_owners));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  v18 = v29;
  if (v29)
  {
    v19 = (unint64_t *)&v29->__shared_owners_;
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
  v21 = v24;
  v24 = 0;
  if (v21)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v24, v21);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v25);
  return 1;
}

void sub_216A6EB60(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  va_list va;
  uint64_t v7;
  va_list va1;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  va_list va2;

  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v5 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v7 = va_arg(va2, _QWORD);
  v9 = va_arg(va2, _QWORD);
  v10 = va_arg(va2, _QWORD);
  v11 = va_arg(va2, _QWORD);
  v12 = va_arg(va2, _QWORD);
  v13 = va_arg(va2, _QWORD);
  v14 = va_arg(va2, _QWORD);
  v15 = va_arg(va2, _QWORD);
  v16 = va_arg(va2, _QWORD);
  v17 = va_arg(va2, _QWORD);
  v18 = va_arg(va2, _QWORD);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v2);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va2);
  v4 = v5;
  v5 = 0;
  if (v4)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)va, v4);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va1);
  _Unwind_Resume(a1);
}

uint64_t QMINetworkRegistrationDriver::setCdmaRoamingSwitchSetting(uint64_t a1, int a2, char a3, uint64_t a4)
{
  os_log_t *v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  const void **v11;
  char *v12;
  _BYTE *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  char *v21;
  uint64_t *v22;
  char *v23;
  char *v24;
  char *v25;
  uint64_t v26;
  const void **v27;
  char *v28;
  void **v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  _QWORD *v33;
  uint64_t v34;
  unint64_t v35;
  unint64_t v36;
  char *v37;
  uint64_t *v38;
  char *v39;
  char *v40;
  char *v41;
  uint64_t v42;
  void *v43;
  uint64_t v44;
  NSObject *v45;
  _BOOL4 v46;
  uint64_t v47;
  std::__shared_weak_count *v48;
  unint64_t *p_shared_owners;
  uint64_t v50;
  uint64_t v51;
  unint64_t v52;
  std::__shared_weak_count *v53;
  unint64_t *v54;
  unint64_t v55;
  std::__shared_weak_count *v56;
  unint64_t *v57;
  unint64_t v58;
  uint64_t v59;
  uint64_t v61;
  uint64_t v62;
  void *__p[2];
  __int128 v64;
  _QWORD *v65;
  std::__shared_weak_count *v66;
  uint8_t buf[24];
  os_log_t *v68;
  _QWORD *v69;
  std::__shared_weak_count *v70;
  _BYTE aBlock[24];
  void *v72;
  uint8_t *v73;
  uint64_t v74;

  v74 = *MEMORY[0x24BDAC8D0];
  v7 = (os_log_t *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 88) + 16))(*(_QWORD *)(a1 + 88));
  v8 = *v7;
  if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
  {
    v9 = CSIBOOLAsString();
    v10 = (uint64_t)(*(_QWORD *)(a4 + 8) - *(_QWORD *)a4) >> 1;
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = v9;
    *(_WORD *)&buf[12] = 2048;
    *(_QWORD *)&buf[14] = v10;
    _os_log_impl(&dword_216897000, v8, OS_LOG_TYPE_DEFAULT, "#I Setting System Selection Preference CDMA roaming switch (%s) with %zu equivalent countries", buf, 0x16u);
  }
  *(_OWORD *)__p = 0u;
  v64 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  v11 = (const void **)__p[1];
  if (__p[1] != (void *)v64)
  {
    while (*((unsigned __int8 *)*v11 + 8) != 161)
    {
      if (++v11 == (const void **)v64)
        goto LABEL_10;
    }
  }
  if (v11 == (const void **)v64)
  {
LABEL_10:
    v14 = operator new();
    v15 = v14;
    *(_WORD *)(v14 + 8) = 161;
    *(_QWORD *)v14 = &off_24D5E95B0;
    v16 = v64;
    if ((unint64_t)v64 >= *((_QWORD *)&v64 + 1))
    {
      v18 = (uint64_t)(v64 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v18 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v19 = (uint64_t)(*((_QWORD *)&v64 + 1) - (unint64_t)__p[1]) >> 2;
      if (v19 <= v18 + 1)
        v19 = v18 + 1;
      if (*((_QWORD *)&v64 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v20 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v20 = v19;
      if (v20)
        v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v64 + 8, v20);
      else
        v21 = 0;
      v22 = (uint64_t *)&v21[8 * v18];
      v23 = &v21[8 * v20];
      *v22 = v15;
      v17 = v22 + 1;
      v25 = (char *)__p[1];
      v24 = (char *)v64;
      if ((void *)v64 != __p[1])
      {
        do
        {
          v26 = *((_QWORD *)v24 - 1);
          v24 -= 8;
          *--v22 = v26;
        }
        while (v24 != v25);
        v24 = (char *)__p[1];
      }
      __p[1] = v22;
      *(_QWORD *)&v64 = v17;
      *((_QWORD *)&v64 + 1) = v23;
      if (v24)
        operator delete(v24);
    }
    else
    {
      *(_QWORD *)v64 = v14;
      v17 = (_QWORD *)(v16 + 8);
    }
    v13 = (_BYTE *)(v15 + 9);
    *(_QWORD *)&v64 = v17;
  }
  else
  {
    if (!v12)
      __cxa_bad_cast();
    v13 = v12 + 9;
  }
  *v13 = a3;
  memset(buf, 0, sizeof(buf));
  std::vector<unsigned short>::__init_with_size[abi:ne180100]<unsigned short *,unsigned short *>(buf, *(const void **)a4, *(_QWORD *)(a4 + 8), (uint64_t)(*(_QWORD *)(a4 + 8) - *(_QWORD *)a4) >> 1);
  v68 = v7;
  v27 = (const void **)__p[1];
  if (__p[1] != (void *)v64)
  {
    while (*((unsigned __int8 *)*v27 + 8) != 162)
    {
      if (++v27 == (const void **)v64)
        goto LABEL_34;
    }
  }
  if (v27 == (const void **)v64)
  {
LABEL_34:
    v30 = operator new();
    v31 = v30;
    *(_BYTE *)(v30 + 8) = -94;
    *(_QWORD *)(v30 + 16) = 0;
    v29 = (void **)(v30 + 16);
    *(_QWORD *)v30 = &off_24D5E9600;
    *(_QWORD *)(v30 + 24) = 0;
    *(_QWORD *)(v30 + 32) = 0;
    v32 = v64;
    if ((unint64_t)v64 >= *((_QWORD *)&v64 + 1))
    {
      v34 = (uint64_t)(v64 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v34 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v35 = (uint64_t)(*((_QWORD *)&v64 + 1) - (unint64_t)__p[1]) >> 2;
      if (v35 <= v34 + 1)
        v35 = v34 + 1;
      if (*((_QWORD *)&v64 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v36 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v36 = v35;
      if (v36)
        v37 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v64 + 8, v36);
      else
        v37 = 0;
      v38 = (uint64_t *)&v37[8 * v34];
      v39 = &v37[8 * v36];
      *v38 = v31;
      v33 = v38 + 1;
      v41 = (char *)__p[1];
      v40 = (char *)v64;
      if ((void *)v64 != __p[1])
      {
        do
        {
          v42 = *((_QWORD *)v40 - 1);
          v40 -= 8;
          *--v38 = v42;
        }
        while (v40 != v41);
        v40 = (char *)__p[1];
      }
      __p[1] = v38;
      *(_QWORD *)&v64 = v33;
      *((_QWORD *)&v64 + 1) = v39;
      if (v40)
        operator delete(v40);
    }
    else
    {
      *(_QWORD *)v64 = v30;
      v33 = (_QWORD *)(v32 + 8);
    }
    *(_QWORD *)&v64 = v33;
  }
  else
  {
    if (!v28)
      __cxa_bad_cast();
    v29 = (void **)(v28 + 16);
  }
  std::vector<unsigned short>::resize((uint64_t)v29, (uint64_t)(*(_QWORD *)&buf[8] - *(_QWORD *)buf) >> 1);
  v43 = *(void **)buf;
  if (*(_QWORD *)&buf[8] == *(_QWORD *)buf)
  {
    v44 = *(_QWORD *)buf;
  }
  else
  {
    memmove(*v29, *(const void **)buf, *(_QWORD *)&buf[8] - *(_QWORD *)buf);
    v43 = *(void **)buf;
    v44 = *(_QWORD *)&buf[8];
  }
  if ((unint64_t)(v44 - (_QWORD)v43) >= 0x15)
  {
    std::vector<unsigned short>::resize((uint64_t)v29, 0xAuLL);
    v45 = *v68;
    v46 = os_log_type_enabled(*v68, OS_LOG_TYPE_DEFAULT);
    v43 = *(void **)buf;
    if (v46)
    {
      *(_DWORD *)aBlock = 134218240;
      *(_QWORD *)&aBlock[4] = (uint64_t)(*(_QWORD *)&buf[8] - *(_QWORD *)buf) >> 1;
      *(_WORD *)&aBlock[12] = 2048;
      *(_QWORD *)&aBlock[14] = 10;
      _os_log_impl(&dword_216897000, v45, OS_LOG_TYPE_DEFAULT, "#I Truncated equivalent country MCC list from %zu entries to %zu", aBlock, 0x16u);
      v43 = *(void **)buf;
    }
  }
  if (v43)
  {
    *(_QWORD *)&buf[8] = v43;
    operator delete(v43);
  }
  if ((a2 - 1) >= 3)
    a2 = 0;
  v47 = qmi::ClientRouter::get();
  qmi::ClientRouter::SendProxy::SendProxy<nas::SetSystemSelectionPreference::Request>((uint64_t)&v61, a2, v47);
  v48 = (std::__shared_weak_count *)operator new(0x20uLL);
  v48->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v48->__shared_owners_;
  v48->__shared_weak_owners_ = 0;
  v48->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E9668;
  v48[1].__vftable = (std::__shared_weak_count_vtbl *)v7;
  v65 = &v48[1].__vftable;
  v66 = v48;
  v50 = v62;
  v51 = MEMORY[0x24BDAC760];
  *(_QWORD *)buf = MEMORY[0x24BDAC760];
  *(_QWORD *)&buf[8] = 1174405120;
  *(_QWORD *)&buf[16] = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver27setCdmaRoamingSwitchSettingEN10subscriber7SimSlotEbRKNSt3__16vectorItNS6_9allocatorItEEEEE3__2EEOS1_OT__block_invoke;
  v68 = (os_log_t *)&__block_descriptor_tmp_29_7;
  v69 = &v48[1].__vftable;
  v70 = v48;
  do
    v52 = __ldxr(p_shared_owners);
  while (__stxr(v52 + 1, p_shared_owners));
  *(_QWORD *)aBlock = v51;
  *(_QWORD *)&aBlock[8] = 0x40000000;
  *(_QWORD *)&aBlock[16] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_31;
  v72 = &unk_24D5E8898;
  v73 = buf;
  *(_QWORD *)(v50 + 32) = _Block_copy(aBlock);
  v53 = v70;
  if (v70)
  {
    v54 = (unint64_t *)&v70->__shared_owners_;
    do
      v55 = __ldaxr(v54);
    while (__stlxr(v55 - 1, v54));
    if (!v55)
    {
      ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
      std::__shared_weak_count::__release_weak(v53);
    }
  }
  v56 = v66;
  if (v66)
  {
    v57 = (unint64_t *)&v66->__shared_owners_;
    do
      v58 = __ldaxr(v57);
    while (__stlxr(v58 - 1, v57));
    if (!v58)
    {
      ((void (*)(std::__shared_weak_count *))v56->__on_zero_shared)(v56);
      std::__shared_weak_count::__release_weak(v56);
    }
  }
  v59 = v62;
  v62 = 0;
  if (v59)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v62, v59);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
  return 1;
}

void sub_216A6F1C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, void *__p, uint64_t a18)
{
  uint64_t v18;
  uint64_t v20;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v18);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a15);
  v20 = a10;
  a10 = 0;
  if (v20)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&a10, v20);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a11);
  _Unwind_Resume(a1);
}

uint64_t QMINetworkRegistrationDriver::setSystemSelectionAndRoamingPreference(QMINetworkRegistrationDriver *this, unsigned int a2, __int16 a3)
{
  QMINetworkRegistrationDriver::setSystemSelectionPreference((uint64_t)this, 1, a2, 0, a3 | 0x100);
  return 1;
}

void QMINetworkRegistrationDriver::setSystemSelectionPreference(uint64_t a1, int a2, unsigned int a3, uint64_t a4, __int16 a5)
{
  os_log_t *v10;
  uint64_t v11;
  __int16 *v12;
  __int16 v13;
  NSObject *v14;
  __int16 v15;
  NSObject *v16;
  NSObject *v17;
  NSObject *v18;
  NSObject *v19;
  NSObject *v20;
  uint64_t v21;
  NSObject *v22;
  NSObject *v23;
  _BOOL8 v24;
  __int16 v25;
  int v26;
  NSObject *v27;
  _BOOL8 v28;
  uint64_t v29;
  NSObject *v30;
  NSObject *v31;
  const void **v32;
  char *v33;
  int *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  _QWORD *v38;
  uint64_t v39;
  unint64_t v40;
  unint64_t v41;
  char *v42;
  uint64_t *v43;
  char *v44;
  char *v45;
  char *v46;
  uint64_t v47;
  NSObject *v48;
  int v49;
  NSObject *v50;
  NSObject *v51;
  const void **v52;
  char *v53;
  __int16 *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  _QWORD *v58;
  uint64_t v59;
  unint64_t v60;
  unint64_t v61;
  char *v62;
  uint64_t *v63;
  char *v64;
  char *v65;
  char *v66;
  uint64_t v67;
  NSObject *v68;
  uint64_t v69;
  __int16 v70;
  NSObject *v71;
  const char *v72;
  int v73;
  uint64_t v74;
  _QWORD *v75;
  unint64_t *v76;
  uint64_t v77;
  uint64_t v78;
  unint64_t v79;
  std::__shared_weak_count *v80;
  unint64_t *p_shared_owners;
  unint64_t v82;
  std::__shared_weak_count *v83;
  unint64_t *v84;
  unint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  void *__p[2];
  __int128 v90;
  char *v91;
  std::__shared_weak_count *v92;
  _QWORD aBlock[5];
  __int128 buf;
  uint64_t (*v95)(uint64_t, uint64_t);
  void *v96;
  char *v97;
  std::__shared_weak_count *v98;
  uint64_t v99;

  v99 = *MEMORY[0x24BDAC8D0];
  v10 = (os_log_t *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 88) + 16))(*(_QWORD *)(a1 + 88));
  *(_OWORD *)__p = 0u;
  v90 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  v11 = qmi::MutableMessageBase::getTLV<nas::tlv::ModePreference>(__p, 17);
  v12 = (__int16 *)v11;
  v13 = 0;
  *(_WORD *)v11 = 0;
  if ((a3 & 1) != 0)
  {
    v14 = *v10;
    v11 = os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT);
    v15 = 0;
    if ((_DWORD)v11)
    {
      LOWORD(buf) = 0;
      _os_log_impl(&dword_216897000, v14, OS_LOG_TYPE_DEFAULT, "#I GSM has been enabled in RAT selection", (uint8_t *)&buf, 2u);
      v15 = *v12;
    }
    v13 = v15 | 4;
    *v12 = v15 | 4;
    if ((a3 & 2) == 0)
    {
LABEL_3:
      if ((a3 & 0x10) == 0)
        goto LABEL_4;
      goto LABEL_14;
    }
  }
  else if ((a3 & 2) == 0)
  {
    goto LABEL_3;
  }
  v16 = *v10;
  v11 = os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT);
  if ((_DWORD)v11)
  {
    LOWORD(buf) = 0;
    _os_log_impl(&dword_216897000, v16, OS_LOG_TYPE_DEFAULT, "#I UMTS has been enabled in RAT selection", (uint8_t *)&buf, 2u);
    v13 = *v12;
  }
  v13 |= 8u;
  *v12 = v13;
  if ((a3 & 0x10) == 0)
  {
LABEL_4:
    if ((a3 & 4) == 0)
      goto LABEL_5;
    goto LABEL_17;
  }
LABEL_14:
  v17 = *v10;
  v11 = os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT);
  if ((_DWORD)v11)
  {
    LOWORD(buf) = 0;
    _os_log_impl(&dword_216897000, v17, OS_LOG_TYPE_DEFAULT, "#I LTE has been enabled in RAT selection", (uint8_t *)&buf, 2u);
    v13 = *v12;
  }
  v13 |= 0x10u;
  *v12 = v13;
  if ((a3 & 4) == 0)
  {
LABEL_5:
    if ((a3 & 8) == 0)
      goto LABEL_6;
    goto LABEL_20;
  }
LABEL_17:
  v18 = *v10;
  v11 = os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT);
  if ((_DWORD)v11)
  {
    LOWORD(buf) = 0;
    _os_log_impl(&dword_216897000, v18, OS_LOG_TYPE_DEFAULT, "#I CDMA 1x has been enabled in RAT selection", (uint8_t *)&buf, 2u);
    v13 = *v12;
  }
  v13 |= 1u;
  *v12 = v13;
  if ((a3 & 8) == 0)
  {
LABEL_6:
    if ((a3 & 0x20) == 0)
      goto LABEL_26;
    goto LABEL_23;
  }
LABEL_20:
  v19 = *v10;
  v11 = os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT);
  if ((_DWORD)v11)
  {
    LOWORD(buf) = 0;
    _os_log_impl(&dword_216897000, v19, OS_LOG_TYPE_DEFAULT, "#I EVDO has been enabled in RAT selection", (uint8_t *)&buf, 2u);
    v13 = *v12;
  }
  v13 |= 2u;
  *v12 = v13;
  if ((a3 & 0x20) != 0)
  {
LABEL_23:
    v20 = *v10;
    v11 = os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT);
    if ((_DWORD)v11)
    {
      LOWORD(buf) = 0;
      _os_log_impl(&dword_216897000, v20, OS_LOG_TYPE_DEFAULT, "#I TDSCDMA has been enabled in RAT selection", (uint8_t *)&buf, 2u);
      v13 = *v12;
    }
    *v12 = v13 | 0x20;
  }
LABEL_26:
  v21 = capabilities::ct::supports5G((capabilities::ct *)v11);
  if ((_DWORD)v21)
  {
    if (a3 < 0x40)
      goto LABEL_51;
    v22 = *v10;
    v21 = os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT);
    if ((_DWORD)v21)
    {
      LOWORD(buf) = 0;
      _os_log_impl(&dword_216897000, v22, OS_LOG_TYPE_DEFAULT, "#I NR has been enabled in RAT selection", (uint8_t *)&buf, 2u);
    }
    *v12 |= 0x40u;
  }
  if (a3 == 255)
  {
    v23 = *v10;
    if (os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl(&dword_216897000, v23, OS_LOG_TYPE_DEFAULT, "#I Automatic has been enabled in RAT selection", (uint8_t *)&buf, 2u);
      v23 = *v10;
    }
    *v12 = 0;
    v24 = os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT);
    if (v24)
    {
      LOWORD(buf) = 0;
      _os_log_impl(&dword_216897000, v23, OS_LOG_TYPE_DEFAULT, "#I UMTS capable device, adding GSM and UMTS to RAT selection", (uint8_t *)&buf, 2u);
      v25 = *v12 | 0xC;
    }
    else
    {
      v25 = 12;
    }
    *v12 = v25;
    v26 = capabilities::ct::supportsCapabilityC2KDevice((capabilities::ct *)v24);
    v27 = *v10;
    if (v26)
    {
      if (os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf) = 0;
        _os_log_impl(&dword_216897000, v27, OS_LOG_TYPE_DEFAULT, "#I CDMA capable device, adding 1x and EVDO to RAT selection", (uint8_t *)&buf, 2u);
        v27 = *v10;
      }
      *v12 |= 3u;
    }
    v28 = os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT);
    if (v28)
    {
      LOWORD(buf) = 0;
      _os_log_impl(&dword_216897000, v27, OS_LOG_TYPE_DEFAULT, "#I LTE capable device, adding LTE to RAT selection", (uint8_t *)&buf, 2u);
    }
    *v12 |= 0x10u;
    v29 = capabilities::ct::supportsCapabilityTDSCDMADevice((capabilities::ct *)v28);
    if ((_DWORD)v29)
    {
      v30 = *v10;
      v29 = os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT);
      if ((_DWORD)v29)
      {
        LOWORD(buf) = 0;
        _os_log_impl(&dword_216897000, v30, OS_LOG_TYPE_DEFAULT, "#I TDSCDMA capable device, adding TDSCDMA to RAT selection", (uint8_t *)&buf, 2u);
      }
      *v12 |= 0x20u;
    }
    v21 = capabilities::ct::supports5G((capabilities::ct *)v29);
    if ((_DWORD)v21)
    {
      v31 = *v10;
      v21 = os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT);
      if ((_DWORD)v21)
      {
        LOWORD(buf) = 0;
        _os_log_impl(&dword_216897000, v31, OS_LOG_TYPE_DEFAULT, "#I NR capable device, adding NR to RAT selection", (uint8_t *)&buf, 2u);
      }
      *v12 |= 0x40u;
    }
  }
LABEL_51:
  if ((a4 & 0xFF00000000) != 0)
  {
    v32 = (const void **)__p[1];
    if (__p[1] != (void *)v90)
    {
      while (*((_BYTE *)*v32 + 8) != 28)
      {
        if (++v32 == (const void **)v90)
          goto LABEL_59;
      }
    }
    if (v32 == (const void **)v90)
    {
LABEL_59:
      v35 = operator new();
      v36 = v35;
      *(_BYTE *)(v35 + 8) = 28;
      *(_QWORD *)v35 = &off_24D5E96D0;
      *(_DWORD *)(v35 + 12) = 0;
      v34 = (int *)(v35 + 12);
      v37 = v90;
      if ((unint64_t)v90 >= *((_QWORD *)&v90 + 1))
      {
        v39 = (uint64_t)(v90 - (unint64_t)__p[1]) >> 3;
        if ((unint64_t)(v39 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v40 = (uint64_t)(*((_QWORD *)&v90 + 1) - (unint64_t)__p[1]) >> 2;
        if (v40 <= v39 + 1)
          v40 = v39 + 1;
        if (*((_QWORD *)&v90 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v41 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v41 = v40;
        if (v41)
          v42 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v90 + 8, v41);
        else
          v42 = 0;
        v43 = (uint64_t *)&v42[8 * v39];
        v44 = &v42[8 * v41];
        *v43 = v36;
        v38 = v43 + 1;
        v46 = (char *)__p[1];
        v45 = (char *)v90;
        if ((void *)v90 != __p[1])
        {
          do
          {
            v47 = *((_QWORD *)v45 - 1);
            v45 -= 8;
            *--v43 = v47;
          }
          while (v45 != v46);
          v45 = (char *)__p[1];
        }
        __p[1] = v43;
        *(_QWORD *)&v90 = v38;
        *((_QWORD *)&v90 + 1) = v44;
        if (v45)
          operator delete(v45);
      }
      else
      {
        *(_QWORD *)v90 = v35;
        v38 = (_QWORD *)(v37 + 8);
      }
      *(_QWORD *)&v90 = v38;
    }
    else
    {
      if (!v33)
        __cxa_bad_cast();
      v34 = (int *)(v33 + 12);
    }
    if ((_DWORD)a4 == 2)
    {
      v50 = *v10;
      v21 = os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT);
      if ((_DWORD)v21)
      {
        LOWORD(buf) = 0;
        v49 = 2;
        _os_log_impl(&dword_216897000, v50, OS_LOG_TYPE_DEFAULT, "#I Setting acquisition order to UMTS", (uint8_t *)&buf, 2u);
      }
      else
      {
        v49 = 2;
      }
    }
    else if ((_DWORD)a4 == 1)
    {
      v48 = *v10;
      v21 = os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT);
      if ((_DWORD)v21)
      {
        LOWORD(buf) = 0;
        _os_log_impl(&dword_216897000, v48, OS_LOG_TYPE_DEFAULT, "#I Setting acquisition order to GSM", (uint8_t *)&buf, 2u);
      }
      v49 = 1;
    }
    else
    {
      v51 = *v10;
      v21 = os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT);
      v49 = 0;
      if ((_DWORD)v21)
      {
        LOWORD(buf) = 0;
        _os_log_impl(&dword_216897000, v51, OS_LOG_TYPE_DEFAULT, "#I Setting acquisition order to Default", (uint8_t *)&buf, 2u);
        v49 = 0;
      }
    }
    *v34 = v49;
  }
  if ((a5 & 0xFF00) != 0)
  {
    v52 = (const void **)__p[1];
    if (__p[1] != (void *)v90)
    {
      while (*((_BYTE *)*v52 + 8) != 20)
      {
        if (++v52 == (const void **)v90)
          goto LABEL_95;
      }
    }
    if (v52 == (const void **)v90)
    {
LABEL_95:
      v55 = operator new();
      v56 = v55;
      *(_BYTE *)(v55 + 8) = 20;
      *(_QWORD *)v55 = &off_24D5E9720;
      *(_WORD *)(v55 + 10) = 0;
      v54 = (__int16 *)(v55 + 10);
      v57 = v90;
      if ((unint64_t)v90 >= *((_QWORD *)&v90 + 1))
      {
        v59 = (uint64_t)(v90 - (unint64_t)__p[1]) >> 3;
        if ((unint64_t)(v59 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v60 = (uint64_t)(*((_QWORD *)&v90 + 1) - (unint64_t)__p[1]) >> 2;
        if (v60 <= v59 + 1)
          v60 = v59 + 1;
        if (*((_QWORD *)&v90 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v61 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v61 = v60;
        if (v61)
          v62 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v90 + 8, v61);
        else
          v62 = 0;
        v63 = (uint64_t *)&v62[8 * v59];
        v64 = &v62[8 * v61];
        *v63 = v56;
        v58 = v63 + 1;
        v66 = (char *)__p[1];
        v65 = (char *)v90;
        if ((void *)v90 != __p[1])
        {
          do
          {
            v67 = *((_QWORD *)v65 - 1);
            v65 -= 8;
            *--v63 = v67;
          }
          while (v65 != v66);
          v65 = (char *)__p[1];
        }
        __p[1] = v63;
        *(_QWORD *)&v90 = v58;
        *((_QWORD *)&v90 + 1) = v64;
        if (v65)
          operator delete(v65);
      }
      else
      {
        *(_QWORD *)v90 = v55;
        v58 = (_QWORD *)(v57 + 8);
      }
      *(_QWORD *)&v90 = v58;
    }
    else
    {
      if (!v53)
        __cxa_bad_cast();
      v54 = (__int16 *)(v53 + 10);
    }
    v68 = *v10;
    v21 = os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT);
    if ((v21 & 1) != 0)
    {
      v69 = CSIBOOLAsString();
      LODWORD(buf) = 136315138;
      *(_QWORD *)((char *)&buf + 4) = v69;
      _os_log_impl(&dword_216897000, v68, OS_LOG_TYPE_DEFAULT, "#I Setting roaming preference to %s", (uint8_t *)&buf, 0xCu);
    }
    if ((_BYTE)a5)
      v70 = 255;
    else
      v70 = 1;
    *v54 = v70;
  }
  if (capabilities::ct::supports5G((capabilities::ct *)v21))
  {
    if ((~a3 & 0xC0) != 0)
    {
      if ((a3 & 0x80) != 0)
      {
        *(_DWORD *)qmi::MutableMessageBase::getTLV<nas::tlv::NRDisableMode>(__p) = 1;
        v71 = *v10;
        if (!os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
          goto LABEL_129;
        LOWORD(buf) = 0;
        v72 = "#I Disabling StandAlone mode";
      }
      else
      {
        if ((a3 & 0x40) == 0)
          goto LABEL_129;
        *(_DWORD *)qmi::MutableMessageBase::getTLV<nas::tlv::NRDisableMode>(__p) = 2;
        v71 = *v10;
        if (!os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
          goto LABEL_129;
        LOWORD(buf) = 0;
        v72 = "#I Disabling Non-StandAlone mode";
      }
    }
    else
    {
      *(_DWORD *)qmi::MutableMessageBase::getTLV<nas::tlv::NRDisableMode>(__p) = 0;
      v71 = *v10;
      if (!os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
        goto LABEL_129;
      LOWORD(buf) = 0;
      v72 = "#I Enabling both Non-StandAlone and StandAlone mode";
    }
    _os_log_impl(&dword_216897000, v71, OS_LOG_TYPE_DEFAULT, v72, (uint8_t *)&buf, 2u);
  }
LABEL_129:
  if ((a2 - 1) >= 3)
    v73 = 0;
  else
    v73 = a2;
  v74 = qmi::ClientRouter::get();
  qmi::ClientRouter::SendProxy::SendProxy<nas::SetSystemSelectionPreference::Request>((uint64_t)&v87, v73, v74);
  v75 = operator new(0x30uLL);
  v75[1] = 0;
  v76 = v75 + 1;
  v75[2] = 0;
  *v75 = &off_24D5E9788;
  v75[3] = a1;
  *((_DWORD *)v75 + 8) = a2;
  *((_BYTE *)v75 + 36) = a3;
  v75[5] = v10;
  v91 = (char *)(v75 + 3);
  v92 = (std::__shared_weak_count *)v75;
  v77 = v88;
  v78 = MEMORY[0x24BDAC760];
  *(_QWORD *)&buf = MEMORY[0x24BDAC760];
  *((_QWORD *)&buf + 1) = 1174405120;
  v95 = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver28setSystemSelectionPreferenceEN10subscriber7SimSlotEhNSt3__18optionalIjEENS7_IbEEE3__6EEOS1_OT__block_invoke;
  v96 = &__block_descriptor_tmp_30_11;
  v97 = (char *)(v75 + 3);
  v98 = (std::__shared_weak_count *)v75;
  do
    v79 = __ldxr(v76);
  while (__stxr(v79 + 1, v76));
  aBlock[0] = v78;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_31;
  aBlock[3] = &unk_24D5E8898;
  aBlock[4] = &buf;
  *(_QWORD *)(v77 + 32) = _Block_copy(aBlock);
  v80 = v98;
  if (v98)
  {
    p_shared_owners = (unint64_t *)&v98->__shared_owners_;
    do
      v82 = __ldaxr(p_shared_owners);
    while (__stlxr(v82 - 1, p_shared_owners));
    if (!v82)
    {
      ((void (*)(std::__shared_weak_count *))v80->__on_zero_shared)(v80);
      std::__shared_weak_count::__release_weak(v80);
    }
  }
  v83 = v92;
  if (v92)
  {
    v84 = (unint64_t *)&v92->__shared_owners_;
    do
      v85 = __ldaxr(v84);
    while (__stlxr(v85 - 1, v84));
    if (!v85)
    {
      ((void (*)(std::__shared_weak_count *))v83->__on_zero_shared)(v83);
      std::__shared_weak_count::__release_weak(v83);
    }
  }
  v86 = v88;
  v88 = 0;
  if (v86)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v88, v86);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
}

void sub_216A6FD98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

uint64_t QMINetworkRegistrationDriver::setSystemSelectionAndOrderPreference(uint64_t a1, int a2, unsigned int a3, unsigned int a4)
{
  QMINetworkRegistrationDriver::setSystemSelectionPreference(a1, a2, a3, a4 | 0x100000000, 0);
  return 1;
}

void QMINetworkRegistrationDriver::getSystemSelectionPreference(_QWORD **a1, int a2)
{
  unsigned int *v3;
  unsigned int *v4;
  os_log_t *v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  unint64_t *v11;
  uint64_t v12;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _OWORD v22[2];
  uint8_t buf[8];
  uint64_t v24;
  void (*v25)(uint64_t, qmi::MessageBase *);
  void *v26;
  char *v27;
  std::__shared_weak_count *v28;
  char *v29;
  std::__shared_weak_count *v30;
  _QWORD aBlock[5];

  if (a2 == 3)
  {
    subscriber::makeSimSlotRange();
    v3 = *(unsigned int **)buf;
    if (*(_QWORD *)buf != v24)
    {
      while ((((uint64_t (*)(_QWORD))v25)(*v3) & 1) == 0)
      {
        if (++v3 == (unsigned int *)v24)
        {
          v3 = (unsigned int *)v24;
          break;
        }
      }
LABEL_6:
      while (v3 != (unsigned int *)v24)
      {
        v4 = v3 + 1;
        ((void (*)(_QWORD **, _QWORD))(*a1)[14])(a1, *v3);
        v3 = (unsigned int *)v24;
        if (v4 != (unsigned int *)v24)
        {
          v3 = v4;
          while ((((uint64_t (*)(_QWORD))v25)(*v3) & 1) == 0)
          {
            if (++v3 == (unsigned int *)v24)
            {
              v3 = (unsigned int *)v24;
              goto LABEL_6;
            }
          }
        }
      }
    }
  }
  else
  {
    v6 = (os_log_t *)(*(uint64_t (**)(_QWORD *))(*a1[11] + 16))(a1[11]);
    v7 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_216897000, v7, OS_LOG_TYPE_DEFAULT, "#I Getting system selection preference from baseband", buf, 2u);
    }
    memset(v22, 0, sizeof(v22));
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v22);
    v8 = qmi::ClientRouter::get();
    v9 = operator new();
    *(_QWORD *)v9 = v8;
    *(_QWORD *)(v9 + 8) = QMIServiceMsg::create();
    *(_DWORD *)(v9 + 16) = 25000;
    *(_QWORD *)(v9 + 24) = 0;
    *(_QWORD *)(v9 + 32) = 0;
    v21 = v9;
    v10 = operator new(0x30uLL);
    v10[1] = 0;
    v11 = v10 + 1;
    v10[2] = 0;
    *v10 = &off_24D5E9808;
    v10[3] = a1;
    *((_DWORD *)v10 + 8) = a2;
    v10[5] = v6;
    v29 = (char *)(v10 + 3);
    v30 = (std::__shared_weak_count *)v10;
    v12 = MEMORY[0x24BDAC760];
    *(_QWORD *)buf = MEMORY[0x24BDAC760];
    v24 = 1174405120;
    v25 = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver28getSystemSelectionPreferenceEN10subscriber7SimSlotEE3__0EEOS1_OT__block_invoke;
    v26 = &__block_descriptor_tmp_31_7;
    v27 = (char *)(v10 + 3);
    v28 = (std::__shared_weak_count *)v10;
    do
      v13 = __ldxr(v11);
    while (__stxr(v13 + 1, v11));
    aBlock[0] = v12;
    aBlock[1] = 0x40000000;
    aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas28GetSystemSelectionPreference8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
    aBlock[3] = &unk_24D5E9850;
    aBlock[4] = buf;
    *(_QWORD *)(v9 + 32) = _Block_copy(aBlock);
    v14 = v28;
    if (v28)
    {
      p_shared_owners = (unint64_t *)&v28->__shared_owners_;
      do
        v16 = __ldaxr(p_shared_owners);
      while (__stlxr(v16 - 1, p_shared_owners));
      if (!v16)
      {
        ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
        std::__shared_weak_count::__release_weak(v14);
      }
    }
    v17 = v30;
    if (v30)
    {
      v18 = (unint64_t *)&v30->__shared_owners_;
      do
        v19 = __ldaxr(v18);
      while (__stlxr(v19 - 1, v18));
      if (!v19)
      {
        ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
        std::__shared_weak_count::__release_weak(v17);
      }
    }
    v20 = v21;
    v21 = 0;
    if (v20)
      std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v21, v20);
    qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v22);
  }
}

void sub_216A70108(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;
  va_list va;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v6 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v4);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  if (a3)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v3, a3);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

uint64_t QMINetworkRegistrationDriver::handleModePreference_sync(capabilities::ct *a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5)
{
  char v7;
  int v10;
  int v11;
  unsigned __int8 v12;
  unsigned int v13;
  char v14;
  unsigned __int8 v15;

  if ((*(_QWORD *)&a3 & 0xFF0000) == 0)
    std::__throw_bad_optional_access[abi:ne180100]();
  v7 = a3;
  v10 = a3 & 0x30 | (4 * (a3 & 3)) | (a3 >> 2) & 3;
  v11 = capabilities::ct::supports5G(a1);
  if ((v7 & 0x40) != 0 && v11)
  {
    if ((a5 & 0xFF00000000) == 0)
      goto LABEL_8;
    switch((_DWORD)a5)
    {
      case 2:
        v12 = v10 | 0x40;
        goto LABEL_22;
      case 1:
        v12 = v10 | 0x80;
        goto LABEL_22;
      case 0:
LABEL_8:
        v12 = v10 | 0xC0;
LABEL_22:
        v15 = v12;
        return (*(uint64_t (**)(_QWORD *, uint64_t, _QWORD, _QWORD))(**((_QWORD **)a1 + 8) + 40))(*((_QWORD **)a1 + 8), a2, v12, v15);
    }
  }
  v13 = 0x20102u >> (8 * a4);
  if (a4 > 2u)
    LOBYTE(v13) = 0;
  if ((a4 & 0xFF00000000) != 0)
    v14 = v13;
  else
    v14 = 3;
  if (v10 == 3)
    v12 = 3;
  else
    v12 = v10;
  if (v10 == 3)
    v15 = v14;
  else
    v15 = v10;
  return (*(uint64_t (**)(_QWORD *, uint64_t, _QWORD, _QWORD))(**((_QWORD **)a1 + 8) + 40))(*((_QWORD **)a1 + 8), a2, v12, v15);
}

void QMINetworkRegistrationDriver::getServingSystem(_QWORD **a1, int a2)
{
  unsigned int *v3;
  unsigned int *v4;
  os_log_t *v6;
  NSObject *v7;
  int v8;
  uint64_t v9;
  _QWORD *v10;
  unint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _OWORD v24[2];
  uint8_t buf[8];
  uint64_t v26;
  void (*v27)(uint64_t, uint64_t);
  void *v28;
  char *v29;
  std::__shared_weak_count *v30;
  char *v31;
  std::__shared_weak_count *v32;
  _QWORD aBlock[5];

  if (a2 == 3)
  {
    subscriber::makeSimSlotRange();
    v3 = *(unsigned int **)buf;
    if (*(_QWORD *)buf != v26)
    {
      while ((((uint64_t (*)(_QWORD))v27)(*v3) & 1) == 0)
      {
        if (++v3 == (unsigned int *)v26)
        {
          v3 = (unsigned int *)v26;
          break;
        }
      }
LABEL_6:
      while (v3 != (unsigned int *)v26)
      {
        v4 = v3 + 1;
        ((void (*)(_QWORD **, _QWORD))(*a1)[16])(a1, *v3);
        v3 = (unsigned int *)v26;
        if (v4 != (unsigned int *)v26)
        {
          v3 = v4;
          while ((((uint64_t (*)(_QWORD))v27)(*v3) & 1) == 0)
          {
            if (++v3 == (unsigned int *)v26)
            {
              v3 = (unsigned int *)v26;
              goto LABEL_6;
            }
          }
        }
      }
    }
  }
  else
  {
    v6 = (os_log_t *)(*(uint64_t (**)(_QWORD *))(*a1[11] + 16))(a1[11]);
    v7 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_216897000, v7, OS_LOG_TYPE_DEFAULT, "#I Getting current serving system from baseband", buf, 2u);
    }
    memset(v24, 0, sizeof(v24));
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v24);
    if (a2 == 1)
      v8 = 1;
    else
      v8 = 2 * (a2 == 2);
    v9 = qmi::ClientRouter::get();
    qmi::ClientRouter::SendProxy::SendProxy<nas::GetSysInfo::Request>((uint64_t)&v22, v8, v9);
    v10 = operator new(0x30uLL);
    v10[1] = 0;
    v11 = v10 + 1;
    v10[2] = 0;
    v10[3] = a1;
    *v10 = &off_24D5E98B0;
    *((_DWORD *)v10 + 8) = a2;
    v10[5] = v6;
    v31 = (char *)(v10 + 3);
    v32 = (std::__shared_weak_count *)v10;
    v12 = v23;
    v13 = MEMORY[0x24BDAC760];
    *(_QWORD *)buf = MEMORY[0x24BDAC760];
    v26 = 1174405120;
    v27 = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver16getServingSystemEN10subscriber7SimSlotEE3__0EEOS1_OT__block_invoke;
    v28 = &__block_descriptor_tmp_35_11;
    v29 = (char *)(v10 + 3);
    v30 = (std::__shared_weak_count *)v10;
    do
      v14 = __ldxr(v11);
    while (__stxr(v14 + 1, v11));
    aBlock[0] = v13;
    aBlock[1] = 0x40000000;
    aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_31;
    aBlock[3] = &unk_24D5E8898;
    aBlock[4] = buf;
    *(_QWORD *)(v12 + 32) = _Block_copy(aBlock);
    v15 = v30;
    if (v30)
    {
      p_shared_owners = (unint64_t *)&v30->__shared_owners_;
      do
        v17 = __ldaxr(p_shared_owners);
      while (__stlxr(v17 - 1, p_shared_owners));
      if (!v17)
      {
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v15);
      }
    }
    v18 = v32;
    if (v32)
    {
      v19 = (unint64_t *)&v32->__shared_owners_;
      do
        v20 = __ldaxr(v19);
      while (__stlxr(v20 - 1, v19));
      if (!v20)
      {
        ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
        std::__shared_weak_count::__release_weak(v18);
      }
    }
    v21 = v23;
    v23 = 0;
    if (v21)
      std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v23, v21);
    qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v24);
  }
}

void sub_216A70518(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  va_list va;
  uint64_t v7;
  va_list va1;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  va_list va2;

  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v5 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v7 = va_arg(va2, _QWORD);
  v9 = va_arg(va2, _QWORD);
  v10 = va_arg(va2, _QWORD);
  v11 = va_arg(va2, _QWORD);
  v12 = va_arg(va2, _QWORD);
  v13 = va_arg(va2, _QWORD);
  v14 = va_arg(va2, _QWORD);
  v15 = va_arg(va2, _QWORD);
  v16 = va_arg(va2, _QWORD);
  v17 = va_arg(va2, _QWORD);
  v18 = va_arg(va2, _QWORD);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v2);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va2);
  v4 = v5;
  v5 = 0;
  if (v4)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)va, v4);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va1);
  _Unwind_Resume(a1);
}

void ServingSystem::~ServingSystem(ServingSystem *this)
{
  void *v2;

  if (*((_BYTE *)this + 152))
  {
    v2 = (void *)*((_QWORD *)this + 16);
    if (v2)
    {
      *((_QWORD *)this + 17) = v2;
      operator delete(v2);
    }
  }
  if (*((_BYTE *)this + 120))
    std::__tree<std::__value_type<RadioAccessTechnology,ServingSystem::GSMSystem>,std::__map_value_compare<RadioAccessTechnology,std::__value_type<RadioAccessTechnology,ServingSystem::GSMSystem>,std::less<RadioAccessTechnology>,true>,std::allocator<std::__value_type<RadioAccessTechnology,ServingSystem::GSMSystem>>>::destroy(*((_QWORD **)this + 13));
  if (*((_BYTE *)this + 32))
    std::__tree<std::__value_type<RadioAccessTechnology,ServingSystem::System>,std::__map_value_compare<RadioAccessTechnology,std::__value_type<RadioAccessTechnology,ServingSystem::System>,std::less<RadioAccessTechnology>,true>,std::allocator<std::__value_type<RadioAccessTechnology,ServingSystem::System>>>::destroy(*((_QWORD **)this + 2));
}

uint64_t std::optional<MCC>::operator=[abi:ne180100]<MCC&,void>(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 32))
  {
    MCC::operator=();
  }
  else
  {
    MCC::MCC();
    *(_BYTE *)(a1 + 32) = 1;
  }
  return a1;
}

MCC *std::optional<MNC>::operator=[abi:ne180100]<MNC&,void>(MCC *this, const MCC *a2)
{
  if (*((_BYTE *)this + 32))
  {
    MCC::operator=();
  }
  else
  {
    MCC::MCC(this, a2);
    *((_BYTE *)this + 32) = 1;
  }
  return this;
}

uint64_t QMINetworkRegistrationDriver::getPlmnName(uint64_t a1, uint64_t a2, uint64_t a3, const MCC *a4, int a5)
{
  const void **v9;
  char *v10;
  _WORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  char *v19;
  uint64_t *v20;
  char *v21;
  char *v22;
  char *v23;
  uint64_t v24;
  char v25;
  char v26;
  NSObject *v27;
  uint64_t v28;
  const void **v29;
  const void **v30;
  char *v31;
  _BYTE *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  unint64_t v38;
  char *v39;
  const void **v40;
  char *v41;
  char *v42;
  char *v43;
  const void *v44;
  const void **i;
  char *v46;
  char *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  _QWORD *v51;
  uint64_t v52;
  unint64_t v53;
  unint64_t v54;
  char *v55;
  uint64_t *v56;
  char *v57;
  char *v58;
  char *v59;
  uint64_t v60;
  const void **v61;
  char *v62;
  BOOL *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  _QWORD *v67;
  uint64_t v68;
  unint64_t v69;
  unint64_t v70;
  char *v71;
  uint64_t *v72;
  char *v73;
  char *v74;
  char *v75;
  uint64_t v76;
  void *v77;
  uint64_t v78;
  uint64_t v79;
  _QWORD *v80;
  unint64_t *v81;
  void *v82;
  unint64_t v83;
  std::__shared_weak_count *v84;
  unint64_t *v85;
  unint64_t v86;
  std::__shared_weak_count *v87;
  unint64_t *p_shared_owners;
  unint64_t v89;
  uint64_t v90;
  uint64_t v92;
  uint64_t v93;
  void *__p[2];
  __int128 v95;
  char *v96;
  std::__shared_weak_count *v97;
  void *aBlock;
  uint64_t v99;
  void (*v100)(uint64_t, QMIServiceMsg *);
  void *v101;
  __int128 *p_buf;
  __int128 buf;
  void (*v104)(uint64_t, qmi::MessageBase *);
  void *v105;
  char *v106;
  void *v107;
  char v108;
  uint64_t v109;

  v109 = *MEMORY[0x24BDAC8D0];
  *(_OWORD *)__p = 0u;
  v95 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  MCC::MCC();
  MCC::MCC((MCC *)&v106, a4);
  v9 = (const void **)__p[1];
  if (__p[1] != (void *)v95)
  {
    while (*((_BYTE *)*v9 + 8) != 1)
    {
      if (++v9 == (const void **)v95)
        goto LABEL_8;
    }
  }
  if (v9 == (const void **)v95)
  {
LABEL_8:
    v12 = operator new();
    v13 = v12;
    *(_BYTE *)(v12 + 8) = 1;
    *(_QWORD *)v12 = &off_24D5E9A38;
    *(_DWORD *)(v12 + 10) = 0;
    v11 = (_WORD *)(v12 + 10);
    v14 = v95;
    if ((unint64_t)v95 >= *((_QWORD *)&v95 + 1))
    {
      v16 = (uint64_t)(v95 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v16 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v17 = (uint64_t)(*((_QWORD *)&v95 + 1) - (unint64_t)__p[1]) >> 2;
      if (v17 <= v16 + 1)
        v17 = v16 + 1;
      if (*((_QWORD *)&v95 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v18 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v18 = v17;
      if (v18)
        v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v95 + 8, v18);
      else
        v19 = 0;
      v20 = (uint64_t *)&v19[8 * v16];
      v21 = &v19[8 * v18];
      *v20 = v13;
      v15 = v20 + 1;
      v23 = (char *)__p[1];
      v22 = (char *)v95;
      if ((void *)v95 != __p[1])
      {
        do
        {
          v24 = *((_QWORD *)v22 - 1);
          v22 -= 8;
          *--v20 = v24;
        }
        while (v22 != v23);
        v22 = (char *)__p[1];
      }
      __p[1] = v20;
      *(_QWORD *)&v95 = v15;
      *((_QWORD *)&v95 + 1) = v21;
      if (v22)
        operator delete(v22);
    }
    else
    {
      *(_QWORD *)v95 = v12;
      v15 = (_QWORD *)(v14 + 8);
    }
    *(_QWORD *)&v95 = v15;
  }
  else
  {
    if (!v10)
      __cxa_bad_cast();
    v11 = v10 + 10;
  }
  *v11 = MCC::getIntValue((MCC *)&buf);
  v11[1] = MCC::getIntValue((MCC *)&v106);
  if (v108 < 0)
    operator delete(v107);
  if (SHIBYTE(v105) < 0)
    operator delete(*((void **)&buf + 1));
  v25 = 0;
  v26 = 1;
  switch(a5)
  {
    case -1:
    case 3:
    case 4:
    case 5:
    case 11:
      v27 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 88) + 16))(*(_QWORD *)(a1 + 88), a2);
      if (os_log_type_enabled(v27, OS_LOG_TYPE_FAULT))
      {
        v92 = asString();
        LODWORD(buf) = 136315138;
        *(_QWORD *)((char *)&buf + 4) = v92;
        _os_log_fault_impl(&dword_216897000, v27, OS_LOG_TYPE_FAULT, "RAT %s should not have been encountered here", (uint8_t *)&buf, 0xCu);
      }
      v28 = 0;
      goto LABEL_132;
    case 0:
      v26 = 0;
      v25 = 4;
      goto LABEL_38;
    case 2:
      v26 = 0;
      v25 = 5;
      goto LABEL_38;
    case 7:
    case 8:
      v26 = 0;
      v25 = 8;
      goto LABEL_38;
    case 9:
      v26 = 0;
      v25 = 9;
      goto LABEL_38;
    case 10:
      v26 = 0;
      v25 = 12;
      goto LABEL_38;
    default:
LABEL_38:
      v29 = (const void **)__p[1];
      v30 = (const void **)v95;
      if (__p[1] == (void *)v95)
        goto LABEL_42;
      break;
  }
  while (*((_BYTE *)*v29 + 8) != 18)
  {
    if (++v29 == (const void **)v95)
      goto LABEL_45;
  }
LABEL_42:
  if (v29 == (const void **)v95)
  {
LABEL_45:
    v33 = operator new();
    v34 = v33;
    *(_WORD *)(v33 + 8) = 18;
    *(_QWORD *)v33 = &off_24D5E9A88;
    v35 = v95;
    if ((unint64_t)v95 >= *((_QWORD *)&v95 + 1))
    {
      v36 = (uint64_t)(v95 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v36 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v37 = (uint64_t)(*((_QWORD *)&v95 + 1) - (unint64_t)__p[1]) >> 2;
      if (v37 <= v36 + 1)
        v37 = v36 + 1;
      if (*((_QWORD *)&v95 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v38 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v38 = v37;
      if (v38)
        v39 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v95 + 8, v38);
      else
        v39 = 0;
      v40 = (const void **)&v39[8 * v36];
      v41 = &v39[8 * v38];
      *v40 = (const void *)v34;
      v30 = v40 + 1;
      v43 = (char *)__p[1];
      v42 = (char *)v95;
      if ((void *)v95 != __p[1])
      {
        do
        {
          v44 = (const void *)*((_QWORD *)v42 - 1);
          v42 -= 8;
          *--v40 = v44;
        }
        while (v42 != v43);
        v42 = (char *)__p[1];
      }
      __p[1] = v40;
      *(_QWORD *)&v95 = v30;
      *((_QWORD *)&v95 + 1) = v41;
      if (v42)
        operator delete(v42);
    }
    else
    {
      *(_QWORD *)v95 = v33;
      v30 = (const void **)(v35 + 8);
    }
    v32 = (_BYTE *)(v34 + 9);
    *(_QWORD *)&v95 = v30;
    goto LABEL_62;
  }
  if (!v31)
    __cxa_bad_cast();
  v32 = v31 + 9;
LABEL_62:
  *v32 = 1;
  if ((v26 & 1) == 0)
  {
    for (i = (const void **)__p[1]; i != v30; ++i)
    {
      if (*((_BYTE *)*i + 8) == 21)
      {
        if (i != v30)
        {
          if (!v46)
            __cxa_bad_cast();
          v47 = v46 + 9;
          goto LABEL_87;
        }
        break;
      }
    }
    v48 = operator new();
    v49 = v48;
    *(_WORD *)(v48 + 8) = 21;
    *(_QWORD *)v48 = &off_24D5E9AD8;
    v50 = v95;
    if ((unint64_t)v95 >= *((_QWORD *)&v95 + 1))
    {
      v52 = (uint64_t)(v95 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v52 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v53 = (uint64_t)(*((_QWORD *)&v95 + 1) - (unint64_t)__p[1]) >> 2;
      if (v53 <= v52 + 1)
        v53 = v52 + 1;
      if (*((_QWORD *)&v95 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v54 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v54 = v53;
      if (v54)
        v55 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v95 + 8, v54);
      else
        v55 = 0;
      v56 = (uint64_t *)&v55[8 * v52];
      v57 = &v55[8 * v54];
      *v56 = v49;
      v51 = v56 + 1;
      v59 = (char *)__p[1];
      v58 = (char *)v95;
      if ((void *)v95 != __p[1])
      {
        do
        {
          v60 = *((_QWORD *)v58 - 1);
          v58 -= 8;
          *--v56 = v60;
        }
        while (v58 != v59);
        v58 = (char *)__p[1];
      }
      __p[1] = v56;
      *(_QWORD *)&v95 = v51;
      *((_QWORD *)&v95 + 1) = v57;
      if (v58)
        operator delete(v58);
    }
    else
    {
      *(_QWORD *)v95 = v48;
      v51 = (_QWORD *)(v50 + 8);
    }
    v47 = (char *)(v49 + 9);
    *(_QWORD *)&v95 = v51;
LABEL_87:
    *v47 = v25;
  }
  MCC::MCC((MCC *)&buf, a4);
  v61 = (const void **)__p[1];
  if (__p[1] != (void *)v95)
  {
    while (*((_BYTE *)*v61 + 8) != 17)
    {
      if (++v61 == (const void **)v95)
        goto LABEL_95;
    }
  }
  if (v61 == (const void **)v95)
  {
LABEL_95:
    v64 = operator new();
    v65 = v64;
    *(_WORD *)(v64 + 8) = 17;
    *(_QWORD *)v64 = &off_24D5E9B28;
    v66 = v95;
    if ((unint64_t)v95 >= *((_QWORD *)&v95 + 1))
    {
      v68 = (uint64_t)(v95 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v68 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v69 = (uint64_t)(*((_QWORD *)&v95 + 1) - (unint64_t)__p[1]) >> 2;
      if (v69 <= v68 + 1)
        v69 = v68 + 1;
      if (*((_QWORD *)&v95 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v70 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v70 = v69;
      if (v70)
        v71 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v95 + 8, v70);
      else
        v71 = 0;
      v72 = (uint64_t *)&v71[8 * v68];
      v73 = &v71[8 * v70];
      *v72 = v65;
      v67 = v72 + 1;
      v75 = (char *)__p[1];
      v74 = (char *)v95;
      if ((void *)v95 != __p[1])
      {
        do
        {
          v76 = *((_QWORD *)v74 - 1);
          v74 -= 8;
          *--v72 = v76;
        }
        while (v74 != v75);
        v74 = (char *)__p[1];
      }
      __p[1] = v72;
      *(_QWORD *)&v95 = v67;
      *((_QWORD *)&v95 + 1) = v73;
      if (v74)
        operator delete(v74);
    }
    else
    {
      *(_QWORD *)v95 = v64;
      v67 = (_QWORD *)(v66 + 8);
    }
    v63 = (BOOL *)(v65 + 9);
    *(_QWORD *)&v95 = v67;
  }
  else
  {
    if (!v62)
      __cxa_bad_cast();
    v63 = (BOOL *)(v62 + 9);
  }
  MCC::getStringValue((MCC *)&buf);
  if (SHIBYTE(v100) < 0)
  {
    v77 = aBlock;
    *v63 = v99 == 3;
    operator delete(v77);
  }
  else
  {
    *v63 = SHIBYTE(v100) == 3;
  }
  if (SHIBYTE(v105) < 0)
    operator delete(*((void **)&buf + 1));
  v78 = qmi::ClientRouter::get();
  v79 = operator new();
  *(_QWORD *)v79 = v78;
  *(_QWORD *)(v79 + 8) = QMIServiceMsg::create();
  *(_DWORD *)(v79 + 16) = 25000;
  *(_QWORD *)(v79 + 24) = 0;
  *(_QWORD *)(v79 + 32) = 0;
  v93 = v79;
  v80 = operator new(0x28uLL);
  v80[1] = 0;
  v81 = v80 + 1;
  v80[2] = 0;
  *v80 = &off_24D5E9B90;
  v80[3] = a1;
  *((_DWORD *)v80 + 8) = a2;
  v96 = (char *)(v80 + 3);
  v97 = (std::__shared_weak_count *)v80;
  v82 = (void *)MEMORY[0x24BDAC760];
  *(_QWORD *)&buf = MEMORY[0x24BDAC760];
  *((_QWORD *)&buf + 1) = 1174405120;
  v104 = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver11getPlmnNameEN10subscriber7SimSlotE3MCC3MNC21RadioAccessTechnologyE3__4EEOS1_OT__block_invoke;
  v105 = &__block_descriptor_tmp_52_6;
  v106 = (char *)(v80 + 3);
  v107 = v80;
  do
    v83 = __ldxr(v81);
  while (__stxr(v83 + 1, v81));
  aBlock = v82;
  v99 = 0x40000000;
  v100 = ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas11GetPlmnName8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
  v101 = &unk_24D5E9BD8;
  p_buf = &buf;
  *(_QWORD *)(v79 + 32) = _Block_copy(&aBlock);
  v84 = (std::__shared_weak_count *)v107;
  if (v107)
  {
    v85 = (unint64_t *)((char *)v107 + 8);
    do
      v86 = __ldaxr(v85);
    while (__stlxr(v86 - 1, v85));
    if (!v86)
    {
      ((void (*)(std::__shared_weak_count *))v84->__on_zero_shared)(v84);
      std::__shared_weak_count::__release_weak(v84);
    }
  }
  v87 = v97;
  if (v97)
  {
    p_shared_owners = (unint64_t *)&v97->__shared_owners_;
    do
      v89 = __ldaxr(p_shared_owners);
    while (__stlxr(v89 - 1, p_shared_owners));
    if (!v89)
    {
      ((void (*)(std::__shared_weak_count *))v87->__on_zero_shared)(v87);
      std::__shared_weak_count::__release_weak(v87);
    }
  }
  v90 = v93;
  v93 = 0;
  if (v90)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v93, v90);
  v28 = 1;
LABEL_132:
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
  return v28;
}

void sub_216A70F40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a11);
  _Unwind_Resume(a1);
}

void NetworkTimeUpdate::~NetworkTimeUpdate(void **this)
{
  if (*((_BYTE *)this + 144) && *((char *)this + 143) < 0)
    operator delete(this[15]);
  if (*((_BYTE *)this + 104))
  {
    if (*((char *)this + 103) < 0)
      operator delete(this[10]);
  }
}

uint64_t QMINetworkRegistrationDriver::sendPSRegistrationRequest(uint64_t a1, int a2, int a3)
{
  const void **v6;
  char *v7;
  _DWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  char *v16;
  uint64_t *v17;
  char *v18;
  char *v19;
  char *v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  _QWORD *v24;
  unint64_t *v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  std::__shared_weak_count *v29;
  unint64_t *p_shared_owners;
  unint64_t v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v37;
  uint64_t v38;
  void *__p[2];
  __int128 v40;
  _QWORD v41[5];
  std::__shared_weak_count *v42;
  char *v43;
  std::__shared_weak_count *v44;
  _QWORD aBlock[5];

  *(_OWORD *)__p = 0u;
  v40 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  v6 = (const void **)__p[1];
  if (__p[1] != (void *)v40)
  {
    while (*((_BYTE *)*v6 + 8) != 24)
    {
      if (++v6 == (const void **)v40)
        goto LABEL_8;
    }
  }
  if (v6 == (const void **)v40)
  {
LABEL_8:
    v9 = operator new();
    v10 = v9;
    *(_BYTE *)(v9 + 8) = 24;
    *(_QWORD *)v9 = &off_24D5E9C20;
    *(_DWORD *)(v9 + 12) = 0;
    v8 = (_DWORD *)(v9 + 12);
    v11 = v40;
    if ((unint64_t)v40 >= *((_QWORD *)&v40 + 1))
    {
      v13 = (uint64_t)(v40 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v13 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v14 = (uint64_t)(*((_QWORD *)&v40 + 1) - (unint64_t)__p[1]) >> 2;
      if (v14 <= v13 + 1)
        v14 = v13 + 1;
      if (*((_QWORD *)&v40 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v15 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v15 = v14;
      if (v15)
        v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v40 + 8, v15);
      else
        v16 = 0;
      v17 = (uint64_t *)&v16[8 * v13];
      v18 = &v16[8 * v15];
      *v17 = v10;
      v12 = v17 + 1;
      v20 = (char *)__p[1];
      v19 = (char *)v40;
      if ((void *)v40 != __p[1])
      {
        do
        {
          v21 = *((_QWORD *)v19 - 1);
          v19 -= 8;
          *--v17 = v21;
        }
        while (v19 != v20);
        v19 = (char *)__p[1];
      }
      __p[1] = v17;
      *(_QWORD *)&v40 = v12;
      *((_QWORD *)&v40 + 1) = v18;
      if (v19)
        operator delete(v19);
    }
    else
    {
      *(_QWORD *)v40 = v9;
      v12 = (_QWORD *)(v11 + 8);
    }
    *(_QWORD *)&v40 = v12;
  }
  else
  {
    if (!v7)
      __cxa_bad_cast();
    v8 = v7 + 12;
  }
  *v8 = 2;
  if (a3)
    *(_BYTE *)qmi::MutableMessageBase::getTLV<nas::tlv::NetworkSelectionPreference>(__p, 22) = 0;
  if ((a2 - 1) >= 3)
    v22 = 0;
  else
    v22 = a2;
  v23 = qmi::ClientRouter::get();
  qmi::ClientRouter::SendProxy::SendProxy<nas::SetSystemSelectionPreference::Request>((uint64_t)&v37, v22, v23);
  v24 = operator new(0x28uLL);
  v24[1] = 0;
  v25 = v24 + 1;
  v24[2] = 0;
  *v24 = &off_24D5E9C88;
  v24[3] = a1;
  *((_DWORD *)v24 + 8) = a2;
  v43 = (char *)(v24 + 3);
  v44 = (std::__shared_weak_count *)v24;
  v26 = v38;
  v27 = MEMORY[0x24BDAC760];
  v41[0] = MEMORY[0x24BDAC760];
  v41[1] = 1174405120;
  v41[2] = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver25sendPSRegistrationRequestEN10subscriber7SimSlotEbE3__2EEOS1_OT__block_invoke;
  v41[3] = &__block_descriptor_tmp_54_9;
  v41[4] = v24 + 3;
  v42 = (std::__shared_weak_count *)v24;
  do
    v28 = __ldxr(v25);
  while (__stxr(v28 + 1, v25));
  aBlock[0] = v27;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_31;
  aBlock[3] = &unk_24D5E8898;
  aBlock[4] = v41;
  *(_QWORD *)(v26 + 32) = _Block_copy(aBlock);
  v29 = v42;
  if (v42)
  {
    p_shared_owners = (unint64_t *)&v42->__shared_owners_;
    do
      v31 = __ldaxr(p_shared_owners);
    while (__stlxr(v31 - 1, p_shared_owners));
    if (!v31)
    {
      ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
      std::__shared_weak_count::__release_weak(v29);
    }
  }
  v32 = v44;
  if (v44)
  {
    v33 = (unint64_t *)&v44->__shared_owners_;
    do
      v34 = __ldaxr(v33);
    while (__stlxr(v34 - 1, v33));
    if (!v34)
    {
      ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
      std::__shared_weak_count::__release_weak(v32);
    }
  }
  v35 = v38;
  v38 = 0;
  if (v35)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v38, v35);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
  return 1;
}

void sub_216A7138C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

void QMINetworkRegistrationDriver::setCampOnlyMode(uint64_t a1, int a2, int a3)
{
  uint64_t v6;
  const void **v7;
  char *v8;
  _DWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  char *v17;
  uint64_t *v18;
  char *v19;
  char *v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  _QWORD *v24;
  unint64_t *v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  std::__shared_weak_count *v29;
  unint64_t *p_shared_owners;
  unint64_t v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void *__p[2];
  __int128 v39;
  _QWORD v40[5];
  std::__shared_weak_count *v41;
  char *v42;
  std::__shared_weak_count *v43;
  _QWORD aBlock[5];

  v6 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 88) + 16))(*(_QWORD *)(a1 + 88), 1);
  *(_OWORD *)__p = 0u;
  v39 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  v7 = (const void **)__p[1];
  if (__p[1] != (void *)v39)
  {
    while (*((_BYTE *)*v7 + 8) != 31)
    {
      if (++v7 == (const void **)v39)
        goto LABEL_8;
    }
  }
  if (v7 == (const void **)v39)
  {
LABEL_8:
    v10 = operator new();
    v11 = v10;
    *(_BYTE *)(v10 + 8) = 31;
    *(_QWORD *)v10 = &off_24D5E9CF0;
    *(_DWORD *)(v10 + 12) = 0;
    v9 = (_DWORD *)(v10 + 12);
    v12 = v39;
    if ((unint64_t)v39 >= *((_QWORD *)&v39 + 1))
    {
      v14 = (uint64_t)(v39 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v14 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v15 = (uint64_t)(*((_QWORD *)&v39 + 1) - (unint64_t)__p[1]) >> 2;
      if (v15 <= v14 + 1)
        v15 = v14 + 1;
      if (*((_QWORD *)&v39 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v16 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v16 = v15;
      if (v16)
        v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v39 + 8, v16);
      else
        v17 = 0;
      v18 = (uint64_t *)&v17[8 * v14];
      v19 = &v17[8 * v16];
      *v18 = v11;
      v13 = v18 + 1;
      v21 = (char *)__p[1];
      v20 = (char *)v39;
      if ((void *)v39 != __p[1])
      {
        do
        {
          v22 = *((_QWORD *)v20 - 1);
          v20 -= 8;
          *--v18 = v22;
        }
        while (v20 != v21);
        v20 = (char *)__p[1];
      }
      __p[1] = v18;
      *(_QWORD *)&v39 = v13;
      *((_QWORD *)&v39 + 1) = v19;
      if (v20)
        operator delete(v20);
    }
    else
    {
      *(_QWORD *)v39 = v10;
      v13 = (_QWORD *)(v12 + 8);
    }
    *(_QWORD *)&v39 = v13;
  }
  else
  {
    if (!v8)
      __cxa_bad_cast();
    v9 = v8 + 12;
  }
  *v9 = a3;
  v23 = qmi::ClientRouter::get();
  qmi::ClientRouter::SendProxy::SendProxy<nas::SetSystemSelectionPreference::Request>((uint64_t)&v36, 1, v23);
  v24 = operator new(0x30uLL);
  v24[1] = 0;
  v25 = v24 + 1;
  v24[2] = 0;
  *v24 = &off_24D5E9D58;
  v24[3] = a1;
  *((_DWORD *)v24 + 8) = a2;
  *((_BYTE *)v24 + 36) = a3;
  v24[5] = v6;
  v42 = (char *)(v24 + 3);
  v43 = (std::__shared_weak_count *)v24;
  v26 = v37;
  v27 = MEMORY[0x24BDAC760];
  v40[0] = MEMORY[0x24BDAC760];
  v40[1] = 1174405120;
  v40[2] = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver15setCampOnlyModeEN10subscriber7SimSlotEbE3__1EEOS1_OT__block_invoke;
  v40[3] = &__block_descriptor_tmp_55_10;
  v40[4] = v24 + 3;
  v41 = (std::__shared_weak_count *)v24;
  do
    v28 = __ldxr(v25);
  while (__stxr(v28 + 1, v25));
  aBlock[0] = v27;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_31;
  aBlock[3] = &unk_24D5E8898;
  aBlock[4] = v40;
  *(_QWORD *)(v26 + 32) = _Block_copy(aBlock);
  v29 = v41;
  if (v41)
  {
    p_shared_owners = (unint64_t *)&v41->__shared_owners_;
    do
      v31 = __ldaxr(p_shared_owners);
    while (__stlxr(v31 - 1, p_shared_owners));
    if (!v31)
    {
      ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
      std::__shared_weak_count::__release_weak(v29);
    }
  }
  v32 = v43;
  if (v43)
  {
    v33 = (unint64_t *)&v43->__shared_owners_;
    do
      v34 = __ldaxr(v33);
    while (__stlxr(v34 - 1, v33));
    if (!v34)
    {
      ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
      std::__shared_weak_count::__release_weak(v32);
    }
  }
  v35 = v37;
  v37 = 0;
  if (v35)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v37, v35);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
}

void sub_216A71718(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  va_list va;
  uint64_t v7;
  va_list va1;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  va_list va2;

  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v5 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v7 = va_arg(va2, _QWORD);
  v9 = va_arg(va2, _QWORD);
  v10 = va_arg(va2, _QWORD);
  v11 = va_arg(va2, _QWORD);
  v12 = va_arg(va2, _QWORD);
  v13 = va_arg(va2, _QWORD);
  v14 = va_arg(va2, _QWORD);
  v15 = va_arg(va2, _QWORD);
  v16 = va_arg(va2, _QWORD);
  v17 = va_arg(va2, _QWORD);
  v18 = va_arg(va2, _QWORD);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v2);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va2);
  v4 = v5;
  v5 = 0;
  if (v4)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)va, v4);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va1);
  _Unwind_Resume(a1);
}

uint64_t QMINetworkRegistrationDriver::setProvisioningMode(QMINetworkRegistrationDriver *this, int a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  unint64_t *v8;
  uint64_t v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  unint64_t *v20;
  uint64_t v21;
  unint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  unint64_t *v26;
  uint64_t v27;
  uint64_t v29;
  __int128 v30;
  __int128 v31;
  uint64_t v32;
  uint64_t v33;
  void (*v34)(uint64_t, uint64_t);
  void *v35;
  char *v36;
  std::__shared_weak_count *v37;
  char *v38;
  std::__shared_weak_count *v39;
  uint64_t aBlock;
  uint64_t v41;
  void (*v42)(uint64_t, uint64_t);
  void *v43;
  uint64_t *v44;

  v4 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)this + 11) + 16))(*((_QWORD *)this + 11), 1);
  if (a2)
  {
    v30 = 0uLL;
    v31 = 0uLL;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)&v30);
    v5 = qmi::ClientRouter::get();
    v6 = operator new();
    *(_QWORD *)v6 = v5;
    *(_QWORD *)(v6 + 8) = QMIServiceMsg::create();
    *(_DWORD *)(v6 + 16) = 25000;
    *(_QWORD *)(v6 + 24) = 0;
    *(_QWORD *)(v6 + 32) = 0;
    v29 = v6;
    v7 = operator new(0x30uLL);
    v7[1] = 0;
    v8 = v7 + 1;
    v7[2] = 0;
    *v7 = &off_24D5E9DD8;
    v7[3] = this;
    *((_BYTE *)v7 + 32) = a2;
    v7[5] = v4;
    v38 = (char *)(v7 + 3);
    v39 = (std::__shared_weak_count *)v7;
    v9 = MEMORY[0x24BDAC760];
    v32 = MEMORY[0x24BDAC760];
    v33 = 1174405120;
    v34 = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver19setProvisioningModeEbE3__0EEOS1_OT__block_invoke;
    v35 = &__block_descriptor_tmp_56_7;
    v36 = (char *)(v7 + 3);
    v37 = (std::__shared_weak_count *)v7;
    do
      v10 = __ldxr(v8);
    while (__stxr(v10 + 1, v8));
    aBlock = v9;
    v41 = 0x40000000;
    v42 = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_31;
    v43 = &unk_24D5E8898;
    v44 = &v32;
    *(_QWORD *)(v6 + 32) = _Block_copy(&aBlock);
    v11 = v37;
    if (v37)
    {
      p_shared_owners = (unint64_t *)&v37->__shared_owners_;
      do
        v13 = __ldaxr(p_shared_owners);
      while (__stlxr(v13 - 1, p_shared_owners));
      if (!v13)
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
    }
    v14 = v39;
    if (v39)
    {
      v15 = (unint64_t *)&v39->__shared_owners_;
      do
        v16 = __ldaxr(v15);
      while (__stlxr(v16 - 1, v15));
      goto LABEL_23;
    }
  }
  else
  {
    v30 = 0uLL;
    v31 = 0uLL;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)&v30);
    v17 = qmi::ClientRouter::get();
    v18 = operator new();
    *(_QWORD *)v18 = v17;
    *(_QWORD *)(v18 + 8) = QMIServiceMsg::create();
    *(_DWORD *)(v18 + 16) = 25000;
    *(_QWORD *)(v18 + 24) = 0;
    *(_QWORD *)(v18 + 32) = 0;
    v29 = v18;
    v19 = operator new(0x30uLL);
    v19[1] = 0;
    v20 = v19 + 1;
    v19[2] = 0;
    *v19 = &off_24D5E9E58;
    v19[3] = this;
    *((_BYTE *)v19 + 32) = 0;
    v19[5] = v4;
    v38 = (char *)(v19 + 3);
    v39 = (std::__shared_weak_count *)v19;
    v21 = MEMORY[0x24BDAC760];
    v32 = MEMORY[0x24BDAC760];
    v33 = 1174405120;
    v34 = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver19setProvisioningModeEbE3__1EEOS1_OT__block_invoke;
    v35 = &__block_descriptor_tmp_57_7;
    v36 = (char *)(v19 + 3);
    v37 = (std::__shared_weak_count *)v19;
    do
      v22 = __ldxr(v20);
    while (__stxr(v22 + 1, v20));
    aBlock = v21;
    v41 = 0x40000000;
    v42 = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_31;
    v43 = &unk_24D5E8898;
    v44 = &v32;
    *(_QWORD *)(v18 + 32) = _Block_copy(&aBlock);
    v23 = v37;
    if (v37)
    {
      v24 = (unint64_t *)&v37->__shared_owners_;
      do
        v25 = __ldaxr(v24);
      while (__stlxr(v25 - 1, v24));
      if (!v25)
      {
        ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
        std::__shared_weak_count::__release_weak(v23);
      }
    }
    v14 = v39;
    if (v39)
    {
      v26 = (unint64_t *)&v39->__shared_owners_;
      do
        v16 = __ldaxr(v26);
      while (__stlxr(v16 - 1, v26));
LABEL_23:
      if (!v16)
      {
        ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
        std::__shared_weak_count::__release_weak(v14);
      }
    }
  }
  v27 = v29;
  v29 = 0;
  if (v27)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v29, v27);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&v30);
  return 1;
}

void sub_216A71AEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;
  va_list va;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v6 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v3);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  if (a3)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v4, a3);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

uint64_t QMINetworkRegistrationDriver::getProvisioningMode(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v21;
  _OWORD v22[2];
  _QWORD v23[5];
  std::__shared_weak_count *v24;
  uint64_t v25;
  std::__shared_weak_count *v26;
  _QWORD aBlock[5];
  _BYTE v28[24];
  _BYTE *v29;
  uint64_t v30;
  uint64_t v31;

  v31 = *MEMORY[0x24BDAC8D0];
  v3 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 88) + 16))(*(_QWORD *)(a1 + 88), 1);
  memset(v22, 0, sizeof(v22));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v22);
  v4 = qmi::ClientRouter::get();
  v5 = operator new();
  *(_QWORD *)v5 = v4;
  *(_QWORD *)(v5 + 8) = QMIServiceMsg::create();
  *(_DWORD *)(v5 + 16) = 25000;
  *(_QWORD *)(v5 + 24) = 0;
  *(_QWORD *)(v5 + 32) = 0;
  v21 = v5;
  std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100]((uint64_t)v28, a2);
  v30 = v3;
  v6 = (std::__shared_weak_count *)operator new(0x40uLL);
  v6->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v6->__shared_owners_;
  v6->__shared_weak_owners_ = 0;
  v6->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E9ED8;
  v8 = std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)&v6[1], (uint64_t)v28);
  v6[2].__shared_owners_ = v30;
  v25 = v8;
  v26 = v6;
  v9 = MEMORY[0x24BDAC760];
  v23[0] = MEMORY[0x24BDAC760];
  v23[1] = 1174405120;
  v23[2] = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver19getProvisioningModeENSt3__18functionIFvbEEEE3__0EEOS1_OT__block_invoke;
  v23[3] = &__block_descriptor_tmp_58_6;
  v23[4] = v8;
  v24 = v6;
  do
    v10 = __ldxr(p_shared_owners);
  while (__stxr(v10 + 1, p_shared_owners));
  aBlock[0] = v9;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas19GetProvisioningMode8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
  aBlock[3] = &unk_24D5E9F20;
  aBlock[4] = v23;
  *(_QWORD *)(v21 + 32) = _Block_copy(aBlock);
  v11 = v24;
  if (v24)
  {
    v12 = (unint64_t *)&v24->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  v14 = v26;
  if (v26)
  {
    v15 = (unint64_t *)&v26->__shared_owners_;
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
  v17 = v29;
  if (v29 == v28)
  {
    v18 = 4;
    v17 = v28;
  }
  else
  {
    if (!v29)
      goto LABEL_18;
    v18 = 5;
  }
  (*(void (**)(_QWORD *))(*v17 + 8 * v18))(v17);
LABEL_18:
  v19 = v21;
  v21 = 0;
  if (v19)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v21, v19);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v22);
  return 1;
}

void sub_216A71DF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  va_list va;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v9 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  v18 = va_arg(va1, _QWORD);
  v19 = va_arg(va1, _QWORD);
  v20 = va_arg(va1, _QWORD);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v4);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  v7 = *(_QWORD **)(v5 - 72);
  if (v7 == (_QWORD *)(v5 - 96))
  {
    v8 = 4;
    v7 = (_QWORD *)(v5 - 96);
  }
  else
  {
    if (!v7)
      goto LABEL_6;
    v8 = 5;
  }
  (*(void (**)(void))(*v7 + 8 * v8))();
LABEL_6:
  if (a3)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v3, a3);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

uint64_t QMINetworkRegistrationDriver::enableServingSystemNotificationInLowPower(QMINetworkRegistrationDriver *this)
{
  qmi::ClientRouter *v1;

  v1 = (QMINetworkRegistrationDriver *)((char *)this + 104);
  qmi::ClientRouter::setIndShouldWake((QMINetworkRegistrationDriver *)((char *)this + 104));
  qmi::ClientRouter::setIndShouldWake(v1);
  return 1;
}

BOOL QMINetworkRegistrationDriver::invalidateNetworkTimeCache(QMINetworkRegistrationDriver *this)
{
  _DWORD *v2;
  uint64_t v3;
  os_log_t *v4;
  std::mutex *ServiceMap;
  uint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  char *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  NSObject *v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  uint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  uint64_t v20;
  unint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  unint64_t v25;
  uint64_t v26;
  _DWORD *v27;
  int v29;
  _DWORD *v30;
  _DWORD *v31;
  uint64_t (*v32)(_QWORD);
  char v33[8];
  uint64_t v34;
  _OWORD v35[2];
  uint64_t v36;
  uint64_t v37;
  void (*v38)(uint64_t, uint64_t);
  void *v39;
  std::__shared_weak_count *v40;
  std::__shared_weak_count *v41;
  uint8_t buf[8];
  uint64_t v43;
  void (*v44)(uint64_t, uint64_t);
  void *v45;
  uint64_t *v46;

  subscriber::makeSimSlotRange();
  v2 = v30;
  if (v30 != v31)
  {
    while ((v32(*v2) & 1) == 0)
    {
      if (++v2 == v31)
      {
        v2 = v31;
        break;
      }
    }
    if (v2 != v31)
    {
      v29 = 1;
      while (1)
      {
        if ((*v2 - 1) >= 3)
          v3 = 0;
        else
          v3 = *v2;
        v4 = (os_log_t *)(*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)this + 11) + 16))(*((_QWORD *)this + 11), v3);
        memset(v35, 0, sizeof(v35));
        qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v35);
        v36 = 0;
        v37 = 0;
        ServiceMap = (std::mutex *)Registry::getServiceMap(*((Registry **)this + 6));
        ctu::shared_ptr_map_impl<ctu::indexed_by_any_map_hashing_key>::get<TimeHandlerInterface>(&v36, ServiceMap);
        v6 = v36;
        if (v36)
        {
          v7 = (std::__shared_weak_count *)v37;
          if (v37)
          {
            v8 = (unint64_t *)(v37 + 8);
            do
              v9 = __ldxr(v8);
            while (__stxr(v9 + 1, v8));
          }
          v10 = qmi::MutableMessageBase::getTLV<nas::tlv::NetworkTimeCachePeriod>(v35);
          *(_DWORD *)v10 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 80))(v6);
          if (v7)
          {
            p_shared_owners = (unint64_t *)&v7->__shared_owners_;
            do
              v12 = __ldaxr(p_shared_owners);
            while (__stlxr(v12 - 1, p_shared_owners));
            if (!v12)
            {
              ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
              std::__shared_weak_count::__release_weak(v7);
            }
          }
        }
        else
        {
          v13 = *v4;
          v29 = 0;
          if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl(&dword_216897000, v13, OS_LOG_TYPE_DEFAULT, "#N Could not get TimeHandlerInterface to invalidate network time cache", buf, 2u);
            v29 = 0;
          }
        }
        v14 = (std::__shared_weak_count *)v37;
        if (!v37)
          goto LABEL_25;
        v15 = (unint64_t *)(v37 + 8);
        do
          v16 = __ldaxr(v15);
        while (__stlxr(v16 - 1, v15));
        if (!v16)
        {
          ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
          std::__shared_weak_count::__release_weak(v14);
          if (v6)
          {
LABEL_26:
            v17 = qmi::ClientRouter::get();
            qmi::ClientRouter::SendProxy::SendProxy<nas::IndicationRegister::Request>((uint64_t)v33, v3, v17);
            v18 = (std::__shared_weak_count *)operator new(0x20uLL);
            v18->__shared_owners_ = 0;
            v19 = (unint64_t *)&v18->__shared_owners_;
            v18->__shared_weak_owners_ = 0;
            v18->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E9F80;
            v18[1].__vftable = (std::__shared_weak_count_vtbl *)v4;
            v20 = v34;
            v36 = MEMORY[0x24BDAC760];
            v37 = 1174405120;
            v38 = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZZN28QMINetworkRegistrationDriver26invalidateNetworkTimeCacheEvENK3__0clINS_16SubscriptionTypeEEEDaT_EUlRKNS_12ResponseBaseEE_EEOS1_OS8__block_invoke;
            v39 = &__block_descriptor_tmp_60_8;
            v40 = v18 + 1;
            v41 = v18;
            do
              v21 = __ldxr(v19);
            while (__stxr(v21 + 1, v19));
            *(_QWORD *)buf = MEMORY[0x24BDAC760];
            v43 = 0x40000000;
            v44 = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_31;
            v45 = &unk_24D5E8898;
            v46 = &v36;
            *(_QWORD *)(v20 + 32) = _Block_copy(buf);
            v22 = v41;
            if (v41)
            {
              v23 = (unint64_t *)&v41->__shared_owners_;
              do
                v24 = __ldaxr(v23);
              while (__stlxr(v24 - 1, v23));
              if (!v24)
              {
                ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
                std::__shared_weak_count::__release_weak(v22);
              }
            }
            do
              v25 = __ldaxr(v19);
            while (__stlxr(v25 - 1, v19));
            if (!v25)
            {
              ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
              std::__shared_weak_count::__release_weak(v18);
            }
            v26 = v34;
            v34 = 0;
            if (v26)
              std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v34, v26);
          }
        }
        else
        {
LABEL_25:
          if (v6)
            goto LABEL_26;
        }
        qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v35);
        v27 = v2 + 1;
        v2 = v31;
        if (v27 != v31)
        {
          v2 = v27;
          while ((v32(*v2) & 1) == 0)
          {
            if (++v2 == v31)
            {
              v2 = v31;
              break;
            }
          }
        }
        if (v2 == v31)
          return v29 != 0;
      }
    }
  }
  v29 = 1;
  return v29 != 0;
}

void sub_216A72288(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,std::__shared_weak_count *a26)
{
  std::__shared_weak_count *v26;
  unint64_t *v27;
  std::__shared_weak_count *v29;
  unint64_t *p_shared_owners;
  unint64_t v31;
  unint64_t v32;

  v29 = a26;
  if (a26)
  {
    p_shared_owners = (unint64_t *)&a26->__shared_owners_;
    do
      v31 = __ldaxr(p_shared_owners);
    while (__stlxr(v31 - 1, p_shared_owners));
    if (!v31)
    {
      ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
      std::__shared_weak_count::__release_weak(v29);
    }
  }
  do
    v32 = __ldaxr(v27);
  while (__stlxr(v32 - 1, v27));
  if (!v32)
  {
    ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
    std::__shared_weak_count::__release_weak(v26);
  }
  if (a16)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](a9, a16);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a17);
  _Unwind_Resume(a1);
}

uint64_t QMINetworkRegistrationDriver::enterE911State(uint64_t a1, int a2, uint64_t a3, char a4, char a5, uint64_t a6)
{
  capabilities::ct *v12;
  int *v13;
  int *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int *v18;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  NSObject *v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  NSObject *v28;
  uint64_t v29;
  uint64_t v30;
  char *v31;
  __int128 v32;
  __int128 v33;
  unint64_t *v34;
  void *v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  std::__shared_weak_count *v41;
  unint64_t *p_shared_owners;
  unint64_t v43;
  std::__shared_weak_count *v44;
  unint64_t *v45;
  unint64_t v46;
  uint64_t v47;
  __int128 v49;
  void *v50[2];
  uint64_t v51;
  __int16 v52;
  void *v53[2];
  __int128 v54;
  void *__p;
  _BYTE *v56;
  uint64_t v57;
  int v58;
  uint64_t v59;
  _OWORD v60[2];
  uint64_t v61;
  void *v62;
  uint64_t v63;
  uint64_t v64;
  __int128 v65;
  void *v66[2];
  uint64_t v67;
  uint64_t v68;
  void *v69;
  uint64_t v70;
  uint64_t v71;
  _QWORD v72[5];
  std::__shared_weak_count *v73;
  char *v74;
  std::__shared_weak_count *v75;
  _QWORD aBlock[5];

  v68 = a1;
  v69 = 0;
  v70 = 0;
  v71 = 0;
  std::vector<EmergencySetupType>::__init_with_size[abi:ne180100]<EmergencySetupType*,EmergencySetupType*>(&v69, *(const void **)a3, *(_QWORD *)(a3 + 8), (uint64_t)(*(_QWORD *)(a3 + 8) - *(_QWORD *)a3) >> 2);
  v67 = 0;
  v65 = 0u;
  *(_OWORD *)v66 = 0u;
  v61 = a1;
  v62 = 0;
  v63 = 0;
  v64 = 0;
  std::vector<EmergencySetupType>::__init_with_size[abi:ne180100]<EmergencySetupType*,EmergencySetupType*>(&v62, *(const void **)a3, *(_QWORD *)(a3 + 8), (uint64_t)(*(_QWORD *)(a3 + 8) - *(_QWORD *)a3) >> 2);
  LOBYTE(v65) = a4;
  BYTE1(v65) = a5 & ~a4;
  *((_QWORD *)&v65 + 1) = v68;
  v66[0] = 0;
  v66[1] = 0;
  v67 = 0;
  v12 = (capabilities::ct *)std::vector<EmergencySetupType>::__init_with_size[abi:ne180100]<EmergencySetupType*,EmergencySetupType*>(v66, v69, v70, (v70 - (uint64_t)v69) >> 2);
  if ((capabilities::ct::supportsEmergencyQMIExtensions(v12) & 1) == 0)
  {
    QMINetworkRegistrationDriver::enterE911State(subscriber::SimSlot,std::vector<EmergencySetupType> const&,BOOL,BOOL,subscriber::SimSlot,BOOL)::$_0::operator()(&v68, 1);
    goto LABEL_58;
  }
  v14 = *(int **)a3;
  v13 = *(int **)(a3 + 8);
  v15 = (uint64_t)v13 - *(_QWORD *)a3;
  if (v13 == *(int **)a3)
  {
    if (v15 == 4)
    {
      v20 = 4;
LABEL_25:
      v25 = subscriber::instanceAsSimSlot((subscriber *)((unint64_t)v20 >> 2));
      QMINetworkRegistrationDriver::enterE911State(subscriber::SimSlot,std::vector<EmergencySetupType> const&,BOOL,BOOL,subscriber::SimSlot,BOOL)::$_1::operator()((uint64_t)&v61, v25);
      goto LABEL_58;
    }
    goto LABEL_35;
  }
  v16 = 0;
  v17 = v15 >> 2;
  v18 = *(int **)a3;
  do
  {
    if (!*v18++)
      ++v16;
  }
  while (v18 != v13);
  if (v17 - v16 == 1)
  {
    v20 = 0;
    while (*(int *)((char *)v14 + v20) != 1)
    {
      v20 += 4;
      if ((int *)((char *)v14 + v20) == v13)
      {
        v21 = v15 >> 2;
        v20 = (uint64_t)v13 - *(_QWORD *)a3;
        goto LABEL_24;
      }
    }
    v21 = v20 >> 2;
LABEL_24:
    if (&v14[v21] != v13)
      goto LABEL_25;
    v26 = 0;
    while (*(int *)((char *)v14 + v26) != 2)
    {
      v26 += 4;
      if ((int *)((char *)v14 + v26) == v13)
      {
        v26 = (uint64_t)v13 - *(_QWORD *)a3;
        goto LABEL_31;
      }
    }
    v17 = v26 >> 2;
LABEL_31:
    if (&v14[v17] != v13)
    {
      v27 = subscriber::instanceAsSimSlot((subscriber *)((unint64_t)v26 >> 2));
      v28 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 88) + 16))(*(_QWORD *)(a1 + 88), v27);
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v49) = 0;
        _os_log_impl(&dword_216897000, v28, OS_LOG_TYPE_DEFAULT, "#I Dial on preferred sub with normal setup as the other sub is not usable. Do not query preferred E911 subscription.", (uint8_t *)&v49, 2u);
      }
      (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 64) + 144))(*(_QWORD *)(a1 + 64), (v27 << 32) | 1);
      goto LABEL_58;
    }
    goto LABEL_35;
  }
  v22 = 0;
  do
  {
    v23 = *v14++;
    if (v23 == 2)
      ++v22;
  }
  while (v14 != v13);
  if (v22 != 2)
  {
LABEL_35:
    if (a2)
    {
      QMINetworkRegistrationDriver::enterE911State(subscriber::SimSlot,std::vector<EmergencySetupType> const&,BOOL,BOOL,subscriber::SimSlot,BOOL)::$_1::operator()((uint64_t)&v61, a2);
    }
    else
    {
      memset(v60, 0, sizeof(v60));
      qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v60);
      v29 = qmi::ClientRouter::get();
      v58 = 1;
      v30 = operator new();
      *(_QWORD *)v30 = v29;
      *(_QWORD *)(v30 + 8) = QMIServiceMsg::create();
      *(_DWORD *)(v30 + 16) = 25000;
      *(_QWORD *)(v30 + 24) = 0;
      *(_QWORD *)(v30 + 32) = 0;
      v59 = v30;
      *(_QWORD *)&v49 = a1;
      *((_QWORD *)&v49 + 1) = v61;
      v50[1] = 0;
      v51 = 0;
      v50[0] = 0;
      std::vector<EmergencySetupType>::__init_with_size[abi:ne180100]<EmergencySetupType*,EmergencySetupType*>(v50, v62, v63, (v63 - (uint64_t)v62) >> 2);
      v52 = v65;
      v53[0] = *((void **)&v65 + 1);
      v53[1] = 0;
      v54 = 0uLL;
      std::vector<EmergencySetupType>::__init_with_size[abi:ne180100]<EmergencySetupType*,EmergencySetupType*>(&v53[1], v66[0], (uint64_t)v66[1], ((char *)v66[1] - (char *)v66[0]) >> 2);
      __p = 0;
      v56 = 0;
      v57 = 0;
      std::vector<EmergencySetupType>::__init_with_size[abi:ne180100]<EmergencySetupType*,EmergencySetupType*>(&__p, *(const void **)a3, *(_QWORD *)(a3 + 8), (uint64_t)(*(_QWORD *)(a3 + 8) - *(_QWORD *)a3) >> 2);
      v74 = 0;
      v75 = 0;
      v31 = (char *)operator new(0x80uLL);
      v32 = *(_OWORD *)v50;
      *(_OWORD *)(v31 + 24) = v49;
      *(_OWORD *)(v31 + 40) = v32;
      v33 = v54;
      *(_OWORD *)(v31 + 72) = *(_OWORD *)v53;
      *((_QWORD *)v31 + 1) = 0;
      v34 = (unint64_t *)(v31 + 8);
      *((_QWORD *)v31 + 2) = 0;
      *(_QWORD *)v31 = &off_24D5EA000;
      *((_QWORD *)v31 + 7) = v51;
      v50[1] = 0;
      v51 = 0;
      v50[0] = 0;
      *((_WORD *)v31 + 32) = v52;
      *(_OWORD *)(v31 + 88) = v33;
      v54 = 0uLL;
      v53[1] = 0;
      *((_QWORD *)v31 + 13) = 0;
      *((_QWORD *)v31 + 14) = 0;
      v35 = __p;
      v36 = (uint64_t)v56;
      v37 = (v56 - (_BYTE *)__p) >> 2;
      *((_QWORD *)v31 + 15) = 0;
      std::vector<EmergencySetupType>::__init_with_size[abi:ne180100]<EmergencySetupType*,EmergencySetupType*>((_QWORD *)v31 + 13, v35, v36, v37);
      v74 = v31 + 24;
      v75 = (std::__shared_weak_count *)v31;
      v38 = v59;
      v39 = MEMORY[0x24BDAC760];
      v72[0] = MEMORY[0x24BDAC760];
      v72[1] = 1174405120;
      v72[2] = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver14enterE911StateEN10subscriber7SimSlotERKNSt3__16vectorI18EmergencySetupTypeNS6_9allocatorIS8_EEEEbbS5_bE3__2EEOS1_OT__block_invoke;
      v72[3] = &__block_descriptor_tmp_61_8;
      v72[4] = v31 + 24;
      v73 = (std::__shared_weak_count *)v31;
      do
        v40 = __ldxr(v34);
      while (__stxr(v40 + 1, v34));
      aBlock[0] = v39;
      aBlock[1] = 0x40000000;
      aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas10GetE911Sub8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
      aBlock[3] = &unk_24D5EA048;
      aBlock[4] = v72;
      *(_QWORD *)(v38 + 32) = _Block_copy(aBlock);
      v41 = v73;
      if (v73)
      {
        p_shared_owners = (unint64_t *)&v73->__shared_owners_;
        do
          v43 = __ldaxr(p_shared_owners);
        while (__stlxr(v43 - 1, p_shared_owners));
        if (!v43)
        {
          ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
          std::__shared_weak_count::__release_weak(v41);
        }
      }
      v44 = v75;
      if (v75)
      {
        v45 = (unint64_t *)&v75->__shared_owners_;
        do
          v46 = __ldaxr(v45);
        while (__stlxr(v46 - 1, v45));
        if (!v46)
        {
          ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
          std::__shared_weak_count::__release_weak(v44);
        }
      }
      if (__p)
      {
        v56 = __p;
        operator delete(__p);
      }
      if (v53[1])
      {
        *(void **)&v54 = v53[1];
        operator delete(v53[1]);
      }
      if (v50[0])
      {
        v50[1] = v50[0];
        operator delete(v50[0]);
      }
      v47 = v59;
      v59 = 0;
      if (v47)
        std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v59, v47);
      qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v60);
    }
    goto LABEL_58;
  }
  v24 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 88) + 16))(*(_QWORD *)(a1 + 88), a6);
  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v49) = 0;
    _os_log_impl(&dword_216897000, v24, OS_LOG_TYPE_DEFAULT, "#I Matched as Normal on both subs. Dial on data preferred sub with normal setup. Do not query preferred E911 subscription.", (uint8_t *)&v49, 2u);
  }
  (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 64) + 144))(*(_QWORD *)(a1 + 64), (a6 << 32) | 1);
LABEL_58:
  if (v66[0])
    operator delete(v66[0]);
  if (v62)
    operator delete(v62);
  if (v69)
    operator delete(v69);
  return 1;
}

void sub_216A72940(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30)
{
  void *v30;

  QMINetworkRegistrationDriver::enterE911State(subscriber::SimSlot,std::vector<EmergencySetupType> const&,BOOL,BOOL,subscriber::SimSlot,BOOL)::$_1::~$_1(&a29);
  if (v30)
    operator delete(v30);
  _Unwind_Resume(a1);
}

void QMINetworkRegistrationDriver::enterE911State(subscriber::SimSlot,std::vector<EmergencySetupType> const&,BOOL,BOOL,subscriber::SimSlot,BOOL)::$_0::operator()(_QWORD *a1, int a2)
{
  uint64_t v4;
  os_log_t *v5;
  NSObject *v6;
  capabilities::ct *v7;
  unsigned int v8;
  const void *v9;
  uint64_t v10;
  unint64_t v11;
  const void **v12;
  char *v13;
  unsigned int *v14;
  os_log_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  char *v23;
  uint64_t *v24;
  char *v25;
  char *v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  void *v30;
  int v31;
  unsigned int v32;
  NSObject *v33;
  const char *v34;
  int v35;
  uint64_t v36;
  _QWORD *v37;
  unint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  std::__shared_weak_count *v42;
  unint64_t *p_shared_owners;
  unint64_t v44;
  std::__shared_weak_count *v45;
  unint64_t *v46;
  unint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  void *__p[2];
  __int128 v52;
  uint8_t buf[8];
  uint64_t v54;
  uint64_t (*v55)(uint64_t, uint64_t);
  void *v56;
  os_log_t *v57;
  std::__shared_weak_count *v58;
  char *v59;
  std::__shared_weak_count *v60;
  __int128 aBlock;
  void (*v62)(uint64_t, uint64_t);
  void *v63;
  uint8_t *v64;
  uint64_t v65;

  v65 = *MEMORY[0x24BDAC8D0];
  v4 = *a1;
  v5 = (os_log_t *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(*a1 + 88) + 16))(*(_QWORD *)(*a1 + 88));
  v6 = *v5;
  if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_216897000, v6, OS_LOG_TYPE_DEFAULT, "#I Entering E911 state", buf, 2u);
  }
  *(_OWORD *)__p = 0u;
  v52 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  v7 = (capabilities::ct *)qmi::MutableMessageBase::getTLV<nas::tlv::E911StateAction>(__p);
  *(_DWORD *)v7 = 0;
  if (capabilities::ct::supportsEmergencyQMIExtensions(v7))
  {
    v8 = subscriber::simSlotAsInstance();
    v9 = (const void *)a1[1];
    v10 = a1[2];
    v11 = (v10 - (uint64_t)v9) >> 2;
    if (v11 > v8)
    {
      *(_QWORD *)buf = 0;
      v54 = 0;
      v55 = 0;
      std::vector<EmergencySetupType>::__init_with_size[abi:ne180100]<EmergencySetupType*,EmergencySetupType*>(buf, v9, v10, v11);
      LODWORD(v56) = v8;
      v57 = v5;
      v12 = (const void **)__p[1];
      if (__p[1] != (void *)v52)
      {
        while (*((_BYTE *)*v12 + 8) != 19)
        {
          if (++v12 == (const void **)v52)
            goto LABEL_12;
        }
      }
      if (v12 == (const void **)v52)
      {
LABEL_12:
        v16 = operator new();
        v17 = v16;
        *(_BYTE *)(v16 + 8) = 19;
        *(_QWORD *)v16 = &off_24D5E87E8;
        *(_DWORD *)(v16 + 12) = 0;
        v14 = (unsigned int *)(v16 + 12);
        v18 = v52;
        if ((unint64_t)v52 >= *((_QWORD *)&v52 + 1))
        {
          v20 = (uint64_t)(v52 - (unint64_t)__p[1]) >> 3;
          if ((unint64_t)(v20 + 1) >> 61)
            std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
          v21 = (uint64_t)(*((_QWORD *)&v52 + 1) - (unint64_t)__p[1]) >> 2;
          if (v21 <= v20 + 1)
            v21 = v20 + 1;
          if (*((_QWORD *)&v52 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
            v22 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v22 = v21;
          if (v22)
            v23 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v52 + 8, v22);
          else
            v23 = 0;
          v24 = (uint64_t *)&v23[8 * v20];
          v25 = &v23[8 * v22];
          *v24 = v17;
          v19 = v24 + 1;
          v27 = (char *)__p[1];
          v26 = (char *)v52;
          if ((void *)v52 != __p[1])
          {
            do
            {
              v28 = *((_QWORD *)v26 - 1);
              v26 -= 8;
              *--v24 = v28;
            }
            while (v26 != v27);
            v26 = (char *)__p[1];
          }
          __p[1] = v24;
          *(_QWORD *)&v52 = v19;
          *((_QWORD *)&v52 + 1) = v25;
          if (v26)
            operator delete(v26);
        }
        else
        {
          *(_QWORD *)v52 = v16;
          v19 = (_QWORD *)(v18 + 8);
        }
        *(_QWORD *)&v52 = v19;
        v15 = v57;
      }
      else
      {
        if (!v13)
          __cxa_bad_cast();
        v14 = (unsigned int *)(v13 + 12);
        v15 = v5;
      }
      v29 = v8;
      v30 = *(void **)buf;
      v31 = *(_DWORD *)(*(_QWORD *)buf + 4 * v29);
      if (v31 == 3)
        v32 = 1;
      else
        v32 = 2 * (v31 == 4);
      *v14 = v32;
      v33 = *v15;
      if (os_log_type_enabled(*v15, OS_LOG_TYPE_DEFAULT))
      {
        v34 = nas::asString(v32);
        LODWORD(aBlock) = 136315138;
        *(_QWORD *)((char *)&aBlock + 4) = v34;
        _os_log_impl(&dword_216897000, v33, OS_LOG_TYPE_DEFAULT, "#I EmergencyType set to %s", (uint8_t *)&aBlock, 0xCu);
      }
      operator delete(v30);
    }
  }
  if ((a2 - 1) >= 3)
    v35 = 0;
  else
    v35 = a2;
  v36 = qmi::ClientRouter::get();
  qmi::ClientRouter::SendProxy::SendProxy<nas::SetE911State::Request>((uint64_t)&v49, v35, v36);
  v37 = operator new(0x30uLL);
  v37[1] = 0;
  v38 = v37 + 1;
  v37[2] = 0;
  v37[3] = v4;
  *v37 = &off_24D5E8850;
  *((_DWORD *)v37 + 8) = a2;
  v37[5] = v5;
  v59 = (char *)(v37 + 3);
  v60 = (std::__shared_weak_count *)v37;
  v39 = v50;
  v40 = MEMORY[0x24BDAC760];
  *(_QWORD *)buf = MEMORY[0x24BDAC760];
  v54 = 1174405120;
  v55 = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZZN28QMINetworkRegistrationDriver14enterE911StateEN10subscriber7SimSlotERKNSt3__16vectorI18EmergencySetupTypeNS6_9allocatorIS8_EEEEbbS5_bENK3__0clES5_EUlRKNS_12ResponseBaseEE_EEOS1_OT__block_invoke;
  v56 = &__block_descriptor_tmp_39;
  v57 = (os_log_t *)(v37 + 3);
  v58 = (std::__shared_weak_count *)v37;
  do
    v41 = __ldxr(v38);
  while (__stxr(v41 + 1, v38));
  *(_QWORD *)&aBlock = v40;
  *((_QWORD *)&aBlock + 1) = 0x40000000;
  v62 = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_31;
  v63 = &unk_24D5E8898;
  v64 = buf;
  *(_QWORD *)(v39 + 32) = _Block_copy(&aBlock);
  v42 = v58;
  if (v58)
  {
    p_shared_owners = (unint64_t *)&v58->__shared_owners_;
    do
      v44 = __ldaxr(p_shared_owners);
    while (__stlxr(v44 - 1, p_shared_owners));
    if (!v44)
    {
      ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
      std::__shared_weak_count::__release_weak(v42);
    }
  }
  v45 = v60;
  if (v60)
  {
    v46 = (unint64_t *)&v60->__shared_owners_;
    do
      v47 = __ldaxr(v46);
    while (__stlxr(v47 - 1, v46));
    if (!v47)
    {
      ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
      std::__shared_weak_count::__release_weak(v45);
    }
  }
  v48 = v50;
  v50 = 0;
  if (v48)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v50, v48);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
}

void sub_216A72EDC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a11);
  _Unwind_Resume(a1);
}

void QMINetworkRegistrationDriver::enterE911State(subscriber::SimSlot,std::vector<EmergencySetupType> const&,BOOL,BOOL,subscriber::SimSlot,BOOL)::$_1::operator()(uint64_t a1, int a2)
{
  os_log_t *v4;
  NSObject **v5;
  int v6;
  NSObject *v7;
  uint64_t v8;
  const void **v9;
  char *v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  char *v19;
  uint64_t *v20;
  char *v21;
  char *v22;
  char *v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  const void *v28;
  uint64_t v29;
  char *v30;
  __int128 v31;
  unint64_t *v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  std::__shared_weak_count *v36;
  unint64_t *p_shared_owners;
  unint64_t v38;
  std::__shared_weak_count *v39;
  unint64_t *v40;
  unint64_t v41;
  uint64_t v42;
  __int128 v43;
  void *v44[2];
  __int128 v45;
  int v46;
  uint64_t v47;
  void *__p[2];
  __int128 v49;
  char *v50;
  std::__shared_weak_count *v51;
  _QWORD aBlock[5];
  __int128 buf;
  void (*v54)(uint64_t, uint64_t);
  void *v55;
  char *v56;
  std::__shared_weak_count *v57;
  uint64_t v58;

  v58 = *MEMORY[0x24BDAC8D0];
  v4 = (os_log_t *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)a1 + 88) + 16))(*(_QWORD *)(*(_QWORD *)a1 + 88));
  v5 = v4;
  v6 = *(unsigned __int8 *)(a1 + 32);
  if (*(_BYTE *)(a1 + 32) || *(_BYTE *)(a1 + 33))
  {
    v7 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl(&dword_216897000, v7, OS_LOG_TYPE_DEFAULT, "#I Sending cell avoidance request", (uint8_t *)&buf, 2u);
      v6 = *(unsigned __int8 *)(a1 + 32);
      v7 = *v5;
    }
    if (v6)
      v8 = 3;
    else
      v8 = 2;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 134217984;
      *(_QWORD *)((char *)&buf + 4) = v8;
      _os_log_impl(&dword_216897000, v7, OS_LOG_TYPE_DEFAULT, "#I Emergency RAT mask set to 0x%08llx", (uint8_t *)&buf, 0xCu);
    }
    *(_OWORD *)__p = 0u;
    v49 = 0u;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
    v9 = (const void **)__p[1];
    if (__p[1] != (void *)v49)
    {
      while (*((_BYTE *)*v9 + 8) != 17)
      {
        if (++v9 == (const void **)v49)
          goto LABEL_17;
      }
    }
    if (v9 == (const void **)v49)
    {
LABEL_17:
      v12 = operator new();
      v13 = v12;
      *(_BYTE *)(v12 + 8) = 17;
      *(_QWORD *)v12 = &off_24D5E88E0;
      *(_QWORD *)(v12 + 16) = 0;
      v11 = (uint64_t *)(v12 + 16);
      v14 = v49;
      if ((unint64_t)v49 >= *((_QWORD *)&v49 + 1))
      {
        v16 = (uint64_t)(v49 - (unint64_t)__p[1]) >> 3;
        if ((unint64_t)(v16 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v17 = (uint64_t)(*((_QWORD *)&v49 + 1) - (unint64_t)__p[1]) >> 2;
        if (v17 <= v16 + 1)
          v17 = v16 + 1;
        if (*((_QWORD *)&v49 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v18 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v18 = v17;
        if (v18)
          v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v49 + 8, v18);
        else
          v19 = 0;
        v20 = (uint64_t *)&v19[8 * v16];
        v21 = &v19[8 * v18];
        *v20 = v13;
        v15 = v20 + 1;
        v23 = (char *)__p[1];
        v22 = (char *)v49;
        if ((void *)v49 != __p[1])
        {
          do
          {
            v24 = *((_QWORD *)v22 - 1);
            v22 -= 8;
            *--v20 = v24;
          }
          while (v22 != v23);
          v22 = (char *)__p[1];
        }
        __p[1] = v20;
        *(_QWORD *)&v49 = v15;
        *((_QWORD *)&v49 + 1) = v21;
        if (v22)
          operator delete(v22);
      }
      else
      {
        *(_QWORD *)v49 = v12;
        v15 = (_QWORD *)(v14 + 8);
      }
      *(_QWORD *)&v49 = v15;
    }
    else
    {
      if (!v10)
        __cxa_bad_cast();
      v11 = (uint64_t *)(v10 + 16);
    }
    *v11 = v8;
    if ((a2 - 1) >= 3)
      v25 = 0;
    else
      v25 = a2;
    v26 = qmi::ClientRouter::get();
    v46 = v25;
    v27 = operator new();
    *(_QWORD *)v27 = v26;
    *(_QWORD *)(v27 + 8) = QMIServiceMsg::create();
    *(_DWORD *)(v27 + 16) = 25000;
    *(_QWORD *)(v27 + 24) = 0;
    *(_QWORD *)(v27 + 32) = 0;
    v47 = v27;
    LODWORD(v43) = a2;
    v28 = *(const void **)(a1 + 48);
    *((_QWORD *)&v43 + 1) = v5;
    v44[0] = *(void **)(a1 + 40);
    v45 = 0uLL;
    v29 = *(_QWORD *)(a1 + 56);
    v44[1] = 0;
    std::vector<EmergencySetupType>::__init_with_size[abi:ne180100]<EmergencySetupType*,EmergencySetupType*>(&v44[1], v28, v29, (v29 - (uint64_t)v28) >> 2);
    v30 = (char *)operator new(0x48uLL);
    v31 = *(_OWORD *)v44;
    *(_OWORD *)(v30 + 24) = v43;
    *((_QWORD *)v30 + 1) = 0;
    v32 = (unint64_t *)(v30 + 8);
    *((_QWORD *)v30 + 2) = 0;
    *(_QWORD *)v30 = &off_24D5E8948;
    *(_OWORD *)(v30 + 40) = v31;
    *(_OWORD *)(v30 + 56) = v45;
    v45 = 0uLL;
    v44[1] = 0;
    v50 = v30 + 24;
    v51 = (std::__shared_weak_count *)v30;
    v33 = v47;
    v34 = MEMORY[0x24BDAC760];
    *(_QWORD *)&buf = MEMORY[0x24BDAC760];
    *((_QWORD *)&buf + 1) = 1174405120;
    v54 = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZZN28QMINetworkRegistrationDriver14enterE911StateEN10subscriber7SimSlotERKNSt3__16vectorI18EmergencySetupTypeNS6_9allocatorIS8_EEEEbbS5_bENK3__1clES5_EUlRKNS_12ResponseBaseEE_EEOS1_OT__block_invoke;
    v55 = &__block_descriptor_tmp_11_15;
    v56 = v30 + 24;
    v57 = (std::__shared_weak_count *)v30;
    do
      v35 = __ldxr(v32);
    while (__stxr(v35 + 1, v32));
    aBlock[0] = v34;
    aBlock[1] = 0x40000000;
    aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_31;
    aBlock[3] = &unk_24D5E8898;
    aBlock[4] = &buf;
    *(_QWORD *)(v33 + 32) = _Block_copy(aBlock);
    v36 = v57;
    if (v57)
    {
      p_shared_owners = (unint64_t *)&v57->__shared_owners_;
      do
        v38 = __ldaxr(p_shared_owners);
      while (__stlxr(v38 - 1, p_shared_owners));
      if (!v38)
      {
        ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
        std::__shared_weak_count::__release_weak(v36);
      }
    }
    v39 = v51;
    if (v51)
    {
      v40 = (unint64_t *)&v51->__shared_owners_;
      do
        v41 = __ldaxr(v40);
      while (__stlxr(v41 - 1, v40));
      if (!v41)
      {
        ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
        std::__shared_weak_count::__release_weak(v39);
      }
    }
    if (v44[1])
      operator delete(v44[1]);
    v42 = v47;
    v47 = 0;
    if (v42)
      std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v47, v42);
    qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
  }
  else
  {
    QMINetworkRegistrationDriver::enterE911State(subscriber::SimSlot,std::vector<EmergencySetupType> const&,BOOL,BOOL,subscriber::SimSlot,BOOL)::$_0::operator()((_QWORD *)(a1 + 40), a2);
  }
}

void sub_216A73424(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22)
{
  uint64_t v22;
  uint64_t v23;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v22);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a22);
  if (a16)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v23, a16);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a17);
  _Unwind_Resume(a1);
}

_QWORD *QMINetworkRegistrationDriver::enterE911State(subscriber::SimSlot,std::vector<EmergencySetupType> const&,BOOL,BOOL,subscriber::SimSlot,BOOL)::$_1::~$_1(_QWORD *a1)
{
  void *v2;
  void *v3;

  v2 = (void *)a1[6];
  if (v2)
  {
    a1[7] = v2;
    operator delete(v2);
  }
  v3 = (void *)a1[1];
  if (v3)
  {
    a1[2] = v3;
    operator delete(v3);
  }
  return a1;
}

_QWORD *QMINetworkRegistrationDriver::enterE911State(subscriber::SimSlot,std::vector<EmergencySetupType> const&,BOOL,BOOL,subscriber::SimSlot,BOOL)::$_2::~$_2(_QWORD *a1)
{
  void *v2;
  void *v3;
  void *v4;

  v2 = (void *)a1[10];
  if (v2)
  {
    a1[11] = v2;
    operator delete(v2);
  }
  v3 = (void *)a1[7];
  if (v3)
  {
    a1[8] = v3;
    operator delete(v3);
  }
  v4 = (void *)a1[2];
  if (v4)
  {
    a1[3] = v4;
    operator delete(v4);
  }
  return a1;
}

uint64_t QMINetworkRegistrationDriver::exitE911State(uint64_t a1, uint64_t a2)
{
  uint64_t isValidSimSlot;
  os_log_t *v5;
  NSObject *v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  uint64_t v19;
  NSObject *v20;
  uint64_t v22;
  uint64_t v23;
  _OWORD v24[2];
  _QWORD *v25;
  std::__shared_weak_count *v26;
  _QWORD aBlock[5];
  __int128 buf;
  void (*v29)(uint64_t, uint64_t);
  void *v30;
  _QWORD *v31;
  std::__shared_weak_count *v32;
  uint64_t v33;

  v33 = *MEMORY[0x24BDAC8D0];
  isValidSimSlot = subscriber::isValidSimSlot();
  if ((isValidSimSlot & 1) != 0)
  {
    v5 = (os_log_t *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 88) + 16))(*(_QWORD *)(a1 + 88), a2);
    v6 = *v5;
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl(&dword_216897000, v6, OS_LOG_TYPE_DEFAULT, "#I Exiting E911 state", (uint8_t *)&buf, 2u);
    }
    memset(v24, 0, sizeof(v24));
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v24);
    *(_DWORD *)qmi::MutableMessageBase::getTLV<nas::tlv::E911StateAction>(v24) = 2;
    if ((a2 - 1) >= 3)
      LODWORD(a2) = 0;
    v7 = qmi::ClientRouter::get();
    qmi::ClientRouter::SendProxy::SendProxy<nas::SetE911State::Request>((uint64_t)&v22, a2, v7);
    v8 = (std::__shared_weak_count *)operator new(0x28uLL);
    v8->__shared_owners_ = 0;
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    v8->__shared_weak_owners_ = 0;
    v8->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5EA0A8;
    v8[1].__vftable = (std::__shared_weak_count_vtbl *)a1;
    v8[1].__shared_owners_ = (uint64_t)v5;
    v25 = &v8[1].__vftable;
    v26 = v8;
    v10 = v23;
    v11 = MEMORY[0x24BDAC760];
    *(_QWORD *)&buf = MEMORY[0x24BDAC760];
    *((_QWORD *)&buf + 1) = 1174405120;
    v29 = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver13exitE911StateEN10subscriber7SimSlotEE3__1EEOS1_OT__block_invoke;
    v30 = &__block_descriptor_tmp_63_4;
    v31 = &v8[1].__vftable;
    v32 = v8;
    do
      v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
    aBlock[0] = v11;
    aBlock[1] = 0x40000000;
    aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_31;
    aBlock[3] = &unk_24D5E8898;
    aBlock[4] = &buf;
    *(_QWORD *)(v10 + 32) = _Block_copy(aBlock);
    v13 = v32;
    if (v32)
    {
      v14 = (unint64_t *)&v32->__shared_owners_;
      do
        v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }
    v16 = v26;
    if (v26)
    {
      v17 = (unint64_t *)&v26->__shared_owners_;
      do
        v18 = __ldaxr(v17);
      while (__stlxr(v18 - 1, v17));
      if (!v18)
      {
        ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
        std::__shared_weak_count::__release_weak(v16);
      }
    }
    v19 = v23;
    v23 = 0;
    if (v19)
      std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v23, v19);
    qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v24);
  }
  else
  {
    v20 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_FAULT))
    {
      LODWORD(buf) = 136315138;
      *(_QWORD *)((char *)&buf + 4) = subscriber::asString();
      _os_log_fault_impl(&dword_216897000, v20, OS_LOG_TYPE_FAULT, "Unhandled SIM slot when existing E911 state: %s", (uint8_t *)&buf, 0xCu);
    }
  }
  return isValidSimSlot;
}

void sub_216A737F8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  va_list va;
  uint64_t v7;
  va_list va1;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  va_list va2;

  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v5 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v7 = va_arg(va2, _QWORD);
  v9 = va_arg(va2, _QWORD);
  v10 = va_arg(va2, _QWORD);
  v11 = va_arg(va2, _QWORD);
  v12 = va_arg(va2, _QWORD);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v2);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va2);
  v4 = v5;
  v5 = 0;
  if (v4)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)va, v4);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va1);
  _Unwind_Resume(a1);
}

void QMINetworkRegistrationDriver::setImsProceedWithSubscriptionChange(uint64_t a1)
{
  os_log_t *v1;
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  uint64_t v7;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _OWORD v17[2];
  uint8_t buf[8];
  uint64_t v19;
  void (*v20)(uint64_t, uint64_t);
  void *v21;
  _QWORD *v22;
  std::__shared_weak_count *v23;
  _QWORD *v24;
  std::__shared_weak_count *v25;
  _QWORD aBlock[5];

  v1 = (os_log_t *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 88) + 16))(*(_QWORD *)(a1 + 88));
  v2 = *v1;
  if (os_log_type_enabled(*v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_216897000, v2, OS_LOG_TYPE_DEFAULT, "#I Indicating to baseband that it is OK to proceed with subscription change", buf, 2u);
  }
  memset(v17, 0, sizeof(v17));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v17);
  v3 = qmi::ClientRouter::get();
  v4 = operator new();
  *(_QWORD *)v4 = v3;
  *(_QWORD *)(v4 + 8) = QMIServiceMsg::create();
  *(_DWORD *)(v4 + 16) = 25000;
  *(_QWORD *)(v4 + 24) = 0;
  *(_QWORD *)(v4 + 32) = 0;
  v16 = v4;
  v5 = (std::__shared_weak_count *)operator new(0x20uLL);
  v5->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v5->__shared_owners_;
  v5->__shared_weak_owners_ = 0;
  v5->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5EA128;
  v5[1].__vftable = (std::__shared_weak_count_vtbl *)v1;
  v24 = &v5[1].__vftable;
  v25 = v5;
  v7 = MEMORY[0x24BDAC760];
  *(_QWORD *)buf = MEMORY[0x24BDAC760];
  v19 = 1174405120;
  v20 = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver35setImsProceedWithSubscriptionChangeEN10subscriber7SimSlotEE3__0EEOS1_OT__block_invoke;
  v21 = &__block_descriptor_tmp_64_5;
  v22 = &v5[1].__vftable;
  v23 = v5;
  do
    v8 = __ldxr(p_shared_owners);
  while (__stxr(v8 + 1, p_shared_owners));
  aBlock[0] = v7;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_31;
  aBlock[3] = &unk_24D5E8898;
  aBlock[4] = buf;
  *(_QWORD *)(v4 + 32) = _Block_copy(aBlock);
  v9 = v23;
  if (v23)
  {
    v10 = (unint64_t *)&v23->__shared_owners_;
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  v12 = v25;
  if (v25)
  {
    v13 = (unint64_t *)&v25->__shared_owners_;
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  v15 = v16;
  v16 = 0;
  if (v15)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v16, v15);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v17);
}

void sub_216A73A80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  va_list va;

  va_start(va, a3);
  v6 = v4;
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v6);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v5 - 88);
  if (a3)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v3, a3);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

void QMINetworkRegistrationDriver::enableIms(uint64_t a1, int a2, int a3)
{
  const void **v6;
  char *v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  char *v16;
  uint64_t *v17;
  char *v18;
  char *v19;
  char *v20;
  uint64_t v21;
  char v22;
  int v23;
  uint64_t v24;
  _QWORD *v25;
  unint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  std::__shared_weak_count *v30;
  unint64_t *p_shared_owners;
  unint64_t v32;
  std::__shared_weak_count *v33;
  unint64_t *v34;
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  void *__p[2];
  __int128 v40;
  _QWORD v41[5];
  std::__shared_weak_count *v42;
  char *v43;
  std::__shared_weak_count *v44;
  _QWORD aBlock[5];

  *(_OWORD *)__p = 0u;
  v40 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  v6 = (const void **)__p[1];
  if (__p[1] != (void *)v40)
  {
    while (*((_BYTE *)*v6 + 8) != 51)
    {
      if (++v6 == (const void **)v40)
        goto LABEL_8;
    }
  }
  if (v6 == (const void **)v40)
  {
LABEL_8:
    v9 = operator new();
    v10 = v9;
    *(_WORD *)(v9 + 8) = 51;
    *(_QWORD *)v9 = &off_24D5EA238;
    v11 = v40;
    if ((unint64_t)v40 >= *((_QWORD *)&v40 + 1))
    {
      v13 = (uint64_t)(v40 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v13 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v14 = (uint64_t)(*((_QWORD *)&v40 + 1) - (unint64_t)__p[1]) >> 2;
      if (v14 <= v13 + 1)
        v14 = v13 + 1;
      if (*((_QWORD *)&v40 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v15 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v15 = v14;
      if (v15)
        v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v40 + 8, v15);
      else
        v16 = 0;
      v17 = (uint64_t *)&v16[8 * v13];
      v18 = &v16[8 * v15];
      *v17 = v10;
      v12 = v17 + 1;
      v20 = (char *)__p[1];
      v19 = (char *)v40;
      if ((void *)v40 != __p[1])
      {
        do
        {
          v21 = *((_QWORD *)v19 - 1);
          v19 -= 8;
          *--v17 = v21;
        }
        while (v19 != v20);
        v19 = (char *)__p[1];
      }
      __p[1] = v17;
      *(_QWORD *)&v40 = v12;
      *((_QWORD *)&v40 + 1) = v18;
      if (v19)
        operator delete(v19);
    }
    else
    {
      *(_QWORD *)v40 = v9;
      v12 = (_QWORD *)(v11 + 8);
    }
    v8 = (char *)(v10 + 9);
    *(_QWORD *)&v40 = v12;
  }
  else
  {
    if (!v7)
      __cxa_bad_cast();
    v8 = v7 + 9;
  }
  v22 = a3 == 1;
  if (a3 == 2)
    v22 = 2;
  *v8 = v22;
  if ((a2 - 1) >= 3)
    v23 = 0;
  else
    v23 = a2;
  v24 = qmi::ClientRouter::get();
  qmi::ClientRouter::SendProxy::SendProxy<nas::SetSystemSelectionPreference::Request>((uint64_t)&v37, v23, v24);
  v25 = operator new(0x28uLL);
  v25[1] = 0;
  v26 = v25 + 1;
  v25[2] = 0;
  *v25 = &off_24D5EA2A0;
  v25[3] = a1;
  *((_DWORD *)v25 + 8) = a2;
  v43 = (char *)(v25 + 3);
  v44 = (std::__shared_weak_count *)v25;
  v27 = v38;
  v28 = MEMORY[0x24BDAC760];
  v41[0] = MEMORY[0x24BDAC760];
  v41[1] = 1174405120;
  v41[2] = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver9enableImsEN10subscriber7SimSlotE19ImsStateForBasebandE3__1EEOS1_OT__block_invoke;
  v41[3] = &__block_descriptor_tmp_67_10;
  v41[4] = v25 + 3;
  v42 = (std::__shared_weak_count *)v25;
  do
    v29 = __ldxr(v26);
  while (__stxr(v29 + 1, v26));
  aBlock[0] = v28;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_31;
  aBlock[3] = &unk_24D5E8898;
  aBlock[4] = v41;
  *(_QWORD *)(v27 + 32) = _Block_copy(aBlock);
  v30 = v42;
  if (v42)
  {
    p_shared_owners = (unint64_t *)&v42->__shared_owners_;
    do
      v32 = __ldaxr(p_shared_owners);
    while (__stlxr(v32 - 1, p_shared_owners));
    if (!v32)
    {
      ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
      std::__shared_weak_count::__release_weak(v30);
    }
  }
  v33 = v44;
  if (v44)
  {
    v34 = (unint64_t *)&v44->__shared_owners_;
    do
      v35 = __ldaxr(v34);
    while (__stlxr(v35 - 1, v34));
    if (!v35)
    {
      ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
      std::__shared_weak_count::__release_weak(v33);
    }
  }
  v36 = v38;
  v38 = 0;
  if (v36)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v38, v36);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
}

void sub_216A73E1C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  va_list va;
  uint64_t v7;
  va_list va1;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  va_list va2;

  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v5 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v7 = va_arg(va2, _QWORD);
  v9 = va_arg(va2, _QWORD);
  v10 = va_arg(va2, _QWORD);
  v11 = va_arg(va2, _QWORD);
  v12 = va_arg(va2, _QWORD);
  v13 = va_arg(va2, _QWORD);
  v14 = va_arg(va2, _QWORD);
  v15 = va_arg(va2, _QWORD);
  v16 = va_arg(va2, _QWORD);
  v17 = va_arg(va2, _QWORD);
  v18 = va_arg(va2, _QWORD);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v2);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va2);
  v4 = v5;
  v5 = 0;
  if (v4)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)va, v4);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va1);
  _Unwind_Resume(a1);
}

void QMINetworkRegistrationDriver::updateVoNRState(uint64_t a1, int a2, int a3)
{
  const void **v6;
  char *v7;
  _DWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  char *v16;
  uint64_t *v17;
  char *v18;
  char *v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _QWORD *v24;
  unint64_t *v25;
  uint64_t v26;
  unint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *p_shared_owners;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;
  void *__p[2];
  __int128 v37;
  _QWORD v38[5];
  std::__shared_weak_count *v39;
  char *v40;
  std::__shared_weak_count *v41;
  _QWORD aBlock[5];

  *(_OWORD *)__p = 0u;
  v37 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  v6 = (const void **)__p[1];
  if (__p[1] != (void *)v37)
  {
    while (*((_BYTE *)*v6 + 8) != 1)
    {
      if (++v6 == (const void **)v37)
        goto LABEL_8;
    }
  }
  if (v6 == (const void **)v37)
  {
LABEL_8:
    v9 = operator new();
    v10 = v9;
    *(_BYTE *)(v9 + 8) = 1;
    *(_QWORD *)v9 = &off_24D5EA308;
    *(_DWORD *)(v9 + 12) = 0;
    v8 = (_DWORD *)(v9 + 12);
    v11 = v37;
    if ((unint64_t)v37 >= *((_QWORD *)&v37 + 1))
    {
      v13 = (uint64_t)(v37 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v13 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v14 = (uint64_t)(*((_QWORD *)&v37 + 1) - (unint64_t)__p[1]) >> 2;
      if (v14 <= v13 + 1)
        v14 = v13 + 1;
      if (*((_QWORD *)&v37 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v15 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v15 = v14;
      if (v15)
        v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v37 + 8, v15);
      else
        v16 = 0;
      v17 = (uint64_t *)&v16[8 * v13];
      v18 = &v16[8 * v15];
      *v17 = v10;
      v12 = v17 + 1;
      v20 = (char *)__p[1];
      v19 = (char *)v37;
      if ((void *)v37 != __p[1])
      {
        do
        {
          v21 = *((_QWORD *)v19 - 1);
          v19 -= 8;
          *--v17 = v21;
        }
        while (v19 != v20);
        v19 = (char *)__p[1];
      }
      __p[1] = v17;
      *(_QWORD *)&v37 = v12;
      *((_QWORD *)&v37 + 1) = v18;
      if (v19)
        operator delete(v19);
    }
    else
    {
      *(_QWORD *)v37 = v9;
      v12 = (_QWORD *)(v11 + 8);
    }
    *(_QWORD *)&v37 = v12;
  }
  else
  {
    if (!v7)
      __cxa_bad_cast();
    v8 = v7 + 12;
  }
  *v8 = a3 == 1;
  v22 = qmi::ClientRouter::get();
  v23 = operator new();
  *(_QWORD *)v23 = v22;
  *(_QWORD *)(v23 + 8) = QMIServiceMsg::create();
  *(_DWORD *)(v23 + 16) = 25000;
  *(_QWORD *)(v23 + 24) = 0;
  *(_QWORD *)(v23 + 32) = 0;
  v35 = v23;
  v24 = operator new(0x28uLL);
  v24[1] = 0;
  v25 = v24 + 1;
  v24[2] = 0;
  *v24 = &off_24D5EA370;
  v24[3] = a1;
  *((_DWORD *)v24 + 8) = a2;
  v40 = (char *)(v24 + 3);
  v41 = (std::__shared_weak_count *)v24;
  v26 = MEMORY[0x24BDAC760];
  v38[0] = MEMORY[0x24BDAC760];
  v38[1] = 1174405120;
  v38[2] = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver15updateVoNRStateEN10subscriber7SimSlotE20VoNRStateForBasebandE3__1EEOS1_OT__block_invoke;
  v38[3] = &__block_descriptor_tmp_68_5;
  v38[4] = v24 + 3;
  v39 = (std::__shared_weak_count *)v24;
  do
    v27 = __ldxr(v25);
  while (__stxr(v27 + 1, v25));
  aBlock[0] = v26;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_31;
  aBlock[3] = &unk_24D5E8898;
  aBlock[4] = v38;
  *(_QWORD *)(v23 + 32) = _Block_copy(aBlock);
  v28 = v39;
  if (v39)
  {
    p_shared_owners = (unint64_t *)&v39->__shared_owners_;
    do
      v30 = __ldaxr(p_shared_owners);
    while (__stlxr(v30 - 1, p_shared_owners));
    if (!v30)
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
  }
  v31 = v41;
  if (v41)
  {
    v32 = (unint64_t *)&v41->__shared_owners_;
    do
      v33 = __ldaxr(v32);
    while (__stlxr(v33 - 1, v32));
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
      std::__shared_weak_count::__release_weak(v31);
    }
  }
  v34 = v35;
  v35 = 0;
  if (v34)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v35, v34);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
}

void sub_216A741C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;
  va_list va;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v6 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v3);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  if (a3)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v4, a3);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

void QMINetworkRegistrationDriver::sendDataRoaming(uint64_t a1, int a2, uint64_t a3)
{
  unsigned int *v5;
  unsigned int *v6;
  const void **v8;
  char *v9;
  _BYTE *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  char *v18;
  uint64_t *v19;
  char *v20;
  char *v21;
  char *v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  _QWORD *v26;
  unint64_t *v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *p_shared_owners;
  unint64_t v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  void *__p[2];
  __int128 v41;
  unsigned int *v42;
  uint64_t v43;
  uint64_t (*v44)(uint64_t, uint64_t);
  void *v45;
  char *v46;
  std::__shared_weak_count *v47;
  char *v48;
  std::__shared_weak_count *v49;
  _QWORD aBlock[5];

  if (a2 == 3)
  {
    subscriber::makeSimSlotRange();
    v5 = v42;
    if (v42 != (unsigned int *)v43)
    {
      while ((((uint64_t (*)(_QWORD))v44)(*v5) & 1) == 0)
      {
        if (++v5 == (unsigned int *)v43)
        {
          v5 = (unsigned int *)v43;
          break;
        }
      }
LABEL_6:
      while (v5 != (unsigned int *)v43)
      {
        v6 = v5 + 1;
        (*(void (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)a1 + 240))(a1, *v5, a3);
        v5 = (unsigned int *)v43;
        if (v6 != (unsigned int *)v43)
        {
          v5 = v6;
          while ((((uint64_t (*)(_QWORD))v44)(*v5) & 1) == 0)
          {
            if (++v5 == (unsigned int *)v43)
            {
              v5 = (unsigned int *)v43;
              goto LABEL_6;
            }
          }
        }
      }
    }
  }
  else
  {
    *(_OWORD *)__p = 0u;
    v41 = 0u;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
    v8 = (const void **)__p[1];
    if (__p[1] != (void *)v41)
    {
      while (*((_BYTE *)*v8 + 8) != 52)
      {
        if (++v8 == (const void **)v41)
          goto LABEL_19;
      }
    }
    if (v8 == (const void **)v41)
    {
LABEL_19:
      v11 = operator new();
      v12 = v11;
      *(_WORD *)(v11 + 8) = 52;
      *(_QWORD *)v11 = &off_24D5EA3D8;
      v13 = v41;
      if ((unint64_t)v41 >= *((_QWORD *)&v41 + 1))
      {
        v15 = (uint64_t)(v41 - (unint64_t)__p[1]) >> 3;
        if ((unint64_t)(v15 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v16 = (uint64_t)(*((_QWORD *)&v41 + 1) - (unint64_t)__p[1]) >> 2;
        if (v16 <= v15 + 1)
          v16 = v15 + 1;
        if (*((_QWORD *)&v41 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v17 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v17 = v16;
        if (v17)
          v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v41 + 8, v17);
        else
          v18 = 0;
        v19 = (uint64_t *)&v18[8 * v15];
        v20 = &v18[8 * v17];
        *v19 = v12;
        v14 = v19 + 1;
        v22 = (char *)__p[1];
        v21 = (char *)v41;
        if ((void *)v41 != __p[1])
        {
          do
          {
            v23 = *((_QWORD *)v21 - 1);
            v21 -= 8;
            *--v19 = v23;
          }
          while (v21 != v22);
          v21 = (char *)__p[1];
        }
        __p[1] = v19;
        *(_QWORD *)&v41 = v14;
        *((_QWORD *)&v41 + 1) = v20;
        if (v21)
          operator delete(v21);
      }
      else
      {
        *(_QWORD *)v41 = v11;
        v14 = (_QWORD *)(v13 + 8);
      }
      v10 = (_BYTE *)(v12 + 9);
      *(_QWORD *)&v41 = v14;
    }
    else
    {
      if (!v9)
        __cxa_bad_cast();
      v10 = v9 + 9;
    }
    *v10 = a3;
    if ((a2 - 1) >= 3)
      v24 = 0;
    else
      v24 = a2;
    v25 = qmi::ClientRouter::get();
    qmi::ClientRouter::SendProxy::SendProxy<nas::SetSystemSelectionPreference::Request>((uint64_t)&v38, v24, v25);
    v26 = operator new(0x28uLL);
    v26[1] = 0;
    v27 = v26 + 1;
    v26[2] = 0;
    *v26 = &off_24D5EA440;
    v26[3] = a1;
    *((_DWORD *)v26 + 8) = a2;
    v48 = (char *)(v26 + 3);
    v49 = (std::__shared_weak_count *)v26;
    v28 = v39;
    v29 = MEMORY[0x24BDAC760];
    v42 = (unsigned int *)MEMORY[0x24BDAC760];
    v43 = 1174405120;
    v44 = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver15sendDataRoamingEN10subscriber7SimSlotEbE3__1EEOS1_OT__block_invoke;
    v45 = &__block_descriptor_tmp_69_8;
    v46 = (char *)(v26 + 3);
    v47 = (std::__shared_weak_count *)v26;
    do
      v30 = __ldxr(v27);
    while (__stxr(v30 + 1, v27));
    aBlock[0] = v29;
    aBlock[1] = 0x40000000;
    aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_31;
    aBlock[3] = &unk_24D5E8898;
    aBlock[4] = &v42;
    *(_QWORD *)(v28 + 32) = _Block_copy(aBlock);
    v31 = v47;
    if (v47)
    {
      p_shared_owners = (unint64_t *)&v47->__shared_owners_;
      do
        v33 = __ldaxr(p_shared_owners);
      while (__stlxr(v33 - 1, p_shared_owners));
      if (!v33)
      {
        ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
        std::__shared_weak_count::__release_weak(v31);
      }
    }
    v34 = v49;
    if (v49)
    {
      v35 = (unint64_t *)&v49->__shared_owners_;
      do
        v36 = __ldaxr(v35);
      while (__stlxr(v36 - 1, v35));
      if (!v36)
      {
        ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
        std::__shared_weak_count::__release_weak(v34);
      }
    }
    v37 = v39;
    v39 = 0;
    if (v37)
      std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v39, v37);
    qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
  }
}

void sub_216A745F0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  va_list va;
  uint64_t v7;
  va_list va1;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  va_list va2;

  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v5 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v7 = va_arg(va2, _QWORD);
  v9 = va_arg(va2, _QWORD);
  v10 = va_arg(va2, _QWORD);
  v11 = va_arg(va2, _QWORD);
  v12 = va_arg(va2, _QWORD);
  v13 = va_arg(va2, _QWORD);
  v14 = va_arg(va2, _QWORD);
  v15 = va_arg(va2, _QWORD);
  v16 = va_arg(va2, _QWORD);
  v17 = va_arg(va2, _QWORD);
  v18 = va_arg(va2, _QWORD);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v2);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va2);
  v4 = v5;
  v5 = 0;
  if (v4)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)va, v4);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va1);
  _Unwind_Resume(a1);
}

BOOL QMINetworkRegistrationDriver::updateIMSStatus(uint64_t a1, uint64_t a2, int a3, int a4, char a5, int a6)
{
  os_log_t *v10;
  char *v11;
  char *v12;
  char v13;
  NSObject *v14;
  uint64_t v15;
  char *v16;
  int v17;
  const void **v18;
  char *v19;
  char **v20;
  char *v21;
  uint64_t v22;
  _QWORD *v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  char *v27;
  char *v28;
  char *v29;
  char *v30;
  uint64_t v31;
  unint64_t v32;
  char *v33;
  char *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  char *v39;
  char *v40;
  char *v41;
  char *v42;
  int v43;
  char v44;
  unint64_t v45;
  char *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  char *v51;
  char *v52;
  char *v53;
  char *v54;
  int v55;
  char v56;
  char v57;
  char v58;
  int v59;
  int v60;
  NSObject *v61;
  const char *v62;
  const void **v63;
  const void **v64;
  const void **v65;
  char *v66;
  int *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  unint64_t v72;
  unint64_t v73;
  char *v74;
  NSObject *v75;
  const void **v76;
  char *v77;
  char *v78;
  char *v79;
  const void *v80;
  char *v81;
  _DWORD *v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  _QWORD *v86;
  uint64_t v87;
  unint64_t v88;
  unint64_t v89;
  char *v90;
  uint64_t *v91;
  char *v92;
  char *v93;
  char *v94;
  uint64_t v95;
  int v96;
  uint64_t v97;
  uint64_t v98;
  std::__shared_weak_count *v99;
  unint64_t *p_shared_owners;
  uint64_t v101;
  unint64_t v102;
  std::__shared_weak_count *v103;
  unint64_t *v104;
  unint64_t v105;
  std::__shared_weak_count *v106;
  unint64_t *v107;
  unint64_t v108;
  uint64_t v109;
  uint64_t v111;
  void *__p[2];
  __int128 v113;
  _QWORD *v114;
  std::__shared_weak_count *v115;
  _QWORD aBlock[5];
  _BYTE buf[24];
  void *v118;
  _QWORD *v119;
  std::__shared_weak_count *v120;
  uint64_t v121;

  v121 = *MEMORY[0x24BDAC8D0];
  v10 = (os_log_t *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 88) + 16))(*(_QWORD *)(a1 + 88));
  *(_OWORD *)__p = 0u;
  v113 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  v11 = qmi::MutableMessageBase::getTLV<nas::tlv::IpDataMode>(__p);
  v12 = v11;
  switch(a4)
  {
    case 1:
    case 2:
      v13 = 4;
      goto LABEL_15;
    case 3:
    case 4:
    case 5:
      if (a3 == 9)
        v13 = 9;
      else
        v13 = 5;
      goto LABEL_15;
    case 13:
      v13 = 2;
      goto LABEL_15;
    case 14:
      goto LABEL_7;
    case 16:
      if ((capabilities::ct::supports5G((capabilities::ct *)v11) & 1) != 0)
      {
LABEL_7:
        v13 = 8;
        goto LABEL_15;
      }
      v75 = *v10;
      if (!os_log_type_enabled(*v10, OS_LOG_TYPE_ERROR))
        goto LABEL_16;
      *(_WORD *)buf = 0;
      goto LABEL_107;
    case 17:
      if ((capabilities::ct::supports5G((capabilities::ct *)v11) & 1) != 0)
      {
        v13 = 12;
LABEL_15:
        *v12 = v13;
      }
      else
      {
        v75 = *v10;
        if (os_log_type_enabled(*v10, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)buf = 0;
LABEL_107:
          _os_log_error_impl(&dword_216897000, v75, OS_LOG_TYPE_ERROR, "Device doesn't support NR", buf, 2u);
        }
      }
LABEL_16:
      v16 = qmi::MutableMessageBase::getTLV<nas::tlv::IpDataMode>(__p);
      v17 = *v16;
      if (!*v16)
        goto LABEL_157;
      v18 = (const void **)__p[1];
      if (__p[1] == (void *)v113)
        goto LABEL_21;
      break;
    case 18:
      if (!capabilities::ct::supports5G((capabilities::ct *)v11))
        goto LABEL_10;
      v13 = 6;
      goto LABEL_15;
    default:
LABEL_10:
      v14 = *v10;
      if (os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
      {
        v15 = asString();
        *(_DWORD *)buf = 136315138;
        *(_QWORD *)&buf[4] = v15;
        _os_log_impl(&dword_216897000, v14, OS_LOG_TYPE_DEFAULT, "#I Cannot update IMS status - Invalid Data Mode: (%s)", buf, 0xCu);
      }
      goto LABEL_16;
  }
  while (*((_BYTE *)*v18 + 8) != 2)
  {
    if (++v18 == (const void **)v113)
      goto LABEL_24;
  }
LABEL_21:
  if (v18 == (const void **)v113)
  {
LABEL_24:
    v19 = (char *)operator new();
    v21 = v19;
    v19[8] = 2;
    *((_QWORD *)v19 + 2) = 0;
    v20 = (char **)(v19 + 16);
    *(_QWORD *)v19 = &off_24D5EA4F8;
    *((_QWORD *)v19 + 3) = 0;
    *((_QWORD *)v19 + 4) = 0;
    v22 = v113;
    if ((unint64_t)v113 >= *((_QWORD *)&v113 + 1))
    {
      v24 = (uint64_t)(v113 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v24 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v25 = (uint64_t)(*((_QWORD *)&v113 + 1) - (unint64_t)__p[1]) >> 2;
      if (v25 <= v24 + 1)
        v25 = v24 + 1;
      if (*((_QWORD *)&v113 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v26 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v26 = v25;
      if (v26)
        v27 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v113 + 8, v26);
      else
        v27 = 0;
      v28 = &v27[8 * v24];
      v29 = &v27[8 * v26];
      *(_QWORD *)v28 = v21;
      v23 = v28 + 8;
      v30 = (char *)__p[1];
      v19 = (char *)v113;
      if ((void *)v113 != __p[1])
      {
        do
        {
          v31 = *((_QWORD *)v19 - 1);
          v19 -= 8;
          *((_QWORD *)v28 - 1) = v31;
          v28 -= 8;
        }
        while (v19 != v30);
        v19 = (char *)__p[1];
      }
      __p[1] = v28;
      *(_QWORD *)&v113 = v23;
      *((_QWORD *)&v113 + 1) = v29;
      if (v19)
        operator delete(v19);
    }
    else
    {
      *(_QWORD *)v113 = v19;
      v23 = (_QWORD *)(v22 + 8);
    }
    *(_QWORD *)&v113 = v23;
    goto LABEL_41;
  }
  if (!v19)
    __cxa_bad_cast();
  v20 = (char **)(v19 + 16);
LABEL_41:
  v32 = (unint64_t)v20[2];
  v33 = v20[1];
  if ((unint64_t)v33 >= v32)
  {
    v35 = (v33 - *v20) >> 3;
    if ((unint64_t)(v35 + 1) >> 61)
      goto LABEL_158;
    v36 = v32 - (_QWORD)*v20;
    v37 = v36 >> 2;
    if (v36 >> 2 <= (unint64_t)(v35 + 1))
      v37 = v35 + 1;
    if ((unint64_t)v36 >= 0x7FFFFFFFFFFFFFF8)
      v38 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v38 = v37;
    if (v38)
      v39 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(v20 + 2), v38);
    else
      v39 = 0;
    v40 = &v39[8 * v35];
    v41 = &v39[8 * v38];
    *(_QWORD *)v40 = 0;
    v34 = v40 + 8;
    v42 = *v20;
    v19 = v20[1];
    if (v19 != *v20)
    {
      do
      {
        v43 = *((_DWORD *)v19 - 2);
        v19 -= 8;
        v44 = v19[4];
        *((_DWORD *)v40 - 2) = v43;
        v40 -= 8;
        v40[4] = v44;
      }
      while (v19 != v42);
      v19 = *v20;
    }
    *v20 = v40;
    v20[1] = v34;
    v20[2] = v41;
    if (v19)
      operator delete(v19);
  }
  else
  {
    *(_QWORD *)v33 = 0;
    v34 = v33 + 8;
  }
  v20[1] = v34;
  *((_DWORD *)v34 - 2) = 0;
  *(v34 - 4) = a5 & 1;
  v45 = (unint64_t)v20[2];
  if ((unint64_t)v34 < v45)
  {
    *(_QWORD *)v34 = 0;
    v46 = v34 + 8;
    goto LABEL_73;
  }
  v47 = (v34 - *v20) >> 3;
  if ((unint64_t)(v47 + 1) >> 61)
LABEL_158:
    std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
  v48 = v45 - (_QWORD)*v20;
  v49 = v48 >> 2;
  if (v48 >> 2 <= (unint64_t)(v47 + 1))
    v49 = v47 + 1;
  if ((unint64_t)v48 >= 0x7FFFFFFFFFFFFFF8)
    v50 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v50 = v49;
  if (v50)
    v51 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(v20 + 2), v50);
  else
    v51 = 0;
  v52 = &v51[8 * v47];
  v53 = &v51[8 * v50];
  *(_QWORD *)v52 = 0;
  v46 = v52 + 8;
  v54 = *v20;
  v19 = v20[1];
  if (v19 != *v20)
  {
    do
    {
      v55 = *((_DWORD *)v19 - 2);
      v19 -= 8;
      v56 = v19[4];
      *((_DWORD *)v52 - 2) = v55;
      v52 -= 8;
      v52[4] = v56;
    }
    while (v19 != v54);
    v19 = *v20;
  }
  *v20 = v52;
  v20[1] = v46;
  v20[2] = v53;
  if (v19)
    operator delete(v19);
LABEL_73:
  v20[1] = v46;
  *((_DWORD *)v46 - 2) = 1;
  *(v46 - 4) = (a5 & 2) != 0;
  v57 = capabilities::ct::supports5G((capabilities::ct *)v19);
  if (a6)
    v58 = v57;
  else
    v58 = 0;
  if ((v58 & 1) != 0)
  {
    if (a6 == -1)
      v59 = 2;
    else
      v59 = 1;
    if ((a5 & 1) != 0)
      v60 = 0;
    else
      v60 = v59;
    v61 = *v10;
    if (os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
    {
      v62 = nas::asString(v60);
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = v62;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = a6;
      _os_log_impl(&dword_216897000, v61, OS_LOG_TYPE_DEFAULT, "#I Updating baseband with IMS registration end cause %s and retry interval: %u", buf, 0x12u);
    }
    v63 = (const void **)__p[1];
    v64 = (const void **)v113;
    v65 = (const void **)__p[1];
    if (__p[1] != (void *)v113)
    {
      v65 = (const void **)__p[1];
      while (*((_BYTE *)*v65 + 8) != 16)
      {
        if (++v65 == (const void **)v113)
          goto LABEL_93;
      }
    }
    if (v65 == (const void **)v113)
    {
LABEL_93:
      v68 = operator new();
      v69 = v68;
      *(_BYTE *)(v68 + 8) = 16;
      *(_QWORD *)v68 = &off_24D5EA548;
      *(_DWORD *)(v68 + 12) = 0;
      v67 = (int *)(v68 + 12);
      v70 = v113;
      if ((unint64_t)v113 >= *((_QWORD *)&v113 + 1))
      {
        v71 = (uint64_t)(v113 - (unint64_t)__p[1]) >> 3;
        if ((unint64_t)(v71 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v72 = (uint64_t)(*((_QWORD *)&v113 + 1) - (unint64_t)__p[1]) >> 2;
        if (v72 <= v71 + 1)
          v72 = v71 + 1;
        if (*((_QWORD *)&v113 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v73 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v73 = v72;
        if (v73)
          v74 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v113 + 8, v73);
        else
          v74 = 0;
        v76 = (const void **)&v74[8 * v71];
        v77 = &v74[8 * v73];
        *v76 = (const void *)v69;
        v64 = v76 + 1;
        v79 = (char *)__p[1];
        v78 = (char *)v113;
        if ((void *)v113 != __p[1])
        {
          do
          {
            v80 = (const void *)*((_QWORD *)v78 - 1);
            v78 -= 8;
            *--v76 = v80;
          }
          while (v78 != v79);
          v78 = (char *)__p[1];
        }
        __p[1] = v76;
        *(_QWORD *)&v113 = v64;
        *((_QWORD *)&v113 + 1) = v77;
        if (v78)
          operator delete(v78);
      }
      else
      {
        *(_QWORD *)v113 = v68;
        v64 = (const void **)(v70 + 8);
      }
      *(_QWORD *)&v113 = v64;
      v63 = (const void **)__p[1];
    }
    else
    {
      if (!v66)
        __cxa_bad_cast();
      v67 = (int *)(v66 + 12);
    }
    *v67 = v60;
    while (v63 != v64)
    {
      if (*((_BYTE *)*v63 + 8) == 17)
      {
        if (v63 != v64)
        {
          if (!v81)
            __cxa_bad_cast();
          v82 = v81 + 12;
          goto LABEL_139;
        }
        break;
      }
      ++v63;
    }
    v83 = operator new();
    v84 = v83;
    *(_BYTE *)(v83 + 8) = 17;
    *(_QWORD *)v83 = &off_24D5EA598;
    *(_DWORD *)(v83 + 12) = 0;
    v82 = (_DWORD *)(v83 + 12);
    v85 = v113;
    if ((unint64_t)v113 >= *((_QWORD *)&v113 + 1))
    {
      v87 = (uint64_t)(v113 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v87 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v88 = (uint64_t)(*((_QWORD *)&v113 + 1) - (unint64_t)__p[1]) >> 2;
      if (v88 <= v87 + 1)
        v88 = v87 + 1;
      if (*((_QWORD *)&v113 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v89 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v89 = v88;
      if (v89)
        v90 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v113 + 8, v89);
      else
        v90 = 0;
      v91 = (uint64_t *)&v90[8 * v87];
      v92 = &v90[8 * v89];
      *v91 = v84;
      v86 = v91 + 1;
      v94 = (char *)__p[1];
      v93 = (char *)v113;
      if ((void *)v113 != __p[1])
      {
        do
        {
          v95 = *((_QWORD *)v93 - 1);
          v93 -= 8;
          *--v91 = v95;
        }
        while (v93 != v94);
        v93 = (char *)__p[1];
      }
      __p[1] = v91;
      *(_QWORD *)&v113 = v86;
      *((_QWORD *)&v113 + 1) = v92;
      if (v93)
        operator delete(v93);
    }
    else
    {
      *(_QWORD *)v113 = v83;
      v86 = (_QWORD *)(v85 + 8);
    }
    *(_QWORD *)&v113 = v86;
LABEL_139:
    if ((a5 & 1) != 0)
      v96 = 0;
    else
      v96 = a6;
    *v82 = v96;
  }
  v97 = qmi::ClientRouter::get();
  v98 = operator new();
  *(_QWORD *)v98 = v97;
  *(_QWORD *)(v98 + 8) = QMIServiceMsg::create();
  *(_DWORD *)(v98 + 16) = 25000;
  *(_QWORD *)(v98 + 24) = 0;
  *(_QWORD *)(v98 + 32) = 0;
  v111 = v98;
  v99 = (std::__shared_weak_count *)operator new(0x20uLL);
  v99->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v99->__shared_owners_;
  v99->__shared_weak_owners_ = 0;
  v99->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5EA600;
  v99[1].__vftable = (std::__shared_weak_count_vtbl *)v10;
  v114 = &v99[1].__vftable;
  v115 = v99;
  v101 = MEMORY[0x24BDAC760];
  *(_QWORD *)buf = MEMORY[0x24BDAC760];
  *(_QWORD *)&buf[8] = 1174405120;
  *(_QWORD *)&buf[16] = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver15updateIMSStatusEN10subscriber7SimSlotE21RadioAccessTechnology8DataModeN5caulk10option_setIN2sd14ImsServiceTypeEjEEjE3__4EEOS1_OT__block_invoke;
  v118 = &__block_descriptor_tmp_70_6;
  v119 = &v99[1].__vftable;
  v120 = v99;
  do
    v102 = __ldxr(p_shared_owners);
  while (__stxr(v102 + 1, p_shared_owners));
  aBlock[0] = v101;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_31;
  aBlock[3] = &unk_24D5E8898;
  aBlock[4] = buf;
  *(_QWORD *)(v98 + 32) = _Block_copy(aBlock);
  v103 = v120;
  if (v120)
  {
    v104 = (unint64_t *)&v120->__shared_owners_;
    do
      v105 = __ldaxr(v104);
    while (__stlxr(v105 - 1, v104));
    if (!v105)
    {
      ((void (*)(std::__shared_weak_count *))v103->__on_zero_shared)(v103);
      std::__shared_weak_count::__release_weak(v103);
    }
  }
  v106 = v115;
  if (v115)
  {
    v107 = (unint64_t *)&v115->__shared_owners_;
    do
      v108 = __ldaxr(v107);
    while (__stlxr(v108 - 1, v107));
    if (!v108)
    {
      ((void (*)(std::__shared_weak_count *))v106->__on_zero_shared)(v106);
      std::__shared_weak_count::__release_weak(v106);
    }
  }
  v109 = v111;
  v111 = 0;
  if (v109)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v111, v109);
LABEL_157:
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
  return v17 != 0;
}

void sub_216A74FF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

uint64_t QMINetworkRegistrationDriver::update5GStandaloneInfo(capabilities::ct *a1, uint64_t a2, char a3)
{
  uint64_t v6;
  uint64_t v7;
  const void **v8;
  char *v9;
  _BYTE *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  char *v18;
  uint64_t *v19;
  char *v20;
  char *v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  std::__shared_weak_count *v26;
  unint64_t *p_shared_owners;
  uint64_t v28;
  unint64_t v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  std::__shared_weak_count *v33;
  unint64_t *v34;
  unint64_t v35;
  uint64_t v36;
  uint64_t v38;
  void *__p[2];
  __int128 v40;
  _QWORD v41[5];
  std::__shared_weak_count *v42;
  _QWORD *v43;
  std::__shared_weak_count *v44;
  _QWORD aBlock[5];

  v6 = capabilities::ct::supports5G(a1);
  if ((_DWORD)v6)
  {
    v7 = (*(uint64_t (**)(_QWORD *, uint64_t))(**((_QWORD **)a1 + 11) + 16))(*((_QWORD **)a1 + 11), a2);
    *(_OWORD *)__p = 0u;
    v40 = 0u;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
    v8 = (const void **)__p[1];
    if (__p[1] != (void *)v40)
    {
      while (*((_BYTE *)*v8 + 8) != 16)
      {
        if (++v8 == (const void **)v40)
          goto LABEL_9;
      }
    }
    if (v8 == (const void **)v40)
    {
LABEL_9:
      v11 = operator new();
      v12 = v11;
      *(_WORD *)(v11 + 8) = 16;
      *(_QWORD *)v11 = &off_24D5EA668;
      v13 = v40;
      if ((unint64_t)v40 >= *((_QWORD *)&v40 + 1))
      {
        v15 = (uint64_t)(v40 - (unint64_t)__p[1]) >> 3;
        if ((unint64_t)(v15 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v16 = (uint64_t)(*((_QWORD *)&v40 + 1) - (unint64_t)__p[1]) >> 2;
        if (v16 <= v15 + 1)
          v16 = v15 + 1;
        if (*((_QWORD *)&v40 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v17 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v17 = v16;
        if (v17)
          v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v40 + 8, v17);
        else
          v18 = 0;
        v19 = (uint64_t *)&v18[8 * v15];
        v20 = &v18[8 * v17];
        *v19 = v12;
        v14 = v19 + 1;
        v22 = (char *)__p[1];
        v21 = (char *)v40;
        if ((void *)v40 != __p[1])
        {
          do
          {
            v23 = *((_QWORD *)v21 - 1);
            v21 -= 8;
            *--v19 = v23;
          }
          while (v21 != v22);
          v21 = (char *)__p[1];
        }
        __p[1] = v19;
        *(_QWORD *)&v40 = v14;
        *((_QWORD *)&v40 + 1) = v20;
        if (v21)
          operator delete(v21);
      }
      else
      {
        *(_QWORD *)v40 = v11;
        v14 = (_QWORD *)(v13 + 8);
      }
      v10 = (_BYTE *)(v12 + 9);
      *(_QWORD *)&v40 = v14;
    }
    else
    {
      if (!v9)
        __cxa_bad_cast();
      v10 = v9 + 9;
    }
    *v10 = a3;
    v24 = qmi::ClientRouter::get();
    v25 = operator new();
    *(_QWORD *)v25 = v24;
    *(_QWORD *)(v25 + 8) = QMIServiceMsg::create();
    *(_DWORD *)(v25 + 16) = 25000;
    *(_QWORD *)(v25 + 24) = 0;
    *(_QWORD *)(v25 + 32) = 0;
    v38 = v25;
    v26 = (std::__shared_weak_count *)operator new(0x20uLL);
    v26->__shared_owners_ = 0;
    p_shared_owners = (unint64_t *)&v26->__shared_owners_;
    v26->__shared_weak_owners_ = 0;
    v26->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5EA6D0;
    v26[1].__vftable = (std::__shared_weak_count_vtbl *)v7;
    v43 = &v26[1].__vftable;
    v44 = v26;
    v28 = MEMORY[0x24BDAC760];
    v41[0] = MEMORY[0x24BDAC760];
    v41[1] = 1174405120;
    v41[2] = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver22update5GStandaloneInfoEN10subscriber7SimSlotEbE3__1EEOS1_OT__block_invoke;
    v41[3] = &__block_descriptor_tmp_71_6;
    v41[4] = v26 + 1;
    v42 = v26;
    do
      v29 = __ldxr(p_shared_owners);
    while (__stxr(v29 + 1, p_shared_owners));
    aBlock[0] = v28;
    aBlock[1] = 0x40000000;
    aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_31;
    aBlock[3] = &unk_24D5E8898;
    aBlock[4] = v41;
    *(_QWORD *)(v25 + 32) = _Block_copy(aBlock);
    v30 = v42;
    if (v42)
    {
      v31 = (unint64_t *)&v42->__shared_owners_;
      do
        v32 = __ldaxr(v31);
      while (__stlxr(v32 - 1, v31));
      if (!v32)
      {
        ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
        std::__shared_weak_count::__release_weak(v30);
      }
    }
    v33 = v44;
    if (v44)
    {
      v34 = (unint64_t *)&v44->__shared_owners_;
      do
        v35 = __ldaxr(v34);
      while (__stlxr(v35 - 1, v34));
      if (!v35)
      {
        ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
        std::__shared_weak_count::__release_weak(v33);
      }
    }
    v36 = v38;
    v38 = 0;
    if (v36)
      std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v38, v36);
    qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
  }
  return v6;
}

void sub_216A753FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;
  va_list va;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v6 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v3);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  if (a3)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v4, a3);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

void QMINetworkRegistrationDriver::triggerClosedSubscriberGroupSearch(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6)
{
  os_log_t *v9;
  const void **v10;
  char *v11;
  _DWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  char *v20;
  uint64_t *v21;
  char *v22;
  char *v23;
  char *v24;
  uint64_t v25;
  NSObject *v26;
  std::__shared_weak_count *v27;
  std::__shared_weak_count *v28;
  unint64_t *p_shared_owners;
  unint64_t v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t *v34;
  unint64_t v35;
  char *v36;
  unint64_t *v37;
  uint64_t v38;
  unint64_t v39;
  std::__shared_weak_count *v40;
  unint64_t *v41;
  unint64_t v42;
  std::__shared_weak_count *v43;
  unint64_t *v44;
  unint64_t v45;
  std::__shared_weak_count *v46;
  unint64_t *v47;
  unint64_t v48;
  uint64_t v49;
  std::__shared_weak_count *v50;
  unint64_t *v51;
  unint64_t v52;
  uint64_t v53;
  __int128 v54;
  void *__p[2];
  __int128 v56;
  _QWORD v57[5];
  std::__shared_weak_count *v58;
  char *v59;
  std::__shared_weak_count *v60;
  _QWORD aBlock[5];
  std::string buf;
  int v63;
  __int128 v64;
  os_log_t *v65;
  uint64_t v66;

  v66 = *MEMORY[0x24BDAC8D0];
  v9 = (os_log_t *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 88) + 16))(*(_QWORD *)(a1 + 88));
  *(_OWORD *)__p = 0u;
  v56 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  v10 = (const void **)__p[1];
  if (__p[1] != (void *)v56)
  {
    while (*((_BYTE *)*v10 + 8) != 1)
    {
      if (++v10 == (const void **)v56)
        goto LABEL_8;
    }
  }
  if (v10 == (const void **)v56)
  {
LABEL_8:
    v13 = operator new();
    v14 = v13;
    *(_BYTE *)(v13 + 8) = 1;
    *(_QWORD *)v13 = &off_24D5EA738;
    *(_DWORD *)(v13 + 12) = 0;
    v12 = (_DWORD *)(v13 + 12);
    v15 = v56;
    if ((unint64_t)v56 >= *((_QWORD *)&v56 + 1))
    {
      v17 = (uint64_t)(v56 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v17 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v18 = (uint64_t)(*((_QWORD *)&v56 + 1) - (unint64_t)__p[1]) >> 2;
      if (v18 <= v17 + 1)
        v18 = v17 + 1;
      if (*((_QWORD *)&v56 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v19 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v19 = v18;
      if (v19)
        v20 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v56 + 8, v19);
      else
        v20 = 0;
      v21 = (uint64_t *)&v20[8 * v17];
      v22 = &v20[8 * v19];
      *v21 = v14;
      v16 = v21 + 1;
      v24 = (char *)__p[1];
      v23 = (char *)v56;
      if ((void *)v56 != __p[1])
      {
        do
        {
          v25 = *((_QWORD *)v23 - 1);
          v23 -= 8;
          *--v21 = v25;
        }
        while (v23 != v24);
        v23 = (char *)__p[1];
      }
      __p[1] = v21;
      *(_QWORD *)&v56 = v16;
      *((_QWORD *)&v56 + 1) = v22;
      if (v23)
        operator delete(v23);
    }
    else
    {
      *(_QWORD *)v56 = v13;
      v16 = (_QWORD *)(v15 + 8);
    }
    *(_QWORD *)&v56 = v16;
  }
  else
  {
    if (!v11)
      __cxa_bad_cast();
    v12 = v11 + 12;
  }
  *v12 = a4;
  v26 = *v9;
  if (os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
    HIDWORD(buf.__r_.__value_.__r.__words[0]) = a4;
    _os_log_impl(&dword_216897000, v26, OS_LOG_TYPE_DEFAULT, "#I Sending CSG ID %d", (uint8_t *)&buf, 8u);
  }
  v27 = (std::__shared_weak_count *)operator new(0x50uLL);
  v28 = v27;
  v27->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v27->__shared_owners_;
  v27->__shared_weak_owners_ = 0;
  v27->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5EA770;
  LOBYTE(v27[1].__vftable) = *(_BYTE *)a6;
  *(_OWORD *)&v27[1].__shared_owners_ = *(_OWORD *)(a6 + 8);
  v27[2].__vftable = *(std::__shared_weak_count_vtbl **)(a6 + 24);
  *(_QWORD *)(a6 + 8) = 0;
  *(_QWORD *)(a6 + 16) = 0;
  *(_QWORD *)(a6 + 24) = 0;
  LODWORD(v27[2].__shared_owners_) = *(_DWORD *)(a6 + 32);
  *(_OWORD *)&v27[2].__shared_weak_owners_ = *(_OWORD *)(a6 + 40);
  *(_QWORD *)(a6 + 40) = 0;
  *(_QWORD *)(a6 + 48) = 0;
  *(_QWORD *)&v54 = v27 + 1;
  *((_QWORD *)&v54 + 1) = v27;
  do
    v30 = __ldxr(p_shared_owners);
  while (__stxr(v30 + 1, p_shared_owners));
  do
    v31 = __ldaxr(p_shared_owners);
  while (__stlxr(v31 - 1, p_shared_owners));
  if (!v31)
  {
    ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
    std::__shared_weak_count::__release_weak(v28);
  }
  v32 = qmi::ClientRouter::get();
  v33 = operator new();
  *(_QWORD *)v33 = v32;
  *(_QWORD *)(v33 + 8) = QMIServiceMsg::create();
  *(_DWORD *)(v33 + 16) = 25000;
  *(_QWORD *)(v33 + 24) = 0;
  *(_QWORD *)(v33 + 32) = 0;
  v53 = v33;
  if (*(char *)(a3 + 23) < 0)
    std::string::__init_copy_ctor_external(&buf, *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
  else
    buf = *(std::string *)a3;
  v63 = a4;
  v64 = v54;
  if (*((_QWORD *)&v54 + 1))
  {
    v34 = (unint64_t *)(*((_QWORD *)&v54 + 1) + 8);
    do
      v35 = __ldxr(v34);
    while (__stxr(v35 + 1, v34));
  }
  v65 = v9;
  v36 = (char *)operator new(0x50uLL);
  *((_QWORD *)v36 + 1) = 0;
  v37 = (unint64_t *)(v36 + 8);
  *((_QWORD *)v36 + 2) = 0;
  *(_QWORD *)v36 = &off_24D5EA7F0;
  *((std::string *)v36 + 1) = buf;
  memset(&buf, 0, sizeof(buf));
  *((_DWORD *)v36 + 12) = v63;
  *(_OWORD *)(v36 + 56) = v64;
  v64 = 0uLL;
  *((_QWORD *)v36 + 9) = v9;
  v59 = v36 + 24;
  v60 = (std::__shared_weak_count *)v36;
  v38 = MEMORY[0x24BDAC760];
  v57[0] = MEMORY[0x24BDAC760];
  v57[1] = 1174405120;
  v57[2] = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver34triggerClosedSubscriberGroupSearchEN10subscriber7SimSlotENSt3__112basic_stringIcNS6_11char_traitsIcEENS6_9allocatorIcEEEEiNS6_8optionalI9MCCAndMNCEEON3ctu4rest19command_responder_tI17CSGSearchResponseEEE3__1EEOS1_OT__block_invoke;
  v57[3] = &__block_descriptor_tmp_72_5;
  v57[4] = v36 + 24;
  v58 = (std::__shared_weak_count *)v36;
  do
    v39 = __ldxr(v37);
  while (__stxr(v39 + 1, v37));
  aBlock[0] = v38;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas28TriggerClosedSubscriberGroup8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
  aBlock[3] = &unk_24D5EA838;
  aBlock[4] = v57;
  *(_QWORD *)(v53 + 32) = _Block_copy(aBlock);
  v40 = v58;
  if (v58)
  {
    v41 = (unint64_t *)&v58->__shared_owners_;
    do
      v42 = __ldaxr(v41);
    while (__stlxr(v42 - 1, v41));
    if (!v42)
    {
      ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
      std::__shared_weak_count::__release_weak(v40);
    }
  }
  v43 = v60;
  if (v60)
  {
    v44 = (unint64_t *)&v60->__shared_owners_;
    do
      v45 = __ldaxr(v44);
    while (__stlxr(v45 - 1, v44));
    if (!v45)
    {
      ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
      std::__shared_weak_count::__release_weak(v43);
    }
  }
  v46 = (std::__shared_weak_count *)*((_QWORD *)&v64 + 1);
  if (*((_QWORD *)&v64 + 1))
  {
    v47 = (unint64_t *)(*((_QWORD *)&v64 + 1) + 8);
    do
      v48 = __ldaxr(v47);
    while (__stlxr(v48 - 1, v47));
    if (!v48)
    {
      ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
      std::__shared_weak_count::__release_weak(v46);
    }
  }
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
    operator delete(buf.__r_.__value_.__l.__data_);
  v49 = v53;
  v53 = 0;
  if (v49)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v53, v49);
  v50 = (std::__shared_weak_count *)*((_QWORD *)&v54 + 1);
  if (*((_QWORD *)&v54 + 1))
  {
    v51 = (unint64_t *)(*((_QWORD *)&v54 + 1) + 8);
    do
      v52 = __ldaxr(v51);
    while (__stlxr(v52 - 1, v51));
    if (!v52)
    {
      ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
      std::__shared_weak_count::__release_weak(v50);
    }
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
}

void sub_216A759F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v3;
  uint64_t v5;
  va_list va;
  uint64_t v7;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v5 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  if (a3)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v3, a3);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va1);
  _Unwind_Resume(a1);
}

uint64_t QMINetworkRegistrationDriver::triggerClosedSubscriberGroupSearch(subscriber::SimSlot,std::string,int,std::optional<MCCAndMNC>,ctu::rest::command_responder_t<CSGSearchResponse> &&)::$_1::~$_1(uint64_t a1)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
  return a1;
}

void QMINetworkRegistrationDriver::sendCommCenterStartsSincePowerCycle(QMINetworkRegistrationDriver *this, int a2)
{
  const void **v4;
  char *v5;
  _BYTE *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  char *v14;
  uint64_t *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *p_shared_owners;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  void *__p[2];
  __int128 v37;
  _QWORD v38[5];
  std::__shared_weak_count *v39;
  _QWORD *v40;
  std::__shared_weak_count *v41;
  _QWORD aBlock[5];

  *(_OWORD *)__p = 0u;
  v37 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  v4 = (const void **)__p[1];
  if (__p[1] != (void *)v37)
  {
    while (*((_BYTE *)*v4 + 8) != 53)
    {
      if (++v4 == (const void **)v37)
        goto LABEL_8;
    }
  }
  if (v4 == (const void **)v37)
  {
LABEL_8:
    v7 = operator new();
    v8 = v7;
    *(_WORD *)(v7 + 8) = 53;
    *(_QWORD *)v7 = &off_24D5EA880;
    v9 = v37;
    if ((unint64_t)v37 >= *((_QWORD *)&v37 + 1))
    {
      v11 = (uint64_t)(v37 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v11 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v12 = (uint64_t)(*((_QWORD *)&v37 + 1) - (unint64_t)__p[1]) >> 2;
      if (v12 <= v11 + 1)
        v12 = v11 + 1;
      if (*((_QWORD *)&v37 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v13 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v13 = v12;
      if (v13)
        v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v37 + 8, v13);
      else
        v14 = 0;
      v15 = (uint64_t *)&v14[8 * v11];
      v16 = &v14[8 * v13];
      *v15 = v8;
      v10 = v15 + 1;
      v18 = (char *)__p[1];
      v17 = (char *)v37;
      if ((void *)v37 != __p[1])
      {
        do
        {
          v19 = *((_QWORD *)v17 - 1);
          v17 -= 8;
          *--v15 = v19;
        }
        while (v17 != v18);
        v17 = (char *)__p[1];
      }
      __p[1] = v15;
      *(_QWORD *)&v37 = v10;
      *((_QWORD *)&v37 + 1) = v16;
      if (v17)
        operator delete(v17);
    }
    else
    {
      *(_QWORD *)v37 = v7;
      v10 = (_QWORD *)(v9 + 8);
    }
    v6 = (_BYTE *)(v8 + 9);
    *(_QWORD *)&v37 = v10;
  }
  else
  {
    if (!v5)
      __cxa_bad_cast();
    v6 = v5 + 9;
  }
  *v6 = (a2 == 1) & (QMINetworkRegistrationDriver::sendCommCenterStartsSincePowerCycle::sAlreadySentRequest ^ 1);
  QMINetworkRegistrationDriver::sendCommCenterStartsSincePowerCycle::sAlreadySentRequest = 1;
  v20 = qmi::ClientRouter::get();
  qmi::ClientRouter::SendProxy::SendProxy<nas::SetSystemSelectionPreference::Request>((uint64_t)&v34, 1, v20);
  v21 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)this + 11) + 16))(*((_QWORD *)this + 11), 1);
  v22 = (std::__shared_weak_count *)operator new(0x20uLL);
  v22->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v22->__shared_owners_;
  v22->__shared_weak_owners_ = 0;
  v22->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5EA8E8;
  v22[1].__vftable = (std::__shared_weak_count_vtbl *)v21;
  v40 = &v22[1].__vftable;
  v41 = v22;
  v24 = v35;
  v25 = MEMORY[0x24BDAC760];
  v38[0] = MEMORY[0x24BDAC760];
  v38[1] = 1174405120;
  v38[2] = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver35sendCommCenterStartsSincePowerCycleEjE3__1EEOS1_OT__block_invoke;
  v38[3] = &__block_descriptor_tmp_74_7;
  v38[4] = v22 + 1;
  v39 = v22;
  do
    v26 = __ldxr(p_shared_owners);
  while (__stxr(v26 + 1, p_shared_owners));
  aBlock[0] = v25;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas28SetSystemSelectionPreference8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke_0;
  aBlock[3] = &unk_24D5EA930;
  aBlock[4] = v38;
  *(_QWORD *)(v24 + 32) = _Block_copy(aBlock);
  v27 = v39;
  if (v39)
  {
    v28 = (unint64_t *)&v39->__shared_owners_;
    do
      v29 = __ldaxr(v28);
    while (__stlxr(v29 - 1, v28));
    if (!v29)
    {
      ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
      std::__shared_weak_count::__release_weak(v27);
    }
  }
  v30 = v41;
  if (v41)
  {
    v31 = (unint64_t *)&v41->__shared_owners_;
    do
      v32 = __ldaxr(v31);
    while (__stlxr(v32 - 1, v31));
    if (!v32)
    {
      ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
      std::__shared_weak_count::__release_weak(v30);
    }
  }
  v33 = v35;
  v35 = 0;
  if (v33)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v35, v33);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
}

void sub_216A75DFC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  va_list va;
  uint64_t v7;
  va_list va1;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  va_list va2;

  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v5 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v7 = va_arg(va2, _QWORD);
  v9 = va_arg(va2, _QWORD);
  v10 = va_arg(va2, _QWORD);
  v11 = va_arg(va2, _QWORD);
  v12 = va_arg(va2, _QWORD);
  v13 = va_arg(va2, _QWORD);
  v14 = va_arg(va2, _QWORD);
  v15 = va_arg(va2, _QWORD);
  v16 = va_arg(va2, _QWORD);
  v17 = va_arg(va2, _QWORD);
  v18 = va_arg(va2, _QWORD);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v2);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va2);
  v4 = v5;
  v5 = 0;
  if (v4)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)va, v4);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va1);
  _Unwind_Resume(a1);
}

void QMINetworkRegistrationDriver::setGeoMccs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _DWORD *v4;
  uint64_t v5;
  const void **v6;
  char *v7;
  _WORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  char *v16;
  uint64_t *v17;
  char *v18;
  char *v19;
  uint64_t v20;
  void *v21;
  const void **v22;
  const void **v23;
  char *v24;
  int *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  unint64_t v31;
  char *v32;
  uint64_t *v33;
  char *v34;
  char *v35;
  uint64_t v36;
  void *v37;
  int v38;
  const void **i;
  char *v40;
  _DWORD *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  _QWORD *v45;
  uint64_t v46;
  unint64_t v47;
  unint64_t v48;
  char *v49;
  uint64_t *v50;
  char *v51;
  char *v52;
  uint64_t v53;
  const void *v54;
  uint64_t v55;
  uint64_t v56;
  const void **v57;
  char *v58;
  _QWORD *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  _QWORD *v63;
  uint64_t v64;
  unint64_t v65;
  unint64_t v66;
  char *v67;
  uint64_t *v68;
  char *v69;
  char *v70;
  uint64_t v71;
  char *v72;
  char *v73;
  int64_t v74;
  unint64_t v75;
  unint64_t v76;
  char *v77;
  uint64_t v78;
  uint64_t v79;
  void **v80;
  char *v81;
  char *v82;
  char *v83;
  size_t v84;
  unint64_t v85;
  char *v86;
  uint64_t v87;
  uint64_t v88;
  std::__shared_weak_count *v89;
  unint64_t *p_shared_owners;
  unint64_t v91;
  std::__shared_weak_count *v92;
  unint64_t *v93;
  unint64_t v94;
  unint64_t v95;
  uint64_t v96;
  _DWORD *v97;
  uint64_t v98;
  uint64_t v100;
  _DWORD *v101;
  _DWORD *v102;
  uint64_t (*v103)(_QWORD);
  uint64_t v104;
  __int128 v105;
  __int128 v106;
  void *__p;
  uint64_t v108;
  void (*v109)(uint64_t, uint64_t);
  void *v110;
  std::__shared_weak_count *v111;
  std::__shared_weak_count *v112;
  _QWORD aBlock[6];

  subscriber::makeSimSlotRange();
  v4 = v101;
  if (v101 != v102)
  {
    while ((v103(*v4) & 1) == 0)
    {
      if (++v4 == v102)
      {
        v4 = v102;
        break;
      }
    }
    if (v4 != v102)
    {
      v98 = a3;
      do
      {
        if ((*v4 - 1) >= 3)
          v5 = 0;
        else
          v5 = *v4;
        v100 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 88) + 16))(*(_QWORD *)(a1 + 88), v5);
        v105 = 0u;
        v106 = 0u;
        qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)&v105);
        __p = 0;
        v108 = 0;
        v109 = 0;
        std::vector<unsigned short>::__init_with_size[abi:ne180100]<unsigned short *,unsigned short *>(&__p, *(const void **)a3, *(_QWORD *)(a3 + 8), (uint64_t)(*(_QWORD *)(a3 + 8) - *(_QWORD *)a3) >> 1);
        v6 = (const void **)*((_QWORD *)&v105 + 1);
        if (*((_QWORD *)&v105 + 1) != (_QWORD)v106)
        {
          while (*((_BYTE *)*v6 + 8) != 16)
          {
            if (++v6 == (const void **)v106)
              goto LABEL_17;
          }
        }
        if (v6 == (const void **)v106)
        {
LABEL_17:
          v9 = operator new();
          v10 = v9;
          *(_BYTE *)(v9 + 8) = 16;
          *(_QWORD *)v9 = &off_24D5EA978;
          *(_WORD *)(v9 + 10) = 0;
          v8 = (_WORD *)(v9 + 10);
          v11 = v106;
          if ((unint64_t)v106 >= *((_QWORD *)&v106 + 1))
          {
            v13 = (uint64_t)(v106 - *((_QWORD *)&v105 + 1)) >> 3;
            if ((unint64_t)(v13 + 1) >> 61)
              std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
            v14 = (uint64_t)(*((_QWORD *)&v106 + 1) - *((_QWORD *)&v105 + 1)) >> 2;
            if (v14 <= v13 + 1)
              v14 = v13 + 1;
            if (*((_QWORD *)&v106 + 1) - *((_QWORD *)&v105 + 1) >= 0x7FFFFFFFFFFFFFF8uLL)
              v15 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v15 = v14;
            if (v15)
              v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v106 + 8, v15);
            else
              v16 = 0;
            v17 = (uint64_t *)&v16[8 * v13];
            *v17 = v10;
            v12 = v17 + 1;
            v19 = (char *)*((_QWORD *)&v105 + 1);
            v18 = (char *)v106;
            if ((_QWORD)v106 != *((_QWORD *)&v105 + 1))
            {
              do
              {
                v20 = *((_QWORD *)v18 - 1);
                v18 -= 8;
                *--v17 = v20;
              }
              while (v18 != v19);
              v18 = (char *)*((_QWORD *)&v105 + 1);
            }
            *((_QWORD *)&v105 + 1) = v17;
            *(_QWORD *)&v106 = v12;
            *((_QWORD *)&v106 + 1) = &v16[8 * v15];
            if (v18)
              operator delete(v18);
          }
          else
          {
            *(_QWORD *)v106 = v9;
            v12 = (_QWORD *)(v11 + 8);
          }
          *(_QWORD *)&v106 = v12;
        }
        else
        {
          if (!v7)
            __cxa_bad_cast();
          v8 = v7 + 10;
        }
        v21 = __p;
        *v8 = *(_WORD *)__p;
        v108 = (uint64_t)v21;
        operator delete(v21);
        __p = 0;
        v108 = 0;
        v109 = 0;
        std::vector<unsigned short>::__init_with_size[abi:ne180100]<unsigned short *,unsigned short *>(&__p, *(const void **)a3, *(_QWORD *)(a3 + 8), (uint64_t)(*(_QWORD *)(a3 + 8) - *(_QWORD *)a3) >> 1);
        v22 = (const void **)*((_QWORD *)&v105 + 1);
        v23 = (const void **)v106;
        if (*((_QWORD *)&v105 + 1) != (_QWORD)v106)
        {
          while (*((_BYTE *)*v22 + 8) != 17)
          {
            if (++v22 == (const void **)v106)
              goto LABEL_41;
          }
        }
        if (v22 == (const void **)v106)
        {
LABEL_41:
          v26 = operator new();
          v27 = v26;
          *(_BYTE *)(v26 + 8) = 17;
          *(_QWORD *)v26 = &off_24D5EA9C8;
          *(_DWORD *)(v26 + 12) = 0;
          v25 = (int *)(v26 + 12);
          v28 = v106;
          if ((unint64_t)v106 >= *((_QWORD *)&v106 + 1))
          {
            v29 = (uint64_t)(v106 - *((_QWORD *)&v105 + 1)) >> 3;
            if ((unint64_t)(v29 + 1) >> 61)
              std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
            v30 = (uint64_t)(*((_QWORD *)&v106 + 1) - *((_QWORD *)&v105 + 1)) >> 2;
            if (v30 <= v29 + 1)
              v30 = v29 + 1;
            if (*((_QWORD *)&v106 + 1) - *((_QWORD *)&v105 + 1) >= 0x7FFFFFFFFFFFFFF8uLL)
              v31 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v31 = v30;
            if (v31)
              v32 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v106 + 8, v31);
            else
              v32 = 0;
            v33 = (uint64_t *)&v32[8 * v29];
            *v33 = v27;
            v23 = (const void **)(v33 + 1);
            v35 = (char *)*((_QWORD *)&v105 + 1);
            v34 = (char *)v106;
            if ((_QWORD)v106 != *((_QWORD *)&v105 + 1))
            {
              do
              {
                v36 = *((_QWORD *)v34 - 1);
                v34 -= 8;
                *--v33 = v36;
              }
              while (v34 != v35);
              v34 = (char *)*((_QWORD *)&v105 + 1);
            }
            *((_QWORD *)&v105 + 1) = v33;
            *(_QWORD *)&v106 = v23;
            *((_QWORD *)&v106 + 1) = &v32[8 * v31];
            if (v34)
              operator delete(v34);
          }
          else
          {
            *(_QWORD *)v106 = v26;
            v23 = (const void **)(v28 + 8);
          }
          *(_QWORD *)&v106 = v23;
        }
        else
        {
          if (!v24)
            __cxa_bad_cast();
          v25 = (int *)(v24 + 12);
        }
        v37 = __p;
        if (v108 - (_QWORD)__p == 2)
          v38 = 4;
        else
          v38 = 2 * (v108 - (_QWORD)__p == 4);
        *v25 = v38;
        if (v37)
        {
          v108 = (uint64_t)v37;
          operator delete(v37);
          v23 = (const void **)v106;
        }
        for (i = (const void **)*((_QWORD *)&v105 + 1); i != v23; ++i)
        {
          if (*((_BYTE *)*i + 8) == 18)
          {
            if (i != v23)
            {
              if (!v40)
                __cxa_bad_cast();
              v41 = v40 + 12;
              goto LABEL_87;
            }
            break;
          }
        }
        v42 = operator new();
        v43 = v42;
        *(_BYTE *)(v42 + 8) = 18;
        *(_QWORD *)v42 = &off_24D5EAA18;
        *(_DWORD *)(v42 + 12) = 0;
        v41 = (_DWORD *)(v42 + 12);
        v44 = v106;
        if ((unint64_t)v106 >= *((_QWORD *)&v106 + 1))
        {
          v46 = (uint64_t)(v106 - *((_QWORD *)&v105 + 1)) >> 3;
          if ((unint64_t)(v46 + 1) >> 61)
            std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
          v47 = (uint64_t)(*((_QWORD *)&v106 + 1) - *((_QWORD *)&v105 + 1)) >> 2;
          if (v47 <= v46 + 1)
            v47 = v46 + 1;
          if (*((_QWORD *)&v106 + 1) - *((_QWORD *)&v105 + 1) >= 0x7FFFFFFFFFFFFFF8uLL)
            v48 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v48 = v47;
          if (v48)
            v49 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v106 + 8, v48);
          else
            v49 = 0;
          v50 = (uint64_t *)&v49[8 * v46];
          *v50 = v43;
          v45 = v50 + 1;
          v52 = (char *)*((_QWORD *)&v105 + 1);
          v51 = (char *)v106;
          if ((_QWORD)v106 != *((_QWORD *)&v105 + 1))
          {
            do
            {
              v53 = *((_QWORD *)v51 - 1);
              v51 -= 8;
              *--v50 = v53;
            }
            while (v51 != v52);
            v51 = (char *)*((_QWORD *)&v105 + 1);
          }
          *((_QWORD *)&v105 + 1) = v50;
          *(_QWORD *)&v106 = v45;
          *((_QWORD *)&v106 + 1) = &v49[8 * v48];
          if (v51)
            operator delete(v51);
        }
        else
        {
          *(_QWORD *)v106 = v42;
          v45 = (_QWORD *)(v44 + 8);
        }
        *(_QWORD *)&v106 = v45;
LABEL_87:
        *v41 = 0;
        v54 = *(const void **)a3;
        v55 = *(_QWORD *)(a3 + 8);
        v56 = v55 - *(_QWORD *)a3;
        if ((unint64_t)v56 >= 3)
        {
          __p = 0;
          v108 = 0;
          v109 = 0;
          std::vector<unsigned short>::__init_with_size[abi:ne180100]<unsigned short *,unsigned short *>(&__p, v54, v55, v56 >> 1);
          v57 = (const void **)*((_QWORD *)&v105 + 1);
          if (*((_QWORD *)&v105 + 1) != (_QWORD)v106)
          {
            while (*((_BYTE *)*v57 + 8) != 19)
            {
              if (++v57 == (const void **)v106)
                goto LABEL_95;
            }
          }
          if (v57 == (const void **)v106)
          {
LABEL_95:
            v60 = operator new();
            v61 = v60;
            *(_BYTE *)(v60 + 8) = 19;
            *(_QWORD *)(v60 + 16) = 0;
            v59 = (_QWORD *)(v60 + 16);
            *(_QWORD *)v60 = &off_24D5EAA68;
            *(_QWORD *)(v60 + 24) = 0;
            *(_QWORD *)(v60 + 32) = 0;
            v62 = v106;
            if ((unint64_t)v106 >= *((_QWORD *)&v106 + 1))
            {
              v64 = (uint64_t)(v106 - *((_QWORD *)&v105 + 1)) >> 3;
              if ((unint64_t)(v64 + 1) >> 61)
                std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
              v65 = (uint64_t)(*((_QWORD *)&v106 + 1) - *((_QWORD *)&v105 + 1)) >> 2;
              if (v65 <= v64 + 1)
                v65 = v64 + 1;
              if (*((_QWORD *)&v106 + 1) - *((_QWORD *)&v105 + 1) >= 0x7FFFFFFFFFFFFFF8uLL)
                v66 = 0x1FFFFFFFFFFFFFFFLL;
              else
                v66 = v65;
              if (v66)
                v67 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v106 + 8, v66);
              else
                v67 = 0;
              v68 = (uint64_t *)&v67[8 * v64];
              *v68 = v61;
              v63 = v68 + 1;
              v70 = (char *)*((_QWORD *)&v105 + 1);
              v69 = (char *)v106;
              if ((_QWORD)v106 != *((_QWORD *)&v105 + 1))
              {
                do
                {
                  v71 = *((_QWORD *)v69 - 1);
                  v69 -= 8;
                  *--v68 = v71;
                }
                while (v69 != v70);
                v69 = (char *)*((_QWORD *)&v105 + 1);
              }
              *((_QWORD *)&v105 + 1) = v68;
              *(_QWORD *)&v106 = v63;
              *((_QWORD *)&v106 + 1) = &v67[8 * v66];
              if (v69)
                operator delete(v69);
            }
            else
            {
              *(_QWORD *)v106 = v60;
              v63 = (_QWORD *)(v62 + 8);
            }
            *(_QWORD *)&v106 = v63;
          }
          else
          {
            if (!v58)
              __cxa_bad_cast();
            v59 = v58 + 16;
          }
          v72 = (char *)v108;
          v73 = (char *)__p + 2;
          v74 = v108 - ((_QWORD)__p + 2);
          v75 = v74 >> 1;
          v76 = v59[2];
          v77 = (char *)*v59;
          if (v74 >> 1 <= (unint64_t)((uint64_t)(v76 - *v59) >> 1))
          {
            v83 = (char *)v59[1];
            v80 = (void **)(v59 + 1);
            v82 = v83;
            v84 = v83 - v77;
            v85 = (v83 - v77) >> 1;
            if (v85 >= v75)
            {
              if ((char *)v108 != v73)
                memmove(v77, (char *)__p + 2, v108 - ((_QWORD)__p + 2));
              a3 = v98;
            }
            else
            {
              if (v82 != v77)
              {
                memmove(v77, (char *)__p + 2, v84);
                v77 = (char *)*v80;
              }
              a3 = v98;
              v86 = &v73[2 * v85];
              v74 = v72 - v86;
              if (v72 != v86)
                memmove(v77, v86, v72 - v86);
            }
          }
          else
          {
            if (v77)
            {
              v59[1] = v77;
              operator delete(v77);
              v76 = 0;
              *v59 = 0;
              v59[1] = 0;
              v59[2] = 0;
            }
            if (v74 < 0)
              std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
            if (v76 <= v75)
              v78 = v74 >> 1;
            else
              v78 = v76;
            if (v76 >= 0x7FFFFFFFFFFFFFFELL)
              v79 = 0x7FFFFFFFFFFFFFFFLL;
            else
              v79 = v78;
            std::vector<unsigned short>::__vallocate[abi:ne180100](v59, v79);
            a3 = v98;
            v81 = (char *)v59[1];
            v80 = (void **)(v59 + 1);
            v77 = v81;
            if (v72 != v73)
              memmove(v77, v73, v74);
          }
          *v80 = &v77[v74];
          if (__p)
          {
            v108 = (uint64_t)__p;
            operator delete(__p);
          }
        }
        v87 = qmi::ClientRouter::get();
        v88 = operator new();
        *(_QWORD *)v88 = v87;
        *(_QWORD *)(v88 + 8) = QMIServiceMsg::create();
        *(_DWORD *)(v88 + 16) = 25000;
        *(_QWORD *)(v88 + 24) = 0;
        *(_QWORD *)(v88 + 32) = 0;
        v104 = v88;
        v89 = (std::__shared_weak_count *)operator new(0x20uLL);
        v89->__shared_owners_ = 0;
        p_shared_owners = (unint64_t *)&v89->__shared_owners_;
        v89->__shared_weak_owners_ = 0;
        v89->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5EAAD0;
        v89[1].__vftable = (std::__shared_weak_count_vtbl *)v100;
        __p = (void *)MEMORY[0x24BDAC760];
        v108 = 1174405120;
        v109 = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZZN28QMINetworkRegistrationDriver10setGeoMccsEN10subscriber7SimSlotERKNSt3__16vectorItNS6_9allocatorItEEEEENK3__0clINS_16SubscriptionTypeEEEDaT_EUlRKN3nas6SetMcc8ResponseEE_EEOS1_OSH__block_invoke;
        v110 = &__block_descriptor_tmp_76_5;
        v111 = v89 + 1;
        v112 = v89;
        do
          v91 = __ldxr(p_shared_owners);
        while (__stxr(v91 + 1, p_shared_owners));
        aBlock[0] = MEMORY[0x24BDAC760];
        aBlock[1] = 0x40000000;
        aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas6SetMcc8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
        aBlock[3] = &unk_24D5EAB18;
        aBlock[4] = &__p;
        *(_QWORD *)(v88 + 32) = _Block_copy(aBlock);
        v92 = v112;
        if (v112)
        {
          v93 = (unint64_t *)&v112->__shared_owners_;
          do
            v94 = __ldaxr(v93);
          while (__stlxr(v94 - 1, v93));
          if (!v94)
          {
            ((void (*)(std::__shared_weak_count *))v92->__on_zero_shared)(v92);
            std::__shared_weak_count::__release_weak(v92);
          }
        }
        do
          v95 = __ldaxr(p_shared_owners);
        while (__stlxr(v95 - 1, p_shared_owners));
        if (!v95)
        {
          ((void (*)(std::__shared_weak_count *))v89->__on_zero_shared)(v89);
          std::__shared_weak_count::__release_weak(v89);
        }
        v96 = v104;
        v104 = 0;
        if (v96)
          std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v104, v96);
        qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&v105);
        v97 = v4 + 1;
        v4 = v102;
        if (v97 != v102)
        {
          v4 = v97;
          while ((v103(*v4) & 1) == 0)
          {
            if (++v4 == v102)
            {
              v4 = v102;
              break;
            }
          }
        }
      }
      while (v4 != v102);
    }
  }
}

void sub_216A76810(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,void *__p,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32)
{
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a23);
  _Unwind_Resume(a1);
}

void QMINetworkRegistrationDriver::setSatelliteSystemConfig(uint64_t a1, uint64_t a2, _BYTE *a3)
{
  const void **v6;
  char *v7;
  BOOL *v8;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  char *v17;
  uint64_t *v18;
  char *v19;
  char *v20;
  char *v21;
  uint64_t v22;
  os_log_t *v23;
  NSObject *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *p_shared_owners;
  uint64_t v30;
  unint64_t v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  std::__shared_weak_count *v35;
  unint64_t *v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  void *__p[2];
  __int128 v41;
  _QWORD *v42;
  std::__shared_weak_count *v43;
  _QWORD aBlock[5];
  __int128 buf;
  void (*v46)(uint64_t, uint64_t);
  void *v47;
  _QWORD *v48;
  std::__shared_weak_count *v49;
  uint64_t v50;

  v50 = *MEMORY[0x24BDAC8D0];
  if ((_DWORD)a2)
  {
    *(_OWORD *)__p = 0u;
    v41 = 0u;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
    v6 = (const void **)__p[1];
    if (__p[1] != (void *)v41)
    {
      while (*((_BYTE *)*v6 + 8) != 17)
      {
        if (++v6 == (const void **)v41)
          goto LABEL_11;
      }
    }
    if (v6 == (const void **)v41)
    {
LABEL_11:
      v10 = operator new();
      v11 = v10;
      *(_WORD *)(v10 + 8) = 17;
      *(_QWORD *)v10 = &off_24D5EAB60;
      v12 = v41;
      if ((unint64_t)v41 >= *((_QWORD *)&v41 + 1))
      {
        v14 = (uint64_t)(v41 - (unint64_t)__p[1]) >> 3;
        if ((unint64_t)(v14 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v15 = (uint64_t)(*((_QWORD *)&v41 + 1) - (unint64_t)__p[1]) >> 2;
        if (v15 <= v14 + 1)
          v15 = v14 + 1;
        if (*((_QWORD *)&v41 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v16 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v16 = v15;
        if (v16)
          v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v41 + 8, v16);
        else
          v17 = 0;
        v18 = (uint64_t *)&v17[8 * v14];
        v19 = &v17[8 * v16];
        *v18 = v11;
        v13 = v18 + 1;
        v21 = (char *)__p[1];
        v20 = (char *)v41;
        if ((void *)v41 != __p[1])
        {
          do
          {
            v22 = *((_QWORD *)v20 - 1);
            v20 -= 8;
            *--v18 = v22;
          }
          while (v20 != v21);
          v20 = (char *)__p[1];
        }
        __p[1] = v18;
        *(_QWORD *)&v41 = v13;
        *((_QWORD *)&v41 + 1) = v19;
        if (v20)
          operator delete(v20);
      }
      else
      {
        *(_QWORD *)v41 = v10;
        v13 = (_QWORD *)(v12 + 8);
      }
      v8 = (BOOL *)(v11 + 9);
      *(_QWORD *)&v41 = v13;
    }
    else
    {
      if (!v7)
        __cxa_bad_cast();
      v8 = (BOOL *)(v7 + 9);
    }
    *v8 = *a3 != 0;
    v23 = (os_log_t *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 88) + 16))(*(_QWORD *)(a1 + 88), a2);
    v24 = *v23;
    if (os_log_type_enabled(*v23, OS_LOG_TYPE_DEFAULT))
    {
      v25 = asString();
      LODWORD(buf) = 136315138;
      *(_QWORD *)((char *)&buf + 4) = v25;
      _os_log_impl(&dword_216897000, v24, OS_LOG_TYPE_DEFAULT, "#I Sending set satellite system config info: %s", (uint8_t *)&buf, 0xCu);
    }
    v26 = qmi::ClientRouter::get();
    v27 = operator new();
    *(_QWORD *)v27 = v26;
    *(_QWORD *)(v27 + 8) = QMIServiceMsg::create();
    *(_DWORD *)(v27 + 16) = 25000;
    *(_QWORD *)(v27 + 24) = 0;
    *(_QWORD *)(v27 + 32) = 0;
    v39 = v27;
    v28 = (std::__shared_weak_count *)operator new(0x20uLL);
    v28->__shared_owners_ = 0;
    p_shared_owners = (unint64_t *)&v28->__shared_owners_;
    v28->__shared_weak_owners_ = 0;
    v28->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5EABC8;
    v28[1].__vftable = (std::__shared_weak_count_vtbl *)v23;
    v42 = &v28[1].__vftable;
    v43 = v28;
    v30 = MEMORY[0x24BDAC760];
    *(_QWORD *)&buf = MEMORY[0x24BDAC760];
    *((_QWORD *)&buf + 1) = 1174405120;
    v46 = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver24setSatelliteSystemConfigEN10subscriber7SimSlotERK21SatelliteSystemConfigE3__1EEOS1_OT__block_invoke;
    v47 = &__block_descriptor_tmp_78_1;
    v48 = &v28[1].__vftable;
    v49 = v28;
    do
      v31 = __ldxr(p_shared_owners);
    while (__stxr(v31 + 1, p_shared_owners));
    aBlock[0] = v30;
    aBlock[1] = 0x40000000;
    aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas24SetSatelliteSystemConfig8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
    aBlock[3] = &unk_24D5EAC10;
    aBlock[4] = &buf;
    *(_QWORD *)(v27 + 32) = _Block_copy(aBlock);
    v32 = v49;
    if (v49)
    {
      v33 = (unint64_t *)&v49->__shared_owners_;
      do
        v34 = __ldaxr(v33);
      while (__stlxr(v34 - 1, v33));
      if (!v34)
      {
        ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
        std::__shared_weak_count::__release_weak(v32);
      }
    }
    v35 = v43;
    if (v43)
    {
      v36 = (unint64_t *)&v43->__shared_owners_;
      do
        v37 = __ldaxr(v36);
      while (__stlxr(v37 - 1, v36));
      if (!v37)
      {
        ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
        std::__shared_weak_count::__release_weak(v35);
      }
    }
    v38 = v39;
    v39 = 0;
    if (v38)
      std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v39, v38);
    qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
  }
  else
  {
    v9 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf) = 136315138;
      *(_QWORD *)((char *)&buf + 4) = subscriber::asString();
      _os_log_error_impl(&dword_216897000, v9, OS_LOG_TYPE_ERROR, "Set satellite system config info does not support slot: %s", (uint8_t *)&buf, 0xCu);
    }
  }
}

void sub_216A76D48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

void QMINetworkRegistrationDriver::bootstrap(uint64_t a1, dispatch_object_t *a2, uint64_t *a3)
{
  _QWORD *v5;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  _QWORD *v11;
  NSObject *v12;
  uint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  _QWORD *v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  uint64_t v21;
  std::__shared_weak_count *v22;
  uint64_t v23;
  uint64_t v24;

  v5 = (_QWORD *)(a1 + 8);
  v6 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v6);
  }
  v8 = *a3;
  v7 = a3[1];
  if (v7)
  {
    v9 = (unint64_t *)(v7 + 8);
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }
  v21 = 0;
  v22 = 0;
  std::shared_ptr<AttachApnCommandDriver>::shared_ptr[abi:ne180100]<AttachApnCommandDriver,void>(&v21, v5);
  v11 = (_QWORD *)operator new();
  *v11 = a1;
  v11[1] = v6;
  v11[2] = v8;
  v11[3] = v7;
  v12 = *(NSObject **)(a1 + 24);
  v13 = v21;
  v14 = v22;
  if (v22)
  {
    p_shared_owners = (unint64_t *)&v22->__shared_owners_;
    do
      v16 = __ldxr(p_shared_owners);
    while (__stxr(v16 + 1, p_shared_owners));
  }
  v17 = (_QWORD *)operator new();
  *v17 = v11;
  v17[1] = v13;
  v17[2] = v14;
  v23 = 0;
  v24 = 0;
  dispatch_async_f(v12, v17, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<NetworkRegistrationDriver>::execute_wrapped<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0>(QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0,std::default_delete<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0>>)::{lambda(void *)#1}::__invoke);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v23);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v24);
  v18 = v22;
  if (v22)
  {
    v19 = (unint64_t *)&v22->__shared_owners_;
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
}

void QMINetworkRegistrationDriver::start(QMINetworkRegistrationDriver *this)
{
  _QWORD *v2;
  NSObject *v3;
  uint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  _QWORD *v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  uint64_t v14;
  uint64_t v15;

  v12 = 0;
  v13 = 0;
  std::shared_ptr<AttachApnCommandDriver>::shared_ptr[abi:ne180100]<AttachApnCommandDriver,void>(&v12, (_QWORD *)this + 1);
  v2 = (_QWORD *)operator new();
  *v2 = this;
  v3 = *((_QWORD *)this + 3);
  v4 = v12;
  v5 = v13;
  if (v13)
  {
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  v8 = (_QWORD *)operator new();
  *v8 = v2;
  v8[1] = v4;
  v8[2] = v5;
  v14 = 0;
  v15 = 0;
  dispatch_async_f(v3, v8, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<NetworkRegistrationDriver>::execute_wrapped<QMINetworkRegistrationDriver::start(void)::$_0>(QMINetworkRegistrationDriver::start(void)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMINetworkRegistrationDriver::start(void)::$_0,dispatch_queue_s *::default_delete<QMINetworkRegistrationDriver::start(void)::$_0>>)::{lambda(void *)#1}::__invoke);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v14);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v15);
  v9 = v13;
  if (v13)
  {
    v10 = (unint64_t *)&v13->__shared_owners_;
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
}

void QMINetworkRegistrationDriver::shutdown(uint64_t a1, dispatch_object_t *a2)
{
  _QWORD *v3;
  NSObject *v4;
  _QWORD *v5;
  NSObject *v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  _QWORD *v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  uint64_t v15;
  std::__shared_weak_count *v16;
  uint64_t v17;
  uint64_t v18;

  v3 = (_QWORD *)(a1 + 8);
  v4 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v4);
  }
  v15 = 0;
  v16 = 0;
  std::shared_ptr<AttachApnCommandDriver>::shared_ptr[abi:ne180100]<AttachApnCommandDriver,void>(&v15, v3);
  v5 = (_QWORD *)operator new();
  *v5 = a1;
  v5[1] = v4;
  v6 = *(NSObject **)(a1 + 24);
  v7 = v15;
  v8 = v16;
  if (v16)
  {
    p_shared_owners = (unint64_t *)&v16->__shared_owners_;
    do
      v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
  }
  v11 = (_QWORD *)operator new();
  *v11 = v5;
  v11[1] = v7;
  v11[2] = v8;
  v17 = 0;
  v18 = 0;
  dispatch_async_f(v6, v11, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<NetworkRegistrationDriver>::execute_wrapped<QMINetworkRegistrationDriver::shutdown(dispatch::group_session)::$_0>(QMINetworkRegistrationDriver::shutdown(dispatch::group_session)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMINetworkRegistrationDriver::shutdown(dispatch::group_session)::$_0,dispatch_queue_s *::default_delete<QMINetworkRegistrationDriver::shutdown(dispatch::group_session)::$_0>>)::{lambda(void *)#1}::__invoke);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v17);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v18);
  v12 = v16;
  if (v16)
  {
    v13 = (unint64_t *)&v16->__shared_owners_;
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
}

_BYTE *std::__optional_copy_base<MCC,false>::__optional_copy_base[abi:ne180100](_BYTE *a1, uint64_t a2)
{
  *a1 = 0;
  a1[32] = 0;
  if (*(_BYTE *)(a2 + 32))
  {
    MCC::MCC();
    a1[32] = 1;
  }
  return a1;
}

void sub_216A7717C(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(_BYTE *)(v1 + 32))
  {
    if (*(char *)(v1 + 31) < 0)
      operator delete(*(void **)(v1 + 8));
  }
  _Unwind_Resume(exception_object);
}

MCC *std::__optional_copy_base<MNC,false>::__optional_copy_base[abi:ne180100](MCC *this, const MCC *a2)
{
  *(_BYTE *)this = 0;
  *((_BYTE *)this + 32) = 0;
  if (*((_BYTE *)a2 + 32))
  {
    MCC::MCC(this, a2);
    *((_BYTE *)this + 32) = 1;
  }
  return this;
}

void sub_216A771E0(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(_BYTE *)(v1 + 32))
  {
    if (*(char *)(v1 + 31) < 0)
      operator delete(*(void **)(v1 + 8));
  }
  _Unwind_Resume(exception_object);
}

void std::unique_ptr<std::__tree_node<std::__value_type<RadioAccessTechnology,ServingSystem::System>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<RadioAccessTechnology,ServingSystem::System>,void *>>>>::reset[abi:ne180100](uint64_t a1)
{
  void *v1;

  v1 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v1)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__destroy_at[abi:ne180100]<std::pair<RadioAccessTechnology const,ServingSystem::System>,0>((uint64_t)v1 + 32);
    operator delete(v1);
  }
}

void std::__destroy_at[abi:ne180100]<std::pair<RadioAccessTechnology const,ServingSystem::System>,0>(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 96) && *(char *)(a1 + 95) < 0)
    operator delete(*(void **)(a1 + 72));
  if (*(_BYTE *)(a1 + 56))
  {
    if (*(char *)(a1 + 55) < 0)
      operator delete(*(void **)(a1 + 32));
  }
}

void ServingSystem::System::~System(void **this)
{
  if (*((_BYTE *)this + 88) && *((char *)this + 87) < 0)
    operator delete(this[8]);
  if (*((_BYTE *)this + 48))
  {
    if (*((char *)this + 47) < 0)
      operator delete(this[3]);
  }
}

void std::unique_ptr<std::__tree_node<std::__value_type<RadioAccessTechnology,ServingSystem::GSMSystem>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<RadioAccessTechnology,ServingSystem::GSMSystem>,void *>>>>::reset[abi:ne180100](uint64_t a1)
{
  void *v1;

  v1 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v1)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__destroy_at[abi:ne180100]<std::pair<RadioAccessTechnology const,ServingSystem::GSMSystem>,0>((uint64_t)v1 + 32);
    operator delete(v1);
  }
}

void std::__destroy_at[abi:ne180100]<std::pair<RadioAccessTechnology const,ServingSystem::GSMSystem>,0>(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 80) && *(char *)(a1 + 79) < 0)
    operator delete(*(void **)(a1 + 56));
  if (*(_BYTE *)(a1 + 40))
  {
    if (*(char *)(a1 + 39) < 0)
      operator delete(*(void **)(a1 + 16));
  }
}

void ServingSystem::GSMSystem::~GSMSystem(void **this)
{
  if (*((_BYTE *)this + 72) && *((char *)this + 71) < 0)
    operator delete(this[6]);
  if (*((_BYTE *)this + 32))
  {
    if (*((char *)this + 31) < 0)
      operator delete(this[1]);
  }
}

void std::__optional_storage_base<MCC,false>::__assign_from[abi:ne180100]<std::__optional_copy_assign_base<MCC,false> const&>(uint64_t a1, uint64_t a2)
{
  if (*(unsigned __int8 *)(a1 + 32) == *(unsigned __int8 *)(a2 + 32))
  {
    if (*(_BYTE *)(a1 + 32))
      MCC::operator=();
  }
  else if (*(_BYTE *)(a1 + 32))
  {
    if (*(char *)(a1 + 31) < 0)
      operator delete(*(void **)(a1 + 8));
    *(_BYTE *)(a1 + 32) = 0;
  }
  else
  {
    MCC::MCC();
    *(_BYTE *)(a1 + 32) = 1;
  }
}

void std::__optional_storage_base<MNC,false>::__assign_from[abi:ne180100]<std::__optional_copy_assign_base<MNC,false> const&>(MCC *this, unsigned __int8 *a2)
{
  if (*((unsigned __int8 *)this + 32) == a2[32])
  {
    if (*((_BYTE *)this + 32))
      MCC::operator=();
  }
  else if (*((_BYTE *)this + 32))
  {
    if (*((char *)this + 31) < 0)
      operator delete(*((void **)this + 1));
    *((_BYTE *)this + 32) = 0;
  }
  else
  {
    MCC::MCC(this, (const MCC *)a2);
    *((_BYTE *)this + 32) = 1;
  }
}

void OperatorNameUpdate::OperatorNameUpdate(std::string *this, const OperatorNameUpdate *a2)
{
  __int128 v4;
  __int128 v5;
  __int128 v6;
  std::string *v7;
  __int128 v8;

  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v4 = *(_OWORD *)a2;
    this->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v4;
  }
  if (*((char *)a2 + 47) < 0)
  {
    std::string::__init_copy_ctor_external(this + 1, *((const std::string::value_type **)a2 + 3), *((_QWORD *)a2 + 4));
  }
  else
  {
    v5 = *(_OWORD *)((char *)a2 + 24);
    this[1].__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 5);
    *(_OWORD *)&this[1].__r_.__value_.__l.__data_ = v5;
  }
  if (*((char *)a2 + 71) < 0)
  {
    std::string::__init_copy_ctor_external(this + 2, *((const std::string::value_type **)a2 + 6), *((_QWORD *)a2 + 7));
  }
  else
  {
    v6 = *((_OWORD *)a2 + 3);
    this[2].__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 8);
    *(_OWORD *)&this[2].__r_.__value_.__l.__data_ = v6;
  }
  this[3].__r_.__value_.__r.__words[0] = *((_QWORD *)a2 + 9);
  std::__optional_copy_base<MCC,false>::__optional_copy_base[abi:ne180100](&this[3].__r_.__value_.__s.__data_[8], (uint64_t)a2 + 80);
  std::__optional_copy_base<MNC,false>::__optional_copy_base[abi:ne180100]((MCC *)&this[5], (const OperatorNameUpdate *)((char *)a2 + 120));
  v7 = (std::string *)((char *)this + 160);
  if (*((char *)a2 + 183) < 0)
  {
    std::string::__init_copy_ctor_external(v7, *((const std::string::value_type **)a2 + 20), *((_QWORD *)a2 + 21));
  }
  else
  {
    v8 = *((_OWORD *)a2 + 10);
    this[7].__r_.__value_.__l.__size_ = *((_QWORD *)a2 + 22);
    *(_OWORD *)&v7->__r_.__value_.__l.__data_ = v8;
  }
}

void sub_216A775AC(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void **v3;

  if (*(_BYTE *)(v1 + 152) && *(char *)(v1 + 151) < 0)
    operator delete(*(void **)(v1 + 128));
  if (*(_BYTE *)(v1 + 112) && *(char *)(v1 + 111) < 0)
    operator delete(*(void **)(v1 + 88));
  if (*(char *)(v1 + 71) < 0)
    operator delete(*v3);
  if (*(char *)(v1 + 47) < 0)
    operator delete(*v2);
  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

void OperatorNameUpdate::~OperatorNameUpdate(void **this)
{
  if (*((char *)this + 183) < 0)
    operator delete(this[20]);
  if (*((_BYTE *)this + 152) && *((char *)this + 151) < 0)
    operator delete(this[16]);
  if (*((_BYTE *)this + 112) && *((char *)this + 111) < 0)
    operator delete(this[11]);
  if (*((char *)this + 71) < 0)
    operator delete(this[6]);
  if (*((char *)this + 47) < 0)
    operator delete(this[3]);
  if (*((char *)this + 23) < 0)
    operator delete(*this);
}

_QWORD *std::vector<EmergencySetupType>::__init_with_size[abi:ne180100]<EmergencySetupType*,EmergencySetupType*>(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v5;
  _QWORD *v8;
  size_t v9;

  if (a4)
  {
    v5 = result;
    if (a4 >> 62)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    result = operator new(4 * a4);
    v8 = result;
    *v5 = result;
    v5[1] = result;
    v5[2] = (char *)result + 4 * a4;
    v9 = a3 - (_QWORD)a2;
    if (v9)
      result = memcpy(result, a2, v9);
    v5[1] = (char *)v8 + v9;
  }
  return result;
}

void sub_216A7774C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *qmi::MutableMessageBase::getTLV<nas::tlv::E911StateAction>(_QWORD *a1)
{
  const void **v2;
  const void **v3;
  char **v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  v4 = (char **)(a1 + 1);
  if (v2 != v3)
  {
    while (*((_BYTE *)*v2 + 8) != 1)
    {
      if (++v2 == v3)
        goto LABEL_8;
    }
  }
  if (v2 == v3)
  {
LABEL_8:
    v7 = operator new();
    *(_BYTE *)(v7 + 8) = 1;
    *(_DWORD *)(v7 + 12) = 0;
    v6 = v7 + 12;
    *(_QWORD *)v7 = &off_24D5E8798;
    v8 = a1[3];
    v9 = (uint64_t *)a1[2];
    if ((unint64_t)v9 >= v8)
    {
      v11 = ((char *)v9 - *v4) >> 3;
      if ((unint64_t)(v11 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v12 = v8 - (_QWORD)*v4;
      v13 = v12 >> 2;
      if (v12 >> 2 <= (unint64_t)(v11 + 1))
        v13 = v11 + 1;
      if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
        v14 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v14 = v13;
      if (v14)
        v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v14);
      else
        v15 = 0;
      v16 = (uint64_t *)&v15[8 * v11];
      v17 = &v15[8 * v14];
      *v16 = v7;
      v10 = v16 + 1;
      v19 = (char *)a1[1];
      v18 = (char *)a1[2];
      if (v18 != v19)
      {
        do
        {
          v20 = *((_QWORD *)v18 - 1);
          v18 -= 8;
          *--v16 = v20;
        }
        while (v18 != v19);
        v18 = *v4;
      }
      a1[1] = v16;
      a1[2] = v10;
      a1[3] = v17;
      if (v18)
        operator delete(v18);
    }
    else
    {
      *v9 = v7;
      v10 = v9 + 1;
    }
    a1[2] = v10;
  }
  else
  {
    if (!v5)
      __cxa_bad_cast();
    return v5 + 12;
  }
  return (char *)v6;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::E911StateAction>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::E911StateAction>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

_DWORD **qmi::MutableMessageBase::TlvWrapper<nas::tlv::E911StateAction>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _DWORD *v4;
  uint64_t v5;
  _DWORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_DWORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::PktDataHandle>((_DWORD **)a2, (_DWORD *)(a1 + 12));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::E911StateAction>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E8798;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a1 + 12);
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::EmergencyType>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::EmergencyType>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

_DWORD **qmi::MutableMessageBase::TlvWrapper<nas::tlv::EmergencyType>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _DWORD *v4;
  uint64_t v5;
  _DWORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_DWORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::PktDataHandle>((_DWORD **)a2, (_DWORD *)(a1 + 12));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::EmergencyType>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E87E8;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a1 + 12);
  return result;
}

uint64_t ___ZNO3qmi12ClientRouter9SendProxy8callbackIZZN28QMINetworkRegistrationDriver14enterE911StateEN10subscriber7SimSlotERKNSt3__16vectorI18EmergencySetupTypeNS6_9allocatorIS8_EEEEbbS5_bENK3__0clES5_EUlRKNS_12ResponseBaseEE_EEOS1_OT__block_invoke(uint64_t result, uint64_t a2)
{
  int v2;
  uint64_t *v3;
  uint64_t v4;
  NSObject *v5;
  _DWORD v6[2];
  __int16 v7;
  uint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v2 = *(_DWORD *)(a2 + 4);
  if (v2)
  {
    v3 = *(uint64_t **)(result + 32);
    v4 = *v3;
    v5 = *(NSObject **)v3[2];
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6[0] = 67109378;
      v6[1] = v2;
      v7 = 2080;
      v8 = qmi::asString();
      _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#N Enter E911 state failed: Error in response with code %d (%s)", (uint8_t *)v6, 0x12u);
      v5 = *(NSObject **)v3[2];
    }
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v6[0]) = 0;
      _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#I E911 state enter failed, send ready indication", (uint8_t *)v6, 2u);
    }
    return (*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(v4 + 64) + 136))(*(_QWORD *)(v4 + 64), 1, *((unsigned int *)v3 + 2));
  }
  return result;
}

uint64_t __copy_helper_block_e8_32c198_ZTSNSt3__110shared_ptrIZZN28QMINetworkRegistrationDriver14enterE911StateEN10subscriber7SimSlotERKNS_6vectorI18EmergencySetupTypeNS_9allocatorIS5_EEEEbbS3_bENK3__0clES3_EUlRKN3qmi12ResponseBaseEE_EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c198_ZTSNSt3__110shared_ptrIZZN28QMINetworkRegistrationDriver14enterE911StateEN10subscriber7SimSlotERKNS_6vectorI18EmergencySetupTypeNS_9allocatorIS5_EEEEbbS3_bENK3__0clES3_EUlRKN3qmi12ResponseBaseEE_EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::enterE911State(subscriber::SimSlot,std::vector<EmergencySetupType> const&,BOOL,BOOL,subscriber::SimSlot,BOOL)::$_0::operator() const(subscriber::SimSlot)::{lambda(qmi::ResponseBase const&)#1},std::allocator<QMINetworkRegistrationDriver::enterE911State(subscriber::SimSlot,std::vector<EmergencySetupType> const&,BOOL,BOOL,subscriber::SimSlot,BOOL)::$_0::operator() const(subscriber::SimSlot)::{lambda(qmi::ResponseBase const&)#1}>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E8850;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::enterE911State(subscriber::SimSlot,std::vector<EmergencySetupType> const&,BOOL,BOOL,subscriber::SimSlot,BOOL)::$_0::operator() const(subscriber::SimSlot)::{lambda(qmi::ResponseBase const&)#1},std::allocator<QMINetworkRegistrationDriver::enterE911State(subscriber::SimSlot,std::vector<EmergencySetupType> const&,BOOL,BOOL,subscriber::SimSlot,BOOL)::$_0::operator() const(subscriber::SimSlot)::{lambda(qmi::ResponseBase const&)#1}>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E8850;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::AvoidRat>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::AvoidRat>::getSize()
{
  return tlv::size<wds::tlv::ProfileTypeMask>();
}

_QWORD **qmi::MutableMessageBase::TlvWrapper<nas::tlv::AvoidRat>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _QWORD *v4;
  uint64_t v5;
  _QWORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_QWORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::ProfileTypeMask>((_QWORD **)a2, (_QWORD *)(a1 + 16));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::AvoidRat>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E88E0;
  *(_QWORD *)(result + 16) = *(_QWORD *)(a1 + 16);
  return result;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZZN28QMINetworkRegistrationDriver14enterE911StateEN10subscriber7SimSlotERKNSt3__16vectorI18EmergencySetupTypeNS6_9allocatorIS8_EEEEbbS5_bENK3__1clES5_EUlRKNS_12ResponseBaseEE_EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  NSObject *v4;
  _DWORD v5[2];
  __int16 v6;
  uint64_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(_DWORD *)(a2 + 4);
  if (v3)
  {
    v4 = **(NSObject ***)(v2 + 8);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      v5[0] = 67109378;
      v5[1] = v3;
      v6 = 2080;
      v7 = qmi::asString();
      _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#N Sending cell avoidance request failed: Error in response with code %d (%s)", (uint8_t *)v5, 0x12u);
    }
  }
  QMINetworkRegistrationDriver::enterE911State(subscriber::SimSlot,std::vector<EmergencySetupType> const&,BOOL,BOOL,subscriber::SimSlot,BOOL)::$_0::operator()((_QWORD *)(v2 + 16), *(_DWORD *)v2);
}

uint64_t __copy_helper_block_e8_32c198_ZTSNSt3__110shared_ptrIZZN28QMINetworkRegistrationDriver14enterE911StateEN10subscriber7SimSlotERKNS_6vectorI18EmergencySetupTypeNS_9allocatorIS5_EEEEbbS3_bENK3__1clES3_EUlRKN3qmi12ResponseBaseEE_EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c198_ZTSNSt3__110shared_ptrIZZN28QMINetworkRegistrationDriver14enterE911StateEN10subscriber7SimSlotERKNS_6vectorI18EmergencySetupTypeNS_9allocatorIS5_EEEEbbS3_bENK3__1clES3_EUlRKN3qmi12ResponseBaseEE_EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::enterE911State(subscriber::SimSlot,std::vector<EmergencySetupType> const&,BOOL,BOOL,subscriber::SimSlot,BOOL)::$_1::operator() const(subscriber::SimSlot)::{lambda(qmi::ResponseBase const&)#1},std::allocator<QMINetworkRegistrationDriver::enterE911State(subscriber::SimSlot,std::vector<EmergencySetupType> const&,BOOL,BOOL,subscriber::SimSlot,BOOL)::$_1::operator() const(subscriber::SimSlot)::{lambda(qmi::ResponseBase const&)#1}>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E8948;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::enterE911State(subscriber::SimSlot,std::vector<EmergencySetupType> const&,BOOL,BOOL,subscriber::SimSlot,BOOL)::$_1::operator() const(subscriber::SimSlot)::{lambda(qmi::ResponseBase const&)#1},std::allocator<QMINetworkRegistrationDriver::enterE911State(subscriber::SimSlot,std::vector<EmergencySetupType> const&,BOOL,BOOL,subscriber::SimSlot,BOOL)::$_1::operator() const(subscriber::SimSlot)::{lambda(qmi::ResponseBase const&)#1}>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E8948;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::enterE911State(subscriber::SimSlot,std::vector<EmergencySetupType> const&,BOOL,BOOL,subscriber::SimSlot,BOOL)::$_1::operator() const(subscriber::SimSlot)::{lambda(qmi::ResponseBase const&)#1},std::allocator<QMINetworkRegistrationDriver::enterE911State(subscriber::SimSlot,std::vector<EmergencySetupType> const&,BOOL,BOOL,subscriber::SimSlot,BOOL)::$_1::operator() const(subscriber::SimSlot)::{lambda(qmi::ResponseBase const&)#1}>>::__on_zero_shared(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(_QWORD *)(a1 + 56) = v2;
    operator delete(v2);
  }
}

uint64_t *std::shared_ptr<QMINetworkRegistrationDriver>::shared_ptr[abi:ne180100]<QMINetworkRegistrationDriver,std::shared_ptr<QMINetworkRegistrationDriver> ctu::SharedSynchronizable<NetworkRegistrationDriver>::make_shared_ptr<QMINetworkRegistrationDriver>(QMINetworkRegistrationDriver*)::{lambda(QMINetworkRegistrationDriver*)#1},void>(uint64_t *a1, uint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24D5E8998;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = (uint64_t)v4;
  if (a2)
    v5 = (_QWORD *)(a2 + 8);
  else
    v5 = 0;
  std::shared_ptr<QMIDataSystemDeterminationManager>::__enable_weak_this[abi:ne180100]<QMIDataSystemDeterminationManager,QMIDataSystemDeterminationManager,void>((uint64_t)a1, v5, a2);
  return a1;
}

void sub_216A77E8C(void *a1)
{
  dispatch_queue_t *v1;

  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)std::shared_ptr<QMINetworkRegistrationDriver> ctu::SharedSynchronizable<NetworkRegistrationDriver>::make_shared_ptr<QMINetworkRegistrationDriver>(QMINetworkRegistrationDriver*)::{lambda(QMINetworkRegistrationDriver*)#1}::operator() const(QMINetworkRegistrationDriver*)::{lambda(void *)#1}::__invoke);
  __cxa_rethrow();
}

void sub_216A77EAC(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<QMINetworkRegistrationDriver *,std::shared_ptr<QMINetworkRegistrationDriver> ctu::SharedSynchronizable<NetworkRegistrationDriver>::make_shared_ptr<QMINetworkRegistrationDriver>(QMINetworkRegistrationDriver*)::{lambda(QMINetworkRegistrationDriver *)#1},std::allocator<QMINetworkRegistrationDriver>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void std::__shared_ptr_pointer<QMINetworkRegistrationDriver *,std::shared_ptr<QMINetworkRegistrationDriver> ctu::SharedSynchronizable<NetworkRegistrationDriver>::make_shared_ptr<QMINetworkRegistrationDriver>(QMINetworkRegistrationDriver*)::{lambda(QMINetworkRegistrationDriver *)#1},std::allocator<QMINetworkRegistrationDriver>>::__on_zero_shared(uint64_t a1)
{
  dispatch_barrier_async_f(*(dispatch_queue_t *)(*(_QWORD *)(a1 + 24) + 24), *(void **)(a1 + 24), (dispatch_function_t)std::shared_ptr<QMINetworkRegistrationDriver> ctu::SharedSynchronizable<NetworkRegistrationDriver>::make_shared_ptr<QMINetworkRegistrationDriver>(QMINetworkRegistrationDriver*)::{lambda(QMINetworkRegistrationDriver*)#1}::operator() const(QMINetworkRegistrationDriver*)::{lambda(void *)#1}::__invoke);
}

uint64_t std::__shared_ptr_pointer<QMINetworkRegistrationDriver *,std::shared_ptr<QMINetworkRegistrationDriver> ctu::SharedSynchronizable<NetworkRegistrationDriver>::make_shared_ptr<QMINetworkRegistrationDriver>(QMINetworkRegistrationDriver*)::{lambda(QMINetworkRegistrationDriver *)#1},std::allocator<QMINetworkRegistrationDriver>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t std::shared_ptr<QMINetworkRegistrationDriver> ctu::SharedSynchronizable<NetworkRegistrationDriver>::make_shared_ptr<QMINetworkRegistrationDriver>(QMINetworkRegistrationDriver*)::{lambda(QMINetworkRegistrationDriver*)#1}::operator() const(QMINetworkRegistrationDriver*)::{lambda(void *)#1}::__invoke(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<NetworkRegistrationDriver>::execute_wrapped<QMINetworkRegistrationDriver::create(std::shared_ptr<Registry const> const&,dispatch::workloop)::$_0>(QMINetworkRegistrationDriver::create(std::shared_ptr<Registry const> const&,dispatch::workloop)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMINetworkRegistrationDriver::create(std::shared_ptr<Registry const> const&,dispatch::workloop)::$_0,std::default_delete<QMINetworkRegistrationDriver::create(std::shared_ptr<Registry const> const&,dispatch::workloop)::$_0>>)::{lambda(void *)#1}::__invoke(uint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  NSObject *v3;
  _DWORD *v4;
  char *v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_weak_owners;
  unint64_t v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  NSObject *v14;
  std::__shared_weak_count *v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  unint64_t *v24;
  unint64_t v25;
  _DWORD *v26;
  uint64_t *v28;
  uint64_t v29;
  _DWORD *v30;
  _DWORD *v31;
  uint64_t (*v32)(_QWORD);
  __int128 v33;
  void *v34[2];
  __int128 v35;
  __int128 v36;
  uint64_t v37;
  std::__shared_weak_count *v38;
  void *__p;
  char v40;
  dispatch_object_t v41;
  __int128 buf;
  __int128 v43;

  v1 = *a1;
  v28 = a1;
  v29 = v1;
  v2 = *(_QWORD *)v1;
  v3 = *(NSObject **)(*(_QWORD *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl(&dword_216897000, v3, OS_LOG_TYPE_DEFAULT, "#I Initializing command driver", (uint8_t *)&buf, 2u);
  }
  subscriber::makeSimSlotRange();
  v4 = v30;
  if (v30 != v31)
  {
    while ((v32(*v4) & 1) == 0)
    {
      if (++v4 == v31)
      {
        v4 = v31;
        break;
      }
    }
    while (v4 != v31)
    {
      if (*v4 == 1)
      {
        v5 = "registration.1";
      }
      else if (*v4 == 2)
      {
        v5 = "registration.2";
      }
      else
      {
        v5 = 0;
      }
      v6 = *(std::__shared_weak_count **)(v2 + 16);
      if (!v6 || (v7 = *(_QWORD *)(v2 + 8), (v8 = std::__shared_weak_count::lock(v6)) == 0))
        std::__throw_bad_weak_ptr[abi:ne180100]();
      v9 = v8;
      p_shared_weak_owners = (unint64_t *)&v8->__shared_weak_owners_;
      do
        v11 = __ldxr(p_shared_weak_owners);
      while (__stxr(v11 + 1, p_shared_weak_owners));
      p_shared_owners = (unint64_t *)&v8->__shared_owners_;
      do
        v13 = __ldaxr(p_shared_owners);
      while (__stlxr(v13 - 1, p_shared_owners));
      if (!v13)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v9);
      }
      Registry::getServerConnection(*(Registry **)(v2 + 48));
      buf = 0u;
      v43 = 0u;
      std::string::basic_string[abi:ne180100]<0>(v34, v5);
      v14 = *(NSObject **)(v2 + 24);
      v41 = v14;
      if (v14)
        dispatch_retain(v14);
      std::string::basic_string[abi:ne180100]<0>(&__p, "registration");
      v37 = 0;
      v38 = 0;
      v15 = std::__shared_weak_count::lock(v9);
      if (v15)
      {
        v16 = v15;
        v17 = (unint64_t *)&v15->__shared_weak_owners_;
        do
          v18 = __ldxr(v17);
        while (__stxr(v18 + 1, v17));
        v37 = v7;
        v38 = v15;
        std::__shared_weak_count::__release_weak(v9);
        v19 = (unint64_t *)&v16->__shared_owners_;
        do
          v20 = __ldaxr(v19);
        while (__stlxr(v20 - 1, v19));
        if (v20)
          goto LABEL_32;
        ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
        v9 = v16;
      }
      else
      {
        v37 = 0;
        v38 = 0;
      }
      std::__shared_weak_count::__release_weak(v9);
LABEL_32:
      v36 = v33;
      v33 = 0uLL;
      qmi::Client::createWithQueueLocal();
      v21 = (std::__shared_weak_count *)*((_QWORD *)&v36 + 1);
      if (*((_QWORD *)&v36 + 1))
      {
        v22 = (unint64_t *)(*((_QWORD *)&v36 + 1) + 8);
        do
          v23 = __ldaxr(v22);
        while (__stlxr(v23 - 1, v22));
        if (!v23)
        {
          ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
          std::__shared_weak_count::__release_weak(v21);
        }
      }
      if (v38)
        std::__shared_weak_count::__release_weak(v38);
      if (v40 < 0)
        operator delete(__p);
      if (v41)
        dispatch_release(v41);
      if (SBYTE7(v35) < 0)
        operator delete(v34[0]);
      v34[0] = 0;
      v34[1] = 0;
      v35 = v43;
      v43 = 0uLL;
      qmi::ClientRouter::addClient();
      qmi::Client::~Client((qmi::Client *)v34);
      qmi::ClientRouter::get();
      qmi::Client::~Client((qmi::Client *)&buf);
      if (*((_QWORD *)&v33 + 1))
      {
        v24 = (unint64_t *)(*((_QWORD *)&v33 + 1) + 8);
        do
          v25 = __ldaxr(v24);
        while (__stlxr(v25 - 1, v24));
        if (!v25)
        {
          (*(void (**)(_QWORD))(**((_QWORD **)&v33 + 1) + 16))(*((_QWORD *)&v33 + 1));
          std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v33 + 1));
        }
      }
      v26 = v4 + 1;
      v4 = v31;
      if (v26 != v31)
      {
        v4 = v26;
        while ((v32(*v4) & 1) == 0)
        {
          if (++v4 == v31)
          {
            v4 = v31;
            break;
          }
        }
      }
    }
  }
  std::unique_ptr<Mav20PreferredNetworksFactoryCommandDriver::create(std::shared_ptr<Registry const>,dispatch::queue)::$_0,std::default_delete<Mav20PreferredNetworksFactoryCommandDriver::create(std::shared_ptr<Registry const>,dispatch::queue)::$_0>>::~unique_ptr[abi:ne180100](&v29);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v28);
}

void sub_216A782F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,std::__shared_weak_count *a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  std::unique_ptr<Mav20PreferredNetworksFactoryCommandDriver::create(std::shared_ptr<Registry const>,dispatch::queue)::$_0,std::default_delete<Mav20PreferredNetworksFactoryCommandDriver::create(std::shared_ptr<Registry const>,dispatch::queue)::$_0>>::~unique_ptr[abi:ne180100](&a13);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&a12);
  _Unwind_Resume(a1);
}

void SimInstanceLoggable<QMINetworkRegistrationDriver,ctu::OsLogLogger,subscriber::SimSlot>::~SimInstanceLoggable()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t SimInstanceLoggable<QMINetworkRegistrationDriver,ctu::OsLogLogger,subscriber::SimSlot>::getLoggerForSlot(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8) + 40;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver24bindNASSubscription_syncENS_16SubscriptionTypeEE3__0EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  unsigned int v4;
  uint64_t v5;
  NSObject *v7;
  uint64_t v8;
  int v9;
  capabilities::ct *v10;
  uint64_t v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *p_shared_owners;
  uint64_t v15;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _OWORD v23[2];
  _QWORD aBlock[5];
  _BYTE buf[24];
  void *v26;
  std::__shared_weak_count *v27;
  std::__shared_weak_count *v28;
  uint64_t v29;

  v29 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(_QWORD *)v2;
  v4 = *(_DWORD *)(v2 + 8);
  if (v4 - 1 >= 3)
    v5 = 0;
  else
    v5 = v4;
  if (*(_DWORD *)(a2 + 4))
  {
    v7 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v3 + 88) + 16))(*(_QWORD *)(v3 + 88), v5);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      v8 = qmi::asString();
      v9 = *(_DWORD *)(a2 + 4);
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = v8;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v9;
      _os_log_impl(&dword_216897000, v7, OS_LOG_TYPE_DEFAULT, "#N Error binding NAS subscription: %s (0x%x)", buf, 0x12u);
    }
  }
  QMINetworkRegistrationDriver::sendIndRegisterReq_sync(v3, *(unsigned int *)(v2 + 8));
  QMINetworkRegistrationDriver::getImsPreferenceInfo_sync(v3, *(unsigned int *)(v2 + 8));
  if (capabilities::ct::supports5G(v10))
  {
    memset(v23, 0, sizeof(v23));
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v23);
    v11 = qmi::ClientRouter::get();
    v12 = operator new();
    *(_QWORD *)v12 = v11;
    *(_QWORD *)(v12 + 8) = QMIServiceMsg::create();
    *(_DWORD *)(v12 + 16) = 25000;
    *(_QWORD *)(v12 + 24) = 0;
    *(_QWORD *)(v12 + 32) = 0;
    v22 = v12;
    v13 = (std::__shared_weak_count *)operator new(0x28uLL);
    v13->__shared_owners_ = 0;
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    v13->__shared_weak_owners_ = 0;
    v13->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E9520;
    v13[1].__vftable = (std::__shared_weak_count_vtbl *)v3;
    LODWORD(v13[1].__shared_owners_) = v5;
    v15 = MEMORY[0x24BDAC760];
    *(_QWORD *)buf = MEMORY[0x24BDAC760];
    *(_QWORD *)&buf[8] = 1174405120;
    *(_QWORD *)&buf[16] = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver23getNRDisableStatus_syncEN10subscriber7SimSlotEE3__0EEOS1_OT__block_invoke;
    v26 = &__block_descriptor_tmp_27_15;
    v27 = v13 + 1;
    v28 = v13;
    do
      v16 = __ldxr(p_shared_owners);
    while (__stxr(v16 + 1, p_shared_owners));
    aBlock[0] = v15;
    aBlock[1] = 0x40000000;
    aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas18GetNRDisableStatus8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
    aBlock[3] = &unk_24D5E9568;
    aBlock[4] = buf;
    *(_QWORD *)(v12 + 32) = _Block_copy(aBlock);
    v17 = v28;
    if (v28)
    {
      v18 = (unint64_t *)&v28->__shared_owners_;
      do
        v19 = __ldaxr(v18);
      while (__stlxr(v19 - 1, v18));
      if (!v19)
      {
        ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
        std::__shared_weak_count::__release_weak(v17);
      }
    }
    do
      v20 = __ldaxr(p_shared_owners);
    while (__stlxr(v20 - 1, p_shared_owners));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
    v21 = v22;
    v22 = 0;
    if (v21)
      std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v22, v21);
    qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v23);
  }
}

void sub_216A786BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,std::__shared_weak_count *a26)
{
  uint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  std::__shared_weak_count *v30;
  unint64_t *p_shared_owners;
  unint64_t v32;
  unint64_t v33;

  v30 = a26;
  if (a26)
  {
    p_shared_owners = (unint64_t *)&a26->__shared_owners_;
    do
      v32 = __ldaxr(p_shared_owners);
    while (__stlxr(v32 - 1, p_shared_owners));
    if (!v32)
    {
      ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
      std::__shared_weak_count::__release_weak(v30);
    }
  }
  do
    v33 = __ldaxr(v28);
  while (__stlxr(v33 - 1, v28));
  if (!v33)
  {
    ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
    std::__shared_weak_count::__release_weak(v27);
  }
  if (a10)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v26, a10);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a11);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_32c114_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver24bindNASSubscription_syncEN3qmi16SubscriptionTypeEE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c114_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver24bindNASSubscription_syncEN3qmi16SubscriptionTypeEE3__0EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::bindNASSubscription_sync(qmi::SubscriptionType)::$_0,std::allocator<QMINetworkRegistrationDriver::bindNASSubscription_sync(qmi::SubscriptionType)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E8A68;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::bindNASSubscription_sync(qmi::SubscriptionType)::$_0,std::allocator<QMINetworkRegistrationDriver::bindNASSubscription_sync(qmi::SubscriptionType)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E8A68;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas16BindSubscription8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke_7(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BYTE v3[24];

  v2 = *(_QWORD *)(a1 + 32);
  cast_message_type<nas::BindSubscription::Response const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_216A78844(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::PlmnModeBit>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::PlmnModeBit>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<nas::tlv::PlmnModeBit>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::PlmnModeBit>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E8AF8;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::CurrentPlmnNameEvent>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::CurrentPlmnNameEvent>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<nas::tlv::CurrentPlmnNameEvent>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::CurrentPlmnNameEvent>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E8B48;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkTimeEvents>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkTimeEvents>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkTimeEvents>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkTimeEvents>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E8B98;
  return result;
}

void ctu::shared_ptr_map_impl<ctu::indexed_by_any_map_hashing_key>::get<TimeHandlerInterface>(_QWORD *a1, std::mutex *this)
{
  unint64_t v4;
  unsigned __int8 *v5;
  uint64_t v6;
  unsigned int v7;
  _QWORD *v8;
  std::__shared_weak_count *v9;
  uint64_t v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;

  v4 = *(_QWORD *)(MEMORY[0x24BDC3C98] + 8);
  if ((v4 & 0x8000000000000000) != 0)
  {
    v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    v6 = 5381;
    do
    {
      v4 = v6;
      v7 = *v5++;
      v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(this);
  v16 = v4;
  v8 = std::__hash_table<std::__hash_value_type<unsigned long,std::shared_ptr<void>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::shared_ptr<void>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::shared_ptr<void>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::shared_ptr<void>>>>::find<unsigned long>(&this[1].__m_.__sig, &v16);
  if (v8)
  {
    v10 = v8[3];
    v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      p_shared_owners = (unint64_t *)&v9->__shared_owners_;
      do
        v12 = __ldxr(p_shared_owners);
      while (__stxr(v12 + 1, p_shared_owners));
    }
  }
  else
  {
    v10 = 0;
    v9 = 0;
  }
  std::mutex::unlock(this);
  *a1 = v10;
  a1[1] = v9;
  if (v9)
  {
    v13 = (unint64_t *)&v9->__shared_owners_;
    do
      v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
    do
      v15 = __ldaxr(v13);
    while (__stlxr(v15 - 1, v13));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
}

void sub_216A78B94(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

char *qmi::MutableMessageBase::getTLV<nas::tlv::NetworkTimeCachePeriod>(_QWORD *a1)
{
  const void **v2;
  const void **v3;
  char **v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  v4 = (char **)(a1 + 1);
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != 192)
    {
      if (++v2 == v3)
        goto LABEL_8;
    }
  }
  if (v2 == v3)
  {
LABEL_8:
    v7 = operator new();
    *(_BYTE *)(v7 + 8) = -64;
    *(_DWORD *)(v7 + 12) = 0;
    v6 = v7 + 12;
    *(_QWORD *)v7 = &off_24D5E8BE8;
    v8 = a1[3];
    v9 = (uint64_t *)a1[2];
    if ((unint64_t)v9 >= v8)
    {
      v11 = ((char *)v9 - *v4) >> 3;
      if ((unint64_t)(v11 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v12 = v8 - (_QWORD)*v4;
      v13 = v12 >> 2;
      if (v12 >> 2 <= (unint64_t)(v11 + 1))
        v13 = v11 + 1;
      if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
        v14 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v14 = v13;
      if (v14)
        v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v14);
      else
        v15 = 0;
      v16 = (uint64_t *)&v15[8 * v11];
      v17 = &v15[8 * v14];
      *v16 = v7;
      v10 = v16 + 1;
      v19 = (char *)a1[1];
      v18 = (char *)a1[2];
      if (v18 != v19)
      {
        do
        {
          v20 = *((_QWORD *)v18 - 1);
          v18 -= 8;
          *--v16 = v20;
        }
        while (v18 != v19);
        v18 = *v4;
      }
      a1[1] = v16;
      a1[2] = v10;
      a1[3] = v17;
      if (v18)
        operator delete(v18);
    }
    else
    {
      *v9 = v7;
      v10 = v9 + 1;
    }
    a1[2] = v10;
  }
  else
  {
    if (!v5)
      __cxa_bad_cast();
    return v5 + 12;
  }
  return (char *)v6;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkTimeCachePeriod>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkTimeCachePeriod>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

_DWORD **qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkTimeCachePeriod>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _DWORD *v4;
  uint64_t v5;
  _DWORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_DWORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::PktDataHandle>((_DWORD **)a2, (_DWORD *)(a1 + 12));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkTimeCachePeriod>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E8BE8;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a1 + 12);
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::IpPrefStatus>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::IpPrefStatus>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<nas::tlv::IpPrefStatus>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::IpPrefStatus>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E8C38;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::SubscriptionChangeIndications>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::SubscriptionChangeIndications>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<nas::tlv::SubscriptionChangeIndications>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::SubscriptionChangeIndications>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E8C88;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::E911ReadyStatus>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::E911ReadyStatus>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<nas::tlv::E911ReadyStatus>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::E911ReadyStatus>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E8CD8;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::T3402TimerChange>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::T3402TimerChange>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<nas::tlv::T3402TimerChange>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::T3402TimerChange>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E8D28;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkRejectIndications>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkRejectIndications>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_PcoMcc>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkRejectIndications>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::ProfileIdentifer>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkRejectIndications>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E8D78;
  *(_WORD *)(result + 9) = *(_WORD *)(a1 + 9);
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::NRDisableStatusIndication>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::NRDisableStatusIndication>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<nas::tlv::NRDisableStatusIndication>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::NRDisableStatusIndication>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E8DC8;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::GeoPlmnIndication>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::GeoPlmnIndication>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<nas::tlv::GeoPlmnIndication>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::GeoPlmnIndication>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E8E18;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::E911ScanFailInd>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::E911ScanFailInd>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<nas::tlv::E911ScanFailInd>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::E911ScanFailInd>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E8E68;
  return result;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver23sendIndRegisterReq_syncENS_16SubscriptionTypeEE4__15EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  int v2;
  NSObject *v3;
  _DWORD v4[2];
  __int16 v5;
  uint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v2 = *(_DWORD *)(a2 + 4);
  if (v2)
  {
    v3 = ***(NSObject ****)(a1 + 32);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      v4[0] = 67109378;
      v4[1] = v2;
      v5 = 2080;
      v6 = qmi::asString();
      _os_log_impl(&dword_216897000, v3, OS_LOG_TYPE_DEFAULT, "#N Register for indications failed: Error in response with code %d (%s)", (uint8_t *)v4, 0x12u);
    }
  }
}

uint64_t __copy_helper_block_e8_32c114_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver23sendIndRegisterReq_syncEN3qmi16SubscriptionTypeEE4__15EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c114_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver23sendIndRegisterReq_syncEN3qmi16SubscriptionTypeEE4__15EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::sendIndRegisterReq_sync(qmi::SubscriptionType)::$_15,std::allocator<QMINetworkRegistrationDriver::sendIndRegisterReq_sync(qmi::SubscriptionType)::$_15>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E8ED0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::sendIndRegisterReq_sync(qmi::SubscriptionType)::$_15,std::allocator<QMINetworkRegistrationDriver::sendIndRegisterReq_sync(qmi::SubscriptionType)::$_15>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E8ED0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::EmergencyMode>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::EmergencyMode>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<nas::tlv::EmergencyMode>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::EmergencyMode>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E8F38;
  return result;
}

uint64_t __copy_helper_block_e8_32c83_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver16setEmergencyModeEbE3__1EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c83_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver16setEmergencyModeEbE3__1EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::setEmergencyMode(BOOL)::$_1,std::allocator<QMINetworkRegistrationDriver::setEmergencyMode(BOOL)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E8FA0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::setEmergencyMode(BOOL)::$_1,std::allocator<QMINetworkRegistrationDriver::setEmergencyMode(BOOL)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E8FA0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::Enable2G>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::Enable2G>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<nas::tlv::Enable2G>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::Enable2G>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E9008;
  return result;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver8enable2GEN10subscriber7SimSlotEb16SetMaxRateSourceE3__1EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  os_log_t *v3;
  int v4;
  BOOL v5;
  NSObject *v6;
  _DWORD v8[2];
  __int16 v9;
  uint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v3 = (os_log_t *)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(**(_QWORD **)(a1 + 32) + 88) + 16))(*(_QWORD *)(**(_QWORD **)(a1 + 32) + 88), *(unsigned int *)(*(_QWORD *)(a1 + 32) + 8));
  v4 = *(_DWORD *)(a2 + 4);
  if (v4)
    v5 = v4 == 26;
  else
    v5 = 1;
  if (!v5)
  {
    v6 = *v3;
    if (os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT))
    {
      v8[0] = 67109378;
      v8[1] = v4;
      v9 = 2080;
      v10 = qmi::asString();
      _os_log_impl(&dword_216897000, v6, OS_LOG_TYPE_DEFAULT, "#N Set 2G enable failed: Error in response with code %d (%s)", (uint8_t *)v8, 0x12u);
    }
  }
}

uint64_t __copy_helper_block_e8_32c114_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver8enable2GEN10subscriber7SimSlotEb16SetMaxRateSourceE3__1EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c114_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver8enable2GEN10subscriber7SimSlotEb16SetMaxRateSourceE3__1EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::enable2G(subscriber::SimSlot,BOOL,SetMaxRateSource)::$_1,std::allocator<QMINetworkRegistrationDriver::enable2G(subscriber::SimSlot,BOOL,SetMaxRateSource)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E9070;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::enable2G(subscriber::SimSlot,BOOL,SetMaxRateSource)::$_1,std::allocator<QMINetworkRegistrationDriver::enable2G(subscriber::SimSlot,BOOL,SetMaxRateSource)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E9070;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::Enable3G>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::Enable3G>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<nas::tlv::Enable3G>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::Enable3G>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E90D8;
  return result;
}

uint64_t ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver8enable3GEN10subscriber7SimSlotEb16SetMaxRateSourceE3__1EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t *v3;
  uint64_t v4;
  os_log_t *v5;
  int v6;
  BOOL v7;
  NSObject *v9;
  _DWORD v11[2];
  __int16 v12;
  uint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v3 = *(uint64_t **)(a1 + 32);
  v4 = *v3;
  v5 = (os_log_t *)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(*v3 + 88) + 16))(*(_QWORD *)(*v3 + 88), *((unsigned int *)v3 + 2));
  v6 = *(_DWORD *)(a2 + 4);
  if (v6)
    v7 = v6 == 26;
  else
    v7 = 1;
  if (v7)
    return (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, _QWORD))(**(_QWORD **)(v4 + 64) + 112))(*(_QWORD *)(v4 + 64), *((unsigned int *)v3 + 2), 1, *((unsigned __int8 *)v3 + 12));
  v9 = *v5;
  if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
  {
    v11[0] = 67109378;
    v11[1] = v6;
    v12 = 2080;
    v13 = qmi::asString();
    _os_log_impl(&dword_216897000, v9, OS_LOG_TYPE_DEFAULT, "#N Set 3G enable failed: Error in response with code %d (%s)", (uint8_t *)v11, 0x12u);
  }
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD))(**(_QWORD **)(v4 + 64) + 112))(*(_QWORD *)(v4 + 64), *((unsigned int *)v3 + 2), 0, *((unsigned __int8 *)v3 + 12));
}

uint64_t __copy_helper_block_e8_32c114_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver8enable3GEN10subscriber7SimSlotEb16SetMaxRateSourceE3__1EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c114_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver8enable3GEN10subscriber7SimSlotEb16SetMaxRateSourceE3__1EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::enable3G(subscriber::SimSlot,BOOL,SetMaxRateSource)::$_1,std::allocator<QMINetworkRegistrationDriver::enable3G(subscriber::SimSlot,BOOL,SetMaxRateSource)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E9140;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::enable3G(subscriber::SimSlot,BOOL,SetMaxRateSource)::$_1,std::allocator<QMINetworkRegistrationDriver::enable3G(subscriber::SimSlot,BOOL,SetMaxRateSource)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E9140;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::EnableLTE>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::EnableLTE>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<nas::tlv::EnableLTE>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::EnableLTE>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E91A8;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::EnableLTEUpdateReason>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::EnableLTEUpdateReason>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<nas::tlv::EnableLTEUpdateReason>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::IPPref>((_BYTE **)a2, (_DWORD *)(a1 + 12));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::EnableLTEUpdateReason>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E91F8;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a1 + 12);
  return result;
}

uint64_t ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver9enableLTEEN10subscriber7SimSlotEb16SetMaxRateSourceE3__2EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t *v2;
  uint64_t v3;
  int v4;
  NSObject *v5;
  _DWORD v7[2];
  __int16 v8;
  uint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v2 = *(uint64_t **)(a1 + 32);
  v3 = *v2;
  v4 = *(_DWORD *)(a2 + 4);
  if (!v4)
    return (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, _QWORD))(**(_QWORD **)(v3 + 64) + 104))(*(_QWORD *)(v3 + 64), *((unsigned int *)v2 + 2), 1, *((unsigned __int8 *)v2 + 12));
  v5 = *(NSObject **)v2[2];
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    v7[0] = 67109378;
    v7[1] = v4;
    v8 = 2080;
    v9 = qmi::asString();
    _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#N Set LTE enable failed: Error in response with code %d (%s)", (uint8_t *)v7, 0x12u);
  }
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD))(**(_QWORD **)(v3 + 64) + 104))(*(_QWORD *)(v3 + 64), *((unsigned int *)v2 + 2), 0, *((unsigned __int8 *)v2 + 12));
}

uint64_t __copy_helper_block_e8_32c115_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver9enableLTEEN10subscriber7SimSlotEb16SetMaxRateSourceE3__2EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c115_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver9enableLTEEN10subscriber7SimSlotEb16SetMaxRateSourceE3__2EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::enableLTE(subscriber::SimSlot,BOOL,SetMaxRateSource)::$_2,std::allocator<QMINetworkRegistrationDriver::enableLTE(subscriber::SimSlot,BOOL,SetMaxRateSource)::$_2>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E9260;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::enableLTE(subscriber::SimSlot,BOOL,SetMaxRateSource)::$_2,std::allocator<QMINetworkRegistrationDriver::enableLTE(subscriber::SimSlot,BOOL,SetMaxRateSource)::$_2>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E9260;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::EnableNr>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::EnableNr>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<nas::tlv::EnableNr>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::EnableNr>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E92C8;
  return result;
}

char *qmi::MutableMessageBase::getTLV<nas::tlv::EnableNrUpdateReason>(_QWORD *a1)
{
  const void **v2;
  const void **v3;
  char **v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  v4 = (char **)(a1 + 1);
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != 164)
    {
      if (++v2 == v3)
        goto LABEL_8;
    }
  }
  if (v2 == v3)
  {
LABEL_8:
    v7 = operator new();
    *(_BYTE *)(v7 + 8) = -92;
    *(_DWORD *)(v7 + 12) = 0;
    v6 = v7 + 12;
    *(_QWORD *)v7 = &off_24D5E9318;
    v8 = a1[3];
    v9 = (uint64_t *)a1[2];
    if ((unint64_t)v9 >= v8)
    {
      v11 = ((char *)v9 - *v4) >> 3;
      if ((unint64_t)(v11 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v12 = v8 - (_QWORD)*v4;
      v13 = v12 >> 2;
      if (v12 >> 2 <= (unint64_t)(v11 + 1))
        v13 = v11 + 1;
      if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
        v14 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v14 = v13;
      if (v14)
        v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v14);
      else
        v15 = 0;
      v16 = (uint64_t *)&v15[8 * v11];
      v17 = &v15[8 * v14];
      *v16 = v7;
      v10 = v16 + 1;
      v19 = (char *)a1[1];
      v18 = (char *)a1[2];
      if (v18 != v19)
      {
        do
        {
          v20 = *((_QWORD *)v18 - 1);
          v18 -= 8;
          *--v16 = v20;
        }
        while (v18 != v19);
        v18 = *v4;
      }
      a1[1] = v16;
      a1[2] = v10;
      a1[3] = v17;
      if (v18)
        operator delete(v18);
    }
    else
    {
      *v9 = v7;
      v10 = v9 + 1;
    }
    a1[2] = v10;
  }
  else
  {
    if (!v5)
      __cxa_bad_cast();
    return v5 + 12;
  }
  return (char *)v6;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::EnableNrUpdateReason>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::EnableNrUpdateReason>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<nas::tlv::EnableNrUpdateReason>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::IPPref>((_BYTE **)a2, (_DWORD *)(a1 + 12));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::EnableNrUpdateReason>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E9318;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a1 + 12);
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::NrRoamingConfig>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::NrRoamingConfig>::getSize()
{
  return tlv::size<wms::tlv::MemoryStorageIdentification>();
}

uint64_t *qmi::MutableMessageBase::TlvWrapper<nas::tlv::NrRoamingConfig>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t *result;
  uint64_t v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = *a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<nas::tlv::NetworkSelectionPreference>(a2, a1 + 10);
  v7 = *a2 - v5;
  *(_BYTE *)v4 = v3;
  *(_WORD *)(v4 + 1) = v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::NrRoamingConfig>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E9368;
  *(_DWORD *)(result + 10) = *(_DWORD *)(a1 + 10);
  *(_WORD *)(result + 14) = *(_WORD *)(a1 + 14);
  return result;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver8enable5GEN10subscriber7SimSlotEj16SetMaxRateSourcebE3__3EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  int v2;
  uint64_t v3;
  NSObject *v4;
  const char *v5;
  int v6;
  const char *v7;
  __int16 v8;
  int v9;
  __int16 v10;
  uint64_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v2 = *(_DWORD *)(a2 + 4);
  if (v2)
  {
    v3 = *(_QWORD *)(a1 + 32);
    v4 = **(NSObject ***)v3;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      if (*(_DWORD *)(v3 + 8))
        v5 = "enabled";
      else
        v5 = "disabled";
      v6 = 136315650;
      v7 = v5;
      v8 = 1024;
      v9 = v2;
      v10 = 2080;
      v11 = qmi::asString();
      _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#N Set 5G %s mode failed: Error in response with code %d (%s)", (uint8_t *)&v6, 0x1Cu);
    }
  }
}

uint64_t __copy_helper_block_e8_32c115_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver8enable5GEN10subscriber7SimSlotEj16SetMaxRateSourcebE3__3EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c115_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver8enable5GEN10subscriber7SimSlotEj16SetMaxRateSourcebE3__3EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::enable5G(subscriber::SimSlot,unsigned int,SetMaxRateSource,BOOL)::$_3,std::allocator<QMINetworkRegistrationDriver::enable5G(subscriber::SimSlot,unsigned int,SetMaxRateSource,BOOL)::$_3>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E93D0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::enable5G(subscriber::SimSlot,unsigned int,SetMaxRateSource,BOOL)::$_3,std::allocator<QMINetworkRegistrationDriver::enable5G(subscriber::SimSlot,unsigned int,SetMaxRateSource,BOOL)::$_3>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E93D0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

char *qmi::MutableMessageBase::getTLV<nas::tlv::NRDisableMode>(_QWORD *a1)
{
  const void **v2;
  const void **v3;
  char **v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  v4 = (char **)(a1 + 1);
  if (v2 != v3)
  {
    while (*((_BYTE *)*v2 + 8) != 46)
    {
      if (++v2 == v3)
        goto LABEL_8;
    }
  }
  if (v2 == v3)
  {
LABEL_8:
    v7 = operator new();
    *(_BYTE *)(v7 + 8) = 46;
    *(_DWORD *)(v7 + 12) = 0;
    v6 = v7 + 12;
    *(_QWORD *)v7 = &off_24D5E9438;
    v8 = a1[3];
    v9 = (uint64_t *)a1[2];
    if ((unint64_t)v9 >= v8)
    {
      v11 = ((char *)v9 - *v4) >> 3;
      if ((unint64_t)(v11 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v12 = v8 - (_QWORD)*v4;
      v13 = v12 >> 2;
      if (v12 >> 2 <= (unint64_t)(v11 + 1))
        v13 = v11 + 1;
      if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
        v14 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v14 = v13;
      if (v14)
        v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v14);
      else
        v15 = 0;
      v16 = (uint64_t *)&v15[8 * v11];
      v17 = &v15[8 * v14];
      *v16 = v7;
      v10 = v16 + 1;
      v19 = (char *)a1[1];
      v18 = (char *)a1[2];
      if (v18 != v19)
      {
        do
        {
          v20 = *((_QWORD *)v18 - 1);
          v18 -= 8;
          *--v16 = v20;
        }
        while (v18 != v19);
        v18 = *v4;
      }
      a1[1] = v16;
      a1[2] = v10;
      a1[3] = v17;
      if (v18)
        operator delete(v18);
    }
    else
    {
      *v9 = v7;
      v10 = v9 + 1;
    }
    a1[2] = v10;
  }
  else
  {
    if (!v5)
      __cxa_bad_cast();
    return v5 + 12;
  }
  return (char *)v6;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::NRDisableMode>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::NRDisableMode>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

_DWORD **qmi::MutableMessageBase::TlvWrapper<nas::tlv::NRDisableMode>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _DWORD *v4;
  uint64_t v5;
  _DWORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_DWORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::PktDataHandle>((_DWORD **)a2, (_DWORD *)(a1 + 12));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::NRDisableMode>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E9438;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a1 + 12);
  return result;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver18enable5GStandaloneEN10subscriber7SimSlotEb16SetMaxRateSourceE3__2EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  int v2;
  uint64_t v3;
  NSObject *v4;
  const char *v5;
  int v6;
  const char *v7;
  __int16 v8;
  int v9;
  __int16 v10;
  uint64_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v2 = *(_DWORD *)(a2 + 4);
  if (v2)
  {
    v3 = *(_QWORD *)(a1 + 32);
    v4 = **(NSObject ***)v3;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      if (*(_BYTE *)(v3 + 8))
        v5 = "enabled";
      else
        v5 = "disabled";
      v6 = 136315650;
      v7 = v5;
      v8 = 1024;
      v9 = v2;
      v10 = 2080;
      v11 = qmi::asString();
      _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#N Set 5G Standalone %s failed: Error in response with code %d (%s)", (uint8_t *)&v6, 0x1Cu);
    }
  }
}

uint64_t __copy_helper_block_e8_32c125_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver18enable5GStandaloneEN10subscriber7SimSlotEb16SetMaxRateSourceE3__2EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c125_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver18enable5GStandaloneEN10subscriber7SimSlotEb16SetMaxRateSourceE3__2EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::enable5GStandalone(subscriber::SimSlot,BOOL,SetMaxRateSource)::$_2,std::allocator<QMINetworkRegistrationDriver::enable5GStandalone(subscriber::SimSlot,BOOL,SetMaxRateSource)::$_2>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E94A0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::enable5GStandalone(subscriber::SimSlot,BOOL,SetMaxRateSource)::$_2,std::allocator<QMINetworkRegistrationDriver::enable5GStandalone(subscriber::SimSlot,BOOL,SetMaxRateSource)::$_2>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E94A0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver23getNRDisableStatus_syncEN10subscriber7SimSlotEE3__0EEOS1_OT__block_invoke(uint64_t a1, qmi::MessageBase *a2)
{
  unsigned int *v3;
  uint64_t v4;
  os_log_t *v5;
  int v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t TlvValue;
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  _QWORD v27[3];

  v27[2] = *MEMORY[0x24BDAC8D0];
  v3 = *(unsigned int **)(a1 + 32);
  v4 = *(_QWORD *)v3;
  v5 = (os_log_t *)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(*(_QWORD *)v3 + 88) + 16))(*(_QWORD *)(*(_QWORD *)v3 + 88), v3[2]);
  v6 = *((_DWORD *)a2 + 1);
  if (v6)
  {
    v7 = *v5;
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR))
    {
      LODWORD(v26) = 67109378;
      HIDWORD(v26) = v6;
      LOWORD(v27[0]) = 2080;
      *(_QWORD *)((char *)v27 + 2) = qmi::asString();
      _os_log_error_impl(&dword_216897000, v7, OS_LOG_TYPE_ERROR, "Get NR disable status failed: Error in response with code %d (%s)", (uint8_t *)&v26, 0x12u);
    }
  }
  else
  {
    v8 = *(_QWORD *)(v4 + 64);
    v9 = v3[2];
    TlvValue = qmi::MessageBase::findTlvValue(a2);
    v12 = TlvValue;
    if (TlvValue)
    {
      v13 = v11;
      v26 = TlvValue;
      tlv::parseV<nas::tlv::IsSADisabled>((unint64_t *)&v26, v11);
      if (!v26)
        ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 16, v12, v13);
    }
    v14 = qmi::MessageBase::findTlvValue(a2);
    if (v14)
    {
      v16 = v14;
      v17 = v15;
      v26 = v14;
      tlv::parseV<nas::tlv::SADisableReasonMask>((unint64_t *)&v26, v15);
      if (!v26)
        ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 18, v16, v17);
    }
    v18 = qmi::MessageBase::findTlvValue(a2);
    v20 = v18;
    if (v18)
    {
      v21 = v19;
      v26 = v18;
      tlv::parseV<nas::tlv::IsNSADisabled>((unint64_t *)&v26, v19);
      if (!v26)
        ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 17, v20, v21);
    }
    v22 = qmi::MessageBase::findTlvValue(a2);
    if (v22)
    {
      v24 = v22;
      v25 = v23;
      v26 = v22;
      tlv::parseV<nas::tlv::NSADisableReasonMask>((unint64_t *)&v26, v23);
      if (!v26)
        ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 19, v24, v25);
    }
    NRDisableStatus::NRDisableStatus((NRDisableStatus *)&v26);
    (*(void (**)(uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)v8 + 216))(v8, v9, v26, v27[0]);
  }
}

uint64_t __copy_helper_block_e8_32c111_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver23getNRDisableStatus_syncEN10subscriber7SimSlotEE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c111_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver23getNRDisableStatus_syncEN10subscriber7SimSlotEE3__0EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::getNRDisableStatus_sync(subscriber::SimSlot)::$_0,std::allocator<QMINetworkRegistrationDriver::getNRDisableStatus_sync(subscriber::SimSlot)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E9520;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::getNRDisableStatus_sync(subscriber::SimSlot)::$_0,std::allocator<QMINetworkRegistrationDriver::getNRDisableStatus_sync(subscriber::SimSlot)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E9520;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas18GetNRDisableStatus8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A7AB9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::CdmaSwitch>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::CdmaSwitch>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<nas::tlv::CdmaSwitch>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::CdmaSwitch>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E95B0;
  return result;
}

_QWORD *qmi::MutableMessageBase::TlvWrapper<nas::tlv::EquivalentCountryCodeList>::~TlvWrapper(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24D5E9600;
  v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::EquivalentCountryCodeList>::~TlvWrapper(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24D5E9600;
  v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::EquivalentCountryCodeList>::getSize(uint64_t a1)
{
  return tlv::size<wds::tlv::NextHdrProtList>((_QWORD *)(a1 + 16));
}

void *qmi::MutableMessageBase::TlvWrapper<nas::tlv::EquivalentCountryCodeList>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  void *result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::DestPortList>((_BYTE **)a2, (_DWORD *)(a1 + 16));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::EquivalentCountryCodeList>::clone(uint64_t a1)
{
  uint64_t v2;

  v2 = operator new();
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)v2 = &off_24D5E9600;
  *(_QWORD *)(v2 + 24) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 16) = 0;
  std::vector<unsigned short>::__init_with_size[abi:ne180100]<unsigned short *,unsigned short *>((_QWORD *)(v2 + 16), *(const void **)(a1 + 16), *(_QWORD *)(a1 + 24), (uint64_t)(*(_QWORD *)(a1 + 24) - *(_QWORD *)(a1 + 16)) >> 1);
  return v2;
}

void sub_216A7ADEC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199FEAC4](v1, 0x1091C40A3A4EB6ALL);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver27setCdmaRoamingSwitchSettingEN10subscriber7SimSlotEbRKNSt3__16vectorItNS6_9allocatorItEEEEE3__2EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  int v2;
  NSObject *v3;
  _DWORD v4[2];
  __int16 v5;
  uint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v2 = *(_DWORD *)(a2 + 4);
  if (v2)
  {
    v3 = ***(NSObject ****)(a1 + 32);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      v4[0] = 67109378;
      v4[1] = v2;
      v5 = 2080;
      v6 = qmi::asString();
      _os_log_impl(&dword_216897000, v3, OS_LOG_TYPE_DEFAULT, "#N Set System Selection failed: Error in response with code %d (%s)", (uint8_t *)v4, 0x12u);
    }
  }
}

uint64_t __copy_helper_block_e8_32c149_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver27setCdmaRoamingSwitchSettingEN10subscriber7SimSlotEbRKNS_6vectorItNS_9allocatorItEEEEE3__2EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c149_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver27setCdmaRoamingSwitchSettingEN10subscriber7SimSlotEbRKNS_6vectorItNS_9allocatorItEEEEE3__2EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::setCdmaRoamingSwitchSetting(subscriber::SimSlot,BOOL,std::vector<unsigned short> const&)::$_2,std::allocator<QMINetworkRegistrationDriver::setCdmaRoamingSwitchSetting(subscriber::SimSlot,BOOL,std::vector<unsigned short> const&)::$_2>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E9668;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::setCdmaRoamingSwitchSetting(subscriber::SimSlot,BOOL,std::vector<unsigned short> const&)::$_2,std::allocator<QMINetworkRegistrationDriver::setCdmaRoamingSwitchSetting(subscriber::SimSlot,BOOL,std::vector<unsigned short> const&)::$_2>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E9668;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::GwAcqOrderPref>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::GwAcqOrderPref>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

_DWORD **qmi::MutableMessageBase::TlvWrapper<nas::tlv::GwAcqOrderPref>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _DWORD *v4;
  uint64_t v5;
  _DWORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_DWORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::PktDataHandle>((_DWORD **)a2, (_DWORD *)(a1 + 12));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::GwAcqOrderPref>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E96D0;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a1 + 12);
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::RoamingPreference>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::RoamingPreference>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_PcoMcc>();
}

_WORD **qmi::MutableMessageBase::TlvWrapper<nas::tlv::RoamingPreference>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _WORD *v4;
  uint64_t v5;
  _WORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_WORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::Profile3GPP_PcoMcc>((_WORD **)a2, (_WORD *)(a1 + 10));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::RoamingPreference>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E9720;
  *(_WORD *)(result + 10) = *(_WORD *)(a1 + 10);
  return result;
}

uint64_t ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver28setSystemSelectionPreferenceEN10subscriber7SimSlotEhNSt3__18optionalIjEENS7_IbEEE3__6EEOS1_OT__block_invoke(uint64_t result, uint64_t a2)
{
  int v2;
  uint64_t *v3;
  uint64_t v4;
  NSObject *v5;
  _DWORD v6[2];
  __int16 v7;
  uint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v2 = *(_DWORD *)(a2 + 4);
  if (v2)
  {
    v3 = *(uint64_t **)(result + 32);
    v4 = *v3;
    v5 = *(NSObject **)v3[2];
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v6[0] = 67109378;
      v6[1] = v2;
      v7 = 2080;
      v8 = qmi::asString();
      _os_log_error_impl(&dword_216897000, v5, OS_LOG_TYPE_ERROR, "Set System Selection failed: Error in response with code %d (%s)", (uint8_t *)v6, 0x12u);
    }
    return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)(v4 + 64) + 48))(*(_QWORD *)(v4 + 64), *((unsigned int *)v3 + 2), *((unsigned __int8 *)v3 + 12));
  }
  return result;
}

uint64_t __copy_helper_block_e8_32c141_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver28setSystemSelectionPreferenceEN10subscriber7SimSlotEhNS_8optionalIjEENS4_IbEEE3__6EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c141_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver28setSystemSelectionPreferenceEN10subscriber7SimSlotEhNS_8optionalIjEENS4_IbEEE3__6EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::setSystemSelectionPreference(subscriber::SimSlot,unsigned char,std::optional<unsigned int>,std::optional<BOOL>)::$_6,std::allocator<QMINetworkRegistrationDriver::setSystemSelectionPreference(subscriber::SimSlot,unsigned char,std::optional<unsigned int>,std::optional<BOOL>)::$_6>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E9788;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::setSystemSelectionPreference(subscriber::SimSlot,unsigned char,std::optional<unsigned int>,std::optional<BOOL>)::$_6,std::allocator<QMINetworkRegistrationDriver::setSystemSelectionPreference(subscriber::SimSlot,unsigned char,std::optional<unsigned int>,std::optional<BOOL>)::$_6>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E9788;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver28getSystemSelectionPreferenceEN10subscriber7SimSlotEE3__0EEOS1_OT__block_invoke(uint64_t a1, qmi::MessageBase *this)
{
  uint64_t v2;
  int v3;
  NSObject *v4;
  capabilities::ct *v6;
  uint64_t TlvValue;
  int v8;
  int v9;
  int v10;
  capabilities::ct *v11;
  unsigned int v12;
  int v13;
  uint64_t v14;
  unsigned int v15;
  int v16;
  uint64_t v17;
  NSObject *v18;
  uint64_t v19;
  uint64_t v20;
  __int16 v21;
  uint64_t v22;
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 32);
  v3 = *((_DWORD *)this + 1);
  if (v3)
  {
    v4 = **(NSObject ***)(v2 + 16);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v20) = 67109378;
      HIDWORD(v20) = v3;
      v21 = 2080;
      v22 = qmi::asString();
      _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#N Get System Selection failed: Error in response with code %d (%s)", (uint8_t *)&v20, 0x12u);
    }
    return;
  }
  v6 = *(capabilities::ct **)v2;
  TlvValue = qmi::MessageBase::findTlvValue(this);
  if (TlvValue)
  {
    LODWORD(v20) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::ModePreference>(this, (uint64_t)&v20);
    if (!(_BYTE)v20)
      goto LABEL_27;
    v8 = WORD1(v20) & 0xFF00;
    v9 = BYTE2(v20);
    v10 = 0x10000;
  }
  else
  {
    v10 = 0;
    v9 = 0;
    v8 = 0;
  }
  v11 = (capabilities::ct *)qmi::MessageBase::findTlvValue(this);
  if (v11)
  {
    v20 = 0;
    v11 = (capabilities::ct *)qmi::MessageBase::tryTlv<nas::tlv::GwAcqOrderPref>(this, (uint64_t)&v20);
    if (!(_BYTE)v20)
      goto LABEL_27;
    v12 = HIDWORD(v20) & 0xFFFFFF00;
    v13 = BYTE4(v20);
    v14 = 0x100000000;
  }
  else
  {
    v12 = 0;
    v13 = 0;
    v14 = 0;
  }
  if (capabilities::ct::supports5G(v11) && qmi::MessageBase::findTlvValue(this))
  {
    v20 = 0;
    qmi::MessageBase::tryTlv<nas::tlv::NRDisableMode>(this, (uint64_t)&v20);
    if ((_BYTE)v20)
    {
      v15 = HIDWORD(v20) & 0xFFFFFF00;
      v16 = BYTE4(v20);
      v17 = 0x100000000;
      if (!TlvValue)
        goto LABEL_16;
      goto LABEL_19;
    }
LABEL_27:
    __assert_rtn("get", "optional.hpp", 1212, "this->is_initialized()");
  }
  v15 = 0;
  v16 = 0;
  v17 = 0;
  if (!TlvValue)
  {
LABEL_16:
    v18 = **(NSObject ***)(v2 + 16);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v20) = 0;
      _os_log_impl(&dword_216897000, v18, OS_LOG_TYPE_DEFAULT, "#I No mode preference present", (uint8_t *)&v20, 2u);
    }
    goto LABEL_20;
  }
LABEL_19:
  QMINetworkRegistrationDriver::handleModePreference_sync(v6, *(unsigned int *)(v2 + 8), v9 | v10 | v8, v14 | v13 | v12, v17 | v16 | v15);
LABEL_20:
  if (qmi::MessageBase::findTlvValue(this))
  {
    LOWORD(v20) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::EmergencyMode>(this, &v20);
    if (!(_BYTE)v20)
      __assert_rtn("get", "optional.hpp", 1212, "this->is_initialized()");
    if (BYTE1(v20))
      v19 = 257;
    else
      v19 = 1;
    (*(void (**)(_QWORD *, _QWORD, uint64_t))(**((_QWORD **)v6 + 8) + 24))(*((_QWORD **)v6 + 8), *(unsigned int *)(v2 + 8), v19);
  }
}

uint64_t __copy_helper_block_e8_32c116_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver28getSystemSelectionPreferenceEN10subscriber7SimSlotEE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c116_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver28getSystemSelectionPreferenceEN10subscriber7SimSlotEE3__0EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::getSystemSelectionPreference(subscriber::SimSlot)::$_0,std::allocator<QMINetworkRegistrationDriver::getSystemSelectionPreference(subscriber::SimSlot)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E9808;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::getSystemSelectionPreference(subscriber::SimSlot)::$_0,std::allocator<QMINetworkRegistrationDriver::getSystemSelectionPreference(subscriber::SimSlot)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E9808;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas28GetSystemSelectionPreference8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A7B618(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

uint64_t qmi::MessageBase::tryTlv<nas::tlv::ModePreference>(qmi::MessageBase *a1, uint64_t a2)
{
  uint64_t result;
  unint64_t v4;
  unint64_t v5[2];

  result = qmi::MessageBase::findTlvValue(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result)
  {
    result = tlv::parseV<nas::tlv::ModePreference>(v5, v4);
    if (!*(_BYTE *)a2)
      *(_BYTE *)a2 = 1;
    *(_WORD *)(a2 + 2) = result;
    if (!v5[0])
      *(_BYTE *)a2 = 0;
  }
  return result;
}

uint64_t qmi::MessageBase::tryTlv<nas::tlv::GwAcqOrderPref>(qmi::MessageBase *a1, uint64_t a2)
{
  uint64_t result;
  unint64_t v4;
  unint64_t v5[2];

  result = qmi::MessageBase::findTlvValue(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result)
  {
    result = tlv::parseV<nas::tlv::GwAcqOrderPref>(v5, v4);
    if (!*(_BYTE *)a2)
      *(_BYTE *)a2 = 1;
    *(_DWORD *)(a2 + 4) = result;
    if (!v5[0])
      *(_BYTE *)a2 = 0;
  }
  return result;
}

uint64_t qmi::MessageBase::tryTlv<nas::tlv::NRDisableMode>(qmi::MessageBase *a1, uint64_t a2)
{
  uint64_t result;
  unint64_t v4;
  unint64_t v5[2];

  result = qmi::MessageBase::findTlvValue(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result)
  {
    result = tlv::parseV<nas::tlv::NRDisableMode>(v5, v4);
    if (!*(_BYTE *)a2)
      *(_BYTE *)a2 = 1;
    *(_DWORD *)(a2 + 4) = result;
    if (!v5[0])
      *(_BYTE *)a2 = 0;
  }
  return result;
}

uint64_t qmi::MessageBase::tryTlv<nas::tlv::EmergencyMode>(qmi::MessageBase *a1, _BYTE *a2)
{
  uint64_t result;
  unint64_t v4;
  unint64_t v5[2];

  result = qmi::MessageBase::findTlvValue(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result)
  {
    result = tlv::parseV<nas::tlv::EmergencyMode>(v5, v4);
    if (!*a2)
      *a2 = 1;
    a2[1] = result;
    if (!v5[0])
      *a2 = 0;
  }
  return result;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver16getServingSystemEN10subscriber7SimSlotEE3__0EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  uint64_t v10;
  _QWORD v11[3];
  uint64_t buf;
  __int16 v13;
  uint64_t v14;
  __int16 v15;
  char v16;
  char v17;
  __int16 v18;
  char v19;
  char v20;
  __int128 v21;
  _OWORD v22[2];
  char v23;
  _BYTE v24[31];
  char v25;
  __int128 v26;
  __int128 v27;
  int v28;
  char v29;
  __int128 v30;
  _BYTE v31[24];
  char v32;
  __int128 v33;
  __int128 v34;
  int v35;
  char v36;
  uint64_t v37;
  void *v38;
  void *v39;
  char v40;
  __int128 v41;
  __int128 v42;
  int v43;
  char v44;
  int v45;
  char v46;
  __int16 v47;
  char v48;
  uint64_t v49;
  char v50;
  uint64_t v51;
  char v52;
  __int16 v53;
  char v54;
  char v55;
  char v56;
  int v57;
  char v58;
  __int16 v59;
  char v60;
  int v61;
  char v62;
  int v63;
  char v64;
  int v65;
  char v66;
  void *__p;
  void *v68;
  char v69;
  uint64_t v70;
  char v71;
  char v72;
  uint64_t v73;
  char v74;
  char v75;
  char v76;
  uint64_t v77;
  char v78;
  _DWORD v79[3];
  uint64_t v80;
  _OWORD v81[4];
  uint64_t v82;
  uint64_t v83;

  v83 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(_DWORD *)(a2 + 4);
  if (v3)
  {
    v4 = **(NSObject ***)(v2 + 16);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 67109378;
      HIDWORD(buf) = v3;
      v13 = 2080;
      v14 = qmi::asString();
      _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#N Get Sys Info failed: Error in response with code %d (%s)", (uint8_t *)&buf, 0x12u);
    }
    return;
  }
  v5 = *(_QWORD *)v2;
  v6 = *(_QWORD *)(a2 + 8);
  v11[0] = *(_QWORD *)a2;
  v11[1] = v6;
  v7 = *(_QWORD *)(a2 + 16);
  v11[2] = v7;
  if (v7)
  {
    v8 = (unint64_t *)(v7 + 8);
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  qmi::MessageBase::validateMsgId((qmi::MessageBase *)v11);
  bzero(&buf, 0x218uLL);
  v10 = *(_QWORD *)(v2 + 16);
  v66 = 0;
  v65 = 0;
  *(_DWORD *)((char *)&v70 + 3) = 0;
  LODWORD(v70) = 0;
  memset(v79, 0, 7);
  v80 = v10;
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v11))
  {
    BYTE2(v81[0]) = 0;
    LOWORD(v81[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::CDMAServiceStatus>((qmi::MessageBase *)v11, (uint64_t)v81);
    if (!LOBYTE(v81[0]))
      goto LABEL_190;
    if (!BYTE2(buf))
      BYTE2(buf) = 1;
    LOWORD(buf) = *(_WORD *)((char *)v81 + 1);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v11))
  {
    BYTE2(v81[0]) = 0;
    LOWORD(v81[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::HDRServiceStatus>((qmi::MessageBase *)v11, (uint64_t)v81);
    if (!LOBYTE(v81[0]))
      goto LABEL_190;
    if (!BYTE5(buf))
      BYTE5(buf) = 1;
    *(_WORD *)((char *)&buf + 3) = *(_WORD *)((char *)v81 + 1);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v11))
  {
    LODWORD(v81[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::GSMServiceStatus>((qmi::MessageBase *)v11, (unsigned __int8 *)v81);
    if (!LOBYTE(v81[0]))
      goto LABEL_190;
    HIWORD(buf) = *(_WORD *)((char *)v81 + 1);
    LOBYTE(v13) = BYTE3(v81[0]);
    if (!HIBYTE(v13))
      HIBYTE(v13) = 1;
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v11))
  {
    LODWORD(v81[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::WCDMAServiceStatus>((qmi::MessageBase *)v11, (unsigned __int8 *)v81);
    if (!LOBYTE(v81[0]))
      goto LABEL_190;
    LOWORD(v14) = *(_WORD *)((char *)v81 + 1);
    BYTE2(v14) = BYTE3(v81[0]);
    if (!BYTE3(v14))
      BYTE3(v14) = 1;
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v11))
  {
    LODWORD(v81[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::LTEServiceStatus>((qmi::MessageBase *)v11, (unsigned __int8 *)v81);
    if (!LOBYTE(v81[0]))
      goto LABEL_190;
    WORD2(v14) = *(_WORD *)((char *)v81 + 1);
    BYTE6(v14) = BYTE3(v81[0]);
    if (!HIBYTE(v14))
      HIBYTE(v14) = 1;
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v11))
  {
    LODWORD(v81[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::NR5GServiceStatus>((qmi::MessageBase *)v11, 74, (unsigned __int8 *)v81);
    if (!LOBYTE(v81[0]))
      goto LABEL_190;
    v18 = *(_WORD *)((char *)v81 + 1);
    v19 = BYTE3(v81[0]);
    if (!v20)
      v20 = 1;
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v11))
  {
    LODWORD(v81[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::TDSCDMAServiceStatus>((qmi::MessageBase *)v11, 36, (unsigned __int8 *)v81);
    if (!LOBYTE(v81[0]))
      goto LABEL_190;
    v15 = *(_WORD *)((char *)v81 + 1);
    v16 = BYTE3(v81[0]);
    if (!v17)
      v17 = 1;
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v11))
  {
    memset(v81, 0, 52);
    qmi::MessageBase::tryTlv<nas::tlv::CDMASysInfo>((qmi::MessageBase *)v11, (uint64_t)v81);
    if (!LOBYTE(v81[0]))
      goto LABEL_190;
    v21 = *(_OWORD *)((char *)v81 + 4);
    v22[0] = *(_OWORD *)((char *)&v81[1] + 4);
    if (v23)
    {
      *(_OWORD *)((char *)v22 + 15) = *(_OWORD *)((char *)&v81[2] + 3);
    }
    else
    {
      v22[1] = *(_OWORD *)((char *)&v81[2] + 4);
      v23 = 1;
    }
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v11))
  {
    memset(v81, 0, 32);
    qmi::MessageBase::tryTlv<nas::tlv::HDRSysInfo>((qmi::MessageBase *)v11, (unsigned __int8 *)v81);
    if (!LOBYTE(v81[0]))
      goto LABEL_190;
    *(_OWORD *)v24 = *(_OWORD *)((char *)v81 + 1);
    *(_OWORD *)&v24[15] = v81[1];
    if (!v25)
      v25 = 1;
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v11))
  {
    memset(v81, 0, 40);
    qmi::MessageBase::tryTlv<nas::tlv::GSMSysInfo>((qmi::MessageBase *)v11, (uint64_t)v81);
    if (!LOBYTE(v81[0]))
      goto LABEL_190;
    v26 = *(_OWORD *)((char *)v81 + 4);
    v27 = *(_OWORD *)((char *)&v81[1] + 4);
    if (v29)
    {
      LOWORD(v28) = WORD2(v81[2]);
    }
    else
    {
      v28 = DWORD1(v81[2]);
      v29 = 1;
    }
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v11))
  {
    memset(v81, 0, 44);
    qmi::MessageBase::tryTlv<nas::tlv::WCDMASysInfo>((qmi::MessageBase *)v11, (uint64_t)v81);
    if (!LOBYTE(v81[0]))
      goto LABEL_190;
    v30 = *(_OWORD *)((char *)v81 + 4);
    *(_OWORD *)v31 = *(_OWORD *)((char *)&v81[1] + 4);
    if (v32)
    {
      *(_QWORD *)&v31[14] = *(_QWORD *)((char *)&v81[2] + 2);
    }
    else
    {
      *(_QWORD *)&v31[16] = *(_QWORD *)((char *)&v81[2] + 4);
      v32 = 1;
    }
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v11))
  {
    memset(v81, 0, 40);
    qmi::MessageBase::tryTlv<nas::tlv::LTESysInfo>((qmi::MessageBase *)v11, (uint64_t)v81);
    if (!LOBYTE(v81[0]))
      goto LABEL_190;
    v33 = *(_OWORD *)((char *)v81 + 4);
    v34 = *(_OWORD *)((char *)&v81[1] + 4);
    if (v36)
    {
      LOWORD(v35) = WORD2(v81[2]);
    }
    else
    {
      v35 = DWORD1(v81[2]);
      v36 = 1;
    }
    BYTE2(v79[1]) = 0;
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v11))
  {
    memset(v81, 0, 40);
    qmi::MessageBase::tryTlv<nas::tlv::NR5GSysInfo>((qmi::MessageBase *)v11, 75, (uint64_t)v81);
    if (!LOBYTE(v81[0]))
      goto LABEL_190;
    v41 = *(_OWORD *)((char *)v81 + 4);
    v42 = *(_OWORD *)((char *)&v81[1] + 4);
    if (v44)
    {
      LOWORD(v43) = WORD2(v81[2]);
    }
    else
    {
      v43 = DWORD1(v81[2]);
      v44 = 1;
    }
    BYTE2(v79[1]) = 0;
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v11))
  {
    v82 = 0;
    memset(v81, 0, sizeof(v81));
    qmi::MessageBase::tryTlv<nas::tlv::TDSCDMASysInfo>((qmi::MessageBase *)v11, 37, (unsigned __int8 *)v81);
    if (!LOBYTE(v81[0]))
      __assert_rtn("get", "optional.hpp", 1212, "this->is_initialized()");
    std::optional<nas::tlv::TDSCDMASysInfo>::operator=[abi:ne180100]<nas::tlv::TDSCDMASysInfo&,void>((uint64_t)&v37, (uint64_t)v81 + 8);
    if (LOBYTE(v81[0]) && *(_QWORD *)&v81[3])
    {
      *((_QWORD *)&v81[3] + 1) = *(_QWORD *)&v81[3];
      operator delete(*(void **)&v81[3]);
    }
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v11))
  {
    WORD2(v81[0]) = 0;
    LODWORD(v81[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::CDMASysInfoEx>((qmi::MessageBase *)v11, (uint64_t)v81);
    if (!LOBYTE(v81[0]))
      goto LABEL_190;
    if (!v46)
      v46 = 1;
    v45 = *(_DWORD *)((char *)v81 + 2);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v11))
  {
    LODWORD(v81[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::HDRSysInfoEx>((qmi::MessageBase *)v11, (uint64_t)v81);
    if (!LOBYTE(v81[0]))
      goto LABEL_190;
    if (!v48)
      v48 = 1;
    v47 = WORD1(v81[0]);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v11))
  {
    DWORD2(v81[0]) = 0;
    *(_QWORD *)&v81[0] = 0;
    qmi::MessageBase::tryTlv<nas::tlv::GSMSysInfoEx>((qmi::MessageBase *)v11, (uint64_t)v81);
    if (!LOBYTE(v81[0]))
      goto LABEL_190;
    if (!v50)
      v50 = 1;
    v49 = *(_QWORD *)((char *)v81 + 4);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v11))
  {
    DWORD2(v81[0]) = 0;
    *(_QWORD *)&v81[0] = 0;
    qmi::MessageBase::tryTlv<nas::tlv::WCDMASysInfoEx>((qmi::MessageBase *)v11, (uint64_t)v81);
    if (!LOBYTE(v81[0]))
      goto LABEL_190;
    if (!v52)
      v52 = 1;
    v51 = *(_QWORD *)((char *)v81 + 4);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v11))
  {
    LODWORD(v81[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::LTESysInfoEx>((qmi::MessageBase *)v11, (uint64_t)v81);
    if (!LOBYTE(v81[0]))
      goto LABEL_190;
    if (!v54)
      v54 = 1;
    v53 = WORD1(v81[0]);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v11))
  {
    LODWORD(v81[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::NR5GTAC>((qmi::MessageBase *)v11, 80, (unsigned __int8 *)v81);
    if (!LOBYTE(v81[0]))
      goto LABEL_190;
    HIWORD(v70) = *(_WORD *)((char *)v81 + 1);
    v71 = BYTE3(v81[0]);
    if (!v72)
      v72 = 1;
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v11))
  {
    BYTE8(v81[0]) = 0;
    *(_QWORD *)&v81[0] = 0;
    qmi::MessageBase::tryTlv<nas::tlv::NR5GCellID>((qmi::MessageBase *)v11, 94, (uint64_t)v81);
    if (!LOBYTE(v81[0]))
      goto LABEL_190;
    if (!v74)
      v74 = 1;
    v73 = *(_QWORD *)((char *)v81 + 1);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v11))
  {
    LOWORD(v81[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::NR5GServiceAreaRestrictionInfo>((qmi::MessageBase *)v11, 81, v81);
    if (!LOBYTE(v81[0]))
      goto LABEL_190;
    if (!v76)
      v76 = 1;
    v75 = BYTE1(v81[0]);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v11))
  {
    DWORD2(v81[0]) = 0;
    *(_QWORD *)&v81[0] = 0;
    qmi::MessageBase::tryTlv<nas::tlv::NR5GEmergencyServiceInfo>((qmi::MessageBase *)v11, 90, (uint64_t)v81);
    if (!LOBYTE(v81[0]))
      goto LABEL_190;
    if (!v78)
      v78 = 1;
    v77 = *(_QWORD *)((char *)v81 + 4);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v11))
  {
    LOWORD(v81[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::NR5GVoiceSupportInfo>((qmi::MessageBase *)v11, 88, v81);
    if (!LOBYTE(v81[0]))
      goto LABEL_190;
    if (!BYTE1(v79[0]))
      BYTE1(v79[0]) = 1;
    LOBYTE(v79[0]) = BYTE1(v81[0]);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v11))
  {
    *(_QWORD *)&v81[0] = 0;
    qmi::MessageBase::tryTlv<nas::tlv::LteEmergencyBearerSupport>((qmi::MessageBase *)v11, 57, (uint64_t)v81);
    if (!LOBYTE(v81[0]))
      goto LABEL_190;
    if (!v62)
      v62 = 1;
    v61 = DWORD1(v81[0]);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v11))
  {
    *(_QWORD *)&v81[0] = 0;
    qmi::MessageBase::tryTlv<nas::tlv::LteEmergencyAccessBarred>((qmi::MessageBase *)v11, 62, (uint64_t)v81);
    if (!LOBYTE(v81[0]))
      goto LABEL_190;
    if (!v64)
      v64 = 1;
    v63 = DWORD1(v81[0]);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v11))
  {
    LOWORD(v81[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::HDRSubnetMaskLength>((qmi::MessageBase *)v11, 69, v81);
    if (!LOBYTE(v81[0]))
      goto LABEL_190;
    if (!BYTE1(v65))
      BYTE1(v65) = 1;
    LOBYTE(v65) = BYTE1(v81[0]);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v11))
  {
    LOWORD(v81[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::GSMCipherDomainSysInfo>((qmi::MessageBase *)v11, v81);
    if (!LOBYTE(v81[0]))
      goto LABEL_190;
    if (!HIBYTE(v79[0]))
      HIBYTE(v79[0]) = 1;
    BYTE2(v79[0]) = BYTE1(v81[0]);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v11))
  {
    LOWORD(v81[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::WCDMACipherDomainSysInfo>((qmi::MessageBase *)v11, v81);
    if (!LOBYTE(v81[0]))
      goto LABEL_190;
    if (!BYTE1(v79[1]))
      BYTE1(v79[1]) = 1;
    LOBYTE(v79[1]) = BYTE1(v81[0]);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v11))
  {
    LOWORD(v81[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::LTEVoiceSupportSysInfo>((qmi::MessageBase *)v11, v81);
    if (!LOBYTE(v81[0]))
      goto LABEL_190;
    if (!v56)
      v56 = 1;
    v55 = BYTE1(v81[0]);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v11))
  {
    *(_QWORD *)&v81[0] = 0;
    qmi::MessageBase::tryTlv<nas::tlv::SimRejectInfo>((qmi::MessageBase *)v11, 39, (uint64_t)v81);
    if (!LOBYTE(v81[0]))
      goto LABEL_190;
    if (!v58)
      v58 = 1;
    v57 = DWORD1(v81[0]);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v11))
  {
    LODWORD(v81[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::CDMADerivedMCC>((qmi::MessageBase *)v11, 46, (uint64_t)v81);
    if (!LOBYTE(v81[0]))
      goto LABEL_190;
    if (!v60)
      v60 = 1;
    v59 = WORD1(v81[0]);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v11))
  {
    LOWORD(v81[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::AgentVoiceSupportStatus>((qmi::MessageBase *)v11, 41, v81);
    if (!LOBYTE(v81[0]))
      goto LABEL_190;
    if (!HIBYTE(v65))
      HIBYTE(v65) = 1;
    BYTE2(v65) = BYTE1(v81[0]);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v11))
  {
    LOWORD(v81[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::ScanCompletionStatus>((qmi::MessageBase *)v11, v81);
    if (!LOBYTE(v81[0]))
      goto LABEL_190;
    if (!BYTE1(v70))
      BYTE1(v70) = 1;
    LOBYTE(v70) = BYTE1(v81[0]);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v11))
  {
    LOWORD(v81[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::CSVoiceSupportStatus>((qmi::MessageBase *)v11, v81);
    if (!LOBYTE(v81[0]))
      goto LABEL_190;
    if (!BYTE3(v70))
      BYTE3(v70) = 1;
    BYTE2(v70) = BYTE1(v81[0]);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v11))
  {
    LOWORD(v81[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::IsSatelliteSystem>((qmi::MessageBase *)v11, v81);
    if (LOBYTE(v81[0]))
    {
      if (!BYTE5(v70))
        BYTE5(v70) = 1;
      BYTE4(v70) = BYTE1(v81[0]);
      goto LABEL_182;
    }
LABEL_190:
    __assert_rtn("get", "optional.hpp", 1212, "this->is_initialized()");
  }
LABEL_182:
  QMINetworkRegistrationDriver::processSystemInfo_sync(v5, *(_DWORD *)(v2 + 8), (unsigned __int8 *)&buf);
  if (v69 && __p)
  {
    v68 = __p;
    operator delete(__p);
  }
  if (v40 && v38)
  {
    v39 = v38;
    operator delete(v38);
  }
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v11);
}

void sub_216A7C464(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,void *a48,uint64_t a49,uint64_t a50,char a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  void *__p;
  uint64_t a69;
  char a71;
  uint64_t v71;
  void *v73;

  if (*(_BYTE *)(v71 - 128))
  {
    v73 = *(void **)(v71 - 80);
    if (v73)
      operator delete(v73);
  }
  if (a71 && __p)
  {
    a69 = (uint64_t)__p;
    operator delete(__p);
  }
  if (a51)
  {
    if (a48)
    {
      a49 = (uint64_t)a48;
      operator delete(a48);
    }
  }
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a10);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_32c104_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver16getServingSystemEN10subscriber7SimSlotEE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c104_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver16getServingSystemEN10subscriber7SimSlotEE3__0EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::getServingSystem(subscriber::SimSlot)::$_0,std::allocator<QMINetworkRegistrationDriver::getServingSystem(subscriber::SimSlot)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E98B0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::getServingSystem(subscriber::SimSlot)::$_0,std::allocator<QMINetworkRegistrationDriver::getServingSystem(subscriber::SimSlot)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E98B0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

uint64_t std::optional<nas::tlv::TDSCDMASysInfo>::operator=[abi:ne180100]<nas::tlv::TDSCDMASysInfo&,void>(uint64_t a1, uint64_t a2)
{
  int v3;
  __int16 v4;
  __int128 v5;

  v3 = *(unsigned __int8 *)(a1 + 64);
  v4 = *(_WORD *)(a2 + 32);
  v5 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v5;
  *(_WORD *)(a1 + 32) = v4;
  if (v3)
  {
    if (a1 != a2)
      std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((_QWORD *)(a1 + 40), *(char **)(a2 + 40), *(char **)(a2 + 48), *(_QWORD *)(a2 + 48) - *(_QWORD *)(a2 + 40));
  }
  else
  {
    *(_QWORD *)(a1 + 40) = 0;
    *(_QWORD *)(a1 + 48) = 0;
    *(_QWORD *)(a1 + 56) = 0;
    std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>((_QWORD *)(a1 + 40), *(const void **)(a2 + 40), *(_QWORD *)(a2 + 48), *(_QWORD *)(a2 + 48) - *(_QWORD *)(a2 + 40));
    *(_BYTE *)(a1 + 64) = 1;
  }
  return a1;
}

uint64_t qmi::MessageBase::tryTlv<nas::tlv::CDMAServiceStatus>(qmi::MessageBase *a1, uint64_t a2)
{
  uint64_t result;
  unint64_t v4;
  unint64_t v5[2];

  result = qmi::MessageBase::findTlvValue(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result)
  {
    result = tlv::parseV<nas::tlv::CDMAServiceStatus>(v5, v4);
    if (!*(_BYTE *)a2)
      *(_BYTE *)a2 = 1;
    *(_WORD *)(a2 + 1) = result;
    if (!v5[0])
      *(_BYTE *)a2 = 0;
  }
  return result;
}

uint64_t qmi::MessageBase::tryTlv<nas::tlv::HDRServiceStatus>(qmi::MessageBase *a1, uint64_t a2)
{
  uint64_t result;
  unint64_t v4;
  unint64_t v5[2];

  result = qmi::MessageBase::findTlvValue(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result)
  {
    result = tlv::parseV<nas::tlv::HDRServiceStatus>(v5, v4);
    if (!*(_BYTE *)a2)
      *(_BYTE *)a2 = 1;
    *(_WORD *)(a2 + 1) = result;
    if (!v5[0])
      *(_BYTE *)a2 = 0;
  }
  return result;
}

_BYTE *qmi::MessageBase::tryTlv<nas::tlv::TDSCDMAServiceStatus>(qmi::MessageBase *a1, uint64_t a2, unsigned __int8 *a3)
{
  _BYTE *result;
  _BYTE *v5;
  int v6;
  _BYTE *v7[2];

  result = (_BYTE *)qmi::MessageBase::findTlvValue(a1);
  v7[0] = result;
  v7[1] = v5;
  if (result)
  {
    result = (_BYTE *)tlv::parseV<nas::tlv::TDSCDMAServiceStatus>(v7, (int)v5);
    v6 = *a3;
    *(_WORD *)(a3 + 1) = (_WORD)result;
    a3[3] = BYTE2(result);
    if (!v6)
      *a3 = 1;
    if (!v7[0])
      *a3 = 0;
  }
  return result;
}

unint64_t qmi::MessageBase::tryTlv<nas::tlv::CDMASysInfo>(qmi::MessageBase *a1, uint64_t a2)
{
  unint64_t result;
  unint64_t v4;
  _OWORD *v5;
  __int128 v6;
  __int128 v7;
  _BYTE v8[32];
  unint64_t v9[2];

  result = qmi::MessageBase::findTlvValue(a1);
  v9[0] = result;
  v9[1] = v4;
  if (result)
  {
    result = tlv::parseV<nas::tlv::CDMASysInfo>(v9, v4, &v7);
    v5 = (_OWORD *)(a2 + 4);
    v6 = *(_OWORD *)v8;
    if (*(_BYTE *)a2)
    {
      *v5 = v7;
      *(_OWORD *)(a2 + 20) = v6;
      *(_OWORD *)(a2 + 35) = *(_OWORD *)&v8[15];
    }
    else
    {
      *v5 = v7;
      *(_OWORD *)(a2 + 20) = v6;
      *(_OWORD *)(a2 + 36) = *(_OWORD *)&v8[16];
      *(_BYTE *)a2 = 1;
    }
    if (!v9[0])
      *(_BYTE *)a2 = 0;
  }
  return result;
}

unint64_t qmi::MessageBase::tryTlv<nas::tlv::HDRSysInfo>(qmi::MessageBase *a1, unsigned __int8 *a2)
{
  unint64_t result;
  unint64_t v4;
  int v5;
  unint64_t v6[2];
  _BYTE v7[31];
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  result = qmi::MessageBase::findTlvValue(a1);
  v6[0] = result;
  v6[1] = v4;
  if (result)
  {
    result = tlv::parseV<nas::tlv::HDRSysInfo>(v6, v4, v7);
    v5 = *a2;
    *(_OWORD *)(a2 + 1) = *(_OWORD *)v7;
    *((_OWORD *)a2 + 1) = *(_OWORD *)&v7[15];
    if (!v5)
      *a2 = 1;
    if (!v6[0])
      *a2 = 0;
  }
  return result;
}

unint64_t qmi::MessageBase::tryTlv<nas::tlv::GSMSysInfo>(qmi::MessageBase *a1, uint64_t a2)
{
  unint64_t result;
  unint64_t v4;
  _OWORD *v5;
  __int128 v6;
  _OWORD v7[2];
  int v8;
  unint64_t v9[2];

  result = qmi::MessageBase::findTlvValue(a1);
  v9[0] = result;
  v9[1] = v4;
  if (result)
  {
    result = tlv::parseV<nas::tlv::GSMSysInfo>(v9, v4, (uint64_t)v7);
    v5 = (_OWORD *)(a2 + 4);
    v6 = v7[1];
    if (*(_BYTE *)a2)
    {
      *v5 = v7[0];
      *(_OWORD *)(a2 + 20) = v6;
      *(_WORD *)(a2 + 36) = v8;
    }
    else
    {
      *v5 = v7[0];
      *(_OWORD *)(a2 + 20) = v6;
      *(_DWORD *)(a2 + 36) = v8;
      *(_BYTE *)a2 = 1;
    }
    if (!v9[0])
      *(_BYTE *)a2 = 0;
  }
  return result;
}

unint64_t qmi::MessageBase::tryTlv<nas::tlv::WCDMASysInfo>(qmi::MessageBase *a1, uint64_t a2)
{
  unint64_t result;
  unint64_t v4;
  _OWORD *v5;
  __int128 v6;
  __int128 v7;
  _BYTE v8[24];
  unint64_t v9[2];

  result = qmi::MessageBase::findTlvValue(a1);
  v9[0] = result;
  v9[1] = v4;
  if (result)
  {
    result = tlv::parseV<nas::tlv::WCDMASysInfo>(v9, v4, (uint64_t)&v7);
    v5 = (_OWORD *)(a2 + 4);
    v6 = *(_OWORD *)v8;
    if (*(_BYTE *)a2)
    {
      *v5 = v7;
      *(_OWORD *)(a2 + 20) = v6;
      *(_QWORD *)(a2 + 34) = *(_QWORD *)&v8[14];
    }
    else
    {
      *v5 = v7;
      *(_OWORD *)(a2 + 20) = v6;
      *(_QWORD *)(a2 + 36) = *(_QWORD *)&v8[16];
      *(_BYTE *)a2 = 1;
    }
    if (!v9[0])
      *(_BYTE *)a2 = 0;
  }
  return result;
}

unint64_t qmi::MessageBase::tryTlv<nas::tlv::NR5GSysInfo>(qmi::MessageBase *a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;
  unint64_t v5;
  _OWORD *v6;
  __int128 v7;
  _OWORD v8[2];
  int v9;
  unint64_t v10[2];

  result = qmi::MessageBase::findTlvValue(a1);
  v10[0] = result;
  v10[1] = v5;
  if (result)
  {
    result = tlv::parseV<nas::tlv::NR5GSysInfo>(v10, v5, (uint64_t)v8);
    v6 = (_OWORD *)(a3 + 4);
    v7 = v8[1];
    if (*(_BYTE *)a3)
    {
      *v6 = v8[0];
      *(_OWORD *)(a3 + 20) = v7;
      *(_WORD *)(a3 + 36) = v9;
    }
    else
    {
      *v6 = v8[0];
      *(_OWORD *)(a3 + 20) = v7;
      *(_DWORD *)(a3 + 36) = v9;
      *(_BYTE *)a3 = 1;
    }
    if (!v10[0])
      *(_BYTE *)a3 = 0;
  }
  return result;
}

void qmi::MessageBase::tryTlv<nas::tlv::TDSCDMASysInfo>(qmi::MessageBase *a1, uint64_t a2, unsigned __int8 *a3)
{
  unint64_t v4;
  int v5;
  __int128 v6;
  void *v7;
  int v8;
  void *v9;
  _OWORD v10[2];
  __int16 v11;
  __int128 v12;
  uint64_t v13;
  unint64_t v14[2];

  v14[0] = qmi::MessageBase::findTlvValue(a1);
  v14[1] = v4;
  if (v14[0])
  {
    tlv::parseV<nas::tlv::TDSCDMASysInfo>(v14, v4, v10);
    v5 = *a3;
    v6 = v10[1];
    *(_OWORD *)(a3 + 8) = v10[0];
    *(_OWORD *)(a3 + 24) = v6;
    *((_WORD *)a3 + 20) = v11;
    if (v5)
    {
      v7 = (void *)*((_QWORD *)a3 + 6);
      if (v7)
      {
        *((_QWORD *)a3 + 7) = v7;
        operator delete(v7);
        v8 = *a3;
      }
      else
      {
        v8 = 1;
      }
      v9 = (void *)v12;
      *((_OWORD *)a3 + 3) = v12;
      *((_QWORD *)a3 + 8) = v13;
    }
    else
    {
      v9 = (void *)v12;
      *((_OWORD *)a3 + 3) = v12;
      *((_QWORD *)a3 + 8) = v13;
      v8 = 1;
      *a3 = 1;
    }
    if (!v14[0] && v8)
    {
      if (v9)
      {
        *((_QWORD *)a3 + 7) = v9;
        operator delete(v9);
      }
      *a3 = 0;
    }
  }
}

uint64_t qmi::MessageBase::tryTlv<nas::tlv::CDMASysInfoEx>(qmi::MessageBase *a1, uint64_t a2)
{
  uint64_t result;
  unint64_t v4;
  unint64_t v5[2];

  result = qmi::MessageBase::findTlvValue(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result)
  {
    result = tlv::parseV<nas::tlv::CDMASysInfoEx>(v5, v4);
    if (!*(_BYTE *)a2)
      *(_BYTE *)a2 = 1;
    *(_DWORD *)(a2 + 2) = result;
    if (!v5[0])
      *(_BYTE *)a2 = 0;
  }
  return result;
}

uint64_t qmi::MessageBase::tryTlv<nas::tlv::HDRSysInfoEx>(qmi::MessageBase *a1, uint64_t a2)
{
  uint64_t result;
  unint64_t v4;
  unint64_t v5[2];

  result = qmi::MessageBase::findTlvValue(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result)
  {
    result = tlv::parseV<nas::tlv::HDRSysInfoEx>(v5, v4);
    if (!*(_BYTE *)a2)
      *(_BYTE *)a2 = 1;
    *(_WORD *)(a2 + 2) = result;
    if (!v5[0])
      *(_BYTE *)a2 = 0;
  }
  return result;
}

uint64_t qmi::MessageBase::tryTlv<nas::tlv::GSMSysInfoEx>(qmi::MessageBase *a1, uint64_t a2)
{
  uint64_t result;
  unint64_t v4;
  unint64_t v5[2];

  result = qmi::MessageBase::findTlvValue(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result)
  {
    result = tlv::parseV<nas::tlv::GSMSysInfoEx>(v5, v4);
    if (!*(_BYTE *)a2)
      *(_BYTE *)a2 = 1;
    *(_QWORD *)(a2 + 4) = result;
    if (!v5[0])
      *(_BYTE *)a2 = 0;
  }
  return result;
}

uint64_t qmi::MessageBase::tryTlv<nas::tlv::WCDMASysInfoEx>(qmi::MessageBase *a1, uint64_t a2)
{
  uint64_t result;
  unint64_t v4;
  unint64_t v5[2];

  result = qmi::MessageBase::findTlvValue(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result)
  {
    result = tlv::parseV<nas::tlv::WCDMASysInfoEx>(v5, v4);
    if (!*(_BYTE *)a2)
      *(_BYTE *)a2 = 1;
    *(_QWORD *)(a2 + 4) = result;
    if (!v5[0])
      *(_BYTE *)a2 = 0;
  }
  return result;
}

uint64_t qmi::MessageBase::tryTlv<nas::tlv::NR5GTAC>(qmi::MessageBase *a1, uint64_t a2, unsigned __int8 *a3)
{
  uint64_t result;
  unint64_t v5;
  int v6;
  unint64_t v7[2];

  result = qmi::MessageBase::findTlvValue(a1);
  v7[0] = result;
  v7[1] = v5;
  if (result)
  {
    result = tlv::parseV<nas::tlv::NR5GTAC>(v7, v5);
    v6 = *a3;
    *(_WORD *)(a3 + 1) = result;
    a3[3] = BYTE2(result);
    if (!v6)
      *a3 = 1;
    if (!v7[0])
      *a3 = 0;
  }
  return result;
}

uint64_t qmi::MessageBase::tryTlv<nas::tlv::NR5GCellID>(qmi::MessageBase *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  unint64_t v5;
  unint64_t v6[2];

  result = qmi::MessageBase::findTlvValue(a1);
  v6[0] = result;
  v6[1] = v5;
  if (result)
  {
    result = tlv::parseV<nas::tlv::NR5GCellID>(v6, v5);
    if (!*(_BYTE *)a3)
      *(_BYTE *)a3 = 1;
    *(_QWORD *)(a3 + 1) = result;
    if (!v6[0])
      *(_BYTE *)a3 = 0;
  }
  return result;
}

uint64_t qmi::MessageBase::tryTlv<nas::tlv::NR5GServiceAreaRestrictionInfo>(qmi::MessageBase *a1, uint64_t a2, _BYTE *a3)
{
  uint64_t result;
  unint64_t v5;
  unint64_t v6[2];

  result = qmi::MessageBase::findTlvValue(a1);
  v6[0] = result;
  v6[1] = v5;
  if (result)
  {
    result = tlv::parseV<nas::tlv::NR5GServiceAreaRestrictionInfo>(v6, v5);
    if (!*a3)
      *a3 = 1;
    a3[1] = result;
    if (!v6[0])
      *a3 = 0;
  }
  return result;
}

uint64_t qmi::MessageBase::tryTlv<nas::tlv::NR5GEmergencyServiceInfo>(qmi::MessageBase *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  unint64_t v5;
  unint64_t v6[2];

  result = qmi::MessageBase::findTlvValue(a1);
  v6[0] = result;
  v6[1] = v5;
  if (result)
  {
    result = tlv::parseV<nas::tlv::NR5GEmergencyServiceInfo>(v6, v5);
    if (!*(_BYTE *)a3)
      *(_BYTE *)a3 = 1;
    *(_QWORD *)(a3 + 4) = result;
    if (!v6[0])
      *(_BYTE *)a3 = 0;
  }
  return result;
}

uint64_t qmi::MessageBase::tryTlv<nas::tlv::NR5GVoiceSupportInfo>(qmi::MessageBase *a1, uint64_t a2, _BYTE *a3)
{
  uint64_t result;
  unint64_t v5;
  unint64_t v6[2];

  result = qmi::MessageBase::findTlvValue(a1);
  v6[0] = result;
  v6[1] = v5;
  if (result)
  {
    result = tlv::parseV<nas::tlv::NR5GVoiceSupportInfo>(v6, v5);
    if (!*a3)
      *a3 = 1;
    a3[1] = result;
    if (!v6[0])
      *a3 = 0;
  }
  return result;
}

uint64_t qmi::MessageBase::tryTlv<nas::tlv::HDRSubnetMaskLength>(qmi::MessageBase *a1, uint64_t a2, _BYTE *a3)
{
  uint64_t result;
  unint64_t v5;
  unint64_t v6[2];

  result = qmi::MessageBase::findTlvValue(a1);
  v6[0] = result;
  v6[1] = v5;
  if (result)
  {
    result = tlv::parseV<nas::tlv::HDRSubnetMaskLength>(v6, v5);
    if (!*a3)
      *a3 = 1;
    a3[1] = result;
    if (!v6[0])
      *a3 = 0;
  }
  return result;
}

uint64_t qmi::MessageBase::tryTlv<nas::tlv::GSMCipherDomainSysInfo>(qmi::MessageBase *a1, _BYTE *a2)
{
  uint64_t result;
  unint64_t v4;
  unint64_t v5[2];

  result = qmi::MessageBase::findTlvValue(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result)
  {
    result = tlv::parseV<nas::tlv::GSMCipherDomainSysInfo>(v5, v4);
    if (!*a2)
      *a2 = 1;
    a2[1] = result;
    if (!v5[0])
      *a2 = 0;
  }
  return result;
}

uint64_t qmi::MessageBase::tryTlv<nas::tlv::WCDMACipherDomainSysInfo>(qmi::MessageBase *a1, _BYTE *a2)
{
  uint64_t result;
  unint64_t v4;
  unint64_t v5[2];

  result = qmi::MessageBase::findTlvValue(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result)
  {
    result = tlv::parseV<nas::tlv::WCDMACipherDomainSysInfo>(v5, v4);
    if (!*a2)
      *a2 = 1;
    a2[1] = result;
    if (!v5[0])
      *a2 = 0;
  }
  return result;
}

unint64_t qmi::MessageBase::tryTlv<nas::tlv::LTEVoiceSupportSysInfo>(qmi::MessageBase *a1, _BYTE *a2)
{
  unint64_t result;
  unint64_t v4;
  unint64_t v5[2];

  result = qmi::MessageBase::findTlvValue(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result)
  {
    result = tlv::parseV<nas::tlv::LTEVoiceSupportSysInfo>(v5, v4);
    if (!*a2)
      *a2 = 1;
    a2[1] = result;
    if (!v5[0])
      *a2 = 0;
  }
  return result;
}

uint64_t qmi::MessageBase::tryTlv<nas::tlv::CDMADerivedMCC>(qmi::MessageBase *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  unint64_t v5;
  unint64_t v6[2];

  result = qmi::MessageBase::findTlvValue(a1);
  v6[0] = result;
  v6[1] = v5;
  if (result)
  {
    result = tlv::parseV<nas::tlv::CDMADerivedMCC>(v6, v5);
    if (!*(_BYTE *)a3)
      *(_BYTE *)a3 = 1;
    *(_WORD *)(a3 + 2) = result;
    if (!v6[0])
      *(_BYTE *)a3 = 0;
  }
  return result;
}

unint64_t qmi::MessageBase::tryTlv<nas::tlv::AgentVoiceSupportStatus>(qmi::MessageBase *a1, uint64_t a2, _BYTE *a3)
{
  unint64_t result;
  unint64_t v5;
  unint64_t v6[2];

  result = qmi::MessageBase::findTlvValue(a1);
  v6[0] = result;
  v6[1] = v5;
  if (result)
  {
    result = tlv::parseV<nas::tlv::AgentVoiceSupportStatus>(v6, v5);
    if (!*a3)
      *a3 = 1;
    a3[1] = result;
    if (!v6[0])
      *a3 = 0;
  }
  return result;
}

unint64_t qmi::MessageBase::tryTlv<nas::tlv::ScanCompletionStatus>(qmi::MessageBase *a1, _BYTE *a2)
{
  unint64_t result;
  unint64_t v4;
  unint64_t v5[2];

  result = qmi::MessageBase::findTlvValue(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result)
  {
    result = tlv::parseV<nas::tlv::ScanCompletionStatus>(v5, v4);
    if (!*a2)
      *a2 = 1;
    a2[1] = result;
    if (!v5[0])
      *a2 = 0;
  }
  return result;
}

unint64_t qmi::MessageBase::tryTlv<nas::tlv::CSVoiceSupportStatus>(qmi::MessageBase *a1, _BYTE *a2)
{
  unint64_t result;
  unint64_t v4;
  unint64_t v5[2];

  result = qmi::MessageBase::findTlvValue(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result)
  {
    result = tlv::parseV<nas::tlv::CSVoiceSupportStatus>(v5, v4);
    if (!*a2)
      *a2 = 1;
    a2[1] = result;
    if (!v5[0])
      *a2 = 0;
  }
  return result;
}

unint64_t qmi::MessageBase::tryTlv<nas::tlv::IsSatelliteSystem>(qmi::MessageBase *a1, _BYTE *a2)
{
  unint64_t result;
  unint64_t v4;
  unint64_t v5[2];

  result = qmi::MessageBase::findTlvValue(a1);
  v5[0] = result;
  v5[1] = v4;
  if (result)
  {
    result = tlv::parseV<nas::tlv::IsSatelliteSystem>(v5, v4);
    if (!*a2)
      *a2 = 1;
    a2[1] = result;
    if (!v5[0])
      *a2 = 0;
  }
  return result;
}

void std::__function::__func<QMINetworkRegistrationDriver::processRegistrationState_sync(subscriber::SimSlot,ServingSystem &,ServingSystemInfo const&)::$_0,std::allocator<QMINetworkRegistrationDriver::processRegistrationState_sync(subscriber::SimSlot,ServingSystem &,ServingSystemInfo const&)::$_0>,void ()(ServingSystem::System &,nas::NasRegistrationState,MCC,MNC,BOOL)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<QMINetworkRegistrationDriver::processRegistrationState_sync(subscriber::SimSlot,ServingSystem &,ServingSystemInfo const&)::$_0,std::allocator<QMINetworkRegistrationDriver::processRegistrationState_sync(subscriber::SimSlot,ServingSystem &,ServingSystemInfo const&)::$_0>,void ()(ServingSystem::System &,nas::NasRegistrationState,MCC,MNC,BOOL)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5E9900;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<QMINetworkRegistrationDriver::processRegistrationState_sync(subscriber::SimSlot,ServingSystem &,ServingSystemInfo const&)::$_0,std::allocator<QMINetworkRegistrationDriver::processRegistrationState_sync(subscriber::SimSlot,ServingSystem &,ServingSystemInfo const&)::$_0>,void ()(ServingSystem::System &,nas::NasRegistrationState,MCC,MNC,BOOL)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5E9900;
  a2[1] = v2;
  return result;
}

void std::__function::__func<QMINetworkRegistrationDriver::processRegistrationState_sync(subscriber::SimSlot,ServingSystem &,ServingSystemInfo const&)::$_0,std::allocator<QMINetworkRegistrationDriver::processRegistrationState_sync(subscriber::SimSlot,ServingSystem &,ServingSystemInfo const&)::$_0>,void ()(ServingSystem::System &,nas::NasRegistrationState,MCC,MNC,BOOL)>::operator()(uint64_t a1, uint64_t a2, char *a3, uint64_t a4, const MCC *a5, unsigned __int8 *a6)
{
  int v9;
  NSObject *v10;
  int IntValue;
  int IntegerWidth;
  int v13;
  _DWORD v14[2];
  __int16 v15;
  int v16;
  __int16 v17;
  int v18;
  __int16 v19;
  uint64_t v20;
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  v9 = *a6;
  *(_DWORD *)a2 = mapToRegStatus(*(os_log_t **)(a1 + 8), *a3);
  *(_BYTE *)(a2 + 4) = 1;
  if (*(_BYTE *)(a2 + 48))
  {
    MCC::operator=();
  }
  else
  {
    MCC::MCC();
    *(_BYTE *)(a2 + 48) = 1;
  }
  if (*(_BYTE *)(a2 + 88))
  {
    MCC::operator=();
  }
  else
  {
    MCC::MCC((MCC *)(a2 + 56), a5);
    *(_BYTE *)(a2 + 88) = 1;
  }
  if (*(_BYTE *)(a2 + 4)
    && (*(_DWORD *)a2 - 1) <= 2
    && MCC::valid((MCC *)(a2 + 16))
    && MCC::valid((MCC *)(a2 + 56)))
  {
    *(_DWORD *)a2 = 6;
    *(_BYTE *)(a2 + 4) = 1;
  }
  if (v9 && *(_BYTE *)(a2 + 4) && *(_DWORD *)a2 == 4)
  {
    *(_DWORD *)a2 = 5;
    *(_BYTE *)(a2 + 4) = 1;
  }
  v10 = **(NSObject ***)(a1 + 8);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    IntValue = MCC::getIntValue((MCC *)(a2 + 16));
    IntegerWidth = MNC::getIntegerWidth((MNC *)(a2 + 56));
    v13 = MCC::getIntValue((MCC *)(a2 + 56));
    if (!*(_BYTE *)(a2 + 4))
      std::__throw_bad_optional_access[abi:ne180100]();
    v14[0] = 67109890;
    v14[1] = IntValue;
    v15 = 1024;
    v16 = IntegerWidth;
    v17 = 1024;
    v18 = v13;
    v19 = 2080;
    v20 = asString();
    _os_log_impl(&dword_216897000, v10, OS_LOG_TYPE_DEFAULT, "#I Serving System: MCC: %03d MNC: %0.*d Registration Status: %s", (uint8_t *)v14, 0x1Eu);
  }
}

uint64_t std::__function::__func<QMINetworkRegistrationDriver::processRegistrationState_sync(subscriber::SimSlot,ServingSystem &,ServingSystemInfo const&)::$_0,std::allocator<QMINetworkRegistrationDriver::processRegistrationState_sync(subscriber::SimSlot,ServingSystem &,ServingSystemInfo const&)::$_0>,void ()(ServingSystem::System &,nas::NasRegistrationState,MCC,MNC,BOOL)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<QMINetworkRegistrationDriver::processRegistrationState_sync(subscriber::SimSlot,ServingSystem &,ServingSystemInfo const&)::$_0,std::allocator<QMINetworkRegistrationDriver::processRegistrationState_sync(subscriber::SimSlot,ServingSystem &,ServingSystemInfo const&)::$_0>,void ()(ServingSystem::System &,nas::NasRegistrationState,MCC,MNC,BOOL)>::target_type()
{
}

void std::__function::__func<QMINetworkRegistrationDriver::processRATAndDataStatus_sync(subscriber::SimSlot,ServingSystem &,ServingSystemInfo const&)::$_0,std::allocator<QMINetworkRegistrationDriver::processRATAndDataStatus_sync(subscriber::SimSlot,ServingSystem &,ServingSystemInfo const&)::$_0>,void ()(ServingSystem::System const&)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<QMINetworkRegistrationDriver::processRATAndDataStatus_sync(subscriber::SimSlot,ServingSystem &,ServingSystemInfo const&)::$_0,std::allocator<QMINetworkRegistrationDriver::processRATAndDataStatus_sync(subscriber::SimSlot,ServingSystem &,ServingSystemInfo const&)::$_0>,void ()(ServingSystem::System const&)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5E9990;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<QMINetworkRegistrationDriver::processRATAndDataStatus_sync(subscriber::SimSlot,ServingSystem &,ServingSystemInfo const&)::$_0,std::allocator<QMINetworkRegistrationDriver::processRATAndDataStatus_sync(subscriber::SimSlot,ServingSystem &,ServingSystemInfo const&)::$_0>,void ()(ServingSystem::System const&)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5E9990;
  a2[1] = v2;
  return result;
}

void std::__function::__func<QMINetworkRegistrationDriver::processRATAndDataStatus_sync(subscriber::SimSlot,ServingSystem &,ServingSystemInfo const&)::$_0,std::allocator<QMINetworkRegistrationDriver::processRATAndDataStatus_sync(subscriber::SimSlot,ServingSystem &,ServingSystemInfo const&)::$_0>,void ()(ServingSystem::System const&)>::operator()(uint64_t a1, _BYTE *a2)
{
  int v4;
  NSObject *v5;
  _BOOL4 v6;
  uint64_t v7;
  const char *v8;
  const char *v9;
  NSObject *v10;
  uint32_t v11;
  int v12;
  NSObject *v13;
  _BOOL4 v14;
  uint64_t v15;
  const char *v16;
  const char *v17;
  NSObject *v18;
  uint32_t v19;
  uint64_t v20;
  int v21;
  NSObject *v22;
  _BOOL4 v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  const char *v27;
  NSObject *v28;
  uint32_t v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  __int16 v33;
  uint64_t v34;
  uint64_t v35;

  v35 = *MEMORY[0x24BDAC8D0];
  v4 = a2[9];
  v5 = **(NSObject ***)(a1 + 8);
  v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (v4)
  {
    if (!v6)
      goto LABEL_10;
    v7 = asString();
    if (!a2[9])
      goto LABEL_27;
    v8 = "true";
    if (!a2[8])
      v8 = "false";
    v31 = 136315394;
    v32 = v7;
    v33 = 2080;
    v34 = (uint64_t)v8;
    v9 = "#I %s system: CS attach - %s";
    v10 = v5;
    v11 = 22;
  }
  else
  {
    if (!v6)
      goto LABEL_10;
    v31 = 136315138;
    v32 = asString();
    v9 = "#I %s system: CS attach - unknown";
    v10 = v5;
    v11 = 12;
  }
  _os_log_impl(&dword_216897000, v10, OS_LOG_TYPE_DEFAULT, v9, (uint8_t *)&v31, v11);
LABEL_10:
  v12 = a2[11];
  v13 = **(NSObject ***)(a1 + 8);
  v14 = os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT);
  if (v12)
  {
    if (!v14)
      goto LABEL_19;
    v15 = asString();
    if (!a2[11])
      goto LABEL_27;
    v16 = "true";
    if (!a2[10])
      v16 = "false";
    v31 = 136315394;
    v32 = v15;
    v33 = 2080;
    v34 = (uint64_t)v16;
    v17 = "#I %s system: PS attach - %s";
    v18 = v13;
    v19 = 22;
  }
  else
  {
    if (!v14)
      goto LABEL_19;
    v20 = asString();
    v31 = 136315138;
    v32 = v20;
    v17 = "#I %s system: PS attach - unknown";
    v18 = v13;
    v19 = 12;
  }
  _os_log_impl(&dword_216897000, v18, OS_LOG_TYPE_DEFAULT, v17, (uint8_t *)&v31, v19);
LABEL_19:
  v21 = a2[100];
  v22 = **(NSObject ***)(a1 + 8);
  v23 = os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT);
  if (v21)
  {
    if (!v23)
      return;
    v24 = asString();
    if (a2[100])
    {
      v25 = v24;
      v26 = asString();
      v31 = 136315394;
      v32 = v25;
      v33 = 2080;
      v34 = v26;
      v27 = "#I %s system: Data mode - %s";
      v28 = v22;
      v29 = 22;
      goto LABEL_25;
    }
LABEL_27:
    std::__throw_bad_optional_access[abi:ne180100]();
  }
  if (!v23)
    return;
  v30 = asString();
  v31 = 136315138;
  v32 = v30;
  v27 = "#I %s system: Data mode - unknown";
  v28 = v22;
  v29 = 12;
LABEL_25:
  _os_log_impl(&dword_216897000, v28, OS_LOG_TYPE_DEFAULT, v27, (uint8_t *)&v31, v29);
}

uint64_t std::__function::__func<QMINetworkRegistrationDriver::processRATAndDataStatus_sync(subscriber::SimSlot,ServingSystem &,ServingSystemInfo const&)::$_0,std::allocator<QMINetworkRegistrationDriver::processRATAndDataStatus_sync(subscriber::SimSlot,ServingSystem &,ServingSystemInfo const&)::$_0>,void ()(ServingSystem::System const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<QMINetworkRegistrationDriver::processRATAndDataStatus_sync(subscriber::SimSlot,ServingSystem &,ServingSystemInfo const&)::$_0,std::allocator<QMINetworkRegistrationDriver::processRATAndDataStatus_sync(subscriber::SimSlot,ServingSystem &,ServingSystemInfo const&)::$_0>,void ()(ServingSystem::System const&)>::target_type()
{
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::PlmnInfo>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::PlmnInfo>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

_WORD **qmi::MutableMessageBase::TlvWrapper<nas::tlv::PlmnInfo>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _WORD *v4;
  uint64_t v5;
  _WORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_WORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::TdFragmentInfo>((_WORD **)a2, (_WORD *)(a1 + 10));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::PlmnInfo>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E9A38;
  *(_DWORD *)(result + 10) = *(_DWORD *)(a1 + 10);
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::AlwaysSendPLMNName>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::AlwaysSendPLMNName>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<nas::tlv::AlwaysSendPLMNName>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::AlwaysSendPLMNName>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E9A88;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::RATForPLMN>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::RATForPLMN>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<nas::tlv::RATForPLMN>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::RATForPLMN>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E9AD8;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::MncPcsDigitInfo>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::MncPcsDigitInfo>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<nas::tlv::MncPcsDigitInfo>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::MncPcsDigitInfo>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E9B28;
  return result;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver11getPlmnNameEN10subscriber7SimSlotE3MCC3MNC21RadioAccessTechnologyE3__4EEOS1_OT__block_invoke(uint64_t a1, qmi::MessageBase *a2)
{
  unsigned int *v3;
  uint64_t v4;
  uint64_t v5;
  os_log_t *v6;
  int v7;
  NSObject *v8;
  nas::tlv *TlvValue;
  int v10;
  nas::tlv::PlmnNameInfo *v11;
  nas::tlv *v12;
  int v13;
  nas::tlv *v14;
  void *v15;
  int v16;
  void *v17;
  int v18;
  uint64_t v19;
  nas::tlv *v20;
  int v21;
  nas::tlv::EvoNitzInfo *v22;
  nas::tlv *v23;
  int v24;
  nas::tlv *v25;
  uint64_t v26;
  void *v27[2];
  void *v28[2];
  void *v29[2];
  void *v30[2];
  void *v31[2];
  void *v32[2];
  char v33;
  char v34;
  void *v35;
  char v36;
  char v37;
  void *v38;
  char v39;
  nas::tlv *v40;
  __int128 v41;
  uint64_t v42;
  uint8_t buf[48];
  void *v44[2];
  __int128 v45;
  void *v46[2];
  __int128 v47;
  __int128 v48;
  void *v49[2];
  __int128 v50;
  __int128 v51;
  uint64_t v52;
  uint64_t v53;

  v53 = *MEMORY[0x24BDAC8D0];
  v3 = *(unsigned int **)(a1 + 32);
  v4 = *(_QWORD *)v3;
  v5 = v3[2];
  v6 = (os_log_t *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(*(_QWORD *)v3 + 88) + 16))(*(_QWORD *)(*(_QWORD *)v3 + 88), v5);
  v7 = *((_DWORD *)a2 + 1);
  if (v7)
  {
    v8 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109378;
      *(_DWORD *)&buf[4] = v7;
      *(_WORD *)&buf[8] = 2080;
      *(_QWORD *)&buf[10] = qmi::asString();
      _os_log_impl(&dword_216897000, v8, OS_LOG_TYPE_DEFAULT, "#N Get PLMN Name failed: Error in response with code %d (%s)", buf, 0x12u);
    }
  }
  else
  {
    *(_OWORD *)v49 = 0u;
    v50 = 0u;
    v47 = 0u;
    v48 = 0u;
    v45 = 0u;
    *(_OWORD *)v46 = 0u;
    *(_OWORD *)v44 = 0u;
    memset(buf, 0, sizeof(buf));
    HIDWORD(v45) = 11;
    v52 = 0;
    v51 = 0uLL;
    TlvValue = (nas::tlv *)qmi::MessageBase::findTlvValue(a2);
    v12 = TlvValue;
    if (TlvValue)
    {
      v13 = v10;
      v40 = TlvValue;
      *(_OWORD *)v31 = 0u;
      *(_OWORD *)v32 = 0u;
      *(_OWORD *)v29 = 0u;
      *(_OWORD *)v30 = 0u;
      *(_OWORD *)v27 = 0u;
      *(_OWORD *)v28 = 0u;
      tlv::parseV<nas::tlv::PlmnNameInfo>(&v40, v10, v11, (uint64_t)v27);
      v14 = v40;
      if (v40)
      {
        decodeOperatorName();
        if ((char)buf[47] < 0)
          operator delete(*(void **)&buf[24]);
        *(_OWORD *)&buf[24] = v41;
        *(_QWORD *)&buf[40] = v42;
        decodeOperatorName();
        if ((char)buf[23] < 0)
          operator delete(*(void **)buf);
        *(_OWORD *)buf = v41;
        *(_QWORD *)&buf[16] = v42;
        decodeOperatorName();
        if (SBYTE7(v45) < 0)
          operator delete(v44[0]);
        *(_OWORD *)v44 = v41;
        *(_QWORD *)&v45 = v42;
      }
      if (v31[1])
      {
        v32[0] = v31[1];
        operator delete(v31[1]);
      }
      if (v29[1])
      {
        v30[0] = v29[1];
        operator delete(v29[1]);
      }
      if (v27[1])
      {
        v28[0] = v27[1];
        operator delete(v27[1]);
      }
      if (!v14)
        ((void (*)(_QWORD, uint64_t, nas::tlv *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 16, v12, v13);
    }
    v15 = (void *)qmi::MessageBase::findTlvValue(a2);
    v17 = v15;
    if (v15)
    {
      v18 = v16;
      v27[0] = v15;
      v19 = tlv::parseV<nas::tlv::NetworkNameSource>((unint64_t *)v27, v16);
      if (v27[0])
        DWORD2(v45) = nas::convert(v19);
      else
        ((void (*)(_QWORD, uint64_t, void *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 21, v17, v18);
    }
    v20 = (nas::tlv *)qmi::MessageBase::findTlvValue(a2);
    v23 = v20;
    if (v20)
    {
      v24 = v21;
      v40 = v20;
      v30[0] = 0;
      *(_OWORD *)v28 = 0u;
      *(_OWORD *)v29 = 0u;
      *(_OWORD *)v27 = 0u;
      tlv::parseV<nas::tlv::EvoNitzInfo>(&v40, v21, v22, (uint64_t)v27);
      v25 = v40;
      if (v40)
      {
        decodeOperatorName();
        if (SHIBYTE(v52) < 0)
          operator delete((void *)v51);
        v51 = v41;
        v52 = v42;
      }
      if (v29[0])
      {
        v29[1] = v29[0];
        operator delete(v29[0]);
      }
      if (v27[1])
      {
        v28[0] = v27[1];
        operator delete(v27[1]);
      }
      if (!v25)
        ((void (*)(_QWORD, uint64_t, nas::tlv *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 160, v23, v24);
    }
    v26 = *(_QWORD *)(v4 + 64);
    OperatorNameUpdate::OperatorNameUpdate((std::string *)v27, (const OperatorNameUpdate *)buf);
    (*(void (**)(uint64_t, uint64_t, void **))(*(_QWORD *)v26 + 80))(v26, v5, v27);
    if (v39 < 0)
      operator delete(v38);
    if (v37 && v36 < 0)
      operator delete(v35);
    if (v34 && v33 < 0)
      operator delete(v32[1]);
    if (SHIBYTE(v31[0]) < 0)
      operator delete(v30[0]);
    if (SHIBYTE(v29[1]) < 0)
      operator delete(v28[1]);
    if (SHIBYTE(v28[0]) < 0)
      operator delete(v27[0]);
    if (SHIBYTE(v52) < 0)
      operator delete((void *)v51);
    if (BYTE8(v50) && SBYTE7(v50) < 0)
      operator delete(v49[0]);
    if ((_BYTE)v48 && SHIBYTE(v47) < 0)
      operator delete(v46[1]);
    if (SBYTE7(v45) < 0)
      operator delete(v44[0]);
    if ((char)buf[47] < 0)
      operator delete(*(void **)&buf[24]);
    if ((char)buf[23] < 0)
      operator delete(*(void **)buf);
  }
}

void sub_216A7DEC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, void *a12, void *__p, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,void *a43,uint64_t a44,int a45,__int16 a46,char a47,char a48,void *a49,uint64_t a50,int a51,__int16 a52,char a53,char a54,uint64_t a55,uint64_t a56,void *a57,uint64_t a58,int a59,__int16 a60,char a61,char a62,char a63)
{
  void *a65;
  char a70;
  char a71;
  void *a72;
  char a73;

  if (__p)
    operator delete(__p);
  if (a10)
    operator delete(a10);
  if (a73 < 0)
    operator delete(a72);
  if (a71 && a70 < 0)
    operator delete(a65);
  if (a63 && a62 < 0)
    operator delete(a57);
  if (a54 < 0)
    operator delete(a49);
  if (a48 < 0)
    operator delete(a43);
  if (a42 < 0)
    operator delete(a37);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_32c130_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver11getPlmnNameEN10subscriber7SimSlotE3MCC3MNC21RadioAccessTechnologyE3__4EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c130_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver11getPlmnNameEN10subscriber7SimSlotE3MCC3MNC21RadioAccessTechnologyE3__4EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::getPlmnName(subscriber::SimSlot,MCC,MNC,RadioAccessTechnology)::$_4,std::allocator<QMINetworkRegistrationDriver::getPlmnName(subscriber::SimSlot,MCC,MNC,RadioAccessTechnology)::$_4>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E9B90;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::getPlmnName(subscriber::SimSlot,MCC,MNC,RadioAccessTechnology)::$_4,std::allocator<QMINetworkRegistrationDriver::getPlmnName(subscriber::SimSlot,MCC,MNC,RadioAccessTechnology)::$_4>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E9B90;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas11GetPlmnName8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A7E13C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::ServiceDomainPreference>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::ServiceDomainPreference>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

_DWORD **qmi::MutableMessageBase::TlvWrapper<nas::tlv::ServiceDomainPreference>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _DWORD *v4;
  uint64_t v5;
  _DWORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_DWORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::PktDataHandle>((_DWORD **)a2, (_DWORD *)(a1 + 12));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::ServiceDomainPreference>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E9C20;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a1 + 12);
  return result;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver25sendPSRegistrationRequestEN10subscriber7SimSlotEbE3__2EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  os_log_t *v3;
  int v4;
  NSObject *v5;
  _DWORD v6[2];
  __int16 v7;
  uint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v3 = (os_log_t *)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(**(_QWORD **)(a1 + 32) + 88) + 16))(*(_QWORD *)(**(_QWORD **)(a1 + 32) + 88), *(unsigned int *)(*(_QWORD *)(a1 + 32) + 8));
  v4 = *(_DWORD *)(a2 + 4);
  if (v4)
  {
    v5 = *v3;
    if (os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT))
    {
      v6[0] = 67109378;
      v6[1] = v4;
      v7 = 2080;
      v8 = qmi::asString();
      _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#E CS-PS Attach preference failed: Error in response with code %d (%s)", (uint8_t *)v6, 0x12u);
    }
  }
}

uint64_t __copy_helper_block_e8_32c114_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver25sendPSRegistrationRequestEN10subscriber7SimSlotEbE3__2EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c114_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver25sendPSRegistrationRequestEN10subscriber7SimSlotEbE3__2EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::sendPSRegistrationRequest(subscriber::SimSlot,BOOL)::$_2,std::allocator<QMINetworkRegistrationDriver::sendPSRegistrationRequest(subscriber::SimSlot,BOOL)::$_2>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E9C88;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::sendPSRegistrationRequest(subscriber::SimSlot,BOOL)::$_2,std::allocator<QMINetworkRegistrationDriver::sendPSRegistrationRequest(subscriber::SimSlot,BOOL)::$_2>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E9C88;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkSelectionRegistrationRestrictionPreference>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkSelectionRegistrationRestrictionPreference>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

_DWORD **qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkSelectionRegistrationRestrictionPreference>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _DWORD *v4;
  uint64_t v5;
  _DWORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_DWORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::PktDataHandle>((_DWORD **)a2, (_DWORD *)(a1 + 12));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::NetworkSelectionRegistrationRestrictionPreference>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E9CF0;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a1 + 12);
  return result;
}

uint64_t ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver15setCampOnlyModeEN10subscriber7SimSlotEbE3__1EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t *v2;
  uint64_t v3;
  int v4;
  NSObject *v6;
  _BOOL4 v7;
  _BOOL8 v8;
  _DWORD v10[2];
  __int16 v11;
  uint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v2 = *(uint64_t **)(a1 + 32);
  v3 = *v2;
  v4 = *(_DWORD *)(a2 + 4);
  if (v4)
  {
    v6 = *(NSObject **)v2[2];
    v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
    v8 = 0;
    if (v7)
    {
      v10[0] = 67109378;
      v10[1] = v4;
      v11 = 2080;
      v12 = qmi::asString();
      _os_log_impl(&dword_216897000, v6, OS_LOG_TYPE_DEFAULT, "#E Set CMAS Mode failed: Error in response with code %d (%s)", (uint8_t *)v10, 0x12u);
      v8 = *(_DWORD *)(a2 + 4) == 0;
    }
  }
  else
  {
    v8 = 1;
  }
  return (*(uint64_t (**)(_QWORD, _QWORD, _BOOL8, _QWORD))(**(_QWORD **)(v3 + 64) + 208))(*(_QWORD *)(v3 + 64), *((unsigned int *)v2 + 2), v8, 2 * *((unsigned __int8 *)v2 + 12));
}

uint64_t __copy_helper_block_e8_32c104_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver15setCampOnlyModeEN10subscriber7SimSlotEbE3__1EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c104_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver15setCampOnlyModeEN10subscriber7SimSlotEbE3__1EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::setCampOnlyMode(subscriber::SimSlot,BOOL)::$_1,std::allocator<QMINetworkRegistrationDriver::setCampOnlyMode(subscriber::SimSlot,BOOL)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E9D58;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::setCampOnlyMode(subscriber::SimSlot,BOOL)::$_1,std::allocator<QMINetworkRegistrationDriver::setCampOnlyMode(subscriber::SimSlot,BOOL)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E9D58;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver19setProvisioningModeEbE3__0EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  unsigned __int8 *v2;
  int v3;
  NSObject *v4;
  _DWORD v5[2];
  __int16 v6;
  uint64_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  v2 = *(unsigned __int8 **)(a1 + 32);
  v3 = *(_DWORD *)(a2 + 4);
  if (v3)
  {
    v4 = **((_QWORD **)v2 + 2);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      v5[0] = 67109378;
      v5[1] = v3;
      v6 = 2080;
      v7 = qmi::asString();
      _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#E Enabling provisioning mode failed: Error in response with code %d (%s)", (uint8_t *)v5, 0x12u);
    }
  }
  else
  {
    (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)(*(_QWORD *)v2 + 64) + 96))(*(_QWORD *)(*(_QWORD *)v2 + 64), v2[8]);
  }
}

uint64_t __copy_helper_block_e8_32c86_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver19setProvisioningModeEbE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c86_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver19setProvisioningModeEbE3__0EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::setProvisioningMode(BOOL)::$_0,std::allocator<QMINetworkRegistrationDriver::setProvisioningMode(BOOL)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E9DD8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::setProvisioningMode(BOOL)::$_0,std::allocator<QMINetworkRegistrationDriver::setProvisioningMode(BOOL)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E9DD8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver19setProvisioningModeEbE3__1EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  unsigned __int8 *v2;
  int v3;
  NSObject *v4;
  _DWORD v5[2];
  __int16 v6;
  uint64_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  v2 = *(unsigned __int8 **)(a1 + 32);
  v3 = *(_DWORD *)(a2 + 4);
  if (v3)
  {
    v4 = **((_QWORD **)v2 + 2);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      v5[0] = 67109378;
      v5[1] = v3;
      v6 = 2080;
      v7 = qmi::asString();
      _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#E Disabling provisioning mode failed: Error in response with code %d (%s)", (uint8_t *)v5, 0x12u);
    }
  }
  else
  {
    (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)(*(_QWORD *)v2 + 64) + 96))(*(_QWORD *)(*(_QWORD *)v2 + 64), v2[8]);
  }
}

uint64_t __copy_helper_block_e8_32c86_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver19setProvisioningModeEbE3__1EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c86_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver19setProvisioningModeEbE3__1EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::setProvisioningMode(BOOL)::$_1,std::allocator<QMINetworkRegistrationDriver::setProvisioningMode(BOOL)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E9E58;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::setProvisioningMode(BOOL)::$_1,std::allocator<QMINetworkRegistrationDriver::setProvisioningMode(BOOL)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E9E58;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver19getProvisioningModeENSt3__18functionIFvbEEEE3__0EEOS1_OT__block_invoke(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v3;
  int v4;
  NSObject *v5;
  uint64_t TlvValue;
  int v7;
  uint64_t v8;
  int v9;
  char v10;
  uint8_t *v11;
  uint64_t v12;
  unint64_t v13;
  BOOL v14;
  uint8_t buf[4];
  int v16;
  __int16 v17;
  uint64_t v18;
  uint8_t *v19;
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 + 32);
  v4 = *((_DWORD *)a2 + 1);
  if (v4)
  {
    v5 = **(NSObject ***)(v3 + 32);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109378;
      v16 = v4;
      v17 = 2080;
      v18 = qmi::asString();
      _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#E Querying provisioning mode failed: Error in response with code %d (%s)", buf, 0x12u);
    }
  }
  else
  {
    std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100]((uint64_t)buf, v3);
    TlvValue = qmi::MessageBase::findTlvValue(a2);
    v8 = TlvValue;
    if (TlvValue)
    {
      v9 = v7;
      v13 = TlvValue;
      v10 = tlv::parseV<nas::tlv::CambioMode>(&v13, v7);
      if (v13)
      {
        v14 = v10 != 0;
        if (!v19)
          std::__throw_bad_function_call[abi:ne180100]();
        (*(void (**)(uint8_t *, BOOL *))(*(_QWORD *)v19 + 48))(v19, &v14);
      }
      else
      {
        ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 1, v8, v9);
      }
    }
    v11 = v19;
    if (v19 == buf)
    {
      v12 = 4;
      v11 = buf;
    }
    else
    {
      if (!v19)
        return;
      v12 = 5;
    }
    (*(void (**)(void))(*(_QWORD *)v11 + 8 * v12))();
  }
}

void sub_216A7EA14(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  _Unwind_Resume(exception_object);
}

uint64_t __copy_helper_block_e8_32c104_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver19getProvisioningModeENS_8functionIFvbEEEE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c104_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver19getProvisioningModeENS_8functionIFvbEEEE3__0EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::getProvisioningMode(std::function<void ()(BOOL)>)::$_0,std::allocator<QMINetworkRegistrationDriver::getProvisioningMode(std::function<void ()(BOOL)>)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E9ED8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::getProvisioningMode(std::function<void ()(BOOL)>)::$_0,std::allocator<QMINetworkRegistrationDriver::getProvisioningMode(std::function<void ()(BOOL)>)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E9ED8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__shared_ptr_emplace<QMINetworkRegistrationDriver::getProvisioningMode(std::function<void ()(BOOL)>)::$_0,std::allocator<QMINetworkRegistrationDriver::getProvisioningMode(std::function<void ()(BOOL)>)::$_0>>::__on_zero_shared(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *result;
  uint64_t v3;

  v1 = (_QWORD *)(a1 + 24);
  result = *(_QWORD **)(a1 + 48);
  if (result == v1)
  {
    v3 = 4;
    result = v1;
  }
  else
  {
    if (!result)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas19GetProvisioningMode8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A7EBB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZZN28QMINetworkRegistrationDriver26invalidateNetworkTimeCacheEvENK3__0clINS_16SubscriptionTypeEEEDaT_EUlRKNS_12ResponseBaseEE_EEOS1_OS8__block_invoke(uint64_t a1, uint64_t a2)
{
  int v2;
  NSObject *v3;
  _DWORD v4[2];
  __int16 v5;
  uint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v2 = *(_DWORD *)(a2 + 4);
  if (v2)
  {
    v3 = ***(NSObject ****)(a1 + 32);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      v4[0] = 67109378;
      v4[1] = v2;
      v5 = 2080;
      v6 = qmi::asString();
      _os_log_impl(&dword_216897000, v3, OS_LOG_TYPE_DEFAULT, "#N Invalidate cache request failed: Error in response with code %d (%s)", (uint8_t *)v4, 0x12u);
    }
  }
}

uint64_t __copy_helper_block_e8_32c155_ZTSNSt3__110shared_ptrIZZN28QMINetworkRegistrationDriver26invalidateNetworkTimeCacheEvENK3__0clIN3qmi16SubscriptionTypeEEEDaT_EUlRKNS4_12ResponseBaseEE_EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void __destroy_helper_block_e8_32c155_ZTSNSt3__110shared_ptrIZZN28QMINetworkRegistrationDriver26invalidateNetworkTimeCacheEvENK3__0clIN3qmi16SubscriptionTypeEEEDaT_EUlRKNS4_12ResponseBaseEE_EE(uint64_t a1)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v3;

  v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1)
  {
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      v3 = __ldaxr(p_shared_owners);
    while (__stlxr(v3 - 1, p_shared_owners));
    if (!v3)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

void _ZNSt3__120__shared_ptr_emplaceIZZN28QMINetworkRegistrationDriver26invalidateNetworkTimeCacheEvENK3__0clIN3qmi16SubscriptionTypeEEEDaT_EUlRKNS4_12ResponseBaseEE_NS_9allocatorISB_EEED1Ev(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E9F80;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void _ZNSt3__120__shared_ptr_emplaceIZZN28QMINetworkRegistrationDriver26invalidateNetworkTimeCacheEvENK3__0clIN3qmi16SubscriptionTypeEEEDaT_EUlRKNS4_12ResponseBaseEE_NS_9allocatorISB_EEED0Ev(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E9F80;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::ClientRouter::SendProxy::SendProxy<nas::SetE911State::Request>(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v5;

  *(_DWORD *)a1 = a2;
  v5 = operator new();
  *(_QWORD *)v5 = a3;
  *(_QWORD *)(v5 + 8) = QMIServiceMsg::create();
  *(_DWORD *)(v5 + 16) = 25000;
  *(_QWORD *)(v5 + 24) = 0;
  *(_QWORD *)(v5 + 32) = 0;
  *(_QWORD *)(a1 + 8) = v5;
  return a1;
}

void sub_216A7EDE4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199FEAC4](v1, 0x10F0C401BA14CC5);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver14enterE911StateEN10subscriber7SimSlotERKNSt3__16vectorI18EmergencySetupTypeNS6_9allocatorIS8_EEEEbbS5_bE3__2EEOS1_OT__block_invoke(uint64_t a1, qmi::MessageBase *this)
{
  uint64_t *v2;
  uint64_t v3;
  int v4;
  NSObject *v5;
  uint64_t TlvValue;
  int v8;
  uint64_t v9;
  int v10;
  unsigned __int8 v11;
  unsigned __int8 v12;
  int v13;
  NSObject *v14;
  const char *v15;
  NSObject *v16;
  uint64_t v17;
  _DWORD *v18;
  uint64_t v19;
  _BOOL4 v20;
  uint64_t v21;
  NSObject *v22;
  uint64_t v23;
  uint64_t v24;
  uint8_t buf[4];
  _BYTE v26[14];
  __int16 v27;
  uint64_t v28;
  uint64_t v29;

  v29 = *MEMORY[0x24BDAC8D0];
  v2 = *(uint64_t **)(a1 + 32);
  v3 = *v2;
  v4 = *((_DWORD *)this + 1);
  if (v4)
  {
    v5 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109634;
      *(_DWORD *)v26 = v4;
      *(_WORD *)&v26[4] = 2080;
      *(_QWORD *)&v26[6] = qmi::asString();
      v27 = 2080;
      v28 = subscriber::asString();
      _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#E Querying preferred E911 subscription failed: Error in response with code %d (%s). Default to %s", buf, 0x1Cu);
    }
    goto LABEL_18;
  }
  TlvValue = qmi::MessageBase::findTlvValue(this);
  if (!TlvValue)
    goto LABEL_13;
  v9 = TlvValue;
  v10 = v8;
  v24 = TlvValue;
  v11 = tlv::parseV<nas::tlv::E911Sub>((unint64_t *)&v24, v8);
  if (!v24)
  {
    ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)this, 16, v9, v10);
LABEL_13:
    v13 = 1;
    goto LABEL_14;
  }
  v12 = v11;
  if (v11)
    v13 = 2 * (v11 == 1);
  else
    v13 = 1;
  if ((subscriber::isValidSimSlot() & 1) == 0)
  {
    v14 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      v15 = nas::asString(v12);
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)v26 = v15;
      _os_log_error_impl(&dword_216897000, v14, OS_LOG_TYPE_ERROR, "Got invalid preferred E911 subscription %s", buf, 0xCu);
    }
  }
LABEL_14:
  v16 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    v17 = subscriber::asString();
    *(_DWORD *)buf = 136315138;
    *(_QWORD *)v26 = v17;
    _os_log_impl(&dword_216897000, v16, OS_LOG_TYPE_DEFAULT, "#I Using %s as preferred E911 subscription", buf, 0xCu);
  }
  if (v13 != 2)
  {
    if (v13 != 1)
    {
      v19 = 0;
LABEL_23:
      v20 = 0;
      goto LABEL_24;
    }
LABEL_18:
    v18 = (_DWORD *)v2[10];
    v19 = 1;
    if ((_DWORD *)v2[11] != v18)
    {
LABEL_19:
      v20 = *v18 == 2;
      goto LABEL_24;
    }
    goto LABEL_23;
  }
  v21 = v2[10];
  if ((unint64_t)(v2[11] - v21) >= 5)
  {
    v18 = (_DWORD *)(v21 + 4);
    v19 = 2;
    goto LABEL_19;
  }
  v20 = 0;
  v19 = 2;
LABEL_24:
  v22 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    v23 = CSIBOOLAsString();
    *(_DWORD *)buf = 136315138;
    *(_QWORD *)v26 = v23;
    _os_log_impl(&dword_216897000, v22, OS_LOG_TYPE_DEFAULT, "#I Is emergency call going to be set up as normal: %s", buf, 0xCu);
  }
  (*(void (**)(_QWORD, unint64_t))(**(_QWORD **)(v3 + 64) + 144))(*(_QWORD *)(v3 + 64), v20 | (unint64_t)(v19 << 32));
  if (!v20)
    QMINetworkRegistrationDriver::enterE911State(subscriber::SimSlot,std::vector<EmergencySetupType> const&,BOOL,BOOL,subscriber::SimSlot,BOOL)::$_1::operator()((uint64_t)(v2 + 1), v19);
}

uint64_t __copy_helper_block_e8_32c162_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver14enterE911StateEN10subscriber7SimSlotERKNS_6vectorI18EmergencySetupTypeNS_9allocatorIS5_EEEEbbS3_bE3__2EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c162_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver14enterE911StateEN10subscriber7SimSlotERKNS_6vectorI18EmergencySetupTypeNS_9allocatorIS5_EEEEbbS3_bE3__2EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::enterE911State(subscriber::SimSlot,std::vector<EmergencySetupType> const&,BOOL,BOOL,subscriber::SimSlot,BOOL)::$_2,std::allocator<QMINetworkRegistrationDriver::enterE911State(subscriber::SimSlot,std::vector<EmergencySetupType> const&,BOOL,BOOL,subscriber::SimSlot,BOOL)::$_2>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5EA000;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::enterE911State(subscriber::SimSlot,std::vector<EmergencySetupType> const&,BOOL,BOOL,subscriber::SimSlot,BOOL)::$_2,std::allocator<QMINetworkRegistrationDriver::enterE911State(subscriber::SimSlot,std::vector<EmergencySetupType> const&,BOOL,BOOL,subscriber::SimSlot,BOOL)::$_2>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5EA000;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::enterE911State(subscriber::SimSlot,std::vector<EmergencySetupType> const&,BOOL,BOOL,subscriber::SimSlot,BOOL)::$_2,std::allocator<QMINetworkRegistrationDriver::enterE911State(subscriber::SimSlot,std::vector<EmergencySetupType> const&,BOOL,BOOL,subscriber::SimSlot,BOOL)::$_2>>::__on_zero_shared(_QWORD *a1)
{
  void *v2;
  void *v3;
  void *v4;

  v2 = (void *)a1[13];
  if (v2)
  {
    a1[14] = v2;
    operator delete(v2);
  }
  v3 = (void *)a1[10];
  if (v3)
  {
    a1[11] = v3;
    operator delete(v3);
  }
  v4 = (void *)a1[5];
  if (v4)
  {
    a1[6] = v4;
    operator delete(v4);
  }
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas10GetE911Sub8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A7F264(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver13exitE911StateEN10subscriber7SimSlotEE3__1EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t *v3;
  int v4;
  uint64_t v5;
  NSObject *v6;
  _BOOL4 v7;
  NSObject *v8;
  uint64_t v9;
  const char *v10;
  NSObject *v11;
  uint32_t v12;
  int v13;
  int v14;
  __int16 v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v3 = *(uint64_t **)(a1 + 32);
  v4 = *(_DWORD *)(a2 + 4);
  v5 = *v3;
  v6 = *(NSObject **)v3[1];
  v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
  if (!v4)
  {
    if (v7)
    {
      LOWORD(v13) = 0;
      v10 = "#I Exit E911 state successful";
      v11 = v6;
      v12 = 2;
      goto LABEL_9;
    }
LABEL_10:
    (*(void (**)(_QWORD))(**(_QWORD **)(v5 + 64) + 160))(*(_QWORD *)(v5 + 64));
    return;
  }
  if (v7)
  {
    v13 = 67109378;
    v14 = v4;
    v15 = 2080;
    v16 = qmi::asString();
    _os_log_impl(&dword_216897000, v6, OS_LOG_TYPE_DEFAULT, "#N Exit E911 state failed: Error in response with code %d (%s)", (uint8_t *)&v13, 0x12u);
    v4 = *(_DWORD *)(a2 + 4);
  }
  if (v4 == 26)
  {
    v8 = *(NSObject **)v3[1];
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = qmi::asString();
      v13 = 67109378;
      v14 = 26;
      v15 = 2080;
      v16 = v9;
      v10 = "#I E911 state exit failed with code %d (%s), send Completed indication anyway";
      v11 = v8;
      v12 = 18;
LABEL_9:
      _os_log_impl(&dword_216897000, v11, OS_LOG_TYPE_DEFAULT, v10, (uint8_t *)&v13, v12);
      goto LABEL_10;
    }
    goto LABEL_10;
  }
}

uint64_t __copy_helper_block_e8_32c101_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver13exitE911StateEN10subscriber7SimSlotEE3__1EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c101_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver13exitE911StateEN10subscriber7SimSlotEE3__1EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::exitE911State(subscriber::SimSlot)::$_1,std::allocator<QMINetworkRegistrationDriver::exitE911State(subscriber::SimSlot)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5EA0A8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::exitE911State(subscriber::SimSlot)::$_1,std::allocator<QMINetworkRegistrationDriver::exitE911State(subscriber::SimSlot)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5EA0A8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver35setImsProceedWithSubscriptionChangeEN10subscriber7SimSlotEE3__0EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  int v2;
  NSObject *v3;
  _DWORD v4[2];
  __int16 v5;
  uint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v2 = *(_DWORD *)(a2 + 4);
  if (v2)
  {
    v3 = ***(NSObject ****)(a1 + 32);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      v4[0] = 67109378;
      v4[1] = v2;
      v5 = 2080;
      v6 = qmi::asString();
      _os_log_impl(&dword_216897000, v3, OS_LOG_TYPE_DEFAULT, "#N ProceedWithSubscriptionChange request failed: Error in response with code %d (%s)", (uint8_t *)v4, 0x12u);
    }
  }
}

uint64_t __copy_helper_block_e8_32c123_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver35setImsProceedWithSubscriptionChangeEN10subscriber7SimSlotEE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c123_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver35setImsProceedWithSubscriptionChangeEN10subscriber7SimSlotEE3__0EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::setImsProceedWithSubscriptionChange(subscriber::SimSlot)::$_0,std::allocator<QMINetworkRegistrationDriver::setImsProceedWithSubscriptionChange(subscriber::SimSlot)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5EA128;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::setImsProceedWithSubscriptionChange(subscriber::SimSlot)::$_0,std::allocator<QMINetworkRegistrationDriver::setImsProceedWithSubscriptionChange(subscriber::SimSlot)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5EA128;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver25getImsPreferenceInfo_syncENS_16SubscriptionTypeEE3__0EEOS1_OT__block_invoke(uint64_t a1, qmi::MessageBase *this)
{
  uint64_t *v2;
  int v3;
  NSObject *v4;
  uint64_t v6;
  unsigned int v7;
  capabilities::ct *v8;
  uint64_t TlvValue;
  int v10;
  uint64_t v11;
  int v12;
  unsigned __int8 v13;
  sd *v14;
  sd *v15;
  NSObject *v16;
  void **v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v21;
  void *__p;
  void *v23;
  uint64_t v24;
  uint8_t v25[4];
  int v26;
  __int16 v27;
  void **v28;
  uint8_t buf[8];
  __int128 v30;
  uint64_t v31;

  v31 = *MEMORY[0x24BDAC8D0];
  v2 = *(uint64_t **)(a1 + 32);
  v3 = *((_DWORD *)this + 1);
  if (v3)
  {
    v4 = *(NSObject **)v2[2];
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109378;
      *(_DWORD *)&buf[4] = v3;
      LOWORD(v30) = 2080;
      *(_QWORD *)((char *)&v30 + 2) = qmi::asString();
      _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#N Get IMS preference failed: Error in response with code %d (%s)", buf, 0x12u);
    }
  }
  else
  {
    v6 = *v2;
    v7 = *((_DWORD *)v2 + 2);
    v8 = (capabilities::ct *)v2[2];
    TlvValue = qmi::MessageBase::findTlvValue(this);
    if (TlvValue)
    {
      v11 = TlvValue;
      v12 = v10;
      v21 = TlvValue;
      v13 = tlv::parseV<nas::tlv::IpPrefInfo>((unint64_t *)&v21, v10);
      if (v21)
      {
        v15 = v14;
        *(_QWORD *)buf = 0;
        v30 = 0uLL;
        dataModesFromSysMode(v8, v13, (uint64_t)buf);
        v16 = *(NSObject **)v8;
        if (*(_QWORD *)buf == (_QWORD)v30)
        {
          if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
          {
            LODWORD(__p) = 67109120;
            HIDWORD(__p) = (_DWORD)v15;
            _os_log_error_impl(&dword_216897000, v16, OS_LOG_TYPE_ERROR, "Get IMS preference retrieved with IMS supported = %d and no data modes", (uint8_t *)&__p, 8u);
          }
        }
        else
        {
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
          {
            asString();
            v17 = v24 >= 0 ? &__p : (void **)__p;
            *(_DWORD *)v25 = 67109378;
            v26 = (int)v15;
            v27 = 2082;
            v28 = v17;
            _os_log_impl(&dword_216897000, v16, OS_LOG_TYPE_DEFAULT, "#I IMS preference retrieved: IMS supported = %d, data modes = %{public}s", v25, 0x12u);
            if (SHIBYTE(v24) < 0)
              operator delete(__p);
          }
          v18 = *(_QWORD *)(v6 + 64);
          if (v7 - 1 >= 3)
            v19 = 0;
          else
            v19 = v7;
          v23 = 0;
          v24 = 0;
          __p = 0;
          std::vector<DataMode>::__init_with_size[abi:ne180100]<DataMode*,DataMode*>(&__p, *(const void **)buf, v30, (uint64_t)(v30 - *(_QWORD *)buf) >> 2);
          v20 = sd::imsServiceMaskFromUint(v15);
          (*(void (**)(uint64_t, uint64_t, void **, _QWORD))(*(_QWORD *)v18 + 128))(v18, v19, &__p, v20);
          if (__p)
          {
            v23 = __p;
            operator delete(__p);
          }
        }
        if (*(_QWORD *)buf)
        {
          *(_QWORD *)&v30 = *(_QWORD *)buf;
          operator delete(*(void **)buf);
        }
      }
      else
      {
        ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)this, 16, v11, v12);
      }
    }
  }
}

void sub_216A7F854(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t __copy_helper_block_e8_32c115_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver25getImsPreferenceInfo_syncEN3qmi16SubscriptionTypeEE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c115_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver25getImsPreferenceInfo_syncEN3qmi16SubscriptionTypeEE3__0EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::getImsPreferenceInfo_sync(qmi::SubscriptionType)::$_0,std::allocator<QMINetworkRegistrationDriver::getImsPreferenceInfo_sync(qmi::SubscriptionType)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5EA1A8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::getImsPreferenceInfo_sync(qmi::SubscriptionType)::$_0,std::allocator<QMINetworkRegistrationDriver::getImsPreferenceInfo_sync(qmi::SubscriptionType)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5EA1A8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas20GetImsPreferenceInfo8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A7F9C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

_QWORD *std::vector<DataMode>::__init_with_size[abi:ne180100]<DataMode*,DataMode*>(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<unsigned int>::__vallocate[abi:ne180100](result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_216A7FA60(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::BasebandIpState>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::BasebandIpState>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<nas::tlv::BasebandIpState>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::BasebandIpState>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5EA238;
  return result;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver9enableImsEN10subscriber7SimSlotE19ImsStateForBasebandE3__1EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  NSObject *v3;
  int v4;
  _DWORD v5[2];
  __int16 v6;
  uint64_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)(a2 + 4))
  {
    v3 = *(NSObject **)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(**(_QWORD **)(a1 + 32) + 88) + 16))(*(_QWORD *)(**(_QWORD **)(a1 + 32) + 88), *(unsigned int *)(*(_QWORD *)(a1 + 32) + 8));
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      v4 = *(_DWORD *)(a2 + 4);
      v5[0] = 67109378;
      v5[1] = v4;
      v6 = 2080;
      v7 = qmi::asString();
      _os_log_impl(&dword_216897000, v3, OS_LOG_TYPE_DEFAULT, "#N IMS setting failed to be sent to baseband: Error in response with code %d (%s)", (uint8_t *)v5, 0x12u);
    }
  }
}

uint64_t __copy_helper_block_e8_32c117_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver9enableImsEN10subscriber7SimSlotE19ImsStateForBasebandE3__1EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c117_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver9enableImsEN10subscriber7SimSlotE19ImsStateForBasebandE3__1EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::enableIms(subscriber::SimSlot,ImsStateForBaseband)::$_1,std::allocator<QMINetworkRegistrationDriver::enableIms(subscriber::SimSlot,ImsStateForBaseband)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5EA2A0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::enableIms(subscriber::SimSlot,ImsStateForBaseband)::$_1,std::allocator<QMINetworkRegistrationDriver::enableIms(subscriber::SimSlot,ImsStateForBaseband)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5EA2A0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::NR5GVoiceSupportSetting>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::NR5GVoiceSupportSetting>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

_DWORD **qmi::MutableMessageBase::TlvWrapper<nas::tlv::NR5GVoiceSupportSetting>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _DWORD *v4;
  uint64_t v5;
  _DWORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_DWORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::PktDataHandle>((_DWORD **)a2, (_DWORD *)(a1 + 12));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::NR5GVoiceSupportSetting>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5EA308;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a1 + 12);
  return result;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver15updateVoNRStateEN10subscriber7SimSlotE20VoNRStateForBasebandE3__1EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  NSObject *v3;
  int v4;
  _DWORD v5[2];
  __int16 v6;
  uint64_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)(a2 + 4))
  {
    v3 = *(NSObject **)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(**(_QWORD **)(a1 + 32) + 88) + 16))(*(_QWORD *)(**(_QWORD **)(a1 + 32) + 88), *(unsigned int *)(*(_QWORD *)(a1 + 32) + 8));
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      v4 = *(_DWORD *)(a2 + 4);
      v5[0] = 67109378;
      v5[1] = v4;
      v6 = 2080;
      v7 = qmi::asString();
      _os_log_impl(&dword_216897000, v3, OS_LOG_TYPE_DEFAULT, "#N VoNR setting failed to be sent to baseband: Error in response with code %d (%s)", (uint8_t *)v5, 0x12u);
    }
  }
}

uint64_t __copy_helper_block_e8_32c125_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver15updateVoNRStateEN10subscriber7SimSlotE20VoNRStateForBasebandE3__1EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c125_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver15updateVoNRStateEN10subscriber7SimSlotE20VoNRStateForBasebandE3__1EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::updateVoNRState(subscriber::SimSlot,VoNRStateForBaseband)::$_1,std::allocator<QMINetworkRegistrationDriver::updateVoNRState(subscriber::SimSlot,VoNRStateForBaseband)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5EA370;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::updateVoNRState(subscriber::SimSlot,VoNRStateForBaseband)::$_1,std::allocator<QMINetworkRegistrationDriver::updateVoNRState(subscriber::SimSlot,VoNRStateForBaseband)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5EA370;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::DataRoamingSwitch>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::DataRoamingSwitch>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<nas::tlv::DataRoamingSwitch>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::DataRoamingSwitch>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5EA3D8;
  return result;
}

uint64_t ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver15sendDataRoamingEN10subscriber7SimSlotEbE3__1EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t *v2;
  uint64_t v3;
  NSObject *v5;
  int v7;
  _DWORD v8[2];
  __int16 v9;
  uint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v2 = *(uint64_t **)(a1 + 32);
  v3 = *v2;
  if (!*(_DWORD *)(a2 + 4))
    return (*(uint64_t (**)(_QWORD, _QWORD, uint64_t))(**(_QWORD **)(v3 + 64) + 120))(*(_QWORD *)(v3 + 64), *((unsigned int *)v2 + 2), 1);
  v5 = *(NSObject **)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(v3 + 88) + 16))(*(_QWORD *)(v3 + 88), *((unsigned int *)v2 + 2));
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    v7 = *(_DWORD *)(a2 + 4);
    v8[0] = 67109378;
    v8[1] = v7;
    v9 = 2080;
    v10 = qmi::asString();
    _os_log_error_impl(&dword_216897000, v5, OS_LOG_TYPE_ERROR, "Send Data Roaming switch failed: %d (%s)", (uint8_t *)v8, 0x12u);
  }
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)(v3 + 64) + 120))(*(_QWORD *)(v3 + 64), *((unsigned int *)v2 + 2), 0);
}

uint64_t __copy_helper_block_e8_32c104_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver15sendDataRoamingEN10subscriber7SimSlotEbE3__1EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c104_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver15sendDataRoamingEN10subscriber7SimSlotEbE3__1EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::sendDataRoaming(subscriber::SimSlot,BOOL)::$_1,std::allocator<QMINetworkRegistrationDriver::sendDataRoaming(subscriber::SimSlot,BOOL)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5EA440;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::sendDataRoaming(subscriber::SimSlot,BOOL)::$_1,std::allocator<QMINetworkRegistrationDriver::sendDataRoaming(subscriber::SimSlot,BOOL)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5EA440;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

char *qmi::MutableMessageBase::getTLV<nas::tlv::IpDataMode>(_QWORD *a1)
{
  const void **v2;
  const void **v3;
  char **v4;
  char *v5;
  char *result;
  uint64_t v7;
  unint64_t v8;
  uint64_t *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  v4 = (char **)(a1 + 1);
  if (v2 != v3)
  {
    while (*((_BYTE *)*v2 + 8) != 1)
    {
      if (++v2 == v3)
        goto LABEL_8;
    }
  }
  if (v2 == v3)
  {
LABEL_8:
    v7 = operator new();
    *(_WORD *)(v7 + 8) = 1;
    *(_QWORD *)v7 = &off_24D5EA4A8;
    v8 = a1[3];
    v9 = (uint64_t *)a1[2];
    if ((unint64_t)v9 >= v8)
    {
      v11 = ((char *)v9 - *v4) >> 3;
      if ((unint64_t)(v11 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v12 = v8 - (_QWORD)*v4;
      v13 = v12 >> 2;
      if (v12 >> 2 <= (unint64_t)(v11 + 1))
        v13 = v11 + 1;
      if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
        v14 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v14 = v13;
      if (v14)
        v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v14);
      else
        v15 = 0;
      v16 = (uint64_t *)&v15[8 * v11];
      v17 = &v15[8 * v14];
      *v16 = v7;
      v10 = v16 + 1;
      v19 = (char *)a1[1];
      v18 = (char *)a1[2];
      if (v18 != v19)
      {
        do
        {
          v20 = *((_QWORD *)v18 - 1);
          v18 -= 8;
          *--v16 = v20;
        }
        while (v18 != v19);
        v18 = *v4;
      }
      a1[1] = v16;
      a1[2] = v10;
      a1[3] = v17;
      if (v18)
        operator delete(v18);
    }
    else
    {
      *v9 = v7;
      v10 = v9 + 1;
    }
    result = (char *)(v7 + 9);
    a1[2] = v10;
  }
  else
  {
    if (!v5)
      __cxa_bad_cast();
    return v5 + 9;
  }
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::IpDataMode>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::IpDataMode>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<nas::tlv::IpDataMode>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::IpDataMode>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5EA4A8;
  return result;
}

_QWORD *qmi::MutableMessageBase::TlvWrapper<nas::tlv::IpRegistrationStates>::~TlvWrapper(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24D5EA4F8;
  v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::IpRegistrationStates>::~TlvWrapper(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24D5EA4F8;
  v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  JUMPOUT(0x2199FEAC4);
}

unint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::IpRegistrationStates>::getSize(uint64_t a1)
{
  return tlv::size<nas::tlv::IpRegistrationStates>((_QWORD *)(a1 + 16));
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<nas::tlv::IpRegistrationStates>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<nas::tlv::IpRegistrationStates>((_BYTE **)a2, (_DWORD *)(a1 + 16));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

_QWORD *qmi::MutableMessageBase::TlvWrapper<nas::tlv::IpRegistrationStates>::clone(uint64_t a1)
{
  uint64_t v2;
  _QWORD *v3;
  _BYTE *v4;
  _BYTE *v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;

  v2 = operator new();
  v3 = (_QWORD *)v2;
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)(v2 + 16) = 0;
  *(_QWORD *)v2 = &off_24D5EA4F8;
  *(_QWORD *)(v2 + 24) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  v5 = *(_BYTE **)(a1 + 16);
  v4 = *(_BYTE **)(a1 + 24);
  v6 = v4 - v5;
  if (v4 != v5)
  {
    if (v6 < 0)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v7 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>(v2 + 32, v6 >> 3);
    v3[2] = v7;
    v3[4] = &v7[8 * v8];
    memmove(v7, v5, v6 - 3);
    v3[3] = &v7[8 * (v6 >> 3)];
  }
  return v3;
}

void sub_216A804D0(_Unwind_Exception *a1)
{
  uint64_t v1;
  void **v2;
  void *v4;

  v4 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 24) = v4;
    operator delete(v4);
  }
  MEMORY[0x2199FEAC4](v1, 0x10A1C403082B835);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::IpRegistrationEndCause>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::IpRegistrationEndCause>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

_DWORD **qmi::MutableMessageBase::TlvWrapper<nas::tlv::IpRegistrationEndCause>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _DWORD *v4;
  uint64_t v5;
  _DWORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_DWORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::PktDataHandle>((_DWORD **)a2, (_DWORD *)(a1 + 12));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::IpRegistrationEndCause>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5EA548;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a1 + 12);
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::IpRegistrationRetryTimer>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::IpRegistrationRetryTimer>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

_DWORD **qmi::MutableMessageBase::TlvWrapper<nas::tlv::IpRegistrationRetryTimer>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _DWORD *v4;
  uint64_t v5;
  _DWORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_DWORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::PktDataHandle>((_DWORD **)a2, (_DWORD *)(a1 + 12));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::IpRegistrationRetryTimer>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5EA598;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a1 + 12);
  return result;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver15updateIMSStatusEN10subscriber7SimSlotE21RadioAccessTechnology8DataModeN5caulk10option_setIN2sd14ImsServiceTypeEjEEjE3__4EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  int v2;
  NSObject *v3;
  _DWORD v4[2];
  __int16 v5;
  uint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v2 = *(_DWORD *)(a2 + 4);
  if (v2)
  {
    v3 = ***(NSObject ****)(a1 + 32);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      v4[0] = 67109378;
      v4[1] = v2;
      v5 = 2080;
      v6 = qmi::asString();
      _os_log_impl(&dword_216897000, v3, OS_LOG_TYPE_DEFAULT, "#N Update IMS Status failed: Error in response with code %d (%s)", (uint8_t *)v4, 0x12u);
    }
  }
}

uint64_t __copy_helper_block_e8_32c180_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver15updateIMSStatusEN10subscriber7SimSlotE21RadioAccessTechnology8DataModeN5caulk10option_setIN2sd14ImsServiceTypeEjEEjE3__4EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c180_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver15updateIMSStatusEN10subscriber7SimSlotE21RadioAccessTechnology8DataModeN5caulk10option_setIN2sd14ImsServiceTypeEjEEjE3__4EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::updateIMSStatus(subscriber::SimSlot,RadioAccessTechnology,DataMode,caulk::option_set<sd::ImsServiceType,unsigned int>,unsigned int)::$_4,std::allocator<QMINetworkRegistrationDriver::updateIMSStatus(subscriber::SimSlot,RadioAccessTechnology,DataMode,caulk::option_set<sd::ImsServiceType,unsigned int>,unsigned int)::$_4>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5EA600;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::updateIMSStatus(subscriber::SimSlot,RadioAccessTechnology,DataMode,caulk::option_set<sd::ImsServiceType,unsigned int>,unsigned int)::$_4,std::allocator<QMINetworkRegistrationDriver::updateIMSStatus(subscriber::SimSlot,RadioAccessTechnology,DataMode,caulk::option_set<sd::ImsServiceType,unsigned int>,unsigned int)::$_4>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5EA600;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::SADisableStatus>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::SADisableStatus>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<nas::tlv::SADisableStatus>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::SADisableStatus>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5EA668;
  return result;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver22update5GStandaloneInfoEN10subscriber7SimSlotEbE3__1EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  int v2;
  NSObject *v3;
  _DWORD v4[2];
  __int16 v5;
  uint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v2 = *(_DWORD *)(a2 + 4);
  if (v2)
  {
    v3 = ***(NSObject ****)(a1 + 32);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      v4[0] = 67109378;
      v4[1] = v2;
      v5 = 2080;
      v6 = qmi::asString();
      _os_log_impl(&dword_216897000, v3, OS_LOG_TYPE_DEFAULT, "#N Update SA Info failed: Error in response with code %d (%s)", (uint8_t *)v4, 0x12u);
    }
  }
}

uint64_t __copy_helper_block_e8_32c111_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver22update5GStandaloneInfoEN10subscriber7SimSlotEbE3__1EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c111_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver22update5GStandaloneInfoEN10subscriber7SimSlotEbE3__1EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::update5GStandaloneInfo(subscriber::SimSlot,BOOL)::$_1,std::allocator<QMINetworkRegistrationDriver::update5GStandaloneInfo(subscriber::SimSlot,BOOL)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5EA6D0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::update5GStandaloneInfo(subscriber::SimSlot,BOOL)::$_1,std::allocator<QMINetworkRegistrationDriver::update5GStandaloneInfo(subscriber::SimSlot,BOOL)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5EA6D0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::ClosedSubscriberGroupID>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::ClosedSubscriberGroupID>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

_DWORD **qmi::MutableMessageBase::TlvWrapper<nas::tlv::ClosedSubscriberGroupID>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _DWORD *v4;
  uint64_t v5;
  _DWORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_DWORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::PktDataHandle>((_DWORD **)a2, (_DWORD *)(a1 + 12));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::ClosedSubscriberGroupID>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5EA738;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a1 + 12);
  return result;
}

void std::__shared_ptr_emplace<ctu::rest::command_responder_t<CSGSearchResponse>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5EA770;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<ctu::rest::command_responder_t<CSGSearchResponse>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5EA770;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void std::__shared_ptr_emplace<ctu::rest::command_responder_t<CSGSearchResponse>>::__on_zero_shared(uint64_t a1)
{
  void **v2;
  void *v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  void *v7;

  if (*(_QWORD *)(a1 + 64))
  {
    write_rest_value();
    v2 = *(void ***)(a1 + 64);
    v3 = *v2;
    *v2 = v7;
    xpc_release(v3);
  }
  v4 = *(std::__shared_weak_count **)(a1 + 72);
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  if (*(char *)(a1 + 55) < 0)
    operator delete(*(void **)(a1 + 32));
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver34triggerClosedSubscriberGroupSearchEN10subscriber7SimSlotENSt3__112basic_stringIcNS6_11char_traitsIcEENS6_9allocatorIcEEEEiNS6_8optionalI9MCCAndMNCEEON3ctu4rest19command_responder_tI17CSGSearchResponseEEE3__1EEOS1_OT__block_invoke(uint64_t a1, qmi::MessageBase *this)
{
  __int128 *v2;
  int v3;
  NSObject *v4;
  __int128 v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  uint64_t TlvValue;
  int v11;
  uint64_t v12;
  int v13;
  unsigned int v14;
  unsigned int v15;
  NSObject *v16;
  char v17;
  uint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  uint64_t v22;
  std::string buf;
  int v24;
  os_log_t *v25;
  uint64_t v26;
  std::__shared_weak_count *v27;
  uint8_t v28[4];
  unsigned int v29;
  uint64_t v30;

  v30 = *MEMORY[0x24BDAC8D0];
  v2 = *(__int128 **)(a1 + 32);
  v3 = *((_DWORD *)this + 1);
  if (v3)
  {
    v4 = **((_QWORD **)v2 + 6);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf.__r_.__value_.__l.__data_) = 67109378;
      HIDWORD(buf.__r_.__value_.__r.__words[0]) = v3;
      LOWORD(buf.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 2) = qmi::asString();
      _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#N Trigger closed subscriber group request failed: %d (%s)", (uint8_t *)&buf, 0x12u);
    }
  }
  else
  {
    if (*((char *)v2 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(&buf, *(const std::string::value_type **)v2, *((_QWORD *)v2 + 1));
    }
    else
    {
      v6 = *v2;
      buf.__r_.__value_.__r.__words[2] = *((_QWORD *)v2 + 2);
      *(_OWORD *)&buf.__r_.__value_.__l.__data_ = v6;
    }
    v24 = *((_DWORD *)v2 + 6);
    v25 = (os_log_t *)*((_QWORD *)v2 + 6);
    v26 = *((_QWORD *)v2 + 4);
    v7 = (std::__shared_weak_count *)*((_QWORD *)v2 + 5);
    v27 = v7;
    if (v7)
    {
      p_shared_owners = (unint64_t *)&v7->__shared_owners_;
      do
        v9 = __ldxr(p_shared_owners);
      while (__stxr(v9 + 1, p_shared_owners));
    }
    TlvValue = qmi::MessageBase::findTlvValue(this);
    v12 = TlvValue;
    if (TlvValue)
    {
      v13 = v11;
      v22 = TlvValue;
      v14 = tlv::parseV<nas::tlv::CnfReason>((unint64_t *)&v22, v11);
      if (v22)
      {
        v15 = v14;
        v16 = *v25;
        if (os_log_type_enabled(*v25, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)v28 = 67109120;
          v29 = v15;
          _os_log_impl(&dword_216897000, v16, OS_LOG_TYPE_DEFAULT, "#I Trigger closed subscriber group request succeeded (reason %d)", v28, 8u);
        }
        if (v15 >= 4)
          v17 = 0;
        else
          v17 = v15;
        v18 = v26;
        *(_BYTE *)v26 = v17;
        std::string::operator=((std::string *)(v18 + 8), &buf);
        *(_DWORD *)(v26 + 32) = v24;
      }
      else
      {
        ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)this, 161, v12, v13);
      }
    }
    v19 = v27;
    if (v27)
    {
      v20 = (unint64_t *)&v27->__shared_owners_;
      do
        v21 = __ldaxr(v20);
      while (__stlxr(v21 - 1, v20));
      if (!v21)
      {
        ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
        std::__shared_weak_count::__release_weak(v19);
      }
    }
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
      operator delete(buf.__r_.__value_.__l.__data_);
  }
}

void sub_216A80D90(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
  _Unwind_Resume(exception_object);
}

uint64_t __copy_helper_block_e8_32c260_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver34triggerClosedSubscriberGroupSearchEN10subscriber7SimSlotENS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEiNS_8optionalI9MCCAndMNCEEON3ctu4rest19command_responder_tI17CSGSearchResponseEEE3__1EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c260_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver34triggerClosedSubscriberGroupSearchEN10subscriber7SimSlotENS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEiNS_8optionalI9MCCAndMNCEEON3ctu4rest19command_responder_tI17CSGSearchResponseEEE3__1EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::triggerClosedSubscriberGroupSearch(subscriber::SimSlot,std::string,int,std::optional<MCCAndMNC>,ctu::rest::command_responder_t<CSGSearchResponse> &&)::$_1,std::allocator<ctu::rest::command_responder_t<CSGSearchResponse> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5EA7F0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::triggerClosedSubscriberGroupSearch(subscriber::SimSlot,std::string,int,std::optional<MCCAndMNC>,ctu::rest::command_responder_t<CSGSearchResponse> &&)::$_1,std::allocator<ctu::rest::command_responder_t<CSGSearchResponse> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5EA7F0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::triggerClosedSubscriberGroupSearch(subscriber::SimSlot,std::string,int,std::optional<MCCAndMNC>,ctu::rest::command_responder_t<CSGSearchResponse> &&)::$_1,std::allocator<ctu::rest::command_responder_t<CSGSearchResponse> &&>>::__on_zero_shared(uint64_t a1)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 56);
  if (*(char *)(a1 + 47) < 0)
    operator delete(*(void **)(a1 + 24));
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas28TriggerClosedSubscriberGroup8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A80F54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::UserReboot>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::UserReboot>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<nas::tlv::UserReboot>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::UserReboot>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5EA880;
  return result;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver35sendCommCenterStartsSincePowerCycleEjE3__1EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  int v2;
  NSObject *v3;
  _DWORD v4[2];
  __int16 v5;
  uint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v2 = *(_DWORD *)(a2 + 4);
  if (v2)
  {
    v3 = ***(NSObject ****)(a1 + 32);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      v4[0] = 67109378;
      v4[1] = v2;
      v5 = 2080;
      v6 = qmi::asString();
      _os_log_impl(&dword_216897000, v3, OS_LOG_TYPE_DEFAULT, "#N Sending system selection preference user reboot information failed: %d (%s)", (uint8_t *)v4, 0x12u);
    }
  }
}

uint64_t __copy_helper_block_e8_32c102_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver35sendCommCenterStartsSincePowerCycleEjE3__1EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c102_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver35sendCommCenterStartsSincePowerCycleEjE3__1EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::sendCommCenterStartsSincePowerCycle(unsigned int)::$_1,std::allocator<QMINetworkRegistrationDriver::sendCommCenterStartsSincePowerCycle(unsigned int)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5EA8E8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::sendCommCenterStartsSincePowerCycle(unsigned int)::$_1,std::allocator<QMINetworkRegistrationDriver::sendCommCenterStartsSincePowerCycle(unsigned int)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5EA8E8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas28SetSystemSelectionPreference8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke_0(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BYTE v3[24];

  v2 = *(_QWORD *)(a1 + 32);
  cast_message_type<nas::SetSystemSelectionPreference::Response const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_216A811C8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::Mcc>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::Mcc>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_PcoMcc>();
}

_WORD **qmi::MutableMessageBase::TlvWrapper<nas::tlv::Mcc>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _WORD *v4;
  uint64_t v5;
  _WORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_WORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::Profile3GPP_PcoMcc>((_WORD **)a2, (_WORD *)(a1 + 10));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::Mcc>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5EA978;
  *(_WORD *)(result + 10) = *(_WORD *)(a1 + 10);
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::Confidence>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::Confidence>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

_DWORD **qmi::MutableMessageBase::TlvWrapper<nas::tlv::Confidence>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _DWORD *v4;
  uint64_t v5;
  _DWORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_DWORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::PktDataHandle>((_DWORD **)a2, (_DWORD *)(a1 + 12));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::Confidence>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5EA9C8;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a1 + 12);
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::DetectionStatus>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::DetectionStatus>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

_DWORD **qmi::MutableMessageBase::TlvWrapper<nas::tlv::DetectionStatus>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _DWORD *v4;
  uint64_t v5;
  _DWORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_DWORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::PktDataHandle>((_DWORD **)a2, (_DWORD *)(a1 + 12));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::DetectionStatus>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5EAA18;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a1 + 12);
  return result;
}

_QWORD *qmi::MutableMessageBase::TlvWrapper<nas::tlv::BorderMcc>::~TlvWrapper(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24D5EAA68;
  v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::BorderMcc>::~TlvWrapper(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24D5EAA68;
  v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::BorderMcc>::getSize(uint64_t a1)
{
  return tlv::size<wds::tlv::NextHdrProtList>((_QWORD *)(a1 + 16));
}

void *qmi::MutableMessageBase::TlvWrapper<nas::tlv::BorderMcc>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  void *result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::DestPortList>((_BYTE **)a2, (_DWORD *)(a1 + 16));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::BorderMcc>::clone(uint64_t a1)
{
  uint64_t v2;

  v2 = operator new();
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)v2 = &off_24D5EAA68;
  *(_QWORD *)(v2 + 24) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 16) = 0;
  std::vector<unsigned short>::__init_with_size[abi:ne180100]<unsigned short *,unsigned short *>((_QWORD *)(v2 + 16), *(const void **)(a1 + 16), *(_QWORD *)(a1 + 24), (uint64_t)(*(_QWORD *)(a1 + 24) - *(_QWORD *)(a1 + 16)) >> 1);
  return v2;
}

void sub_216A81584(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199FEAC4](v1, 0x1091C40A3A4EB6ALL);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZZN28QMINetworkRegistrationDriver10setGeoMccsEN10subscriber7SimSlotERKNSt3__16vectorItNS6_9allocatorItEEEEENK3__0clINS_16SubscriptionTypeEEEDaT_EUlRKN3nas6SetMcc8ResponseEE_EEOS1_OSH__block_invoke(uint64_t a1, uint64_t a2)
{
  int v2;
  NSObject *v3;
  _DWORD v4[2];
  __int16 v5;
  uint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v2 = *(_DWORD *)(a2 + 4);
  if (v2)
  {
    v3 = ***(NSObject ****)(a1 + 32);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      v4[0] = 67109378;
      v4[1] = v2;
      v5 = 2080;
      v6 = qmi::asString();
      _os_log_impl(&dword_216897000, v3, OS_LOG_TYPE_DEFAULT, "#N Sending set mcc failed: %d (%s)", (uint8_t *)v4, 0x12u);
    }
  }
}

uint64_t __copy_helper_block_e8_32c196_ZTSNSt3__110shared_ptrIZZN28QMINetworkRegistrationDriver10setGeoMccsEN10subscriber7SimSlotERKNS_6vectorItNS_9allocatorItEEEEENK3__0clIN3qmi16SubscriptionTypeEEEDaT_EUlRKN3nas6SetMcc8ResponseEE_EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void __destroy_helper_block_e8_32c196_ZTSNSt3__110shared_ptrIZZN28QMINetworkRegistrationDriver10setGeoMccsEN10subscriber7SimSlotERKNS_6vectorItNS_9allocatorItEEEEENK3__0clIN3qmi16SubscriptionTypeEEEDaT_EUlRKN3nas6SetMcc8ResponseEE_EE(uint64_t a1)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v3;

  v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1)
  {
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      v3 = __ldaxr(p_shared_owners);
    while (__stlxr(v3 - 1, p_shared_owners));
    if (!v3)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

void _ZNSt3__120__shared_ptr_emplaceIZZN28QMINetworkRegistrationDriver10setGeoMccsEN10subscriber7SimSlotERKNS_6vectorItNS_9allocatorItEEEEENK3__0clIN3qmi16SubscriptionTypeEEEDaT_EUlRKN3nas6SetMcc8ResponseEE_NS5_ISL_EEED1Ev(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5EAAD0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void _ZNSt3__120__shared_ptr_emplaceIZZN28QMINetworkRegistrationDriver10setGeoMccsEN10subscriber7SimSlotERKNS_6vectorItNS_9allocatorItEEEEENK3__0clIN3qmi16SubscriptionTypeEEEDaT_EUlRKN3nas6SetMcc8ResponseEE_NS5_ISL_EEED0Ev(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5EAAD0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas6SetMcc8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A817E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::RegistrationOverSatPlmnsStatus>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::RegistrationOverSatPlmnsStatus>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<nas::tlv::RegistrationOverSatPlmnsStatus>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::RegistrationOverSatPlmnsStatus>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5EAB60;
  return result;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver24setSatelliteSystemConfigEN10subscriber7SimSlotERK21SatelliteSystemConfigE3__1EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  int v2;
  NSObject *v3;
  _DWORD v4[2];
  __int16 v5;
  uint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v2 = *(_DWORD *)(a2 + 4);
  v3 = ***(NSObject ****)(a1 + 32);
  if (v2)
  {
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      v4[0] = 67109378;
      v4[1] = v2;
      v5 = 2080;
      v6 = qmi::asString();
      _os_log_error_impl(&dword_216897000, v3, OS_LOG_TYPE_ERROR, "Set satellite system config failed: %d (%s)", (uint8_t *)v4, 0x12u);
    }
  }
  else if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v4[0]) = 0;
    _os_log_impl(&dword_216897000, v3, OS_LOG_TYPE_DEFAULT, "#I Set satellite system config successful", (uint8_t *)v4, 2u);
  }
}

uint64_t __copy_helper_block_e8_32c137_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver24setSatelliteSystemConfigEN10subscriber7SimSlotERK21SatelliteSystemConfigE3__1EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c137_ZTSNSt3__110shared_ptrIZN28QMINetworkRegistrationDriver24setSatelliteSystemConfigEN10subscriber7SimSlotERK21SatelliteSystemConfigE3__1EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::setSatelliteSystemConfig(subscriber::SimSlot,SatelliteSystemConfig const&)::$_1,std::allocator<QMINetworkRegistrationDriver::setSatelliteSystemConfig(subscriber::SimSlot,SatelliteSystemConfig const&)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5EABC8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMINetworkRegistrationDriver::setSatelliteSystemConfig(subscriber::SimSlot,SatelliteSystemConfig const&)::$_1,std::allocator<QMINetworkRegistrationDriver::setSatelliteSystemConfig(subscriber::SimSlot,SatelliteSystemConfig const&)::$_1>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5EABC8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas24SetSatelliteSystemConfig8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A81B00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<NetworkRegistrationDriver>::execute_wrapped<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0>(QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0,std::default_delete<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0>>)::{lambda(void *)#1}::__invoke(_QWORD **a1)
{
  _QWORD *v1;
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  uint64_t (***v10)();
  uint64_t v11;
  uint64_t (***v12)();
  uint64_t v13;
  uint64_t (***v14)();
  uint64_t v15;
  uint64_t (***v16)();
  uint64_t v17;
  uint64_t (***v18)();
  uint64_t v19;
  uint64_t (***v20)();
  uint64_t v21;
  uint64_t (***v22)();
  uint64_t v23;
  uint64_t (***v24)();
  uint64_t v25;
  uint64_t (***v26)();
  uint64_t v27;
  uint64_t (***v28)();
  uint64_t v29;
  uint64_t (***v30)();
  uint64_t v31;
  capabilities::ct *v32;
  uint64_t v33;
  uint64_t (***v34)();
  uint64_t v35;
  _QWORD *v36;
  uint64_t v37;
  capabilities::ct *v38;
  uint64_t v39;
  uint64_t (***v40)();
  uint64_t v41;
  _QWORD **v43;
  _QWORD *v44;
  _QWORD v45[3];
  capabilities::ct *v46;
  _QWORD v47[3];
  _QWORD *v48;
  uint64_t (**v49)();
  _QWORD *v50;
  uint64_t (***v51)();
  uint64_t v52;

  v52 = *MEMORY[0x24BDAC8D0];
  v1 = *a1;
  v43 = a1;
  v44 = v1;
  v2 = (_QWORD *)*v1;
  v4 = v1[2];
  v3 = v1[3];
  if (v3)
  {
    v5 = (unint64_t *)(v3 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  v7 = (std::__shared_weak_count *)v2[9];
  v2[8] = v4;
  v2[9] = v3;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  v49 = &off_24D5EAC40;
  v50 = v2;
  v51 = &v49;
  qmi::ClientRouter::setIndHandlerInternal();
  v10 = v51;
  if (v51 == &v49)
  {
    v11 = 4;
    v10 = &v49;
  }
  else
  {
    if (!v51)
      goto LABEL_14;
    v11 = 5;
  }
  (*v10)[v11]();
LABEL_14:
  v49 = &off_24D5EACC0;
  v50 = v2;
  v51 = &v49;
  qmi::ClientRouter::setIndHandlerInternal();
  v12 = v51;
  if (v51 == &v49)
  {
    v13 = 4;
    v12 = &v49;
  }
  else
  {
    if (!v51)
      goto LABEL_19;
    v13 = 5;
  }
  (*v12)[v13]();
LABEL_19:
  v49 = &off_24D5EAD40;
  v50 = v2;
  v51 = &v49;
  qmi::ClientRouter::setIndHandlerInternal();
  v14 = v51;
  if (v51 == &v49)
  {
    v15 = 4;
    v14 = &v49;
  }
  else
  {
    if (!v51)
      goto LABEL_24;
    v15 = 5;
  }
  (*v14)[v15]();
LABEL_24:
  v49 = &off_24D5EADC0;
  v50 = v2;
  v51 = &v49;
  qmi::ClientRouter::setIndHandlerInternal();
  v16 = v51;
  if (v51 == &v49)
  {
    v17 = 4;
    v16 = &v49;
  }
  else
  {
    if (!v51)
      goto LABEL_29;
    v17 = 5;
  }
  (*v16)[v17]();
LABEL_29:
  qmi::ClientRouter::setIndShouldWake((qmi::ClientRouter *)(v2 + 13));
  v49 = &off_24D5EAE40;
  v50 = v2;
  v51 = &v49;
  qmi::ClientRouter::setIndHandlerInternal();
  v18 = v51;
  if (v51 == &v49)
  {
    v19 = 4;
    v18 = &v49;
  }
  else
  {
    if (!v51)
      goto LABEL_34;
    v19 = 5;
  }
  (*v18)[v19]();
LABEL_34:
  v49 = &off_24D5EAEC0;
  v50 = v2;
  v51 = &v49;
  qmi::ClientRouter::setIndHandlerInternal();
  v20 = v51;
  if (v51 == &v49)
  {
    v21 = 4;
    v20 = &v49;
  }
  else
  {
    if (!v51)
      goto LABEL_39;
    v21 = 5;
  }
  (*v20)[v21]();
LABEL_39:
  v49 = &off_24D5EAF40;
  v50 = v2;
  v51 = &v49;
  qmi::ClientRouter::setIndHandlerInternal();
  v22 = v51;
  if (v51 == &v49)
  {
    v23 = 4;
    v22 = &v49;
  }
  else
  {
    if (!v51)
      goto LABEL_44;
    v23 = 5;
  }
  (*v22)[v23]();
LABEL_44:
  qmi::ClientRouter::setIndShouldWake((qmi::ClientRouter *)(v2 + 13));
  v49 = &off_24D5EAFC0;
  v50 = v2;
  v51 = &v49;
  qmi::ClientRouter::setIndHandlerInternal();
  v24 = v51;
  if (v51 == &v49)
  {
    v25 = 4;
    v24 = &v49;
  }
  else
  {
    if (!v51)
      goto LABEL_49;
    v25 = 5;
  }
  (*v24)[v25]();
LABEL_49:
  v49 = &off_24D5EB040;
  v50 = v2;
  v51 = &v49;
  qmi::ClientRouter::setIndHandlerInternal();
  v26 = v51;
  if (v51 == &v49)
  {
    v27 = 4;
    v26 = &v49;
  }
  else
  {
    if (!v51)
      goto LABEL_54;
    v27 = 5;
  }
  (*v26)[v27]();
LABEL_54:
  v49 = &off_24D5EB0C0;
  v50 = v2;
  v51 = &v49;
  qmi::ClientRouter::setIndHandlerInternal();
  v28 = v51;
  if (v51 == &v49)
  {
    v29 = 4;
    v28 = &v49;
  }
  else
  {
    if (!v51)
      goto LABEL_59;
    v29 = 5;
  }
  (*v28)[v29]();
LABEL_59:
  qmi::ClientRouter::setIndShouldWake((qmi::ClientRouter *)(v2 + 13));
  v49 = &off_24D5EB140;
  v50 = v2;
  v51 = &v49;
  qmi::ClientRouter::setIndHandlerInternal();
  v30 = v51;
  if (v51 == &v49)
  {
    v31 = 4;
    v30 = &v49;
  }
  else
  {
    if (!v51)
      goto LABEL_64;
    v31 = 5;
  }
  (*v30)[v31]();
LABEL_64:
  v49 = &off_24D5EB1C0;
  v50 = v2;
  v51 = &v49;
  qmi::ClientRouter::setIndHandlerInternal();
  v32 = (capabilities::ct *)v51;
  if (v51 == &v49)
  {
    v33 = 4;
    v32 = (capabilities::ct *)&v49;
  }
  else
  {
    if (!v51)
      goto LABEL_69;
    v33 = 5;
  }
  v32 = (capabilities::ct *)(*(uint64_t (**)(void))(*(_QWORD *)v32 + 8 * v33))();
LABEL_69:
  if (!capabilities::ct::supportsPrivateNetwork(v32))
    goto LABEL_75;
  v49 = &off_24D5EB240;
  v50 = v2;
  v51 = &v49;
  qmi::ClientRouter::setIndHandlerInternal();
  v34 = v51;
  if (v51 == &v49)
  {
    v35 = 4;
    v34 = &v49;
  }
  else
  {
    if (!v51)
      goto LABEL_75;
    v35 = 5;
  }
  (*v34)[v35]();
LABEL_75:
  v47[0] = &off_24D5EB2C0;
  v47[1] = v2;
  v48 = v47;
  qmi::ClientRouter::setHandler();
  v36 = v48;
  if (v48 == v47)
  {
    v37 = 4;
    v36 = v47;
  }
  else
  {
    if (!v48)
      goto LABEL_80;
    v37 = 5;
  }
  (*(void (**)(void))(*v36 + 8 * v37))();
LABEL_80:
  v45[0] = &off_24D5EB340;
  v45[1] = v2;
  v46 = (capabilities::ct *)v45;
  qmi::ClientRouter::setHandler();
  v38 = v46;
  if (v46 == (capabilities::ct *)v45)
  {
    v39 = 4;
    v38 = (capabilities::ct *)v45;
  }
  else
  {
    if (!v46)
      goto LABEL_85;
    v39 = 5;
  }
  v38 = (capabilities::ct *)(*(uint64_t (**)(void))(*(_QWORD *)v38 + 8 * v39))();
LABEL_85:
  if (capabilities::ct::supportsPrivateNetwork(v38))
  {
    v49 = &off_24D5EB3C0;
    v50 = v2;
    v51 = &v49;
    qmi::ClientRouter::setIndHandlerInternal();
    v40 = v51;
    if (v51 == &v49)
    {
      v41 = 4;
      v40 = &v49;
      goto LABEL_90;
    }
    if (v51)
    {
      v41 = 5;
LABEL_90:
      (*v40)[v41]();
    }
  }
  std::unique_ptr<QMIEnhancedLQMCommandDriver::bootstrap(dispatch::group_session,std::shared_ptr<EnhancedLQMCommandDriverDelegateInterface>)::$_0,std::default_delete<QMIEnhancedLQMCommandDriver::bootstrap(dispatch::group_session,std::shared_ptr<EnhancedLQMCommandDriverDelegateInterface>)::$_0>>::~unique_ptr[abi:ne180100]((uint64_t *)&v44);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v43);
}

void sub_216A8211C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  _QWORD *v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  va_list va;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v7 = va_arg(va1, _QWORD);
  v5 = *(_QWORD **)(v3 - 48);
  if (v5 == v2)
  {
    v6 = 4;
    v5 = (_QWORD *)(v3 - 72);
  }
  else
  {
    if (!v5)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  std::unique_ptr<QMIEnhancedLQMCommandDriver::bootstrap(dispatch::group_session,std::shared_ptr<EnhancedLQMCommandDriverDelegateInterface>)::$_0,std::default_delete<QMIEnhancedLQMCommandDriver::bootstrap(dispatch::group_session,std::shared_ptr<EnhancedLQMCommandDriverDelegateInterface>)::$_0>>::~unique_ptr[abi:ne180100]((uint64_t *)va1);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NetworkReject::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NetworkReject::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NetworkReject::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NetworkReject::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5EAC40;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NetworkReject::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NetworkReject::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5EAC40;
  a2[1] = v2;
  return result;
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NetworkReject::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NetworkReject::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::operator()(uint64_t a1, unsigned int *a2, QMIServiceMsg *this)
{
  unsigned int v4;
  uint64_t v6;
  void *TlvValue;
  int v8;
  void *v9;
  int v10;
  unsigned __int8 v11;
  void *v12;
  int v13;
  void *v14;
  int v15;
  char v16;
  char v17;
  uint64_t v18;
  void *v19;
  int v20;
  void *v21;
  int v22;
  unsigned __int8 v23;
  uint64_t v24;
  uint64_t v25;
  _WORD v26[12];
  void *__p;
  void *v28;
  uint64_t v29;

  v4 = *a2;
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v28 = 0;
    v29 = 0;
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v26, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v26);
    if (__p)
    {
      v28 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v26);
  }
  v6 = *(_QWORD *)(a1 + 8);
  TlvValue = (void *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)v26);
  v9 = TlvValue;
  if (TlvValue)
  {
    v10 = v8;
    __p = TlvValue;
    v11 = tlv::parseV<nas::tlv::RejCause>((unint64_t *)&__p, v8);
    if (__p)
      goto LABEL_12;
    ((void (*)(_QWORD, uint64_t, void *, _QWORD))*MEMORY[0x24BED8BD0])(v26[0], 3, v9, v10);
  }
  v11 = 0;
LABEL_12:
  v12 = (void *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)v26);
  v14 = v12;
  if (v12)
  {
    v15 = v13;
    __p = v12;
    v16 = tlv::parseV<nas::tlv::RadioIf>((unint64_t *)&__p, v13);
    if (__p)
    {
      v17 = v16 - 4;
      if ((v16 - 4) <= 5u && ((0x33u >> v17) & 1) != 0)
      {
        v18 = dword_216AC1078[v17];
        goto LABEL_19;
      }
    }
    else
    {
      ((void (*)(_QWORD, uint64_t, void *, _QWORD))*MEMORY[0x24BED8BD0])(v26[0], 1, v14, v15);
    }
  }
  v18 = 11;
LABEL_19:
  v19 = (void *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)v26);
  v21 = v19;
  if (v19)
  {
    v22 = v20;
    __p = v19;
    v23 = tlv::parseV<nas::tlv::ServiceDomain>((unint64_t *)&__p, v20);
    if (__p)
    {
      v24 = v23;
      goto LABEL_24;
    }
    ((void (*)(_QWORD, uint64_t, void *, _QWORD))*MEMORY[0x24BED8BD0])(v26[0], 2, v21, v22);
  }
  v24 = 0;
LABEL_24:
  if (v4 - 1 >= 3)
    v25 = 0;
  else
    v25 = v4;
  (*(void (**)(_QWORD, uint64_t, uint64_t, _QWORD, uint64_t))(**(_QWORD **)(v6 + 64) + 32))(*(_QWORD *)(v6 + 64), v25, v24, v11, v18);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v26);
}

void sub_216A82464(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NetworkReject::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NetworkReject::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NetworkReject::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NetworkReject::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::target_type()
{
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SysInfo::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SysInfo::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SysInfo::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SysInfo::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5EACC0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SysInfo::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SysInfo::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5EACC0;
  a2[1] = v2;
  return result;
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SysInfo::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SysInfo::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::operator()(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  NSObject *v7;
  unint64_t *v8;
  unint64_t v9;
  capabilities::ct *v10;
  char v11;
  int v12;
  int v13;
  char v14;
  char v15;
  uint64_t v16;
  BOOL v17;
  unint64_t v18;
  void *v19;
  unsigned int v20;
  _QWORD v21[2];
  uint64_t v22;
  _QWORD v23[3];
  unint64_t v24[2];
  uint8_t buf[2];
  _BYTE v26[3];
  _BYTE v27[3];
  char v28;
  _BYTE v29[3];
  char v30;
  _BYTE v31[3];
  char v32;
  _BYTE v33[3];
  char v34;
  _BYTE v35[3];
  char v36;
  char v37;
  __int128 v38;
  _OWORD v39[2];
  char v40;
  _BYTE v41[31];
  _BYTE v42[17];
  __int128 v43;
  int v44;
  char v45;
  __int128 v46;
  _BYTE v47[24];
  char v48;
  __int128 v49;
  __int128 v50;
  int v51;
  char v52;
  _BYTE v53[40];
  void *v54;
  void *v55;
  char v56;
  __int128 v57;
  __int128 v58;
  int v59;
  char v60;
  int v61;
  char v62;
  __int16 v63;
  char v64;
  uint64_t v65;
  char v66;
  uint64_t v67;
  char v68;
  __int16 v69;
  char v70;
  __int16 v71;
  int v72;
  char v73;
  __int16 v74;
  __int16 v75;
  char v76;
  int v77;
  char v78;
  int v79;
  char v80;
  int v81;
  int v82;
  void *__p;
  void *v84;
  uint64_t v85;
  char v86;
  uint64_t v87;
  char v88;
  _BYTE v89[9];
  __int16 v90;
  char v91;
  uint64_t v92;
  char v93;
  _DWORD v94[3];
  uint64_t v95;
  char v96;
  _OWORD v97[4];
  uint64_t v98;
  uint64_t v99;

  v99 = *MEMORY[0x24BDAC8D0];
  v4 = *a2;
  cast_message_type<nas::SysInfo::Indication const&>::cast(a3, (qmi::MessageBase *)v21);
  v5 = *(_QWORD *)(a1 + 8);
  if (v4 - 1 >= 3)
    v6 = 0;
  else
    v6 = v4;
  v7 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v5 + 88) + 16))(*(_QWORD *)(v5 + 88), v6);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_216897000, v7, OS_LOG_TYPE_DEFAULT, "#I Received sys info update from baseband", buf, 2u);
  }
  v23[0] = v21[0];
  v23[1] = v21[1];
  v23[2] = v22;
  if (v22)
  {
    v8 = (unint64_t *)(v22 + 8);
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  bzero(buf, 0x218uLL);
  v11 = capabilities::ct::supportsDataQMIExtensions(v10);
  buf[0] = 0;
  *(_WORD *)v26 = 0;
  *(_WORD *)v27 = 0;
  *(_WORD *)v29 = 0;
  *(_WORD *)v31 = 0;
  *(_WORD *)v33 = 0;
  *(_WORD *)v35 = 0;
  v37 = 0;
  LOBYTE(v38) = 0;
  v40 = 0;
  v41[0] = 0;
  *(_WORD *)v42 = 0;
  v45 = 0;
  LOBYTE(v46) = 0;
  v48 = 0;
  LOBYTE(v49) = 0;
  v52 = 0;
  v53[0] = 0;
  v56 = 0;
  LOBYTE(v57) = 0;
  v60 = 0;
  LOBYTE(v61) = 0;
  v62 = 0;
  LOBYTE(v63) = 0;
  v64 = 0;
  LOBYTE(v65) = 0;
  v66 = 0;
  LOBYTE(v67) = 0;
  v68 = 0;
  LOBYTE(v69) = 0;
  v70 = 0;
  v71 = 0;
  LOBYTE(v72) = 0;
  v73 = 0;
  v74 = 0;
  LOBYTE(v75) = 0;
  v76 = 0;
  LOBYTE(v77) = 0;
  v78 = 0;
  LOBYTE(v79) = 0;
  v80 = 0;
  v86 = 0;
  *(_WORD *)v89 = 0;
  v90 = 0;
  v91 = 0;
  LOBYTE(v92) = 0;
  v93 = 0;
  LOBYTE(v82) = 0;
  v81 = 0;
  *(_DWORD *)((char *)&v87 + 3) = 0;
  LODWORD(v87) = 0;
  memset(v94, 0, 7);
  v95 = v5 + 40;
  v96 = 1;
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v23))
  {
    BYTE2(v97[0]) = 0;
    LOWORD(v97[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::CDMAServiceStatus>((qmi::MessageBase *)v23, (uint64_t)v97);
    if (!LOBYTE(v97[0]))
      goto LABEL_228;
    if (!v26[0])
      v26[0] = 1;
    *(_WORD *)buf = *(_WORD *)((char *)v97 + 1);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v23))
  {
    BYTE2(v97[0]) = 0;
    LOWORD(v97[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::HDRServiceStatus>((qmi::MessageBase *)v23, (uint64_t)v97);
    if (!LOBYTE(v97[0]))
      goto LABEL_228;
    if (!v27[0])
      v27[0] = 1;
    *(_WORD *)&v26[1] = *(_WORD *)((char *)v97 + 1);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v23))
  {
    LODWORD(v97[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::GSMServiceStatus>((qmi::MessageBase *)v23, (unsigned __int8 *)v97);
    if (!LOBYTE(v97[0]))
      goto LABEL_228;
    *(_WORD *)&v27[1] = *(_WORD *)((char *)v97 + 1);
    v28 = BYTE3(v97[0]);
    if (!v29[0])
      v29[0] = 1;
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v23))
  {
    LODWORD(v97[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::WCDMAServiceStatus>((qmi::MessageBase *)v23, (unsigned __int8 *)v97);
    if (!LOBYTE(v97[0]))
      goto LABEL_228;
    *(_WORD *)&v29[1] = *(_WORD *)((char *)v97 + 1);
    v30 = BYTE3(v97[0]);
    if (!v31[0])
      v31[0] = 1;
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v23))
  {
    LODWORD(v97[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::LTEServiceStatus>((qmi::MessageBase *)v23, (unsigned __int8 *)v97);
    if (!LOBYTE(v97[0]))
      goto LABEL_228;
    *(_WORD *)&v31[1] = *(_WORD *)((char *)v97 + 1);
    v32 = BYTE3(v97[0]);
    if (!v33[0])
      v33[0] = 1;
    goto LABEL_32;
  }
  if (v33[0])
  {
LABEL_32:
    v12 = v31[1];
    goto LABEL_33;
  }
  v12 = 0;
LABEL_33:
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v23))
  {
    LODWORD(v97[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::NR5GServiceStatus>((qmi::MessageBase *)v23, 76, (unsigned __int8 *)v97);
    if (!LOBYTE(v97[0]))
      goto LABEL_228;
    *(_WORD *)&v35[1] = *(_WORD *)((char *)v97 + 1);
    v36 = BYTE3(v97[0]);
    if (!v37)
      v37 = 1;
    goto LABEL_38;
  }
  if (v37)
  {
LABEL_38:
    v13 = v35[1];
    goto LABEL_39;
  }
  v13 = 0;
LABEL_39:
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v23))
  {
    LODWORD(v97[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::TDSCDMAServiceStatus>((qmi::MessageBase *)v23, 37, (unsigned __int8 *)v97);
    if (!LOBYTE(v97[0]))
      goto LABEL_228;
    *(_WORD *)&v33[1] = *(_WORD *)((char *)v97 + 1);
    v34 = BYTE3(v97[0]);
    if (!v35[0])
      v35[0] = 1;
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v23))
  {
    memset(v97, 0, 52);
    qmi::MessageBase::tryTlv<nas::tlv::CDMASysInfo>((qmi::MessageBase *)v23, (uint64_t)v97);
    if (!LOBYTE(v97[0]))
      goto LABEL_228;
    v38 = *(_OWORD *)((char *)v97 + 4);
    v39[0] = *(_OWORD *)((char *)&v97[1] + 4);
    if (v40)
    {
      *(_OWORD *)((char *)v39 + 15) = *(_OWORD *)((char *)&v97[2] + 3);
    }
    else
    {
      v39[1] = *(_OWORD *)((char *)&v97[2] + 4);
      v40 = 1;
    }
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v23))
  {
    memset(v97, 0, 32);
    qmi::MessageBase::tryTlv<nas::tlv::HDRSysInfo>((qmi::MessageBase *)v23, (unsigned __int8 *)v97);
    if (!LOBYTE(v97[0]))
      goto LABEL_228;
    *(_OWORD *)v41 = *(_OWORD *)((char *)v97 + 1);
    *(_OWORD *)&v41[15] = v97[1];
    if (!v42[0])
      v42[0] = 1;
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v23))
  {
    memset(v97, 0, 40);
    qmi::MessageBase::tryTlv<nas::tlv::GSMSysInfo>((qmi::MessageBase *)v23, (uint64_t)v97);
    if (!LOBYTE(v97[0]))
      goto LABEL_228;
    *(_OWORD *)&v42[1] = *(_OWORD *)((char *)v97 + 4);
    v43 = *(_OWORD *)((char *)&v97[1] + 4);
    if (v45)
    {
      LOWORD(v44) = WORD2(v97[2]);
    }
    else
    {
      v44 = DWORD1(v97[2]);
      v45 = 1;
    }
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v23))
  {
    memset(v97, 0, 44);
    qmi::MessageBase::tryTlv<nas::tlv::WCDMASysInfo>((qmi::MessageBase *)v23, (uint64_t)v97);
    if (!LOBYTE(v97[0]))
      goto LABEL_228;
    v46 = *(_OWORD *)((char *)v97 + 4);
    *(_OWORD *)v47 = *(_OWORD *)((char *)&v97[1] + 4);
    if (v48)
    {
      *(_QWORD *)&v47[14] = *(_QWORD *)((char *)&v97[2] + 2);
    }
    else
    {
      *(_QWORD *)&v47[16] = *(_QWORD *)((char *)&v97[2] + 4);
      v48 = 1;
    }
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v23))
  {
    memset(v97, 0, 40);
    qmi::MessageBase::tryTlv<nas::tlv::LTESysInfo>((qmi::MessageBase *)v23, (uint64_t)v97);
    if (!LOBYTE(v97[0]))
      goto LABEL_228;
    v49 = *(_OWORD *)((char *)v97 + 4);
    v50 = *(_OWORD *)((char *)&v97[1] + 4);
    if (v52)
    {
      LOWORD(v51) = WORD2(v97[2]);
    }
    else
    {
      v51 = DWORD1(v97[2]);
      v52 = 1;
    }
    if (v12 == 2)
      v14 = v11;
    else
      v14 = 0;
    if (!(_BYTE)v49)
      v14 = 0;
    if (BYTE1(v49) != 4)
      v14 = 0;
    BYTE2(v94[1]) = v14;
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v23))
  {
    memset(v97, 0, 40);
    qmi::MessageBase::tryTlv<nas::tlv::NR5GSysInfo>((qmi::MessageBase *)v23, 77, (uint64_t)v97);
    if (!LOBYTE(v97[0]))
      goto LABEL_228;
    v57 = *(_OWORD *)((char *)v97 + 4);
    v58 = *(_OWORD *)((char *)&v97[1] + 4);
    if (v60)
    {
      LOWORD(v59) = WORD2(v97[2]);
    }
    else
    {
      v59 = DWORD1(v97[2]);
      v60 = 1;
    }
    if (v13 == 2)
      v15 = v11;
    else
      v15 = 0;
    if (!(_BYTE)v57)
      v15 = 0;
    if (BYTE1(v57) != 4)
      v15 = 0;
    BYTE2(v94[1]) = v15;
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v23))
  {
    v98 = 0;
    memset(v97, 0, sizeof(v97));
    qmi::MessageBase::tryTlv<nas::tlv::TDSCDMASysInfo>((qmi::MessageBase *)v23, 38, (unsigned __int8 *)v97);
    if (!LOBYTE(v97[0]))
      __assert_rtn("get", "optional.hpp", 1212, "this->is_initialized()");
    std::optional<nas::tlv::TDSCDMASysInfo>::operator=[abi:ne180100]<nas::tlv::TDSCDMASysInfo&,void>((uint64_t)v53, (uint64_t)v97 + 8);
    if (LOBYTE(v97[0]) && *(_QWORD *)&v97[3])
    {
      *((_QWORD *)&v97[3] + 1) = *(_QWORD *)&v97[3];
      operator delete(*(void **)&v97[3]);
    }
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v23))
  {
    WORD2(v97[0]) = 0;
    LODWORD(v97[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::CDMASysInfoEx>((qmi::MessageBase *)v23, (uint64_t)v97);
    if (!LOBYTE(v97[0]))
      goto LABEL_228;
    if (!v62)
      v62 = 1;
    v61 = *(_DWORD *)((char *)v97 + 2);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v23))
  {
    LODWORD(v97[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::HDRSysInfoEx>((qmi::MessageBase *)v23, (uint64_t)v97);
    if (!LOBYTE(v97[0]))
      goto LABEL_228;
    if (!v64)
      v64 = 1;
    v63 = WORD1(v97[0]);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v23))
  {
    DWORD2(v97[0]) = 0;
    *(_QWORD *)&v97[0] = 0;
    qmi::MessageBase::tryTlv<nas::tlv::GSMSysInfoEx>((qmi::MessageBase *)v23, (uint64_t)v97);
    if (!LOBYTE(v97[0]))
      goto LABEL_228;
    if (!v66)
      v66 = 1;
    v65 = *(_QWORD *)((char *)v97 + 4);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v23))
  {
    DWORD2(v97[0]) = 0;
    *(_QWORD *)&v97[0] = 0;
    qmi::MessageBase::tryTlv<nas::tlv::WCDMASysInfoEx>((qmi::MessageBase *)v23, (uint64_t)v97);
    if (!LOBYTE(v97[0]))
      goto LABEL_228;
    if (!v68)
      v68 = 1;
    v67 = *(_QWORD *)((char *)v97 + 4);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v23))
  {
    LODWORD(v97[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::LTESysInfoEx>((qmi::MessageBase *)v23, (uint64_t)v97);
    if (!LOBYTE(v97[0]))
      goto LABEL_228;
    if (!v70)
      v70 = 1;
    v69 = WORD1(v97[0]);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v23))
  {
    LODWORD(v97[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::NR5GTAC>((qmi::MessageBase *)v23, 82, (unsigned __int8 *)v97);
    if (!LOBYTE(v97[0]))
      goto LABEL_228;
    HIWORD(v87) = *(_WORD *)((char *)v97 + 1);
    v88 = BYTE3(v97[0]);
    if (!v89[0])
      v89[0] = 1;
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v23))
  {
    BYTE8(v97[0]) = 0;
    *(_QWORD *)&v97[0] = 0;
    qmi::MessageBase::tryTlv<nas::tlv::NR5GCellID>((qmi::MessageBase *)v23, 96, (uint64_t)v97);
    if (!LOBYTE(v97[0]))
      goto LABEL_228;
    if (!(_BYTE)v90)
      LOBYTE(v90) = 1;
    *(_QWORD *)&v89[1] = *(_QWORD *)((char *)v97 + 1);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v23))
  {
    LOWORD(v97[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::NR5GServiceAreaRestrictionInfo>((qmi::MessageBase *)v23, 83, v97);
    if (!LOBYTE(v97[0]))
      goto LABEL_228;
    if (!v91)
      v91 = 1;
    HIBYTE(v90) = BYTE1(v97[0]);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v23))
  {
    DWORD2(v97[0]) = 0;
    *(_QWORD *)&v97[0] = 0;
    qmi::MessageBase::tryTlv<nas::tlv::NR5GEmergencyServiceInfo>((qmi::MessageBase *)v23, 92, (uint64_t)v97);
    if (!LOBYTE(v97[0]))
      goto LABEL_228;
    if (!v93)
      v93 = 1;
    v92 = *(_QWORD *)((char *)v97 + 4);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v23))
  {
    LOWORD(v97[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::NR5GVoiceSupportInfo>((qmi::MessageBase *)v23, 90, v97);
    if (!LOBYTE(v97[0]))
      goto LABEL_228;
    if (!BYTE1(v94[0]))
      BYTE1(v94[0]) = 1;
    LOBYTE(v94[0]) = BYTE1(v97[0]);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v23))
  {
    *(_QWORD *)&v97[0] = 0;
    qmi::MessageBase::tryTlv<nas::tlv::LteEmergencyBearerSupport>((qmi::MessageBase *)v23, 58, (uint64_t)v97);
    if (!LOBYTE(v97[0]))
      goto LABEL_228;
    if (!v78)
      v78 = 1;
    v77 = DWORD1(v97[0]);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v23))
  {
    *(_QWORD *)&v97[0] = 0;
    qmi::MessageBase::tryTlv<nas::tlv::LteEmergencyAccessBarred>((qmi::MessageBase *)v23, 63, (uint64_t)v97);
    if (!LOBYTE(v97[0]))
      goto LABEL_228;
    if (!v80)
      v80 = 1;
    v79 = DWORD1(v97[0]);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v23))
  {
    LOWORD(v97[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::HDRSubnetMaskLength>((qmi::MessageBase *)v23, 70, v97);
    if (!LOBYTE(v97[0]))
      goto LABEL_228;
    if (!BYTE1(v81))
      BYTE1(v81) = 1;
    LOBYTE(v81) = BYTE1(v97[0]);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v23))
  {
    LOWORD(v97[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::GSMCipherDomainSysInfo>((qmi::MessageBase *)v23, v97);
    if (!LOBYTE(v97[0]))
      goto LABEL_228;
    if (!HIBYTE(v94[0]))
      HIBYTE(v94[0]) = 1;
    BYTE2(v94[0]) = BYTE1(v97[0]);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v23))
  {
    LOWORD(v97[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::WCDMACipherDomainSysInfo>((qmi::MessageBase *)v23, v97);
    if (!LOBYTE(v97[0]))
      goto LABEL_228;
    if (!BYTE1(v94[1]))
      BYTE1(v94[1]) = 1;
    LOBYTE(v94[1]) = BYTE1(v97[0]);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v23))
  {
    LOWORD(v97[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::LTEVoiceSupportSysInfo>((qmi::MessageBase *)v23, v97);
    if (!LOBYTE(v97[0]))
      goto LABEL_228;
    if (!HIBYTE(v71))
      HIBYTE(v71) = 1;
    LOBYTE(v71) = BYTE1(v97[0]);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v23))
  {
    *(_QWORD *)&v97[0] = 0;
    qmi::MessageBase::tryTlv<nas::tlv::SimRejectInfo>((qmi::MessageBase *)v23, 40, (uint64_t)v97);
    if (!LOBYTE(v97[0]))
      goto LABEL_228;
    if (!v73)
      v73 = 1;
    v72 = DWORD1(v97[0]);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v23))
  {
    LODWORD(v97[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::CDMADerivedMCC>((qmi::MessageBase *)v23, 47, (uint64_t)v97);
    if (!LOBYTE(v97[0]))
      goto LABEL_228;
    if (!v76)
      v76 = 1;
    v75 = WORD1(v97[0]);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v23))
  {
    LOWORD(v97[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::AgentVoiceSupportStatus>((qmi::MessageBase *)v23, 42, v97);
    if (!LOBYTE(v97[0]))
      goto LABEL_228;
    if (!HIBYTE(v81))
      HIBYTE(v81) = 1;
    BYTE2(v81) = BYTE1(v97[0]);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v23))
  {
    LOWORD(v97[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::ScanCompletionStatus>((qmi::MessageBase *)v23, v97);
    if (!LOBYTE(v97[0]))
      goto LABEL_228;
    if (!BYTE1(v87))
      BYTE1(v87) = 1;
    LOBYTE(v87) = BYTE1(v97[0]);
  }
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v23))
  {
    LOWORD(v97[0]) = 0;
    qmi::MessageBase::tryTlv<nas::tlv::CSVoiceSupportStatus>((qmi::MessageBase *)v23, v97);
    if (!LOBYTE(v97[0]))
      goto LABEL_228;
    if (!BYTE3(v87))
      BYTE3(v87) = 1;
    BYTE2(v87) = BYTE1(v97[0]);
  }
  if (!qmi::MessageBase::findTlvValue((qmi::MessageBase *)v23))
    goto LABEL_202;
  LOWORD(v97[0]) = 0;
  qmi::MessageBase::tryTlv<nas::tlv::IsSatelliteSystem>((qmi::MessageBase *)v23, v97);
  if (!LOBYTE(v97[0]))
LABEL_228:
    __assert_rtn("get", "optional.hpp", 1212, "this->is_initialized()");
  if (!BYTE5(v87))
    BYTE5(v87) = 1;
  BYTE4(v87) = BYTE1(v97[0]);
LABEL_202:
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v23))
  {
    *(_QWORD *)&v97[0] = qmi::MessageBase::findTlvValue((qmi::MessageBase *)v23);
    *((_QWORD *)&v97[0] + 1) = v16;
    if (!*(_QWORD *)&v97[0]
      || (v17 = tlv::parseV<nas::tlv::SysInfoNoChange>((unint64_t *)v97, v16), !*(_QWORD *)&v97[0]))
    {
      __assert_rtn("get", "optional.hpp", 1212, "this->is_initialized()");
    }
    if (!HIBYTE(v74))
      HIBYTE(v74) = 1;
    LOBYTE(v74) = v17;
  }
  if (!qmi::MessageBase::findTlvValue((qmi::MessageBase *)v23))
    goto LABEL_214;
  v24[0] = qmi::MessageBase::findTlvValue((qmi::MessageBase *)v23);
  v24[1] = v18;
  if (!v24[0])
LABEL_233:
    __assert_rtn("get", "optional.hpp", 1212, "this->is_initialized()");
  tlv::parseV<nas::tlv::WCDMAClosedSubscriberGroup>(v24, v18, v97);
  v19 = (void *)*((_QWORD *)&v97[0] + 1);
  if (!v24[0])
  {
    if (*((_QWORD *)&v97[0] + 1))
      operator delete(*((void **)&v97[0] + 1));
    goto LABEL_233;
  }
  v82 = v97[0];
  if (v86)
  {
    std::vector<unsigned short>::__assign_with_size[abi:ne180100]<unsigned short *,unsigned short *>((char *)&__p, *((char **)&v97[0] + 1), *(uint64_t *)&v97[1], (uint64_t)(*(_QWORD *)&v97[1] - *((_QWORD *)&v97[0] + 1)) >> 1);
    if (!v19)
      goto LABEL_214;
    goto LABEL_213;
  }
  __p = 0;
  v84 = 0;
  v85 = 0;
  std::vector<unsigned short>::__init_with_size[abi:ne180100]<unsigned short *,unsigned short *>(&__p, *((const void **)&v97[0] + 1), *(uint64_t *)&v97[1], (uint64_t)(*(_QWORD *)&v97[1] - *((_QWORD *)&v97[0] + 1)) >> 1);
  v86 = 1;
  if (v19)
LABEL_213:
    operator delete(v19);
LABEL_214:
  if (v4 - 1 >= 3)
    v20 = 0;
  else
    v20 = v4;
  QMINetworkRegistrationDriver::processSystemInfo_sync(v5, v20, buf);
  if (v86 && __p)
  {
    v84 = __p;
    operator delete(__p);
  }
  if (v56 && v54)
  {
    v55 = v54;
    operator delete(v54);
  }
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v23);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v21);
}

void sub_216A83478(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,void *a52,uint64_t a53,uint64_t a54,char a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  void *__p;
  void *v72;
  void *v74;

  if (v72)
    operator delete(v72);
  if (LOBYTE(STACK[0x210]))
  {
    v74 = __p;
    if (__p)
    {
      STACK[0x200] = (unint64_t)__p;
      operator delete(v74);
    }
  }
  if (a55)
  {
    if (a52)
    {
      a53 = (uint64_t)a52;
      operator delete(a52);
    }
  }
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a12);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SysInfo::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SysInfo::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SysInfo::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SysInfo::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::target_type()
{
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::CurrentPlmnName::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::CurrentPlmnName::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::CurrentPlmnName::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::CurrentPlmnName::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5EAD40;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::CurrentPlmnName::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::CurrentPlmnName::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5EAD40;
  a2[1] = v2;
  return result;
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::CurrentPlmnName::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::CurrentPlmnName::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::operator()(uint64_t a1, unsigned int *a2, QMIServiceMsg *this)
{
  unsigned int v4;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  NSObject *v9;
  uint64_t v10;
  NSObject **v11;
  nas::tlv *TlvValue;
  int v13;
  nas::tlv *v14;
  int v15;
  nas::tlv *v16;
  nas::tlv *v17;
  int v18;
  nas::tlv *v19;
  int v20;
  nas::tlv *v21;
  nas::tlv *v22;
  int v23;
  nas::tlv *v24;
  int v25;
  nas::tlv *v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  nas::tlv *v32;
  int v33;
  nas::tlv::EvoNitzInfo *v34;
  nas::tlv *v35;
  int v36;
  nas::tlv *v37;
  NSObject *v38;
  int v39;
  void **v40;
  int v41;
  void **v42;
  int v43;
  void **v44;
  int v45;
  __int128 *v46;
  uint64_t v47;
  void **v48;
  void **v49;
  void **v50;
  __int128 *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  unsigned int v55;
  unsigned int v56;
  _WORD v57[12];
  void *__p[2];
  void *v59[4];
  void *v60[2];
  __int128 v61;
  void *v62[2];
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  void *v68;
  nas::tlv *v69;
  __int128 v70;
  void *v71;
  _BYTE buf[56];
  char v73;
  void *v74;
  char v75;
  char v76;
  void *v77;
  char v78;
  char v79;
  void *v80;
  char v81;
  uint64_t v82;

  v82 = *MEMORY[0x24BDAC8D0];
  v4 = *a2;
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p[0] = 0;
    __p[1] = 0;
    v59[0] = 0;
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v57, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v57);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v57);
  }
  v6 = *(_QWORD *)(a1 + 8);
  v7 = v4 - 1;
  if (v4 - 1 >= 3)
    v8 = 0;
  else
    v8 = v4;
  v9 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v6 + 88) + 16))(*(_QWORD *)(v6 + 88), v8);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p[0]) = 0;
    _os_log_impl(&dword_216897000, v9, OS_LOG_TYPE_DEFAULT, "#I Received current PLMN indication from baseband", (uint8_t *)__p, 2u);
  }
  if (v7 >= 3)
    v10 = 0;
  else
    v10 = v4;
  v11 = (NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v6 + 88) + 16))(*(_QWORD *)(v6 + 88), v10);
  v65 = 0u;
  v66 = 0u;
  v64 = 0u;
  *(_OWORD *)v62 = 0u;
  v63 = 0u;
  *(_OWORD *)v60 = 0u;
  v61 = 0u;
  memset(v59, 0, sizeof(v59));
  *(_OWORD *)__p = 0u;
  HIDWORD(v61) = 11;
  v68 = 0;
  v67 = 0uLL;
  TlvValue = (nas::tlv *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)v57);
  v14 = TlvValue;
  if (TlvValue)
  {
    v15 = v13;
    v69 = TlvValue;
    memset(buf, 0, 32);
    tlv::parseV<nas::tlv::PlmnShortName>((unint64_t *)&v69, v13, buf);
    v16 = v69;
    if (v69)
    {
      decodeOperatorName();
      if (SHIBYTE(v59[3]) < 0)
        operator delete(v59[1]);
      *(_OWORD *)&v59[1] = v70;
      v59[3] = v71;
    }
    if (*(_QWORD *)&buf[8])
    {
      *(_QWORD *)&buf[16] = *(_QWORD *)&buf[8];
      operator delete(*(void **)&buf[8]);
    }
    if (!v16)
      ((void (*)(_QWORD, uint64_t, nas::tlv *, _QWORD))*MEMORY[0x24BED8BD0])(v57[0], 18, v14, v15);
  }
  v17 = (nas::tlv *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)v57);
  v19 = v17;
  if (v17)
  {
    v20 = v18;
    v69 = v17;
    memset(buf, 0, 32);
    tlv::parseV<nas::tlv::PlmnLongName>((unint64_t *)&v69, v18, buf);
    v21 = v69;
    if (v69)
    {
      decodeOperatorName();
      if (SHIBYTE(v59[0]) < 0)
        operator delete(__p[0]);
      *(_OWORD *)__p = v70;
      v59[0] = v71;
    }
    if (*(_QWORD *)&buf[8])
    {
      *(_QWORD *)&buf[16] = *(_QWORD *)&buf[8];
      operator delete(*(void **)&buf[8]);
    }
    if (!v21)
      ((void (*)(_QWORD, uint64_t, nas::tlv *, _QWORD))*MEMORY[0x24BED8BD0])(v57[0], 19, v19, v20);
  }
  v22 = (nas::tlv *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)v57);
  v24 = v22;
  if (v22)
  {
    v25 = v23;
    v69 = v22;
    memset(buf, 0, 32);
    tlv::parseV<nas::tlv::SrvProviderName>((unint64_t *)&v69, v23, buf);
    v26 = v69;
    if (v69)
    {
      decodeOperatorName();
      if (SBYTE7(v61) < 0)
        operator delete(v60[0]);
      *(_OWORD *)v60 = v70;
      *(_QWORD *)&v61 = v71;
    }
    if (*(_QWORD *)&buf[8])
    {
      *(_QWORD *)&buf[16] = *(_QWORD *)&buf[8];
      operator delete(*(void **)&buf[8]);
    }
    if (!v26)
      ((void (*)(_QWORD, uint64_t, nas::tlv *, _QWORD))*MEMORY[0x24BED8BD0])(v57[0], 17, v24, v25);
  }
  v27 = qmi::MessageBase::findTlvValue((qmi::MessageBase *)v57);
  v29 = v27;
  if (v27)
  {
    v30 = v28;
    *(_QWORD *)buf = v27;
    v31 = tlv::parseV<nas::tlv::NetworkNameSource>((unint64_t *)buf, v28);
    if (*(_QWORD *)buf)
      DWORD2(v61) = nas::convert(v31);
    else
      ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(v57[0], 26, v29, v30);
  }
  v32 = (nas::tlv *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)v57);
  v35 = v32;
  if (v32)
  {
    v36 = v33;
    v69 = v32;
    memset(buf, 0, sizeof(buf));
    tlv::parseV<nas::tlv::EvoNitzInfo>(&v69, v33, v34, (uint64_t)buf);
    v37 = v69;
    if (v69)
    {
      decodeOperatorName();
      if (SHIBYTE(v68) < 0)
        operator delete((void *)v67);
      v67 = v70;
      v68 = v71;
    }
    if (*(_QWORD *)&buf[32])
    {
      *(_QWORD *)&buf[40] = *(_QWORD *)&buf[32];
      operator delete(*(void **)&buf[32]);
    }
    if (*(_QWORD *)&buf[8])
    {
      *(_QWORD *)&buf[16] = *(_QWORD *)&buf[8];
      operator delete(*(void **)&buf[8]);
    }
    if (!v37)
      ((void (*)(_QWORD, uint64_t, nas::tlv *, _QWORD))*MEMORY[0x24BED8BD0])(v57[0], 160, v35, v36);
  }
  v38 = *v11;
  if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
  {
    v54 = v6;
    v55 = v4 - 1;
    v56 = v4;
    v39 = SHIBYTE(v59[0]);
    v40 = (void **)__p[0];
    v41 = SHIBYTE(v59[3]);
    v42 = (void **)v59[1];
    v43 = SBYTE7(v61);
    v44 = (void **)v60[0];
    v45 = SHIBYTE(v68);
    v46 = (__int128 *)v67;
    v47 = asString();
    v48 = __p;
    v49 = &v59[1];
    v50 = v60;
    if (v45 >= 0)
      v51 = &v67;
    else
      v51 = v46;
    *(_DWORD *)buf = 136447234;
    if (v43 < 0)
      v50 = v44;
    if (v41 < 0)
      v49 = v42;
    if (v39 < 0)
      v48 = v40;
    *(_QWORD *)&buf[4] = v48;
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = v49;
    *(_WORD *)&buf[22] = 2082;
    *(_QWORD *)&buf[24] = v50;
    *(_WORD *)&buf[32] = 2082;
    *(_QWORD *)&buf[34] = v51;
    *(_WORD *)&buf[42] = 2080;
    *(_QWORD *)&buf[44] = v47;
    _os_log_impl(&dword_216897000, v38, OS_LOG_TYPE_DEFAULT, "#I Received long name (%{public}s) short name (%{public}s) service provider name (%{public}s) TOE (%{public}s) and name source (%s)", buf, 0x34u);
    v7 = v55;
    v4 = v56;
    v6 = v54;
  }
  v52 = *(_QWORD *)(v6 + 64);
  OperatorNameUpdate::OperatorNameUpdate((std::string *)buf, (const OperatorNameUpdate *)__p);
  if (v7 >= 3)
    v53 = 0;
  else
    v53 = v4;
  (*(void (**)(uint64_t, uint64_t, _BYTE *))(*(_QWORD *)v52 + 80))(v52, v53, buf);
  if (v81 < 0)
    operator delete(v80);
  if (v79 && v78 < 0)
    operator delete(v77);
  if (v76 && v75 < 0)
    operator delete(v74);
  if (v73 < 0)
    operator delete(*(void **)&buf[48]);
  if ((buf[47] & 0x80000000) != 0)
    operator delete(*(void **)&buf[24]);
  if ((buf[23] & 0x80000000) != 0)
    operator delete(*(void **)buf);
  if (SHIBYTE(v68) < 0)
    operator delete((void *)v67);
  if (BYTE8(v66) && SBYTE7(v66) < 0)
    operator delete((void *)v65);
  if ((_BYTE)v64 && SHIBYTE(v63) < 0)
    operator delete(v62[1]);
  if (SBYTE7(v61) < 0)
    operator delete(v60[0]);
  if (SHIBYTE(v59[3]) < 0)
    operator delete(v59[1]);
  if (SHIBYTE(v59[0]) < 0)
    operator delete(__p[0]);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v57);
}

void sub_216A83CCC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43,void *a44,uint64_t a45,uint64_t a46,void *__p,uint64_t a48)
{
  if (__p)
  {
    a48 = (uint64_t)__p;
    operator delete(__p);
  }
  if (a44)
  {
    a45 = (uint64_t)a44;
    operator delete(a44);
  }
  OperatorNameUpdate::~OperatorNameUpdate(&a15);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a12);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::CurrentPlmnName::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::CurrentPlmnName::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::CurrentPlmnName::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::CurrentPlmnName::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::target_type()
{
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NetworkTime::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NetworkTime::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NetworkTime::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NetworkTime::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5EADC0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NetworkTime::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NetworkTime::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5EADC0;
  a2[1] = v2;
  return result;
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NetworkTime::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NetworkTime::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::operator()(uint64_t a1, unsigned int *a2, QMIServiceMsg *this)
{
  unsigned int v4;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  NSObject *v9;
  uint64_t v10;
  os_log_t *v11;
  uint64_t TlvValue;
  int v13;
  uint64_t v14;
  int v15;
  unsigned __int8 v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  unsigned __int8 v21;
  int v22;
  NSObject *v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  int v27;
  unint64_t v28;
  NSObject *v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  int v33;
  char v34;
  int v35;
  NSObject *v36;
  int v37;
  NSObject *v38;
  uint64_t v39;
  int v40;
  uint64_t v41;
  int v42;
  unint64_t v43;
  uint64_t v44;
  uint64_t v45;
  _WORD v46[12];
  void *__p[2];
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  void *v52[2];
  __int128 v53;
  __int128 v54;
  __int128 v55;
  uint64_t v56;
  uint64_t v57;
  __int128 v58;
  __int128 v59;
  __int16 v60;
  char v61;
  __int16 v62;
  char v63;
  __int128 buf;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  uint64_t v68;
  _BYTE v69[8];
  void *v70;
  char v71;
  char v72;
  uint64_t v73;
  void *v74;
  char v75;
  char v76;
  uint64_t v77;

  v77 = *MEMORY[0x24BDAC8D0];
  v4 = *a2;
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p[0] = 0;
    __p[1] = 0;
    *(_QWORD *)&v48 = 0;
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v46, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v46);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v46);
  }
  v6 = *(_QWORD *)(a1 + 8);
  v7 = v4 - 1;
  if (v4 - 1 >= 3)
    v8 = 0;
  else
    v8 = v4;
  v9 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v6 + 88) + 16))(*(_QWORD *)(v6 + 88), v8);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p[0]) = 0;
    _os_log_impl(&dword_216897000, v9, OS_LOG_TYPE_DEFAULT, "#I Received network time indication from baseband", (uint8_t *)__p, 2u);
  }
  if (v7 >= 3)
    v10 = 0;
  else
    v10 = v4;
  v11 = (os_log_t *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v6 + 88) + 16))(*(_QWORD *)(v6 + 88), v10);
  v56 = 0;
  v54 = 0u;
  v55 = 0u;
  *(_OWORD *)v52 = 0u;
  v53 = 0u;
  v50 = 0u;
  v51 = 0u;
  v48 = 0u;
  v49 = 0u;
  *(_OWORD *)__p = 0u;
  DWORD2(v50) = -1;
  LOBYTE(v51) = 1;
  DWORD1(v51) = 11;
  TlvValue = qmi::MessageBase::findTlvValue((qmi::MessageBase *)v46);
  v14 = TlvValue;
  if (TlvValue)
  {
    v15 = v13;
    *(_QWORD *)&buf = TlvValue;
    v16 = tlv::parseV<nas::tlv::TimeFromRadioInterface>((unint64_t *)&buf, v13);
    if ((_QWORD)buf)
    {
      if (v16 <= 0xCu && ((0x133Fu >> v16) & 1) != 0)
        DWORD1(v51) = dword_216AC1090[(char)v16];
    }
    else
    {
      ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(v46[0], 18, v14, v15);
    }
  }
  v17 = qmi::MessageBase::findTlvValue((qmi::MessageBase *)v46);
  v19 = v17;
  if (v17)
  {
    v20 = v18;
    *(_QWORD *)&v58 = v17;
    v21 = tlv::parseV<nas::tlv::DatelightSavings>((unint64_t *)&v58, v18);
    if ((_QWORD)v58)
    {
      v22 = v21;
      DWORD2(v50) = v21;
      if (v21 <= 1u)
        BYTE4(v49) = v21 == 1;
      v23 = *v11;
      if (os_log_type_enabled(*v11, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 67109120;
        DWORD1(buf) = v22;
        _os_log_impl(&dword_216897000, v23, OS_LOG_TYPE_DEFAULT, "#I DST is present with value %d", (uint8_t *)&buf, 8u);
      }
      LODWORD(v19) = 1;
    }
    else
    {
      LODWORD(v19) = ((uint64_t (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(v46[0], 17, v19, v20);
    }
  }
  v24 = qmi::MessageBase::findTlvValue((qmi::MessageBase *)v46);
  v26 = v24;
  if (v24)
  {
    v27 = v25;
    *(_QWORD *)&buf = v24;
    v28 = tlv::parseV<nas::tlv::UniversalTime>((unint64_t *)&buf, v25);
    if ((_QWORD)buf)
    {
      DWORD2(v48) = BYTE2(v28);
      HIDWORD(v48) = (unsigned __int16)v28;
      __p[1] = (void *)vand_s8((int8x8_t)vmovn_s64((int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v28), (uint64x2_t)xmmword_216AC10D0)), (int8x8_t)0xFF000000FFLL);
      LODWORD(v48) = BYTE6(v28);
      DWORD1(v48) = BYTE3(v28);
      v29 = *v11;
      if (os_log_type_enabled(*v11, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v58) = 0;
        _os_log_impl(&dword_216897000, v29, OS_LOG_TYPE_DEFAULT, "#I Time values are present", (uint8_t *)&v58, 2u);
      }
      LODWORD(v26) = 1;
    }
    else
    {
      LODWORD(v26) = ((uint64_t (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(v46[0], 1, v26, v27);
    }
  }
  v30 = qmi::MessageBase::findTlvValue((qmi::MessageBase *)v46);
  v32 = v30;
  if (v30)
  {
    v33 = v31;
    *(_QWORD *)&v58 = v30;
    v34 = tlv::parseV<nas::tlv::TimeZone>((unint64_t *)&v58, v31);
    if ((_QWORD)v58)
    {
      v35 = *MEMORY[0x24BDC4328] * v34;
      LODWORD(v49) = v35;
      v36 = *v11;
      if (os_log_type_enabled(*v11, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 67109120;
        DWORD1(buf) = v35;
        _os_log_impl(&dword_216897000, v36, OS_LOG_TYPE_DEFAULT, "#I Timezone offset is present with value %d", (uint8_t *)&buf, 8u);
      }
      v37 = 1;
    }
    else
    {
      v37 = ((uint64_t (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(v46[0], 16, v32, v33);
    }
  }
  else
  {
    v37 = 0;
  }
  if ((((v26 | v37) ^ 1 | v19) & 1) == 0)
  {
    v38 = *v11;
    if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl(&dword_216897000, v38, OS_LOG_TYPE_DEFAULT, "#I DST TLV is absent. Assuming it to be 0", (uint8_t *)&buf, 2u);
    }
    DWORD2(v50) = 0;
    BYTE4(v49) = 0;
  }
  v39 = qmi::MessageBase::findTlvValue((qmi::MessageBase *)v46);
  v41 = v39;
  if (v39)
  {
    v42 = v40;
    v57 = v39;
    v43 = tlv::parseV<nas::tlv::TimeFromPLMN>((unint64_t *)&v57, v40);
    if (v57)
    {
      v62 = v43;
      v63 = BYTE2(v43);
      v61 = BYTE5(v43);
      v60 = v43 >> 24;
      buf = 0u;
      v65 = 0u;
      MCC::MCC((MCC *)&buf);
      v58 = 0u;
      v59 = 0u;
      MNC::MNC((MNC *)&v58);
      convertMccAndMnc((unsigned __int8 *)&v62, (unsigned __int8 *)&v60, (const MCC *)&buf, (const MNC *)&v58);
      std::optional<MCC>::operator=[abi:ne180100]<MCC&,void>((uint64_t)&v51 + 8);
      std::optional<MNC>::operator=[abi:ne180100]<MNC&,void>((MCC *)&v54, (const MCC *)&v58);
      if (SHIBYTE(v59) < 0)
        operator delete(*((void **)&v58 + 1));
      if (SHIBYTE(v65) < 0)
        operator delete(*((void **)&buf + 1));
    }
    else
    {
      ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(v46[0], 193, v41, v42);
    }
  }
  v44 = *(_QWORD *)(v6 + 64);
  if (v7 >= 3)
    v45 = 0;
  else
    v45 = v4;
  v66 = v49;
  v67 = v50;
  buf = *(_OWORD *)__p;
  v65 = v48;
  v68 = v51;
  std::__optional_copy_base<MCC,false>::__optional_copy_base[abi:ne180100](v69, (uint64_t)&v51 + 8);
  std::__optional_copy_base<MNC,false>::__optional_copy_base[abi:ne180100]((MCC *)&v73, (const MCC *)&v54);
  (*(void (**)(uint64_t, uint64_t, __int128 *))(*(_QWORD *)v44 + 88))(v44, v45, &buf);
  if (v76 && v75 < 0)
    operator delete(v74);
  if (v72 && v71 < 0)
    operator delete(v70);
  if ((_BYTE)v56 && SHIBYTE(v55) < 0)
    operator delete(*((void **)&v54 + 1));
  if (BYTE8(v53) && SBYTE7(v53) < 0)
    operator delete(v52[0]);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v46);
}

void sub_216A8448C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39,uint64_t a40,uint64_t a41,char a42,void *__p,uint64_t a44,int a45,__int16 a46,char a47,char a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,int a57,__int16 a58,char a59,char a60,char a61)
{
  if (a48 < 0)
    operator delete(__p);
  NetworkTimeUpdate::~NetworkTimeUpdate(&a13);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a10);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NetworkTime::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NetworkTime::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NetworkTime::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NetworkTime::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::target_type()
{
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SystemSelectionPreference::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SystemSelectionPreference::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SystemSelectionPreference::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SystemSelectionPreference::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5EAE40;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SystemSelectionPreference::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SystemSelectionPreference::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5EAE40;
  a2[1] = v2;
  return result;
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SystemSelectionPreference::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SystemSelectionPreference::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::operator()(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  unsigned int v4;
  capabilities::ct *v5;
  uint64_t v6;
  NSObject *v7;
  uint64_t TlvValue;
  int v9;
  int v10;
  int v11;
  capabilities::ct *v12;
  unsigned int v13;
  int v14;
  uint64_t v15;
  unsigned int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint8_t v20[24];
  uint8_t buf[16];

  v4 = *a2;
  cast_message_type<nas::SystemSelectionPreference::Indication const&>::cast(a3, (qmi::MessageBase *)v20);
  v5 = *(capabilities::ct **)(a1 + 8);
  if (v4 - 1 >= 3)
    v6 = 0;
  else
    v6 = v4;
  v7 = *(NSObject **)(*(uint64_t (**)(_QWORD *, uint64_t))(**((_QWORD **)v5 + 11) + 16))(*((_QWORD **)v5 + 11), v6);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_216897000, v7, OS_LOG_TYPE_DEFAULT, "#I Received system selection preference update from baseband", buf, 2u);
  }
  TlvValue = qmi::MessageBase::findTlvValue((qmi::MessageBase *)v20);
  if (TlvValue)
  {
    *(_DWORD *)buf = 0;
    qmi::MessageBase::tryTlv<nas::tlv::ModePreference>((qmi::MessageBase *)v20, (uint64_t)buf);
    if (!buf[0])
      __assert_rtn("get", "optional.hpp", 1212, "this->is_initialized()");
    v9 = *(_WORD *)&buf[2] & 0xFF00;
    v10 = buf[2];
    v11 = 0x10000;
  }
  else
  {
    v11 = 0;
    v10 = 0;
    v9 = 0;
  }
  v12 = (capabilities::ct *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)v20);
  if (v12)
  {
    *(_QWORD *)buf = 0;
    v12 = (capabilities::ct *)qmi::MessageBase::tryTlv<nas::tlv::GwAcqOrderPref>((qmi::MessageBase *)v20, (uint64_t)buf);
    if (!buf[0])
      __assert_rtn("get", "optional.hpp", 1212, "this->is_initialized()");
    v13 = *(_DWORD *)&buf[4] & 0xFFFFFF00;
    v14 = buf[4];
    v15 = 0x100000000;
  }
  else
  {
    v13 = 0;
    v14 = 0;
    v15 = 0;
  }
  if (!capabilities::ct::supports5G(v12) || !qmi::MessageBase::findTlvValue((qmi::MessageBase *)v20))
  {
    v16 = 0;
    v17 = 0;
    v18 = 0;
    if (!TlvValue)
      goto LABEL_21;
    goto LABEL_20;
  }
  *(_QWORD *)buf = 0;
  qmi::MessageBase::tryTlv<nas::tlv::NRDisableMode>((qmi::MessageBase *)v20, (uint64_t)buf);
  if (!buf[0])
    __assert_rtn("get", "optional.hpp", 1212, "this->is_initialized()");
  v16 = *(_DWORD *)&buf[4] & 0xFFFFFF00;
  v17 = buf[4];
  v18 = 0x100000000;
  if (TlvValue)
LABEL_20:
    QMINetworkRegistrationDriver::handleModePreference_sync(v5, v6, v10 | v11 | v9, v15 | v14 | v13, v18 | v17 | v16);
LABEL_21:
  if (qmi::MessageBase::findTlvValue((qmi::MessageBase *)v20))
  {
    *(_WORD *)buf = 0;
    qmi::MessageBase::tryTlv<nas::tlv::EmergencyMode>((qmi::MessageBase *)v20, buf);
    if (!buf[0])
      __assert_rtn("get", "optional.hpp", 1212, "this->is_initialized()");
    if (buf[1])
      v19 = 257;
    else
      v19 = 1;
    (*(void (**)(_QWORD *, uint64_t, uint64_t))(**((_QWORD **)v5 + 8) + 24))(*((_QWORD **)v5 + 8), v6, v19);
  }
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v20);
}

void sub_216A848AC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SystemSelectionPreference::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SystemSelectionPreference::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SystemSelectionPreference::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SystemSelectionPreference::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::target_type()
{
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::ImsPreferenceInfo::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::ImsPreferenceInfo::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::ImsPreferenceInfo::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::ImsPreferenceInfo::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5EAEC0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::ImsPreferenceInfo::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::ImsPreferenceInfo::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5EAEC0;
  a2[1] = v2;
  return result;
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::ImsPreferenceInfo::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::ImsPreferenceInfo::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::operator()(uint64_t a1, unsigned int *a2, QMIServiceMsg *this)
{
  unsigned int v4;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  NSObject *v9;
  uint64_t TlvValue;
  int v11;
  uint64_t v12;
  int v13;
  unsigned __int8 v14;
  sd *v15;
  unsigned __int8 v16;
  sd *v17;
  uint64_t v18;
  capabilities::ct *v19;
  _BYTE *v20;
  NSObject *v21;
  void **v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  _WORD v26[12];
  uint64_t v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *__p;
  _BYTE *v32;
  uint64_t v33;
  uint8_t buf[4];
  int v35;
  __int16 v36;
  void **v37;
  uint64_t v38;

  v38 = *MEMORY[0x24BDAC8D0];
  v4 = *a2;
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v32 = 0;
    v33 = 0;
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v26, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v26);
    if (__p)
    {
      v32 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v26);
  }
  v6 = *(_QWORD *)(a1 + 8);
  v7 = v4 - 1;
  if (v4 - 1 >= 3)
    v8 = 0;
  else
    v8 = v4;
  v9 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v6 + 88) + 16))(*(_QWORD *)(v6 + 88), v8);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p) = 0;
    _os_log_impl(&dword_216897000, v9, OS_LOG_TYPE_DEFAULT, "#I Received IMS preference update from baseband", (uint8_t *)&__p, 2u);
  }
  TlvValue = qmi::MessageBase::findTlvValue((qmi::MessageBase *)v26);
  v12 = TlvValue;
  if (TlvValue)
  {
    v13 = v11;
    v27 = TlvValue;
    v14 = tlv::parseV<nas::tlv::IpPrefInfo>((unint64_t *)&v27, v11);
    if (v27)
    {
      v16 = v14;
      v17 = v15;
      if (v7 >= 3)
        v18 = 0;
      else
        v18 = v4;
      v19 = (capabilities::ct *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v6 + 88) + 16))(*(_QWORD *)(v6 + 88), v18);
      __p = 0;
      v32 = 0;
      v33 = 0;
      dataModesFromSysMode(v19, v16, (uint64_t)&__p);
      v20 = __p;
      if (__p != v32)
      {
        v21 = *(NSObject **)v19;
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
        {
          asString();
          v22 = v30 >= 0 ? &v28 : (void **)v28;
          *(_DWORD *)buf = 67109378;
          v35 = (int)v17;
          v36 = 2082;
          v37 = v22;
          _os_log_impl(&dword_216897000, v21, OS_LOG_TYPE_DEFAULT, "#I IMS preference changed: IMS supported = %d, data modes = %{public}s", buf, 0x12u);
          if (SHIBYTE(v30) < 0)
            operator delete(v28);
        }
        v23 = *(_QWORD *)(v6 + 64);
        if (v7 >= 3)
          v24 = 0;
        else
          v24 = v4;
        v29 = 0;
        v30 = 0;
        v28 = 0;
        std::vector<DataMode>::__init_with_size[abi:ne180100]<DataMode*,DataMode*>(&v28, __p, (uint64_t)v32, (v32 - (_BYTE *)__p) >> 2);
        v25 = sd::imsServiceMaskFromUint(v17);
        (*(void (**)(uint64_t, uint64_t, void **, _QWORD))(*(_QWORD *)v23 + 128))(v23, v24, &v28, v25);
        if (v28)
        {
          v29 = v28;
          operator delete(v28);
        }
        v20 = __p;
      }
      if (v20)
      {
        v32 = v20;
        operator delete(v20);
      }
    }
    else
    {
      ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(v26[0], 1, v12, v13);
    }
  }
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v26);
}

void sub_216A84C54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18)
{
  if (__p)
  {
    a18 = (uint64_t)__p;
    operator delete(__p);
  }
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a10);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::ImsPreferenceInfo::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::ImsPreferenceInfo::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::ImsPreferenceInfo::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::ImsPreferenceInfo::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::target_type()
{
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SubscriptionChange::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SubscriptionChange::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SubscriptionChange::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SubscriptionChange::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5EAF40;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SubscriptionChange::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SubscriptionChange::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5EAF40;
  a2[1] = v2;
  return result;
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SubscriptionChange::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SubscriptionChange::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::operator()(uint64_t a1, unsigned int *a2, QMIServiceMsg *this)
{
  unsigned int v4;
  uint64_t v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  _BYTE v10[24];
  void *__p;
  void *v12;
  uint64_t v13;

  v4 = *a2;
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v12 = 0;
    v13 = 0;
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v10, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v10);
    if (__p)
    {
      v12 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v10);
  }
  v6 = *(_QWORD *)(a1 + 8);
  if (v4 - 1 >= 3)
    v7 = 0;
  else
    v7 = v4;
  v8 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v6 + 88) + 16))(*(_QWORD *)(v6 + 88), v7);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p) = 0;
    _os_log_impl(&dword_216897000, v8, OS_LOG_TYPE_DEFAULT, "#I Received Subscription change indication from baseband", (uint8_t *)&__p, 2u);
  }
  if (v4 - 1 >= 3)
    v9 = 0;
  else
    v9 = v4;
  (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(v6 + 64) + 184))(*(_QWORD *)(v6 + 64), v9);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v10);
}

void sub_216A84EAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a10);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SubscriptionChange::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SubscriptionChange::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SubscriptionChange::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::SubscriptionChange::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::target_type()
{
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::E911StateReady::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::E911StateReady::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::E911StateReady::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::E911StateReady::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5EAFC0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::E911StateReady::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::E911StateReady::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5EAFC0;
  a2[1] = v2;
  return result;
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::E911StateReady::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::E911StateReady::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::operator()(uint64_t a1, unsigned int *a2, QMIServiceMsg *this)
{
  unsigned int v4;
  uint64_t v6;
  uint64_t v7;
  NSObject *v8;
  _BYTE v9[24];
  void *__p;
  void *v11;
  uint64_t v12;

  v4 = *a2;
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v11 = 0;
    v12 = 0;
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v9, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v9);
    if (__p)
    {
      v11 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v9);
  }
  v6 = *(_QWORD *)(a1 + 8);
  if (v4 - 1 >= 3)
    v7 = 0;
  else
    v7 = v4;
  v8 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v6 + 88) + 16))(*(_QWORD *)(v6 + 88), v7);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p) = 0;
    _os_log_impl(&dword_216897000, v8, OS_LOG_TYPE_DEFAULT, "#I E911 state ready", (uint8_t *)&__p, 2u);
  }
  (*(void (**)(_QWORD, uint64_t, uint64_t))(**(_QWORD **)(v6 + 64) + 136))(*(_QWORD *)(v6 + 64), 1, v7);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v9);
}

void sub_216A850CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a10);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::E911StateReady::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::E911StateReady::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::E911StateReady::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::E911StateReady::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::target_type()
{
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::T911StateReady::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::T911StateReady::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::T911StateReady::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::T911StateReady::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5EB040;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::T911StateReady::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::T911StateReady::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5EB040;
  a2[1] = v2;
  return result;
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::T911StateReady::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::T911StateReady::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::operator()(uint64_t a1, unsigned int *a2, QMIServiceMsg *this)
{
  unsigned int v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t TlvValue;
  int v9;
  uint64_t v10;
  int v11;
  BOOL v12;
  BOOL v13;
  NSObject *v14;
  void *v15;
  _WORD v16[12];
  uint64_t v17;
  void *__p[4];

  __p[3] = *(void **)MEMORY[0x24BDAC8D0];
  v4 = *a2;
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    memset(__p, 0, 24);
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v16, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v16);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v16);
  }
  v6 = *(_QWORD *)(a1 + 8);
  if (v4 - 1 >= 3)
    v7 = 0;
  else
    v7 = v4;
  TlvValue = qmi::MessageBase::findTlvValue((qmi::MessageBase *)v16);
  v10 = TlvValue;
  if (TlvValue)
  {
    v11 = v9;
    v17 = TlvValue;
    v12 = tlv::parseV<nas::tlv::SmsReady>((unint64_t *)&v17, v9);
    if (v17)
    {
      v13 = v12;
      v14 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v6 + 88) + 16))(*(_QWORD *)(v6 + 88), v7);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        v15 = (void *)asStringBool();
        LODWORD(__p[0]) = 136315138;
        *(void **)((char *)__p + 4) = v15;
        _os_log_impl(&dword_216897000, v14, OS_LOG_TYPE_DEFAULT, "#I T911 state ready: %s", (uint8_t *)__p, 0xCu);
      }
      (*(void (**)(_QWORD, BOOL, uint64_t))(**(_QWORD **)(v6 + 64) + 136))(*(_QWORD *)(v6 + 64), v13, v7);
    }
    else
    {
      ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(v16[0], 16, v10, v11);
    }
  }
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v16);
}

void sub_216A85390(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::T911StateReady::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::T911StateReady::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::T911StateReady::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::T911StateReady::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::target_type()
{
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::E911ScanFail::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::E911ScanFail::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::E911ScanFail::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::E911ScanFail::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5EB0C0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::E911ScanFail::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::E911ScanFail::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5EB0C0;
  a2[1] = v2;
  return result;
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::E911ScanFail::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::E911ScanFail::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::operator()(uint64_t a1, unsigned int *a2, QMIServiceMsg *this)
{
  unsigned int v4;
  uint64_t v6;
  uint64_t v7;
  NSObject *v8;
  _BYTE v9[24];
  void *__p;
  void *v11;
  uint64_t v12;

  v4 = *a2;
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v11 = 0;
    v12 = 0;
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v9, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v9);
    if (__p)
    {
      v11 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v9);
  }
  v6 = *(_QWORD *)(a1 + 8);
  if (v4 - 1 >= 3)
    v7 = 0;
  else
    v7 = v4;
  v8 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v6 + 88) + 16))(*(_QWORD *)(v6 + 88), v7);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p) = 0;
    _os_log_impl(&dword_216897000, v8, OS_LOG_TYPE_DEFAULT, "#I E911 scan completed (failed)", (uint8_t *)&__p, 2u);
  }
  (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(v6 + 64) + 152))(*(_QWORD *)(v6 + 64), v7);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v9);
}

void sub_216A855B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a10);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::E911ScanFail::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::E911ScanFail::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::E911ScanFail::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::E911ScanFail::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::target_type()
{
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::T3402TimerChange::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::T3402TimerChange::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::T3402TimerChange::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::T3402TimerChange::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5EB140;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::T3402TimerChange::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::T3402TimerChange::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5EB140;
  a2[1] = v2;
  return result;
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::T3402TimerChange::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::T3402TimerChange::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::operator()(uint64_t a1, unsigned int *a2, QMIServiceMsg *this)
{
  unsigned int v4;
  uint64_t v6;
  uint64_t v7;
  NSObject *v8;
  void *TlvValue;
  int v10;
  void *v11;
  int v12;
  uint64_t v13;
  _WORD v14[12];
  void *__p;
  void *v16;
  uint64_t v17;

  v4 = *a2;
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v16 = 0;
    v17 = 0;
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v14, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v14);
    if (__p)
    {
      v16 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v14);
  }
  v6 = *(_QWORD *)(a1 + 8);
  if (v4 - 1 >= 3)
    v7 = 0;
  else
    v7 = v4;
  v8 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v6 + 88) + 16))(*(_QWORD *)(v6 + 88), v7);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p) = 0;
    _os_log_impl(&dword_216897000, v8, OS_LOG_TYPE_DEFAULT, "#I T3402 timer changed", (uint8_t *)&__p, 2u);
  }
  TlvValue = (void *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)v14);
  v11 = TlvValue;
  if (!TlvValue)
    goto LABEL_16;
  v12 = v10;
  __p = TlvValue;
  v13 = tlv::parseV<nas::tlv::T3402Timer>((unint64_t *)&__p, v10);
  if (!__p)
  {
    ((void (*)(_QWORD, uint64_t, void *, _QWORD))*MEMORY[0x24BED8BD0])(v14[0], 16, v11, v12);
LABEL_16:
    v13 = 0;
  }
  (*(void (**)(_QWORD, uint64_t, uint64_t))(**(_QWORD **)(v6 + 64) + 176))(*(_QWORD *)(v6 + 64), v7, v13);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v14);
}

void sub_216A85824(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a10);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::T3402TimerChange::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::T3402TimerChange::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::T3402TimerChange::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::T3402TimerChange::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::target_type()
{
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NRDisableStatus::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NRDisableStatus::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NRDisableStatus::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NRDisableStatus::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5EB1C0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NRDisableStatus::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NRDisableStatus::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5EB1C0;
  a2[1] = v2;
  return result;
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NRDisableStatus::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NRDisableStatus::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::operator()(uint64_t a1, unsigned int *a2, QMIServiceMsg *this)
{
  unsigned int v4;
  uint64_t v6;
  uint64_t v7;
  NSObject *v8;
  _BOOL8 v9;
  uint64_t v10;
  uint64_t v11;
  void *TlvValue;
  int v13;
  void *v14;
  int v15;
  void *v16;
  int v17;
  void *v18;
  int v19;
  void *v20;
  int v21;
  void *v22;
  int v23;
  void *v24;
  int v25;
  void *v26;
  int v27;
  uint64_t v28;
  _WORD v29[12];
  void *__p;
  void *v31;
  uint64_t v32;

  v4 = *a2;
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v31 = 0;
    v32 = 0;
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v29, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v29);
    if (__p)
    {
      v31 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v29);
  }
  v6 = *(_QWORD *)(a1 + 8);
  if (v4 - 1 >= 3)
    v7 = 0;
  else
    v7 = v4;
  v8 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v6 + 88) + 16))(*(_QWORD *)(v6 + 88), v7);
  v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
  if (v9)
  {
    LOWORD(__p) = 0;
    _os_log_impl(&dword_216897000, v8, OS_LOG_TYPE_DEFAULT, "#I NR disable status changed", (uint8_t *)&__p, 2u);
  }
  if (capabilities::ct::supports5G((capabilities::ct *)v9))
  {
    if (v4 - 1 >= 3)
      v10 = 0;
    else
      v10 = v4;
    v11 = *(_QWORD *)(v6 + 64);
    TlvValue = (void *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)v29);
    v14 = TlvValue;
    if (TlvValue)
    {
      v15 = v13;
      __p = TlvValue;
      tlv::parseV<nas::tlv::IsSADisabled>((unint64_t *)&__p, v13);
      if (!__p)
        ((void (*)(_QWORD, uint64_t, void *, _QWORD))*MEMORY[0x24BED8BD0])(v29[0], 1, v14, v15);
    }
    v16 = (void *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)v29);
    v18 = v16;
    if (v16)
    {
      v19 = v17;
      __p = v16;
      tlv::parseV<nas::tlv::SADisableReasonMask>((unint64_t *)&__p, v17);
      if (!__p)
        ((void (*)(_QWORD, uint64_t, void *, _QWORD))*MEMORY[0x24BED8BD0])(v29[0], 16, v18, v19);
    }
    v20 = (void *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)v29);
    v22 = v20;
    if (v20)
    {
      v23 = v21;
      __p = v20;
      tlv::parseV<nas::tlv::IsNSADisabled>((unint64_t *)&__p, v21);
      if (!__p)
        ((void (*)(_QWORD, uint64_t, void *, _QWORD))*MEMORY[0x24BED8BD0])(v29[0], 2, v22, v23);
    }
    v24 = (void *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)v29);
    v26 = v24;
    if (v24)
    {
      v27 = v25;
      __p = v24;
      v28 = tlv::parseV<nas::tlv::NSADisableReasonMask>((unint64_t *)&__p, v25);
      if (!__p)
        ((void (*)(_QWORD, uint64_t, void *, _QWORD, uint64_t))*MEMORY[0x24BED8BD0])(v29[0], 17, v26, v27, v28);
    }
    NRDisableStatus::NRDisableStatus((NRDisableStatus *)&__p);
    (*(void (**)(uint64_t, uint64_t, void *, void *))(*(_QWORD *)v11 + 216))(v11, v10, __p, v31);
  }
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v29);
}

void sub_216A85BE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a10);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NRDisableStatus::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NRDisableStatus::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NRDisableStatus::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::NRDisableStatus::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::target_type()
{
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::GeoPlmnInfo::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::GeoPlmnInfo::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::GeoPlmnInfo::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::GeoPlmnInfo::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5EB240;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::GeoPlmnInfo::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::GeoPlmnInfo::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5EB240;
  a2[1] = v2;
  return result;
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::GeoPlmnInfo::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::GeoPlmnInfo::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::operator()(uint64_t a1, unsigned int *a2, QMIServiceMsg *this)
{
  unsigned int v4;
  uint64_t v6;
  uint64_t v7;
  NSObject **v8;
  void *TlvValue;
  int v10;
  void *v11;
  int v12;
  int v13;
  void *v14;
  int v15;
  void *v16;
  int v17;
  int v18;
  NSObject *v19;
  int IntValue;
  int IntegerWidth;
  int v22;
  uint64_t v23;
  _WORD v24[12];
  void *v25[2];
  __int128 v26;
  void *v27[2];
  __int128 v28;
  __int16 v29;
  char v30;
  __int16 v31;
  char v32;
  void *__p;
  void *v34;
  uint64_t v35;
  char v36;
  void *v37;
  char v38;
  uint64_t v39;

  v39 = *MEMORY[0x24BDAC8D0];
  v4 = *a2;
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v34 = 0;
    v35 = 0;
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v24, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v24);
    if (__p)
    {
      v34 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v24);
  }
  v6 = *(_QWORD *)(a1 + 8);
  if (v4 - 1 >= 3)
    v7 = 0;
  else
    v7 = v4;
  v8 = (NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v6 + 88) + 16))(*(_QWORD *)(v6 + 88), v7);
  v32 = -1;
  v31 = -1;
  TlvValue = (void *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)v24);
  v11 = TlvValue;
  if (TlvValue)
  {
    v12 = v10;
    __p = TlvValue;
    v13 = tlv::parseV<nas::tlv::GeoMcc>((unint64_t *)&__p, v10);
    if (__p)
    {
      v31 = v13;
      v32 = BYTE2(v13);
    }
    else
    {
      ((void (*)(_QWORD, uint64_t, void *, _QWORD))*MEMORY[0x24BED8BD0])(v24[0], 16, v11, v12);
    }
  }
  v30 = -1;
  v29 = -1;
  v14 = (void *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)v24);
  v16 = v14;
  if (v14)
  {
    v17 = v15;
    __p = v14;
    v18 = tlv::parseV<nas::tlv::GeoMnc>((unint64_t *)&__p, v15);
    if (__p)
    {
      v29 = v18;
      v30 = BYTE2(v18);
    }
    else
    {
      ((void (*)(_QWORD, uint64_t, void *, _QWORD))*MEMORY[0x24BED8BD0])(v24[0], 17, v16, v17);
    }
  }
  *(_OWORD *)v27 = 0u;
  v28 = 0u;
  MCC::MCC((MCC *)v27);
  *(_OWORD *)v25 = 0u;
  v26 = 0u;
  MNC::MNC((MNC *)v25);
  convertMccAndMnc((unsigned __int8 *)&v31, (unsigned __int8 *)&v29, (const MCC *)v27, (const MNC *)v25);
  v19 = *v8;
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    IntValue = MCC::getIntValue((MCC *)v27);
    IntegerWidth = MNC::getIntegerWidth((MNC *)v25);
    v22 = MCC::getIntValue((MCC *)v25);
    LODWORD(__p) = 67109632;
    HIDWORD(__p) = IntValue;
    LOWORD(v34) = 1024;
    *(_DWORD *)((char *)&v34 + 2) = IntegerWidth;
    HIWORD(v34) = 1024;
    LODWORD(v35) = v22;
    _os_log_impl(&dword_216897000, v19, OS_LOG_TYPE_DEFAULT, "#I Geo Plmn %03d-%0.*d", (uint8_t *)&__p, 0x14u);
  }
  v23 = *(_QWORD *)(v6 + 64);
  MEMORY[0x2199FE380](&__p, v27, v25);
  (*(void (**)(uint64_t, uint64_t, void **))(*(_QWORD *)v23 + 224))(v23, v7, &__p);
  if (v38 < 0)
    operator delete(v37);
  if (v36 < 0)
    operator delete(v34);
  if (SHIBYTE(v26) < 0)
    operator delete(v25[1]);
  if (SHIBYTE(v28) < 0)
    operator delete(v27[1]);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v24);
}

void sub_216A85FD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28,void *__p,uint64_t a30)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a10);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::GeoPlmnInfo::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::GeoPlmnInfo::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::GeoPlmnInfo::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::GeoPlmnInfo::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::target_type()
{
}

void std::__function::__func<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType)#1},std::allocator<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType)#1}>,void ()(qmi::SubscriptionType)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType)#1},std::allocator<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType)#1}>,void ()(qmi::SubscriptionType)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5EB2C0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType)#1},std::allocator<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType)#1}>,void ()(qmi::SubscriptionType)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5EB2C0;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType)#1},std::allocator<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType)#1}>,void ()(qmi::SubscriptionType)>::operator()(uint64_t a1, unsigned int *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  NSObject *v5;
  _BOOL8 v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  NSObject *v18;
  uint64_t result;
  uint64_t v20;
  uint64_t v21;
  _OWORD v22[2];
  uint8_t buf[8];
  uint64_t v24;
  void (*v25)(uint64_t, uint64_t);
  void *v26;
  std::__shared_weak_count *v27;
  std::__shared_weak_count *v28;
  _QWORD aBlock[5];

  v2 = *a2;
  v3 = *(_QWORD *)(a1 + 8);
  if ((v2 - 1) >= 3)
    v4 = 0;
  else
    v4 = v2;
  v5 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v3 + 88) + 16))(*(_QWORD *)(v3 + 88), v4);
  v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (v6)
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#I NAS Client has started", buf, 2u);
  }
  if ((capabilities::ct::supportsGemini((capabilities::ct *)v6) & 1) != 0)
  {
    memset(v22, 0, sizeof(v22));
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v22);
    *(_BYTE *)qmi::MutableMessageBase::getTLV<nas::tlv::SubType>(v22, 1) = (_DWORD)v2 == 2;
    v7 = qmi::ClientRouter::get();
    qmi::ClientRouter::SendProxy::SendProxy<nas::BindSubscription::Request>((uint64_t)&v20, v2, v7);
    v8 = (std::__shared_weak_count *)operator new(0x28uLL);
    v8->__shared_owners_ = 0;
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    v8->__shared_weak_owners_ = 0;
    v8->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E8A68;
    v8[1].__vftable = (std::__shared_weak_count_vtbl *)v3;
    LODWORD(v8[1].__shared_owners_) = v2;
    v10 = v21;
    v11 = MEMORY[0x24BDAC760];
    *(_QWORD *)buf = MEMORY[0x24BDAC760];
    v24 = 1174405120;
    v25 = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN28QMINetworkRegistrationDriver24bindNASSubscription_syncENS_16SubscriptionTypeEE3__0EEOS1_OT__block_invoke;
    v26 = &__block_descriptor_tmp_16_20;
    v27 = v8 + 1;
    v28 = v8;
    do
      v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
    aBlock[0] = v11;
    aBlock[1] = 0x40000000;
    aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas16BindSubscription8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke_7;
    aBlock[3] = &unk_24D5E8AB0;
    aBlock[4] = buf;
    *(_QWORD *)(v10 + 32) = _Block_copy(aBlock);
    v13 = v28;
    if (v28)
    {
      v14 = (unint64_t *)&v28->__shared_owners_;
      do
        v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }
    do
      v16 = __ldaxr(p_shared_owners);
    while (__stlxr(v16 - 1, p_shared_owners));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
    v17 = v21;
    v21 = 0;
    if (v17)
      std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v21, v17);
    qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v22);
  }
  else
  {
    v18 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_216897000, v18, OS_LOG_TYPE_DEFAULT, "#I NAS client binding not required", buf, 2u);
    }
    QMINetworkRegistrationDriver::sendIndRegisterReq_sync(v3, v2);
    QMINetworkRegistrationDriver::getImsPreferenceInfo_sync(v3, v2);
  }
  result = qmi::NotifyHelper::shouldNotifyStart(*(_QWORD **)(v3 + 96));
  if ((_DWORD)result)
    return (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v3 + 64) + 16))(*(_QWORD *)(v3 + 64), 1);
  return result;
}

void sub_216A863A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20)
{
  std::__shared_weak_count *v20;
  unint64_t *v21;
  std::__shared_weak_count *v23;
  unint64_t *p_shared_owners;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;

  v23 = a20;
  if (a20)
  {
    p_shared_owners = (unint64_t *)&a20->__shared_owners_;
    do
      v25 = __ldaxr(p_shared_owners);
    while (__stlxr(v25 - 1, p_shared_owners));
    if (!v25)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }
  do
    v26 = __ldaxr(v21);
  while (__stlxr(v26 - 1, v21));
  if (!v26)
  {
    ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
    std::__shared_weak_count::__release_weak(v20);
  }
  v27 = a10;
  a10 = 0;
  if (v27)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&a10, v27);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a11);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType)#1},std::allocator<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType)#1}>,void ()(qmi::SubscriptionType)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType)#1},std::allocator<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType)#1}>,void ()(qmi::SubscriptionType)>::target_type()
{
}

void std::__function::__func<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType)#2},std::allocator<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType)#2}>,void ()(qmi::SubscriptionType)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType)#2},std::allocator<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType)#2}>,void ()(qmi::SubscriptionType)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5EB340;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType)#2},std::allocator<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType)#2}>,void ()(qmi::SubscriptionType)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5EB340;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType)#2},std::allocator<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType)#2}>,void ()(qmi::SubscriptionType)>::operator()(uint64_t a1, _DWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  uint64_t result;
  uint8_t v6[16];

  v2 = *(_QWORD *)(a1 + 8);
  if ((*a2 - 1) >= 3)
    v3 = 0;
  else
    v3 = *a2;
  v4 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v2 + 88) + 16))(*(_QWORD *)(v2 + 88), v3);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v6 = 0;
    _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I NAS Client has stopped", v6, 2u);
  }
  result = qmi::NotifyHelper::shouldNotifyStop(*(unint64_t ***)(v2 + 96));
  if ((_DWORD)result)
    return (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(v2 + 64) + 16))(*(_QWORD *)(v2 + 64), 0);
  return result;
}

uint64_t std::__function::__func<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType)#2},std::allocator<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType)#2}>,void ()(qmi::SubscriptionType)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType)#2},std::allocator<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType)#2}>,void ()(qmi::SubscriptionType)>::target_type()
{
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::GeoMccFetch::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::GeoMccFetch::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::GeoMccFetch::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::GeoMccFetch::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5EB3C0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::GeoMccFetch::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::GeoMccFetch::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5EB3C0;
  a2[1] = v2;
  return result;
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::GeoMccFetch::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::GeoMccFetch::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::operator()(uint64_t a1, unsigned int *a2, QMIServiceMsg *this)
{
  unsigned int v4;
  uint64_t v6;
  uint64_t v7;
  _BYTE v8[24];
  void *__p;
  void *v10;
  uint64_t v11;

  v4 = *a2;
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v10 = 0;
    v11 = 0;
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v8, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v8);
    if (__p)
    {
      v10 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v8);
  }
  v6 = *(_QWORD *)(a1 + 8);
  if (v4 - 1 >= 3)
    v7 = 0;
  else
    v7 = v4;
  (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(v6 + 88) + 16))(*(_QWORD *)(v6 + 88), v7);
  (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(v6 + 64) + 232))(*(_QWORD *)(v6 + 64), v7);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v8);
}

void sub_216A86740(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::GeoMccFetch::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::GeoMccFetch::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::GeoMccFetch::Indication const&)#1}>(unsigned short,QMINetworkRegistrationDriver::bootstrap(dispatch::group_session,std::shared_ptr<NetworkRegistrationDriverEventHandlerInterface>)::$_0::operator() const(void)::{lambda(qmi::SubscriptionType,nas::GeoMccFetch::Indication const&)#1} &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(qmi::SubscriptionType,QMIServiceMsg const)>::target_type()
{
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<NetworkRegistrationDriver>::execute_wrapped<QMINetworkRegistrationDriver::start(void)::$_0>(QMINetworkRegistrationDriver::start(void)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMINetworkRegistrationDriver::start(void)::$_0,dispatch_queue_s *::default_delete<QMINetworkRegistrationDriver::start(void)::$_0>>)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  uint64_t v4;
  uint8_t buf[16];

  v4 = a1;
  v1 = *(_QWORD *)a1;
  v2 = *(NSObject **)(**(_QWORD **)a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_216897000, v2, OS_LOG_TYPE_DEFAULT, "#I Starting", buf, 2u);
  }
  qmi::ClientRouter::start();
  MEMORY[0x2199FEAC4](v1, 0x20C4093837F09);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v4);
}

void sub_216A86864(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  va_list va;

  va_start(va, a2);
  MEMORY[0x2199FEAC4](v2, 0x20C4093837F09);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<NetworkRegistrationDriver>::execute_wrapped<QMINetworkRegistrationDriver::shutdown(dispatch::group_session)::$_0>(QMINetworkRegistrationDriver::shutdown(dispatch::group_session)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMINetworkRegistrationDriver::shutdown(dispatch::group_session)::$_0,dispatch_queue_s *::default_delete<QMINetworkRegistrationDriver::shutdown(dispatch::group_session)::$_0>>)::{lambda(void *)#1}::__invoke(uint64_t *a1)
{
  uint64_t v1;
  uint64_t *v3;
  uint64_t v4;

  v1 = *a1;
  v3 = a1;
  v4 = v1;
  qmi::ClientRouter::stop();
  std::unique_ptr<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0,std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>>::~unique_ptr[abi:ne180100](&v4);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v3);
}

void sub_216A868D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  std::unique_ptr<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0,std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>>::~unique_ptr[abi:ne180100](&a10);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

uint64_t QMIQOSClientIP::QMIQOSClientIP(uint64_t a1, _QWORD *a2, uint64_t a3, _QWORD *a4, int a5, NSObject **a6)
{
  _QWORD *v12;
  int v13;
  unsigned int v14;
  const char *v15;
  NSObject *v16;
  uint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  int v20;
  unsigned int v21;
  uint64_t v22;
  unint64_t *v23;
  unint64_t v24;
  _BYTE v26[16];
  _BYTE v27[8];

  *(_QWORD *)a1 = &off_24D5EB440;
  v12 = (_QWORD *)(a1 + 8);
  v13 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(a3 + *(_QWORD *)(*(_QWORD *)a3 - 56)) + 24))(a3 + *(_QWORD *)(*(_QWORD *)a3 - 56));
  v14 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a3 + 64))(a3);
  v15 = QMIQOSClientIP::nameForFamily(a1, v13, v14, a5);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)v26, (const char *)*MEMORY[0x24BDC3E90], v15);
  *v12 = 0;
  v12[1] = 0;
  v16 = *a6;
  *(_QWORD *)(a1 + 24) = *a6;
  if (v16)
    dispatch_retain(v16);
  *(_QWORD *)(a1 + 32) = 0;
  ctu::OsLogLogger::OsLogLogger();
  ctu::OsLogLogger::OsLogLogger();
  MEMORY[0x2199FDF6C](v27);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v26);
  *(_QWORD *)a1 = &off_24D5EB440;
  *(_QWORD *)(a1 + 48) = *a2;
  v17 = a2[1];
  *(_QWORD *)(a1 + 56) = v17;
  if (v17)
  {
    v18 = (unint64_t *)(v17 + 8);
    do
      v19 = __ldxr(v18);
    while (__stxr(v19 + 1, v18));
  }
  *(_OWORD *)(a1 + 72) = 0u;
  *(_QWORD *)(a1 + 64) = a3;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_DWORD *)(a1 + 104) = a5;
  *(_WORD *)(a1 + 108) = 0;
  v20 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(a3 + *(_QWORD *)(*(_QWORD *)a3 - 56)) + 24))(a3 + *(_QWORD *)(*(_QWORD *)a3 - 56));
  v21 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a3 + 64))(a3);
  *(_QWORD *)(a1 + 112) = QMIQOSClientIP::nameForFamily(a1, v20, v21, a5);
  *(_QWORD *)(a1 + 120) = *a4;
  v22 = a4[1];
  *(_QWORD *)(a1 + 128) = v22;
  if (v22)
  {
    v23 = (unint64_t *)(v22 + 8);
    do
      v24 = __ldxr(v23);
    while (__stxr(v24 + 1, v23));
  }
  *(_QWORD *)(a1 + 136) = xpc_null_create();
  return a1;
}

const char *QMIQOSClientIP::nameForFamily(uint64_t a1, int a2, unsigned int a3, int a4)
{
  char **v4;
  NSObject *v5;
  int v7;
  uint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  if (a2 == 2)
  {
    if (a4 == 2)
    {
      if (a3 < 0xA)
      {
        v4 = off_24D5EC0D8;
        return v4[a3];
      }
      return "DATA.QMIContext.2:N:QOSIPv6";
    }
    else if (a4 == 1)
    {
      if (a3 < 0xA)
      {
        v4 = off_24D5EC088;
        return v4[a3];
      }
      return "DATA.QMIContext.2:N:QOSIPv4";
    }
    else
    {
      if (a3 < 0xA)
      {
        v4 = off_24D5EC128;
        return v4[a3];
      }
      return "DATA.QMIContext.2:N:QOSIPvX";
    }
  }
  else if (a2 == 1)
  {
    if (a4 == 2)
    {
      if (a3 < 0xA)
      {
        v4 = off_24D5EBFE8;
        return v4[a3];
      }
      return "DATA.QMIContext.1:N:QOSIPv6";
    }
    else if (a4 == 1)
    {
      if (a3 < 0xA)
      {
        v4 = off_24D5EBF98;
        return v4[a3];
      }
      return "DATA.QMIContext.1:N:QOSIPv4";
    }
    else
    {
      if (a3 < 0xA)
      {
        v4 = off_24D5EC038;
        return v4[a3];
      }
      return "DATA.QMIContext.1:N:QOSIPvX";
    }
  }
  else
  {
    v5 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v7 = 136315138;
      v8 = subscriber::asString();
      _os_log_error_impl(&dword_216897000, v5, OS_LOG_TYPE_ERROR, "Wrong SIM: %s", (uint8_t *)&v7, 0xCu);
    }
    return "DATA.QMIContext.X:X:QOSIPvX";
  }
}

void QMIQOSClientIP::createQoSClientOnDemand(QMIQOSClientIP *this)
{
  char *v1;
  NSObject *v3;
  NSObject *v4;
  std::__shared_weak_count *v5;
  uint64_t v6;
  std::__shared_weak_count *v7;
  qmi::Client *v8;
  unint64_t *p_shared_weak_owners;
  unint64_t v10;
  uint64_t *p_shared_owners;
  unint64_t v12;
  uint64_t *v13;
  unint64_t v14;
  uint64_t v15;
  capabilities::ct *v16;
  _QWORD v17[5];
  _QWORD v18[5];
  _QWORD v19[20];
  std::__shared_weak_count *v20;
  uint64_t v21;
  std::__shared_weak_count *v22;
  uint64_t v23;
  std::__shared_weak_count *v24;
  dispatch_object_t v25;
  void *v26;
  char v27;
  void *v28[2];
  uint64_t v29;
  uint8_t buf[8];
  uint64_t v31;
  __int128 v32;
  _QWORD *v33;

  v1 = (char *)this + 88;
  if (!*((_QWORD *)this + 11))
  {
    v3 = *((_QWORD *)this + 5);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_216897000, v3, OS_LOG_TYPE_DEFAULT, "#I creating fQOSClient", buf, 2u);
    }
    *((_BYTE *)this + 109) = 0;
    v28[0] = 0;
    v28[1] = 0;
    v29 = 0;
    std::string::basic_string[abi:ne180100]<0>(v28, "qos_1");
    std::string::basic_string[abi:ne180100]<0>(&v26, *((char **)this + 14));
    v4 = *((_QWORD *)this + 3);
    v25 = v4;
    if (v4)
      dispatch_retain(v4);
    v6 = *((_QWORD *)this + 1);
    v5 = (std::__shared_weak_count *)*((_QWORD *)this + 2);
    v21 = v6;
    if (!v5 || (v7 = std::__shared_weak_count::lock(v5), (v22 = v7) == 0))
      std::__throw_bad_weak_ptr[abi:ne180100]();
    v8 = (qmi::Client *)(v1 - 16);
    v23 = v6;
    v24 = v7;
    p_shared_weak_owners = (unint64_t *)&v7->__shared_weak_owners_;
    do
      v10 = __ldxr(p_shared_weak_owners);
    while (__stxr(v10 + 1, p_shared_weak_owners));
    Registry::getServerConnection(*((Registry **)this + 6));
    qmi::Client::createWithQueueLocal();
    std::shared_ptr<qmi::Client::State>::operator=[abi:ne180100]((uint64_t)v1, &v32);
    qmi::Client::~Client((qmi::Client *)buf);
    if (v20)
    {
      p_shared_owners = &v20->__shared_owners_;
      do
        v12 = __ldaxr((unint64_t *)p_shared_owners);
      while (__stlxr(v12 - 1, (unint64_t *)p_shared_owners));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
        std::__shared_weak_count::__release_weak(v20);
      }
    }
    std::__shared_weak_count::__release_weak(v24);
    if (v22)
    {
      v13 = &v22->__shared_owners_;
      do
        v14 = __ldaxr((unint64_t *)v13);
      while (__stlxr(v14 - 1, (unint64_t *)v13));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
        std::__shared_weak_count::__release_weak(v22);
      }
    }
    if (v25)
      dispatch_release(v25);
    if (v27 < 0)
      operator delete(v26);
    v15 = MEMORY[0x24BDAC760];
    v19[15] = MEMORY[0x24BDAC760];
    v19[16] = 0x40000000;
    v19[17] = ___ZN14QMIQOSClientIP23createQoSClientOnDemandEv_block_invoke;
    v19[18] = &__block_descriptor_tmp_40;
    v19[19] = this;
    qmi::Client::setHandler();
    v19[10] = v15;
    v19[11] = 0x40000000;
    v19[12] = ___ZN14QMIQOSClientIP23createQoSClientOnDemandEv_block_invoke_2;
    v19[13] = &__block_descriptor_tmp_70_7;
    v19[14] = this;
    v16 = (capabilities::ct *)qmi::Client::setHandler();
    if (capabilities::ct::supportsDataQMIExtensions(v16))
    {
      v19[5] = v15;
      v19[6] = 0x40000000;
      v19[7] = ___ZN14QMIQOSClientIP23createQoSClientOnDemandEv_block_invoke_3;
      v19[8] = &__block_descriptor_tmp_71_7;
      v19[9] = this;
      qmi::Client::setHandler();
    }
    v19[0] = v15;
    v19[1] = 0x40000000;
    v19[2] = ___ZN14QMIQOSClientIP23createQoSClientOnDemandEv_block_invoke_4;
    v19[3] = &__block_descriptor_tmp_73_9;
    v19[4] = this;
    *(_QWORD *)buf = v15;
    v31 = 0x40000000;
    *(_QWORD *)&v32 = ___ZNK3qmi6Client13setIndHandlerIRKN3qos9QosStatus10IndicationEEEvtU13block_pointerFvT_E_block_invoke;
    *((_QWORD *)&v32 + 1) = &unk_24D5EB8C0;
    v33 = v19;
    qmi::Client::setIndHandler();
    v18[0] = v15;
    v18[1] = 0x40000000;
    v18[2] = ___ZN14QMIQOSClientIP23createQoSClientOnDemandEv_block_invoke_5;
    v18[3] = &__block_descriptor_tmp_74_8;
    v18[4] = this;
    *(_QWORD *)buf = v15;
    v31 = 0x40000000;
    *(_QWORD *)&v32 = ___ZNK3qmi6Client13setIndHandlerIRKN3qos14EventReportInd10IndicationEEEvtU13block_pointerFvT_E_block_invoke;
    *((_QWORD *)&v32 + 1) = &unk_24D5EB8E8;
    v33 = v18;
    qmi::Client::setIndHandler();
    v17[0] = v15;
    v17[1] = 0x40000000;
    v17[2] = ___ZN14QMIQOSClientIP23createQoSClientOnDemandEv_block_invoke_6;
    v17[3] = &__block_descriptor_tmp_75_8;
    v17[4] = this;
    *(_QWORD *)buf = v15;
    v31 = 0x40000000;
    *(_QWORD *)&v32 = ___ZNK3qmi6Client13setIndHandlerIRKN3qos16GlobalQosFlowInd10IndicationEEEvtU13block_pointerFvT_E_block_invoke;
    *((_QWORD *)&v32 + 1) = &unk_24D5EB910;
    v33 = v17;
    qmi::Client::setIndHandler();
    qmi::Client::start(v8);
    if (SHIBYTE(v29) < 0)
      operator delete(v28[0]);
  }
}

void sub_216A8705C(_Unwind_Exception *a1)
{
  uint64_t v1;
  std::__shared_weak_count *v3;
  NSObject *v4;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v1 - 216);
  v3 = *(std::__shared_weak_count **)(v1 - 176);
  if (v3)
    std::__shared_weak_count::__release_weak(v3);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v1 - 200);
  v4 = *(NSObject **)(v1 - 168);
  if (v4)
    dispatch_release(v4);
  if (*(char *)(v1 - 137) < 0)
    operator delete(*(void **)(v1 - 160));
  if (*(char *)(v1 - 113) < 0)
    operator delete(*(void **)(v1 - 136));
  _Unwind_Resume(a1);
}

void ___ZN14QMIQOSClientIP23createQoSClientOnDemandEv_block_invoke_2(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  const void **v3;
  NSObject *v4;
  uint64_t v5;
  const void **v6;
  _WORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  NSObject *v13;
  _BYTE *v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  char *v26;
  uint64_t *v27;
  char *v28;
  char *v29;
  char *v30;
  uint64_t v31;
  _QWORD *v32;
  uint64_t v33;
  void *v34;
  uint64_t *v35;
  char *v36;
  char *v37;
  char *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  _QWORD *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  void *v46;
  void *v47;
  uint64_t v48;
  uint64_t v49;
  void (*v50)(uint64_t *, uint64_t);
  void *v51;
  uint64_t v52;
  void *__p[2];
  __int128 v54;
  uint64_t aBlock;
  uint64_t v56;
  void (*v57)(uint64_t, QMIServiceMsg *);
  void *v58;
  uint8_t *v59;
  uint8_t buf[8];
  uint64_t v61;
  uint64_t (*v62)(uint64_t, uint64_t);
  void *v63;
  uint64_t v64;
  _BYTE v65[24];
  _BYTE *v66;
  _QWORD v67[3];
  _QWORD *v68;
  uint64_t v69;

  v69 = *MEMORY[0x24BDAC8D0];
  v1 = *(_QWORD *)(a1 + 32);
  if (*(_BYTE *)(v1 + 108))
    return;
  if (!*(_QWORD *)(v1 + 88))
  {
    v4 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_216897000, v4, OS_LOG_TYPE_ERROR, "bindDataPort after client is deleted", buf, 2u);
    }
    return;
  }
  v67[0] = &off_24D5EB9B8;
  v67[1] = v1;
  v67[2] = 0;
  v68 = v67;
  *(_BYTE *)(v1 + 109) = 0;
  if (!(*(unsigned int (**)(_QWORD))(**(_QWORD **)(v1 + 120) + 184))(*(_QWORD *)(v1 + 120)))
  {
    if (!(*(unsigned int (**)(_QWORD))(**(_QWORD **)(v1 + 120) + 192))(*(_QWORD *)(v1 + 120)))
    {
      v13 = *(NSObject **)(v1 + 40);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_216897000, v13, OS_LOG_TYPE_ERROR, "Unknown baseband type", buf, 2u);
      }
      if (!v68)
        std::__throw_bad_function_call[abi:ne180100]();
      (*(void (**)(_QWORD *))(*v68 + 48))(v68);
      goto LABEL_83;
    }
    *(_OWORD *)__p = 0u;
    v54 = 0u;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
    v5 = MEMORY[0x24BDAC760];
    v48 = MEMORY[0x24BDAC760];
    v49 = 0x40000000;
    v50 = (void (*)(uint64_t *, uint64_t))___ZN14QMIQOSClientIP17bindDataPort_syncEv_block_invoke_80;
    v51 = &__block_descriptor_tmp_82_3;
    v52 = v1;
    v6 = (const void **)__p[1];
    if (__p[1] != (void *)v54)
    {
      while (*((_BYTE *)*v6 + 8) != 17)
      {
        if (++v6 == (const void **)v54)
          goto LABEL_35;
      }
    }
    if (v6 == (const void **)v54)
    {
LABEL_35:
      v19 = operator new();
      v20 = v19;
      *(_WORD *)(v19 + 8) = 17;
      *(_QWORD *)v19 = &off_24D5EBB48;
      v21 = v54;
      if ((unint64_t)v54 >= *((_QWORD *)&v54 + 1))
      {
        v23 = (uint64_t)(v54 - (unint64_t)__p[1]) >> 3;
        if ((unint64_t)(v23 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v24 = (uint64_t)(*((_QWORD *)&v54 + 1) - (unint64_t)__p[1]) >> 2;
        if (v24 <= v23 + 1)
          v24 = v23 + 1;
        if (*((_QWORD *)&v54 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v25 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v25 = v24;
        if (v25)
          v26 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v54 + 8, v25);
        else
          v26 = 0;
        v35 = (uint64_t *)&v26[8 * v23];
        v36 = &v26[8 * v25];
        *v35 = v20;
        v22 = v35 + 1;
        v38 = (char *)__p[1];
        v37 = (char *)v54;
        if ((void *)v54 != __p[1])
        {
          do
          {
            v39 = *((_QWORD *)v37 - 1);
            v37 -= 8;
            *--v35 = v39;
          }
          while (v37 != v38);
          v37 = (char *)__p[1];
        }
        __p[1] = v35;
        *(_QWORD *)&v54 = v22;
        *((_QWORD *)&v54 + 1) = v36;
        if (v37)
          operator delete(v37);
      }
      else
      {
        *(_QWORD *)v54 = v19;
        v22 = (_QWORD *)(v21 + 8);
      }
      *(_QWORD *)&v54 = v22;
      v50(&v48, v20 + 9);
    }
    else
    {
      if (!v14)
        __cxa_bad_cast();
      ___ZN14QMIQOSClientIP17bindDataPort_syncEv_block_invoke_80((uint64_t)&v48, v14 + 9);
    }
    v45 = QMIServiceMsg::create();
    *(_QWORD *)buf = v5;
    v61 = 1174405120;
    v62 = ___ZN14QMIQOSClientIP17bindDataPort_syncEv_block_invoke_2_83;
    v63 = &__block_descriptor_tmp_84_3;
    v64 = v1;
    v32 = v65;
    v40 = (uint64_t)v68;
    if (v68)
    {
      if (v68 == v67)
      {
        v66 = v65;
        (*(void (**)(_QWORD *, _BYTE *))(v67[0] + 24))(v67, v65);
LABEL_73:
        aBlock = v5;
        v56 = 0x40000000;
        v57 = ___ZNO3qmi6Client9SendProxy8callbackIRKN3qos12BindDataPort8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
        v58 = &unk_24D5EBB00;
        v59 = buf;
        v34 = _Block_copy(&aBlock);
        v47 = v34;
        if (v45)
        {
          qmi::Client::send();
          v34 = v47;
        }
        if (v34)
          goto LABEL_76;
        goto LABEL_77;
      }
      v40 = (*(uint64_t (**)(_QWORD *))(*v68 + 16))(v68);
    }
    v66 = (_BYTE *)v40;
    goto LABEL_73;
  }
  *(_OWORD *)__p = 0u;
  v54 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  v2 = MEMORY[0x24BDAC760];
  v48 = MEMORY[0x24BDAC760];
  v49 = 0x40000000;
  v50 = (void (*)(uint64_t *, uint64_t))___ZN14QMIQOSClientIP17bindDataPort_syncEv_block_invoke;
  v51 = &__block_descriptor_tmp_78_2;
  v52 = v1;
  v3 = (const void **)__p[1];
  if (__p[1] != (void *)v54)
  {
    while (*((_BYTE *)*v3 + 8) != 18)
    {
      if (++v3 == (const void **)v54)
        goto LABEL_18;
    }
  }
  if (v3 == (const void **)v54)
  {
LABEL_18:
    v8 = operator new();
    v9 = v8;
    *(_BYTE *)(v8 + 8) = 18;
    *(_QWORD *)v8 = &off_24D5EBAD0;
    *(_WORD *)(v8 + 10) = 0;
    v10 = v8 + 10;
    v11 = v54;
    if ((unint64_t)v54 >= *((_QWORD *)&v54 + 1))
    {
      v15 = (uint64_t)(v54 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v15 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v16 = (uint64_t)(*((_QWORD *)&v54 + 1) - (unint64_t)__p[1]) >> 2;
      if (v16 <= v15 + 1)
        v16 = v15 + 1;
      if (*((_QWORD *)&v54 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v17 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v17 = v16;
      if (v17)
        v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v54 + 8, v17);
      else
        v18 = 0;
      v27 = (uint64_t *)&v18[8 * v15];
      v28 = &v18[8 * v17];
      *v27 = v9;
      v12 = v27 + 1;
      v30 = (char *)__p[1];
      v29 = (char *)v54;
      if ((void *)v54 != __p[1])
      {
        do
        {
          v31 = *((_QWORD *)v29 - 1);
          v29 -= 8;
          *--v27 = v31;
        }
        while (v29 != v30);
        v29 = (char *)__p[1];
      }
      __p[1] = v27;
      *(_QWORD *)&v54 = v12;
      *((_QWORD *)&v54 + 1) = v28;
      if (v29)
        operator delete(v29);
    }
    else
    {
      *(_QWORD *)v54 = v8;
      v12 = (_QWORD *)(v11 + 8);
    }
    *(_QWORD *)&v54 = v12;
    v50(&v48, v10);
  }
  else
  {
    if (!v7)
      __cxa_bad_cast();
    ___ZN14QMIQOSClientIP17bindDataPort_syncEv_block_invoke((uint64_t)&v48, v7 + 5);
  }
  v44 = QMIServiceMsg::create();
  *(_QWORD *)buf = v2;
  v61 = 1174405120;
  v62 = ___ZN14QMIQOSClientIP17bindDataPort_syncEv_block_invoke_2;
  v63 = &__block_descriptor_tmp_79_5;
  v64 = v1;
  v32 = v65;
  v33 = (uint64_t)v68;
  if (!v68)
    goto LABEL_55;
  if (v68 != v67)
  {
    v33 = (*(uint64_t (**)(_QWORD *))(*v68 + 16))(v68);
LABEL_55:
    v66 = (_BYTE *)v33;
    goto LABEL_57;
  }
  v66 = v65;
  (*(void (**)(_QWORD *, _BYTE *))(v67[0] + 24))(v67, v65);
LABEL_57:
  aBlock = v2;
  v56 = 0x40000000;
  v57 = ___ZNO3qmi6Client9SendProxy8callbackIRKN3qos12BindDataPort8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
  v58 = &unk_24D5EBB00;
  v59 = buf;
  v34 = _Block_copy(&aBlock);
  v46 = v34;
  if (v44)
  {
    qmi::Client::send();
    v34 = v46;
  }
  if (v34)
LABEL_76:
    _Block_release(v34);
LABEL_77:
  if (v66 == v65)
  {
    v41 = 4;
    goto LABEL_81;
  }
  if (v66)
  {
    v41 = 5;
    v32 = v66;
LABEL_81:
    (*(void (**)(_QWORD *))(*v32 + 8 * v41))(v32);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
LABEL_83:
  v42 = v68;
  if (v68 == v67)
  {
    v43 = 4;
    v42 = v67;
  }
  else
  {
    if (!v68)
      return;
    v43 = 5;
  }
  (*(void (**)(_QWORD *))(*v42 + 8 * v43))(v42);
}

void sub_216A877B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *aBlock, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37)
{
  uint64_t v37;
  _QWORD *v39;
  uint64_t v40;

  if (a10)
    qmi::Client::send();
  if (aBlock)
    _Block_release(aBlock);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a19);
  v39 = *(_QWORD **)(v37 - 96);
  if (v39 == (_QWORD *)(v37 - 120))
  {
    v40 = 4;
    v39 = (_QWORD *)(v37 - 120);
  }
  else
  {
    if (!v39)
      goto LABEL_10;
    v40 = 5;
  }
  (*(void (**)(void))(*v39 + 8 * v40))();
LABEL_10:
  _Unwind_Resume(a1);
}

void sub_216A87BC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *aBlock, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,char *a28)
{
  char *v29;
  uint64_t v30;

  if (a11)
    qmi::Client::send();
  if (aBlock)
    _Block_release(aBlock);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a15);
  v29 = a28;
  if (a28 == &a25)
  {
    v30 = 4;
    v29 = &a25;
  }
  else
  {
    if (!a28)
      goto LABEL_10;
    v30 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v29 + 8 * v30))();
LABEL_10:
  _Unwind_Resume(a1);
}

void ___ZN14QMIQOSClientIP23createQoSClientOnDemandEv_block_invoke_4(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v2;
  NSObject *v4;
  uint64_t TlvValue;
  int v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  char v13;
  uint64_t v14;
  __int128 buf;
  uint64_t v16;
  int v17;
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)(v2 + 108))
  {
    v4 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 136315138;
      *(_QWORD *)((char *)&buf + 4) = "handleQOSStatusInd_sync";
      _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I %s: start", (uint8_t *)&buf, 0xCu);
    }
    *(_QWORD *)&buf = 0;
    *((_QWORD *)&buf + 1) = &buf;
    v16 = 0x2000000000;
    v17 = 0;
    v10 = 0;
    v11 = &v10;
    v12 = 0x2000000000;
    v13 = 0;
    TlvValue = qmi::MessageBase::findTlvValue(a2);
    v7 = TlvValue;
    if (TlvValue)
    {
      v8 = v6;
      v14 = TlvValue;
      v9 = tlv::parseV<qos::tlv::QosStatusInfo>((unint64_t *)&v14, v6);
      if (v14)
      {
        *(_DWORD *)(*((_QWORD *)&buf + 1) + 24) = v9;
        *((_BYTE *)v11 + 24) = BYTE4(v9);
      }
      else
      {
        ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 1, v7, v8);
      }
    }
    _Block_object_dispose(&v10, 8);
    _Block_object_dispose(&buf, 8);
  }
}

void sub_216A87DF4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3;
  va_list va;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  v5 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void ___ZN14QMIQOSClientIP23createQoSClientOnDemandEv_block_invoke_5(uint64_t a1, unsigned __int16 *a2)
{
  uint64_t v2;
  NSObject *v4;
  __int128 v5;
  _QWORD *v6;
  uint64_t v7;
  unint64_t v8;
  char *v9;
  uint64_t v10;
  char v11;
  __int16 v12;
  qos::tlv *NextTlv;
  int v14;
  qos::tlv::FlowInfo *v15;
  qos::tlv *v16;
  int v17;
  char *v18;
  char *v19;
  int v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  char *v24;
  char *v25;
  uint64_t v26;
  char *v27;
  uint64_t v28;
  void **v29;
  char v30;
  __int16 v31;
  __int16 v32;
  uint64_t v33;
  _BYTE v34[24];
  qos::tlv *v35;
  void **v36;
  unint64_t v37;
  uint64_t v38;
  char *v39;
  _BYTE v40[24];
  void **v41;
  uint8_t buf[16];
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  void *v49[2];
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  void *__p[2];
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  uint64_t v64;

  v64 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 32);
  if (*(_BYTE *)(v2 + 108))
    return;
  v4 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315138;
    *(_QWORD *)&buf[4] = "handleQOSEventReportInd_sync";
    _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I %s: start", buf, 0xCu);
  }
  v5 = 0uLL;
  memset(v34, 0, sizeof(v34));
  memset(v40, 0, sizeof(v40));
  v38 = 0;
  v6 = (_QWORD *)*((_QWORD *)a2 + 1);
  if (v6)
  {
    v7 = *v6;
    v8 = v6[1];
    v36 = (void **)(*v6 + 4);
    v37 = v8;
    v9 = (char *)(v7 + 7);
    if (v7 + 7 <= v8)
    {
      v11 = *(_BYTE *)(v7 + 4);
      v12 = *(_WORD *)(v7 + 5);
      v39 = v9;
      LOBYTE(v38) = v11;
      for (WORD1(v38) = v12; ; WORD1(v38) = v32)
      {
        NextTlv = (qos::tlv *)qmi::MessageBase::findNextTlv();
        v16 = NextTlv;
        if (!NextTlv)
        {
LABEL_125:
          v10 = *(_QWORD *)v40;
          v5 = *(_OWORD *)&v40[8];
          goto LABEL_126;
        }
        v17 = v14;
        v35 = NextTlv;
        v62 = 0u;
        v63 = 0u;
        v60 = 0u;
        v61 = 0u;
        *(_OWORD *)__p = 0u;
        v59 = 0u;
        v56 = 0u;
        v57 = 0u;
        v54 = 0u;
        v55 = 0u;
        v52 = 0u;
        v53 = 0u;
        v50 = 0u;
        v51 = 0u;
        v48 = 0u;
        *(_OWORD *)v49 = 0u;
        v46 = 0u;
        v47 = 0u;
        v44 = 0u;
        v45 = 0u;
        *(_OWORD *)buf = 0u;
        v43 = 0u;
        tlv::parseV<qos::tlv::FlowInfo>(&v35, v14, v15, (uint64_t)buf);
        if (v35)
          break;
        if ((((uint64_t (*)(_QWORD, uint64_t, qos::tlv *, _QWORD))*MEMORY[0x24BED8BD0])(*a2, 16, v16, v17) & 1) == 0)
        {
          v20 = 0;
          memset(v34, 0, sizeof(v34));
          goto LABEL_32;
        }
LABEL_31:
        v20 = 1;
LABEL_32:
        if (BYTE12(v63))
          BYTE12(v63) = 0;
        if (BYTE10(v63))
          BYTE10(v63) = 0;
        if (BYTE8(v63))
          BYTE8(v63) = 0;
        if ((_BYTE)v55)
        {
          if ((_BYTE)v63)
            LOBYTE(v63) = 0;
          if (BYTE14(v62))
            BYTE14(v62) = 0;
          if (BYTE12(v62))
            BYTE12(v62) = 0;
          if (BYTE10(v62))
            BYTE10(v62) = 0;
          if (BYTE8(v62))
            BYTE8(v62) = 0;
          if (BYTE4(v62))
            BYTE4(v62) = 0;
          if (BYTE2(v62))
            BYTE2(v62) = 0;
          if ((_BYTE)v62)
            LOBYTE(v62) = 0;
          if (BYTE8(v61))
            BYTE8(v61) = 0;
          if ((_BYTE)v61)
            LOBYTE(v61) = 0;
          if (BYTE8(v60))
            BYTE8(v60) = 0;
          if ((_BYTE)v60)
            LOBYTE(v60) = 0;
          if (BYTE8(v59))
            BYTE8(v59) = 0;
          if (BYTE8(v57))
          {
            if (__p[0])
            {
              __p[1] = __p[0];
              operator delete(__p[0]);
            }
            BYTE8(v57) = 0;
          }
          if (BYTE12(v56))
            BYTE12(v56) = 0;
          if (BYTE12(v55))
            BYTE12(v55) = 0;
          if (BYTE8(v55))
            BYTE8(v55) = 0;
          LOBYTE(v55) = 0;
        }
        if (BYTE8(v46))
        {
          if (BYTE8(v54))
            BYTE8(v54) = 0;
          if (BYTE6(v54))
            BYTE6(v54) = 0;
          if (BYTE4(v54))
            BYTE4(v54) = 0;
          if (BYTE2(v54))
            BYTE2(v54) = 0;
          if ((_BYTE)v54)
            LOBYTE(v54) = 0;
          if (BYTE12(v53))
            BYTE12(v53) = 0;
          if (BYTE10(v53))
            BYTE10(v53) = 0;
          if (BYTE8(v53))
            BYTE8(v53) = 0;
          if ((_BYTE)v53)
            LOBYTE(v53) = 0;
          if (BYTE8(v52))
            BYTE8(v52) = 0;
          if ((_BYTE)v52)
            LOBYTE(v52) = 0;
          if (BYTE8(v51))
            BYTE8(v51) = 0;
          if ((_BYTE)v51)
            LOBYTE(v51) = 0;
          if (LOBYTE(v49[0]))
          {
            if (v49[1])
            {
              *(void **)&v50 = v49[1];
              operator delete(v49[1]);
            }
            LOBYTE(v49[0]) = 0;
          }
          if (BYTE4(v48))
            BYTE4(v48) = 0;
          if (BYTE4(v47))
            BYTE4(v47) = 0;
          if ((_BYTE)v47)
            LOBYTE(v47) = 0;
          BYTE8(v46) = 0;
        }
        if (BYTE8(v44))
        {
          v41 = (void **)&v45;
          std::vector<tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>>::__destroy_vector::operator()[abi:ne180100](&v41);
          BYTE8(v44) = 0;
        }
        if (buf[8])
        {
          v41 = (void **)&v43;
          std::vector<tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>>::__destroy_vector::operator()[abi:ne180100](&v41);
        }
        if (!v20)
        {
          v33 = *(_QWORD *)&v34[8];
          v10 = *(_QWORD *)v34;
          goto LABEL_127;
        }
        v29 = (void **)&v39[WORD1(v38)];
        v36 = v29;
        if (!v39 || (unint64_t)v29 + 3 > v37)
          goto LABEL_125;
        v39 = (char *)v29 + 1;
        v30 = *(_BYTE *)v29;
        v39 = (char *)v29 + 2;
        v31 = *((unsigned __int8 *)v29 + 1);
        v39 = (char *)v29 + 3;
        v32 = v31 | (*((unsigned __int8 *)v29 + 2) << 8);
        LOBYTE(v38) = v30;
      }
      v18 = *(char **)&v40[8];
      if (*(_QWORD *)&v40[8] < *(_QWORD *)&v40[16])
      {
        qos::tlv::FlowInfo::FlowInfo(*(uint64_t *)&v40[8], (uint64_t)buf);
        v19 = v18 + 352;
LABEL_30:
        *(_QWORD *)&v40[8] = v19;
        goto LABEL_31;
      }
      v21 = 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(*(_QWORD *)&v40[8] - *(_QWORD *)v40) >> 5);
      v22 = v21 + 1;
      if ((unint64_t)(v21 + 1) > 0xBA2E8BA2E8BA2ELL)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      if (0x5D1745D1745D1746 * ((uint64_t)(*(_QWORD *)&v40[16] - *(_QWORD *)v40) >> 5) > v22)
        v22 = 0x5D1745D1745D1746 * ((uint64_t)(*(_QWORD *)&v40[16] - *(_QWORD *)v40) >> 5);
      if ((unint64_t)(0x2E8BA2E8BA2E8BA3 * ((uint64_t)(*(_QWORD *)&v40[16] - *(_QWORD *)v40) >> 5)) >= 0x5D1745D1745D17)
        v23 = 0xBA2E8BA2E8BA2ELL;
      else
        v23 = v22;
      if (v23)
      {
        if (v23 > 0xBA2E8BA2E8BA2ELL)
          std::__throw_bad_array_new_length[abi:ne180100]();
        v24 = (char *)operator new(352 * v23);
      }
      else
      {
        v24 = 0;
      }
      v25 = &v24[352 * v23];
      v26 = qos::tlv::FlowInfo::FlowInfo((uint64_t)&v24[352 * v21], (uint64_t)buf);
      v19 = (char *)(v26 + 352);
      v27 = *(char **)v40;
      if (v18 == *(char **)v40)
      {
        *(_QWORD *)v40 = v26;
        *(_QWORD *)&v40[8] = v26 + 352;
        *(_QWORD *)&v40[16] = v25;
      }
      else
      {
        do
        {
          v18 -= 352;
          v26 = qos::tlv::FlowInfo::FlowInfo(v26 - 352, (uint64_t)v18);
        }
        while (v18 != v27);
        v28 = *(_QWORD *)&v40[8];
        v18 = *(char **)v40;
        *(_QWORD *)v40 = v26;
        *(_QWORD *)&v40[8] = v19;
        *(_QWORD *)&v40[16] = v25;
        if ((char *)v28 != v18)
        {
          do
          {
            v28 -= 352;
            std::__destroy_at[abi:ne180100]<qos::tlv::FlowInfo,0>(v28);
          }
          while ((char *)v28 != v18);
          if (!v18)
            goto LABEL_30;
LABEL_29:
          operator delete(v18);
          goto LABEL_30;
        }
      }
      if (!v18)
        goto LABEL_30;
      goto LABEL_29;
    }
  }
  v10 = 0;
LABEL_126:
  *(_QWORD *)v34 = v10;
  *(_OWORD *)&v34[8] = v5;
  v33 = v5;
  memset(v40, 0, sizeof(v40));
LABEL_127:
  *(_QWORD *)buf = v40;
  std::vector<qos::tlv::FlowInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
  *(_QWORD *)buf = MEMORY[0x24BDAC760];
  *(_QWORD *)&buf[8] = 0x40000000;
  *(_QWORD *)&v43 = ___ZNK14QMIQOSClientIP28handleQOSEventReportInd_syncERKN3qos14EventReportInd10IndicationE_block_invoke;
  *((_QWORD *)&v43 + 1) = &__block_descriptor_tmp_122_2;
  *(_QWORD *)&v44 = v2;
  while (v10 != v33)
  {
    ((void (*)(uint8_t *, uint64_t))v43)(buf, v10);
    v10 += 352;
  }
  v36 = (void **)v34;
  std::vector<qos::tlv::FlowInfo>::__destroy_vector::operator()[abi:ne180100](&v36);
}

void sub_216A8844C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30,int a31,__int16 a32,__int16 a33,__int16 a34,uint64_t a35,int a36,char a37,uint64_t a38,char a39,void *a40,uint64_t a41,uint64_t a42,char a43,int a44,__int16 a45,int a46,__int16 a47,int a48,__int16 a49,int a50,__int16 a51,int a52,__int16 a53,char a54,char a55,char a56,__int16 a57,__int16 a58,char a59,char a60,char a61,char a62,char a63)
{
  char a65;
  __int16 a67;
  __int16 a69;
  __int16 a71;
  char a72;
  char a73;
  void *__p;
  uint64_t a75;
  char a76;
  __int16 a77;
  __int16 a78;
  __int16 a79;
  __int16 a80;
  __int16 a81;
  char a82;
  char a83;
  __int16 a84;
  char a85;
  char a86;
  char a87;
  char a88;
  __int16 a89;
  char a90;
  char a91;

  if (a91)
    a91 = 0;
  if (a90)
    a90 = 0;
  if ((_BYTE)a89)
    LOBYTE(a89) = 0;
  if ((_BYTE)a67)
  {
    if (a88)
      a88 = 0;
    if (a87)
      a87 = 0;
    if (a86)
      a86 = 0;
    if (a85)
      a85 = 0;
    if ((_BYTE)a84)
      LOBYTE(a84) = 0;
    if (a83)
      a83 = 0;
    if (a82)
      a82 = 0;
    if ((_BYTE)a81)
      LOBYTE(a81) = 0;
    if ((_BYTE)a80)
      LOBYTE(a80) = 0;
    if ((_BYTE)a79)
      LOBYTE(a79) = 0;
    if ((_BYTE)a78)
      LOBYTE(a78) = 0;
    if ((_BYTE)a77)
      LOBYTE(a77) = 0;
    if (a76)
      a76 = 0;
    if (a73)
    {
      if (__p)
      {
        a75 = (uint64_t)__p;
        operator delete(__p);
      }
      a73 = 0;
    }
    if (a72)
      a72 = 0;
    if ((_BYTE)a71)
      LOBYTE(a71) = 0;
    if ((_BYTE)a69)
      LOBYTE(a69) = 0;
    LOBYTE(a67) = 0;
  }
  if (a30)
  {
    if (a65)
      a65 = 0;
    if (a63)
      a63 = 0;
    if (a61)
      a61 = 0;
    if (a59)
      a59 = 0;
    if ((_BYTE)a58)
      LOBYTE(a58) = 0;
    if (a56)
      a56 = 0;
    if (a54)
      a54 = 0;
    if ((_BYTE)a53)
      LOBYTE(a53) = 0;
    if ((_BYTE)a51)
      LOBYTE(a51) = 0;
    if ((_BYTE)a49)
      LOBYTE(a49) = 0;
    if ((_BYTE)a47)
      LOBYTE(a47) = 0;
    if ((_BYTE)a45)
      LOBYTE(a45) = 0;
    if (a43)
      a43 = 0;
    if (a39)
    {
      if (a40)
      {
        a41 = (uint64_t)a40;
        operator delete(a40);
      }
      a39 = 0;
    }
    if (a37)
      a37 = 0;
    if ((_BYTE)a34)
      LOBYTE(a34) = 0;
    if ((_BYTE)a32)
      LOBYTE(a32) = 0;
    a30 = 0;
  }
  if (a26)
  {
    std::vector<tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a20);
    a26 = 0;
  }
  if (a22)
    std::vector<tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a20);
  a21 = (uint64_t)&a17;
  std::vector<qos::tlv::FlowInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)&a21);
  _Unwind_Resume(a1);
}

void ___ZN14QMIQOSClientIP23createQoSClientOnDemandEv_block_invoke_6(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v2;
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  unsigned int v9;
  NSObject *v10;
  const char *v11;
  const char *v12;
  uint64_t v13;
  __int16 v14;
  __int128 v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  __int16 v19;
  __int128 v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  char *v24;
  char *v25;
  char *v26;
  uint64_t v27;
  unsigned __int8 *v28;
  unsigned __int8 *v29;
  unsigned __int8 *v30;
  uint64_t v31;
  unsigned __int8 v32;
  void *TlvValue;
  uint64_t v34;
  void (*v35)(uint64_t, unsigned __int8 *);
  void *v36;
  _BYTE *v37;
  uint64_t v38;
  void *__p[2];
  __int128 v40;
  __int128 v41;
  uint64_t v42;
  int v43;
  unsigned __int8 *v44;
  uint64_t v45;
  _BYTE buf[24];
  __int128 v47;
  __int128 v48;
  __int128 v49;
  _BYTE v50[32];
  __int128 v51;
  __int128 v52;
  _BYTE v53[32];
  __int128 v54;
  uint64_t v55;
  uint64_t v56;

  v56 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)(v2 + 108))
  {
    v4 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = "handleGlobalQosFlowInd_sync";
      _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I %s: start", buf, 0xCu);
    }
    *(_QWORD *)buf = qmi::MessageBase::findTlvValue(a2);
    *(_QWORD *)&buf[8] = v5;
    if (*(_QWORD *)buf)
    {
      v6 = tlv::parseV<qos::tlv::QosFlowState>((unint64_t *)buf, v5);
      if (*(_QWORD *)buf)
      {
        v8 = v6;
        v9 = v7;
        v10 = *(NSObject **)(v2 + 40);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          v11 = qos::asString(v9);
          v12 = "New ";
          *(_DWORD *)buf = 136315906;
          *(_QWORD *)&buf[4] = "handleGlobalQosFlowInd_sync";
          if ((v8 & 0xFF00000000) == 0)
            v12 = (const char *)&unk_216AC4FCA;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = v12;
          *(_WORD *)&buf[22] = 1024;
          LODWORD(v47) = v8;
          WORD2(v47) = 2080;
          *(_QWORD *)((char *)&v47 + 6) = v11;
          _os_log_impl(&dword_216897000, v10, OS_LOG_TYPE_DEFAULT, "#I %s: %sQOS ID: %u, State change=%s", buf, 0x26u);
        }
        *(_QWORD *)buf = 0;
        *(_QWORD *)&buf[8] = buf;
        *(_QWORD *)&buf[16] = 0xC002000000;
        *(_QWORD *)&v47 = __Block_byref_object_copy__11;
        *((_QWORD *)&v47 + 1) = __Block_byref_object_dispose__11;
        v55 = 256;
        v48 = 0u;
        v49 = 0u;
        memset(v50, 0, sizeof(v50));
        v51 = 0u;
        v52 = 0u;
        memset(v53, 0, sizeof(v53));
        v54 = 0u;
        LODWORD(v48) = v8;
        TlvValue = (void *)qmi::MessageBase::findTlvValue(a2);
        v34 = v13;
        if (TlvValue)
        {
          tlv::parseV<qos::tlv::TxQosGrantedFlow>((unint64_t *)&TlvValue, v13, (uint64_t)__p);
          if (TlvValue)
          {
            v14 = (__int16)__p[0];
            v15 = v40;
            v42 = 0;
            v40 = 0u;
            v41 = 0u;
            *(_OWORD *)__p = 0u;
            if ((v14 & 2) != 0)
            {
              BYTE4(__p[1]) = 1;
              LODWORD(__p[1]) = v15;
              BYTE4(v40) = 1;
              LODWORD(v40) = DWORD2(v15);
            }
            if ((v14 & 0x4000) != 0)
            {
              LODWORD(__p[0]) = v43;
              BYTE4(__p[0]) = 1;
            }
            if (v14 < 0)
            {
              TlvValue = (void *)qmi::MessageBase::findTlvValue(a2);
              v34 = v16;
              if (TlvValue)
              {
                v17 = tlv::parseV<qos::tlv::Tx5gQci>((unint64_t *)&TlvValue, v16);
                if (TlvValue)
                {
                  LODWORD(__p[0]) = v17;
                  BYTE4(__p[0]) = 1;
                  *(_WORD *)(*(_QWORD *)&buf[8] + 184) = 257;
                }
              }
            }
            std::optional<DataQoS>::operator=[abi:ne180100]<DataQoS&,void>(*(_QWORD *)&buf[8] + 56, (uint64_t)__p);
            if ((_BYTE)v42)
            {
              TlvValue = (char *)&v40 + 8;
              std::vector<DataIPFilter>::__destroy_vector::operator()[abi:ne180100]((void ***)&TlvValue);
            }
          }
        }
        TlvValue = (void *)qmi::MessageBase::findTlvValue(a2);
        v34 = v18;
        if (TlvValue)
        {
          tlv::parseV<qos::tlv::RxQosGrantedFlow>((unint64_t *)&TlvValue, v18, (uint64_t)__p);
          if (TlvValue)
          {
            v19 = (__int16)__p[0];
            v20 = v40;
            v42 = 0;
            v40 = 0u;
            v41 = 0u;
            *(_OWORD *)__p = 0u;
            if ((v19 & 2) != 0)
            {
              BYTE4(__p[1]) = 1;
              LODWORD(__p[1]) = v20;
              BYTE4(v40) = 1;
              LODWORD(v40) = DWORD2(v20);
            }
            if ((v19 & 0x4000) != 0)
            {
              LODWORD(__p[0]) = v43;
              BYTE4(__p[0]) = 1;
            }
            if (v19 < 0)
            {
              TlvValue = (void *)qmi::MessageBase::findTlvValue(a2);
              v34 = v21;
              if (TlvValue)
              {
                v22 = tlv::parseV<qos::tlv::Rx5gQci>((unint64_t *)&TlvValue, v21);
                if (TlvValue)
                {
                  LODWORD(__p[0]) = v22;
                  BYTE4(__p[0]) = 1;
                  *(_WORD *)(*(_QWORD *)&buf[8] + 184) = 257;
                }
              }
            }
            std::optional<DataQoS>::operator=[abi:ne180100]<DataQoS&,void>(*(_QWORD *)&buf[8] + 120, (uint64_t)__p);
            if ((_BYTE)v42)
            {
              TlvValue = (char *)&v40 + 8;
              std::vector<DataIPFilter>::__destroy_vector::operator()[abi:ne180100]((void ***)&TlvValue);
            }
          }
        }
        TlvValue = (void *)qmi::MessageBase::findTlvValue(a2);
        v34 = v23;
        if (TlvValue)
        {
          tlv::parseV<qos::tlv::TxQosFilterSpecList>((unsigned __int8 **)&TlvValue, v23, (uint64_t *)__p);
          v24 = (char *)__p[0];
          if (TlvValue)
          {
            v25 = (char *)__p[1];
            __p[0] = (void *)MEMORY[0x24BDAC760];
            __p[1] = (void *)0x40000000;
            *(_QWORD *)&v40 = ___ZNK14QMIQOSClientIP27handleGlobalQosFlowInd_syncERKN3qos16GlobalQosFlowInd10IndicationE_block_invoke;
            *((_QWORD *)&v40 + 1) = &unk_24D5EB6E8;
            *(_QWORD *)&v41 = buf;
            *((_QWORD *)&v41 + 1) = v2;
            if (v24 != v25)
            {
              v26 = v24;
              do
              {
                ((void (*)(void **, char *))v40)(__p, v26);
                v26 += 176;
              }
              while (v26 != v25);
            }
          }
          if (v24)
            operator delete(v24);
        }
        v44 = (unsigned __int8 *)qmi::MessageBase::findTlvValue(a2);
        v45 = v27;
        if (v44)
        {
          tlv::parseV<qos::tlv::RxQosFilterSpecList>(&v44, v27, (uint64_t *)&TlvValue);
          v28 = (unsigned __int8 *)TlvValue;
          if (v44)
          {
            v29 = (unsigned __int8 *)v34;
            TlvValue = (void *)MEMORY[0x24BDAC760];
            v34 = 0x40000000;
            v35 = ___ZNK14QMIQOSClientIP27handleGlobalQosFlowInd_syncERKN3qos16GlobalQosFlowInd10IndicationE_block_invoke_2;
            v36 = &unk_24D5EB710;
            v37 = buf;
            v38 = v2;
            if (v28 != v29)
            {
              v30 = v28;
              do
              {
                v35((uint64_t)&TlvValue, v30);
                v30 += 176;
              }
              while (v30 != v29);
            }
          }
          if (v28)
            operator delete(v28);
        }
        v44 = (unsigned __int8 *)qmi::MessageBase::findTlvValue(a2);
        v45 = v31;
        if (v44)
        {
          v32 = tlv::parseV<qos::tlv::BearerId>((unint64_t *)&v44, v31);
          if (v44)
            *(_DWORD *)(*(_QWORD *)&buf[8] + 44) = v32;
        }
        if (v9 >= 2)
        {
          if (v9 == 2)
            (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)(v2 + 64) + 88))(*(_QWORD *)(v2 + 64), *(unsigned int *)(*(_QWORD *)&buf[8] + 40));
        }
        else
        {
          (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(v2 + 64) + 80))(*(_QWORD *)(v2 + 64), *(_QWORD *)&buf[8] + 40);
        }
        _Block_object_dispose(buf, 8);
        if (BYTE8(v54) && (_BYTE)v54)
        {
          v44 = &v53[8];
          std::vector<DataIPFilter>::__destroy_vector::operator()[abi:ne180100]((void ***)&v44);
        }
        if (BYTE8(v51))
        {
          if ((_BYTE)v51)
          {
            v44 = &v50[8];
            std::vector<DataIPFilter>::__destroy_vector::operator()[abi:ne180100]((void ***)&v44);
          }
        }
      }
    }
  }
}

void sub_216A88C3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void **a26,uint64_t a27,void **a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,char a42,int a43,char a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,char a51,int a52,char a53)
{
  if (a21)
    std::vector<DataIPFilter>::__destroy_vector::operator()[abi:ne180100](&a26);
  _Block_object_dispose(&a29, 8);
  if (a53 && a51)
  {
    a28 = (void **)&a48;
    std::vector<DataIPFilter>::__destroy_vector::operator()[abi:ne180100](&a28);
  }
  if (a44)
  {
    if (a42)
    {
      a28 = (void **)&a39;
      std::vector<DataIPFilter>::__destroy_vector::operator()[abi:ne180100](&a28);
    }
  }
  _Unwind_Resume(a1);
}

void QMIQOSClientIP::releaseQoSClient(QMIQOSClientIP *this)
{
  uint64_t v2;
  char *v3;
  NSObject *v4;
  const char *v5;
  __int128 v6;
  __int128 v7;

  v3 = (char *)this + 88;
  v2 = *((_QWORD *)this + 11);
  *((_BYTE *)this + 109) = 0;
  if (v2)
  {
    qmi::Client::stop((QMIQOSClientIP *)((char *)this + 72));
    v6 = 0u;
    v7 = 0u;
    std::shared_ptr<qmi::Client::State>::operator=[abi:ne180100]((uint64_t)v3, &v7);
    qmi::Client::~Client((qmi::Client *)&v6);
    v4 = *((_QWORD *)this + 5);
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      return;
    LOWORD(v6) = 0;
    v5 = "#I fQOSClient deleted";
  }
  else
  {
    v4 = *((_QWORD *)this + 5);
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      return;
    LOWORD(v6) = 0;
    v5 = "#I Null fQOSClient";
  }
  _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, v5, (uint8_t *)&v6, 2u);
}

void QMIQOSClientIP::~QMIQOSClientIP(QMIQOSClientIP *this)
{
  qmi::Client *v2;

  *(_QWORD *)this = &off_24D5EB440;
  *((_BYTE *)this + 109) = 0;
  v2 = (QMIQOSClientIP *)((char *)this + 72);
  if (*((_QWORD *)this + 11))
    qmi::Client::stop((QMIQOSClientIP *)((char *)this + 72));
  xpc_release(*((xpc_object_t *)this + 17));
  *((_QWORD *)this + 17) = 0;
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)this + 120);
  qmi::Client::~Client(v2);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)this + 48);
  MEMORY[0x2199FDF6C]((char *)this + 40);
  ctu::SharedSynchronizable<QMIDataSystemDeterminationManager>::~SharedSynchronizable((_QWORD *)this + 1);
}

{
  QMIQOSClientIP::~QMIQOSClientIP(this);
  JUMPOUT(0x2199FEAC4);
}

uint64_t ___ZN14QMIQOSClientIP21bindSubscription_syncENSt3__18functionIFvvEEE_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  NSObject *v4;
  uint64_t v6;
  int v7;
  uint64_t v8;
  int v10;
  uint64_t v11;
  __int16 v12;
  int v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 + 32);
  v4 = *(NSObject **)(v3 + 40);
  if (*(_DWORD *)(a2 + 4))
  {
    if (os_log_type_enabled(*(os_log_t *)(v3 + 40), OS_LOG_TYPE_ERROR))
    {
      v6 = qmi::asString();
      v7 = *(_DWORD *)(a2 + 4);
      v10 = 136315394;
      v11 = v6;
      v12 = 1024;
      v13 = v7;
      _os_log_error_impl(&dword_216897000, v4, OS_LOG_TYPE_ERROR, "Binding subscription: %s (0x%x)", (uint8_t *)&v10, 0x12u);
    }
  }
  else if (os_log_type_enabled(*(os_log_t *)(v3 + 40), OS_LOG_TYPE_DEFAULT))
  {
    v10 = 136315138;
    v11 = subscriber::asString();
    _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I QoS bound: subscription: %s", (uint8_t *)&v10, 0xCu);
  }
  v8 = *(_QWORD *)(a1 + 64);
  if (!v8)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v8 + 48))(v8);
}

uint64_t ___ZN14QMIQOSClientIP17bindDataPort_syncEv_block_invoke(uint64_t a1, _WORD *a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 32) + 64) + 64))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 64));
  *a2 = result;
  return result;
}

uint64_t ___ZN14QMIQOSClientIP17bindDataPort_syncEv_block_invoke_2(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  NSObject *v5;
  uint64_t v6;
  _DWORD v7[2];
  __int16 v8;
  uint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(result + 32);
  if (!*(_BYTE *)(v2 + 108))
  {
    v3 = result;
    v4 = *(_DWORD *)(a2 + 4);
    v5 = *(NSObject **)(v2 + 40);
    if (v4)
    {
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        v7[0] = 67109378;
        v7[1] = v4;
        v8 = 2080;
        v9 = qmi::asString();
        _os_log_error_impl(&dword_216897000, v5, OS_LOG_TYPE_ERROR, "Error in response to BindDataPort with code = 0x%x (%s)", (uint8_t *)v7, 0x12u);
      }
    }
    else if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v7[0]) = 0;
      _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#I Response to BindDataPort received", (uint8_t *)v7, 2u);
    }
    v6 = *(_QWORD *)(v3 + 64);
    if (!v6)
      std::__throw_bad_function_call[abi:ne180100]();
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 48))(v6);
  }
  return result;
}

uint64_t ___ZN14QMIQOSClientIP17bindDataPort_syncEv_block_invoke_80(uint64_t a1, _BYTE *a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 32) + 64) + 64))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 64));
  *a2 = result + 1;
  return result;
}

uint64_t ___ZN14QMIQOSClientIP17bindDataPort_syncEv_block_invoke_2_83(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  NSObject *v5;
  uint64_t v6;
  _DWORD v7[2];
  __int16 v8;
  uint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(result + 32);
  if (!*(_BYTE *)(v2 + 108))
  {
    v3 = result;
    v4 = *(_DWORD *)(a2 + 4);
    v5 = *(NSObject **)(v2 + 40);
    if (v4)
    {
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        v7[0] = 67109378;
        v7[1] = v4;
        v8 = 2080;
        v9 = qmi::asString();
        _os_log_error_impl(&dword_216897000, v5, OS_LOG_TYPE_ERROR, "Error in response to BindDataPort with code = 0x%x (%s)", (uint8_t *)v7, 0x12u);
      }
    }
    else if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v7[0]) = 0;
      _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#I Response to BindDataPort received", (uint8_t *)v7, 2u);
    }
    v6 = *(_QWORD *)(v3 + 64);
    if (!v6)
      std::__throw_bad_function_call[abi:ne180100]();
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 48))(v6);
  }
  return result;
}

void ___ZN14QMIQOSClientIP14setupQMIClientEv_block_invoke_92(uint64_t a1, uint64_t a2)
{
  int v2;
  NSObject *v3;
  _DWORD v4[2];
  __int16 v5;
  uint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v2 = *(_DWORD *)(a2 + 4);
  v3 = *(NSObject **)(*(_QWORD *)(a1 + 32) + 40);
  if (v2)
  {
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      v4[0] = 67109378;
      v4[1] = v2;
      v5 = 2080;
      v6 = qmi::asString();
      _os_log_error_impl(&dword_216897000, v3, OS_LOG_TYPE_ERROR, "Error in response to SetIpClientFamily with code = 0x%x (%s)", (uint8_t *)v4, 0x12u);
    }
  }
  else if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v4[0]) = 0;
    _os_log_impl(&dword_216897000, v3, OS_LOG_TYPE_DEFAULT, "#I Response to SetIpClientFamily received", (uint8_t *)v4, 2u);
  }
}

void ___ZN14QMIQOSClientIP14setupQMIClientEv_block_invoke_3(uint64_t a1, uint64_t a2)
{
  int v2;
  NSObject *v3;
  _DWORD v4[2];
  __int16 v5;
  uint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v2 = *(_DWORD *)(a2 + 4);
  v3 = *(NSObject **)(*(_QWORD *)(a1 + 32) + 40);
  if (v2)
  {
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      v4[0] = 67109378;
      v4[1] = v2;
      v5 = 2080;
      v6 = qmi::asString();
      _os_log_error_impl(&dword_216897000, v3, OS_LOG_TYPE_ERROR, "Error in response to SetEventReport with code = 0x%x (%s)", (uint8_t *)v4, 0x12u);
    }
  }
  else if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v4[0]) = 0;
    _os_log_impl(&dword_216897000, v3, OS_LOG_TYPE_DEFAULT, "#I Response to SetEventReport received", (uint8_t *)v4, 2u);
  }
}

void ___ZN14QMIQOSClientIP14setupQMIClientEv_block_invoke_4(uint64_t a1, uint64_t a2)
{
  int v2;
  NSObject *v3;
  _DWORD v4[2];
  __int16 v5;
  uint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v2 = *(_DWORD *)(a2 + 4);
  v3 = *(NSObject **)(*(_QWORD *)(a1 + 32) + 40);
  if (v2)
  {
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      v4[0] = 67109378;
      v4[1] = v2;
      v5 = 2080;
      v6 = qmi::asString();
      _os_log_error_impl(&dword_216897000, v3, OS_LOG_TYPE_ERROR, "Error in response to IndicationRegister with code = 0x%x (%s)", (uint8_t *)v4, 0x12u);
    }
  }
  else if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v4[0]) = 0;
    _os_log_impl(&dword_216897000, v3, OS_LOG_TYPE_DEFAULT, "#I Response to IndicationRegister received", (uint8_t *)v4, 2u);
  }
}

uint64_t QMIQOSClientIP::shutDownQMIQOSClientIP(uint64_t this)
{
  *(_BYTE *)(this + 108) = 1;
  return this;
}

void QMIQOSClientIP::dumpState(QMIQOSClientIP *this)
{
  NSObject *v1;
  uint8_t v2[16];

  v1 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v2 = 0;
    _os_log_impl(&dword_216897000, v1, OS_LOG_TYPE_DEFAULT, "#I DATA:: start", v2, 2u);
  }
}

void QMIQOSClientIP::FilterSpecToDict(QMIQOSClientIP *this, const qos::tlv::QoSFilter *a2, DataIPFilter *a3)
{
  __int16 v5;
  __int16 v6;
  unsigned int v7;
  __int16 v8;
  __int16 v9;
  unsigned int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  __n128 __p;
  char v17;
  char v18;
  __int16 v19;
  char v20;
  char v21;
  char v22;
  char v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unsigned __int8 v27[24];
  uint64_t v28;

  v28 = *MEMORY[0x24BDAC8D0];
  if (*((_BYTE *)this + 116))
  {
    *((_DWORD *)a2 + 7) = 4;
    v24 = 0;
    v25 = 0;
    v26 = 0;
    CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)&v24);
    CSIPacketAddress::setIPv4AddressLE((CSIPacketAddress *)&v24);
    if (!*((_BYTE *)a2 + 80))
    {
      __p.n128_u8[0] = 0;
      v18 = 0;
      v19 = 0;
      v20 = 0;
      v21 = 0;
      v22 = 0;
      v23 = 0;
      std::optional<DataIPFilterEndpoint>::operator=[abi:ne180100]<DataIPFilterEndpoint,void>((uint64_t)a2 + 32, &__p);
      if (v18)
      {
        if (v17 < 0)
          operator delete((void *)__p.n128_u64[0]);
      }
    }
    CSIPacketAddress::operator std::string();
    if (!*((_BYTE *)a2 + 80))
      std::__throw_bad_optional_access[abi:ne180100]();
    std::optional<std::string>::operator=[abi:ne180100]<std::string,void>((uint64_t)a2 + 32, (__int128 *)&__p);
    if (v17 < 0)
      operator delete((void *)__p.n128_u64[0]);
    CSIPacketAddress::setIPv4AddressLE((CSIPacketAddress *)&v24);
    v5 = CSIPacketAddress::maskToPrefix((CSIPacketAddress *)&v24);
    if (!*((_BYTE *)a2 + 80))
      std::__throw_bad_optional_access[abi:ne180100]();
    *((_WORD *)a2 + 32) = v5 | 0x100;
  }
  if (*((_BYTE *)this + 104))
  {
    *((_DWORD *)a2 + 7) = 4;
    v24 = 0;
    v25 = 0;
    v26 = 0;
    CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)&v24);
    CSIPacketAddress::setIPv4AddressLE((CSIPacketAddress *)&v24);
    if (!*((_BYTE *)a2 + 136))
    {
      __p.n128_u8[0] = 0;
      v18 = 0;
      v19 = 0;
      v20 = 0;
      v21 = 0;
      v22 = 0;
      v23 = 0;
      std::optional<DataIPFilterEndpoint>::operator=[abi:ne180100]<DataIPFilterEndpoint,void>((uint64_t)a2 + 88, &__p);
      if (v18)
      {
        if (v17 < 0)
          operator delete((void *)__p.n128_u64[0]);
      }
    }
    CSIPacketAddress::operator std::string();
    if (!*((_BYTE *)a2 + 136))
      std::__throw_bad_optional_access[abi:ne180100]();
    std::optional<std::string>::operator=[abi:ne180100]<std::string,void>((uint64_t)a2 + 88, (__int128 *)&__p);
    if (v17 < 0)
      operator delete((void *)__p.n128_u64[0]);
    CSIPacketAddress::setIPv4AddressLE((CSIPacketAddress *)&v24);
    v6 = CSIPacketAddress::maskToPrefix((CSIPacketAddress *)&v24);
    if (!*((_BYTE *)a2 + 136))
      std::__throw_bad_optional_access[abi:ne180100]();
    *((_WORD *)a2 + 60) = v6 | 0x100;
  }
  if (*((_BYTE *)this + 63))
  {
    v7 = *((unsigned __int16 *)this + 32);
    *((_DWORD *)a2 + 7) = 4;
    *((_WORD *)a2 + 72) = v7 | 0x100;
    *((_WORD *)a2 + 73) = (v7 >> 8) | 0x100;
  }
  if (*((_BYTE *)this + 86))
  {
    *(_OWORD *)v27 = *(_OWORD *)((char *)this + 87);
    v8 = *((unsigned __int8 *)this + 103);
    *((_DWORD *)a2 + 7) = 41;
    v24 = 0;
    v25 = 0;
    v26 = 0;
    CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)&v24);
    CSIPacketAddress::setIPv6Address((CSIPacketAddress *)&v24, v27);
    if (!*((_BYTE *)a2 + 80))
    {
      __p.n128_u8[0] = 0;
      v18 = 0;
      v19 = 0;
      v20 = 0;
      v21 = 0;
      v22 = 0;
      v23 = 0;
      std::optional<DataIPFilterEndpoint>::operator=[abi:ne180100]<DataIPFilterEndpoint,void>((uint64_t)a2 + 32, &__p);
      if (v18)
      {
        if (v17 < 0)
          operator delete((void *)__p.n128_u64[0]);
      }
    }
    CSIPacketAddress::operator std::string();
    if (!*((_BYTE *)a2 + 80))
      std::__throw_bad_optional_access[abi:ne180100]();
    std::optional<std::string>::operator=[abi:ne180100]<std::string,void>((uint64_t)a2 + 32, (__int128 *)&__p);
    if (v17 < 0)
      operator delete((void *)__p.n128_u64[0]);
    if (!*((_BYTE *)a2 + 80))
      std::__throw_bad_optional_access[abi:ne180100]();
    *((_WORD *)a2 + 32) = v8 | 0x100;
  }
  if (*((_BYTE *)this + 68))
  {
    *(_OWORD *)v27 = *(_OWORD *)((char *)this + 69);
    v9 = *((unsigned __int8 *)this + 85);
    *((_DWORD *)a2 + 7) = 41;
    v24 = 0;
    v25 = 0;
    v26 = 0;
    CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)&v24);
    CSIPacketAddress::setIPv6Address((CSIPacketAddress *)&v24, v27);
    if (!*((_BYTE *)a2 + 136))
    {
      __p.n128_u8[0] = 0;
      v18 = 0;
      v19 = 0;
      v20 = 0;
      v21 = 0;
      v22 = 0;
      v23 = 0;
      std::optional<DataIPFilterEndpoint>::operator=[abi:ne180100]<DataIPFilterEndpoint,void>((uint64_t)a2 + 88, &__p);
      if (v18)
      {
        if (v17 < 0)
          operator delete((void *)__p.n128_u64[0]);
      }
    }
    CSIPacketAddress::operator std::string();
    if (!*((_BYTE *)a2 + 136))
      std::__throw_bad_optional_access[abi:ne180100]();
    std::optional<std::string>::operator=[abi:ne180100]<std::string,void>((uint64_t)a2 + 88, (__int128 *)&__p);
    if (v17 < 0)
      operator delete((void *)__p.n128_u64[0]);
    if (!*((_BYTE *)a2 + 136))
      std::__throw_bad_optional_access[abi:ne180100]();
    *((_WORD *)a2 + 60) = v9 | 0x100;
  }
  if (*((_BYTE *)this + 60))
  {
    v10 = *(unsigned __int16 *)((char *)this + 61);
    *((_DWORD *)a2 + 7) = 41;
    *((_WORD *)a2 + 72) = v10 | 0x100;
    *((_WORD *)a2 + 73) = (v10 >> 8) | 0x100;
  }
  if (*((_BYTE *)this + 52))
  {
    v11 = *((_DWORD *)this + 14);
    *((_DWORD *)a2 + 7) = 41;
    *((_DWORD *)a2 + 37) = v11;
    *((_BYTE *)a2 + 152) = 1;
  }
  if (*((_BYTE *)this + 46))
  {
    v12 = *((_DWORD *)this + 12);
    *((_DWORD *)a2 + 6) = 6;
    if (!*((_BYTE *)a2 + 80))
    {
      __p.n128_u8[0] = 0;
      v18 = 0;
      v19 = 0;
      v20 = 0;
      v21 = 0;
      v22 = 0;
      v23 = 0;
      std::optional<DataIPFilterEndpoint>::operator=[abi:ne180100]<DataIPFilterEndpoint,void>((uint64_t)a2 + 32, &__p);
      if (v18 && v17 < 0)
        operator delete((void *)__p.n128_u64[0]);
      if (!*((_BYTE *)a2 + 80))
        std::__throw_bad_optional_access[abi:ne180100]();
    }
    *((_WORD *)a2 + 33) = v12;
    *((_BYTE *)a2 + 68) = 1;
    *((_WORD *)a2 + 35) = HIWORD(v12);
    *((_BYTE *)a2 + 72) = 1;
  }
  if (*((_BYTE *)this + 40))
  {
    v13 = *(_DWORD *)((char *)this + 42);
    *((_DWORD *)a2 + 6) = 6;
    if (!*((_BYTE *)a2 + 136))
    {
      __p.n128_u8[0] = 0;
      v18 = 0;
      v19 = 0;
      v20 = 0;
      v21 = 0;
      v22 = 0;
      v23 = 0;
      std::optional<DataIPFilterEndpoint>::operator=[abi:ne180100]<DataIPFilterEndpoint,void>((uint64_t)a2 + 88, &__p);
      if (v18 && v17 < 0)
        operator delete((void *)__p.n128_u64[0]);
      if (!*((_BYTE *)a2 + 136))
        std::__throw_bad_optional_access[abi:ne180100]();
    }
    *((_WORD *)a2 + 61) = v13;
    *((_BYTE *)a2 + 124) = 1;
    *((_WORD *)a2 + 63) = HIWORD(v13);
    *((_BYTE *)a2 + 128) = 1;
  }
  if (*((_BYTE *)this + 34))
  {
    v14 = *((_DWORD *)this + 9);
    *((_DWORD *)a2 + 6) = 17;
    if (!*((_BYTE *)a2 + 80))
    {
      __p.n128_u8[0] = 0;
      v18 = 0;
      v19 = 0;
      v20 = 0;
      v21 = 0;
      v22 = 0;
      v23 = 0;
      std::optional<DataIPFilterEndpoint>::operator=[abi:ne180100]<DataIPFilterEndpoint,void>((uint64_t)a2 + 32, &__p);
      if (v18 && v17 < 0)
        operator delete((void *)__p.n128_u64[0]);
      if (!*((_BYTE *)a2 + 80))
        std::__throw_bad_optional_access[abi:ne180100]();
    }
    *((_WORD *)a2 + 33) = v14;
    *((_BYTE *)a2 + 68) = 1;
    *((_WORD *)a2 + 35) = HIWORD(v14);
    *((_BYTE *)a2 + 72) = 1;
  }
  if (*((_BYTE *)this + 28))
  {
    v15 = *(_DWORD *)((char *)this + 30);
    *((_DWORD *)a2 + 6) = 17;
    if (!*((_BYTE *)a2 + 136))
    {
      __p.n128_u8[0] = 0;
      v18 = 0;
      v19 = 0;
      v20 = 0;
      v21 = 0;
      v22 = 0;
      v23 = 0;
      std::optional<DataIPFilterEndpoint>::operator=[abi:ne180100]<DataIPFilterEndpoint,void>((uint64_t)a2 + 88, &__p);
      if (v18 && v17 < 0)
        operator delete((void *)__p.n128_u64[0]);
      if (!*((_BYTE *)a2 + 136))
        std::__throw_bad_optional_access[abi:ne180100]();
    }
    *((_WORD *)a2 + 61) = v15;
    *((_BYTE *)a2 + 124) = 1;
    *((_WORD *)a2 + 63) = HIWORD(v15);
    *((_BYTE *)a2 + 128) = 1;
  }
  if (*((_BYTE *)this + 4))
    *((_DWORD *)a2 + 5) = *((unsigned __int16 *)this + 3);
  if (*(_BYTE *)this)
    *(_DWORD *)a2 = *((unsigned __int16 *)this + 1);
}

void sub_216A89BD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  _Unwind_Resume(exception_object);
}

uint64_t std::optional<DataIPFilterEndpoint>::operator=[abi:ne180100]<DataIPFilterEndpoint,void>(uint64_t a1, __n128 *a2)
{
  unint64_t v4;
  __n128 v5;
  unint64_t v6;

  if (*(_BYTE *)(a1 + 48))
  {
    std::__optional_storage_base<std::string,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<std::string,false>>(a1, a2);
    v4 = a2[2].n128_u64[0];
    *(_BYTE *)(a1 + 40) = a2[2].n128_u8[8];
    *(_QWORD *)(a1 + 32) = v4;
  }
  else
  {
    *(_BYTE *)a1 = 0;
    *(_BYTE *)(a1 + 24) = 0;
    if (a2[1].n128_u8[8])
    {
      v5 = *a2;
      *(_QWORD *)(a1 + 16) = a2[1].n128_u64[0];
      *(__n128 *)a1 = v5;
      a2->n128_u64[1] = 0;
      a2[1].n128_u64[0] = 0;
      a2->n128_u64[0] = 0;
      *(_BYTE *)(a1 + 24) = 1;
    }
    v6 = a2[2].n128_u64[0];
    *(_BYTE *)(a1 + 40) = a2[2].n128_u8[8];
    *(_QWORD *)(a1 + 32) = v6;
    *(_BYTE *)(a1 + 48) = 1;
  }
  return a1;
}

void QMIQOSClientIP::mav20FilterSpecToDict(unsigned __int8 *a1, uint64_t a2)
{
  int v4;
  uint64_t v5;
  __int16 v6;
  __int16 v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  void *v12[2];
  char v13;
  __n128 __p;
  uint64_t v15;
  char v16;
  __int16 v17;
  char v18;
  char v19;
  char v20;
  char v21;
  unsigned __int8 v22[24];
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  v4 = *a1;
  if (v4 == 6)
  {
    *(_DWORD *)(a2 + 28) = 41;
    v8 = *((_QWORD *)a1 + 5);
    if ((v8 & 1) != 0)
    {
      if (!*(_BYTE *)(a2 + 80))
      {
        __p.n128_u8[0] = 0;
        v16 = 0;
        v17 = 0;
        v18 = 0;
        v19 = 0;
        v20 = 0;
        v21 = 0;
        std::optional<DataIPFilterEndpoint>::operator=[abi:ne180100]<DataIPFilterEndpoint,void>(a2 + 32, &__p);
        if (v16)
        {
          if (SHIBYTE(v15) < 0)
            operator delete((void *)__p.n128_u64[0]);
        }
      }
      *(_OWORD *)v22 = *((_OWORD *)a1 + 3);
      __p = 0uLL;
      v15 = 0;
      CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)&__p);
      CSIPacketAddress::setIPv6Address((CSIPacketAddress *)&__p, v22);
      CSIPacketAddress::operator std::string();
      if (!*(_BYTE *)(a2 + 80))
        std::__throw_bad_optional_access[abi:ne180100]();
      std::optional<std::string>::operator=[abi:ne180100]<std::string,void>(a2 + 32, (__int128 *)v12);
      if (v13 < 0)
        operator delete(v12[0]);
      if (!*(_BYTE *)(a2 + 80))
        std::__throw_bad_optional_access[abi:ne180100]();
      *(_WORD *)(a2 + 64) = a1[81] | 0x100;
      v8 = *((_QWORD *)a1 + 5);
    }
    if ((v8 & 2) != 0)
    {
      if (!*(_BYTE *)(a2 + 136))
      {
        __p.n128_u8[0] = 0;
        v16 = 0;
        v17 = 0;
        v18 = 0;
        v19 = 0;
        v20 = 0;
        v21 = 0;
        std::optional<DataIPFilterEndpoint>::operator=[abi:ne180100]<DataIPFilterEndpoint,void>(a2 + 88, &__p);
        if (v16)
        {
          if (SHIBYTE(v15) < 0)
            operator delete((void *)__p.n128_u64[0]);
        }
      }
      *(_OWORD *)v22 = *(_OWORD *)(a1 + 65);
      __p = 0uLL;
      v15 = 0;
      CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)&__p);
      CSIPacketAddress::setIPv6Address((CSIPacketAddress *)&__p, v22);
      CSIPacketAddress::operator std::string();
      if (!*(_BYTE *)(a2 + 136))
        std::__throw_bad_optional_access[abi:ne180100]();
      std::optional<std::string>::operator=[abi:ne180100]<std::string,void>(a2 + 88, (__int128 *)v12);
      if (v13 < 0)
        operator delete(v12[0]);
      if (!*(_BYTE *)(a2 + 136))
        std::__throw_bad_optional_access[abi:ne180100]();
      *(_WORD *)(a2 + 120) = a1[81] | 0x100;
      v8 = *((_QWORD *)a1 + 5);
    }
    if ((v8 & 4) != 0)
    {
      *(_WORD *)(a2 + 144) = a1[82] | 0x100;
      *(_WORD *)(a2 + 146) = a1[83] | 0x100;
      v8 = *((_QWORD *)a1 + 5);
    }
    if ((v8 & 8) != 0)
    {
      *(_DWORD *)(a2 + 148) = *((_DWORD *)a1 + 21);
      *(_BYTE *)(a2 + 152) = 1;
    }
  }
  else if (v4 == 4)
  {
    *(_DWORD *)(a2 + 28) = 4;
    v5 = *((_QWORD *)a1 + 1);
    if ((v5 & 1) != 0)
    {
      if (!*(_BYTE *)(a2 + 80))
      {
        __p.n128_u8[0] = 0;
        v16 = 0;
        v17 = 0;
        v18 = 0;
        v19 = 0;
        v20 = 0;
        v21 = 0;
        std::optional<DataIPFilterEndpoint>::operator=[abi:ne180100]<DataIPFilterEndpoint,void>(a2 + 32, &__p);
        if (v16)
        {
          if (SHIBYTE(v15) < 0)
            operator delete((void *)__p.n128_u64[0]);
        }
      }
      __p = 0uLL;
      v15 = 0;
      CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)&__p);
      CSIPacketAddress::setIPv4AddressLE((CSIPacketAddress *)&__p);
      CSIPacketAddress::operator std::string();
      if (!*(_BYTE *)(a2 + 80))
        std::__throw_bad_optional_access[abi:ne180100]();
      std::optional<std::string>::operator=[abi:ne180100]<std::string,void>(a2 + 32, (__int128 *)v12);
      if (v13 < 0)
        operator delete(v12[0]);
      CSIPacketAddress::setIPv4AddressLE((CSIPacketAddress *)&__p);
      v6 = CSIPacketAddress::maskToPrefix((CSIPacketAddress *)&__p);
      if (!*(_BYTE *)(a2 + 80))
        std::__throw_bad_optional_access[abi:ne180100]();
      *(_WORD *)(a2 + 64) = v6 | 0x100;
      v5 = *((_QWORD *)a1 + 1);
    }
    if ((v5 & 2) != 0)
    {
      if (!*(_BYTE *)(a2 + 136))
      {
        __p.n128_u8[0] = 0;
        v16 = 0;
        v17 = 0;
        v18 = 0;
        v19 = 0;
        v20 = 0;
        v21 = 0;
        std::optional<DataIPFilterEndpoint>::operator=[abi:ne180100]<DataIPFilterEndpoint,void>(a2 + 88, &__p);
        if (v16)
        {
          if (SHIBYTE(v15) < 0)
            operator delete((void *)__p.n128_u64[0]);
        }
      }
      __p = 0uLL;
      v15 = 0;
      CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)&__p);
      CSIPacketAddress::setIPv4AddressLE((CSIPacketAddress *)&__p);
      CSIPacketAddress::operator std::string();
      if (!*(_BYTE *)(a2 + 136))
        std::__throw_bad_optional_access[abi:ne180100]();
      std::optional<std::string>::operator=[abi:ne180100]<std::string,void>(a2 + 88, (__int128 *)v12);
      if (v13 < 0)
        operator delete(v12[0]);
      CSIPacketAddress::setIPv4AddressLE((CSIPacketAddress *)&__p);
      v7 = CSIPacketAddress::maskToPrefix((CSIPacketAddress *)&__p);
      if (!*(_BYTE *)(a2 + 136))
        std::__throw_bad_optional_access[abi:ne180100]();
      *(_WORD *)(a2 + 120) = v7 | 0x100;
      v5 = *((_QWORD *)a1 + 1);
    }
    if ((v5 & 4) != 0)
    {
      *(_WORD *)(a2 + 144) = a1[32] | 0x100;
      *(_WORD *)(a2 + 146) = a1[33] | 0x100;
    }
  }
  v9 = *((_DWORD *)a1 + 22);
  if (v9 == 6)
  {
    *(_DWORD *)(a2 + 24) = 6;
    v10 = *((_QWORD *)a1 + 12);
    if ((v10 & 1) != 0)
    {
      if (!*(_BYTE *)(a2 + 80))
      {
        __p.n128_u8[0] = 0;
        v16 = 0;
        v17 = 0;
        v18 = 0;
        v19 = 0;
        v20 = 0;
        v21 = 0;
        std::optional<DataIPFilterEndpoint>::operator=[abi:ne180100]<DataIPFilterEndpoint,void>(a2 + 32, &__p);
        if (v16 && SHIBYTE(v15) < 0)
          operator delete((void *)__p.n128_u64[0]);
        if (!*(_BYTE *)(a2 + 80))
          std::__throw_bad_optional_access[abi:ne180100]();
      }
      *(_WORD *)(a2 + 66) = *((_WORD *)a1 + 52);
      *(_BYTE *)(a2 + 68) = 1;
      *(_WORD *)(a2 + 70) = *((_WORD *)a1 + 53);
      *(_BYTE *)(a2 + 72) = 1;
      v10 = *((_QWORD *)a1 + 12);
    }
    if ((v10 & 2) != 0)
    {
      if (!*(_BYTE *)(a2 + 136))
      {
        __p.n128_u8[0] = 0;
        v16 = 0;
        v17 = 0;
        v18 = 0;
        v19 = 0;
        v20 = 0;
        v21 = 0;
        std::optional<DataIPFilterEndpoint>::operator=[abi:ne180100]<DataIPFilterEndpoint,void>(a2 + 88, &__p);
        if (v16 && SHIBYTE(v15) < 0)
          operator delete((void *)__p.n128_u64[0]);
        if (!*(_BYTE *)(a2 + 136))
          std::__throw_bad_optional_access[abi:ne180100]();
      }
      *(_WORD *)(a2 + 122) = *((_WORD *)a1 + 54);
      *(_BYTE *)(a2 + 124) = 1;
      *(_WORD *)(a2 + 126) = *((_WORD *)a1 + 55);
      *(_BYTE *)(a2 + 128) = 1;
    }
    v9 = *((_DWORD *)a1 + 22);
  }
  if (v9 == 17)
  {
    *(_DWORD *)(a2 + 24) = 17;
    v11 = *((_QWORD *)a1 + 14);
    if ((v11 & 1) != 0)
    {
      if (!*(_BYTE *)(a2 + 80))
      {
        __p.n128_u8[0] = 0;
        v16 = 0;
        v17 = 0;
        v18 = 0;
        v19 = 0;
        v20 = 0;
        v21 = 0;
        std::optional<DataIPFilterEndpoint>::operator=[abi:ne180100]<DataIPFilterEndpoint,void>(a2 + 32, &__p);
        if (v16 && SHIBYTE(v15) < 0)
          operator delete((void *)__p.n128_u64[0]);
        if (!*(_BYTE *)(a2 + 80))
          std::__throw_bad_optional_access[abi:ne180100]();
      }
      *(_WORD *)(a2 + 66) = *((_WORD *)a1 + 60);
      *(_BYTE *)(a2 + 68) = 1;
      *(_WORD *)(a2 + 70) = *((_WORD *)a1 + 61);
      *(_BYTE *)(a2 + 72) = 1;
      v11 = *((_QWORD *)a1 + 14);
    }
    if ((v11 & 2) != 0)
    {
      if (!*(_BYTE *)(a2 + 136))
      {
        __p.n128_u8[0] = 0;
        v16 = 0;
        v17 = 0;
        v18 = 0;
        v19 = 0;
        v20 = 0;
        v21 = 0;
        std::optional<DataIPFilterEndpoint>::operator=[abi:ne180100]<DataIPFilterEndpoint,void>(a2 + 88, &__p);
        if (v16 && SHIBYTE(v15) < 0)
          operator delete((void *)__p.n128_u64[0]);
        if (!*(_BYTE *)(a2 + 136))
          std::__throw_bad_optional_access[abi:ne180100]();
      }
      *(_WORD *)(a2 + 122) = *((_WORD *)a1 + 62);
      *(_BYTE *)(a2 + 124) = 1;
      *(_WORD *)(a2 + 126) = *((_WORD *)a1 + 63);
      *(_BYTE *)(a2 + 128) = 1;
    }
  }
  *(_DWORD *)a2 = *((unsigned __int16 *)a1 + 86);
  *(_DWORD *)(a2 + 20) = *((unsigned __int16 *)a1 + 87);
}

void sub_216A8A30C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void ___ZNK14QMIQOSClientIP28handleQOSEventReportInd_syncERKN3qos14EventReportInd10IndicationE_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  __int128 v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  _QWORD v11[2];
  void (*v12)(uint64_t, QMIQOSClientIP *, DataIPFilter *);
  void *v13;
  uint64_t *v14;
  uint64_t v15;
  _QWORD v16[2];
  void (*v17)(uint64_t, QMIQOSClientIP *, DataIPFilter *);
  void *v18;
  uint64_t *v19;
  uint64_t v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t (*v28)(uint64_t, uint64_t);
  void (*v29)(uint64_t);
  __int128 v30;
  __int128 v31;
  _BYTE v32[32];
  __int128 v33;
  __int128 v34;
  _BYTE v35[32];
  __int128 v36;
  uint64_t v37;
  void **v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  uint64_t v47;
  uint64_t v48;

  v48 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 + 32);
  v25 = 0;
  v26 = &v25;
  v27 = 0xC002000000;
  v28 = __Block_byref_object_copy__11;
  v29 = __Block_byref_object_dispose__11;
  v37 = 256;
  v4 = 0uLL;
  v30 = 0u;
  v31 = 0u;
  memset(v32, 0, sizeof(v32));
  v33 = 0u;
  v34 = 0u;
  memset(v35, 0, sizeof(v35));
  v36 = 0u;
  LODWORD(v30) = *(_DWORD *)a2;
  v47 = 0;
  v45 = 0u;
  v46 = 0u;
  v43 = 0u;
  v44 = 0u;
  v41 = 0u;
  v42 = 0u;
  v39 = 0u;
  v40 = 0u;
  if (*(_BYTE *)(a2 + 208))
  {
    qos::tlv::FlowSpec::FlowSpec((qos::tlv::FlowSpec *)((char *)&v39 + 8), (const qos::tlv::FlowSpec *)(a2 + 216));
    LOBYTE(v39) = 1;
    v24 = 0;
    v22 = 0u;
    v23 = 0u;
    v21 = 0u;
    if (BYTE12(v40))
    {
      DWORD2(v21) = v41;
      BYTE12(v21) = 1;
      LODWORD(v22) = DWORD1(v41);
      BYTE4(v22) = 1;
    }
    if (BYTE14(v46))
    {
      BYTE4(v21) = 1;
      LODWORD(v21) = HIBYTE(v46);
    }
    std::optional<DataQoS>::operator=[abi:ne180100]<DataQoS&,void>((uint64_t)(v26 + 7), (uint64_t)&v21);
    if ((_BYTE)v24)
    {
      v38 = (void **)&v22 + 1;
      std::vector<DataIPFilter>::__destroy_vector::operator()[abi:ne180100](&v38);
    }
    v4 = 0uLL;
    if ((_BYTE)v39)
    {
      if ((_BYTE)v47)
        LOBYTE(v47) = 0;
      if (BYTE14(v46))
        BYTE14(v46) = 0;
      if (BYTE12(v46))
        BYTE12(v46) = 0;
      if (BYTE10(v46))
        BYTE10(v46) = 0;
      if (BYTE8(v46))
        BYTE8(v46) = 0;
      if (BYTE4(v46))
        BYTE4(v46) = 0;
      if (BYTE2(v46))
        BYTE2(v46) = 0;
      if ((_BYTE)v46)
        LOBYTE(v46) = 0;
      if (BYTE8(v45))
        BYTE8(v45) = 0;
      if ((_BYTE)v45)
        LOBYTE(v45) = 0;
      if (BYTE8(v44))
        BYTE8(v44) = 0;
      if ((_BYTE)v44)
        LOBYTE(v44) = 0;
      if (BYTE8(v43))
        BYTE8(v43) = 0;
      if (BYTE8(v41) && (_QWORD)v42)
      {
        *((_QWORD *)&v42 + 1) = v42;
        operator delete((void *)v42);
        v4 = 0uLL;
      }
    }
  }
  v47 = 0;
  v45 = v4;
  v46 = v4;
  v43 = v4;
  v44 = v4;
  v41 = v4;
  v42 = v4;
  v39 = v4;
  v40 = v4;
  if (*(_BYTE *)(a2 + 72))
  {
    qos::tlv::FlowSpec::FlowSpec((qos::tlv::FlowSpec *)((char *)&v39 + 8), (const qos::tlv::FlowSpec *)(a2 + 80));
    LOBYTE(v39) = 1;
    v24 = 0;
    v22 = 0u;
    v23 = 0u;
    v21 = 0u;
    if (BYTE12(v40))
    {
      DWORD2(v21) = v41;
      BYTE12(v21) = 1;
      LODWORD(v22) = DWORD1(v41);
      BYTE4(v22) = 1;
    }
    if (BYTE14(v46))
    {
      BYTE4(v21) = 1;
      LODWORD(v21) = HIBYTE(v46);
    }
    std::optional<DataQoS>::operator=[abi:ne180100]<DataQoS&,void>((uint64_t)(v26 + 15), (uint64_t)&v21);
    if ((_BYTE)v24)
    {
      v38 = (void **)&v22 + 1;
      std::vector<DataIPFilter>::__destroy_vector::operator()[abi:ne180100](&v38);
    }
    if ((_BYTE)v39)
    {
      if ((_BYTE)v47)
        LOBYTE(v47) = 0;
      if (BYTE14(v46))
        BYTE14(v46) = 0;
      if (BYTE12(v46))
        BYTE12(v46) = 0;
      if (BYTE10(v46))
        BYTE10(v46) = 0;
      if (BYTE8(v46))
        BYTE8(v46) = 0;
      if (BYTE4(v46))
        BYTE4(v46) = 0;
      if (BYTE2(v46))
        BYTE2(v46) = 0;
      if ((_BYTE)v46)
        LOBYTE(v46) = 0;
      if (BYTE8(v45))
        BYTE8(v45) = 0;
      if ((_BYTE)v45)
        LOBYTE(v45) = 0;
      if (BYTE8(v44))
        BYTE8(v44) = 0;
      if ((_BYTE)v44)
        LOBYTE(v44) = 0;
      if (BYTE8(v43))
        BYTE8(v43) = 0;
      if (BYTE8(v41) && (_QWORD)v42)
      {
        *((_QWORD *)&v42 + 1) = v42;
        operator delete((void *)v42);
      }
    }
  }
  *(_QWORD *)&v39 = 0;
  v5 = MEMORY[0x24BDAC760];
  if (*(_BYTE *)(a2 + 40))
  {
    *((_QWORD *)&v39 + 1) = 0;
    v40 = 0uLL;
    std::vector<tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>>::__init_with_size[abi:ne180100]<tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>*,tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>*>((_QWORD *)&v39 + 1, *(_QWORD *)(a2 + 48), *(_QWORD *)(a2 + 56), 0xF83E0F83E0F83E1 * ((uint64_t)(*(_QWORD *)(a2 + 56) - *(_QWORD *)(a2 + 48)) >> 2));
    LOBYTE(v39) = 1;
    v6 = *((_QWORD *)&v39 + 1);
    v7 = v40;
    v16[0] = v5;
    v16[1] = 0x40000000;
    v17 = ___ZNK14QMIQOSClientIP28handleQOSEventReportInd_syncERKN3qos14EventReportInd10IndicationE_block_invoke_118;
    v18 = &unk_24D5EB678;
    v19 = &v25;
    v20 = v3;
    if (*((_QWORD *)&v39 + 1) == (_QWORD)v40)
      goto LABEL_79;
    do
    {
      ((void (*)(_QWORD *, uint64_t))v17)(v16, v6);
      v6 += 132;
    }
    while (v6 != v7);
    if ((_BYTE)v39)
    {
LABEL_79:
      *(_QWORD *)&v21 = (char *)&v39 + 8;
      std::vector<tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v21);
    }
  }
  *(_QWORD *)&v39 = 0;
  if (*(_BYTE *)(a2 + 8))
  {
    *((_QWORD *)&v39 + 1) = 0;
    v40 = 0uLL;
    std::vector<tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>>::__init_with_size[abi:ne180100]<tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>*,tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>*>((_QWORD *)&v39 + 1, *(_QWORD *)(a2 + 16), *(_QWORD *)(a2 + 24), 0xF83E0F83E0F83E1 * ((uint64_t)(*(_QWORD *)(a2 + 24) - *(_QWORD *)(a2 + 16)) >> 2));
    LOBYTE(v39) = 1;
    v8 = *((_QWORD *)&v39 + 1);
    v9 = v40;
    v11[0] = v5;
    v11[1] = 0x40000000;
    v12 = ___ZNK14QMIQOSClientIP28handleQOSEventReportInd_syncERKN3qos14EventReportInd10IndicationE_block_invoke_2;
    v13 = &unk_24D5EB6A0;
    v14 = &v25;
    v15 = v3;
    if (*((_QWORD *)&v39 + 1) == (_QWORD)v40)
      goto LABEL_84;
    do
    {
      ((void (*)(_QWORD *, uint64_t))v12)(v11, v8);
      v8 += 132;
    }
    while (v8 != v9);
    if ((_BYTE)v39)
    {
LABEL_84:
      *(_QWORD *)&v21 = (char *)&v39 + 8;
      std::vector<tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v21);
    }
  }
  if (*(_BYTE *)(a2 + 346))
    *((_DWORD *)v26 + 11) = *(unsigned __int8 *)(a2 + 347);
  v10 = *(unsigned __int8 *)(a2 + 5);
  if ((v10 - 1) >= 2)
  {
    if (v10 == 3)
      (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)(v3 + 64) + 88))(*(_QWORD *)(v3 + 64), *((unsigned int *)v26 + 10));
  }
  else
  {
    (*(void (**)(_QWORD, uint64_t *))(**(_QWORD **)(v3 + 64) + 80))(*(_QWORD *)(v3 + 64), v26 + 5);
  }
  _Block_object_dispose(&v25, 8);
  if (BYTE8(v36) && (_BYTE)v36)
  {
    *(_QWORD *)&v39 = &v35[8];
    std::vector<DataIPFilter>::__destroy_vector::operator()[abi:ne180100]((void ***)&v39);
  }
  if (BYTE8(v33))
  {
    if ((_BYTE)v33)
    {
      *(_QWORD *)&v39 = &v32[8];
      std::vector<DataIPFilter>::__destroy_vector::operator()[abi:ne180100]((void ***)&v39);
    }
  }
}

void sub_216A8A90C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  uint64_t v28;

  _Block_object_dispose(&a28, 8);
  DataCellularQoSFlow::~DataCellularQoSFlow((DataCellularQoSFlow *)(v28 + 40));
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__11(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
  std::__optional_move_base<DataQoS,false>::__optional_move_base[abi:ne180100](a1 + 56, (__int128 *)(a2 + 56));
  result = std::__optional_move_base<DataQoS,false>::__optional_move_base[abi:ne180100](a1 + 120, (__int128 *)(a2 + 120));
  *(_WORD *)(a1 + 184) = *(_WORD *)(a2 + 184);
  return result;
}

void __Block_byref_object_dispose__11(uint64_t a1)
{
  void **v2;

  if (*(_BYTE *)(a1 + 176) && *(_BYTE *)(a1 + 168))
  {
    v2 = (void **)(a1 + 144);
    std::vector<DataIPFilter>::__destroy_vector::operator()[abi:ne180100](&v2);
  }
  if (*(_BYTE *)(a1 + 112))
  {
    if (*(_BYTE *)(a1 + 104))
    {
      v2 = (void **)(a1 + 80);
      std::vector<DataIPFilter>::__destroy_vector::operator()[abi:ne180100](&v2);
    }
  }
}

void DataCellularQoSFlow::~DataCellularQoSFlow(DataCellularQoSFlow *this)
{
  void **v2;

  if (*((_BYTE *)this + 136) && *((_BYTE *)this + 128))
  {
    v2 = (void **)((char *)this + 104);
    std::vector<DataIPFilter>::__destroy_vector::operator()[abi:ne180100](&v2);
  }
  if (*((_BYTE *)this + 72))
  {
    if (*((_BYTE *)this + 64))
    {
      v2 = (void **)((char *)this + 40);
      std::vector<DataIPFilter>::__destroy_vector::operator()[abi:ne180100](&v2);
    }
  }
}

uint64_t std::optional<DataQoS>::operator=[abi:ne180100]<DataQoS&,void>(uint64_t a1, uint64_t a2)
{
  int v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void **v16;

  v3 = *(unsigned __int8 *)(a1 + 56);
  v4 = *(_QWORD *)(a2 + 13);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_QWORD *)(a1 + 13) = v4;
  v5 = (_QWORD *)(a1 + 24);
  if (v3)
  {
    if (*(unsigned __int8 *)(a1 + 48) == *(unsigned __int8 *)(a2 + 48))
    {
      if (a1 != a2 && *(_BYTE *)(a1 + 48))
      {
        v7 = *(_QWORD *)(a2 + 24);
        v6 = *(_QWORD *)(a2 + 32);
        v8 = 0xCCCCCCCCCCCCCCCDLL * ((v6 - v7) >> 5);
        v9 = *(_QWORD *)(a1 + 24);
        if (0xCCCCCCCCCCCCCCCDLL * ((*(_QWORD *)(a1 + 40) - v9) >> 5) >= v8)
        {
          if (0xCCCCCCCCCCCCCCCDLL * ((*(_QWORD *)(a1 + 32) - v9) >> 5) >= v8)
          {
            std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<DataIPFilter *,DataIPFilter *,DataIPFilter *>((uint64_t)&v16, *(_QWORD *)(a2 + 24), v6, v9);
            std::vector<DataIPFilter>::__base_destruct_at_end[abi:ne180100]((uint64_t)v5, v14);
            return a1;
          }
          v13 = v7 + 32 * ((*(_QWORD *)(a1 + 32) - v9) >> 5);
          std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<DataIPFilter *,DataIPFilter *,DataIPFilter *>((uint64_t)&v16, *(_QWORD *)(a2 + 24), v13, v9);
          v12 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<DataIPFilter>,DataIPFilter*,DataIPFilter*,DataIPFilter*>(a1 + 40, v13, v6, *(_QWORD *)(a1 + 32));
        }
        else
        {
          std::vector<DataIPFilter>::__vdeallocate((uint64_t *)(a1 + 24));
          if (v8 > 0x199999999999999)
            std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
          v10 = 0x999999999999999ALL * ((uint64_t)(*(_QWORD *)(a1 + 40) - *(_QWORD *)(a1 + 24)) >> 5);
          if (v10 <= v8)
            v10 = 0xCCCCCCCCCCCCCCCDLL * ((v6 - v7) >> 5);
          if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(_QWORD *)(a1 + 40) - *(_QWORD *)(a1 + 24)) >> 5) >= 0xCCCCCCCCCCCCCCLL)
            v11 = 0x199999999999999;
          else
            v11 = v10;
          std::vector<DataIPFilter>::__vallocate[abi:ne180100](v5, v11);
          v12 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<DataIPFilter>,DataIPFilter*,DataIPFilter*,DataIPFilter*>(a1 + 40, v7, v6, *(_QWORD *)(a1 + 32));
        }
        *(_QWORD *)(a1 + 32) = v12;
      }
    }
    else if (*(_BYTE *)(a1 + 48))
    {
      v16 = (void **)(a1 + 24);
      std::vector<DataIPFilter>::__destroy_vector::operator()[abi:ne180100](&v16);
      *(_BYTE *)(a1 + 48) = 0;
    }
    else
    {
      *v5 = 0;
      *(_QWORD *)(a1 + 32) = 0;
      *(_QWORD *)(a1 + 40) = 0;
      std::vector<DataIPFilter>::__init_with_size[abi:ne180100]<DataIPFilter*,DataIPFilter*>((_QWORD *)(a1 + 24), *(_QWORD *)(a2 + 24), *(_QWORD *)(a2 + 32), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(_QWORD *)(a2 + 32) - *(_QWORD *)(a2 + 24)) >> 5));
      *(_BYTE *)(a1 + 48) = 1;
    }
  }
  else
  {
    *(_BYTE *)(a1 + 24) = 0;
    *(_BYTE *)(a1 + 48) = 0;
    if (*(_BYTE *)(a2 + 48))
    {
      *v5 = 0;
      *(_QWORD *)(a1 + 32) = 0;
      *(_QWORD *)(a1 + 40) = 0;
      std::vector<DataIPFilter>::__init_with_size[abi:ne180100]<DataIPFilter*,DataIPFilter*>((_QWORD *)(a1 + 24), *(_QWORD *)(a2 + 24), *(_QWORD *)(a2 + 32), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(_QWORD *)(a2 + 32) - *(_QWORD *)(a2 + 24)) >> 5));
      *(_BYTE *)(a1 + 48) = 1;
    }
    *(_BYTE *)(a1 + 56) = 1;
  }
  return a1;
}

void sub_216A8ACD8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  uint64_t v10;
  uint64_t v11;

  *(_QWORD *)(v10 + 32) = v11;
  _Unwind_Resume(exception_object);
}

void ___ZNK14QMIQOSClientIP28handleQOSEventReportInd_syncERKN3qos14EventReportInd10IndicationE_block_invoke_118(uint64_t a1, QMIQOSClientIP *this, DataIPFilter *a3)
{
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  void *v11[2];
  __int128 v12;
  __int128 v13;
  void *__p[2];
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  void **v19;

  v5 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (!*(_BYTE *)(v5 + 112))
  {
    LOBYTE(v9) = 0;
    BYTE4(v9) = 0;
    BYTE8(v9) = 0;
    BYTE12(v9) = 0;
    LOBYTE(v10) = 0;
    BYTE4(v10) = 0;
    BYTE8(v10) = 0;
    LOBYTE(v12) = 0;
    std::optional<DataQoS>::operator=[abi:ne180100]<DataQoS,void>(v5 + 56, (uint64_t)&v9);
    if ((_BYTE)v12)
    {
      v19 = (void **)&v10 + 1;
      std::vector<DataIPFilter>::__destroy_vector::operator()[abi:ne180100](&v19);
    }
    v5 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    if (!*(_BYTE *)(v5 + 112))
      std::__throw_bad_optional_access[abi:ne180100]();
  }
  if (!*(_BYTE *)(v5 + 104))
  {
    v9 = 0uLL;
    *(_QWORD *)&v10 = 0;
    std::optional<std::vector<DataIPFilter>>::operator=[abi:ne180100]<std::vector<DataIPFilter>,void>(v5 + 80, (uint64_t)&v9);
    v19 = (void **)&v9;
    std::vector<DataIPFilter>::__destroy_vector::operator()[abi:ne180100](&v19);
  }
  v17 = 0u;
  v18 = 0u;
  v15 = 0u;
  v16 = 0u;
  v13 = 0u;
  *(_OWORD *)__p = 0u;
  *(_OWORD *)v11 = 0u;
  v12 = 0u;
  v9 = 0u;
  v10 = 0u;
  QMIQOSClientIP::FilterSpecToDict(this, (const qos::tlv::QoSFilter *)&v9, a3);
  v6 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (!*(_BYTE *)(v6 + 112) || !*(_BYTE *)(v6 + 104))
    std::__throw_bad_optional_access[abi:ne180100]();
  v7 = *(_QWORD *)(v6 + 88);
  if (v7 >= *(_QWORD *)(v6 + 96))
  {
    v8 = std::vector<DataIPFilter>::__emplace_back_slow_path<DataIPFilter&>((uint64_t *)(v6 + 80), (uint64_t)&v9);
  }
  else
  {
    std::construct_at[abi:ne180100]<DataIPFilter,DataIPFilter&,DataIPFilter*>(*(_QWORD *)(v6 + 88), (uint64_t)&v9);
    v8 = v7 + 160;
    *(_QWORD *)(v6 + 88) = v7 + 160;
  }
  *(_QWORD *)(v6 + 88) = v8;
  if (BYTE8(v17) && (_BYTE)v16 && SHIBYTE(v15) < 0)
    operator delete(__p[1]);
  if (LOBYTE(__p[0]) && BYTE8(v12) && SBYTE7(v12) < 0)
    operator delete(v11[0]);
}

void sub_216A8AE88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19, uint64_t a20,uint64_t a21,char a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,char a29,uint64_t a30,uint64_t a31,char a32)
{
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;

  v34 = v32;
  *(_QWORD *)(v34 + 88) = v33;
  if (a32 && a29 && a28 < 0)
    operator delete(__p);
  if (a22 && a19 && a18 < 0)
    operator delete(a13);
  _Unwind_Resume(exception_object);
}

uint64_t std::optional<DataQoS>::operator=[abi:ne180100]<DataQoS,void>(uint64_t a1, uint64_t a2)
{
  int v4;
  uint64_t v5;
  uint64_t *v6;
  _QWORD *v7;
  void **v9;

  v4 = *(unsigned __int8 *)(a1 + 56);
  v5 = *(_QWORD *)(a2 + 13);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_QWORD *)(a1 + 13) = v5;
  v6 = (uint64_t *)(a1 + 24);
  if (v4)
  {
    v7 = (_QWORD *)(a2 + 24);
    if (*(unsigned __int8 *)(a1 + 48) == *(unsigned __int8 *)(a2 + 48))
    {
      if (*(_BYTE *)(a1 + 48))
      {
        std::vector<DataIPFilter>::__vdeallocate(v6);
        *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
        *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
        *v7 = 0;
        *(_QWORD *)(a2 + 32) = 0;
        *(_QWORD *)(a2 + 40) = 0;
      }
    }
    else if (*(_BYTE *)(a1 + 48))
    {
      v9 = (void **)v6;
      std::vector<DataIPFilter>::__destroy_vector::operator()[abi:ne180100](&v9);
      *(_BYTE *)(a1 + 48) = 0;
    }
    else
    {
      *v6 = 0;
      v6[1] = 0;
      v6[2] = 0;
      *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
      *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
      *v7 = 0;
      *(_QWORD *)(a2 + 32) = 0;
      *(_QWORD *)(a2 + 40) = 0;
      *(_BYTE *)(a1 + 48) = 1;
    }
  }
  else
  {
    *(_BYTE *)(a1 + 24) = 0;
    *(_BYTE *)(a1 + 48) = 0;
    if (*(_BYTE *)(a2 + 48))
    {
      *v6 = 0;
      v6[1] = 0;
      v6[2] = 0;
      *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
      *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
      *(_QWORD *)(a2 + 24) = 0;
      *(_QWORD *)(a2 + 32) = 0;
      *(_QWORD *)(a2 + 40) = 0;
      *(_BYTE *)(a1 + 48) = 1;
    }
    *(_BYTE *)(a1 + 56) = 1;
  }
  return a1;
}

uint64_t std::optional<std::vector<DataIPFilter>>::operator=[abi:ne180100]<std::vector<DataIPFilter>,void>(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(a1 + 24))
  {
    std::vector<DataIPFilter>::__vdeallocate((uint64_t *)a1);
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
    *(_QWORD *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
  }
  else
  {
    *(_QWORD *)a1 = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
    *(_QWORD *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    *(_BYTE *)(a1 + 24) = 1;
  }
  return a1;
}

void ___ZNK14QMIQOSClientIP28handleQOSEventReportInd_syncERKN3qos14EventReportInd10IndicationE_block_invoke_2(uint64_t a1, QMIQOSClientIP *this, DataIPFilter *a3)
{
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  void *v11[2];
  __int128 v12;
  __int128 v13;
  void *__p[2];
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  void **v19;

  v5 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (!*(_BYTE *)(v5 + 176))
  {
    LOBYTE(v9) = 0;
    BYTE4(v9) = 0;
    BYTE8(v9) = 0;
    BYTE12(v9) = 0;
    LOBYTE(v10) = 0;
    BYTE4(v10) = 0;
    BYTE8(v10) = 0;
    LOBYTE(v12) = 0;
    std::optional<DataQoS>::operator=[abi:ne180100]<DataQoS,void>(v5 + 120, (uint64_t)&v9);
    if ((_BYTE)v12)
    {
      v19 = (void **)&v10 + 1;
      std::vector<DataIPFilter>::__destroy_vector::operator()[abi:ne180100](&v19);
    }
    v5 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    if (!*(_BYTE *)(v5 + 176))
      std::__throw_bad_optional_access[abi:ne180100]();
  }
  if (!*(_BYTE *)(v5 + 168))
  {
    v9 = 0uLL;
    *(_QWORD *)&v10 = 0;
    std::optional<std::vector<DataIPFilter>>::operator=[abi:ne180100]<std::vector<DataIPFilter>,void>(v5 + 144, (uint64_t)&v9);
    v19 = (void **)&v9;
    std::vector<DataIPFilter>::__destroy_vector::operator()[abi:ne180100](&v19);
  }
  v17 = 0u;
  v18 = 0u;
  v15 = 0u;
  v16 = 0u;
  v13 = 0u;
  *(_OWORD *)__p = 0u;
  *(_OWORD *)v11 = 0u;
  v12 = 0u;
  v9 = 0u;
  v10 = 0u;
  QMIQOSClientIP::FilterSpecToDict(this, (const qos::tlv::QoSFilter *)&v9, a3);
  v6 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (!*(_BYTE *)(v6 + 176) || !*(_BYTE *)(v6 + 168))
    std::__throw_bad_optional_access[abi:ne180100]();
  v7 = *(_QWORD *)(v6 + 152);
  if (v7 >= *(_QWORD *)(v6 + 160))
  {
    v8 = std::vector<DataIPFilter>::__emplace_back_slow_path<DataIPFilter&>((uint64_t *)(v6 + 144), (uint64_t)&v9);
  }
  else
  {
    std::construct_at[abi:ne180100]<DataIPFilter,DataIPFilter&,DataIPFilter*>(*(_QWORD *)(v6 + 152), (uint64_t)&v9);
    v8 = v7 + 160;
    *(_QWORD *)(v6 + 152) = v7 + 160;
  }
  *(_QWORD *)(v6 + 152) = v8;
  if (BYTE8(v17) && (_BYTE)v16 && SHIBYTE(v15) < 0)
    operator delete(__p[1]);
  if (LOBYTE(__p[0]) && BYTE8(v12) && SBYTE7(v12) < 0)
    operator delete(v11[0]);
}

void sub_216A8B1E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19, uint64_t a20,uint64_t a21,char a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,char a29,uint64_t a30,uint64_t a31,char a32)
{
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;

  v34 = v32;
  *(_QWORD *)(v34 + 152) = v33;
  if (a32 && a29 && a28 < 0)
    operator delete(__p);
  if (a22 && a19 && a18 < 0)
    operator delete(a13);
  _Unwind_Resume(exception_object);
}

void ___ZNK14QMIQOSClientIP27handleGlobalQosFlowInd_syncERKN3qos16GlobalQosFlowInd10IndicationE_block_invoke(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  __int128 v8;
  __int128 v9;
  void *v10[2];
  __int128 v11;
  __int128 v12;
  void *__p[2];
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  void **v18;

  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (!*(_BYTE *)(v4 + 112))
  {
    LOBYTE(v8) = 0;
    BYTE4(v8) = 0;
    BYTE8(v8) = 0;
    BYTE12(v8) = 0;
    LOBYTE(v9) = 0;
    BYTE4(v9) = 0;
    BYTE8(v9) = 0;
    LOBYTE(v11) = 0;
    std::optional<DataQoS>::operator=[abi:ne180100]<DataQoS,void>(v4 + 56, (uint64_t)&v8);
    if ((_BYTE)v11)
    {
      v18 = (void **)&v9 + 1;
      std::vector<DataIPFilter>::__destroy_vector::operator()[abi:ne180100](&v18);
    }
    v4 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    if (!*(_BYTE *)(v4 + 112))
      std::__throw_bad_optional_access[abi:ne180100]();
  }
  if (!*(_BYTE *)(v4 + 104))
  {
    v8 = 0uLL;
    *(_QWORD *)&v9 = 0;
    std::optional<std::vector<DataIPFilter>>::operator=[abi:ne180100]<std::vector<DataIPFilter>,void>(v4 + 80, (uint64_t)&v8);
    v18 = (void **)&v8;
    std::vector<DataIPFilter>::__destroy_vector::operator()[abi:ne180100](&v18);
  }
  v16 = 0u;
  v17 = 0u;
  v14 = 0u;
  v15 = 0u;
  v12 = 0u;
  *(_OWORD *)__p = 0u;
  *(_OWORD *)v10 = 0u;
  v11 = 0u;
  v8 = 0u;
  v9 = 0u;
  QMIQOSClientIP::mav20FilterSpecToDict(a2, (uint64_t)&v8);
  v5 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (!*(_BYTE *)(v5 + 112) || !*(_BYTE *)(v5 + 104))
    std::__throw_bad_optional_access[abi:ne180100]();
  v6 = *(_QWORD *)(v5 + 88);
  if (v6 >= *(_QWORD *)(v5 + 96))
  {
    v7 = std::vector<DataIPFilter>::__emplace_back_slow_path<DataIPFilter&>((uint64_t *)(v5 + 80), (uint64_t)&v8);
  }
  else
  {
    std::construct_at[abi:ne180100]<DataIPFilter,DataIPFilter&,DataIPFilter*>(*(_QWORD *)(v5 + 88), (uint64_t)&v8);
    v7 = v6 + 160;
    *(_QWORD *)(v5 + 88) = v6 + 160;
  }
  *(_QWORD *)(v5 + 88) = v7;
  if (BYTE8(v16) && (_BYTE)v15 && SHIBYTE(v14) < 0)
    operator delete(__p[1]);
  if (LOBYTE(__p[0]) && BYTE8(v11) && SBYTE7(v11) < 0)
    operator delete(v10[0]);
}

void sub_216A8B3C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19, uint64_t a20,uint64_t a21,char a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,char a29,uint64_t a30,uint64_t a31,char a32)
{
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;

  v34 = v32;
  *(_QWORD *)(v34 + 88) = v33;
  if (a32 && a29 && a28 < 0)
    operator delete(__p);
  if (a22 && a19 && a18 < 0)
    operator delete(a13);
  _Unwind_Resume(exception_object);
}

void ___ZNK14QMIQOSClientIP27handleGlobalQosFlowInd_syncERKN3qos16GlobalQosFlowInd10IndicationE_block_invoke_2(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  __int128 v8;
  __int128 v9;
  void *v10[2];
  __int128 v11;
  __int128 v12;
  void *__p[2];
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  void **v18;

  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (!*(_BYTE *)(v4 + 176))
  {
    LOBYTE(v8) = 0;
    BYTE4(v8) = 0;
    BYTE8(v8) = 0;
    BYTE12(v8) = 0;
    LOBYTE(v9) = 0;
    BYTE4(v9) = 0;
    BYTE8(v9) = 0;
    LOBYTE(v11) = 0;
    std::optional<DataQoS>::operator=[abi:ne180100]<DataQoS,void>(v4 + 120, (uint64_t)&v8);
    if ((_BYTE)v11)
    {
      v18 = (void **)&v9 + 1;
      std::vector<DataIPFilter>::__destroy_vector::operator()[abi:ne180100](&v18);
    }
    v4 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    if (!*(_BYTE *)(v4 + 176))
      std::__throw_bad_optional_access[abi:ne180100]();
  }
  if (!*(_BYTE *)(v4 + 168))
  {
    v8 = 0uLL;
    *(_QWORD *)&v9 = 0;
    std::optional<std::vector<DataIPFilter>>::operator=[abi:ne180100]<std::vector<DataIPFilter>,void>(v4 + 144, (uint64_t)&v8);
    v18 = (void **)&v8;
    std::vector<DataIPFilter>::__destroy_vector::operator()[abi:ne180100](&v18);
  }
  v16 = 0u;
  v17 = 0u;
  v14 = 0u;
  v15 = 0u;
  v12 = 0u;
  *(_OWORD *)__p = 0u;
  *(_OWORD *)v10 = 0u;
  v11 = 0u;
  v8 = 0u;
  v9 = 0u;
  QMIQOSClientIP::mav20FilterSpecToDict(a2, (uint64_t)&v8);
  v5 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (!*(_BYTE *)(v5 + 176) || !*(_BYTE *)(v5 + 168))
    std::__throw_bad_optional_access[abi:ne180100]();
  v6 = *(_QWORD *)(v5 + 152);
  if (v6 >= *(_QWORD *)(v5 + 160))
  {
    v7 = std::vector<DataIPFilter>::__emplace_back_slow_path<DataIPFilter&>((uint64_t *)(v5 + 144), (uint64_t)&v8);
  }
  else
  {
    std::construct_at[abi:ne180100]<DataIPFilter,DataIPFilter&,DataIPFilter*>(*(_QWORD *)(v5 + 152), (uint64_t)&v8);
    v7 = v6 + 160;
    *(_QWORD *)(v5 + 152) = v6 + 160;
  }
  *(_QWORD *)(v5 + 152) = v7;
  if (BYTE8(v16) && (_BYTE)v15 && SHIBYTE(v14) < 0)
    operator delete(__p[1]);
  if (LOBYTE(__p[0]) && BYTE8(v11) && SBYTE7(v11) < 0)
    operator delete(v10[0]);
}

void sub_216A8B5A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19, uint64_t a20,uint64_t a21,char a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,char a29,uint64_t a30,uint64_t a31,char a32)
{
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;

  v34 = v32;
  *(_QWORD *)(v34 + 152) = v33;
  if (a32 && a29 && a28 < 0)
    operator delete(__p);
  if (a22 && a19 && a18 < 0)
    operator delete(a13);
  _Unwind_Resume(exception_object);
}

void ___ZN14QMIQOSClientIP25queryCurrentQosFlows_syncENSt3__18functionIFvRKNS0_6vectorIjNS0_9allocatorIjEEEEbEEE_block_invoke(uint64_t a1, qmi::MessageBase *this)
{
  uint64_t v3;
  uint64_t v4;
  void *v5;
  uint64_t v7;
  NSObject *v8;
  unsigned __int8 *TlvValue;
  int v10;
  unsigned __int8 *v11;
  int v12;
  unsigned __int8 *v13;
  NSObject *v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  void *v18;
  _QWORD v19[6];
  unsigned __int8 *v20;
  void *__p[5];
  void *v22;
  void *v23;
  uint64_t v24;
  std::vector<unsigned int> buf;
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 + 32);
  if (*(_BYTE *)(v3 + 108))
  {
    memset(__p, 0, 24);
    LOBYTE(buf.__begin_) = 0;
    v4 = *(_QWORD *)(a1 + 64);
    if (!v4)
      std::__throw_bad_function_call[abi:ne180100]();
    (*(void (**)(uint64_t, void **, std::vector<unsigned int> *))(*(_QWORD *)v4 + 48))(v4, __p, &buf);
    v5 = __p[0];
    if (__p[0])
    {
      __p[1] = __p[0];
LABEL_5:
      operator delete(v5);
    }
  }
  else if (*((_DWORD *)this + 1))
  {
    memset(__p, 0, 24);
    LOBYTE(buf.__begin_) = 0;
    v7 = *(_QWORD *)(a1 + 64);
    if (!v7)
      std::__throw_bad_function_call[abi:ne180100]();
    (*(void (**)(uint64_t, void **, std::vector<unsigned int> *))(*(_QWORD *)v7 + 48))(v7, __p, &buf);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    v8 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      v17 = *((_DWORD *)this + 1);
      v18 = (void *)qmi::asString();
      LODWORD(__p[0]) = 136315650;
      *(void **)((char *)__p + 4) = "queryCurrentQosFlows_sync_block_invoke";
      WORD2(__p[1]) = 1024;
      *(_DWORD *)((char *)&__p[1] + 6) = v17;
      WORD1(__p[2]) = 2080;
      *(void **)((char *)&__p[2] + 4) = v18;
      _os_log_error_impl(&dword_216897000, v8, OS_LOG_TYPE_ERROR, "%s: GetQosIds: Error in response with code = 0x%x (%s)", (uint8_t *)__p, 0x1Cu);
    }
  }
  else
  {
    __p[0] = 0;
    __p[1] = __p;
    __p[2] = (void *)0x4002000000;
    __p[3] = __Block_byref_object_copy__127;
    __p[4] = __Block_byref_object_dispose__128;
    v23 = 0;
    v24 = 0;
    v22 = 0;
    v19[0] = MEMORY[0x24BDAC760];
    v19[1] = 0x40000000;
    v19[2] = ___ZN14QMIQOSClientIP25queryCurrentQosFlows_syncENSt3__18functionIFvRKNS0_6vectorIjNS0_9allocatorIjEEEEbEEE_block_invoke_129;
    v19[3] = &unk_24D5EB738;
    v19[4] = __p;
    v19[5] = v3;
    TlvValue = (unsigned __int8 *)qmi::MessageBase::findTlvValue(this);
    v11 = TlvValue;
    if (TlvValue)
    {
      v12 = v10;
      v20 = TlvValue;
      memset(&buf, 0, sizeof(buf));
      tlv::parseV<qos::tlv::QoSIdsList>(&v20, v10, &buf);
      v13 = v20;
      if (v20)
        ___ZN14QMIQOSClientIP25queryCurrentQosFlows_syncENSt3__18functionIFvRKNS0_6vectorIjNS0_9allocatorIjEEEEbEEE_block_invoke_129((uint64_t)v19, (uint64_t)&buf);
      if (buf.__begin_)
      {
        buf.__end_ = buf.__begin_;
        operator delete(buf.__begin_);
      }
      if (!v13)
        ((void (*)(_QWORD, uint64_t, unsigned __int8 *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)this, 16, v11, v12);
    }
    v14 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      v15 = (uint64_t)(*((_QWORD *)__p[1] + 6) - *((_QWORD *)__p[1] + 5)) >> 2;
      LODWORD(buf.__begin_) = 136315394;
      *(std::vector<unsigned int>::pointer *)((char *)&buf.__begin_ + 4) = (std::vector<unsigned int>::pointer)"queryCurrentQosFlows_sync_block_invoke";
      WORD2(buf.__end_) = 2048;
      *(std::vector<unsigned int>::pointer *)((char *)&buf.__end_ + 6) = (std::vector<unsigned int>::pointer)v15;
      _os_log_impl(&dword_216897000, v14, OS_LOG_TYPE_DEFAULT, "#I %s: GetQosIds: size = %lu", (uint8_t *)&buf, 0x16u);
    }
    LOBYTE(buf.__begin_) = 1;
    v16 = *(_QWORD *)(a1 + 64);
    if (!v16)
      std::__throw_bad_function_call[abi:ne180100]();
    (*(void (**)(uint64_t, char *, std::vector<unsigned int> *))(*(_QWORD *)v16 + 48))(v16, (char *)__p[1] + 40, &buf);
    _Block_object_dispose(__p, 8);
    v5 = v22;
    if (v22)
    {
      v23 = v22;
      goto LABEL_5;
    }
  }
}

void sub_216A8B900(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23)
{
  uint64_t v23;
  void *v25;

  v25 = *(void **)(v23 - 80);
  if (v25)
  {
    *(_QWORD *)(v23 - 72) = v25;
    operator delete(v25);
  }
  _Block_object_dispose(&a17, 8);
  if (__p)
  {
    a23 = (uint64_t)__p;
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__127(_QWORD *a1, uint64_t a2)
{
  __n128 result;

  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 5) = result;
  a1[7] = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a2 + 40) = 0;
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(a2 + 56) = 0;
  return result;
}

void __Block_byref_object_dispose__128(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 40);
  if (v2)
  {
    *(_QWORD *)(a1 + 48) = v2;
    operator delete(v2);
  }
}

void ___ZN14QMIQOSClientIP25queryCurrentQosFlows_syncENSt3__18functionIFvRKNS0_6vectorIjNS0_9allocatorIjEEEEbEEE_block_invoke_129(uint64_t a1, uint64_t a2)
{
  _DWORD *v2;
  _DWORD *v3;
  uint64_t v5;
  _QWORD *v6;
  char *v7;
  unint64_t v8;
  _DWORD *v9;
  char *v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  char *v15;
  char *v16;
  int v17;
  NSObject *v18;
  uint64_t v19;
  uint8_t buf[4];
  const char *v21;
  __int16 v22;
  uint64_t v23;
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  v2 = *(_DWORD **)a2;
  v3 = *(_DWORD **)(a2 + 8);
  if (*(_DWORD **)a2 != v3)
  {
    v5 = *(_QWORD *)(a1 + 40);
    do
    {
      v6 = *(_QWORD **)(*(_QWORD *)(a1 + 32) + 8);
      v7 = (char *)v6[6];
      v8 = v6[7];
      if ((unint64_t)v7 >= v8)
      {
        v10 = (char *)v6[5];
        v11 = (v7 - v10) >> 2;
        if ((unint64_t)(v11 + 1) >> 62)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v12 = v8 - (_QWORD)v10;
        v13 = (uint64_t)(v8 - (_QWORD)v10) >> 1;
        if (v13 <= v11 + 1)
          v13 = v11 + 1;
        if (v12 >= 0x7FFFFFFFFFFFFFFCLL)
          v14 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v14 = v13;
        if (v14)
        {
          v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::array<unsigned char,4ul>>>((uint64_t)(v6 + 7), v14);
          v10 = (char *)v6[5];
          v7 = (char *)v6[6];
        }
        else
        {
          v15 = 0;
        }
        v16 = &v15[4 * v11];
        *(_DWORD *)v16 = *v2;
        v9 = v16 + 4;
        while (v7 != v10)
        {
          v17 = *((_DWORD *)v7 - 1);
          v7 -= 4;
          *((_DWORD *)v16 - 1) = v17;
          v16 -= 4;
        }
        v6[5] = v16;
        v6[6] = v9;
        v6[7] = &v15[4 * v14];
        if (v10)
          operator delete(v10);
      }
      else
      {
        *(_DWORD *)v7 = *v2;
        v9 = v7 + 4;
      }
      v6[6] = v9;
      v18 = *(NSObject **)(v5 + 40);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        v19 = *v2;
        *(_DWORD *)buf = 136315394;
        v21 = "queryCurrentQosFlows_sync_block_invoke";
        v22 = 2048;
        v23 = v19;
        _os_log_impl(&dword_216897000, v18, OS_LOG_TYPE_DEFAULT, "#I %s: GetQosIds: id = %lu", buf, 0x16u);
      }
      ++v2;
    }
    while (v2 != v3);
  }
}

uint64_t __copy_helper_block_e8_40c60_ZTSNSt3__18functionIFvRKNS_6vectorIjNS_9allocatorIjEEEEbEEE(uint64_t a1, uint64_t a2)
{
  return std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100](a1 + 40, a2 + 40);
}

_QWORD *__destroy_helper_block_e8_40c60_ZTSNSt3__18functionIFvRKNS_6vectorIjNS_9allocatorIjEEEEbEEE(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *result;
  uint64_t v3;

  v1 = (_QWORD *)(a1 + 40);
  result = *(_QWORD **)(a1 + 64);
  if (result == v1)
  {
    v3 = 4;
    result = v1;
  }
  else
  {
    if (!result)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

uint64_t QMIQOSClientIP::requestQos(uint64_t a1, int a2, const __CFDictionary **a3, int a4)
{
  const __CFDictionary *v5;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  const char *v12;
  uint64_t (*v13)(uint64_t);
  unsigned __int16 *Value;
  unsigned __int16 *v15;
  CFTypeID v16;
  const __CFNumber *v17;
  int v18;
  unsigned __int8 *v19;
  unsigned __int8 *v20;
  CFTypeID v21;
  const __CFNumber *v22;
  int v23;
  NSObject *v24;
  int v25;
  const __CFData *v26;
  const __CFData *v27;
  CFTypeID v28;
  const __CFData *v29;
  const __CFData *v30;
  CFTypeID v31;
  unsigned __int16 *v32;
  unsigned __int16 *v33;
  CFTypeID v34;
  unsigned __int16 *v35;
  const __CFNumber *v36;
  unsigned __int16 *v37;
  CFTypeID v38;
  const UInt8 *BytePtr;
  uint64_t v40;
  NSObject *v41;
  const __CFData *v42;
  const __CFData *v43;
  CFTypeID v44;
  const __CFData *v45;
  const __CFData *v46;
  CFTypeID v47;
  unsigned __int16 *v48;
  unsigned __int16 *v49;
  CFTypeID v50;
  unsigned __int16 *v51;
  const __CFNumber *v52;
  unsigned __int16 *v53;
  CFTypeID v54;
  const UInt8 *v55;
  uint64_t v56;
  __int16 v57;
  __int16 v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  _QWORD *v62;
  uint64_t v63;
  unint64_t v64;
  unint64_t v65;
  char *v66;
  __int16 v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  _QWORD *v71;
  uint64_t v72;
  unint64_t v73;
  unint64_t v74;
  char *v75;
  uint64_t *v76;
  char *v77;
  char *v78;
  char *v79;
  uint64_t v80;
  uint64_t *v81;
  char *v82;
  char *v83;
  char *v84;
  uint64_t v85;
  void *v86;
  uint64_t v88;
  uint64_t v89;
  _QWORD v90[5];
  int v91;
  void *__p[2];
  __int128 v93;
  __int16 v94;
  CFDictionaryRef theDict[2];
  int v96;
  uint64_t v97;
  void *aBlock;
  _BYTE buf[24];
  void *v100;
  _QWORD *v101;
  uint64_t v102;

  v102 = *MEMORY[0x24BDAC8D0];
  if (*(_QWORD *)(a1 + 88) && *(_BYTE *)(a1 + 109))
  {
    v5 = *a3;
    if (*a3)
    {
      *(_OWORD *)__p = 0u;
      v93 = 0u;
      qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
      if (a2)
      {
        v8 = *(NSObject **)(a1 + 40);
        v9 = 0;
        if (!os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
LABEL_121:
          qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
          return v9;
        }
        v10 = asString();
        *(_DWORD *)buf = 136315394;
        *(_QWORD *)&buf[4] = "getFlowProfile";
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = v10;
        _os_log_impl(&dword_216897000, v8, OS_LOG_TYPE_DEFAULT, "#I %s: Not supported QOS flow type %s", buf, 0x16u);
LABEL_45:
        v9 = 0;
        goto LABEL_121;
      }
      theDict[0] = 0;
      (*(void (**)(_BYTE *__return_ptr, _QWORD, const __CFString *, _QWORD, _QWORD))(**(_QWORD **)(a1 + 120)
                                                                                              + 88))(buf, *(_QWORD *)(a1 + 120), CFSTR("QualityOfServiceAudio"), 0, 0);
      ctu::cf::CFSharedRef<__CFDictionary const>::CFSharedRef<void const,void>(theDict, (CFTypeRef *)buf);
      ctu::SharedRef<void const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,void const>::~SharedRef((const void **)buf);
      v13 = ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::get;
      if (!theDict[0])
        v13 = 0;
      if (!v13)
      {
        v41 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315138;
          *(_QWORD *)&buf[4] = "getFlowProfile";
          _os_log_impl(&dword_216897000, v41, OS_LOG_TYPE_DEFAULT, "#I %s: Audio QOS parameters not found in CB", buf, 0xCu);
        }
        ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef((const void **)theDict);
        goto LABEL_45;
      }
      Value = (unsigned __int16 *)CFDictionaryGetValue(theDict[0], CFSTR("ProfileID"));
      v15 = Value;
      *(_WORD *)buf = 0;
      if (Value && (v16 = CFGetTypeID(Value), v16 == CFNumberGetTypeID()))
      {
        ctu::cf::assign((ctu::cf *)buf, v15, v17);
        v18 = *(unsigned __int16 *)buf;
      }
      else
      {
        v18 = 0;
      }
      v19 = (unsigned __int8 *)CFDictionaryGetValue(theDict[0], CFSTR("FlowPriority"));
      v20 = v19;
      buf[0] = 0;
      if (v19 && (v21 = CFGetTypeID(v19), v21 == CFNumberGetTypeID()))
      {
        ctu::cf::assign((ctu::cf *)buf, v20, v22);
        v23 = buf[0];
      }
      else
      {
        v23 = 0;
      }
      v24 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = "getFlowProfile";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v18;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v23;
        _os_log_impl(&dword_216897000, v24, OS_LOG_TYPE_DEFAULT, "#I %s: Audio QOS parameters found in CB: Profile ID = %d, Flow Priority = %d", buf, 0x18u);
      }
      ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef((const void **)theDict);
      v25 = *(_DWORD *)(a1 + 104);
      if (v25 != 2)
      {
        if (v25 != 1)
          goto LABEL_45;
        v26 = (const __CFData *)CFDictionaryGetValue(v5, (const void *)*MEMORY[0x24BDC3E40]);
        v27 = v26;
        if (v26)
        {
          v28 = CFGetTypeID(v26);
          if (v28 != CFDataGetTypeID())
            v27 = 0;
        }
        v29 = (const __CFData *)CFDictionaryGetValue(v5, (const void *)*MEMORY[0x24BDC3E00]);
        v30 = v29;
        if (v29)
        {
          v31 = CFGetTypeID(v29);
          if (v31 != CFDataGetTypeID())
            v30 = 0;
        }
        v32 = (unsigned __int16 *)CFDictionaryGetValue(v5, (const void *)*MEMORY[0x24BDC3E48]);
        v33 = v32;
        if (v32)
        {
          v34 = CFGetTypeID(v32);
          if (v34 != CFNumberGetTypeID())
            v33 = 0;
        }
        v35 = (unsigned __int16 *)CFDictionaryGetValue(v5, (const void *)*MEMORY[0x24BDC3E08]);
        v37 = v35;
        if (v35)
        {
          v38 = CFGetTypeID(v35);
          if (v38 != CFNumberGetTypeID())
            v37 = 0;
        }
        if (v27 && CFDataGetLength(v27) == 4)
        {
          BytePtr = CFDataGetBytePtr(v27);
          HIDWORD(v40) = -1;
          LODWORD(v40) = *(_DWORD *)BytePtr;
        }
        else
        {
          v40 = 0;
        }
        v89 = v40;
        if (v30 && CFDataGetLength(v30) == 4)
        {
          v55 = CFDataGetBytePtr(v30);
          HIDWORD(v56) = -1;
          LODWORD(v56) = *(_DWORD *)v55;
        }
        else
        {
          v56 = 0;
        }
        v88 = v56;
        if (v33)
        {
          *(_WORD *)buf = 0;
          ctu::cf::assign((ctu::cf *)buf, v33, v36);
          v57 = *(_WORD *)buf;
        }
        else
        {
          v57 = 0;
        }
        if (v37)
        {
          *(_WORD *)buf = 0;
          ctu::cf::assign((ctu::cf *)buf, v37, v36);
          v58 = *(_WORD *)buf;
        }
        else
        {
          v58 = 0;
        }
        v59 = operator new();
        v60 = v59;
        *(_BYTE *)(v59 + 8) = 16;
        *(_QWORD *)v59 = &off_24D5EBF08;
        v61 = v93;
        if ((unint64_t)v93 < *((_QWORD *)&v93 + 1))
        {
          *(_QWORD *)v93 = v59;
          v62 = (_QWORD *)(v61 + 8);
LABEL_108:
          *(_QWORD *)&v93 = v62;
          *(_WORD *)(v60 + 12) = 0;
          *(_WORD *)(v60 + 14) = v18;
          *(_BYTE *)(v60 + 16) = v23;
          *(_WORD *)(v60 + 17) = 1024;
          *(_BYTE *)(v60 + 19) = 0;
          *(_WORD *)(v60 + 20) = v57;
          *(_WORD *)(v60 + 22) = 0;
          *(_WORD *)(v60 + 24) = v58;
          *(_WORD *)(v60 + 26) = 0;
          *(_QWORD *)(v60 + 28) = v89;
          *(_QWORD *)(v60 + 36) = v88;
LABEL_116:
          theDict[0] = (CFDictionaryRef)(a1 + 72);
          theDict[1] = (CFDictionaryRef)QMIServiceMsg::create();
          v96 = 25000;
          v97 = 0;
          aBlock = 0;
          v90[0] = MEMORY[0x24BDAC760];
          v90[1] = 0x40000000;
          v90[2] = ___ZN14QMIQOSClientIP10requestQosE15DataQosFlowTypeN3ctu2cf11CFSharedRefIK14__CFDictionaryEEj_block_invoke;
          v90[3] = &__block_descriptor_tmp_134_0;
          v90[4] = a1;
          v91 = a4;
          *(_QWORD *)buf = MEMORY[0x24BDAC760];
          *(_QWORD *)&buf[8] = 0x40000000;
          *(_QWORD *)&buf[16] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3qos10RequestQos8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
          v100 = &unk_24D5EBE60;
          v101 = v90;
          v86 = _Block_copy(buf);
          aBlock = v86;
          if (theDict[1])
          {
            qmi::Client::send();
            v86 = aBlock;
          }
          if (v86)
            _Block_release(v86);
          v9 = 1;
          goto LABEL_121;
        }
        v63 = (uint64_t)(v93 - (unint64_t)__p[1]) >> 3;
        if (!((unint64_t)(v63 + 1) >> 61))
        {
          v64 = (uint64_t)(*((_QWORD *)&v93 + 1) - (unint64_t)__p[1]) >> 2;
          if (v64 <= v63 + 1)
            v64 = v63 + 1;
          if (*((_QWORD *)&v93 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
            v65 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v65 = v64;
          if (v65)
            v66 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v93 + 8, v65);
          else
            v66 = 0;
          v76 = (uint64_t *)&v66[8 * v63];
          v77 = &v66[8 * v65];
          *v76 = v60;
          v62 = v76 + 1;
          v79 = (char *)__p[1];
          v78 = (char *)v93;
          if ((void *)v93 != __p[1])
          {
            do
            {
              v80 = *((_QWORD *)v78 - 1);
              v78 -= 8;
              *--v76 = v80;
            }
            while (v78 != v79);
            v78 = (char *)__p[1];
          }
          __p[1] = v76;
          *(_QWORD *)&v93 = v62;
          *((_QWORD *)&v93 + 1) = v77;
          if (v78)
            operator delete(v78);
          goto LABEL_108;
        }
LABEL_123:
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      }
      *(_QWORD *)buf = 0;
      *(_QWORD *)&buf[8] = 0;
      theDict[0] = 0;
      theDict[1] = 0;
      v42 = (const __CFData *)CFDictionaryGetValue(v5, (const void *)*MEMORY[0x24BDC3E40]);
      v43 = v42;
      if (v42)
      {
        v44 = CFGetTypeID(v42);
        if (v44 != CFDataGetTypeID())
          v43 = 0;
      }
      v45 = (const __CFData *)CFDictionaryGetValue(v5, (const void *)*MEMORY[0x24BDC3E00]);
      v46 = v45;
      if (v45)
      {
        v47 = CFGetTypeID(v45);
        if (v47 != CFDataGetTypeID())
          v46 = 0;
      }
      v48 = (unsigned __int16 *)CFDictionaryGetValue(v5, (const void *)*MEMORY[0x24BDC3E48]);
      v49 = v48;
      if (v48)
      {
        v50 = CFGetTypeID(v48);
        if (v50 != CFNumberGetTypeID())
          v49 = 0;
      }
      v51 = (unsigned __int16 *)CFDictionaryGetValue(v5, (const void *)*MEMORY[0x24BDC3E08]);
      v53 = v51;
      if (v51)
      {
        v54 = CFGetTypeID(v51);
        if (v54 != CFNumberGetTypeID())
          v53 = 0;
      }
      if (v43)
      {
        if (CFDataGetLength(v43) == 16)
        {
          *(_OWORD *)buf = *(_OWORD *)CFDataGetBytePtr(v43);
          LOBYTE(v43) = 0x80;
        }
        else
        {
          LOBYTE(v43) = 0;
        }
      }
      if (v46)
      {
        if (CFDataGetLength(v46) == 16)
        {
          *(_OWORD *)theDict = *(_OWORD *)CFDataGetBytePtr(v46);
          LOBYTE(v46) = 0x80;
        }
        else
        {
          LOBYTE(v46) = 0;
        }
      }
      if (v49)
      {
        v94 = 0;
        ctu::cf::assign((ctu::cf *)&v94, v49, v52);
        LOWORD(v49) = v94;
      }
      if (v53)
      {
        v94 = 0;
        ctu::cf::assign((ctu::cf *)&v94, v53, v52);
        v67 = v94;
      }
      else
      {
        v67 = 0;
      }
      v68 = operator new();
      v69 = v68;
      *(_BYTE *)(v68 + 8) = 16;
      *(_QWORD *)v68 = &off_24D5EBF58;
      v70 = v93;
      if ((unint64_t)v93 >= *((_QWORD *)&v93 + 1))
      {
        v72 = (uint64_t)(v93 - (unint64_t)__p[1]) >> 3;
        if ((unint64_t)(v72 + 1) >> 61)
          goto LABEL_123;
        v73 = (uint64_t)(*((_QWORD *)&v93 + 1) - (unint64_t)__p[1]) >> 2;
        if (v73 <= v72 + 1)
          v73 = v72 + 1;
        if (*((_QWORD *)&v93 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v74 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v74 = v73;
        if (v74)
          v75 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v93 + 8, v74);
        else
          v75 = 0;
        v81 = (uint64_t *)&v75[8 * v72];
        v82 = &v75[8 * v74];
        *v81 = v69;
        v71 = v81 + 1;
        v84 = (char *)__p[1];
        v83 = (char *)v93;
        if ((void *)v93 != __p[1])
        {
          do
          {
            v85 = *((_QWORD *)v83 - 1);
            v83 -= 8;
            *--v81 = v85;
          }
          while (v83 != v84);
          v83 = (char *)__p[1];
        }
        __p[1] = v81;
        *(_QWORD *)&v93 = v71;
        *((_QWORD *)&v93 + 1) = v82;
        if (v83)
          operator delete(v83);
      }
      else
      {
        *(_QWORD *)v93 = v68;
        v71 = (_QWORD *)(v70 + 8);
      }
      *(_QWORD *)&v93 = v71;
      *(_WORD *)(v69 + 10) = 0;
      *(_WORD *)(v69 + 12) = v18;
      *(_BYTE *)(v69 + 14) = v23;
      *(_WORD *)(v69 + 15) = 1536;
      *(_BYTE *)(v69 + 17) = 0;
      *(_WORD *)(v69 + 18) = (_WORD)v49;
      *(_WORD *)(v69 + 20) = 0;
      *(_WORD *)(v69 + 22) = v67;
      *(_WORD *)(v69 + 24) = 0;
      *(_OWORD *)(v69 + 26) = *(_OWORD *)buf;
      *(_BYTE *)(v69 + 42) = (_BYTE)v43;
      *(_OWORD *)(v69 + 43) = *(_OWORD *)theDict;
      *(_BYTE *)(v69 + 59) = (_BYTE)v46;
      goto LABEL_116;
    }
    v11 = *(NSObject **)(a1 + 40);
    v9 = 0;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = "requestQos";
      v12 = "#I %s: Flow Dictionary not present";
      goto LABEL_9;
    }
  }
  else
  {
    v11 = *(NSObject **)(a1 + 40);
    v9 = 0;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = "requestQos";
      v12 = "#I %s: QOS Client not ready yet";
LABEL_9:
      _os_log_impl(&dword_216897000, v11, OS_LOG_TYPE_DEFAULT, v12, buf, 0xCu);
      return 0;
    }
  }
  return v9;
}

void sub_216A8C4F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  uint64_t v12;
  va_list va;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  va_list va1;

  va_start(va1, a11);
  va_start(va, a11);
  v12 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  v18 = va_arg(va1, _QWORD);
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)va1);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

void ___ZN14QMIQOSClientIP10requestQosE15DataQosFlowTypeN3ctu2cf11CFSharedRefIK14__CFDictionaryEEj_block_invoke(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v2;
  int v5;
  NSObject *v6;
  unsigned __int8 *TlvValue;
  int v8;
  unsigned __int8 *v9;
  int v10;
  unsigned __int8 *v11;
  unsigned int *begin;
  NSObject *v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  char v17;
  std::vector<unsigned int> __p;
  unsigned __int8 *v19;
  _BYTE buf[24];
  int v21;
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 32);
  if (*(_BYTE *)(v2 + 108))
    return;
  v5 = *((_DWORD *)a2 + 1);
  v6 = *(NSObject **)(v2 + 40);
  if (v5)
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109378;
      *(_DWORD *)&buf[4] = v5;
      *(_WORD *)&buf[8] = 2080;
      *(_QWORD *)&buf[10] = qmi::asString();
      _os_log_error_impl(&dword_216897000, v6, OS_LOG_TYPE_ERROR, "Error in response to RequestQos with code = 0x%x (%s)", buf, 0x12u);
    }
    (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)(v2 + 64) + 48))(*(_QWORD *)(v2 + 64), *(unsigned int *)(a1 + 40));
    return;
  }
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315138;
    *(_QWORD *)&buf[4] = "requestQos_block_invoke";
    _os_log_impl(&dword_216897000, v6, OS_LOG_TYPE_DEFAULT, "#I %s: Response to RequestQos received", buf, 0xCu);
  }
  *(_QWORD *)buf = 0;
  *(_QWORD *)&buf[8] = buf;
  *(_QWORD *)&buf[16] = 0x2000000000;
  v21 = 0;
  v14 = 0;
  v15 = &v14;
  v16 = 0x2000000000;
  v17 = 0;
  TlvValue = (unsigned __int8 *)qmi::MessageBase::findTlvValue(a2);
  v9 = TlvValue;
  if (TlvValue)
  {
    v10 = v8;
    v19 = TlvValue;
    memset(&__p, 0, sizeof(__p));
    tlv::parseV<qos::tlv::IdentifierList>(&v19, v8, &__p);
    v11 = v19;
    begin = __p.__begin_;
    if (!v19 || __p.__end_ == __p.__begin_)
    {
      if (!__p.__begin_)
        goto LABEL_14;
    }
    else
    {
      *(_DWORD *)(*(_QWORD *)&buf[8] + 24) = *__p.__begin_;
      *((_BYTE *)v15 + 24) = 1;
    }
    __p.__end_ = begin;
    operator delete(begin);
LABEL_14:
    if (!v11)
      ((void (*)(_QWORD, uint64_t, unsigned __int8 *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 1, v9, v10);
  }
  if (*((_BYTE *)v15 + 24))
  {
    (*(void (**)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)(v2 + 64) + 40))(*(_QWORD *)(v2 + 64), *(unsigned int *)(a1 + 40), *(unsigned int *)(*(_QWORD *)&buf[8] + 24));
  }
  else
  {
    v13 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p.__begin_) = 0;
      _os_log_error_impl(&dword_216897000, v13, OS_LOG_TYPE_ERROR, "Error: Mandatory TLV fIdentifiers not present/valid", (uint8_t *)&__p, 2u);
    }
    (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)(v2 + 64) + 48))(*(_QWORD *)(v2 + 64), *(unsigned int *)(a1 + 40));
  }
  _Block_object_dispose(&v14, 8);
  _Block_object_dispose(buf, 8);
}

void sub_216A8C7DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  _Unwind_Resume(exception_object);
}

void QMIQOSClientIP::releaseQos(QMIQOSClientIP *this, int a2)
{
  uint64_t v4;
  const void **v5;
  NSObject *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  char *v16;
  uint64_t *v17;
  char *v18;
  char *v19;
  char *v20;
  uint64_t v21;
  void *v22;
  _QWORD v23[6];
  uint64_t v24;
  int v25;
  uint64_t v26;
  void *aBlock;
  _QWORD v28[4];
  int v29;
  void *__p[2];
  __int128 v31;
  __int128 buf;
  void (*v33)(uint64_t, QMIServiceMsg *);
  void *v34;
  _QWORD *v35;
  uint64_t v36;

  v36 = *MEMORY[0x24BDAC8D0];
  if (*((_QWORD *)this + 11) && *((_BYTE *)this + 109))
  {
    v31 = 0u;
    *(_OWORD *)__p = 0u;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
    v4 = MEMORY[0x24BDAC760];
    v28[0] = MEMORY[0x24BDAC760];
    v28[1] = 0x40000000;
    v28[2] = ___ZN14QMIQOSClientIP10releaseQosEj_block_invoke;
    v28[3] = &__block_descriptor_tmp_135_1;
    v29 = a2;
    v5 = (const void **)__p[1];
    if (__p[1] != (void *)v31)
    {
      while (*((_BYTE *)*v5 + 8) != 1)
      {
        if (++v5 == (const void **)v31)
          goto LABEL_12;
      }
    }
    if (v5 == (const void **)v31)
    {
LABEL_12:
      v9 = operator new();
      v10 = v9;
      *(_BYTE *)(v9 + 8) = 1;
      *(_QWORD *)(v9 + 16) = 0;
      v8 = v9 + 16;
      *(_QWORD *)v9 = &off_24D5EBEA8;
      *(_QWORD *)(v9 + 24) = 0;
      *(_QWORD *)(v9 + 32) = 0;
      v11 = v31;
      if ((unint64_t)v31 >= *((_QWORD *)&v31 + 1))
      {
        v13 = (uint64_t)(v31 - (unint64_t)__p[1]) >> 3;
        if ((unint64_t)(v13 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v14 = (uint64_t)(*((_QWORD *)&v31 + 1) - (unint64_t)__p[1]) >> 2;
        if (v14 <= v13 + 1)
          v14 = v13 + 1;
        if (*((_QWORD *)&v31 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v15 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v15 = v14;
        if (v15)
          v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v31 + 8, v15);
        else
          v16 = 0;
        v17 = (uint64_t *)&v16[8 * v13];
        v18 = &v16[8 * v15];
        *v17 = v10;
        v12 = v17 + 1;
        v20 = (char *)__p[1];
        v19 = (char *)v31;
        if ((void *)v31 != __p[1])
        {
          do
          {
            v21 = *((_QWORD *)v19 - 1);
            v19 -= 8;
            *--v17 = v21;
          }
          while (v19 != v20);
          v19 = (char *)__p[1];
        }
        __p[1] = v17;
        *(_QWORD *)&v31 = v12;
        *((_QWORD *)&v31 + 1) = v18;
        if (v19)
          operator delete(v19);
      }
      else
      {
        *(_QWORD *)v31 = v9;
        v12 = (_QWORD *)(v11 + 8);
      }
      *(_QWORD *)&v31 = v12;
    }
    else
    {
      if (!v7)
        __cxa_bad_cast();
      v8 = (uint64_t)v7 + 16;
    }
    ___ZN14QMIQOSClientIP10releaseQosEj_block_invoke((uint64_t)v28, v8);
    v23[5] = (char *)this + 72;
    v24 = QMIServiceMsg::create();
    v25 = 25000;
    v26 = 0;
    aBlock = 0;
    v23[0] = v4;
    v23[1] = 0x40000000;
    v23[2] = ___ZN14QMIQOSClientIP10releaseQosEj_block_invoke_2;
    v23[3] = &__block_descriptor_tmp_136_0;
    v23[4] = this;
    *(_QWORD *)&buf = v4;
    *((_QWORD *)&buf + 1) = 0x40000000;
    v33 = ___ZNO3qmi6Client9SendProxy8callbackIRKN3qos10ReleaseQos8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
    v34 = &unk_24D5EBED8;
    v35 = v23;
    v22 = _Block_copy(&buf);
    aBlock = v22;
    if (v24)
    {
      qmi::Client::send();
      v22 = aBlock;
    }
    if (v22)
      _Block_release(v22);
    qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
  }
  else
  {
    v6 = *((_QWORD *)this + 5);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 136315138;
      *(_QWORD *)((char *)&buf + 4) = "releaseQos";
      _os_log_impl(&dword_216897000, v6, OS_LOG_TYPE_DEFAULT, "#I %s: QOS Client not ready yet", (uint8_t *)&buf, 0xCu);
    }
  }
}

void sub_216A8CB28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v8;
  va_list va;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  va_list va1;

  va_start(va1, a7);
  va_start(va, a7);
  v8 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  v18 = va_arg(va1, _QWORD);
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)va);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va1);
  _Unwind_Resume(a1);
}

void ___ZN14QMIQOSClientIP10releaseQosEj_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  _DWORD *v6;
  _DWORD *v7;
  _DWORD *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  int v16;

  v4 = a2 + 16;
  v5 = *(_QWORD *)(a2 + 16);
  v6 = *(_DWORD **)(a2 + 8);
  if ((unint64_t)v6 >= v5)
  {
    v8 = *(_DWORD **)a2;
    v9 = ((uint64_t)v6 - *(_QWORD *)a2) >> 2;
    v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 62)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v11 = v5 - (_QWORD)v8;
    if (v11 >> 1 > v10)
      v10 = v11 >> 1;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFFCLL)
      v12 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v12 = v10;
    if (v12)
    {
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::array<unsigned char,4ul>>>(v4, v12);
      v8 = *(_DWORD **)a2;
      v6 = *(_DWORD **)(a2 + 8);
    }
    else
    {
      v13 = 0;
    }
    v14 = &v13[4 * v9];
    v15 = &v13[4 * v12];
    *(_DWORD *)v14 = *(_DWORD *)(a1 + 32);
    v7 = v14 + 4;
    while (v6 != v8)
    {
      v16 = *--v6;
      *((_DWORD *)v14 - 1) = v16;
      v14 -= 4;
    }
    *(_QWORD *)a2 = v14;
    *(_QWORD *)(a2 + 8) = v7;
    *(_QWORD *)(a2 + 16) = v15;
    if (v8)
      operator delete(v8);
  }
  else
  {
    *v6 = *(_DWORD *)(a1 + 32);
    v7 = v6 + 1;
  }
  *(_QWORD *)(a2 + 8) = v7;
}

void ___ZN14QMIQOSClientIP10releaseQosEj_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  NSObject *v4;
  _DWORD v5[2];
  __int16 v6;
  uint64_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)(v2 + 108))
  {
    v3 = *(_DWORD *)(a2 + 4);
    v4 = *(NSObject **)(v2 + 40);
    if (v3)
    {
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        v5[0] = 67109378;
        v5[1] = v3;
        v6 = 2080;
        v7 = qmi::asString();
        _os_log_error_impl(&dword_216897000, v4, OS_LOG_TYPE_ERROR, "Error in response to ReleaseQos with code = 0x%x (%s)", (uint8_t *)v5, 0x12u);
      }
    }
    else if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v5[0]) = 0;
      _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I Response to ReleaseQos received", (uint8_t *)v5, 2u);
    }
  }
}

uint64_t std::__optional_move_base<DataQoS,false>::__optional_move_base[abi:ne180100](uint64_t result, __int128 *a2)
{
  __int128 v2;

  *(_BYTE *)result = 0;
  *(_BYTE *)(result + 56) = 0;
  if (*((_BYTE *)a2 + 56))
  {
    v2 = *a2;
    *(_QWORD *)(result + 13) = *(_QWORD *)((char *)a2 + 13);
    *(_OWORD *)result = v2;
    *(_BYTE *)(result + 24) = 0;
    *(_BYTE *)(result + 48) = 0;
    if (*((_BYTE *)a2 + 48))
    {
      *(_QWORD *)(result + 24) = 0;
      *(_QWORD *)(result + 32) = 0;
      *(_QWORD *)(result + 40) = 0;
      *(_OWORD *)(result + 24) = *(__int128 *)((char *)a2 + 24);
      *(_QWORD *)(result + 40) = *((_QWORD *)a2 + 5);
      *((_QWORD *)a2 + 3) = 0;
      *((_QWORD *)a2 + 4) = 0;
      *((_QWORD *)a2 + 5) = 0;
      *(_BYTE *)(result + 48) = 1;
    }
    *(_BYTE *)(result + 56) = 1;
  }
  return result;
}

void std::vector<DataIPFilter>::__vdeallocate(uint64_t *a1)
{
  if (*a1)
  {
    std::vector<DataIPFilter>::__base_destruct_at_end[abi:ne180100]((uint64_t)a1, *a1);
    operator delete((void *)*a1);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

char *std::vector<DataIPFilter>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >= 0x19999999999999ALL)
    std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<DataIPFilter>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[160 * v4];
  return result;
}

_QWORD *std::vector<DataIPFilter>::__init_with_size[abi:ne180100]<DataIPFilter*,DataIPFilter*>(_QWORD *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;

  if (a4)
  {
    v6 = result;
    std::vector<DataIPFilter>::__vallocate[abi:ne180100](result, a4);
    result = (_QWORD *)std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<DataIPFilter>,DataIPFilter*,DataIPFilter*,DataIPFilter*>((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_216A8CE94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  uint64_t v9;
  uint64_t v10;

  *(_QWORD *)(v9 + 8) = v10;
  std::vector<DataIPFilter>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

uint64_t std::vector<DataIPFilter>::__emplace_back_slow_path<DataIPFilter&>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  uint64_t v11;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  uint64_t *v17;

  v3 = *a1;
  v4 = 0xCCCCCCCCCCCCCCCDLL * ((a1[1] - *a1) >> 5);
  v5 = v4 + 1;
  if (v4 + 1 > 0x199999999999999)
    std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
  v7 = (uint64_t)(a1 + 2);
  v8 = 0xCCCCCCCCCCCCCCCDLL * ((a1[2] - v3) >> 5);
  if (2 * v8 > v5)
    v5 = 2 * v8;
  if (v8 >= 0xCCCCCCCCCCCCCCLL)
    v9 = 0x199999999999999;
  else
    v9 = v5;
  v17 = a1 + 2;
  if (v9)
    v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<DataIPFilter>>(v7, v9);
  else
    v10 = 0;
  v13 = v10;
  v14 = &v10[160 * v4];
  v16 = &v10[160 * v9];
  std::construct_at[abi:ne180100]<DataIPFilter,DataIPFilter&,DataIPFilter*>((uint64_t)v14, a2);
  v15 = v14 + 160;
  std::vector<DataIPFilter>::__swap_out_circular_buffer(a1, &v13);
  v11 = a1[1];
  std::__split_buffer<DataIPFilter>::~__split_buffer((uint64_t)&v13);
  return v11;
}

void sub_216A8CFA4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<DataIPFilter>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::vector<qos::tlv::FlowInfo>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 352;
        std::__destroy_at[abi:ne180100]<qos::tlv::FlowInfo,0>(v4);
      }
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::__destroy_at[abi:ne180100]<qos::tlv::FlowInfo,0>(uint64_t a1)
{
  void **v2;

  if (*(_BYTE *)(a1 + 348))
    *(_BYTE *)(a1 + 348) = 0;
  if (*(_BYTE *)(a1 + 346))
    *(_BYTE *)(a1 + 346) = 0;
  if (*(_BYTE *)(a1 + 344))
    *(_BYTE *)(a1 + 344) = 0;
  if (*(_BYTE *)(a1 + 208))
  {
    qos::tlv::FlowSpec::~FlowSpec((qos::tlv::FlowSpec *)(a1 + 216));
    *(_BYTE *)(a1 + 208) = 0;
  }
  if (*(_BYTE *)(a1 + 72))
  {
    qos::tlv::FlowSpec::~FlowSpec((qos::tlv::FlowSpec *)(a1 + 80));
    *(_BYTE *)(a1 + 72) = 0;
  }
  if (*(_BYTE *)(a1 + 40))
  {
    v2 = (void **)(a1 + 48);
    std::vector<tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>>::__destroy_vector::operator()[abi:ne180100](&v2);
    *(_BYTE *)(a1 + 40) = 0;
  }
  if (*(_BYTE *)(a1 + 8))
  {
    v2 = (void **)(a1 + 16);
    std::vector<tlv::NestedTlv<(unsigned char)16,qos::tlv::QoSFilter>>::__destroy_vector::operator()[abi:ne180100](&v2);
    *(_BYTE *)(a1 + 8) = 0;
  }
}

void ___ZNK3qmi6Client13setIndHandlerIRKN3qos9QosStatus10IndicationEEEvtU13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A8D18C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ___ZNK3qmi6Client13setIndHandlerIRKN3qos14EventReportInd10IndicationEEEvtU13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A8D288(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ___ZNK3qmi6Client13setIndHandlerIRKN3qos16GlobalQosFlowInd10IndicationEEEvtU13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A8D384(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<qos::tlv::SubscriptionType>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<qos::tlv::SubscriptionType>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

_DWORD **qmi::MutableMessageBase::TlvWrapper<qos::tlv::SubscriptionType>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _DWORD *v4;
  uint64_t v5;
  _DWORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_DWORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::PktDataHandle>((_DWORD **)a2, (_DWORD *)(a1 + 12));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<qos::tlv::SubscriptionType>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5EB958;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a1 + 12);
  return result;
}

void std::__function::__func<QMIQOSClientIP::bindDataPort_sync(void)::$_0,std::allocator<QMIQOSClientIP::bindDataPort_sync(void)::$_0>,void ()(void)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<QMIQOSClientIP::bindDataPort_sync(void)::$_0,std::allocator<QMIQOSClientIP::bindDataPort_sync(void)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5EB9B8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<QMIQOSClientIP::bindDataPort_sync(void)::$_0,std::allocator<QMIQOSClientIP::bindDataPort_sync(void)::$_0>,void ()(void)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5EB9B8;
  a2[1] = v2;
  return result;
}

_QWORD *std::__function::__func<QMIQOSClientIP::bindDataPort_sync(void)::$_0,std::allocator<QMIQOSClientIP::bindDataPort_sync(void)::$_0>,void ()(void)>::operator()(capabilities::ct *a1)
{
  _QWORD *v1;
  int v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  const void **v7;
  char *v8;
  int *v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  char *v18;
  uint64_t *v19;
  char *v20;
  char *v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  _QWORD *v25;
  uint64_t v26;
  void *v27;
  uint64_t v28;
  _QWORD *v29;
  uint64_t v30;
  _QWORD *result;
  uint64_t v32;
  uint64_t v33;
  void *v34;
  void *__p[2];
  __int128 v36;
  _QWORD aBlock[5];
  _QWORD v38[3];
  _QWORD *v39;
  _QWORD v40[3];
  _QWORD *v41;
  uint8_t buf[8];
  uint64_t v43;
  uint64_t (*v44)(uint64_t, uint64_t);
  void *v45;
  _QWORD *v46;
  _BYTE v47[24];
  _BYTE *v48;
  int v49;
  uint64_t v50;

  v50 = *MEMORY[0x24BDAC8D0];
  v1 = (_QWORD *)*((_QWORD *)a1 + 1);
  v40[0] = &off_24D5EBA28;
  v40[1] = v1;
  v40[2] = 0;
  v41 = v40;
  v2 = capabilities::ct::supportsGemini(a1);
  v3 = (uint64_t)v41;
  if (!v2)
  {
    if (!v41)
      std::__throw_bad_function_call[abi:ne180100]();
    (*(void (**)(void))(*v41 + 48))();
    goto LABEL_61;
  }
  if (!v41)
    goto LABEL_5;
  if (v41 != v40)
  {
    v3 = (*(uint64_t (**)(void))(*v41 + 16))();
LABEL_5:
    v39 = (_QWORD *)v3;
    goto LABEL_9;
  }
  v39 = v38;
  (*(void (**)(_QWORD *, _QWORD *))(v40[0] + 24))(v40, v38);
LABEL_9:
  if (!v1[11])
  {
    v10 = v1[5];
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_216897000, v10, OS_LOG_TYPE_ERROR, "bindSubscription after client is deleted", buf, 2u);
    }
    if (!v39)
      std::__throw_bad_function_call[abi:ne180100]();
    (*(void (**)(_QWORD *))(*v39 + 48))(v39);
    goto LABEL_56;
  }
  v4 = v1[8] + *(_QWORD *)(*(_QWORD *)v1[8] - 56);
  v5 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
  subscriber::simSlotAsInstance();
  qmi::Client::set((qmi::Client *)(v1 + 9), (const char *)*MEMORY[0x24BED1E20]);
  *(_OWORD *)__p = 0u;
  v36 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  if (v5 == 2)
    v6 = 2;
  else
    v6 = 1;
  v7 = (const void **)__p[1];
  if (__p[1] != (void *)v36)
  {
    while (*((_BYTE *)*v7 + 8) != 1)
    {
      if (++v7 == (const void **)v36)
        goto LABEL_24;
    }
  }
  if (v7 == (const void **)v36)
  {
LABEL_24:
    v11 = operator new();
    v12 = v11;
    *(_BYTE *)(v11 + 8) = 1;
    *(_QWORD *)v11 = &off_24D5EB958;
    *(_DWORD *)(v11 + 12) = 0;
    v9 = (int *)(v11 + 12);
    v13 = v36;
    if ((unint64_t)v36 >= *((_QWORD *)&v36 + 1))
    {
      v15 = (uint64_t)(v36 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v15 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v16 = (uint64_t)(*((_QWORD *)&v36 + 1) - (unint64_t)__p[1]) >> 2;
      if (v16 <= v15 + 1)
        v16 = v15 + 1;
      if (*((_QWORD *)&v36 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v17 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v17 = v16;
      if (v17)
        v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v36 + 8, v17);
      else
        v18 = 0;
      v19 = (uint64_t *)&v18[8 * v15];
      v20 = &v18[8 * v17];
      *v19 = v12;
      v14 = v19 + 1;
      v22 = (char *)__p[1];
      v21 = (char *)v36;
      if ((void *)v36 != __p[1])
      {
        do
        {
          v23 = *((_QWORD *)v21 - 1);
          v21 -= 8;
          *--v19 = v23;
        }
        while (v21 != v22);
        v21 = (char *)__p[1];
      }
      __p[1] = v19;
      *(_QWORD *)&v36 = v14;
      *((_QWORD *)&v36 + 1) = v20;
      if (v21)
        operator delete(v21);
    }
    else
    {
      *(_QWORD *)v36 = v11;
      v14 = (_QWORD *)(v13 + 8);
    }
    *(_QWORD *)&v36 = v14;
  }
  else
  {
    if (!v8)
      __cxa_bad_cast();
    v9 = (int *)(v8 + 12);
  }
  *v9 = v6;
  v33 = QMIServiceMsg::create();
  v24 = MEMORY[0x24BDAC760];
  *(_QWORD *)buf = MEMORY[0x24BDAC760];
  v43 = 1174405120;
  v44 = ___ZN14QMIQOSClientIP21bindSubscription_syncENSt3__18functionIFvvEEE_block_invoke;
  v45 = &__block_descriptor_tmp_76_6;
  v46 = v1;
  v49 = v5;
  v25 = v47;
  v26 = (uint64_t)v39;
  if (!v39)
    goto LABEL_44;
  if (v39 != v38)
  {
    v26 = (*(uint64_t (**)(void))(*v39 + 16))();
LABEL_44:
    v48 = (_BYTE *)v26;
    goto LABEL_46;
  }
  v48 = v47;
  (*(void (**)(_QWORD *, _BYTE *))(v38[0] + 24))(v38, v47);
LABEL_46:
  aBlock[0] = v24;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_32;
  aBlock[3] = &unk_24D5EB988;
  aBlock[4] = buf;
  v27 = _Block_copy(aBlock);
  v34 = v27;
  if (v33)
  {
    qmi::Client::send();
    v27 = v34;
  }
  if (v27)
    _Block_release(v27);
  if (v48 == v47)
  {
    v28 = 4;
    goto LABEL_54;
  }
  if (v48)
  {
    v28 = 5;
    v25 = v48;
LABEL_54:
    (*(void (**)(_QWORD *))(*v25 + 8 * v28))(v25);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
LABEL_56:
  v29 = v39;
  if (v39 == v38)
  {
    v30 = 4;
    v29 = v38;
  }
  else
  {
    if (!v39)
      goto LABEL_61;
    v30 = 5;
  }
  (*(void (**)(void))(*v29 + 8 * v30))();
LABEL_61:
  result = v41;
  if (v41 == v40)
  {
    v32 = 4;
    result = v40;
  }
  else
  {
    if (!v41)
      return result;
    v32 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v32))();
}

void sub_216A8D98C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,char *a28,char a29,uint64_t a30,uint64_t a31,char *a32)
{
  char *v33;
  uint64_t v34;
  char *v35;
  uint64_t v36;

  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)&a10);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a15);
  v33 = a28;
  if (a28 == &a25)
  {
    v34 = 4;
    v33 = &a25;
  }
  else
  {
    if (!a28)
      goto LABEL_6;
    v34 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v33 + 8 * v34))();
LABEL_6:
  v35 = a32;
  if (a32 == &a29)
  {
    v36 = 4;
    v35 = &a29;
  }
  else
  {
    if (!a32)
      goto LABEL_11;
    v36 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v35 + 8 * v36))();
LABEL_11:
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<QMIQOSClientIP::bindDataPort_sync(void)::$_0,std::allocator<QMIQOSClientIP::bindDataPort_sync(void)::$_0>,void ()(void)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<QMIQOSClientIP::bindDataPort_sync(void)::$_0,std::allocator<QMIQOSClientIP::bindDataPort_sync(void)::$_0>,void ()(void)>::target_type()
{
}

void std::__function::__func<QMIQOSClientIP::bindDataPort_sync(void)::$_0::operator() const(void)::{lambda(void)#1},std::allocator<QMIQOSClientIP::bindDataPort_sync(void)::$_0::operator() const(void)::{lambda(void)#1}>,void ()(void)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<QMIQOSClientIP::bindDataPort_sync(void)::$_0::operator() const(void)::{lambda(void)#1},std::allocator<QMIQOSClientIP::bindDataPort_sync(void)::$_0::operator() const(void)::{lambda(void)#1}>,void ()(void)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5EBA28;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<QMIQOSClientIP::bindDataPort_sync(void)::$_0::operator() const(void)::{lambda(void)#1},std::allocator<QMIQOSClientIP::bindDataPort_sync(void)::$_0::operator() const(void)::{lambda(void)#1}>,void ()(void)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5EBA28;
  a2[1] = v2;
  return result;
}

void std::__function::__func<QMIQOSClientIP::bindDataPort_sync(void)::$_0::operator() const(void)::{lambda(void)#1},std::allocator<QMIQOSClientIP::bindDataPort_sync(void)::$_0::operator() const(void)::{lambda(void)#1}>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v1;
  _QWORD *v2;
  int v3;
  char *v4;
  char v5;
  NSObject *v6;
  uint64_t v7;
  void *v8;
  capabilities::ct *v9;
  const void **v10;
  const void **v11;
  char *v12;
  _BYTE *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  char *v20;
  const void **v21;
  char *v22;
  char *v23;
  char *v24;
  const void *v25;
  const void **i;
  char *v27;
  char *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  _QWORD *v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  char *v36;
  uint64_t *v37;
  char *v38;
  char *v39;
  char *v40;
  uint64_t v41;
  void *v42;
  const void **v43;
  const void **v44;
  const void **v45;
  char *v46;
  _BYTE *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  unint64_t v52;
  unint64_t v53;
  char *v54;
  const void **v55;
  char *v56;
  char *v57;
  char *v58;
  const void *v59;
  char *v60;
  _BYTE *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  unint64_t v66;
  unint64_t v67;
  char *v68;
  const void **v69;
  char *v70;
  char *v71;
  char *v72;
  const void *v73;
  const void **j;
  char *v75;
  _BYTE *v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  _QWORD *v80;
  uint64_t v81;
  unint64_t v82;
  unint64_t v83;
  char *v84;
  uint64_t *v85;
  char *v86;
  char *v87;
  char *v88;
  uint64_t v89;
  void *v90;
  _QWORD v91[5];
  void *v92[2];
  __int128 v93;
  _QWORD v94[5];
  void *__p[2];
  __int128 v96;
  _QWORD v97[5];
  uint64_t v98;
  uint64_t v99;
  int v100;
  uint64_t v101;
  void *aBlock;
  uint8_t v103[32];
  _BYTE buf[24];
  void *v105;
  _QWORD *v106;
  uint64_t v107;

  v107 = *MEMORY[0x24BDAC8D0];
  v1 = *(_QWORD *)(a1 + 8);
  if (*(_QWORD *)(v1 + 88))
  {
    memset(v103, 0, sizeof(v103));
    v2 = (_QWORD *)qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v103);
    v3 = *(_DWORD *)(v1 + 104);
    if (v3 == 2)
    {
      v4 = qmi::MutableMessageBase::getTLV<qos::tlv::IpFamilyPref>(v2);
      v5 = 6;
    }
    else
    {
      if (v3 != 1)
      {
        if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315650;
          *(_QWORD *)&buf[4] = "wrong ip family";
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "/Library/Caches/com.apple.xbs/Sources/CoreTelephony/CommCenter/CommCenterCommandDrivers/"
                                "Data/QMI/Context/QMIQOSClientIP.cpp";
          *(_WORD *)&buf[22] = 1024;
          LODWORD(v105) = 324;
          _os_log_error_impl(&dword_216897000, MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR, "\n**********\n   ASSERT fIpFamilyType == kDataProtocolFamilyIPv4 || fIpFamilyType == kDataProtocolFamilyIPv6\n %s\n at %s:%d\n**********", buf, 0x1Cu);
          v3 = *(_DWORD *)(v1 + 104);
        }
        if ((v3 - 1) >= 2)
          __TUAssertTrigger();
        goto LABEL_151;
      }
      v4 = qmi::MutableMessageBase::getTLV<qos::tlv::IpFamilyPref>(v2);
      v5 = 4;
    }
    *v4 = v5;
    v98 = v1 + 72;
    v99 = QMIServiceMsg::create();
    v100 = 25000;
    v101 = 0;
    aBlock = 0;
    v7 = MEMORY[0x24BDAC760];
    v97[0] = MEMORY[0x24BDAC760];
    v97[1] = 0x40000000;
    v97[2] = ___ZN14QMIQOSClientIP14setupQMIClientEv_block_invoke_92;
    v97[3] = &__block_descriptor_tmp_93_1;
    v97[4] = v1;
    *(_QWORD *)buf = MEMORY[0x24BDAC760];
    *(_QWORD *)&buf[8] = 0x40000000;
    *(_QWORD *)&buf[16] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_32;
    v105 = &unk_24D5EB988;
    v106 = v97;
    v8 = _Block_copy(buf);
    aBlock = v8;
    if (v99)
    {
      qmi::Client::send();
      v8 = aBlock;
    }
    if (v8)
      _Block_release(v8);
    v96 = 0u;
    *(_OWORD *)__p = 0u;
    v9 = (capabilities::ct *)qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
    if (capabilities::ct::supportsDataQMIExtensions(v9))
    {
      v10 = (const void **)v96;
    }
    else
    {
      v11 = (const void **)__p[1];
      v10 = (const void **)v96;
      if (__p[1] != (void *)v96)
      {
        while (*((_BYTE *)*v11 + 8) != 16)
        {
          if (++v11 == (const void **)v96)
            goto LABEL_25;
        }
      }
      if (v11 == (const void **)v96)
      {
LABEL_25:
        v14 = operator new();
        v15 = v14;
        *(_WORD *)(v14 + 8) = 16;
        *(_QWORD *)v14 = &off_24D5EBBE8;
        v16 = v96;
        if ((unint64_t)v96 >= *((_QWORD *)&v96 + 1))
        {
          v17 = (uint64_t)(v96 - (unint64_t)__p[1]) >> 3;
          if ((unint64_t)(v17 + 1) >> 61)
            goto LABEL_153;
          v18 = (uint64_t)(*((_QWORD *)&v96 + 1) - (unint64_t)__p[1]) >> 2;
          if (v18 <= v17 + 1)
            v18 = v17 + 1;
          if (*((_QWORD *)&v96 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
            v19 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v19 = v18;
          if (v19)
            v20 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v96 + 8, v19);
          else
            v20 = 0;
          v21 = (const void **)&v20[8 * v17];
          v22 = &v20[8 * v19];
          *v21 = (const void *)v15;
          v10 = v21 + 1;
          v24 = (char *)__p[1];
          v23 = (char *)v96;
          if ((void *)v96 != __p[1])
          {
            do
            {
              v25 = (const void *)*((_QWORD *)v23 - 1);
              v23 -= 8;
              *--v21 = v25;
            }
            while (v23 != v24);
            v23 = (char *)__p[1];
          }
          __p[1] = v21;
          *(_QWORD *)&v96 = v10;
          *((_QWORD *)&v96 + 1) = v22;
          if (v23)
            operator delete(v23);
        }
        else
        {
          *(_QWORD *)v96 = v14;
          v10 = (const void **)(v16 + 8);
        }
        v13 = (_BYTE *)(v15 + 9);
        *(_QWORD *)&v96 = v10;
      }
      else
      {
        if (!v12)
          goto LABEL_155;
        v13 = v12 + 9;
      }
      *v13 = 1;
    }
    for (i = (const void **)__p[1]; ; ++i)
    {
      if (i == v10)
        goto LABEL_50;
      if (*((_BYTE *)*i + 8) == 17)
        break;
    }
    if (i != v10)
    {
      if (v27)
      {
        v28 = v27 + 10;
        goto LABEL_67;
      }
LABEL_155:
      __cxa_bad_cast();
    }
LABEL_50:
    v29 = operator new();
    v30 = v29;
    *(_BYTE *)(v29 + 8) = 17;
    *(_QWORD *)v29 = &off_24D5EBC38;
    *(_BYTE *)(v29 + 10) = 0;
    v28 = (char *)(v29 + 10);
    *(_WORD *)(v29 + 12) = 0;
    v31 = v96;
    if ((unint64_t)v96 < *((_QWORD *)&v96 + 1))
    {
      *(_QWORD *)v96 = v29;
      v32 = (_QWORD *)(v31 + 8);
LABEL_66:
      *(_QWORD *)&v96 = v32;
LABEL_67:
      *v28 = 1;
      *((_WORD *)v28 + 1) = -32764;
      v98 = v1 + 72;
      v99 = QMIServiceMsg::create();
      v100 = 25000;
      v101 = 0;
      aBlock = 0;
      v94[0] = v7;
      v94[1] = 0x40000000;
      v94[2] = ___ZN14QMIQOSClientIP14setupQMIClientEv_block_invoke_3;
      v94[3] = &__block_descriptor_tmp_102_2;
      v94[4] = v1;
      *(_QWORD *)buf = v7;
      *(_QWORD *)&buf[8] = 0x40000000;
      *(_QWORD *)&buf[16] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3qos14SetEventReport8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
      v105 = &unk_24D5EBC68;
      v106 = v94;
      v42 = _Block_copy(buf);
      aBlock = v42;
      if (v99)
      {
        qmi::Client::send();
        v42 = aBlock;
      }
      if (v42)
        _Block_release(v42);
      if (!capabilities::ct::supportsDataQMIExtensions((capabilities::ct *)v42))
        goto LABEL_150;
      *(_OWORD *)v92 = 0u;
      v93 = 0u;
      qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v92);
      v43 = (const void **)v92[1];
      v44 = (const void **)v93;
      v45 = (const void **)v92[1];
      if (v92[1] != (void *)v93)
      {
        v45 = (const void **)v92[1];
        while (*((_BYTE *)*v45 + 8) != 16)
        {
          if (++v45 == (const void **)v93)
            goto LABEL_80;
        }
      }
      if (v45 == (const void **)v93)
      {
LABEL_80:
        v48 = operator new();
        v49 = v48;
        *(_WORD *)(v48 + 8) = 16;
        *(_QWORD *)v48 = &off_24D5EBCB0;
        v50 = v93;
        if ((unint64_t)v93 >= *((_QWORD *)&v93 + 1))
        {
          v51 = (uint64_t)(v93 - (unint64_t)v92[1]) >> 3;
          if ((unint64_t)(v51 + 1) >> 61)
            goto LABEL_154;
          v52 = (uint64_t)(*((_QWORD *)&v93 + 1) - (unint64_t)v92[1]) >> 2;
          if (v52 <= v51 + 1)
            v52 = v51 + 1;
          if (*((_QWORD *)&v93 + 1) - (unint64_t)v92[1] >= 0x7FFFFFFFFFFFFFF8)
            v53 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v53 = v52;
          if (v53)
            v54 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v93 + 8, v53);
          else
            v54 = 0;
          v55 = (const void **)&v54[8 * v51];
          v56 = &v54[8 * v53];
          *v55 = (const void *)v49;
          v44 = v55 + 1;
          v58 = (char *)v92[1];
          v57 = (char *)v93;
          if ((void *)v93 != v92[1])
          {
            do
            {
              v59 = (const void *)*((_QWORD *)v57 - 1);
              v57 -= 8;
              *--v55 = v59;
            }
            while (v57 != v58);
            v57 = (char *)v92[1];
          }
          v92[1] = v55;
          *(_QWORD *)&v93 = v44;
          *((_QWORD *)&v93 + 1) = v56;
          if (v57)
            operator delete(v57);
        }
        else
        {
          *(_QWORD *)v93 = v48;
          v44 = (const void **)(v50 + 8);
        }
        v47 = (_BYTE *)(v49 + 9);
        *(_QWORD *)&v93 = v44;
        v43 = (const void **)v92[1];
      }
      else
      {
        if (!v46)
          goto LABEL_156;
        v47 = v46 + 9;
      }
      *v47 = 1;
      while (1)
      {
        if (v43 == v44)
          goto LABEL_104;
        if (*((_BYTE *)*v43 + 8) == 17)
          break;
        ++v43;
      }
      if (v43 == v44)
      {
LABEL_104:
        v62 = operator new();
        v63 = v62;
        *(_WORD *)(v62 + 8) = 17;
        *(_QWORD *)v62 = &off_24D5EBD00;
        v64 = v93;
        if ((unint64_t)v93 >= *((_QWORD *)&v93 + 1))
        {
          v65 = (uint64_t)(v93 - (unint64_t)v92[1]) >> 3;
          if ((unint64_t)(v65 + 1) >> 61)
            goto LABEL_154;
          v66 = (uint64_t)(*((_QWORD *)&v93 + 1) - (unint64_t)v92[1]) >> 2;
          if (v66 <= v65 + 1)
            v66 = v65 + 1;
          if (*((_QWORD *)&v93 + 1) - (unint64_t)v92[1] >= 0x7FFFFFFFFFFFFFF8)
            v67 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v67 = v66;
          if (v67)
            v68 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v93 + 8, v67);
          else
            v68 = 0;
          v69 = (const void **)&v68[8 * v65];
          v70 = &v68[8 * v67];
          *v69 = (const void *)v63;
          v44 = v69 + 1;
          v72 = (char *)v92[1];
          v71 = (char *)v93;
          if ((void *)v93 != v92[1])
          {
            do
            {
              v73 = (const void *)*((_QWORD *)v71 - 1);
              v71 -= 8;
              *--v69 = v73;
            }
            while (v71 != v72);
            v71 = (char *)v92[1];
          }
          v92[1] = v69;
          *(_QWORD *)&v93 = v44;
          *((_QWORD *)&v93 + 1) = v70;
          if (v71)
            operator delete(v71);
        }
        else
        {
          *(_QWORD *)v93 = v62;
          v44 = (const void **)(v64 + 8);
        }
        v61 = (_BYTE *)(v63 + 9);
        *(_QWORD *)&v93 = v44;
      }
      else
      {
        if (!v60)
          goto LABEL_156;
        v61 = v60 + 9;
      }
      *v61 = 1;
      for (j = (const void **)v92[1]; ; ++j)
      {
        if (j == v44)
          goto LABEL_128;
        if (*((_BYTE *)*j + 8) == 18)
          break;
      }
      if (j != v44)
      {
        if (v75)
        {
          v76 = v75 + 9;
LABEL_145:
          *v76 = 1;
          v98 = v1 + 72;
          v99 = QMIServiceMsg::create();
          v100 = 25000;
          v101 = 0;
          aBlock = 0;
          v91[0] = v7;
          v91[1] = 0x40000000;
          v91[2] = ___ZN14QMIQOSClientIP14setupQMIClientEv_block_invoke_4;
          v91[3] = &__block_descriptor_tmp_115_2;
          v91[4] = v1;
          *(_QWORD *)buf = v7;
          *(_QWORD *)&buf[8] = 0x40000000;
          *(_QWORD *)&buf[16] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3qos18IndicationRegister8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
          v105 = &unk_24D5EBD80;
          v106 = v91;
          v90 = _Block_copy(buf);
          aBlock = v90;
          if (v99)
          {
            qmi::Client::send();
            v90 = aBlock;
          }
          if (v90)
            _Block_release(v90);
          qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v92);
LABEL_150:
          *(_BYTE *)(v1 + 109) = 1;
          qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
LABEL_151:
          qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v103);
          return;
        }
LABEL_156:
        __cxa_bad_cast();
      }
LABEL_128:
      v77 = operator new();
      v78 = v77;
      *(_WORD *)(v77 + 8) = 18;
      *(_QWORD *)v77 = &off_24D5EBD50;
      v79 = v93;
      if ((unint64_t)v93 < *((_QWORD *)&v93 + 1))
      {
        *(_QWORD *)v93 = v77;
        v80 = (_QWORD *)(v79 + 8);
LABEL_144:
        v76 = (_BYTE *)(v78 + 9);
        *(_QWORD *)&v93 = v80;
        goto LABEL_145;
      }
      v81 = (uint64_t)(v93 - (unint64_t)v92[1]) >> 3;
      if (!((unint64_t)(v81 + 1) >> 61))
      {
        v82 = (uint64_t)(*((_QWORD *)&v93 + 1) - (unint64_t)v92[1]) >> 2;
        if (v82 <= v81 + 1)
          v82 = v81 + 1;
        if (*((_QWORD *)&v93 + 1) - (unint64_t)v92[1] >= 0x7FFFFFFFFFFFFFF8)
          v83 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v83 = v82;
        if (v83)
          v84 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v93 + 8, v83);
        else
          v84 = 0;
        v85 = (uint64_t *)&v84[8 * v81];
        v86 = &v84[8 * v83];
        *v85 = v78;
        v80 = v85 + 1;
        v88 = (char *)v92[1];
        v87 = (char *)v93;
        if ((void *)v93 != v92[1])
        {
          do
          {
            v89 = *((_QWORD *)v87 - 1);
            v87 -= 8;
            *--v85 = v89;
          }
          while (v87 != v88);
          v87 = (char *)v92[1];
        }
        v92[1] = v85;
        *(_QWORD *)&v93 = v80;
        *((_QWORD *)&v93 + 1) = v86;
        if (v87)
          operator delete(v87);
        goto LABEL_144;
      }
LABEL_154:
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    }
    v33 = (uint64_t)(v96 - (unint64_t)__p[1]) >> 3;
    if (!((unint64_t)(v33 + 1) >> 61))
    {
      v34 = (uint64_t)(*((_QWORD *)&v96 + 1) - (unint64_t)__p[1]) >> 2;
      if (v34 <= v33 + 1)
        v34 = v33 + 1;
      if (*((_QWORD *)&v96 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v35 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v35 = v34;
      if (v35)
        v36 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v96 + 8, v35);
      else
        v36 = 0;
      v37 = (uint64_t *)&v36[8 * v33];
      v38 = &v36[8 * v35];
      *v37 = v30;
      v32 = v37 + 1;
      v40 = (char *)__p[1];
      v39 = (char *)v96;
      if ((void *)v96 != __p[1])
      {
        do
        {
          v41 = *((_QWORD *)v39 - 1);
          v39 -= 8;
          *--v37 = v41;
        }
        while (v39 != v40);
        v39 = (char *)__p[1];
      }
      __p[1] = v37;
      *(_QWORD *)&v96 = v32;
      *((_QWORD *)&v96 + 1) = v38;
      if (v39)
        operator delete(v39);
      goto LABEL_66;
    }
LABEL_153:
    std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
  }
  v6 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl(&dword_216897000, v6, OS_LOG_TYPE_ERROR, "setupQMIClient after client is deleted", buf, 2u);
  }
}

void sub_216A8E534(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,void *aBlock)
{
  uint64_t v38;

  if (a35)
    qmi::Client::send();
  if (aBlock)
    _Block_release(aBlock);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a15);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a25);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)(v38 - 160));
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<QMIQOSClientIP::bindDataPort_sync(void)::$_0::operator() const(void)::{lambda(void)#1},std::allocator<QMIQOSClientIP::bindDataPort_sync(void)::$_0::operator() const(void)::{lambda(void)#1}>,void ()(void)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<QMIQOSClientIP::bindDataPort_sync(void)::$_0::operator() const(void)::{lambda(void)#1},std::allocator<QMIQOSClientIP::bindDataPort_sync(void)::$_0::operator() const(void)::{lambda(void)#1}>,void ()(void)>::target_type()
{
}

void qmi::MutableMessageBase::TlvWrapper<qos::tlv::DataPort>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<qos::tlv::DataPort>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_PcoMcc>();
}

_WORD **qmi::MutableMessageBase::TlvWrapper<qos::tlv::DataPort>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _WORD *v4;
  uint64_t v5;
  _WORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_WORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::Profile3GPP_PcoMcc>((_WORD **)a2, (_WORD *)(a1 + 10));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<qos::tlv::DataPort>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5EBAD0;
  *(_WORD *)(result + 10) = *(_WORD *)(a1 + 10);
  return result;
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3qos12BindDataPort8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A8E7EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<qos::tlv::MuxId>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<qos::tlv::MuxId>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<qos::tlv::MuxId>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<qos::tlv::MuxId>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5EBB48;
  return result;
}

char *qmi::MutableMessageBase::getTLV<qos::tlv::IpFamilyPref>(_QWORD *a1)
{
  const void **v2;
  const void **v3;
  char **v4;
  char *v5;
  char *result;
  uint64_t v7;
  unint64_t v8;
  uint64_t *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  v4 = (char **)(a1 + 1);
  if (v2 != v3)
  {
    while (*((_BYTE *)*v2 + 8) != 1)
    {
      if (++v2 == v3)
        goto LABEL_8;
    }
  }
  if (v2 == v3)
  {
LABEL_8:
    v7 = operator new();
    *(_WORD *)(v7 + 8) = 1;
    *(_QWORD *)v7 = &off_24D5EBB98;
    v8 = a1[3];
    v9 = (uint64_t *)a1[2];
    if ((unint64_t)v9 >= v8)
    {
      v11 = ((char *)v9 - *v4) >> 3;
      if ((unint64_t)(v11 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v12 = v8 - (_QWORD)*v4;
      v13 = v12 >> 2;
      if (v12 >> 2 <= (unint64_t)(v11 + 1))
        v13 = v11 + 1;
      if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
        v14 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v14 = v13;
      if (v14)
        v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v14);
      else
        v15 = 0;
      v16 = (uint64_t *)&v15[8 * v11];
      v17 = &v15[8 * v14];
      *v16 = v7;
      v10 = v16 + 1;
      v19 = (char *)a1[1];
      v18 = (char *)a1[2];
      if (v18 != v19)
      {
        do
        {
          v20 = *((_QWORD *)v18 - 1);
          v18 -= 8;
          *--v16 = v20;
        }
        while (v18 != v19);
        v18 = *v4;
      }
      a1[1] = v16;
      a1[2] = v10;
      a1[3] = v17;
      if (v18)
        operator delete(v18);
    }
    else
    {
      *v9 = v7;
      v10 = v9 + 1;
    }
    result = (char *)(v7 + 9);
    a1[2] = v10;
  }
  else
  {
    if (!v5)
      __cxa_bad_cast();
    return v5 + 9;
  }
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<qos::tlv::IpFamilyPref>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<qos::tlv::IpFamilyPref>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<qos::tlv::IpFamilyPref>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<qos::tlv::IpFamilyPref>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5EBB98;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<qos::tlv::GlobalFlowReporting>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<qos::tlv::GlobalFlowReporting>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<qos::tlv::GlobalFlowReporting>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<qos::tlv::GlobalFlowReporting>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5EBBE8;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<qos::tlv::NetworkProfileChange>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<qos::tlv::NetworkProfileChange>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_PcoMnc>();
}

uint64_t *qmi::MutableMessageBase::TlvWrapper<qos::tlv::NetworkProfileChange>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t *result;
  uint64_t v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = *a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<qos::tlv::NetworkProfileChange>(a2, a1 + 10);
  v7 = *a2 - v5;
  *(_BYTE *)v4 = v3;
  *(_WORD *)(v4 + 1) = v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<qos::tlv::NetworkProfileChange>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5EBC38;
  *(_DWORD *)(result + 10) = *(_DWORD *)(a1 + 10);
  return result;
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3qos14SetEventReport8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A8ED5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<qos::tlv::ReportGlobalQosFlows>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<qos::tlv::ReportGlobalQosFlows>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<qos::tlv::ReportGlobalQosFlows>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<qos::tlv::ReportGlobalQosFlows>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5EBCB0;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<qos::tlv::SuppressFlowControlReport>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<qos::tlv::SuppressFlowControlReport>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<qos::tlv::SuppressFlowControlReport>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<qos::tlv::SuppressFlowControlReport>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5EBD00;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<qos::tlv::SuppressNetworkStatusInd>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<qos::tlv::SuppressNetworkStatusInd>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<qos::tlv::SuppressNetworkStatusInd>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<qos::tlv::SuppressNetworkStatusInd>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5EBD50;
  return result;
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3qos18IndicationRegister8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A8F098(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

uint64_t qos::tlv::FlowInfo::FlowInfo(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_BYTE *)(a1 + 8) = 0;
  if (*(_BYTE *)(a2 + 8))
  {
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)(a1 + 24) = 0;
    *(_QWORD *)(a1 + 32) = 0;
    *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
    *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
    *(_QWORD *)(a2 + 16) = 0;
    *(_QWORD *)(a2 + 24) = 0;
    *(_QWORD *)(a2 + 32) = 0;
    *(_BYTE *)(a1 + 8) = 1;
  }
  *(_BYTE *)(a1 + 40) = 0;
  if (*(_BYTE *)(a2 + 40))
  {
    *(_QWORD *)(a1 + 48) = 0;
    *(_QWORD *)(a1 + 56) = 0;
    *(_QWORD *)(a1 + 64) = 0;
    *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
    *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
    *(_QWORD *)(a2 + 48) = 0;
    *(_QWORD *)(a2 + 56) = 0;
    *(_QWORD *)(a2 + 64) = 0;
    *(_BYTE *)(a1 + 40) = 1;
  }
  *(_BYTE *)(a1 + 72) = 0;
  if (*(_BYTE *)(a2 + 72))
  {
    qos::tlv::FlowSpec::FlowSpec(a1 + 80, a2 + 80);
    *(_BYTE *)(a1 + 72) = 1;
  }
  *(_BYTE *)(a1 + 208) = 0;
  if (*(_BYTE *)(a2 + 208))
  {
    qos::tlv::FlowSpec::FlowSpec(a1 + 216, a2 + 216);
    *(_BYTE *)(a1 + 208) = 1;
  }
  *(_BYTE *)(a1 + 344) = 0;
  if (*(_BYTE *)(a2 + 344))
  {
    *(_BYTE *)(a1 + 345) = *(_BYTE *)(a2 + 345);
    *(_BYTE *)(a1 + 344) = 1;
  }
  *(_BYTE *)(a1 + 346) = 0;
  if (*(_BYTE *)(a2 + 346))
  {
    *(_BYTE *)(a1 + 347) = *(_BYTE *)(a2 + 347);
    *(_BYTE *)(a1 + 346) = 1;
  }
  *(_BYTE *)(a1 + 348) = 0;
  if (*(_BYTE *)(a2 + 348))
  {
    *(_WORD *)(a1 + 350) = *(_WORD *)(a2 + 350);
    *(_BYTE *)(a1 + 348) = 1;
  }
  return a1;
}

uint64_t qos::tlv::FlowSpec::FlowSpec(uint64_t result, uint64_t a2)
{
  uint64_t v2;

  *(_BYTE *)result = 0;
  if (*(_BYTE *)a2)
  {
    *(_BYTE *)(result + 1) = *(_BYTE *)(a2 + 1);
    *(_BYTE *)result = 1;
  }
  *(_BYTE *)(result + 4) = 0;
  if (*(_BYTE *)(a2 + 4))
  {
    v2 = *(_QWORD *)(a2 + 8);
    *(_DWORD *)(result + 16) = *(_DWORD *)(a2 + 16);
    *(_QWORD *)(result + 8) = v2;
    *(_BYTE *)(result + 4) = 1;
  }
  *(_BYTE *)(result + 20) = 0;
  if (*(_BYTE *)(a2 + 20))
  {
    *(_QWORD *)(result + 24) = *(_QWORD *)(a2 + 24);
    *(_BYTE *)(result + 20) = 1;
  }
  *(_BYTE *)(result + 32) = 0;
  if (*(_BYTE *)(a2 + 32))
  {
    *(_QWORD *)(result + 40) = 0;
    *(_QWORD *)(result + 48) = 0;
    *(_QWORD *)(result + 56) = 0;
    *(_OWORD *)(result + 40) = *(_OWORD *)(a2 + 40);
    *(_QWORD *)(result + 56) = *(_QWORD *)(a2 + 56);
    *(_QWORD *)(a2 + 40) = 0;
    *(_QWORD *)(a2 + 48) = 0;
    *(_QWORD *)(a2 + 56) = 0;
    *(_BYTE *)(result + 32) = 1;
  }
  *(_BYTE *)(result + 64) = 0;
  if (*(_BYTE *)(a2 + 64))
  {
    *(_DWORD *)(result + 68) = *(_DWORD *)(a2 + 68);
    *(_BYTE *)(result + 64) = 1;
  }
  *(_BYTE *)(result + 72) = 0;
  if (*(_BYTE *)(a2 + 72))
  {
    *(_DWORD *)(result + 76) = *(_DWORD *)(a2 + 76);
    *(_BYTE *)(result + 72) = 1;
  }
  *(_BYTE *)(result + 80) = 0;
  if (*(_BYTE *)(a2 + 80))
  {
    *(_DWORD *)(result + 82) = *(_DWORD *)(a2 + 82);
    *(_BYTE *)(result + 80) = 1;
  }
  *(_BYTE *)(result + 88) = 0;
  if (*(_BYTE *)(a2 + 88))
  {
    *(_DWORD *)(result + 92) = *(_DWORD *)(a2 + 92);
    *(_BYTE *)(result + 88) = 1;
  }
  *(_BYTE *)(result + 96) = 0;
  if (*(_BYTE *)(a2 + 96))
  {
    *(_DWORD *)(result + 100) = *(_DWORD *)(a2 + 100);
    *(_BYTE *)(result + 96) = 1;
  }
  *(_BYTE *)(result + 104) = 0;
  if (*(_BYTE *)(a2 + 104))
  {
    *(_BYTE *)(result + 105) = *(_BYTE *)(a2 + 105);
    *(_BYTE *)(result + 104) = 1;
  }
  *(_BYTE *)(result + 106) = 0;
  if (*(_BYTE *)(a2 + 106))
  {
    *(_BYTE *)(result + 107) = *(_BYTE *)(a2 + 107);
    *(_BYTE *)(result + 106) = 1;
  }
  *(_BYTE *)(result + 108) = 0;
  if (*(_BYTE *)(a2 + 108))
  {
    *(_WORD *)(result + 110) = *(_WORD *)(a2 + 110);
    *(_BYTE *)(result + 108) = 1;
  }
  *(_BYTE *)(result + 112) = 0;
  if (*(_BYTE *)(a2 + 112))
  {
    *(_BYTE *)(result + 113) = *(_BYTE *)(a2 + 113);
    *(_BYTE *)(result + 112) = 1;
  }
  *(_BYTE *)(result + 114) = 0;
  if (*(_BYTE *)(a2 + 114))
  {
    *(_BYTE *)(result + 115) = *(_BYTE *)(a2 + 115);
    *(_BYTE *)(result + 114) = 1;
  }
  *(_BYTE *)(result + 116) = 0;
  if (*(_BYTE *)(a2 + 116))
  {
    *(_BYTE *)(result + 117) = *(_BYTE *)(a2 + 117);
    *(_BYTE *)(result + 116) = 1;
  }
  *(_BYTE *)(result + 118) = 0;
  if (*(_BYTE *)(a2 + 118))
  {
    *(_BYTE *)(result + 119) = *(_BYTE *)(a2 + 119);
    *(_BYTE *)(result + 118) = 1;
  }
  *(_BYTE *)(result + 120) = 0;
  if (*(_BYTE *)(a2 + 120))
  {
    *(_BYTE *)(result + 121) = *(_BYTE *)(a2 + 121);
    *(_BYTE *)(result + 120) = 1;
  }
  return result;
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3qos9GetQosIds8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A8F4BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void std::__function::__func<QMIQOSClientIP::cleanCurrentQosFlows_sync(void)::$_0,std::allocator<QMIQOSClientIP::cleanCurrentQosFlows_sync(void)::$_0>,void ()(std::vector<unsigned int> const&,BOOL)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<QMIQOSClientIP::cleanCurrentQosFlows_sync(void)::$_0,std::allocator<QMIQOSClientIP::cleanCurrentQosFlows_sync(void)::$_0>,void ()(std::vector<unsigned int> const&,BOOL)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5EBDD8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<QMIQOSClientIP::cleanCurrentQosFlows_sync(void)::$_0,std::allocator<QMIQOSClientIP::cleanCurrentQosFlows_sync(void)::$_0>,void ()(std::vector<unsigned int> const&,BOOL)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5EBDD8;
  a2[1] = v2;
  return result;
}

void std::__function::__func<QMIQOSClientIP::cleanCurrentQosFlows_sync(void)::$_0,std::allocator<QMIQOSClientIP::cleanCurrentQosFlows_sync(void)::$_0>,void ()(std::vector<unsigned int> const&,BOOL)>::operator()(uint64_t a1, uint64_t a2, _BYTE *a3)
{
  uint64_t v3;
  NSObject *v4;
  int v5;
  const char *v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 + 8);
  if (*a3)
  {
    (*(void (**)(_QWORD, _QWORD, uint64_t))(**(_QWORD **)(v3 + 64) + 96))(*(_QWORD *)(v3 + 64), *(unsigned int *)(v3 + 104), a2);
  }
  else
  {
    v4 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      v5 = 136315138;
      v6 = "operator()";
      _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I %s: GetQosIds: cannot update current QoSFlows", (uint8_t *)&v5, 0xCu);
    }
  }
}

uint64_t std::__function::__func<QMIQOSClientIP::cleanCurrentQosFlows_sync(void)::$_0,std::allocator<QMIQOSClientIP::cleanCurrentQosFlows_sync(void)::$_0>,void ()(std::vector<unsigned int> const&,BOOL)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<QMIQOSClientIP::cleanCurrentQosFlows_sync(void)::$_0,std::allocator<QMIQOSClientIP::cleanCurrentQosFlows_sync(void)::$_0>,void ()(std::vector<unsigned int> const&,BOOL)>::target_type()
{
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3qos10RequestQos8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A8F750(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

_QWORD *qmi::MutableMessageBase::TlvWrapper<qos::tlv::QosIdentifierList>::~TlvWrapper(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24D5EBEA8;
  v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<qos::tlv::QosIdentifierList>::~TlvWrapper(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24D5EBEA8;
  v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  JUMPOUT(0x2199FEAC4);
}

unint64_t qmi::MutableMessageBase::TlvWrapper<qos::tlv::QosIdentifierList>::getSize(uint64_t a1)
{
  return tlv::size<wds::tlv::DestPortRangeList>((_QWORD *)(a1 + 16));
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<qos::tlv::QosIdentifierList>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<qos::tlv::QosIdentifierList>((_BYTE **)a2, (_DWORD *)(a1 + 16));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<qos::tlv::QosIdentifierList>::clone(uint64_t a1)
{
  uint64_t v2;

  v2 = operator new();
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)v2 = &off_24D5EBEA8;
  *(_QWORD *)(v2 + 24) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 16) = 0;
  std::vector<unsigned int>::__init_with_size[abi:ne180100]<unsigned int *,unsigned int *>((_QWORD *)(v2 + 16), *(const void **)(a1 + 16), *(_QWORD *)(a1 + 24), (uint64_t)(*(_QWORD *)(a1 + 24) - *(_QWORD *)(a1 + 16)) >> 2);
  return v2;
}

void sub_216A8F8E0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199FEAC4](v1, 0x1091C40A3A4EB6ALL);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3qos10ReleaseQos8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A8F9C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<qos::tlv::QosSpecV4>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<qos::tlv::QosSpecV4>::getSize()
{
  return tlv::size<qos::tlv::QosSpecV4>();
}

uint64_t qmi::MutableMessageBase::TlvWrapper<qos::tlv::QosSpecV4>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  uint64_t v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = *a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<qos::tlv::QosSpecV4>(a2, a1 + 12);
  v7 = *a2 - v5;
  *(_BYTE *)v4 = v3;
  *(_WORD *)(v4 + 1) = v7;
  return result;
}

__n128 qmi::MutableMessageBase::TlvWrapper<qos::tlv::QosSpecV4>::clone(uint64_t a1)
{
  uint64_t v2;
  __n128 result;

  v2 = operator new();
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)v2 = &off_24D5EBF08;
  *(_OWORD *)(v2 + 12) = *(_OWORD *)(a1 + 12);
  result = *(__n128 *)(a1 + 28);
  *(__n128 *)(v2 + 28) = result;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<qos::tlv::QosSpecV6>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<qos::tlv::QosSpecV6>::getSize()
{
  return tlv::size<qos::tlv::QosSpecV6>();
}

uint64_t qmi::MutableMessageBase::TlvWrapper<qos::tlv::QosSpecV6>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  uint64_t v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = *a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<qos::tlv::QosSpecV6>(a2, a1 + 10);
  v7 = *a2 - v5;
  *(_BYTE *)v4 = v3;
  *(_WORD *)(v4 + 1) = v7;
  return result;
}

__n128 qmi::MutableMessageBase::TlvWrapper<qos::tlv::QosSpecV6>::clone(uint64_t a1)
{
  uint64_t v2;
  __n128 result;

  v2 = operator new();
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)v2 = &off_24D5EBF58;
  *(_OWORD *)(v2 + 10) = *(_OWORD *)(a1 + 10);
  *(_OWORD *)(v2 + 26) = *(_OWORD *)(a1 + 26);
  result = *(__n128 *)(a1 + 42);
  *(__n128 *)(v2 + 42) = result;
  *(_WORD *)(v2 + 58) = *(_WORD *)(a1 + 58);
  return result;
}

void MCommandDriversFactory::create(std::__shared_weak_count **a1@<X8>)
{
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *shared_weak_owners;
  unint64_t v7;
  unint64_t *p_shared_weak_owners;
  unint64_t v9;
  unint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  unint64_t v13;

  v3 = (std::__shared_weak_count *)operator new(0x40uLL);
  v3->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v3->__shared_owners_;
  v3->__shared_weak_owners_ = 0;
  v3->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5EC2E0;
  v3[1].std::__shared_count = 0u;
  v5 = v3 + 1;
  *(_OWORD *)&v3[1].__shared_weak_owners_ = 0u;
  v3[2].__shared_owners_ = 0;
  CommandDriversFactory::CommandDriversFactory((CommandDriversFactory *)&v3[1]);
  v3[1].__vftable = (std::__shared_weak_count_vtbl *)&off_24D5EC188;
  shared_weak_owners = (std::__shared_weak_count *)v3[1].__shared_weak_owners_;
  if (shared_weak_owners)
  {
    if (shared_weak_owners->__shared_owners_ != -1)
      goto LABEL_14;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
    p_shared_weak_owners = (unint64_t *)&v3->__shared_weak_owners_;
    do
      v9 = __ldxr(p_shared_weak_owners);
    while (__stxr(v9 + 1, p_shared_weak_owners));
    v3[1].__shared_owners_ = (uint64_t)v5;
    v3[1].__shared_weak_owners_ = (uint64_t)v3;
    std::__shared_weak_count::__release_weak(shared_weak_owners);
  }
  else
  {
    do
      v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
    v11 = (unint64_t *)&v3->__shared_weak_owners_;
    do
      v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
    v3[1].__shared_owners_ = (uint64_t)v5;
    v3[1].__shared_weak_owners_ = (uint64_t)v3;
  }
  do
    v13 = __ldaxr(p_shared_owners);
  while (__stlxr(v13 - 1, p_shared_owners));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_14:
  *a1 = v5;
  a1[1] = v3;
}

void sub_216A8FCBC(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;
  void *v3;

  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

uint64_t MCommandDriversFactory::init(uint64_t a1, uint64_t a2)
{
  Registry *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  std::mutex *ServiceMap;
  std::mutex *v11;
  const char *v12;
  unsigned __int8 *v13;
  uint64_t v14;
  unsigned int v15;
  std::__shared_weak_count *v16;
  uint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  unint64_t v20;
  uint8x8_t v21;
  unint64_t v22;
  uint8x8_t v23;
  unint64_t v24;
  _QWORD *v25;
  _QWORD *i;
  unint64_t v27;
  Registry *v28;
  char *v29;
  unint64_t *v30;
  unint64_t v31;
  float v32;
  float v33;
  _BOOL8 v34;
  unint64_t v35;
  unint64_t v36;
  int8x8_t prime;
  void *v38;
  void *sig;
  uint64_t v40;
  _QWORD *v41;
  unint64_t v42;
  uint8x8_t v43;
  unint64_t v44;
  uint8x8_t v45;
  uint64_t v46;
  uint64_t v47;
  Registry **v48;
  Registry *v49;
  unint64_t v50;
  unint64_t v51;
  _QWORD *v52;
  unint64_t v53;
  uint64_t v54;
  Registry **v55;
  Registry *v56;
  unint64_t v57;
  unint64_t *v58;
  unint64_t v59;
  std::__shared_weak_count *v60;
  unint64_t *v61;
  unint64_t v62;
  char v64;
  void *v65;
  char *v66;
  char *v67;
  unint64_t v68;
  unint64_t v69;
  Registry *v70;
  unint64_t v71;
  std::runtime_error *exception;
  uint64_t v73;
  std::__shared_weak_count *v74;
  Registry *v75;
  std::__shared_weak_count *v76;
  uint64_t v77;

  CommandDriversFactory::init();
  v4 = *(Registry **)a2;
  if (!*(_QWORD *)a2)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 296))(a1);
  v73 = 0;
  v74 = 0;
  v5 = *(std::__shared_weak_count **)(a2 + 8);
  v75 = v4;
  v76 = v5;
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  QMIClientPool::create(&v75, &v73);
  if (v5)
  {
    v8 = (unint64_t *)&v5->__shared_owners_;
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)a2);
  v11 = ServiceMap;
  v12 = "13QMIClientPool";
  if (((unint64_t)"13QMIClientPool" & 0x8000000000000000) != 0)
  {
    v13 = (unsigned __int8 *)((unint64_t)"13QMIClientPool" & 0x7FFFFFFFFFFFFFFFLL);
    v14 = 5381;
    do
    {
      v12 = (const char *)v14;
      v15 = *v13++;
      v14 = (33 * v14) ^ v15;
    }
    while (v15);
  }
  std::mutex::lock(ServiceMap);
  v17 = v73;
  v16 = v74;
  if (v74)
  {
    v18 = (unint64_t *)&v74->__shared_owners_;
    do
      v19 = __ldxr(v18);
    while (__stxr(v19 + 1, v18));
  }
  v20 = *(_QWORD *)v11[1].__m_.__opaque;
  if (v17)
  {
    if (v20)
    {
      v21 = (uint8x8_t)vcnt_s8((int8x8_t)v20);
      v21.i16[0] = vaddlv_u8(v21);
      if (v21.u32[0] > 1uLL)
      {
        v22 = (unint64_t)v12;
        if (v20 <= (unint64_t)v12)
          v22 = (unint64_t)v12 % v20;
      }
      else
      {
        v22 = (v20 - 1) & (unint64_t)v12;
      }
      v25 = *(_QWORD **)(v11[1].__m_.__sig + 8 * v22);
      if (v25)
      {
        for (i = (_QWORD *)*v25; i; i = (_QWORD *)*i)
        {
          v27 = i[1];
          if ((const char *)v27 == v12)
          {
            if ((const char *)i[2] == v12)
            {
              v64 = 0;
              goto LABEL_112;
            }
          }
          else
          {
            if (v21.u32[0] > 1uLL)
            {
              if (v27 >= v20)
                v27 %= v20;
            }
            else
            {
              v27 &= v20 - 1;
            }
            if (v27 != v22)
              break;
          }
        }
      }
    }
    else
    {
      v22 = 0;
    }
    v77 = 1;
    v28 = (Registry *)operator new(0x28uLL);
    v29 = &v11[1].__m_.__opaque[8];
    v75 = v28;
    v76 = (std::__shared_weak_count *)&v11[1].__m_.__opaque[8];
    *(_QWORD *)v28 = 0;
    *((_QWORD *)v28 + 1) = v12;
    *((_QWORD *)v28 + 2) = v12;
    *((_QWORD *)v28 + 3) = v17;
    *((_QWORD *)v28 + 4) = v16;
    if (v16)
    {
      v30 = (unint64_t *)&v16->__shared_owners_;
      do
        v31 = __ldxr(v30);
      while (__stxr(v31 + 1, v30));
    }
    v32 = (float)(unint64_t)(*(_QWORD *)&v11[1].__m_.__opaque[16] + 1);
    v33 = *(float *)&v11[1].__m_.__opaque[24];
    if (v20 && (float)(v33 * (float)v20) >= v32)
    {
LABEL_101:
      v55 = *(Registry ***)(v11[1].__m_.__sig + 8 * v22);
      v56 = v75;
      if (v55)
      {
        *(_QWORD *)v75 = *v55;
      }
      else
      {
        *(_QWORD *)v75 = *(_QWORD *)&v11[1].__m_.__opaque[8];
        *(_QWORD *)&v11[1].__m_.__opaque[8] = v56;
        *(_QWORD *)(v11[1].__m_.__sig + 8 * v22) = v29;
        if (!*(_QWORD *)v56)
        {
LABEL_110:
          v75 = 0;
          ++*(_QWORD *)&v11[1].__m_.__opaque[16];
          std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long,std::shared_ptr<void>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long,std::shared_ptr<void>>,void *>>>>::reset[abi:ne180100]((uint64_t)&v75);
LABEL_111:
          v64 = 1;
          goto LABEL_112;
        }
        v57 = *(_QWORD *)(*(_QWORD *)v56 + 8);
        if ((v20 & (v20 - 1)) != 0)
        {
          if (v57 >= v20)
            v57 %= v20;
        }
        else
        {
          v57 &= v20 - 1;
        }
        v55 = (Registry **)(v11[1].__m_.__sig + 8 * v57);
      }
      *v55 = v56;
      goto LABEL_110;
    }
    v34 = 1;
    if (v20 >= 3)
      v34 = (v20 & (v20 - 1)) != 0;
    v35 = v34 | (2 * v20);
    v36 = vcvtps_u32_f32(v32 / v33);
    if (v35 <= v36)
      prime = (int8x8_t)v36;
    else
      prime = (int8x8_t)v35;
    if (*(_QWORD *)&prime == 1)
    {
      prime = (int8x8_t)2;
    }
    else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
    {
      prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
    }
    v20 = *(_QWORD *)v11[1].__m_.__opaque;
    if (*(_QWORD *)&prime > v20)
      goto LABEL_52;
    if (*(_QWORD *)&prime < v20)
    {
      v44 = vcvtps_u32_f32((float)*(unint64_t *)&v11[1].__m_.__opaque[16] / *(float *)&v11[1].__m_.__opaque[24]);
      if (v20 < 3 || (v45 = (uint8x8_t)vcnt_s8((int8x8_t)v20), v45.i16[0] = vaddlv_u8(v45), v45.u32[0] > 1uLL))
      {
        v44 = std::__next_prime(v44);
      }
      else
      {
        v46 = 1 << -(char)__clz(v44 - 1);
        if (v44 >= 2)
          v44 = v46;
      }
      if (*(_QWORD *)&prime <= v44)
        prime = (int8x8_t)v44;
      if (*(_QWORD *)&prime >= v20)
      {
        v20 = *(_QWORD *)v11[1].__m_.__opaque;
      }
      else
      {
        if (prime)
        {
LABEL_52:
          if (*(_QWORD *)&prime >> 61)
            std::__throw_bad_array_new_length[abi:ne180100]();
          v38 = operator new(8 * *(_QWORD *)&prime);
          sig = (void *)v11[1].__m_.__sig;
          v11[1].__m_.__sig = (uint64_t)v38;
          if (sig)
            operator delete(sig);
          v40 = 0;
          *(int8x8_t *)v11[1].__m_.__opaque = prime;
          do
            *(_QWORD *)(v11[1].__m_.__sig + 8 * v40++) = 0;
          while (*(_QWORD *)&prime != v40);
          v41 = *(_QWORD **)v29;
          if (*(_QWORD *)v29)
          {
            v42 = v41[1];
            v43 = (uint8x8_t)vcnt_s8(prime);
            v43.i16[0] = vaddlv_u8(v43);
            if (v43.u32[0] > 1uLL)
            {
              if (v42 >= *(_QWORD *)&prime)
                v42 %= *(_QWORD *)&prime;
            }
            else
            {
              v42 &= *(_QWORD *)&prime - 1;
            }
            *(_QWORD *)(v11[1].__m_.__sig + 8 * v42) = v29;
            v52 = (_QWORD *)*v41;
            if (*v41)
            {
              do
              {
                v53 = v52[1];
                if (v43.u32[0] > 1uLL)
                {
                  if (v53 >= *(_QWORD *)&prime)
                    v53 %= *(_QWORD *)&prime;
                }
                else
                {
                  v53 &= *(_QWORD *)&prime - 1;
                }
                if (v53 != v42)
                {
                  v54 = v11[1].__m_.__sig;
                  if (!*(_QWORD *)(v54 + 8 * v53))
                  {
                    *(_QWORD *)(v54 + 8 * v53) = v41;
                    goto LABEL_92;
                  }
                  *v41 = *v52;
                  *v52 = **(_QWORD **)(v11[1].__m_.__sig + 8 * v53);
                  **(_QWORD **)(v11[1].__m_.__sig + 8 * v53) = v52;
                  v52 = v41;
                }
                v53 = v42;
LABEL_92:
                v41 = v52;
                v52 = (_QWORD *)*v52;
                v42 = v53;
              }
              while (v52);
            }
          }
          v20 = (unint64_t)prime;
          goto LABEL_96;
        }
        v65 = (void *)v11[1].__m_.__sig;
        v11[1].__m_.__sig = 0;
        if (v65)
          operator delete(v65);
        v20 = 0;
        *(_QWORD *)v11[1].__m_.__opaque = 0;
      }
    }
LABEL_96:
    if ((v20 & (v20 - 1)) != 0)
    {
      if (v20 <= (unint64_t)v12)
        v22 = (unint64_t)v12 % v20;
      else
        v22 = (unint64_t)v12;
    }
    else
    {
      v22 = (v20 - 1) & (unint64_t)v12;
    }
    goto LABEL_101;
  }
  if (!v20)
    goto LABEL_111;
  v23 = (uint8x8_t)vcnt_s8((int8x8_t)v20);
  v23.i16[0] = vaddlv_u8(v23);
  if (v23.u32[0] > 1uLL)
  {
    v24 = (unint64_t)v12;
    if (v20 <= (unint64_t)v12)
      v24 = (unint64_t)v12 % v20;
  }
  else
  {
    v24 = (v20 - 1) & (unint64_t)v12;
  }
  v47 = v11[1].__m_.__sig;
  v48 = *(Registry ***)(v47 + 8 * v24);
  if (!v48)
    goto LABEL_111;
  v49 = *v48;
  if (!v49)
    goto LABEL_111;
  v50 = v20 - 1;
  while (1)
  {
    v51 = *((_QWORD *)v49 + 1);
    if ((const char *)v51 == v12)
      break;
    if (v23.u32[0] > 1uLL)
    {
      if (v51 >= v20)
        v51 %= v20;
    }
    else
    {
      v51 &= v50;
    }
    if (v51 != v24)
      goto LABEL_111;
LABEL_79:
    v49 = *(Registry **)v49;
    if (!v49)
      goto LABEL_111;
  }
  if (*((const char **)v49 + 2) != v12)
    goto LABEL_79;
  if (v23.u32[0] > 1uLL)
  {
    if ((unint64_t)v12 >= v20)
      v12 = (const char *)((unint64_t)v12 % v20);
  }
  else
  {
    v12 = (const char *)(v50 & (unint64_t)v12);
  }
  v66 = *(char **)(v47 + 8 * (_QWORD)v12);
  do
  {
    v67 = v66;
    v66 = *(char **)v66;
  }
  while (v66 != (char *)v49);
  if (v67 == &v11[1].__m_.__opaque[8])
    goto LABEL_150;
  v68 = *((_QWORD *)v67 + 1);
  if (v23.u32[0] > 1uLL)
  {
    if (v68 >= v20)
      v68 %= v20;
  }
  else
  {
    v68 &= v50;
  }
  if ((const char *)v68 != v12)
  {
LABEL_150:
    if (!*(_QWORD *)v49)
      goto LABEL_151;
    v69 = *(_QWORD *)(*(_QWORD *)v49 + 8);
    if (v23.u32[0] > 1uLL)
    {
      if (v69 >= v20)
        v69 %= v20;
    }
    else
    {
      v69 &= v50;
    }
    if ((const char *)v69 != v12)
LABEL_151:
      *(_QWORD *)(v47 + 8 * (_QWORD)v12) = 0;
  }
  v70 = *(Registry **)v49;
  if (*(_QWORD *)v49)
  {
    v71 = *((_QWORD *)v70 + 1);
    if (v23.u32[0] > 1uLL)
    {
      if (v71 >= v20)
        v71 %= v20;
    }
    else
    {
      v71 &= v50;
    }
    if ((const char *)v71 != v12)
    {
      *(_QWORD *)(v11[1].__m_.__sig + 8 * v71) = v67;
      v70 = *(Registry **)v49;
    }
  }
  *(_QWORD *)v67 = v70;
  *(_QWORD *)v49 = 0;
  --*(_QWORD *)&v11[1].__m_.__opaque[16];
  v75 = v49;
  v76 = (std::__shared_weak_count *)&v11[1].__m_.__opaque[8];
  v64 = 1;
  LOBYTE(v77) = 1;
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long,std::shared_ptr<void>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long,std::shared_ptr<void>>,void *>>>>::reset[abi:ne180100]((uint64_t)&v75);
LABEL_112:
  if (v16)
  {
    v58 = (unint64_t *)&v16->__shared_owners_;
    do
      v59 = __ldaxr(v58);
    while (__stlxr(v59 - 1, v58));
    if (!v59)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
  std::mutex::unlock(v11);
  if ((v64 & 1) == 0)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "The given type is already in the map!");
    __cxa_throw(exception, MEMORY[0x24BEDB730], MEMORY[0x24BEDAB60]);
  }
  v60 = v74;
  if (v74)
  {
    v61 = (unint64_t *)&v74->__shared_owners_;
    do
      v62 = __ldaxr(v61);
    while (__stlxr(v62 - 1, v61));
    if (!v62)
    {
      ((void (*)(std::__shared_weak_count *))v60->__on_zero_shared)(v60);
      std::__shared_weak_count::__release_weak(v60);
    }
  }
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 296))(a1);
}

void sub_216A9042C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long,std::shared_ptr<void>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long,std::shared_ptr<void>>,void *>>>>::reset[abi:ne180100]((uint64_t)va);
  __clang_call_terminate(a1);
}

void sub_216A9045C(uint64_t a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va);
  JUMPOUT(0x216A90478);
}

void MCommandDriversFactory::~MCommandDriversFactory(MCommandDriversFactory *this)
{
  CommandDriversFactory::~CommandDriversFactory(this);
  JUMPOUT(0x2199FEAC4);
}

uint64_t MCommandDriversFactory::setupQmiExceptionHandlers(MCommandDriversFactory *this, BOOL (*a2)(unsigned __int16, unsigned __int16, const unsigned __int8 *, unint64_t))
{
  return qmi::MutableMessageBase::setWriteErrorHandler();
}

uint64_t `anonymous namespace'::ChangeQMIParserErrorToCSIAssert(_anonymous_namespace_ *this, int a2, unsigned __int16 a3, const unsigned __int8 *a4)
{
  int v4;
  int v6;
  _DWORD v8[2];
  __int16 v9;
  int v10;
  __int16 v11;
  int v12;
  uint64_t v13;

  v4 = (int)a4;
  v6 = (int)this;
  v13 = *MEMORY[0x24BDAC8D0];
  if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
  {
    v8[0] = 67109632;
    v8[1] = v6;
    v9 = 1024;
    v10 = a2;
    v11 = 1024;
    v12 = v4;
    _os_log_error_impl(&dword_216897000, MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR, "CSI ASSERT: QMI parsing error in message with msgId=0x%04x during tlvId=0x%02x (tlv_len=%u)", (uint8_t *)v8, 0x14u);
  }
  __TUAssertTrigger();
  return 0;
}

uint64_t `anonymous namespace'::ChangeQMIWriteErrorToCSIAssert(int a1, _DWORD *a2, uint64_t a3)
{
  int v7;
  _DWORD v8[2];
  __int16 v9;
  uint64_t v10;
  __int16 v11;
  int v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
  {
    v7 = a2[2] - *a2;
    v8[0] = 67109632;
    v8[1] = a1;
    v9 = 2048;
    v10 = a3;
    v11 = 1024;
    v12 = v7;
    _os_log_error_impl(&dword_216897000, MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR, "CSI ASSERT: QMI serialization error in message with msgId=0x%04x (%td bytes written to buf of size %u bytes)", (uint8_t *)v8, 0x18u);
  }
  return __TUAssertTrigger();
}

void MCommandDriversFactory::createSimCommandDriver(uint64_t a1@<X0>, dispatch_object_t *a2@<X1>, _OWORD *a3@<X8>)
{
  std::__shared_weak_count *v5;
  __n128 v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  NSObject *object;
  std::__shared_weak_count *v10;

  v10 = 0;
  v5 = *(std::__shared_weak_count **)(a1 + 32);
  if (v5)
    v10 = std::__shared_weak_count::lock(v5);
  object = *a2;
  if (*a2)
    dispatch_retain(*a2);
  v6.n128_f64[0] = subscriber::EURSimCommandDriver::create(a3);
  if (object)
    dispatch_release(object);
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *, __n128))v10->__on_zero_shared)(v10, v6);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
}

void sub_216A90738(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, char a11)
{
  if (object)
    dispatch_release(object);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

void MCommandDriversFactory::createEosCommandDriver(uint64_t a1@<X0>, dispatch_object_t *a2@<X1>, uint64_t a3@<X8>)
{
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  NSObject *object;
  uint64_t v11;
  std::__shared_weak_count *v12;

  v11 = 0;
  v12 = 0;
  v6 = *(std::__shared_weak_count **)(a1 + 32);
  if (v6)
  {
    v12 = std::__shared_weak_count::lock(v6);
    if (v12)
      v11 = *(_QWORD *)(a1 + 24);
  }
  object = *a2;
  if (*a2)
    dispatch_retain(*a2);
  QmiEosCommandDriver::create((capabilities::euicc *)&v11, a3);
  if (object)
    dispatch_release(object);
  v7 = v12;
  if (v12)
  {
    p_shared_owners = (unint64_t *)&v12->__shared_owners_;
    do
      v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
}

void sub_216A90810(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, char a11)
{
  if (object)
    dispatch_release(object);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

void MCommandDriversFactory::createSignalStrengthCommandDriver(uint64_t a1@<X0>, NSObject **a2@<X1>, uint64_t a3@<X8>)
{
  std::__shared_weak_count *v5;
  capabilities::ct *v7;
  int SignalStrengthPersonality;
  NSObject *v9;
  NSObject *v10;
  int v11;
  std::__shared_weak_count *v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  NSObject *v15;
  dispatch_object_t object;
  NSObject *v17;
  __int128 v18;
  uint64_t v19;
  std::__shared_weak_count *v20;

  v19 = 0;
  v20 = 0;
  v5 = *(std::__shared_weak_count **)(a1 + 32);
  if (!v5)
    goto LABEL_11;
  v7 = (capabilities::ct *)std::__shared_weak_count::lock(v5);
  v20 = (std::__shared_weak_count *)v7;
  if (!v7)
    goto LABEL_11;
  v19 = *(_QWORD *)(a1 + 24);
  if (!v19)
    goto LABEL_11;
  SignalStrengthPersonality = capabilities::ct::getSignalStrengthPersonality(v7);
  if (SignalStrengthPersonality != 1)
  {
    if (SignalStrengthPersonality == 2)
    {
      v9 = *a2;
      object = v9;
      if (v9)
        dispatch_retain(v9);
      Mav20SignalStrengthCommandDriver::create(&v19, &object, (uint64_t *)&v18);
      *(_OWORD *)a3 = v18;
      v18 = 0uLL;
      v10 = object;
      if (!object)
        goto LABEL_10;
      goto LABEL_9;
    }
LABEL_11:
    v11 = 1;
    goto LABEL_12;
  }
  v15 = *a2;
  v17 = v15;
  if (v15)
    dispatch_retain(v15);
  Mav7SignalStrengthCommandDriver::create(&v19, &v17, (std::__shared_weak_count **)&v18);
  *(_OWORD *)a3 = v18;
  v10 = v17;
  if (!v17)
    goto LABEL_10;
LABEL_9:
  dispatch_release(v10);
LABEL_10:
  v11 = 0;
LABEL_12:
  v12 = v20;
  if (!v20)
    goto LABEL_16;
  p_shared_owners = (unint64_t *)&v20->__shared_owners_;
  do
    v14 = __ldaxr(p_shared_owners);
  while (__stlxr(v14 - 1, p_shared_owners));
  if (v14)
  {
LABEL_16:
    if (!v11)
      return;
    goto LABEL_17;
  }
  ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
  std::__shared_weak_count::__release_weak(v12);
  if (v11)
  {
LABEL_17:
    *(_QWORD *)a3 = 0;
    *(_QWORD *)(a3 + 8) = 0;
  }
}

void sub_216A9095C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, uint64_t a11, uint64_t a12, char a13)
{
  if (object)
    dispatch_release(object);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  _Unwind_Resume(a1);
}

void MCommandDriversFactory::createDMSCommandDriver(uint64_t a1@<X0>, NSObject **a2@<X1>, uint64_t a3@<X8>, __n128 a4@<Q0>)
{
  std::__shared_weak_count *v6;
  NSObject *v8;
  int v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  dispatch_object_t v13;
  uint64_t v14;
  std::__shared_weak_count *v15;

  v14 = 0;
  v15 = 0;
  v6 = *(std::__shared_weak_count **)(a1 + 32);
  if (v6 && (v15 = std::__shared_weak_count::lock(v6)) != 0 && (v14 = *(_QWORD *)(a1 + 24)) != 0)
  {
    v8 = *a2;
    v13 = v8;
    if (v8)
      dispatch_retain(v8);
    a4.n128_f64[0] = QMIDMSCommandDriver::create((uint64_t)&v14, &v13, (_OWORD *)a3);
    if (v8)
      dispatch_release(v8);
    v9 = 0;
  }
  else
  {
    v9 = 1;
  }
  v10 = v15;
  if (!v15)
    goto LABEL_14;
  p_shared_owners = (unint64_t *)&v15->__shared_owners_;
  do
    v12 = __ldaxr(p_shared_owners);
  while (__stlxr(v12 - 1, p_shared_owners));
  if (!v12)
  {
    ((void (*)(std::__shared_weak_count *, __n128))v10->__on_zero_shared)(v10, a4);
    std::__shared_weak_count::__release_weak(v10);
    if (!v9)
      return;
  }
  else
  {
LABEL_14:
    if (!v9)
      return;
  }
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
}

void sub_216A90A70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  NSObject *v11;

  if (v11)
    dispatch_release(v11);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

void MCommandDriversFactory::createPhonebookCommandDriver(uint64_t a1@<X0>, NSObject **a2@<X1>, _OWORD *a3@<X8>)
{
  std::__shared_weak_count *v6;
  NSObject *v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  dispatch_object_t object;
  uint64_t v12;
  std::__shared_weak_count *v13;
  __int128 v14;

  v12 = 0;
  v13 = 0;
  v6 = *(std::__shared_weak_count **)(a1 + 32);
  if (v6)
  {
    v13 = std::__shared_weak_count::lock(v6);
    if (v13)
      v12 = *(_QWORD *)(a1 + 24);
  }
  v7 = *a2;
  object = v7;
  if (v7)
    dispatch_retain(v7);
  QMIPhonebookCommandDriver::create((uint64_t)&v12, &object, (uint64_t *)&v14);
  *a3 = v14;
  v14 = 0uLL;
  if (object)
    dispatch_release(object);
  v8 = v13;
  if (v13)
  {
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      v10 = __ldaxr(p_shared_owners);
    while (__stlxr(v10 - 1, p_shared_owners));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
}

void sub_216A90B54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, char a11)
{
  if (object)
    dispatch_release(object);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

void MCommandDriversFactory::createAwdCommandDriver(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  std::__shared_weak_count *v4;
  capabilities::radio *v5;
  int v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  __int128 v10;
  uint64_t v11;
  std::__shared_weak_count *v12;

  v11 = 0;
  v12 = 0;
  v4 = *(std::__shared_weak_count **)(a1 + 32);
  if (v4
    && (v5 = (capabilities::radio *)std::__shared_weak_count::lock(v4), (v12 = (std::__shared_weak_count *)v5) != 0)
    && (v11 = *(_QWORD *)(a1 + 24)) != 0)
  {
    if (capabilities::radio::supportsMultiClientAWD(v5))
      awd::QMIMav20AwdCommandDriver::create(&v10);
    else
      awd::QMIAwdCommandDriver::create((uint64_t *)&v10);
    v6 = 0;
    *(_OWORD *)a2 = v10;
  }
  else
  {
    v6 = 1;
  }
  v7 = v12;
  if (!v12)
    goto LABEL_13;
  p_shared_owners = (unint64_t *)&v12->__shared_owners_;
  do
    v9 = __ldaxr(p_shared_owners);
  while (__stlxr(v9 - 1, p_shared_owners));
  if (!v9)
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
    if (!v6)
      return;
  }
  else
  {
LABEL_13:
    if (!v6)
      return;
  }
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
}

void sub_216A90C54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void MCommandDriversFactory::createActivationCommandDriver(uint64_t a1@<X0>, NSObject **a2@<X1>, _OWORD *a3@<X8>)
{
  std::__shared_weak_count *v6;
  NSObject *v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  NSObject *v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  __int128 v14;

  v12 = 0;
  v13 = 0;
  v6 = *(std::__shared_weak_count **)(a1 + 32);
  if (v6)
  {
    v13 = std::__shared_weak_count::lock(v6);
    if (v13)
      v12 = *(_QWORD *)(a1 + 24);
  }
  v7 = *a2;
  v11 = v7;
  if (v7)
    dispatch_retain(v7);
  QMIActivationCommandDriver::create((uint64_t)&v12, &v11, &v14);
  *a3 = v14;
  v14 = 0uLL;
  if (v7)
    dispatch_release(v7);
  v8 = v13;
  if (v13)
  {
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      v10 = __ldaxr(p_shared_owners);
    while (__stlxr(v10 - 1, p_shared_owners));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
}

void sub_216A90D38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  NSObject *v11;

  if (v11)
    dispatch_release(v11);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

void MCommandDriversFactory::createDesenseCommandDriver(uint64_t a1@<X0>, NSObject **a2@<X1>, uint64_t a3@<X8>)
{
  std::__shared_weak_count *v5;
  capabilities::ct *v7;
  NSObject *v8;
  int v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  NSObject *v13;
  NSObject *v14;
  __int128 v15;
  uint64_t v16;
  std::__shared_weak_count *v17;

  v16 = 0;
  v17 = 0;
  v5 = *(std::__shared_weak_count **)(a1 + 32);
  if (v5
    && (v7 = (capabilities::ct *)std::__shared_weak_count::lock(v5), (v17 = (std::__shared_weak_count *)v7) != 0)
    && (v16 = *(_QWORD *)(a1 + 24)) != 0)
  {
    if (capabilities::ct::supports5G(v7))
    {
      v8 = *a2;
      v14 = v8;
      if (v8)
        dispatch_retain(v8);
      Mav20QMIDesenseCommandDriver::create((uint64_t)&v16, &v14, (uint64_t *)&v15);
    }
    else
    {
      v8 = *a2;
      v13 = v8;
      if (v8)
        dispatch_retain(v8);
      QMIDesenseCommandDriver::create((uint64_t)&v16, &v13, (uint64_t *)&v15);
    }
    *(_OWORD *)a3 = v15;
    v15 = 0uLL;
    if (v8)
      dispatch_release(v8);
    v9 = 0;
  }
  else
  {
    v9 = 1;
  }
  v10 = v17;
  if (!v17)
    goto LABEL_19;
  p_shared_owners = (unint64_t *)&v17->__shared_owners_;
  do
    v12 = __ldaxr(p_shared_owners);
  while (__stlxr(v12 - 1, p_shared_owners));
  if (!v12)
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
    if (!v9)
      return;
  }
  else
  {
LABEL_19:
    if (!v9)
      return;
  }
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
}

void sub_216A90E70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  NSObject *v13;

  if (v13)
    dispatch_release(v13);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  _Unwind_Resume(a1);
}

void MCommandDriversFactory::createAQMCommandDriver(uint64_t a1@<X0>, NSObject **a2@<X1>, _QWORD *a3@<X8>)
{
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v7;
  uint64_t v8;
  NSObject *v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  NSObject *v15;
  __int128 v16;
  uint64_t v17;
  std::__shared_weak_count *v18;

  v5 = *(std::__shared_weak_count **)(a1 + 32);
  if (!v5)
    goto LABEL_17;
  v7 = std::__shared_weak_count::lock(v5);
  v18 = v7;
  if (!v7)
    goto LABEL_17;
  v8 = *(_QWORD *)(a1 + 24);
  v17 = v8;
  if (!v8)
  {
    v10 = v7;
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v14 = __ldaxr(p_shared_owners);
    while (__stlxr(v14 - 1, p_shared_owners));
    if (!v14)
      goto LABEL_16;
LABEL_17:
    *a3 = 0;
    a3[1] = 0;
    return;
  }
  v9 = *a2;
  v15 = v9;
  if (v9)
    dispatch_retain(v9);
  QMIAQMCommandDriver::create((uint64_t)&v17, &v15, (uint64_t *)&v16);
  *(_OWORD *)a3 = v16;
  v16 = 0uLL;
  if (v9)
    dispatch_release(v9);
  v10 = v18;
  if (v18)
  {
    v11 = (unint64_t *)&v18->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
LABEL_16:
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
      if (v8)
        return;
      goto LABEL_17;
    }
  }
}

void sub_216A90F8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  NSObject *v13;

  if (v13)
    dispatch_release(v13);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  _Unwind_Resume(a1);
}

void MCommandDriversFactory::createDormancyCommandDriver(_QWORD *a1@<X0>, NSObject **a2@<X1>, int a3@<W2>, _OWORD *a4@<X8>)
{
  std::__shared_weak_count *v8;
  NSObject *v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  std::__shared_weak_count *v12;
  std::__shared_weak_count *v13;
  unint64_t *p_shared_owners;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  uint64_t v19[2];
  dispatch_object_t object;
  uint64_t v21;
  std::__shared_weak_count *v22;
  __int128 v23;

  v21 = 0;
  v22 = 0;
  v8 = (std::__shared_weak_count *)a1[4];
  if (v8)
  {
    v22 = std::__shared_weak_count::lock(v8);
    if (v22)
      v21 = a1[3];
  }
  v9 = *a2;
  object = v9;
  if (v9)
    dispatch_retain(v9);
  v10 = (std::__shared_weak_count *)a1[2];
  if (!v10 || (v11 = a1[1], (v12 = std::__shared_weak_count::lock(v10)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v13 = v12;
  v19[0] = v11;
  v19[1] = (uint64_t)v12;
  dormancy::QMIDormancyCommandDriver::create((uint64_t)&v21, &object, a3, v19, (uint64_t *)&v23);
  *a4 = v23;
  v23 = 0uLL;
  p_shared_owners = (unint64_t *)&v13->__shared_owners_;
  do
    v15 = __ldaxr(p_shared_owners);
  while (__stlxr(v15 - 1, p_shared_owners));
  if (!v15)
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
  if (object)
    dispatch_release(object);
  v16 = v22;
  if (v22)
  {
    v17 = (unint64_t *)&v22->__shared_owners_;
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
}

void sub_216A91118(_Unwind_Exception *a1, uint64_t a2, ...)
{
  NSObject *v2;
  uint64_t v4;
  va_list va;
  uint64_t v6;
  uint64_t v7;
  va_list va1;
  uint64_t v9;
  uint64_t v10;
  va_list va2;

  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v7 = va_arg(va2, _QWORD);
  v9 = va_arg(va2, _QWORD);
  v10 = va_arg(va2, _QWORD);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va);
  if (v2)
    dispatch_release(v2);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va2);
  _Unwind_Resume(a1);
}

void MCommandDriversFactory::createAttachApnCommandDriver(uint64_t a1@<X0>, NSObject **a2@<X1>, _QWORD *a3@<X8>)
{
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  NSObject *v12;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  NSObject *v18;
  uint64_t v19[2];
  __int128 v20;
  uint64_t v21;
  std::__shared_weak_count *v22;

  v5 = *(std::__shared_weak_count **)(a1 + 32);
  if (!v5)
    goto LABEL_22;
  v7 = std::__shared_weak_count::lock(v5);
  v22 = v7;
  if (!v7)
    goto LABEL_22;
  v8 = v7;
  v9 = *(_QWORD *)(a1 + 24);
  v21 = v9;
  if (!v9)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v17 = __ldaxr(p_shared_owners);
    while (__stlxr(v17 - 1, p_shared_owners));
    if (!v17)
      goto LABEL_21;
LABEL_22:
    *a3 = 0;
    a3[1] = 0;
    return;
  }
  v19[0] = v9;
  v19[1] = (uint64_t)v7;
  v10 = (unint64_t *)&v7->__shared_owners_;
  do
    v11 = __ldxr(v10);
  while (__stxr(v11 + 1, v10));
  v12 = *a2;
  v18 = v12;
  if (v12)
    dispatch_retain(v12);
  QMIAttachApnCommandDriverFactory::create(v19, &v18, (uint64_t *)&v20);
  *(_OWORD *)a3 = v20;
  v20 = 0uLL;
  if (v12)
    dispatch_release(v12);
  do
    v13 = __ldaxr(v10);
  while (__stlxr(v13 - 1, v10));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
  v8 = v22;
  if (v22)
  {
    v14 = (unint64_t *)&v22->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
LABEL_21:
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
      if (v9)
        return;
      goto LABEL_22;
    }
  }
}

void sub_216A9128C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  NSObject *v15;

  if (v15)
    dispatch_release(v15);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a15);
  _Unwind_Resume(a1);
}

void MCommandDriversFactory::createP2PCommandDriver(uint64_t a1@<X0>, NSObject **a2@<X1>, _QWORD *a3@<X8>)
{
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  NSObject *v12;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  NSObject *v18;
  _QWORD v19[2];
  __int128 v20;
  uint64_t v21;
  std::__shared_weak_count *v22;

  v5 = *(std::__shared_weak_count **)(a1 + 32);
  if (!v5)
    goto LABEL_22;
  v7 = std::__shared_weak_count::lock(v5);
  v22 = v7;
  if (!v7)
    goto LABEL_22;
  v8 = v7;
  v9 = *(_QWORD *)(a1 + 24);
  v21 = v9;
  if (!v9)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v17 = __ldaxr(p_shared_owners);
    while (__stlxr(v17 - 1, p_shared_owners));
    if (!v17)
      goto LABEL_21;
LABEL_22:
    *a3 = 0;
    a3[1] = 0;
    return;
  }
  v19[0] = v9;
  v19[1] = v7;
  v10 = (unint64_t *)&v7->__shared_owners_;
  do
    v11 = __ldxr(v10);
  while (__stxr(v11 + 1, v10));
  v12 = *a2;
  v18 = v12;
  if (v12)
    dispatch_retain(v12);
  QMIP2PCommandDriver::create(v19, &v18, (uint64_t *)&v20);
  *(_OWORD *)a3 = v20;
  v20 = 0uLL;
  if (v12)
    dispatch_release(v12);
  do
    v13 = __ldaxr(v10);
  while (__stlxr(v13 - 1, v10));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
  v8 = v22;
  if (v22)
  {
    v14 = (unint64_t *)&v22->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
LABEL_21:
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
      if (v9)
        return;
      goto LABEL_22;
    }
  }
}

void sub_216A913F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  NSObject *v15;

  if (v15)
    dispatch_release(v15);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a15);
  _Unwind_Resume(a1);
}

void MCommandDriversFactory::createDataFactoryCommandDriver(uint64_t a1@<X0>, NSObject **a2@<X1>, _QWORD *a3@<X8>)
{
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  NSObject *v12;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  NSObject *v18;
  uint64_t v19[2];
  __int128 v20;
  uint64_t v21;
  std::__shared_weak_count *v22;

  v5 = *(std::__shared_weak_count **)(a1 + 32);
  if (!v5)
    goto LABEL_22;
  v7 = std::__shared_weak_count::lock(v5);
  v22 = v7;
  if (!v7)
    goto LABEL_22;
  v8 = v7;
  v9 = *(_QWORD *)(a1 + 24);
  v21 = v9;
  if (!v9)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v17 = __ldaxr(p_shared_owners);
    while (__stlxr(v17 - 1, p_shared_owners));
    if (!v17)
      goto LABEL_21;
LABEL_22:
    *a3 = 0;
    a3[1] = 0;
    return;
  }
  v19[0] = v9;
  v19[1] = (uint64_t)v7;
  v10 = (unint64_t *)&v7->__shared_owners_;
  do
    v11 = __ldxr(v10);
  while (__stxr(v11 + 1, v10));
  v12 = *a2;
  v18 = v12;
  if (v12)
    dispatch_retain(v12);
  QMIDataFactoryCommandDriver::create(v19, &v18, (uint64_t *)&v20);
  *(_OWORD *)a3 = v20;
  v20 = 0uLL;
  if (v12)
    dispatch_release(v12);
  do
    v13 = __ldaxr(v10);
  while (__stlxr(v13 - 1, v10));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
  v8 = v22;
  if (v22)
  {
    v14 = (unint64_t *)&v22->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
LABEL_21:
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
      if (v9)
        return;
      goto LABEL_22;
    }
  }
}

void sub_216A91554(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  NSObject *v15;

  if (v15)
    dispatch_release(v15);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a15);
  _Unwind_Resume(a1);
}

void MCommandDriversFactory::createCellMonitorCommandDriver(uint64_t a1@<X0>, NSObject **a2@<X1>, _OWORD *a3@<X8>)
{
  std::__shared_weak_count *v6;
  NSObject *v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  NSObject *v11;
  uint64_t v12;
  std::__shared_weak_count *v13;

  v12 = 0;
  v13 = 0;
  v6 = *(std::__shared_weak_count **)(a1 + 32);
  if (v6)
  {
    v13 = std::__shared_weak_count::lock(v6);
    if (v13)
      v12 = *(_QWORD *)(a1 + 24);
  }
  v7 = *a2;
  v11 = v7;
  if (v7)
    dispatch_retain(v7);
  QMICellMonitorCommandDriver::create((uint64_t)&v12, &v11, a3);
  if (v7)
    dispatch_release(v7);
  v8 = v13;
  if (v13)
  {
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      v10 = __ldaxr(p_shared_owners);
    while (__stlxr(v10 - 1, p_shared_owners));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
}

void sub_216A91638(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  NSObject *v11;

  if (v11)
    dispatch_release(v11);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

void MCommandDriversFactory::createEnhancedLQMCommandDriver(uint64_t a1@<X0>, NSObject **a2@<X1>, _QWORD *a3@<X8>)
{
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v7;
  uint64_t v8;
  NSObject *v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  NSObject *v15;
  __int128 v16;
  uint64_t v17;
  std::__shared_weak_count *v18;

  v5 = *(std::__shared_weak_count **)(a1 + 32);
  if (!v5)
    goto LABEL_17;
  v7 = std::__shared_weak_count::lock(v5);
  v18 = v7;
  if (!v7)
    goto LABEL_17;
  v8 = *(_QWORD *)(a1 + 24);
  v17 = v8;
  if (!v8)
  {
    v10 = v7;
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v14 = __ldaxr(p_shared_owners);
    while (__stlxr(v14 - 1, p_shared_owners));
    if (!v14)
      goto LABEL_16;
LABEL_17:
    *a3 = 0;
    a3[1] = 0;
    return;
  }
  v9 = *a2;
  v15 = v9;
  if (v9)
    dispatch_retain(v9);
  QMIEnhancedLQMCommandDriver::create((uint64_t)&v17, &v15, (uint64_t *)&v16);
  *(_OWORD *)a3 = v16;
  v16 = 0uLL;
  if (v9)
    dispatch_release(v9);
  v10 = v18;
  if (v18)
  {
    v11 = (unint64_t *)&v18->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
LABEL_16:
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
      if (v8)
        return;
      goto LABEL_17;
    }
  }
}

void sub_216A91748(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  NSObject *v13;

  if (v13)
    dispatch_release(v13);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  _Unwind_Resume(a1);
}

void MCommandDriversFactory::createAudioRoutingCommandDriver(uint64_t a1@<X0>, NSObject **a2@<X1>, _QWORD *a3@<X8>)
{
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v7;
  uint64_t v8;
  NSObject *v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  NSObject *v15;
  __int128 v16;
  uint64_t v17;
  std::__shared_weak_count *v18;

  v5 = *(std::__shared_weak_count **)(a1 + 32);
  if (!v5)
    goto LABEL_17;
  v7 = std::__shared_weak_count::lock(v5);
  v18 = v7;
  if (!v7)
    goto LABEL_17;
  v8 = *(_QWORD *)(a1 + 24);
  v17 = v8;
  if (!v8)
  {
    v10 = v7;
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v14 = __ldaxr(p_shared_owners);
    while (__stlxr(v14 - 1, p_shared_owners));
    if (!v14)
      goto LABEL_16;
LABEL_17:
    *a3 = 0;
    a3[1] = 0;
    return;
  }
  v9 = *a2;
  v15 = v9;
  if (v9)
    dispatch_retain(v9);
  QMIAudioRoutingCommandDriver::create((uint64_t)&v17, &v15, (uint64_t *)&v16);
  *(_OWORD *)a3 = v16;
  v16 = 0uLL;
  if (v9)
    dispatch_release(v9);
  v10 = v18;
  if (v18)
  {
    v11 = (unint64_t *)&v18->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
LABEL_16:
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
      if (v8)
        return;
      goto LABEL_17;
    }
  }
}

void sub_216A91858(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  NSObject *v13;

  if (v13)
    dispatch_release(v13);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  _Unwind_Resume(a1);
}

void MCommandDriversFactory::createAudioCommandDriver(uint64_t a1@<X0>, NSObject **a2@<X1>, _QWORD *a3@<X8>)
{
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  NSObject *v12;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  NSObject *v18;
  uint64_t v19[2];
  __int128 v20;
  uint64_t v21;
  std::__shared_weak_count *v22;

  v5 = *(std::__shared_weak_count **)(a1 + 32);
  if (!v5)
    goto LABEL_22;
  v7 = std::__shared_weak_count::lock(v5);
  v22 = v7;
  if (!v7)
    goto LABEL_22;
  v8 = v7;
  v9 = *(_QWORD *)(a1 + 24);
  v21 = v9;
  if (!v9)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v17 = __ldaxr(p_shared_owners);
    while (__stlxr(v17 - 1, p_shared_owners));
    if (!v17)
      goto LABEL_21;
LABEL_22:
    *a3 = 0;
    a3[1] = 0;
    return;
  }
  v19[0] = v9;
  v19[1] = (uint64_t)v7;
  v10 = (unint64_t *)&v7->__shared_owners_;
  do
    v11 = __ldxr(v10);
  while (__stxr(v11 + 1, v10));
  v12 = *a2;
  v18 = v12;
  if (v12)
    dispatch_retain(v12);
  QMIAudioCommandDriver::create(v19, &v18, (uint64_t *)&v20);
  *(_OWORD *)a3 = v20;
  v20 = 0uLL;
  if (v12)
    dispatch_release(v12);
  do
    v13 = __ldaxr(v10);
  while (__stlxr(v13 - 1, v10));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
  v8 = v22;
  if (v22)
  {
    v14 = (unint64_t *)&v22->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
LABEL_21:
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
      if (v9)
        return;
      goto LABEL_22;
    }
  }
}

void sub_216A919B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  NSObject *v15;

  if (v15)
    dispatch_release(v15);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a15);
  _Unwind_Resume(a1);
}

void MCommandDriversFactory::createCallAudioCommandDriver(uint64_t a1@<X0>, NSObject **a2@<X1>, __int128 *a3@<X2>, __int128 *a4@<X3>, _QWORD *a5@<X8>)
{
  std::__shared_weak_count *v7;
  std::__shared_weak_count *v11;
  std::__shared_weak_count *v12;
  uint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  NSObject *v16;
  __int128 v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  unint64_t *v27;
  unint64_t v28;
  unint64_t *p_shared_owners;
  unint64_t v30;
  __int128 v31;
  __int128 v32;
  dispatch_object_t object;
  uint64_t v34;
  std::__shared_weak_count *v35;
  __int128 v36;
  uint64_t v37;
  std::__shared_weak_count *v38;

  v7 = *(std::__shared_weak_count **)(a1 + 32);
  if (!v7)
    goto LABEL_34;
  v11 = std::__shared_weak_count::lock(v7);
  v38 = v11;
  if (!v11)
    goto LABEL_34;
  v12 = v11;
  v13 = *(_QWORD *)(a1 + 24);
  v37 = v13;
  if (!v13)
  {
    p_shared_owners = (unint64_t *)&v11->__shared_owners_;
    do
      v30 = __ldaxr(p_shared_owners);
    while (__stlxr(v30 - 1, p_shared_owners));
    if (!v30)
      goto LABEL_33;
LABEL_34:
    *a5 = 0;
    a5[1] = 0;
    return;
  }
  v34 = v13;
  v35 = v11;
  v14 = (unint64_t *)&v11->__shared_owners_;
  do
    v15 = __ldxr(v14);
  while (__stxr(v15 + 1, v14));
  v16 = *a2;
  object = v16;
  if (v16)
    dispatch_retain(v16);
  v17 = *a3;
  *(_QWORD *)a3 = 0;
  *((_QWORD *)a3 + 1) = 0;
  v31 = *a4;
  v32 = v17;
  *(_QWORD *)a4 = 0;
  *((_QWORD *)a4 + 1) = 0;
  QMICallAudioDriver::create((uint64_t)&v34, &object, (uint64_t)&v32, (uint64_t)&v31, (uint64_t *)&v36);
  *(_OWORD *)a5 = v36;
  v36 = 0uLL;
  v18 = (std::__shared_weak_count *)*((_QWORD *)&v31 + 1);
  if (*((_QWORD *)&v31 + 1))
  {
    v19 = (unint64_t *)(*((_QWORD *)&v31 + 1) + 8);
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
  v21 = (std::__shared_weak_count *)*((_QWORD *)&v32 + 1);
  if (*((_QWORD *)&v32 + 1))
  {
    v22 = (unint64_t *)(*((_QWORD *)&v32 + 1) + 8);
    do
      v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }
  if (object)
    dispatch_release(object);
  v24 = v35;
  if (v35)
  {
    v25 = (unint64_t *)&v35->__shared_owners_;
    do
      v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
  }
  v12 = v38;
  if (v38)
  {
    v27 = (unint64_t *)&v38->__shared_owners_;
    do
      v28 = __ldaxr(v27);
    while (__stlxr(v28 - 1, v27));
    if (!v28)
    {
LABEL_33:
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
      if (v13)
        return;
      goto LABEL_34;
    }
  }
}

void sub_216A91BB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, dispatch_object_t object, char a15)
{
  uint64_t v15;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  if (object)
    dispatch_release(object);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a15);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v15 - 64);
  _Unwind_Resume(a1);
}

void MCommandDriversFactory::createSuppServicesCommandDriver(uint64_t a1@<X0>, dispatch_object_t *a2@<X1>, _QWORD *a3@<X8>)
{
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  dispatch_object_t object;
  __int128 v15;
  uint64_t v16;
  std::__shared_weak_count *v17;

  v5 = *(std::__shared_weak_count **)(a1 + 32);
  if (!v5)
    goto LABEL_15;
  v7 = std::__shared_weak_count::lock(v5);
  v17 = v7;
  if (!v7)
    goto LABEL_15;
  v8 = *(_QWORD *)(a1 + 24);
  v16 = v8;
  if (!v8)
  {
    v9 = v7;
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v13 = __ldaxr(p_shared_owners);
    while (__stlxr(v13 - 1, p_shared_owners));
    if (!v13)
      goto LABEL_14;
LABEL_15:
    *a3 = 0;
    a3[1] = 0;
    return;
  }
  object = *a2;
  *a2 = 0;
  QMISuppServicesCommandDriver::create((uint64_t)&v16, &object, (uint64_t *)&v15);
  *(_OWORD *)a3 = v15;
  v15 = 0uLL;
  if (object)
    dispatch_release(object);
  v9 = v17;
  if (v17)
  {
    v10 = (unint64_t *)&v17->__shared_owners_;
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
LABEL_14:
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
      if (v8)
        return;
      goto LABEL_15;
    }
  }
}

void sub_216A91CD4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, uint64_t a11, uint64_t a12, char a13)
{
  if (object)
    dispatch_release(object);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  _Unwind_Resume(a1);
}

void MCommandDriversFactory::createStkCommandDriver(uint64_t a1@<X0>, dispatch_object_t *a2@<X1>, uint64_t a3@<X2>, _QWORD *a4@<X8>)
{
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v9;
  uint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t *p_shared_owners;
  unint64_t v18;
  __int128 v19;
  dispatch_object_t object;
  __int128 v21;
  uint64_t v22;
  std::__shared_weak_count *v23;

  v6 = *(std::__shared_weak_count **)(a1 + 32);
  if (!v6)
    goto LABEL_20;
  v9 = std::__shared_weak_count::lock(v6);
  v23 = v9;
  if (!v9)
    goto LABEL_20;
  v10 = *(_QWORD *)(a1 + 24);
  v22 = v10;
  if (!v10)
  {
    v14 = v9;
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v18 = __ldaxr(p_shared_owners);
    while (__stlxr(v18 - 1, p_shared_owners));
    if (!v18)
      goto LABEL_19;
LABEL_20:
    *a4 = 0;
    a4[1] = 0;
    return;
  }
  object = *a2;
  *a2 = 0;
  v19 = *(_OWORD *)a3;
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  QMI_STK_CommandDriver::create(&v22, &object, &v19, (uint64_t *)&v21);
  *(_OWORD *)a4 = v21;
  v21 = 0uLL;
  v11 = (std::__shared_weak_count *)*((_QWORD *)&v19 + 1);
  if (*((_QWORD *)&v19 + 1))
  {
    v12 = (unint64_t *)(*((_QWORD *)&v19 + 1) + 8);
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  if (object)
    dispatch_release(object);
  v14 = v23;
  if (v23)
  {
    v15 = (unint64_t *)&v23->__shared_owners_;
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
LABEL_19:
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
      if (v10)
        return;
      goto LABEL_20;
    }
  }
}

void sub_216A91E30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, dispatch_object_t object, uint64_t a13, uint64_t a14, char a15)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  if (object)
    dispatch_release(object);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a15);
  _Unwind_Resume(a1);
}

void MCommandDriversFactory::createCallCommandDriver(uint64_t a1@<X0>, NSObject **a2@<X1>, objc_class **a3@<X2>, _QWORD *a4@<X8>)
{
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v9;
  uint64_t v10;
  NSObject *v11;
  NSObject *v12;
  std::__shared_weak_count *v13;
  objc_class *v14;
  unint64_t *v15;
  unint64_t v16;
  NSObject *v17;
  unint64_t *v18;
  unint64_t *v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  std::__shared_weak_count *v27;
  unint64_t v28;
  unint64_t *p_shared_weak_owners;
  unint64_t v30;
  unint64_t v31;
  unint64_t *v32;
  unint64_t v33;
  unint64_t v34;
  std::__shared_weak_count *v35;
  unint64_t *v36;
  unint64_t v37;
  unint64_t *v38;
  unint64_t v39;
  std::__shared_weak_count *v40;
  unint64_t *v41;
  unint64_t v42;
  std::__shared_weak_count *v43;
  unint64_t *v44;
  unint64_t v45;
  unint64_t *v46;
  unint64_t v47;
  std::__shared_weak_count *v48;
  unint64_t *v49;
  unint64_t v50;
  std::__shared_weak_count *v51;
  unint64_t *v52;
  unint64_t v53;
  unint64_t *p_shared_owners;
  unint64_t v55;
  __int128 v56;
  __int128 v57;
  dispatch_object_t object;
  __int128 v59;
  uint64_t v60;
  std::__shared_weak_count *v61;
  __int128 v62;
  NSObject *v63;
  std::__shared_weak_count *v64;
  NSObject *v65[2];
  std::__shared_weak_count *v66;

  v6 = *(std::__shared_weak_count **)(a1 + 32);
  if (!v6)
    goto LABEL_72;
  v9 = std::__shared_weak_count::lock(v6);
  v61 = v9;
  if (!v9)
    goto LABEL_72;
  v10 = *(_QWORD *)(a1 + 24);
  v60 = v10;
  if (!v10)
  {
    v51 = v9;
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v55 = __ldaxr(p_shared_owners);
    while (__stlxr(v55 - 1, p_shared_owners));
    if (!v55)
      goto LABEL_71;
LABEL_72:
    *a4 = 0;
    a4[1] = 0;
    return;
  }
  v11 = *a2;
  object = v11;
  if (v11)
    dispatch_retain(v11);
  v59 = 0uLL;
  std::allocate_shared[abi:ne180100]<EurOTASPService,std::allocator<EurOTASPService>,std::shared_ptr<Registry const> const&,dispatch::queue &,std::shared_ptr<ServiceProvisioningInterface> const&,char const* const&,void>((uint64_t)&v60, &object, &v59);
  if (object)
    dispatch_release(object);
  v12 = *a2;
  *a2 = 0;
  v14 = *a3;
  v13 = (std::__shared_weak_count *)a3[1];
  *a3 = 0;
  a3[1] = 0;
  v56 = v59;
  if (*((_QWORD *)&v59 + 1))
  {
    v15 = (unint64_t *)(*((_QWORD *)&v59 + 1) + 8);
    do
      v16 = __ldxr(v15);
    while (__stxr(v16 + 1, v15));
  }
  v17 = operator new(0x30uLL);
  v17[1].isa = 0;
  v18 = (unint64_t *)&v17[1];
  v17[2].isa = 0;
  v17->isa = (Class)&off_24D5EC330;
  v17[3].isa = (Class)&off_24D5EC380;
  v17[4].isa = v14;
  v17[5].isa = (Class)v13;
  if (v13)
  {
    v19 = (unint64_t *)&v13->__shared_owners_;
    do
      v20 = __ldxr(v19);
    while (__stxr(v20 + 1, v19));
    do
      v21 = __ldaxr(v19);
    while (__stlxr(v21 - 1, v19));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  v65[1] = v17 + 3;
  v66 = (std::__shared_weak_count *)v17;
  v22 = operator new();
  v23 = v22;
  v65[0] = v12;
  v63 = v17 + 3;
  v64 = (std::__shared_weak_count *)v17;
  do
    v24 = __ldxr(v18);
  while (__stxr(v24 + 1, v18));
  EurekaCallCommandDriver::EurekaCallCommandDriver(v22, (uint64_t)&v60, v65, (uint64_t)"EurekaCallCommandDriver", &v63);
  *(_QWORD *)&v57 = v23;
  v25 = (std::__shared_weak_count *)operator new();
  v25->__shared_owners_ = 0;
  v26 = (unint64_t *)&v25->__shared_owners_;
  v25->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5EC520;
  v25->__shared_weak_owners_ = 0;
  v25[1].__vftable = (std::__shared_weak_count_vtbl *)v23;
  *((_QWORD *)&v57 + 1) = v25;
  v27 = *(std::__shared_weak_count **)(v23 + 16);
  if (v27)
  {
    if (v27->__shared_owners_ != -1)
      goto LABEL_32;
    do
      v28 = __ldxr(v26);
    while (__stxr(v28 + 1, v26));
    p_shared_weak_owners = (unint64_t *)&v25->__shared_weak_owners_;
    do
      v30 = __ldxr(p_shared_weak_owners);
    while (__stxr(v30 + 1, p_shared_weak_owners));
    *(_QWORD *)(v23 + 8) = v23;
    *(_QWORD *)(v23 + 16) = v25;
    std::__shared_weak_count::__release_weak(v27);
  }
  else
  {
    do
      v31 = __ldxr(v26);
    while (__stxr(v31 + 1, v26));
    v32 = (unint64_t *)&v25->__shared_weak_owners_;
    do
      v33 = __ldxr(v32);
    while (__stxr(v33 + 1, v32));
    *(_QWORD *)(v23 + 8) = v23;
    *(_QWORD *)(v23 + 16) = v25;
  }
  do
    v34 = __ldaxr(v26);
  while (__stlxr(v34 - 1, v26));
  if (!v34)
  {
    ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
    std::__shared_weak_count::__release_weak(v25);
  }
LABEL_32:
  v35 = v64;
  if (v64)
  {
    v36 = (unint64_t *)&v64->__shared_owners_;
    do
      v37 = __ldaxr(v36);
    while (__stlxr(v37 - 1, v36));
    if (!v37)
    {
      ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
      std::__shared_weak_count::__release_weak(v35);
    }
  }
  if (v65[0])
    dispatch_release(v65[0]);
  if ((_QWORD)v57)
  {
    v62 = v56;
    if (*((_QWORD *)&v56 + 1))
    {
      v38 = (unint64_t *)(*((_QWORD *)&v56 + 1) + 8);
      do
        v39 = __ldxr(v38);
      while (__stxr(v39 + 1, v38));
    }
    std::shared_ptr<qmi::Client::State>::operator=[abi:ne180100](v57 + 216, &v62);
    EurekaCallCommandDriver::createQMIClients((EurekaCallCommandDriver *)v57);
    v40 = (std::__shared_weak_count *)*((_QWORD *)&v62 + 1);
    if (*((_QWORD *)&v62 + 1))
    {
      v41 = (unint64_t *)(*((_QWORD *)&v62 + 1) + 8);
      do
        v42 = __ldaxr(v41);
      while (__stlxr(v42 - 1, v41));
      if (!v42)
      {
        ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
        std::__shared_weak_count::__release_weak(v40);
      }
    }
  }
  v43 = v66;
  if (v66)
  {
    v44 = (unint64_t *)&v66->__shared_owners_;
    do
      v45 = __ldaxr(v44);
    while (__stlxr(v45 - 1, v44));
    if (!v45)
    {
      ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
      std::__shared_weak_count::__release_weak(v43);
    }
  }
  *(_OWORD *)a4 = v57;
  if (*((_QWORD *)&v56 + 1))
  {
    v46 = (unint64_t *)(*((_QWORD *)&v56 + 1) + 8);
    do
      v47 = __ldaxr(v46);
    while (__stlxr(v47 - 1, v46));
    if (!v47)
    {
      (*(void (**)(_QWORD))(**((_QWORD **)&v56 + 1) + 16))(*((_QWORD *)&v56 + 1));
      std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v56 + 1));
    }
  }
  v48 = (std::__shared_weak_count *)*((_QWORD *)&v59 + 1);
  if (*((_QWORD *)&v59 + 1))
  {
    v49 = (unint64_t *)(*((_QWORD *)&v59 + 1) + 8);
    do
      v50 = __ldaxr(v49);
    while (__stlxr(v50 - 1, v49));
    if (!v50)
    {
      ((void (*)(std::__shared_weak_count *))v48->__on_zero_shared)(v48);
      std::__shared_weak_count::__release_weak(v48);
    }
  }
  v51 = v61;
  if (v61)
  {
    v52 = (unint64_t *)&v61->__shared_owners_;
    do
      v53 = __ldaxr(v52);
    while (__stlxr(v53 - 1, v52));
    if (!v53)
    {
LABEL_71:
      ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
      std::__shared_weak_count::__release_weak(v51);
      if (v10)
        return;
      goto LABEL_72;
    }
  }
}

void sub_216A922E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, char a18, uint64_t a19, char a20)
{
  uint64_t v20;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a20);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v20 - 80);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a16);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a18);
  _Unwind_Resume(a1);
}

void sub_216A923BC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, dispatch_object_t object)
{
  if (object)
    dispatch_release(object);
  JUMPOUT(0x216A923ACLL);
}

void MCommandDriversFactory::createSmsCommandDriver(uint64_t a1@<X0>, dispatch_object_t *a2@<X1>, _QWORD *a3@<X8>)
{
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v7;
  uint64_t v8;
  NSObject *v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  dispatch_object_t v15;
  __int128 v16;
  uint64_t v17;
  std::__shared_weak_count *v18;

  v5 = *(std::__shared_weak_count **)(a1 + 32);
  if (!v5)
    goto LABEL_15;
  v7 = std::__shared_weak_count::lock(v5);
  v18 = v7;
  if (!v7)
    goto LABEL_15;
  v8 = *(_QWORD *)(a1 + 24);
  v17 = v8;
  if (!v8)
  {
    v10 = v7;
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v14 = __ldaxr(p_shared_owners);
    while (__stlxr(v14 - 1, p_shared_owners));
    if (!v14)
      goto LABEL_14;
LABEL_15:
    *a3 = 0;
    a3[1] = 0;
    return;
  }
  v15 = *a2;
  v9 = v15;
  *a2 = 0;
  QMISMSCommandDriver::create((uint64_t)&v17, &v15, (uint64_t *)&v16);
  *(_OWORD *)a3 = v16;
  v16 = 0uLL;
  if (v9)
    dispatch_release(v9);
  v10 = v18;
  if (v18)
  {
    v11 = (unint64_t *)&v18->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
LABEL_14:
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
      if (v8)
        return;
      goto LABEL_15;
    }
  }
}

void sub_216A924B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  NSObject *v13;

  if (v13)
    dispatch_release(v13);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  _Unwind_Resume(a1);
}

void MCommandDriversFactory::createWiFiSettingsCommandDriver(uint64_t a1@<X0>, NSObject **a2@<X1>, _QWORD *a3@<X8>)
{
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v7;
  uint64_t v8;
  NSObject *v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  NSObject *v15;
  __int128 v16;
  uint64_t v17;
  std::__shared_weak_count *v18;

  v5 = *(std::__shared_weak_count **)(a1 + 32);
  if (!v5)
    goto LABEL_17;
  v7 = std::__shared_weak_count::lock(v5);
  v18 = v7;
  if (!v7)
    goto LABEL_17;
  v8 = *(_QWORD *)(a1 + 24);
  v17 = v8;
  if (!v8)
  {
    v10 = v7;
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v14 = __ldaxr(p_shared_owners);
    while (__stlxr(v14 - 1, p_shared_owners));
    if (!v14)
      goto LABEL_16;
LABEL_17:
    *a3 = 0;
    a3[1] = 0;
    return;
  }
  v9 = *a2;
  v15 = v9;
  if (v9)
    dispatch_retain(v9);
  QMIWiFiSettingsCommandDriver::create((uint64_t)&v17, &v15, (uint64_t *)&v16);
  *(_OWORD *)a3 = v16;
  v16 = 0uLL;
  if (v9)
    dispatch_release(v9);
  v10 = v18;
  if (v18)
  {
    v11 = (unint64_t *)&v18->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
LABEL_16:
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
      if (v8)
        return;
      goto LABEL_17;
    }
  }
}

void sub_216A925C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  NSObject *v13;

  if (v13)
    dispatch_release(v13);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  _Unwind_Resume(a1);
}

void MCommandDriversFactory::createNetworkListCommandDriver(uint64_t a1@<X0>, NSObject **a2@<X1>, _QWORD *a3@<X8>)
{
  std::__shared_weak_count *v5;
  CCPreferences *v7;
  uint64_t v8;
  NSObject *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  uint64_t v17;
  std::__shared_weak_count *v18;
  _QWORD v19[2];
  dispatch_object_t object;
  __int128 v21;
  uint64_t v22;
  std::__shared_weak_count *v23;

  v5 = *(std::__shared_weak_count **)(a1 + 32);
  if (!v5)
    goto LABEL_22;
  v7 = (CCPreferences *)std::__shared_weak_count::lock(v5);
  v23 = (std::__shared_weak_count *)v7;
  if (!v7)
    goto LABEL_22;
  v8 = *(_QWORD *)(a1 + 24);
  v22 = v8;
  if (!v8)
  {
    v12 = (std::__shared_weak_count *)v7;
    v15 = (unint64_t *)((char *)v7 + 8);
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
      goto LABEL_21;
LABEL_22:
    *a3 = 0;
    a3[1] = 0;
    return;
  }
  v9 = *a2;
  object = v9;
  if (v9)
    dispatch_retain(v9);
  CCPreferences::create(v7);
  v19[0] = v17;
  v19[1] = v18;
  QMINetworkListCommandDriver::create((uint64_t)&v22, &object, v19, (uint64_t *)&v21);
  *(_OWORD *)a3 = v21;
  v21 = 0uLL;
  if (v18)
  {
    p_shared_owners = (unint64_t *)&v18->__shared_owners_;
    do
      v11 = __ldaxr(p_shared_owners);
    while (__stlxr(v11 - 1, p_shared_owners));
    if (!v11)
    {
      ((void (*)())v18->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v18);
    }
  }
  if (object)
    dispatch_release(object);
  v12 = v23;
  if (v23)
  {
    v13 = (unint64_t *)&v23->__shared_owners_;
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
LABEL_21:
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
      if (v8)
        return;
      goto LABEL_22;
    }
  }
}

void sub_216A9275C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v5;
  va_list va;
  uint64_t v7;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v5 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va);
  if (v2)
    dispatch_release(v2);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v3 - 48);
  _Unwind_Resume(a1);
}

void MCommandDriversFactory::createNetworkRegistrationCommandDriver(uint64_t a1@<X0>, NSObject **a2@<X1>, uint64_t a3@<X8>, __n128 a4@<Q0>)
{
  std::__shared_weak_count *v6;
  NSObject *v8;
  int v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  NSObject *v13;
  uint64_t v14;
  std::__shared_weak_count *v15;

  v14 = 0;
  v15 = 0;
  v6 = *(std::__shared_weak_count **)(a1 + 32);
  if (v6 && (v15 = std::__shared_weak_count::lock(v6)) != 0 && (v14 = *(_QWORD *)(a1 + 24)) != 0)
  {
    v8 = *a2;
    v13 = v8;
    if (v8)
      dispatch_retain(v8);
    a4.n128_f64[0] = QMINetworkRegistrationDriver::create((uint64_t)&v14, &v13, (_OWORD *)a3);
    if (v8)
      dispatch_release(v8);
    v9 = 0;
  }
  else
  {
    v9 = 1;
  }
  v10 = v15;
  if (!v15)
    goto LABEL_14;
  p_shared_owners = (unint64_t *)&v15->__shared_owners_;
  do
    v12 = __ldaxr(p_shared_owners);
  while (__stlxr(v12 - 1, p_shared_owners));
  if (!v12)
  {
    ((void (*)(std::__shared_weak_count *, __n128))v10->__on_zero_shared)(v10, a4);
    std::__shared_weak_count::__release_weak(v10);
    if (!v9)
      return;
  }
  else
  {
LABEL_14:
    if (!v9)
      return;
  }
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
}

void sub_216A92870(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  NSObject *v11;

  if (v11)
    dispatch_release(v11);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

void MCommandDriversFactory::createBasebandSettingsCommandDriver(uint64_t a1@<X0>, NSObject **a2@<X1>, _QWORD *a3@<X8>)
{
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  NSObject *v12;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  dispatch_object_t object;
  uint64_t v19[2];
  __int128 v20;
  uint64_t v21;
  std::__shared_weak_count *v22;

  v5 = *(std::__shared_weak_count **)(a1 + 32);
  if (!v5)
    goto LABEL_22;
  v7 = std::__shared_weak_count::lock(v5);
  v22 = v7;
  if (!v7)
    goto LABEL_22;
  v8 = v7;
  v9 = *(_QWORD *)(a1 + 24);
  v21 = v9;
  if (!v9)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v17 = __ldaxr(p_shared_owners);
    while (__stlxr(v17 - 1, p_shared_owners));
    if (!v17)
      goto LABEL_21;
LABEL_22:
    *a3 = 0;
    a3[1] = 0;
    return;
  }
  v19[0] = v9;
  v19[1] = (uint64_t)v7;
  v10 = (unint64_t *)&v7->__shared_owners_;
  do
    v11 = __ldxr(v10);
  while (__stxr(v11 + 1, v10));
  v12 = *a2;
  object = v12;
  if (v12)
    dispatch_retain(v12);
  QMIBasebandSettingsDriver::create(v19, &object, (uint64_t *)&v20);
  *(_OWORD *)a3 = v20;
  v20 = 0uLL;
  if (object)
    dispatch_release(object);
  do
    v13 = __ldaxr(v10);
  while (__stlxr(v13 - 1, v10));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
  v8 = v22;
  if (v22)
  {
    v14 = (unint64_t *)&v22->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
LABEL_21:
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
      if (v9)
        return;
      goto LABEL_22;
    }
  }
}

void sub_216A929C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, char a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  if (object)
    dispatch_release(object);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a15);
  _Unwind_Resume(a1);
}

void MCommandDriversFactory::createVinylCommandDriver(MCommandDriversFactory *this@<X0>, _QWORD *a2@<X8>)
{
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  __int128 v12;
  _QWORD v13[2];

  v4 = (std::__shared_weak_count *)*((_QWORD *)this + 4);
  if (!v4)
    goto LABEL_12;
  v5 = std::__shared_weak_count::lock(v4);
  v13[1] = v5;
  if (!v5)
    goto LABEL_12;
  v6 = v5;
  v7 = *((_QWORD *)this + 3);
  v13[0] = v7;
  if (!v7)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v11 = __ldaxr(p_shared_owners);
    while (__stlxr(v11 - 1, p_shared_owners));
    if (!v11)
    {
LABEL_11:
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
      if (v7)
        return;
    }
LABEL_12:
    *a2 = 0;
    a2[1] = 0;
    return;
  }
  VinylQMICommandDriver::create((capabilities::ct *)v13, &v12);
  *(_OWORD *)a2 = v12;
  v8 = (unint64_t *)&v6->__shared_owners_;
  do
    v9 = __ldaxr(v8);
  while (__stlxr(v9 - 1, v8));
  if (!v9)
    goto LABEL_11;
}

void sub_216A92AAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void MCommandDriversFactory::createATCommandDriver(uint64_t a1@<X0>, NSObject **a2@<X1>, uint64_t a3@<X8>)
{
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  NSObject *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  dispatch_object_t v13;
  _QWORD v14[2];

  v5 = *(std::__shared_weak_count **)(a1 + 32);
  if (!v5)
    goto LABEL_12;
  v7 = std::__shared_weak_count::lock(v5);
  v14[1] = v7;
  if (!v7)
    goto LABEL_12;
  v8 = v7;
  v9 = *(_QWORD *)(a1 + 24);
  v14[0] = v9;
  if (v9)
  {
    v10 = *a2;
    v13 = v10;
    if (v10)
      dispatch_retain(v10);
    QMIATCommandDriver::create(&v13, v14, (_OWORD *)a3);
    if (v10)
      dispatch_release(v10);
  }
  p_shared_owners = (unint64_t *)&v8->__shared_owners_;
  do
    v12 = __ldaxr(p_shared_owners);
  while (__stlxr(v12 - 1, p_shared_owners));
  if (v12)
  {
    if (v9)
      return;
    goto LABEL_12;
  }
  ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
  std::__shared_weak_count::__release_weak(v8);
  if (!v9)
  {
LABEL_12:
    *(_QWORD *)a3 = 0;
    *(_QWORD *)(a3 + 8) = 0;
  }
}

void sub_216A92B88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  NSObject *v11;

  if (v11)
    dispatch_release(v11);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

void MCommandDriversFactory::createPreferredNetworksCommandDriver(uint64_t a1@<X0>, NSObject **a2@<X1>, uint64_t a3@<X8>)
{
  std::__shared_weak_count *v5;
  capabilities::ct *v7;
  uint64_t v8;
  capabilities::ct *v9;
  int v10;
  unint64_t *v11;
  unint64_t v12;
  NSObject *v13;
  std::__shared_weak_count *v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  int v17;
  unint64_t v18;
  NSObject *v19;
  xpc_object_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t *v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  xpc_object_t v27;
  NSObject *v28;
  uint64_t v29;
  std::__shared_weak_count *v30;
  dispatch_object_t object;
  uint64_t v32;
  std::__shared_weak_count *v33;
  __int128 v34;
  uint64_t v35;
  std::__shared_weak_count *v36;

  v35 = 0;
  v36 = 0;
  v5 = *(std::__shared_weak_count **)(a1 + 32);
  if (v5)
  {
    v7 = (capabilities::ct *)std::__shared_weak_count::lock(v5);
    v36 = (std::__shared_weak_count *)v7;
    if (v7)
    {
      v8 = *(_QWORD *)(a1 + 24);
      v35 = v8;
      if (v8)
      {
        v9 = v7;
        v10 = capabilities::ct::supports5G(v7);
        v11 = (unint64_t *)((char *)v9 + 8);
        if (v10)
        {
          v32 = v8;
          v33 = (std::__shared_weak_count *)v9;
          do
            v12 = __ldxr(v11);
          while (__stxr(v12 + 1, v11));
          v13 = *a2;
          object = v13;
          if (v13)
            dispatch_retain(v13);
          Mav20PreferredNetworksFactoryCommandDriver::create(&v32, &object, (uint64_t *)&v34);
          *(_OWORD *)a3 = v34;
          v34 = 0uLL;
          if (object)
            dispatch_release(object);
          v14 = v33;
          if (!v33)
            goto LABEL_30;
          p_shared_owners = (unint64_t *)&v33->__shared_owners_;
          do
            v16 = __ldaxr(p_shared_owners);
          while (__stlxr(v16 - 1, p_shared_owners));
        }
        else
        {
          v29 = v8;
          v30 = (std::__shared_weak_count *)v9;
          do
            v18 = __ldxr(v11);
          while (__stxr(v18 + 1, v11));
          v19 = *a2;
          v28 = v19;
          if (v19)
            dispatch_retain(v19);
          v20 = xpc_null_create();
          v27 = v20;
          QMIPreferredNetworksCommandDriver::create((uint64_t)&v29, &v28, &v27, (uint64_t *)&v34);
          v21 = *((_QWORD *)&v34 + 1);
          if ((_QWORD)v34)
            v22 = v34 + 40;
          else
            v22 = 0;
          *(_QWORD *)a3 = v22;
          *(_QWORD *)(a3 + 8) = v21;
          v34 = 0uLL;
          xpc_release(v20);
          v27 = 0;
          if (v19)
            dispatch_release(v19);
          v14 = v30;
          if (!v30)
            goto LABEL_30;
          v23 = (unint64_t *)&v30->__shared_owners_;
          do
            v16 = __ldaxr(v23);
          while (__stlxr(v16 - 1, v23));
        }
        if (!v16)
        {
          ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
          std::__shared_weak_count::__release_weak(v14);
        }
LABEL_30:
        v17 = 0;
        goto LABEL_31;
      }
    }
  }
  v17 = 1;
LABEL_31:
  v24 = v36;
  if (!v36)
    goto LABEL_35;
  v25 = (unint64_t *)&v36->__shared_owners_;
  do
    v26 = __ldaxr(v25);
  while (__stlxr(v26 - 1, v25));
  if (!v26)
  {
    ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
    std::__shared_weak_count::__release_weak(v24);
    if (!v17)
      return;
  }
  else
  {
LABEL_35:
    if (!v17)
      return;
  }
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
}

void sub_216A92D84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, dispatch_object_t object, char a15)
{
  NSObject *v15;
  void *v16;
  uint64_t v17;

  xpc_release(v16);
  if (v15)
    dispatch_release(v15);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a12);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v17 - 48);
  _Unwind_Resume(a1);
}

void MCommandDriversFactory::createCDMASettingsCommandDriver(uint64_t a1@<X0>, NSObject **a2@<X1>, uint64_t a3@<X8>)
{
  std::__shared_weak_count *v5;
  capabilities::ct *v7;
  NSObject *v8;
  NSObject *v9;
  int v10;
  std::__shared_weak_count *v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  NSObject *v14;
  NSObject *v15;
  dispatch_object_t object;
  __int128 v17;
  uint64_t v18;
  std::__shared_weak_count *v19;

  v18 = 0;
  v19 = 0;
  v5 = *(std::__shared_weak_count **)(a1 + 32);
  if (!v5
    || (v7 = (capabilities::ct *)std::__shared_weak_count::lock(v5), (v19 = (std::__shared_weak_count *)v7) == 0)
    || (v18 = *(_QWORD *)(a1 + 24)) == 0)
  {
    v10 = 1;
    goto LABEL_11;
  }
  if (capabilities::ct::supports5G(v7))
  {
    v8 = *a2;
    object = v8;
    if (v8)
      dispatch_retain(v8);
    Mav20QMICDMASettingsCommandDriver::create(&v18, &object, (uint64_t *)&v17);
    *(_OWORD *)a3 = v17;
    v17 = 0uLL;
    v9 = object;
    if (!object)
      goto LABEL_9;
  }
  else
  {
    v14 = *a2;
    v15 = v14;
    if (v14)
      dispatch_retain(v14);
    QMICDMASettingsCommandDriver::create(&v18, &v15, (uint64_t *)&v17);
    *(_OWORD *)a3 = v17;
    v17 = 0uLL;
    v9 = v15;
    if (!v15)
      goto LABEL_9;
  }
  dispatch_release(v9);
LABEL_9:
  v10 = 0;
LABEL_11:
  v11 = v19;
  if (!v19)
    goto LABEL_15;
  p_shared_owners = (unint64_t *)&v19->__shared_owners_;
  do
    v13 = __ldaxr(p_shared_owners);
  while (__stlxr(v13 - 1, p_shared_owners));
  if (v13)
  {
LABEL_15:
    if (!v10)
      return;
    goto LABEL_16;
  }
  ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
  std::__shared_weak_count::__release_weak(v11);
  if (v10)
  {
LABEL_16:
    *(_QWORD *)a3 = 0;
    *(_QWORD *)(a3 + 8) = 0;
  }
}

void sub_216A92F00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  if (object)
    dispatch_release(object);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  _Unwind_Resume(a1);
}

void MCommandDriversFactory::createDataSubscriptionCommandDriver(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  uint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  __int128 v12;
  uint64_t v13;
  std::__shared_weak_count *v14;

  v4 = *(std::__shared_weak_count **)(a1 + 32);
  if (!v4)
    goto LABEL_13;
  v5 = std::__shared_weak_count::lock(v4);
  v14 = v5;
  if (!v5)
    goto LABEL_13;
  v6 = *(_QWORD *)(a1 + 24);
  v13 = v6;
  if (!v6)
  {
    v7 = v5;
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v11 = __ldaxr(p_shared_owners);
    while (__stlxr(v11 - 1, p_shared_owners));
    if (!v11)
    {
LABEL_12:
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
      if (v6)
        return;
    }
LABEL_13:
    *a2 = 0;
    a2[1] = 0;
    return;
  }
  QMIDataSubscriptionCommandDriver::create((capabilities::ct *)&v13, (uint64_t *)&v12);
  *(_OWORD *)a2 = v12;
  v7 = v14;
  if (v14)
  {
    v8 = (unint64_t *)&v14->__shared_owners_;
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
      goto LABEL_12;
  }
}

void sub_216A93004(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void MCommandDriversFactory::createDownLinkFilterCommandDriver(uint64_t a1@<X0>, NSObject **a2@<X1>, int a3@<W2>, int a4@<W3>, unsigned int a5@<W4>, uint64_t *a6@<X5>, _QWORD *a7@<X8>)
{
  std::__shared_weak_count *v9;
  std::__shared_weak_count *v15;
  uint64_t v16;
  NSObject *v17;
  uint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *p_shared_weak_owners;
  unint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  unint64_t *p_shared_owners;
  unint64_t v26;
  uint64_t v27[2];
  NSObject *v28;
  __int128 v29;
  uint64_t v30;
  std::__shared_weak_count *v31;

  v9 = *(std::__shared_weak_count **)(a1 + 32);
  if (!v9)
    goto LABEL_22;
  v15 = std::__shared_weak_count::lock(v9);
  v31 = v15;
  if (!v15)
    goto LABEL_22;
  v16 = *(_QWORD *)(a1 + 24);
  v30 = v16;
  if (!v16)
  {
    v22 = v15;
    p_shared_owners = (unint64_t *)&v15->__shared_owners_;
    do
      v26 = __ldaxr(p_shared_owners);
    while (__stlxr(v26 - 1, p_shared_owners));
    if (!v26)
      goto LABEL_21;
LABEL_22:
    *a7 = 0;
    a7[1] = 0;
    return;
  }
  v17 = *a2;
  v28 = v17;
  if (v17)
    dispatch_retain(v17);
  v18 = *a6;
  v19 = (std::__shared_weak_count *)a6[1];
  v27[0] = v18;
  v27[1] = (uint64_t)v19;
  if (v19)
  {
    p_shared_weak_owners = (unint64_t *)&v19->__shared_weak_owners_;
    do
      v21 = __ldxr(p_shared_weak_owners);
    while (__stxr(v21 + 1, p_shared_weak_owners));
  }
  QMIDownLinkFilterCommandDriver::create(&v30, &v28, a3, a4, a5, v27, (uint64_t *)&v29);
  *(_OWORD *)a7 = v29;
  v29 = 0uLL;
  if (v19)
    std::__shared_weak_count::__release_weak(v19);
  if (v17)
    dispatch_release(v17);
  v22 = v31;
  if (v31)
  {
    v23 = (unint64_t *)&v31->__shared_owners_;
    do
      v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
LABEL_21:
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
      if (v16)
        return;
      goto LABEL_22;
    }
  }
}

void sub_216A93164(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  NSObject *v15;
  std::__shared_weak_count *v16;

  if (v16)
    std::__shared_weak_count::__release_weak(v16);
  if (v15)
    dispatch_release(v15);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a15);
  _Unwind_Resume(a1);
}

void MCommandDriversFactory::createEmbmsCommandDriver(uint64_t a1@<X0>, NSObject **a2@<X1>, _QWORD *a3@<X8>)
{
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v7;
  uint64_t v8;
  NSObject *v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  dispatch_object_t object;
  __int128 v16;
  uint64_t v17;
  std::__shared_weak_count *v18;

  v5 = *(std::__shared_weak_count **)(a1 + 32);
  if (!v5)
    goto LABEL_17;
  v7 = std::__shared_weak_count::lock(v5);
  v18 = v7;
  if (!v7)
    goto LABEL_17;
  v8 = *(_QWORD *)(a1 + 24);
  v17 = v8;
  if (!v8)
  {
    v10 = v7;
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v14 = __ldaxr(p_shared_owners);
    while (__stlxr(v14 - 1, p_shared_owners));
    if (!v14)
      goto LABEL_16;
LABEL_17:
    *a3 = 0;
    a3[1] = 0;
    return;
  }
  v9 = *a2;
  object = v9;
  if (v9)
    dispatch_retain(v9);
  QMIEmbmsCommandDriver::create(&v17, &object, (uint64_t *)&v16);
  *(_OWORD *)a3 = v16;
  v16 = 0uLL;
  if (object)
    dispatch_release(object);
  v10 = v18;
  if (v18)
  {
    v11 = (unint64_t *)&v18->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
LABEL_16:
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
      if (v8)
        return;
      goto LABEL_17;
    }
  }
}

void sub_216A9327C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, uint64_t a11, uint64_t a12, char a13)
{
  if (object)
    dispatch_release(object);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  _Unwind_Resume(a1);
}

void MCommandDriversFactory::createStewieCommandDriver(uint64_t a1@<X0>, NSObject **a2@<X1>, uint64_t a3@<X8>)
{
  std::__shared_weak_count *v5;
  capabilities::ct *v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  uint64_t v12;
  capabilities::ct *v13;

  v5 = *(std::__shared_weak_count **)(a1 + 32);
  if (!v5)
    goto LABEL_12;
  v7 = (capabilities::ct *)std::__shared_weak_count::lock(v5);
  v13 = v7;
  if (!v7)
    goto LABEL_12;
  v8 = (std::__shared_weak_count *)v7;
  v9 = *(_QWORD *)(a1 + 24);
  v12 = v9;
  if (v9)
  {
    if ((capabilities::ct::supportsStewie(v7) & 1) != 0)
    {
      QMIStewieCommandDriver::create((uint64_t)&v12, a2, (_OWORD *)a3);
      v8 = (std::__shared_weak_count *)v13;
      if (!v13)
        return;
    }
    else
    {
      *(_QWORD *)a3 = 0;
      *(_QWORD *)(a3 + 8) = 0;
    }
  }
  p_shared_owners = (unint64_t *)&v8->__shared_owners_;
  do
    v11 = __ldaxr(p_shared_owners);
  while (__stlxr(v11 - 1, p_shared_owners));
  if (v11)
  {
    if (v9)
      return;
    goto LABEL_12;
  }
  ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
  std::__shared_weak_count::__release_weak(v8);
  if (!v9)
  {
LABEL_12:
    *(_QWORD *)a3 = 0;
    *(_QWORD *)(a3 + 8) = 0;
  }
}

void sub_216A9335C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<MCommandDriversFactory>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5EC2E0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<MCommandDriversFactory>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5EC2E0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

uint64_t std::__shared_ptr_emplace<MCommandDriversFactory>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long,std::shared_ptr<void>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long,std::shared_ptr<void>>,void *>>>>::reset[abi:ne180100](uint64_t a1)
{
  void *v1;

  v1 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v1)
  {
    if (*(_BYTE *)(a1 + 16))
      std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)v1 + 24);
    operator delete(v1);
  }
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5EC330;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5EC330;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

uint64_t std::__shared_ptr_emplace<EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

_QWORD *EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::~CommandDriverDelegate(_QWORD *a1)
{
  *a1 = &off_24D5EC380;
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)(a1 + 1));
  return a1;
}

void EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::~CommandDriverDelegate(_QWORD *a1)
{
  *a1 = &off_24D5EC380;
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)(a1 + 1));
  JUMPOUT(0x2199FEAC4);
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::handleVoiceDialCallResp(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 16))(result);
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::handleCallDialedInd(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 24))(result);
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::handleCallDialedAndMediaInitializedInd(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 32))(result);
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::handleCallAlertingInd(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 48))(result);
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::handleCallActiveInd(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 64))(result);
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::handleCallActiveWithFWIM(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 72))(result);
  return result;
}

void EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::handleCallEndInd(uint64_t a1, const CallInfo *a2, uint64_t a3)
{
  uint64_t v3;
  void *v5[51];

  v3 = *(_QWORD *)(a1 + 8);
  if (v3)
  {
    CallInfo::CallInfo((CallInfo *)v5, a2);
    (*(void (**)(uint64_t, void **, uint64_t, uint64_t))(*(_QWORD *)v3 + 80))(v3, v5, a3, 1);
    CallInfo::~CallInfo(v5);
  }
}

void sub_216A935B4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  CallInfo::~CallInfo((void **)va);
  _Unwind_Resume(a1);
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::handleCallIncomingInd(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 96))(result);
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::handleBrandedCall(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 104))(result);
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::handleCallWaitingInd(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 112))(result);
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::handleNewWaitingCallWithTimer(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 136))(result);
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::handleCallHeldInd(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 144))(result);
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::handleMergedCalls(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 152))(result);
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::handleMergeCallsFailed(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 160))(result);
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::handleBBEmergencyModeExit(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 184))(result);
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::handlePrivateConversation(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 192))(result);
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::handleUSSDInd(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 200))(result);
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::handleSendUSSDResponse(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 208))(result);
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::handleVoiceHandoverEvent(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 216))(result);
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::handleSRVCCCallInfo(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 224))(result);
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::areVoiceCallsAllowedRightNow(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 296))(result);
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::isIncomingCallAllowedOnSIM(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 568))(result);
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::notifyCallCapabilities(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 304))(result);
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::setCallerIdForCall(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 312))(result);
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::cancelUSSDSession(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 480))(result);
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::triggerSilentRedialOverIMS(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 464))(result);
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::getTrafficChannelId(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 8);
  if (v1)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 320))(v1);
  else
    return *MEMORY[0x24BDC39A8];
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::handleCallHoldFailure(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 168))(result);
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::handleCallAnswerFailure(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 176))(result);
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::getNumberOfCurrentCalls(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 328))(result);
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::setCallCapability(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 336))(result);
  return result;
}

{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 344))(result);
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::handleVoicePrivacySet(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 352))(result);
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::setExpectDisconnectionOnAllCalls(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 448))(result);
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::getAudioDriver@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 488))(result);
  *a2 = 0;
  a2[1] = 0;
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::getCallInfoForUUID(uint64_t a1, const void **a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v5;
  const void *v7;

  v3 = *(_QWORD *)(a1 + 8);
  if (!v3)
    return 0;
  ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::SharedRef(&v7, a2);
  v5 = (*(uint64_t (**)(uint64_t, const void **, uint64_t))(*(_QWORD *)v3 + 432))(v3, &v7, a3);
  ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::~SharedRef(&v7);
  return v5;
}

void sub_216A938DC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::~SharedRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::getActiveCalls@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 400))(result);
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::getHeldCalls@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 424))(result);
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::getCurrentCalls@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 384))(result);
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  return result;
}

{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 392))(result);
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::updateCallIds(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 504))(result);
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::reportCallDisconnect(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 512))(result);
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::getTTYEnabledForSim(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 520))(result);
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::getTTYEnabledForCall(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 528))(result);
  return result;
}

uint64_t EurekaCallCommandDriver::CommandDriverDelegate<CallCommandDriverDelegateInterface>::ratSelectedCallReadyToDial(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 608))(result);
  return result;
}

void std::__shared_ptr_pointer<EurekaCallCommandDriver *,std::shared_ptr<EurekaCallCommandDriver> ctu::SharedSynchronizable<CallCommandDriver>::make_shared_ptr<EurekaCallCommandDriver>(EurekaCallCommandDriver*)::{lambda(EurekaCallCommandDriver *)#1},std::allocator<EurekaCallCommandDriver>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void std::__shared_ptr_pointer<EurekaCallCommandDriver *,std::shared_ptr<EurekaCallCommandDriver> ctu::SharedSynchronizable<CallCommandDriver>::make_shared_ptr<EurekaCallCommandDriver>(EurekaCallCommandDriver*)::{lambda(EurekaCallCommandDriver *)#1},std::allocator<EurekaCallCommandDriver>>::__on_zero_shared(uint64_t a1)
{
  dispatch_barrier_async_f(*(dispatch_queue_t *)(*(_QWORD *)(a1 + 24) + 24), *(void **)(a1 + 24), (dispatch_function_t)std::shared_ptr<EurekaCallCommandDriver> ctu::SharedSynchronizable<CallCommandDriver>::make_shared_ptr<EurekaCallCommandDriver>(EurekaCallCommandDriver*)::{lambda(EurekaCallCommandDriver*)#1}::operator() const(EurekaCallCommandDriver*)::{lambda(void *)#1}::__invoke);
}

uint64_t std::__shared_ptr_pointer<EurekaCallCommandDriver *,std::shared_ptr<EurekaCallCommandDriver> ctu::SharedSynchronizable<CallCommandDriver>::make_shared_ptr<EurekaCallCommandDriver>(EurekaCallCommandDriver*)::{lambda(EurekaCallCommandDriver *)#1},std::allocator<EurekaCallCommandDriver>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

unsigned int **std::shared_ptr<EurekaCallCommandDriver> ctu::SharedSynchronizable<CallCommandDriver>::make_shared_ptr<EurekaCallCommandDriver>(EurekaCallCommandDriver*)::{lambda(EurekaCallCommandDriver*)#1}::operator() const(EurekaCallCommandDriver*)::{lambda(void *)#1}::__invoke(unsigned int **result)
{
  if (result)
  {
    EurekaCallCommandDriver::~EurekaCallCommandDriver(result);
    JUMPOUT(0x2199FEAC4);
  }
  return result;
}

void QMIDataCommandDriverInterface::create(uint64_t *a1@<X0>, uint64_t a2@<X1>, NSObject **a3@<X2>, _QWORD *a4@<X8>)
{
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  NSObject *v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  dispatch_object_t object;
  uint64_t v16;
  std::__shared_weak_count *v17;
  uint64_t v18;
  uint64_t v19;

  v18 = 0;
  v19 = 0;
  v6 = a1[1];
  v16 = *a1;
  v17 = (std::__shared_weak_count *)v6;
  if (v6)
  {
    v7 = (unint64_t *)(v6 + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  v9 = *a3;
  object = v9;
  if (v9)
    dispatch_retain(v9);
  QMIDataCommandDriver::create(&v16, a2, &object, &v18);
  if (object)
    dispatch_release(object);
  v10 = v17;
  if (v17)
  {
    p_shared_owners = (unint64_t *)&v17->__shared_owners_;
    do
      v12 = __ldaxr(p_shared_owners);
    while (__stlxr(v12 - 1, p_shared_owners));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  v13 = v19;
  if (v18)
    v14 = v18 + 24;
  else
    v14 = 0;
  *a4 = v14;
  a4[1] = v13;
}

void sub_216A93B58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, char a11)
{
  if (object)
    dispatch_release(object);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

void QMIDataCommandDriver::create(uint64_t *a1@<X0>, uint64_t a2@<X1>, NSObject **a3@<X2>, uint64_t *a4@<X8>)
{
  uint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  NSObject *v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  dispatch_object_t object;
  uint64_t v17;
  std::__shared_weak_count *v18;

  *a4 = 0;
  a4[1] = 0;
  v8 = operator new();
  v9 = (std::__shared_weak_count *)a1[1];
  v17 = *a1;
  v18 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
  }
  v12 = *a3;
  object = v12;
  if (v12)
    dispatch_retain(v12);
  QMIDataCommandDriver::QMIDataCommandDriver(v8, &v17, a2, &object);
  *a4 = 0;
  a4[1] = 0;
  std::shared_ptr<QMIDataCommandDriver>::shared_ptr[abi:ne180100]<QMIDataCommandDriver,std::shared_ptr<QMIDataCommandDriver> ctu::SharedSynchronizable<QMIDataCommandDriver>::make_shared_ptr<QMIDataCommandDriver>(QMIDataCommandDriver*)::{lambda(QMIDataCommandDriver*)#1},void>(a4, v8);
  if (object)
    dispatch_release(object);
  v13 = v18;
  if (v18)
  {
    v14 = (unint64_t *)&v18->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  QMIDataCommandDriver::initialize_sync((QMIDataCommandDriver *)*a4);
}

void sub_216A93C80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, char a11)
{
  uint64_t v11;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v11);
  _Unwind_Resume(a1);
}

uint64_t *std::shared_ptr<QMIDataCommandDriver>::shared_ptr[abi:ne180100]<QMIDataCommandDriver,std::shared_ptr<QMIDataCommandDriver> ctu::SharedSynchronizable<QMIDataCommandDriver>::make_shared_ptr<QMIDataCommandDriver>(QMIDataCommandDriver*)::{lambda(QMIDataCommandDriver*)#1},void>(uint64_t *a1, uint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24D5EC580;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = (uint64_t)v4;
  if (a2)
    v5 = (_QWORD *)(a2 + 64);
  else
    v5 = 0;
  std::shared_ptr<QMIDataSystemDeterminationManager>::__enable_weak_this[abi:ne180100]<QMIDataSystemDeterminationManager,QMIDataSystemDeterminationManager,void>((uint64_t)a1, v5, a2);
  return a1;
}

void sub_216A93D50(void *a1)
{
  dispatch_queue_t *v1;

  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[10], v1, (dispatch_function_t)std::shared_ptr<QMIDataCommandDriver> ctu::SharedSynchronizable<QMIDataCommandDriver>::make_shared_ptr<QMIDataCommandDriver>(QMIDataCommandDriver*)::{lambda(QMIDataCommandDriver*)#1}::operator() const(QMIDataCommandDriver*)::{lambda(void *)#1}::__invoke);
  __cxa_rethrow();
}

void sub_216A93D70(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<QMIDataCommandDriver *,std::shared_ptr<QMIDataCommandDriver> ctu::SharedSynchronizable<QMIDataCommandDriver>::make_shared_ptr<QMIDataCommandDriver>(QMIDataCommandDriver*)::{lambda(QMIDataCommandDriver *)#1},std::allocator<QMIDataCommandDriver>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void std::__shared_ptr_pointer<QMIDataCommandDriver *,std::shared_ptr<QMIDataCommandDriver> ctu::SharedSynchronizable<QMIDataCommandDriver>::make_shared_ptr<QMIDataCommandDriver>(QMIDataCommandDriver*)::{lambda(QMIDataCommandDriver *)#1},std::allocator<QMIDataCommandDriver>>::__on_zero_shared(uint64_t a1)
{
  dispatch_barrier_async_f(*(dispatch_queue_t *)(*(_QWORD *)(a1 + 24) + 80), *(void **)(a1 + 24), (dispatch_function_t)std::shared_ptr<QMIDataCommandDriver> ctu::SharedSynchronizable<QMIDataCommandDriver>::make_shared_ptr<QMIDataCommandDriver>(QMIDataCommandDriver*)::{lambda(QMIDataCommandDriver*)#1}::operator() const(QMIDataCommandDriver*)::{lambda(void *)#1}::__invoke);
}

uint64_t std::__shared_ptr_pointer<QMIDataCommandDriver *,std::shared_ptr<QMIDataCommandDriver> ctu::SharedSynchronizable<QMIDataCommandDriver>::make_shared_ptr<QMIDataCommandDriver>(QMIDataCommandDriver*)::{lambda(QMIDataCommandDriver *)#1},std::allocator<QMIDataCommandDriver>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t std::shared_ptr<QMIDataCommandDriver> ctu::SharedSynchronizable<QMIDataCommandDriver>::make_shared_ptr<QMIDataCommandDriver>(QMIDataCommandDriver*)::{lambda(QMIDataCommandDriver*)#1}::operator() const(QMIDataCommandDriver*)::{lambda(void *)#1}::__invoke(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t QMIDataContextDriver::create@<X0>(uint64_t *a1@<X0>, NSObject **a2@<X3>, uint64_t *a3@<X4>, uint64_t *a4@<X5>, uint64_t *a5@<X6>, uint64_t a6@<X7>, uint64_t *a7@<X8>)
{
  uint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  NSObject *v18;
  std::__shared_weak_count *v19;
  uint64_t v20;
  unint64_t *v21;
  unint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  uint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  unint64_t *v30;
  unint64_t v31;
  unint64_t *v32;
  unint64_t v33;
  const char *DataContextName;
  std::string *v35;
  __int128 v36;
  const char *v37;
  size_t v38;
  std::string *v39;
  __int128 v40;
  unint64_t *v41;
  unint64_t v42;
  unint64_t *p_shared_weak_owners;
  unint64_t v44;
  unint64_t *v45;
  unint64_t v46;
  std::__shared_weak_count *v47;
  unint64_t *v48;
  std::__shared_weak_count *v49;
  unint64_t v50;
  unint64_t *v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t *v54;
  unint64_t v55;
  unint64_t v56;
  unint64_t *v57;
  unint64_t v58;
  unint64_t *v59;
  unint64_t v60;
  unint64_t *v61;
  unint64_t v62;
  unint64_t *v63;
  unint64_t v64;
  uint64_t v66;
  uint64_t v67;
  std::__shared_weak_count *v68;
  std::__shared_weak_count *v69;
  uint64_t v70;
  std::__shared_weak_count *v71;
  std::string v72;
  std::string v73;
  _QWORD v74[3];

  *a7 = 0;
  a7[1] = 0;
  v14 = operator new();
  v15 = (std::__shared_weak_count *)a1[1];
  v70 = *a1;
  v71 = v15;
  if (v15)
  {
    p_shared_owners = (unint64_t *)&v15->__shared_owners_;
    do
      v17 = __ldxr(p_shared_owners);
    while (__stxr(v17 + 1, p_shared_owners));
  }
  v18 = *a2;
  if (v18)
    dispatch_retain(v18);
  v20 = *a3;
  v19 = (std::__shared_weak_count *)a3[1];
  v69 = v19;
  if (v19)
  {
    v21 = (unint64_t *)&v19->__shared_owners_;
    do
      v22 = __ldxr(v21);
    while (__stxr(v22 + 1, v21));
  }
  v23 = (std::__shared_weak_count *)a4[1];
  v67 = *a4;
  v68 = v23;
  if (v23)
  {
    v24 = (unint64_t *)&v23->__shared_owners_;
    do
      v25 = __ldxr(v24);
    while (__stxr(v25 + 1, v24));
  }
  v26 = *a5;
  v27 = (std::__shared_weak_count *)a5[1];
  v66 = v26;
  if (v27)
  {
    v28 = (unint64_t *)&v27->__shared_owners_;
    do
      v29 = __ldxr(v28);
    while (__stxr(v29 + 1, v28));
  }
  *(_QWORD *)v14 = MEMORY[0x24BDC3D38] + 16;
  PersonalitySpecificImpl::PersonalitySpecificImpl();
  v74[0] = v20;
  v74[1] = v19;
  if (v19)
  {
    v30 = (unint64_t *)&v19->__shared_owners_;
    do
      v31 = __ldxr(v30);
    while (__stxr(v31 + 1, v30));
  }
  QMIDataContextDriverInterface::QMIDataContextDriverInterface((uint64_t *)(v14 + 24), (uint64_t *)&off_24D5ECD68, (uint64_t)v74);
  if (v19)
  {
    v32 = (unint64_t *)&v19->__shared_owners_;
    do
      v33 = __ldaxr(v32);
    while (__stlxr(v33 - 1, v32));
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }
  *(_QWORD *)(v14 + 48) = &unk_24D5C3E28;
  (*(void (**)(uint64_t))(*(_QWORD *)(v66 + 8) + 48))(v66 + 8);
  DataContextName = (const char *)DataUtils::getDataContextName();
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v73, (const char *)*MEMORY[0x24BDC3E90], DataContextName);
  *(_QWORD *)(v14 + 56) = 0;
  *(_QWORD *)(v14 + 64) = 0;
  *(_QWORD *)(v14 + 72) = v18;
  if (v18)
    dispatch_retain(v18);
  *(_QWORD *)(v14 + 80) = 0;
  ctu::OsLogLogger::OsLogLogger();
  ctu::OsLogLogger::OsLogLogger();
  MEMORY[0x2199FDF6C](&v72);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v73);
  *(_QWORD *)v14 = &off_24D5EC640;
  *(_QWORD *)(v14 + 24) = &unk_24D5EC9C8;
  *(_QWORD *)(v14 + 48) = &unk_24D5ECB80;
  std::string::basic_string[abi:ne180100]<0>(&v72, "DATA");
  v35 = std::string::append(&v72, ".", 1uLL);
  v36 = *(_OWORD *)&v35->__r_.__value_.__l.__data_;
  v73.__r_.__value_.__r.__words[2] = v35->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v73.__r_.__value_.__l.__data_ = v36;
  v35->__r_.__value_.__l.__size_ = 0;
  v35->__r_.__value_.__r.__words[2] = 0;
  v35->__r_.__value_.__r.__words[0] = 0;
  (*(void (**)(uint64_t))(*(_QWORD *)(v66 + 8) + 48))(v66 + 8);
  v37 = (const char *)DataUtils::getDataContextName();
  v38 = strlen(v37);
  v39 = std::string::append(&v73, v37, v38);
  v40 = *(_OWORD *)&v39->__r_.__value_.__l.__data_;
  *(_QWORD *)(v14 + 112) = *((_QWORD *)&v39->__r_.__value_.__l + 2);
  *(_OWORD *)(v14 + 96) = v40;
  v39->__r_.__value_.__l.__size_ = 0;
  v39->__r_.__value_.__r.__words[2] = 0;
  v39->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v73.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v73.__r_.__value_.__l.__data_);
  if (SHIBYTE(v72.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v72.__r_.__value_.__l.__data_);
  *(_QWORD *)(v14 + 120) = v70;
  *(_QWORD *)(v14 + 128) = v71;
  if (v71)
  {
    v41 = (unint64_t *)&v71->__shared_owners_;
    do
      v42 = __ldxr(v41);
    while (__stxr(v42 + 1, v41));
  }
  (*(void (**)(uint64_t))(*(_QWORD *)v20 + 480))(v20);
  *(_OWORD *)(v14 + 168) = 0u;
  *(_OWORD *)(v14 + 152) = 0u;
  *(_QWORD *)(v14 + 184) = v67;
  *(_QWORD *)(v14 + 192) = v68;
  if (v68)
  {
    p_shared_weak_owners = (unint64_t *)&v68->__shared_weak_owners_;
    do
      v44 = __ldxr(p_shared_weak_owners);
    while (__stxr(v44 + 1, p_shared_weak_owners));
  }
  *(_QWORD *)(v14 + 200) = v66;
  *(_QWORD *)(v14 + 208) = v27;
  if (v27)
  {
    v45 = (unint64_t *)&v27->__shared_weak_owners_;
    do
      v46 = __ldxr(v45);
    while (__stxr(v46 + 1, v45));
  }
  *(_QWORD *)(v14 + 216) = MEMORY[0x24BDC3D28] + 16;
  *(_QWORD *)(v14 + 376) = 0;
  *(_DWORD *)(v14 + 384) = 0;
  *(_OWORD *)(v14 + 224) = 0u;
  *(_OWORD *)(v14 + 240) = 0u;
  *(_OWORD *)(v14 + 256) = 0u;
  *(_OWORD *)(v14 + 272) = 0u;
  *(_OWORD *)(v14 + 288) = 0u;
  *(_OWORD *)(v14 + 304) = 0u;
  *(_OWORD *)(v14 + 320) = 0u;
  *(_OWORD *)(v14 + 336) = 0u;
  *(_OWORD *)(v14 + 352) = 0u;
  *(_DWORD *)(v14 + 368) = 0;
  *(_BYTE *)(v14 + 392) = 0;
  *a7 = v14;
  a7[1] = 0;
  v47 = (std::__shared_weak_count *)operator new();
  v47->__shared_owners_ = 0;
  v48 = (unint64_t *)&v47->__shared_owners_;
  v47->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5ED380;
  v47->__shared_weak_owners_ = 0;
  v47[1].__vftable = (std::__shared_weak_count_vtbl *)v14;
  a7[1] = (uint64_t)v47;
  v49 = *(std::__shared_weak_count **)(v14 + 64);
  if (v49)
  {
    if (v49->__shared_owners_ != -1)
      goto LABEL_51;
    do
      v50 = __ldxr(v48);
    while (__stxr(v50 + 1, v48));
    v51 = (unint64_t *)&v47->__shared_weak_owners_;
    do
      v52 = __ldxr(v51);
    while (__stxr(v52 + 1, v51));
    *(_QWORD *)(v14 + 56) = v14;
    *(_QWORD *)(v14 + 64) = v47;
    std::__shared_weak_count::__release_weak(v49);
  }
  else
  {
    do
      v53 = __ldxr(v48);
    while (__stxr(v53 + 1, v48));
    v54 = (unint64_t *)&v47->__shared_weak_owners_;
    do
      v55 = __ldxr(v54);
    while (__stxr(v55 + 1, v54));
    *(_QWORD *)(v14 + 56) = v14;
    *(_QWORD *)(v14 + 64) = v47;
  }
  do
    v56 = __ldaxr(v48);
  while (__stlxr(v56 - 1, v48));
  if (!v56)
  {
    ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
    std::__shared_weak_count::__release_weak(v47);
  }
LABEL_51:
  if (v27)
  {
    v57 = (unint64_t *)&v27->__shared_owners_;
    do
      v58 = __ldaxr(v57);
    while (__stlxr(v58 - 1, v57));
    if (!v58)
    {
      ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
      std::__shared_weak_count::__release_weak(v27);
    }
  }
  if (v68)
  {
    v59 = (unint64_t *)&v68->__shared_owners_;
    do
      v60 = __ldaxr(v59);
    while (__stlxr(v60 - 1, v59));
    if (!v60)
    {
      ((void (*)(std::__shared_weak_count *))v68->__on_zero_shared)(v68);
      std::__shared_weak_count::__release_weak(v68);
    }
  }
  if (v69)
  {
    v61 = (unint64_t *)&v69->__shared_owners_;
    do
      v62 = __ldaxr(v61);
    while (__stlxr(v62 - 1, v61));
    if (!v62)
    {
      ((void (*)(std::__shared_weak_count *))v69->__on_zero_shared)(v69);
      std::__shared_weak_count::__release_weak(v69);
    }
  }
  if (v18)
    dispatch_release(v18);
  if (v71)
  {
    v63 = (unint64_t *)&v71->__shared_owners_;
    do
      v64 = __ldaxr(v63);
    while (__stlxr(v64 - 1, v63));
    if (!v64)
    {
      ((void (*)(std::__shared_weak_count *))v71->__on_zero_shared)(v71);
      std::__shared_weak_count::__release_weak(v71);
    }
  }
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)*a7 + 824))(*a7, a6);
}

void sub_216A943B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, BBDataContextDriverInterface *a11, char a12, uint64_t a13, char a14, uint64_t a15, char a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  uint64_t v31;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v31);
  _Unwind_Resume(a1);
}

void QMIDataContextDriver::~QMIDataContextDriver(QMIDataContextDriver *this)
{
  BBDataContextDriverInterface *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;

  *(_QWORD *)this = &off_24D5EC640;
  *((_QWORD *)this + 3) = &unk_24D5EC9C8;
  v2 = (QMIDataContextDriver *)((char *)this + 24);
  *((_QWORD *)this + 6) = &unk_24D5ECB80;
  MEMORY[0x2199FD75C]((char *)this + 216);
  v3 = (std::__shared_weak_count *)*((_QWORD *)this + 26);
  if (v3)
    std::__shared_weak_count::__release_weak(v3);
  v4 = (std::__shared_weak_count *)*((_QWORD *)this + 24);
  if (v4)
    std::__shared_weak_count::__release_weak(v4);
  v5 = (std::__shared_weak_count *)*((_QWORD *)this + 22);
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)this + 152);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)this + 136);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)this + 120);
  if (*((char *)this + 119) < 0)
    operator delete(*((void **)this + 12));
  MEMORY[0x2199FDF6C]((char *)this + 88);
  ctu::SharedSynchronizable<QMIDataSystemDeterminationManager>::~SharedSynchronizable((_QWORD *)this + 7);
  BBDataContextDriverInterface::~BBDataContextDriverInterface(v2);
  PersonalitySpecificImpl::~PersonalitySpecificImpl(this);
}

{
  PersonalitySpecific *v1;

  QMIDataContextDriver::~QMIDataContextDriver(this);
  PersonalitySpecific::~PersonalitySpecific(v1);
}

{
  PersonalitySpecific *v1;

  QMIDataContextDriver::~QMIDataContextDriver(this);
  PersonalitySpecific::~PersonalitySpecific(v1);
  JUMPOUT(0x2199FEAC4);
}

void `non-virtual thunk to'QMIDataContextDriver::~QMIDataContextDriver(QMIDataContextDriver *this)
{
  PersonalitySpecific *v1;

  QMIDataContextDriver::~QMIDataContextDriver((QMIDataContextDriver *)((char *)this - 24));
  PersonalitySpecific::~PersonalitySpecific(v1);
}

{
  PersonalitySpecific *v1;

  QMIDataContextDriver::~QMIDataContextDriver((QMIDataContextDriver *)((char *)this - 48));
  PersonalitySpecific::~PersonalitySpecific(v1);
}

{
  QMIDataContextDriver::~QMIDataContextDriver((QMIDataContextDriver *)((char *)this - 24));
}

{
  QMIDataContextDriver::~QMIDataContextDriver((QMIDataContextDriver *)((char *)this - 48));
}

void QMIDataContextDriver::initialize(QMIDataContextDriver *this, uint64_t a2)
{
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  NSObject *v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  std::__shared_weak_count *v12;
  __int128 v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  std::__shared_weak_count *v29;
  unint64_t *v30;
  unint64_t v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  std::__shared_weak_count *v35;
  unint64_t *v36;
  unint64_t v37;
  std::__shared_weak_count *v38;
  uint64_t v39;
  unint64_t *v40;
  unint64_t v41;
  std::__shared_weak_count *v42;
  std::__shared_weak_count *v43;
  uint64_t v44;
  NSObject *v45;
  _QWORD *v46;
  _QWORD *v47;
  unint64_t *v48;
  unint64_t v49;
  unint64_t *v50;
  unint64_t v51;
  _QWORD *v52;
  unint64_t *v53;
  unint64_t v54;
  std::__shared_weak_count *v55;
  unint64_t *v56;
  unint64_t v57;
  std::__shared_weak_count *v58;
  unint64_t *v59;
  unint64_t v60;
  std::__shared_weak_count *v61;
  unint64_t *v62;
  unint64_t v63;
  std::__shared_weak_count *v64;
  unint64_t *v65;
  unint64_t v66;
  unint64_t *v67;
  unint64_t v68;
  unint64_t *v69;
  unint64_t v70;
  std::__shared_weak_count *v71;
  unint64_t *v72;
  unint64_t v73;
  std::__shared_weak_count *v74;
  unint64_t *v75;
  unint64_t v76;
  std::__shared_weak_count *v77;
  uint64_t v78;
  std::__shared_weak_count *v79;
  uint64_t v80;
  std::__shared_weak_count *v81;
  uint64_t v82;
  std::__shared_weak_count *v83;
  uint64_t v84;
  std::__shared_weak_count *v85;
  char *v86;
  std::__shared_weak_count *v87;
  uint64_t v88;
  std::__shared_weak_count *v89;
  dispatch_object_t object;
  uint64_t v91;
  std::__shared_weak_count *v92;
  NSObject *v93;
  uint64_t v94;
  std::__shared_weak_count *v95;
  uint64_t v96;
  std::__shared_weak_count *v97;
  __int128 v98;

  v4 = (std::__shared_weak_count *)*((_QWORD *)this + 16);
  v91 = *((_QWORD *)this + 15);
  v92 = v4;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  v7 = *((_QWORD *)this + 9);
  object = v7;
  if (v7)
    dispatch_retain(v7);
  v8 = (std::__shared_weak_count *)*((_QWORD *)this + 8);
  if (!v8 || (v9 = *((_QWORD *)this + 7), (v10 = std::__shared_weak_count::lock(v8)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v11 = v9 + 48;
  if (!v9)
    v11 = 0;
  v88 = v11;
  v89 = v10;
  v96 = 0;
  v97 = 0;
  v86 = 0;
  v87 = 0;
  v12 = (std::__shared_weak_count *)*((_QWORD *)this + 26);
  if (v12)
  {
    v87 = std::__shared_weak_count::lock(v12);
    if (v87)
      v86 = (char *)*((_QWORD *)this + 25);
  }
  BBDataContextDriverInterface::getObserver((QMIDataContextDriver *)((char *)this + 24));
  (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v94 + 480))(&v84);
  QMIDataContextIPAggregatorInterface::create(&v91, &object, &v88, &v86, &v84, a2, (uint64_t *)&v98);
  v13 = v98;
  v98 = 0uLL;
  v14 = (std::__shared_weak_count *)*((_QWORD *)this + 20);
  *(_OWORD *)((char *)this + 152) = v13;
  if (v14)
  {
    v15 = (unint64_t *)&v14->__shared_owners_;
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
  v17 = (std::__shared_weak_count *)*((_QWORD *)&v98 + 1);
  if (*((_QWORD *)&v98 + 1))
  {
    v18 = (unint64_t *)(*((_QWORD *)&v98 + 1) + 8);
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
  v20 = v85;
  if (v85)
  {
    v21 = (unint64_t *)&v85->__shared_owners_;
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
  v23 = v95;
  if (v95)
  {
    v24 = (unint64_t *)&v95->__shared_owners_;
    do
      v25 = __ldaxr(v24);
    while (__stlxr(v25 - 1, v24));
    if (!v25)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }
  v26 = v87;
  if (v87)
  {
    v27 = (unint64_t *)&v87->__shared_owners_;
    do
      v28 = __ldaxr(v27);
    while (__stlxr(v28 - 1, v27));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
      std::__shared_weak_count::__release_weak(v26);
    }
  }
  v29 = v89;
  if (v89)
  {
    v30 = (unint64_t *)&v89->__shared_owners_;
    do
      v31 = __ldaxr(v30);
    while (__stlxr(v31 - 1, v30));
    if (!v31)
    {
      ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
      std::__shared_weak_count::__release_weak(v29);
    }
  }
  v32 = v97;
  if (v97)
  {
    v33 = (unint64_t *)&v97->__shared_owners_;
    do
      v34 = __ldaxr(v33);
    while (__stlxr(v34 - 1, v33));
    if (!v34)
    {
      ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
      std::__shared_weak_count::__release_weak(v32);
    }
  }
  if (object)
    dispatch_release(object);
  v35 = v92;
  if (v92)
  {
    v36 = (unint64_t *)&v92->__shared_owners_;
    do
      v37 = __ldaxr(v36);
    while (__stlxr(v37 - 1, v36));
    if (!v37)
    {
      ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
      std::__shared_weak_count::__release_weak(v35);
    }
  }
  v39 = *((_QWORD *)this + 15);
  v38 = (std::__shared_weak_count *)*((_QWORD *)this + 16);
  v82 = v39;
  v83 = v38;
  if (v38)
  {
    v40 = (unint64_t *)&v38->__shared_owners_;
    do
      v41 = __ldxr(v40);
    while (__stxr(v41 + 1, v40));
  }
  (*(void (**)(uint64_t *__return_ptr, QMIDataContextDriver *))(*(_QWORD *)this + 16))(&v80, this);
  BBDataContextDriverInterface::getObserver((QMIDataContextDriver *)((char *)this + 24));
  v77 = 0;
  v42 = (std::__shared_weak_count *)*((_QWORD *)this + 26);
  if (v42)
  {
    v43 = std::__shared_weak_count::lock(v42);
    v77 = v43;
    if (v43)
    {
      v44 = *((_QWORD *)this + 25);
      goto LABEL_63;
    }
  }
  else
  {
    v43 = 0;
  }
  v44 = 0;
LABEL_63:
  v45 = *((_QWORD *)this + 9);
  if (v45)
    dispatch_retain(*((dispatch_object_t *)this + 9));
  v46 = operator new(0x98uLL);
  v47 = v46;
  v46[1] = 0;
  v46[2] = 0;
  *v46 = &off_24D5ED330;
  *(_QWORD *)&v98 = v39;
  *((_QWORD *)&v98 + 1) = v38;
  if (v38)
  {
    v48 = (unint64_t *)&v38->__shared_owners_;
    do
      v49 = __ldxr(v48);
    while (__stxr(v49 + 1, v48));
  }
  v96 = v78;
  v97 = v79;
  if (v79)
  {
    v50 = (unint64_t *)&v79->__shared_owners_;
    do
      v51 = __ldxr(v50);
    while (__stxr(v51 + 1, v50));
  }
  v52 = v46 + 3;
  v94 = v44;
  v95 = v43;
  if (v43)
  {
    v53 = (unint64_t *)&v43->__shared_owners_;
    do
      v54 = __ldxr(v53);
    while (__stxr(v54 + 1, v53));
  }
  v93 = v45;
  if (v45)
    dispatch_retain(v45);
  QMIDataQOSHelper::QMIDataQOSHelper((uint64_t)(v47 + 3), &v98, (uint64_t)&v80, &v96, &v94, &v93);
  if (v93)
    dispatch_release(v93);
  v55 = v95;
  if (v95)
  {
    v56 = (unint64_t *)&v95->__shared_owners_;
    do
      v57 = __ldaxr(v56);
    while (__stlxr(v57 - 1, v56));
    if (!v57)
    {
      ((void (*)(std::__shared_weak_count *))v55->__on_zero_shared)(v55);
      std::__shared_weak_count::__release_weak(v55);
    }
  }
  v58 = v97;
  if (v97)
  {
    v59 = (unint64_t *)&v97->__shared_owners_;
    do
      v60 = __ldaxr(v59);
    while (__stlxr(v60 - 1, v59));
    if (!v60)
    {
      ((void (*)(std::__shared_weak_count *))v58->__on_zero_shared)(v58);
      std::__shared_weak_count::__release_weak(v58);
    }
  }
  v61 = (std::__shared_weak_count *)*((_QWORD *)&v98 + 1);
  if (*((_QWORD *)&v98 + 1))
  {
    v62 = (unint64_t *)(*((_QWORD *)&v98 + 1) + 8);
    do
      v63 = __ldaxr(v62);
    while (__stlxr(v63 - 1, v62));
    if (!v63)
    {
      ((void (*)(std::__shared_weak_count *))v61->__on_zero_shared)(v61);
      std::__shared_weak_count::__release_weak(v61);
    }
  }
  v64 = (std::__shared_weak_count *)*((_QWORD *)this + 22);
  *((_QWORD *)this + 21) = v52;
  *((_QWORD *)this + 22) = v47;
  if (v64)
  {
    v65 = (unint64_t *)&v64->__shared_owners_;
    do
      v66 = __ldaxr(v65);
    while (__stlxr(v66 - 1, v65));
    if (!v66)
    {
      ((void (*)(std::__shared_weak_count *))v64->__on_zero_shared)(v64);
      std::__shared_weak_count::__release_weak(v64);
    }
  }
  if (v45)
    dispatch_release(v45);
  if (v77)
  {
    v67 = (unint64_t *)&v77->__shared_owners_;
    do
      v68 = __ldaxr(v67);
    while (__stlxr(v68 - 1, v67));
    if (!v68)
    {
      ((void (*)(std::__shared_weak_count *))v77->__on_zero_shared)(v77);
      std::__shared_weak_count::__release_weak(v77);
    }
  }
  if (v79)
  {
    v69 = (unint64_t *)&v79->__shared_owners_;
    do
      v70 = __ldaxr(v69);
    while (__stlxr(v70 - 1, v69));
    if (!v70)
    {
      ((void (*)())v79->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v79);
    }
  }
  v71 = v81;
  if (v81)
  {
    v72 = (unint64_t *)&v81->__shared_owners_;
    do
      v73 = __ldaxr(v72);
    while (__stlxr(v73 - 1, v72));
    if (!v73)
    {
      ((void (*)(std::__shared_weak_count *))v71->__on_zero_shared)(v71);
      std::__shared_weak_count::__release_weak(v71);
    }
  }
  v74 = v83;
  if (v83)
  {
    v75 = (unint64_t *)&v83->__shared_owners_;
    do
      v76 = __ldaxr(v75);
    while (__stlxr(v76 - 1, v75));
    if (!v76)
    {
      ((void (*)(std::__shared_weak_count *))v74->__on_zero_shared)(v74);
      std::__shared_weak_count::__release_weak(v74);
    }
  }
}

void sub_216A94C6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13, uint64_t a14, char a15, uint64_t a16, char a17, uint64_t a18, char a19, uint64_t a20,char a21,uint64_t a22,dispatch_object_t object,char a24)
{
  NSObject *v24;
  std::__shared_weak_count *v25;
  uint64_t v26;
  NSObject *v28;
  void *v29;

  v28 = *(NSObject **)(v26 - 120);
  if (v28)
    dispatch_release(v28);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v26 - 112);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v26 - 96);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v26 - 80);
  std::__shared_weak_count::~__shared_weak_count(v25);
  operator delete(v29);
  if (v24)
    dispatch_release(v24);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a15);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'QMIDataContextDriver::initialize(QMIDataContextDriver *this, uint64_t a2)
{
  QMIDataContextDriver::initialize((QMIDataContextDriver *)((char *)this - 24), a2);
}

void QMIDataContextDriver::resetBaseband(uint64_t a1, uint64_t a2)
{
  unint64_t *p_shared_owners;
  unint64_t v4;
  uint64_t v5;
  std::__shared_weak_count *v6;

  BBDataContextDriverInterface::getObserver((BBDataContextDriverInterface *)(a1 + 24));
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v5 + 584))(v5, a2);
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)())v6->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

void sub_216A94DC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'QMIDataContextDriver::resetBaseband(uint64_t a1, uint64_t a2)
{
  QMIDataContextDriver::resetBaseband(a1 - 48, a2);
}

void QMIDataContextDriver::updateResetBasebandTimer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t *p_shared_owners;
  unint64_t v8;
  uint64_t v9;
  std::__shared_weak_count *v10;

  BBDataContextDriverInterface::getObserver((BBDataContextDriverInterface *)(a1 + 24));
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v9 + 592))(v9, a2, a3, a4);
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)())v10->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v10);
    }
  }
}

void sub_216A94E78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'QMIDataContextDriver::updateResetBasebandTimer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  QMIDataContextDriver::updateResetBasebandTimer(a1 - 48, a2, a3, a4);
}

uint64_t QMIDataContextDriver::bootstrapBBCtxCmdDriver(QMIDataContextDriver *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 19);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 16))(result);
  return result;
}

uint64_t `non-virtual thunk to'QMIDataContextDriver::bootstrapBBCtxCmdDriver(QMIDataContextDriver *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 16);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 16))(result);
  return result;
}

uint64_t QMIDataContextDriver::startBBCtxCmdDriver(QMIDataContextDriver *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 19);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 24))(result);
  return result;
}

uint64_t `non-virtual thunk to'QMIDataContextDriver::startBBCtxCmdDriver(QMIDataContextDriver *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 16);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 24))(result);
  return result;
}

uint64_t QMIDataContextDriver::stopBBCtxCmdDriver(QMIDataContextDriver *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 19);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 32))(result);
  return result;
}

uint64_t `non-virtual thunk to'QMIDataContextDriver::stopBBCtxCmdDriver(QMIDataContextDriver *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 16);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 32))(result);
  return result;
}

uint64_t QMIDataContextDriver::getName(QMIDataContextDriver *this)
{
  uint64_t result;

  result = (uint64_t)this + 96;
  if (*((char *)this + 119) < 0)
    return *(_QWORD *)result;
  return result;
}

uint64_t `non-virtual thunk to'QMIDataContextDriver::getName(QMIDataContextDriver *this)
{
  uint64_t result;

  result = (uint64_t)this + 48;
  if (*((char *)this + 71) < 0)
    return *(_QWORD *)result;
  return result;
}

uint64_t QMIDataContextDriver::getIPAddress(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 152) + 48))(*(_QWORD *)(a1 + 152));
}

uint64_t `non-virtual thunk to'QMIDataContextDriver::getIPAddress(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 128) + 48))(*(_QWORD *)(a1 + 128));
}

uint64_t QMIDataContextDriver::getOriginalIPv6Address(QMIDataContextDriver *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 19) + 56))(*((_QWORD *)this + 19));
}

uint64_t `non-virtual thunk to'QMIDataContextDriver::getOriginalIPv6Address(QMIDataContextDriver *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 16) + 56))(*((_QWORD *)this + 16));
}

uint64_t QMIDataContextDriver::getLinkLocalIPAddress(QMIDataContextDriver *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 19) + 64))(*((_QWORD *)this + 19));
}

uint64_t `non-virtual thunk to'QMIDataContextDriver::getLinkLocalIPAddress(QMIDataContextDriver *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 16) + 64))(*((_QWORD *)this + 16));
}

uint64_t QMIDataContextDriver::getDNSAddresses(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 152) + 72))(*(_QWORD *)(a1 + 152));
}

uint64_t `non-virtual thunk to'QMIDataContextDriver::getDNSAddresses(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 128) + 72))(*(_QWORD *)(a1 + 128));
}

uint64_t QMIDataContextDriver::transitionalStateMask(QMIDataContextDriver *this)
{
  unsigned int v2;
  BBDataContextDriverInterface *v3;
  int v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  int v7;
  unint64_t *v8;
  unint64_t v9;
  unsigned int v10;
  uint64_t v12;
  std::__shared_weak_count *v13;

  v2 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 19) + 88))(*((_QWORD *)this + 19));
  v3 = (QMIDataContextDriver *)((char *)this + 24);
  BBDataContextDriverInterface::getObserver((QMIDataContextDriver *)((char *)this + 24));
  v4 = (*(uint64_t (**)())(*(_QWORD *)v12 + 496))();
  if (v13)
  {
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)())v13->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  BBDataContextDriverInterface::getObserver(v3);
  v7 = (*(uint64_t (**)())(*(_QWORD *)v12 + 504))();
  if (v13)
  {
    v8 = (unint64_t *)&v13->__shared_owners_;
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)())v13->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  v10 = v2 | 2;
  if (!v4)
    v10 = v2;
  if (v7)
    return v10 | 4;
  else
    return v10;
}

void sub_216A950E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t `non-virtual thunk to'QMIDataContextDriver::transitionalStateMask(QMIDataContextDriver *this)
{
  return QMIDataContextDriver::transitionalStateMask((QMIDataContextDriver *)((char *)this - 24));
}

uint64_t QMIDataContextDriver::getPDPMetricInfo(QMIDataContextDriver *this)
{
  return (uint64_t)this + 216;
}

uint64_t `non-virtual thunk to'QMIDataContextDriver::getPDPMetricInfo(QMIDataContextDriver *this)
{
  return (uint64_t)this + 192;
}

uint64_t QMIDataContextDriver::getPDPMetricInfo(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 152) + 80))(*(_QWORD *)(a1 + 152));
}

uint64_t `non-virtual thunk to'QMIDataContextDriver::getPDPMetricInfo(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 128) + 80))(*(_QWORD *)(a1 + 128));
}

uint64_t QMIDataContextDriver::getDataContextState(uint64_t a1, int a2)
{
  uint64_t v4;
  BBDataContextDriverInterface *v5;
  _BOOL4 v6;
  int v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  uint64_t v13;
  std::__shared_weak_count *v14;
  uint64_t v15;
  std::__shared_weak_count *v16;

  v4 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 152) + 96))(*(_QWORD *)(a1 + 152));
  if ((int)v4 <= 3)
  {
    v5 = (BBDataContextDriverInterface *)(a1 + 24);
    BBDataContextDriverInterface::getObserver(v5);
    if (((*(uint64_t (**)())(*(_QWORD *)v15 + 336))() & 1) != 0)
    {
      v6 = a2 == 3;
    }
    else
    {
      BBDataContextDriverInterface::getObserver(v5);
      v7 = (*(uint64_t (**)())(*(_QWORD *)v13 + 360))();
      if (a2 == 3)
        v6 = v7;
      else
        v6 = 0;
      if (v14)
      {
        p_shared_owners = (unint64_t *)&v14->__shared_owners_;
        do
          v9 = __ldaxr(p_shared_owners);
        while (__stlxr(v9 - 1, p_shared_owners));
        if (!v9)
        {
          ((void (*)())v14->__on_zero_shared)();
          std::__shared_weak_count::__release_weak(v14);
        }
      }
    }
    if (v16)
    {
      v10 = (unint64_t *)&v16->__shared_owners_;
      do
        v11 = __ldaxr(v10);
      while (__stlxr(v11 - 1, v10));
      if (!v11)
      {
        ((void (*)())v16->__on_zero_shared)();
        std::__shared_weak_count::__release_weak(v16);
      }
    }
    if (v6)
      return 4;
    else
      return v4;
  }
  return v4;
}

void sub_216A95258(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

uint64_t `non-virtual thunk to'QMIDataContextDriver::getDataContextState(uint64_t a1, int a2)
{
  return QMIDataContextDriver::getDataContextState(a1 - 24, a2);
}

uint64_t QMIDataContextDriver::getDataContextStateRaw(QMIDataContextDriver *this)
{
  return (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)this + 19) + 96))(*((_QWORD *)this + 19), 3);
}

uint64_t `non-virtual thunk to'QMIDataContextDriver::getDataContextStateRaw(QMIDataContextDriver *this)
{
  return (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)this + 16) + 96))(*((_QWORD *)this + 16), 3);
}

uint64_t QMIDataContextDriver::reportHandoverWwanPduSessionId(QMIDataContextDriver *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 19) + 224))(*((_QWORD *)this + 19));
}

uint64_t `non-virtual thunk to'QMIDataContextDriver::reportHandoverWwanPduSessionId(QMIDataContextDriver *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 16) + 224))(*((_QWORD *)this + 16));
}

uint64_t QMIDataContextDriver::updateAnbrFilters(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  _BYTE v6[168];
  _BYTE v7[168];

  v4 = *(_QWORD *)(a1 + 152);
  std::__optional_copy_base<DataIPFilter,false>::__optional_copy_base[abi:ne180100](v7, a2);
  std::__optional_copy_base<DataIPFilter,false>::__optional_copy_base[abi:ne180100](v6, a3);
  (*(void (**)(uint64_t, _BYTE *, _BYTE *))(*(_QWORD *)v4 + 232))(v4, v7, v6);
  std::__optional_destruct_base<DataIPFilter,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)v6);
  return std::__optional_destruct_base<DataIPFilter,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)v7);
}

void sub_216A9533C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
  std::__optional_destruct_base<DataIPFilter,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&a9);
  std::__optional_destruct_base<DataIPFilter,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&a30);
  _Unwind_Resume(a1);
}

uint64_t `non-virtual thunk to'QMIDataContextDriver::updateAnbrFilters(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return QMIDataContextDriver::updateAnbrFilters(a1 - 24, a2, a3);
}

uint64_t QMIDataContextDriver::getAnbr(QMIDataContextDriver *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 19) + 240))(*((_QWORD *)this + 19));
}

uint64_t `non-virtual thunk to'QMIDataContextDriver::getAnbr(QMIDataContextDriver *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 16) + 240))(*((_QWORD *)this + 16));
}

_QWORD *QMIDataContextDriver::getAnbrActivationState(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD *result;
  uint64_t v4;
  _BYTE v5[24];
  _BYTE *v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 152);
  std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100]((uint64_t)v5, a2);
  (*(void (**)(uint64_t, _BYTE *))(*(_QWORD *)v2 + 248))(v2, v5);
  result = v6;
  if (v6 == v5)
  {
    v4 = 4;
    result = v5;
  }
  else
  {
    if (!v6)
      return result;
    v4 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v4))();
}

void sub_216A95424(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v13;
  char *v15;
  uint64_t v16;

  v15 = a13;
  if (a13 == v13)
  {
    v16 = 4;
    v15 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v16 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v15 + 8 * v16))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

_QWORD *`non-virtual thunk to'QMIDataContextDriver::getAnbrActivationState(uint64_t a1, uint64_t a2)
{
  return QMIDataContextDriver::getAnbrActivationState(a1 - 24, a2);
}

_QWORD *QMIDataContextDriver::queryAnbrBitrate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  _QWORD *result;
  uint64_t v8;
  _BYTE v9[24];
  _BYTE *v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v6 = *(_QWORD *)(a1 + 152);
  std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100]((uint64_t)v9, a4);
  (*(void (**)(uint64_t, uint64_t, uint64_t, _BYTE *))(*(_QWORD *)v6 + 256))(v6, a2, a3, v9);
  result = v10;
  if (v10 == v9)
  {
    v8 = 4;
    result = v9;
  }
  else
  {
    if (!v10)
      return result;
    v8 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v8))();
}

void sub_216A95524(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v13;
  char *v15;
  uint64_t v16;

  v15 = a13;
  if (a13 == v13)
  {
    v16 = 4;
    v15 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v16 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v15 + 8 * v16))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

_QWORD *`non-virtual thunk to'QMIDataContextDriver::queryAnbrBitrate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return QMIDataContextDriver::queryAnbrBitrate(a1 - 24, a2, a3, a4);
}

uint64_t QMIDataContextDriver::setCoalescing(uint64_t a1, unsigned __int16 a2)
{
  return (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 152) + 264))(*(_QWORD *)(a1 + 152), a2);
}

uint64_t `non-virtual thunk to'QMIDataContextDriver::setCoalescing(uint64_t a1, unsigned __int16 a2)
{
  return (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 128) + 264))(*(_QWORD *)(a1 + 128), a2);
}

uint64_t QMIDataContextDriver::isActivating(QMIDataContextDriver *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 19) + 104))(*((_QWORD *)this + 19));
}

uint64_t `non-virtual thunk to'QMIDataContextDriver::isActivating(QMIDataContextDriver *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 16) + 104))(*((_QWORD *)this + 16));
}

uint64_t QMIDataContextDriver::releaseDataContextClient(QMIDataContextDriver *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 19) + 288))(*((_QWORD *)this + 19));
}

uint64_t `non-virtual thunk to'QMIDataContextDriver::releaseDataContextClient(QMIDataContextDriver *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 16) + 288))(*((_QWORD *)this + 16));
}

unint64_t QMIDataContextDriver::activateDataContext(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v3;
  unsigned int v4;
  char *v9;
  char *v10;
  int v11;
  NSObject *v12;
  BBDataContextDriverInterface *v13;
  __int128 v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  std::string::size_type v19;
  std::__shared_weak_count *v20;
  unint64_t *p_shared_owners;
  unint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  std::__shared_weak_count *size;
  unint64_t *v27;
  unint64_t v28;
  int v29;
  NSObject *v30;
  _BOOL4 v31;
  _QWORD *v32;
  uint64_t v33;
  uint64_t v34;
  const char *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  const char *v40;
  NSObject *v41;
  uint32_t v42;
  NSObject *v43;
  std::string::size_type v44;
  char v45;
  std::__shared_weak_count *v46;
  unint64_t *v47;
  unint64_t v48;
  NSObject *v49;
  _BOOL4 v50;
  uint64_t v51;
  char v52;
  char v53;
  std::__shared_weak_count *v54;
  unint64_t *v55;
  unint64_t v56;
  _QWORD *v57;
  uint64_t v58;
  uint64_t v59;
  const char *v60;
  const char *v61;
  uint64_t v62;
  std::__shared_weak_count *v63;
  unint64_t *v64;
  unint64_t v65;
  std::__shared_weak_count *v66;
  unint64_t *v67;
  unint64_t v68;
  std::__shared_weak_count *v69;
  unint64_t *v70;
  unint64_t v71;
  char v72;
  std::string::size_type v73;
  unsigned int v74;
  std::__shared_weak_count *v75;
  unint64_t *v76;
  unint64_t v77;
  std::__shared_weak_count *v78;
  unint64_t *v79;
  unint64_t v80;
  std::string::size_type v81;
  unint64_t *v82;
  unint64_t v83;
  std::__shared_weak_count *v84;
  unint64_t *v85;
  unint64_t v86;
  std::__shared_weak_count *v87;
  unint64_t *v88;
  unint64_t v89;
  std::__shared_weak_count *v90;
  unint64_t *v91;
  unint64_t v92;
  NSObject *v93;
  const std::string::value_type **v94;
  std::string::size_type v95;
  void **v96;
  int v97;
  void *v98[2];
  char v99;
  void *v100[2];
  char v101;
  unsigned int v102;
  int v103;
  const char *v104;
  void *v105;
  int v106;
  char v107;
  uint64_t v108;
  uint64_t v109;
  std::__shared_weak_count *v110;
  void *v111;
  void *v112;
  uint64_t v113;
  _OWORD v114[3];
  std::__shared_weak_count *v115;
  void *__p;
  void *v117;
  uint64_t v118;
  uint64_t v119;
  std::__shared_weak_count *v120;
  uint64_t v121;
  std::__shared_weak_count *v122;
  __int128 v123;
  __int128 v124;
  __int128 v125;
  std::__shared_weak_count *v126;
  std::string buf;
  const char *v128;
  __int16 v129;
  const char *v130;
  __int16 v131;
  uint64_t v132;
  __int16 v133;
  const char *v134;
  __int16 v135;
  uint64_t v136;
  __int16 v137;
  uint64_t v138;
  __int16 v139;
  uint64_t v140;
  __int16 v141;
  uint64_t v142;
  __int16 v143;
  uint64_t v144;
  uint64_t v145;

  v145 = *MEMORY[0x24BDAC8D0];
  if (*(_BYTE *)(a1 + 392))
  {
    v3 = -8;
LABEL_3:
    v4 = -1;
    return v4 | ((unint64_t)v3 << 32);
  }
  v9 = *(char **)(a2 + 8);
  v10 = *(char **)(a2 + 16);
  v97 = *(unsigned __int8 *)(a2 + 24);
  v11 = *(unsigned __int8 *)(a2 + 72);
  v12 = *(NSObject **)(a1 + 88);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf.__r_.__value_.__l.__data_) = 136316162;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"activateDataContext";
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v9;
    HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
    v128 = v10;
    v129 = 2080;
    v130 = (const char *)asStringBool();
    v131 = 2080;
    v132 = asStringBool();
    _os_log_impl(&dword_216897000, v12, OS_LOG_TYPE_DEFAULT, "#I %s: reason=%s, processName=%s, handover=%s, networkDisconnect = %s", (uint8_t *)&buf, 0x34u);
  }
  v13 = (BBDataContextDriverInterface *)(a1 + 24);
  BBDataContextDriverInterface::getObserver((BBDataContextDriverInterface *)(a1 + 24));
  (*(void (**)(std::string *__return_ptr))(*(_QWORD *)v123 + 392))(&buf);
  v14 = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
  if (buf.__r_.__value_.__l.__size_)
  {
    v15 = (unint64_t *)(buf.__r_.__value_.__l.__size_ + 8);
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      (*(void (**)(_QWORD))(**((_QWORD **)&v14 + 1) + 16))(*((_QWORD *)&v14 + 1));
      std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v14 + 1));
    }
  }
  if (!*((_QWORD *)&v123 + 1))
    goto LABEL_16;
  v17 = (unint64_t *)(*((_QWORD *)&v123 + 1) + 8);
  do
    v18 = __ldaxr(v17);
  while (__stlxr(v18 - 1, v17));
  if (v18)
  {
LABEL_16:
    if ((_QWORD)v14)
      goto LABEL_17;
LABEL_41:
    v43 = *(NSObject **)(a1 + 88);
    if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"activateDataContext";
      _os_log_impl(&dword_216897000, v43, OS_LOG_TYPE_DEFAULT, "#I %s: DataContext should be grabbed first", (uint8_t *)&buf, 0xCu);
    }
    if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315650;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"DataContext should be grabbed first";
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"/Library/Caches/com.apple.xbs/Sources/CoreTelephony/CommCenter/CommCenterCommandDrivers/Data/QMI/Context/QMIDataContextDriver.cpp";
      HIWORD(buf.__r_.__value_.__r.__words[2]) = 1024;
      LODWORD(v128) = 213;
      _os_log_error_impl(&dword_216897000, MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR, "\n**********\n   ASSERT false\n %s\n at %s:%d\n**********", (uint8_t *)&buf, 0x1Cu);
    }
    __TUAssertTrigger();
    v3 = -9;
    goto LABEL_3;
  }
  (*(void (**)(_QWORD))(**((_QWORD **)&v123 + 1) + 16))(*((_QWORD *)&v123 + 1));
  std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v123 + 1));
  if (!(_QWORD)v14)
    goto LABEL_41;
LABEL_17:
  v126 = 0;
  v124 = 0u;
  v125 = 0u;
  v123 = 0u;
  BBDataContextDriverInterface::getObserver((BBDataContextDriverInterface *)(a1 + 24));
  v19 = buf.__r_.__value_.__r.__words[0];
  BBDataContextDriverInterface::getObserver((BBDataContextDriverInterface *)(a1 + 24));
  (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v119 + 392))(&v121);
  __p = 0;
  v117 = 0;
  v118 = 0;
  std::vector<DataConnectionTraits>::__init_with_size[abi:ne180100]<DataConnectionTraits*,DataConnectionTraits*>(&__p, *(const void **)a3, *(_QWORD *)(a3 + 8), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a3 + 8) - *(_QWORD *)a3) >> 2));
  (*(void (**)(__int128 *__return_ptr, std::string::size_type, uint64_t *, void **))(*(_QWORD *)v19 + 376))(&v123, v19, &v121, &__p);
  if (__p)
  {
    v117 = __p;
    operator delete(__p);
  }
  v20 = v122;
  if (v122)
  {
    p_shared_owners = (unint64_t *)&v122->__shared_owners_;
    do
      v22 = __ldaxr(p_shared_owners);
    while (__stlxr(v22 - 1, p_shared_owners));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
  v23 = v120;
  if (v120)
  {
    v24 = (unint64_t *)&v120->__shared_owners_;
    do
      v25 = __ldaxr(v24);
    while (__stlxr(v25 - 1, v24));
    if (!v25)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }
  size = (std::__shared_weak_count *)buf.__r_.__value_.__l.__size_;
  if (buf.__r_.__value_.__l.__size_)
  {
    v27 = (unint64_t *)(buf.__r_.__value_.__l.__size_ + 8);
    do
      v28 = __ldaxr(v27);
    while (__stlxr(v28 - 1, v27));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))size->__on_zero_shared)(size);
      std::__shared_weak_count::__release_weak(size);
    }
  }
  if ((_DWORD)v123)
  {
    v29 = BYTE12(v124);
    v30 = *(NSObject **)(a1 + 88);
    v31 = os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT);
    if (v29)
    {
      if (!v31)
        goto LABEL_102;
      v32 = (_QWORD *)(a1 + 96);
      if (*(char *)(a1 + 119) < 0)
        v32 = (_QWORD *)*v32;
      v33 = CSIErrorString();
      v35 = (const char *)*((_QWORD *)&v123 + 1);
      v34 = v124;
      v36 = asStringBool();
      v37 = asStringBool();
      v38 = asStringBool();
      v39 = asStringBool();
      LODWORD(buf.__r_.__value_.__l.__data_) = 136317698;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v32;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"activateDataContext";
      HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
      v128 = "DataContext activation is not possible";
      v129 = 2080;
      v130 = "f";
      v131 = 2080;
      v132 = v33;
      v133 = 2080;
      v134 = v35;
      v135 = 2080;
      v136 = v34;
      v137 = 2080;
      v138 = v36;
      v139 = 2080;
      v140 = v37;
      v141 = 2080;
      v142 = v38;
      v143 = 2080;
      v144 = v39;
      v40 = "#I DATA.%s: %s: %s: %s(%s{%s %s [ allowed=%s blocked=%s netAvailable=%s home=%s ]})";
      v41 = v30;
      v42 = 112;
      goto LABEL_101;
    }
    if (!v31)
      goto LABEL_102;
    v57 = (_QWORD *)(a1 + 96);
    if (*(char *)(a1 + 119) < 0)
      v57 = (_QWORD *)*v57;
    v58 = CSIErrorString();
    if (*((_QWORD *)&v123 + 1))
    {
      v59 = v124;
      if (**((_BYTE **)&v123 + 1))
      {
        v60 = "}";
        v61 = "{";
LABEL_100:
        LODWORD(buf.__r_.__value_.__l.__data_) = 136317186;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v57;
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"activateDataContext";
        HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
        v128 = "DataContext activation is not possible";
        v129 = 2080;
        v130 = "f";
        v131 = 2080;
        v132 = v58;
        v133 = 2080;
        v134 = v61;
        v135 = 2080;
        v136 = *((_QWORD *)&v123 + 1);
        v137 = 2080;
        v138 = v59;
        v139 = 2080;
        v140 = (uint64_t)v60;
        v40 = "#I DATA.%s: %s: %s: %s(%s%s%s %s%s)";
        v41 = v30;
        v42 = 92;
LABEL_101:
        _os_log_impl(&dword_216897000, v41, OS_LOG_TYPE_DEFAULT, v40, (uint8_t *)&buf, v42);
LABEL_102:
        if ((_DWORD)v123 == -5)
        {
          LODWORD(v123) = 24;
          *((_QWORD *)&v123 + 1) = "activateDataContext replacement";
          *(_QWORD *)&v124 = &unk_216AC4FCA;
          DWORD2(v124) = 0;
          BYTE12(v124) = 0;
          v75 = v126;
          v126 = 0;
          v125 = 0uLL;
          if (v75)
          {
            v76 = (unint64_t *)&v75->__shared_owners_;
            do
              v77 = __ldaxr(v76);
            while (__stlxr(v77 - 1, v76));
            if (!v77)
            {
              ((void (*)(std::__shared_weak_count *))v75->__on_zero_shared)(v75);
              std::__shared_weak_count::__release_weak(v75);
            }
          }
        }
        BBDataContextDriverInterface::getObserver(v13);
        (*(void (**)(std::string::size_type, _QWORD))(*(_QWORD *)buf.__r_.__value_.__l.__data_ + 88))(buf.__r_.__value_.__r.__words[0], 0);
        v78 = (std::__shared_weak_count *)buf.__r_.__value_.__l.__size_;
        if (buf.__r_.__value_.__l.__size_)
        {
          v79 = (unint64_t *)(buf.__r_.__value_.__l.__size_ + 8);
          do
            v80 = __ldaxr(v79);
          while (__stlxr(v80 - 1, v79));
          if (!v80)
          {
            ((void (*)(std::__shared_weak_count *))v78->__on_zero_shared)(v78);
            std::__shared_weak_count::__release_weak(v78);
          }
        }
        BBDataContextDriverInterface::getObserver(v13);
        v81 = buf.__r_.__value_.__r.__words[0];
        v114[0] = v123;
        v114[1] = v124;
        v114[2] = v125;
        v115 = v126;
        if (v126)
        {
          v82 = (unint64_t *)&v126->__shared_owners_;
          do
            v83 = __ldxr(v82);
          while (__stxr(v83 + 1, v82));
        }
        (*(void (**)(std::string::size_type, _OWORD *, _QWORD))(*(_QWORD *)v81 + 112))(v81, v114, 0);
        v84 = v115;
        if (v115)
        {
          v85 = (unint64_t *)&v115->__shared_owners_;
          do
            v86 = __ldaxr(v85);
          while (__stlxr(v86 - 1, v85));
          if (!v86)
          {
            ((void (*)(std::__shared_weak_count *))v84->__on_zero_shared)(v84);
            std::__shared_weak_count::__release_weak(v84);
          }
        }
        v87 = (std::__shared_weak_count *)buf.__r_.__value_.__l.__size_;
        if (buf.__r_.__value_.__l.__size_)
        {
          v88 = (unint64_t *)(buf.__r_.__value_.__l.__size_ + 8);
          do
            v89 = __ldaxr(v88);
          while (__stlxr(v89 - 1, v88));
          if (!v89)
          {
            ((void (*)(std::__shared_weak_count *))v87->__on_zero_shared)(v87);
            std::__shared_weak_count::__release_weak(v87);
          }
        }
        v3 = v123;
LABEL_127:
        v4 = -1;
        goto LABEL_128;
      }
    }
    else
    {
      v59 = v124;
    }
    v61 = (const char *)&unk_216AC4FCA;
    v60 = (const char *)&unk_216AC4FCA;
    goto LABEL_100;
  }
  LODWORD(v119) = 0;
  BBDataContextDriverInterface::getObserver((BBDataContextDriverInterface *)(a1 + 24));
  v44 = buf.__r_.__value_.__r.__words[0];
  v112 = 0;
  v113 = 0;
  v111 = 0;
  std::vector<DataConnectionTraits>::__init_with_size[abi:ne180100]<DataConnectionTraits*,DataConnectionTraits*>(&v111, *(const void **)a3, *(_QWORD *)(a3 + 8), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a3 + 8) - *(_QWORD *)a3) >> 2));
  v45 = (*(uint64_t (**)(std::string::size_type, void **, uint64_t *))(*(_QWORD *)v44 + 96))(v44, &v111, &v119);
  if (v111)
  {
    v112 = v111;
    operator delete(v111);
  }
  v46 = (std::__shared_weak_count *)buf.__r_.__value_.__l.__size_;
  if (buf.__r_.__value_.__l.__size_)
  {
    v47 = (unint64_t *)(buf.__r_.__value_.__l.__size_ + 8);
    do
      v48 = __ldaxr(v47);
    while (__stlxr(v48 - 1, v47));
    if (!v48)
    {
      ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
      std::__shared_weak_count::__release_weak(v46);
    }
  }
  v49 = *(NSObject **)(a1 + 88);
  v50 = os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT);
  if ((v45 & 1) == 0)
  {
    if (v50)
    {
      v62 = CSIEventString();
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"activateDataContext";
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v62;
      _os_log_impl(&dword_216897000, v49, OS_LOG_TYPE_DEFAULT, "#I %s: DataContext activation is not possible: radio is not ready: event=%s", (uint8_t *)&buf, 0x16u);
    }
    BBDataContextDriverInterface::getObserver((BBDataContextDriverInterface *)(a1 + 24));
    (*(void (**)(std::string::size_type, _QWORD))(*(_QWORD *)buf.__r_.__value_.__l.__data_ + 88))(buf.__r_.__value_.__r.__words[0], 0);
    v63 = (std::__shared_weak_count *)buf.__r_.__value_.__l.__size_;
    if (buf.__r_.__value_.__l.__size_)
    {
      v64 = (unint64_t *)(buf.__r_.__value_.__l.__size_ + 8);
      do
        v65 = __ldaxr(v64);
      while (__stlxr(v65 - 1, v64));
      if (!v65)
      {
        ((void (*)(std::__shared_weak_count *))v63->__on_zero_shared)(v63);
        std::__shared_weak_count::__release_weak(v63);
      }
    }
    BBDataContextDriverInterface::getObserver(v13);
    v103 = 0;
    v104 = "Radio is not ready";
    v105 = &unk_216AC4FCA;
    v106 = 0;
    v107 = 0;
    v109 = 0;
    v110 = 0;
    v108 = 0;
    (*(void (**)(std::string::size_type, int *, _QWORD))(*(_QWORD *)buf.__r_.__value_.__l.__data_ + 112))(buf.__r_.__value_.__r.__words[0], &v103, v119);
    v66 = v110;
    if (v110)
    {
      v67 = (unint64_t *)&v110->__shared_owners_;
      do
        v68 = __ldaxr(v67);
      while (__stlxr(v68 - 1, v67));
      if (!v68)
      {
        ((void (*)(std::__shared_weak_count *))v66->__on_zero_shared)(v66);
        std::__shared_weak_count::__release_weak(v66);
      }
    }
    v69 = (std::__shared_weak_count *)buf.__r_.__value_.__l.__size_;
    if (buf.__r_.__value_.__l.__size_)
    {
      v70 = (unint64_t *)(buf.__r_.__value_.__l.__size_ + 8);
      do
        v71 = __ldaxr(v70);
      while (__stlxr(v71 - 1, v70));
      if (!v71)
      {
        ((void (*)(std::__shared_weak_count *))v69->__on_zero_shared)(v69);
        std::__shared_weak_count::__release_weak(v69);
      }
    }
    v3 = 24;
    goto LABEL_127;
  }
  if (v50)
  {
    v51 = asStringBool();
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"activateDataContext";
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v51;
    _os_log_impl(&dword_216897000, v49, OS_LOG_TYPE_DEFAULT, "#I %s: trying handover=%s", (uint8_t *)&buf, 0x16u);
  }
  if (v11
    || (BBDataContextDriverInterface::getObserver((BBDataContextDriverInterface *)(a1 + 24)),
        v52 = (*(uint64_t (**)(std::string::size_type))(*(_QWORD *)buf.__r_.__value_.__l.__data_ + 72))(buf.__r_.__value_.__r.__words[0]),
        std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&buf),
        (v52 & 1) == 0))
  {
    BBDataContextDriverInterface::getObserver((BBDataContextDriverInterface *)(a1 + 24));
    v53 = (*(uint64_t (**)(std::string::size_type, char *))(*(_QWORD *)buf.__r_.__value_.__l.__data_ + 80))(buf.__r_.__value_.__r.__words[0], v9);
    v54 = (std::__shared_weak_count *)buf.__r_.__value_.__l.__size_;
    if (buf.__r_.__value_.__l.__size_)
    {
      v55 = (unint64_t *)(buf.__r_.__value_.__l.__size_ + 8);
      do
        v56 = __ldaxr(v55);
      while (__stlxr(v56 - 1, v55));
      if (!v56)
      {
        ((void (*)(std::__shared_weak_count *))v54->__on_zero_shared)(v54);
        std::__shared_weak_count::__release_weak(v54);
      }
    }
    if ((v53 & 1) == 0)
    {
      BBDataContextDriverInterface::getObserver((BBDataContextDriverInterface *)(a1 + 24));
      (*(void (**)(std::string::size_type, uint64_t))(*(_QWORD *)buf.__r_.__value_.__l.__data_ + 88))(buf.__r_.__value_.__r.__words[0], 1);
      std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&buf);
      v102 = 3;
      BBDataContextDriverInterface::getObserver((BBDataContextDriverInterface *)(a1 + 24));
      v72 = (*(uint64_t (**)(std::string::size_type, unsigned int *, BOOL))(*(_QWORD *)buf.__r_.__value_.__l.__data_
                                                                                    + 568))(buf.__r_.__value_.__r.__words[0], &v102, v97 != 0);
      std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&buf);
      if ((v72 & 1) == 0)
      {
        v93 = *(NSObject **)(a1 + 88);
        if (os_log_type_enabled(v93, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"activateDataContext";
          _os_log_impl(&dword_216897000, v93, OS_LOG_TYPE_DEFAULT, "#I %s: DataSettings does not want us to proceed, bailing", (uint8_t *)&buf, 0xCu);
        }
        v3 = -3;
        goto LABEL_127;
      }
      if (!v97)
      {
        BBDataContextDriverInterface::getObserver((BBDataContextDriverInterface *)(a1 + 24));
        v73 = buf.__r_.__value_.__r.__words[0];
        std::string::basic_string[abi:ne180100]<0>(v100, v9);
        std::string::basic_string[abi:ne180100]<0>(v98, v10);
        (*(void (**)(std::string::size_type, uint64_t, void **, void **))(*(_QWORD *)v73 + 312))(v73, 3, v100, v98);
        if (v99 < 0)
          operator delete(v98[0]);
        if (v101 < 0)
          operator delete(v100[0]);
        std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&buf);
      }
      v74 = QMIDataContextDriver::getDataContextState(a1, 3) - 1;
      if (v74 < 6)
      {
        v4 = dword_216AC1D70[2 * v74];
        v3 = dword_216AC1DA0[v74];
        goto LABEL_128;
      }
      PDPMetricInfo::clear((PDPMetricInfo *)(a1 + 216));
      v94 = (const std::string::value_type **)(a2 + 48);
      if (*(char *)(a2 + 71) < 0)
      {
        v95 = *(_QWORD *)(a2 + 56);
        if (v95)
        {
          std::string::__init_copy_ctor_external(&buf, *v94, v95);
          goto LABEL_142;
        }
      }
      else if (*(_BYTE *)(a2 + 71))
      {
        *(_OWORD *)&buf.__r_.__value_.__l.__data_ = *(_OWORD *)v94;
        buf.__r_.__value_.__r.__words[2] = *(_QWORD *)(a2 + 64);
LABEL_142:
        v96 = (void **)(a1 + 224);
        if (*(char *)(a1 + 247) < 0)
          operator delete(*v96);
        *(_OWORD *)v96 = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
        *(_QWORD *)(a1 + 240) = *((_QWORD *)&buf.__r_.__value_.__l + 2);
        *(_QWORD *)(a1 + 376) = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 136) + 80))(*(_QWORD *)(a1 + 136));
        v4 = QMIDataContextDriver::startDataCall(a1, v102, v97 != 0, a1 + 224) - 1;
        v3 = -9;
        goto LABEL_128;
      }
      std::string::basic_string[abi:ne180100]<0>(&buf, v9);
      goto LABEL_142;
    }
  }
  v3 = 0;
  v4 = 2;
LABEL_128:
  v90 = v126;
  if (v126)
  {
    v91 = (unint64_t *)&v126->__shared_owners_;
    do
      v92 = __ldaxr(v91);
    while (__stlxr(v92 - 1, v91));
    if (!v92)
    {
      ((void (*)(std::__shared_weak_count *))v90->__on_zero_shared)(v90);
      std::__shared_weak_count::__release_weak(v90);
    }
  }
  return v4 | ((unint64_t)v3 << 32);
}

void sub_216A962E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void *a40,uint64_t a41,uint64_t a42,char a43,uint64_t a44,char a45,uint64_t a46,char a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a52);
  _Unwind_Resume(a1);
}

uint64_t QMIDataContextDriver::startDataCall(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  int v12;
  uint64_t v13;
  NSObject *v14;
  void *p_p;
  unsigned int v16;
  unint64_t *p_shared_owners;
  unint64_t v18;
  uint64_t v20;
  std::__shared_weak_count *v21;
  void *__p;
  char v23;
  _BYTE buf[22];
  __int16 v25;
  uint64_t v26;
  __int16 v27;
  uint64_t v28;
  __int16 v29;
  uint64_t v30;
  __int16 v31;
  uint64_t v32;
  uint64_t v33;

  v33 = *MEMORY[0x24BDAC8D0];
  if (((*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 136) + 48))(*(_QWORD *)(a1 + 136)) & 1) != 0)
    goto LABEL_13;
  BBDataContextDriverInterface::getObserver((BBDataContextDriverInterface *)(a1 + 24));
  v8 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)buf + 120))(*(_QWORD *)buf, a3);
  v9 = v8;
  if (!*(_QWORD *)&buf[8])
    goto LABEL_6;
  v10 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
  do
    v11 = __ldaxr(v10);
  while (__stlxr(v11 - 1, v10));
  if (!v11)
  {
    (*(void (**)(_QWORD))(**(_QWORD **)&buf[8] + 16))(*(_QWORD *)&buf[8]);
    std::__shared_weak_count::__release_weak(*(std::__shared_weak_count **)&buf[8]);
    if (!(_DWORD)v9)
      goto LABEL_13;
  }
  else
  {
LABEL_6:
    if (!(_DWORD)v8)
      goto LABEL_13;
  }
  if (a2)
    v12 = a2;
  else
    v12 = 3;
  if ((_DWORD)v9 != 3)
  {
    v13 = v9 & v12;
    goto LABEL_14;
  }
LABEL_13:
  v9 = 3;
  v13 = 3;
LABEL_14:
  v14 = *(NSObject **)(a1 + 88);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    p_p = &__p;
    QMIDataContextDriver::getAPNObserver((QMIDataContextDriver *)a1);
    if (v23 < 0)
      p_p = __p;
    BBDataContextDriverInterface::getObserver((BBDataContextDriverInterface *)(a1 + 24));
    v16 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v20 + 120))(v20, a3);
    *(_DWORD *)buf = 136447490;
    *(_QWORD *)&buf[4] = p_p;
    *(_WORD *)&buf[12] = 2048;
    *(_QWORD *)&buf[14] = a2;
    v25 = 2048;
    v26 = v16;
    v27 = 2048;
    v28 = v9;
    v29 = 2048;
    v30 = v13;
    v31 = 2048;
    v32 = 3;
    _os_log_impl(&dword_216897000, v14, OS_LOG_TYPE_DEFAULT, "#I startDataCall: apn=%{public}s: ipFamily is allowed: family=0x%lx, allowed=0x%lx, localAllowed=0x%lx, activation=0x%lx, requested=0x%lx", buf, 0x3Eu);
    if (v21)
    {
      p_shared_owners = (unint64_t *)&v21->__shared_owners_;
      do
        v18 = __ldaxr(p_shared_owners);
      while (__stlxr(v18 - 1, p_shared_owners));
      if (!v18)
      {
        ((void (*)())v21->__on_zero_shared)();
        std::__shared_weak_count::__release_weak(v21);
      }
    }
    if (v23 < 0)
      operator delete(__p);
  }
  *(_DWORD *)(a1 + 384) = v13;
  return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(**(_QWORD **)(a1 + 152) + 40))(*(_QWORD *)(a1 + 152), v13, v9, 3, a3, a4);
}

void sub_216A9666C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a10);
  if (a17 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

unint64_t `non-virtual thunk to'QMIDataContextDriver::activateDataContext(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return QMIDataContextDriver::activateDataContext(a1 - 24, a2, a3);
}

void QMIDataContextDriver::getAPNObserver(QMIDataContextDriver *this)
{
  unint64_t *p_shared_owners;
  unint64_t v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  BBDataContextDriverInterface::getObserver((QMIDataContextDriver *)((char *)this + 24));
  (*(void (**)())(*(_QWORD *)v3 + 456))();
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v2 = __ldaxr(p_shared_owners);
    while (__stlxr(v2 - 1, p_shared_owners));
    if (!v2)
    {
      ((void (*)())v4->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

void sub_216A96748(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t QMIDataContextDriver::getDataFamilyActive(QMIDataContextDriver *this)
{
  int v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  CSIPacketAddress *v8;
  unsigned int v9;
  CSIPacketAddress *v10;
  uint64_t v12;
  std::__shared_weak_count *v13;
  uint64_t v14;
  std::__shared_weak_count *v15;

  BBDataContextDriverInterface::getObserver((QMIDataContextDriver *)((char *)this + 24));
  (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v12 + 328))(&v14);
  v2 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v14 + 360))(v14);
  v3 = v15;
  if (v15)
  {
    p_shared_owners = (unint64_t *)&v15->__shared_owners_;
    do
      v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  if (!v13)
    goto LABEL_10;
  v6 = (unint64_t *)&v13->__shared_owners_;
  do
    v7 = __ldaxr(v6);
  while (__stlxr(v7 - 1, v6));
  if (!v7)
  {
    ((void (*)())v13->__on_zero_shared)();
    std::__shared_weak_count::__release_weak(v13);
    if (!v2)
      return 0;
  }
  else
  {
LABEL_10:
    if (!v2)
      return 0;
  }
  if (QMIDataContextDriver::getDataContextState((uint64_t)this, 3) - 3 >= 4)
    return 0;
  v8 = (CSIPacketAddress *)(*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)this + 19) + 48))(*((_QWORD *)this + 19), 1);
  v9 = CSIPacketAddress::isZeroIP(v8) ^ 1;
  v10 = (CSIPacketAddress *)(*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)this + 19) + 48))(*((_QWORD *)this + 19), 2);
  if (CSIPacketAddress::isZeroIP(v10))
    return v9;
  else
    return v9 | 2;
}

void sub_216A96894(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t `non-virtual thunk to'QMIDataContextDriver::getDataFamilyActive(QMIDataContextDriver *this)
{
  return QMIDataContextDriver::getDataFamilyActive((QMIDataContextDriver *)((char *)this - 24));
}

void QMIDataContextDriver::handleDataContextIPActivated(QMIDataContextDriver *this)
{
  unint64_t *p_shared_owners;
  unint64_t v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  BBDataContextDriverInterface::getObserver((QMIDataContextDriver *)((char *)this + 24));
  (*(void (**)())(*(_QWORD *)v3 + 448))();
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v2 = __ldaxr(p_shared_owners);
    while (__stlxr(v2 - 1, p_shared_owners));
    if (!v2)
    {
      ((void (*)())v4->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

void sub_216A96934(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'QMIDataContextDriver::handleDataContextIPActivated(QMIDataContextDriver *this)
{
  QMIDataContextDriver::handleDataContextIPActivated((QMIDataContextDriver *)((char *)this - 48));
}

void QMIDataContextDriver::handleDataContextIPSuspended(QMIDataContextDriver *this)
{
  unint64_t *p_shared_owners;
  unint64_t v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  BBDataContextDriverInterface::getObserver((QMIDataContextDriver *)((char *)this + 24));
  (*(void (**)())(*(_QWORD *)v3 + 208))();
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v2 = __ldaxr(p_shared_owners);
    while (__stlxr(v2 - 1, p_shared_owners));
    if (!v2)
    {
      ((void (*)())v4->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

void sub_216A969C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'QMIDataContextDriver::handleDataContextIPSuspended(QMIDataContextDriver *this)
{
  QMIDataContextDriver::handleDataContextIPSuspended((QMIDataContextDriver *)((char *)this - 48));
}

void QMIDataContextDriver::handleDataContextIPOffline(uint64_t a1, uint64_t a2)
{
  unint64_t *p_shared_owners;
  unint64_t v4;
  uint64_t v5;
  std::__shared_weak_count *v6;

  BBDataContextDriverInterface::getObserver((BBDataContextDriverInterface *)(a1 + 24));
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v5 + 432))(v5, a2);
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)())v6->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

void sub_216A96A5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'QMIDataContextDriver::handleDataContextIPOffline(uint64_t a1, uint64_t a2)
{
  QMIDataContextDriver::handleDataContextIPOffline(a1 - 48, a2);
}

void QMIDataContextDriver::handleDataContextIPActivateFailure(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, char a7)
{
  NSObject *v14;
  BBDataContextDriverInterface *v15;
  uint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *p_shared_owners;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  void *__p[2];
  char v27;
  int v28;
  const char *v29;
  void *v30;
  int v31;
  char v32;
  uint64_t v33;
  uint64_t v34;
  std::__shared_weak_count *v35;
  __int128 buf;
  uint64_t v37;

  v37 = *MEMORY[0x24BDAC8D0];
  v14 = *(NSObject **)(a1 + 88);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 136315138;
    *(_QWORD *)((char *)&buf + 4) = "handleDataContextIPActivateFailure";
    _os_log_impl(&dword_216897000, v14, OS_LOG_TYPE_DEFAULT, "#I %s: start", (uint8_t *)&buf, 0xCu);
  }
  v15 = (BBDataContextDriverInterface *)(a1 + 24);
  BBDataContextDriverInterface::getObserver(v15);
  v16 = buf;
  v28 = a3;
  v29 = "we are done with this context";
  v30 = &unk_216AC4FCA;
  v31 = 0;
  v32 = 0;
  v34 = 0;
  v35 = 0;
  v33 = 0;
  std::string::basic_string[abi:ne180100]<0>(__p, "qmi activate fail");
  (*(void (**)(uint64_t, uint64_t, int *, void **, _QWORD, uint64_t, uint64_t, uint64_t, char))(*(_QWORD *)v16 + 440))(v16, a2, &v28, __p, 0, a6, a4, a5, a7);
  if (v27 < 0)
    operator delete(__p[0]);
  v17 = v35;
  if (v35)
  {
    p_shared_owners = (unint64_t *)&v35->__shared_owners_;
    do
      v19 = __ldaxr(p_shared_owners);
    while (__stlxr(v19 - 1, p_shared_owners));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
  v20 = (std::__shared_weak_count *)*((_QWORD *)&buf + 1);
  if (*((_QWORD *)&buf + 1))
  {
    v21 = (unint64_t *)(*((_QWORD *)&buf + 1) + 8);
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
  BBDataContextDriverInterface::getObserver(v15);
  (*(void (**)(_QWORD))(*(_QWORD *)buf + 544))(buf);
  v23 = (std::__shared_weak_count *)*((_QWORD *)&buf + 1);
  if (*((_QWORD *)&buf + 1))
  {
    v24 = (unint64_t *)(*((_QWORD *)&buf + 1) + 8);
    do
      v25 = __ldaxr(v24);
    while (__stlxr(v25 - 1, v24));
    if (!v25)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }
}

void sub_216A96C98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a24);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'QMIDataContextDriver::handleDataContextIPActivateFailure(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, char a7)
{
  QMIDataContextDriver::handleDataContextIPActivateFailure(a1 - 48, a2, a3, a4, a5, a6, a7);
}

void QMIDataContextDriver::handleDataContextIPOfflineIfActivated(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  BBDataContextDriverInterface *v5;
  int v6;
  int v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  NSObject *v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  _BYTE v16[22];
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v4 = *(NSObject **)(a1 + 88);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)v16 = 136315138;
    *(_QWORD *)&v16[4] = "handleDataContextIPOfflineIfActivated";
    _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I %s: start", v16, 0xCu);
  }
  v5 = (BBDataContextDriverInterface *)(a1 + 24);
  BBDataContextDriverInterface::getObserver((BBDataContextDriverInterface *)(a1 + 24));
  v6 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)v16 + 424))(*(_QWORD *)v16, a2);
  v7 = v6;
  v8 = *(std::__shared_weak_count **)&v16[8];
  if (!*(_QWORD *)&v16[8])
    goto LABEL_7;
  v9 = (unint64_t *)(*(_QWORD *)&v16[8] + 8);
  do
    v10 = __ldaxr(v9);
  while (__stlxr(v10 - 1, v9));
  if (!v10)
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
    if (!v7)
      return;
  }
  else
  {
LABEL_7:
    if (!v6)
      return;
  }
  v11 = *(NSObject **)(a1 + 88);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    v12 = asString();
    *(_DWORD *)v16 = 136315394;
    *(_QWORD *)&v16[4] = "handleDataContextIPOfflineIfActivated";
    *(_WORD *)&v16[12] = 2080;
    *(_QWORD *)&v16[14] = v12;
    _os_log_impl(&dword_216897000, v11, OS_LOG_TYPE_DEFAULT, "#I %s: %s network is already online, take it offline (2)", v16, 0x16u);
  }
  BBDataContextDriverInterface::getObserver(v5);
  (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)v16 + 432))(*(_QWORD *)v16, a2);
  v13 = *(std::__shared_weak_count **)&v16[8];
  if (*(_QWORD *)&v16[8])
  {
    v14 = (unint64_t *)(*(_QWORD *)&v16[8] + 8);
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
}

void sub_216A96EC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'QMIDataContextDriver::handleDataContextIPOfflineIfActivated(uint64_t a1, uint64_t a2)
{
  QMIDataContextDriver::handleDataContextIPOfflineIfActivated(a1 - 48, a2);
}

uint64_t QMIDataContextDriver::handleNetworkStackFailure(uint64_t a1, uint64_t a2, int a3)
{
  NSObject *v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  void *__p[2];
  char v18;
  int v19;
  const char *v20;
  void *v21;
  int v22;
  char v23;
  uint64_t v24;
  uint64_t v25;
  std::__shared_weak_count *v26;
  __int128 buf;
  uint64_t v28;

  v28 = *MEMORY[0x24BDAC8D0];
  v6 = *(NSObject **)(a1 + 88);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 136315138;
    *(_QWORD *)((char *)&buf + 4) = "handleNetworkStackFailure";
    _os_log_impl(&dword_216897000, v6, OS_LOG_TYPE_DEFAULT, "#I %s: start", (uint8_t *)&buf, 0xCu);
  }
  if (a3 == 99)
    v7 = 38;
  else
    v7 = 18;
  QMIDataContextDriver::deactivateDataContext(a1, v7, "CommCenter");
  if ((int)QMIDataContextDriver::getDataContextState(a1, 3) <= 3)
  {
    v8 = *(NSObject **)(a1 + 88);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 136315138;
      *(_QWORD *)((char *)&buf + 4) = "handleNetworkStackFailure";
      _os_log_impl(&dword_216897000, v8, OS_LOG_TYPE_DEFAULT, "#I %s: done with context", (uint8_t *)&buf, 0xCu);
    }
    BBDataContextDriverInterface::getObserver((BBDataContextDriverInterface *)(a1 + 24));
    v9 = buf;
    v19 = a3;
    v20 = "handleNetworkStackFailure";
    v21 = &unk_216AC4FCA;
    v22 = 0;
    v23 = 0;
    v25 = 0;
    v26 = 0;
    v24 = 0;
    std::string::basic_string[abi:ne180100]<0>(__p, "QMI network fail");
    (*(void (**)(uint64_t, uint64_t, int *, void **, uint64_t, _QWORD, _QWORD, _QWORD, _BYTE))(*(_QWORD *)v9 + 440))(v9, a2, &v19, __p, 1, 0, 0, 0, 0);
    if (v18 < 0)
      operator delete(__p[0]);
    v10 = v26;
    if (v26)
    {
      p_shared_owners = (unint64_t *)&v26->__shared_owners_;
      do
        v12 = __ldaxr(p_shared_owners);
      while (__stlxr(v12 - 1, p_shared_owners));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
    v13 = (std::__shared_weak_count *)*((_QWORD *)&buf + 1);
    if (*((_QWORD *)&buf + 1))
    {
      v14 = (unint64_t *)(*((_QWORD *)&buf + 1) + 8);
      do
        v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }
  }
  return (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 152) + 120))(*(_QWORD *)(a1 + 152), a2);
}

void sub_216A9712C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22)
{
  uint64_t v22;

  if (a16 < 0)
    operator delete(__p);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a22);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v22 - 80);
  _Unwind_Resume(a1);
}

uint64_t QMIDataContextDriver::deactivateDataContext(uint64_t a1, uint64_t a2, const std::string::value_type *a3)
{
  NSObject *v6;
  BBDataContextDriverInterface *v7;
  int v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  int v12;
  unint64_t *v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  NSObject *v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  _BOOL4 v30;
  _BOOL8 v31;
  const std::string::value_type *v32;
  uint64_t v33;
  std::__shared_weak_count *v34;
  uint64_t v35;
  std::__shared_weak_count *v36;
  uint64_t v37;
  std::__shared_weak_count *v38;
  _BYTE buf[22];
  uint64_t v40;

  v40 = *MEMORY[0x24BDAC8D0];
  v6 = *(NSObject **)(a1 + 88);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = "deactivateDataContext";
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = asString();
    _os_log_impl(&dword_216897000, v6, OS_LOG_TYPE_DEFAULT, "#I %s: reason %s", buf, 0x16u);
  }
  v7 = (BBDataContextDriverInterface *)(a1 + 24);
  BBDataContextDriverInterface::getObserver((BBDataContextDriverInterface *)(a1 + 24));
  (*(void (**)(_BYTE *__return_ptr))(*(_QWORD *)v37 + 392))(buf);
  if (*(_QWORD *)buf)
  {
    BBDataContextDriverInterface::getObserver((BBDataContextDriverInterface *)(a1 + 24));
    (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v33 + 392))(&v35);
    v8 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)v35 + 96))(v35, 0, a2);
    v9 = v36;
    if (v36)
    {
      p_shared_owners = (unint64_t *)&v36->__shared_owners_;
      do
        v11 = __ldaxr(p_shared_owners);
      while (__stlxr(v11 - 1, p_shared_owners));
      if (!v11)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
    v12 = v8 ^ 1;
    if (v34)
    {
      v13 = (unint64_t *)&v34->__shared_owners_;
      do
        v14 = __ldaxr(v13);
      while (__stlxr(v14 - 1, v13));
      if (!v14)
      {
        ((void (*)())v34->__on_zero_shared)();
        std::__shared_weak_count::__release_weak(v34);
      }
    }
  }
  else
  {
    v12 = 0;
  }
  v15 = *(std::__shared_weak_count **)&buf[8];
  if (*(_QWORD *)&buf[8])
  {
    v16 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  v18 = v38;
  if (v38)
  {
    v19 = (unint64_t *)&v38->__shared_owners_;
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
      if (v12)
        goto LABEL_25;
LABEL_39:
      v30 = (_DWORD)a2 != 38 && (_DWORD)a2 != 21;
      v31 = (a2 - 23) >= 2 && v30;
      v32 = (const std::string::value_type *)asString();
      std::string::__assign_external((std::string *)(a1 + 248), v32);
      std::string::__assign_external((std::string *)(a1 + 272), a3);
      return (*(uint64_t (**)(_QWORD, _BOOL8, BOOL))(**(_QWORD **)(a1 + 152) + 136))(*(_QWORD *)(a1 + 152), v31, (_DWORD)a2 == 23);
    }
  }
  if (!v12)
    goto LABEL_39;
LABEL_25:
  v21 = *(NSObject **)(a1 + 88);
  if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315138;
    *(_QWORD *)&buf[4] = "deactivateDataContext";
    _os_log_impl(&dword_216897000, v21, OS_LOG_TYPE_DEFAULT, "#I %s: DataSettings prevented deactivation", buf, 0xCu);
  }
  BBDataContextDriverInterface::getObserver(v7);
  (*(void (**)(_BYTE *__return_ptr))(*(_QWORD *)v37 + 328))(buf);
  (*(void (**)(_QWORD))(**(_QWORD **)buf + 648))(*(_QWORD *)buf);
  v22 = *(std::__shared_weak_count **)&buf[8];
  if (*(_QWORD *)&buf[8])
  {
    v23 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
    do
      v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
  }
  v25 = v38;
  if (v38)
  {
    v26 = (unint64_t *)&v38->__shared_owners_;
    do
      v27 = __ldaxr(v26);
    while (__stlxr(v27 - 1, v26));
    if (!v27)
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }
  return 0;
}

void sub_216A974E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  uint64_t v6;
  va_list va;
  uint64_t v8;
  va_list va1;

  va_start(va1, a5);
  va_start(va, a5);
  v6 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t `non-virtual thunk to'QMIDataContextDriver::handleNetworkStackFailure(uint64_t a1, uint64_t a2, int a3)
{
  return QMIDataContextDriver::handleNetworkStackFailure(a1 - 24, a2, a3);
}

void QMIDataContextDriver::handleDataContextIpDeactivatedContextDisappeared(QMIDataContextDriver *this)
{
  unint64_t *p_shared_owners;
  unint64_t v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  BBDataContextDriverInterface::getObserver((QMIDataContextDriver *)((char *)this + 24));
  (*(void (**)())(*(_QWORD *)v3 + 248))();
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v2 = __ldaxr(p_shared_owners);
    while (__stlxr(v2 - 1, p_shared_owners));
    if (!v2)
    {
      ((void (*)())v4->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

void sub_216A975C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'QMIDataContextDriver::handleDataContextIpDeactivatedContextDisappeared(QMIDataContextDriver *this)
{
  QMIDataContextDriver::handleDataContextIpDeactivatedContextDisappeared((QMIDataContextDriver *)((char *)this - 48));
}

void QMIDataContextDriver::updateBbThrottlingTimer(QMIDataContextDriver *this, uint64_t a2)
{
  unint64_t *p_shared_owners;
  unint64_t v4;
  uint64_t v5;
  std::__shared_weak_count *v6;

  BBDataContextDriverInterface::getObserver((QMIDataContextDriver *)((char *)this + 24));
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v5 + 656))(v5, a2);
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)())v6->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

void sub_216A97658(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'QMIDataContextDriver::updateBbThrottlingTimer(QMIDataContextDriver *this, uint64_t a2)
{
  QMIDataContextDriver::updateBbThrottlingTimer((QMIDataContextDriver *)((char *)this - 48), a2);
}

void QMIDataContextDriver::handleDataContextIpDeactivatedNetworkDisconnect(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t *p_shared_owners;
  unint64_t v8;
  uint64_t v9;
  std::__shared_weak_count *v10;

  BBDataContextDriverInterface::getObserver((BBDataContextDriverInterface *)(a1 + 24));
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v9 + 240))(v9, a2, a3, a4);
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)())v10->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v10);
    }
  }
}

void sub_216A97708(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'QMIDataContextDriver::handleDataContextIpDeactivatedNetworkDisconnect(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  QMIDataContextDriver::handleDataContextIpDeactivatedNetworkDisconnect(a1 - 48, a2, a3, a4);
}

void QMIDataContextDriver::handleDataContextIPFailedCleaningDone(QMIDataContextDriver *this)
{
  unint64_t *p_shared_owners;
  unint64_t v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  BBDataContextDriverInterface::getObserver((QMIDataContextDriver *)((char *)this + 24));
  (*(void (**)())(*(_QWORD *)v3 + 184))();
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v2 = __ldaxr(p_shared_owners);
    while (__stlxr(v2 - 1, p_shared_owners));
    if (!v2)
    {
      ((void (*)())v4->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

void sub_216A97798(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'QMIDataContextDriver::handleDataContextIPFailedCleaningDone(QMIDataContextDriver *this)
{
  QMIDataContextDriver::handleDataContextIPFailedCleaningDone((QMIDataContextDriver *)((char *)this - 48));
}

void QMIDataContextDriver::sendAnbrActivationState(QMIDataContextDriver *this, uint64_t a2)
{
  unint64_t *p_shared_owners;
  unint64_t v4;
  uint64_t v5;
  std::__shared_weak_count *v6;

  BBDataContextDriverInterface::getObserver((QMIDataContextDriver *)((char *)this + 24));
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v5 + 192))(v5, a2);
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)())v6->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

void sub_216A97830(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'QMIDataContextDriver::sendAnbrActivationState(QMIDataContextDriver *this, uint64_t a2)
{
  QMIDataContextDriver::sendAnbrActivationState((QMIDataContextDriver *)((char *)this - 48), a2);
}

void QMIDataContextDriver::sendAnbrBitrateRecommendation(QMIDataContextDriver *this, uint64_t a2, uint64_t a3)
{
  unint64_t *p_shared_owners;
  unint64_t v6;
  uint64_t v7;
  std::__shared_weak_count *v8;

  BBDataContextDriverInterface::getObserver((QMIDataContextDriver *)((char *)this + 24));
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v7 + 200))(v7, a2, a3);
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)())v8->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v8);
    }
  }
}

void sub_216A978D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'QMIDataContextDriver::sendAnbrBitrateRecommendation(QMIDataContextDriver *this, uint64_t a2, uint64_t a3)
{
  QMIDataContextDriver::sendAnbrBitrateRecommendation((QMIDataContextDriver *)((char *)this - 48), a2, a3);
}

void QMIDataContextDriver::handleDataContextIPAborted(QMIDataContextDriver *this)
{
  unint64_t *p_shared_owners;
  unint64_t v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  BBDataContextDriverInterface::getObserver((QMIDataContextDriver *)((char *)this + 24));
  (*(void (**)())(*(_QWORD *)v3 + 256))();
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v2 = __ldaxr(p_shared_owners);
    while (__stlxr(v2 - 1, p_shared_owners));
    if (!v2)
    {
      ((void (*)())v4->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

void sub_216A97960(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'QMIDataContextDriver::handleDataContextIPAborted(QMIDataContextDriver *this)
{
  QMIDataContextDriver::handleDataContextIPAborted((QMIDataContextDriver *)((char *)this - 48));
}

void QMIDataContextDriver::handleDataContextIPIdle(QMIDataContextDriver *this)
{
  unint64_t *p_shared_owners;
  unint64_t v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  BBDataContextDriverInterface::getObserver((QMIDataContextDriver *)((char *)this + 24));
  (*(void (**)())(*(_QWORD *)v3 + 176))();
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v2 = __ldaxr(p_shared_owners);
    while (__stlxr(v2 - 1, p_shared_owners));
    if (!v2)
    {
      ((void (*)())v4->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

void sub_216A979F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'QMIDataContextDriver::handleDataContextIPIdle(QMIDataContextDriver *this)
{
  QMIDataContextDriver::handleDataContextIPIdle((QMIDataContextDriver *)((char *)this - 48));
}

uint64_t QMIDataContextDriver::handleDataContextIPResume(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  uint64_t v9;
  std::__shared_weak_count *v10;

  BBDataContextDriverInterface::getObserver((BBDataContextDriverInterface *)(a1 + 24));
  v5 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v9 + 224))(v9, a2, a3);
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)())v10->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  return v5;
}

void sub_216A97A98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t `non-virtual thunk to'QMIDataContextDriver::handleDataContextIPResume(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return QMIDataContextDriver::handleDataContextIPResume(a1 - 48, a2, a3);
}

void QMIDataContextDriver::handleDataContextIPResumed(QMIDataContextDriver *this)
{
  unint64_t *p_shared_owners;
  unint64_t v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  BBDataContextDriverInterface::getObserver((QMIDataContextDriver *)((char *)this + 24));
  (*(void (**)())(*(_QWORD *)v3 + 232))();
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v2 = __ldaxr(p_shared_owners);
    while (__stlxr(v2 - 1, p_shared_owners));
    if (!v2)
    {
      ((void (*)())v4->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

void sub_216A97B28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'QMIDataContextDriver::handleDataContextIPResumed(QMIDataContextDriver *this)
{
  QMIDataContextDriver::handleDataContextIPResumed((QMIDataContextDriver *)((char *)this - 48));
}

void QMIDataContextDriver::handleDataContextIPDidGetPcoInfo(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t *p_shared_owners;
  unint64_t v6;
  uint64_t v7;
  std::__shared_weak_count *v8;

  BBDataContextDriverInterface::getObserver((BBDataContextDriverInterface *)(a1 + 24));
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v7 + 264))(v7, a2, a3);
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)())v8->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v8);
    }
  }
}

void sub_216A97BC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'QMIDataContextDriver::handleDataContextIPDidGetPcoInfo(uint64_t a1, uint64_t a2, uint64_t a3)
{
  QMIDataContextDriver::handleDataContextIPDidGetPcoInfo(a1 - 48, a2, a3);
}

void QMIDataContextDriver::handleDataContextIPDidGetMTU(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t *p_shared_owners;
  unint64_t v6;
  uint64_t v7;
  std::__shared_weak_count *v8;

  BBDataContextDriverInterface::getObserver((BBDataContextDriverInterface *)(a1 + 24));
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v7 + 280))(v7, a2, a3);
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)())v8->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v8);
    }
  }
}

void sub_216A97C68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'QMIDataContextDriver::handleDataContextIPDidGetMTU(uint64_t a1, uint64_t a2, uint64_t a3)
{
  QMIDataContextDriver::handleDataContextIPDidGetMTU(a1 - 48, a2, a3);
}

uint64_t QMIDataContextDriver::handleDataContextIPOnline(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  uint64_t v11;
  std::__shared_weak_count *v12;

  BBDataContextDriverInterface::getObserver((BBDataContextDriverInterface *)(a1 + 24));
  v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v11 + 104))(v11, a2, a3, a4);
  if (v12)
  {
    p_shared_owners = (unint64_t *)&v12->__shared_owners_;
    do
      v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)())v12->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  return v7;
}

void sub_216A97D20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t `non-virtual thunk to'QMIDataContextDriver::handleDataContextIPOnline(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return QMIDataContextDriver::handleDataContextIPOnline(a1 - 48, a2, a3, a4);
}

uint64_t QMIDataContextDriver::ipFamilyMustBeConfigured(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  uint64_t v7;
  std::__shared_weak_count *v8;

  BBDataContextDriverInterface::getObserver((BBDataContextDriverInterface *)(a1 + 24));
  v3 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v7 + 288))(v7, a2);
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)())v8->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  return v3;
}

void sub_216A97DC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t `non-virtual thunk to'QMIDataContextDriver::ipFamilyMustBeConfigured(uint64_t a1, uint64_t a2)
{
  return QMIDataContextDriver::ipFamilyMustBeConfigured(a1 - 48, a2);
}

void QMIDataContextDriver::proxyUpdate(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t *p_shared_owners;
  unint64_t v6;
  uint64_t v7;
  std::__shared_weak_count *v8;

  BBDataContextDriverInterface::getObserver((BBDataContextDriverInterface *)(a1 + 24));
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v7 + 128))(v7, a2, a3);
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)())v8->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v8);
    }
  }
}

void sub_216A97E60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'QMIDataContextDriver::proxyUpdate(uint64_t a1, uint64_t a2, uint64_t a3)
{
  QMIDataContextDriver::proxyUpdate(a1 - 48, a2, a3);
}

void QMIDataContextDriver::applicationIDUpdate(QMIDataContextDriver *this, uint64_t a2)
{
  unint64_t *p_shared_owners;
  unint64_t v4;
  uint64_t v5;
  std::__shared_weak_count *v6;

  BBDataContextDriverInterface::getObserver((QMIDataContextDriver *)((char *)this + 24));
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v5 + 136))(v5, a2);
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)())v6->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

void sub_216A97EF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'QMIDataContextDriver::applicationIDUpdate(QMIDataContextDriver *this, uint64_t a2)
{
  QMIDataContextDriver::applicationIDUpdate((QMIDataContextDriver *)((char *)this - 48), a2);
}

void QMIDataContextDriver::getInterfaceAddress(uint64_t a1, uint64_t a2)
{
  unint64_t *p_shared_owners;
  unint64_t v4;
  uint64_t v5;
  std::__shared_weak_count *v6;

  BBDataContextDriverInterface::getObserver((BBDataContextDriverInterface *)(a1 + 24));
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v5 + 296))(v5, a2);
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)())v6->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

void sub_216A97F98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'QMIDataContextDriver::getInterfaceAddress(uint64_t a1, uint64_t a2)
{
  QMIDataContextDriver::getInterfaceAddress(a1 - 48, a2);
}

uint64_t QMIDataContextDriver::isInEnteringLowPowerForNoWowIP(QMIDataContextDriver *this)
{
  uint64_t v1;
  unint64_t *p_shared_owners;
  unint64_t v3;
  uint64_t v5;
  std::__shared_weak_count *v6;

  BBDataContextDriverInterface::getObserver((QMIDataContextDriver *)((char *)this + 24));
  v1 = (*(uint64_t (**)())(*(_QWORD *)v5 + 304))();
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v3 = __ldaxr(p_shared_owners);
    while (__stlxr(v3 - 1, p_shared_owners));
    if (!v3)
    {
      ((void (*)())v6->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  return v1;
}

void sub_216A98030(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t `non-virtual thunk to'QMIDataContextDriver::isInEnteringLowPowerForNoWowIP(QMIDataContextDriver *this)
{
  return QMIDataContextDriver::isInEnteringLowPowerForNoWowIP((QMIDataContextDriver *)((char *)this - 48));
}

void QMIDataContextDriver::submitIpv4AddressChangeMetric(QMIDataContextDriver *this)
{
  unint64_t *p_shared_owners;
  unint64_t v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  BBDataContextDriverInterface::getObserver((QMIDataContextDriver *)((char *)this + 24));
  (*(void (**)())(*(_QWORD *)v3 + 320))();
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v2 = __ldaxr(p_shared_owners);
    while (__stlxr(v2 - 1, p_shared_owners));
    if (!v2)
    {
      ((void (*)())v4->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

void sub_216A980C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'QMIDataContextDriver::submitIpv4AddressChangeMetric(QMIDataContextDriver *this)
{
  QMIDataContextDriver::submitIpv4AddressChangeMetric((QMIDataContextDriver *)((char *)this - 48));
}

void QMIDataContextDriver::getDataSettingsInfo(QMIDataContextDriver *this)
{
  unint64_t *p_shared_owners;
  unint64_t v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  BBDataContextDriverInterface::getObserver((QMIDataContextDriver *)((char *)this + 24));
  (*(void (**)())(*(_QWORD *)v3 + 392))();
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v2 = __ldaxr(p_shared_owners);
    while (__stlxr(v2 - 1, p_shared_owners));
    if (!v2)
    {
      ((void (*)())v4->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

void sub_216A98158(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'QMIDataContextDriver::getDataSettingsInfo(QMIDataContextDriver *this)
{
  QMIDataContextDriver::getDataSettingsInfo((QMIDataContextDriver *)((char *)this - 48));
}

uint64_t QMIDataContextDriver::getConnectionMask(QMIDataContextDriver *this, uint64_t a2)
{
  uint64_t v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  uint64_t v7;
  std::__shared_weak_count *v8;

  BBDataContextDriverInterface::getObserver((QMIDataContextDriver *)((char *)this + 24));
  v3 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v7 + 416))(v7, a2);
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)())v8->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  return v3;
}

void sub_216A981F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t `non-virtual thunk to'QMIDataContextDriver::getConnectionMask(QMIDataContextDriver *this, uint64_t a2)
{
  return QMIDataContextDriver::getConnectionMask((QMIDataContextDriver *)((char *)this - 48), a2);
}

void QMIDataContextDriver::reInitThrottleTimer(QMIDataContextDriver *this, uint64_t a2)
{
  unint64_t *p_shared_owners;
  unint64_t v4;
  uint64_t v5;
  std::__shared_weak_count *v6;

  BBDataContextDriverInterface::getObserver((QMIDataContextDriver *)((char *)this + 24));
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v5 + 552))(v5, a2);
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)())v6->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

void sub_216A98290(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'QMIDataContextDriver::reInitThrottleTimer(QMIDataContextDriver *this, uint64_t a2)
{
  QMIDataContextDriver::reInitThrottleTimer((QMIDataContextDriver *)((char *)this - 48), a2);
}

uint64_t QMIDataContextDriver::getCellularDataTechnology(QMIDataContextDriver *this)
{
  uint64_t v1;
  unint64_t *p_shared_owners;
  unint64_t v3;
  uint64_t v5;
  std::__shared_weak_count *v6;

  BBDataContextDriverInterface::getObserver((QMIDataContextDriver *)((char *)this + 24));
  v1 = (*(uint64_t (**)())(*(_QWORD *)v5 + 384))();
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v3 = __ldaxr(p_shared_owners);
    while (__stlxr(v3 - 1, p_shared_owners));
    if (!v3)
    {
      ((void (*)())v6->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  return v1;
}

void sub_216A98328(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t `non-virtual thunk to'QMIDataContextDriver::getCellularDataTechnology(QMIDataContextDriver *this)
{
  return QMIDataContextDriver::getCellularDataTechnology((QMIDataContextDriver *)((char *)this - 48));
}

void QMIDataContextDriver::setOutgoingTrafficEnabled(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t *p_shared_owners;
  unint64_t v8;
  uint64_t v9;
  std::__shared_weak_count *v10;

  BBDataContextDriverInterface::getObserver((BBDataContextDriverInterface *)(a1 + 24));
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v9 + 400))(v9, a2, a3, a4);
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)())v10->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v10);
    }
  }
}

void sub_216A983D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'QMIDataContextDriver::setOutgoingTrafficEnabled(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  QMIDataContextDriver::setOutgoingTrafficEnabled(a1 - 48, a2, a3, a4);
}

uint64_t QMIDataContextDriver::getHandoverPduSessionId(QMIDataContextDriver *this)
{
  uint64_t v1;
  unint64_t *p_shared_owners;
  unint64_t v3;
  uint64_t v5;
  std::__shared_weak_count *v6;

  BBDataContextDriverInterface::getObserver((QMIDataContextDriver *)((char *)this + 24));
  v1 = (*(uint64_t (**)())(*(_QWORD *)v5 + 144))();
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v3 = __ldaxr(p_shared_owners);
    while (__stlxr(v3 - 1, p_shared_owners));
    if (!v3)
    {
      ((void (*)())v6->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  return v1;
}

void sub_216A98470(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t `non-virtual thunk to'QMIDataContextDriver::getHandoverPduSessionId(QMIDataContextDriver *this)
{
  return QMIDataContextDriver::getHandoverPduSessionId((QMIDataContextDriver *)((char *)this - 48));
}

void QMIDataContextDriver::freePduSessionId(QMIDataContextDriver *this)
{
  unint64_t *p_shared_owners;
  unint64_t v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  BBDataContextDriverInterface::getObserver((QMIDataContextDriver *)((char *)this + 24));
  (*(void (**)())(*(_QWORD *)v3 + 152))();
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v2 = __ldaxr(p_shared_owners);
    while (__stlxr(v2 - 1, p_shared_owners));
    if (!v2)
    {
      ((void (*)())v4->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

void sub_216A98500(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'QMIDataContextDriver::freePduSessionId(QMIDataContextDriver *this)
{
  QMIDataContextDriver::freePduSessionId((QMIDataContextDriver *)((char *)this - 48));
}

uint64_t QMIDataContextDriver::getIwlanSnssai(QMIDataContextDriver *this)
{
  uint64_t v1;
  unint64_t *p_shared_owners;
  unint64_t v3;
  uint64_t v5;
  std::__shared_weak_count *v6;

  BBDataContextDriverInterface::getObserver((QMIDataContextDriver *)((char *)this + 24));
  v1 = (*(uint64_t (**)())(*(_QWORD *)v5 + 160))();
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v3 = __ldaxr(p_shared_owners);
    while (__stlxr(v3 - 1, p_shared_owners));
    if (!v3)
    {
      ((void (*)())v6->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  return v1;
}

void sub_216A98598(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t `non-virtual thunk to'QMIDataContextDriver::getIwlanSnssai(QMIDataContextDriver *this)
{
  return QMIDataContextDriver::getIwlanSnssai((QMIDataContextDriver *)((char *)this - 48));
}

void QMIDataContextDriver::updateHandoverPduSessionId(QMIDataContextDriver *this, uint64_t a2)
{
  unint64_t *p_shared_owners;
  unint64_t v4;
  uint64_t v5;
  std::__shared_weak_count *v6;

  BBDataContextDriverInterface::getObserver((QMIDataContextDriver *)((char *)this + 24));
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v5 + 168))(v5, a2);
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)())v6->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

void sub_216A98630(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'QMIDataContextDriver::updateHandoverPduSessionId(QMIDataContextDriver *this, uint64_t a2)
{
  QMIDataContextDriver::updateHandoverPduSessionId((QMIDataContextDriver *)((char *)this - 48), a2);
}

void QMIDataContextDriver::reportContextConnectionError(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t *p_shared_owners;
  unint64_t v6;
  uint64_t v7;
  std::__shared_weak_count *v8;

  BBDataContextDriverInterface::getObserver((BBDataContextDriverInterface *)(a1 + 24));
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v7 + 488))(v7, a2, a3);
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)())v8->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v8);
    }
  }
}

void sub_216A986D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'QMIDataContextDriver::reportContextConnectionError(uint64_t a1, uint64_t a2, uint64_t a3)
{
  QMIDataContextDriver::reportContextConnectionError(a1 - 48, a2, a3);
}

uint64_t QMIDataContextDriver::isOnProbation(QMIDataContextDriver *this)
{
  uint64_t v1;
  unint64_t *p_shared_owners;
  unint64_t v3;
  uint64_t v5;
  std::__shared_weak_count *v6;

  BBDataContextDriverInterface::getObserver((QMIDataContextDriver *)((char *)this + 24));
  v1 = (*(uint64_t (**)())(*(_QWORD *)v5 + 496))();
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v3 = __ldaxr(p_shared_owners);
    while (__stlxr(v3 - 1, p_shared_owners));
    if (!v3)
    {
      ((void (*)())v6->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  return v1;
}

void sub_216A98768(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t `non-virtual thunk to'QMIDataContextDriver::isOnProbation(QMIDataContextDriver *this)
{
  return QMIDataContextDriver::isOnProbation((QMIDataContextDriver *)((char *)this - 48));
}

uint64_t QMIDataContextDriver::isOnDNSProbation(QMIDataContextDriver *this)
{
  uint64_t v1;
  unint64_t *p_shared_owners;
  unint64_t v3;
  uint64_t v5;
  std::__shared_weak_count *v6;

  BBDataContextDriverInterface::getObserver((QMIDataContextDriver *)((char *)this + 24));
  v1 = (*(uint64_t (**)())(*(_QWORD *)v5 + 504))();
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v3 = __ldaxr(p_shared_owners);
    while (__stlxr(v3 - 1, p_shared_owners));
    if (!v3)
    {
      ((void (*)())v6->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  return v1;
}

void sub_216A98800(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t `non-virtual thunk to'QMIDataContextDriver::isOnDNSProbation(QMIDataContextDriver *this)
{
  return QMIDataContextDriver::isOnDNSProbation((QMIDataContextDriver *)((char *)this - 48));
}

void QMIDataContextDriver::setProbation(QMIDataContextDriver *this)
{
  unint64_t *p_shared_owners;
  unint64_t v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  BBDataContextDriverInterface::getObserver((QMIDataContextDriver *)((char *)this + 24));
  (*(void (**)())(*(_QWORD *)v3 + 512))();
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v2 = __ldaxr(p_shared_owners);
    while (__stlxr(v2 - 1, p_shared_owners));
    if (!v2)
    {
      ((void (*)())v4->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

void sub_216A98890(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'QMIDataContextDriver::setProbation(QMIDataContextDriver *this)
{
  QMIDataContextDriver::setProbation((QMIDataContextDriver *)((char *)this - 48));
}

void QMIDataContextDriver::handleActivatedIfReady(QMIDataContextDriver *this)
{
  unint64_t *p_shared_owners;
  unint64_t v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  BBDataContextDriverInterface::getObserver((QMIDataContextDriver *)((char *)this + 24));
  (*(void (**)())(*(_QWORD *)v3 + 520))();
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v2 = __ldaxr(p_shared_owners);
    while (__stlxr(v2 - 1, p_shared_owners));
    if (!v2)
    {
      ((void (*)())v4->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

void sub_216A98920(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'QMIDataContextDriver::handleActivatedIfReady(QMIDataContextDriver *this)
{
  QMIDataContextDriver::handleActivatedIfReady((QMIDataContextDriver *)((char *)this - 48));
}

void QMIDataContextDriver::setDeactivating(QMIDataContextDriver *this)
{
  unint64_t *p_shared_owners;
  unint64_t v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  BBDataContextDriverInterface::getObserver((QMIDataContextDriver *)((char *)this + 24));
  (*(void (**)())(*(_QWORD *)v3 + 528))();
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v2 = __ldaxr(p_shared_owners);
    while (__stlxr(v2 - 1, p_shared_owners));
    if (!v2)
    {
      ((void (*)())v4->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

void sub_216A989B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'QMIDataContextDriver::setDeactivating(QMIDataContextDriver *this)
{
  QMIDataContextDriver::setDeactivating((QMIDataContextDriver *)((char *)this - 48));
}

void `non-virtual thunk to'QMIDataContextDriver::getAPNObserver(QMIDataContextDriver *this)
{
  QMIDataContextDriver::getAPNObserver((QMIDataContextDriver *)((char *)this - 48));
}

void QMIDataContextDriver::copyValueFromCarrierBundleForKeyWithDefault(QMIDataContextDriver *this, const __CFString *a2, const void *a3, uint64_t a4)
{
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  uint64_t v14;
  std::__shared_weak_count *v15;

  BBDataContextDriverInterface::getObserver((QMIDataContextDriver *)((char *)this + 24));
  (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v12 + 472))(&v14);
  (*(void (**)(uint64_t, const __CFString *, const void *, uint64_t))(*(_QWORD *)v14 + 88))(v14, a2, a3, a4);
  v7 = v15;
  if (v15)
  {
    p_shared_owners = (unint64_t *)&v15->__shared_owners_;
    do
      v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  if (v13)
  {
    v10 = (unint64_t *)&v13->__shared_owners_;
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)())v13->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v13);
    }
  }
}

void sub_216A98ABC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'QMIDataContextDriver::copyValueFromCarrierBundleForKeyWithDefault(QMIDataContextDriver *this, const __CFString *a2, const void *a3, uint64_t a4)
{
  QMIDataContextDriver::copyValueFromCarrierBundleForKeyWithDefault((QMIDataContextDriver *)((char *)this - 48), a2, a3, a4);
}

uint64_t QMIDataContextDriver::supportsPDNAuthentication(QMIDataContextDriver *this)
{
  uint64_t v1;
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  uint64_t v8;
  std::__shared_weak_count *v9;
  uint64_t v10;
  std::__shared_weak_count *v11;

  BBDataContextDriverInterface::getObserver((QMIDataContextDriver *)((char *)this + 24));
  (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v8 + 472))(&v10);
  v1 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v10 + 56))(v10);
  v2 = v11;
  if (v11)
  {
    p_shared_owners = (unint64_t *)&v11->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  if (v9)
  {
    v5 = (unint64_t *)&v9->__shared_owners_;
    do
      v6 = __ldaxr(v5);
    while (__stlxr(v6 - 1, v5));
    if (!v6)
    {
      ((void (*)())v9->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  return v1;
}

void sub_216A98BB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t `non-virtual thunk to'QMIDataContextDriver::supportsPDNAuthentication(QMIDataContextDriver *this)
{
  return QMIDataContextDriver::supportsPDNAuthentication((QMIDataContextDriver *)((char *)this - 48));
}

uint64_t QMIDataContextDriver::alwaysUseIpv4v6(QMIDataContextDriver *this)
{
  uint64_t v1;
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  uint64_t v8;
  std::__shared_weak_count *v9;
  uint64_t v10;
  std::__shared_weak_count *v11;

  BBDataContextDriverInterface::getObserver((QMIDataContextDriver *)((char *)this + 24));
  (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v8 + 472))(&v10);
  v1 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v10 + 48))(v10);
  v2 = v11;
  if (v11)
  {
    p_shared_owners = (unint64_t *)&v11->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  if (v9)
  {
    v5 = (unint64_t *)&v9->__shared_owners_;
    do
      v6 = __ldaxr(v5);
    while (__stlxr(v6 - 1, v5));
    if (!v6)
    {
      ((void (*)())v9->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  return v1;
}

void sub_216A98CA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t `non-virtual thunk to'QMIDataContextDriver::alwaysUseIpv4v6(QMIDataContextDriver *this)
{
  return QMIDataContextDriver::alwaysUseIpv4v6((QMIDataContextDriver *)((char *)this - 48));
}

void QMIDataContextDriver::submitPDPContextStateChangeMetrics(QMIDataContextDriver *this)
{
  unint64_t *p_shared_owners;
  unint64_t v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  BBDataContextDriverInterface::getObserver((QMIDataContextDriver *)((char *)this + 24));
  (*(void (**)())(*(_QWORD *)v3 + 576))();
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v2 = __ldaxr(p_shared_owners);
    while (__stlxr(v2 - 1, p_shared_owners));
    if (!v2)
    {
      ((void (*)())v4->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

void sub_216A98D44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'QMIDataContextDriver::submitPDPContextStateChangeMetrics(QMIDataContextDriver *this)
{
  QMIDataContextDriver::submitPDPContextStateChangeMetrics((QMIDataContextDriver *)((char *)this - 48));
}

void QMIDataContextDriver::submitCommCenterIPSetupFailure(QMIDataContextDriver *this, uint64_t a2, uint64_t a3)
{
  unint64_t *p_shared_owners;
  unint64_t v6;
  uint64_t v7;
  std::__shared_weak_count *v8;

  BBDataContextDriverInterface::getObserver((QMIDataContextDriver *)((char *)this + 24));
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v7 + 600))(v7, a2, a3);
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)())v8->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v8);
    }
  }
}

void sub_216A98DE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'QMIDataContextDriver::submitCommCenterIPSetupFailure(QMIDataContextDriver *this, uint64_t a2, uint64_t a3)
{
  QMIDataContextDriver::submitCommCenterIPSetupFailure((QMIDataContextDriver *)((char *)this - 48), a2, a3);
}

void QMIDataContextDriver::handleDataContextIPDeactivatedDriver(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  BBDataContextDriverInterface *v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  NSObject *v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  __int128 v19;
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  v4 = *(NSObject **)(a1 + 88);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(v19) = 136315138;
    *(_QWORD *)((char *)&v19 + 4) = "handleDataContextIPDeactivatedDriver";
    _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I %s: start", (uint8_t *)&v19, 0xCu);
  }
  (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 152) + 120))(*(_QWORD *)(a1 + 152), a2);
  v5 = (BBDataContextDriverInterface *)(a1 + 24);
  BBDataContextDriverInterface::getObserver((BBDataContextDriverInterface *)(a1 + 24));
  (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)v19 + 432))(v19, a2);
  v6 = (std::__shared_weak_count *)*((_QWORD *)&v19 + 1);
  if (*((_QWORD *)&v19 + 1))
  {
    v7 = (unint64_t *)(*((_QWORD *)&v19 + 1) + 8);
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  if (!QMIDataContextDriver::getDataContextState(a1, 3))
  {
    v9 = *(NSObject **)(a1 + 88);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v19) = 136315138;
      *(_QWORD *)((char *)&v19 + 4) = "handleDataContextIPDeactivatedDriver";
      _os_log_impl(&dword_216897000, v9, OS_LOG_TYPE_DEFAULT, "#I %s: Done with this context", (uint8_t *)&v19, 0xCu);
    }
    BBDataContextDriverInterface::getObserver(v5);
    (*(void (**)(_QWORD))(*(_QWORD *)v19 + 560))(v19);
    v10 = (std::__shared_weak_count *)*((_QWORD *)&v19 + 1);
    if (*((_QWORD *)&v19 + 1))
    {
      v11 = (unint64_t *)(*((_QWORD *)&v19 + 1) + 8);
      do
        v12 = __ldaxr(v11);
      while (__stlxr(v12 - 1, v11));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
    BBDataContextDriverInterface::getObserver(v5);
    (*(void (**)(_QWORD))(*(_QWORD *)v19 + 344))(v19);
    v13 = (std::__shared_weak_count *)*((_QWORD *)&v19 + 1);
    if (*((_QWORD *)&v19 + 1))
    {
      v14 = (unint64_t *)(*((_QWORD *)&v19 + 1) + 8);
      do
        v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }
    BBDataContextDriverInterface::getObserver(v5);
    (*(void (**)(_QWORD))(*(_QWORD *)v19 + 544))(v19);
    v16 = (std::__shared_weak_count *)*((_QWORD *)&v19 + 1);
    if (*((_QWORD *)&v19 + 1))
    {
      v17 = (unint64_t *)(*((_QWORD *)&v19 + 1) + 8);
      do
        v18 = __ldaxr(v17);
      while (__stlxr(v18 - 1, v17));
      if (!v18)
      {
        ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
        std::__shared_weak_count::__release_weak(v16);
      }
    }
  }
}

void sub_216A9907C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'QMIDataContextDriver::handleDataContextIPDeactivatedDriver(uint64_t a1, uint64_t a2)
{
  QMIDataContextDriver::handleDataContextIPDeactivatedDriver(a1 - 24, a2);
}

{
  QMIDataContextDriver::handleDataContextIPDeactivatedDriver(a1 - 48, a2);
}

uint64_t `non-virtual thunk to'QMIDataContextDriver::deactivateDataContext(uint64_t a1, uint64_t a2, const std::string::value_type *a3)
{
  return QMIDataContextDriver::deactivateDataContext(a1 - 24, a2, a3);
}

uint64_t QMIDataContextDriver::suspendDataContext(QMIDataContextDriver *this)
{
  NSObject *v2;
  int v4;
  const char *v5;
  uint64_t v6;

  v6 = *MEMORY[0x24BDAC8D0];
  v2 = *((_QWORD *)this + 11);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v4 = 136315138;
    v5 = "suspendDataContext";
    _os_log_impl(&dword_216897000, v2, OS_LOG_TYPE_DEFAULT, "#I %s: start", (uint8_t *)&v4, 0xCu);
  }
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 19) + 144))(*((_QWORD *)this + 19));
}

uint64_t `non-virtual thunk to'QMIDataContextDriver::suspendDataContext(QMIDataContextDriver *this)
{
  return QMIDataContextDriver::suspendDataContext((QMIDataContextDriver *)((char *)this - 24));
}

uint64_t QMIDataContextDriver::resumeDataContext(QMIDataContextDriver *this)
{
  NSObject *v2;
  int v4;
  const char *v5;
  uint64_t v6;

  v6 = *MEMORY[0x24BDAC8D0];
  v2 = *((_QWORD *)this + 11);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v4 = 136315138;
    v5 = "resumeDataContext";
    _os_log_impl(&dword_216897000, v2, OS_LOG_TYPE_DEFAULT, "#I %s: start", (uint8_t *)&v4, 0xCu);
  }
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 19) + 152))(*((_QWORD *)this + 19));
}

uint64_t `non-virtual thunk to'QMIDataContextDriver::resumeDataContext(QMIDataContextDriver *this)
{
  return QMIDataContextDriver::resumeDataContext((QMIDataContextDriver *)((char *)this - 24));
}

uint64_t QMIDataContextDriver::resetDataContext(QMIDataContextDriver *this)
{
  NSObject *v2;
  int v4;
  const char *v5;
  uint64_t v6;

  v6 = *MEMORY[0x24BDAC8D0];
  v2 = *((_QWORD *)this + 11);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v4 = 136315138;
    v5 = "resetDataContext";
    _os_log_impl(&dword_216897000, v2, OS_LOG_TYPE_DEFAULT, "#I %s: start", (uint8_t *)&v4, 0xCu);
  }
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 19) + 160))(*((_QWORD *)this + 19));
}

uint64_t `non-virtual thunk to'QMIDataContextDriver::resetDataContext(QMIDataContextDriver *this)
{
  return QMIDataContextDriver::resetDataContext((QMIDataContextDriver *)((char *)this - 24));
}

_QWORD *QMIDataContextDriver::createQoSClientOnDemand(_QWORD *result, int a2)
{
  uint64_t v2;

  v2 = result[21];
  if (a2 == 2)
  {
    result = *(_QWORD **)(v2 + 112);
    if (result)
      return (_QWORD *)(*(uint64_t (**)(_QWORD *))(*result + 48))(result);
  }
  else if (a2 == 1)
  {
    result = *(_QWORD **)(v2 + 96);
    if (result)
      return (_QWORD *)(*(uint64_t (**)(_QWORD *))(*result + 48))(result);
  }
  return result;
}

_QWORD *`non-virtual thunk to'QMIDataContextDriver::createQoSClientOnDemand(_QWORD *result, int a2)
{
  uint64_t v2;

  v2 = result[15];
  if (a2 == 2)
  {
    result = *(_QWORD **)(v2 + 112);
    if (result)
      return (_QWORD *)(*(uint64_t (**)(_QWORD *))(*result + 48))(result);
  }
  else if (a2 == 1)
  {
    result = *(_QWORD **)(v2 + 96);
    if (result)
      return (_QWORD *)(*(uint64_t (**)(_QWORD *))(*result + 48))(result);
  }
  return result;
}

_QWORD *QMIDataContextDriver::releaseQoSClient(_QWORD *result, int a2)
{
  uint64_t v2;

  v2 = result[21];
  if (a2 == 2)
  {
    result = *(_QWORD **)(v2 + 112);
    if (result)
      return (_QWORD *)(*(uint64_t (**)(_QWORD *))(*result + 56))(result);
  }
  else if (a2 == 1)
  {
    result = *(_QWORD **)(v2 + 96);
    if (result)
      return (_QWORD *)(*(uint64_t (**)(_QWORD *))(*result + 56))(result);
  }
  return result;
}

_QWORD *`non-virtual thunk to'QMIDataContextDriver::releaseQoSClient(_QWORD *result, int a2)
{
  uint64_t v2;

  v2 = result[15];
  if (a2 == 2)
  {
    result = *(_QWORD **)(v2 + 112);
    if (result)
      return (_QWORD *)(*(uint64_t (**)(_QWORD *))(*result + 56))(result);
  }
  else if (a2 == 1)
  {
    result = *(_QWORD **)(v2 + 96);
    if (result)
      return (_QWORD *)(*(uint64_t (**)(_QWORD *))(*result + 56))(result);
  }
  return result;
}

uint64_t QMIDataContextDriver::requestQos(uint64_t a1, uint64_t a2, uint64_t a3, const void **a4, uint64_t a5)
{
  _QWORD *v8;
  uint64_t v9;
  const void *v11;

  v8 = *(_QWORD **)(a1 + 168);
  ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::SharedRef(&v11, a4);
  v9 = QMIDataQOSHelper::requestQos(v8, a2, a3, &v11, a5);
  ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef(&v11);
  return v9;
}

void sub_216A99420(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t `non-virtual thunk to'QMIDataContextDriver::requestQos(uint64_t a1, uint64_t a2, uint64_t a3, const void **a4, uint64_t a5)
{
  return QMIDataContextDriver::requestQos(a1 - 24, a2, a3, a4, a5);
}

void QMIDataContextDriver::releaseQos(uint64_t a1, int a2, uint64_t a3)
{
  QMIDataQOSHelper::releaseQos(*(_QWORD **)(a1 + 168), a2, a3);
}

void `non-virtual thunk to'QMIDataContextDriver::releaseQos(uint64_t a1, int a2, uint64_t a3)
{
  QMIDataQOSHelper::releaseQos(*(_QWORD **)(a1 + 144), a2, a3);
}

const void **QMIDataContextDriver::setPacketNotificationFilter(uint64_t a1, uint64_t a2, const void **a3)
{
  uint64_t v4;
  const void *v6;

  v4 = *(_QWORD *)(a1 + 152);
  ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::SharedRef(&v6, a3);
  (*(void (**)(uint64_t, uint64_t, const void **))(*(_QWORD *)v4 + 208))(v4, a2, &v6);
  return ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef(&v6);
}

void sub_216A994A0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::~SharedRef((const void **)va);
  _Unwind_Resume(a1);
}

const void **`non-virtual thunk to'QMIDataContextDriver::setPacketNotificationFilter(uint64_t a1, uint64_t a2, const void **a3)
{
  return QMIDataContextDriver::setPacketNotificationFilter(a1 - 24, a2, a3);
}

const void **QMIDataContextDriver::dropIPPackets(uint64_t a1, const void **a2, uint64_t a3)
{
  uint64_t v4;
  const void *v6;

  v4 = *(_QWORD *)(a1 + 152);
  ctu::SharedRef<__CFArray const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFArray const>::SharedRef(&v6, a2);
  (*(void (**)(uint64_t, const void **, uint64_t))(*(_QWORD *)v4 + 192))(v4, &v6, a3);
  return ctu::SharedRef<__CFArray const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFArray const>::~SharedRef(&v6);
}

void sub_216A9950C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  ctu::SharedRef<__CFArray const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFArray const>::~SharedRef((const void **)va);
  _Unwind_Resume(a1);
}

const void **`non-virtual thunk to'QMIDataContextDriver::dropIPPackets(uint64_t a1, const void **a2, uint64_t a3)
{
  return QMIDataContextDriver::dropIPPackets(a1 - 24, a2, a3);
}

uint64_t QMIDataContextDriver::dropIMSPackets(QMIDataContextDriver *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 19) + 200))(*((_QWORD *)this + 19));
}

uint64_t `non-virtual thunk to'QMIDataContextDriver::dropIMSPackets(QMIDataContextDriver *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 16) + 200))(*((_QWORD *)this + 16));
}

uint64_t QMIDataContextDriver::setQuality(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 152) + 184))(*(_QWORD *)(a1 + 152));
}

uint64_t `non-virtual thunk to'QMIDataContextDriver::setQuality(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 128) + 184))(*(_QWORD *)(a1 + 128));
}

uint64_t QMIDataContextDriver::shutDownContextDriver(QMIDataContextDriver *this)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t result;
  int v6;
  const char *v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  v2 = *((_QWORD *)this + 11);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v6 = 136315138;
    v7 = "shutDownContextDriver";
    _os_log_impl(&dword_216897000, v2, OS_LOG_TYPE_DEFAULT, "#I %s: start", (uint8_t *)&v6, 0xCu);
  }
  *((_BYTE *)this + 392) = 1;
  (*(void (**)(_QWORD))(**((_QWORD **)this + 19) + 216))(*((_QWORD *)this + 19));
  v3 = *((_QWORD *)this + 21);
  v4 = *(_QWORD *)(v3 + 96);
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 32))(v4);
  result = *(_QWORD *)(v3 + 112);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 32))(result);
  return result;
}

uint64_t `non-virtual thunk to'QMIDataContextDriver::shutDownContextDriver(QMIDataContextDriver *this)
{
  return QMIDataContextDriver::shutDownContextDriver((QMIDataContextDriver *)((char *)this - 24));
}

uint64_t QMIDataContextDriver::ipv6ServiceUp(QMIDataContextDriver *this, const CSIPacketAddress *a2)
{
  NSObject *v4;
  void *p_p;
  void *__p;
  char v8;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  void *v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v4 = *((_QWORD *)this + 11);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    CSIPacketAddress::operator std::string();
    if (v8 >= 0)
      p_p = &__p;
    else
      p_p = __p;
    *(_DWORD *)buf = 136315394;
    v10 = "ipv6ServiceUp";
    v11 = 2080;
    v12 = p_p;
    _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I %s:  %s ", buf, 0x16u);
    if (v8 < 0)
      operator delete(__p);
  }
  return (*(uint64_t (**)(_QWORD, const CSIPacketAddress *))(**((_QWORD **)this + 19) + 176))(*((_QWORD *)this + 19), a2);
}

uint64_t `non-virtual thunk to'QMIDataContextDriver::ipv6ServiceUp(QMIDataContextDriver *this, const CSIPacketAddress *a2)
{
  return QMIDataContextDriver::ipv6ServiceUp((QMIDataContextDriver *)((char *)this - 24), a2);
}

uint64_t QMIDataContextDriver::ipv4ServiceUp(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 152) + 168))(*(_QWORD *)(a1 + 152));
}

uint64_t `non-virtual thunk to'QMIDataContextDriver::ipv4ServiceUp(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 128) + 168))(*(_QWORD *)(a1 + 128));
}

uint64_t QMIDataContextDriver::getPdpId(QMIDataContextDriver *this)
{
  uint64_t v1;
  unint64_t *p_shared_owners;
  unint64_t v3;
  uint64_t v5;
  std::__shared_weak_count *v6;

  BBDataContextDriverInterface::getObserver((QMIDataContextDriver *)((char *)this + 24));
  v1 = (*(uint64_t (**)())(*(_QWORD *)v5 + 64))();
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v3 = __ldaxr(p_shared_owners);
    while (__stlxr(v3 - 1, p_shared_owners));
    if (!v3)
    {
      ((void (*)())v6->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  return v1;
}

void sub_216A997F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t `non-virtual thunk to'QMIDataContextDriver::getPdpId(QMIDataContextDriver *this)
{
  return QMIDataContextDriver::getPdpId((QMIDataContextDriver *)((char *)this - 24));
}

{
  return QMIDataContextDriver::getPdpId((QMIDataContextDriver *)((char *)this - 48));
}

uint64_t QMIDataContextDriver::getAllowedIpFamily(QMIDataContextDriver *this)
{
  uint64_t v1;
  unint64_t *p_shared_owners;
  unint64_t v3;
  uint64_t v5;
  std::__shared_weak_count *v6;

  BBDataContextDriverInterface::getObserver((QMIDataContextDriver *)((char *)this + 24));
  v1 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v5 + 120))(v5, 0);
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v3 = __ldaxr(p_shared_owners);
    while (__stlxr(v3 - 1, p_shared_owners));
    if (!v3)
    {
      ((void (*)())v6->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  return v1;
}

void sub_216A9989C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t `non-virtual thunk to'QMIDataContextDriver::getAllowedIpFamily(QMIDataContextDriver *this)
{
  return QMIDataContextDriver::getAllowedIpFamily((QMIDataContextDriver *)((char *)this - 48));
}

uint64_t QMIDataContextDriver::isImsSupported(QMIDataContextDriver *this)
{
  unint64_t *p_shared_owners;
  unint64_t v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *v5;
  unint64_t v6;
  uint64_t v8;
  std::__shared_weak_count *v9;
  uint64_t v10;
  std::__shared_weak_count *v11;

  v10 = 0;
  v11 = 0;
  BBDataContextDriverInterface::getObserver((QMIDataContextDriver *)((char *)this + 24));
  (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v8 + 392))(&v10);
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v2 = __ldaxr(p_shared_owners);
    while (__stlxr(v2 - 1, p_shared_owners));
    if (!v2)
    {
      ((void (*)())v9->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  if (v10)
    v3 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v10 + 56))(v10, 0);
  else
    v3 = 0;
  v4 = v11;
  if (v11)
  {
    v5 = (unint64_t *)&v11->__shared_owners_;
    do
      v6 = __ldaxr(v5);
    while (__stlxr(v6 - 1, v5));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  return v3;
}

void sub_216A99994(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t `non-virtual thunk to'QMIDataContextDriver::isImsSupported(QMIDataContextDriver *this)
{
  return QMIDataContextDriver::isImsSupported((QMIDataContextDriver *)((char *)this - 24));
}

uint64_t QMIDataContextDriver::dumpStateDriver(QMIDataContextDriver *this)
{
  NSObject *v2;
  _QWORD *v3;
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  int v7;
  _QWORD *v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v2 = *((_QWORD *)this + 11);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v3 = (_QWORD *)((char *)this + 96);
    if (*((char *)this + 119) < 0)
      v3 = (_QWORD *)*v3;
    v7 = 136315138;
    v8 = v3;
    _os_log_impl(&dword_216897000, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: ------- %s (driver) -------", (uint8_t *)&v7, 0xCu);
  }
  result = *((_QWORD *)this + 19);
  if (result)
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 272))(result);
  v5 = *((_QWORD *)this + 21);
  if (v5)
  {
    v6 = *(_QWORD *)(v5 + 96);
    if (v6)
      (*(void (**)(uint64_t))(*(_QWORD *)v6 + 40))(v6);
    result = *(_QWORD *)(v5 + 112);
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
  }
  return result;
}

uint64_t `non-virtual thunk to'QMIDataContextDriver::dumpStateDriver(QMIDataContextDriver *this)
{
  return QMIDataContextDriver::dumpStateDriver((QMIDataContextDriver *)((char *)this - 24));
}

uint64_t QMIDataContextDriver::isInLoopBackMode(QMIDataContextDriver *this)
{
  uint64_t v1;
  unint64_t *p_shared_owners;
  unint64_t v3;
  uint64_t v5;
  std::__shared_weak_count *v6;

  BBDataContextDriverInterface::getObserver((QMIDataContextDriver *)((char *)this + 24));
  v1 = (*(uint64_t (**)())(*(_QWORD *)v5 + 616))();
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v3 = __ldaxr(p_shared_owners);
    while (__stlxr(v3 - 1, p_shared_owners));
    if (!v3)
    {
      ((void (*)())v6->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  return v1;
}

void sub_216A99B30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t `non-virtual thunk to'QMIDataContextDriver::isInLoopBackMode(QMIDataContextDriver *this)
{
  return QMIDataContextDriver::isInLoopBackMode((QMIDataContextDriver *)((char *)this - 48));
}

void QMIDataContextDriver::updateLastActiveProfileConnectionMask(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t *p_shared_owners;
  unint64_t v6;
  uint64_t v7;
  std::__shared_weak_count *v8;

  BBDataContextDriverInterface::getObserver((BBDataContextDriverInterface *)(a1 + 24));
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v7 + 624))(v7, a2, a3);
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)())v8->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v8);
    }
  }
}

void sub_216A99BD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'QMIDataContextDriver::updateLastActiveProfileConnectionMask(uint64_t a1, uint64_t a2, uint64_t a3)
{
  QMIDataContextDriver::updateLastActiveProfileConnectionMask(a1 - 48, a2, a3);
}

uint64_t QMIDataContextDriver::handleBasebandRefreshComplete(QMIDataContextDriver *this)
{
  NSObject *v2;
  uint64_t result;
  uint8_t v4[16];

  v2 = *((_QWORD *)this + 11);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v4 = 0;
    _os_log_impl(&dword_216897000, v2, OS_LOG_TYPE_DEFAULT, "#I recevied rest baseband_refresh_complete event", v4, 2u);
  }
  result = *((_QWORD *)this + 19);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 280))(result);
  return result;
}

uint64_t `non-virtual thunk to'QMIDataContextDriver::handleBasebandRefreshComplete(QMIDataContextDriver *this)
{
  return QMIDataContextDriver::handleBasebandRefreshComplete((QMIDataContextDriver *)((char *)this - 24));
}

void QMIDataContextDriver::sendServiceDisconnectionStatus_sync(uint64_t a1, uint64_t a2)
{
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  char *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;

  v3 = *(std::__shared_weak_count **)(a1 + 192);
  if (v3)
  {
    v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      v6 = v5;
      v7 = *(char **)(a1 + 184);
      if (v7)
        (*(void (**)(char *, uint64_t))(*(_QWORD *)&v7[*(_QWORD *)(*(_QWORD *)v7 - 320)] + 288))(&v7[*(_QWORD *)(*(_QWORD *)v7 - 320)], a2);
      p_shared_owners = (unint64_t *)&v6->__shared_owners_;
      do
        v9 = __ldaxr(p_shared_owners);
      while (__stlxr(v9 - 1, p_shared_owners));
      if (!v9)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
  }
}

void sub_216A99D1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'QMIDataContextDriver::sendServiceDisconnectionStatus_sync(uint64_t a1, uint64_t a2)
{
  QMIDataContextDriver::sendServiceDisconnectionStatus_sync(a1 - 48, a2);
}

uint64_t QMIDataContextDriver::updateVoLTEDataCallType(QMIDataContextDriver *this, uint64_t a2)
{
  NSObject *v4;
  uint64_t result;
  uint8_t v6[16];

  v4 = *((_QWORD *)this + 11);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v6 = 0;
    _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I Updating VolTE call data type", v6, 2u);
  }
  result = *((_QWORD *)this + 19);
  if (result)
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)result + 112))(result, a2);
  return result;
}

uint64_t `non-virtual thunk to'QMIDataContextDriver::updateVoLTEDataCallType(QMIDataContextDriver *this, uint64_t a2)
{
  return QMIDataContextDriver::updateVoLTEDataCallType((QMIDataContextDriver *)((char *)this - 24), a2);
}

uint64_t QMIDataContextDriver::deactivateDataContextOtherActive()
{
  return 1;
}

uint64_t QMIDataContextDriver::addLLFilters_sync(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  char v6;

  v6 = 0;
  v4 = *(_QWORD *)(a4 + 24);
  if (!v4)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, char *))(*(_QWORD *)v4 + 48))(v4, &v6);
}

uint64_t QMIDataContextDriver::delLLFilters_sync(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  char v6;

  v6 = 0;
  v4 = *(_QWORD *)(a4 + 24);
  if (!v4)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, char *))(*(_QWORD *)v4 + 48))(v4, &v6);
}

void QMIDataContextDriver::getLLFilters_sync(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  _QWORD v4[3];
  void **v5;

  memset(v4, 0, sizeof(v4));
  v3 = *(_QWORD *)(a3 + 24);
  if (!v3)
    std::__throw_bad_function_call[abi:ne180100]();
  (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v3 + 48))(v3, v4);
  v5 = (void **)v4;
  std::vector<DataIPFilter>::__destroy_vector::operator()[abi:ne180100](&v5);
}

void sub_216A99E94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  std::vector<DataIPFilter>::__destroy_vector::operator()[abi:ne180100](&a12);
  _Unwind_Resume(a1);
}

uint64_t `non-virtual thunk to'QMIDataContextDriver::deactivateDataContextOtherActive()
{
  return 1;
}

uint64_t `non-virtual thunk to'QMIDataContextDriver::addLLFilters_sync(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  char v6;

  v6 = 0;
  v4 = *(_QWORD *)(a4 + 24);
  if (!v4)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, char *))(*(_QWORD *)v4 + 48))(v4, &v6);
}

uint64_t `non-virtual thunk to'QMIDataContextDriver::delLLFilters_sync(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  char v6;

  v6 = 0;
  v4 = *(_QWORD *)(a4 + 24);
  if (!v4)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, char *))(*(_QWORD *)v4 + 48))(v4, &v6);
}

void std::__shared_ptr_emplace<QMIDataQOSHelper>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5ED330;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMIDataQOSHelper>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5ED330;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

uint64_t std::__shared_ptr_emplace<QMIDataQOSHelper>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

_QWORD *std::vector<DataConnectionTraits>::__init_with_size[abi:ne180100]<DataConnectionTraits*,DataConnectionTraits*>(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v5;
  _QWORD *v8;
  size_t v9;

  if (a4)
  {
    v5 = result;
    if (a4 >= 0x1555555555555556)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    result = operator new(12 * a4);
    v8 = result;
    *v5 = result;
    v5[1] = result;
    v5[2] = (char *)result + 12 * a4;
    v9 = a3 - (_QWORD)a2;
    if (v9)
      result = memcpy(result, a2, v9);
    v5[1] = (char *)v8 + v9;
  }
  return result;
}

void sub_216A9A014(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<QMIDataContextDriver *,std::shared_ptr<QMIDataContextDriver> ctu::SharedSynchronizable<QMIDataContextDriver>::make_shared_ptr<QMIDataContextDriver>(QMIDataContextDriver*)::{lambda(QMIDataContextDriver *)#1},std::allocator<QMIDataContextDriver>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void std::__shared_ptr_pointer<QMIDataContextDriver *,std::shared_ptr<QMIDataContextDriver> ctu::SharedSynchronizable<QMIDataContextDriver>::make_shared_ptr<QMIDataContextDriver>(QMIDataContextDriver*)::{lambda(QMIDataContextDriver *)#1},std::allocator<QMIDataContextDriver>>::__on_zero_shared(uint64_t a1)
{
  dispatch_barrier_async_f(*(dispatch_queue_t *)(*(_QWORD *)(a1 + 24) + 72), *(void **)(a1 + 24), (dispatch_function_t)std::shared_ptr<QMIDataContextDriver> ctu::SharedSynchronizable<QMIDataContextDriver>::make_shared_ptr<QMIDataContextDriver>(QMIDataContextDriver*)::{lambda(QMIDataContextDriver*)#1}::operator() const(QMIDataContextDriver*)::{lambda(void *)#1}::__invoke);
}

uint64_t std::__shared_ptr_pointer<QMIDataContextDriver *,std::shared_ptr<QMIDataContextDriver> ctu::SharedSynchronizable<QMIDataContextDriver>::make_shared_ptr<QMIDataContextDriver>(QMIDataContextDriver*)::{lambda(QMIDataContextDriver *)#1},std::allocator<QMIDataContextDriver>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t std::shared_ptr<QMIDataContextDriver> ctu::SharedSynchronizable<QMIDataContextDriver>::make_shared_ptr<QMIDataContextDriver>(QMIDataContextDriver*)::{lambda(QMIDataContextDriver*)#1}::operator() const(QMIDataContextDriver*)::{lambda(void *)#1}::__invoke(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

void CFArrayApplyFunction(CFArrayRef theArray, CFRange range, CFArrayApplierFunction applier, void *context)
{
  MEMORY[0x24BDBB7D8](theArray, range.location, range.length, applier, context);
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return MEMORY[0x24BDBB820](theArray);
}

CFTypeID CFArrayGetTypeID(void)
{
  return MEMORY[0x24BDBB850]();
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return (const void *)MEMORY[0x24BDBB860](theArray, idx);
}

CFTypeID CFBooleanGetTypeID(void)
{
  return MEMORY[0x24BDBBA18]();
}

const UInt8 *__cdecl CFDataGetBytePtr(CFDataRef theData)
{
  return (const UInt8 *)MEMORY[0x24BDBBCE0](theData);
}

CFIndex CFDataGetLength(CFDataRef theData)
{
  return MEMORY[0x24BDBBCF8](theData);
}

CFTypeID CFDataGetTypeID(void)
{
  return MEMORY[0x24BDBBD08]();
}

void CFDictionaryAddValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
  MEMORY[0x24BDBBDB0](theDict, key, value);
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFMutableDictionaryRef)MEMORY[0x24BDBBDF0](allocator, capacity, keyCallBacks, valueCallBacks);
}

CFTypeID CFDictionaryGetTypeID(void)
{
  return MEMORY[0x24BDBBE18]();
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return (const void *)MEMORY[0x24BDBBE30](theDict, key);
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return MEMORY[0x24BDBBEF8](cf);
}

CFTypeID CFNumberGetTypeID(void)
{
  return MEMORY[0x24BDBC118]();
}

Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
{
  return MEMORY[0x24BDBC130](number, theType, valuePtr);
}

void CFRelease(CFTypeRef cf)
{
  MEMORY[0x24BDBC298](cf);
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return (CFTypeRef)MEMORY[0x24BDBC2A8](cf);
}

CFStringRef CFStringCreateWithBytes(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalRepresentation)
{
  return (CFStringRef)MEMORY[0x24BDBC558](alloc, bytes, numBytes, *(_QWORD *)&encoding, isExternalRepresentation);
}

Boolean CFStringGetCString(CFStringRef theString, char *buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  return MEMORY[0x24BDBC600](theString, buffer, bufferSize, *(_QWORD *)&encoding);
}

CFTypeID CFStringGetTypeID(void)
{
  return MEMORY[0x24BDBC698]();
}

CFUUIDRef CFUUIDCreateWithBytes(CFAllocatorRef alloc, UInt8 byte0, UInt8 byte1, UInt8 byte2, UInt8 byte3, UInt8 byte4, UInt8 byte5, UInt8 byte6, UInt8 byte7, UInt8 byte8, UInt8 byte9, UInt8 byte10, UInt8 byte11, UInt8 byte12, UInt8 byte13, UInt8 byte14, UInt8 byte15)
{
  return (CFUUIDRef)MEMORY[0x24BDBC8F0](alloc, byte0, byte1, byte2, byte3, byte4, byte5, byte6);
}

CFUUIDBytes CFUUIDGetUUIDBytes(CFUUIDRef uuid)
{
  uint64_t v1;
  uint64_t v2;
  CFUUIDBytes result;

  v1 = MEMORY[0x24BDBC908](uuid);
  result.byte8 = v2;
  result.byte9 = BYTE1(v2);
  result.byte10 = BYTE2(v2);
  result.byte11 = BYTE3(v2);
  result.byte12 = BYTE4(v2);
  result.byte13 = BYTE5(v2);
  result.byte14 = BYTE6(v2);
  result.byte15 = HIBYTE(v2);
  result.byte0 = v1;
  result.byte1 = BYTE1(v1);
  result.byte2 = BYTE2(v1);
  result.byte3 = BYTE3(v1);
  result.byte4 = BYTE4(v1);
  result.byte5 = BYTE5(v1);
  result.byte6 = BYTE6(v1);
  result.byte7 = HIBYTE(v1);
  return result;
}

uint64_t CSIErrorString()
{
  return MEMORY[0x24BDC3198]();
}

uint64_t CSIEventString()
{
  return MEMORY[0x24BDC31A0]();
}

void *__cdecl _Block_copy(const void *aBlock)
{
  return (void *)MEMORY[0x24BDAC720](aBlock);
}

void _Block_object_dispose(const void *a1, const int a2)
{
  MEMORY[0x24BDAC730](a1, *(_QWORD *)&a2);
}

void _Block_release(const void *aBlock)
{
  MEMORY[0x24BDAC738](aBlock);
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
  MEMORY[0x24BDAC780](exception_object);
}

uint64_t createPLMN()
{
  return MEMORY[0x24BDC31A8]();
}

uint64_t getCSIError()
{
  return MEMORY[0x24BDC31B0]();
}

uint64_t getDSReason()
{
  return MEMORY[0x24BDC31B8]();
}

uint64_t asStringBool()
{
  return MEMORY[0x24BDC31C8]();
}

{
  return MEMORY[0x24BDC31D0]();
}

uint64_t decodeString()
{
  return MEMORY[0x24BDC31E0]();
}

{
  return MEMORY[0x24BDC31E8]();
}

uint64_t sGetEmptyAddrs(void)
{
  return MEMORY[0x24BDC31F8]();
}

uint64_t shouldRetrySMS()
{
  return MEMORY[0x24BDC3200]();
}

uint64_t CSIBOOLAsString()
{
  return MEMORY[0x24BDC3208]();
}

uint64_t read_rest_value()
{
  return MEMORY[0x24BDC3210]();
}

uint64_t CSIDateToSeconds()
{
  return MEMORY[0x24BDC3230]();
}

uint64_t VinylSlotIdToInt()
{
  return MEMORY[0x24BDC3240]();
}

uint64_t appendDataSoMask()
{
  return MEMORY[0x24BDC3248]();
}

uint64_t write_rest_value()
{
  return MEMORY[0x24BDC3F08]();
}

{
  return MEMORY[0x24BDC3258]();
}

uint64_t ratSelectionAsStr()
{
  return MEMORY[0x24BDC3260]();
}

uint64_t VinylSlotIdFromInt()
{
  return MEMORY[0x24BDC3268]();
}

uint64_t asStringDataSoMask()
{
  return MEMORY[0x24BDC3270]();
}

uint64_t dataUiModifierMask()
{
  return MEMORY[0x24BDC3278]();
}

uint64_t decodeOperatorName()
{
  return MEMORY[0x24BDC3F10]();
}

uint64_t is5GDataTechnology()
{
  return MEMORY[0x24BDC3280]();
}

uint64_t attachApnClientName()
{
  return MEMORY[0x24BDC3298]();
}

uint64_t asWirelessTechnology()
{
  return MEMORY[0x24BDC32B8]();
}

uint64_t callTechnologyToString()
{
  return MEMORY[0x24BDC32D8]();
}

uint64_t numberContainsAlphabet()
{
  return MEMORY[0x24BDC32E0]();
}

uint64_t sGetEmptyPDPMetricInfo(void)
{
  return MEMORY[0x24BDC32E8]();
}

uint64_t PersonalityIdFromSlotId()
{
  return MEMORY[0x24BDC32F0]();
}

uint64_t sVinylProfileIdAsString()
{
  return MEMORY[0x24BDC32F8]();
}

uint64_t convertMaskToBandsForRat()
{
  return MEMORY[0x24BDC3F20]();
}

uint64_t decodeBCDExtendedAddress()
{
  return MEMORY[0x24BDC3300]();
}

uint64_t DevicePersistentCopyValue(const __CFString *a1, const void *a2)
{
  return MEMORY[0x24BDC3308](a1, a2);
}

uint64_t WirelessTechnologyAsString()
{
  return MEMORY[0x24BDC3328]();
}

uint64_t convertOtaspStatusToString()
{
  return MEMORY[0x24BDC3330]();
}

uint64_t convertWirelessTechnologyToCallTechnology()
{
  return MEMORY[0x24BDC3348]();
}

uint64_t asString()
{
  return MEMORY[0x24BDC3360]();
}

{
  return MEMORY[0x24BDC3370]();
}

{
  return MEMORY[0x24BDC3378]();
}

{
  return MEMORY[0x24BDC3F28]();
}

{
  return MEMORY[0x24BDC3390]();
}

{
  return MEMORY[0x24BDC33A8]();
}

{
  return MEMORY[0x24BDC33B0]();
}

{
  return MEMORY[0x24BDC33D0]();
}

{
  return MEMORY[0x24BDC33D8]();
}

{
  return MEMORY[0x24BDC33E0]();
}

{
  return MEMORY[0x24BDC33F0]();
}

{
  return MEMORY[0x24BDC33F8]();
}

{
  return MEMORY[0x24BDC3400]();
}

{
  return MEMORY[0x24BDC3408]();
}

{
  return MEMORY[0x24BDC3410]();
}

{
  return MEMORY[0x24BDC3418]();
}

{
  return MEMORY[0x24BDC3420]();
}

{
  return MEMORY[0x24BDC3428]();
}

{
  return MEMORY[0x24BDC3448]();
}

{
  return MEMORY[0x24BDC3450]();
}

{
  return MEMORY[0x24BDC3458]();
}

{
  return MEMORY[0x24BDC3460]();
}

{
  return MEMORY[0x24BDC3470]();
}

{
  return MEMORY[0x24BDC3480]();
}

{
  return MEMORY[0x24BDC3490]();
}

{
  return MEMORY[0x24BDC3498]();
}

{
  return MEMORY[0x24BDC34A8]();
}

{
  return MEMORY[0x24BDC34B0]();
}

{
  return MEMORY[0x24BDC34B8]();
}

{
  return MEMORY[0x24BDC34C8]();
}

{
  return MEMORY[0x24BDC34D0]();
}

{
  return MEMORY[0x24BDC34E0]();
}

uint64_t isCdmaRat()
{
  return MEMORY[0x24BDC34E8]();
}

uint64_t printUuid()
{
  return MEMORY[0x24BDC34F8]();
}

void SelectItem::~SelectItem(SelectItem *this)
{
  MEMORY[0x24BDC3F48](this);
}

uint64_t subscriber::SimCardInfo::SimCardInfo()
{
  return MEMORY[0x24BDC3508]();
}

uint64_t subscriber::encodeIccid()
{
  return MEMORY[0x24BDC3510]();
}

uint64_t subscriber::isSimSettled()
{
  return MEMORY[0x24BDC3528]();
}

uint64_t subscriber::sDecodeIccid(subscriber *this, const unsigned __int8 *a2)
{
  return MEMORY[0x24BDC3530](this, a2);
}

uint64_t subscriber::isEsimCapable()
{
  return MEMORY[0x24BDC3540]();
}

uint64_t subscriber::getSimFilePath()
{
  return MEMORY[0x24BDC3F50]();
}

uint64_t subscriber::isValidSimSlot()
{
  return MEMORY[0x24BDC3550]();
}

uint64_t subscriber::markNotPresent()
{
  return MEMORY[0x24BDC3F58]();
}

uint64_t subscriber::isFileIdInvalid()
{
  return MEMORY[0x24BDC3F60]();
}

uint64_t subscriber::SimCommandDriver::parseEapAka()
{
  return MEMORY[0x24BDC3F68]();
}

uint64_t subscriber::SimCommandDriver::parseEapSim()
{
  return MEMORY[0x24BDC3F70]();
}

uint64_t subscriber::SimCommandDriver::parseImsAka()
{
  return MEMORY[0x24BDC3F78]();
}

uint64_t subscriber::SimCommandDriver::parseImsGbaBs()
{
  return MEMORY[0x24BDC3F80]();
}

uint64_t subscriber::SimCommandDriver::parseImsGbaNaf()
{
  return MEMORY[0x24BDC3F88]();
}

uint64_t subscriber::SimCommandDriver::SimCommandDriver()
{
  return MEMORY[0x24BDC3F90]();
}

void subscriber::SimCommandDriver::~SimCommandDriver(subscriber::SimCommandDriver *this)
{
  MEMORY[0x24BDC3F98](this);
}

uint64_t subscriber::expectedSimCount()
{
  return MEMORY[0x24BDC3560]();
}

uint64_t subscriber::makeSimSlotRange()
{
  return MEMORY[0x24BDC3570]();
}

uint64_t subscriber::instanceAsSimSlot(subscriber *this)
{
  return MEMORY[0x24BDC3578](this);
}

uint64_t subscriber::simSlotAsInstance()
{
  return MEMORY[0x24BDC3580]();
}

uint64_t subscriber::isCardResultSW1Good(subscriber *this)
{
  return MEMORY[0x24BDC3FA0](this);
}

uint64_t subscriber::maybeMarkNotPresent()
{
  return MEMORY[0x24BDC3FA8]();
}

uint64_t subscriber::isSet()
{
  return MEMORY[0x24BDC3FB0]();
}

uint64_t subscriber::asString()
{
  return MEMORY[0x24BDC3598]();
}

{
  return MEMORY[0x24BDC35A0]();
}

{
  return MEMORY[0x24BDC35A8]();
}

{
  return MEMORY[0x24BDC35B8]();
}

{
  return MEMORY[0x24BDC35C0]();
}

{
  return MEMORY[0x24BDC35C8]();
}

{
  return MEMORY[0x24BDC35D0]();
}

{
  return MEMORY[0x24BDC35D8]();
}

uint64_t subscriber::clearFlag()
{
  return MEMORY[0x24BDC3FC0]();
}

uint64_t subscriber::getFileId()
{
  return MEMORY[0x24BDC3FC8]();
}

uint64_t subscriber::setFlagIf()
{
  return MEMORY[0x24BDC3FD0]();
}

uint64_t subscriber::operator<<()
{
  return MEMORY[0x24BDC35F0]();
}

void DisplayText::~DisplayText(DisplayText *this)
{
  MEMORY[0x24BDC3FD8](this);
}

void OpenChannel::~OpenChannel(OpenChannel *this)
{
  MEMORY[0x24BDC3FE0](this);
}

void ReceiveData::~ReceiveData(ReceiveData *this)
{
  MEMORY[0x24BDC3FE8](this);
}

void CloseChannel::~CloseChannel(CloseChannel *this)
{
  MEMORY[0x24BDC3FF0](this);
}

uint64_t DataIPFilter::adjust(DataIPFilter *this)
{
  return MEMORY[0x24BDC35F8](this);
}

uint64_t OTASPService::OTASPService()
{
  return MEMORY[0x24BDC3600]();
}

void OTASPService::~OTASPService(OTASPService *this)
{
  MEMORY[0x24BDC3608](this);
}

void RefreshAlpha::~RefreshAlpha(RefreshAlpha *this)
{
  MEMORY[0x24BDC3FF8](this);
}

uint64_t capabilities::ct::supports5G(capabilities::ct *this)
{
  return MEMORY[0x24BED8E38](this);
}

uint64_t capabilities::ct::supportsVoNR(capabilities::ct *this)
{
  return MEMORY[0x24BED8E40](this);
}

uint64_t capabilities::ct::supportsHydra(capabilities::ct *this)
{
  return MEMORY[0x24BED8E48](this);
}

uint64_t capabilities::ct::supportsVoLTE(capabilities::ct *this)
{
  return MEMORY[0x24BED8E50](this);
}

uint64_t capabilities::ct::supportsGemini(capabilities::ct *this)
{
  return MEMORY[0x24BED8E58](this);
}

uint64_t capabilities::ct::supportsStewie(capabilities::ct *this)
{
  return MEMORY[0x24BED8E60](this);
}

uint64_t capabilities::ct::shouldAWDWakeAP(capabilities::ct *this)
{
  return MEMORY[0x24BED8E68](this);
}

uint64_t capabilities::ct::supports5GSlicing(capabilities::ct *this)
{
  return MEMORY[0x24BED8E70](this);
}

uint64_t capabilities::ct::supportsLLFilters(capabilities::ct *this)
{
  return MEMORY[0x24BED8E80](this);
}

uint64_t capabilities::ct::supportsVoiceCall(capabilities::ct *this)
{
  return MEMORY[0x24BED8E88](this);
}

uint64_t capabilities::ct::defaultVinylSlotID(capabilities::ct *this)
{
  return MEMORY[0x24BED8E90](this);
}

uint64_t capabilities::ct::supportsDynamicSID(capabilities::ct *this)
{
  return MEMORY[0x24BED8EA0](this);
}

uint64_t capabilities::ct::supportsEcoDataMode(capabilities::ct *this)
{
  return MEMORY[0x24BED8EA8](this);
}

uint64_t capabilities::ct::supportsHandoverPDN(capabilities::ct *this)
{
  return MEMORY[0x24BED8EB0](this);
}

uint64_t capabilities::ct::supportsSMSIMSStack(capabilities::ct *this)
{
  return MEMORY[0x24BED8EB8](this);
}

uint64_t capabilities::ct::getCDMASettingsSupport(capabilities::ct *this)
{
  return MEMORY[0x24BED8ED8](this);
}

uint64_t capabilities::ct::requireVinylManagerInd(capabilities::ct *this)
{
  return MEMORY[0x24BED8EE0](this);
}

uint64_t capabilities::ct::supportsBB2GMitigation(capabilities::ct *this)
{
  return MEMORY[0x24BED8EE8](this);
}

uint64_t capabilities::ct::supportsPrivateNetwork(capabilities::ct *this)
{
  return MEMORY[0x24BED8EF0](this);
}

uint64_t capabilities::ct::dataOnlySingleSIMDevice(capabilities::ct *this)
{
  return MEMORY[0x24BED8F08](this);
}

uint64_t capabilities::ct::supportedVinylSlotCount(capabilities::ct *this)
{
  return MEMORY[0x24BED8F20](this);
}

uint64_t capabilities::ct::supportsDualPhysicalSIM(capabilities::ct *this)
{
  return MEMORY[0x24BED8F28](this);
}

uint64_t capabilities::ct::supportsQMIWakeUpForDFC(capabilities::ct *this)
{
  return MEMORY[0x24BED8F30](this);
}

uint64_t capabilities::ct::shouldSendWiFiCallStatus(capabilities::ct *this)
{
  return MEMORY[0x24BED8F38](this);
}

uint64_t capabilities::ct::supportedPDPContextCount(capabilities::ct *this)
{
  return MEMORY[0x24BED8F40](this);
}

uint64_t capabilities::ct::supportsCSFBFastSAReturn(capabilities::ct *this)
{
  return MEMORY[0x24BED8F48](this);
}

uint64_t capabilities::ct::supportsNASCallEndReason(capabilities::ct *this)
{
  return MEMORY[0x24BED8F58](this);
}

uint64_t capabilities::ct::supportsDataQMIExtensions(capabilities::ct *this)
{
  return MEMORY[0x24BED8F60](this);
}

uint64_t capabilities::ct::supportsQualityIndication(capabilities::ct *this)
{
  return MEMORY[0x24BED8F70](this);
}

uint64_t capabilities::ct::defaultVinylCardTypeToGSMA(capabilities::ct *this)
{
  return MEMORY[0x24BED8F78](this);
}

uint64_t capabilities::ct::supportsUplinkHealthUpdate(capabilities::ct *this)
{
  return MEMORY[0x24BED8F90](this);
}

uint64_t capabilities::ct::supportsCapabilityC2KDevice(capabilities::ct *this)
{
  return MEMORY[0x24BED8F98](this);
}

uint64_t capabilities::ct::supportsDisableICCIDCommand(capabilities::ct *this)
{
  return MEMORY[0x24BED8FA0](this);
}

uint64_t capabilities::ct::getSignalStrengthPersonality(capabilities::ct *this)
{
  return MEMORY[0x24BED8FA8](this);
}

uint64_t capabilities::ct::supports2StepDataCallBringUp(capabilities::ct *this)
{
  return MEMORY[0x24BED8FB0](this);
}

uint64_t capabilities::ct::supportsPacketFilterCallType(capabilities::ct *this)
{
  return MEMORY[0x24BED8FC8](this);
}

uint64_t capabilities::ct::getProvisioningProfileSupport(capabilities::ct *this)
{
  return MEMORY[0x24BED8FD0](this);
}

uint64_t capabilities::ct::supportsCapabilityeHRPDDevice(capabilities::ct *this)
{
  return MEMORY[0x24BED8FE0](this);
}

uint64_t capabilities::ct::supportsSIMDetectionInterrupt(capabilities::ct *this)
{
  return MEMORY[0x24BED8FF0](this);
}

uint64_t capabilities::ct::supportsSIMMomentaryPowerDown(capabilities::ct *this)
{
  return MEMORY[0x24BED8FF8](this);
}

uint64_t capabilities::ct::supportsThroughputEngineering(capabilities::ct *this)
{
  return MEMORY[0x24BED9000](this);
}

uint64_t capabilities::ct::supportsEmergencyQMIExtensions(capabilities::ct *this)
{
  return MEMORY[0x24BED9008](this);
}

uint64_t capabilities::ct::supportsCapabilityTDSCDMADevice(capabilities::ct *this)
{
  return MEMORY[0x24BED9010](this);
}

uint64_t capabilities::ct::supportsDataSystemDetermination(capabilities::ct *this)
{
  return MEMORY[0x24BED9018](this);
}

uint64_t capabilities::ct::supportsEnhanced5GCellularHarvesting(capabilities::ct *this)
{
  return MEMORY[0x24BED9050](this);
}

uint64_t capabilities::ct::supportsDynamicRRCReleaseVersionUpdate(capabilities::ct *this)
{
  return MEMORY[0x24BED9060](this);
}

uint64_t capabilities::ct::supportsCompleteCleanupOnFilePushFailure(capabilities::ct *this)
{
  return MEMORY[0x24BED9078](this);
}

uint64_t capabilities::ct::supportsForceUserConfirmationForSTKCalls(capabilities::ct *this)
{
  return MEMORY[0x24BED9080](this);
}

uint64_t capabilities::ct::supportsNVRAMUpdateWithoutBasebandReboot(capabilities::ct *this)
{
  return MEMORY[0x24BED9088](this);
}

uint64_t capabilities::ct::supportsReportingTetheringStateToBaseband(capabilities::ct *this)
{
  return MEMORY[0x24BED9090](this);
}

uint64_t capabilities::ct::asString()
{
  return MEMORY[0x24BED90B0]();
}

uint64_t capabilities::ipc::supportsCoalescing(capabilities::ipc *this)
{
  return MEMORY[0x24BED91C0](this);
}

uint64_t capabilities::euicc::supportsEOS(capabilities::euicc *this)
{
  return MEMORY[0x24BED9228](this);
}

uint64_t capabilities::radio::supportsMultiClientAWD(capabilities::radio *this)
{
  return MEMORY[0x24BED9270](this);
}

uint64_t CCPreferences::create(CCPreferences *this)
{
  return MEMORY[0x24BDC4000](this);
}

uint64_t PDPMetricInfo::clear(PDPMetricInfo *this)
{
  return MEMORY[0x24BDC3610](this);
}

void PDPMetricInfo::~PDPMetricInfo(PDPMetricInfo *this)
{
  MEMORY[0x24BDC3618](this);
}

uint64_t QMIServiceMsg::create()
{
  return MEMORY[0x24BED1E18]();
}

void SelectionItem::~SelectionItem(SelectionItem *this)
{
  MEMORY[0x24BDC4008](this);
}

void SetupIdleText::~SetupIdleText(SetupIdleText *this)
{
  MEMORY[0x24BDC4010](this);
}

void ActivationInfo::ActivationInfo(ActivationInfo *this)
{
  MEMORY[0x24BDC3648](this);
}

uint64_t CSIPhoneNumber::setBaseNumber()
{
  return MEMORY[0x24BDC3650]();
}

uint64_t CSIPhoneNumber::setTypeOfAddress(CSIPhoneNumber *this)
{
  return MEMORY[0x24BDC3658](this);
}

void CSIPhoneNumber::CSIPhoneNumber(CSIPhoneNumber *this, const char *a2)
{
  MEMORY[0x24BDC3660](this, a2);
}

uint64_t CSIPhoneNumber::CSIPhoneNumber()
{
  return MEMORY[0x24BDC3668]();
}

{
  return MEMORY[0x24BDC3670]();
}

void CSIPhoneNumber::CSIPhoneNumber(CSIPhoneNumber *this)
{
  MEMORY[0x24BDC3678](this);
}

uint64_t PBCapabilities::SecondName::SecondName(PBCapabilities::SecondName *this)
{
  return MEMORY[0x24BDC3680](this);
}

uint64_t PBCapabilities::HiddenRecords::HiddenRecords(PBCapabilities::HiddenRecords *this)
{
  return MEMORY[0x24BDC3688](this);
}

uint64_t PBCapabilities::PrimaryNumber::PrimaryNumber(PBCapabilities::PrimaryNumber *this)
{
  return MEMORY[0x24BDC3690](this);
}

uint64_t PBCapabilities::AdditionaNumber::AdditionaNumber(PBCapabilities::AdditionaNumber *this)
{
  return MEMORY[0x24BDC3698](this);
}

uint64_t PBCapabilities::Email::Email(PBCapabilities::Email *this)
{
  return MEMORY[0x24BDC36A0](this);
}

uint64_t PBCapabilities::Groups::Groups(PBCapabilities::Groups *this)
{
  return MEMORY[0x24BDC36A8](this);
}

uint64_t ATCommandDriver::handleCommand_sync()
{
  return MEMORY[0x24BDC4018]();
}

uint64_t ATCommandDriver::getSupportedCommands(ATCommandDriver *this)
{
  return MEMORY[0x24BDC4020](this);
}

uint64_t ATCommandDriver::ATCommandDriver()
{
  return MEMORY[0x24BDC4028]();
}

void ATCommandDriver::~ATCommandDriver(ATCommandDriver *this)
{
  MEMORY[0x24BDC4030](this);
}

uint64_t CallAudioDriver::stopLocalDtmf(CallAudioDriver *this)
{
  return MEMORY[0x24BDC4038](this);
}

uint64_t CallAudioDriver::playLocalDtmfDigits()
{
  return MEMORY[0x24BDC4040]();
}

uint64_t CallAudioDriver::CallAudioDriver()
{
  return MEMORY[0x24BDC4048]();
}

void CallAudioDriver::~CallAudioDriver(CallAudioDriver *this)
{
  MEMORY[0x24BDC4050](this);
}

void ChipInformation::ChipInformation(ChipInformation *this)
{
  MEMORY[0x24BDC36C0](this);
}

void NRDisableStatus::NRDisableStatus(NRDisableStatus *this)
{
  MEMORY[0x24BDC36D0](this);
}

uint64_t AQMCommandDriver::AQMCommandDriver()
{
  return MEMORY[0x24BDC4058]();
}

void AQMCommandDriver::~AQMCommandDriver(AQMCommandDriver *this)
{
  MEMORY[0x24BDC4060](this);
}

uint64_t CSIPacketAddress::setPrefixLen(CSIPacketAddress *this)
{
  return MEMORY[0x24BDC36D8](this);
}

uint64_t CSIPacketAddress::setIPv6Address(CSIPacketAddress *this, const unsigned __int8 *a2)
{
  return MEMORY[0x24BDC36E8](this, a2);
}

uint64_t CSIPacketAddress::applyMaskPrefix(CSIPacketAddress *this)
{
  return MEMORY[0x24BDC36F0](this);
}

uint64_t CSIPacketAddress::setIPv4AddressLE(CSIPacketAddress *this)
{
  return MEMORY[0x24BDC36F8](this);
}

uint64_t CSIPacketAddress::CSIPacketAddress()
{
  return MEMORY[0x24BDC3700]();
}

void CSIPacketAddress::CSIPacketAddress(CSIPacketAddress *this, const CSIPacketAddress *a2)
{
  MEMORY[0x24BDC3708](this, a2);
}

void CSIPacketAddress::CSIPacketAddress(CSIPacketAddress *this)
{
  MEMORY[0x24BDC3710](this);
}

uint64_t CSIPacketAddress::operator=()
{
  return MEMORY[0x24BDC3718]();
}

uint64_t DMSCommandDriver::setImeiSvn()
{
  return MEMORY[0x24BDC4068]();
}

uint64_t DMSCommandDriver::setPrlVersion()
{
  return MEMORY[0x24BDC4070]();
}

uint64_t DMSCommandDriver::clearPrlVersion()
{
  return MEMORY[0x24BDC4078]();
}

uint64_t DMSCommandDriver::stop(DMSCommandDriver *this)
{
  return MEMORY[0x24BDC4088](this);
}

uint64_t DMSCommandDriver::start(DMSCommandDriver *this)
{
  return MEMORY[0x24BDC4098](this);
}

uint64_t DMSCommandDriver::setMin()
{
  return MEMORY[0x24BDC40A0]();
}

uint64_t DMSCommandDriver::setImei()
{
  return MEMORY[0x24BDC40A8]();
}

uint64_t DMSCommandDriver::setMeid()
{
  return MEMORY[0x24BDC40B0]();
}

uint64_t DMSCommandDriver::clearMin()
{
  return MEMORY[0x24BDC40B8]();
}

uint64_t DMSCommandDriver::DMSCommandDriver()
{
  return MEMORY[0x24BDC40C0]();
}

void DMSCommandDriver::~DMSCommandDriver(DMSCommandDriver *this)
{
  MEMORY[0x24BDC40C8](this);
}

uint64_t EosCommandDriver::EosCommandDriver()
{
  return MEMORY[0x24BDC40D0]();
}

void EosCommandDriver::~EosCommandDriver(EosCommandDriver *this)
{
  MEMORY[0x24BDC40D8](this);
}

uint64_t P2PCommandDriver::P2PCommandDriver()
{
  return MEMORY[0x24BDC40E0]();
}

void P2PCommandDriver::~P2PCommandDriver(P2PCommandDriver *this)
{
  MEMORY[0x24BDC40E8](this);
}

void SendShortMessage::~SendShortMessage(SendShortMessage *this)
{
  MEMORY[0x24BDC40F0](this);
}

uint64_t CallCommandDriver::shouldMTCallContinue(CallCommandDriver *this, uint64_t a2, const CallInfo *a3)
{
  return MEMORY[0x24BDC40F8](this, a2, a3);
}

uint64_t CallCommandDriver::computeClirValue_sync(CallCommandDriver *this, const CallInfo *a2)
{
  return MEMORY[0x24BDC4100](this, a2);
}

uint64_t CallCommandDriver::shutdown()
{
  return MEMORY[0x24BDC4108]();
}

uint64_t CallCommandDriver::bootstrap()
{
  return MEMORY[0x24BDC4110]();
}

uint64_t CallCommandDriver::CallCommandDriver()
{
  return MEMORY[0x24BDC4118]();
}

void CallCommandDriver::~CallCommandDriver(CallCommandDriver *this)
{
  MEMORY[0x24BDC4120](this);
}

void STK_CommandDriver::~STK_CommandDriver(STK_CommandDriver *this)
{
  MEMORY[0x24BDC4128](this);
}

uint64_t TrafficDescriptor::TrafficDescriptor()
{
  return MEMORY[0x24BDC3728]();
}

{
  return MEMORY[0x24BDC3730]();
}

void TrafficDescriptor::TrafficDescriptor(TrafficDescriptor *this)
{
  MEMORY[0x24BDC3738](this);
}

void TrafficDescriptor::~TrafficDescriptor(TrafficDescriptor *this)
{
  MEMORY[0x24BDC3740](this);
}

uint64_t TrafficDescriptor::operator=()
{
  return MEMORY[0x24BDC3748]();
}

uint64_t AudioCommandDriver::bootstrap()
{
  return MEMORY[0x24BDC4130]();
}

uint64_t AudioCommandDriver::AudioCommandDriver()
{
  return MEMORY[0x24BDC4138]();
}

void AudioCommandDriver::~AudioCommandDriver(AudioCommandDriver *this)
{
  MEMORY[0x24BDC4140](this);
}

void EmbmsCommandDriver::~EmbmsCommandDriver(EmbmsCommandDriver *this)
{
  MEMORY[0x24BDC4148](this);
}

void VinylCommandDriver::VinylCommandDriver(VinylCommandDriver *this, const char *a2)
{
  MEMORY[0x24BDC4158](this, a2);
}

void VinylCommandDriver::~VinylCommandDriver(VinylCommandDriver *this)
{
  MEMORY[0x24BDC4160](this);
}

uint64_t CSISMSCommandDriver::clientStopped()
{
  return MEMORY[0x24BDC4170]();
}

uint64_t CSISMSCommandDriver::CSISMSCommandDriver()
{
  return MEMORY[0x24BDC4188]();
}

void CSISMSCommandDriver::~CSISMSCommandDriver(CSISMSCommandDriver *this)
{
  MEMORY[0x24BDC4190](this);
}

uint64_t FilePushTransaction::create()
{
  return MEMORY[0x24BDC4198]();
}

void FilePushTransaction::~FilePushTransaction(FilePushTransaction *this)
{
  MEMORY[0x24BDC41A0](this);
}

uint64_t NetworkListOperator::NetworkListOperator()
{
  return MEMORY[0x24BDC3760]();
}

void PersonalitySpecific::~PersonalitySpecific(PersonalitySpecific *this)
{
  MEMORY[0x24BDC3768](this);
}

void StewieCommandDriver::~StewieCommandDriver(StewieCommandDriver *this)
{
  MEMORY[0x24BDC41A8](this);
}

uint64_t DesenseCommandDriver::addSingleFrequencyToMap()
{
  return MEMORY[0x24BDC41B0]();
}

uint64_t DesenseCommandDriver::bootstrap()
{
  return MEMORY[0x24BDC41B8]();
}

uint64_t DesenseCommandDriver::DesenseCommandDriver()
{
  return MEMORY[0x24BDC41C0]();
}

void DesenseCommandDriver::~DesenseCommandDriver(DesenseCommandDriver *this)
{
  MEMORY[0x24BDC41C8](this);
}

void LanguageNotification::~LanguageNotification(LanguageNotification *this)
{
  MEMORY[0x24BDC41D0](this);
}

uint64_t CommandDriversFactory::init()
{
  return MEMORY[0x24BDC41D8]();
}

void CommandDriversFactory::CommandDriversFactory(CommandDriversFactory *this)
{
  MEMORY[0x24BDC41E0](this);
}

void CommandDriversFactory::~CommandDriversFactory(CommandDriversFactory *this)
{
  MEMORY[0x24BDC41E8](this);
}

uint64_t DormancyCommandDriver::DormancyCommandDriver()
{
  return MEMORY[0x24BDC41F8]();
}

void DormancyCommandDriver::~DormancyCommandDriver(DormancyCommandDriver *this)
{
  MEMORY[0x24BDC4200](this);
}

uint64_t NetworkListScanResult::addOperator()
{
  return MEMORY[0x24BDC4208]();
}

uint64_t NetworkListScanResult::setState()
{
  return MEMORY[0x24BDC4210]();
}

void SetupCallAlphaDisplay::~SetupCallAlphaDisplay(SetupCallAlphaDisplay *this)
{
  MEMORY[0x24BDC4218](this);
}

uint64_t AttachApnCommandDriver::start_sync(AttachApnCommandDriver *this)
{
  return MEMORY[0x24BDC4220](this);
}

uint64_t AttachApnCommandDriver::shutdown_sync(AttachApnCommandDriver *this)
{
  return MEMORY[0x24BDC4228](this);
}

uint64_t AttachApnCommandDriver::bootstrap_sync(AttachApnCommandDriver *this)
{
  return MEMORY[0x24BDC4230](this);
}

uint64_t AttachApnCommandDriver::getApnListForType_sync()
{
  return MEMORY[0x24BDC4238]();
}

uint64_t AttachApnCommandDriver::AttachApnCommandDriver()
{
  return MEMORY[0x24BDC4240]();
}

void AttachApnCommandDriver::~AttachApnCommandDriver(AttachApnCommandDriver *this)
{
  MEMORY[0x24BDC4248](this);
}

uint64_t BasebandSettingsDriver::readSegment()
{
  return MEMORY[0x24BDC4250]();
}

uint64_t BasebandSettingsDriver::reportFileTransferStatus_sync()
{
  return MEMORY[0x24BDC4258]();
}

uint64_t BasebandSettingsDriver::BasebandSettingsDriver()
{
  return MEMORY[0x24BDC4260]();
}

void BasebandSettingsDriver::~BasebandSettingsDriver(BasebandSettingsDriver *this)
{
  MEMORY[0x24BDC4268](this);
}

uint64_t PhonebookCommandDriver::decodeName()
{
  return MEMORY[0x24BDC4270]();
}

uint64_t PhonebookCommandDriver::convertToString()
{
  return MEMORY[0x24BDC4278]();
}

uint64_t PhonebookCommandDriver::getVectorForString()
{
  return MEMORY[0x24BDC4280]();
}

uint64_t PhonebookCommandDriver::PhonebookCommandDriver()
{
  return MEMORY[0x24BDC4288]();
}

void PhonebookCommandDriver::~PhonebookCommandDriver(PhonebookCommandDriver *this)
{
  MEMORY[0x24BDC4290](this);
}

void SetupEventUserActivity::~SetupEventUserActivity(SetupEventUserActivity *this)
{
  MEMORY[0x24BDC42A0](this);
}

uint64_t ActivationCommandDriver::parseImei(ActivationCommandDriver *this, unsigned __int8 *a2)
{
  return MEMORY[0x24BDC42A8](this, a2);
}

uint64_t ActivationCommandDriver::ActivationCommandDriver()
{
  return MEMORY[0x24BDC42B0]();
}

void ActivationCommandDriver::~ActivationCommandDriver(ActivationCommandDriver *this)
{
  MEMORY[0x24BDC42B8](this);
}

uint64_t PersonalitySpecificImpl::PersonalitySpecificImpl()
{
  return MEMORY[0x24BDC3790]();
}

void PersonalitySpecificImpl::~PersonalitySpecificImpl(PersonalitySpecificImpl *this)
{
  MEMORY[0x24BDC3798](this);
}

uint64_t RequestDumpStatePayload::RequestDumpStatePayload()
{
  return MEMORY[0x24BDC37A0]();
}

uint64_t CellMonitorCommandDriver::CellMonitorCommandDriver()
{
  return MEMORY[0x24BDC42C0]();
}

void CellMonitorCommandDriver::~CellMonitorCommandDriver(CellMonitorCommandDriver *this)
{
  MEMORY[0x24BDC42C8](this);
}

uint64_t EnhancedLQMCommandDriver::EnhancedLQMCommandDriver()
{
  return MEMORY[0x24BDC42D0]();
}

void EnhancedLQMCommandDriver::~EnhancedLQMCommandDriver(EnhancedLQMCommandDriver *this)
{
  MEMORY[0x24BDC42D8](this);
}

uint64_t NetworkListCommandDriver::NetworkListCommandDriver()
{
  return MEMORY[0x24BDC42E0]();
}

void NetworkListCommandDriver::~NetworkListCommandDriver(NetworkListCommandDriver *this)
{
  MEMORY[0x24BDC42E8](this);
}

void ProvideLocalInfoLanguage::~ProvideLocalInfoLanguage(ProvideLocalInfoLanguage *this)
{
  MEMORY[0x24BDC42F0](this);
}

uint64_t AudioRoutingCommandDriver::AudioRoutingCommandDriver()
{
  return MEMORY[0x24BDC42F8]();
}

void AudioRoutingCommandDriver::~AudioRoutingCommandDriver(AudioRoutingCommandDriver *this)
{
  MEMORY[0x24BDC4300](this);
}

void CDMASettingsCommandDriver::~CDMASettingsCommandDriver(CDMASettingsCommandDriver *this)
{
  MEMORY[0x24BDC4308](this);
}

uint64_t FilePushTransactionResult::FilePushTransactionResult()
{
  return MEMORY[0x24BDC4310]();
}

uint64_t NetworkRegistrationDriver::NetworkRegistrationDriver()
{
  return MEMORY[0x24BDC4330]();
}

void NetworkRegistrationDriver::~NetworkRegistrationDriver(NetworkRegistrationDriver *this)
{
  MEMORY[0x24BDC4338](this);
}

void SetupCallUserConfirmation::~SetupCallUserConfirmation(SetupCallUserConfirmation *this)
{
  MEMORY[0x24BDC4340](this);
}

uint64_t SuppServicesCommandDriver::SuppServicesCommandDriver()
{
  return MEMORY[0x24BDC4348]();
}

void SuppServicesCommandDriver::~SuppServicesCommandDriver(SuppServicesCommandDriver *this)
{
  MEMORY[0x24BDC4350](this);
}

uint64_t WiFiSettingsCommandDriver::parseBssid()
{
  return MEMORY[0x24BDC4358]();
}

uint64_t WiFiSettingsCommandDriver::WiFiSettingsCommandDriver()
{
  return MEMORY[0x24BDC4360]();
}

void WiFiSettingsCommandDriver::~WiFiSettingsCommandDriver(WiFiSettingsCommandDriver *this)
{
  MEMORY[0x24BDC4368](this);
}

void BBDataFactoryCommandDriver::~BBDataFactoryCommandDriver(BBDataFactoryCommandDriver *this)
{
  MEMORY[0x24BDC4370](this);
}

uint64_t NetworkListSelectionResult::NetworkListSelectionResult()
{
  return MEMORY[0x24BDC4378]();
}

void SetupEventIdleScreenNotify::~SetupEventIdleScreenNotify(SetupEventIdleScreenNotify *this)
{
  MEMORY[0x24BDC4380](this);
}

void SignalStrengthCommandDriver::~SignalStrengthCommandDriver(SignalStrengthCommandDriver *this)
{
  MEMORY[0x24BDC4388](this);
}

void BBDataCommandDriverInterface::~BBDataCommandDriverInterface(BBDataCommandDriverInterface *this)
{
  MEMORY[0x24BDC4390](this);
}

uint64_t BBDataContextDriverInterface::getObserver(BBDataContextDriverInterface *this)
{
  return MEMORY[0x24BDC4398](this);
}

{
  return MEMORY[0x24BDC4510](this);
}

uint64_t BBDataContextDriverInterface::BBDataContextDriverInterface()
{
  return MEMORY[0x24BDC43A0]();
}

void BBDataContextDriverInterface::~BBDataContextDriverInterface(BBDataContextDriverInterface *this)
{
  MEMORY[0x24BDC43A8](this);
}

void AttachApnCommandDriverFactory::~AttachApnCommandDriverFactory(AttachApnCommandDriverFactory *this)
{
  MEMORY[0x24BDC43B0](this);
}

void SubscriptionSlotConfiguration::SubscriptionSlotConfiguration(SubscriptionSlotConfiguration *this)
{
  MEMORY[0x24BDC37A8](this);
}

uint64_t at::asString()
{
  return MEMORY[0x24BDC43B8]();
}

uint64_t sd::imsServiceMaskFromUint(sd *this)
{
  return MEMORY[0x24BDC37D0](this);
}

uint64_t PreferredNetworksCommandDriver::PreferredNetworksCommandDriver()
{
  return MEMORY[0x24BDC3890]();
}

void PreferredNetworksCommandDriver::~PreferredNetworksCommandDriver(PreferredNetworksCommandDriver *this)
{
  MEMORY[0x24BDC3898](this);
}

void SetupEventLanguageSelectNotify::~SetupEventLanguageSelectNotify(SetupEventLanguageSelectNotify *this)
{
  MEMORY[0x24BDC43C0](this);
}

void BBDataCommandDriverEventHandler::~BBDataCommandDriverEventHandler(BBDataCommandDriverEventHandler *this)
{
  MEMORY[0x24BDC43C8](this);
}

uint64_t ES10TapeLoadBoundProfilePackage::getNextPayload()
{
  return MEMORY[0x24BDC38A0]();
}

uint64_t ES10TapeLoadBoundProfilePackage::ES10TapeLoadBoundProfilePackage()
{
  return MEMORY[0x24BDC38A8]();
}

uint64_t DataSubscriptionBaseCommandDriver::operationCompleted_sync()
{
  return MEMORY[0x24BDC43D0]();
}

uint64_t DataSubscriptionBaseCommandDriver::DataSubscriptionBaseCommandDriver()
{
  return MEMORY[0x24BDC43D8]();
}

void DataSubscriptionBaseCommandDriver::~DataSubscriptionBaseCommandDriver(DataSubscriptionBaseCommandDriver *this)
{
  MEMORY[0x24BDC43E0](this);
}

uint64_t NetworkListCommandDriverResponseError::NetworkListCommandDriverResponseError()
{
  return MEMORY[0x24BDC43E8]();
}

uint64_t MCC::MCC()
{
  return MEMORY[0x24BDC38C0]();
}

{
  return MEMORY[0x24BDC38D0]();
}

void MCC::MCC(MCC *this)
{
  MEMORY[0x24BDC38C8](this);
}

{
  MEMORY[0x24BDC38D8](this);
}

void MCC::MCC(MCC *this, const MCC *a2)
{
  MEMORY[0x24BDC38E0](this, a2);
}

uint64_t MCC::operator=()
{
  return MEMORY[0x24BDC38E8]();
}

void MNC::MNC(MNC *this, uint64_t a2, const MCC *a3)
{
  MEMORY[0x24BDC38F8](this, a2, a3);
}

uint64_t MNC::MNC()
{
  return MEMORY[0x24BDC3900]();
}

void MNC::MNC(MNC *this)
{
  MEMORY[0x24BDC3908](this);
}

uint64_t awd::AwdCommandDriver::AwdCommandDriver()
{
  return MEMORY[0x24BDC43F8]();
}

void awd::AwdCommandDriver::~AwdCommandDriver(awd::AwdCommandDriver *this)
{
  MEMORY[0x24BDC4400](this);
}

uint64_t ctu::MallocZone::MallocZone(ctu::MallocZone *this, const char *a2)
{
  return MEMORY[0x24BED97F0](this, a2);
}

uint64_t ctu::RestModule::RestModule()
{
  return MEMORY[0x24BED97F8]();
}

uint64_t ctu::UnfairLock::lock(ctu::UnfairLock *this)
{
  return MEMORY[0x24BED9808](this);
}

uint64_t ctu::UnfairLock::unlock(ctu::UnfairLock *this)
{
  return MEMORY[0x24BED9810](this);
}

uint64_t ctu::OsLogLogger::OsLogLogger()
{
  return MEMORY[0x24BED9830]();
}

{
  return MEMORY[0x24BED9838]();
}

void ctu::OsLogLogger::~OsLogLogger(ctu::OsLogLogger *this)
{
  MEMORY[0x24BED9840](this);
}

uint64_t ctu::OsLogContext::OsLogContext(ctu::OsLogContext *this, const char *a2, const char *a3)
{
  return MEMORY[0x24BED9858](this, a2, a3);
}

void ctu::OsLogContext::~OsLogContext(ctu::OsLogContext *this)
{
  MEMORY[0x24BED9868](this);
}

uint64_t ctu::TextConverter::pushConversion()
{
  return MEMORY[0x24BED98B8]();
}

uint64_t ctu::TextConverter::readChars(ctu::TextConverter *this)
{
  return MEMORY[0x24BED98F8](this);
}

uint64_t ctu::TextConverter::setSource(ctu::TextConverter *this, const char *a2)
{
  return MEMORY[0x24BED9900](this, a2);
}

uint64_t ctu::TextConverter::TextConverter(ctu::TextConverter *this)
{
  return MEMORY[0x24BED9908](this);
}

void ctu::TextConverter::~TextConverter(ctu::TextConverter *this)
{
  MEMORY[0x24BED9910](this);
}

uint64_t ctu::ResultIsEmptyError::ResultIsEmptyError(ctu::ResultIsEmptyError *this)
{
  return MEMORY[0x24BED99D8](this);
}

uint64_t ctu::appendLeftoverBits()
{
  return MEMORY[0x24BED99F8]();
}

uint64_t ctu::appendLabelIfBitSet()
{
  return MEMORY[0x24BED9A18]();
}

uint64_t ctu::cf::MakeCFString::MakeCFString(ctu::cf::MakeCFString *this, const char *a2)
{
  return MEMORY[0x24BED9A78](this, a2);
}

void ctu::cf::MakeCFString::~MakeCFString(ctu::cf::MakeCFString *this)
{
  MEMORY[0x24BED9A80](this);
}

uint64_t ctu::cf::convert_copy()
{
  return MEMORY[0x24BED9A98]();
}

uint64_t ctu::cf::dict_adapter::dict_adapter(ctu::cf::dict_adapter *this, const __CFDictionary *a2)
{
  return MEMORY[0x24BED9AA0](this, a2);
}

uint64_t ctu::cf::dict_adapter::dict_adapter(ctu::cf::dict_adapter *this, const ctu::cf::dict_adapter *a2)
{
  return MEMORY[0x24BED9AA8](this, a2);
}

void ctu::cf::dict_adapter::~dict_adapter(ctu::cf::dict_adapter *this)
{
  MEMORY[0x24BED9AB0](this);
}

uint64_t ctu::cf::assign()
{
  return MEMORY[0x24BED9AD8]();
}

{
  return MEMORY[0x24BED9AE8]();
}

uint64_t ctu::cf::assign(ctu::cf *this, BOOL *a2, const __CFBoolean *a3)
{
  return MEMORY[0x24BED9AF8](this, a2, a3);
}

uint64_t ctu::cf::assign(ctu::cf *this, unsigned __int8 *a2, const __CFNumber *a3)
{
  return MEMORY[0x24BED9B00](this, a2, a3);
}

uint64_t ctu::cf::assign(ctu::cf *this, int *a2, const __CFNumber *a3)
{
  return MEMORY[0x24BED9B08](this, a2, a3);
}

uint64_t ctu::cf::assign(ctu::cf *this, unsigned __int16 *a2, const __CFNumber *a3)
{
  return MEMORY[0x24BED9B18](this, a2, a3);
}

uint64_t ctu::hex(ctu *this, const void *a2)
{
  return MEMORY[0x24BED9BB0](this, a2);
}

uint64_t ctu::hex()
{
  return MEMORY[0x24BED9BB8]();
}

uint64_t ctu::rest::detail::read_enum_string_value()
{
  return MEMORY[0x24BED9C28]();
}

uint64_t ctu::rest::detail::write_enum_string_value(ctu::rest::detail *this, uint64_t a2, const char *a3)
{
  return MEMORY[0x24BED9C38](this, a2, a3);
}

uint64_t ctu::cf_to_xpc(ctu *this, const void *a2)
{
  return MEMORY[0x24BED9D08](this, a2);
}

uint64_t ctu::operator<<()
{
  return MEMORY[0x24BED9D38]();
}

{
  return MEMORY[0x24BED9D48]();
}

{
  return MEMORY[0x24BED9D58]();
}

{
  return MEMORY[0x24BED9D60]();
}

uint64_t qmi::MessageBase::validateMsgId(qmi::MessageBase *this)
{
  return MEMORY[0x24BED8BC8](this);
}

uint64_t qmi::MessageBase::setParsingErrorHandler(qmi::MessageBase *this, BOOL (*a2)(unsigned __int16, unsigned __int16, const unsigned __int8 *, unint64_t))
{
  return MEMORY[0x24BED8BD8](this, a2);
}

uint64_t qmi::MessageBase::MessageBase(qmi::MessageBase *this, const void *a2)
{
  return MEMORY[0x24BED8BE0](this, a2);
}

{
  return MEMORY[0x24BED8BF0](this, a2);
}

uint64_t qmi::MessageBase::MessageBase()
{
  return MEMORY[0x24BED8BE8]();
}

{
  return MEMORY[0x24BED8BF8]();
}

void qmi::MessageBase::~MessageBase(qmi::MessageBase *this)
{
  MEMORY[0x24BED8C00](this);
}

{
  MEMORY[0x24BED8C08](this);
}

uint64_t qmi::ClientRouter::addClient()
{
  return MEMORY[0x24BED1E28]();
}

uint64_t qmi::ClientRouter::ClientRouter(qmi::ClientRouter *this, os_log_s *a2)
{
  return MEMORY[0x24BED1E30](this, a2);
}

uint64_t qmi::ResponseBase::ResponseBase(qmi::ResponseBase *this, const void *a2)
{
  return MEMORY[0x24BED8C10](this, a2);
}

{
  return MEMORY[0x24BED8C18](this, a2);
}

uint64_t qmi::asShortString()
{
  return MEMORY[0x24BED8C20]();
}

uint64_t qmi::isInternalError()
{
  return MEMORY[0x24BED8C28]();
}

uint64_t qmi::MutableMessageBase::setWriteErrorHandler()
{
  return MEMORY[0x24BED8C30]();
}

uint64_t qmi::MutableMessageBase::MutableMessageBase()
{
  return MEMORY[0x24BED8C38]();
}

{
  return MEMORY[0x24BED8C40]();
}

uint64_t qmi::MutableMessageBase::MutableMessageBase(qmi::MutableMessageBase *this)
{
  return MEMORY[0x24BED8C48](this);
}

void qmi::MutableMessageBase::~MutableMessageBase(qmi::MutableMessageBase *this)
{
  MEMORY[0x24BED8C50](this);
}

uint64_t qmi::Client::createWithQueue()
{
  return MEMORY[0x24BED1E40]();
}

uint64_t qmi::Client::createWithQueueLocal()
{
  return MEMORY[0x24BED1E48]();
}

uint64_t qmi::Client::set(qmi::Client *this, const char *a2)
{
  return MEMORY[0x24BED1E50](this, a2);
}

{
  return MEMORY[0x24BED1E58](this, a2);
}

uint64_t qmi::Client::release(qmi::Client *this)
{
  return MEMORY[0x24BED1E60](this);
}

uint64_t qmi::Client::Client()
{
  return MEMORY[0x24BED1E68]();
}

void qmi::Client::~Client(qmi::Client *this)
{
  MEMORY[0x24BED1E70](this);
}

uint64_t qmi::asString()
{
  return MEMORY[0x24BED1E78]();
}

{
  return MEMORY[0x24BED8C58]();
}

uint64_t sms::MTSmsDetails::MTSmsDetails()
{
  return MEMORY[0x24BDC3910]();
}

void sms::MTSmsDetails::~MTSmsDetails(sms::MTSmsDetails *this)
{
  MEMORY[0x24BDC3918](this);
}

uint64_t sms::Model::setMessageID(sms::Model *this)
{
  return MEMORY[0x24BDC3920](this);
}

uint64_t sms::asString()
{
  return MEMORY[0x24BDC3938]();
}

uint64_t sms::isRPError(sms *this)
{
  return MEMORY[0x24BDC3948](this);
}

uint64_t stk::truncateLanguageIfNeeded()
{
  return MEMORY[0x24BDC4408]();
}

uint64_t xpc::dyn_cast_or_default()
{
  return MEMORY[0x24BED9D80]();
}

{
  return MEMORY[0x24BED9DA8]();
}

void PreferredNetworksCommandDriverEventHandler::~PreferredNetworksCommandDriverEventHandler(PreferredNetworksCommandDriverEventHandler *this)
{
  MEMORY[0x24BDC3950](this);
}

uint64_t rest::ResetPayload::ResetPayload()
{
  return MEMORY[0x24BDC3958]();
}

uint64_t rest::BandwidthInfo::BandwidthInfo()
{
  return MEMORY[0x24BDC3960]();
}

uint64_t rest::write_rest_value()
{
  return MEMORY[0x24BDC3970]();
}

void SendSS::~SendSS(SendSS *this)
{
  MEMORY[0x24BDC4428](this);
}

uint64_t detail::createOsLogLoggers()
{
  return MEMORY[0x24BDC3988]();
}

{
  return MEMORY[0x24BDC3990]();
}

uint64_t detail::createUnknownOsLogLogger()
{
  return MEMORY[0x24BDC3998]();
}

{
  return MEMORY[0x24BDC39A0]();
}

void GetInkey::~GetInkey(GetInkey *this)
{
  MEMORY[0x24BDC4430](this);
}

void GetInput::~GetInput(GetInput *this)
{
  MEMORY[0x24BDC4438](this);
}

void PlayTone::~PlayTone(PlayTone *this)
{
  MEMORY[0x24BDC4440](this);
}

uint64_t Registry::getServiceMap(Registry *this)
{
  return MEMORY[0x24BDC39B0](this);
}

{
  return MEMORY[0x24BDC3C00](this);
}

void SendDTMF::~SendDTMF(SendDTMF *this)
{
  MEMORY[0x24BDC4448](this);
}

void SendData::~SendData(SendData *this)
{
  MEMORY[0x24BDC4450](this);
}

void SendUSSD::~SendUSSD(SendUSSD *this)
{
  MEMORY[0x24BDC4458](this);
}

uint64_t printers::asString(printers *this, const BOOL *a2)
{
  return MEMORY[0x24BDC39C0](this, a2);
}

uint64_t DataUtils::lteishDataMode()
{
  return MEMORY[0x24BDC39C8]();
}

uint64_t DataUtils::getDataContextName()
{
  return MEMORY[0x24BDC39D0]();
}

void MCCAndMNC::MCCAndMNC(MCCAndMNC *this, const MCC *a2, const MNC *a3)
{
  MEMORY[0x24BDC39D8](this, a2, a3);
}

uint64_t MCCAndMNC::MCCAndMNC()
{
  return MEMORY[0x24BDC39E0]();
}

void MCCAndMNC::MCCAndMNC(MCCAndMNC *this)
{
  MEMORY[0x24BDC39F0](this);
}

void ModelBase::~ModelBase(ModelBase *this)
{
  MEMORY[0x24BDC4460](this);
}

void SetupMenu::~SetupMenu(SetupMenu *this)
{
  MEMORY[0x24BDC4468](this);
}

uint64_t subscriber::SimCommandDriver::allowSimRefresh(subscriber::SimCommandDriver *this)
{
  return MEMORY[0x24BDC4470](this);
}

uint64_t subscriber::SimCommandDriver::sendSimDriverInfo()
{
  return MEMORY[0x24BDC4478]();
}

uint64_t subscriber::SimCommandDriver::indexToHardwareSimSlot(subscriber::SimCommandDriver *this)
{
  return MEMORY[0x24BDC4480](this);
}

uint64_t subscriber::SimCommandDriver::checkSimHwIdConfig_sync()
{
  return MEMORY[0x24BDC4488]();
}

uint64_t subscriber::SimCommandDriver::getVinylCapabilitiesFromATR()
{
  return MEMORY[0x24BDC4490]();
}

uint64_t subscriber::SimCommandDriver::appendMissingDriverInfo_sync()
{
  return MEMORY[0x24BDC4498]();
}

uint64_t subscriber::SimCommandDriver::markAllowedToReadCDMAAuxInfo()
{
  return MEMORY[0x24BDC44A8]();
}

uint64_t QMIServiceMsg::getNewError(QMIServiceMsg *this)
{
  return MEMORY[0x24BED1E80](this);
}

uint64_t QMIServiceMsg::serialize(QMIServiceMsg *this)
{
  return MEMORY[0x24BED1E88](this);
}

uint64_t CSIPhoneNumber::getBaseNumber(CSIPhoneNumber *this)
{
  return MEMORY[0x24BDC3A30](this);
}

uint64_t CSIPhoneNumber::getFullNumber(CSIPhoneNumber *this)
{
  return MEMORY[0x24BDC3A38](this);
}

uint64_t CSIPhoneNumber::getTypeOfAddress(CSIPhoneNumber *this)
{
  return MEMORY[0x24BDC3A40](this);
}

uint64_t CSIPacketAddress::isLinkLocal(CSIPacketAddress *this)
{
  return MEMORY[0x24BDC3A50](this);
}

uint64_t CSIPacketAddress::getPrefixLen(CSIPacketAddress *this)
{
  return MEMORY[0x24BDC3A58](this);
}

uint64_t CSIPacketAddress::maskToPrefix(CSIPacketAddress *this)
{
  return MEMORY[0x24BDC3A60](this);
}

uint64_t CSIPacketAddress::ipv4PrefixLenToMaskAddr(CSIPacketAddress *this)
{
  return MEMORY[0x24BDC3A70](this);
}

uint64_t CSIPacketAddress::isIPv4(CSIPacketAddress *this)
{
  return MEMORY[0x24BDC3A78](this);
}

uint64_t CSIPacketAddress::isIPv6(CSIPacketAddress *this)
{
  return MEMORY[0x24BDC3A80](this);
}

uint64_t CSIPacketAddress::toIPv6(CSIPacketAddress *this, unsigned __int8 *a2)
{
  return MEMORY[0x24BDC3A90](this, a2);
}

uint64_t CSIPacketAddress::isZeroIP(CSIPacketAddress *this)
{
  return MEMORY[0x24BDC3A98](this);
}

uint64_t CSIPacketAddress::toIPv4LE(CSIPacketAddress *this)
{
  return MEMORY[0x24BDC3AA0](this);
}

uint64_t CSIPacketAddress::operator std::string()
{
  return MEMORY[0x24BDC3AA8]();
}

uint64_t CSIPacketAddress::operator==()
{
  return MEMORY[0x24BDC3AB0]();
}

uint64_t EosCommandDriver::publishEosStatus()
{
  return MEMORY[0x24BDC44B8]();
}

uint64_t EosCommandDriver::getName(EosCommandDriver *this)
{
  return MEMORY[0x24BDC44C0](this);
}

uint64_t CallCommandDriver::carrierSupportsCallingTimewithFWIM()
{
  return MEMORY[0x24BDC44C8]();
}

uint64_t CallCommandDriver::dumpState(CallCommandDriver *this)
{
  return MEMORY[0x24BDC44D8](this);
}

uint64_t TrafficDescriptor::hasDnnInfo(TrafficDescriptor *this)
{
  return MEMORY[0x24BDC3AB8](this);
}

uint64_t TrafficDescriptor::hasBundleInfo(TrafficDescriptor *this)
{
  return MEMORY[0x24BDC3AC0](this);
}

uint64_t TrafficDescriptor::empty(TrafficDescriptor *this)
{
  return MEMORY[0x24BDC3AC8](this);
}

uint64_t TrafficDescriptor::toString(TrafficDescriptor *this)
{
  return MEMORY[0x24BDC3AD0](this);
}

uint64_t VinylCommandDriver::sendReadyCallback_sync()
{
  return MEMORY[0x24BDC44E0]();
}

uint64_t CSISMSCommandDriver::handleSmsSendTimeout()
{
  return MEMORY[0x24BDC44E8]();
}

uint64_t NetworkListOperator::getMCC(NetworkListOperator *this)
{
  return MEMORY[0x24BDC3AF8](this);
}

uint64_t NetworkListOperator::getMNC(NetworkListOperator *this)
{
  return MEMORY[0x24BDC3B00](this);
}

uint64_t NetworkListOperator::getRAT(NetworkListOperator *this)
{
  return MEMORY[0x24BDC3B08](this);
}

uint64_t PersonalitySpecificImpl::simSlot(PersonalitySpecificImpl *this)
{
  return MEMORY[0x24BDC3B38](this);
}

uint64_t SuppServicesCommandDriver::supportsCallWaitingServiceClass()
{
  return MEMORY[0x24BDC4508]();
}

uint64_t SubscriptionSlotConfiguration::isValid()
{
  return MEMORY[0x24BDC3B48]();
}

uint64_t DataSubscriptionBaseCommandDriver::isValidSlot_sync()
{
  return MEMORY[0x24BDC4518]();
}

uint64_t MCC::getIntValue(MCC *this)
{
  return MEMORY[0x24BDC3BA8](this);
}

uint64_t MCC::getStringValue(MCC *this)
{
  return MEMORY[0x24BDC3BB0](this);
}

uint64_t MCC::valid(MCC *this)
{
  return MEMORY[0x24BDC3BB8](this);
}

uint64_t MNC::isThreeDigit(MNC *this)
{
  return MEMORY[0x24BDC3BC8](this);
}

uint64_t MNC::getIntegerWidth(MNC *this)
{
  return MEMORY[0x24BDC3BD0](this);
}

uint64_t awd::AppContext::submitTrigger()
{
  return MEMORY[0x24BDC4528]();
}

uint64_t awd::AppContext::getAppSettings(awd::AppContext *this)
{
  return MEMORY[0x24BDC4530](this);
}

uint64_t awd::AppContext::postResultToHandler()
{
  return MEMORY[0x24BDC4538]();
}

uint64_t awd::AppContext::submitMetricPayload()
{
  return MEMORY[0x24BDC4540]();
}

uint64_t awd::AppContext::updateAppSettingsUsed()
{
  return MEMORY[0x24BDC4548]();
}

uint64_t awd::AppContext::sendConfigurationResult(awd::AppContext *this)
{
  return MEMORY[0x24BDC4550](this);
}

uint64_t awd::AppContext::markMetricSubmissionComplete()
{
  return MEMORY[0x24BDC4558]();
}

uint64_t awd::AppContext::getAppID(awd::AppContext *this)
{
  return MEMORY[0x24BDC4560](this);
}

uint64_t awd::AwdCommandDriver::broadcastState_sync()
{
  return MEMORY[0x24BDC4568]();
}

uint64_t awd::AwdCommandDriver::getName(awd::AwdCommandDriver *this)
{
  return MEMORY[0x24BDC4570](this);
}

uint64_t ctu::MallocZone::free(ctu::MallocZone *this, void *a2)
{
  return MEMORY[0x24BED9DC8](this, a2);
}

uint64_t ctu::MallocZone::malloc(ctu::MallocZone *this)
{
  return MEMORY[0x24BED9DD0](this);
}

uint64_t ctu::MallocZone::operator==()
{
  return MEMORY[0x24BED9DD8]();
}

uint64_t ctu::RestModule::disconnect(ctu::RestModule *this)
{
  return MEMORY[0x24BED9DE0](this);
}

uint64_t ctu::RestModule::setProperty()
{
  return MEMORY[0x24BED9DF0]();
}

uint64_t ctu::RestModule::observeEvent()
{
  return MEMORY[0x24BED9DF8]();
}

uint64_t ctu::RestModule::observeProperty()
{
  return MEMORY[0x24BED9E08]();
}

uint64_t ctu::RestModule::connect()
{
  return MEMORY[0x24BED9E10]();
}

uint64_t ctu::RestModule::sendEvent()
{
  return MEMORY[0x24BED9E20]();
}

uint64_t ctu::cf::map_adapter::getInt(ctu::cf::map_adapter *this, const __CFString *a2)
{
  return MEMORY[0x24BED9E90](this, a2);
}

uint64_t ctu::cf::map_adapter::getBool(ctu::cf::map_adapter *this, const __CFString *a2)
{
  return MEMORY[0x24BED9E98](this, a2);
}

uint64_t ctu::cf::map_adapter::getString()
{
  return MEMORY[0x24BED9EA8]();
}

uint64_t qmi::MessageBase::findNextTlv()
{
  return MEMORY[0x24BED8C60]();
}

uint64_t qmi::MessageBase::findTlvValue(qmi::MessageBase *this)
{
  return MEMORY[0x24BED8C68](this);
}

uint64_t qmi::ClientRouter::setHandler()
{
  return MEMORY[0x24BED1E90]();
}

uint64_t qmi::ClientRouter::setIndShouldWake(qmi::ClientRouter *this)
{
  return MEMORY[0x24BED1E98](this);
}

uint64_t qmi::ClientRouter::setIndHandlerInternal()
{
  return MEMORY[0x24BED1EA0]();
}

uint64_t qmi::ClientRouter::get()
{
  return MEMORY[0x24BED1EA8]();
}

uint64_t qmi::ClientRouter::has()
{
  return MEMORY[0x24BED1EB0]();
}

uint64_t qmi::ClientRouter::stop()
{
  return MEMORY[0x24BED1EB8]();
}

uint64_t qmi::ClientRouter::start()
{
  return MEMORY[0x24BED1EC0]();
}

uint64_t qmi::Client::getSvcType(qmi::Client *this)
{
  return MEMORY[0x24BED1EC8](this);
}

uint64_t qmi::Client::setHandler()
{
  return MEMORY[0x24BED1ED0]();
}

{
  return MEMORY[0x24BED1ED8]();
}

uint64_t qmi::Client::setIndHandler()
{
  return MEMORY[0x24BED1EE0]();
}

uint64_t qmi::Client::setIndShouldWake(qmi::Client *this)
{
  return MEMORY[0x24BED1EE8](this);
}

uint64_t qmi::Client::send()
{
  return MEMORY[0x24BED1EF0]();
}

uint64_t qmi::Client::stop(qmi::Client *this)
{
  return MEMORY[0x24BED1EF8](this);
}

uint64_t qmi::Client::start(qmi::Client *this)
{
  return MEMORY[0x24BED1F00](this);
}

uint64_t qmi::Client::getName(qmi::Client *this)
{
  return MEMORY[0x24BED1F08](this);
}

uint64_t qmi::Client::operator std::weak_ptr<qmi::Client::State>()
{
  return MEMORY[0x24BED1F10]();
}

uint64_t sms::Model::getMessageID(sms::Model *this)
{
  return MEMORY[0x24BDC3BD8](this);
}

uint64_t sms::Model::getTransportType(sms::Model *this)
{
  return MEMORY[0x24BDC3BE0](this);
}

uint64_t xpc::object::to_string(xpc::object *this)
{
  return MEMORY[0x24BED9ED0](this);
}

uint64_t CallInfo::getCCDisconnectErrorCode(CallInfo *this)
{
  return MEMORY[0x24BDC3BE8](this);
}

uint64_t CallInfo::toString(CallInfo *this)
{
  return MEMORY[0x24BDC3BF0](this);
}

uint64_t CallInfo::operator BOOL()
{
  return MEMORY[0x24BDC3BF8]();
}

uint64_t Registry::getTimerService(Registry *this)
{
  return MEMORY[0x24BDC3C08](this);
}

uint64_t Registry::getServerConnection(Registry *this)
{
  return MEMORY[0x24BDC3C18](this);
}

uint64_t Registry::createRestModuleOneTimeUseConnection(Registry *this)
{
  return MEMORY[0x24BDC3C30](this);
}

uint64_t MCCAndMNC::getMcc(MCCAndMNC *this)
{
  return MEMORY[0x24BDC3C38](this);
}

uint64_t MCCAndMNC::getMnc(MCCAndMNC *this)
{
  return MEMORY[0x24BDC3C40](this);
}

int std::string::compare(const std::string *this, const std::string::value_type *__s)
{
  return MEMORY[0x24BEDA9C0](this, __s);
}

const std::locale::facet *__cdecl std::locale::use_facet(const std::locale *this, std::locale::id *a2)
{
  return (const std::locale::facet *)MEMORY[0x24BEDAA60](this, a2);
}

std::locale std::ios_base::getloc(const std::ios_base *this)
{
  return (std::locale)MEMORY[0x24BEDAA70](this);
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const char *a2)
{
  return (std::logic_error *)MEMORY[0x24BEDAAA8](this, a2);
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const std::string *a2)
{
  return (std::logic_error *)MEMORY[0x24BEDAAB0](this, a2);
}

void std::out_of_range::~out_of_range(std::out_of_range *this)
{
  MEMORY[0x24BEDAB08](this);
}

std::runtime_error *__cdecl std::runtime_error::runtime_error(std::runtime_error *this, const char *a2)
{
  return (std::runtime_error *)MEMORY[0x24BEDAB30](this, a2);
}

{
  return (std::runtime_error *)MEMORY[0x24BEDAB48](this, a2);
}

std::runtime_error *__cdecl std::runtime_error::runtime_error(std::runtime_error *this, const std::runtime_error *a2)
{
  return (std::runtime_error *)MEMORY[0x24BEDAB58](this, a2);
}

void std::runtime_error::~runtime_error(std::runtime_error *this)
{
  MEMORY[0x24BEDAB68](this);
}

std::bad_array_new_length *__cdecl std::bad_array_new_length::bad_array_new_length(std::bad_array_new_length *this)
{
  return (std::bad_array_new_length *)MEMORY[0x24BEDABB0](this);
}

size_t std::__next_prime(size_t __n)
{
  return MEMORY[0x24BEDABE8](__n);
}

void std::string::__grow_by_and_replace(std::string *this, std::string::size_type __old_cap, std::string::size_type __delta_cap, std::string::size_type __old_sz, std::string::size_type __n_copy, std::string::size_type __n_del, std::string::size_type __n_add, const std::string::value_type *__p_new_stuff)
{
  MEMORY[0x24BEDAC08](this, __old_cap, __delta_cap, __old_sz, __n_copy, __n_del, __n_add, __p_new_stuff);
}

std::string *__cdecl std::string::append(std::string *this, const std::string::value_type *__s, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x24BEDAC40](this, __s, __n);
}

std::string *__cdecl std::string::insert(std::string *this, std::string::size_type __pos, const std::string::value_type *__s, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x24BEDAC88](this, __pos, __s, __n);
}

void std::string::resize(std::string *this, std::string::size_type __n, std::string::value_type __c)
{
  MEMORY[0x24BEDAC98](this, __n, __c);
}

void std::string::reserve(std::string *this, std::string::size_type __requested_capacity)
{
  MEMORY[0x24BEDACB8](this, __requested_capacity);
}

void std::string::__grow_by(std::string *this, std::string::size_type __old_cap, std::string::size_type __delta_cap, std::string::size_type __old_sz, std::string::size_type __n_copy, std::string::size_type __n_del, std::string::size_type __n_add)
{
  MEMORY[0x24BEDACC0](this, __old_cap, __delta_cap, __old_sz, __n_copy, __n_del, __n_add);
}

void std::string::push_back(std::string *this, std::string::value_type __c)
{
  MEMORY[0x24BEDACC8](this, __c);
}

std::string *__cdecl std::string::operator=(std::string *this, const std::string *__str)
{
  return (std::string *)MEMORY[0x24BEDAD00](this, __str);
}

uint64_t std::istream::read()
{
  return MEMORY[0x24BEDAE18]();
}

uint64_t std::ostream::put()
{
  return MEMORY[0x24BEDAEE0]();
}

uint64_t std::ostream::flush()
{
  return MEMORY[0x24BEDAEE8]();
}

uint64_t std::ostream::sentry::sentry()
{
  return MEMORY[0x24BEDAEF8]();
}

uint64_t std::ostream::sentry::~sentry()
{
  return MEMORY[0x24BEDAF00]();
}

uint64_t std::ostream::~ostream()
{
  return MEMORY[0x24BEDAF10]();
}

uint64_t std::ostream::operator<<()
{
  return MEMORY[0x24BEDAF28]();
}

{
  return MEMORY[0x24BEDAF48]();
}

{
  return MEMORY[0x24BEDAF50]();
}

{
  return MEMORY[0x24BEDAF68]();
}

{
  return MEMORY[0x24BEDAF70]();
}

uint64_t std::iostream::~basic_iostream()
{
  return MEMORY[0x24BEDB010]();
}

uint64_t std::streambuf::basic_streambuf()
{
  return MEMORY[0x24BEDB048]();
}

uint64_t std::streambuf::~streambuf()
{
  return MEMORY[0x24BEDB050]();
}

void std::__shared_weak_count::__release_weak(std::__shared_weak_count *this)
{
  MEMORY[0x24BEDB180](this);
}

std::__shared_weak_count *__cdecl std::__shared_weak_count::lock(std::__shared_weak_count *this)
{
  return (std::__shared_weak_count *)MEMORY[0x24BEDB188](this);
}

void std::__shared_weak_count::~__shared_weak_count(std::__shared_weak_count *this)
{
  MEMORY[0x24BEDB190](this);
}

void std::mutex::lock(std::mutex *this)
{
  MEMORY[0x24BEDB368](this);
}

void std::mutex::unlock(std::mutex *this)
{
  MEMORY[0x24BEDB370](this);
}

void std::mutex::~mutex(std::mutex *this)
{
  MEMORY[0x24BEDB380](this);
}

void std::locale::~locale(std::locale *this)
{
  MEMORY[0x24BEDB448](this);
}

void std::ios_base::__set_badbit_and_consider_rethrow(std::ios_base *this)
{
  MEMORY[0x24BEDB500](this);
}

void std::ios_base::init(std::ios_base *this, void *__sb)
{
  MEMORY[0x24BEDB518](this, __sb);
}

void std::ios_base::clear(std::ios_base *this, std::ios_base::iostate __state)
{
  MEMORY[0x24BEDB530](this, *(_QWORD *)&__state);
}

uint64_t std::ios::~ios()
{
  return MEMORY[0x24BEDB5E8]();
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, int __val)
{
  return (std::string *)MEMORY[0x24BEDB608](retstr, *(_QWORD *)&__val);
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, unsigned int __val)
{
  return (std::string *)MEMORY[0x24BEDB610](retstr, *(_QWORD *)&__val);
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, unint64_t __val)
{
  return (std::string *)MEMORY[0x24BEDB620](retstr, __val);
}

void std::exception::~exception(std::exception *this)
{
  MEMORY[0x24BEDB688](this);
}

void std::terminate(void)
{
  MEMORY[0x24BEDB6C0]();
}

void operator delete(void *__p)
{
  off_24D5C22A0(__p);
}

uint64_t operator delete()
{
  return off_24D5C22A8();
}

uint64_t operator<<()
{
  return MEMORY[0x24BDC3D80]();
}

void *__cdecl operator new(size_t __sz)
{
  return (void *)off_24D5C22B8(__sz);
}

uint64_t operator new()
{
  return off_24D5C22C0();
}

uint64_t __TUAssertTrigger()
{
  return MEMORY[0x24BED9EF0]();
}

void __assert_rtn(const char *a1, const char *a2, int a3, const char *a4)
{
  MEMORY[0x24BDAC7A0](a1, a2, *(_QWORD *)&a3, a4);
}

void *__cxa_allocate_exception(size_t thrown_size)
{
  return (void *)MEMORY[0x24BEDB8F8](thrown_size);
}

int __cxa_atexit(void (*lpfunc)(void *), void *obj, void *lpdso_handle)
{
  return MEMORY[0x24BDAC7B0](lpfunc, obj, lpdso_handle);
}

void __cxa_bad_cast(void)
{
  MEMORY[0x24BEDB900]();
}

void *__cxa_begin_catch(void *a1)
{
  return (void *)MEMORY[0x24BEDB910](a1);
}

void __cxa_end_catch(void)
{
  MEMORY[0x24BEDB928]();
}

void __cxa_free_exception(void *a1)
{
  MEMORY[0x24BEDB930](a1);
}

void __cxa_guard_abort(__guard *a1)
{
  MEMORY[0x24BEDB940](a1);
}

int __cxa_guard_acquire(__guard *a1)
{
  return MEMORY[0x24BEDB948](a1);
}

void __cxa_guard_release(__guard *a1)
{
  MEMORY[0x24BEDB950](a1);
}

void __cxa_rethrow(void)
{
  MEMORY[0x24BEDB958]();
}

void __cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
  MEMORY[0x24BEDB960](a1, lptinfo, a3);
}

void *__dynamic_cast(const void *lpsrc, const struct __class_type_info *lpstype, const struct __class_type_info *lpdtype, ptrdiff_t s2d)
{
  return (void *)MEMORY[0x24BEDB968](lpsrc, lpstype, lpdtype, s2d);
}

uint64_t _os_feature_enabled_impl()
{
  return MEMORY[0x24BDACB60]();
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x24BDACB80](dso, log, type, format, buf, *(_QWORD *)&size);
}

void _os_log_fault_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x24BDACB88](dso, log, type, format, buf, *(_QWORD *)&size);
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x24BDACB90](dso, log, type, format, buf, *(_QWORD *)&size);
}

void bzero(void *a1, size_t a2)
{
  MEMORY[0x24BDAD320](a1, a2);
}

uint64_t ctConvertLteBandToMask()
{
  return MEMORY[0x24BDC4698]();
}

uint64_t ctConvertNrBandToMask()
{
  return MEMORY[0x24BDC46A0]();
}

void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x24BDADC60](when, queue, block);
}

void dispatch_assert_queue_V2(dispatch_queue_t queue)
{
  MEMORY[0x24BDADCA8](queue);
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x24BDADCC0](queue, block);
}

void dispatch_async_and_wait(dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x24BDADCC8](queue, block);
}

void dispatch_async_f(dispatch_queue_t queue, void *context, dispatch_function_t work)
{
  MEMORY[0x24BDADCD8](queue, context, work);
}

void dispatch_barrier_async_f(dispatch_queue_t queue, void *context, dispatch_function_t work)
{
  MEMORY[0x24BDADCF0](queue, context, work);
}

dispatch_queue_global_t dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
{
  return (dispatch_queue_global_t)MEMORY[0x24BDADDA8](identifier, flags);
}

dispatch_group_t dispatch_group_create(void)
{
  return (dispatch_group_t)MEMORY[0x24BDADDC8]();
}

void dispatch_group_enter(dispatch_group_t group)
{
  MEMORY[0x24BDADDD0](group);
}

void dispatch_group_leave(dispatch_group_t group)
{
  MEMORY[0x24BDADDD8](group);
}

void dispatch_group_notify(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x24BDADDE0](group, queue, block);
}

void dispatch_group_notify_f(dispatch_group_t group, dispatch_queue_t queue, void *context, dispatch_function_t work)
{
  MEMORY[0x24BDADDE8](group, queue, context, work);
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_qos_class(dispatch_queue_attr_t attr, dispatch_qos_class_t qos_class, int relative_priority)
{
  return (dispatch_queue_attr_t)MEMORY[0x24BDADEC8](attr, *(_QWORD *)&qos_class, *(_QWORD *)&relative_priority);
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return (dispatch_queue_t)MEMORY[0x24BDADED0](label, attr);
}

void dispatch_release(dispatch_object_t object)
{
  MEMORY[0x24BDADF10](object);
}

void dispatch_retain(dispatch_object_t object)
{
  MEMORY[0x24BDADF20](object);
}

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x24BDADFE8](queue, block);
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  return MEMORY[0x24BDADFF8](when, delta);
}

int gettimeofday(timeval *a1, void *a2)
{
  return MEMORY[0x24BDAE780](a1, a2);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x24BDAEE78](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x24BDAEE80](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x24BDAEE98](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x24BDAEEA8](__b, *(_QWORD *)&__c, __len);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x24BDAF398](oslog, type);
}

void os_release(void *object)
{
  MEMORY[0x24BDAF3F0](object);
}

int pthread_mutex_lock(pthread_mutex_t *a1)
{
  return MEMORY[0x24BDAF8D0](a1);
}

int pthread_mutex_unlock(pthread_mutex_t *a1)
{
  return MEMORY[0x24BDAF8E0](a1);
}

int pthread_once(pthread_once_t *a1, void (*a2)(void))
{
  return MEMORY[0x24BDAF910](a1, a2);
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return MEMORY[0x24BDAFE40](__str, __size, __format);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x24BDAFEF0](__s1, __s2);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x24BDAFF40](__s);
}

time_t time(time_t *a1)
{
  return MEMORY[0x24BDB0240](a1);
}

size_t xpc_array_get_count(xpc_object_t xarray)
{
  return MEMORY[0x24BDB0660](xarray);
}

xpc_object_t xpc_array_get_value(xpc_object_t xarray, size_t index)
{
  return (xpc_object_t)MEMORY[0x24BDB06A0](xarray, index);
}

xpc_object_t xpc_BOOL_create(BOOL value)
{
  return (xpc_object_t)MEMORY[0x24BDB06D8](value);
}

xpc_connection_t xpc_connection_create_from_endpoint(xpc_endpoint_t endpoint)
{
  return (xpc_connection_t)MEMORY[0x24BDB0738](endpoint);
}

xpc_object_t xpc_dictionary_create(const char *const *keys, xpc_object_t *values, size_t count)
{
  return (xpc_object_t)MEMORY[0x24BDB08C0](keys, values, count);
}

xpc_object_t xpc_dictionary_get_value(xpc_object_t xdict, const char *key)
{
  return (xpc_object_t)MEMORY[0x24BDB0968](xdict, key);
}

void xpc_dictionary_set_value(xpc_object_t xdict, const char *key, xpc_object_t value)
{
  MEMORY[0x24BDB09E0](xdict, key, value);
}

xpc_type_t xpc_get_type(xpc_object_t object)
{
  return (xpc_type_t)MEMORY[0x24BDB0A70](object);
}

xpc_object_t xpc_null_create(void)
{
  return (xpc_object_t)MEMORY[0x24BDB0AC0]();
}

void xpc_release(xpc_object_t object)
{
  MEMORY[0x24BDB0AE0](object);
}

xpc_object_t xpc_retain(xpc_object_t object)
{
  return (xpc_object_t)MEMORY[0x24BDB0AE8](object);
}

