void sub_2169D0A78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<cat::tlv::Item>,cat::tlv::Item*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

_WORD *std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,vs::tlv::RemoteNumberListItem *,vs::tlv::RemoteNumberListItem *,vs::tlv::RemoteNumberListItem *,0>(_WORD *a1, _WORD *a2, _WORD *a3)
{
  _WORD *v5;
  const std::string *v6;
  __int16 v7;
  std::string *v8;

  if (a1 != a2)
  {
    v5 = a1;
    do
    {
      v6 = (const std::string *)(v5 + 4);
      v7 = *v5;
      v5 += 16;
      v8 = (std::string *)(a3 + 4);
      *a3 = v7;
      a3 += 16;
      std::string::operator=(v8, v6);
    }
    while (v5 != a2);
  }
  return a3;
}

const void **ctu::SharedRef<__CFString const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFString const>::~SharedRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

void std::allocate_shared[abi:ne180100]<EurOTASPService,std::allocator<EurOTASPService>,std::shared_ptr<Registry const> const&,dispatch::queue &,std::shared_ptr<ServiceProvisioningInterface> const&,char const* const&,void>(uint64_t a1@<X1>, NSObject **a2@<X2>, _QWORD *a3@<X8>)
{
  _QWORD *v6;

  v6 = operator new(0x88uLL);
  std::__shared_ptr_emplace<EurOTASPService>::__shared_ptr_emplace[abi:ne180100]<std::shared_ptr<Registry const> const&,dispatch::queue &,std::shared_ptr<ServiceProvisioningInterface> const&,char const* const&,std::allocator<EurOTASPService>,0>(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  std::shared_ptr<QMIDataSystemDeterminationManager>::__enable_weak_this[abi:ne180100]<QMIDataSystemDeterminationManager,QMIDataSystemDeterminationManager,void>((uint64_t)a3, v6 + 4, (uint64_t)(v6 + 3));
}

void sub_2169D0B7C(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__shared_ptr_emplace<EurOTASPService>::__shared_ptr_emplace[abi:ne180100]<std::shared_ptr<Registry const> const&,dispatch::queue &,std::shared_ptr<ServiceProvisioningInterface> const&,char const* const&,std::allocator<EurOTASPService>,0>(_QWORD *a1, uint64_t a2, NSObject **a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &off_24D5DAAE0;
  std::construct_at[abi:ne180100]<EurOTASPService,std::shared_ptr<Registry const> const&,dispatch::queue &,std::shared_ptr<ServiceProvisioningInterface> const&,char const* const&,EurOTASPService*>(a1 + 3, a2, a3);
  return a1;
}

void sub_2169D0BC4(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<EurOTASPService>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5DAAE0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<EurOTASPService>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5DAAE0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

uint64_t std::__shared_ptr_emplace<EurOTASPService>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

_QWORD *std::construct_at[abi:ne180100]<EurOTASPService,std::shared_ptr<Registry const> const&,dispatch::queue &,std::shared_ptr<ServiceProvisioningInterface> const&,char const* const&,EurOTASPService*>(_QWORD *a1, uint64_t a2, NSObject **a3)
{
  NSObject *v5;
  dispatch_object_t v7;

  v5 = *a3;
  v7 = v5;
  if (v5)
    dispatch_retain(v5);
  EurOTASPService::EurOTASPService(a1, a2, &v7);
  if (v5)
    dispatch_release(v5);
  return a1;
}

void sub_2169D0CA4(_Unwind_Exception *exception_object)
{
  NSObject *v1;

  if (v1)
    dispatch_release(v1);
  _Unwind_Resume(exception_object);
}

uint64_t qmi::MessageBase::applyTlv<vs::tlv::RemoteNumberList,void({block_pointer})(vs::tlv::RemoteNumberList const&)>(qmi::MessageBase *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  int v7;
  uint64_t v8;
  int v9;

  result = qmi::MessageBase::findTlvValue(a1);
  if (result)
  {
    v8 = result;
    v9 = v7;
    if (qmi::MessageBase::tryTlv<vs::tlv::RemoteNumberList,void({block_pointer})(vs::tlv::RemoteNumberList const&)>((uint64_t)a1, (unsigned __int8 *)result, v7, a3))
    {
      return 1;
    }
    else
    {
      return ((uint64_t (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, a2, v8, v9);
    }
  }
  return result;
}

BOOL qmi::MessageBase::tryTlv<vs::tlv::RemoteNumberList,void({block_pointer})(vs::tlv::RemoteNumberList const&)>(uint64_t a1, unsigned __int8 *a2, int a3, uint64_t a4)
{
  unsigned __int8 *v5;
  uint64_t v7[3];
  unsigned __int8 *v8;
  void **v9;

  v8 = a2;
  memset(v7, 0, sizeof(v7));
  tlv::parseV<vs::tlv::RemoteNumberList>(&v8, a3, v7);
  v5 = v8;
  if (v8)
    (*(void (**)(void))(*(_QWORD *)a4 + 16))();
  v9 = (void **)v7;
  std::vector<vs::tlv::RemoteNumberListItem>::__destroy_vector::operator()[abi:ne180100](&v9);
  return v5 != 0;
}

void sub_2169D0DC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, void **a14)
{
  a14 = (void **)&a10;
  std::vector<vs::tlv::RemoteNumberListItem>::__destroy_vector::operator()[abi:ne180100](&a14);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN15EurOTASPService11sendDialReqES0_RKNSt3__112basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEEN2vs8callList9Call_TypeEN10subscriber7SimSlotEE3__0EEOS1_OT__block_invoke(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  NSObject *v7;
  NSObject *v8;
  _QWORD v9[3];
  uint8_t buf[16];
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  int v14;
  _BYTE v15[24];
  void *v16;
  uint64_t *v17;
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  v2 = **(_QWORD **)(a1 + 32);
  v3 = a2[1];
  v9[0] = *a2;
  v9[1] = v3;
  v4 = a2[2];
  v9[2] = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  if (HIDWORD(v9[0]))
  {
    v7 = *(NSObject **)(v2 + 24);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v15 = 136315394;
      *(_QWORD *)&v15[4] = qmi::asString();
      *(_WORD *)&v15[12] = 1024;
      *(_DWORD *)&v15[14] = WORD2(v9[0]);
      _os_log_error_impl(&dword_216897000, v7, OS_LOG_TYPE_ERROR, "Error in otaps (voice) dail response with %s (0x%02x)", v15, 0x12u);
    }
    *(_BYTE *)(v2 + 77) = 0;
    *(_DWORD *)(v2 + 72) = -1;
  }
  else
  {
    v11 = 0;
    v12 = &v11;
    v13 = 0x2000000000;
    v14 = -1;
    *(_QWORD *)v15 = MEMORY[0x24BDAC760];
    *(_QWORD *)&v15[8] = 0x40000000;
    *(_QWORD *)&v15[16] = ___ZN15EurOTASPService24handleOtaspVoiceDialRespEN2vs13VoiceDialCall8ResponseE_block_invoke;
    v16 = &unk_24D5DAA98;
    v17 = &v11;
    *(_QWORD *)buf = v15;
    if ((qmi::MessageBase::applyTlv<vs::tlv::CallIdentifier,void({block_pointer})(vs::tlv::CallIdentifier const&)>((qmi::MessageBase *)v9, 16, (uint64_t)buf) & 1) != 0)
    {
      *(_DWORD *)(v2 + 72) = *((_DWORD *)v12 + 6);
    }
    else
    {
      v8 = *(NSObject **)(v2 + 24);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_216897000, v8, OS_LOG_TYPE_DEFAULT, "#E Mandatory TLV, callId, (0x01) not present. Ignoring response.", buf, 2u);
      }
    }
    _Block_object_dispose(&v11, 8);
  }
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v9);
}

void sub_2169D0FA8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3;
  va_list va;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  v5 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  _Block_object_dispose(va1, 8);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_32c190_ZTSNSt3__110shared_ptrIZN15EurOTASPService11sendDialReqEN3qmi12ClientRouterERKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEN2vs8callList9Call_TypeEN10subscriber7SimSlotEE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c190_ZTSNSt3__110shared_ptrIZN15EurOTASPService11sendDialReqEN3qmi12ClientRouterERKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEN2vs8callList9Call_TypeEN10subscriber7SimSlotEE3__0EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<EurOTASPService::sendDialReq(qmi::ClientRouter,std::string const&,vs::callList::Call_Type,subscriber::SimSlot)::$_0,std::allocator<EurOTASPService::sendDialReq(qmi::ClientRouter,std::string const&,vs::callList::Call_Type,subscriber::SimSlot)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5DAB60;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<EurOTASPService::sendDialReq(qmi::ClientRouter,std::string const&,vs::callList::Call_Type,subscriber::SimSlot)::$_0,std::allocator<EurOTASPService::sendDialReq(qmi::ClientRouter,std::string const&,vs::callList::Call_Type,subscriber::SimSlot)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5DAB60;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN2vs13VoiceDialCall8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BYTE v3[24];

  v2 = *(_QWORD *)(a1 + 32);
  cast_message_type<vs::VoiceDialCall::Response const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_2169D108C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void cast_message_type<vs::VoiceDialCall::Response const&>::cast(uint64_t a1@<X0>, qmi::ResponseBase *a2@<X8>)
{
  if (*(_DWORD *)(a1 + 40) != 1 || *(_WORD *)(a1 + 44) == 3)
  {
    QMIServiceMsg::serialize((QMIServiceMsg *)a1);
    qmi::Response<(unsigned short)32,vs::VoiceDialCall::ResponseTLVList>::Response(a2, 0);
  }
  else
  {
    QMIServiceMsg::getNewError((QMIServiceMsg *)a1);
    qmi::Response<(unsigned short)32,vs::VoiceDialCall::ResponseTLVList>::Response((uint64_t)a2);
  }
}

void sub_2169D112C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t qmi::Response<(unsigned short)32,vs::VoiceDialCall::ResponseTLVList>::Response(uint64_t a1)
{
  qmi::MessageBase *v2;

  v2 = (qmi::MessageBase *)qmi::MessageBase::MessageBase();
  qmi::MessageBase::validateMsgId(v2);
  return a1;
}

void sub_2169D1174(_Unwind_Exception *a1)
{
  qmi::MessageBase *v1;

  qmi::MessageBase::~MessageBase(v1);
  _Unwind_Resume(a1);
}

qmi::ResponseBase *qmi::Response<(unsigned short)32,vs::VoiceDialCall::ResponseTLVList>::Response(qmi::ResponseBase *a1, const void *a2)
{
  qmi::MessageBase *v3;

  v3 = (qmi::MessageBase *)qmi::ResponseBase::ResponseBase(a1, a2);
  qmi::MessageBase::validateMsgId(v3);
  return a1;
}

void sub_2169D11B4(_Unwind_Exception *a1)
{
  qmi::MessageBase *v1;

  qmi::MessageBase::~MessageBase(v1);
  _Unwind_Resume(a1);
}

uint64_t qmi::ClientRouter::SendProxy::SendProxy<vs::EndCall::Request>(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v5;

  *(_DWORD *)a1 = a2;
  v5 = operator new();
  *(_QWORD *)v5 = a3;
  *(_QWORD *)(v5 + 8) = QMIServiceMsg::create();
  *(_DWORD *)(v5 + 16) = 25000;
  *(_QWORD *)(v5 + 24) = 0;
  *(_QWORD *)(v5 + 32) = 0;
  *(_QWORD *)(a1 + 8) = v5;
  return a1;
}

void sub_2169D1238(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199FEAC4](v1, 0x10F0C401BA14CC5);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_32c110_ZTSNSt3__110shared_ptrIZN15EurOTASPService14sendEndcallReqEN3qmi12ClientRouterEhN10subscriber7SimSlotEE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c110_ZTSNSt3__110shared_ptrIZN15EurOTASPService14sendEndcallReqEN3qmi12ClientRouterEhN10subscriber7SimSlotEE3__0EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<EurOTASPService::sendEndcallReq(qmi::ClientRouter,unsigned char,subscriber::SimSlot)::$_0,std::allocator<EurOTASPService::sendEndcallReq(qmi::ClientRouter,unsigned char,subscriber::SimSlot)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5DAC08;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<EurOTASPService::sendEndcallReq(qmi::ClientRouter,unsigned char,subscriber::SimSlot)::$_0,std::allocator<EurOTASPService::sendEndcallReq(qmi::ClientRouter,unsigned char,subscriber::SimSlot)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5DAC08;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN2vs7EndCall8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BYTE v3[24];

  v2 = *(_QWORD *)(a1 + 32);
  cast_message_type<vs::EndCall::Response const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_2169D131C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void cast_message_type<vs::EndCall::Response const&>::cast(uint64_t a1@<X0>, qmi::ResponseBase *a2@<X8>)
{
  if (*(_DWORD *)(a1 + 40) != 1 || *(_WORD *)(a1 + 44) == 3)
  {
    QMIServiceMsg::serialize((QMIServiceMsg *)a1);
    qmi::Response<(unsigned short)33,vs::EndCall::ResponseTLVList>::Response(a2, 0);
  }
  else
  {
    QMIServiceMsg::getNewError((QMIServiceMsg *)a1);
    qmi::Response<(unsigned short)33,vs::EndCall::ResponseTLVList>::Response((uint64_t)a2);
  }
}

void sub_2169D13BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t qmi::Response<(unsigned short)33,vs::EndCall::ResponseTLVList>::Response(uint64_t a1)
{
  qmi::MessageBase *v2;

  v2 = (qmi::MessageBase *)qmi::MessageBase::MessageBase();
  qmi::MessageBase::validateMsgId(v2);
  return a1;
}

void sub_2169D1404(_Unwind_Exception *a1)
{
  qmi::MessageBase *v1;

  qmi::MessageBase::~MessageBase(v1);
  _Unwind_Resume(a1);
}

qmi::ResponseBase *qmi::Response<(unsigned short)33,vs::EndCall::ResponseTLVList>::Response(qmi::ResponseBase *a1, const void *a2)
{
  qmi::MessageBase *v3;

  v3 = (qmi::MessageBase *)qmi::ResponseBase::ResponseBase(a1, a2);
  qmi::MessageBase::validateMsgId(v3);
  return a1;
}

void sub_2169D1444(_Unwind_Exception *a1)
{
  qmi::MessageBase *v1;

  qmi::MessageBase::~MessageBase(v1);
  _Unwind_Resume(a1);
}

uint64_t subscriber::sGetSimFilePath(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t SimFilePath;
  char v5[8];
  void *__p;
  void *v7;

  subscriber::sConvertFileId(v5, a3);
  SimFilePath = subscriber::getSimFilePath();
  if (__p)
  {
    v7 = __p;
    operator delete(__p);
  }
  return SimFilePath;
}

void sub_2169D14B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

double subscriber::EURSimCommandDriver::create@<D0>(_OWORD *a1@<X8>)
{
  uint64_t v2;
  double result;
  __int128 v4;

  v2 = operator new();
  subscriber::EURSimCommandDriver::EURSimCommandDriver(v2);
  v4 = 0uLL;
  std::shared_ptr<subscriber::EURSimCommandDriver>::shared_ptr[abi:ne180100]<subscriber::EURSimCommandDriver,std::shared_ptr<subscriber::EURSimCommandDriver> ctu::SharedSynchronizable<subscriber::SimCommandDriver>::make_shared_ptr<subscriber::EURSimCommandDriver>(subscriber::EURSimCommandDriver*)::{lambda(subscriber::EURSimCommandDriver*)#1},void>((uint64_t *)&v4, v2);
  result = *(double *)&v4;
  *a1 = v4;
  return result;
}

void sub_2169D1544(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199FEAC4](v1, 0x10E1C40E6D98D44);
  _Unwind_Resume(a1);
}

uint64_t subscriber::EURSimCommandDriver::EURSimCommandDriver(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  _QWORD v5[3];
  _QWORD *v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = &off_24D5DB3F0;
  v6 = v5;
  subscriber::SimCommandDriver::SimCommandDriver();
  v2 = v6;
  if (v6 == v5)
  {
    v3 = 4;
    v2 = v5;
    goto LABEL_5;
  }
  if (v6)
  {
    v3 = 5;
LABEL_5:
    (*(void (**)(void))(*v2 + 8 * v3))();
  }
  *(_QWORD *)a1 = &unk_24D5DAC80;
  *(_QWORD *)(a1 + 192) = 0;
  *(_QWORD *)(a1 + 200) = 0;
  *(_QWORD *)(a1 + 184) = 0;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_BYTE *)(a1 + 160) = 0;
  *(_QWORD *)(a1 + 168) = 0;
  *(_QWORD *)(a1 + 176) = a1 + 184;
  *(_QWORD *)(a1 + 232) = 0;
  *(_QWORD *)(a1 + 208) = 0;
  *(_QWORD *)(a1 + 216) = 0;
  *(_QWORD *)(a1 + 224) = a1 + 232;
  *(_QWORD *)(a1 + 256) = 0;
  *(_QWORD *)(a1 + 264) = 0;
  *(_QWORD *)(a1 + 240) = 0;
  *(_QWORD *)(a1 + 248) = a1 + 256;
  *(_QWORD *)(a1 + 280) = 0;
  *(_QWORD *)(a1 + 288) = 0;
  *(_QWORD *)(a1 + 272) = a1 + 280;
  *(_WORD *)(a1 + 296) = 0;
  *(_BYTE *)(a1 + 298) = 0;
  *(_QWORD *)(a1 + 300) = 0;
  return a1;
}

void sub_2169D1674(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v13;
  char *v15;
  uint64_t v16;

  v15 = a13;
  if (a13 == v13)
  {
    v16 = 4;
    v15 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v16 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v15 + 8 * v16))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t subscriber::EURSimCommandDriver::init_sync(subscriber::EURSimCommandDriver *this)
{
  NSObject *v2;
  std::__shared_weak_count *v3;
  uint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_weak_owners;
  unint64_t v7;
  uint64_t *p_shared_owners;
  unint64_t v9;
  uint64_t *v10;
  unint64_t v11;
  uint64_t v12;
  capabilities::ct *v13;
  uint64_t result;
  _QWORD v15[15];
  _QWORD v16[5];
  _QWORD v17[5];
  std::__shared_weak_count *v18;
  uint64_t v19;
  std::__shared_weak_count *v20;
  uint64_t v21;
  std::__shared_weak_count *v22;
  void *v23;
  char v24;
  dispatch_object_t v25;
  void *v26;
  char v27;
  uint64_t v28;
  uint64_t v29;
  __int128 v30;
  _QWORD *v31;

  std::string::basic_string[abi:ne180100]<0>(&v26, "subscriber::EURSimCommandDriver");
  v2 = *((_QWORD *)this + 3);
  v25 = v2;
  if (v2)
    dispatch_retain(v2);
  std::string::basic_string[abi:ne180100]<0>(&v23, "sim");
  v4 = *((_QWORD *)this + 1);
  v3 = (std::__shared_weak_count *)*((_QWORD *)this + 2);
  v19 = v4;
  if (!v3 || (v5 = std::__shared_weak_count::lock(v3), (v20 = v5) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v21 = v4;
  v22 = v5;
  p_shared_weak_owners = (unint64_t *)&v5->__shared_weak_owners_;
  do
    v7 = __ldxr(p_shared_weak_owners);
  while (__stxr(v7 + 1, p_shared_weak_owners));
  Registry::getServerConnection(*((Registry **)this + 7));
  qmi::Client::createWithQueueLocal();
  std::shared_ptr<qmi::Client::State>::operator=[abi:ne180100]((uint64_t)this + 144, &v30);
  qmi::Client::~Client((qmi::Client *)&v28);
  if (v18)
  {
    p_shared_owners = &v18->__shared_owners_;
    do
      v9 = __ldaxr((unint64_t *)p_shared_owners);
    while (__stlxr(v9 - 1, (unint64_t *)p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
  std::__shared_weak_count::__release_weak(v22);
  if (v20)
  {
    v10 = &v20->__shared_owners_;
    do
      v11 = __ldaxr((unint64_t *)v10);
    while (__stlxr(v11 - 1, (unint64_t *)v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
  if (v24 < 0)
    operator delete(v23);
  if (v25)
    dispatch_release(v25);
  if (v27 < 0)
    operator delete(v26);
  v12 = MEMORY[0x24BDAC760];
  v17[0] = MEMORY[0x24BDAC760];
  v17[1] = 0x40000000;
  v17[2] = ___ZN10subscriber19EURSimCommandDriver9init_syncEv_block_invoke;
  v17[3] = &__block_descriptor_tmp_30;
  v17[4] = this;
  v28 = MEMORY[0x24BDAC760];
  v29 = 0x40000000;
  *(_QWORD *)&v30 = ___ZNK3qmi6Client13setIndHandlerIRKN3uim16CardStatusChange10IndicationEEEvtU13block_pointerFvT_E_block_invoke;
  *((_QWORD *)&v30 + 1) = &unk_24D5DB488;
  v31 = v17;
  qmi::Client::setIndHandler();
  v16[0] = v12;
  v16[1] = 0x40000000;
  v16[2] = ___ZN10subscriber19EURSimCommandDriver9init_syncEv_block_invoke_2;
  v16[3] = &__block_descriptor_tmp_4_4;
  v16[4] = this;
  v28 = v12;
  v29 = 0x40000000;
  *(_QWORD *)&v30 = ___ZNK3qmi6Client13setIndHandlerIRKN3uim7Refresh10IndicationEEEvtU13block_pointerFvT_E_block_invoke;
  *((_QWORD *)&v30 + 1) = &unk_24D5DB4B0;
  v31 = v16;
  qmi::Client::setIndHandler();
  qmi::Client::setIndShouldWake((subscriber::EURSimCommandDriver *)((char *)this + 128));
  qmi::Client::setIndShouldWake((subscriber::EURSimCommandDriver *)((char *)this + 128));
  v15[10] = v12;
  v15[11] = 0x40000000;
  v15[12] = ___ZN10subscriber19EURSimCommandDriver9init_syncEv_block_invoke_3;
  v15[13] = &__block_descriptor_tmp_6_4;
  v15[14] = this;
  qmi::Client::setHandler();
  v15[5] = v12;
  v15[6] = 0x40000000;
  v15[7] = ___ZN10subscriber19EURSimCommandDriver9init_syncEv_block_invoke_4;
  v15[8] = &__block_descriptor_tmp_7_9;
  v15[9] = this;
  v13 = (capabilities::ct *)qmi::Client::setHandler();
  result = capabilities::ct::supportsSIMDetectionInterrupt(v13);
  if ((_DWORD)result)
  {
    v15[0] = v12;
    v15[1] = 0x40000000;
    v15[2] = ___ZN10subscriber19EURSimCommandDriver9init_syncEv_block_invoke_5;
    v15[3] = &__block_descriptor_tmp_8_13;
    v15[4] = this;
    v28 = v12;
    v29 = 0x40000000;
    *(_QWORD *)&v30 = ___ZNK3qmi6Client13setIndHandlerIRKN3uim18CardDebounceStatus10IndicationEEEvtU13block_pointerFvT_E_block_invoke;
    *((_QWORD *)&v30 + 1) = &unk_24D5DB4D8;
    v31 = v15;
    return qmi::Client::setIndHandler();
  }
  return result;
}

void sub_2169D19F8(_Unwind_Exception *a1)
{
  uint64_t v1;
  NSObject *v3;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v1 - 192);
  if (*(_QWORD *)(v1 - 152))
    std::__shared_weak_count::__release_weak(*(std::__shared_weak_count **)(v1 - 152));
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v1 - 176);
  if (*(char *)(v1 - 121) < 0)
    operator delete(*(void **)(v1 - 144));
  v3 = *(NSObject **)(v1 - 120);
  if (v3)
    dispatch_release(v3);
  if (*(char *)(v1 - 89) < 0)
    operator delete(*(void **)(v1 - 112));
  _Unwind_Resume(a1);
}

void ___ZN10subscriber19EURSimCommandDriver9init_syncEv_block_invoke(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v3;
  NSObject *v4;
  int v5;
  NSObject *v6;
  uint64_t v7;
  const char *v8;
  NSObject *v9;
  uint32_t v10;
  NSObject *v11;
  uint8_t *v12;
  capabilities::ct *v13;
  std::__shared_weak_count *v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  uint8_t *v19;
  uint64_t v20;
  void *v21;
  void *v22;
  uint64_t v23;
  qmi::MessageBase *v24;
  uint8_t **v25;
  uint8_t buf[8];
  __int128 v27;
  void *v28;
  uint64_t v29;
  qmi::MessageBase *v30;
  uint64_t v31;

  v31 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 + 32);
  v4 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I handling uim::CardStatusChange::Indication", buf, 2u);
  }
  if (!*(_BYTE *)(v3 + 296))
  {
    v11 = *(NSObject **)(v3 + 40);
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      return;
    *(_WORD *)buf = 0;
    v8 = "#I CardStatusChange ignored while offline";
    v9 = v11;
    v10 = 2;
    goto LABEL_9;
  }
  v5 = *((_DWORD *)a2 + 1);
  if (v5)
  {
    v6 = *(NSObject **)(v3 + 40);
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      return;
    v7 = qmi::asString();
    *(_DWORD *)buf = 67109378;
    *(_DWORD *)&buf[4] = v5;
    LOWORD(v27) = 2080;
    *(_QWORD *)((char *)&v27 + 2) = v7;
    v8 = "#N CardStatusChange returns error: 0x%04x (%s)";
    v9 = v6;
    v10 = 18;
LABEL_9:
    _os_log_impl(&dword_216897000, v9, OS_LOG_TYPE_DEFAULT, v8, buf, v10);
    return;
  }
  std::vector<subscriber::VinylCapability>::__assign_with_size[abi:ne180100]<subscriber::VinylCapability const*,subscriber::VinylCapability const*>((char *)(v3 + 200), 0, 0, 0);
  v12 = (uint8_t *)MEMORY[0x24BDAC760];
  *(_QWORD *)buf = MEMORY[0x24BDAC760];
  *(_QWORD *)&v27 = 0x40000000;
  *((_QWORD *)&v27 + 1) = ___ZN10subscriber19sHandleVinylAbilityIN3uim16CardStatusChange10IndicationEEEvRKT_RNSt3__16vectorINS_15VinylCapabilityENS7_9allocatorIS9_EEEE_block_invoke;
  v28 = &__block_descriptor_tmp_121_0;
  v29 = v3 + 200;
  v19 = buf;
  if ((qmi::MessageBase::applyTlv<uim::tlv::VinylSupport,void({block_pointer}&)(uim::tlv::VinylSupport const&)>(a2, (uint64_t)&v19) & 1) == 0)
  {
    v19 = v12;
    v20 = 0x40000000;
    v21 = ___ZN10subscriber19sHandleVinylAbilityIN3uim16CardStatusChange10IndicationEEEvRKT_RNSt3__16vectorINS_15VinylCapabilityENS7_9allocatorIS9_EEEE_block_invoke_2;
    v22 = &__block_descriptor_tmp_122_0;
    v23 = v3 + 200;
    v25 = &v19;
    qmi::MessageBase::applyTlv<uim::tlv::VinylSupportLegacy,void({block_pointer}&)(uim::tlv::VinylSupportLegacy const&)>(a2, (uint64_t)&v25);
  }
  *(_QWORD *)buf = v12;
  *(_QWORD *)&v27 = 0x40000000;
  *((_QWORD *)&v27 + 1) = ___ZN10subscriber13sHandleIccidsIN3uim16CardStatusChange10IndicationEEEvRKT_RNSt3__13mapIjNS7_12basic_stringIcNS7_11char_traitsIcEENS7_9allocatorIcEEEENS7_4lessIjEENSC_INS7_4pairIKjSE_EEEEEE_block_invoke;
  v28 = &__block_descriptor_tmp_123_1;
  v29 = v3 + 224;
  v19 = buf;
  qmi::MessageBase::applyTlv<uim::tlv::Iccids,void({block_pointer}&)(uim::tlv::Iccids const&)>(a2, (uint64_t)&v19);
  v19 = v12;
  v20 = 0x40000000;
  v21 = ___ZN10subscriber13sHandleIccidsIN3uim16CardStatusChange10IndicationEEEvRKT_RNSt3__13mapIjNS7_12basic_stringIcNS7_11char_traitsIcEENS7_9allocatorIcEEEENS7_4lessIjEENSC_INS7_4pairIKjSE_EEEEEE_block_invoke_2;
  v22 = &__block_descriptor_tmp_124_0;
  v23 = v3 + 224;
  v25 = &v19;
  qmi::MessageBase::applyTlv<uim::tlv::ExtendedCardInfoList,void({block_pointer}&)(uim::tlv::ExtendedCardInfoList const&)>(a2, 20, (uint64_t)&v25);
  *(_QWORD *)buf = v12;
  *(_QWORD *)&v27 = 0x40000000;
  *((_QWORD *)&v27 + 1) = ___ZN10subscriber19sHandleCardInfoListIN3uim16CardStatusChange10IndicationEEEvRKT_RNSt3__13mapIjNS7_6vectorIhNS7_9allocatorIhEEEENS7_4lessIjEENSA_INS7_4pairIKjSC_EEEEEE_block_invoke;
  v28 = &__block_descriptor_tmp_125_0;
  v29 = v3 + 272;
  v19 = buf;
  qmi::MessageBase::applyTlv<uim::tlv::ExtendedCardInfoList,void({block_pointer}&)(uim::tlv::ExtendedCardInfoList const&)>(a2, 20, (uint64_t)&v19);
  v14 = *(std::__shared_weak_count **)(v3 + 64);
  if (v14)
  {
    p_shared_owners = (unint64_t *)&v14->__shared_owners_;
    do
      v16 = __ldxr(p_shared_owners);
    while (__stxr(v16 + 1, p_shared_owners));
  }
  if (capabilities::ct::supportsSIMMomentaryPowerDown(v13))
  {
    std::__tree<std::__value_type<AQMThroughputKey,unsigned int>,std::__map_value_compare<AQMThroughputKey,std::__value_type<AQMThroughputKey,unsigned int>,std::less<AQMThroughputKey>,true>,std::allocator<std::__value_type<AQMThroughputKey,unsigned int>>>::destroy(*(_QWORD **)(v3 + 256));
    *(_QWORD *)(v3 + 256) = 0;
    *(_QWORD *)(v3 + 264) = 0;
    *(_QWORD *)(v3 + 248) = v3 + 256;
    *(_QWORD *)buf = v12;
    *(_QWORD *)&v27 = 0x40000000;
    *((_QWORD *)&v27 + 1) = ___ZN10subscriber27sHandleIsMomentaryPowerDownIN3uim16CardStatusChange10IndicationEEEvNSt3__110shared_ptrIK8RegistryEERKT_RNS4_3mapIjbNS4_4lessIjEENS4_9allocatorINS4_4pairIKjbEEEEEE_block_invoke;
    v28 = &__block_descriptor_tmp_126_1;
    v29 = v3 + 248;
    v19 = buf;
    qmi::MessageBase::applyTlv<uim::tlv::IsMomentaryPowerDown,void({block_pointer}&)(uim::tlv::IsMomentaryPowerDown const&)>(a2, 21, (uint64_t)&v19);
  }
  if (v14)
  {
    v17 = (unint64_t *)&v14->__shared_owners_;
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
  *(_QWORD *)buf = v12;
  *(_QWORD *)&v27 = 0x40000000;
  *((_QWORD *)&v27 + 1) = ___ZN10subscriber19EURSimCommandDriver20handleCardStatus_indERKN3uim16CardStatusChange10IndicationE_block_invoke;
  v28 = &__block_descriptor_tmp_21_8;
  v29 = v3;
  v30 = a2;
  v19 = buf;
  if ((qmi::MessageBase::applyTlv<uim::tlv::ExtendedCardStatus,void({block_pointer})(uim::tlv::ExtendedCardStatus const&)>(a2, 18, (uint64_t)&v19) & 1) == 0)
  {
    v19 = v12;
    v20 = 0x40000000;
    v21 = ___ZN10subscriber19EURSimCommandDriver20handleCardStatus_indERKN3uim16CardStatusChange10IndicationE_block_invoke_2;
    v22 = &__block_descriptor_tmp_22_11;
    v23 = v3;
    v24 = a2;
    v25 = &v19;
    qmi::MessageBase::applyTlv<uim::tlv::CardStatus,void({block_pointer})(uim::tlv::CardStatus const&)>(a2, (uint64_t)&v25);
  }
}

void sub_2169D1E14(_Unwind_Exception *exception_object)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v4;

  if (v1)
  {
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
  _Unwind_Resume(exception_object);
}

void ___ZN10subscriber19EURSimCommandDriver9init_syncEv_block_invoke_2(uint64_t a1, qmi::MessageBase *this)
{
  uint64_t v3;
  uim::tlv *TlvValue;
  int v5;
  uim::tlv::Refresh *v6;
  uim::tlv *v7;
  int v8;
  uim::tlv *v9;
  NSObject *v10;
  _QWORD v11[5];
  uint8_t buf[16];
  void *__p[2];
  _OWORD v14[2];
  uim::tlv *v15;
  void **v16;

  v3 = *(_QWORD *)(a1 + 32);
  v11[0] = MEMORY[0x24BDAC760];
  v11[1] = 0x40000000;
  v11[2] = ___ZN10subscriber19EURSimCommandDriver17handleRefresh_indERKN3uim7Refresh10IndicationE_block_invoke;
  v11[3] = &__block_descriptor_tmp_35_7;
  v11[4] = v3;
  TlvValue = (uim::tlv *)qmi::MessageBase::findTlvValue(this);
  if (!TlvValue)
    goto LABEL_8;
  v7 = TlvValue;
  v8 = v5;
  v15 = TlvValue;
  memset(v14, 0, sizeof(v14));
  *(_OWORD *)buf = 0u;
  *(_OWORD *)__p = 0u;
  tlv::parseV<uim::tlv::Refresh>(&v15, v5, v6, (uint64_t)buf);
  v9 = v15;
  if (v15)
    ___ZN10subscriber19EURSimCommandDriver17handleRefresh_indERKN3uim7Refresh10IndicationE_block_invoke((uint64_t)v11, buf);
  v16 = (void **)v14 + 1;
  std::vector<at::tlv::CommandCallback>::__destroy_vector::operator()[abi:ne180100](&v16);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (!v9
    && (((uint64_t (*)(_QWORD, uint64_t, uim::tlv *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)this, 16, v7, v8) & 1) == 0)
  {
LABEL_8:
    v10 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_216897000, v10, OS_LOG_TYPE_DEFAULT, "#I Got uim::Refresh::Indication with no refresh TLV; ignoring",
        buf,
        2u);
    }
  }
}

void sub_2169D1FA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18)
{
  uint64_t v18;
  uint64_t v19;

  *(_QWORD *)(v19 - 72) = v18 + 40;
  std::vector<at::tlv::CommandCallback>::__destroy_vector::operator()[abi:ne180100]((void ***)(v19 - 72));
  if (__p)
    operator delete(__p);
  _Unwind_Resume(a1);
}

void ___ZN10subscriber19EURSimCommandDriver9init_syncEv_block_invoke_3(uint64_t a1)
{
  subscriber::EURSimCommandDriver *v1;
  const void **v2;
  char *v3;
  int *v4;
  char *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  char *v11;
  char *v12;
  char *v13;
  char *v14;
  uint64_t v15;
  int v16;
  void *__p[2];
  __int128 v18;

  v1 = *(subscriber::EURSimCommandDriver **)(a1 + 32);
  *((_BYTE *)v1 + 296) = 1;
  *(_OWORD *)__p = 0u;
  v18 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  v2 = (const void **)__p[1];
  if (__p[1] != (void *)v18)
  {
    while (*((_BYTE *)*v2 + 8) != 1)
    {
      if (++v2 == (const void **)v18)
        goto LABEL_8;
    }
  }
  if (v2 == (const void **)v18)
  {
LABEL_8:
    v3 = (char *)operator new();
    v5 = v3;
    v3[8] = 1;
    *(_QWORD *)v3 = &off_24D5DB520;
    *((_DWORD *)v3 + 3) = 0;
    v4 = (int *)(v3 + 12);
    v6 = v18;
    if ((unint64_t)v18 >= *((_QWORD *)&v18 + 1))
    {
      v8 = (uint64_t)(v18 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v8 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v9 = (uint64_t)(*((_QWORD *)&v18 + 1) - (unint64_t)__p[1]) >> 2;
      if (v9 <= v8 + 1)
        v9 = v8 + 1;
      if (*((_QWORD *)&v18 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v10 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v10 = v9;
      if (v10)
        v11 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v18 + 8, v10);
      else
        v11 = 0;
      v12 = &v11[8 * v8];
      v13 = &v11[8 * v10];
      *(_QWORD *)v12 = v5;
      v7 = v12 + 8;
      v14 = (char *)__p[1];
      v3 = (char *)v18;
      if ((void *)v18 != __p[1])
      {
        do
        {
          v15 = *((_QWORD *)v3 - 1);
          v3 -= 8;
          *((_QWORD *)v12 - 1) = v15;
          v12 -= 8;
        }
        while (v3 != v14);
        v3 = (char *)__p[1];
      }
      __p[1] = v12;
      *(_QWORD *)&v18 = v7;
      *((_QWORD *)&v18 + 1) = v13;
      if (v3)
        operator delete(v3);
    }
    else
    {
      *(_QWORD *)v18 = v3;
      v7 = (_QWORD *)(v6 + 8);
    }
    *(_QWORD *)&v18 = v7;
  }
  else
  {
    if (!v3)
      __cxa_bad_cast();
    v4 = (int *)(v3 + 12);
  }
  if (capabilities::ct::supportsHydra((capabilities::ct *)v3))
    v16 = 4;
  else
    v16 = 1;
  *v4 = v16;
  if (QMIServiceMsg::create())
    qmi::Client::send();
  subscriber::EURSimCommandDriver::queryStatus(v1);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
}

void sub_2169D21D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

void ___ZN10subscriber19EURSimCommandDriver9init_syncEv_block_invoke_4(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  _QWORD v3[3];
  void **v4;

  v1 = *(_QWORD *)(a1 + 32);
  *(_BYTE *)(v1 + 296) = 0;
  v2 = *(NSObject **)(v1 + 168);
  *(_QWORD *)(v1 + 168) = 0;
  if (v2)
    dispatch_release(v2);
  std::__tree<std::__value_type<uim::SessionType,dispatch::group_session>,std::__map_value_compare<uim::SessionType,std::__value_type<uim::SessionType,dispatch::group_session>,std::less<uim::SessionType>,true>,std::allocator<std::__value_type<uim::SessionType,dispatch::group_session>>>::destroy(*(_QWORD **)(v1 + 184));
  *(_QWORD *)(v1 + 176) = v1 + 184;
  *(_QWORD *)(v1 + 192) = 0;
  *(_QWORD *)(v1 + 184) = 0;
  std::__tree<std::__value_type<unsigned int,std::string>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::string>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::string>>>::destroy(*(char **)(v1 + 232));
  *(_QWORD *)(v1 + 224) = v1 + 232;
  *(_QWORD *)(v1 + 240) = 0;
  *(_QWORD *)(v1 + 232) = 0;
  std::__tree<std::__value_type<unsigned int,std::vector<unsigned char>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<unsigned char>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::vector<unsigned char>>>>::destroy(*(_QWORD **)(v1 + 280));
  *(_QWORD *)(v1 + 280) = 0;
  *(_QWORD *)(v1 + 288) = 0;
  *(_QWORD *)(v1 + 272) = v1 + 280;
  memset(v3, 0, sizeof(v3));
  subscriber::SimCommandDriver::sendSimDriverInfo();
  v4 = (void **)v3;
  std::vector<subscriber::SimDriverInfo>::__destroy_vector::operator()[abi:ne180100](&v4);
}

void sub_2169D2290(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  std::vector<subscriber::SimDriverInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

void ___ZN10subscriber19EURSimCommandDriver9init_syncEv_block_invoke_5(uint64_t a1, qmi::MessageBase *this)
{
  uint64_t v3;
  uint64_t TlvValue;
  int v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  _QWORD v9[5];
  _QWORD v10[2];
  uint64_t v11;

  v3 = *(_QWORD *)(a1 + 32);
  v9[0] = MEMORY[0x24BDAC760];
  v9[1] = 0x40000000;
  v9[2] = ___ZNK10subscriber19EURSimCommandDriver27handleCardDebounceState_indERKN3uim18CardDebounceStatus10IndicationE_block_invoke;
  v9[3] = &__block_descriptor_tmp_10_9;
  v9[4] = v3;
  TlvValue = qmi::MessageBase::findTlvValue(this);
  if (TlvValue)
  {
    v6 = TlvValue;
    v7 = v5;
    v11 = TlvValue;
    v10[0] = tlv::parseV<uim::tlv::DebouncingState>((unint64_t *)&v11, v5);
    v10[1] = v8;
    if (v11)
      ___ZNK10subscriber19EURSimCommandDriver27handleCardDebounceState_indERKN3uim18CardDebounceStatus10IndicationE_block_invoke((uint64_t)v9, v10);
    else
      ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)this, 241, v6, v7);
  }
}

void ___ZNK10subscriber19EURSimCommandDriver27handleCardDebounceState_indERKN3uim18CardDebounceStatus10IndicationE_block_invoke(uint64_t a1, _BYTE *a2)
{
  NSObject *v2;
  uint8_t v3[16];

  if (*a2 == 1)
  {
    v2 = *(NSObject **)(*(_QWORD *)(a1 + 32) + 40);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v3 = 0;
      _os_log_impl(&dword_216897000, v2, OS_LOG_TYPE_DEFAULT, "#I Sim tray detected", v3, 2u);
    }
  }
}

uint64_t subscriber::EURSimCommandDriver::start(Registry **this)
{
  std::mutex *ServiceMap;
  capabilities::ct *v3;
  char v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  uint64_t v12;
  std::__shared_weak_count *v13;

  ServiceMap = (std::mutex *)Registry::getServiceMap(this[7]);
  ctu::shared_ptr_map_impl<ctu::indexed_by_any_map_hashing_key>::get<GestaltUtilityInterface>(ServiceMap, &v12);
  v3 = (capabilities::ct *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v12 + 72))(v12);
  if ((_DWORD)v3)
  {
    v4 = capabilities::ct::supportsDualPhysicalSIM(v3);
    v5 = v13;
    if (v13)
    {
      p_shared_owners = (unint64_t *)&v13->__shared_owners_;
      do
        v7 = __ldaxr(p_shared_owners);
      while (__stlxr(v7 - 1, p_shared_owners));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
    }
    if ((v4 & 1) == 0)
      *((_BYTE *)this + 160) = 1;
  }
  else
  {
    v8 = v13;
    if (v13)
    {
      v9 = (unint64_t *)&v13->__shared_owners_;
      do
        v10 = __ldaxr(v9);
      while (__stlxr(v10 - 1, v9));
      if (!v10)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }
  }
  return qmi::Client::start((qmi::Client *)(this + 16));
}

void sub_2169D24B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t subscriber::EURSimCommandDriver::stop(subscriber::EURSimCommandDriver *this)
{
  return qmi::Client::stop((subscriber::EURSimCommandDriver *)((char *)this + 128));
}

void subscriber::EURSimCommandDriver::queryStatus(subscriber::EURSimCommandDriver *this)
{
  const void **v2;
  char *v3;
  _BYTE *v4;
  NSObject *v5;
  char *v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  char *v15;
  uint64_t v16;
  void *v17;
  _QWORD v18[6];
  uint64_t v19;
  int v20;
  uint64_t v21;
  void *aBlock;
  void *__p[2];
  __int128 v24;
  uint8_t buf[8];
  uint64_t v26;
  void (*v27)(uint64_t, QMIServiceMsg *);
  void *v28;
  _QWORD *v29;

  if (*((_BYTE *)this + 296))
  {
    *(_OWORD *)__p = 0u;
    v24 = 0u;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
    v2 = (const void **)__p[1];
    if (__p[1] != (void *)v24)
    {
      while (*((_BYTE *)*v2 + 8) != 16)
      {
        if (++v2 == (const void **)v24)
          goto LABEL_11;
      }
    }
    if (v2 == (const void **)v24)
    {
LABEL_11:
      v3 = (char *)operator new();
      v6 = v3;
      *((_WORD *)v3 + 4) = 16;
      *(_QWORD *)v3 = &off_24D5DB570;
      v7 = v24;
      if ((unint64_t)v24 >= *((_QWORD *)&v24 + 1))
      {
        v9 = (uint64_t)(v24 - (unint64_t)__p[1]) >> 3;
        if ((unint64_t)(v9 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v10 = (uint64_t)(*((_QWORD *)&v24 + 1) - (unint64_t)__p[1]) >> 2;
        if (v10 <= v9 + 1)
          v10 = v9 + 1;
        if (*((_QWORD *)&v24 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v11 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v11 = v10;
        if (v11)
          v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v24 + 8, v11);
        else
          v12 = 0;
        v13 = &v12[8 * v9];
        v14 = &v12[8 * v11];
        *(_QWORD *)v13 = v6;
        v8 = v13 + 8;
        v15 = (char *)__p[1];
        v3 = (char *)v24;
        if ((void *)v24 != __p[1])
        {
          do
          {
            v16 = *((_QWORD *)v3 - 1);
            v3 -= 8;
            *((_QWORD *)v13 - 1) = v16;
            v13 -= 8;
          }
          while (v3 != v15);
          v3 = (char *)__p[1];
        }
        __p[1] = v13;
        *(_QWORD *)&v24 = v8;
        *((_QWORD *)&v24 + 1) = v14;
        if (v3)
          operator delete(v3);
      }
      else
      {
        *(_QWORD *)v24 = v3;
        v8 = (_QWORD *)(v7 + 8);
      }
      v4 = v6 + 9;
      *(_QWORD *)&v24 = v8;
    }
    else
    {
      if (!v3)
        __cxa_bad_cast();
      v4 = v3 + 9;
    }
    *v4 = capabilities::ct::supportsHydra((capabilities::ct *)v3);
    v18[5] = (char *)this + 128;
    v19 = QMIServiceMsg::create();
    v21 = 0;
    aBlock = 0;
    v20 = 240000;
    v18[0] = MEMORY[0x24BDAC760];
    v18[1] = 0x40000000;
    v18[2] = ___ZN10subscriber19EURSimCommandDriver11queryStatusEv_block_invoke_2;
    v18[3] = &__block_descriptor_tmp_17_14;
    v18[4] = this;
    *(_QWORD *)buf = MEMORY[0x24BDAC760];
    v26 = 0x40000000;
    v27 = ___ZNO3qmi6Client9SendProxy8callbackIRKN3uim13GetCardStatus8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
    v28 = &unk_24D5DB5A0;
    v29 = v18;
    v17 = _Block_copy(buf);
    aBlock = v17;
    if (v19)
    {
      qmi::Client::send();
      v17 = aBlock;
    }
    if (v17)
      _Block_release(v17);
    qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
  }
  else
  {
    v5 = *((_QWORD *)this + 5);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#I Skipping CardStatus query while baseband in reset", buf, 2u);
    }
  }
}

void sub_2169D275C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  uint64_t v7;
  va_list va;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  va_list va1;

  va_start(va1, a6);
  va_start(va, a6);
  v7 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)va);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va1);
  _Unwind_Resume(a1);
}

void ___ZN10subscriber19EURSimCommandDriver11queryStatusEv_block_invoke_2(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v3;
  NSObject *v4;
  int v5;
  NSObject *v6;
  uint64_t v7;
  const char *v8;
  NSObject *v9;
  uint32_t v10;
  NSObject *v11;
  uint8_t *v12;
  capabilities::ct *v13;
  std::__shared_weak_count *v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  uint8_t *v19;
  uint64_t v20;
  void *v21;
  void *v22;
  uint64_t v23;
  qmi::MessageBase *v24;
  uint8_t **v25;
  uint8_t buf[8];
  __int128 v27;
  void *v28;
  uint64_t v29;
  qmi::MessageBase *v30;
  uint64_t v31;

  v31 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 + 32);
  v4 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I handling uim::GetCardStatus::Response", buf, 2u);
  }
  if (!*(_BYTE *)(v3 + 296))
  {
    v11 = *(NSObject **)(v3 + 40);
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      return;
    *(_WORD *)buf = 0;
    v8 = "#I CardStatus response ignored while offline";
    v9 = v11;
    v10 = 2;
    goto LABEL_11;
  }
  if (*(_BYTE *)(v3 + 298))
    *(_BYTE *)(v3 + 298) = 0;
  v5 = *((_DWORD *)a2 + 1);
  if (v5)
  {
    v6 = *(NSObject **)(v3 + 40);
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      return;
    v7 = qmi::asString();
    *(_DWORD *)buf = 67109378;
    *(_DWORD *)&buf[4] = v5;
    LOWORD(v27) = 2080;
    *(_QWORD *)((char *)&v27 + 2) = v7;
    v8 = "#N GetCardStatus returns error: 0x%04x (%s)";
    v9 = v6;
    v10 = 18;
LABEL_11:
    _os_log_impl(&dword_216897000, v9, OS_LOG_TYPE_DEFAULT, v8, buf, v10);
    return;
  }
  std::vector<subscriber::VinylCapability>::__assign_with_size[abi:ne180100]<subscriber::VinylCapability const*,subscriber::VinylCapability const*>((char *)(v3 + 200), 0, 0, 0);
  v12 = (uint8_t *)MEMORY[0x24BDAC760];
  *(_QWORD *)buf = MEMORY[0x24BDAC760];
  *(_QWORD *)&v27 = 0x40000000;
  *((_QWORD *)&v27 + 1) = ___ZN10subscriber19sHandleVinylAbilityIN3uim13GetCardStatus8ResponseEEEvRKT_RNSt3__16vectorINS_15VinylCapabilityENS7_9allocatorIS9_EEEE_block_invoke;
  v28 = &__block_descriptor_tmp_113_1;
  v29 = v3 + 200;
  v19 = buf;
  if ((qmi::MessageBase::applyTlv<uim::tlv::VinylSupport,void({block_pointer}&)(uim::tlv::VinylSupport const&)>(a2, (uint64_t)&v19) & 1) == 0)
  {
    v19 = v12;
    v20 = 0x40000000;
    v21 = ___ZN10subscriber19sHandleVinylAbilityIN3uim13GetCardStatus8ResponseEEEvRKT_RNSt3__16vectorINS_15VinylCapabilityENS7_9allocatorIS9_EEEE_block_invoke_2;
    v22 = &__block_descriptor_tmp_115_1;
    v23 = v3 + 200;
    v25 = &v19;
    qmi::MessageBase::applyTlv<uim::tlv::VinylSupportLegacy,void({block_pointer}&)(uim::tlv::VinylSupportLegacy const&)>(a2, (uint64_t)&v25);
  }
  *(_QWORD *)buf = v12;
  *(_QWORD *)&v27 = 0x40000000;
  *((_QWORD *)&v27 + 1) = ___ZN10subscriber13sHandleIccidsIN3uim13GetCardStatus8ResponseEEEvRKT_RNSt3__13mapIjNS7_12basic_stringIcNS7_11char_traitsIcEENS7_9allocatorIcEEEENS7_4lessIjEENSC_INS7_4pairIKjSE_EEEEEE_block_invoke;
  v28 = &__block_descriptor_tmp_116_2;
  v29 = v3 + 224;
  v19 = buf;
  qmi::MessageBase::applyTlv<uim::tlv::Iccids,void({block_pointer}&)(uim::tlv::Iccids const&)>(a2, (uint64_t)&v19);
  v19 = v12;
  v20 = 0x40000000;
  v21 = ___ZN10subscriber13sHandleIccidsIN3uim13GetCardStatus8ResponseEEEvRKT_RNSt3__13mapIjNS7_12basic_stringIcNS7_11char_traitsIcEENS7_9allocatorIcEEEENS7_4lessIjEENSC_INS7_4pairIKjSE_EEEEEE_block_invoke_2;
  v22 = &__block_descriptor_tmp_117_0;
  v23 = v3 + 224;
  v25 = &v19;
  qmi::MessageBase::applyTlv<uim::tlv::ExtendedCardInfoList,void({block_pointer}&)(uim::tlv::ExtendedCardInfoList const&)>(a2, 23, (uint64_t)&v25);
  *(_QWORD *)buf = v12;
  *(_QWORD *)&v27 = 0x40000000;
  *((_QWORD *)&v27 + 1) = ___ZN10subscriber19sHandleCardInfoListIN3uim13GetCardStatus8ResponseEEEvRKT_RNSt3__13mapIjNS7_6vectorIhNS7_9allocatorIhEEEENS7_4lessIjEENSA_INS7_4pairIKjSC_EEEEEE_block_invoke;
  v28 = &__block_descriptor_tmp_118_1;
  v29 = v3 + 272;
  v19 = buf;
  qmi::MessageBase::applyTlv<uim::tlv::ExtendedCardInfoList,void({block_pointer}&)(uim::tlv::ExtendedCardInfoList const&)>(a2, 23, (uint64_t)&v19);
  v14 = *(std::__shared_weak_count **)(v3 + 64);
  if (v14)
  {
    p_shared_owners = (unint64_t *)&v14->__shared_owners_;
    do
      v16 = __ldxr(p_shared_owners);
    while (__stxr(v16 + 1, p_shared_owners));
  }
  if (capabilities::ct::supportsSIMMomentaryPowerDown(v13))
  {
    std::__tree<std::__value_type<AQMThroughputKey,unsigned int>,std::__map_value_compare<AQMThroughputKey,std::__value_type<AQMThroughputKey,unsigned int>,std::less<AQMThroughputKey>,true>,std::allocator<std::__value_type<AQMThroughputKey,unsigned int>>>::destroy(*(_QWORD **)(v3 + 256));
    *(_QWORD *)(v3 + 256) = 0;
    *(_QWORD *)(v3 + 264) = 0;
    *(_QWORD *)(v3 + 248) = v3 + 256;
    *(_QWORD *)buf = v12;
    *(_QWORD *)&v27 = 0x40000000;
    *((_QWORD *)&v27 + 1) = ___ZN10subscriber27sHandleIsMomentaryPowerDownIN3uim13GetCardStatus8ResponseEEEvNSt3__110shared_ptrIK8RegistryEERKT_RNS4_3mapIjbNS4_4lessIjEENS4_9allocatorINS4_4pairIKjbEEEEEE_block_invoke;
    v28 = &__block_descriptor_tmp_119_0;
    v29 = v3 + 248;
    v19 = buf;
    qmi::MessageBase::applyTlv<uim::tlv::IsMomentaryPowerDown,void({block_pointer}&)(uim::tlv::IsMomentaryPowerDown const&)>(a2, 24, (uint64_t)&v19);
  }
  if (v14)
  {
    v17 = (unint64_t *)&v14->__shared_owners_;
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
  *(_QWORD *)buf = v12;
  *(_QWORD *)&v27 = 0x40000000;
  *((_QWORD *)&v27 + 1) = ___ZN10subscriber19EURSimCommandDriver21handleCardStatus_respERKN3uim13GetCardStatus8ResponseE_block_invoke;
  v28 = &__block_descriptor_tmp_19_11;
  v29 = v3;
  v30 = a2;
  v19 = buf;
  if ((qmi::MessageBase::applyTlv<uim::tlv::ExtendedCardStatus,void({block_pointer})(uim::tlv::ExtendedCardStatus const&)>(a2, 19, (uint64_t)&v19) & 1) == 0)
  {
    v19 = v12;
    v20 = 0x40000000;
    v21 = ___ZN10subscriber19EURSimCommandDriver21handleCardStatus_respERKN3uim13GetCardStatus8ResponseE_block_invoke_2;
    v22 = &__block_descriptor_tmp_20_10;
    v23 = v3;
    v24 = a2;
    v25 = &v19;
    qmi::MessageBase::applyTlv<uim::tlv::CardStatus,void({block_pointer})(uim::tlv::CardStatus const&)>(a2, (uint64_t)&v25);
  }
}

void sub_2169D2B40(_Unwind_Exception *exception_object)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v4;

  if (v1)
  {
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t subscriber::EURSimCommandDriver::isAppPresentButNotInitialized(_DWORD *a1, _DWORD *a2, int a3, unsigned __int8 *a4, unsigned __int8 *a5, int a6)
{
  int v6;
  int v7;

  while (a4 != a5)
  {
    v6 = a4[1];
    if (v6 == a3 && v6 != 255 && *a4 != 255)
      return 0;
    a4 += 2;
  }
  if (a1 == a2)
    return 0;
  while (1)
  {
    v7 = *a1 - 1;
    if (v7 <= 4 && dword_216AB138C[v7] == a6)
      break;
    a1 += 18;
    if (a1 == a2)
      return 0;
  }
  return 1;
}

void subscriber::EURSimCommandDriver::checkInstanceConsistency_sync(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;
  _DWORD *v4;
  _DWORD *v5;
  _DWORD *v6;
  int v7;
  NSObject *v8;
  _DWORD *i;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  __int16 v15;
  uint64_t v16;
  uint64_t v17;

  v3 = a1;
  v17 = *MEMORY[0x24BDAC8D0];
  v5 = (_DWORD *)*a2;
  v4 = (_DWORD *)a2[1];
  if ((_DWORD *)*a2 == v4)
    goto LABEL_11;
  v6 = (_DWORD *)*a2;
  do
  {
    if (v6[1])
      goto LABEL_9;
    if (*(_DWORD *)(a1 + 300) == *v6)
    {
      v7 = 1;
    }
    else
    {
      if (*(_DWORD *)(a1 + 304) != *v6)
        goto LABEL_9;
      v7 = 2;
    }
    v6[1] = v7;
LABEL_9:
    v6 += 36;
  }
  while (v6 != v4);
  if (!*(_DWORD *)(a1 + 300))
  {
    while (v5[1])
    {
      v5 += 36;
      if (v5 == v4)
        goto LABEL_11;
    }
    v5[1] = 1;
    v8 = *(NSObject **)(a1 + 40);
    a1 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
    if ((_DWORD)a1)
    {
      v13 = 136315394;
      v14 = subscriber::asString();
      v15 = 2080;
      v16 = subscriber::asString();
      _os_log_impl(&dword_216897000, v8, OS_LOG_TYPE_DEFAULT, "#I Default instance for slot (%s) to (%s)", (uint8_t *)&v13, 0x16u);
    }
  }
LABEL_11:
  if (capabilities::ct::supportsGemini((capabilities::ct *)a1) && !*(_DWORD *)(v3 + 304))
  {
    for (i = (_DWORD *)*a2; i != (_DWORD *)a2[1]; i += 36)
    {
      if (!i[1])
      {
        i[1] = 2;
        v10 = *(NSObject **)(v3 + 40);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          v11 = subscriber::asString();
          v12 = subscriber::asString();
          v13 = 136315394;
          v14 = v11;
          v15 = 2080;
          v16 = v12;
          _os_log_impl(&dword_216897000, v10, OS_LOG_TYPE_DEFAULT, "#I Default instance for slot (%s) to (%s)", (uint8_t *)&v13, 0x16u);
        }
        return;
      }
    }
  }
}

void subscriber::EURSimCommandDriver::checkHardwareConfiguration_sync(NSObject **this, _QWORD *a2, uint64_t a3)
{
  unsigned __int8 v6;
  uint64_t v7;
  unsigned __int8 v8;
  char v9;
  int v10;
  int v11;
  uint64_t *v12;
  uint64_t **v13;
  uint64_t **v14;
  int v15;
  uint64_t *v16;
  _DWORD *v17;
  NSObject *v18;
  _DWORD *v19;
  _DWORD *v20;
  uint64_t v21;
  int v22;
  __int128 v23;
  uint64_t v24;
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  if (*(_BYTE *)a3)
  {
    v6 = 0;
    *((_QWORD *)&v23 + 1) = 0;
    v24 = 0;
    *(_QWORD *)&v23 = (char *)&v23 + 8;
    do
    {
      v7 = *(_QWORD *)(a3 + 8);
      if (*(_QWORD *)(a3 + 16) - v7 <= (unint64_t)v6)
        break;
      v8 = v6;
      v9 = *(_BYTE *)(v7 + v6);
      v10 = subscriber::SimCommandDriver::indexToHardwareSimSlot((subscriber::SimCommandDriver *)this);
      v11 = v10;
      v12 = (uint64_t *)*((_QWORD *)&v23 + 1);
      v13 = (uint64_t **)&v23 + 1;
      v14 = (uint64_t **)&v23 + 1;
      if (*((_QWORD *)&v23 + 1))
      {
        do
        {
          while (1)
          {
            v14 = (uint64_t **)v12;
            v15 = *((_DWORD *)v12 + 7);
            if (v15 <= v10)
              break;
            v12 = *v14;
            v13 = v14;
            if (!*v14)
              goto LABEL_12;
          }
          if (v15 >= v10)
          {
            v17 = v14;
            goto LABEL_15;
          }
          v12 = v14[1];
        }
        while (v12);
        v13 = v14 + 1;
      }
LABEL_12:
      v17 = operator new(0x28uLL);
      v17[7] = v11;
      *((_BYTE *)v17 + 32) = 0;
      *(_QWORD *)v17 = 0;
      *((_QWORD *)v17 + 1) = 0;
      *((_QWORD *)v17 + 2) = v14;
      *v13 = (uint64_t *)v17;
      v16 = (uint64_t *)v17;
      if (*(_QWORD *)v23)
      {
        *(_QWORD *)&v23 = *(_QWORD *)v23;
        v16 = *v13;
      }
      std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*((uint64_t **)&v23 + 1), v16);
      ++v24;
LABEL_15:
      *((_BYTE *)v17 + 32) = v9;
      v6 = v8 + 1;
    }
    while (*(_BYTE *)a3);
    subscriber::SimCommandDriver::checkSimHwIdConfig_sync();
    std::__tree<std::__value_type<AQMThroughputKey,unsigned int>,std::__map_value_compare<AQMThroughputKey,std::__value_type<AQMThroughputKey,unsigned int>,std::less<AQMThroughputKey>,true>,std::allocator<std::__value_type<AQMThroughputKey,unsigned int>>>::destroy(*((_QWORD **)&v23 + 1));
  }
  if (capabilities::ct::supportsGemini((capabilities::ct *)this))
  {
    subscriber::SimCommandDriver::appendMissingDriverInfo_sync();
    if (*((_BYTE *)this + 160))
    {
      v18 = this[5];
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        if (a2[1] == *a2)
          std::vector<wds::tlv::CurrentDataSystem>::__throw_out_of_range[abi:ne180100]();
        LODWORD(v23) = 136315138;
        *(_QWORD *)((char *)&v23 + 4) = subscriber::asString();
        _os_log_impl(&dword_216897000, v18, OS_LOG_TYPE_DEFAULT, "#I Overriding slot kTwo using %s", (uint8_t *)&v23, 0xCu);
      }
      v19 = (_DWORD *)a2[1];
      if ((_DWORD *)*a2 == v19)
        std::vector<wds::tlv::CurrentDataSystem>::__throw_out_of_range[abi:ne180100]();
      v20 = (_DWORD *)*a2;
      while (*v20 != 2)
      {
        v20 += 36;
        if (v20 == v19)
        {
          v20 = (_DWORD *)a2[1];
          break;
        }
      }
      v21 = *(int *)(*a2 + 8);
      if (v21 > 3)
        v22 = 0;
      else
        v22 = dword_216AB1430[v21];
      v20[2] = v22;
    }
  }
}

void sub_2169D3034(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, _QWORD *a10)
{
  std::__tree<std::__value_type<AQMThroughputKey,unsigned int>,std::__map_value_compare<AQMThroughputKey,std::__value_type<AQMThroughputKey,unsigned int>,std::less<AQMThroughputKey>,true>,std::allocator<std::__value_type<AQMThroughputKey,unsigned int>>>::destroy(a10);
  _Unwind_Resume(a1);
}

void subscriber::EURSimCommandDriver::setSimInfo(uint64_t a1, unsigned int *a2, uint64_t a3, unsigned __int8 **a4, unsigned __int8 **a5)
{
  int v7;
  int v8;
  int v9;
  BOOL v10;
  NSObject *v11;
  _DWORD *v12;
  NSObject *v13;
  unsigned int v14;
  NSObject *v15;
  uint64_t v16;
  uint64_t i;
  int v18;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  _DWORD *v28;
  char *v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  int64x2_t v36;
  const char *v37;
  os_log_t *v38;
  unint64_t v39;
  uint64_t v40;
  int v41;
  int v42;
  int isEsimCapable;
  int v44;
  int v45;
  unsigned int v46;
  uint64_t *v47;
  uint64_t *v48;
  unsigned int v49;
  unsigned int v50;
  uint64_t *v51;
  uint64_t *v52;
  unsigned int v53;
  unsigned int v54;
  uint64_t v55;
  uint64_t v56;
  unsigned int v57;
  BOOL v58;
  uint64_t *v59;
  os_log_t v60;
  const char *v61;
  os_log_t v62;
  uint64_t v63;
  const char *v64;
  NSObject *v65;
  uint32_t v66;
  int v67;
  uint64_t v68;
  NSObject *v69;
  const char *v70;
  int v71;
  uint64_t v72;
  uint64_t v73;
  unsigned int v74;
  BOOL v75;
  uint64_t *v76;
  uint64_t v77;
  char v78;
  uint64_t v79;
  uint64_t v80;
  BOOL v81;
  NSObject *v82;
  _BOOL4 v83;
  _BOOL4 v84;
  os_log_t *v85;
  os_log_t *v86;
  int v87;
  _DWORD *v88;
  _DWORD *v89;
  const char *v90;
  unsigned int v91;
  int v92;
  os_log_t v93;
  const BOOL *v94;
  uint64_t v95;
  uint64_t v96;
  const char *v97;
  uint64_t v98;
  uint64_t v99;
  unsigned int v100;
  BOOL v101;
  uint64_t *v102;
  os_log_t v103;
  const char *v104;
  NSObject *v105;
  uint32_t v106;
  char v110;
  int v111;
  _BYTE buf[24];
  const char *v113;
  unsigned int *v114;
  uint64_t v115;

  v115 = *MEMORY[0x24BDAC8D0];
  v7 = *a2;
  v8 = *a2 == 2;
  if (*a2 == 3)
    v8 = 2;
  if (v8 == (*a4)[1] || v8 == (*a5)[1])
  {
    v9 = *(_DWORD *)(a1 + 300);
    if (v9)
      v10 = v9 == v7;
    else
      v10 = 1;
    if (!v10)
    {
      if (!capabilities::ct::defaultVinylCardTypeToGSMA((capabilities::ct *)a1))
        goto LABEL_22;
      v7 = *a2;
    }
    a2[1] = 1;
    v11 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = subscriber::asString();
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = subscriber::asString();
      _os_log_impl(&dword_216897000, v11, OS_LOG_TYPE_DEFAULT, "#I Instance for slot (%s): (%s)", buf, 0x16u);
      v7 = *a2;
    }
    *(_DWORD *)(a1 + 300) = v7;
    if (*(_DWORD *)(a1 + 304) == *a2)
    {
      v12 = (_DWORD *)(a1 + 304);
LABEL_21:
      *v12 = 0;
    }
  }
  else if (v8 == (*a4)[3] || v8 == (*a5)[3])
  {
    a2[1] = 2;
    v13 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = subscriber::asString();
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = subscriber::asString();
      _os_log_impl(&dword_216897000, v13, OS_LOG_TYPE_DEFAULT, "#I Instance for slot (%s): (%s)", buf, 0x16u);
      v7 = *a2;
    }
    *(_DWORD *)(a1 + 304) = v7;
    if (*(_DWORD *)(a1 + 300) == *a2)
    {
      v12 = (_DWORD *)(a1 + 300);
      goto LABEL_21;
    }
  }
LABEL_22:
  v14 = a2[1];
  if (v14 == 2)
  {
    subscriber::EURSimCommandDriver::setSimAppInfo((uint64_t)a2, a2 + 8, a3, *a4 + 2);
    subscriber::EURSimCommandDriver::setSimAppInfo((uint64_t)a2, a2 + 16, a3, *a5 + 2);
  }
  else if (v14 == 1)
  {
    subscriber::EURSimCommandDriver::setSimAppInfo((uint64_t)a2, a2 + 8, a3, *a4);
    subscriber::EURSimCommandDriver::setSimAppInfo((uint64_t)a2, a2 + 16, a3, *a5);
  }
  else
  {
    v15 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      goto LABEL_29;
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_216897000, v15, OS_LOG_TYPE_DEFAULT, "#I Unknown instance, skipping to read apps info", buf, 2u);
  }
  v14 = a2[1];
LABEL_29:
  if (v14)
  {
    v16 = *(_QWORD *)(a3 + 16);
    for (i = *(_QWORD *)(a3 + 24); v16 != i; v16 += 72)
    {
      if (*(_DWORD *)v16 == 5)
      {
        v18 = *(_DWORD *)(v16 + 4);
        if (v18 == 7 || v18 == 1)
        {
          v21 = *((_QWORD *)a2 + 13);
          v20 = *((_QWORD *)a2 + 14);
          if (v21 >= v20)
          {
            v23 = *((_QWORD *)a2 + 12);
            v24 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v21 - v23) >> 3);
            v25 = v24 + 1;
            if (v24 + 1 > 0x666666666666666)
              std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
            v26 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v20 - v23) >> 3);
            if (2 * v26 > v25)
              v25 = 2 * v26;
            if (v26 >= 0x333333333333333)
              v27 = 0x666666666666666;
            else
              v27 = v25;
            v114 = a2 + 28;
            if (v27)
            {
              if (v27 > 0x666666666666666)
                std::__throw_bad_array_new_length[abi:ne180100]();
              v28 = operator new(40 * v27);
            }
            else
            {
              v28 = 0;
            }
            v29 = (char *)&v28[10 * v24];
            *(_QWORD *)buf = v28;
            *(_QWORD *)&buf[8] = v29;
            *(_QWORD *)&buf[16] = v29;
            v113 = (const char *)&v28[10 * v27];
            *(_DWORD *)v29 = 0;
            *((_QWORD *)v29 + 2) = 0;
            *((_QWORD *)v29 + 3) = 0;
            *((_QWORD *)v29 + 1) = 0;
            std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>((_QWORD *)v29 + 1, *(const void **)(v16 + 24), *(_QWORD *)(v16 + 32), *(_QWORD *)(v16 + 32) - *(_QWORD *)(v16 + 24));
            v28[10 * v24 + 8] = 4;
            v30 = *(_QWORD *)&buf[8];
            v22 = *(_QWORD *)&buf[16] + 40;
            *(_QWORD *)&buf[16] += 40;
            v32 = *((_QWORD *)a2 + 12);
            v31 = *((_QWORD *)a2 + 13);
            if (v31 == v32)
            {
              v36 = vdupq_n_s64(v31);
            }
            else
            {
              v33 = 0;
              do
              {
                v34 = v30 + v33;
                v35 = v31 + v33;
                *(_DWORD *)(v34 - 40) = *(_DWORD *)(v31 + v33 - 40);
                *(_QWORD *)(v34 - 24) = 0;
                *(_QWORD *)(v34 - 16) = 0;
                *(_QWORD *)(v34 - 32) = 0;
                *(_OWORD *)(v34 - 32) = *(_OWORD *)(v31 + v33 - 32);
                *(_QWORD *)(v34 - 16) = *(_QWORD *)(v31 + v33 - 16);
                *(_QWORD *)(v35 - 32) = 0;
                *(_QWORD *)(v35 - 24) = 0;
                *(_QWORD *)(v35 - 16) = 0;
                *(_DWORD *)(v34 - 8) = *(_DWORD *)(v31 + v33 - 8);
                v33 -= 40;
              }
              while (v31 + v33 != v32);
              v36 = *((int64x2_t *)a2 + 6);
              v22 = *(_QWORD *)&buf[16];
              v30 += v33;
            }
            *((_QWORD *)a2 + 12) = v30;
            *((_QWORD *)a2 + 13) = v22;
            *(int64x2_t *)&buf[8] = v36;
            v37 = (const char *)*((_QWORD *)a2 + 14);
            *((_QWORD *)a2 + 14) = v113;
            v113 = v37;
            *(_QWORD *)buf = v36.i64[0];
            std::__split_buffer<subscriber::NpAppInfo>::~__split_buffer((uint64_t)buf);
          }
          else
          {
            *(_DWORD *)v21 = 0;
            *(_QWORD *)(v21 + 16) = 0;
            *(_QWORD *)(v21 + 24) = 0;
            *(_QWORD *)(v21 + 8) = 0;
            std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>((_QWORD *)(v21 + 8), *(const void **)(v16 + 24), *(_QWORD *)(v16 + 32), *(_QWORD *)(v16 + 32) - *(_QWORD *)(v16 + 24));
            *(_DWORD *)(v21 + 32) = 4;
            v22 = v21 + 40;
            *((_QWORD *)a2 + 13) = v21 + 40;
          }
          *((_QWORD *)a2 + 13) = v22;
        }
      }
    }
  }
  v38 = (os_log_t *)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 48) + 16))(*(_QWORD *)(a1 + 48), *a2);
  if (*a2 == 3)
    v39 = 2;
  else
    v39 = *a2 == 2;
  v40 = *(_QWORD *)(a1 + 200);
  if (v39 >= (*(_QWORD *)(a1 + 208) - v40) >> 2)
    v41 = 1;
  else
    v41 = *(_DWORD *)(v40 + 4 * v39);
  v42 = *(_DWORD *)a3;
  v111 = v41;
  a2[5] = v41;
  isEsimCapable = subscriber::isEsimCapable();
  v44 = isEsimCapable;
  v110 = isEsimCapable;
  switch(*(_DWORD *)a3)
  {
    case 0:
      if (isEsimCapable)
        v45 = 2;
      else
        v45 = 3;
      goto LABEL_77;
    case 1:
      goto LABEL_76;
    case 2:
      v45 = 0;
      v46 = *(unsigned __int8 *)(a3 + 12);
      if (v46 > 3)
      {
        if (v46 - 4 >= 6 && v46 != 64)
          goto LABEL_77;
LABEL_76:
        v45 = 2;
        goto LABEL_77;
      }
      if (v46 < 3)
        goto LABEL_76;
      v45 = 3;
LABEL_77:
      a2[2] = v45;
      if (*((char *)a2 + 143) < 0)
      {
        **((_BYTE **)a2 + 15) = 0;
        *((_QWORD *)a2 + 16) = 0;
      }
      else
      {
        *((_BYTE *)a2 + 120) = 0;
        *((_BYTE *)a2 + 143) = 0;
      }
      v47 = *(uint64_t **)(a1 + 232);
      if (!v47)
        goto LABEL_93;
      v48 = *(uint64_t **)(a1 + 232);
      while (1)
      {
        v49 = *((_DWORD *)v48 + 8);
        if (v39 >= v49)
          break;
LABEL_85:
        v48 = (uint64_t *)*v48;
        if (!v48)
          goto LABEL_93;
      }
      if (v49 < v39)
      {
        ++v48;
        goto LABEL_85;
      }
      while (1)
      {
        while (1)
        {
          v50 = *((_DWORD *)v47 + 8);
          if (v50 <= v39)
            break;
          v47 = (uint64_t *)*v47;
          if (!v47)
LABEL_233:
            std::__throw_out_of_range[abi:ne180100]("map::at:  key not found");
        }
        if (v50 >= v39)
          break;
        v47 = (uint64_t *)v47[1];
        if (!v47)
          goto LABEL_233;
      }
      std::string::operator=((std::string *)a2 + 5, (const std::string *)(v47 + 5));
LABEL_93:
      if (*((_BYTE *)a2 + 25))
        *((_BYTE *)a2 + 25) = 0;
      v51 = *(uint64_t **)(a1 + 280);
      if (!v51)
        goto LABEL_108;
      v52 = *(uint64_t **)(a1 + 280);
      while (2)
      {
        v53 = *((_DWORD *)v52 + 8);
        if (v39 < v53)
        {
LABEL_100:
          v52 = (uint64_t *)*v52;
          if (!v52)
            goto LABEL_108;
          continue;
        }
        break;
      }
      if (v53 < v39)
      {
        ++v52;
        goto LABEL_100;
      }
      while (1)
      {
        while (1)
        {
          v54 = *((_DWORD *)v51 + 8);
          if (v54 <= v39)
            break;
          v51 = (uint64_t *)*v51;
          if (!v51)
LABEL_234:
            std::__throw_out_of_range[abi:ne180100]("map::at:  key not found");
        }
        if (v54 >= v39)
          break;
        v51 = (uint64_t *)v51[1];
        if (!v51)
          goto LABEL_234;
      }
      *((_WORD *)a2 + 12) = subscriber::SimCommandDriver::getVinylCapabilitiesFromATR();
LABEL_108:
      switch(v42)
      {
        case 0:
          v55 = *(_QWORD *)(a1 + 256);
          if (v55)
          {
            v56 = a1 + 256;
            do
            {
              v57 = *(_DWORD *)(v55 + 28);
              v58 = v57 >= v39;
              if (v57 >= v39)
                v59 = (uint64_t *)v55;
              else
                v59 = (uint64_t *)(v55 + 8);
              if (v58)
                v56 = v55;
              v55 = *v59;
            }
            while (*v59);
            if (v56 != a1 + 256 && v39 >= *(_DWORD *)(v56 + 28) && *(_BYTE *)(v56 + 32))
            {
              v60 = *v38;
              if (!os_log_type_enabled(*v38, OS_LOG_TYPE_DEFAULT))
                goto LABEL_198;
              *(_WORD *)buf = 0;
              v61 = "#I Momentary power down detected, treat as unknown";
              goto LABEL_196;
            }
          }
          v82 = *v38;
          v84 = os_log_type_enabled(*v38, OS_LOG_TYPE_DEFAULT);
          if (v44)
          {
            if (!v84)
              goto LABEL_163;
            *(_WORD *)buf = 0;
            goto LABEL_162;
          }
          if (!v84)
            goto LABEL_178;
          *(_WORD *)buf = 0;
          v90 = "#I SIM card absent (tray present)";
          goto LABEL_177;
        case 1:
          if (a2[8] | a2[16])
          {
            v85 = (os_log_t *)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 48) + 16))(*(_QWORD *)(a1 + 48), *a2);
            v86 = v85;
            if (a2[8] == 2 || a2[16] == 2)
            {
              v60 = *v85;
              if (!os_log_type_enabled(*v85, OS_LOG_TYPE_DEFAULT))
                goto LABEL_198;
              *(_WORD *)buf = 0;
              v61 = "#I SIM slot not ready yet; some app is detected and not yet ready.";
LABEL_196:
              v65 = v60;
              v66 = 2;
LABEL_197:
              _os_log_impl(&dword_216897000, v65, OS_LOG_TYPE_DEFAULT, v61, buf, v66);
            }
            else
            {
              if (*a2 == 3)
                v87 = 2;
              else
                v87 = *a2 == 2;
              v89 = *(_DWORD **)(a3 + 16);
              v88 = *(_DWORD **)(a3 + 24);
              if (subscriber::EURSimCommandDriver::isAppPresentButNotInitialized(v89, v88, v87, *a4, a4[1], 1))
              {
                v60 = *v86;
                if (!os_log_type_enabled(*v86, OS_LOG_TYPE_DEFAULT))
                  goto LABEL_198;
                *(_WORD *)buf = 0;
                v61 = "#I SIM slot not ready yet; Gw app is present but not initialized yet; waiting.";
                goto LABEL_196;
              }
              if (!subscriber::EURSimCommandDriver::isAppPresentButNotInitialized(v89, v88, v87, *a5, a5[1], 2))goto LABEL_200;
              v60 = *v86;
              if (os_log_type_enabled(*v86, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)buf = 0;
                v61 = "#I SIM slot not ready yet; Gw app is present but not initialized yet; waiting.";
                goto LABEL_196;
              }
            }
LABEL_198:
            if (*((_BYTE *)a2 + 16))
LABEL_199:
              *((_BYTE *)a2 + 16) = 0;
          }
          else
          {
            if (v44)
            {
              v77 = *((unsigned __int8 *)a2 + 143);
              v78 = v77;
              v79 = *((_QWORD *)a2 + 16);
              if ((v77 & 0x80u) == 0)
                v80 = *((unsigned __int8 *)a2 + 143);
              else
                v80 = *((_QWORD *)a2 + 16);
              if (v80)
                v81 = a2[1] == 0;
              else
                v81 = 1;
              if (!v81)
              {
LABEL_190:
                if (v78 < 0)
                  v77 = v79;
                if (v77)
                {
                  v71 = 2;
                  goto LABEL_164;
                }
                goto LABEL_200;
              }
            }
            else if (a2[1])
            {
              v77 = *((unsigned __int8 *)a2 + 143);
              v79 = *((_QWORD *)a2 + 16);
              v78 = *((_BYTE *)a2 + 143);
              goto LABEL_190;
            }
            a2[3] = 8;
            *((_BYTE *)a2 + 16) = 1;
            v93 = *v38;
            if (!os_log_type_enabled(*v38, OS_LOG_TYPE_DEFAULT))
              goto LABEL_200;
            v95 = printers::asString((printers *)&v110, v94);
            v96 = subscriber::asString();
            if (*((_BYTE *)a2 + 16))
              v97 = (const char *)subscriber::asString();
            else
              v97 = "<uninitialized_value>";
            *(_DWORD *)buf = 136315650;
            *(_QWORD *)&buf[4] = v95;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = v96;
            *(_WORD *)&buf[22] = 2080;
            v113 = v97;
            v104 = "#I vinyl (%s), instance (%s) -> state: %s";
            v105 = v93;
            v106 = 32;
LABEL_232:
            _os_log_impl(&dword_216897000, v105, OS_LOG_TYPE_DEFAULT, v104, buf, v106);
          }
LABEL_200:
          if (*((_BYTE *)a2 + 16))
          {
            v91 = a2[3];
            if (v91 <= 9)
            {
              v92 = 1 << v91;
              if ((v92 & 0x78) != 0)
              {
                subscriber::maybeMarkNotPresent();
                subscriber::maybeMarkNotPresent();
              }
              else if ((v92 & 0x382) != 0)
              {
                subscriber::markNotPresent();
                subscriber::markNotPresent();
              }
            }
          }
          return;
        case 2:
          v67 = *(unsigned __int8 *)(a3 + 12);
          v68 = (v67 - 1);
          if (v68 > 0x3F)
            goto LABEL_184;
          if (((1 << (v67 - 1)) & 0xCA) != 0)
            goto LABEL_128;
          if (v67 == 1)
          {
            v98 = *(_QWORD *)(a1 + 256);
            if (!v98)
              goto LABEL_178;
            v99 = a1 + 256;
            do
            {
              v100 = *(_DWORD *)(v98 + 28);
              v101 = v100 >= v39;
              if (v100 >= v39)
                v102 = (uint64_t *)v98;
              else
                v102 = (uint64_t *)(v98 + 8);
              if (v101)
                v99 = v98;
              v98 = *v102;
            }
            while (*v102);
            if (v99 == a1 + 256 || v39 < *(_DWORD *)(v99 + 28) || !*(_BYTE *)(v99 + 32))
              goto LABEL_178;
            if (*((_BYTE *)a2 + 16))
              *((_BYTE *)a2 + 16) = 0;
            v103 = *v38;
            if (os_log_type_enabled(*v38, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)buf = 0;
              v104 = "#I Momentary power down detected, treat as unknown";
              v105 = v103;
              v106 = 2;
              goto LABEL_232;
            }
            goto LABEL_200;
          }
          if (v68 == 63)
          {
            v60 = *v38;
            if (!os_log_type_enabled(*v38, OS_LOG_TYPE_DEFAULT))
              goto LABEL_198;
            *(_WORD *)buf = 0;
            v61 = "#I SIM is in recovery; ignoring SIM state for now";
            goto LABEL_196;
          }
LABEL_184:
          if (!*(_BYTE *)(a3 + 12))
          {
LABEL_128:
            v69 = *v38;
            if (os_log_type_enabled(*v38, OS_LOG_TYPE_DEFAULT))
            {
              v70 = uim::asString(v67);
              *(_DWORD *)buf = 136315138;
              *(_QWORD *)&buf[4] = v70;
              _os_log_impl(&dword_216897000, v69, OS_LOG_TYPE_DEFAULT, "#I SIM slot being marked as 'dead' due to SIM error (%s)", buf, 0xCu);
            }
            v71 = 7;
            goto LABEL_164;
          }
          if (a2[8] | a2[16])
            goto LABEL_200;
          v82 = *v38;
          if (os_log_type_enabled(*v38, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            v90 = "#I No ATR Received, assuming SIM is not present.";
            goto LABEL_177;
          }
          goto LABEL_178;
        case 3:
          v72 = *(_QWORD *)(a1 + 256);
          if (!v72)
            goto LABEL_156;
          v73 = a1 + 256;
          do
          {
            v74 = *(_DWORD *)(v72 + 28);
            v75 = v74 >= v39;
            if (v74 >= v39)
              v76 = (uint64_t *)v72;
            else
              v76 = (uint64_t *)(v72 + 8);
            if (v75)
              v73 = v72;
            v72 = *v76;
          }
          while (*v76);
          if (v73 == a1 + 256 || v39 < *(_DWORD *)(v73 + 28) || !*(_BYTE *)(v73 + 32))
          {
LABEL_156:
            v82 = *v38;
            v83 = os_log_type_enabled(*v38, OS_LOG_TYPE_DEFAULT);
            if (v44)
            {
              if (v83)
              {
                *(_WORD *)buf = 0;
LABEL_162:
                _os_log_impl(&dword_216897000, v82, OS_LOG_TYPE_DEFAULT, "#I SIM has no profiles", buf, 2u);
              }
LABEL_163:
              v71 = 8;
LABEL_164:
              a2[3] = v71;
            }
            else
            {
              if (v83)
              {
                *(_WORD *)buf = 0;
                v90 = "#I SIM card absent (tray removed)";
LABEL_177:
                _os_log_impl(&dword_216897000, v82, OS_LOG_TYPE_DEFAULT, v90, buf, 2u);
              }
LABEL_178:
              a2[3] = 1;
            }
            *((_BYTE *)a2 + 16) = 1;
            goto LABEL_200;
          }
          v60 = *v38;
          if (!os_log_type_enabled(*v38, OS_LOG_TYPE_DEFAULT))
            goto LABEL_198;
          *(_WORD *)buf = 0;
          v61 = "#I Momentary power down detected, treat as unknown";
          goto LABEL_196;
        case 4:
          if (!*((_BYTE *)a2 + 16))
            goto LABEL_200;
          v62 = *v38;
          if (!os_log_type_enabled(*v38, OS_LOG_TYPE_DEFAULT))
            goto LABEL_199;
          v63 = subscriber::asString();
          v64 = uim::asString(4u);
          *(_DWORD *)buf = 136315394;
          *(_QWORD *)&buf[4] = v63;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = v64;
          v61 = "#I Resetting overall reported SIM state from %s to 'none' due to CardState=%s";
          v65 = v62;
          v66 = 22;
          goto LABEL_197;
        default:
          goto LABEL_200;
      }
    case 3:
      if (isEsimCapable)
        v45 = 2;
      else
        v45 = 1;
      goto LABEL_77;
    default:
      v45 = 0;
      goto LABEL_77;
  }
}

void sub_2169D3D80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  uint64_t v13;
  uint64_t v14;

  *(_QWORD *)(v13 + 104) = v14;
  _Unwind_Resume(exception_object);
}

uint64_t subscriber::EURSimCommandDriver::setSimAppInfo(uint64_t result, _DWORD *a2, uint64_t a3, unsigned __int8 *a4)
{
  unint64_t v5;
  uint64_t v8;
  uint64_t v9;
  int v10;
  int v11;
  int v12;
  unsigned int v13;
  int v15;
  unsigned int v16;
  unsigned int v17;
  _DWORD *v18;

  if (a4[1] != 255)
  {
    v5 = *a4;
    if ((_DWORD)v5 != 255)
    {
      v8 = result;
      v9 = *(_QWORD *)(a3 + 16);
      if (0x8E38E38E38E38E39 * ((*(_QWORD *)(a3 + 24) - v9) >> 3) <= v5)
      {
        result = __TUAssertTrigger();
        LODWORD(v5) = *a4;
        v9 = *(_QWORD *)(a3 + 16);
      }
      v10 = *(_DWORD *)(v9 + 72 * v5) - 1;
      if (v10 > 4)
        v11 = 0;
      else
        v11 = dword_216AB13A0[v10];
      a2[1] = v11;
      v12 = *(_DWORD *)(v9 + 72 * v5 + 4);
      if (v12)
      {
        v13 = *(_DWORD *)(v9 + 72 * v5 + 52);
        if (v13)
        {
          *(_WORD *)(v8 + 27) = *(_WORD *)(v9 + 72 * v5 + 56);
          if (v13 <= 5 && ((1 << v13) & 0x36) != 0)
            *(_BYTE *)(v8 + 26) = 1;
        }
        switch(v12)
        {
          case 1:
          case 4:
            goto LABEL_16;
          case 2:
            v16 = 3;
            *a2 = 3;
            if (!*(_BYTE *)(v8 + 16))
              break;
            v17 = *(_DWORD *)(v8 + 12) - 1;
            if (v17 <= 7)
            {
              v18 = &unk_216AB13B4;
              goto LABEL_28;
            }
            v16 = 3;
            break;
          case 3:
            *a2 = 3;
            if (*(_BYTE *)(v8 + 16) && (v17 = *(_DWORD *)(v8 + 12) - 1, v17 <= 7))
            {
              v18 = &unk_216AB13D4;
LABEL_28:
              v16 = v18[v17];
            }
            else
            {
              v16 = 4;
            }
            break;
          case 5:
            *a2 = 3;
            if (!*(_BYTE *)(v8 + 16) || (v16 = *(_DWORD *)(v8 + 12), v16 > 8) || ((1 << v16) & 0x182) == 0)
              v16 = 6;
            break;
          case 6:
          case 7:
            *a2 = 4;
            v15 = *(_DWORD *)(v8 + 12);
            if ((v15 - 1) >= 8)
              v15 = 5;
            if (*(_BYTE *)(v8 + 16))
              v16 = v15;
            else
              v16 = 5;
            break;
          default:
            return result;
        }
        *(_DWORD *)(v8 + 12) = v16;
        *(_BYTE *)(v8 + 16) = 1;
      }
      else
      {
LABEL_16:
        *a2 = 2;
      }
    }
  }
  return result;
}

void ___ZN10subscriber19EURSimCommandDriver21handleCardStatus_respERKN3uim13GetCardStatus8ResponseE_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  _BYTE v4[8];
  void *__p;
  uint64_t v6;

  v6 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 + 32);
  qmi::Message<uim::GetCardStatus::ResponseTLVList,qmi::ResponseBase>::get<uim::tlv::HardwareSlotTypes>((uint64_t)v4, *(qmi::MessageBase **)(a1 + 40));
  subscriber::EURSimCommandDriver::sendSimInfo<uim::tlv::ExtendedCardStatus>(v3, a2, (uint64_t)v4);
  if (v4[0])
  {
    if (__p)
      operator delete(__p);
  }
}

void sub_2169D4058(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *__p)
{
  if (a10)
  {
    if (__p)
      operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void subscriber::EURSimCommandDriver::sendSimInfo<uim::tlv::ExtendedCardStatus>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  capabilities::ct *v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  NSObject *v15;
  unsigned int *i;
  uint64_t v17;
  unsigned int v18;
  uint64_t j;
  uint64_t v20;
  int v21;
  _BYTE v22[8];
  _QWORD *v23;
  uint8_t buf[8];
  _QWORD *v25[2];
  void *__p;
  _BYTE *v27;
  uint64_t v28;
  void *v29;
  _BYTE *v30;
  uint64_t v31;
  int64x2_t v32;
  unint64_t v33;

  if (*(_QWORD *)(a2 + 48) == *(_QWORD *)(a2 + 56))
  {
    v32 = 0uLL;
    v33 = 0;
    subscriber::SimCommandDriver::sendSimDriverInfo();
    v29 = &v32;
  }
  else
  {
    v32 = 0uLL;
    v33 = 0;
    v6 = std::vector<subscriber::SimDriverInfo>::__emplace_back_slow_path<>(&v32);
    v7 = *(_QWORD *)(a2 + 48);
    v8 = *(_QWORD *)(a2 + 56);
    v32.i64[1] = (uint64_t)v6;
    *((_DWORD *)v6 - 36) = 1;
    if (v8 - v7 == 40)
      *((_DWORD *)v6 - 35) = 1;
    v9 = capabilities::ct::supportsGemini((capabilities::ct *)v6);
    if ((v9 & 1) != 0
      || (v10 = capabilities::ct::supportsDynamicSID((capabilities::ct *)v9), (v10 & 1) != 0)
      || (v11 = (capabilities::ct *)capabilities::ct::dataOnlySingleSIMDevice((capabilities::ct *)v10), (_DWORD)v11))
    {
      v12 = v32.i64[1];
      if (v32.i64[1] >= v33)
      {
        v11 = (capabilities::ct *)std::vector<subscriber::SimDriverInfo>::__emplace_back_slow_path<>(&v32);
      }
      else
      {
        *(_QWORD *)(v32.i64[1] + 16) = 0;
        *(_QWORD *)(v12 + 24) = 0;
        *(_QWORD *)(v12 + 8) = 0;
        *(_DWORD *)v12 = 1;
        *(_BYTE *)(v12 + 12) = 0;
        *(_QWORD *)(v12 + 4) = 0;
        *(_QWORD *)(v12 + 20) = 0;
        *(_BYTE *)(v12 + 28) = 0;
        *(_OWORD *)(v12 + 32) = 0u;
        *(_OWORD *)(v12 + 48) = 0u;
        *(_OWORD *)(v12 + 64) = 0u;
        *(_OWORD *)(v12 + 80) = 0u;
        *(_OWORD *)(v12 + 96) = 0u;
        *(_OWORD *)(v12 + 112) = 0u;
        v11 = (capabilities::ct *)(v12 + 144);
        *(_OWORD *)(v12 + 128) = 0u;
      }
      v32.i64[1] = (uint64_t)v11;
      *((_DWORD *)v11 - 36) = 2;
    }
    if (capabilities::ct::supportsHydra(v11)
      && 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(_QWORD *)(a2 + 56) - *(_QWORD *)(a2 + 48)) >> 3) >= 3)
    {
      v13 = v32.i64[1];
      if (v32.i64[1] >= v33)
      {
        v14 = std::vector<subscriber::SimDriverInfo>::__emplace_back_slow_path<>(&v32);
      }
      else
      {
        *(_QWORD *)(v32.i64[1] + 16) = 0;
        *(_QWORD *)(v13 + 24) = 0;
        *(_QWORD *)(v13 + 8) = 0;
        *(_DWORD *)v13 = 1;
        *(_BYTE *)(v13 + 12) = 0;
        *(_QWORD *)(v13 + 4) = 0;
        *(_QWORD *)(v13 + 20) = 0;
        *(_BYTE *)(v13 + 28) = 0;
        *(_OWORD *)(v13 + 32) = 0u;
        *(_OWORD *)(v13 + 48) = 0u;
        *(_OWORD *)(v13 + 64) = 0u;
        *(_OWORD *)(v13 + 80) = 0u;
        *(_OWORD *)(v13 + 96) = 0u;
        *(_OWORD *)(v13 + 112) = 0u;
        v14 = (char *)(v13 + 144);
        *(_OWORD *)(v13 + 128) = 0u;
      }
      v32.i64[1] = (uint64_t)v14;
      *((_DWORD *)v14 - 36) = 3;
    }
    v29 = 0;
    v30 = 0;
    v31 = 0;
    __p = 0;
    v27 = 0;
    v28 = 0;
    if (&v29 != (void **)a2)
      std::vector<uim::tlv::AppIndex>::__assign_with_size[abi:ne180100]<uim::tlv::AppIndex*,uim::tlv::AppIndex*>(&v29, *(char **)a2, *(char **)(a2 + 8), (uint64_t)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 1);
    if ((void **)(a2 + 24) != &__p)
      std::vector<uim::tlv::AppIndex>::__assign_with_size[abi:ne180100]<uim::tlv::AppIndex*,uim::tlv::AppIndex*>(&__p, *(char **)(a2 + 24), *(char **)(a2 + 32), (uint64_t)(*(_QWORD *)(a2 + 32) - *(_QWORD *)(a2 + 24)) >> 1);
    if ((unint64_t)(v30 - (_BYTE *)v29) > 3 || (unint64_t)(v27 - (_BYTE *)__p) > 3)
    {
      v17 = v32.i64[1];
      for (i = (unsigned int *)v32.i64[0]; i != (unsigned int *)v17; i += 36)
      {
        if (*i == 3)
          v18 = 2;
        else
          v18 = *i == 2;
        subscriber::EURSimCommandDriver::setSimInfo(a1, i, *(_QWORD *)(a2 + 48) + 40 * v18, (unsigned __int8 **)&v29, (unsigned __int8 **)&__p);
      }
      subscriber::EURSimCommandDriver::checkHardwareConfiguration_sync((NSObject **)a1, &v32, a3);
      subscriber::EURSimCommandDriver::checkInstanceConsistency_sync(a1, &v32);
      subscriber::SimCommandDriver::sendSimDriverInfo();
      v25[0] = 0;
      v25[1] = 0;
      *(_QWORD *)buf = v25;
      v20 = v32.i64[1];
      for (j = v32.i64[0]; j != v20; j += 144)
      {
        if (*(_BYTE *)(j + 16) && (subscriber::isSimSettled() & 1) != 0)
        {
          v21 = *(_DWORD *)j;
          if (*(_DWORD *)(j + 64) == 4)
            std::__tree<std::__value_type<subscriber::HardwareSimSlot,BOOL>,std::__map_value_compare<subscriber::HardwareSimSlot,std::__value_type<subscriber::HardwareSimSlot,BOOL>,std::less<subscriber::HardwareSimSlot>,true>,std::allocator<std::__value_type<subscriber::HardwareSimSlot,BOOL>>>::__emplace_unique_key_args<subscriber::HardwareSimSlot,subscriber::HardwareSimSlot const&,BOOL>((uint64_t *)buf, v21, *(_DWORD *)j, 1);
          else
            std::__tree<std::__value_type<subscriber::HardwareSimSlot,BOOL>,std::__map_value_compare<subscriber::HardwareSimSlot,std::__value_type<subscriber::HardwareSimSlot,BOOL>,std::less<subscriber::HardwareSimSlot>,true>,std::allocator<std::__value_type<subscriber::HardwareSimSlot,BOOL>>>::__emplace_unique_key_args<subscriber::HardwareSimSlot,subscriber::HardwareSimSlot const&,BOOL>((uint64_t *)buf, v21, *(_DWORD *)j, 0);
        }
      }
      std::map<subscriber::HardwareSimSlot,BOOL>::map[abi:ne180100]((uint64_t)v22, buf);
      subscriber::SimCommandDriver::markAllowedToReadCDMAAuxInfo();
      std::__tree<std::__value_type<AQMThroughputKey,unsigned int>,std::__map_value_compare<AQMThroughputKey,std::__value_type<AQMThroughputKey,unsigned int>,std::less<AQMThroughputKey>,true>,std::allocator<std::__value_type<AQMThroughputKey,unsigned int>>>::destroy(v23);
      std::__tree<std::__value_type<AQMThroughputKey,unsigned int>,std::__map_value_compare<AQMThroughputKey,std::__value_type<AQMThroughputKey,unsigned int>,std::less<AQMThroughputKey>,true>,std::allocator<std::__value_type<AQMThroughputKey,unsigned int>>>::destroy(v25[0]);
    }
    else
    {
      v15 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_216897000, v15, OS_LOG_TYPE_ERROR, "Not enough app indices, required at least 2", buf, 2u);
      }
    }
    if (__p)
    {
      v27 = __p;
      operator delete(__p);
    }
    if (v29)
    {
      v30 = v29;
      operator delete(v29);
    }
    v29 = &v32;
  }
  std::vector<subscriber::SimDriverInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)&v29);
}

void sub_2169D4408(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, uint64_t a18, void *a19, uint64_t a20)
{
  uint64_t v20;

  a19 = (void *)(v20 - 88);
  std::vector<subscriber::SimDriverInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)&a19);
  _Unwind_Resume(a1);
}

void qmi::Message<uim::GetCardStatus::ResponseTLVList,qmi::ResponseBase>::get<uim::tlv::HardwareSlotTypes>(uint64_t a1, qmi::MessageBase *a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  qmi::MessageBase::tryTlv<uim::tlv::HardwareSlotTypes>(a2, (unsigned __int8 *)a1);
}

void sub_2169D44C4(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  if (*(_BYTE *)v1)
  {
    v3 = *(void **)(v1 + 8);
    if (v3)
    {
      *(_QWORD *)(v1 + 16) = v3;
      operator delete(v3);
    }
    *(_BYTE *)v1 = 0;
  }
  _Unwind_Resume(exception_object);
}

void ___ZN10subscriber19EURSimCommandDriver21handleCardStatus_respERKN3uim13GetCardStatus8ResponseE_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  _BYTE v4[8];
  void *__p;
  uint64_t v6;

  v6 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 + 32);
  qmi::Message<uim::GetCardStatus::ResponseTLVList,qmi::ResponseBase>::get<uim::tlv::HardwareSlotTypes>((uint64_t)v4, *(qmi::MessageBase **)(a1 + 40));
  subscriber::EURSimCommandDriver::sendSimInfo<uim::tlv::CardStatus>(v3, a2, (uint64_t)v4);
  if (v4[0])
  {
    if (__p)
      operator delete(__p);
  }
}

void sub_2169D4590(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *__p)
{
  if (a10)
  {
    if (__p)
      operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void subscriber::EURSimCommandDriver::sendSimInfo<uim::tlv::CardStatus>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  capabilities::ct *v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  NSObject *v15;
  unsigned int *i;
  uint64_t v17;
  unsigned int v18;
  uint64_t j;
  uint64_t v20;
  int v21;
  _BYTE v22[8];
  _QWORD *v23;
  uint8_t buf[8];
  _QWORD *v25[2];
  void *__p;
  _BYTE *v27;
  uint64_t v28;
  void *v29;
  _BYTE *v30;
  uint64_t v31;
  int64x2_t v32;
  unint64_t v33;

  if (*(_QWORD *)(a2 + 8) == *(_QWORD *)(a2 + 16))
  {
    v32 = 0uLL;
    v33 = 0;
    subscriber::SimCommandDriver::sendSimDriverInfo();
    v29 = &v32;
  }
  else
  {
    v32 = 0uLL;
    v33 = 0;
    v6 = std::vector<subscriber::SimDriverInfo>::__emplace_back_slow_path<>(&v32);
    v7 = *(_QWORD *)(a2 + 8);
    v8 = *(_QWORD *)(a2 + 16);
    v32.i64[1] = (uint64_t)v6;
    *((_DWORD *)v6 - 36) = 1;
    if (v8 - v7 == 40)
      *((_DWORD *)v6 - 35) = 1;
    v9 = capabilities::ct::supportsGemini((capabilities::ct *)v6);
    if ((v9 & 1) != 0
      || (v10 = capabilities::ct::supportsDynamicSID((capabilities::ct *)v9), (v10 & 1) != 0)
      || (v11 = (capabilities::ct *)capabilities::ct::dataOnlySingleSIMDevice((capabilities::ct *)v10), (_DWORD)v11))
    {
      v12 = v32.i64[1];
      if (v32.i64[1] >= v33)
      {
        v11 = (capabilities::ct *)std::vector<subscriber::SimDriverInfo>::__emplace_back_slow_path<>(&v32);
      }
      else
      {
        *(_QWORD *)(v32.i64[1] + 16) = 0;
        *(_QWORD *)(v12 + 24) = 0;
        *(_QWORD *)(v12 + 8) = 0;
        *(_DWORD *)v12 = 1;
        *(_BYTE *)(v12 + 12) = 0;
        *(_QWORD *)(v12 + 4) = 0;
        *(_QWORD *)(v12 + 20) = 0;
        *(_BYTE *)(v12 + 28) = 0;
        *(_OWORD *)(v12 + 32) = 0u;
        *(_OWORD *)(v12 + 48) = 0u;
        *(_OWORD *)(v12 + 64) = 0u;
        *(_OWORD *)(v12 + 80) = 0u;
        *(_OWORD *)(v12 + 96) = 0u;
        *(_OWORD *)(v12 + 112) = 0u;
        v11 = (capabilities::ct *)(v12 + 144);
        *(_OWORD *)(v12 + 128) = 0u;
      }
      v32.i64[1] = (uint64_t)v11;
      *((_DWORD *)v11 - 36) = 2;
    }
    if (capabilities::ct::supportsHydra(v11)
      && 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(_QWORD *)(a2 + 16) - *(_QWORD *)(a2 + 8)) >> 3) >= 3)
    {
      v13 = v32.i64[1];
      if (v32.i64[1] >= v33)
      {
        v14 = std::vector<subscriber::SimDriverInfo>::__emplace_back_slow_path<>(&v32);
      }
      else
      {
        *(_QWORD *)(v32.i64[1] + 16) = 0;
        *(_QWORD *)(v13 + 24) = 0;
        *(_QWORD *)(v13 + 8) = 0;
        *(_DWORD *)v13 = 1;
        *(_BYTE *)(v13 + 12) = 0;
        *(_QWORD *)(v13 + 4) = 0;
        *(_QWORD *)(v13 + 20) = 0;
        *(_BYTE *)(v13 + 28) = 0;
        *(_OWORD *)(v13 + 32) = 0u;
        *(_OWORD *)(v13 + 48) = 0u;
        *(_OWORD *)(v13 + 64) = 0u;
        *(_OWORD *)(v13 + 80) = 0u;
        *(_OWORD *)(v13 + 96) = 0u;
        *(_OWORD *)(v13 + 112) = 0u;
        v14 = (char *)(v13 + 144);
        *(_OWORD *)(v13 + 128) = 0u;
      }
      v32.i64[1] = (uint64_t)v14;
      *((_DWORD *)v14 - 36) = 3;
    }
    v29 = 0;
    v30 = 0;
    v31 = 0;
    __p = 0;
    v27 = 0;
    v28 = 0;
    std::vector<vs::tlv::IsHandoverCallItem>::resize((uint64_t)&v29, 2uLL);
    *(_WORD *)v29 = *(_WORD *)a2;
    *((_WORD *)v29 + 1) = *(_WORD *)(a2 + 4);
    std::vector<vs::tlv::IsHandoverCallItem>::resize((uint64_t)&__p, 2uLL);
    *(_WORD *)__p = *(_WORD *)(a2 + 2);
    *((_WORD *)__p + 1) = *(_WORD *)(a2 + 6);
    if ((unint64_t)(v30 - (_BYTE *)v29) > 3 || (unint64_t)(v27 - (_BYTE *)__p) > 3)
    {
      v17 = v32.i64[1];
      for (i = (unsigned int *)v32.i64[0]; i != (unsigned int *)v17; i += 36)
      {
        if (*i == 3)
          v18 = 2;
        else
          v18 = *i == 2;
        subscriber::EURSimCommandDriver::setSimInfo(a1, i, *(_QWORD *)(a2 + 8) + 40 * v18, (unsigned __int8 **)&v29, (unsigned __int8 **)&__p);
      }
      subscriber::EURSimCommandDriver::checkHardwareConfiguration_sync((NSObject **)a1, &v32, a3);
      subscriber::EURSimCommandDriver::checkInstanceConsistency_sync(a1, &v32);
      subscriber::SimCommandDriver::sendSimDriverInfo();
      v25[0] = 0;
      v25[1] = 0;
      *(_QWORD *)buf = v25;
      v20 = v32.i64[1];
      for (j = v32.i64[0]; j != v20; j += 144)
      {
        if (*(_BYTE *)(j + 16) && (subscriber::isSimSettled() & 1) != 0)
        {
          v21 = *(_DWORD *)j;
          if (*(_DWORD *)(j + 64) == 4)
            std::__tree<std::__value_type<subscriber::HardwareSimSlot,BOOL>,std::__map_value_compare<subscriber::HardwareSimSlot,std::__value_type<subscriber::HardwareSimSlot,BOOL>,std::less<subscriber::HardwareSimSlot>,true>,std::allocator<std::__value_type<subscriber::HardwareSimSlot,BOOL>>>::__emplace_unique_key_args<subscriber::HardwareSimSlot,subscriber::HardwareSimSlot const&,BOOL>((uint64_t *)buf, v21, *(_DWORD *)j, 1);
          else
            std::__tree<std::__value_type<subscriber::HardwareSimSlot,BOOL>,std::__map_value_compare<subscriber::HardwareSimSlot,std::__value_type<subscriber::HardwareSimSlot,BOOL>,std::less<subscriber::HardwareSimSlot>,true>,std::allocator<std::__value_type<subscriber::HardwareSimSlot,BOOL>>>::__emplace_unique_key_args<subscriber::HardwareSimSlot,subscriber::HardwareSimSlot const&,BOOL>((uint64_t *)buf, v21, *(_DWORD *)j, 0);
        }
      }
      std::map<subscriber::HardwareSimSlot,BOOL>::map[abi:ne180100]((uint64_t)v22, buf);
      subscriber::SimCommandDriver::markAllowedToReadCDMAAuxInfo();
      std::__tree<std::__value_type<AQMThroughputKey,unsigned int>,std::__map_value_compare<AQMThroughputKey,std::__value_type<AQMThroughputKey,unsigned int>,std::less<AQMThroughputKey>,true>,std::allocator<std::__value_type<AQMThroughputKey,unsigned int>>>::destroy(v23);
      std::__tree<std::__value_type<AQMThroughputKey,unsigned int>,std::__map_value_compare<AQMThroughputKey,std::__value_type<AQMThroughputKey,unsigned int>,std::less<AQMThroughputKey>,true>,std::allocator<std::__value_type<AQMThroughputKey,unsigned int>>>::destroy(v25[0]);
    }
    else
    {
      v15 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_216897000, v15, OS_LOG_TYPE_ERROR, "Not enough app indices, required at least 2", buf, 2u);
      }
    }
    if (__p)
    {
      v27 = __p;
      operator delete(__p);
    }
    if (v29)
    {
      v30 = v29;
      operator delete(v29);
    }
    v29 = &v32;
  }
  std::vector<subscriber::SimDriverInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)&v29);
}

void sub_2169D4944(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, uint64_t a18, void *a19, uint64_t a20)
{
  uint64_t v20;

  a19 = (void *)(v20 - 88);
  std::vector<subscriber::SimDriverInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)&a19);
  _Unwind_Resume(a1);
}

void ___ZN10subscriber19EURSimCommandDriver20handleCardStatus_indERKN3uim16CardStatusChange10IndicationE_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  _BYTE v4[8];
  void *__p;
  uint64_t v6;

  v6 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 + 32);
  qmi::Message<uim::CardStatusChange::IndicationTLVList,qmi::IndicationBase>::get<uim::tlv::HardwareSlotTypes>((uint64_t)v4, *(qmi::MessageBase **)(a1 + 40));
  subscriber::EURSimCommandDriver::sendSimInfo<uim::tlv::ExtendedCardStatus>(v3, a2, (uint64_t)v4);
  if (v4[0])
  {
    if (__p)
      operator delete(__p);
  }
}

void sub_2169D4A74(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *__p)
{
  if (a10)
  {
    if (__p)
      operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void qmi::Message<uim::CardStatusChange::IndicationTLVList,qmi::IndicationBase>::get<uim::tlv::HardwareSlotTypes>(uint64_t a1, qmi::MessageBase *a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  qmi::MessageBase::tryTlv<uim::tlv::HardwareSlotTypes>(a2, (unsigned __int8 *)a1);
}

void sub_2169D4ACC(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  if (*(_BYTE *)v1)
  {
    v3 = *(void **)(v1 + 8);
    if (v3)
    {
      *(_QWORD *)(v1 + 16) = v3;
      operator delete(v3);
    }
    *(_BYTE *)v1 = 0;
  }
  _Unwind_Resume(exception_object);
}

void ___ZN10subscriber19EURSimCommandDriver20handleCardStatus_indERKN3uim16CardStatusChange10IndicationE_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  _BYTE v4[8];
  void *__p;
  uint64_t v6;

  v6 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 + 32);
  qmi::Message<uim::CardStatusChange::IndicationTLVList,qmi::IndicationBase>::get<uim::tlv::HardwareSlotTypes>((uint64_t)v4, *(qmi::MessageBase **)(a1 + 40));
  subscriber::EURSimCommandDriver::sendSimInfo<uim::tlv::CardStatus>(v3, a2, (uint64_t)v4);
  if (v4[0])
  {
    if (__p)
      operator delete(__p);
  }
}

void sub_2169D4B98(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *__p)
{
  if (a10)
  {
    if (__p)
      operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void subscriber::EURSimCommandDriver::unlockPin(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  os_log_t *v6;
  _QWORD *v7;
  char *v8;
  const void **v9;
  char *v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  char *v19;
  uint64_t *v20;
  char *v21;
  char *v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  void *v26;
  _QWORD v27[6];
  __int128 v28;
  void *v29;
  void *v30;
  uint64_t v31;
  std::string __p;
  uint64_t v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  void *v37;
  __int128 v38;
  void *v39;
  _BYTE *v40;
  uint64_t v41;
  std::string v42;
  __int128 v43;
  __int128 v44;
  _QWORD aBlock[5];

  v6 = (os_log_t *)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 48) + 16))(*(_QWORD *)(a1 + 48), *a2);
  v43 = 0u;
  v44 = 0u;
  v7 = (_QWORD *)qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)&v43);
  v8 = qmi::MutableMessageBase::getTLV<uim::tlv::SessionInfo>(v7);
  v9 = (const void **)*((_QWORD *)&v43 + 1);
  if (*((_QWORD *)&v43 + 1) != (_QWORD)v44)
  {
    while (*((_BYTE *)*v9 + 8) != 2)
    {
      if (++v9 == (const void **)v44)
        goto LABEL_8;
    }
  }
  if (v9 == (const void **)v44)
  {
LABEL_8:
    v12 = operator new();
    v13 = v12;
    *(_BYTE *)(v12 + 8) = 2;
    *(_QWORD *)v12 = off_24D5DB7B8;
    *(_DWORD *)(v12 + 16) = 0;
    v11 = (char *)(v12 + 16);
    *(_QWORD *)(v12 + 32) = 0;
    *(_QWORD *)(v12 + 40) = 0;
    *(_QWORD *)(v12 + 24) = 0;
    v14 = v44;
    if ((unint64_t)v44 >= *((_QWORD *)&v44 + 1))
    {
      v16 = (uint64_t)(v44 - *((_QWORD *)&v43 + 1)) >> 3;
      if ((unint64_t)(v16 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v17 = (uint64_t)(*((_QWORD *)&v44 + 1) - *((_QWORD *)&v43 + 1)) >> 2;
      if (v17 <= v16 + 1)
        v17 = v16 + 1;
      if (*((_QWORD *)&v44 + 1) - *((_QWORD *)&v43 + 1) >= 0x7FFFFFFFFFFFFFF8uLL)
        v18 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v18 = v17;
      if (v18)
        v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v44 + 8, v18);
      else
        v19 = 0;
      v20 = (uint64_t *)&v19[8 * v16];
      v21 = &v19[8 * v18];
      *v20 = v13;
      v15 = v20 + 1;
      v23 = (char *)*((_QWORD *)&v43 + 1);
      v22 = (char *)v44;
      if ((_QWORD)v44 != *((_QWORD *)&v43 + 1))
      {
        do
        {
          v24 = *((_QWORD *)v22 - 1);
          v22 -= 8;
          *--v20 = v24;
        }
        while (v22 != v23);
        v22 = (char *)*((_QWORD *)&v43 + 1);
      }
      *((_QWORD *)&v43 + 1) = v20;
      *(_QWORD *)&v44 = v15;
      *((_QWORD *)&v44 + 1) = v21;
      if (v22)
        operator delete(v22);
    }
    else
    {
      *(_QWORD *)v44 = v12;
      v15 = (_QWORD *)(v14 + 8);
    }
    *(_QWORD *)&v44 = v15;
  }
  else
  {
    if (!v10)
      __cxa_bad_cast();
    v11 = v10 + 16;
  }
  *(_DWORD *)v11 = 1;
  std::string::operator=((std::string *)(v11 + 8), (const std::string *)a3);
  memset(&v42, 0, sizeof(v42));
  if (*(char *)(a3 + 23) < 0)
    std::string::__init_copy_ctor_external(&v42, *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
  else
    v42 = *(std::string *)a3;
  v38 = *(_OWORD *)a2;
  v40 = 0;
  v41 = 0;
  v39 = 0;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(&v39, *((const void **)a2 + 2), *((_QWORD *)a2 + 3), *((_QWORD *)a2 + 3) - *((_QWORD *)a2 + 2));
  v33 = a1 + 128;
  v34 = QMIServiceMsg::create();
  v36 = 0;
  v37 = 0;
  v35 = 240000;
  v25 = MEMORY[0x24BDAC760];
  v27[0] = MEMORY[0x24BDAC760];
  v27[1] = 1174405120;
  v27[2] = ___ZN10subscriber19EURSimCommandDriver9unlockPinERKNS_11SimCardInfoERKNSt3__112basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEE_block_invoke;
  v27[3] = &__block_descriptor_tmp_23_6;
  v27[4] = a1;
  v27[5] = v6;
  v28 = v38;
  v30 = 0;
  v31 = 0;
  v29 = 0;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(&v29, v39, (uint64_t)v40, v40 - (_BYTE *)v39);
  if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0)
    std::string::__init_copy_ctor_external(&__p, v42.__r_.__value_.__l.__data_, v42.__r_.__value_.__l.__size_);
  else
    __p = v42;
  aBlock[0] = v25;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3uim9VerifyPin8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
  aBlock[3] = &unk_24D5DB7E8;
  aBlock[4] = v27;
  v26 = _Block_copy(aBlock);
  v37 = v26;
  if (v34)
  {
    qmi::Client::send();
    v26 = v37;
  }
  if (v26)
    _Block_release(v26);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if (v29)
  {
    v30 = v29;
    operator delete(v29);
  }
  if (v39)
  {
    v40 = v39;
    operator delete(v39);
  }
  if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v42.__r_.__value_.__l.__data_);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&v43);
}

void sub_2169D4F58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35)
{
  uint64_t v35;

  if (__p)
    operator delete(__p);
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)&a27);
  if (a34)
  {
    a35 = (uint64_t)a34;
    operator delete(a34);
  }
  if (*(char *)(v35 - 169) < 0)
    operator delete(*(void **)(v35 - 192));
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)(v35 - 160));
  _Unwind_Resume(a1);
}

uint64_t ___ZN10subscriber19EURSimCommandDriver9unlockPinERKNS_11SimCardInfoERKNSt3__112basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEE_block_invoke(uint64_t a1, qmi::MessageBase *this)
{
  uint64_t v4;
  uint64_t TlvValue;
  int v6;
  uint64_t v7;
  int v8;
  __int16 v9;
  int v10;
  NSObject *v11;
  uint64_t v12;
  const char *v13;
  NSObject *v14;
  uint32_t v15;
  NSObject *v16;
  uint64_t v17;
  uint64_t v19;
  uint64_t v20;
  _BYTE buf[18];
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)(a1 + 32);
  v19 = 0;
  v20 = 0;
  TlvValue = qmi::MessageBase::findTlvValue(this);
  if (TlvValue)
  {
    v7 = TlvValue;
    v8 = v6;
    *(_QWORD *)buf = TlvValue;
    v9 = tlv::parseV<uim::tlv::RetriesLeft>((unint64_t *)buf, v6);
    if (*(_QWORD *)buf)
    {
      BYTE4(v20) = 1;
      LODWORD(v20) = v9;
      BYTE4(v19) = 1;
      LODWORD(v19) = HIBYTE(v9);
    }
    else
    {
      ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)this, 16, v7, v8);
    }
  }
  v10 = *((_DWORD *)this + 1);
  if (v10)
  {
    if ((v10 - 35) >= 2)
    {
      if (v10 == 12)
      {
        v11 = **(NSObject ***)(a1 + 40);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
LABEL_11:
          v12 = qmi::asString();
          *(_DWORD *)buf = 136315138;
          *(_QWORD *)&buf[4] = v12;
          v13 = "#I VerifyPin did not succeed: %s";
          v14 = v11;
          v15 = 12;
LABEL_14:
          _os_log_impl(&dword_216897000, v14, OS_LOG_TYPE_DEFAULT, v13, buf, v15);
        }
      }
      else
      {
        v16 = **(NSObject ***)(a1 + 40);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          v17 = qmi::asString();
          *(_DWORD *)buf = 67109378;
          *(_DWORD *)&buf[4] = v10;
          *(_WORD *)&buf[8] = 2080;
          *(_QWORD *)&buf[10] = v17;
          v13 = "#I VerifyPin returns error: 0x%04x (%s); reseting Sim state to try again";
          v14 = v16;
          v15 = 18;
          goto LABEL_14;
        }
      }
    }
    else
    {
      v11 = **(NSObject ***)(a1 + 40);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        goto LABEL_11;
    }
  }
  return (*(uint64_t (**)(_QWORD, uint64_t, _QWORD, uint64_t, BOOL, uint64_t *, uint64_t *))(**(_QWORD **)(v4 + 88)
                                                                                                 + 48))(*(_QWORD *)(v4 + 88), a1 + 48, 0, a1 + 88, v10 == 0, &v20, &v19);
}

void __copy_helper_block_e8_48c32_ZTSKN10subscriber11SimCardInfoE88c67_ZTSKNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE(uint64_t a1, uint64_t a2)
{
  __int128 v3;
  std::string *v4;
  std::string *v5;
  __int128 v6;

  v3 = *(_OWORD *)(a2 + 48);
  *(_QWORD *)(a1 + 64) = 0;
  v4 = (std::string *)(a1 + 64);
  *(_OWORD *)(a1 + 48) = v3;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>((_QWORD *)(a1 + 64), *(const void **)(a2 + 64), *(_QWORD *)(a2 + 72), *(_QWORD *)(a2 + 72) - *(_QWORD *)(a2 + 64));
  v5 = v4 + 1;
  if (*(char *)(a2 + 111) < 0)
  {
    std::string::__init_copy_ctor_external(v5, *(const std::string::value_type **)(a2 + 88), *(_QWORD *)(a2 + 96));
  }
  else
  {
    v6 = *(_OWORD *)(a2 + 88);
    v4[1].__r_.__value_.__r.__words[2] = *(_QWORD *)(a2 + 104);
    *(_OWORD *)&v5->__r_.__value_.__l.__data_ = v6;
  }
}

void sub_2169D527C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void *v4;

  v4 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 72) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

void __destroy_helper_block_e8_48c32_ZTSKN10subscriber11SimCardInfoE88c67_ZTSKNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE(uint64_t a1)
{
  void *v2;

  if (*(char *)(a1 + 111) < 0)
    operator delete(*(void **)(a1 + 88));
  v2 = *(void **)(a1 + 64);
  if (v2)
  {
    *(_QWORD *)(a1 + 72) = v2;
    operator delete(v2);
  }
}

void subscriber::EURSimCommandDriver::unlockPuk(uint64_t a1, unsigned int *a2, const std::string *a3, uint64_t a4)
{
  os_log_t *v8;
  _QWORD *v9;
  char *v10;
  const void **v11;
  char *v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  char *v21;
  uint64_t *v22;
  char *v23;
  char *v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  void *v28;
  _QWORD v29[6];
  __int128 v30;
  void *v31;
  void *v32;
  uint64_t v33;
  std::string __p;
  uint64_t v35;
  uint64_t v36;
  int v37;
  uint64_t v38;
  void *v39;
  __int128 v40;
  void *v41;
  _BYTE *v42;
  uint64_t v43;
  std::string v44;
  __int128 v45;
  __int128 v46;
  _QWORD aBlock[5];

  v8 = (os_log_t *)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 48) + 16))(*(_QWORD *)(a1 + 48), *a2);
  v45 = 0u;
  v46 = 0u;
  v9 = (_QWORD *)qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)&v45);
  v10 = qmi::MutableMessageBase::getTLV<uim::tlv::SessionInfo>(v9);
  v11 = (const void **)*((_QWORD *)&v45 + 1);
  if (*((_QWORD *)&v45 + 1) != (_QWORD)v46)
  {
    while (*((_BYTE *)*v11 + 8) != 2)
    {
      if (++v11 == (const void **)v46)
        goto LABEL_8;
    }
  }
  if (v11 == (const void **)v46)
  {
LABEL_8:
    v14 = operator new();
    v15 = v14;
    *(_BYTE *)(v14 + 8) = 2;
    *(_QWORD *)v14 = off_24D5DB830;
    *(_DWORD *)(v14 + 16) = 0;
    v13 = (char *)(v14 + 16);
    *(_OWORD *)(v14 + 24) = 0u;
    *(_OWORD *)(v14 + 40) = 0u;
    *(_OWORD *)(v14 + 56) = 0u;
    v16 = v46;
    if ((unint64_t)v46 >= *((_QWORD *)&v46 + 1))
    {
      v18 = (uint64_t)(v46 - *((_QWORD *)&v45 + 1)) >> 3;
      if ((unint64_t)(v18 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v19 = (uint64_t)(*((_QWORD *)&v46 + 1) - *((_QWORD *)&v45 + 1)) >> 2;
      if (v19 <= v18 + 1)
        v19 = v18 + 1;
      if (*((_QWORD *)&v46 + 1) - *((_QWORD *)&v45 + 1) >= 0x7FFFFFFFFFFFFFF8uLL)
        v20 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v20 = v19;
      if (v20)
        v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v46 + 8, v20);
      else
        v21 = 0;
      v22 = (uint64_t *)&v21[8 * v18];
      v23 = &v21[8 * v20];
      *v22 = v15;
      v17 = v22 + 1;
      v25 = (char *)*((_QWORD *)&v45 + 1);
      v24 = (char *)v46;
      if ((_QWORD)v46 != *((_QWORD *)&v45 + 1))
      {
        do
        {
          v26 = *((_QWORD *)v24 - 1);
          v24 -= 8;
          *--v22 = v26;
        }
        while (v24 != v25);
        v24 = (char *)*((_QWORD *)&v45 + 1);
      }
      *((_QWORD *)&v45 + 1) = v22;
      *(_QWORD *)&v46 = v17;
      *((_QWORD *)&v46 + 1) = v23;
      if (v24)
        operator delete(v24);
    }
    else
    {
      *(_QWORD *)v46 = v14;
      v17 = (_QWORD *)(v16 + 8);
    }
    *(_QWORD *)&v46 = v17;
  }
  else
  {
    if (!v12)
      __cxa_bad_cast();
    v13 = v12 + 16;
  }
  *(_DWORD *)v13 = 1;
  std::string::operator=((std::string *)(v13 + 8), a3);
  std::string::operator=((std::string *)(v13 + 32), (const std::string *)a4);
  memset(&v44, 0, sizeof(v44));
  if (*(char *)(a4 + 23) < 0)
    std::string::__init_copy_ctor_external(&v44, *(const std::string::value_type **)a4, *(_QWORD *)(a4 + 8));
  else
    v44 = *(std::string *)a4;
  v40 = *(_OWORD *)a2;
  v42 = 0;
  v43 = 0;
  v41 = 0;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(&v41, *((const void **)a2 + 2), *((_QWORD *)a2 + 3), *((_QWORD *)a2 + 3) - *((_QWORD *)a2 + 2));
  v35 = a1 + 128;
  v36 = QMIServiceMsg::create();
  v38 = 0;
  v39 = 0;
  v37 = 240000;
  v27 = MEMORY[0x24BDAC760];
  v29[0] = MEMORY[0x24BDAC760];
  v29[1] = 1174405120;
  v29[2] = ___ZN10subscriber19EURSimCommandDriver9unlockPukERKNS_11SimCardInfoERKNSt3__112basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEESC__block_invoke;
  v29[3] = &__block_descriptor_tmp_24_10;
  v29[4] = a1;
  v29[5] = v8;
  v30 = v40;
  v32 = 0;
  v33 = 0;
  v31 = 0;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(&v31, v41, (uint64_t)v42, v42 - (_BYTE *)v41);
  if (SHIBYTE(v44.__r_.__value_.__r.__words[2]) < 0)
    std::string::__init_copy_ctor_external(&__p, v44.__r_.__value_.__l.__data_, v44.__r_.__value_.__l.__size_);
  else
    __p = v44;
  aBlock[0] = v27;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3uim10UnblockPin8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
  aBlock[3] = &unk_24D5DB860;
  aBlock[4] = v29;
  v28 = _Block_copy(aBlock);
  v39 = v28;
  if (v36)
  {
    qmi::Client::send();
    v28 = v39;
  }
  if (v28)
    _Block_release(v28);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if (v31)
  {
    v32 = v31;
    operator delete(v31);
  }
  if (v41)
  {
    v42 = v41;
    operator delete(v41);
  }
  if (SHIBYTE(v44.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v44.__r_.__value_.__l.__data_);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&v45);
}

void sub_2169D568C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35)
{
  uint64_t v35;

  if (__p)
    operator delete(__p);
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)&a27);
  if (a34)
  {
    a35 = (uint64_t)a34;
    operator delete(a34);
  }
  if (*(char *)(v35 - 169) < 0)
    operator delete(*(void **)(v35 - 192));
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)(v35 - 160));
  _Unwind_Resume(a1);
}

uint64_t ___ZN10subscriber19EURSimCommandDriver9unlockPukERKNS_11SimCardInfoERKNSt3__112basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEESC__block_invoke(uint64_t a1, qmi::MessageBase *this)
{
  uint64_t v4;
  uint64_t TlvValue;
  int v6;
  uint64_t v7;
  int v8;
  __int16 v9;
  int v10;
  NSObject *v11;
  uint64_t v12;
  const char *v13;
  NSObject *v14;
  uint32_t v15;
  NSObject *v16;
  uint64_t v17;
  uint64_t v19;
  uint64_t v20;
  _BYTE buf[18];
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)(a1 + 32);
  v19 = 0;
  v20 = 0;
  TlvValue = qmi::MessageBase::findTlvValue(this);
  if (TlvValue)
  {
    v7 = TlvValue;
    v8 = v6;
    *(_QWORD *)buf = TlvValue;
    v9 = tlv::parseV<uim::tlv::RetriesLeft>((unint64_t *)buf, v6);
    if (*(_QWORD *)buf)
    {
      BYTE4(v20) = 1;
      LODWORD(v20) = v9;
      BYTE4(v19) = 1;
      LODWORD(v19) = HIBYTE(v9);
    }
    else
    {
      ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)this, 16, v7, v8);
    }
  }
  v10 = *((_DWORD *)this + 1);
  if (v10)
  {
    if ((v10 - 35) >= 2)
    {
      if (v10 == 12)
      {
        v11 = **(NSObject ***)(a1 + 40);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
LABEL_11:
          v12 = qmi::asString();
          *(_DWORD *)buf = 136315138;
          *(_QWORD *)&buf[4] = v12;
          v13 = "#I UnblockPin did not succeed: %s";
          v14 = v11;
          v15 = 12;
LABEL_14:
          _os_log_impl(&dword_216897000, v14, OS_LOG_TYPE_DEFAULT, v13, buf, v15);
        }
      }
      else
      {
        v16 = **(NSObject ***)(a1 + 40);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          v17 = qmi::asString();
          *(_DWORD *)buf = 67109378;
          *(_DWORD *)&buf[4] = v10;
          *(_WORD *)&buf[8] = 2080;
          *(_QWORD *)&buf[10] = v17;
          v13 = "#I UnblockPin returns error: 0x%04x (%s); reseting Sim state to try again";
          v14 = v16;
          v15 = 18;
          goto LABEL_14;
        }
      }
    }
    else
    {
      v11 = **(NSObject ***)(a1 + 40);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        goto LABEL_11;
    }
  }
  return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t, BOOL, uint64_t *, uint64_t *))(**(_QWORD **)(v4 + 88)
                                                                                                  + 48))(*(_QWORD *)(v4 + 88), a1 + 48, 1, a1 + 88, v10 == 0, &v20, &v19);
}

void subscriber::EURSimCommandDriver::changePin(uint64_t a1, unsigned int *a2, const std::string *a3, uint64_t a4)
{
  os_log_t *v8;
  _QWORD *v9;
  char *v10;
  const void **v11;
  char *v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  char *v21;
  uint64_t *v22;
  char *v23;
  char *v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  void *v28;
  _QWORD v29[6];
  __int128 v30;
  void *v31;
  void *v32;
  uint64_t v33;
  std::string __p;
  uint64_t v35;
  uint64_t v36;
  int v37;
  uint64_t v38;
  void *v39;
  __int128 v40;
  void *v41;
  _BYTE *v42;
  uint64_t v43;
  std::string v44;
  __int128 v45;
  __int128 v46;
  _QWORD aBlock[5];

  v8 = (os_log_t *)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 48) + 16))(*(_QWORD *)(a1 + 48), *a2);
  v45 = 0u;
  v46 = 0u;
  v9 = (_QWORD *)qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)&v45);
  v10 = qmi::MutableMessageBase::getTLV<uim::tlv::SessionInfo>(v9);
  v11 = (const void **)*((_QWORD *)&v45 + 1);
  if (*((_QWORD *)&v45 + 1) != (_QWORD)v46)
  {
    while (*((_BYTE *)*v11 + 8) != 2)
    {
      if (++v11 == (const void **)v46)
        goto LABEL_8;
    }
  }
  if (v11 == (const void **)v46)
  {
LABEL_8:
    v14 = operator new();
    v15 = v14;
    *(_BYTE *)(v14 + 8) = 2;
    *(_QWORD *)v14 = off_24D5DB8A8;
    *(_DWORD *)(v14 + 16) = 0;
    v13 = (char *)(v14 + 16);
    *(_OWORD *)(v14 + 24) = 0u;
    *(_OWORD *)(v14 + 40) = 0u;
    *(_OWORD *)(v14 + 56) = 0u;
    v16 = v46;
    if ((unint64_t)v46 >= *((_QWORD *)&v46 + 1))
    {
      v18 = (uint64_t)(v46 - *((_QWORD *)&v45 + 1)) >> 3;
      if ((unint64_t)(v18 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v19 = (uint64_t)(*((_QWORD *)&v46 + 1) - *((_QWORD *)&v45 + 1)) >> 2;
      if (v19 <= v18 + 1)
        v19 = v18 + 1;
      if (*((_QWORD *)&v46 + 1) - *((_QWORD *)&v45 + 1) >= 0x7FFFFFFFFFFFFFF8uLL)
        v20 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v20 = v19;
      if (v20)
        v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v46 + 8, v20);
      else
        v21 = 0;
      v22 = (uint64_t *)&v21[8 * v18];
      v23 = &v21[8 * v20];
      *v22 = v15;
      v17 = v22 + 1;
      v25 = (char *)*((_QWORD *)&v45 + 1);
      v24 = (char *)v46;
      if ((_QWORD)v46 != *((_QWORD *)&v45 + 1))
      {
        do
        {
          v26 = *((_QWORD *)v24 - 1);
          v24 -= 8;
          *--v22 = v26;
        }
        while (v24 != v25);
        v24 = (char *)*((_QWORD *)&v45 + 1);
      }
      *((_QWORD *)&v45 + 1) = v22;
      *(_QWORD *)&v46 = v17;
      *((_QWORD *)&v46 + 1) = v23;
      if (v24)
        operator delete(v24);
    }
    else
    {
      *(_QWORD *)v46 = v14;
      v17 = (_QWORD *)(v16 + 8);
    }
    *(_QWORD *)&v46 = v17;
  }
  else
  {
    if (!v12)
      __cxa_bad_cast();
    v13 = v12 + 16;
  }
  *(_DWORD *)v13 = 1;
  std::string::operator=((std::string *)(v13 + 8), a3);
  std::string::operator=((std::string *)(v13 + 32), (const std::string *)a4);
  memset(&v44, 0, sizeof(v44));
  if (*(char *)(a4 + 23) < 0)
    std::string::__init_copy_ctor_external(&v44, *(const std::string::value_type **)a4, *(_QWORD *)(a4 + 8));
  else
    v44 = *(std::string *)a4;
  v40 = *(_OWORD *)a2;
  v42 = 0;
  v43 = 0;
  v41 = 0;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(&v41, *((const void **)a2 + 2), *((_QWORD *)a2 + 3), *((_QWORD *)a2 + 3) - *((_QWORD *)a2 + 2));
  v35 = a1 + 128;
  v36 = QMIServiceMsg::create();
  v38 = 0;
  v39 = 0;
  v37 = 240000;
  v27 = MEMORY[0x24BDAC760];
  v29[0] = MEMORY[0x24BDAC760];
  v29[1] = 1174405120;
  v29[2] = ___ZN10subscriber19EURSimCommandDriver9changePinERKNS_11SimCardInfoERKNSt3__112basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEESC__block_invoke;
  v29[3] = &__block_descriptor_tmp_25_6;
  v29[4] = a1;
  v29[5] = v8;
  v30 = v40;
  v32 = 0;
  v33 = 0;
  v31 = 0;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(&v31, v41, (uint64_t)v42, v42 - (_BYTE *)v41);
  if (SHIBYTE(v44.__r_.__value_.__r.__words[2]) < 0)
    std::string::__init_copy_ctor_external(&__p, v44.__r_.__value_.__l.__data_, v44.__r_.__value_.__l.__size_);
  else
    __p = v44;
  aBlock[0] = v27;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3uim9ChangePin8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
  aBlock[3] = &unk_24D5DB8D8;
  aBlock[4] = v29;
  v28 = _Block_copy(aBlock);
  v39 = v28;
  if (v36)
  {
    qmi::Client::send();
    v28 = v39;
  }
  if (v28)
    _Block_release(v28);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if (v31)
  {
    v32 = v31;
    operator delete(v31);
  }
  if (v41)
  {
    v42 = v41;
    operator delete(v41);
  }
  if (SHIBYTE(v44.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v44.__r_.__value_.__l.__data_);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&v45);
}

void sub_2169D5CE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35)
{
  uint64_t v35;

  if (__p)
    operator delete(__p);
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)&a27);
  if (a34)
  {
    a35 = (uint64_t)a34;
    operator delete(a34);
  }
  if (*(char *)(v35 - 169) < 0)
    operator delete(*(void **)(v35 - 192));
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)(v35 - 160));
  _Unwind_Resume(a1);
}

uint64_t ___ZN10subscriber19EURSimCommandDriver9changePinERKNS_11SimCardInfoERKNSt3__112basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEESC__block_invoke(uint64_t a1, qmi::MessageBase *this)
{
  uint64_t v4;
  uint64_t TlvValue;
  int v6;
  uint64_t v7;
  int v8;
  __int16 v9;
  int v10;
  NSObject *v11;
  uint64_t v12;
  uint64_t v13;
  const char *v14;
  NSObject *v15;
  uint32_t v16;
  NSObject *v17;
  uint64_t v18;
  uint64_t v20;
  uint64_t v21;
  _BYTE buf[18];
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)(a1 + 32);
  v20 = 0;
  v21 = 0;
  TlvValue = qmi::MessageBase::findTlvValue(this);
  if (TlvValue)
  {
    v7 = TlvValue;
    v8 = v6;
    *(_QWORD *)buf = TlvValue;
    v9 = tlv::parseV<uim::tlv::RetriesLeft>((unint64_t *)buf, v6);
    if (*(_QWORD *)buf)
    {
      BYTE4(v21) = 1;
      LODWORD(v21) = v9;
      BYTE4(v20) = 1;
      LODWORD(v20) = HIBYTE(v9);
    }
    else
    {
      ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)this, 16, v7, v8);
    }
  }
  v10 = *((_DWORD *)this + 1);
  if (v10)
  {
    if ((v10 - 35) >= 2)
    {
      if (v10 == 12)
      {
        v11 = **(NSObject ***)(a1 + 40);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
LABEL_12:
          v13 = qmi::asString();
          *(_DWORD *)buf = 136315138;
          *(_QWORD *)&buf[4] = v13;
          v14 = "#I ChangePin did not succeed: %s";
          v15 = v11;
          v16 = 12;
LABEL_15:
          _os_log_impl(&dword_216897000, v15, OS_LOG_TYPE_DEFAULT, v14, buf, v16);
        }
      }
      else
      {
        v17 = **(NSObject ***)(a1 + 40);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          v18 = qmi::asString();
          *(_DWORD *)buf = 67109378;
          *(_DWORD *)&buf[4] = v10;
          *(_WORD *)&buf[8] = 2080;
          *(_QWORD *)&buf[10] = v18;
          v14 = "#I ChangePin returns error: 0x%04x (%s); reseting Sim state to try again";
          v15 = v17;
          v16 = 18;
          goto LABEL_15;
        }
      }
    }
    else
    {
      v11 = **(NSObject ***)(a1 + 40);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        goto LABEL_12;
    }
    v12 = 42;
    return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, BOOL, uint64_t, uint64_t *, uint64_t *))(**(_QWORD **)(v4 + 88) + 56))(*(_QWORD *)(v4 + 88), a1 + 48, a1 + 88, v10 == 0, v12, &v21, &v20);
  }
  v12 = 0;
  return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, BOOL, uint64_t, uint64_t *, uint64_t *))(**(_QWORD **)(v4 + 88)
                                                                                                  + 56))(*(_QWORD *)(v4 + 88), a1 + 48, a1 + 88, v10 == 0, v12, &v21, &v20);
}

void subscriber::EURSimCommandDriver::setPinEnabled(uint64_t a1, unsigned int *a2, char a3, uint64_t a4)
{
  os_log_t *v8;
  _QWORD *v9;
  char *v10;
  const void **v11;
  char *v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  char *v21;
  uint64_t *v22;
  char *v23;
  char *v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  void *v28;
  _QWORD v29[6];
  __int128 v30;
  void *v31;
  void *v32;
  uint64_t v33;
  std::string __p;
  char v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  void *v40;
  __int128 v41;
  void *v42;
  _BYTE *v43;
  uint64_t v44;
  std::string v45;
  __int128 v46;
  __int128 v47;
  _QWORD aBlock[5];

  v8 = (os_log_t *)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 48) + 16))(*(_QWORD *)(a1 + 48), *a2);
  v46 = 0u;
  v47 = 0u;
  v9 = (_QWORD *)qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)&v46);
  v10 = qmi::MutableMessageBase::getTLV<uim::tlv::SessionInfo>(v9);
  v11 = (const void **)*((_QWORD *)&v46 + 1);
  if (*((_QWORD *)&v46 + 1) != (_QWORD)v47)
  {
    while (*((_BYTE *)*v11 + 8) != 2)
    {
      if (++v11 == (const void **)v47)
        goto LABEL_8;
    }
  }
  if (v11 == (const void **)v47)
  {
LABEL_8:
    v14 = operator new();
    v15 = v14;
    *(_BYTE *)(v14 + 8) = 2;
    *(_QWORD *)v14 = off_24D5DB920;
    *(_DWORD *)(v14 + 16) = 0;
    v13 = (char *)(v14 + 16);
    *(_BYTE *)(v14 + 20) = 0;
    *(_QWORD *)(v14 + 32) = 0;
    *(_QWORD *)(v14 + 40) = 0;
    *(_QWORD *)(v14 + 24) = 0;
    v16 = v47;
    if ((unint64_t)v47 >= *((_QWORD *)&v47 + 1))
    {
      v18 = (uint64_t)(v47 - *((_QWORD *)&v46 + 1)) >> 3;
      if ((unint64_t)(v18 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v19 = (uint64_t)(*((_QWORD *)&v47 + 1) - *((_QWORD *)&v46 + 1)) >> 2;
      if (v19 <= v18 + 1)
        v19 = v18 + 1;
      if (*((_QWORD *)&v47 + 1) - *((_QWORD *)&v46 + 1) >= 0x7FFFFFFFFFFFFFF8uLL)
        v20 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v20 = v19;
      if (v20)
        v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v47 + 8, v20);
      else
        v21 = 0;
      v22 = (uint64_t *)&v21[8 * v18];
      v23 = &v21[8 * v20];
      *v22 = v15;
      v17 = v22 + 1;
      v25 = (char *)*((_QWORD *)&v46 + 1);
      v24 = (char *)v47;
      if ((_QWORD)v47 != *((_QWORD *)&v46 + 1))
      {
        do
        {
          v26 = *((_QWORD *)v24 - 1);
          v24 -= 8;
          *--v22 = v26;
        }
        while (v24 != v25);
        v24 = (char *)*((_QWORD *)&v46 + 1);
      }
      *((_QWORD *)&v46 + 1) = v22;
      *(_QWORD *)&v47 = v17;
      *((_QWORD *)&v47 + 1) = v23;
      if (v24)
        operator delete(v24);
    }
    else
    {
      *(_QWORD *)v47 = v14;
      v17 = (_QWORD *)(v16 + 8);
    }
    *(_QWORD *)&v47 = v17;
  }
  else
  {
    if (!v12)
      __cxa_bad_cast();
    v13 = v12 + 16;
  }
  *(_DWORD *)v13 = 1;
  v13[4] = a3;
  std::string::operator=((std::string *)(v13 + 8), (const std::string *)a4);
  memset(&v45, 0, sizeof(v45));
  if (*(char *)(a4 + 23) < 0)
    std::string::__init_copy_ctor_external(&v45, *(const std::string::value_type **)a4, *(_QWORD *)(a4 + 8));
  else
    v45 = *(std::string *)a4;
  v41 = *(_OWORD *)a2;
  v43 = 0;
  v44 = 0;
  v42 = 0;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(&v42, *((const void **)a2 + 2), *((_QWORD *)a2 + 3), *((_QWORD *)a2 + 3) - *((_QWORD *)a2 + 2));
  v36 = a1 + 128;
  v37 = QMIServiceMsg::create();
  v39 = 0;
  v40 = 0;
  v38 = 240000;
  v27 = MEMORY[0x24BDAC760];
  v29[0] = MEMORY[0x24BDAC760];
  v29[1] = 1174405120;
  v29[2] = ___ZN10subscriber19EURSimCommandDriver13setPinEnabledERKNS_11SimCardInfoEbRKNSt3__112basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEE_block_invoke;
  v29[3] = &__block_descriptor_tmp_26_7;
  v29[4] = a1;
  v29[5] = v8;
  v30 = v41;
  v32 = 0;
  v33 = 0;
  v31 = 0;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(&v31, v42, (uint64_t)v43, v43 - (_BYTE *)v42);
  v35 = a3;
  if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0)
    std::string::__init_copy_ctor_external(&__p, v45.__r_.__value_.__l.__data_, v45.__r_.__value_.__l.__size_);
  else
    __p = v45;
  aBlock[0] = v27;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3uim16SetPinProtection8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
  aBlock[3] = &unk_24D5DB950;
  aBlock[4] = v29;
  v28 = _Block_copy(aBlock);
  v40 = v28;
  if (v37)
  {
    qmi::Client::send();
    v28 = v40;
  }
  if (v28)
    _Block_release(v28);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if (v31)
  {
    v32 = v31;
    operator delete(v31);
  }
  if (v42)
  {
    v43 = v42;
    operator delete(v42);
  }
  if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v45.__r_.__value_.__l.__data_);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&v46);
}

void sub_2169D6338(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35)
{
  uint64_t v35;

  if (__p)
    operator delete(__p);
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)&a27);
  if (a34)
  {
    a35 = (uint64_t)a34;
    operator delete(a34);
  }
  if (*(char *)(v35 - 169) < 0)
    operator delete(*(void **)(v35 - 192));
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)(v35 - 160));
  _Unwind_Resume(a1);
}

uint64_t ___ZN10subscriber19EURSimCommandDriver13setPinEnabledERKNS_11SimCardInfoEbRKNSt3__112basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEE_block_invoke(uint64_t a1, qmi::MessageBase *this)
{
  uint64_t v4;
  uint64_t TlvValue;
  int v6;
  uint64_t v7;
  int v8;
  int v9;
  NSObject *v10;
  uint64_t v11;
  const char *v12;
  NSObject *v13;
  NSObject *v14;
  uint64_t v15;
  uint32_t v16;
  NSObject *v17;
  uint64_t v18;
  _BYTE buf[18];
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)(a1 + 32);
  TlvValue = qmi::MessageBase::findTlvValue(this);
  if (TlvValue)
  {
    v7 = TlvValue;
    v8 = v6;
    *(_QWORD *)buf = TlvValue;
    tlv::parseV<uim::tlv::RetriesLeft>((unint64_t *)buf, v6);
    if (!*(_QWORD *)buf)
      ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)this, 16, v7, v8);
  }
  v9 = *((_DWORD *)this + 1);
  if ((v9 - 35) < 2)
  {
    v14 = **(NSObject ***)(a1 + 40);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      v15 = qmi::asString();
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = v15;
      v12 = "#I SetPinProtection did not succeed: %s";
      v13 = v14;
      goto LABEL_11;
    }
  }
  else
  {
    if (!v9)
      return (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v4 + 88) + 64))(*(_QWORD *)(v4 + 88), a1 + 48);
    if (v9 == 12)
    {
      v10 = **(NSObject ***)(a1 + 40);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        v11 = qmi::asString();
        *(_DWORD *)buf = 136315138;
        *(_QWORD *)&buf[4] = v11;
        v12 = "#I SetPinProtection did not succeed: %s";
        v13 = v10;
LABEL_11:
        v16 = 12;
LABEL_15:
        _os_log_impl(&dword_216897000, v13, OS_LOG_TYPE_DEFAULT, v12, buf, v16);
      }
    }
    else
    {
      v17 = **(NSObject ***)(a1 + 40);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        v18 = qmi::asString();
        *(_DWORD *)buf = 67109378;
        *(_DWORD *)&buf[4] = v9;
        *(_WORD *)&buf[8] = 2080;
        *(_QWORD *)&buf[10] = v18;
        v12 = "#I SetPinProtection returns error: 0x%04x (%s); reseting Sim state to try again";
        v13 = v17;
        v16 = 18;
        goto LABEL_15;
      }
    }
  }
  return (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v4 + 88) + 64))(*(_QWORD *)(v4 + 88), a1 + 48);
}

void subscriber::EURSimCommandDriver::setObservedFiles(uint64_t a1, char **a2, _QWORD *a3)
{
  uint64_t v6;
  os_log_t *v7;
  _QWORD *v8;
  char *v9;
  char *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  char *v16;
  uint64_t v17;
  char *v18;
  void *v19;
  _QWORD *v20;
  _QWORD *v21;
  BOOL v22;
  NSObject *v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  unsigned int *v27;
  uint64_t v28;
  const void **v29;
  NSObject *v30;
  uint64_t v31;
  char *v32;
  char *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  _QWORD *v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  char *v41;
  uint64_t *v42;
  char *v43;
  char *v44;
  char *v45;
  uint64_t v46;
  void *v47;
  uint64_t v48;
  os_log_t *v49;
  _QWORD v50[5];
  uint64_t v51;
  void *__p[2];
  uint64_t v53;
  void *aBlock;
  _QWORD v55[2];
  uint64_t (*v56)(uint64_t *, uint64_t);
  void *v57;
  _QWORD v58[3];
  __int128 v59;
  __int128 v60;
  char *v61;
  char *v62;
  unint64_t v63;
  _BYTE buf[24];
  char *v65;
  unint64_t *v66;
  uint64_t v67;

  v67 = *MEMORY[0x24BDAC8D0];
  v6 = (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 48) + 16))(*(_QWORD *)(a1 + 48), *(unsigned int *)a2);
  v7 = (os_log_t *)v6;
  v61 = 0;
  v62 = 0;
  v63 = 0;
  v8 = (_QWORD *)*a3;
  if ((_QWORD *)*a3 == a3 + 1)
    goto LABEL_32;
  v48 = a1;
  v49 = (os_log_t *)v6;
  do
  {
    subscriber::sGetFileId((char *)&v51);
    v9 = v62;
    if ((unint64_t)v62 >= v63)
    {
      v11 = (v62 - v61) >> 5;
      v12 = v11 + 1;
      if ((unint64_t)(v11 + 1) >> 59)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v13 = v63 - (_QWORD)v61;
      if ((uint64_t)(v63 - (_QWORD)v61) >> 4 > v12)
        v12 = v13 >> 4;
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFE0)
        v14 = 0x7FFFFFFFFFFFFFFLL;
      else
        v14 = v12;
      v66 = &v63;
      v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<vs::tlv::RemoteNumberListItem>>((uint64_t)&v63, v14);
      v16 = &v15[32 * v11];
      *(_QWORD *)buf = v15;
      *(_QWORD *)&buf[8] = v16;
      v65 = &v15[32 * v17];
      *(_WORD *)v16 = v51;
      *((_QWORD *)v16 + 2) = 0;
      *((_QWORD *)v16 + 3) = 0;
      *((_QWORD *)v16 + 1) = 0;
      *(_OWORD *)(v16 + 8) = *(_OWORD *)__p;
      *((_QWORD *)v16 + 3) = v53;
      __p[0] = 0;
      __p[1] = 0;
      v53 = 0;
      *(_QWORD *)&buf[16] = v16 + 32;
      std::vector<uim::tlv::FileId>::__swap_out_circular_buffer((uint64_t *)&v61, buf);
      v10 = v62;
      std::__split_buffer<at::tlv::CommandCallback>::~__split_buffer((uint64_t)buf);
      v62 = v10;
      if (__p[0])
      {
        __p[1] = __p[0];
        operator delete(__p[0]);
        v10 = v62;
      }
    }
    else
    {
      *(_WORD *)v62 = v51;
      *((_QWORD *)v9 + 2) = 0;
      *((_QWORD *)v9 + 3) = 0;
      *((_QWORD *)v9 + 1) = 0;
      *(_OWORD *)(v9 + 8) = *(_OWORD *)__p;
      *((_QWORD *)v9 + 3) = v53;
      v10 = v9 + 32;
      v62 = v9 + 32;
    }
    if (subscriber::sIsFileIdInvalid((uint64_t)(v10 - 32)))
    {
      v18 = v62;
      v19 = (void *)*((_QWORD *)v62 - 3);
      if (v19)
      {
        *((_QWORD *)v62 - 2) = v19;
        operator delete(v19);
      }
      v62 = v18 - 32;
    }
    v20 = (_QWORD *)v8[1];
    if (v20)
    {
      do
      {
        v21 = v20;
        v20 = (_QWORD *)*v20;
      }
      while (v20);
    }
    else
    {
      do
      {
        v21 = (_QWORD *)v8[2];
        v22 = *v21 == (_QWORD)v8;
        v8 = v21;
      }
      while (!v22);
    }
    v8 = v21;
  }
  while (v21 != a3 + 1);
  v7 = v49;
  if (v61 == v62)
  {
LABEL_32:
    v30 = *v7;
    if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
    {
      v31 = subscriber::asString();
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = v31;
      _os_log_impl(&dword_216897000, v30, OS_LOG_TYPE_DEFAULT, "#I Observed files list for %s ended up empty, probably due to unknown sim type; skipping for now",
        buf,
        0xCu);
    }
  }
  else
  {
    v23 = *v49;
    if (os_log_type_enabled(*v49, OS_LOG_TYPE_DEFAULT))
    {
      v24 = a3[2];
      v25 = subscriber::asString();
      *(_DWORD *)buf = 134218242;
      *(_QWORD *)&buf[4] = v24;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = v25;
      _os_log_impl(&dword_216897000, v23, OS_LOG_TYPE_DEFAULT, "#I Setting observed files (count = %lu) for %s", buf, 0x16u);
    }
    v59 = 0u;
    v60 = 0u;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)&v59);
    v26 = qmi::MutableMessageBase::getTLV<uim::tlv::SessionInfo>(&v59);
    v27 = (unsigned int *)(v26 + 8);
    if (v27 != (unsigned int *)(a2 + 2))
      std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(v27, a2[2], a2[3], a2[3] - a2[2]);
    v28 = MEMORY[0x24BDAC760];
    v55[0] = MEMORY[0x24BDAC760];
    v55[1] = 1174405120;
    v56 = ___ZN10subscriber19EURSimCommandDriver16setObservedFilesERKNS_11SimCardInfoERKNSt3__13setINS_11SimFilePathENS4_4lessIS6_EENS4_9allocatorIS6_EEEE_block_invoke;
    v57 = &__block_descriptor_tmp_28_8;
    memset(v58, 0, sizeof(v58));
    std::vector<uim::tlv::FileId>::__init_with_size[abi:ne180100]<uim::tlv::FileId*,uim::tlv::FileId*>(v58, (uint64_t)v61, (uint64_t)v62, (v62 - v61) >> 5);
    v29 = (const void **)*((_QWORD *)&v59 + 1);
    if (*((_QWORD *)&v59 + 1) != (_QWORD)v60)
    {
      while (*((_BYTE *)*v29 + 8) != 2)
      {
        if (++v29 == (const void **)v60)
          goto LABEL_37;
      }
    }
    if (v29 == (const void **)v60)
    {
LABEL_37:
      v34 = operator new();
      v35 = v34;
      *(_BYTE *)(v34 + 8) = 2;
      *(_QWORD *)v34 = off_24D5DB998;
      *(_WORD *)(v34 + 16) = 0;
      v33 = (char *)(v34 + 16);
      *(_QWORD *)(v34 + 32) = 0;
      *(_QWORD *)(v34 + 40) = 0;
      *(_QWORD *)(v34 + 24) = 0;
      v36 = v60;
      if ((unint64_t)v60 >= *((_QWORD *)&v60 + 1))
      {
        v38 = (uint64_t)(v60 - *((_QWORD *)&v59 + 1)) >> 3;
        if ((unint64_t)(v38 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v39 = (uint64_t)(*((_QWORD *)&v60 + 1) - *((_QWORD *)&v59 + 1)) >> 2;
        if (v39 <= v38 + 1)
          v39 = v38 + 1;
        if (*((_QWORD *)&v60 + 1) - *((_QWORD *)&v59 + 1) >= 0x7FFFFFFFFFFFFFF8uLL)
          v40 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v40 = v39;
        if (v40)
          v41 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v60 + 8, v40);
        else
          v41 = 0;
        v42 = (uint64_t *)&v41[8 * v38];
        v43 = &v41[8 * v40];
        *v42 = v35;
        v37 = v42 + 1;
        v45 = (char *)*((_QWORD *)&v59 + 1);
        v44 = (char *)v60;
        if ((_QWORD)v60 != *((_QWORD *)&v59 + 1))
        {
          do
          {
            v46 = *((_QWORD *)v44 - 1);
            v44 -= 8;
            *--v42 = v46;
          }
          while (v44 != v45);
          v44 = (char *)*((_QWORD *)&v59 + 1);
        }
        *((_QWORD *)&v59 + 1) = v42;
        *(_QWORD *)&v60 = v37;
        *((_QWORD *)&v60 + 1) = v43;
        if (v44)
          operator delete(v44);
      }
      else
      {
        *(_QWORD *)v60 = v34;
        v37 = (_QWORD *)(v36 + 8);
      }
      *(_QWORD *)&v60 = v37;
    }
    else
    {
      if (!v32)
        __cxa_bad_cast();
      v33 = v32 + 16;
    }
    v56(v55, (uint64_t)v33);
    v51 = v48 + 128;
    __p[0] = (void *)QMIServiceMsg::create();
    v53 = 0;
    aBlock = 0;
    LODWORD(__p[1]) = 240000;
    v50[0] = v28;
    v50[1] = 0x40000000;
    v50[2] = ___ZN10subscriber19EURSimCommandDriver16setObservedFilesERKNS_11SimCardInfoERKNSt3__13setINS_11SimFilePathENS4_4lessIS6_EENS4_9allocatorIS6_EEEE_block_invoke_29;
    v50[3] = &__block_descriptor_tmp_30_7;
    v50[4] = v49;
    *(_QWORD *)buf = v28;
    *(_QWORD *)&buf[8] = 0x40000000;
    *(_QWORD *)&buf[16] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_21;
    v65 = (char *)&unk_24D5DB9C8;
    v66 = v50;
    v47 = _Block_copy(buf);
    aBlock = v47;
    if (__p[0])
    {
      qmi::Client::send();
      v47 = aBlock;
    }
    if (v47)
      _Block_release(v47);
    *(_QWORD *)buf = v58;
    std::vector<at::tlv::CommandCallback>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
    qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&v59);
  }
  *(_QWORD *)buf = &v61;
  std::vector<at::tlv::CommandCallback>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
}

void sub_2169D6BCC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  uint64_t v29;

  a17 = v29 - 168;
  std::vector<at::tlv::CommandCallback>::__destroy_vector::operator()[abi:ne180100]((void ***)&a17);
  _Unwind_Resume(a1);
}

void subscriber::sGetFileId(char *a1)
{
  uint64_t v2;
  void *__p;
  void *v4;

  subscriber::getFileId();
  subscriber::sConvertFileId(a1, (uint64_t)&v2);
  if (__p)
  {
    v4 = __p;
    operator delete(__p);
  }
}

void sub_2169D6CD0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t subscriber::sIsFileIdInvalid(uint64_t a1)
{
  uint64_t isFileIdInvalid;
  char v3[8];
  void *__p;
  void *v5;

  subscriber::sConvertFileId(v3, a1);
  isFileIdInvalid = subscriber::isFileIdInvalid();
  if (__p)
  {
    v5 = __p;
    operator delete(__p);
  }
  return isFileIdInvalid;
}

void sub_2169D6D38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t ___ZN10subscriber19EURSimCommandDriver16setObservedFilesERKNS_11SimCardInfoERKNSt3__13setINS_11SimFilePathENS4_4lessIS6_EENS4_9allocatorIS6_EEEE_block_invoke(uint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t *v14;
  uint64_t result;

  *(_BYTE *)a2 = 1;
  v3 = a2 + 8;
  if ((uint64_t *)(a2 + 8) == a1 + 4)
    goto LABEL_20;
  v5 = a1[4];
  v4 = a1[5];
  v6 = (v4 - v5) >> 5;
  v7 = *(_QWORD *)(a2 + 24);
  v8 = *(_QWORD *)(a2 + 8);
  if (v6 > (v7 - v8) >> 5)
  {
    if (v8)
    {
      std::vector<at::tlv::CommandCallback>::__clear[abi:ne180100]((uint64_t *)(a2 + 8));
      operator delete(*(void **)v3);
      v7 = 0;
      *(_QWORD *)v3 = 0;
      *(_QWORD *)(v3 + 8) = 0;
      *(_QWORD *)(v3 + 16) = 0;
    }
    if (v4 - v5 < 0)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v9 = v7 >> 4;
    if (v7 >> 4 <= v6)
      v9 = (v4 - v5) >> 5;
    if ((unint64_t)v7 >= 0x7FFFFFFFFFFFFFE0)
      v10 = 0x7FFFFFFFFFFFFFFLL;
    else
      v10 = v9;
    std::vector<uim::tlv::FileId>::__vallocate[abi:ne180100]((_QWORD *)v3, v10);
    a1 = (uint64_t *)std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<uim::tlv::FileId>,uim::tlv::FileId*,uim::tlv::FileId*,uim::tlv::FileId*>(a2 + 24, v5, v4, *(_QWORD *)(a2 + 16));
    goto LABEL_14;
  }
  v11 = (*(_QWORD *)(a2 + 16) - v8) >> 5;
  if (v11 < v6)
  {
    v12 = v5 + 32 * v11;
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<uim::tlv::FileId *,uim::tlv::FileId *,uim::tlv::FileId *>(a1[4], v12, v8);
    a1 = (uint64_t *)std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<uim::tlv::FileId>,uim::tlv::FileId*,uim::tlv::FileId*,uim::tlv::FileId*>(a2 + 24, v12, v4, *(_QWORD *)(a2 + 16));
LABEL_14:
    *(_QWORD *)(a2 + 16) = a1;
    goto LABEL_20;
  }
  a1 = (uint64_t *)std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<uim::tlv::FileId *,uim::tlv::FileId *,uim::tlv::FileId *>(a1[4], v4, v8);
  v13 = a1;
  v14 = *(uint64_t **)(a2 + 16);
  if (v14 != a1)
  {
    do
    {
      a1 = (uint64_t *)*(v14 - 3);
      if (a1)
      {
        *(v14 - 2) = (uint64_t)a1;
        operator delete(a1);
      }
      v14 -= 4;
    }
    while (v14 != v13);
  }
  *(_QWORD *)(a2 + 16) = v13;
LABEL_20:
  result = capabilities::ct::supportsVoiceCall((capabilities::ct *)a1);
  if ((_DWORD)result)
    *(_BYTE *)(a2 + 1) = 1;
  return result;
}

void sub_2169D6EC0(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 16) = v2;
  _Unwind_Resume(a1);
}

void sub_2169D6EC8(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 16) = v2;
  _Unwind_Resume(a1);
}

_QWORD *__copy_helper_block_e8_32c57_ZTSNSt3__16vectorIN3uim3tlv6FileIdENS_9allocatorIS3_EEEE(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  v2 = (_QWORD *)(a1 + 32);
  v2[2] = 0;
  return std::vector<uim::tlv::FileId>::__init_with_size[abi:ne180100]<uim::tlv::FileId*,uim::tlv::FileId*>(v2, *(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 40), (uint64_t)(*(_QWORD *)(a2 + 40) - *(_QWORD *)(a2 + 32)) >> 5);
}

void __destroy_helper_block_e8_32c57_ZTSNSt3__16vectorIN3uim3tlv6FileIdENS_9allocatorIS3_EEEE(uint64_t a1)
{
  void **v1;

  v1 = (void **)(a1 + 32);
  std::vector<at::tlv::CommandCallback>::__destroy_vector::operator()[abi:ne180100](&v1);
}

void ___ZN10subscriber19EURSimCommandDriver16setObservedFilesERKNS_11SimCardInfoERKNSt3__13setINS_11SimFilePathENS4_4lessIS6_EENS4_9allocatorIS6_EEEE_block_invoke_29(uint64_t a1, uint64_t a2)
{
  int v2;
  NSObject *v3;
  _DWORD v4[2];
  __int16 v5;
  uint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v2 = *(_DWORD *)(a2 + 4);
  v3 = **(NSObject ***)(a1 + 32);
  if (v2)
  {
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      v4[0] = 67109378;
      v4[1] = v2;
      v5 = 2080;
      v6 = qmi::asString();
      _os_log_error_impl(&dword_216897000, v3, OS_LOG_TYPE_ERROR, "RefreshReg returns error: 0x%04x (%s); should reset?",
        (uint8_t *)v4,
        0x12u);
    }
  }
  else if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v4[0]) = 0;
    _os_log_impl(&dword_216897000, v3, OS_LOG_TYPE_DEFAULT, "#I Refresh indication for the observed files has been registered successfully", (uint8_t *)v4, 2u);
  }
}

void ___ZNK10subscriber19EURSimCommandDriver19sendRefreshCompleteEN8dispatch13group_sessionERKN3uim3tlv11SessionInfoEb_block_invoke_3(uint64_t a1, uint64_t a2)
{
  int v2;
  NSObject *v3;
  _BOOL4 v4;
  const char *v5;
  NSObject *v6;
  uint32_t v7;
  _DWORD v8[2];
  __int16 v9;
  uint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v2 = *(_DWORD *)(a2 + 4);
  v3 = *(NSObject **)(*(_QWORD *)(a1 + 32) + 40);
  v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (!v4)
      return;
    v8[0] = 67109378;
    v8[1] = v2;
    v9 = 2080;
    v10 = qmi::asString();
    v5 = "#I RefreshComplete returns error: 0x%04x (%s); should reset?";
    v6 = v3;
    v7 = 18;
  }
  else
  {
    if (!v4)
      return;
    LOWORD(v8[0]) = 0;
    v5 = "#I RefreshComplete sent to baseband successfully";
    v6 = v3;
    v7 = 2;
  }
  _os_log_impl(&dword_216897000, v6, OS_LOG_TYPE_DEFAULT, v5, (uint8_t *)v8, v7);
}

void ___ZN10subscriber19EURSimCommandDriver17handleRefresh_indERKN3uim7Refresh10IndicationE_block_invoke(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v3;
  NSObject *v4;
  const char *v5;
  const char *v6;
  const char *v7;
  void **v8;
  char *v9;
  const void **v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  int v14;
  unsigned int v15;
  _BOOL4 v16;
  unsigned int v17;
  unsigned int v18;
  char *v19;
  _BYTE *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _QWORD *v24;
  unsigned int v25;
  int v26;
  int v27;
  int v28;
  uint64_t v29;
  uint64_t (***v30)();
  uint64_t v31;
  unsigned int v32;
  int v33;
  int v34;
  int v35;
  uint64_t v36;
  uint64_t (***v37)();
  uint64_t v38;
  unsigned int v39;
  void *v40;
  uint64_t v41;
  unint64_t v42;
  unint64_t v43;
  char *v44;
  NSObject *v45;
  NSObject *v46;
  unsigned int v47;
  uint64_t v48;
  unsigned int v49;
  unsigned int v50;
  int v51;
  int v52;
  uint64_t v53;
  uint64_t v54;
  char *v55;
  char *v56;
  unint64_t v57;
  char *v58;
  uint64_t v59;
  int SimFilePath;
  uint64_t v61;
  unint64_t v62;
  unint64_t v63;
  uint64_t v64;
  char *v65;
  int v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t (***v69)();
  uint64_t v70;
  __int16 v71;
  char *v72;
  _QWORD *v73;
  uint64_t v74;
  uint64_t v75;
  NSObject *v76;
  NSObject *v77;
  NSObject *v78;
  NSObject *v79;
  std::__shared_weak_count *v80;
  uint64_t v81;
  std::__shared_weak_count *v82;
  std::__shared_weak_count *v83;
  unint64_t *p_shared_weak_owners;
  unint64_t v85;
  unint64_t *p_shared_owners;
  unint64_t v87;
  NSObject *v88;
  unint64_t v89;
  uint64_t *v90;
  char *v91;
  char *v92;
  char *v93;
  uint64_t v94;
  char v95;
  NSObject *v96;
  int v97;
  int v98;
  unsigned int v99;
  char v100;
  unsigned __int8 *v101;
  int v102;
  unsigned int v103;
  _QWORD *v104;
  dispatch_object_t object;
  os_log_t *v106;
  _QWORD block[4];
  dispatch_group_t group;
  void *__p[2];
  __int128 v110;
  void *v111[2];
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  dispatch_object_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  __int128 v120;
  __int128 v121;
  uint64_t v122;
  void **v123;
  uint8_t buf[24];
  const char *v125;
  __int128 aBlock;
  std::__shared_weak_count *v127;
  dispatch_object_t v128;
  _BYTE v129[24];
  _BYTE *v130;
  uint64_t (**v131)();
  int v132;
  uint64_t (***v133)();
  uint64_t (***v134)();
  char *v135;
  __int16 v136;
  uint64_t v137;

  v137 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 + 32);
  v4 = *(NSObject **)(v3 + 40);
  v106 = (os_log_t *)(v3 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v5 = uim::asString(*a2);
    v6 = uim::asString(*((_DWORD *)a2 + 1));
    v7 = uim::asString(a2[8]);
    ctu::hex();
    v8 = (SBYTE7(v110) & 0x80u) == 0 ? __p : (void **)__p[0];
    *(_DWORD *)buf = 136315906;
    *(_QWORD *)&buf[4] = v5;
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = v6;
    *(_WORD *)&buf[22] = 2080;
    v125 = v7;
    LOWORD(aBlock) = 2080;
    *(_QWORD *)((char *)&aBlock + 2) = v8;
    _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I Got uim::Refresh::Indication (stage=%s, mode=%s, type=%s, appID=%s)", buf, 0x2Au);
    if (SBYTE7(v110) < 0)
      operator delete(__p[0]);
  }
  switch(*a2)
  {
    case 0u:
      *(_OWORD *)__p = 0u;
      v110 = 0u;
      qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
      v9 = qmi::MutableMessageBase::getTLV<uim::tlv::SessionInfo>(__p);
      *v9 = a2[8];
      if (a2 + 8 != (unsigned __int8 *)v9)
        std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((_QWORD *)v9 + 1, *((char **)a2 + 2), *((char **)a2 + 3), *((_QWORD *)a2 + 3) - *((_QWORD *)a2 + 2));
      v10 = (const void **)__p[1];
      if (__p[1] == (void *)v110)
        goto LABEL_20;
      while (*((_BYTE *)*v10 + 8) != 2)
      {
        if (++v10 == (const void **)v110)
          goto LABEL_23;
      }
LABEL_20:
      if (v10 == (const void **)v110)
      {
LABEL_23:
        v21 = operator new();
        v22 = v21;
        *(_WORD *)(v21 + 8) = 2;
        *(_QWORD *)v21 = &off_24D5DBE60;
        v23 = v110;
        if ((unint64_t)v110 >= *((_QWORD *)&v110 + 1))
        {
          v41 = (uint64_t)(v110 - (unint64_t)__p[1]) >> 3;
          if ((unint64_t)(v41 + 1) >> 61)
            std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
          v42 = (uint64_t)(*((_QWORD *)&v110 + 1) - (unint64_t)__p[1]) >> 2;
          if (v42 <= v41 + 1)
            v42 = v41 + 1;
          if (*((_QWORD *)&v110 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
            v43 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v43 = v42;
          if (v43)
            v44 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v110 + 8, v43);
          else
            v44 = 0;
          v90 = (uint64_t *)&v44[8 * v41];
          v91 = &v44[8 * v43];
          *v90 = v22;
          v24 = v90 + 1;
          v93 = (char *)__p[1];
          v92 = (char *)v110;
          if ((void *)v110 != __p[1])
          {
            do
            {
              v94 = *((_QWORD *)v92 - 1);
              v92 -= 8;
              *--v90 = v94;
            }
            while (v92 != v93);
            v92 = (char *)__p[1];
          }
          __p[1] = v90;
          *(_QWORD *)&v110 = v24;
          *((_QWORD *)&v110 + 1) = v91;
          if (v92)
            operator delete(v92);
        }
        else
        {
          *(_QWORD *)v110 = v21;
          v24 = (_QWORD *)(v23 + 8);
        }
        v20 = (_BYTE *)(v22 + 9);
        *(_QWORD *)&v110 = v24;
        goto LABEL_190;
      }
      if (!v19)
        __cxa_bad_cast();
      v20 = v19 + 9;
LABEL_190:
      if (*(_BYTE *)(v3 + 296))
      {
        v95 = subscriber::SimCommandDriver::allowSimRefresh((subscriber::SimCommandDriver *)v3);
        *v20 = v95;
        if ((v95 & 1) != 0)
          goto LABEL_196;
      }
      else
      {
        *v20 = 0;
      }
      v96 = *v106;
      if (os_log_type_enabled(*v106, OS_LOG_TYPE_DEFAULT))
      {
        v97 = *(unsigned __int8 *)(v3 + 296);
        v98 = subscriber::SimCommandDriver::allowSimRefresh((subscriber::SimCommandDriver *)v3);
        *(_DWORD *)buf = 67109376;
        *(_DWORD *)&buf[4] = v97;
        *(_WORD *)&buf[8] = 1024;
        *(_DWORD *)&buf[10] = v98;
        _os_log_impl(&dword_216897000, v96, OS_LOG_TYPE_DEFAULT, "#I Preventing Sim refresh, should process sim updates, %d, celluar IMS call %d", buf, 0xEu);
      }
LABEL_196:
      *(_QWORD *)buf = v3 + 128;
      *(_QWORD *)&buf[8] = QMIServiceMsg::create();
      v125 = 0;
      *(_QWORD *)&aBlock = 0;
      *(_DWORD *)&buf[16] = 240000;
      if (*(_QWORD *)&buf[8])
      {
        qmi::Client::send();
        if ((_QWORD)aBlock)
          _Block_release((const void *)aBlock);
      }
      qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
      return;
    case 1u:
      v15 = a2[8];
      v16 = v15 < 0x11;
      v122 = 0;
      v120 = 0u;
      v121 = 0u;
      v117 = 0;
      v118 = 0;
      v119 = 0;
      std::vector<uim::tlv::FileId>::__init_with_size[abi:ne180100]<uim::tlv::FileId*,uim::tlv::FileId*>(&v117, *((_QWORD *)a2 + 5), *((_QWORD *)a2 + 6), (uint64_t)(*((_QWORD *)a2 + 6) - *((_QWORD *)a2 + 5)) >> 5);
      v17 = v16 & (0x10030u >> v15);
      switch(*((_DWORD *)a2 + 1))
      {
        case 0:
          goto LABEL_180;
        case 1:
        case 2:
        case 4:
          v18 = v16 & (0x10030u >> v15);
          goto LABEL_74;
        case 3:
          v18 = 1;
          LOBYTE(v17) = 1;
          goto LABEL_74;
        case 5:
          v18 = 0;
          goto LABEL_74;
        case 6:
          v18 = 1;
          goto LABEL_74;
        default:
          v18 = 0;
          LOBYTE(v17) = 0;
LABEL_74:
          v45 = dispatch_group_create();
          v46 = v45;
          v47 = a2[8];
          v116 = v45;
          if (v45)
          {
            dispatch_retain(v45);
            dispatch_group_enter(v46);
          }
          object = v46;
          subscriber::EURSimCommandDriver::setRefreshGroupForSession(v3, v47, &v116);
          if (v46)
          {
            dispatch_group_leave(v46);
            dispatch_release(v46);
          }
          v48 = *((int *)a2 + 1);
          if (v48 > 6)
            v49 = 0;
          else
            v49 = dword_216AB13F4[v48];
          v50 = a2[8];
          v51 = 1;
          if (v50 <= 0x10)
          {
            if (((1 << v50) & 0x10030) != 0)
            {
              v51 = 3;
            }
            else if (((1 << v50) & 0xA) != 0)
            {
              v51 = 2;
            }
          }
          v101 = a2;
          v104 = (_QWORD *)v3;
          v113 = 0;
          v114 = 0;
          v115 = 0;
          std::vector<uim::tlv::FileId>::__init_with_size[abi:ne180100]<uim::tlv::FileId*,uim::tlv::FileId*>(&v113, v117, v118, (v118 - v117) >> 5);
          v52 = 1;
          v53 = v113;
          v54 = v114;
          if (v50 <= 0x10)
          {
            if (((1 << v50) & 0x10030) != 0)
            {
              v52 = 3;
            }
            else if (((1 << v50) & 0xA) != 0)
            {
              v52 = 2;
            }
          }
          v102 = v51;
          v103 = v49;
          v99 = v18;
          v100 = v17;
          if (v113 == v114)
          {
            v55 = 0;
            v58 = 0;
            goto LABEL_122;
          }
          v55 = 0;
          v56 = 0;
          v57 = 0;
          v58 = 0;
          break;
      }
      do
      {
        memset(buf, 0, sizeof(buf));
        *(_WORD *)buf = *(_WORD *)v53;
        v125 = 0;
        std::vector<unsigned short>::__init_with_size[abi:ne180100]<unsigned short *,unsigned short *>(&buf[8], *(const void **)(v53 + 8), *(_QWORD *)(v53 + 16), (uint64_t)(*(_QWORD *)(v53 + 16) - *(_QWORD *)(v53 + 8)) >> 1);
        if (v52 == 1)
        {
          SimFilePath = subscriber::sGetSimFilePath((uint64_t)v106, 2, (uint64_t)buf);
          if (SimFilePath != 40)
            goto LABEL_100;
          v59 = 1;
        }
        else if (v52 == 2)
        {
          v59 = 3;
        }
        else
        {
          v59 = 5;
        }
        SimFilePath = subscriber::sGetSimFilePath((uint64_t)v106, v59, (uint64_t)buf);
LABEL_100:
        if ((unint64_t)v58 >= v57)
        {
          v61 = (v58 - v56) >> 2;
          v62 = v61 + 1;
          if ((unint64_t)(v61 + 1) >> 62)
            std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
          if ((uint64_t)(v57 - (_QWORD)v56) >> 1 > v62)
            v62 = (uint64_t)(v57 - (_QWORD)v56) >> 1;
          if (v57 - (unint64_t)v56 >= 0x7FFFFFFFFFFFFFFCLL)
            v63 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v63 = v62;
          if (v63)
            v63 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<subscriber::HardwareSimSlot>>(v63);
          else
            v64 = 0;
          v55 = (char *)(v63 + 4 * v61);
          *(_DWORD *)v55 = SimFilePath;
          v65 = v55 + 4;
          while (v58 != v56)
          {
            v66 = *((_DWORD *)v58 - 1);
            v58 -= 4;
            *((_DWORD *)v55 - 1) = v66;
            v55 -= 4;
          }
          v57 = v63 + 4 * v64;
          if (v56)
            operator delete(v56);
          v56 = v55;
          v58 = v65;
        }
        else
        {
          *(_DWORD *)v58 = SimFilePath;
          v58 += 4;
        }
        if (*(_QWORD *)&buf[8])
        {
          *(_QWORD *)&buf[16] = *(_QWORD *)&buf[8];
          operator delete(*(void **)&buf[8]);
        }
        v53 += 32;
      }
      while (v53 != v54);
LABEL_122:
      *(_QWORD *)buf = &v113;
      std::vector<at::tlv::CommandCallback>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
      v67 = v104[11];
      v131 = (uint64_t (**)())__PAIR64__(v102, v103);
      v132 = 1;
      v134 = 0;
      v135 = 0;
      v133 = 0;
      v68 = v58 - v55;
      if (v58 != v55)
      {
        if (v68 < 0)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v69 = (uint64_t (***)())std::__allocate_at_least[abi:ne180100]<std::allocator<subscriber::HardwareSimSlot>>(v68 >> 2);
        v133 = v69;
        v134 = v69;
        v135 = (char *)v69 + 4 * v70;
        memmove(v69, v55, v58 - v55);
        v134 = (uint64_t (***)())((char *)v69 + 4 * (v68 >> 2));
      }
      if (v99)
        v71 = 257;
      else
        v71 = 1;
      v136 = v71;
      __p[0] = v104;
      __p[1] = object;
      if (object)
      {
        dispatch_retain(object);
        if (__p[1])
          dispatch_group_enter((dispatch_group_t)__p[1]);
      }
      LOBYTE(v110) = v100;
      BYTE8(v110) = v101[8];
      v111[1] = 0;
      v112 = 0;
      v111[0] = 0;
      std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(v111, *((const void **)v101 + 2), *((_QWORD *)v101 + 3), *((_QWORD *)v101 + 3) - *((_QWORD *)v101 + 2));
      v130 = 0;
      v72 = (char *)operator new(0x40uLL);
      *(_QWORD *)v72 = &off_24D5DBA48;
      *(_OWORD *)(v72 + 8) = *(_OWORD *)__p;
      __p[1] = 0;
      v72[24] = v110;
      v72[32] = BYTE8(v110);
      *(_OWORD *)(v72 + 40) = *(_OWORD *)v111;
      *((_QWORD *)v72 + 7) = v112;
      v111[1] = 0;
      v112 = 0;
      v111[0] = 0;
      v130 = v72;
      (*(void (**)(uint64_t, __int128 *, uint64_t (***)(), _BYTE *))(*(_QWORD *)v67 + 80))(v67, &v120, &v131, v129);
      v73 = v130;
      if (v130 == v129)
      {
        v74 = 4;
        v73 = v129;
LABEL_135:
        (*(void (**)(void))(*v73 + 8 * v74))();
      }
      else if (v130)
      {
        v74 = 5;
        goto LABEL_135;
      }
      if (v111[0])
      {
        v111[1] = v111[0];
        operator delete(v111[0]);
      }
      if (__p[1])
      {
        dispatch_group_leave((dispatch_group_t)__p[1]);
        if (__p[1])
          dispatch_release((dispatch_object_t)__p[1]);
      }
      if (v133)
      {
        v134 = v133;
        operator delete(v133);
      }
      v75 = MEMORY[0x24BDAC760];
      if (v104[21])
      {
        v76 = *v106;
        if (os_log_type_enabled(*v106, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_216897000, v76, OS_LOG_TYPE_DEFAULT, "#I Multiple refreshes in progress; chaining groups together",
            buf,
            2u);
        }
        if (object)
        {
          dispatch_retain(object);
          dispatch_group_enter(object);
        }
        v77 = v104[21];
        v78 = v104[3];
        block[0] = v75;
        block[1] = 1174405120;
        block[2] = ___ZN10subscriber19EURSimCommandDriver18handleRefreshStartERKN3uim3tlv7RefreshE_block_invoke;
        block[3] = &__block_descriptor_tmp_36_6;
        group = object;
        if (object)
        {
          dispatch_retain(object);
          dispatch_group_enter(group);
        }
        dispatch_group_notify(v77, v78, block);
        if (group)
        {
          dispatch_group_leave(group);
          if (group)
            dispatch_release(group);
        }
        if (object)
        {
          dispatch_group_leave(object);
          dispatch_release(object);
          goto LABEL_156;
        }
LABEL_157:
        v79 = v104[21];
        v104[21] = object;
        if (v79)
          dispatch_release(v79);
      }
      else
      {
        if (object)
        {
LABEL_156:
          dispatch_retain(object);
          goto LABEL_157;
        }
        v104[21] = 0;
      }
      v80 = (std::__shared_weak_count *)v104[2];
      if (!v80 || (v81 = v104[1], (v82 = std::__shared_weak_count::lock(v80)) == 0))
        std::__throw_bad_weak_ptr[abi:ne180100]();
      v83 = v82;
      p_shared_weak_owners = (unint64_t *)&v82->__shared_weak_owners_;
      do
        v85 = __ldxr(p_shared_weak_owners);
      while (__stxr(v85 + 1, p_shared_weak_owners));
      p_shared_owners = (unint64_t *)&v82->__shared_owners_;
      do
        v87 = __ldaxr(p_shared_owners);
      while (__stlxr(v87 - 1, p_shared_owners));
      if (!v87)
      {
        ((void (*)(std::__shared_weak_count *))v82->__on_zero_shared)(v82);
        std::__shared_weak_count::__release_weak(v83);
      }
      v88 = v104[3];
      *(_QWORD *)buf = v75;
      *(_QWORD *)&buf[8] = 1174405120;
      *(_QWORD *)&buf[16] = ___ZN10subscriber19EURSimCommandDriver18handleRefreshStartERKN3uim3tlv7RefreshE_block_invoke_37;
      v125 = (const char *)&__block_descriptor_tmp_38_7;
      *(_QWORD *)&aBlock = v104;
      *((_QWORD *)&aBlock + 1) = v81;
      v127 = v83;
      do
        v89 = __ldxr(p_shared_weak_owners);
      while (__stxr(v89 + 1, p_shared_weak_owners));
      v128 = object;
      if (object)
        dispatch_retain(object);
      dispatch_group_notify(object, v88, buf);
      if (v128)
        dispatch_release(v128);
      if (v127)
        std::__shared_weak_count::__release_weak(v127);
      std::__shared_weak_count::__release_weak(v83);
      if (v55)
        operator delete(v55);
      if (object)
        dispatch_release(object);
LABEL_180:
      v123 = (void **)&v117;
      std::vector<at::tlv::CommandCallback>::__destroy_vector::operator()[abi:ne180100](&v123);
      v40 = (void *)v121;
      if ((_QWORD)v121)
      {
        *((_QWORD *)&v121 + 1) = v121;
        goto LABEL_182;
      }
      return;
    case 2u:
      v11 = *((int *)a2 + 1);
      if (v11 > 6)
        v12 = 0;
      else
        v12 = dword_216AB13F4[v11];
      v25 = a2[8];
      if (((1 << v25) & 0xA) != 0)
        v26 = 2;
      else
        v26 = 1;
      if (((1 << v25) & 0x10030) != 0)
        v27 = 3;
      else
        v27 = v26;
      if (v25 <= 0x10)
        v28 = v27;
      else
        v28 = 1;
      v111[0] = 0;
      *(_OWORD *)__p = 0u;
      v110 = 0u;
      v29 = *(_QWORD *)(v3 + 88);
      *(_DWORD *)buf = v12;
      *(_DWORD *)&buf[4] = v28;
      *(_DWORD *)&buf[8] = 2;
      v125 = 0;
      *(_QWORD *)&aBlock = 0;
      *(_QWORD *)&buf[16] = 0;
      WORD4(aBlock) = 256;
      v131 = &off_24D5DBD48;
      v134 = &v131;
      (*(void (**)(uint64_t, void **, uint8_t *, uint64_t (***)()))(*(_QWORD *)v29 + 80))(v29, __p, buf, &v131);
      v30 = v134;
      if (v134 == &v131)
      {
        v31 = 4;
        v30 = &v131;
      }
      else
      {
        if (!v134)
          goto LABEL_53;
        v31 = 5;
      }
      (*v30)[v31]();
LABEL_53:
      if (*(_QWORD *)&buf[16])
      {
        v125 = *(const char **)&buf[16];
        operator delete(*(void **)&buf[16]);
      }
      goto LABEL_60;
    case 3u:
      v13 = *((int *)a2 + 1);
      if (v13 > 6)
        v14 = 0;
      else
        v14 = dword_216AB13F4[v13];
      v32 = a2[8];
      if (((1 << v32) & 0xA) != 0)
        v33 = 2;
      else
        v33 = 1;
      if (((1 << v32) & 0x10030) != 0)
        v34 = 3;
      else
        v34 = v33;
      if (v32 <= 0x10)
        v35 = v34;
      else
        v35 = 1;
      v111[0] = 0;
      *(_OWORD *)__p = 0u;
      v110 = 0u;
      v36 = *(_QWORD *)(v3 + 88);
      *(_DWORD *)buf = v14;
      *(_DWORD *)&buf[4] = v35;
      *(_DWORD *)&buf[8] = 3;
      v125 = 0;
      *(_QWORD *)&aBlock = 0;
      *(_QWORD *)&buf[16] = 0;
      WORD4(aBlock) = 0;
      v131 = &off_24D5DBDC8;
      v134 = &v131;
      (*(void (**)(uint64_t, void **, uint8_t *, uint64_t (***)()))(*(_QWORD *)v36 + 80))(v36, __p, buf, &v131);
      v37 = v134;
      if (v134 == &v131)
      {
        v38 = 4;
        v37 = &v131;
      }
      else
      {
        if (!v134)
          goto LABEL_58;
        v38 = 5;
      }
      (*v37)[v38]();
LABEL_58:
      if (*(_QWORD *)&buf[16])
      {
        v125 = *(const char **)&buf[16];
        operator delete(*(void **)&buf[16]);
      }
LABEL_60:
      v39 = a2[8];
      *(_QWORD *)&v120 = 0;
      subscriber::EURSimCommandDriver::setRefreshGroupForSession(v3, v39, (dispatch_object_t *)&v120);
      v40 = (void *)v110;
      if ((_QWORD)v110)
      {
        *((_QWORD *)&v110 + 1) = v110;
LABEL_182:
        operator delete(v40);
      }
      return;
    default:
      return;
  }
}

void sub_2169D7DB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, dispatch_object_t object, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,dispatch_group_t group,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,uint64_t a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,void *a37,uint64_t a38,uint64_t a39,uint64_t a40,char *a41,void *a42,void *a43,uint64_t a44)
{
  _QWORD *v44;
  void *v45;
  uint64_t v46;
  _QWORD *v48;
  uint64_t v49;
  void *v50;

  v48 = *(_QWORD **)(v46 - 160);
  if (v48 == v44)
  {
    v49 = 4;
    v48 = (_QWORD *)(v46 - 184);
  }
  else
  {
    if (!v48)
      goto LABEL_6;
    v49 = 5;
  }
  (*(void (**)(void))(*v48 + 8 * v49))();
LABEL_6:
  if (__p)
    operator delete(__p);
  if (group)
  {
    dispatch_group_leave(group);
    dispatch_release(group);
  }
  v50 = *(void **)(v46 - 136);
  if (v50)
  {
    *(_QWORD *)(v46 - 128) = v50;
    operator delete(v50);
  }
  if (v45)
    operator delete(v45);
  if (object)
    dispatch_release(object);
  a41 = &a32;
  std::vector<at::tlv::CommandCallback>::__destroy_vector::operator()[abi:ne180100]((void ***)&a41);
  if (a37)
  {
    a38 = (uint64_t)a37;
    operator delete(a37);
  }
  _Unwind_Resume(a1);
}

uint64_t `anonymous namespace'::sSimCardInfoFromSessionType()
{
  return subscriber::SimCardInfo::SimCardInfo();
}

void subscriber::EURSimCommandDriver::setRefreshGroupForSession(uint64_t a1, unsigned int a2, dispatch_object_t *a3)
{
  char *v5;
  uint64_t **v6;
  char *v8;
  unsigned int v9;
  char *v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  NSObject *v14;
  _BOOL4 v15;
  const char *v16;
  uint64_t **v17;
  unsigned int v18;
  BOOL v19;
  char **v20;
  NSObject *v21;
  NSObject *v22;
  NSObject *v23;
  NSObject *v24;
  uint64_t *v25;
  uint64_t *v26;
  uint64_t **v27;
  BOOL v28;
  uint64_t *v29;
  int v30;
  const char *v31;
  uint64_t v32;

  v32 = *MEMORY[0x24BDAC8D0];
  v6 = (uint64_t **)(a1 + 184);
  v5 = *(char **)(a1 + 184);
  if (*a3)
  {
    v8 = (char *)(a1 + 184);
    if (v5)
    {
      while (1)
      {
        while (1)
        {
          v8 = v5;
          v9 = v5[32];
          if (v9 <= a2)
            break;
          v5 = *(char **)v8;
          v6 = (uint64_t **)v8;
          if (!*(_QWORD *)v8)
            goto LABEL_9;
        }
        if (v9 >= a2)
          break;
        v5 = (char *)*((_QWORD *)v8 + 1);
        if (!v5)
        {
          v6 = (uint64_t **)(v8 + 8);
          goto LABEL_9;
        }
      }
    }
    else
    {
LABEL_9:
      v10 = v8;
      v8 = (char *)operator new(0x30uLL);
      v8[32] = a2;
      *((_QWORD *)v8 + 5) = 0;
      *(_QWORD *)v8 = 0;
      *((_QWORD *)v8 + 1) = 0;
      *((_QWORD *)v8 + 2) = v10;
      *v6 = (uint64_t *)v8;
      v11 = **(_QWORD **)(a1 + 176);
      v12 = (uint64_t *)v8;
      if (v11)
      {
        *(_QWORD *)(a1 + 176) = v11;
        v12 = *v6;
      }
      std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 184), v12);
      ++*(_QWORD *)(a1 + 192);
    }
    v13 = *((_QWORD *)v8 + 5);
    v14 = *(NSObject **)(a1 + 40);
    v15 = os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT);
    if (v13)
    {
      if (v15)
      {
        v30 = 136315138;
        v31 = uim::asString(a2);
        v16 = "#E Session start: replacing start for session type %s; it was not expected to overlap!";
LABEL_30:
        _os_log_impl(&dword_216897000, v14, OS_LOG_TYPE_DEFAULT, v16, (uint8_t *)&v30, 0xCu);
      }
    }
    else if (v15)
    {
      v30 = 136315138;
      v31 = uim::asString(a2);
      v16 = "#I Session start: marking start for session type %s";
      goto LABEL_30;
    }
    v22 = *a3;
    if (*a3)
    {
      dispatch_retain(*a3);
      dispatch_group_enter(v22);
    }
    v23 = *((_QWORD *)v8 + 5);
    *((_QWORD *)v8 + 5) = v22;
    if (v23)
    {
      dispatch_group_leave(v23);
      dispatch_release(v23);
    }
    return;
  }
  if (!v5)
    goto LABEL_26;
  v17 = (uint64_t **)(a1 + 184);
  do
  {
    v18 = v5[32];
    v19 = v18 >= a2;
    if (v18 >= a2)
      v20 = (char **)v5;
    else
      v20 = (char **)(v5 + 8);
    if (v19)
      v17 = (uint64_t **)v5;
    v5 = *v20;
  }
  while (*v20);
  if (v17 != v6 && *((unsigned __int8 *)v17 + 32) <= a2)
  {
    v24 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      v30 = 136315138;
      v31 = uim::asString(a2);
      _os_log_impl(&dword_216897000, v24, OS_LOG_TYPE_DEFAULT, "#I Session end: marking end for session type %s", (uint8_t *)&v30, 0xCu);
    }
    v25 = v17[1];
    if (v25)
    {
      do
      {
        v26 = v25;
        v25 = (uint64_t *)*v25;
      }
      while (v25);
    }
    else
    {
      v27 = v17;
      do
      {
        v26 = v27[2];
        v28 = *v26 == (_QWORD)v27;
        v27 = (uint64_t **)v26;
      }
      while (!v28);
    }
    if (*(uint64_t ***)(a1 + 176) == v17)
      *(_QWORD *)(a1 + 176) = v26;
    v29 = *(uint64_t **)(a1 + 184);
    --*(_QWORD *)(a1 + 192);
    std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(v29, (uint64_t *)v17);
    std::__destroy_at[abi:ne180100]<std::pair<uim::SessionType const,dispatch::group_session>,0>((uint64_t)(v17 + 4));
    operator delete(v17);
  }
  else
  {
LABEL_26:
    v21 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      v30 = 136315138;
      v31 = uim::asString(a2);
      _os_log_impl(&dword_216897000, v21, OS_LOG_TYPE_DEFAULT, "#E Session end: did not find a prior start for %s; this was not expected.",
        (uint8_t *)&v30,
        0xCu);
    }
  }
}

void __copy_helper_block_e8_32c30_ZTSN8dispatch13group_sessionE(uint64_t a1, uint64_t a2)
{
  NSObject *v3;
  NSObject *v4;

  v3 = *(NSObject **)(a2 + 32);
  *(_QWORD *)(a1 + 32) = v3;
  if (v3)
  {
    dispatch_retain(v3);
    v4 = *(NSObject **)(a1 + 32);
    if (v4)
      dispatch_group_enter(v4);
  }
}

void __destroy_helper_block_e8_32c30_ZTSN8dispatch13group_sessionE(uint64_t a1)
{
  NSObject *v2;
  NSObject *v3;

  v2 = *(NSObject **)(a1 + 32);
  if (v2)
  {
    dispatch_group_leave(v2);
    v3 = *(NSObject **)(a1 + 32);
    if (v3)
      dispatch_release(v3);
  }
}

void ___ZN10subscriber19EURSimCommandDriver18handleRefreshStartERKN3uim3tlv7RefreshE_block_invoke_37(_QWORD *a1)
{
  std::__shared_weak_count *v2;
  subscriber::EURSimCommandDriver *v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  NSObject *v6;
  NSObject *v7;
  NSObject *v8;
  _BOOL4 v9;
  const char *v10;
  NSObject *v11;
  NSObject *v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  uint8_t v15[16];
  std::__shared_weak_count *v17;

  v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    v3 = (subscriber::EURSimCommandDriver *)a1[4];
    v4 = std::__shared_weak_count::lock(v2);
    v17 = v4;
    if (v4)
    {
      v5 = v4;
      if (!a1[5])
        goto LABEL_17;
      v6 = *((_QWORD *)v3 + 21);
      if (!v6)
      {
        v12 = *((_QWORD *)v3 + 5);
        if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
          goto LABEL_17;
        *(_WORD *)v15 = 0;
        v10 = "#I Prior refresh group no longer active (is now null); returning";
        v11 = v12;
        goto LABEL_10;
      }
      v7 = a1[7];
      v8 = *((_QWORD *)v3 + 5);
      v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
      if (v7 != v6)
      {
        if (!v9)
          goto LABEL_17;
        *(_WORD *)v15 = 0;
        v10 = "#I Prior refresh group finished, but a new one has taken its place; returning now";
        v11 = v8;
LABEL_10:
        _os_log_impl(&dword_216897000, v11, OS_LOG_TYPE_DEFAULT, v10, v15, 2u);
        goto LABEL_17;
      }
      if (v9)
      {
        *(_WORD *)v15 = 0;
        _os_log_impl(&dword_216897000, v8, OS_LOG_TYPE_DEFAULT, "#I Refresh groups complete; querying SIM state once for free",
          v15,
          2u);
        v6 = *((_QWORD *)v3 + 21);
        *((_QWORD *)v3 + 21) = 0;
        if (!v6)
          goto LABEL_16;
      }
      else
      {
        *((_QWORD *)v3 + 21) = 0;
      }
      dispatch_release(v6);
LABEL_16:
      subscriber::EURSimCommandDriver::queryStatus(v3);
LABEL_17:
      p_shared_owners = (unint64_t *)&v5->__shared_owners_;
      do
        v14 = __ldaxr(p_shared_owners);
      while (__stlxr(v14 - 1, p_shared_owners));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
    }
  }
}

void sub_2169D84FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void __copy_helper_block_e8_40c55_ZTSNSt3__18weak_ptrIN10subscriber16SimCommandDriverEEE56c21_ZTSN8dispatch5groupE(_QWORD *a1, _QWORD *a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;
  NSObject *v5;

  v2 = a2[6];
  a1[5] = a2[5];
  a1[6] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 16);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  v5 = a2[7];
  a1[7] = v5;
  if (v5)
    dispatch_retain(v5);
}

void __destroy_helper_block_e8_40c55_ZTSNSt3__18weak_ptrIN10subscriber16SimCommandDriverEEE56c21_ZTSN8dispatch5groupE(uint64_t a1)
{
  NSObject *v2;
  std::__shared_weak_count *v3;

  v2 = *(NSObject **)(a1 + 56);
  if (v2)
    dispatch_release(v2);
  v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (v3)
    std::__shared_weak_count::__release_weak(v3);
}

void subscriber::EURSimCommandDriver::readTransparentFile(uint64_t a1, char **a2, unsigned __int16 *a3, uint64_t a4)
{
  os_log_t *v8;
  NSObject *v9;
  uint64_t v10;
  int v11;
  NSObject *v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *p_shared_owners;
  unint64_t v18;
  char *v19;
  unsigned int *v20;
  char *v21;
  const void **v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  char *v30;
  uint64_t *v31;
  char *v32;
  char *v33;
  char *v34;
  uint64_t v35;
  uint64_t v36;
  _QWORD *v37;
  void *v38;
  uint64_t v39;
  uint64_t v40;
  void *aBlock;
  void *__p[2];
  __int128 v43;
  uint64_t v44;
  std::__shared_weak_count *v45;
  void *v46[2];
  __int128 v47;
  _QWORD v48[5];
  _BYTE v49[24];
  _BYTE *v50;
  _BYTE buf[24];
  void *v52;
  _QWORD *v53;
  uint64_t v54;

  v54 = *MEMORY[0x24BDAC8D0];
  v8 = (os_log_t *)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 48) + 16))(*(_QWORD *)(a1 + 48), *(unsigned int *)a2);
  v9 = *v8;
  if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
  {
    v10 = subscriber::asString();
    v11 = *a3;
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = v10;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v11;
    _os_log_impl(&dword_216897000, v9, OS_LOG_TYPE_DEFAULT, "#I Reading Transparent %s file 0x%04x", buf, 0x12u);
  }
  *(_OWORD *)v46 = 0u;
  v47 = 0u;
  subscriber::sConvertFileId((char *)v46, (uint64_t)a3);
  if (!subscriber::sIsFileIdInvalid((uint64_t)v46))
  {
    *(_OWORD *)__p = 0u;
    v43 = 0u;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
    v19 = qmi::MutableMessageBase::getTLV<uim::tlv::SessionInfo>(__p);
    v20 = (unsigned int *)(v19 + 8);
    if (v20 != (unsigned int *)(a2 + 2))
      std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(v20, a2[2], a2[3], a2[3] - a2[2]);
    v21 = qmi::MutableMessageBase::getTLV<uim::tlv::FileId>(__p);
    *(_WORD *)v21 = v46[0];
    if (v21 != (char *)v46)
      std::vector<unsigned short>::__assign_with_size[abi:ne180100]<unsigned short *,unsigned short *>(v21 + 8, (char *)v46[1], v47, (uint64_t)(v47 - (unint64_t)v46[1]) >> 1);
    v22 = (const void **)__p[1];
    if (__p[1] != (void *)v43)
    {
      while (*((_BYTE *)*v22 + 8) != 3)
      {
        if (++v22 == (const void **)v43)
          goto LABEL_23;
      }
    }
    if (v22 == (const void **)v43)
    {
LABEL_23:
      v23 = operator new();
      v24 = v23;
      *(_BYTE *)(v23 + 8) = 3;
      *(_QWORD *)v23 = &off_24D5DBF00;
      *(_DWORD *)(v23 + 10) = 0;
      v25 = v43;
      if ((unint64_t)v43 >= *((_QWORD *)&v43 + 1))
      {
        v27 = (uint64_t)(v43 - (unint64_t)__p[1]) >> 3;
        if ((unint64_t)(v27 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v28 = (uint64_t)(*((_QWORD *)&v43 + 1) - (unint64_t)__p[1]) >> 2;
        if (v28 <= v27 + 1)
          v28 = v27 + 1;
        if (*((_QWORD *)&v43 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v29 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v29 = v28;
        if (v29)
          v30 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v43 + 8, v29);
        else
          v30 = 0;
        v31 = (uint64_t *)&v30[8 * v27];
        v32 = &v30[8 * v29];
        *v31 = v24;
        v26 = v31 + 1;
        v34 = (char *)__p[1];
        v33 = (char *)v43;
        if ((void *)v43 != __p[1])
        {
          do
          {
            v35 = *((_QWORD *)v33 - 1);
            v33 -= 8;
            *--v31 = v35;
          }
          while (v33 != v34);
          v33 = (char *)__p[1];
        }
        __p[1] = v31;
        *(_QWORD *)&v43 = v26;
        *((_QWORD *)&v43 + 1) = v32;
        if (v33)
          operator delete(v33);
      }
      else
      {
        *(_QWORD *)v43 = v23;
        v26 = (_QWORD *)(v25 + 8);
      }
      *(_QWORD *)&v43 = v26;
    }
    {
      __cxa_bad_cast();
    }
    v40 = QMIServiceMsg::create();
    v36 = MEMORY[0x24BDAC760];
    v48[0] = MEMORY[0x24BDAC760];
    v48[1] = 1174405120;
    v48[2] = ___ZN10subscriber19EURSimCommandDriver19readTransparentFileERKNS_11SimCardInfoERKNS_6FileIdENSt3__18functionIFvNS7_10shared_ptrINS7_6vectorIhNS7_9allocatorIhEEEEEEEEE_block_invoke;
    v48[3] = &__block_descriptor_tmp_41_9;
    v48[4] = a1;
    v37 = v49;
    std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100]((uint64_t)v49, a4);
    *(_QWORD *)buf = v36;
    *(_QWORD *)&buf[8] = 0x40000000;
    *(_QWORD *)&buf[16] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3uim15ReadTransparent8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
    v52 = &unk_24D5DBF80;
    v53 = v48;
    v38 = _Block_copy(buf);
    aBlock = v38;
    if (v40)
    {
      qmi::Client::send();
      v38 = aBlock;
    }
    if (v38)
      _Block_release(v38);
    if (v50 == v49)
    {
      v39 = 4;
    }
    else
    {
      if (!v50)
      {
LABEL_49:
        qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
        goto LABEL_50;
      }
      v39 = 5;
      v37 = v50;
    }
    (*(void (**)(_QWORD *))(*v37 + 8 * v39))(v37);
    goto LABEL_49;
  }
  v12 = *v8;
  if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
  {
    v13 = *a3;
    v14 = subscriber::asString();
    *(_DWORD *)buf = 67109378;
    *(_DWORD *)&buf[4] = v13;
    *(_WORD *)&buf[8] = 2080;
    *(_QWORD *)&buf[10] = v14;
    _os_log_impl(&dword_216897000, v12, OS_LOG_TYPE_DEFAULT, "#I No path and file id known, sending file data error for file 0x%04x under SIM %s", buf, 0x12u);
  }
  v44 = 0;
  v45 = 0;
  v15 = *(_QWORD *)(a4 + 24);
  if (!v15)
    std::__throw_bad_function_call[abi:ne180100]();
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v15 + 48))(v15, &v44);
  v16 = v45;
  if (v45)
  {
    p_shared_owners = (unint64_t *)&v45->__shared_owners_;
    do
      v18 = __ldaxr(p_shared_owners);
    while (__stlxr(v18 - 1, p_shared_owners));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
LABEL_50:
  if (v46[1])
  {
    *(void **)&v47 = v46[1];
    operator delete(v46[1]);
  }
}

void sub_2169D8A1C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

char *subscriber::sConvertFileId(char *result, uint64_t a2)
{
  *(_OWORD *)result = 0u;
  *((_OWORD *)result + 1) = 0u;
  *(_WORD *)result = *(_WORD *)a2;
  if (result != (char *)a2)
    return std::vector<unsigned short>::__assign_with_size[abi:ne180100]<unsigned short *,unsigned short *>(result + 8, *(char **)(a2 + 8), *(_QWORD *)(a2 + 16), (uint64_t)(*(_QWORD *)(a2 + 16) - *(_QWORD *)(a2 + 8)) >> 1);
  return result;
}

{
  *(_OWORD *)result = 0u;
  *((_OWORD *)result + 1) = 0u;
  *(_WORD *)result = *(_WORD *)a2;
  if (result != (char *)a2)
    return std::vector<unsigned short>::__assign_with_size[abi:ne180100]<unsigned short *,unsigned short *>(result + 8, *(char **)(a2 + 8), *(_QWORD *)(a2 + 16), (uint64_t)(*(_QWORD *)(a2 + 16) - *(_QWORD *)(a2 + 8)) >> 1);
  return result;
}

void sub_2169D8B20(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void *v4;

  v4 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 16) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN10subscriber19EURSimCommandDriver19readTransparentFileERKNS_11SimCardInfoERKNS_6FileIdENSt3__18functionIFvNS7_10shared_ptrINS7_6vectorIhNS7_9allocatorIhEEEEEEEEE_block_invoke(uint64_t a1, qmi::MessageBase *this)
{
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  uint64_t TlvValue;
  int v9;
  uint64_t v10;
  int v11;
  unsigned __int8 v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  unint64_t v17;
  void *v18;
  uint64_t v19;
  std::__shared_weak_count *v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  char v24;
  uint64_t v25;
  unint64_t *v26;
  unint64_t *v27;
  uint64_t v28;
  uint64_t v29;
  std::__shared_weak_count *v30;
  uint64_t v31;
  std::__shared_weak_count *v32;
  void *__p;
  void *v34;
  uint64_t v35;
  unint64_t v36;
  _QWORD *v37;
  std::__shared_weak_count *v38;
  unint64_t v39[3];
  unint64_t *v40;
  uint64_t v41;

  v41 = *MEMORY[0x24BDAC8D0];
  if (*((_DWORD *)this + 1))
  {
    v31 = 0;
    v32 = 0;
    v3 = *(_QWORD *)(a1 + 64);
    if (!v3)
      std::__throw_bad_function_call[abi:ne180100]();
    (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v3 + 48))(v3, &v31);
    v4 = v32;
    if (v32)
    {
      p_shared_owners = (unint64_t *)&v32->__shared_owners_;
      do
        v6 = __ldaxr(p_shared_owners);
      while (__stlxr(v6 - 1, p_shared_owners));
LABEL_28:
      if (!v6)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
      return;
    }
    return;
  }
  TlvValue = qmi::MessageBase::findTlvValue(this);
  if (!TlvValue)
  {
LABEL_23:
    __TUAssertTrigger();
    goto LABEL_24;
  }
  v10 = TlvValue;
  v11 = v9;
  v39[0] = TlvValue;
  v12 = tlv::parseV<uim::tlv::CardResult>(v39, v9);
  if (!v39[0])
  {
    if ((((uint64_t (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)this, 16, v10, v11) & 1) != 0)goto LABEL_24;
    goto LABEL_23;
  }
  if (subscriber::isCardResultSW1Good((subscriber *)v12))
  {
    std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100]((uint64_t)v39, a1 + 40);
    v13 = qmi::MessageBase::findTlvValue(this);
    v15 = v13;
    if (v13)
    {
      v16 = v14;
      v35 = 0;
      v36 = v13;
      __p = 0;
      v34 = 0;
      tlv::parseV<uim::tlv::ReadResult>(&v36, v14, &__p);
      v17 = v36;
      if (v36)
      {
        v18 = __p;
        v19 = (uint64_t)v34;
        v20 = (std::__shared_weak_count *)operator new(0x30uLL);
        v20->__shared_owners_ = 0;
        v20->__shared_weak_owners_ = 0;
        v20->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5DBF38;
        v20[1].__vftable = 0;
        v20[1].__shared_owners_ = 0;
        v20[1].__shared_weak_owners_ = 0;
        std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(&v20[1].__vftable, v18, v19, v19 - (_QWORD)v18);
        v37 = &v20[1].__vftable;
        v38 = v20;
        if (!v40)
          std::__throw_bad_function_call[abi:ne180100]();
        (*(void (**)(unint64_t *, _QWORD **))(*v40 + 48))(v40, &v37);
        v21 = v38;
        if (v38)
        {
          v22 = (unint64_t *)&v38->__shared_owners_;
          do
            v23 = __ldaxr(v22);
          while (__stlxr(v23 - 1, v22));
          if (!v23)
          {
            ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
            std::__shared_weak_count::__release_weak(v21);
          }
        }
      }
      if (__p)
      {
        v34 = __p;
        operator delete(__p);
      }
      if (v17)
        v24 = 1;
      else
        v24 = ((uint64_t (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)this, 17, v15, v16);
    }
    else
    {
      v24 = 0;
    }
    v27 = v40;
    if (v40 == v39)
    {
      v28 = 4;
      v27 = v39;
    }
    else
    {
      if (!v40)
        goto LABEL_38;
      v28 = 5;
    }
    (*(void (**)(void))(*v27 + 8 * v28))();
LABEL_38:
    if ((v24 & 1) == 0)
      __TUAssertTrigger();
    return;
  }
LABEL_24:
  v29 = 0;
  v30 = 0;
  v25 = *(_QWORD *)(a1 + 64);
  if (!v25)
    std::__throw_bad_function_call[abi:ne180100]();
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v25 + 48))(v25, &v29);
  v4 = v30;
  if (v30)
  {
    v26 = (unint64_t *)&v30->__shared_owners_;
    do
      v6 = __ldaxr(v26);
    while (__stlxr(v6 - 1, v26));
    goto LABEL_28;
  }
}

void sub_2169D8E20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12, uint64_t a13, void *__p, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,char *a23)
{
  std::__shared_weak_count *v23;
  void *v25;
  char *v26;
  uint64_t v27;

  std::__shared_weak_count::~__shared_weak_count(v23);
  operator delete(v25);
  if (__p)
    operator delete(__p);
  v26 = a23;
  if (a23 == &a20)
  {
    v27 = 4;
    v26 = &a20;
  }
  else
  {
    if (!a23)
      goto LABEL_8;
    v27 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v26 + 8 * v27))();
LABEL_8:
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_40c75_ZTSNSt3__18functionIFvNS_10shared_ptrINS_6vectorIhNS_9allocatorIhEEEEEEEEE(uint64_t a1, uint64_t a2)
{
  return std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100](a1 + 40, a2 + 40);
}

_QWORD *__destroy_helper_block_e8_40c75_ZTSNSt3__18functionIFvNS_10shared_ptrINS_6vectorIhNS_9allocatorIhEEEEEEEEE(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *result;
  uint64_t v3;

  v1 = (_QWORD *)(a1 + 40);
  result = *(_QWORD **)(a1 + 64);
  if (result == v1)
  {
    v3 = 4;
    result = v1;
  }
  else
  {
    if (!result)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

void subscriber::EURSimCommandDriver::writeTransparentFile(uint64_t a1, char **a2, uint64_t a3, char **a4, uint64_t a5)
{
  os_log_t *v9;
  NSObject *v10;
  NSObject *v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  unsigned int *v15;
  char *v16;
  const void **v17;
  char *v18;
  _WORD *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD *v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  char *v27;
  uint64_t *v28;
  char *v29;
  char *v30;
  char *v31;
  uint64_t v32;
  char **v33;
  void *v34;
  _QWORD v35[6];
  uint64_t v36;
  int v37;
  uint64_t v38;
  void *aBlock;
  void *__p[2];
  __int128 v41;
  void *v42[2];
  __int128 v43;
  _BYTE buf[24];
  void *v45;
  _QWORD *v46;
  uint64_t v47;

  v47 = *MEMORY[0x24BDAC8D0];
  v9 = (os_log_t *)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 48) + 16))(*(_QWORD *)(a1 + 48), *(unsigned int *)a2);
  v10 = *v9;
  if (os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = subscriber::asString();
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = subscriber::asString();
    _os_log_impl(&dword_216897000, v10, OS_LOG_TYPE_DEFAULT, "#I Writing to Transparent %s file %s", buf, 0x16u);
  }
  *(_OWORD *)v42 = 0u;
  v43 = 0u;
  subscriber::sGetFileId((char *)v42);
  if (subscriber::sIsFileIdInvalid((uint64_t)v42))
  {
    v11 = *v9;
    if (os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT))
    {
      v12 = subscriber::asString();
      v13 = subscriber::asString();
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = v12;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = v13;
      _os_log_impl(&dword_216897000, v11, OS_LOG_TYPE_DEFAULT, "#I No path and file id known, sending file data error for file %s under SIM %s", buf, 0x16u);
    }
    (*(void (**)(uint64_t, _QWORD))(a5 + 16))(a5, 0);
  }
  else
  {
    *(_OWORD *)__p = 0u;
    v41 = 0u;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
    v14 = qmi::MutableMessageBase::getTLV<uim::tlv::SessionInfo>(__p);
    v15 = (unsigned int *)(v14 + 8);
    if (v15 != (unsigned int *)(a2 + 2))
      std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(v15, a2[2], a2[3], a2[3] - a2[2]);
    v16 = qmi::MutableMessageBase::getTLV<uim::tlv::FileId>(__p);
    *(_WORD *)v16 = v42[0];
    if (v16 != (char *)v42)
      std::vector<unsigned short>::__assign_with_size[abi:ne180100]<unsigned short *,unsigned short *>(v16 + 8, (char *)v42[1], v43, (uint64_t)(v43 - (unint64_t)v42[1]) >> 1);
    v17 = (const void **)__p[1];
    if (__p[1] != (void *)v41)
    {
      while (*((_BYTE *)*v17 + 8) != 3)
      {
        if (++v17 == (const void **)v41)
          goto LABEL_18;
      }
    }
    if (v17 == (const void **)v41)
    {
LABEL_18:
      v20 = operator new();
      v21 = v20;
      *(_BYTE *)(v20 + 8) = 3;
      *(_QWORD *)v20 = &off_24D5DBFC8;
      *(_WORD *)(v20 + 16) = 0;
      v19 = (_WORD *)(v20 + 16);
      *(_QWORD *)(v20 + 32) = 0;
      *(_QWORD *)(v20 + 40) = 0;
      *(_QWORD *)(v20 + 24) = 0;
      v22 = v41;
      if ((unint64_t)v41 >= *((_QWORD *)&v41 + 1))
      {
        v24 = (uint64_t)(v41 - (unint64_t)__p[1]) >> 3;
        if ((unint64_t)(v24 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v25 = (uint64_t)(*((_QWORD *)&v41 + 1) - (unint64_t)__p[1]) >> 2;
        if (v25 <= v24 + 1)
          v25 = v24 + 1;
        if (*((_QWORD *)&v41 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v26 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v26 = v25;
        if (v26)
          v27 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v41 + 8, v26);
        else
          v27 = 0;
        v28 = (uint64_t *)&v27[8 * v24];
        v29 = &v27[8 * v26];
        *v28 = v21;
        v23 = v28 + 1;
        v31 = (char *)__p[1];
        v30 = (char *)v41;
        if ((void *)v41 != __p[1])
        {
          do
          {
            v32 = *((_QWORD *)v30 - 1);
            v30 -= 8;
            *--v28 = v32;
          }
          while (v30 != v31);
          v30 = (char *)__p[1];
        }
        __p[1] = v28;
        *(_QWORD *)&v41 = v23;
        *((_QWORD *)&v41 + 1) = v29;
        if (v30)
          operator delete(v30);
      }
      else
      {
        *(_QWORD *)v41 = v20;
        v23 = (_QWORD *)(v22 + 8);
      }
      *(_QWORD *)&v41 = v23;
    }
    else
    {
      if (!v18)
        __cxa_bad_cast();
      v19 = v18 + 16;
    }
    *v19 = 0;
    v33 = (char **)(v19 + 4);
    if (v33 != a4)
      std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(v33, *a4, a4[1], a4[1] - *a4);
    v35[5] = a1 + 128;
    v36 = QMIServiceMsg::create();
    v38 = 0;
    aBlock = 0;
    v37 = 240000;
    v35[0] = MEMORY[0x24BDAC760];
    v35[1] = 0x40000000;
    v35[2] = ___ZN10subscriber19EURSimCommandDriver20writeTransparentFileERKNS_11SimCardInfoENS_11SimFilePathERKNSt3__16vectorIhNS5_9allocatorIhEEEEU13block_pointerFvbE_block_invoke;
    v35[3] = &unk_24D5DB068;
    v35[4] = a5;
    *(_QWORD *)buf = MEMORY[0x24BDAC760];
    *(_QWORD *)&buf[8] = 0x40000000;
    *(_QWORD *)&buf[16] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3uim16WriteTransparent8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
    v45 = &unk_24D5DBFF8;
    v46 = v35;
    v34 = _Block_copy(buf);
    aBlock = v34;
    if (v36)
    {
      qmi::Client::send();
      v34 = aBlock;
    }
    if (v34)
      _Block_release(v34);
    qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
  }
  if (v42[1])
  {
    *(void **)&v43 = v42[1];
    operator delete(v42[1]);
  }
}

void sub_2169D9384(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *__p,uint64_t a25)
{
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)&a14);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a19);
  if (__p)
  {
    a25 = (uint64_t)__p;
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t ___ZN10subscriber19EURSimCommandDriver20writeTransparentFileERKNS_11SimCardInfoENS_11SimFilePathERKNSt3__16vectorIhNS5_9allocatorIhEEEEU13block_pointerFvbE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void subscriber::EURSimCommandDriver::readRecordFile(uint64_t a1, char **a2, unsigned __int16 *a3, int a4, uint64_t a5)
{
  __int16 v6;
  NSObject *v10;
  uint64_t v11;
  int v12;
  std::__shared_weak_count_vtbl *v13;
  std::__shared_weak_count *v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  unint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  uint64_t v23[2];
  unsigned __int16 v24;
  void *__p;
  void *v26;
  uint64_t v27;
  uint64_t v28;
  _BYTE v29[24];
  _BYTE *v30;
  _BYTE buf[18];
  uint64_t v32;

  v32 = *MEMORY[0x24BDAC8D0];
  if (!a4)
    return;
  v6 = a4;
  v10 = *(NSObject **)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 48) + 16))(*(_QWORD *)(a1 + 48), *(unsigned int *)a2);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    v11 = subscriber::asString();
    v12 = *a3;
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = v11;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v12;
    _os_log_impl(&dword_216897000, v10, OS_LOG_TYPE_DEFAULT, "#I Reading record %s file 0x%04x", buf, 0x12u);
  }
  v13 = (std::__shared_weak_count_vtbl *)operator new();
  v13->__on_zero_shared = 0;
  v13->~__shared_weak_count_0 = 0;
  v13->~__shared_weak_count = (void (__cdecl *)(std::__shared_weak_count *__hidden))&v13->~__shared_weak_count_0;
  *(_QWORD *)buf = v13;
  v14 = (std::__shared_weak_count *)operator new();
  v14->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v14->__shared_owners_;
  v14->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5DC028;
  v14->__shared_weak_owners_ = 0;
  v14[1].__vftable = v13;
  *(_QWORD *)&buf[8] = v14;
  v28 = 0;
  std::unique_ptr<std::map<unsigned short,std::vector<unsigned char>>>::reset[abi:ne180100](&v28);
  v24 = *a3;
  v26 = 0;
  v27 = 0;
  __p = 0;
  std::vector<unsigned short>::__init_with_size[abi:ne180100]<unsigned short *,unsigned short *>(&__p, *((const void **)a3 + 1), *((_QWORD *)a3 + 2), (uint64_t)(*((_QWORD *)a3 + 2) - *((_QWORD *)a3 + 1)) >> 1);
  std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100]((uint64_t)v29, a5);
  v23[0] = (uint64_t)v13;
  v23[1] = (uint64_t)v14;
  do
    v16 = __ldxr(p_shared_owners);
  while (__stxr(v16 + 1, p_shared_owners));
  subscriber::EURSimCommandDriver::readRecordInFile(a1, a2, &v24, 1, v6, (uint64_t)v29, v23);
  do
    v17 = __ldaxr(p_shared_owners);
  while (__stlxr(v17 - 1, p_shared_owners));
  if (!v17)
  {
    ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
    std::__shared_weak_count::__release_weak(v14);
  }
  v18 = v30;
  if (v30 == v29)
  {
    v19 = 4;
    v18 = v29;
    goto LABEL_14;
  }
  if (v30)
  {
    v19 = 5;
LABEL_14:
    (*(void (**)(void))(*v18 + 8 * v19))();
  }
  if (__p)
  {
    v26 = __p;
    operator delete(__p);
  }
  v20 = *(std::__shared_weak_count **)&buf[8];
  if (*(_QWORD *)&buf[8])
  {
    v21 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
}

void sub_2169D967C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, char a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,__int16 *a23,char a24)
{
  __int16 *v24;
  __int16 *v26;
  uint64_t v27;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a10);
  v26 = a23;
  if (a23 == v24)
  {
    v27 = 4;
    v26 = &a18;
  }
  else
  {
    if (!a23)
      goto LABEL_6;
    v27 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v26 + 8 * v27))();
LABEL_6:
  if (__p)
  {
    a14 = (uint64_t)__p;
    operator delete(__p);
  }
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a24);
  _Unwind_Resume(a1);
}

void subscriber::EURSimCommandDriver::readRecordInFile(uint64_t a1, char **a2, unsigned __int16 *a3, int a4, __int16 a5, uint64_t a6, uint64_t *a7)
{
  os_log_t *v14;
  NSObject *v15;
  uint64_t v16;
  int v17;
  char *v18;
  unsigned int *v19;
  char *v20;
  void *v21;
  const void **v22;
  char *v23;
  _WORD *v24;
  __int16 v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  _QWORD *v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  char *v33;
  uint64_t *v34;
  char *v35;
  char *v36;
  char *v37;
  uint64_t v38;
  uint64_t v39;
  _QWORD *v40;
  std::__shared_weak_count *v41;
  unint64_t *p_shared_owners;
  unint64_t v43;
  void *v44;
  std::__shared_weak_count *v45;
  unint64_t *v46;
  unint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  void *aBlock;
  __int128 v52;
  void *v53;
  _BYTE *v54;
  uint64_t v55;
  void *__p[2];
  __int128 v57;
  _QWORD v58[5];
  __int128 v59;
  void *v60;
  void *v61;
  uint64_t v62;
  __int16 v63;
  void *v64;
  void *v65;
  uint64_t v66;
  _BYTE v67[24];
  _BYTE *v68;
  uint64_t v69;
  std::__shared_weak_count *v70;
  os_log_t *v71;
  __int16 v72;
  __int16 v73;
  uint8_t buf[8];
  __int128 v75;
  void *v76;
  _QWORD *v77;
  uint64_t v78;

  v78 = *MEMORY[0x24BDAC8D0];
  v14 = (os_log_t *)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 48) + 16))(*(_QWORD *)(a1 + 48), *(unsigned int *)a2);
  v15 = *v14;
  if (os_log_type_enabled(*v14, OS_LOG_TYPE_DEFAULT))
  {
    v16 = subscriber::asString();
    v17 = *a3;
    *(_DWORD *)buf = 67109634;
    *(_DWORD *)&buf[4] = a4;
    LOWORD(v75) = 2080;
    *(_QWORD *)((char *)&v75 + 2) = v16;
    WORD5(v75) = 1024;
    HIDWORD(v75) = v17;
    _os_log_impl(&dword_216897000, v15, OS_LOG_TYPE_DEFAULT, "#I Received read record for id: %d in %s file 0x%04x", buf, 0x18u);
  }
  *(_OWORD *)__p = 0u;
  v57 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  v18 = qmi::MutableMessageBase::getTLV<uim::tlv::SessionInfo>(__p);
  v19 = (unsigned int *)(v18 + 8);
  if (v19 != (unsigned int *)(a2 + 2))
    std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(v19, a2[2], a2[3], a2[3] - a2[2]);
  subscriber::sConvertFileId((char *)buf, (uint64_t)a3);
  v49 = a6;
  v20 = qmi::MutableMessageBase::getTLV<uim::tlv::FileId>(__p);
  *(_WORD *)v20 = *(_WORD *)buf;
  v21 = (void *)*((_QWORD *)v20 + 1);
  if (v21)
  {
    *((_QWORD *)v20 + 2) = v21;
    operator delete(v21);
    *((_QWORD *)v20 + 1) = 0;
    *((_QWORD *)v20 + 2) = 0;
    *((_QWORD *)v20 + 3) = 0;
  }
  *(_OWORD *)(v20 + 8) = v75;
  *((_QWORD *)v20 + 3) = v76;
  v22 = (const void **)__p[1];
  if (__p[1] != (void *)v57)
  {
    while (*((_BYTE *)*v22 + 8) != 3)
    {
      if (++v22 == (const void **)v57)
        goto LABEL_14;
    }
  }
  if (v22 == (const void **)v57)
  {
LABEL_14:
    v25 = a5;
    v26 = operator new();
    v27 = v26;
    *(_BYTE *)(v26 + 8) = 3;
    *(_QWORD *)v26 = &off_24D5DC0E0;
    *(_DWORD *)(v26 + 10) = 0;
    v24 = (_WORD *)(v26 + 10);
    v28 = v57;
    if ((unint64_t)v57 >= *((_QWORD *)&v57 + 1))
    {
      v30 = (uint64_t)(v57 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v30 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v31 = (uint64_t)(*((_QWORD *)&v57 + 1) - (unint64_t)__p[1]) >> 2;
      if (v31 <= v30 + 1)
        v31 = v30 + 1;
      if (*((_QWORD *)&v57 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v32 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v32 = v31;
      if (v32)
        v33 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v57 + 8, v32);
      else
        v33 = 0;
      v34 = (uint64_t *)&v33[8 * v30];
      v35 = &v33[8 * v32];
      *v34 = v27;
      v29 = v34 + 1;
      v37 = (char *)__p[1];
      v36 = (char *)v57;
      if ((void *)v57 != __p[1])
      {
        do
        {
          v38 = *((_QWORD *)v36 - 1);
          v36 -= 8;
          *--v34 = v38;
        }
        while (v36 != v37);
        v36 = (char *)__p[1];
      }
      __p[1] = v34;
      *(_QWORD *)&v57 = v29;
      *((_QWORD *)&v57 + 1) = v35;
      if (v36)
        operator delete(v36);
    }
    else
    {
      *(_QWORD *)v57 = v26;
      v29 = (_QWORD *)(v28 + 8);
    }
    *(_QWORD *)&v57 = v29;
    a5 = v25;
  }
  else
  {
    if (!v23)
      __cxa_bad_cast();
    v24 = v23 + 10;
  }
  *v24 = a4;
  v24[1] = 0;
  v52 = *(_OWORD *)a2;
  v54 = 0;
  v55 = 0;
  v53 = 0;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(&v53, a2[2], (uint64_t)a2[3], a2[3] - a2[2]);
  v50 = QMIServiceMsg::create();
  v39 = MEMORY[0x24BDAC760];
  v58[0] = MEMORY[0x24BDAC760];
  v58[1] = 1174405120;
  v58[2] = ___ZN10subscriber19EURSimCommandDriver16readRecordInFileERKNS_11SimCardInfoENS_6FileIdEttNSt3__18functionIFvNS5_10shared_ptrINS5_6vectorIhNS5_9allocatorIhEEEEEEEEENS7_INS5_3mapItSB_NS5_4lessItEENS9_INS5_4pairIKtSB_EEEEEEEE_block_invoke;
  v58[3] = &__block_descriptor_tmp_44_6;
  v59 = v52;
  v58[4] = a1;
  v60 = 0;
  v61 = 0;
  v62 = 0;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(&v60, v53, (uint64_t)v54, v54 - (_BYTE *)v53);
  v63 = *a3;
  v65 = 0;
  v66 = 0;
  v64 = 0;
  std::vector<unsigned short>::__init_with_size[abi:ne180100]<unsigned short *,unsigned short *>(&v64, *((const void **)a3 + 1), *((_QWORD *)a3 + 2), (uint64_t)(*((_QWORD *)a3 + 2) - *((_QWORD *)a3 + 1)) >> 1);
  v72 = a4;
  v40 = v67;
  std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100]((uint64_t)v67, v49);
  v41 = (std::__shared_weak_count *)a7[1];
  v69 = *a7;
  v70 = v41;
  if (v41)
  {
    p_shared_owners = (unint64_t *)&v41->__shared_owners_;
    do
      v43 = __ldxr(p_shared_owners);
    while (__stxr(v43 + 1, p_shared_owners));
  }
  v71 = v14;
  v73 = a5;
  *(_QWORD *)buf = v39;
  *(_QWORD *)&v75 = 0x40000000;
  *((_QWORD *)&v75 + 1) = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_21;
  v76 = &unk_24D5DB9C8;
  v77 = v58;
  v44 = _Block_copy(buf);
  aBlock = v44;
  if (v50)
  {
    qmi::Client::send();
    v44 = aBlock;
  }
  if (v44)
    _Block_release(v44);
  v45 = v70;
  if (v70)
  {
    v46 = (unint64_t *)&v70->__shared_owners_;
    do
      v47 = __ldaxr(v46);
    while (__stlxr(v47 - 1, v46));
    if (!v47)
    {
      ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
      std::__shared_weak_count::__release_weak(v45);
    }
  }
  if (v68 == v67)
  {
    v48 = 4;
  }
  else
  {
    if (!v68)
      goto LABEL_48;
    v48 = 5;
    v40 = v68;
  }
  (*(void (**)(_QWORD *))(*v40 + 8 * v48))(v40);
LABEL_48:
  if (v64)
  {
    v65 = v64;
    operator delete(v64);
  }
  if (v60)
  {
    v61 = v60;
    operator delete(v60);
  }
  if (v53)
  {
    v54 = v53;
    operator delete(v53);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
}

void sub_2169D9C10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32,uint64_t a33,uint64_t a34,uint64_t a35,void *__p,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,_QWORD *a42)
{
  uint64_t v42;
  _QWORD *v43;
  uint64_t v45;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v42);
  if (a42 == v43)
  {
    v45 = 4;
  }
  else
  {
    if (!a42)
      goto LABEL_6;
    v45 = 5;
    v43 = a42;
  }
  (*(void (**)(_QWORD *))(*v43 + 8 * v45))(v43);
LABEL_6:
  if (__p)
  {
    a37 = (uint64_t)__p;
    operator delete(__p);
  }
  if (a32)
  {
    a33 = (uint64_t)a32;
    operator delete(a32);
  }
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)&a10);
  if (a17)
  {
    a18 = (uint64_t)a17;
    operator delete(a17);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a21);
  _Unwind_Resume(a1);
}

void subscriber::EURSimCommandDriver::queryFileAttributes(uint64_t a1, char **a2, unsigned __int16 *a3, uint64_t a4)
{
  os_log_t *v8;
  NSObject *v9;
  uint64_t v10;
  int v11;
  NSObject *v12;
  int v13;
  uint64_t v14;
  char *v15;
  unsigned int *v16;
  char *v17;
  __int16 v18;
  unsigned int v19;
  uint64_t v20;
  _QWORD *v21;
  void *v22;
  uint64_t v23;
  uint64_t v24;
  void *aBlock;
  _OWORD v26[2];
  void *__p[2];
  __int128 v28;
  _QWORD v29[6];
  _BYTE v30[24];
  _BYTE *v31;
  unsigned int v32;
  __int16 v33;
  _BYTE buf[24];
  void *v35;
  _QWORD *v36;
  uint64_t v37;

  v37 = *MEMORY[0x24BDAC8D0];
  v8 = (os_log_t *)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 48) + 16))(*(_QWORD *)(a1 + 48), *(unsigned int *)a2);
  v9 = *v8;
  if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
  {
    v10 = subscriber::asString();
    v11 = *a3;
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = v10;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v11;
    _os_log_impl(&dword_216897000, v9, OS_LOG_TYPE_DEFAULT, "#I Reading record %s file 0x%04x", buf, 0x12u);
  }
  *(_OWORD *)__p = 0u;
  v28 = 0u;
  subscriber::sConvertFileId((char *)__p, (uint64_t)a3);
  if (!subscriber::sIsFileIdInvalid((uint64_t)__p))
  {
    memset(v26, 0, sizeof(v26));
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v26);
    v15 = qmi::MutableMessageBase::getTLV<uim::tlv::SessionInfo>(v26);
    v16 = (unsigned int *)(v15 + 8);
    if (v16 != (unsigned int *)(a2 + 2))
      std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(v16, a2[2], a2[3], a2[3] - a2[2]);
    v17 = qmi::MutableMessageBase::getTLV<uim::tlv::FileId>(v26);
    *(_WORD *)v17 = __p[0];
    if (v17 != (char *)__p)
      std::vector<unsigned short>::__assign_with_size[abi:ne180100]<unsigned short *,unsigned short *>(v17 + 8, (char *)__p[1], v28, (uint64_t)(v28 - (unint64_t)__p[1]) >> 1);
    v18 = *a3;
    v19 = *((_DWORD *)a2 + 3);
    v24 = QMIServiceMsg::create();
    v20 = MEMORY[0x24BDAC760];
    v29[0] = MEMORY[0x24BDAC760];
    v29[1] = 1174405120;
    v29[2] = ___ZN10subscriber19EURSimCommandDriver19queryFileAttributesERKNS_11SimCardInfoERKNS_6FileIdENSt3__18functionIFvNS7_8optionalINS_17SimFileAttributesEEEhNS_11SimFileTypeEEEE_block_invoke;
    v29[3] = &__block_descriptor_tmp_43_9;
    v29[4] = a1;
    v29[5] = v8;
    v32 = v19;
    v21 = v30;
    v33 = v18;
    std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100]((uint64_t)v30, a4);
    *(_QWORD *)buf = v20;
    *(_QWORD *)&buf[8] = 0x40000000;
    *(_QWORD *)&buf[16] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3uim17GetFileAttributes8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
    v35 = &unk_24D5DC098;
    v36 = v29;
    v22 = _Block_copy(buf);
    aBlock = v22;
    if (v24)
    {
      qmi::Client::send();
      v22 = aBlock;
    }
    if (v22)
      _Block_release(v22);
    if (v31 == v30)
    {
      v23 = 4;
    }
    else
    {
      if (!v31)
      {
LABEL_20:
        qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v26);
        goto LABEL_21;
      }
      v23 = 5;
      v21 = v31;
    }
    (*(void (**)(_QWORD *))(*v21 + 8 * v23))(v21);
    goto LABEL_20;
  }
  v12 = *v8;
  if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
  {
    v13 = *a3;
    v14 = subscriber::asString();
    *(_DWORD *)buf = 67109378;
    *(_DWORD *)&buf[4] = v13;
    *(_WORD *)&buf[8] = 2080;
    *(_QWORD *)&buf[10] = v14;
    _os_log_impl(&dword_216897000, v12, OS_LOG_TYPE_DEFAULT, "#I No path and file id known, sending file data error for file 0x%04x under SIM %s", buf, 0x12u);
  }
  std::function<void ()(std::optional<subscriber::SimFileAttributes>,unsigned char,subscriber::SimFileType)>::operator()(*(_QWORD *)(a4 + 24), 0, 0, 0);
LABEL_21:
  if (__p[1])
  {
    *(void **)&v28 = __p[1];
    operator delete(__p[1]);
  }
}

void sub_2169DA00C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t std::function<void ()(std::optional<subscriber::SimFileAttributes>,unsigned char,subscriber::SimFileType)>::operator()(uint64_t a1, __int16 a2, char a3, int a4)
{
  int v5;
  char v6;
  __int16 v7;

  v7 = a2;
  v6 = a3;
  v5 = a4;
  if (!a1)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, __int16 *, char *, int *))(*(_QWORD *)a1 + 48))(a1, &v7, &v6, &v5);
}

uint64_t ___ZN10subscriber19EURSimCommandDriver19queryFileAttributesERKNS_11SimCardInfoERKNS_6FileIdENSt3__18functionIFvNS7_8optionalINS_17SimFileAttributesEEEhNS_11SimFileTypeEEEE_block_invoke(uint64_t a1, qmi::MessageBase *a2)
{
  int v4;
  NSObject *v5;
  _BOOL4 v6;
  uint64_t v7;
  int v8;
  int v9;
  uint64_t v10;
  int v11;
  uint64_t TlvValue;
  int v13;
  uint64_t v14;
  int v15;
  unsigned __int8 v16;
  NSObject *v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int v21;
  unint64_t v22;
  char v23;
  __int16 v24;
  NSObject *v25;
  int v27;
  unint64_t v28;
  uint8_t buf[48];
  void *__p[2];
  __int128 v31;
  uint64_t v32;

  v32 = *MEMORY[0x24BDAC8D0];
  v4 = *((_DWORD *)a2 + 1);
  v5 = **(NSObject ***)(a1 + 40);
  v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (v4)
  {
    if (v6)
    {
      v7 = subscriber::asString();
      v8 = *(unsigned __int16 *)(a1 + 84);
      v9 = *((_DWORD *)a2 + 1);
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = v7;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v8;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v9;
      *(_WORD *)&buf[24] = 2080;
      *(_QWORD *)&buf[26] = qmi::asString();
      _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#I GetFileAttributes(%s file 0x%04x) returns error: 0x%04x (%s)", buf, 0x22u);
    }
    return std::function<void ()(std::optional<subscriber::SimFileAttributes>,unsigned char,subscriber::SimFileType)>::operator()(*(_QWORD *)(a1 + 72), 0, 0, 0);
  }
  if (v6)
  {
    v10 = subscriber::asString();
    v11 = *(unsigned __int16 *)(a1 + 84);
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = v10;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v11;
    _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#I Got the file attributes for %s file 0x%04x", buf, 0x12u);
  }
  if (qmi::MessageBase::findTlvValue(a2))
  {
    TlvValue = qmi::MessageBase::findTlvValue(a2);
    v14 = TlvValue;
    if (TlvValue)
    {
      v15 = v13;
      *(_QWORD *)buf = TlvValue;
      v16 = tlv::parseV<uim::tlv::CardResult>((unint64_t *)buf, v13);
      if (*(_QWORD *)buf)
      {
        if ((subscriber::isCardResultSW1Good((subscriber *)v16) & 1) == 0)
        {
          v17 = **(NSObject ***)(a1 + 40);
          if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)buf = 0;
            _os_log_error_impl(&dword_216897000, v17, OS_LOG_TYPE_ERROR, "Get File Attributes returned with card result failed", buf, 2u);
          }
          return std::function<void ()(std::optional<subscriber::SimFileAttributes>,unsigned char,subscriber::SimFileType)>::operator()(*(_QWORD *)(a1 + 72), 0, 0, 0);
        }
      }
      else
      {
        ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 16, v14, v15);
      }
    }
  }
  if (!qmi::MessageBase::findTlvValue(a2))
  {
    v25 = **(NSObject ***)(a1 + 40);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_216897000, v25, OS_LOG_TYPE_ERROR, "Get File Attributes returned without FileAttributes", buf, 2u);
    }
    return std::function<void ()(std::optional<subscriber::SimFileAttributes>,unsigned char,subscriber::SimFileType)>::operator()(*(_QWORD *)(a1 + 72), 0, 0, 0);
  }
  v18 = qmi::MessageBase::findTlvValue(a2);
  v20 = v18;
  if (v18)
  {
    v21 = v19;
    v28 = v18;
    *(_OWORD *)__p = 0u;
    v31 = 0u;
    memset(buf, 0, sizeof(buf));
    tlv::parseV<uim::tlv::FileAttributes>(&v28, v19, buf);
    v22 = v28;
    if (v28)
    {
      v23 = buf[10];
      if (*(_DWORD *)&buf[20] == 4)
      {
        v24 = *(_DWORD *)&buf[24] == 1;
      }
      else if (*(_DWORD *)&buf[20] == 3)
      {
        v24 = buf[24] & 1;
      }
      else
      {
        v24 = *(_DWORD *)&buf[20] == 0;
      }
      if (*(_DWORD *)&buf[4] <= 4u)
      {
        v27 = dword_216AB1410[*(int *)&buf[4]];
LABEL_31:
        if (__p[1])
        {
          *(void **)&v31 = __p[1];
          operator delete(__p[1]);
        }
        if (!v22)
          ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 17, v20, v21);
        return std::function<void ()(std::optional<subscriber::SimFileAttributes>,unsigned char,subscriber::SimFileType)>::operator()(*(_QWORD *)(a1 + 72), v24 | 0x100u, v23, v27);
      }
    }
    else
    {
      v23 = 0;
      v24 = 0;
    }
    v27 = 0;
    goto LABEL_31;
  }
  v23 = 0;
  v24 = 0;
  v27 = 0;
  return std::function<void ()(std::optional<subscriber::SimFileAttributes>,unsigned char,subscriber::SimFileType)>::operator()(*(_QWORD *)(a1 + 72), v24 | 0x100u, v23, v27);
}

uint64_t __copy_helper_block_e8_48c93_ZTSNSt3__18functionIFvNS_8optionalIN10subscriber17SimFileAttributesEEEhNS2_11SimFileTypeEEEE(uint64_t a1, uint64_t a2)
{
  return std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100](a1 + 48, a2 + 48);
}

_QWORD *__destroy_helper_block_e8_48c93_ZTSNSt3__18functionIFvNS_8optionalIN10subscriber17SimFileAttributesEEEhNS2_11SimFileTypeEEEE(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *result;
  uint64_t v3;

  v1 = (_QWORD *)(a1 + 48);
  result = *(_QWORD **)(a1 + 72);
  if (result == v1)
  {
    v3 = 4;
    result = v1;
  }
  else
  {
    if (!result)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

void ___ZN10subscriber19EURSimCommandDriver16readRecordInFileERKNS_11SimCardInfoENS_6FileIdEttNSt3__18functionIFvNS5_10shared_ptrINS5_6vectorIhNS5_9allocatorIhEEEEEEEEENS7_INS5_3mapItSB_NS5_4lessItEENS9_INS5_4pairIKtSB_EEEEEEEE_block_invoke(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  std::__shared_weak_count *v9;
  uint64_t **v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  unsigned int *v13;
  NSObject *v14;
  uint64_t v15;
  int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  uint64_t TlvValue;
  int v24;
  uint64_t v25;
  int v26;
  unsigned __int8 v27;
  unint64_t *v28;
  unint64_t v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t **v34;
  uint64_t **v35;
  unsigned int v36;
  uint64_t v37;
  unint64_t *v38;
  unint64_t *v39;
  unint64_t v40;
  unsigned int v41;
  unsigned int v42;
  NSObject *v43;
  _BOOL4 v44;
  unsigned int v45;
  uint64_t v46;
  int v47;
  uint64_t v48;
  uint64_t v49;
  std::__shared_weak_count *v50;
  unint64_t *v51;
  unint64_t v52;
  unint64_t *v53;
  unint64_t v54;
  _QWORD *v55;
  uint64_t v56;
  NSObject *v57;
  uint64_t v58;
  int v59;
  _QWORD *v60;
  _QWORD *v61;
  _QWORD *v62;
  _QWORD *v63;
  _QWORD *v64;
  _QWORD *v65;
  BOOL v66;
  uint64_t v67;
  const void *v68;
  std::__shared_weak_count *v69;
  uint64_t v70;
  std::__shared_weak_count *v71;
  unint64_t *v72;
  unint64_t v73;
  void *v74;
  _WORD *v75;
  uint64_t *v76;
  uint64_t *v77;
  std::__shared_weak_count *v78;
  unint64_t *v79;
  unint64_t v80;
  unint64_t v81;
  int v82;
  _QWORD *v83;
  std::__shared_weak_count *v84;
  _QWORD v85[2];
  __int16 v86;
  void *__p;
  void *v88;
  uint64_t v89;
  uint64_t **v90;
  std::__shared_weak_count *v91;
  _QWORD v92[4];
  std::__shared_weak_count *v93;
  __int16 v94;
  unint64_t v95;
  _BYTE v96[24];
  _BYTE *v97;
  uint8_t buf[24];
  __int16 v99;
  uint64_t v100;
  uint64_t v101;

  v101 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 + 32);
  v4 = *(unsigned __int16 *)(a1 + 168);
  v5 = a2[1];
  v92[0] = *a2;
  v92[1] = v5;
  v6 = a2[2];
  v92[2] = v6;
  if (v6)
  {
    v7 = (unint64_t *)(v6 + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  qmi::MessageBase::validateMsgId((qmi::MessageBase *)v92);
  v10 = *(uint64_t ***)(a1 + 144);
  v9 = *(std::__shared_weak_count **)(a1 + 152);
  v90 = v10;
  v91 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
  }
  v13 = (unsigned int *)(a1 + 40);
  if (HIDWORD(v92[0]))
  {
    v14 = *(NSObject **)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(v3 + 48) + 16))(*(_QWORD *)(v3 + 48), *v13);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      v15 = subscriber::asString();
      v16 = *(unsigned __int16 *)(a1 + 80);
      v17 = HIDWORD(v92[0]);
      v18 = qmi::asString();
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = v15;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v16;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v17;
      v99 = 2080;
      v100 = v18;
      _os_log_impl(&dword_216897000, v14, OS_LOG_TYPE_DEFAULT, "#I ReadRecord(%s file 0x%04x) returns error: 0x%04x (%s)", buf, 0x22u);
    }
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = 0;
    v19 = *(_QWORD *)(a1 + 136);
    if (!v19)
      std::__throw_bad_function_call[abi:ne180100]();
    (*(void (**)(uint64_t, uint8_t *))(*(_QWORD *)v19 + 48))(v19, buf);
    v20 = *(std::__shared_weak_count **)&buf[8];
    if (*(_QWORD *)&buf[8])
    {
      v21 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
      do
        v22 = __ldaxr(v21);
      while (__stlxr(v22 - 1, v21));
LABEL_36:
      if (!v22)
      {
        ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
        std::__shared_weak_count::__release_weak(v20);
      }
      LOBYTE(v20) = 0;
      goto LABEL_39;
    }
    goto LABEL_39;
  }
  TlvValue = qmi::MessageBase::findTlvValue((qmi::MessageBase *)v92);
  v25 = TlvValue;
  if (!TlvValue)
  {
LABEL_31:
    __TUAssertTrigger();
LABEL_32:
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = 0;
    v37 = *(_QWORD *)(a1 + 136);
    if (!v37)
      std::__throw_bad_function_call[abi:ne180100]();
    (*(void (**)(uint64_t, uint8_t *))(*(_QWORD *)v37 + 48))(v37, buf);
    v20 = *(std::__shared_weak_count **)&buf[8];
    if (*(_QWORD *)&buf[8])
    {
      v38 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
      do
        v22 = __ldaxr(v38);
      while (__stlxr(v22 - 1, v38));
      goto LABEL_36;
    }
LABEL_39:
    if (!v9)
      goto LABEL_44;
    goto LABEL_40;
  }
  v26 = v24;
  *(_QWORD *)buf = TlvValue;
  v27 = tlv::parseV<uim::tlv::CardResult>((unint64_t *)buf, v24);
  if (!*(_QWORD *)buf)
  {
    if ((((uint64_t (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(LOWORD(v92[0]), 16, v25, v26) & 1) != 0)goto LABEL_32;
    goto LABEL_31;
  }
  if (!subscriber::isCardResultSW1Good((subscriber *)v27))
    goto LABEL_32;
  v92[3] = v10;
  v93 = v9;
  if (v9)
  {
    v28 = (unint64_t *)&v9->__shared_owners_;
    do
      v29 = __ldxr(v28);
    while (__stxr(v29 + 1, v28));
  }
  v94 = v4;
  v30 = qmi::MessageBase::findTlvValue((qmi::MessageBase *)v92);
  v82 = v31;
  v32 = v30;
  if (v30)
  {
    v95 = v30;
    memset(buf, 0, sizeof(buf));
    tlv::parseV<uim::tlv::ReadResult>(&v95, v31, buf);
    v81 = v95;
    if (v95)
    {
      v34 = v10 + 1;
      v33 = v10[1];
      if (v33)
      {
        while (1)
        {
          while (1)
          {
            v35 = (uint64_t **)v33;
            v36 = *((unsigned __int16 *)v33 + 16);
            if (v36 <= v4)
              break;
            v33 = *v35;
            v34 = v35;
            if (!*v35)
              goto LABEL_87;
          }
          if (v36 >= v4)
            break;
          v33 = v35[1];
          if (!v33)
          {
            v34 = v35 + 1;
            goto LABEL_87;
          }
        }
        v75 = v35;
      }
      else
      {
        v35 = v10 + 1;
LABEL_87:
        v75 = operator new(0x40uLL);
        v75[16] = v4;
        *((_QWORD *)v75 + 6) = 0;
        *((_QWORD *)v75 + 7) = 0;
        *((_QWORD *)v75 + 5) = 0;
        *(_QWORD *)v75 = 0;
        *((_QWORD *)v75 + 1) = 0;
        *((_QWORD *)v75 + 2) = v35;
        *v34 = (uint64_t *)v75;
        v76 = (uint64_t *)**v10;
        v77 = (uint64_t *)v75;
        if (v76)
        {
          *v10 = v76;
          v77 = *v34;
        }
        std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v10[1], v77);
        v10[2] = (uint64_t *)((char *)v10[2] + 1);
      }
      if (v75 + 20 != (_WORD *)buf)
        std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((_QWORD *)v75 + 5, *(char **)buf, *(char **)&buf[8], *(_QWORD *)&buf[8] - *(_QWORD *)buf);
    }
    if (*(_QWORD *)buf)
    {
      *(_QWORD *)&buf[8] = *(_QWORD *)buf;
      operator delete(*(void **)buf);
    }
    if (v81)
      LOBYTE(v32) = 1;
    else
      LOBYTE(v32) = ((uint64_t (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(LOWORD(v92[0]), 17, v32, v82);
  }
  v78 = v93;
  if (v93)
  {
    v79 = (unint64_t *)&v93->__shared_owners_;
    do
      v80 = __ldaxr(v79);
    while (__stlxr(v80 - 1, v79));
    if (!v80)
    {
      ((void (*)(std::__shared_weak_count *))v78->__on_zero_shared)(v78);
      std::__shared_weak_count::__release_weak(v78);
    }
  }
  if ((v32 & 1) == 0)
    __TUAssertTrigger();
  LOBYTE(v20) = 1;
  if (v9)
  {
LABEL_40:
    v39 = (unint64_t *)&v9->__shared_owners_;
    do
      v40 = __ldaxr(v39);
    while (__stlxr(v40 - 1, v39));
    if (!v40)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
LABEL_44:
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v92);
  if ((v20 & 1) != 0)
  {
    v41 = *(unsigned __int16 *)(a1 + 168);
    v42 = *(unsigned __int16 *)(a1 + 170);
    v43 = **(NSObject ***)(a1 + 160);
    v44 = os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT);
    if (v41 < v42)
    {
      v45 = v41 + 1;
      if (v44)
      {
        v46 = subscriber::asString();
        v47 = *(unsigned __int16 *)(a1 + 80);
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = v46;
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v47;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v45;
        _os_log_impl(&dword_216897000, v43, OS_LOG_TYPE_DEFAULT, "#I There are more records for %s file 0x%04x. Sending read record for ID: %d", buf, 0x18u);
      }
      v86 = *(_WORD *)(a1 + 80);
      v88 = 0;
      v89 = 0;
      __p = 0;
      std::vector<unsigned short>::__init_with_size[abi:ne180100]<unsigned short *,unsigned short *>(&__p, *(const void **)(a1 + 88), *(_QWORD *)(a1 + 96), (uint64_t)(*(_QWORD *)(a1 + 96) - *(_QWORD *)(a1 + 88)) >> 1);
      v48 = *(unsigned __int16 *)(a1 + 170);
      std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100]((uint64_t)v96, a1 + 112);
      v49 = *(_QWORD *)(a1 + 144);
      v50 = *(std::__shared_weak_count **)(a1 + 152);
      v85[0] = v49;
      v85[1] = v50;
      if (v50)
      {
        v51 = (unint64_t *)&v50->__shared_owners_;
        do
          v52 = __ldxr(v51);
        while (__stxr(v52 + 1, v51));
      }
      subscriber::EURSimCommandDriver::readRecordInFile(v3, v13, &v86, (unsigned __int16)v45, v48, v96, v85);
      if (v50)
      {
        v53 = (unint64_t *)&v50->__shared_owners_;
        do
          v54 = __ldaxr(v53);
        while (__stlxr(v54 - 1, v53));
        if (!v54)
        {
          ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
          std::__shared_weak_count::__release_weak(v50);
        }
      }
      v55 = v97;
      if (v97 == v96)
      {
        v56 = 4;
        v55 = v96;
      }
      else
      {
        if (!v97)
        {
LABEL_82:
          v74 = __p;
          if (!__p)
            return;
          v88 = __p;
          goto LABEL_84;
        }
        v56 = 5;
      }
      (*(void (**)(void))(*v55 + 8 * v56))();
      goto LABEL_82;
    }
    if (v44)
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_216897000, v43, OS_LOG_TYPE_DEFAULT, "#I All records have been collected, assembling now", buf, 2u);
    }
    memset(buf, 0, sizeof(buf));
    v60 = *(_QWORD **)(a1 + 144);
    v63 = (_QWORD *)*v60;
    v61 = v60 + 1;
    v62 = v63;
    if (v63 == v61)
    {
      v67 = 0;
      v68 = 0;
    }
    else
    {
      do
      {
        std::vector<unsigned char>::__insert_with_size[abi:ne180100]<std::__wrap_iter<unsigned char *>,std::__wrap_iter<unsigned char *>>((uint64_t)buf, *(char **)&buf[8], (char *)v62[5], (char *)v62[6], v62[6] - v62[5]);
        v64 = (_QWORD *)v62[1];
        if (v64)
        {
          do
          {
            v65 = v64;
            v64 = (_QWORD *)*v64;
          }
          while (v64);
        }
        else
        {
          do
          {
            v65 = (_QWORD *)v62[2];
            v66 = *v65 == (_QWORD)v62;
            v62 = v65;
          }
          while (!v66);
        }
        v62 = v65;
      }
      while (v65 != v61);
      v68 = *(const void **)buf;
      v67 = *(_QWORD *)&buf[8];
    }
    v69 = (std::__shared_weak_count *)operator new(0x30uLL);
    v69->__shared_owners_ = 0;
    v69->__shared_weak_owners_ = 0;
    v69->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5DBF38;
    v69[1].__vftable = 0;
    v69[1].__shared_owners_ = 0;
    v69[1].__shared_weak_owners_ = 0;
    std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(&v69[1].__vftable, v68, v67, v67 - (_QWORD)v68);
    v83 = &v69[1].__vftable;
    v84 = v69;
    v70 = *(_QWORD *)(a1 + 136);
    if (!v70)
      std::__throw_bad_function_call[abi:ne180100]();
    (*(void (**)(uint64_t, _QWORD **))(*(_QWORD *)v70 + 48))(v70, &v83);
    v71 = v84;
    if (v84)
    {
      v72 = (unint64_t *)&v84->__shared_owners_;
      do
        v73 = __ldaxr(v72);
      while (__stlxr(v73 - 1, v72));
      if (!v73)
      {
        ((void (*)(std::__shared_weak_count *))v71->__on_zero_shared)(v71);
        std::__shared_weak_count::__release_weak(v71);
      }
    }
    v74 = *(void **)buf;
    if (*(_QWORD *)buf)
    {
      *(_QWORD *)&buf[8] = *(_QWORD *)buf;
LABEL_84:
      operator delete(v74);
    }
  }
  else
  {
    v57 = **(NSObject ***)(a1 + 160);
    if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR))
    {
      v58 = subscriber::asString();
      v59 = *(unsigned __int16 *)(a1 + 80);
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = v58;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v59;
      _os_log_error_impl(&dword_216897000, v57, OS_LOG_TYPE_ERROR, "Not continuing to read record for %s file 0x%04x. File Data Error has been sent out", buf, 0x12u);
    }
  }
}

void sub_2169DAC6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  uint64_t v12;
  void *v14;
  uint64_t v15;
  va_list va;
  uint64_t v17;
  uint64_t v18;
  va_list va1;
  uint64_t v20;
  uint64_t v21;
  va_list va2;

  va_start(va2, a12);
  va_start(va1, a12);
  va_start(va, a12);
  v15 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v18 = va_arg(va2, _QWORD);
  v20 = va_arg(va2, _QWORD);
  v21 = va_arg(va2, _QWORD);
  v14 = *(void **)(v12 - 144);
  if (v14)
  {
    *(_QWORD *)(v12 - 136) = v14;
    operator delete(v14);
  }
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va2);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va1);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_40c32_ZTSKN10subscriber11SimCardInfoE80c25_ZTSN10subscriber6FileIdE112c75_ZTSNSt3__18functionIFvNS_10shared_ptrINS_6vectorIhNS_9allocatorIhEEEEEEEEE144c103_ZTSNSt3__110shared_ptrINS_3mapItNS_6vectorIhNS_9allocatorIhEEEENS_4lessItEENS3_INS_4pairIKtS5_EEEEEEEE(uint64_t a1, uint64_t a2)
{
  __int128 v4;
  __int16 v5;
  uint64_t result;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;

  v4 = *(_OWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 56) = 0;
  *(_OWORD *)(a1 + 40) = v4;
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>((_QWORD *)(a1 + 56), *(const void **)(a2 + 56), *(_QWORD *)(a2 + 64), *(_QWORD *)(a2 + 64) - *(_QWORD *)(a2 + 56));
  v5 = *(_WORD *)(a2 + 80);
  *(_QWORD *)(a1 + 88) = 0;
  *(_WORD *)(a1 + 80) = v5;
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 104) = 0;
  std::vector<unsigned short>::__init_with_size[abi:ne180100]<unsigned short *,unsigned short *>((_QWORD *)(a1 + 88), *(const void **)(a2 + 88), *(_QWORD *)(a2 + 96), (uint64_t)(*(_QWORD *)(a2 + 96) - *(_QWORD *)(a2 + 88)) >> 1);
  result = std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100](a1 + 112, a2 + 112);
  v7 = *(_QWORD *)(a2 + 152);
  *(_QWORD *)(a1 + 144) = *(_QWORD *)(a2 + 144);
  *(_QWORD *)(a1 + 152) = v7;
  if (v7)
  {
    v8 = (unint64_t *)(v7 + 8);
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  return result;
}

void sub_2169DAE08(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void **v3;
  void *v5;
  void *v6;

  v5 = *v3;
  if (*v3)
  {
    *(_QWORD *)(v1 + 96) = v5;
    operator delete(v5);
  }
  v6 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 64) = v6;
    operator delete(v6);
  }
  _Unwind_Resume(exception_object);
}

void __destroy_helper_block_e8_40c32_ZTSKN10subscriber11SimCardInfoE80c25_ZTSN10subscriber6FileIdE112c75_ZTSNSt3__18functionIFvNS_10shared_ptrINS_6vectorIhNS_9allocatorIhEEEEEEEEE144c103_ZTSNSt3__110shared_ptrINS_3mapItNS_6vectorIhNS_9allocatorIhEEEENS_4lessItEENS3_INS_4pairIKtS5_EEEEEEEE(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  void *v5;
  void *v6;

  v2 = a1 + 14;
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)(a1 + 18));
  v3 = (_QWORD *)a1[17];
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
  v5 = (void *)a1[11];
  if (v5)
  {
    a1[12] = v5;
    operator delete(v5);
  }
  v6 = (void *)a1[7];
  if (v6)
  {
    a1[8] = v6;
    operator delete(v6);
  }
}

void subscriber::EURSimCommandDriver::authenticate(uint64_t a1, char **a2, int a3, uint64_t **a4, uint64_t a5)
{
  os_log_t *v10;
  os_log_t *v11;
  unsigned int v12;
  uint64_t **v13;
  int v14;
  unsigned int v15;
  NSObject *v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  NSObject *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t **v24;
  int v25;
  uint64_t **v26;
  int v27;
  uint64_t **v28;
  uint64_t **v29;
  int v30;
  uint64_t **v31;
  uint64_t **v32;
  int v33;
  uint64_t **v34;
  uint64_t **v35;
  int v36;
  uint64_t v37;
  int64_t v38;
  unint64_t v39;
  size_t v40;
  _BYTE *v41;
  uint64_t v42;
  int64_t v43;
  unint64_t v44;
  size_t v45;
  _BYTE *v46;
  uint64_t v47;
  int64_t v48;
  unint64_t v49;
  size_t v50;
  _BYTE *v51;
  uint64_t v52;
  int64_t v53;
  unint64_t v54;
  size_t v55;
  _BYTE *v56;
  uint64_t v57;
  int64_t v58;
  unint64_t v59;
  size_t v60;
  _BYTE *v61;
  char *v62;
  char *v63;
  char *v64;
  uint64_t **v65;
  int v66;
  char *v67;
  char *v68;
  char *v69;
  uint64_t v70;
  int64_t v71;
  unint64_t v72;
  size_t v73;
  void *v74;
  char *v75;
  char *v76;
  char v77;
  char *v78;
  char *v79;
  char *v80;
  char *v81;
  char *v82;
  uint64_t **v83;
  int v84;
  char *v85;
  char *v86;
  char *v87;
  uint64_t v88;
  int64_t v89;
  unint64_t v90;
  size_t v91;
  void *v92;
  char *v93;
  uint64_t **v94;
  int v95;
  char *v96;
  char *v97;
  char *v98;
  uint64_t v99;
  int64_t v100;
  unint64_t v101;
  size_t v102;
  void *v103;
  char *v104;
  char *v105;
  char v106;
  char *v107;
  char *v108;
  char v109;
  char *v110;
  unsigned int *v111;
  uint64_t v112;
  const void **v113;
  char *v114;
  char *v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  _QWORD *v119;
  uint64_t v120;
  unint64_t v121;
  unint64_t v122;
  char *v123;
  uint64_t *v124;
  char *v125;
  char *v126;
  char *v127;
  uint64_t v128;
  _QWORD *v129;
  void *v130;
  uint64_t v131;
  uint64_t **v132;
  uint64_t **v133;
  uint64_t **v134;
  uint64_t v135;
  void *aBlock;
  __int128 v137;
  void *v138;
  _BYTE *v139;
  uint64_t v140;
  _QWORD v141[2];
  void (*v142)(_QWORD *, char *);
  void *v143;
  void *v144;
  void *v145;
  uint64_t v146;
  int v147;
  __int128 v148;
  __int128 v149;
  _QWORD **v150;
  _QWORD *v151[2];
  void *__p;
  char *v153;
  unint64_t v154;
  _QWORD v155[6];
  __int128 v156;
  void *v157;
  void *v158;
  uint64_t v159;
  _BYTE v160[24];
  _BYTE *v161;
  int v162;
  _BYTE buf[24];
  void *v164;
  _QWORD *v165;
  uint64_t v166;

  v166 = *MEMORY[0x24BDAC8D0];
  v10 = (os_log_t *)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 48) + 16))(*(_QWORD *)(a1 + 48), *(unsigned int *)a2);
  v11 = v10;
  __p = 0;
  v153 = 0;
  v154 = 0;
  switch(a3)
  {
    case 1:
      v12 = *((_DWORD *)a2 + 3);
      if (v12 == 2)
      {
        *(_DWORD *)buf = 0;
        v24 = std::__tree<std::__value_type<subscriber::AuthInfo,std::vector<unsigned char>>,std::__map_value_compare<subscriber::AuthInfo,std::__value_type<subscriber::AuthInfo,std::vector<unsigned char>>,std::less<subscriber::AuthInfo>,true>,std::allocator<std::__value_type<subscriber::AuthInfo,std::vector<unsigned char>>>>::__emplace_unique_key_args<subscriber::AuthInfo,std::piecewise_construct_t const&,std::tuple<subscriber::AuthInfo&&>,std::tuple<>>(a4, 0, buf);
        v25 = *((_DWORD *)v24 + 12) - *((_DWORD *)v24 + 10);
        v37 = v153 - (_BYTE *)__p;
        v38 = v153 - (_BYTE *)__p + 1;
        if (v38 < 0)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v39 = v154 - (_QWORD)__p;
        if (2 * (v154 - (unint64_t)__p) > v38)
          v38 = 2 * v39;
        if (v39 >= 0x3FFFFFFFFFFFFFFFLL)
          v40 = 0x7FFFFFFFFFFFFFFFLL;
        else
          v40 = v38;
        if (v40)
          v41 = operator new(v40);
        else
          v41 = 0;
        v41[v37] = v25;
        __p = &v41[v37];
        v154 = (unint64_t)&v41[v40];
        v153 = &v41[v37 + 1];
        std::vector<unsigned char>::__insert_with_size[abi:ne180100]<std::__wrap_iter<unsigned char *>,std::__wrap_iter<unsigned char *>>((uint64_t)&__p, v153, (char *)v24[5], (char *)v24[6], (char *)v24[6] - (char *)v24[5]);
        v14 = 2;
      }
      else
      {
        if (v12 != 1)
          goto LABEL_20;
        *(_DWORD *)buf = 0;
        v13 = std::__tree<std::__value_type<subscriber::AuthInfo,std::vector<unsigned char>>,std::__map_value_compare<subscriber::AuthInfo,std::__value_type<subscriber::AuthInfo,std::vector<unsigned char>>,std::less<subscriber::AuthInfo>,true>,std::allocator<std::__value_type<subscriber::AuthInfo,std::vector<unsigned char>>>>::__emplace_unique_key_args<subscriber::AuthInfo,std::piecewise_construct_t const&,std::tuple<subscriber::AuthInfo&&>,std::tuple<>>(a4, 0, buf);
        if (&__p != (void **)(v13 + 5))
          std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(&__p, (char *)v13[5], (char *)v13[6], (char *)v13[6] - (char *)v13[5]);
        v14 = 0;
      }
      goto LABEL_138;
    case 2:
      v19 = *((_DWORD *)a2 + 3);
      if (v19 > 5)
        goto LABEL_20;
      if (((1 << v19) & 0x33) == 0)
      {
        *(_DWORD *)buf = 0;
        v34 = std::__tree<std::__value_type<subscriber::AuthInfo,std::vector<unsigned char>>,std::__map_value_compare<subscriber::AuthInfo,std::__value_type<subscriber::AuthInfo,std::vector<unsigned char>>,std::less<subscriber::AuthInfo>,true>,std::allocator<std::__value_type<subscriber::AuthInfo,std::vector<unsigned char>>>>::__emplace_unique_key_args<subscriber::AuthInfo,std::piecewise_construct_t const&,std::tuple<subscriber::AuthInfo&&>,std::tuple<>>(a4, 0, buf);
        *(_DWORD *)buf = 1;
        v35 = std::__tree<std::__value_type<subscriber::AuthInfo,std::vector<unsigned char>>,std::__map_value_compare<subscriber::AuthInfo,std::__value_type<subscriber::AuthInfo,std::vector<unsigned char>>,std::less<subscriber::AuthInfo>,true>,std::allocator<std::__value_type<subscriber::AuthInfo,std::vector<unsigned char>>>>::__emplace_unique_key_args<subscriber::AuthInfo,std::piecewise_construct_t const&,std::tuple<subscriber::AuthInfo&&>,std::tuple<>>(a4, 1, buf);
        v36 = *((_DWORD *)v34 + 12) - *((_DWORD *)v34 + 10);
        v134 = v35;
        v42 = v153 - (_BYTE *)__p;
        v43 = v153 - (_BYTE *)__p + 1;
        if (v43 < 0)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v44 = v154 - (_QWORD)__p;
        if (2 * (v154 - (unint64_t)__p) > v43)
          v43 = 2 * v44;
        if (v44 >= 0x3FFFFFFFFFFFFFFFLL)
          v45 = 0x7FFFFFFFFFFFFFFFLL;
        else
          v45 = v43;
        if (v45)
          v46 = operator new(v45);
        else
          v46 = 0;
        v62 = &v46[v45];
        v46[v42] = v36;
        v63 = &v46[v42 + 1];
        v64 = &v46[v42];
        v65 = v134;
        __p = v64;
        v154 = (unint64_t)v62;
        v153 = v63;
        std::vector<unsigned char>::__insert_with_size[abi:ne180100]<std::__wrap_iter<unsigned char *>,std::__wrap_iter<unsigned char *>>((uint64_t)&__p, v63, (char *)v34[5], (char *)v34[6], (char *)v34[6] - (char *)v34[5]);
        v66 = *((_DWORD *)v65 + 12) - *((_DWORD *)v65 + 10);
        v67 = v153;
        if ((unint64_t)v153 >= v154)
        {
          v69 = (char *)__p;
          v70 = v153 - (_BYTE *)__p;
          v71 = v153 - (_BYTE *)__p + 1;
          if (v71 < 0)
            std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
          v72 = v154 - (_QWORD)__p;
          if (2 * (v154 - (unint64_t)__p) > v71)
            v71 = 2 * v72;
          if (v72 >= 0x3FFFFFFFFFFFFFFFLL)
            v73 = 0x7FFFFFFFFFFFFFFFLL;
          else
            v73 = v71;
          if (v73)
            v74 = operator new(v73);
          else
            v74 = 0;
          v75 = (char *)v74 + v73;
          *((_BYTE *)v74 + v70) = v66;
          v68 = (char *)v74 + v70 + 1;
          if (v67 == v69)
          {
            v74 = (char *)v74 + v70;
            v65 = v134;
          }
          else
          {
            v76 = &v67[~(unint64_t)v69];
            v65 = v134;
            do
            {
              v77 = *--v67;
              (v76--)[(_QWORD)v74] = v77;
            }
            while (v67 != v69);
            v67 = (char *)__p;
          }
          __p = v74;
          v153 = v68;
          v154 = (unint64_t)v75;
          if (v67)
            operator delete(v67);
        }
        else
        {
          *v153 = v66;
          v68 = v67 + 1;
        }
        v153 = v68;
        std::vector<unsigned char>::__insert_with_size[abi:ne180100]<std::__wrap_iter<unsigned char *>,std::__wrap_iter<unsigned char *>>((uint64_t)&__p, v68, (char *)v65[5], (char *)v65[6], (char *)v65[6] - (char *)v65[5]);
        v14 = 3;
        goto LABEL_138;
      }
      v16 = *v10;
      if (!os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
        goto LABEL_20;
      goto LABEL_19;
    case 3:
      v17 = *((_DWORD *)a2 + 3);
      if (v17 < 5)
      {
        v16 = *v10;
        if (!os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
          goto LABEL_20;
        goto LABEL_19;
      }
      if (v17 != 5)
        goto LABEL_20;
      *(_DWORD *)buf = 0;
      v28 = std::__tree<std::__value_type<subscriber::AuthInfo,std::vector<unsigned char>>,std::__map_value_compare<subscriber::AuthInfo,std::__value_type<subscriber::AuthInfo,std::vector<unsigned char>>,std::less<subscriber::AuthInfo>,true>,std::allocator<std::__value_type<subscriber::AuthInfo,std::vector<unsigned char>>>>::__emplace_unique_key_args<subscriber::AuthInfo,std::piecewise_construct_t const&,std::tuple<subscriber::AuthInfo&&>,std::tuple<>>(a4, 0, buf);
      *(_DWORD *)buf = 1;
      v29 = std::__tree<std::__value_type<subscriber::AuthInfo,std::vector<unsigned char>>,std::__map_value_compare<subscriber::AuthInfo,std::__value_type<subscriber::AuthInfo,std::vector<unsigned char>>,std::less<subscriber::AuthInfo>,true>,std::allocator<std::__value_type<subscriber::AuthInfo,std::vector<unsigned char>>>>::__emplace_unique_key_args<subscriber::AuthInfo,std::piecewise_construct_t const&,std::tuple<subscriber::AuthInfo&&>,std::tuple<>>(a4, 1, buf);
      v30 = *((_DWORD *)v28 + 12) - *((_DWORD *)v28 + 10);
      v132 = v29;
      v52 = v153 - (_BYTE *)__p;
      v53 = v153 - (_BYTE *)__p + 1;
      if (v53 < 0)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v54 = v154 - (_QWORD)__p;
      if (2 * (v154 - (unint64_t)__p) > v53)
        v53 = 2 * v54;
      if (v54 >= 0x3FFFFFFFFFFFFFFFLL)
        v55 = 0x7FFFFFFFFFFFFFFFLL;
      else
        v55 = v53;
      if (v55)
        v56 = operator new(v55);
      else
        v56 = 0;
      v78 = &v56[v55];
      v56[v52] = v30;
      v79 = &v56[v52 + 1];
      v82 = &v56[v52];
      v83 = v132;
      __p = v82;
      v154 = (unint64_t)v78;
      v153 = v79;
      std::vector<unsigned char>::__insert_with_size[abi:ne180100]<std::__wrap_iter<unsigned char *>,std::__wrap_iter<unsigned char *>>((uint64_t)&__p, v79, (char *)v28[5], (char *)v28[6], (char *)v28[6] - (char *)v28[5]);
      v84 = *((_DWORD *)v132 + 12) - *((_DWORD *)v132 + 10);
      v85 = v153;
      if ((unint64_t)v153 >= v154)
      {
        v87 = (char *)__p;
        v88 = v153 - (_BYTE *)__p;
        v89 = v153 - (_BYTE *)__p + 1;
        if (v89 < 0)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v90 = v154 - (_QWORD)__p;
        if (2 * (v154 - (unint64_t)__p) > v89)
          v89 = 2 * v90;
        if (v90 >= 0x3FFFFFFFFFFFFFFFLL)
          v91 = 0x7FFFFFFFFFFFFFFFLL;
        else
          v91 = v89;
        if (v91)
          v92 = operator new(v91);
        else
          v92 = 0;
        v104 = (char *)v92 + v91;
        *((_BYTE *)v92 + v88) = v84;
        v86 = (char *)v92 + v88 + 1;
        if (v85 == v87)
        {
          v92 = (char *)v92 + v88;
          v83 = v132;
        }
        else
        {
          v105 = &v85[~(unint64_t)v87];
          v83 = v132;
          do
          {
            v106 = *--v85;
            (v105--)[(_QWORD)v92] = v106;
          }
          while (v85 != v87);
          v85 = (char *)__p;
        }
        __p = v92;
        v153 = v86;
        v154 = (unint64_t)v104;
        if (v85)
          operator delete(v85);
      }
      else
      {
        *v153 = v84;
        v86 = v85 + 1;
      }
      v153 = v86;
      std::vector<unsigned char>::__insert_with_size[abi:ne180100]<std::__wrap_iter<unsigned char *>,std::__wrap_iter<unsigned char *>>((uint64_t)&__p, v86, (char *)v83[5], (char *)v83[6], (char *)v83[6] - (char *)v83[5]);
      v14 = 11;
      goto LABEL_138;
    case 4:
      v18 = *((_DWORD *)a2 + 3);
      if (v18 < 5)
      {
        v16 = *v10;
        if (!os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
          goto LABEL_20;
        goto LABEL_19;
      }
      if (v18 != 5)
        goto LABEL_20;
      *(_DWORD *)buf = 0;
      v31 = std::__tree<std::__value_type<subscriber::AuthInfo,std::vector<unsigned char>>,std::__map_value_compare<subscriber::AuthInfo,std::__value_type<subscriber::AuthInfo,std::vector<unsigned char>>,std::less<subscriber::AuthInfo>,true>,std::allocator<std::__value_type<subscriber::AuthInfo,std::vector<unsigned char>>>>::__emplace_unique_key_args<subscriber::AuthInfo,std::piecewise_construct_t const&,std::tuple<subscriber::AuthInfo&&>,std::tuple<>>(a4, 0, buf);
      *(_DWORD *)buf = 1;
      v32 = std::__tree<std::__value_type<subscriber::AuthInfo,std::vector<unsigned char>>,std::__map_value_compare<subscriber::AuthInfo,std::__value_type<subscriber::AuthInfo,std::vector<unsigned char>>,std::less<subscriber::AuthInfo>,true>,std::allocator<std::__value_type<subscriber::AuthInfo,std::vector<unsigned char>>>>::__emplace_unique_key_args<subscriber::AuthInfo,std::piecewise_construct_t const&,std::tuple<subscriber::AuthInfo&&>,std::tuple<>>(a4, 1, buf);
      v33 = *((_DWORD *)v31 + 12) - *((_DWORD *)v31 + 10);
      v133 = v32;
      v57 = v153 - (_BYTE *)__p;
      v58 = v153 - (_BYTE *)__p + 1;
      if (v58 < 0)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v59 = v154 - (_QWORD)__p;
      if (2 * (v154 - (unint64_t)__p) > v58)
        v58 = 2 * v59;
      if (v59 >= 0x3FFFFFFFFFFFFFFFLL)
        v60 = 0x7FFFFFFFFFFFFFFFLL;
      else
        v60 = v58;
      if (v60)
        v61 = operator new(v60);
      else
        v61 = 0;
      v80 = &v61[v60];
      v61[v57] = v33;
      v81 = &v61[v57 + 1];
      v93 = &v61[v57];
      v94 = v133;
      __p = v93;
      v154 = (unint64_t)v80;
      v153 = v81;
      std::vector<unsigned char>::__insert_with_size[abi:ne180100]<std::__wrap_iter<unsigned char *>,std::__wrap_iter<unsigned char *>>((uint64_t)&__p, v81, (char *)v31[5], (char *)v31[6], (char *)v31[6] - (char *)v31[5]);
      v95 = *((_DWORD *)v133 + 12) - *((_DWORD *)v133 + 10);
      v96 = v153;
      if ((unint64_t)v153 >= v154)
      {
        v98 = (char *)__p;
        v99 = v153 - (_BYTE *)__p;
        v100 = v153 - (_BYTE *)__p + 1;
        if (v100 < 0)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v101 = v154 - (_QWORD)__p;
        if (2 * (v154 - (unint64_t)__p) > v100)
          v100 = 2 * v101;
        if (v101 >= 0x3FFFFFFFFFFFFFFFLL)
          v102 = 0x7FFFFFFFFFFFFFFFLL;
        else
          v102 = v100;
        if (v102)
          v103 = operator new(v102);
        else
          v103 = 0;
        v107 = (char *)v103 + v102;
        *((_BYTE *)v103 + v99) = v95;
        v97 = (char *)v103 + v99 + 1;
        if (v96 == v98)
        {
          v103 = (char *)v103 + v99;
          v94 = v133;
        }
        else
        {
          v108 = &v96[~(unint64_t)v98];
          v94 = v133;
          do
          {
            v109 = *--v96;
            (v108--)[(_QWORD)v103] = v109;
          }
          while (v96 != v98);
          v96 = (char *)__p;
        }
        __p = v103;
        v153 = v97;
        v154 = (unint64_t)v107;
        if (v96)
          operator delete(v96);
      }
      else
      {
        *v153 = v95;
        v97 = v96 + 1;
      }
      v153 = v97;
      std::vector<unsigned char>::__insert_with_size[abi:ne180100]<std::__wrap_iter<unsigned char *>,std::__wrap_iter<unsigned char *>>((uint64_t)&__p, v97, (char *)v94[5], (char *)v94[6], (char *)v94[6] - (char *)v94[5]);
      v14 = 5;
      goto LABEL_138;
    case 5:
      v15 = *((_DWORD *)a2 + 3);
      if (v15 < 5)
      {
        v16 = *v10;
        if (os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
        {
LABEL_19:
          *(_DWORD *)buf = 136315138;
          *(_QWORD *)&buf[4] = subscriber::asString();
          _os_log_impl(&dword_216897000, v16, OS_LOG_TYPE_DEFAULT, "#N SIM authenticate fails because SIM type=%s", buf, 0xCu);
        }
        goto LABEL_20;
      }
      if (v15 == 5)
      {
        *(_DWORD *)buf = 2;
        v26 = std::__tree<std::__value_type<subscriber::AuthInfo,std::vector<unsigned char>>,std::__map_value_compare<subscriber::AuthInfo,std::__value_type<subscriber::AuthInfo,std::vector<unsigned char>>,std::less<subscriber::AuthInfo>,true>,std::allocator<std::__value_type<subscriber::AuthInfo,std::vector<unsigned char>>>>::__emplace_unique_key_args<subscriber::AuthInfo,std::piecewise_construct_t const&,std::tuple<subscriber::AuthInfo&&>,std::tuple<>>(a4, 2, buf);
        v27 = *((_DWORD *)v26 + 12) - *((_DWORD *)v26 + 10);
        v47 = v153 - (_BYTE *)__p;
        v48 = v153 - (_BYTE *)__p + 1;
        if (v48 < 0)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v49 = v154 - (_QWORD)__p;
        if (2 * (v154 - (unint64_t)__p) > v48)
          v48 = 2 * v49;
        if (v49 >= 0x3FFFFFFFFFFFFFFFLL)
          v50 = 0x7FFFFFFFFFFFFFFFLL;
        else
          v50 = v48;
        if (v50)
          v51 = operator new(v50);
        else
          v51 = 0;
        v51[v47] = v27;
        __p = &v51[v47];
        v154 = (unint64_t)&v51[v50];
        v153 = &v51[v47 + 1];
        std::vector<unsigned char>::__insert_with_size[abi:ne180100]<std::__wrap_iter<unsigned char *>,std::__wrap_iter<unsigned char *>>((uint64_t)&__p, v153, (char *)v26[5], (char *)v26[6], (char *)v26[6] - (char *)v26[5]);
        v14 = 6;
LABEL_138:
        v148 = 0u;
        v149 = 0u;
        qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)&v148);
        v110 = qmi::MutableMessageBase::getTLV<uim::tlv::SessionInfo>(&v148);
        v111 = (unsigned int *)(v110 + 8);
        if (v111 != (unsigned int *)(a2 + 2))
          std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(v111, a2[2], a2[3], a2[3] - a2[2]);
        v112 = MEMORY[0x24BDAC760];
        v141[0] = MEMORY[0x24BDAC760];
        v141[1] = 1174405120;
        v142 = (void (*)(_QWORD *, char *))___ZN10subscriber19EURSimCommandDriver12authenticateERKNS_11SimCardInfoENS_8AuthTypeENSt3__13mapINS_8AuthInfoENS5_6vectorIhNS5_9allocatorIhEEEENS5_4lessIS7_EENS9_INS5_4pairIKS7_SB_EEEEEENS5_8functionIFvSI_EEE_block_invoke;
        v143 = &__block_descriptor_tmp_45_6;
        v147 = v14;
        v145 = 0;
        v146 = 0;
        v144 = 0;
        std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(&v144, __p, (uint64_t)v153, v153 - (_BYTE *)__p);
        v113 = (const void **)*((_QWORD *)&v148 + 1);
        if (*((_QWORD *)&v148 + 1) != (_QWORD)v149)
        {
          while (*((_BYTE *)*v113 + 8) != 2)
          {
            if (++v113 == (const void **)v149)
              goto LABEL_147;
          }
        }
        if (v113 == (const void **)v149)
        {
LABEL_147:
          v116 = operator new();
          v117 = v116;
          *(_BYTE *)(v116 + 8) = 2;
          *(_QWORD *)v116 = &off_24D5DC130;
          *(_DWORD *)(v116 + 16) = 0;
          v115 = (char *)(v116 + 16);
          *(_QWORD *)(v116 + 32) = 0;
          *(_QWORD *)(v116 + 40) = 0;
          *(_QWORD *)(v116 + 24) = 0;
          v118 = v149;
          if ((unint64_t)v149 >= *((_QWORD *)&v149 + 1))
          {
            v120 = (uint64_t)(v149 - *((_QWORD *)&v148 + 1)) >> 3;
            if ((unint64_t)(v120 + 1) >> 61)
              std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
            v121 = (uint64_t)(*((_QWORD *)&v149 + 1) - *((_QWORD *)&v148 + 1)) >> 2;
            if (v121 <= v120 + 1)
              v121 = v120 + 1;
            if (*((_QWORD *)&v149 + 1) - *((_QWORD *)&v148 + 1) >= 0x7FFFFFFFFFFFFFF8uLL)
              v122 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v122 = v121;
            if (v122)
              v123 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v149 + 8, v122);
            else
              v123 = 0;
            v124 = (uint64_t *)&v123[8 * v120];
            v125 = &v123[8 * v122];
            *v124 = v117;
            v119 = v124 + 1;
            v127 = (char *)*((_QWORD *)&v148 + 1);
            v126 = (char *)v149;
            if ((_QWORD)v149 != *((_QWORD *)&v148 + 1))
            {
              do
              {
                v128 = *((_QWORD *)v126 - 1);
                v126 -= 8;
                *--v124 = v128;
              }
              while (v126 != v127);
              v126 = (char *)*((_QWORD *)&v148 + 1);
            }
            *((_QWORD *)&v148 + 1) = v124;
            *(_QWORD *)&v149 = v119;
            *((_QWORD *)&v149 + 1) = v125;
            if (v126)
              operator delete(v126);
          }
          else
          {
            *(_QWORD *)v149 = v116;
            v119 = (_QWORD *)(v118 + 8);
          }
          *(_QWORD *)&v149 = v119;
        }
        else
        {
          if (!v114)
            __cxa_bad_cast();
          v115 = v114 + 16;
        }
        v142(v141, v115);
        v137 = *(_OWORD *)a2;
        v139 = 0;
        v140 = 0;
        v138 = 0;
        std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(&v138, a2[2], (uint64_t)a2[3], a2[3] - a2[2]);
        v135 = QMIServiceMsg::create();
        v155[0] = v112;
        v155[1] = 1174405120;
        v155[2] = ___ZN10subscriber19EURSimCommandDriver12authenticateERKNS_11SimCardInfoENS_8AuthTypeENSt3__13mapINS_8AuthInfoENS5_6vectorIhNS5_9allocatorIhEEEENS5_4lessIS7_EENS9_INS5_4pairIKS7_SB_EEEEEENS5_8functionIFvSI_EEE_block_invoke_46;
        v155[3] = &__block_descriptor_tmp_49_5;
        v155[4] = a1;
        v155[5] = v11;
        v162 = v14;
        v156 = v137;
        v158 = 0;
        v159 = 0;
        v157 = 0;
        std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(&v157, v138, (uint64_t)v139, v139 - (_BYTE *)v138);
        v129 = v160;
        std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100]((uint64_t)v160, a5);
        *(_QWORD *)buf = v112;
        *(_QWORD *)&buf[8] = 0x40000000;
        *(_QWORD *)&buf[16] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3uim12Authenticate8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
        v164 = &unk_24D5DC160;
        v165 = v155;
        v130 = _Block_copy(buf);
        aBlock = v130;
        if (v135)
        {
          qmi::Client::send();
          v130 = aBlock;
        }
        if (v130)
          _Block_release(v130);
        if (v161 == v160)
        {
          v131 = 4;
        }
        else
        {
          if (!v161)
          {
LABEL_173:
            if (v157)
            {
              v158 = v157;
              operator delete(v157);
            }
            if (v138)
            {
              v139 = v138;
              operator delete(v138);
            }
            if (v144)
            {
              v145 = v144;
              operator delete(v144);
            }
            qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&v148);
            goto LABEL_180;
          }
          v131 = 5;
          v129 = v161;
        }
        (*(void (**)(_QWORD *))(*v129 + 8 * v131))(v129);
        goto LABEL_173;
      }
LABEL_20:
      v20 = *v11;
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        v21 = subscriber::asString();
        v22 = subscriber::asString();
        *(_DWORD *)buf = 136315394;
        *(_QWORD *)&buf[4] = v21;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = v22;
        _os_log_impl(&dword_216897000, v20, OS_LOG_TYPE_DEFAULT, "#N SIM authenticate type %s fails because SIM type=%s", buf, 0x16u);
      }
      v151[0] = 0;
      v151[1] = 0;
      v150 = v151;
      v23 = *(_QWORD *)(a5 + 24);
      if (!v23)
        std::__throw_bad_function_call[abi:ne180100]();
      (*(void (**)(uint64_t, _QWORD ***))(*(_QWORD *)v23 + 48))(v23, &v150);
      std::__tree<std::__value_type<unsigned int,std::vector<unsigned char>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<unsigned char>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::vector<unsigned char>>>>::destroy(v151[0]);
LABEL_180:
      if (__p)
      {
        v153 = (char *)__p;
        operator delete(__p);
      }
      return;
    default:
      goto LABEL_20;
  }
}

void sub_2169DBDA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,void *__p,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,void *a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *__copy_helper_block_e8_32c39_ZTSNSt3__16vectorIhNS_9allocatorIhEEEE(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  v2 = (_QWORD *)(a1 + 32);
  v2[2] = 0;
  return std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(v2, *(const void **)(a2 + 32), *(_QWORD *)(a2 + 40), *(_QWORD *)(a2 + 40) - *(_QWORD *)(a2 + 32));
}

void __destroy_helper_block_e8_32c39_ZTSNSt3__16vectorIhNS_9allocatorIhEEEE(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 32);
  if (v2)
  {
    *(_QWORD *)(a1 + 40) = v2;
    operator delete(v2);
  }
}

void ___ZN10subscriber19EURSimCommandDriver12authenticateERKNS_11SimCardInfoENS_8AuthTypeENSt3__13mapINS_8AuthInfoENS5_6vectorIhNS5_9allocatorIhEEEENS5_4lessIS7_EENS9_INS5_4pairIKS7_SB_EEEEEENS5_8functionIFvSI_EEE_block_invoke_46(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v4;
  int v5;
  const void *v6;
  uint64_t v7;
  uint64_t TlvValue;
  int v9;
  uint64_t v10;
  int v11;
  unint64_t v12;
  NSObject *v13;
  uint64_t v14;
  NSObject *v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t *v18;
  uint64_t *v19;
  uint64_t **v20;
  uint64_t **v21;
  uint64_t *v22;
  uint64_t **v23;
  BOOL v24;
  int v25;
  uint64_t **v26;
  uint64_t **v27;
  uint64_t *v28;
  int v29;
  _QWORD *v30;
  int v31;
  uint64_t *v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t **v35;
  uint64_t *v36;
  uint64_t v37;
  _QWORD v38[2];
  void (*v39)(uint64_t);
  void *v40;
  uint64_t *v41;
  uint64_t v42;
  uint64_t v43;
  __int128 v44;
  void *__p;
  void *v46;
  uint64_t v47;
  int v48;
  uint64_t v49;
  uint64_t *v50;
  uint64_t v51;
  _QWORD *(*v52)(_QWORD *, _QWORD *);
  void (*v53)(uint64_t);
  _QWORD **v54;
  _QWORD *v55[2];
  unint64_t v56;
  uint8_t buf[24];
  uint64_t v58;

  v58 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)(a1 + 32);
  v49 = 0;
  v50 = &v49;
  v51 = 0x4002000000;
  v52 = __Block_byref_object_copy__6;
  v53 = __Block_byref_object_dispose__6;
  v55[0] = 0;
  v55[1] = 0;
  v54 = v55;
  v5 = *((_DWORD *)a2 + 1);
  if (v5 && v5 != 34)
  {
    v15 = **(NSObject ***)(a1 + 40);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      v16 = qmi::asString();
      *(_DWORD *)buf = 67109378;
      *(_DWORD *)&buf[4] = v5;
      *(_WORD *)&buf[8] = 2080;
      *(_QWORD *)&buf[10] = v16;
      _os_log_impl(&dword_216897000, v15, OS_LOG_TYPE_DEFAULT, "#N SIM authenticate fails due to error 0x%04x (%s)", buf, 0x12u);
    }
  }
  else
  {
    v38[0] = MEMORY[0x24BDAC760];
    v38[1] = 1174405120;
    v39 = ___ZN10subscriber19EURSimCommandDriver12authenticateERKNS_11SimCardInfoENS_8AuthTypeENSt3__13mapINS_8AuthInfoENS5_6vectorIhNS5_9allocatorIhEEEENS5_4lessIS7_EENS9_INS5_4pairIKS7_SB_EEEEEENS5_8functionIFvSI_EEE_block_invoke_47;
    v40 = &unk_24D5DB120;
    v48 = *(_DWORD *)(a1 + 120);
    v41 = &v49;
    v42 = v4;
    v43 = *(_QWORD *)(a1 + 40);
    v44 = *(_OWORD *)(a1 + 48);
    v46 = 0;
    v47 = 0;
    v6 = *(const void **)(a1 + 64);
    v7 = *(_QWORD *)(a1 + 72);
    __p = 0;
    std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(&__p, v6, v7, v7 - (_QWORD)v6);
    TlvValue = qmi::MessageBase::findTlvValue(a2);
    v10 = TlvValue;
    if (!TlvValue)
      goto LABEL_10;
    v11 = v9;
    v56 = TlvValue;
    memset(buf, 0, sizeof(buf));
    tlv::parseV<uim::tlv::AuthResult>(&v56, v9, buf);
    v12 = v56;
    if (v56)
      ((void (*)(_QWORD *, uint8_t *))v39)(v38, buf);
    if (*(_QWORD *)buf)
    {
      *(_QWORD *)&buf[8] = *(_QWORD *)buf;
      operator delete(*(void **)buf);
    }
    if (!v12
      && (((uint64_t (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 17, v10, v11) & 1) == 0)
    {
LABEL_10:
      v13 = **(NSObject ***)(a1 + 40);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        v14 = subscriber::asString();
        *(_DWORD *)buf = 136315138;
        *(_QWORD *)&buf[4] = v14;
        _os_log_impl(&dword_216897000, v13, OS_LOG_TYPE_DEFAULT, "#I SIM authenticate success but no data for card %s", buf, 0xCu);
      }
    }
    if (__p)
    {
      v46 = __p;
      operator delete(__p);
    }
  }
  v36 = 0;
  v37 = 0;
  v35 = &v36;
  v17 = (uint64_t *)v50[5];
  v18 = v50 + 6;
  if (v17 != v50 + 6)
  {
    v19 = 0;
    v20 = &v36;
    while (1)
    {
      v21 = &v36;
      if (v20 == &v36)
        break;
      v22 = v19;
      v23 = &v36;
      if (v19)
      {
        do
        {
          v21 = (uint64_t **)v22;
          v22 = (uint64_t *)v22[1];
        }
        while (v22);
      }
      else
      {
        do
        {
          v21 = (uint64_t **)v23[2];
          v24 = *v21 == (uint64_t *)v23;
          v23 = v21;
        }
        while (v24);
      }
      v25 = *((_DWORD *)v17 + 8);
      if (*((_DWORD *)v21 + 8) < v25)
        break;
      v27 = &v36;
      v26 = &v36;
      if (!v19)
        goto LABEL_40;
      v28 = v19;
      while (1)
      {
        while (1)
        {
          v26 = (uint64_t **)v28;
          v29 = *((_DWORD *)v28 + 8);
          if (v29 <= v25)
            break;
          v28 = *v26;
          v27 = v26;
          if (!*v26)
            goto LABEL_40;
        }
        if (v29 >= v25)
          break;
        v28 = v26[1];
        if (!v28)
        {
          v27 = v26 + 1;
          goto LABEL_40;
        }
      }
LABEL_43:
      v32 = (uint64_t *)v17[1];
      if (v32)
      {
        do
        {
          v33 = v32;
          v32 = (uint64_t *)*v32;
        }
        while (v32);
      }
      else
      {
        do
        {
          v33 = (uint64_t *)v17[2];
          v24 = *v33 == (_QWORD)v17;
          v17 = v33;
        }
        while (!v24);
      }
      if (v33 == v18)
        goto LABEL_50;
      v20 = v35;
      v19 = v36;
      v17 = v33;
    }
    if (v19)
      v26 = v21;
    else
      v26 = &v36;
    if (v19)
    {
      v27 = v21 + 1;
    }
    else
    {
      v21 = (uint64_t **)&v35;
      v27 = &v36;
    }
    if (v21[1])
      goto LABEL_43;
LABEL_40:
    v30 = operator new(0x40uLL);
    v31 = *((_DWORD *)v17 + 8);
    v30[5] = 0;
    *((_DWORD *)v30 + 8) = v31;
    v30[6] = 0;
    v30[7] = 0;
    std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(v30 + 5, (const void *)v17[5], v17[6], v17[6] - v17[5]);
    *v30 = 0;
    v30[1] = 0;
    v30[2] = v26;
    *v27 = v30;
    if (*v35)
    {
      v35 = (uint64_t **)*v35;
      v30 = *v27;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v36, v30);
    ++v37;
    goto LABEL_43;
  }
LABEL_50:
  v34 = *(_QWORD *)(a1 + 112);
  if (!v34)
    std::__throw_bad_function_call[abi:ne180100]();
  (*(void (**)(uint64_t, uint64_t ***))(*(_QWORD *)v34 + 48))(v34, &v35);
  std::__tree<std::__value_type<unsigned int,std::vector<unsigned char>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<unsigned char>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::vector<unsigned char>>>>::destroy(v36);
  _Block_object_dispose(&v49, 8);
  std::__tree<std::__value_type<unsigned int,std::vector<unsigned char>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<unsigned char>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::vector<unsigned char>>>>::destroy(v55[0]);
}

void sub_2169DC378(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,_QWORD *a32)
{
  if (__p)
    operator delete(__p);
  _Block_object_dispose(&a26, 8);
  std::__tree<std::__value_type<unsigned int,std::vector<unsigned char>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<unsigned char>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::vector<unsigned char>>>>::destroy(a32);
  _Unwind_Resume(a1);
}

_QWORD *__Block_byref_object_copy__6(_QWORD *result, _QWORD *a2)
{
  _QWORD *v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;

  result[5] = a2[5];
  v2 = a2 + 6;
  v3 = a2[6];
  result[6] = v3;
  v4 = result + 6;
  v5 = a2[7];
  result[7] = v5;
  if (v5)
  {
    *(_QWORD *)(v3 + 16) = v4;
    a2[5] = v2;
    *v2 = 0;
    a2[7] = 0;
  }
  else
  {
    result[5] = v4;
  }
  return result;
}

void __Block_byref_object_dispose__6(uint64_t a1)
{
  std::__tree<std::__value_type<unsigned int,std::vector<unsigned char>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<unsigned char>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::vector<unsigned char>>>>::destroy(*(_QWORD **)(a1 + 48));
}

void ___ZN10subscriber19EURSimCommandDriver12authenticateERKNS_11SimCardInfoENS_8AuthTypeENSt3__13mapINS_8AuthInfoENS5_6vectorIhNS5_9allocatorIhEEEENS5_4lessIS7_EENS9_INS5_4pairIKS7_SB_EEEEEENS5_8functionIFvSI_EEE_block_invoke_47(uint64_t a1)
{
  NSObject *v2;
  const char *v3;
  NSObject *v4;
  uint64_t v5;
  const char *v6;
  _QWORD *v7;
  _QWORD *v8;
  int v9;
  uint64_t v10;
  __int16 v11;
  const char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  switch(*(_DWORD *)(a1 + 96))
  {
    case 0:
      if ((subscriber::SimCommandDriver::parseEapSim() & 1) == 0)
      {
        v2 = **(NSObject ***)(a1 + 48);
        if (!os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
          goto LABEL_23;
        LOWORD(v9) = 0;
        v3 = "EAP-SIM response received, but response is error or not parsable; dropping";
        goto LABEL_22;
      }
      break;
    case 2:
      if ((subscriber::SimCommandDriver::parseEapSim() & 1) == 0)
      {
        v2 = **(NSObject ***)(a1 + 48);
        if (!os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
          goto LABEL_23;
        LOWORD(v9) = 0;
        v3 = "EAP-SIM response received, but response is error or not parsable; dropping";
        goto LABEL_22;
      }
      break;
    case 3:
      if ((subscriber::SimCommandDriver::parseEapAka() & 1) == 0)
      {
        v2 = **(NSObject ***)(a1 + 48);
        if (!os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
          goto LABEL_23;
        LOWORD(v9) = 0;
        v3 = "EAP-AKA response received, but response is error or not parsable; dropping";
        goto LABEL_22;
      }
      break;
    case 5:
      if ((subscriber::SimCommandDriver::parseImsGbaBs() & 1) == 0)
      {
        v2 = **(NSObject ***)(a1 + 48);
        if (!os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
          goto LABEL_23;
        LOWORD(v9) = 0;
        v3 = "GBA-BS response received, but response is error or not parsable; dropping";
        goto LABEL_22;
      }
      break;
    case 6:
      if ((subscriber::SimCommandDriver::parseImsGbaNaf() & 1) == 0)
      {
        v2 = **(NSObject ***)(a1 + 48);
        if (!os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
          goto LABEL_23;
        LOWORD(v9) = 0;
        v3 = "IMS-GBA-NAF response received, but response is error or not parsable; dropping";
        goto LABEL_22;
      }
      break;
    case 0xB:
      if ((subscriber::SimCommandDriver::parseImsAka() & 1) == 0)
      {
        v2 = **(NSObject ***)(a1 + 48);
        if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
        {
          LOWORD(v9) = 0;
          v3 = "AKA response received, but response is error or not parsable; dropping";
LABEL_22:
          _os_log_error_impl(&dword_216897000, v2, OS_LOG_TYPE_ERROR, v3, (uint8_t *)&v9, 2u);
        }
LABEL_23:
        v7 = *(_QWORD **)(*(_QWORD *)(a1 + 32) + 8);
        v8 = (_QWORD *)v7[6];
        v7 += 6;
        std::__tree<std::__value_type<unsigned int,std::vector<unsigned char>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<unsigned char>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::vector<unsigned char>>>>::destroy(v8);
        *(v7 - 1) = v7;
        *v7 = 0;
        v7[1] = 0;
      }
      break;
    default:
      v4 = **(NSObject ***)(a1 + 48);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        v5 = subscriber::asString();
        v6 = uim::asString(*(_DWORD *)(a1 + 96));
        v9 = 136315394;
        v10 = v5;
        v11 = 2080;
        v12 = v6;
        _os_log_error_impl(&dword_216897000, v4, OS_LOG_TYPE_ERROR, "SIM authenticate response for card %s uses unknown context %s; dropping",
          (uint8_t *)&v9,
          0x16u);
      }
      break;
  }
}

_QWORD *__copy_helper_block_e8_56c32_ZTSKN10subscriber11SimCardInfoE(uint64_t a1, uint64_t a2)
{
  __int128 v2;
  _QWORD *v3;

  v2 = *(_OWORD *)(a2 + 56);
  *(_QWORD *)(a1 + 72) = 0;
  v3 = (_QWORD *)(a1 + 72);
  *((_OWORD *)v3 - 1) = v2;
  v3[1] = 0;
  v3[2] = 0;
  return std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(v3, *(const void **)(a2 + 72), *(_QWORD *)(a2 + 80), *(_QWORD *)(a2 + 80) - *(_QWORD *)(a2 + 72));
}

void __destroy_helper_block_e8_56c32_ZTSKN10subscriber11SimCardInfoE(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 72);
  if (v2)
  {
    *(_QWORD *)(a1 + 80) = v2;
    operator delete(v2);
  }
}

uint64_t __copy_helper_block_e8_48c32_ZTSKN10subscriber11SimCardInfoE88c129_ZTSNSt3__18functionIFvNS_3mapIN10subscriber8AuthInfoENS_6vectorIhNS_9allocatorIhEEEENS_4lessIS3_EENS5_INS_4pairIKS3_S7_EEEEEEEEE(uint64_t a1, uint64_t a2)
{
  __int128 v3;
  uint64_t v4;

  v3 = *(_OWORD *)(a2 + 48);
  *(_QWORD *)(a1 + 64) = 0;
  v4 = a1 + 64;
  *(_OWORD *)(a1 + 48) = v3;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>((_QWORD *)(a1 + 64), *(const void **)(a2 + 64), *(_QWORD *)(a2 + 72), *(_QWORD *)(a2 + 72) - *(_QWORD *)(a2 + 64));
  return std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100](v4 + 24, a2 + 88);
}

void sub_2169DC7C4(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void *v4;

  v4 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 72) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

void __destroy_helper_block_e8_48c32_ZTSKN10subscriber11SimCardInfoE88c129_ZTSNSt3__18functionIFvNS_3mapIN10subscriber8AuthInfoENS_6vectorIhNS_9allocatorIhEEEENS_4lessIS3_EENS5_INS_4pairIKS3_S7_EEEEEEEEE(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  void *v5;

  v2 = a1 + 11;
  v3 = (_QWORD *)a1[14];
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
  v5 = (void *)a1[8];
  if (v5)
  {
    a1[9] = v5;
    operator delete(v5);
  }
}

void subscriber::EURSimCommandDriver::sendSimApdu(uint64_t a1, unsigned int *a2, uint64_t *a3, uint64_t a4)
{
  unsigned int v8;
  std::__shared_weak_count *v9;
  uint64_t v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  void *__p;
  void *v21;
  uint64_t v22;
  _BYTE v23[24];
  _BYTE *v24;
  _QWORD v25[6];
  std::__shared_weak_count *v26;
  _BYTE v27[24];
  _BYTE *v28;
  _BYTE v29[15];
  _BYTE v30[9];

  *(_QWORD *)&v30[1] = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)v29 = 0x10F15330000000A0;
  *(_QWORD *)&v29[7] = 0x5652500101058310;
  __p = 0;
  v21 = 0;
  v22 = 0;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(&__p, v29, (uint64_t)v30, 0xFuLL);
  v8 = *a2;
  v25[0] = MEMORY[0x24BDAC760];
  v25[1] = 1174405120;
  v25[2] = ___ZN10subscriber19EURSimCommandDriver11sendSimApduERKNS_11SimCardInfoENSt3__110shared_ptrINS4_6vectorIhNS4_9allocatorIhEEEEEENS4_8functionIFvbEEE_block_invoke;
  v25[3] = &__block_descriptor_tmp_51_5;
  v10 = *a3;
  v9 = (std::__shared_weak_count *)a3[1];
  v25[4] = a1;
  v25[5] = v10;
  v26 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
  }
  v13 = v27;
  std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100]((uint64_t)v27, a4);
  std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100]((uint64_t)v23, a4);
  subscriber::EURSimCommandDriver::sendSimApdu_start(a1, v8, (char **)&__p, (uint64_t)v25, (uint64_t)v23);
  v14 = v24;
  if (v24 == v23)
  {
    v15 = 4;
    v14 = v23;
  }
  else
  {
    if (!v24)
      goto LABEL_9;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_9:
  if (v28 == v27)
  {
    v16 = 4;
    goto LABEL_13;
  }
  if (v28)
  {
    v16 = 5;
    v13 = v28;
LABEL_13:
    (*(void (**)(_QWORD *))(*v13 + 8 * v16))(v13);
  }
  v17 = v26;
  if (v26)
  {
    v18 = (unint64_t *)&v26->__shared_owners_;
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
  if (__p)
  {
    v21 = __p;
    operator delete(__p);
  }
}

void sub_2169DCA1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, char *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,_QWORD *a27)
{
  _QWORD *v27;
  char *v28;
  uint64_t v29;
  char *v31;
  uint64_t v32;
  uint64_t v33;

  v31 = a16;
  if (a16 == v28)
  {
    v32 = 4;
    v31 = &a13;
  }
  else
  {
    if (!a16)
      goto LABEL_6;
    v32 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v31 + 8 * v32))();
LABEL_6:
  if (a27 == v27)
  {
    v33 = 4;
  }
  else
  {
    if (!a27)
      goto LABEL_11;
    v33 = 5;
    v27 = a27;
  }
  (*(void (**)(_QWORD *))(*v27 + 8 * v33))(v27);
LABEL_11:
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v29 + 40);
  if (__p)
    operator delete(__p);
  _Unwind_Resume(a1);
}

void subscriber::EURSimCommandDriver::sendSimApdu_start(uint64_t a1, unsigned int a2, char **a3, uint64_t a4, uint64_t a5)
{
  char *v10;
  char v11;
  const void **v12;
  char *v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  char *v22;
  uint64_t *v23;
  char *v24;
  char *v25;
  char *v26;
  uint64_t v27;
  uint64_t v28;
  _QWORD *v29;
  void *v30;
  uint64_t v31;
  uint64_t v32;
  void *v33;
  void *__p[2];
  __int128 v35;
  _QWORD aBlock[5];
  _QWORD v37[6];
  _BYTE v38[24];
  _BYTE *v39;
  unsigned int v40;
  uint64_t v41;

  v41 = *MEMORY[0x24BDAC8D0];
  *(_OWORD *)__p = 0u;
  v35 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  v10 = qmi::MutableMessageBase::getTLV<uim::tlv::SlotId>(__p);
  if (a2 >= 4)
    v11 = 0;
  else
    v11 = a2;
  *v10 = v11;
  v12 = (const void **)__p[1];
  if (__p[1] != (void *)v35)
  {
    while (*((_BYTE *)*v12 + 8) != 16)
    {
      if (++v12 == (const void **)v35)
        goto LABEL_11;
    }
  }
  if (v12 == (const void **)v35)
  {
LABEL_11:
    v15 = operator new();
    v16 = v15;
    *(_BYTE *)(v15 + 8) = 16;
    *(_QWORD *)(v15 + 16) = 0;
    v14 = (_QWORD *)(v15 + 16);
    *(_QWORD *)v15 = &off_24D5DC1F8;
    *(_QWORD *)(v15 + 24) = 0;
    *(_QWORD *)(v15 + 32) = 0;
    v17 = v35;
    if ((unint64_t)v35 >= *((_QWORD *)&v35 + 1))
    {
      v19 = (uint64_t)(v35 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v19 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v20 = (uint64_t)(*((_QWORD *)&v35 + 1) - (unint64_t)__p[1]) >> 2;
      if (v20 <= v19 + 1)
        v20 = v19 + 1;
      if (*((_QWORD *)&v35 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v21 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v21 = v20;
      if (v21)
        v22 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v35 + 8, v21);
      else
        v22 = 0;
      v23 = (uint64_t *)&v22[8 * v19];
      v24 = &v22[8 * v21];
      *v23 = v16;
      v18 = v23 + 1;
      v26 = (char *)__p[1];
      v25 = (char *)v35;
      if ((void *)v35 != __p[1])
      {
        do
        {
          v27 = *((_QWORD *)v25 - 1);
          v25 -= 8;
          *--v23 = v27;
        }
        while (v25 != v26);
        v25 = (char *)__p[1];
      }
      __p[1] = v23;
      *(_QWORD *)&v35 = v18;
      *((_QWORD *)&v35 + 1) = v24;
      if (v25)
        operator delete(v25);
    }
    else
    {
      *(_QWORD *)v35 = v15;
      v18 = (_QWORD *)(v17 + 8);
    }
    *(_QWORD *)&v35 = v18;
  }
  else
  {
    if (!v13)
      __cxa_bad_cast();
    v14 = v13 + 16;
  }
  std::vector<unsigned char>::__assign_with_size[abi:ne180100]<std::__wrap_iter<unsigned char const*>,std::__wrap_iter<unsigned char const*>>(v14, *a3, a3[1], a3[1] - *a3);
  v32 = QMIServiceMsg::create();
  v28 = MEMORY[0x24BDAC760];
  v37[0] = MEMORY[0x24BDAC760];
  v37[1] = 1174405120;
  v37[2] = ___ZN10subscriber19EURSimCommandDriver17sendSimApdu_startENS_15HardwareSimSlotERKNSt3__16vectorIhNS2_9allocatorIhEEEEU13block_pointerFvS1_hENS2_8functionIFvbEEE_block_invoke_3;
  v37[3] = &unk_24D5DB1E8;
  v37[5] = a1;
  v40 = a2;
  v29 = v38;
  std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100]((uint64_t)v38, a5);
  v37[4] = a4;
  aBlock[0] = v28;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3uim14LogicalChannel8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
  aBlock[3] = &unk_24D5DC228;
  aBlock[4] = v37;
  v30 = _Block_copy(aBlock);
  v33 = v30;
  if (v32)
  {
    qmi::Client::send();
    v30 = v33;
  }
  if (v30)
    _Block_release(v30);
  if (v39 == v38)
  {
    v31 = 4;
    goto LABEL_36;
  }
  if (v39)
  {
    v31 = 5;
    v29 = v39;
LABEL_36:
    (*(void (**)(_QWORD *))(*v29 + 8 * v31))(v29);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
}

void sub_2169DCDC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,_QWORD *a34)
{
  _QWORD *v34;
  uint64_t v36;

  if (a34 == v34)
  {
    v36 = 4;
  }
  else
  {
    if (!a34)
      goto LABEL_6;
    v36 = 5;
    v34 = a34;
  }
  (*(void (**)(_QWORD *))(*v34 + 8 * v36))(v34);
LABEL_6:
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)&a10);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a15);
  _Unwind_Resume(a1);
}

void ___ZN10subscriber19EURSimCommandDriver11sendSimApduERKNS_11SimCardInfoENSt3__110shared_ptrINS4_6vectorIhNS4_9allocatorIhEEEEEENS4_8functionIFvbEEE_block_invoke(_QWORD *a1, unsigned int a2, char a3)
{
  uint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  _QWORD v13[2];
  _BYTE v14[24];
  _BYTE *v15;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  v5 = a1[4];
  v6 = (std::__shared_weak_count *)a1[6];
  v13[0] = a1[5];
  v13[1] = v6;
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }
  std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100]((uint64_t)v14, (uint64_t)(a1 + 7));
  subscriber::EURSimCommandDriver::sendSimApdu_block(v5, a2, a3, v13, 0, (uint64_t)v14);
  v9 = v15;
  if (v15 == v14)
  {
    v10 = 4;
    v9 = v14;
  }
  else
  {
    if (!v15)
      goto LABEL_9;
    v10 = 5;
  }
  (*(void (**)(void))(*v9 + 8 * v10))();
LABEL_9:
  if (v6)
  {
    v11 = (unint64_t *)&v6->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

void sub_2169DCF4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, char *a15)
{
  char *v15;
  char *v17;
  uint64_t v18;

  v17 = a15;
  if (a15 == v15)
  {
    v18 = 4;
    v17 = &a12;
  }
  else
  {
    if (!a15)
      goto LABEL_6;
    v18 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v17 + 8 * v18))();
LABEL_6:
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a10);
  _Unwind_Resume(a1);
}

void subscriber::EURSimCommandDriver::sendSimApdu_block(uint64_t a1, unsigned int a2, char a3, _QWORD *a4, int a5, uint64_t a6)
{
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  char *v16;
  char v17;
  uint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *p_shared_owners;
  unint64_t v21;
  char *v22;
  char *v23;
  _QWORD *v24;
  std::__shared_weak_count *v25;
  uint64_t v26;
  unint64_t *v27;
  unint64_t v28;
  void *v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  uint64_t v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  uint64_t v37;
  void *v38;
  _QWORD v39[4];
  char v40;
  _QWORD v41[2];
  void (*v42)(uint64_t, unint64_t *);
  void *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  std::__shared_weak_count *v47;
  unint64_t v48;
  int v49;
  char v50;
  _OWORD v51[2];
  _QWORD aBlock[5];
  _QWORD v53[5];
  _BYTE v54[24];
  _BYTE *v55;
  uint64_t v56;
  uint64_t v57;
  std::__shared_weak_count *v58;
  unsigned int v59;
  int v60;
  char v61;
  uint64_t v62;

  v62 = *MEMORY[0x24BDAC8D0];
  v12 = 248;
  v13 = 248 * a5;
  v14 = *(_QWORD *)(*a4 + 8) - *(_QWORD *)*a4;
  if (v14 - v13 < 0xF8)
    v12 = v14 - v13;
  if (v14 <= v13)
    v15 = 0;
  else
    v15 = v12;
  memset(v51, 0, sizeof(v51));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v51);
  v16 = qmi::MutableMessageBase::getTLV<uim::tlv::SlotId>(v51);
  if (a2 >= 4)
    v17 = 0;
  else
    v17 = a2;
  *v16 = v17;
  v18 = MEMORY[0x24BDAC760];
  v41[0] = MEMORY[0x24BDAC760];
  v41[1] = 1174405120;
  v42 = ___ZN10subscriber19EURSimCommandDriver17sendSimApdu_blockENS_15HardwareSimSlotEhNSt3__110shared_ptrINS2_6vectorIhNS2_9allocatorIhEEEEEEiNS2_8functionIFvbEEE_block_invoke_2;
  v43 = &__block_descriptor_tmp_70_4;
  v50 = a3;
  v49 = a5;
  v44 = a1;
  v45 = v15;
  v19 = (std::__shared_weak_count *)a4[1];
  v46 = *a4;
  v47 = v19;
  if (v19)
  {
    p_shared_owners = (unint64_t *)&v19->__shared_owners_;
    do
      v21 = __ldxr(p_shared_owners);
    while (__stxr(v21 + 1, p_shared_owners));
  }
  v48 = v13;
  v22 = qmi::MutableMessageBase::getTLV<uim::tlv::APDU>(v51);
  v42((uint64_t)v41, (unint64_t *)v22);
  v39[0] = v18;
  v39[1] = 0x40000000;
  v39[2] = ___ZN10subscriber19EURSimCommandDriver17sendSimApdu_blockENS_15HardwareSimSlotEhNSt3__110shared_ptrINS2_6vectorIhNS2_9allocatorIhEEEEEEiNS2_8functionIFvbEEE_block_invoke_71;
  v39[3] = &__block_descriptor_tmp_72_3;
  v40 = a3;
  v23 = qmi::MutableMessageBase::getTLV<uim::tlv::LChannelId>(v51);
  ___ZN10subscriber19EURSimCommandDriver17sendSimApdu_blockENS_15HardwareSimSlotEhNSt3__110shared_ptrINS2_6vectorIhNS2_9allocatorIhEEEEEEiNS2_8functionIFvbEEE_block_invoke_71((uint64_t)v39, v23);
  v37 = QMIServiceMsg::create();
  v53[0] = v18;
  v53[1] = 1174405120;
  v53[2] = ___ZN10subscriber19EURSimCommandDriver17sendSimApdu_blockENS_15HardwareSimSlotEhNSt3__110shared_ptrINS2_6vectorIhNS2_9allocatorIhEEEEEEiNS2_8functionIFvbEEE_block_invoke_2_73;
  v53[3] = &__block_descriptor_tmp_76_1;
  v53[4] = a1;
  v59 = a2;
  v24 = v54;
  v61 = a3;
  std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100]((uint64_t)v54, a6);
  v60 = a5;
  v26 = *a4;
  v25 = (std::__shared_weak_count *)a4[1];
  v56 = v15;
  v57 = v26;
  v58 = v25;
  if (v25)
  {
    v27 = (unint64_t *)&v25->__shared_owners_;
    do
      v28 = __ldxr(v27);
    while (__stxr(v28 + 1, v27));
  }
  aBlock[0] = v18;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3uim8SendAPDU8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
  aBlock[3] = &unk_24D5DC2F0;
  aBlock[4] = v53;
  v29 = _Block_copy(aBlock);
  v38 = v29;
  if (v37)
  {
    qmi::Client::send();
    v29 = v38;
  }
  if (v29)
    _Block_release(v29);
  v30 = v58;
  if (v58)
  {
    v31 = (unint64_t *)&v58->__shared_owners_;
    do
      v32 = __ldaxr(v31);
    while (__stlxr(v32 - 1, v31));
    if (!v32)
    {
      ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
      std::__shared_weak_count::__release_weak(v30);
    }
  }
  if (v55 == v54)
  {
    v33 = 4;
    goto LABEL_28;
  }
  if (v55)
  {
    v33 = 5;
    v24 = v55;
LABEL_28:
    (*(void (**)(_QWORD *))(*v24 + 8 * v33))(v24);
  }
  v34 = v47;
  if (v47)
  {
    v35 = (unint64_t *)&v47->__shared_owners_;
    do
      v36 = __ldaxr(v35);
    while (__stlxr(v36 - 1, v35));
    if (!v36)
    {
      ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
      std::__shared_weak_count::__release_weak(v34);
    }
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v51);
}

void sub_2169DD2B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  uint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  uint64_t v32;
  _QWORD *v34;
  uint64_t v35;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v30);
  v34 = *(_QWORD **)(v32 - 160);
  if (v34 == v31)
  {
    v35 = 4;
  }
  else
  {
    if (!v34)
      goto LABEL_6;
    v35 = 5;
    v31 = *(_QWORD **)(v32 - 160);
  }
  (*(void (**)(_QWORD *))(*v31 + 8 * v35))(v31);
LABEL_6:
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)&a9);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v29);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a29);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_40c57_ZTSNSt3__110shared_ptrINS_6vectorIhNS_9allocatorIhEEEEEE56c27_ZTSNSt3__18functionIFvbEEE(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 48) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100](a1 + 56, a2 + 56);
}

void sub_2169DD38C(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

uint64_t __destroy_helper_block_e8_40c57_ZTSNSt3__110shared_ptrINS_6vectorIhNS_9allocatorIhEEEEEE56c27_ZTSNSt3__18functionIFvbEEE(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  v2 = (_QWORD *)(a1 + 56);
  v3 = *(_QWORD **)(a1 + 80);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 40);
}

void subscriber::EURSimCommandDriver::sendSimSingleApduCommand(uint64_t a1, unsigned int *a2, char ***a3, char a4, uint64_t *a5, uint64_t a6)
{
  unsigned int v8;
  char **v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  _BYTE v21[24];
  _BYTE *v22;
  _QWORD v23[6];
  std::__shared_weak_count *v24;
  _BYTE v25[24];
  _BYTE *v26;
  char v27;
  uint64_t v28;

  v28 = *MEMORY[0x24BDAC8D0];
  v8 = *a2;
  v9 = *a3;
  v23[0] = MEMORY[0x24BDAC760];
  v23[1] = 1174405120;
  v23[2] = ___ZN10subscriber19EURSimCommandDriver24sendSimSingleApduCommandERKNS_11SimCardInfoENSt3__110shared_ptrINS4_6vectorIhNS4_9allocatorIhEEEEEEhSA_NS4_8functionIFvbEEE_block_invoke;
  v23[3] = &__block_descriptor_tmp_52_4;
  v27 = a4;
  v11 = *a5;
  v10 = (std::__shared_weak_count *)a5[1];
  v23[4] = a1;
  v23[5] = v11;
  v24 = v10;
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      v13 = __ldxr(p_shared_owners);
    while (__stxr(v13 + 1, p_shared_owners));
  }
  v14 = v25;
  std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100]((uint64_t)v25, a6);
  std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100]((uint64_t)v21, a6);
  subscriber::EURSimCommandDriver::sendSimApdu_start(a1, v8, v9, (uint64_t)v23, (uint64_t)v21);
  v15 = v22;
  if (v22 == v21)
  {
    v16 = 4;
    v15 = v21;
  }
  else
  {
    if (!v22)
      goto LABEL_9;
    v16 = 5;
  }
  (*(void (**)(void))(*v15 + 8 * v16))();
LABEL_9:
  if (v26 == v25)
  {
    v17 = 4;
  }
  else
  {
    if (!v26)
      goto LABEL_14;
    v17 = 5;
    v14 = v26;
  }
  (*(void (**)(_QWORD *))(*v14 + 8 * v17))(v14);
LABEL_14:
  v18 = v24;
  if (v24)
  {
    v19 = (unint64_t *)&v24->__shared_owners_;
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
}

void sub_2169DD580(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,_QWORD *a24)
{
  _QWORD *v24;
  char *v25;
  uint64_t v26;
  char *v28;
  uint64_t v29;
  uint64_t v30;

  v28 = a13;
  if (a13 == v25)
  {
    v29 = 4;
    v28 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v29 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v28 + 8 * v29))();
LABEL_6:
  if (a24 == v24)
  {
    v30 = 4;
  }
  else
  {
    if (!a24)
      goto LABEL_11;
    v30 = 5;
    v24 = a24;
  }
  (*(void (**)(_QWORD *))(*v24 + 8 * v30))(v24);
LABEL_11:
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v26 + 40);
  _Unwind_Resume(a1);
}

void sub_2169DD868(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32,uint64_t a33,uint64_t a34,char *a35)
{
  char *v36;
  uint64_t v37;

  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)&a11);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a23);
  v36 = a35;
  if (a35 == &a32)
  {
    v37 = 4;
    v36 = &a32;
  }
  else
  {
    if (!a35)
      goto LABEL_6;
    v37 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v36 + 8 * v37))();
LABEL_6:
  _Unwind_Resume(a1);
}

void ___ZN10subscriber19EURSimCommandDriver17sendSimApdu_startENS_15HardwareSimSlotERKNSt3__16vectorIhNS2_9allocatorIhEEEEU13block_pointerFvS1_hENS2_8functionIFvbEEE_block_invoke_3(_QWORD *a1, qmi::MessageBase *this)
{
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t TlvValue;
  int v10;
  uint64_t v11;
  int v12;
  char v13;
  NSObject *v14;
  uint64_t v15;
  int v16;
  _BYTE v17[12];
  __int16 v18;
  int v19;
  _BYTE buf[28];
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  v4 = a1[5];
  if (*((_DWORD *)this + 1))
  {
    v5 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = subscriber::asString();
      v7 = *((_DWORD *)this + 1);
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = v6;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v7;
      *(_WORD *)&buf[18] = 2080;
      *(_QWORD *)&buf[20] = qmi::asString();
      _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#I uim::LogicalChannel, slot:%s open() get QMI error 0x%04x (%s)", buf, 0x1Cu);
    }
    buf[0] = 0;
    v8 = a1[9];
    if (!v8)
      std::__throw_bad_function_call[abi:ne180100]();
    (*(void (**)(uint64_t, _BYTE *))(*(_QWORD *)v8 + 48))(v8, buf);
  }
  else
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2000000000;
    buf[24] = 0;
    TlvValue = qmi::MessageBase::findTlvValue(this);
    v11 = TlvValue;
    if (TlvValue)
    {
      v12 = v10;
      *(_QWORD *)v17 = TlvValue;
      v13 = tlv::parseV<uim::tlv::LChannelId>((unint64_t *)v17, v10);
      if (*(_QWORD *)v17)
        *(_BYTE *)(*(_QWORD *)&buf[8] + 24) = v13;
      else
        ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)this, 16, v11, v12);
    }
    v14 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      v15 = subscriber::asString();
      v16 = *(unsigned __int8 *)(*(_QWORD *)&buf[8] + 24);
      *(_DWORD *)v17 = 136315394;
      *(_QWORD *)&v17[4] = v15;
      v18 = 1024;
      v19 = v16;
      _os_log_impl(&dword_216897000, v14, OS_LOG_TYPE_DEFAULT, "#I uim::LogicalChannel, slot:%s channel %d opened", v17, 0x12u);
    }
    (*(void (**)(void))(a1[4] + 16))();
    _Block_object_dispose(buf, 8);
  }
}

void sub_2169DDB20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_48c27_ZTSNSt3__18functionIFvbEEE(uint64_t a1, uint64_t a2)
{
  return std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100](a1 + 48, a2 + 48);
}

_QWORD *__destroy_helper_block_e8_48c27_ZTSNSt3__18functionIFvbEEE(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *result;
  uint64_t v3;

  v1 = (_QWORD *)(a1 + 48);
  result = *(_QWORD **)(a1 + 72);
  if (result == v1)
  {
    v3 = 4;
    result = v1;
  }
  else
  {
    if (!result)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

void ___ZN10subscriber19EURSimCommandDriver19sendSimApdu_commandENS_15HardwareSimSlotEhhRNSt3__16vectorIhNS2_9allocatorIhEEEENS2_8functionIFvbEEE_block_invoke_2(uint64_t a1, unint64_t *a2)
{
  unint64_t v4;
  _BYTE *v5;
  _BYTE *v6;
  unint64_t v7;
  _BYTE *v8;
  unint64_t v9;
  unint64_t v10;
  size_t v11;
  unint64_t v12;
  char *v13;
  _BYTE *v14;
  char v15;
  unint64_t v16;
  _BYTE *v17;
  unint64_t v18;
  _BYTE *v19;
  unint64_t v20;
  unint64_t v21;
  size_t v22;
  unint64_t v23;
  char *v24;
  _BYTE *v25;
  char v26;
  unint64_t v27;
  _BYTE *v28;
  unint64_t v29;
  _BYTE *v30;
  unint64_t v31;
  unint64_t v32;
  size_t v33;
  unint64_t v34;
  char *v35;
  _BYTE *v36;
  char v37;
  unint64_t v38;
  _BYTE *v39;
  unint64_t v40;
  _BYTE *v41;
  unint64_t v42;
  unint64_t v43;
  size_t v44;
  unint64_t v45;
  char *v46;
  _BYTE *v47;
  char v48;
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  unint64_t v52;
  _BYTE *v53;
  unint64_t v54;
  uint64_t v55;
  unint64_t v56;
  _BYTE *v57;
  unint64_t v58;
  unint64_t v59;
  size_t v60;
  unint64_t v61;
  unint64_t v62;
  _BYTE *v63;
  unint64_t v64;
  unint64_t v65;
  size_t v66;
  unint64_t v67;
  char *v68;
  _BYTE *v69;
  char v70;
  char *v71;
  _BYTE *v72;
  char v73;
  uint64_t v74;
  _BYTE *v75;
  _BYTE *v76;
  unint64_t v77;
  uint64_t v78;
  unint64_t v79;
  _BYTE *v80;
  unint64_t v81;
  unint64_t v82;
  size_t v83;
  unint64_t v84;
  char *v85;
  _BYTE *v86;
  char v87;

  std::vector<unsigned char>::reserve(a2);
  v5 = (_BYTE *)a2[1];
  v4 = a2[2];
  if ((unint64_t)v5 >= v4)
  {
    v7 = *a2;
    v8 = &v5[-*a2];
    v9 = (unint64_t)(v8 + 1);
    if ((uint64_t)(v8 + 1) < 0)
      goto LABEL_134;
    v10 = v4 - v7;
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x3FFFFFFFFFFFFFFFLL)
      v11 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v11 = v9;
    if (v11)
      v12 = (unint64_t)operator new(v11);
    else
      v12 = 0;
    v13 = (char *)(v12 + v11);
    v8[v12] = *(_BYTE *)(a1 + 48);
    v6 = &v8[v12 + 1];
    if (v5 == (_BYTE *)v7)
    {
      v12 += (unint64_t)v8;
    }
    else
    {
      v14 = &v5[~v7];
      do
      {
        v15 = *--v5;
        (v14--)[v12] = v15;
      }
      while (v5 != (_BYTE *)v7);
      v5 = (_BYTE *)*a2;
    }
    *a2 = v12;
    a2[1] = (unint64_t)v6;
    a2[2] = (unint64_t)v13;
    if (v5)
      operator delete(v5);
  }
  else
  {
    *v5 = *(_BYTE *)(a1 + 48);
    v6 = v5 + 1;
  }
  a2[1] = (unint64_t)v6;
  v16 = a2[2];
  if ((unint64_t)v6 < v16)
  {
    *v6 = *(_BYTE *)(a1 + 49);
    v17 = v6 + 1;
    goto LABEL_37;
  }
  v18 = *a2;
  v19 = &v6[-*a2];
  v20 = (unint64_t)(v19 + 1);
  if ((uint64_t)(v19 + 1) < 0)
    goto LABEL_134;
  v21 = v16 - v18;
  if (2 * v21 > v20)
    v20 = 2 * v21;
  if (v21 >= 0x3FFFFFFFFFFFFFFFLL)
    v22 = 0x7FFFFFFFFFFFFFFFLL;
  else
    v22 = v20;
  if (v22)
    v23 = (unint64_t)operator new(v22);
  else
    v23 = 0;
  v24 = (char *)(v23 + v22);
  v19[v23] = *(_BYTE *)(a1 + 49);
  v17 = &v19[v23 + 1];
  if (v6 == (_BYTE *)v18)
  {
    *a2 = (unint64_t)&v19[v23];
    a2[1] = (unint64_t)v17;
    a2[2] = (unint64_t)v24;
LABEL_36:
    operator delete(v6);
    goto LABEL_37;
  }
  v25 = &v6[~v18];
  do
  {
    v26 = *--v6;
    (v25--)[v23] = v26;
  }
  while (v6 != (_BYTE *)v18);
  v6 = (_BYTE *)*a2;
  *a2 = v23;
  a2[1] = (unint64_t)v17;
  a2[2] = (unint64_t)v24;
  if (v6)
    goto LABEL_36;
LABEL_37:
  a2[1] = (unint64_t)v17;
  v27 = a2[2];
  if ((unint64_t)v17 < v27)
  {
    *v17 = 0;
    v28 = v17 + 1;
    goto LABEL_55;
  }
  v29 = *a2;
  v30 = &v17[-*a2];
  v31 = (unint64_t)(v30 + 1);
  if ((uint64_t)(v30 + 1) < 0)
    goto LABEL_134;
  v32 = v27 - v29;
  if (2 * v32 > v31)
    v31 = 2 * v32;
  if (v32 >= 0x3FFFFFFFFFFFFFFFLL)
    v33 = 0x7FFFFFFFFFFFFFFFLL;
  else
    v33 = v31;
  if (v33)
    v34 = (unint64_t)operator new(v33);
  else
    v34 = 0;
  v35 = (char *)(v34 + v33);
  v30[v34] = 0;
  v28 = &v30[v34 + 1];
  if (v17 == (_BYTE *)v29)
  {
    *a2 = (unint64_t)&v30[v34];
    a2[1] = (unint64_t)v28;
    a2[2] = (unint64_t)v35;
LABEL_54:
    operator delete(v17);
    goto LABEL_55;
  }
  v36 = &v17[~v29];
  do
  {
    v37 = *--v17;
    (v36--)[v34] = v37;
  }
  while (v17 != (_BYTE *)v29);
  v17 = (_BYTE *)*a2;
  *a2 = v34;
  a2[1] = (unint64_t)v28;
  a2[2] = (unint64_t)v35;
  if (v17)
    goto LABEL_54;
LABEL_55:
  a2[1] = (unint64_t)v28;
  v38 = a2[2];
  if ((unint64_t)v28 < v38)
  {
    *v28 = 0;
    v39 = v28 + 1;
    goto LABEL_73;
  }
  v40 = *a2;
  v41 = &v28[-*a2];
  v42 = (unint64_t)(v41 + 1);
  if ((uint64_t)(v41 + 1) < 0)
    goto LABEL_134;
  v43 = v38 - v40;
  if (2 * v43 > v42)
    v42 = 2 * v43;
  if (v43 >= 0x3FFFFFFFFFFFFFFFLL)
    v44 = 0x7FFFFFFFFFFFFFFFLL;
  else
    v44 = v42;
  if (v44)
    v45 = (unint64_t)operator new(v44);
  else
    v45 = 0;
  v46 = (char *)(v45 + v44);
  v41[v45] = 0;
  v39 = &v41[v45 + 1];
  if (v28 == (_BYTE *)v40)
  {
    *a2 = (unint64_t)&v41[v45];
    a2[1] = (unint64_t)v39;
    a2[2] = (unint64_t)v46;
LABEL_72:
    operator delete(v28);
    goto LABEL_73;
  }
  v47 = &v28[~v40];
  do
  {
    v48 = *--v28;
    (v47--)[v45] = v48;
  }
  while (v28 != (_BYTE *)v40);
  v28 = (_BYTE *)*a2;
  *a2 = v45;
  a2[1] = (unint64_t)v39;
  a2[2] = (unint64_t)v46;
  if (v28)
    goto LABEL_72;
LABEL_73:
  a2[1] = (unint64_t)v39;
  v49 = **(_QWORD **)(a1 + 40);
  v50 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
  v51 = v50 - v49;
  if (v50 == v49 || v51 > 0xF7)
  {
    v54 = a2[2];
    if ((unint64_t)v39 >= v54)
    {
      v62 = *a2;
      v63 = &v39[-*a2];
      v64 = (unint64_t)(v63 + 1);
      if ((uint64_t)(v63 + 1) < 0)
        goto LABEL_134;
      v65 = v54 - v62;
      if (2 * v65 > v64)
        v64 = 2 * v65;
      if (v65 >= 0x3FFFFFFFFFFFFFFFLL)
        v66 = 0x7FFFFFFFFFFFFFFFLL;
      else
        v66 = v64;
      if (v66)
        v67 = (unint64_t)operator new(v66);
      else
        v67 = 0;
      v71 = (char *)(v67 + v66);
      v63[v67] = 0;
      v55 = (uint64_t)&v63[v67 + 1];
      if (v39 == (_BYTE *)v62)
      {
        *a2 = (unint64_t)&v63[v67];
        a2[1] = v55;
        a2[2] = (unint64_t)v71;
      }
      else
      {
        v72 = &v39[~v62];
        do
        {
          v73 = *--v39;
          (v72--)[v67] = v73;
        }
        while (v39 != (_BYTE *)v62);
        v39 = (_BYTE *)*a2;
        *a2 = v67;
        a2[1] = v55;
        a2[2] = (unint64_t)v71;
        if (!v39)
          goto LABEL_132;
      }
      operator delete(v39);
    }
    else
    {
      *v39 = 0;
      v55 = (uint64_t)(v39 + 1);
    }
LABEL_132:
    a2[1] = v55;
    return;
  }
  v52 = a2[2];
  if ((unint64_t)v39 < v52)
  {
    *v39 = v51;
    v53 = v39 + 1;
    goto LABEL_109;
  }
  v56 = *a2;
  v57 = &v39[-*a2];
  v58 = (unint64_t)(v57 + 1);
  if ((uint64_t)(v57 + 1) < 0)
LABEL_134:
    std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
  v59 = v52 - v56;
  if (2 * v59 > v58)
    v58 = 2 * v59;
  if (v59 >= 0x3FFFFFFFFFFFFFFFLL)
    v60 = 0x7FFFFFFFFFFFFFFFLL;
  else
    v60 = v58;
  if (v60)
    v61 = (unint64_t)operator new(v60);
  else
    v61 = 0;
  v68 = (char *)(v61 + v60);
  v57[v61] = v51;
  v53 = &v57[v61 + 1];
  if (v39 == (_BYTE *)v56)
  {
    *a2 = (unint64_t)&v57[v61];
    a2[1] = (unint64_t)v53;
    a2[2] = (unint64_t)v68;
LABEL_108:
    operator delete(v39);
    goto LABEL_109;
  }
  v69 = &v39[~v56];
  do
  {
    v70 = *--v39;
    (v69--)[v61] = v70;
  }
  while (v39 != (_BYTE *)v56);
  v39 = (_BYTE *)*a2;
  *a2 = v61;
  a2[1] = (unint64_t)v53;
  a2[2] = (unint64_t)v68;
  if (v39)
    goto LABEL_108;
LABEL_109:
  a2[1] = (unint64_t)v53;
  v74 = *(_QWORD *)(a1 + 40);
  v75 = *(_BYTE **)v74;
  v76 = *(_BYTE **)(v74 + 8);
  if (*(_BYTE **)v74 != v76)
  {
    do
    {
      v77 = a2[2];
      if ((unint64_t)v53 >= v77)
      {
        v79 = *a2;
        v80 = &v53[-*a2];
        v81 = (unint64_t)(v80 + 1);
        if ((uint64_t)(v80 + 1) < 0)
          goto LABEL_134;
        v82 = v77 - v79;
        if (2 * v82 > v81)
          v81 = 2 * v82;
        if (v82 >= 0x3FFFFFFFFFFFFFFFLL)
          v83 = 0x7FFFFFFFFFFFFFFFLL;
        else
          v83 = v81;
        if (v83)
          v84 = (unint64_t)operator new(v83);
        else
          v84 = 0;
        v85 = (char *)(v84 + v83);
        v80[v84] = *v75;
        v78 = (uint64_t)&v80[v84 + 1];
        if (v53 == (_BYTE *)v79)
        {
          *a2 = (unint64_t)&v80[v84];
          a2[1] = v78;
          a2[2] = (unint64_t)v85;
        }
        else
        {
          v86 = &v53[~v79];
          do
          {
            v87 = *--v53;
            (v86--)[v84] = v87;
          }
          while (v53 != (_BYTE *)v79);
          v53 = (_BYTE *)*a2;
          *a2 = v84;
          a2[1] = v78;
          a2[2] = (unint64_t)v85;
          if (!v53)
            goto LABEL_128;
        }
        operator delete(v53);
      }
      else
      {
        *v53 = *v75;
        v78 = (uint64_t)(v53 + 1);
      }
LABEL_128:
      a2[1] = v78;
      ++v75;
      v53 = (_BYTE *)v78;
    }
    while (v75 != v76);
  }
}

void std::vector<unsigned char>::reserve(unint64_t *a1)
{
  unint64_t v1;
  char *v3;
  _BYTE *v4;
  char *v5;
  _BYTE *v6;
  char *v7;
  char v8;

  v1 = *a1;
  if (a1[2] - *a1 <= 0xFC)
  {
    v3 = (char *)a1[1];
    v4 = operator new(0xFDuLL);
    v5 = &v3[(_QWORD)v4 - v1];
    v6 = v5;
    if (v3 != (char *)v1)
    {
      v7 = &v3[~v1];
      do
      {
        v8 = *--v3;
        (v7--)[(_QWORD)v4] = v8;
      }
      while (v3 != (char *)v1);
      v6 = v4;
    }
    *a1 = (unint64_t)v6;
    a1[1] = (unint64_t)v5;
    a1[2] = (unint64_t)(v4 + 253);
    if (v1)
      operator delete((void *)v1);
  }
}

void ___ZN10subscriber19EURSimCommandDriver19sendSimApdu_commandENS_15HardwareSimSlotEhhRNSt3__16vectorIhNS2_9allocatorIhEEEENS2_8functionIFvbEEE_block_invoke_4(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  uint64_t v10;
  char *v11;
  int v12;
  unsigned int v13;
  char v14;
  _QWORD *v15;
  uint64_t v16;
  _QWORD v17[6];
  int v18;
  __int16 v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  char v23;
  _BYTE v24[24];
  _BYTE *v25;
  _BYTE buf[12];
  __int16 v27;
  int v28;
  __int16 v29;
  int v30;
  __int16 v31;
  int v32;
  __int16 v33;
  uint64_t v34;
  uint64_t v35;

  v35 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)(a1 + 32);
  v20 = 0;
  v21 = &v20;
  v22 = 0x2000000000;
  v23 = 1;
  if (*((_DWORD *)a2 + 1))
  {
    v5 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = subscriber::asString();
      v7 = *(unsigned __int8 *)(a1 + 76);
      v8 = *(unsigned __int8 *)(a1 + 77);
      v9 = *((_DWORD *)a2 + 1);
      v10 = qmi::asString();
      *(_DWORD *)buf = 136316162;
      *(_QWORD *)&buf[4] = v6;
      v27 = 1024;
      v28 = v7;
      v29 = 1024;
      v30 = v8;
      v31 = 1024;
      v32 = v9;
      v33 = 2080;
      v34 = v10;
      _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#I uim::SendAPDU, slot:%s chan:%d sending cmnd %d, get QMI error 0x%04x (%s)", buf, 0x28u);
      v11 = (char *)(v21 + 3);
    }
    else
    {
      v11 = &v23;
    }
    v12 = 0;
    *v11 = 0;
  }
  else
  {
    v17[0] = MEMORY[0x24BDAC760];
    v17[1] = 0x40000000;
    v17[2] = ___ZN10subscriber19EURSimCommandDriver19sendSimApdu_commandENS_15HardwareSimSlotEhhRNSt3__16vectorIhNS2_9allocatorIhEEEENS2_8functionIFvbEEE_block_invoke_65;
    v17[3] = &unk_24D5DB240;
    v17[4] = &v20;
    v17[5] = v4;
    v18 = *(_DWORD *)(a1 + 72);
    v19 = *(_WORD *)(a1 + 76);
    *(_QWORD *)buf = v17;
    qmi::MessageBase::applyTlv<uim::tlv::APDU,void({block_pointer}&)(uim::tlv::APDU const&)>(a2, (uint64_t)buf);
    v12 = *((unsigned __int8 *)v21 + 24);
  }
  v13 = *(_DWORD *)(a1 + 72);
  v14 = *(_BYTE *)(a1 + 76);
  std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100]((uint64_t)v24, a1 + 40);
  subscriber::EURSimCommandDriver::sendSimApdu_close(v4, v13, v14, v12 != 0, (uint64_t)v24);
  v15 = v25;
  if (v25 == v24)
  {
    v16 = 4;
    v15 = v24;
    goto LABEL_11;
  }
  if (v25)
  {
    v16 = 5;
LABEL_11:
    (*(void (**)(void))(*v15 + 8 * v16))();
  }
  _Block_object_dispose(&v20, 8);
}

void sub_2169DE3D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void ___ZN10subscriber19EURSimCommandDriver19sendSimApdu_commandENS_15HardwareSimSlotEhhRNSt3__16vectorIhNS2_9allocatorIhEEEENS2_8functionIFvbEEE_block_invoke_65(uint64_t a1, unsigned __int8 **a2)
{
  uint64_t v3;
  unsigned __int8 *v4;
  int v5;
  subscriber *v6;
  NSObject *v7;
  uint64_t v8;
  int v9;
  int v10;
  const char *v11;
  NSObject *v12;
  uint32_t v13;
  NSObject *v14;
  uint64_t v15;
  int v16;
  int v17;
  int v18;
  uint64_t v19;
  __int16 v20;
  int v21;
  __int16 v22;
  int v23;
  __int16 v24;
  int v25;
  __int16 v26;
  const char *v27;
  uint64_t v28;

  v28 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 + 40);
  v4 = *a2;
  if ((unint64_t)(a2[1] - *a2) < 2)
  {
    v14 = *(NSObject **)(v3 + 40);
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      return;
    v15 = subscriber::asString();
    v16 = *(unsigned __int8 *)(a1 + 52);
    v17 = *(unsigned __int8 *)(a1 + 53);
    v18 = 136315650;
    v19 = v15;
    v20 = 1024;
    v21 = v16;
    v22 = 1024;
    v23 = v17;
    v11 = "#I uim::SendAPDU, slot:%s, chan:%d, cmnd:%d get empty CSIM response, treat as OK";
    v12 = v14;
    v13 = 24;
    goto LABEL_8;
  }
  v5 = *v4;
  if (v5 != 145)
  {
    v6 = (subscriber *)(v4[1] | (v5 << 8));
    if ((v4[1] & 0xFE | (unsigned __int16)((_WORD)v5 << 8)) != 0x9000)
    {
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
      v7 = *(NSObject **)(v3 + 40);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        v8 = subscriber::asString();
        v9 = *(unsigned __int8 *)(a1 + 52);
        v10 = *(unsigned __int8 *)(a1 + 53);
        v18 = 136316162;
        v19 = v8;
        v20 = 1024;
        v21 = v9;
        v22 = 1024;
        v23 = v10;
        v24 = 1024;
        v25 = (int)v6;
        v26 = 2080;
        v27 = subscriber::sendAdpuResponseString(v6);
        v11 = "#I uim::SendAPDU, slot:%s, chan:%d, cmnd:%d, CSIM return code is 0x%X '%s'";
        v12 = v7;
        v13 = 40;
LABEL_8:
        _os_log_impl(&dword_216897000, v12, OS_LOG_TYPE_DEFAULT, v11, (uint8_t *)&v18, v13);
      }
    }
  }
}

const char *subscriber::sendAdpuResponseString(subscriber *this)
{
  const char *result;
  unsigned int v2;

  if ((int)this > 28576)
  {
    if ((int)this < 36864)
    {
      if ((_DWORD)this == 28577)
        return "Critical Error. Internal buffer overflow";
      if ((_DWORD)this == 28593)
        return "Critical error. Data formatting error";
    }
    else
    {
      switch((_DWORD)this)
      {
        case 0x9000:
          return "Success";
        case 0x9862:
          return "Security error: MAC not verified";
        case 0x9001:
          return "Success, unsupported field ignored";
      }
    }
  }
  else
  {
    if ((int)this > 27903)
    {
      switch((int)this)
      {
        case 28416:
          return "Critical error. No precise diagnosis";
        case 28417:
          result = "Mobile IP Shared Secret file update error";
          break;
        case 28418:
          result = "Mobile IP UPP file update error";
          break;
        case 28419:
          result = "IMSI_M file update error";
          break;
        case 28420:
          result = "MDN file update error";
          break;
        case 28421:
          result = "ACCOLC file update error";
          break;
        case 28422:
          result = "IMEI file update error";
          break;
        default:
          if ((_DWORD)this != 27904)
            goto LABEL_21;
          result = "APDU is incorrect or has invalid instruction";
          break;
      }
      return result;
    }
    switch((_DWORD)this)
    {
      case 0x6982:
        return "Security error: synchronization failure";
      case 0x6985:
        return "APDU is not in right sequence";
      case 0x6A80:
        return "Last group failed to be updated";
    }
  }
LABEL_21:
  v2 = this >> 8;
  if (this >> 8 == 145)
    return "Success";
  if (v2 == 111)
  {
    if ((this & 0xF0) == 0)
      return "Critical error. No precise diagnosis";
  }
  else if (v2 == 103)
  {
    return "Incorrect data length field (LL) in APDU";
  }
  return "Unknown unspecified error";
}

void subscriber::EURSimCommandDriver::sendSimApdu_close(uint64_t a1, unsigned int a2, char a3, char a4, uint64_t a5)
{
  char *v10;
  char v11;
  const void **v12;
  char *v13;
  _BYTE *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  char *v22;
  uint64_t *v23;
  char *v24;
  char *v25;
  char *v26;
  uint64_t v27;
  uint64_t v28;
  _QWORD *v29;
  void *v30;
  uint64_t v31;
  uint64_t v32;
  void *v33;
  void *__p[2];
  __int128 v35;
  _QWORD aBlock[5];
  _QWORD v37[5];
  _BYTE v38[24];
  _BYTE *v39;
  unsigned int v40;
  char v41;
  char v42;
  uint64_t v43;

  v43 = *MEMORY[0x24BDAC8D0];
  *(_OWORD *)__p = 0u;
  v35 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  v10 = qmi::MutableMessageBase::getTLV<uim::tlv::SlotId>(__p);
  if (a2 >= 4)
    v11 = 0;
  else
    v11 = a2;
  *v10 = v11;
  v12 = (const void **)__p[1];
  if (__p[1] != (void *)v35)
  {
    while (*((_BYTE *)*v12 + 8) != 17)
    {
      if (++v12 == (const void **)v35)
        goto LABEL_11;
    }
  }
  if (v12 == (const void **)v35)
  {
LABEL_11:
    v15 = operator new();
    v16 = v15;
    *(_WORD *)(v15 + 8) = 17;
    *(_QWORD *)v15 = &off_24D5DC338;
    v17 = v35;
    if ((unint64_t)v35 >= *((_QWORD *)&v35 + 1))
    {
      v19 = (uint64_t)(v35 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v19 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v20 = (uint64_t)(*((_QWORD *)&v35 + 1) - (unint64_t)__p[1]) >> 2;
      if (v20 <= v19 + 1)
        v20 = v19 + 1;
      if (*((_QWORD *)&v35 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v21 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v21 = v20;
      if (v21)
        v22 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v35 + 8, v21);
      else
        v22 = 0;
      v23 = (uint64_t *)&v22[8 * v19];
      v24 = &v22[8 * v21];
      *v23 = v16;
      v18 = v23 + 1;
      v26 = (char *)__p[1];
      v25 = (char *)v35;
      if ((void *)v35 != __p[1])
      {
        do
        {
          v27 = *((_QWORD *)v25 - 1);
          v25 -= 8;
          *--v23 = v27;
        }
        while (v25 != v26);
        v25 = (char *)__p[1];
      }
      __p[1] = v23;
      *(_QWORD *)&v35 = v18;
      *((_QWORD *)&v35 + 1) = v24;
      if (v25)
        operator delete(v25);
    }
    else
    {
      *(_QWORD *)v35 = v15;
      v18 = (_QWORD *)(v17 + 8);
    }
    v14 = (_BYTE *)(v16 + 9);
    *(_QWORD *)&v35 = v18;
  }
  else
  {
    if (!v13)
      __cxa_bad_cast();
    v14 = v13 + 9;
  }
  *v14 = a3;
  v32 = QMIServiceMsg::create();
  v28 = MEMORY[0x24BDAC760];
  v37[0] = MEMORY[0x24BDAC760];
  v37[1] = 1174405120;
  v37[2] = ___ZN10subscriber19EURSimCommandDriver17sendSimApdu_closeENS_15HardwareSimSlotEhbNSt3__18functionIFvbEEE_block_invoke_3;
  v37[3] = &__block_descriptor_tmp_80_1;
  v37[4] = a1;
  v40 = a2;
  v29 = v38;
  v41 = a3;
  std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100]((uint64_t)v38, a5);
  v42 = a4;
  aBlock[0] = v28;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3uim14LogicalChannel8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
  aBlock[3] = &unk_24D5DC228;
  aBlock[4] = v37;
  v30 = _Block_copy(aBlock);
  v33 = v30;
  if (v32)
  {
    qmi::Client::send();
    v30 = v33;
  }
  if (v30)
    _Block_release(v30);
  if (v39 == v38)
  {
    v31 = 4;
    goto LABEL_36;
  }
  if (v39)
  {
    v31 = 5;
    v29 = v39;
LABEL_36:
    (*(void (**)(_QWORD *))(*v29 + 8 * v31))(v29);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
}

void sub_2169DEA5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,_QWORD *a32)
{
  _QWORD *v32;
  uint64_t v34;

  if (a32 == v32)
  {
    v34 = 4;
  }
  else
  {
    if (!a32)
      goto LABEL_6;
    v34 = 5;
    v32 = a32;
  }
  (*(void (**)(_QWORD *))(*v32 + 8 * v34))(v32);
LABEL_6:
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)&a10);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a15);
  _Unwind_Resume(a1);
}

void ___ZN10subscriber19EURSimCommandDriver17sendSimApdu_blockENS_15HardwareSimSlotEhNSt3__110shared_ptrINS2_6vectorIhNS2_9allocatorIhEEEEEEiNS2_8functionIFvbEEE_block_invoke_2(uint64_t a1, unint64_t *a2)
{
  unint64_t v4;
  _BYTE *v5;
  _BYTE *v6;
  unint64_t v7;
  _BYTE *v8;
  unint64_t v9;
  unint64_t v10;
  size_t v11;
  unint64_t v12;
  char *v13;
  _BYTE *v14;
  char v15;
  char v16;
  unint64_t v17;
  _BYTE *v18;
  unint64_t v19;
  _BYTE *v20;
  unint64_t v21;
  unint64_t v22;
  size_t v23;
  unint64_t v24;
  char *v25;
  _BYTE *v26;
  char v27;
  int v28;
  unint64_t v29;
  _BYTE *v30;
  unint64_t v31;
  _BYTE *v32;
  unint64_t v33;
  unint64_t v34;
  size_t v35;
  unint64_t v36;
  char *v37;
  _BYTE *v38;
  char v39;
  int v40;
  unint64_t v41;
  _BYTE *v42;
  unint64_t v43;
  _BYTE *v44;
  unint64_t v45;
  unint64_t v46;
  size_t v47;
  unint64_t v48;
  char *v49;
  _BYTE *v50;
  char v51;
  char v52;
  unint64_t v53;
  _BYTE *v54;
  unint64_t v55;
  _BYTE *v56;
  unint64_t v57;
  unint64_t v58;
  size_t v59;
  unint64_t v60;
  char *v61;
  _BYTE *v62;
  char v63;
  uint64_t v64;
  _BYTE *v65;
  _BYTE *v66;
  unint64_t v67;
  uint64_t v68;
  unint64_t v69;
  _BYTE *v70;
  unint64_t v71;
  unint64_t v72;
  size_t v73;
  unint64_t v74;
  char *v75;
  _BYTE *v76;
  char v77;

  std::vector<unsigned char>::reserve(a2);
  v5 = (_BYTE *)a2[1];
  v4 = a2[2];
  if ((unint64_t)v5 >= v4)
  {
    v7 = *a2;
    v8 = &v5[-*a2];
    v9 = (unint64_t)(v8 + 1);
    if ((uint64_t)(v8 + 1) < 0)
      goto LABEL_118;
    v10 = v4 - v7;
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x3FFFFFFFFFFFFFFFLL)
      v11 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v11 = v9;
    if (v11)
      v12 = (unint64_t)operator new(v11);
    else
      v12 = 0;
    v13 = (char *)(v12 + v11);
    v8[v12] = *(_BYTE *)(a1 + 76);
    v6 = &v8[v12 + 1];
    if (v5 == (_BYTE *)v7)
    {
      v12 += (unint64_t)v8;
    }
    else
    {
      v14 = &v5[~v7];
      do
      {
        v15 = *--v5;
        (v14--)[v12] = v15;
      }
      while (v5 != (_BYTE *)v7);
      v5 = (_BYTE *)*a2;
    }
    *a2 = v12;
    a2[1] = (unint64_t)v6;
    a2[2] = (unint64_t)v13;
    if (v5)
      operator delete(v5);
  }
  else
  {
    *v5 = *(_BYTE *)(a1 + 76);
    v6 = v5 + 1;
  }
  a2[1] = (unint64_t)v6;
  if (*(_DWORD *)(a1 + 72))
  {
    if (*(_QWORD *)(a1 + 40) == 248)
      v16 = -94;
    else
      v16 = -93;
  }
  else
  {
    v16 = -95;
  }
  v17 = a2[2];
  if ((unint64_t)v6 < v17)
  {
    *v6 = v16;
    v18 = v6 + 1;
    goto LABEL_42;
  }
  v19 = *a2;
  v20 = &v6[-*a2];
  v21 = (unint64_t)(v20 + 1);
  if ((uint64_t)(v20 + 1) < 0)
    goto LABEL_118;
  v22 = v17 - v19;
  if (2 * v22 > v21)
    v21 = 2 * v22;
  if (v22 >= 0x3FFFFFFFFFFFFFFFLL)
    v23 = 0x7FFFFFFFFFFFFFFFLL;
  else
    v23 = v21;
  if (v23)
    v24 = (unint64_t)operator new(v23);
  else
    v24 = 0;
  v25 = (char *)(v24 + v23);
  v20[v24] = v16;
  v18 = &v20[v24 + 1];
  if (v6 == (_BYTE *)v19)
  {
    *a2 = (unint64_t)&v20[v24];
    a2[1] = (unint64_t)v18;
    a2[2] = (unint64_t)v25;
LABEL_41:
    operator delete(v6);
    goto LABEL_42;
  }
  v26 = &v6[~v19];
  do
  {
    v27 = *--v6;
    (v26--)[v24] = v27;
  }
  while (v6 != (_BYTE *)v19);
  v6 = (_BYTE *)*a2;
  *a2 = v24;
  a2[1] = (unint64_t)v18;
  a2[2] = (unint64_t)v25;
  if (v6)
    goto LABEL_41;
LABEL_42:
  a2[1] = (unint64_t)v18;
  v28 = *(_DWORD *)(a1 + 72);
  v29 = a2[2];
  if ((unint64_t)v18 < v29)
  {
    *v18 = BYTE1(v28);
    v30 = v18 + 1;
    goto LABEL_60;
  }
  v31 = *a2;
  v32 = &v18[-*a2];
  v33 = (unint64_t)(v32 + 1);
  if ((uint64_t)(v32 + 1) < 0)
    goto LABEL_118;
  v34 = v29 - v31;
  if (2 * v34 > v33)
    v33 = 2 * v34;
  if (v34 >= 0x3FFFFFFFFFFFFFFFLL)
    v35 = 0x7FFFFFFFFFFFFFFFLL;
  else
    v35 = v33;
  if (v35)
    v36 = (unint64_t)operator new(v35);
  else
    v36 = 0;
  v37 = (char *)(v36 + v35);
  v32[v36] = BYTE1(v28);
  v30 = &v32[v36 + 1];
  if (v18 == (_BYTE *)v31)
  {
    *a2 = (unint64_t)&v32[v36];
    a2[1] = (unint64_t)v30;
    a2[2] = (unint64_t)v37;
LABEL_59:
    operator delete(v18);
    goto LABEL_60;
  }
  v38 = &v18[~v31];
  do
  {
    v39 = *--v18;
    (v38--)[v36] = v39;
  }
  while (v18 != (_BYTE *)v31);
  v18 = (_BYTE *)*a2;
  *a2 = v36;
  a2[1] = (unint64_t)v30;
  a2[2] = (unint64_t)v37;
  if (v18)
    goto LABEL_59;
LABEL_60:
  a2[1] = (unint64_t)v30;
  v40 = *(_DWORD *)(a1 + 72);
  v41 = a2[2];
  if ((unint64_t)v30 < v41)
  {
    *v30 = v40;
    v42 = v30 + 1;
    goto LABEL_78;
  }
  v43 = *a2;
  v44 = &v30[-*a2];
  v45 = (unint64_t)(v44 + 1);
  if ((uint64_t)(v44 + 1) < 0)
    goto LABEL_118;
  v46 = v41 - v43;
  if (2 * v46 > v45)
    v45 = 2 * v46;
  if (v46 >= 0x3FFFFFFFFFFFFFFFLL)
    v47 = 0x7FFFFFFFFFFFFFFFLL;
  else
    v47 = v45;
  if (v47)
    v48 = (unint64_t)operator new(v47);
  else
    v48 = 0;
  v49 = (char *)(v48 + v47);
  v44[v48] = v40;
  v42 = &v44[v48 + 1];
  if (v30 == (_BYTE *)v43)
  {
    *a2 = (unint64_t)&v44[v48];
    a2[1] = (unint64_t)v42;
    a2[2] = (unint64_t)v49;
LABEL_77:
    operator delete(v30);
    goto LABEL_78;
  }
  v50 = &v30[~v43];
  do
  {
    v51 = *--v30;
    (v50--)[v48] = v51;
  }
  while (v30 != (_BYTE *)v43);
  v30 = (_BYTE *)*a2;
  *a2 = v48;
  a2[1] = (unint64_t)v42;
  a2[2] = (unint64_t)v49;
  if (v30)
    goto LABEL_77;
LABEL_78:
  a2[1] = (unint64_t)v42;
  v52 = *(_BYTE *)(a1 + 40);
  v53 = a2[2];
  if ((unint64_t)v42 < v53)
  {
    *v42 = v52;
    v54 = v42 + 1;
    goto LABEL_96;
  }
  v55 = *a2;
  v56 = &v42[-*a2];
  v57 = (unint64_t)(v56 + 1);
  if ((uint64_t)(v56 + 1) < 0)
LABEL_118:
    std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
  v58 = v53 - v55;
  if (2 * v58 > v57)
    v57 = 2 * v58;
  if (v58 >= 0x3FFFFFFFFFFFFFFFLL)
    v59 = 0x7FFFFFFFFFFFFFFFLL;
  else
    v59 = v57;
  if (v59)
    v60 = (unint64_t)operator new(v59);
  else
    v60 = 0;
  v61 = (char *)(v60 + v59);
  v56[v60] = v52;
  v54 = &v56[v60 + 1];
  if (v42 == (_BYTE *)v55)
  {
    *a2 = (unint64_t)&v56[v60];
    a2[1] = (unint64_t)v54;
    a2[2] = (unint64_t)v61;
LABEL_95:
    operator delete(v42);
    goto LABEL_96;
  }
  v62 = &v42[~v55];
  do
  {
    v63 = *--v42;
    (v62--)[v60] = v63;
  }
  while (v42 != (_BYTE *)v55);
  v42 = (_BYTE *)*a2;
  *a2 = v60;
  a2[1] = (unint64_t)v54;
  a2[2] = (unint64_t)v61;
  if (v42)
    goto LABEL_95;
LABEL_96:
  a2[1] = (unint64_t)v54;
  v64 = *(_QWORD *)(a1 + 40);
  if (v64 >= 1)
  {
    v65 = (_BYTE *)(**(_QWORD **)(a1 + 48) + *(_QWORD *)(a1 + 64));
    v66 = &v65[v64];
    do
    {
      v67 = a2[2];
      if ((unint64_t)v54 >= v67)
      {
        v69 = *a2;
        v70 = &v54[-*a2];
        v71 = (unint64_t)(v70 + 1);
        if ((uint64_t)(v70 + 1) < 0)
          goto LABEL_118;
        v72 = v67 - v69;
        if (2 * v72 > v71)
          v71 = 2 * v72;
        if (v72 >= 0x3FFFFFFFFFFFFFFFLL)
          v73 = 0x7FFFFFFFFFFFFFFFLL;
        else
          v73 = v71;
        if (v73)
          v74 = (unint64_t)operator new(v73);
        else
          v74 = 0;
        v75 = (char *)(v74 + v73);
        v70[v74] = *v65;
        v68 = (uint64_t)&v70[v74 + 1];
        if (v54 == (_BYTE *)v69)
        {
          *a2 = (unint64_t)&v70[v74];
          a2[1] = v68;
          a2[2] = (unint64_t)v75;
        }
        else
        {
          v76 = &v54[~v69];
          do
          {
            v77 = *--v54;
            (v76--)[v74] = v77;
          }
          while (v54 != (_BYTE *)v69);
          v54 = (_BYTE *)*a2;
          *a2 = v74;
          a2[1] = v68;
          a2[2] = (unint64_t)v75;
          if (!v54)
            goto LABEL_116;
        }
        operator delete(v54);
      }
      else
      {
        *v54 = *v65;
        v68 = (uint64_t)(v54 + 1);
      }
LABEL_116:
      a2[1] = v68;
      ++v65;
      v54 = (_BYTE *)v68;
    }
    while (v65 < v66);
  }
}

uint64_t __copy_helper_block_e8_48c57_ZTSNSt3__110shared_ptrINS_6vectorIhNS_9allocatorIhEEEEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(result + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 56) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_48c57_ZTSNSt3__110shared_ptrINS_6vectorIhNS_9allocatorIhEEEEEE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 48);
}

uint64_t ___ZN10subscriber19EURSimCommandDriver17sendSimApdu_blockENS_15HardwareSimSlotEhNSt3__110shared_ptrINS2_6vectorIhNS2_9allocatorIhEEEEEEiNS2_8functionIFvbEEE_block_invoke_71(uint64_t result, _BYTE *a2)
{
  *a2 = *(_BYTE *)(result + 32);
  return result;
}

void ___ZN10subscriber19EURSimCommandDriver17sendSimApdu_blockENS_15HardwareSimSlotEhNSt3__110shared_ptrINS2_6vectorIhNS2_9allocatorIhEEEEEEiNS2_8functionIFvbEEE_block_invoke_2_73(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  int v7;
  int v8;
  unsigned int v9;
  char v10;
  _QWORD *v11;
  uint64_t v12;
  int v13;
  unsigned int v14;
  char v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *p_shared_owners;
  unint64_t v22;
  int v23;
  uint64_t v24;
  _QWORD *v25;
  uint64_t v26;
  unint64_t *v27;
  unint64_t v28;
  _QWORD v29[2];
  _QWORD v30[6];
  int v31;
  char v32;
  _QWORD *v33;
  _BYTE v34[24];
  _BYTE *v35;
  _BYTE v36[24];
  _BYTE *v37;
  _BYTE v38[24];
  _BYTE *v39;
  _BYTE buf[24];
  __int16 v41;
  uint64_t v42;
  uint64_t v43;

  v43 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)(a1 + 32);
  if (!*((_DWORD *)a2 + 1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2000000000;
    LOBYTE(v41) = 1;
    v30[0] = MEMORY[0x24BDAC760];
    v30[1] = 0x40000000;
    v30[2] = ___ZN10subscriber19EURSimCommandDriver17sendSimApdu_blockENS_15HardwareSimSlotEhNSt3__110shared_ptrINS2_6vectorIhNS2_9allocatorIhEEEEEEiNS2_8functionIFvbEEE_block_invoke_74;
    v30[3] = &unk_24D5DB2E8;
    v30[4] = buf;
    v30[5] = v4;
    v31 = *(_DWORD *)(a1 + 96);
    v32 = *(_BYTE *)(a1 + 104);
    v33 = v30;
    qmi::MessageBase::applyTlv<uim::tlv::APDU,void({block_pointer}&)(uim::tlv::APDU const&)>(a2, (uint64_t)&v33);
    v13 = *(unsigned __int8 *)(*(_QWORD *)&buf[8] + 24);
    if (!*(_BYTE *)(*(_QWORD *)&buf[8] + 24) || *(_QWORD *)(a1 + 72) != 248 && *(_DWORD *)(a1 + 100))
    {
      v14 = *(_DWORD *)(a1 + 96);
      v15 = *(_BYTE *)(a1 + 104);
      std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100]((uint64_t)v34, a1 + 40);
      subscriber::EURSimCommandDriver::sendSimApdu_close(v4, v14, v15, v13 != 0, (uint64_t)v34);
      v16 = v35;
      if (v35 == v34)
      {
        v17 = 4;
        v16 = v34;
      }
      else
      {
        if (!v35)
        {
LABEL_30:
          _Block_object_dispose(buf, 8);
          return;
        }
        v17 = 5;
      }
      (*(void (**)(void))(*v16 + 8 * v17))();
      goto LABEL_30;
    }
    v18 = *(unsigned int *)(a1 + 96);
    v19 = *(unsigned __int8 *)(a1 + 104);
    v20 = *(std::__shared_weak_count **)(a1 + 88);
    v29[0] = *(_QWORD *)(a1 + 80);
    v29[1] = v20;
    if (v20)
    {
      p_shared_owners = (unint64_t *)&v20->__shared_owners_;
      do
        v22 = __ldxr(p_shared_owners);
      while (__stxr(v22 + 1, p_shared_owners));
    }
    v23 = *(_DWORD *)(a1 + 100);
    std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100]((uint64_t)v36, a1 + 40);
    subscriber::EURSimCommandDriver::sendSimApdu_block(v4, v18, v19, v29, (v23 + 1), v36);
    v25 = v37;
    if (v37 == v36)
    {
      v26 = 4;
      v25 = v36;
    }
    else
    {
      if (!v37)
      {
LABEL_25:
        if (v20)
        {
          v27 = (unint64_t *)&v20->__shared_owners_;
          do
            v28 = __ldaxr(v27);
          while (__stlxr(v28 - 1, v27));
          if (!v28)
          {
            ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
            std::__shared_weak_count::__release_weak(v20);
          }
        }
        goto LABEL_30;
      }
      v26 = 5;
    }
    (*(void (**)(_QWORD *, uint64_t))(*v25 + 8 * v26))(v25, v24);
    goto LABEL_25;
  }
  v5 = *(NSObject **)(v4 + 40);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    v6 = subscriber::asString();
    v7 = *(unsigned __int8 *)(a1 + 104);
    v8 = *((_DWORD *)a2 + 1);
    *(_DWORD *)buf = 136315906;
    *(_QWORD *)&buf[4] = v6;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v7;
    *(_WORD *)&buf[18] = 1024;
    *(_DWORD *)&buf[20] = v8;
    v41 = 2080;
    v42 = qmi::asString();
    _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#I uim::SendAPDU, slot:%s, chan:%d, sending block, get QMI error 0x%04x (%s)", buf, 0x22u);
  }
  v9 = *(_DWORD *)(a1 + 96);
  v10 = *(_BYTE *)(a1 + 104);
  std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100]((uint64_t)v38, a1 + 40);
  subscriber::EURSimCommandDriver::sendSimApdu_close(v4, v9, v10, 0, (uint64_t)v38);
  v11 = v39;
  if (v39 == v38)
  {
    v12 = 4;
    v11 = v38;
  }
  else
  {
    if (!v39)
      return;
    v12 = 5;
  }
  (*(void (**)(void))(*v11 + 8 * v12))();
}

void sub_2169DF330(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,char *a26)
{
  char *v26;
  uint64_t v27;
  char *v29;
  uint64_t v30;

  v29 = a26;
  if (a26 == v26)
  {
    v30 = 4;
    v29 = &a23;
  }
  else
  {
    if (!a26)
      goto LABEL_6;
    v30 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v29 + 8 * v30))();
LABEL_6:
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Block_object_dispose((const void *)(v27 - 112), 8);
  _Unwind_Resume(a1);
}

void ___ZN10subscriber19EURSimCommandDriver17sendSimApdu_blockENS_15HardwareSimSlotEhNSt3__110shared_ptrINS2_6vectorIhNS2_9allocatorIhEEEEEEiNS2_8functionIFvbEEE_block_invoke_74(uint64_t a1, unsigned __int8 **a2)
{
  uint64_t v3;
  unsigned __int8 *v4;
  int v5;
  subscriber *v6;
  NSObject *v7;
  uint64_t v8;
  int v9;
  const char *v10;
  NSObject *v11;
  uint32_t v12;
  NSObject *v13;
  uint64_t v14;
  int v15;
  int v16;
  uint64_t v17;
  __int16 v18;
  int v19;
  __int16 v20;
  int v21;
  __int16 v22;
  const char *v23;
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 + 40);
  v4 = *a2;
  if ((unint64_t)(a2[1] - *a2) < 2)
  {
    v13 = *(NSObject **)(v3 + 40);
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      return;
    v14 = subscriber::asString();
    v15 = *(unsigned __int8 *)(a1 + 52);
    v16 = 136315394;
    v17 = v14;
    v18 = 1024;
    v19 = v15;
    v10 = "#I uim::SendAPDU, slot:%s, chan:%d, sending block, get empty CSIM response, treat as OK";
    v11 = v13;
    v12 = 18;
    goto LABEL_8;
  }
  v5 = *v4;
  if (v5 != 145)
  {
    v6 = (subscriber *)(v4[1] | (v5 << 8));
    if ((v4[1] & 0xFE | (unsigned __int16)((_WORD)v5 << 8)) != 0x9000)
    {
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
      v7 = *(NSObject **)(v3 + 40);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        v8 = subscriber::asString();
        v9 = *(unsigned __int8 *)(a1 + 52);
        v16 = 136315906;
        v17 = v8;
        v18 = 1024;
        v19 = v9;
        v20 = 1024;
        v21 = (int)v6;
        v22 = 2080;
        v23 = subscriber::sendAdpuResponseString(v6);
        v10 = "#I uim::SendAPDU, slot:%s, chan:%d, sending block, CSIM return code is 0x%X '%s'";
        v11 = v7;
        v12 = 34;
LABEL_8:
        _os_log_impl(&dword_216897000, v11, OS_LOG_TYPE_DEFAULT, v10, (uint8_t *)&v16, v12);
      }
    }
  }
}

uint64_t __copy_helper_block_e8_40c27_ZTSNSt3__18functionIFvbEEE80c57_ZTSNSt3__110shared_ptrINS_6vectorIhNS_9allocatorIhEEEEEE(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;

  result = std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100](a1 + 40, a2 + 40);
  v5 = *(_QWORD *)(a2 + 88);
  *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
  *(_QWORD *)(a1 + 88) = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  return result;
}

_QWORD *__destroy_helper_block_e8_40c27_ZTSNSt3__18functionIFvbEEE80c57_ZTSNSt3__110shared_ptrINS_6vectorIhNS_9allocatorIhEEEEEE(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *result;
  uint64_t v4;

  v2 = (_QWORD *)(a1 + 40);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 80);
  result = *(_QWORD **)(a1 + 64);
  if (result == v2)
  {
    v4 = 4;
    result = v2;
  }
  else
  {
    if (!result)
      return result;
    v4 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v4))();
}

uint64_t ___ZN10subscriber19EURSimCommandDriver17sendSimApdu_closeENS_15HardwareSimSlotEhbNSt3__18functionIFvbEEE_block_invoke_3(uint64_t a1, uint64_t a2)
{
  int v4;
  NSObject *v5;
  _BOOL4 v6;
  uint64_t v7;
  int v8;
  int v9;
  const char *v10;
  NSObject *v11;
  uint32_t v12;
  uint64_t v13;
  int v14;
  BOOL v15;
  char v16;
  uint64_t v17;
  int v19;
  uint64_t v20;
  __int16 v21;
  int v22;
  __int16 v23;
  int v24;
  __int16 v25;
  uint64_t v26;
  uint64_t v27;

  v27 = *MEMORY[0x24BDAC8D0];
  v4 = *(_DWORD *)(a2 + 4);
  v5 = *(NSObject **)(*(_QWORD *)(a1 + 32) + 40);
  v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (v4)
  {
    if (!v6)
      goto LABEL_7;
    v7 = subscriber::asString();
    v8 = *(unsigned __int8 *)(a1 + 76);
    v9 = *(_DWORD *)(a2 + 4);
    v19 = 136315906;
    v20 = v7;
    v21 = 1024;
    v22 = v8;
    v23 = 1024;
    v24 = v9;
    v25 = 2080;
    v26 = qmi::asString();
    v10 = "#I uim::LogicalChannel, slot:%s, chan:%d, close() failed with QMI error 0x%04x (%s)";
    v11 = v5;
    v12 = 34;
  }
  else
  {
    if (!v6)
      goto LABEL_7;
    v13 = subscriber::asString();
    v14 = *(unsigned __int8 *)(a1 + 76);
    v19 = 136315394;
    v20 = v13;
    v21 = 1024;
    v22 = v14;
    v10 = "#I uim::LogicalChannel, slot:%s channel %d closed";
    v11 = v5;
    v12 = 18;
  }
  _os_log_impl(&dword_216897000, v11, OS_LOG_TYPE_DEFAULT, v10, (uint8_t *)&v19, v12);
LABEL_7:
  if (*(_BYTE *)(a1 + 77))
    v15 = *(_DWORD *)(a2 + 4) == 0;
  else
    v15 = 0;
  v16 = v15;
  LOBYTE(v19) = v16;
  v17 = *(_QWORD *)(a1 + 64);
  if (!v17)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, int *))(*(_QWORD *)v17 + 48))(v17, &v19);
}

void subscriber::EURSimCommandDriver::~EURSimCommandDriver(subscriber::EURSimCommandDriver *this)
{
  subscriber::EURSimCommandDriver::~EURSimCommandDriver(this);
  JUMPOUT(0x2199FEAC4);
}

{
  void *v2;
  NSObject *v3;

  *(_QWORD *)this = &unk_24D5DAC80;
  std::__tree<std::__value_type<unsigned int,std::vector<unsigned char>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<unsigned char>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::vector<unsigned char>>>>::destroy(*((_QWORD **)this + 35));
  std::__tree<std::__value_type<AQMThroughputKey,unsigned int>,std::__map_value_compare<AQMThroughputKey,std::__value_type<AQMThroughputKey,unsigned int>,std::less<AQMThroughputKey>,true>,std::allocator<std::__value_type<AQMThroughputKey,unsigned int>>>::destroy(*((_QWORD **)this + 32));
  std::__tree<std::__value_type<unsigned int,std::string>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::string>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::string>>>::destroy(*((char **)this + 29));
  v2 = (void *)*((_QWORD *)this + 25);
  if (v2)
  {
    *((_QWORD *)this + 26) = v2;
    operator delete(v2);
  }
  std::__tree<std::__value_type<uim::SessionType,dispatch::group_session>,std::__map_value_compare<uim::SessionType,std::__value_type<uim::SessionType,dispatch::group_session>,std::less<uim::SessionType>,true>,std::allocator<std::__value_type<uim::SessionType,dispatch::group_session>>>::destroy(*((_QWORD **)this + 23));
  v3 = *((_QWORD *)this + 21);
  if (v3)
    dispatch_release(v3);
  qmi::Client::~Client((subscriber::EURSimCommandDriver *)((char *)this + 128));
  subscriber::SimCommandDriver::~SimCommandDriver(this);
}

void sub_2169DF814(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void *v4;

  v4 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 16) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<subscriber::SimDriverInfo>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 144;
        std::__destroy_at[abi:ne180100]<subscriber::SimDriverInfo,0>(v4);
      }
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::__destroy_at[abi:ne180100]<subscriber::SimDriverInfo,0>(uint64_t a1)
{
  void *v2;
  void *v3;
  void **v4;

  if (*(char *)(a1 + 143) < 0)
    operator delete(*(void **)(a1 + 120));
  v4 = (void **)(a1 + 96);
  std::vector<pbm::tlv::AdditionalNumberParam>::__destroy_vector::operator()[abi:ne180100](&v4);
  v2 = *(void **)(a1 + 72);
  if (v2)
  {
    *(_QWORD *)(a1 + 80) = v2;
    operator delete(v2);
  }
  v3 = *(void **)(a1 + 40);
  if (v3)
  {
    *(_QWORD *)(a1 + 48) = v3;
    operator delete(v3);
  }
}

uint64_t std::__split_buffer<subscriber::NpAppInfo>::~__split_buffer(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  v3 = *(_QWORD *)(a1 + 8);
  v2 = *(_QWORD *)(a1 + 16);
  while (v2 != v3)
  {
    *(_QWORD *)(a1 + 16) = v2 - 40;
    v4 = *(void **)(v2 - 32);
    if (v4)
    {
      *(_QWORD *)(v2 - 24) = v4;
      operator delete(v4);
      v2 = *(_QWORD *)(a1 + 16);
    }
    else
    {
      v2 -= 40;
    }
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

char *std::vector<uim::tlv::FileId>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 59)
    std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<vs::tlv::RemoteNumberListItem>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[32 * v4];
  return result;
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<uim::tlv::FileId>,uim::tlv::FileId*,uim::tlv::FileId*,uim::tlv::FileId*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v6;
  _QWORD v8[3];
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v4 = a4;
  v10 = a4;
  v11 = a4;
  v8[0] = a1;
  v8[1] = &v10;
  v8[2] = &v11;
  v9 = 0;
  if (a2 != a3)
  {
    v6 = a2;
    do
    {
      *(_WORD *)v4 = *(_WORD *)v6;
      *(_QWORD *)(v4 + 16) = 0;
      *(_QWORD *)(v4 + 24) = 0;
      *(_QWORD *)(v4 + 8) = 0;
      std::vector<unsigned short>::__init_with_size[abi:ne180100]<unsigned short *,unsigned short *>((_QWORD *)(v4 + 8), *(const void **)(v6 + 8), *(_QWORD *)(v6 + 16), (uint64_t)(*(_QWORD *)(v6 + 16) - *(_QWORD *)(v6 + 8)) >> 1);
      v4 = v11 + 32;
      v11 += 32;
      v6 += 32;
    }
    while (v6 != a3);
  }
  LOBYTE(v9) = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<at::tlv::CommandCallback>,at::tlv::CommandCallback*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v8);
  return v4;
}

void sub_2169DFA44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<at::tlv::CommandCallback>,at::tlv::CommandCallback*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<uim::tlv::FileId *,uim::tlv::FileId *,uim::tlv::FileId *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;

  if (a1 != a2)
  {
    v5 = a1;
    do
    {
      *(_WORD *)a3 = *(_WORD *)v5;
      if (v5 != a3)
        std::vector<unsigned short>::__assign_with_size[abi:ne180100]<unsigned short *,unsigned short *>((char *)(a3 + 8), *(char **)(v5 + 8), *(_QWORD *)(v5 + 16), (uint64_t)(*(_QWORD *)(v5 + 16) - *(_QWORD *)(v5 + 8)) >> 1);
      v5 += 32;
      a3 += 32;
    }
    while (v5 != a2);
  }
  return a3;
}

_QWORD *std::vector<uim::tlv::FileId>::__init_with_size[abi:ne180100]<uim::tlv::FileId*,uim::tlv::FileId*>(_QWORD *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;

  if (a4)
  {
    v6 = result;
    std::vector<uim::tlv::FileId>::__vallocate[abi:ne180100](result, a4);
    result = (_QWORD *)std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<uim::tlv::FileId>,uim::tlv::FileId*,uim::tlv::FileId*,uim::tlv::FileId*>((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_2169DFB28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  uint64_t v9;
  uint64_t v10;

  *(_QWORD *)(v9 + 8) = v10;
  std::vector<at::tlv::CommandCallback>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

void std::__tree<std::__value_type<unsigned int,std::vector<unsigned char>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<unsigned char>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::vector<unsigned char>>>>::destroy(_QWORD *a1)
{
  void *v2;

  if (a1)
  {
    std::__tree<std::__value_type<unsigned int,std::vector<unsigned char>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<unsigned char>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::vector<unsigned char>>>>::destroy(*a1);
    std::__tree<std::__value_type<unsigned int,std::vector<unsigned char>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<unsigned char>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::vector<unsigned char>>>>::destroy(a1[1]);
    v2 = (void *)a1[5];
    if (v2)
    {
      a1[6] = v2;
      operator delete(v2);
    }
    operator delete(a1);
  }
}

void std::__tree<std::__value_type<unsigned int,std::string>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::string>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::string>>>::destroy(char *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<unsigned int,std::string>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::string>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::string>>>::destroy(*(_QWORD *)a1);
    std::__tree<std::__value_type<unsigned int,std::string>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::string>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::string>>>::destroy(*((_QWORD *)a1 + 1));
    if (a1[63] < 0)
      operator delete(*((void **)a1 + 5));
    operator delete(a1);
  }
}

void std::__tree<std::__value_type<uim::SessionType,dispatch::group_session>,std::__map_value_compare<uim::SessionType,std::__value_type<uim::SessionType,dispatch::group_session>,std::less<uim::SessionType>,true>,std::allocator<std::__value_type<uim::SessionType,dispatch::group_session>>>::destroy(_QWORD *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<uim::SessionType,dispatch::group_session>,std::__map_value_compare<uim::SessionType,std::__value_type<uim::SessionType,dispatch::group_session>,std::less<uim::SessionType>,true>,std::allocator<std::__value_type<uim::SessionType,dispatch::group_session>>>::destroy(*a1);
    std::__tree<std::__value_type<uim::SessionType,dispatch::group_session>,std::__map_value_compare<uim::SessionType,std::__value_type<uim::SessionType,dispatch::group_session>,std::less<uim::SessionType>,true>,std::allocator<std::__value_type<uim::SessionType,dispatch::group_session>>>::destroy(a1[1]);
    std::__destroy_at[abi:ne180100]<std::pair<uim::SessionType const,dispatch::group_session>,0>((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

void std::__destroy_at[abi:ne180100]<std::pair<uim::SessionType const,dispatch::group_session>,0>(uint64_t a1)
{
  NSObject *v2;
  NSObject *v3;

  v2 = *(NSObject **)(a1 + 8);
  if (v2)
  {
    dispatch_group_leave(v2);
    v3 = *(NSObject **)(a1 + 8);
    if (v3)
      dispatch_release(v3);
  }
}

uint64_t *std::shared_ptr<subscriber::EURSimCommandDriver>::shared_ptr[abi:ne180100]<subscriber::EURSimCommandDriver,std::shared_ptr<subscriber::EURSimCommandDriver> ctu::SharedSynchronizable<subscriber::SimCommandDriver>::make_shared_ptr<subscriber::EURSimCommandDriver>(subscriber::EURSimCommandDriver*)::{lambda(subscriber::EURSimCommandDriver*)#1},void>(uint64_t *a1, uint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24D5DB390;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = (uint64_t)v4;
  if (a2)
    v5 = (_QWORD *)(a2 + 8);
  else
    v5 = 0;
  std::shared_ptr<QMIDataSystemDeterminationManager>::__enable_weak_this[abi:ne180100]<QMIDataSystemDeterminationManager,QMIDataSystemDeterminationManager,void>((uint64_t)a1, v5, a2);
  return a1;
}

void sub_2169DFD30(void *a1)
{
  dispatch_queue_t *v1;

  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)std::shared_ptr<subscriber::EURSimCommandDriver> ctu::SharedSynchronizable<subscriber::SimCommandDriver>::make_shared_ptr<subscriber::EURSimCommandDriver>(subscriber::EURSimCommandDriver*)::{lambda(subscriber::EURSimCommandDriver*)#1}::operator() const(subscriber::EURSimCommandDriver*)::{lambda(void *)#1}::__invoke);
  __cxa_rethrow();
}

void sub_2169DFD50(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<subscriber::EURSimCommandDriver *,std::shared_ptr<subscriber::EURSimCommandDriver> ctu::SharedSynchronizable<subscriber::SimCommandDriver>::make_shared_ptr<subscriber::EURSimCommandDriver>(subscriber::EURSimCommandDriver*)::{lambda(subscriber::EURSimCommandDriver *)#1},std::allocator<subscriber::EURSimCommandDriver>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void std::__shared_ptr_pointer<subscriber::EURSimCommandDriver *,std::shared_ptr<subscriber::EURSimCommandDriver> ctu::SharedSynchronizable<subscriber::SimCommandDriver>::make_shared_ptr<subscriber::EURSimCommandDriver>(subscriber::EURSimCommandDriver*)::{lambda(subscriber::EURSimCommandDriver *)#1},std::allocator<subscriber::EURSimCommandDriver>>::__on_zero_shared(uint64_t a1)
{
  dispatch_barrier_async_f(*(dispatch_queue_t *)(*(_QWORD *)(a1 + 24) + 24), *(void **)(a1 + 24), (dispatch_function_t)std::shared_ptr<subscriber::EURSimCommandDriver> ctu::SharedSynchronizable<subscriber::SimCommandDriver>::make_shared_ptr<subscriber::EURSimCommandDriver>(subscriber::EURSimCommandDriver*)::{lambda(subscriber::EURSimCommandDriver*)#1}::operator() const(subscriber::EURSimCommandDriver*)::{lambda(void *)#1}::__invoke);
}

uint64_t std::__shared_ptr_pointer<subscriber::EURSimCommandDriver *,std::shared_ptr<subscriber::EURSimCommandDriver> ctu::SharedSynchronizable<subscriber::SimCommandDriver>::make_shared_ptr<subscriber::EURSimCommandDriver>(subscriber::EURSimCommandDriver*)::{lambda(subscriber::EURSimCommandDriver *)#1},std::allocator<subscriber::EURSimCommandDriver>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t std::shared_ptr<subscriber::EURSimCommandDriver> ctu::SharedSynchronizable<subscriber::SimCommandDriver>::make_shared_ptr<subscriber::EURSimCommandDriver>(subscriber::EURSimCommandDriver*)::{lambda(subscriber::EURSimCommandDriver*)#1}::operator() const(subscriber::EURSimCommandDriver*)::{lambda(void *)#1}::__invoke(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 48))(result);
  return result;
}

void std::__function::__func<char const* const (*)(subscriber::HardwareSimSlot),std::allocator<char const* const (*)(subscriber::HardwareSimSlot)>,char const* const ()(subscriber::HardwareSimSlot)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<char const* const (*)(subscriber::HardwareSimSlot),std::allocator<char const* const (*)(subscriber::HardwareSimSlot)>,char const* const ()(subscriber::HardwareSimSlot)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5DB3F0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<char const* const (*)(subscriber::HardwareSimSlot),std::allocator<char const* const (*)(subscriber::HardwareSimSlot)>,char const* const ()(subscriber::HardwareSimSlot)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5DB3F0;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<char const* const (*)(subscriber::HardwareSimSlot),std::allocator<char const* const (*)(subscriber::HardwareSimSlot)>,char const* const ()(subscriber::HardwareSimSlot)>::operator()(uint64_t a1, unsigned int *a2)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 8))(*a2);
}

uint64_t std::__function::__func<char const* const (*)(subscriber::HardwareSimSlot),std::allocator<char const* const (*)(subscriber::HardwareSimSlot)>,char const* const ()(subscriber::HardwareSimSlot)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<char const* const (*)(subscriber::HardwareSimSlot),std::allocator<char const* const (*)(subscriber::HardwareSimSlot)>,char const* const ()(subscriber::HardwareSimSlot)>::target_type()
{
}

void ___ZNK3qmi6Client13setIndHandlerIRKN3uim16CardStatusChange10IndicationEEEvtU13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2169DFF6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ___ZNK3qmi6Client13setIndHandlerIRKN3uim7Refresh10IndicationEEEvtU13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2169E0068(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ___ZNK3qmi6Client13setIndHandlerIRKN3uim18CardDebounceStatus10IndicationEEEvtU13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2169E0164(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<uim::tlv::EventMask>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<uim::tlv::EventMask>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

_DWORD **qmi::MutableMessageBase::TlvWrapper<uim::tlv::EventMask>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _DWORD *v4;
  uint64_t v5;
  _DWORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_DWORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::PktDataHandle>((_DWORD **)a2, (_DWORD *)(a1 + 12));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<uim::tlv::EventMask>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5DB520;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a1 + 12);
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<uim::tlv::GetExtendedStatus>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<uim::tlv::GetExtendedStatus>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<uim::tlv::GetExtendedStatus>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<uim::tlv::GetExtendedStatus>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5DB570;
  return result;
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3uim13GetCardStatus8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2169E03E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ___ZN10subscriber19sHandleVinylAbilityIN3uim13GetCardStatus8ResponseEEEvRKT_RNSt3__16vectorINS_15VinylCapabilityENS7_9allocatorIS9_EEEE_block_invoke(uint64_t a1, char **a2)
{
  char **v4;
  unint64_t v5;
  char *v6;
  char *v7;
  int *v8;
  char v9;
  int v10;
  int v11;
  int v12;

  v4 = *(char ***)(a1 + 32);
  v5 = a2[1] - *a2;
  v12 = 1;
  std::vector<subscriber::VinylCapability>::resize(v4, v5, &v12);
  v6 = *a2;
  v7 = a2[1];
  if (*a2 != v7)
  {
    v8 = **(int ***)(a1 + 32);
    do
    {
      v9 = *v6++;
      v10 = (v9 - 1) + 2;
      if (((v9 - 1) & 0xFC) != 0)
        v11 = 1;
      else
        v11 = v10;
      *v8++ = v11;
    }
    while (v6 != v7);
  }
}

void std::vector<subscriber::VinylCapability>::resize(char **a1, unint64_t a2, _DWORD *a3)
{
  char *v5;
  char *v6;
  unint64_t v7;
  char *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t v14;
  char *v15;
  char *v16;
  uint64_t v17;
  char *v18;
  char *v19;
  char *v20;
  char *i;
  int v22;
  char *v23;
  uint64_t v24;

  v6 = *a1;
  v5 = a1[1];
  v7 = (v5 - *a1) >> 2;
  if (a2 <= v7)
  {
    if (a2 < v7)
      a1[1] = &v6[4 * a2];
  }
  else
  {
    v9 = a1[2];
    if (a2 - v7 <= (v9 - v5) >> 2)
    {
      v23 = &v5[4 * (a2 - v7)];
      v24 = 4 * a2 - 4 * v7;
      do
      {
        *(_DWORD *)v5 = *a3;
        v5 += 4;
        v24 -= 4;
      }
      while (v24);
      a1[1] = v23;
    }
    else
    {
      if (a2 >> 62)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v10 = v9 - v6;
      v11 = (v9 - v6) >> 1;
      if (v11 <= a2)
        v11 = a2;
      if (v10 >= 0x7FFFFFFFFFFFFFFCLL)
        v12 = 0x3FFFFFFFFFFFFFFFLL;
      else
        v12 = v11;
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<subscriber::HardwareSimSlot>>(v12);
      v15 = &v13[4 * v7];
      v16 = &v13[4 * a2];
      v17 = 4 * a2 - 4 * v7;
      v18 = v15;
      do
      {
        *(_DWORD *)v18 = *a3;
        v18 += 4;
        v17 -= 4;
      }
      while (v17);
      v19 = &v13[4 * v14];
      v20 = *a1;
      for (i = a1[1]; i != v20; i -= 4)
      {
        v22 = *((_DWORD *)i - 1);
        *((_DWORD *)v15 - 1) = v22;
        v15 -= 4;
      }
      *a1 = v15;
      a1[1] = v16;
      a1[2] = v19;
      if (v20)
        operator delete(v20);
    }
  }
}

char *std::vector<subscriber::VinylCapability>::__assign_with_size[abi:ne180100]<subscriber::VinylCapability const*,subscriber::VinylCapability const*>(char *result, void *__src, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  size_t v12;
  void **v13;
  _BYTE *v14;

  v6 = result;
  v7 = *((_QWORD *)result + 2);
  v8 = *(char **)result;
  if (a4 <= (v7 - *(_QWORD *)result) >> 2)
  {
    v13 = (void **)(result + 8);
    v14 = (_BYTE *)*((_QWORD *)result + 1);
    if (a4 > (v14 - v8) >> 2 && v14 != v8)
    {
      result = (char *)memmove(*(void **)result, __src, v14 - v8);
      v8 = (char *)*v13;
    }
    v12 = a3 - (_QWORD)__src;
    if (v12)
      result = (char *)memmove(v8, __src, v12);
  }
  else
  {
    if (v8)
    {
      *((_QWORD *)result + 1) = v8;
      operator delete(v8);
      v7 = 0;
      *v6 = 0;
      v6[1] = 0;
      v6[2] = 0;
    }
    v9 = v7 >> 1;
    if ((unint64_t)(v7 >> 1) <= 1)
      v9 = 1;
    if ((unint64_t)v7 >= 0x7FFFFFFFFFFFFFFCLL)
      v10 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v10 = v9;
    if (v10 >> 62)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<subscriber::HardwareSimSlot>>(v10);
    v8 = result;
    *v6 = result;
    v6[1] = result;
    v6[2] = &result[4 * v11];
    v12 = a3 - (_QWORD)__src;
    if (v12)
      result = (char *)memmove(result, __src, v12);
    v13 = (void **)(v6 + 1);
  }
  *v13 = &v8[v12];
  return result;
}

uint64_t qmi::MessageBase::applyTlv<uim::tlv::VinylSupport,void({block_pointer}&)(uim::tlv::VinylSupport const&)>(qmi::MessageBase *a1, uint64_t a2)
{
  uint64_t result;
  int v5;
  uint64_t v6;
  int v7;
  char *v8;
  void *__p;
  void *v10;
  uint64_t v11;
  char *v12;

  result = qmi::MessageBase::findTlvValue(a1);
  if (result)
  {
    v6 = result;
    v7 = v5;
    v11 = 0;
    v12 = (char *)result;
    __p = 0;
    v10 = 0;
    tlv::parseV<uim::tlv::VinylSupport>(&v12, v5, &__p);
    v8 = v12;
    if (v12)
      (*(void (**)(void))(*(_QWORD *)a2 + 16))();
    if (__p)
    {
      v10 = __p;
      operator delete(__p);
    }
    if (v8)
      return 1;
    else
      return ((uint64_t (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, 33, v6, v7);
  }
  return result;
}

void sub_2169E07D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t qmi::MessageBase::applyTlv<uim::tlv::VinylSupportLegacy,void({block_pointer}&)(uim::tlv::VinylSupportLegacy const&)>(qmi::MessageBase *a1, uint64_t a2)
{
  uint64_t result;
  int v5;
  uint64_t v6;
  int v7;
  BOOL v8;
  uint64_t v9;

  result = qmi::MessageBase::findTlvValue(a1);
  if (result)
  {
    v6 = result;
    v7 = v5;
    v9 = result;
    v8 = tlv::parseV<uim::tlv::VinylSupportLegacy>((unint64_t *)&v9, v5);
    if (v9)
      return (*(uint64_t (**)(void))(*(_QWORD *)a2 + 16))();
    else
      return ((uint64_t (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, 32, v6, v7);
  }
  return result;
}

double ___ZN10subscriber13sHandleIccidsIN3uim13GetCardStatus8ResponseEEEvRKT_RNSt3__13mapIjNS7_12basic_stringIcNS7_11char_traitsIcEENS7_9allocatorIcEEEENS7_4lessIjEENSC_INS7_4pairIKjSE_EEEEEE_block_invoke(uint64_t a1, unsigned __int8 **a2)
{
  uint64_t v4;
  double result;
  unsigned __int8 *v6;
  unsigned __int8 *v7;
  uint64_t **v8;
  unsigned int v9;
  uint64_t **v10;
  uint64_t **v11;
  unsigned int v12;
  __int128 v13;
  uint64_t *v14;

  v4 = *(_QWORD *)(a1 + 32);
  std::__tree<std::__value_type<unsigned int,std::string>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::string>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::string>>>::destroy(*(char **)(v4 + 8));
  *(_QWORD *)v4 = v4 + 8;
  *(_QWORD *)(v4 + 16) = 0;
  *(_QWORD *)(v4 + 8) = 0;
  v7 = *a2;
  v6 = a2[1];
  while (v7 != v6)
  {
    subscriber::sDecodeIccid((subscriber *)(v7 + 1), (const unsigned __int8 *)0xA);
    v8 = *(uint64_t ***)(a1 + 32);
    v9 = *v7;
    v12 = v9;
    v10 = std::__tree<std::__value_type<unsigned int,std::string>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::string>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::string>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int &&>,std::tuple<>>(v8, v9, &v12);
    v11 = v10 + 5;
    if (*((char *)v10 + 63) < 0)
      operator delete(*v11);
    result = *(double *)&v13;
    *(_OWORD *)v11 = v13;
    v11[2] = v14;
    v7 += 11;
  }
  return result;
}

void sub_2169E0934(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

double ___ZN10subscriber13sHandleIccidsIN3uim13GetCardStatus8ResponseEEEvRKT_RNSt3__13mapIjNS7_12basic_stringIcNS7_11char_traitsIcEENS7_9allocatorIcEEEENS7_4lessIjEENSC_INS7_4pairIKjSE_EEEEEE_block_invoke_2(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  double result;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t **v9;
  uint64_t **v10;
  __int128 v11;
  uint64_t *v12;
  unsigned int v13;

  v13 = 0;
  v4 = *(_QWORD *)(a1 + 32);
  std::__tree<std::__value_type<unsigned int,std::string>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::string>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::string>>>::destroy(*(char **)(v4 + 8));
  *(_QWORD *)v4 = v4 + 8;
  *(_QWORD *)(v4 + 16) = 0;
  *(_QWORD *)(v4 + 8) = 0;
  v6 = *a2;
  v7 = a2[1];
  if (*a2 != v7)
  {
    v8 = 0;
    do
    {
      subscriber::sDecodeIccid(*(subscriber **)v6, (const unsigned __int8 *)(*(_QWORD *)(v6 + 8) - *(_QWORD *)v6));
      v9 = std::__tree<std::__value_type<unsigned int,std::string>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::string>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::string>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int &&>,std::tuple<>>(*(uint64_t ***)(a1 + 32), v8, &v13);
      v10 = v9 + 5;
      if (*((char *)v9 + 63) < 0)
        operator delete(*v10);
      result = *(double *)&v11;
      *(_OWORD *)v10 = v11;
      v10[2] = v12;
      v13 = ++v8;
      v6 += 72;
    }
    while (v6 != v7);
  }
  return result;
}

void sub_2169E0A10(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void qmi::MessageBase::applyTlv<uim::tlv::Iccids,void({block_pointer}&)(uim::tlv::Iccids const&)>(qmi::MessageBase *a1, uint64_t a2)
{
  tlv *TlvValue;
  int v5;
  tlv *v6;
  int v7;
  tlv *v8;
  void *__p;
  void *v10;
  uint64_t v11;
  tlv *v12;

  TlvValue = (tlv *)qmi::MessageBase::findTlvValue(a1);
  if (TlvValue)
  {
    v6 = TlvValue;
    v7 = v5;
    v11 = 0;
    v12 = TlvValue;
    __p = 0;
    v10 = 0;
    tlv::parseV<uim::tlv::Iccids>(&v12, v5, (uint64_t)&__p);
    v8 = v12;
    if (v12)
      (*(void (**)(void))(*(_QWORD *)a2 + 16))();
    if (__p)
    {
      v10 = __p;
      operator delete(__p);
    }
    if (!v8)
      ((void (*)(_QWORD, uint64_t, tlv *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, 34, v6, v7);
  }
}

void sub_2169E0AEC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t **std::__tree<std::__value_type<unsigned int,std::string>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::string>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::string>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int &&>,std::tuple<>>(uint64_t **a1, unsigned int a2, _DWORD *a3)
{
  uint64_t *v5;
  uint64_t **v6;
  uint64_t **v7;
  unsigned int v8;
  _DWORD *v9;

  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v7 = (uint64_t **)v5;
        v8 = *((_DWORD *)v5 + 8);
        if (v8 <= a2)
          break;
        v5 = *v7;
        v6 = v7;
        if (!*v7)
          goto LABEL_9;
      }
      if (v8 >= a2)
        break;
      v5 = v7[1];
      if (!v5)
      {
        v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    v7 = a1 + 1;
LABEL_9:
    v9 = operator new(0x40uLL);
    v9[8] = *a3;
    *((_QWORD *)v9 + 6) = 0;
    *((_QWORD *)v9 + 7) = 0;
    *((_QWORD *)v9 + 5) = 0;
    std::__tree<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::less<unsigned short>,true>,std::allocator<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>>>::__insert_node_at(a1, (uint64_t)v7, v6, (uint64_t *)v9);
    return (uint64_t **)v9;
  }
  return v7;
}

void qmi::MessageBase::applyTlv<uim::tlv::ExtendedCardInfoList,void({block_pointer}&)(uim::tlv::ExtendedCardInfoList const&)>(qmi::MessageBase *a1, uint64_t a2, uint64_t a3)
{
  unsigned __int8 *TlvValue;
  int v7;
  unsigned __int8 *v8;
  int v9;
  uint64_t v10[3];
  unsigned __int8 *v11;
  void **v12;

  TlvValue = (unsigned __int8 *)qmi::MessageBase::findTlvValue(a1);
  if (TlvValue)
  {
    v8 = TlvValue;
    v9 = v7;
    v11 = TlvValue;
    memset(v10, 0, sizeof(v10));
    tlv::parseV<uim::tlv::ExtendedCardInfoList>(&v11, v7, v10);
    if (v11)
    {
      (*(void (**)(void))(*(_QWORD *)a3 + 16))();
      v12 = (void **)v10;
      std::vector<uim::tlv::ExtendedCardInfo>::__destroy_vector::operator()[abi:ne180100](&v12);
    }
    else
    {
      v12 = (void **)v10;
      std::vector<uim::tlv::ExtendedCardInfo>::__destroy_vector::operator()[abi:ne180100](&v12);
      ((void (*)(_QWORD, uint64_t, unsigned __int8 *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, a2, v8, v9);
    }
  }
}

void sub_2169E0C80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  std::vector<uim::tlv::ExtendedCardInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

void ___ZN10subscriber19sHandleCardInfoListIN3uim13GetCardStatus8ResponseEEEvRKT_RNSt3__13mapIjNS7_6vectorIhNS7_9allocatorIhEEEENS7_4lessIjEENSA_INS7_4pairIKjSC_EEEEEE_block_invoke(uint64_t a1, char ***a2)
{
  uint64_t v4;
  char **v5;
  char **v6;
  unsigned int v7;
  char **v8;
  uint64_t **v9;
  char **v10;
  unsigned int v11;

  v11 = 0;
  v4 = *(_QWORD *)(a1 + 32);
  std::__tree<std::__value_type<unsigned int,std::vector<unsigned char>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<unsigned char>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::vector<unsigned char>>>>::destroy(*(_QWORD **)(v4 + 8));
  *(_QWORD *)v4 = v4 + 8;
  *(_QWORD *)(v4 + 16) = 0;
  *(_QWORD *)(v4 + 8) = 0;
  v5 = *a2;
  v6 = a2[1];
  if (*a2 != v6)
  {
    v7 = 0;
    v8 = v5 + 3;
    do
    {
      v9 = std::__tree<std::__value_type<unsigned int,QMIDataCommandDriver::QosFlowItem>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,QMIDataCommandDriver::QosFlowItem>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,QMIDataCommandDriver::QosFlowItem>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(*(uint64_t ***)(a1 + 32), v7, &v11)+ 5;
      if (v8 != (char **)v9)
        std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(v9, *v8, v8[1], v8[1] - *v8);
      v11 = ++v7;
      v10 = v8 + 6;
      v8 += 9;
    }
    while (v10 != v6);
  }
}

void qmi::MessageBase::applyTlv<uim::tlv::IsMomentaryPowerDown,void({block_pointer}&)(uim::tlv::IsMomentaryPowerDown const&)>(qmi::MessageBase *a1, uint64_t a2, uint64_t a3)
{
  uint64_t TlvValue;
  int v7;
  uint64_t v8;
  int v9;
  unint64_t v10;
  void *__p;
  void *v12;
  uint64_t v13;
  unint64_t v14;

  TlvValue = qmi::MessageBase::findTlvValue(a1);
  if (TlvValue)
  {
    v8 = TlvValue;
    v9 = v7;
    v13 = 0;
    v14 = TlvValue;
    __p = 0;
    v12 = 0;
    tlv::parseV<uim::tlv::IsMomentaryPowerDown>(&v14, v7, &__p);
    v10 = v14;
    if (v14)
      (*(void (**)(void))(*(_QWORD *)a3 + 16))();
    if (__p)
    {
      v12 = __p;
      operator delete(__p);
    }
    if (!v10)
      ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, a2, v8, v9);
  }
}

void sub_2169E0E78(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t **std::__tree<std::__value_type<unsigned int,BOOL>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,BOOL>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,BOOL>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(uint64_t **a1, unsigned int a2, _DWORD *a3)
{
  uint64_t *v5;
  uint64_t **v6;
  uint64_t **v7;
  unsigned int v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t *v11;

  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v7 = (uint64_t **)v5;
        v8 = *((_DWORD *)v5 + 7);
        if (v8 <= a2)
          break;
        v5 = *v7;
        v6 = v7;
        if (!*v7)
          goto LABEL_9;
      }
      if (v8 >= a2)
        break;
      v5 = v7[1];
      if (!v5)
      {
        v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    v7 = a1 + 1;
LABEL_9:
    v9 = (uint64_t *)v7;
    v7 = (uint64_t **)operator new(0x28uLL);
    *((_DWORD *)v7 + 7) = *a3;
    *((_BYTE *)v7 + 32) = 0;
    *v7 = 0;
    v7[1] = 0;
    v7[2] = v9;
    *v6 = (uint64_t *)v7;
    v10 = (uint64_t *)**a1;
    v11 = (uint64_t *)v7;
    if (v10)
    {
      *a1 = v10;
      v11 = *v6;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

void qmi::MessageBase::tryTlv<uim::tlv::HardwareSlotTypes>(qmi::MessageBase *a1, unsigned __int8 *a2)
{
  tlv *v3;
  void *v4;
  int v5;
  void *v6;
  __int128 v7;
  uint64_t v8;
  tlv *v9[2];

  v9[0] = (tlv *)qmi::MessageBase::findTlvValue(a1);
  v9[1] = v3;
  if (v9[0])
  {
    tlv::parseV<uim::tlv::HardwareSlotTypes>(v9, (int)v3, (unint64_t *)&v7);
    if (*a2)
    {
      v4 = (void *)*((_QWORD *)a2 + 1);
      if (v4)
      {
        *((_QWORD *)a2 + 2) = v4;
        operator delete(v4);
        v5 = *a2;
      }
      else
      {
        v5 = 1;
      }
      v6 = (void *)v7;
      *(_OWORD *)(a2 + 8) = v7;
      *((_QWORD *)a2 + 3) = v8;
    }
    else
    {
      v6 = (void *)v7;
      *(_OWORD *)(a2 + 8) = v7;
      *((_QWORD *)a2 + 3) = v8;
      v5 = 1;
      *a2 = 1;
    }
    if (!v9[0] && v5)
    {
      if (v6)
      {
        *((_QWORD *)a2 + 2) = v6;
        operator delete(v6);
      }
      *a2 = 0;
    }
  }
}

char *std::vector<subscriber::SimDriverInfo>::__emplace_back_slow_path<>(int64x2_t *a1)
{
  unint64_t v1;
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  char *v6;
  unint64_t v7;
  char *v8;
  char *v9;
  char *v10;
  char *v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  __int128 v15;
  __int128 v16;
  int64x2_t v17;
  uint64_t v19;
  int64x2_t v20;
  char *v21;
  int64x2_t *v22;

  v2 = a1->i64[0];
  v1 = a1->u64[1];
  v3 = 0x8E38E38E38E38E39 * ((uint64_t)(v1 - a1->i64[0]) >> 4);
  v4 = v3 + 1;
  if (v3 + 1 > 0x1C71C71C71C71C7)
    std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
  v6 = (char *)a1[1].i64[0];
  if (0x1C71C71C71C71C72 * ((uint64_t)&v6[-v2] >> 4) > v4)
    v4 = 0x1C71C71C71C71C72 * ((uint64_t)&v6[-v2] >> 4);
  if (0x8E38E38E38E38E39 * ((uint64_t)&v6[-v2] >> 4) >= 0xE38E38E38E38E3)
    v7 = 0x1C71C71C71C71C7;
  else
    v7 = v4;
  v22 = a1 + 1;
  if (v7)
  {
    if (v7 > 0x1C71C71C71C71C7)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v8 = (char *)operator new(144 * v7);
  }
  else
  {
    v8 = 0;
  }
  v9 = &v8[144 * v3];
  *(_DWORD *)v9 = 1;
  *((_QWORD *)v9 + 2) = 0;
  *((_QWORD *)v9 + 3) = 0;
  *((_QWORD *)v9 + 1) = 0;
  v10 = &v8[144 * v7];
  *(_QWORD *)(v9 + 4) = 0;
  v9[12] = 0;
  v9[28] = 0;
  *(_QWORD *)(v9 + 20) = 0;
  *((_OWORD *)v9 + 2) = 0u;
  *((_OWORD *)v9 + 3) = 0u;
  *((_OWORD *)v9 + 4) = 0u;
  *((_OWORD *)v9 + 5) = 0u;
  *((_OWORD *)v9 + 6) = 0u;
  *((_OWORD *)v9 + 7) = 0u;
  *((_OWORD *)v9 + 8) = 0u;
  v11 = v9 + 144;
  v20.i64[1] = (uint64_t)(v9 + 144);
  v21 = v10;
  if (v1 == v2)
  {
    v17 = vdupq_n_s64(v1);
  }
  else
  {
    v12 = 0;
    do
    {
      v13 = &v9[v12];
      v14 = v1 + v12;
      v15 = *(_OWORD *)(v1 + v12 - 144);
      *(_OWORD *)(v13 - 131) = *(_OWORD *)(v1 + v12 - 131);
      *((_OWORD *)v13 - 9) = v15;
      *((_QWORD *)v13 - 14) = *(_QWORD *)(v1 + v12 - 112);
      *((_QWORD *)v13 - 12) = 0;
      *((_QWORD *)v13 - 11) = 0;
      *(_OWORD *)(v13 - 104) = *(_OWORD *)(v1 + v12 - 104);
      *((_QWORD *)v13 - 11) = *(_QWORD *)(v1 + v12 - 88);
      *(_QWORD *)(v14 - 96) = 0;
      *(_QWORD *)(v14 - 88) = 0;
      *(_QWORD *)(v14 - 104) = 0;
      *((_QWORD *)v13 - 10) = *(_QWORD *)(v1 + v12 - 80);
      *((_QWORD *)v13 - 8) = 0;
      *((_QWORD *)v13 - 7) = 0;
      *(_OWORD *)(v13 - 72) = *(_OWORD *)(v1 + v12 - 72);
      *((_QWORD *)v13 - 7) = *(_QWORD *)(v1 + v12 - 56);
      *(_QWORD *)(v14 - 72) = 0;
      *(_QWORD *)(v14 - 64) = 0;
      *(_QWORD *)(v14 - 56) = 0;
      *((_QWORD *)v13 - 5) = 0;
      *((_QWORD *)v13 - 4) = 0;
      *((_OWORD *)v13 - 3) = *(_OWORD *)(v1 + v12 - 48);
      *((_QWORD *)v13 - 4) = *(_QWORD *)(v1 + v12 - 32);
      *(_QWORD *)(v14 - 48) = 0;
      *(_QWORD *)(v14 - 40) = 0;
      *(_QWORD *)(v14 - 32) = 0;
      v16 = *(_OWORD *)(v1 + v12 - 24);
      *((_QWORD *)v13 - 1) = *(_QWORD *)(v1 + v12 - 8);
      *(_OWORD *)(v13 - 24) = v16;
      *(_QWORD *)(v14 - 16) = 0;
      *(_QWORD *)(v14 - 8) = 0;
      *(_QWORD *)(v14 - 24) = 0;
      v12 -= 144;
    }
    while (v1 + v12 != v2);
    v17 = *a1;
    v6 = (char *)a1[1].i64[0];
    v9 += v12;
    v11 = (char *)v20.i64[1];
    v10 = v21;
  }
  a1->i64[0] = (uint64_t)v9;
  a1->i64[1] = (uint64_t)v11;
  v20 = v17;
  a1[1].i64[0] = (uint64_t)v10;
  v21 = v6;
  v19 = v17.i64[0];
  std::__split_buffer<subscriber::SimDriverInfo>::~__split_buffer((uint64_t)&v19);
  return v11;
}

uint64_t std::__split_buffer<subscriber::SimDriverInfo>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 144;
    std::__destroy_at[abi:ne180100]<subscriber::SimDriverInfo,0>(i - 144);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

_QWORD *std::vector<uim::tlv::AppIndex>::__assign_with_size[abi:ne180100]<uim::tlv::AppIndex*,uim::tlv::AppIndex*>(_QWORD *result, char *__src, char *a3, unint64_t a4)
{
  char *v6;
  _QWORD *v7;
  unint64_t v8;
  uint64_t v9;
  char *v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  size_t v14;
  void **v15;
  _BYTE *v16;
  unint64_t v17;
  char *v18;
  void *v19;

  v6 = __src;
  v7 = result;
  v9 = (uint64_t)(result + 2);
  v8 = result[2];
  v10 = (char *)*result;
  if (a4 > (uint64_t)(v8 - *result) >> 1)
  {
    if (v10)
    {
      result[1] = v10;
      operator delete(v10);
      v8 = 0;
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if ((a4 & 0x8000000000000000) != 0
      || (v8 <= a4 ? (v11 = a4) : (v11 = v8),
          v8 >= 0x7FFFFFFFFFFFFFFELL ? (v12 = 0x7FFFFFFFFFFFFFFFLL) : (v12 = v11),
          v12 < 0))
    {
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    }
    result = std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned short>>(v9, v12);
    v10 = (char *)result;
    *v7 = result;
    v7[1] = result;
    v7[2] = (char *)result + 2 * v13;
    v14 = a3 - v6;
    if (v14)
      result = memmove(result, v6, v14);
    v15 = (void **)(v7 + 1);
    goto LABEL_23;
  }
  v15 = (void **)(result + 1);
  v16 = (_BYTE *)result[1];
  v17 = (v16 - v10) >> 1;
  if (v17 >= a4)
  {
    v14 = a3 - __src;
    if (a3 == __src)
      goto LABEL_23;
    v19 = (void *)*result;
LABEL_22:
    result = memmove(v19, __src, v14);
    goto LABEL_23;
  }
  v18 = &__src[2 * v17];
  if (v16 != v10)
  {
    result = memmove((void *)*result, __src, v16 - v10);
    v10 = (char *)*v15;
  }
  v14 = a3 - v18;
  if (v14)
  {
    v19 = v10;
    __src = v18;
    goto LABEL_22;
  }
LABEL_23:
  *v15 = &v10[v14];
  return result;
}

uint64_t *std::__tree<std::__value_type<subscriber::HardwareSimSlot,BOOL>,std::__map_value_compare<subscriber::HardwareSimSlot,std::__value_type<subscriber::HardwareSimSlot,BOOL>,std::less<subscriber::HardwareSimSlot>,true>,std::allocator<std::__value_type<subscriber::HardwareSimSlot,BOOL>>>::__emplace_unique_key_args<subscriber::HardwareSimSlot,subscriber::HardwareSimSlot const&,BOOL>(uint64_t *result, int a2, int a3, char a4)
{
  uint64_t **v6;
  uint64_t *v7;
  uint64_t **v8;
  uint64_t **v9;
  int v10;
  _DWORD *v11;

  v6 = (uint64_t **)result;
  v8 = (uint64_t **)(result + 1);
  v7 = (uint64_t *)result[1];
  if (v7)
  {
    while (1)
    {
      while (1)
      {
        v9 = (uint64_t **)v7;
        v10 = *((_DWORD *)v7 + 7);
        if (v10 <= a2)
          break;
        v7 = *v9;
        v8 = v9;
        if (!*v9)
          goto LABEL_9;
      }
      if (v10 >= a2)
        break;
      v7 = v9[1];
      if (!v7)
      {
        v8 = v9 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    v9 = (uint64_t **)(result + 1);
LABEL_9:
    v11 = operator new(0x28uLL);
    v11[7] = a3;
    *((_BYTE *)v11 + 32) = a4;
    return std::__tree<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::less<unsigned short>,true>,std::allocator<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>>>::__insert_node_at(v6, (uint64_t)v9, v8, (uint64_t *)v11);
  }
  return result;
}

uint64_t std::map<subscriber::HardwareSimSlot,BOOL>::map[abi:ne180100](uint64_t a1, _QWORD *a2)
{
  uint64_t **v3;
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t **v7;
  uint64_t v8;
  uint64_t **v9;
  BOOL v10;
  int v11;
  uint64_t **v12;
  uint64_t **v13;
  uint64_t *v14;
  int v15;
  uint64_t *v16;
  _QWORD *v17;
  _QWORD *v18;

  *(_QWORD *)(a1 + 8) = 0;
  v3 = (uint64_t **)(a1 + 8);
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = a1 + 8;
  v4 = a2 + 1;
  v5 = (_QWORD *)*a2;
  if ((_QWORD *)*a2 != a2 + 1)
  {
    do
    {
      v6 = *(_QWORD *)(a1 + 8);
      v7 = v3;
      if (*(uint64_t ***)a1 == v3)
        goto LABEL_8;
      v8 = *(_QWORD *)(a1 + 8);
      v9 = v3;
      if (v6)
      {
        do
        {
          v7 = (uint64_t **)v8;
          v8 = *(_QWORD *)(v8 + 8);
        }
        while (v8);
      }
      else
      {
        do
        {
          v7 = (uint64_t **)v9[2];
          v10 = *v7 == (uint64_t *)v9;
          v9 = v7;
        }
        while (v10);
      }
      v11 = *((_DWORD *)v5 + 7);
      if (*((_DWORD *)v7 + 7) < v11)
      {
LABEL_8:
        if (v6)
          v12 = v7;
        else
          v12 = v3;
        if (v6)
          v13 = v7 + 1;
        else
          v13 = v3;
        if (*v13)
          goto LABEL_25;
      }
      else
      {
        v13 = v3;
        v12 = v3;
        if (v6)
        {
          v14 = *(uint64_t **)(a1 + 8);
          while (1)
          {
            while (1)
            {
              v12 = (uint64_t **)v14;
              v15 = *((_DWORD *)v14 + 7);
              if (v15 <= v11)
                break;
              v14 = *v12;
              v13 = v12;
              if (!*v12)
                goto LABEL_24;
            }
            if (v15 >= v11)
              goto LABEL_25;
            v14 = v12[1];
            if (!v14)
            {
              v13 = v12 + 1;
              break;
            }
          }
        }
      }
LABEL_24:
      v16 = (uint64_t *)operator new(0x28uLL);
      *(uint64_t *)((char *)v16 + 28) = *(_QWORD *)((char *)v5 + 28);
      std::__tree<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::less<unsigned short>,true>,std::allocator<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>>>::__insert_node_at((uint64_t **)a1, (uint64_t)v12, v13, v16);
LABEL_25:
      v17 = (_QWORD *)v5[1];
      if (v17)
      {
        do
        {
          v18 = v17;
          v17 = (_QWORD *)*v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          v18 = (_QWORD *)v5[2];
          v10 = *v18 == (_QWORD)v5;
          v5 = v18;
        }
        while (!v10);
      }
      v5 = v18;
    }
    while (v18 != v4);
  }
  return a1;
}

void sub_2169E15A4(_Unwind_Exception *a1)
{
  _QWORD *v1;

  std::__tree<std::__value_type<AQMThroughputKey,unsigned int>,std::__map_value_compare<AQMThroughputKey,std::__value_type<AQMThroughputKey,unsigned int>,std::less<AQMThroughputKey>,true>,std::allocator<std::__value_type<AQMThroughputKey,unsigned int>>>::destroy(v1);
  _Unwind_Resume(a1);
}

uint64_t qmi::MessageBase::applyTlv<uim::tlv::ExtendedCardStatus,void({block_pointer})(uim::tlv::ExtendedCardStatus const&)>(qmi::MessageBase *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  int v7;
  uim::tlv::ExtendedCardStatus *v8;
  uint64_t v9;
  int v10;
  uim::tlv *v11;
  void *v12[2];
  void *__p[2];
  __int128 v14;
  __int128 v15;
  uint64_t v16;
  uim::tlv *v17;
  void **v18;

  result = qmi::MessageBase::findTlvValue(a1);
  if (result)
  {
    v9 = result;
    v10 = v7;
    v17 = (uim::tlv *)result;
    v16 = 0;
    v14 = 0u;
    v15 = 0u;
    *(_OWORD *)v12 = 0u;
    *(_OWORD *)__p = 0u;
    tlv::parseV<uim::tlv::ExtendedCardStatus>(&v17, v7, v8, (uint64_t)v12);
    v11 = v17;
    if (v17)
      (*(void (**)(void))(*(_QWORD *)a3 + 16))();
    v18 = (void **)&v15;
    std::vector<uim::tlv::Slot>::__destroy_vector::operator()[abi:ne180100](&v18);
    if (__p[1])
    {
      *(void **)&v14 = __p[1];
      operator delete(__p[1]);
    }
    if (v12[0])
    {
      v12[1] = v12[0];
      operator delete(v12[0]);
    }
    if (v11)
      return 1;
    else
      return ((uint64_t (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, a2, v9, v10);
  }
  return result;
}

void sub_2169E16BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  uint64_t v13;
  uint64_t v14;

  *(_QWORD *)(v14 - 72) = v13 + 48;
  std::vector<uim::tlv::Slot>::__destroy_vector::operator()[abi:ne180100]((void ***)(v14 - 72));
  if (__p)
    operator delete(__p);
  if (a9)
    operator delete(a9);
  _Unwind_Resume(a1);
}

void qmi::MessageBase::applyTlv<uim::tlv::CardStatus,void({block_pointer})(uim::tlv::CardStatus const&)>(qmi::MessageBase *a1, uint64_t a2)
{
  unsigned __int8 *TlvValue;
  int v5;
  unsigned __int8 *v6;
  int v7;
  _OWORD v8[2];
  unsigned __int8 *v9;
  void **v10;

  TlvValue = (unsigned __int8 *)qmi::MessageBase::findTlvValue(a1);
  if (TlvValue)
  {
    v6 = TlvValue;
    v7 = v5;
    v9 = TlvValue;
    memset(v8, 0, sizeof(v8));
    tlv::parseV<uim::tlv::CardStatus>(&v9, v5, v8);
    if (v9)
    {
      (*(void (**)(void))(*(_QWORD *)a2 + 16))();
      v10 = (void **)v8 + 1;
      std::vector<uim::tlv::Slot>::__destroy_vector::operator()[abi:ne180100](&v10);
    }
    else
    {
      v10 = (void **)v8 + 1;
      std::vector<uim::tlv::Slot>::__destroy_vector::operator()[abi:ne180100](&v10);
      ((void (*)(_QWORD, uint64_t, unsigned __int8 *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, 16, v6, v7);
    }
  }
}

void sub_2169E17D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void **a14)
{
  uint64_t v14;

  a14 = (void **)(v14 | 8);
  std::vector<uim::tlv::Slot>::__destroy_vector::operator()[abi:ne180100](&a14);
  _Unwind_Resume(a1);
}

void ___ZN10subscriber19sHandleVinylAbilityIN3uim16CardStatusChange10IndicationEEEvRKT_RNSt3__16vectorINS_15VinylCapabilityENS7_9allocatorIS9_EEEE_block_invoke(uint64_t a1, char **a2)
{
  char **v4;
  unint64_t v5;
  char *v6;
  char *v7;
  int *v8;
  char v9;
  int v10;
  int v11;
  int v12;

  v4 = *(char ***)(a1 + 32);
  v5 = a2[1] - *a2;
  v12 = 1;
  std::vector<subscriber::VinylCapability>::resize(v4, v5, &v12);
  v6 = *a2;
  v7 = a2[1];
  if (*a2 != v7)
  {
    v8 = **(int ***)(a1 + 32);
    do
    {
      v9 = *v6++;
      v10 = (v9 - 1) + 2;
      if (((v9 - 1) & 0xFC) != 0)
        v11 = 1;
      else
        v11 = v10;
      *v8++ = v11;
    }
    while (v6 != v7);
  }
}

double ___ZN10subscriber13sHandleIccidsIN3uim16CardStatusChange10IndicationEEEvRKT_RNSt3__13mapIjNS7_12basic_stringIcNS7_11char_traitsIcEENS7_9allocatorIcEEEENS7_4lessIjEENSC_INS7_4pairIKjSE_EEEEEE_block_invoke(uint64_t a1, unsigned __int8 **a2)
{
  uint64_t v4;
  double result;
  unsigned __int8 *v6;
  unsigned __int8 *v7;
  uint64_t **v8;
  unsigned int v9;
  uint64_t **v10;
  uint64_t **v11;
  unsigned int v12;
  __int128 v13;
  uint64_t *v14;

  v4 = *(_QWORD *)(a1 + 32);
  std::__tree<std::__value_type<unsigned int,std::string>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::string>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::string>>>::destroy(*(char **)(v4 + 8));
  *(_QWORD *)v4 = v4 + 8;
  *(_QWORD *)(v4 + 16) = 0;
  *(_QWORD *)(v4 + 8) = 0;
  v7 = *a2;
  v6 = a2[1];
  while (v7 != v6)
  {
    subscriber::sDecodeIccid((subscriber *)(v7 + 1), (const unsigned __int8 *)0xA);
    v8 = *(uint64_t ***)(a1 + 32);
    v9 = *v7;
    v12 = v9;
    v10 = std::__tree<std::__value_type<unsigned int,std::string>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::string>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::string>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int &&>,std::tuple<>>(v8, v9, &v12);
    v11 = v10 + 5;
    if (*((char *)v10 + 63) < 0)
      operator delete(*v11);
    result = *(double *)&v13;
    *(_OWORD *)v11 = v13;
    v11[2] = v14;
    v7 += 11;
  }
  return result;
}

void sub_2169E1954(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

double ___ZN10subscriber13sHandleIccidsIN3uim16CardStatusChange10IndicationEEEvRKT_RNSt3__13mapIjNS7_12basic_stringIcNS7_11char_traitsIcEENS7_9allocatorIcEEEENS7_4lessIjEENSC_INS7_4pairIKjSE_EEEEEE_block_invoke_2(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  double result;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t **v9;
  uint64_t **v10;
  __int128 v11;
  uint64_t *v12;
  unsigned int v13;

  v13 = 0;
  v4 = *(_QWORD *)(a1 + 32);
  std::__tree<std::__value_type<unsigned int,std::string>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::string>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::string>>>::destroy(*(char **)(v4 + 8));
  *(_QWORD *)v4 = v4 + 8;
  *(_QWORD *)(v4 + 16) = 0;
  *(_QWORD *)(v4 + 8) = 0;
  v6 = *a2;
  v7 = a2[1];
  if (*a2 != v7)
  {
    v8 = 0;
    do
    {
      subscriber::sDecodeIccid(*(subscriber **)v6, (const unsigned __int8 *)(*(_QWORD *)(v6 + 8) - *(_QWORD *)v6));
      v9 = std::__tree<std::__value_type<unsigned int,std::string>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::string>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::string>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int &&>,std::tuple<>>(*(uint64_t ***)(a1 + 32), v8, &v13);
      v10 = v9 + 5;
      if (*((char *)v9 + 63) < 0)
        operator delete(*v10);
      result = *(double *)&v11;
      *(_OWORD *)v10 = v11;
      v10[2] = v12;
      v13 = ++v8;
      v6 += 72;
    }
    while (v6 != v7);
  }
  return result;
}

void sub_2169E1A30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void ___ZN10subscriber19sHandleCardInfoListIN3uim16CardStatusChange10IndicationEEEvRKT_RNSt3__13mapIjNS7_6vectorIhNS7_9allocatorIhEEEENS7_4lessIjEENSA_INS7_4pairIKjSC_EEEEEE_block_invoke(uint64_t a1, char ***a2)
{
  uint64_t v4;
  char **v5;
  char **v6;
  unsigned int v7;
  char **v8;
  uint64_t **v9;
  char **v10;
  unsigned int v11;

  v11 = 0;
  v4 = *(_QWORD *)(a1 + 32);
  std::__tree<std::__value_type<unsigned int,std::vector<unsigned char>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<unsigned char>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::vector<unsigned char>>>>::destroy(*(_QWORD **)(v4 + 8));
  *(_QWORD *)v4 = v4 + 8;
  *(_QWORD *)(v4 + 16) = 0;
  *(_QWORD *)(v4 + 8) = 0;
  v5 = *a2;
  v6 = a2[1];
  if (*a2 != v6)
  {
    v7 = 0;
    v8 = v5 + 3;
    do
    {
      v9 = std::__tree<std::__value_type<unsigned int,QMIDataCommandDriver::QosFlowItem>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,QMIDataCommandDriver::QosFlowItem>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,QMIDataCommandDriver::QosFlowItem>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(*(uint64_t ***)(a1 + 32), v7, &v11)+ 5;
      if (v8 != (char **)v9)
        std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(v9, *v8, v8[1], v8[1] - *v8);
      v11 = ++v7;
      v10 = v8 + 6;
      v8 += 9;
    }
    while (v10 != v6);
  }
}

char *qmi::MutableMessageBase::getTLV<uim::tlv::SessionInfo>(_QWORD *a1)
{
  const void **v2;
  const void **v3;
  char **v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  v4 = (char **)(a1 + 1);
  if (v2 != v3)
  {
    while (*((_BYTE *)*v2 + 8) != 1)
    {
      if (++v2 == v3)
        goto LABEL_8;
    }
  }
  if (v2 == v3)
  {
LABEL_8:
    v7 = operator new();
    *(_BYTE *)(v7 + 8) = 1;
    *(_QWORD *)v7 = &off_24D5DB768;
    *(_BYTE *)(v7 + 16) = 0;
    v6 = v7 + 16;
    *(_QWORD *)(v7 + 32) = 0;
    *(_QWORD *)(v7 + 40) = 0;
    *(_QWORD *)(v7 + 24) = 0;
    v8 = a1[3];
    v9 = (uint64_t *)a1[2];
    if ((unint64_t)v9 >= v8)
    {
      v11 = ((char *)v9 - *v4) >> 3;
      if ((unint64_t)(v11 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v12 = v8 - (_QWORD)*v4;
      v13 = v12 >> 2;
      if (v12 >> 2 <= (unint64_t)(v11 + 1))
        v13 = v11 + 1;
      if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
        v14 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v14 = v13;
      if (v14)
        v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v14);
      else
        v15 = 0;
      v16 = (uint64_t *)&v15[8 * v11];
      v17 = &v15[8 * v14];
      *v16 = v7;
      v10 = v16 + 1;
      v19 = (char *)a1[1];
      v18 = (char *)a1[2];
      if (v18 != v19)
      {
        do
        {
          v20 = *((_QWORD *)v18 - 1);
          v18 -= 8;
          *--v16 = v20;
        }
        while (v18 != v19);
        v18 = *v4;
      }
      a1[1] = v16;
      a1[2] = v10;
      a1[3] = v17;
      if (v18)
        operator delete(v18);
    }
    else
    {
      *v9 = v7;
      v10 = v9 + 1;
    }
    a1[2] = v10;
  }
  else
  {
    if (!v5)
      __cxa_bad_cast();
    return v5 + 16;
  }
  return (char *)v6;
}

_QWORD *qmi::MutableMessageBase::TlvWrapper<uim::tlv::SessionInfo>::~TlvWrapper(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24D5DB768;
  v2 = (void *)a1[3];
  if (v2)
  {
    a1[4] = v2;
    operator delete(v2);
  }
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<uim::tlv::SessionInfo>::~TlvWrapper(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24D5DB768;
  v2 = (void *)a1[3];
  if (v2)
  {
    a1[4] = v2;
    operator delete(v2);
  }
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<uim::tlv::SessionInfo>::getSize(uint64_t a1)
{
  return tlv::size<vs::tlv::USSInfo>(a1 + 16);
}

void *qmi::MutableMessageBase::TlvWrapper<uim::tlv::SessionInfo>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  void *result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<vs::tlv::BurstDtmfInfo>((_BYTE **)a2, a1 + 16);
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<uim::tlv::SessionInfo>::clone(uint64_t a1)
{
  uint64_t v2;

  v2 = operator new();
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)v2 = &off_24D5DB768;
  *(_BYTE *)(v2 + 16) = *(_BYTE *)(a1 + 16);
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 40) = 0;
  *(_QWORD *)(v2 + 24) = 0;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>((_QWORD *)(v2 + 24), *(const void **)(a1 + 24), *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 32) - *(_QWORD *)(a1 + 24));
  return v2;
}

void sub_2169E1E44(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199FEAC4](v1, 0x1091C40AD8DF7F0);
  _Unwind_Resume(a1);
}

uint64_t `anonymous namespace'::sToSessionType(os_log_t *a1, _DWORD *a2)
{
  int v2;
  unsigned int v3;
  unsigned int v4;
  NSObject *v5;
  int v7;
  uint64_t v8;
  __int16 v9;
  uint64_t v10;
  __int16 v11;
  uint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v2 = a2[2];
  switch(v2)
  {
    case 3:
      v4 = *a2 - 1;
      if (v4 >= 3)
        goto LABEL_12;
      v3 = 0x100504u >> (8 * v4);
      break;
    case 2:
      v3 = a2[1];
      if (v3 != 1)
      {
        if (v3 != 2)
          goto LABEL_12;
        LOBYTE(v3) = 3;
      }
      break;
    case 1:
      v3 = a2[1];
      if (v3 == 1)
      {
LABEL_14:
        LOBYTE(v3) = 0;
        return v3;
      }
      if (v3 != 2)
      {
LABEL_12:
        v5 = *a1;
        if (os_log_type_enabled(*a1, OS_LOG_TYPE_FAULT))
        {
          v7 = 136315650;
          v8 = subscriber::asString();
          v9 = 2080;
          v10 = subscriber::asString();
          v11 = 2080;
          v12 = subscriber::asString();
          _os_log_fault_impl(&dword_216897000, v5, OS_LOG_TYPE_FAULT, "bad type %s or slot %s | %s", (uint8_t *)&v7, 0x20u);
        }
        goto LABEL_14;
      }
      break;
    default:
      goto LABEL_12;
  }
  return v3;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<uim::tlv::VerifyPin>::~TlvWrapper(uint64_t a1)
{
  *(_QWORD *)a1 = off_24D5DB7B8;
  if (*(char *)(a1 + 47) < 0)
    operator delete(*(void **)(a1 + 24));
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<uim::tlv::VerifyPin>::~TlvWrapper(uint64_t a1)
{
  *(_QWORD *)a1 = off_24D5DB7B8;
  if (*(char *)(a1 + 47) < 0)
    operator delete(*(void **)(a1 + 24));
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<uim::tlv::VerifyPin>::getSize(uint64_t a1)
{
  return tlv::size<cat::tlv::TextString>(a1 + 16);
}

void *qmi::MutableMessageBase::TlvWrapper<uim::tlv::VerifyPin>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  uint64_t v4;
  uint64_t v5;
  void *result;
  uint64_t v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = *a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<uim::tlv::VerifyPin>(a2, a1 + 16);
  v7 = *a2 - v5;
  *(_BYTE *)v4 = v3;
  *(_WORD *)(v4 + 1) = v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<uim::tlv::VerifyPin>::clone(uint64_t a1)
{
  uint64_t v2;
  std::string *v3;

  v2 = operator new();
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)v2 = off_24D5DB7B8;
  *(_DWORD *)(v2 + 16) = *(_DWORD *)(a1 + 16);
  v3 = (std::string *)(v2 + 24);
  if (*(char *)(a1 + 47) < 0)
  {
    std::string::__init_copy_ctor_external(v3, *(const std::string::value_type **)(a1 + 24), *(_QWORD *)(a1 + 32));
  }
  else
  {
    *(_OWORD *)&v3->__r_.__value_.__l.__data_ = *(_OWORD *)(a1 + 24);
    *(_QWORD *)(v2 + 40) = *(_QWORD *)(a1 + 40);
  }
  return v2;
}

void sub_2169E2128(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199FEAC4](v1, 0x1093C40FA1C946DLL);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3uim9VerifyPin8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2169E2208(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<uim::tlv::UnblockPin>::~TlvWrapper(uint64_t a1)
{
  *(_QWORD *)a1 = off_24D5DB830;
  if (*(char *)(a1 + 71) < 0)
    operator delete(*(void **)(a1 + 48));
  if (*(char *)(a1 + 47) < 0)
    operator delete(*(void **)(a1 + 24));
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<uim::tlv::UnblockPin>::~TlvWrapper(uint64_t a1)
{
  *(_QWORD *)a1 = off_24D5DB830;
  if (*(char *)(a1 + 71) < 0)
    operator delete(*(void **)(a1 + 48));
  if (*(char *)(a1 + 47) < 0)
    operator delete(*(void **)(a1 + 24));
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<uim::tlv::UnblockPin>::getSize(uint64_t a1)
{
  return tlv::size<uim::tlv::UnblockPin>(a1 + 16);
}

char *qmi::MutableMessageBase::TlvWrapper<uim::tlv::UnblockPin>::write(uint64_t a1, char **a2)
{
  char v3;
  char *v4;
  uint64_t v5;
  char *result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = *a2;
  v5 = (uint64_t)(*a2 + 3);
  *a2 = (char *)v5;
  result = tlv::writeV<uim::tlv::UnblockPin>(a2, a1 + 16);
  v7 = &(*a2)[-v5];
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

std::string *qmi::MutableMessageBase::TlvWrapper<uim::tlv::UnblockPin>::clone(uint64_t a1)
{
  uint64_t v2;
  std::string *v3;
  std::string *v4;

  v2 = operator new();
  v3 = (std::string *)v2;
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)v2 = off_24D5DB830;
  *(_DWORD *)(v2 + 16) = *(_DWORD *)(a1 + 16);
  if (*(char *)(a1 + 47) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)(v2 + 24), *(const std::string::value_type **)(a1 + 24), *(_QWORD *)(a1 + 32));
  }
  else
  {
    *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
    *(_QWORD *)(v2 + 40) = *(_QWORD *)(a1 + 40);
  }
  v4 = v3 + 2;
  if (*(char *)(a1 + 71) < 0)
  {
    std::string::__init_copy_ctor_external(v4, *(const std::string::value_type **)(a1 + 48), *(_QWORD *)(a1 + 56));
  }
  else
  {
    *(_OWORD *)&v4->__r_.__value_.__l.__data_ = *(_OWORD *)(a1 + 48);
    v3[2].__r_.__value_.__r.__words[2] = *(_QWORD *)(a1 + 64);
  }
  return v3;
}

void sub_2169E240C(_Unwind_Exception *a1)
{
  uint64_t v1;
  void **v2;

  if (*(char *)(v1 + 47) < 0)
    operator delete(*v2);
  MEMORY[0x2199FEAC4](v1, 0x1093C40A530C863);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3uim10UnblockPin8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2169E2504(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<uim::tlv::ChangePin>::~TlvWrapper(uint64_t a1)
{
  *(_QWORD *)a1 = off_24D5DB8A8;
  if (*(char *)(a1 + 71) < 0)
    operator delete(*(void **)(a1 + 48));
  if (*(char *)(a1 + 47) < 0)
    operator delete(*(void **)(a1 + 24));
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<uim::tlv::ChangePin>::~TlvWrapper(uint64_t a1)
{
  *(_QWORD *)a1 = off_24D5DB8A8;
  if (*(char *)(a1 + 71) < 0)
    operator delete(*(void **)(a1 + 48));
  if (*(char *)(a1 + 47) < 0)
    operator delete(*(void **)(a1 + 24));
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<uim::tlv::ChangePin>::getSize(uint64_t a1)
{
  return tlv::size<uim::tlv::UnblockPin>(a1 + 16);
}

char *qmi::MutableMessageBase::TlvWrapper<uim::tlv::ChangePin>::write(uint64_t a1, char **a2)
{
  char v3;
  char *v4;
  uint64_t v5;
  char *result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = *a2;
  v5 = (uint64_t)(*a2 + 3);
  *a2 = (char *)v5;
  result = tlv::writeV<uim::tlv::UnblockPin>(a2, a1 + 16);
  v7 = &(*a2)[-v5];
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

std::string *qmi::MutableMessageBase::TlvWrapper<uim::tlv::ChangePin>::clone(uint64_t a1)
{
  uint64_t v2;
  std::string *v3;
  std::string *v4;

  v2 = operator new();
  v3 = (std::string *)v2;
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)v2 = off_24D5DB8A8;
  *(_DWORD *)(v2 + 16) = *(_DWORD *)(a1 + 16);
  if (*(char *)(a1 + 47) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)(v2 + 24), *(const std::string::value_type **)(a1 + 24), *(_QWORD *)(a1 + 32));
  }
  else
  {
    *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
    *(_QWORD *)(v2 + 40) = *(_QWORD *)(a1 + 40);
  }
  v4 = v3 + 2;
  if (*(char *)(a1 + 71) < 0)
  {
    std::string::__init_copy_ctor_external(v4, *(const std::string::value_type **)(a1 + 48), *(_QWORD *)(a1 + 56));
  }
  else
  {
    *(_OWORD *)&v4->__r_.__value_.__l.__data_ = *(_OWORD *)(a1 + 48);
    v3[2].__r_.__value_.__r.__words[2] = *(_QWORD *)(a1 + 64);
  }
  return v3;
}

void sub_2169E2708(_Unwind_Exception *a1)
{
  uint64_t v1;
  void **v2;

  if (*(char *)(v1 + 47) < 0)
    operator delete(*v2);
  MEMORY[0x2199FEAC4](v1, 0x1093C40A530C863);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3uim9ChangePin8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2169E2800(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<uim::tlv::SetPinProtection>::~TlvWrapper(uint64_t a1)
{
  *(_QWORD *)a1 = off_24D5DB920;
  if (*(char *)(a1 + 47) < 0)
    operator delete(*(void **)(a1 + 24));
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<uim::tlv::SetPinProtection>::~TlvWrapper(uint64_t a1)
{
  *(_QWORD *)a1 = off_24D5DB920;
  if (*(char *)(a1 + 47) < 0)
    operator delete(*(void **)(a1 + 24));
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<uim::tlv::SetPinProtection>::getSize(uint64_t a1)
{
  return tlv::size<cat::tlv::Address>(a1 + 16);
}

void *qmi::MutableMessageBase::TlvWrapper<uim::tlv::SetPinProtection>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  void *result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<uim::tlv::SetPinProtection>((_BYTE **)a2, a1 + 16);
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<uim::tlv::SetPinProtection>::clone(uint64_t a1)
{
  uint64_t v2;
  std::string *v3;

  v2 = operator new();
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)v2 = off_24D5DB920;
  *(_DWORD *)(v2 + 16) = *(_DWORD *)(a1 + 16);
  *(_BYTE *)(v2 + 20) = *(_BYTE *)(a1 + 20);
  v3 = (std::string *)(v2 + 24);
  if (*(char *)(a1 + 47) < 0)
  {
    std::string::__init_copy_ctor_external(v3, *(const std::string::value_type **)(a1 + 24), *(_QWORD *)(a1 + 32));
  }
  else
  {
    *(_OWORD *)&v3->__r_.__value_.__l.__data_ = *(_OWORD *)(a1 + 24);
    *(_QWORD *)(v2 + 40) = *(_QWORD *)(a1 + 40);
  }
  return v2;
}

void sub_2169E29B4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199FEAC4](v1, 0x1093C403CC153C4);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3uim16SetPinProtection8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2169E2A94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<uim::tlv::RefreshReg>::~TlvWrapper(uint64_t a1)
{
  void **v3;

  *(_QWORD *)a1 = off_24D5DB998;
  v3 = (void **)(a1 + 24);
  std::vector<at::tlv::CommandCallback>::__destroy_vector::operator()[abi:ne180100](&v3);
  return a1;
}

{
  void **v3;

  *(_QWORD *)a1 = off_24D5DB998;
  v3 = (void **)(a1 + 24);
  std::vector<at::tlv::CommandCallback>::__destroy_vector::operator()[abi:ne180100](&v3);
  return MEMORY[0x2199FEAC4](a1, 0x10A1C406F1F2BB1);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<uim::tlv::RefreshReg>::getSize(uint64_t a1)
{
  return tlv::size<uim::tlv::RefreshReg>(a1 + 16);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<uim::tlv::RefreshReg>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  uint64_t v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = *a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<uim::tlv::RefreshReg>(a2, a1 + 16);
  v7 = *a2 - v5;
  *(_BYTE *)v4 = v3;
  *(_WORD *)(v4 + 1) = v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<uim::tlv::RefreshReg>::clone(uint64_t a1)
{
  uint64_t v2;

  v2 = operator new();
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)v2 = off_24D5DB998;
  *(_WORD *)(v2 + 16) = *(_WORD *)(a1 + 16);
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 40) = 0;
  *(_QWORD *)(v2 + 24) = 0;
  std::vector<uim::tlv::FileId>::__init_with_size[abi:ne180100]<uim::tlv::FileId*,uim::tlv::FileId*>((_QWORD *)(v2 + 24), *(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 32), (uint64_t)(*(_QWORD *)(a1 + 32) - *(_QWORD *)(a1 + 24)) >> 5);
  return v2;
}

void sub_2169E2C40(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199FEAC4](v1, 0x10A1C406F1F2BB1);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<uim::tlv::RefreshComplete>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<uim::tlv::RefreshComplete>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<uim::tlv::RefreshComplete>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<uim::tlv::RefreshComplete>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5DBA10;
  return result;
}

_QWORD *std::__function::__func<subscriber::EURSimCommandDriver::handleRefreshStart(uim::tlv::Refresh const&)::$_0,std::allocator<subscriber::EURSimCommandDriver::handleRefreshStart(uim::tlv::Refresh const&)::$_0>,void ()(subscriber::SimSlot)>::~__func(_QWORD *a1)
{
  void *v2;
  NSObject *v3;
  NSObject *v4;

  *a1 = &off_24D5DBA48;
  v2 = (void *)a1[5];
  if (v2)
  {
    a1[6] = v2;
    operator delete(v2);
  }
  v3 = a1[2];
  if (v3)
  {
    dispatch_group_leave(v3);
    v4 = a1[2];
    if (v4)
      dispatch_release(v4);
  }
  return a1;
}

void std::__function::__func<subscriber::EURSimCommandDriver::handleRefreshStart(uim::tlv::Refresh const&)::$_0,std::allocator<subscriber::EURSimCommandDriver::handleRefreshStart(uim::tlv::Refresh const&)::$_0>,void ()(subscriber::SimSlot)>::~__func(_QWORD *a1)
{
  void *v2;
  NSObject *v3;
  NSObject *v4;

  *a1 = &off_24D5DBA48;
  v2 = (void *)a1[5];
  if (v2)
  {
    a1[6] = v2;
    operator delete(v2);
  }
  v3 = a1[2];
  if (v3)
  {
    dispatch_group_leave(v3);
    v4 = a1[2];
    if (v4)
      dispatch_release(v4);
  }
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<subscriber::EURSimCommandDriver::handleRefreshStart(uim::tlv::Refresh const&)::$_0,std::allocator<subscriber::EURSimCommandDriver::handleRefreshStart(uim::tlv::Refresh const&)::$_0>,void ()(subscriber::SimSlot)>::__clone(uint64_t a1)
{
  uint64_t v1;
  _QWORD *v2;

  v1 = a1 + 8;
  v2 = operator new(0x40uLL);
  *v2 = &off_24D5DBA48;
  std::__compressed_pair_elem<subscriber::EURSimCommandDriver::handleRefreshStart(uim::tlv::Refresh const&)::$_0,0,false>::__compressed_pair_elem[abi:ne180100]<subscriber::EURSimCommandDriver::handleRefreshStart(uim::tlv::Refresh const&)::$_0 const&,0ul>((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_2169E2E1C(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<subscriber::EURSimCommandDriver::handleRefreshStart(uim::tlv::Refresh const&)::$_0,std::allocator<subscriber::EURSimCommandDriver::handleRefreshStart(uim::tlv::Refresh const&)::$_0>,void ()(subscriber::SimSlot)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_24D5DBA48;
  return std::__compressed_pair_elem<subscriber::EURSimCommandDriver::handleRefreshStart(uim::tlv::Refresh const&)::$_0,0,false>::__compressed_pair_elem[abi:ne180100]<subscriber::EURSimCommandDriver::handleRefreshStart(uim::tlv::Refresh const&)::$_0 const&,0ul>((uint64_t)(a2 + 1), a1 + 8);
}

void std::__function::__func<subscriber::EURSimCommandDriver::handleRefreshStart(uim::tlv::Refresh const&)::$_0,std::allocator<subscriber::EURSimCommandDriver::handleRefreshStart(uim::tlv::Refresh const&)::$_0>,void ()(subscriber::SimSlot)>::destroy(uint64_t a1)
{
  std::__function::__alloc_func<subscriber::EURSimCommandDriver::handleRefreshStart(uim::tlv::Refresh const&)::$_0,std::allocator<subscriber::EURSimCommandDriver::handleRefreshStart(uim::tlv::Refresh const&)::$_0>,void ()(subscriber::SimSlot)>::destroy[abi:ne180100]((_QWORD *)(a1 + 8));
}

void std::__function::__func<subscriber::EURSimCommandDriver::handleRefreshStart(uim::tlv::Refresh const&)::$_0,std::allocator<subscriber::EURSimCommandDriver::handleRefreshStart(uim::tlv::Refresh const&)::$_0>,void ()(subscriber::SimSlot)>::destroy_deallocate(_QWORD *a1)
{
  std::__function::__alloc_func<subscriber::EURSimCommandDriver::handleRefreshStart(uim::tlv::Refresh const&)::$_0,std::allocator<subscriber::EURSimCommandDriver::handleRefreshStart(uim::tlv::Refresh const&)::$_0>,void ()(subscriber::SimSlot)>::destroy[abi:ne180100](a1 + 1);
  operator delete(a1);
}

void std::__function::__func<subscriber::EURSimCommandDriver::handleRefreshStart(uim::tlv::Refresh const&)::$_0,std::allocator<subscriber::EURSimCommandDriver::handleRefreshStart(uim::tlv::Refresh const&)::$_0>,void ()(subscriber::SimSlot)>::operator()(uint64_t a1, int *a2)
{
  int v3;
  NSObject *v4;
  NSObject *isa;
  const BOOL *v6;
  NSObject *v7;
  char *v8;
  const void **v9;
  char *v10;
  _BYTE *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  char *v19;
  uint64_t *v20;
  char *v21;
  char *v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  void *v26;
  unsigned int v27;
  int v28;
  int v29;
  int v30;
  _QWORD *v31;
  _QWORD *v32;
  const char *v33;
  size_t v34;
  _BOOL4 v35;
  uint64_t v36;
  uint64_t v37;
  __int128 *p_aBlock;
  uint64_t *v39;
  pthread_mutex_t *v40;
  uint64_t v41;
  unsigned int v42;
  uint64_t v43;
  unsigned int v44;
  uint64_t *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t *v48;
  uint64_t v49;
  uint64_t v50;
  unsigned int *v51;
  unsigned int v52;
  __int128 v53;
  uint64_t *v54;
  uint64_t v55;
  uint64_t *v56;
  uint64_t v57;
  uint64_t *v58;
  uint64_t v59;
  void *v60;
  uint64_t *v61;
  void *v62;
  void *v63;
  uint64_t v64;
  uint64_t v65;
  int v66;
  BOOL v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  __int128 aBlock;
  __int128 v72;
  uint8_t *v73;
  void *__p[2];
  __int128 v75;
  _QWORD v76[3];
  __int128 v77;
  int v78;
  int v79;
  std::runtime_error v80;
  _BYTE v81[32];
  void *v82;
  uint8_t buf[16];
  __int128 v84;
  dispatch_group_t group[2];
  __int128 v86;
  void *v87[2];
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  boost::signals2::mutex *v94[2];
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  uint8_t *v99;
  uint64_t v100;
  int *v101;
  int *v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;

  v105 = *MEMORY[0x24BDAC8D0];
  v3 = *a2;
  v4 = *(NSObject **)(a1 + 8);
  isa = v4[5].isa;
  if (os_log_type_enabled(isa, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315138;
    *(_QWORD *)&buf[4] = printers::asString((printers *)(a1 + 24), v6);
    _os_log_impl(&dword_216897000, isa, OS_LOG_TYPE_DEFAULT, "#I shouldSendComplete (%s)", buf, 0xCu);
  }
  if (*(_BYTE *)(a1 + 24))
  {
    v7 = *(NSObject **)(a1 + 16);
    if (v7)
    {
      dispatch_retain(*(dispatch_object_t *)(a1 + 16));
      dispatch_group_enter(v7);
    }
    *(_OWORD *)__p = 0u;
    v75 = 0u;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
    v8 = qmi::MutableMessageBase::getTLV<uim::tlv::SessionInfo>(__p);
    *v8 = *(_BYTE *)(a1 + 32);
    if (v8 != (char *)(a1 + 32))
      std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((_QWORD *)v8 + 1, *(char **)(a1 + 40), *(char **)(a1 + 48), *(_QWORD *)(a1 + 48) - *(_QWORD *)(a1 + 40));
    v9 = (const void **)__p[1];
    if (__p[1] != (void *)v75)
    {
      while (*((_BYTE *)*v9 + 8) != 2)
      {
        if (++v9 == (const void **)v75)
          goto LABEL_15;
      }
    }
    if (v9 == (const void **)v75)
    {
LABEL_15:
      v12 = operator new();
      v13 = v12;
      *(_WORD *)(v12 + 8) = 2;
      *(_QWORD *)v12 = &off_24D5DBA10;
      v14 = v75;
      if ((unint64_t)v75 >= *((_QWORD *)&v75 + 1))
      {
        v16 = (uint64_t)(v75 - (unint64_t)__p[1]) >> 3;
        if ((unint64_t)(v16 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v17 = (uint64_t)(*((_QWORD *)&v75 + 1) - (unint64_t)__p[1]) >> 2;
        if (v17 <= v16 + 1)
          v17 = v16 + 1;
        if (*((_QWORD *)&v75 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v18 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v18 = v17;
        if (v18)
          v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v75 + 8, v18);
        else
          v19 = 0;
        v20 = (uint64_t *)&v19[8 * v16];
        v21 = &v19[8 * v18];
        *v20 = v13;
        v15 = v20 + 1;
        v23 = (char *)__p[1];
        v22 = (char *)v75;
        if ((void *)v75 != __p[1])
        {
          do
          {
            v24 = *((_QWORD *)v22 - 1);
            v22 -= 8;
            *--v20 = v24;
          }
          while (v22 != v23);
          v22 = (char *)__p[1];
        }
        __p[1] = v20;
        *(_QWORD *)&v75 = v15;
        *((_QWORD *)&v75 + 1) = v21;
        if (v22)
          operator delete(v22);
      }
      else
      {
        *(_QWORD *)v75 = v12;
        v15 = (_QWORD *)(v14 + 8);
      }
      v11 = (_BYTE *)(v13 + 9);
      *(_QWORD *)&v75 = v15;
    }
    else
    {
      if (!v10)
        __cxa_bad_cast();
      v11 = v10 + 9;
    }
    *v11 = 1;
    *(_QWORD *)v81 = v4 + 16;
    *(_QWORD *)&v81[8] = QMIServiceMsg::create();
    *(_QWORD *)&v81[24] = 0;
    v82 = 0;
    *(_DWORD *)&v81[16] = 240000;
    v25 = MEMORY[0x24BDAC760];
    *(_QWORD *)buf = MEMORY[0x24BDAC760];
    *(_QWORD *)&buf[8] = 1174405120;
    *(_QWORD *)&v84 = ___ZNK10subscriber19EURSimCommandDriver19sendRefreshCompleteEN8dispatch13group_sessionERKN3uim3tlv11SessionInfoEb_block_invoke_3;
    *((_QWORD *)&v84 + 1) = &__block_descriptor_tmp_34_9;
    group[0] = v4;
    group[1] = v7;
    if (v7)
    {
      dispatch_retain(v7);
      dispatch_group_enter(v7);
    }
    *(_QWORD *)&aBlock = v25;
    *((_QWORD *)&aBlock + 1) = 0x40000000;
    *(_QWORD *)&v72 = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_21;
    *((_QWORD *)&v72 + 1) = &unk_24D5DB9C8;
    v73 = buf;
    v26 = _Block_copy(&aBlock);
    v82 = v26;
    if (*(_QWORD *)&v81[8])
    {
      qmi::Client::send();
      v26 = v82;
    }
    if (v26)
      _Block_release(v26);
    if (group[1])
    {
      dispatch_group_leave(group[1]);
      if (group[1])
        dispatch_release(group[1]);
    }
    qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
    if (v7)
    {
      dispatch_group_leave(v7);
      dispatch_release(v7);
    }
  }
  v27 = *(unsigned __int8 *)(a1 + 32);
  LODWORD(__p[0]) = v3;
  v99 = 0;
  if (((1 << v27) & 0xA) != 0)
    v28 = 2;
  else
    v28 = 1;
  v97 = 0u;
  v98 = 0u;
  if (((1 << v27) & 0x10030) != 0)
    v29 = 3;
  else
    v29 = v28;
  if (v27 <= 0x10)
    v30 = v29;
  else
    v30 = 1;
  v95 = 0uLL;
  v96 = 0uLL;
  v93 = 0uLL;
  *(_OWORD *)v94 = 0uLL;
  v91 = 0uLL;
  v92 = 0uLL;
  v89 = 0uLL;
  v90 = 0uLL;
  *(_OWORD *)v87 = 0uLL;
  v88 = 0uLL;
  *(_OWORD *)group = 0uLL;
  v86 = 0uLL;
  *(_OWORD *)buf = 0uLL;
  v84 = 0uLL;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)buf);
  v31 = (_QWORD *)subscriber::operator<<();
  v32 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v31, (uint64_t)", ", 2);
  v33 = (const char *)subscriber::asString();
  v34 = strlen(v33);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v32, (uint64_t)v33, v34);
  std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)&buf[8], &aBlock);
  v35 = os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_DEFAULT);
  v36 = MEMORY[0x24BDC4420];
  if (v35)
  {
    v37 = *(_QWORD *)(MEMORY[0x24BDC4420] + 24);
    p_aBlock = &aBlock;
    if (SBYTE7(v72) < 0)
      p_aBlock = (__int128 *)aBlock;
    *(_DWORD *)v81 = 136315394;
    *(_QWORD *)&v81[4] = v37;
    *(_WORD *)&v81[12] = 2080;
    *(_QWORD *)&v81[14] = p_aBlock;
    _os_log_impl(&dword_216897000, MEMORY[0x24BDACB70], OS_LOG_TYPE_DEFAULT, "Firing event '%s': with params= %s", v81, 0x16u);
  }
  if (SBYTE7(v72) < 0)
    operator delete((void *)aBlock);
  *(_QWORD *)buf = *MEMORY[0x24BEDB800];
  *(_QWORD *)&buf[*(_QWORD *)(*(_QWORD *)buf - 24)] = *(_QWORD *)(MEMORY[0x24BEDB800] + 24);
  *(_QWORD *)&buf[8] = MEMORY[0x24BEDB848] + 16;
  if (SHIBYTE(v88) < 0)
    operator delete(v87[1]);
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x2199FEA70](&v90);
  v39 = *(uint64_t **)(v36 + 8);
  if (!v39)
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  v78 = v30;
  v79 = v3;
  v77 = 0uLL;
  v93 = 0u;
  *(_OWORD *)v94 = 0u;
  v91 = 0u;
  v92 = 0u;
  v89 = 0u;
  v90 = 0u;
  *(_OWORD *)v87 = 0u;
  v88 = 0u;
  *(_OWORD *)group = 0u;
  v86 = 0u;
  *(_OWORD *)buf = 0u;
  v84 = 0u;
  v40 = (pthread_mutex_t *)boost::shared_ptr<boost::signals2::mutex>::operator*(v39 + 3);
  boost::signals2::detail::garbage_collecting_lock<boost::signals2::mutex>::garbage_collecting_lock(buf, v40);
  v41 = v39[1];
  if (v41)
  {
    v42 = atomic_load((unsigned int *)(v41 + 8));
    if (v42 == 1)
    {
      v43 = v39[1];
      if (!v43 || (v44 = atomic_load((unsigned int *)(v43 + 8)), v44 != 1))
        __assert_rtn("nolock_cleanup_connections", "signal_template.hpp", 461, "_shared_state.unique()");
      v45 = (uint64_t *)boost::shared_ptr<boost::signals2::detail::signal_impl<void ()(subscriber::SimSlot,subscriber::SimCard),boost::signals2::optional_last_value<void>,int,std::less<int>,boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>,boost::function<void ()(boost::signals2::connection const&,subscriber::SimSlot,subscriber::SimCard)>,boost::signals2::mutex>::invocation_state>::operator->(*v39);
      v46 = boost::shared_ptr<boost::signals2::detail::grouped_list<int,std::less<int>,boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>>>::operator*(*v45);
      v47 = v39[2];
      if (v47 == v46)
      {
        v48 = (uint64_t *)boost::shared_ptr<boost::signals2::detail::signal_impl<void ()(subscriber::SimSlot,subscriber::SimCard),boost::signals2::optional_last_value<void>,int,std::less<int>,boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>,boost::function<void ()(boost::signals2::connection const&,subscriber::SimSlot,subscriber::SimCard)>,boost::signals2::mutex>::invocation_state>::operator->(*v39);
        v47 = *(_QWORD *)(boost::shared_ptr<boost::signals2::detail::grouped_list<int,std::less<int>,boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>>>::operator*(*v48)
                        + 8);
      }
      *(_QWORD *)&aBlock = v47;
      boost::signals2::detail::signal_impl<void ()(subscriber::SimSlot,subscriber::SimCard),boost::signals2::optional_last_value<void>,int,std::less<int>,boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>,boost::function<void ()(boost::signals2::connection const&,subscriber::SimSlot,subscriber::SimCard)>,boost::signals2::mutex>::nolock_cleanup_connections_from(v39, (uint64_t **)&aBlock, 1);
    }
    v49 = *v39;
    v50 = v39[1];
    if (v50)
    {
      v51 = (unsigned int *)(v50 + 8);
      do
        v52 = __ldxr(v51);
      while (__stxr(v52 + 1, v51));
    }
  }
  else
  {
    v50 = 0;
    v49 = *v39;
  }
  v53 = v77;
  *(_QWORD *)&v77 = v49;
  *((_QWORD *)&v77 + 1) = v50;
  aBlock = v53;
  boost::detail::shared_count::~shared_count((unsigned int **)&aBlock + 1);
  boost::signals2::mutex::unlock((pthread_mutex_t *)v94[1]);
  boost::signals2::detail::auto_buffer<boost::shared_ptr<void>,boost::signals2::detail::store_n_objects<10u>,boost::signals2::detail::default_grow_policy,std::allocator<boost::shared_ptr<void>>>::auto_buffer_destroy(buf);
  v96 = 0u;
  v97 = 0u;
  *(_OWORD *)v94 = 0u;
  v95 = 0u;
  v92 = 0u;
  v93 = 0u;
  v90 = 0u;
  v91 = 0u;
  v88 = 0u;
  v89 = 0u;
  v86 = 0u;
  *(_OWORD *)v87 = 0u;
  v84 = 0u;
  *(_OWORD *)group = 0u;
  *(_OWORD *)buf = 0u;
  *(_QWORD *)&v98 = 0;
  *((_QWORD *)&v98 + 1) = 10;
  v99 = &buf[8];
  v100 = 0;
  v101 = &v79;
  v102 = &v78;
  v104 = 0;
  v103 = 0;
  v54 = (uint64_t *)boost::shared_ptr<boost::signals2::detail::signal_impl<void ()(subscriber::SimSlot,subscriber::SimCard),boost::signals2::optional_last_value<void>,int,std::less<int>,boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>,boost::function<void ()(boost::signals2::connection const&,subscriber::SimSlot,subscriber::SimCard)>,boost::signals2::mutex>::invocation_state>::operator->(v77);
  v55 = boost::shared_ptr<boost::signals2::detail::grouped_list<int,std::less<int>,boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>>>::operator*(*v54);
  v76[0] = buf;
  v76[1] = v39;
  v76[2] = v55;
  if (!*(_QWORD *)(boost::shared_ptr<boost::signals2::detail::signal_impl<void ()(subscriber::SimSlot,subscriber::SimCard),boost::signals2::optional_last_value<void>,int,std::less<int>,boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>,boost::function<void ()(boost::signals2::connection const&,subscriber::SimSlot,subscriber::SimCard)>,boost::signals2::mutex>::invocation_state>::operator->(v77)
                  + 16))
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  v56 = (uint64_t *)boost::shared_ptr<boost::signals2::detail::signal_impl<void ()(subscriber::SimSlot,subscriber::SimCard),boost::signals2::optional_last_value<void>,int,std::less<int>,boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>,boost::function<void ()(boost::signals2::connection const&,subscriber::SimSlot,subscriber::SimCard)>,boost::signals2::mutex>::invocation_state>::operator->(v77);
  v57 = *(_QWORD *)(boost::shared_ptr<boost::signals2::detail::grouped_list<int,std::less<int>,boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>>>::operator*(*v56)
                  + 8);
  v58 = (uint64_t *)boost::shared_ptr<boost::signals2::detail::signal_impl<void ()(subscriber::SimSlot,subscriber::SimCard),boost::signals2::optional_last_value<void>,int,std::less<int>,boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>,boost::function<void ()(boost::signals2::connection const&,subscriber::SimSlot,subscriber::SimCard)>,boost::signals2::mutex>::invocation_state>::operator->(v77);
  v59 = boost::shared_ptr<boost::signals2::detail::grouped_list<int,std::less<int>,boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>>>::operator*(*v58);
  *(_QWORD *)v81 = v57;
  *(_QWORD *)&v81[8] = v59;
  *(_QWORD *)&v81[16] = buf;
  *(_QWORD *)&v81[24] = v59;
  boost::signals2::detail::slot_call_iterator_t<boost::signals2::detail::variadic_slot_invoker<boost::signals2::detail::void_type,subscriber::SimSlot,subscriber::SimCard>,std::__list_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>,void *>,boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>::lock_next_callable((uint64_t *)v81);
  v60 = *(void **)boost::shared_ptr<boost::signals2::detail::signal_impl<void ()(subscriber::SimSlot,subscriber::SimCard),boost::signals2::optional_last_value<void>,int,std::less<int>,boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>,boost::function<void ()(boost::signals2::connection const&,subscriber::SimSlot,subscriber::SimCard)>,boost::signals2::mutex>::invocation_state>::operator->(v77);
  boost::shared_ptr<boost::signals2::detail::grouped_list<int,std::less<int>,boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>>>::operator*((uint64_t)v60);
  v61 = (uint64_t *)boost::shared_ptr<boost::signals2::detail::signal_impl<void ()(subscriber::SimSlot,subscriber::SimCard),boost::signals2::optional_last_value<void>,int,std::less<int>,boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>,boost::function<void ()(boost::signals2::connection const&,subscriber::SimSlot,subscriber::SimCard)>,boost::signals2::mutex>::invocation_state>::operator->(v77);
  v62 = (void *)boost::shared_ptr<boost::signals2::detail::grouped_list<int,std::less<int>,boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>>>::operator*(*v61);
  __p[0] = v60;
  __p[1] = v62;
  *(_QWORD *)&v75 = buf;
  *((_QWORD *)&v75 + 1) = v62;
  boost::signals2::detail::slot_call_iterator_t<boost::signals2::detail::variadic_slot_invoker<boost::signals2::detail::void_type,subscriber::SimSlot,subscriber::SimCard>,std::__list_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>,void *>,boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>::lock_next_callable((uint64_t *)__p);
  aBlock = *(_OWORD *)v81;
  v72 = *(_OWORD *)&v81[16];
  v63 = __p[0];
  v64 = *(_QWORD *)v81;
  if (*(void **)v81 != __p[0])
  {
    v65 = v72;
    v66 = *(unsigned __int8 *)v72;
    v67 = *(_BYTE *)v72 == 0;
    do
    {
      if (v67)
      {
        v68 = boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>::operator->(*(_QWORD *)(v64 + 16));
        v69 = boost::shared_ptr<boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>>::operator*(*(_QWORD *)(v68 + 32));
        v70 = *(_QWORD *)(v69 + 24);
        if (!v70)
        {
          std::runtime_error::runtime_error(&v80, "call to empty boost::function");
          v80.__vftable = (std::runtime_error_vtbl *)&unk_24D5DBC20;
          boost::throw_exception<boost::bad_function_call>(&v80);
        }
        (*(void (**)(uint64_t, _QWORD, _QWORD))((v70 & 0xFFFFFFFFFFFFFFFELL) + 8))(v69 + 32, **(unsigned int **)(v65 + 272), **(unsigned int **)(v65 + 280));
        if (!*(_BYTE *)v65)
          *(_BYTE *)v65 = 1;
      }
      else if (!v66)
      {
        __assert_rtn("get", "optional.hpp", 1212, "this->is_initialized()");
      }
      *(_QWORD *)&aBlock = *(_QWORD *)(v64 + 8);
      boost::signals2::detail::slot_call_iterator_t<boost::signals2::detail::variadic_slot_invoker<boost::signals2::detail::void_type,subscriber::SimSlot,subscriber::SimCard>,std::__list_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>,void *>,boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>::lock_next_callable((uint64_t *)&aBlock);
      v65 = v72;
      if (*(_BYTE *)v72)
        *(_BYTE *)v72 = 0;
      v66 = 0;
      v64 = aBlock;
      v67 = 1;
    }
    while ((void *)aBlock != v63);
  }
  boost::signals2::detail::signal_impl<void ()(subscriber::SimSlot,subscriber::SimCard),boost::signals2::optional_last_value<void>,int,std::less<int>,boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>,boost::function<void ()(boost::signals2::connection const&,subscriber::SimSlot,subscriber::SimCard)>,boost::signals2::mutex>::invocation_janitor::~invocation_janitor(v76);
  boost::signals2::detail::slot_call_iterator_cache<boost::signals2::detail::void_type,boost::signals2::detail::variadic_slot_invoker<boost::signals2::detail::void_type,subscriber::SimSlot,subscriber::SimCard>>::~slot_call_iterator_cache((uint64_t)buf);
  boost::detail::shared_count::~shared_count((unsigned int **)&v77 + 1);
}

void sub_2169E37A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,dispatch_group_t group,uint64_t a43,uint64_t a44,uint64_t a45,void *__p,uint64_t a47,int a48,__int16 a49,char a50,char a51)
{
  NSObject *v51;

  if (group)
  {
    dispatch_group_leave(group);
    if (group)
      dispatch_release(group);
  }
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)&a31);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a17);
  if (v51)
  {
    dispatch_group_leave(v51);
    dispatch_release(v51);
  }
  _Unwind_Resume(a1);
}

void sub_2169E389C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,boost::signals2::mutex *a60)
{
  boost::signals2::mutex::unlock((pthread_mutex_t *)a60);
  boost::signals2::detail::auto_buffer<boost::shared_ptr<void>,boost::signals2::detail::store_n_objects<10u>,boost::signals2::detail::default_grow_policy,std::allocator<boost::shared_ptr<void>>>::auto_buffer_destroy(&a37);
  JUMPOUT(0x2169E38B0);
}

void sub_2169E38CC(void *a1, int a2)
{
  if (!a2)
    JUMPOUT(0x2169E38D4);
  __clang_call_terminate(a1);
}

uint64_t std::__function::__func<subscriber::EURSimCommandDriver::handleRefreshStart(uim::tlv::Refresh const&)::$_0,std::allocator<subscriber::EURSimCommandDriver::handleRefreshStart(uim::tlv::Refresh const&)::$_0>,void ()(subscriber::SimSlot)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<subscriber::EURSimCommandDriver::handleRefreshStart(uim::tlv::Refresh const&)::$_0,std::allocator<subscriber::EURSimCommandDriver::handleRefreshStart(uim::tlv::Refresh const&)::$_0>,void ()(subscriber::SimSlot)>::target_type()
{
}

uint64_t std::__compressed_pair_elem<subscriber::EURSimCommandDriver::handleRefreshStart(uim::tlv::Refresh const&)::$_0,0,false>::__compressed_pair_elem[abi:ne180100]<subscriber::EURSimCommandDriver::handleRefreshStart(uim::tlv::Refresh const&)::$_0 const&,0ul>(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  NSObject *v5;
  char v6;
  char v7;

  v4 = *(NSObject **)(a2 + 8);
  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_QWORD *)(a1 + 8) = v4;
  if (v4)
  {
    dispatch_retain(v4);
    v5 = *(NSObject **)(a1 + 8);
    if (v5)
      dispatch_group_enter(v5);
  }
  v6 = *(_BYTE *)(a2 + 16);
  v7 = *(_BYTE *)(a2 + 24);
  *(_QWORD *)(a1 + 32) = 0;
  *(_BYTE *)(a1 + 16) = v6;
  *(_BYTE *)(a1 + 24) = v7;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>((_QWORD *)(a1 + 32), *(const void **)(a2 + 32), *(_QWORD *)(a2 + 40), *(_QWORD *)(a2 + 40) - *(_QWORD *)(a2 + 32));
  return a1;
}

void sub_2169E3994(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  NSObject *v3;
  NSObject *v4;

  v3 = *(NSObject **)(v1 + 8);
  if (v3)
  {
    dispatch_group_leave(v3);
    v4 = *(NSObject **)(v1 + 8);
    if (v4)
      dispatch_release(v4);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__alloc_func<subscriber::EURSimCommandDriver::handleRefreshStart(uim::tlv::Refresh const&)::$_0,std::allocator<subscriber::EURSimCommandDriver::handleRefreshStart(uim::tlv::Refresh const&)::$_0>,void ()(subscriber::SimSlot)>::destroy[abi:ne180100](_QWORD *a1)
{
  void *v2;
  NSObject *v3;
  NSObject *v4;

  v2 = (void *)a1[4];
  if (v2)
  {
    a1[5] = v2;
    operator delete(v2);
  }
  v3 = a1[1];
  if (v3)
  {
    dispatch_group_leave(v3);
    v4 = a1[1];
    if (v4)
      dispatch_release(v4);
  }
}

uint64_t boost::shared_ptr<boost::signals2::mutex>::operator*(uint64_t *a1)
{
  uint64_t result;

  result = *a1;
  if (!result)
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  return result;
}

uint64_t boost::signals2::detail::garbage_collecting_lock<boost::signals2::mutex>::~garbage_collecting_lock(uint64_t a1)
{
  boost::signals2::mutex::unlock(*(pthread_mutex_t **)(a1 + 184));
  boost::signals2::detail::auto_buffer<boost::shared_ptr<void>,boost::signals2::detail::store_n_objects<10u>,boost::signals2::detail::default_grow_policy,std::allocator<boost::shared_ptr<void>>>::auto_buffer_destroy((_QWORD *)a1);
  return a1;
}

uint64_t boost::shared_ptr<boost::signals2::detail::signal_impl<void ()(subscriber::SimSlot,subscriber::SimCard),boost::signals2::optional_last_value<void>,int,std::less<int>,boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>,boost::function<void ()(boost::signals2::connection const&,subscriber::SimSlot,subscriber::SimCard)>,boost::signals2::mutex>::invocation_state>::operator->(uint64_t result)
{
  if (!result)
    __assert_rtn("operator->", "shared_ptr.hpp", 786, "px != 0");
  return result;
}

_QWORD *boost::signals2::detail::garbage_collecting_lock<boost::signals2::mutex>::garbage_collecting_lock(_QWORD *a1, pthread_mutex_t *this)
{
  a1[20] = 10;
  a1[21] = a1;
  a1[22] = 0;
  a1[23] = this;
  boost::signals2::mutex::lock(this);
  return a1;
}

void sub_2169E3AEC(_Unwind_Exception *a1)
{
  _QWORD *v1;

  boost::signals2::detail::auto_buffer<boost::shared_ptr<void>,boost::signals2::detail::store_n_objects<10u>,boost::signals2::detail::default_grow_policy,std::allocator<boost::shared_ptr<void>>>::auto_buffer_destroy(v1);
  _Unwind_Resume(a1);
}

uint64_t boost::signals2::mutex::lock(pthread_mutex_t *this)
{
  uint64_t result;

  result = pthread_mutex_lock(this);
  if ((_DWORD)result)
    __assert_rtn("lock", "lwm_pthreads.hpp", 60, "pthread_mutex_lock(&m_) == 0");
  return result;
}

void boost::signals2::detail::auto_buffer<boost::shared_ptr<void>,boost::signals2::detail::store_n_objects<10u>,boost::signals2::detail::default_grow_policy,std::allocator<boost::shared_ptr<void>>>::auto_buffer_destroy(_QWORD *a1)
{
  _QWORD *v1;
  unint64_t v2;
  BOOL v3;

  v1 = (_QWORD *)a1[21];
  if (v1)
  {
    v2 = a1[20];
    if (v2 < 0xA || (v1 == a1 ? (v3 = v2 == 10) : (v3 = 1), !v3 || a1[22] > v2))
      __assert_rtn("auto_buffer_destroy", "auto_buffer.hpp", 255, "is_valid()");
    boost::signals2::detail::auto_buffer<boost::shared_ptr<void>,boost::signals2::detail::store_n_objects<10u>,boost::signals2::detail::default_grow_policy,std::allocator<boost::shared_ptr<void>>>::auto_buffer_destroy((uint64_t)a1);
  }
}

void boost::signals2::detail::auto_buffer<boost::shared_ptr<void>,boost::signals2::detail::store_n_objects<10u>,boost::signals2::detail::default_grow_policy,std::allocator<boost::shared_ptr<void>>>::auto_buffer_destroy(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 176);
  if (v2)
    boost::signals2::detail::auto_buffer<boost::shared_ptr<void>,boost::signals2::detail::store_n_objects<10u>,boost::signals2::detail::default_grow_policy,std::allocator<boost::shared_ptr<void>>>::destroy_back_n(a1, v2);
  if (*(_QWORD *)(a1 + 160) >= 0xBuLL)
    operator delete(*(void **)(a1 + 168));
}

void boost::signals2::detail::auto_buffer<boost::shared_ptr<void>,boost::signals2::detail::store_n_objects<10u>,boost::signals2::detail::default_grow_policy,std::allocator<boost::shared_ptr<void>>>::destroy_back_n(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;

  if (!a2)
    __assert_rtn("destroy_back_n", "auto_buffer.hpp", 263, "n > 0");
  if (a2 - 1 >= 0)
  {
    v2 = *(_QWORD *)(a1 + 168) + 16 * *(_QWORD *)(a1 + 176);
    v3 = v2 + 16 * ~a2;
    v4 = v2 - 16;
    do
    {
      boost::detail::shared_count::~shared_count((unsigned int **)(v4 + 8));
      v4 -= 16;
    }
    while (v4 > v3);
  }
}

void boost::detail::shared_count::~shared_count(unsigned int **this)
{
  unsigned int *v1;
  unsigned int *v2;
  unsigned int v3;
  unsigned int v4;
  unsigned int *v5;
  unsigned int v6;
  unsigned int v7;

  v1 = *this;
  if (*this)
  {
    v2 = v1 + 2;
    do
    {
      v3 = __ldaxr(v2);
      v4 = v3 - 1;
    }
    while (__stlxr(v4, v2));
    if (!v4)
    {
      (*(void (**)(unsigned int *))(*(_QWORD *)v1 + 16))(v1);
      v5 = v1 + 3;
      do
      {
        v6 = __ldaxr(v5);
        v7 = v6 - 1;
      }
      while (__stlxr(v7, v5));
      if (!v7)
        (*(void (**)(unsigned int *))(*(_QWORD *)v1 + 24))(v1);
    }
  }
}

uint64_t boost::signals2::detail::signal_impl<void ()(subscriber::SimSlot,subscriber::SimCard),boost::signals2::optional_last_value<void>,int,std::less<int>,boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>,boost::function<void ()(boost::signals2::connection const&,subscriber::SimSlot,subscriber::SimCard)>,boost::signals2::mutex>::nolock_cleanup_connections_from(uint64_t *a1, uint64_t **a2, int a3)
{
  uint64_t v3;
  unsigned int v4;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t *v8;
  uint64_t result;
  unsigned int v10;
  unsigned int v11;
  uint64_t *v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t *v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t *v18;
  _BOOL4 v19;
  _QWORD *v20;
  _QWORD *v21;
  uint64_t *v22;
  uint64_t *v23;
  _BOOL4 v24;
  _QWORD *v25;
  void **v26;
  _QWORD *v27;
  uint64_t **v28;
  int v29;
  uint64_t *v30;
  uint64_t *v31;
  uint64_t *v32;
  BOOL v33;
  uint64_t *v34;
  uint64_t v35;
  uint64_t *v36;
  BOOL v37;
  uint64_t v38;
  uint64_t *v39;
  uint64_t **v40;
  uint64_t v41;

  v3 = a1[1];
  if (!v3 || (v4 = atomic_load((unsigned int *)(v3 + 8)), v4 != 1))
    __assert_rtn("nolock_cleanup_connections_from", "signal_template.hpp", 436, "_shared_state.unique()");
  v6 = a1;
  v7 = *a2;
  v8 = (uint64_t *)boost::shared_ptr<boost::signals2::detail::signal_impl<void ()(subscriber::SimSlot,subscriber::SimCard),boost::signals2::optional_last_value<void>,int,std::less<int>,boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>,boost::function<void ()(boost::signals2::connection const&,subscriber::SimSlot,subscriber::SimCard)>,boost::signals2::mutex>::invocation_state>::operator->(*a1);
  result = boost::shared_ptr<boost::signals2::detail::grouped_list<int,std::less<int>,boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>>>::operator*(*v8);
  if ((uint64_t *)result != v7)
  {
    v10 = 0;
    v11 = a3 - 1;
    v12 = v7;
    v39 = v6;
    do
    {
      if (*(_BYTE *)(boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>::operator->(v12[2])
                    + 24))
      {
        v7 = (uint64_t *)v12[1];
      }
      else
      {
        v13 = *(uint64_t **)boost::shared_ptr<boost::signals2::detail::signal_impl<void ()(subscriber::SimSlot,subscriber::SimCard),boost::signals2::optional_last_value<void>,int,std::less<int>,boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>,boost::function<void ()(boost::signals2::connection const&,subscriber::SimSlot,subscriber::SimCard)>,boost::signals2::mutex>::invocation_state>::operator->(*v6);
        boost::shared_ptr<boost::signals2::detail::grouped_list<int,std::less<int>,boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>>>::operator*((uint64_t)v13);
        v14 = boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>::operator->(v12[2]);
        if (v12 == v13)
          __assert_rtn("erase", "slot_groups.hpp", 148, "it != _list.end()");
        v15 = v13 + 4;
        v16 = (_QWORD *)v13[4];
        if (!v16)
          goto LABEL_45;
        v17 = v14 + 64;
        v40 = (uint64_t **)(v13 + 3);
        v18 = v13 + 4;
        do
        {
          v19 = boost::signals2::detail::group_key_less<int,std::less<int>>::operator()((uint64_t)(v13 + 6), (uint64_t)(v16 + 4), v17);
          v20 = v16 + 1;
          if (!v19)
          {
            v20 = v16;
            v18 = v16;
          }
          v16 = (_QWORD *)*v20;
        }
        while (*v20);
        if (v18 == v15)
LABEL_45:
          __assert_rtn("erase", "slot_groups.hpp", 150, "map_it != _group_map.end()");
        if (boost::signals2::detail::group_key_less<int,std::less<int>>::operator()((uint64_t)(v13 + 7), (uint64_t)(v18 + 4), v17)|| boost::signals2::detail::group_key_less<int,std::less<int>>::operator()((uint64_t)(v13 + 7), v17, (uint64_t)(v18 + 4)))
        {
          __assert_rtn("erase", "slot_groups.hpp", 151, "weakly_equivalent(map_it->first, key)");
        }
        if ((uint64_t *)v18[6] == v12)
        {
          v38 = v12[1];
          v21 = (_QWORD *)*v15;
          v22 = v13;
          if (*v15)
          {
            v23 = v13 + 4;
            do
            {
              v24 = boost::signals2::detail::group_key_less<int,std::less<int>>::operator()((uint64_t)(v13 + 6), v17, (uint64_t)(v21 + 4));
              v25 = v21 + 1;
              if (v24)
              {
                v25 = v21;
                v23 = v21;
              }
              v21 = (_QWORD *)*v25;
            }
            while (*v25);
            v22 = v13;
            if (v23 != v15)
              v22 = (uint64_t *)v23[6];
          }
          if ((uint64_t *)v38 == v22)
          {
            v30 = (uint64_t *)v18[1];
            v31 = v18;
            if (v30)
            {
              do
              {
                v32 = v30;
                v30 = (uint64_t *)*v30;
              }
              while (v30);
            }
            else
            {
              do
              {
                v32 = (uint64_t *)v31[2];
                v33 = *v32 == (_QWORD)v31;
                v31 = v32;
              }
              while (!v33);
            }
            if (*v40 == v18)
              *v40 = v32;
            v34 = (uint64_t *)v13[4];
            --v13[5];
            std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(v34, v18);
            operator delete(v18);
          }
          else
          {
            v41 = 0;
            v26 = (void **)std::__tree<std::__value_type<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,std::__list_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>,void *>>,std::__map_value_compare<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,std::__value_type<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,std::__list_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>,void *>>,boost::signals2::detail::group_key_less<int,std::less<int>>,false>,std::allocator<std::__value_type<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,std::__list_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>,void *>>>>::__find_equal<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>>((uint64_t)v40, &v41, v17);
            v27 = *v26;
            if (!*v26)
            {
              v28 = (uint64_t **)v26;
              v27 = operator new(0x38uLL);
              v29 = *(_DWORD *)(v17 + 8);
              v27[4] = *(_QWORD *)v17;
              *((_DWORD *)v27 + 10) = v29;
              v27[6] = 0;
              std::__tree<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::less<unsigned short>,true>,std::allocator<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>>>::__insert_node_at(v40, v41, v28, v27);
            }
            v27[6] = v38;
          }
        }
        v35 = *v12;
        v7 = (uint64_t *)v12[1];
        *(_QWORD *)(v35 + 8) = v7;
        *(_QWORD *)v12[1] = v35;
        --v13[2];
        boost::detail::shared_count::~shared_count((unsigned int **)v12 + 3);
        operator delete(v12);
        v6 = v39;
      }
      ++v10;
      v36 = (uint64_t *)boost::shared_ptr<boost::signals2::detail::signal_impl<void ()(subscriber::SimSlot,subscriber::SimCard),boost::signals2::optional_last_value<void>,int,std::less<int>,boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>,boost::function<void ()(boost::signals2::connection const&,subscriber::SimSlot,subscriber::SimCard)>,boost::signals2::mutex>::invocation_state>::operator->(*v6);
      result = boost::shared_ptr<boost::signals2::detail::grouped_list<int,std::less<int>,boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>>>::operator*(*v36);
      v37 = v7 != (uint64_t *)result && v11 >= v10;
      v12 = v7;
    }
    while (v37);
  }
  v6[2] = (uint64_t)v7;
  return result;
}

uint64_t boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>::operator->(uint64_t result)
{
  if (!result)
    __assert_rtn("operator->", "shared_ptr.hpp", 786, "px != 0");
  return result;
}

uint64_t boost::signals2::slot_base::expired(boost::signals2::slot_base *this)
{
  uint64_t v1;
  uint64_t result;

  v1 = *(_QWORD *)this;
  if (*(_QWORD *)this == *((_QWORD *)this + 1))
    return 0;
  do
  {
    result = boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>::apply_visitor<boost::signals2::detail::expired_weak_ptr_visitor const>(v1);
    if ((_DWORD)result)
      break;
    v1 += 24;
  }
  while (v1 != *((_QWORD *)this + 1));
  return result;
}

uint64_t boost::shared_ptr<boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>>::operator*(uint64_t result)
{
  if (!result)
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  return result;
}

uint64_t boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>::apply_visitor<boost::signals2::detail::expired_weak_ptr_visitor const>(uint64_t a1)
{
  uint64_t v1;
  unsigned int v2;
  uint64_t result;
  uint64_t v4;

  switch(*(_DWORD *)a1 ^ (*(int *)a1 >> 31))
  {
    case 0:
    case 1:
      v1 = *(_QWORD *)(a1 + 16);
      if (v1)
      {
        v2 = atomic_load((unsigned int *)(v1 + 8));
        result = v2 == 0;
      }
      else
      {
        result = 1;
      }
      break;
    case 2:
      v4 = boost::scoped_ptr<boost::signals2::detail::foreign_weak_ptr_impl_base>::operator->((uint64_t *)(a1 + 8));
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
      break;
    default:
      boost::detail::variant::forced_return<void>();
  }
  return result;
}

uint64_t boost::scoped_ptr<boost::signals2::detail::foreign_weak_ptr_impl_base>::operator->(uint64_t *a1)
{
  uint64_t result;

  result = *a1;
  if (!result)
    __assert_rtn("operator->", "scoped_ptr.hpp", 105, "px != 0");
  return result;
}

void boost::signals2::detail::connection_body_base::dec_slot_refcount<boost::signals2::mutex>(_DWORD *a1, _QWORD *a2)
{
  int v2;
  int v3;
  __int128 v5;

  v2 = a1[7];
  if (!v2)
    __assert_rtn("dec_slot_refcount", "connection.hpp", 124, "m_slot_refcount != 0");
  v3 = v2 - 1;
  a1[7] = v3;
  if (!v3)
  {
    (*(void (**)(__int128 *__return_ptr))(*(_QWORD *)a1 + 40))(&v5);
    boost::signals2::detail::auto_buffer<boost::shared_ptr<void>,boost::signals2::detail::store_n_objects<10u>,boost::signals2::detail::default_grow_policy,std::allocator<boost::shared_ptr<void>>>::push_back(a2, &v5);
    boost::detail::shared_count::~shared_count((unsigned int **)&v5 + 1);
  }
}

void sub_2169E4228(_Unwind_Exception *a1)
{
  uint64_t v1;

  boost::detail::shared_count::~shared_count((unsigned int **)(v1 + 8));
  _Unwind_Resume(a1);
}

_QWORD *boost::signals2::detail::auto_buffer<boost::shared_ptr<void>,boost::signals2::detail::store_n_objects<10u>,boost::signals2::detail::default_grow_policy,std::allocator<boost::shared_ptr<void>>>::push_back(_QWORD *a1, __int128 *a2)
{
  uint64_t v4;

  v4 = a1[22];
  if (v4 == a1[20])
    boost::signals2::detail::auto_buffer<boost::shared_ptr<void>,boost::signals2::detail::store_n_objects<10u>,boost::signals2::detail::default_grow_policy,std::allocator<boost::shared_ptr<void>>>::reserve(a1, v4 + 1);
  return boost::signals2::detail::auto_buffer<boost::shared_ptr<void>,boost::signals2::detail::store_n_objects<10u>,boost::signals2::detail::default_grow_policy,std::allocator<boost::shared_ptr<void>>>::unchecked_push_back(a1, a2);
}

_QWORD *boost::signals2::detail::auto_buffer<boost::shared_ptr<void>,boost::signals2::detail::store_n_objects<10u>,boost::signals2::detail::default_grow_policy,std::allocator<boost::shared_ptr<void>>>::unchecked_push_back(_QWORD *result, __int128 *a2)
{
  uint64_t v2;
  __int128 v3;
  unsigned int *v4;
  unsigned int v5;

  v2 = result[22];
  if (v2 == result[20])
    __assert_rtn("unchecked_push_back", "auto_buffer.hpp", 767, "!full()");
  v3 = *a2;
  *(_OWORD *)(result[21] + 16 * v2) = *a2;
  if (*((_QWORD *)&v3 + 1))
  {
    v4 = (unsigned int *)(*((_QWORD *)&v3 + 1) + 8);
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
    v2 = result[22];
  }
  result[22] = v2 + 1;
  return result;
}

void boost::signals2::detail::auto_buffer<boost::shared_ptr<void>,boost::signals2::detail::store_n_objects<10u>,boost::signals2::detail::default_grow_policy,std::allocator<boost::shared_ptr<void>>>::reserve(_QWORD *a1, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v5;

  v2 = a1[20];
  if (v2 <= 9)
    __assert_rtn("reserve", "auto_buffer.hpp", 793, "members_.capacity_ >= N");
  v3 = a2;
  if (v2 < a2)
  {
    v5 = 4 * v2;
    if (v5 > a2)
      a2 = v5;
    boost::signals2::detail::auto_buffer<boost::shared_ptr<void>,boost::signals2::detail::store_n_objects<10u>,boost::signals2::detail::default_grow_policy,std::allocator<boost::shared_ptr<void>>>::reserve_impl(a1, a2);
    if (a1[20] < v3)
      __assert_rtn("reserve", "auto_buffer.hpp", 799, "members_.capacity_ >= n");
  }
}

void boost::signals2::detail::auto_buffer<boost::shared_ptr<void>,boost::signals2::detail::store_n_objects<10u>,boost::signals2::detail::default_grow_policy,std::allocator<boost::shared_ptr<void>>>::reserve_impl(_QWORD *a1, unint64_t a2)
{
  _QWORD *v4;

  v4 = boost::signals2::detail::auto_buffer<boost::shared_ptr<void>,boost::signals2::detail::store_n_objects<10u>,boost::signals2::detail::default_grow_policy,std::allocator<boost::shared_ptr<void>>>::move_to_new_buffer((uint64_t)a1, a2);
  boost::signals2::detail::auto_buffer<boost::shared_ptr<void>,boost::signals2::detail::store_n_objects<10u>,boost::signals2::detail::default_grow_policy,std::allocator<boost::shared_ptr<void>>>::auto_buffer_destroy(a1);
  a1[20] = a2;
  a1[21] = v4;
  if (a1[22] > a2)
    __assert_rtn("reserve_impl", "auto_buffer.hpp", 316, "size_ <= members_.capacity_");
}

_QWORD *boost::signals2::detail::auto_buffer<boost::shared_ptr<void>,boost::signals2::detail::store_n_objects<10u>,boost::signals2::detail::default_grow_policy,std::allocator<boost::shared_ptr<void>>>::move_to_new_buffer(uint64_t a1, unint64_t a2)
{
  _QWORD *result;
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  unsigned int *v9;
  unsigned int v10;

  result = boost::signals2::detail::auto_buffer<boost::shared_ptr<void>,boost::signals2::detail::store_n_objects<10u>,boost::signals2::detail::default_grow_policy,std::allocator<boost::shared_ptr<void>>>::allocate(a1, a2);
  v4 = *(_QWORD *)(a1 + 176);
  if (v4)
  {
    v5 = *(_QWORD **)(a1 + 168);
    v6 = &v5[2 * v4];
    v7 = result;
    do
    {
      v8 = v5[1];
      *v7 = *v5;
      v7[1] = v8;
      if (v8)
      {
        v9 = (unsigned int *)(v8 + 8);
        do
          v10 = __ldxr(v9);
        while (__stxr(v10 + 1, v9));
      }
      v5 += 2;
      v7 += 2;
    }
    while (v5 != v6);
  }
  return result;
}

void *boost::signals2::detail::auto_buffer<boost::shared_ptr<void>,boost::signals2::detail::store_n_objects<10u>,boost::signals2::detail::default_grow_policy,std::allocator<boost::shared_ptr<void>>>::allocate(uint64_t a1, unint64_t a2)
{
  void *result;

  if (a2 >= 0xB)
  {
    if (a2 >> 60)
      std::__throw_bad_array_new_length[abi:ne180100]();
    return operator new(16 * a2);
  }
  return result;
}

BOOL boost::signals2::detail::group_key_less<int,std::less<int>>::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BOOL v3;

  v3 = *(_DWORD *)a2 < *(_DWORD *)a3;
  if (*(_DWORD *)a2 == *(_DWORD *)a3)
  {
    if (*(_DWORD *)a2 != 1)
      return 0;
    if (!*(_BYTE *)(a2 + 4) || !*(_BYTE *)(a3 + 4))
      __assert_rtn("get", "optional.hpp", 1211, "this->is_initialized()");
    return *(_DWORD *)(a2 + 8) < *(_DWORD *)(a3 + 8);
  }
  return v3;
}

_QWORD *std::__tree<std::__value_type<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,std::__list_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>,void *>>,std::__map_value_compare<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,std::__value_type<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,std::__list_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>,void *>>,boost::signals2::detail::group_key_less<int,std::less<int>>,false>,std::allocator<std::__value_type<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,std::__list_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>,void *>>>>::__find_equal<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>>(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;

  v5 = (_QWORD *)(a1 + 8);
  v4 = *(_QWORD **)(a1 + 8);
  if (v4)
  {
    v7 = a1 + 24;
    do
    {
      while (1)
      {
        v8 = v4;
        v9 = (uint64_t)(v4 + 4);
        if (!boost::signals2::detail::group_key_less<int,std::less<int>>::operator()(v7, a3, (uint64_t)(v4 + 4)))
          break;
        v4 = (_QWORD *)*v8;
        v5 = v8;
        if (!*v8)
          goto LABEL_10;
      }
      if (!boost::signals2::detail::group_key_less<int,std::less<int>>::operator()(v7, v9, a3))
        break;
      v5 = v8 + 1;
      v4 = (_QWORD *)v8[1];
    }
    while (v4);
  }
  else
  {
    v8 = (_QWORD *)(a1 + 8);
  }
LABEL_10:
  *a2 = v8;
  return v5;
}

uint64_t boost::signals2::mutex::unlock(pthread_mutex_t *this)
{
  uint64_t result;

  result = pthread_mutex_unlock(this);
  if ((_DWORD)result)
    __assert_rtn("unlock", "lwm_pthreads.hpp", 70, "pthread_mutex_unlock(&m_) == 0");
  return result;
}

uint64_t boost::shared_ptr<boost::signals2::detail::grouped_list<int,std::less<int>,boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>>>::operator*(uint64_t result)
{
  if (!result)
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  return result;
}

void boost::signals2::detail::connection_body_base::disconnect(boost::signals2::detail::connection_body_base *this)
{
  _OWORD v2[11];
  __int128 v3;
  uint64_t v4;

  v4 = *MEMORY[0x24BDAC8D0];
  v3 = 0u;
  memset(v2, 0, sizeof(v2));
  boost::signals2::detail::garbage_collecting_lock<boost::signals2::detail::connection_body_base>::garbage_collecting_lock(v2, (uint64_t)this);
  if (*((_BYTE *)this + 24))
  {
    *((_BYTE *)this + 24) = 0;
    boost::signals2::detail::connection_body_base::dec_slot_refcount<boost::signals2::detail::connection_body_base>(this, v2);
  }
  (*(void (**)(_QWORD))(**((_QWORD **)&v3 + 1) + 32))(*((_QWORD *)&v3 + 1));
  boost::signals2::detail::auto_buffer<boost::shared_ptr<void>,boost::signals2::detail::store_n_objects<10u>,boost::signals2::detail::default_grow_policy,std::allocator<boost::shared_ptr<void>>>::auto_buffer_destroy(v2);
}

void sub_2169E46AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  boost::signals2::detail::garbage_collecting_lock<boost::signals2::detail::connection_body_base>::~garbage_collecting_lock((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void boost::throw_exception<boost::bad_function_call>(const std::runtime_error *a1)
{
  void *exception;

  exception = __cxa_allocate_exception(0x40uLL);
  boost::wrapexcept<boost::bad_function_call>::wrapexcept((uint64_t)exception, a1);
}

void sub_2169E4718(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t boost::wrapexcept<boost::bad_function_call>::wrapexcept(uint64_t a1, const std::runtime_error *a2)
{
  *(_QWORD *)a1 = &unk_24D5DBBF0;
  std::runtime_error::runtime_error((std::runtime_error *)(a1 + 8), a2);
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 56) = -1;
  *(_QWORD *)a1 = &unk_24D5DBB78;
  *(_QWORD *)(a1 + 8) = &unk_24D5DBBA8;
  *(_QWORD *)(a1 + 24) = &unk_24D5DBBD0;
  *(_QWORD *)(a1 + 32) = 0;
  return a1;
}

uint64_t boost::wrapexcept<boost::bad_function_call>::~wrapexcept(uint64_t a1)
{
  *(_QWORD *)(a1 + 24) = &unk_24D5DBC48;
  boost::exception_detail::refcount_ptr<boost::exception_detail::error_info_container>::~refcount_ptr((uint64_t *)(a1 + 32));
  std::runtime_error::~runtime_error((std::runtime_error *)(a1 + 8));
  return a1;
}

uint64_t boost::wrapexcept<boost::bad_function_call>::clone(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = operator new();
  *(_QWORD *)v2 = &unk_24D5DBBF0;
  std::runtime_error::runtime_error((std::runtime_error *)(v2 + 8), (const std::runtime_error *)(a1 + 8));
  *(_QWORD *)(v2 + 8) = &unk_24D5DBC20;
  *(_QWORD *)(v2 + 24) = &unk_24D5DBC48;
  v3 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(v2 + 32) = v3;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  *(_OWORD *)(v2 + 40) = *(_OWORD *)(a1 + 40);
  *(_DWORD *)(v2 + 56) = *(_DWORD *)(a1 + 56);
  *(_QWORD *)v2 = &unk_24D5DBB78;
  *(_QWORD *)(v2 + 8) = &unk_24D5DBBA8;
  *(_QWORD *)(v2 + 24) = &unk_24D5DBBD0;
  boost::exception_detail::copy_boost_exception(v2 + 24, a1 + 24);
  return v2;
}

void sub_2169E48A4(_Unwind_Exception *a1)
{
  uint64_t v1;
  std::runtime_error *v2;

  std::runtime_error::~runtime_error(v2);
  MEMORY[0x2199FEAC4](v1, 0x10F1C40250A9ABCLL);
  _Unwind_Resume(a1);
}

void boost::wrapexcept<boost::bad_function_call>::rethrow(uint64_t a1)
{
  void *exception;

  exception = __cxa_allocate_exception(0x40uLL);
  boost::wrapexcept<boost::bad_function_call>::wrapexcept((uint64_t)exception, a1);
}

void sub_2169E4924(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void boost::wrapexcept<boost::bad_function_call>::~wrapexcept(uint64_t a1)
{
  *(_QWORD *)(a1 + 24) = &unk_24D5DBC48;
  boost::exception_detail::refcount_ptr<boost::exception_detail::error_info_container>::~refcount_ptr((uint64_t *)(a1 + 32));
  std::runtime_error::~runtime_error((std::runtime_error *)(a1 + 8));
  JUMPOUT(0x2199FEAC4);
}

void `non-virtual thunk to'boost::wrapexcept<boost::bad_function_call>::~wrapexcept(uint64_t a1)
{
  *(_QWORD *)(a1 + 16) = &unk_24D5DBC48;
  boost::exception_detail::refcount_ptr<boost::exception_detail::error_info_container>::~refcount_ptr((uint64_t *)(a1 + 24));
  std::runtime_error::~runtime_error((std::runtime_error *)a1);
}

{
  *(_QWORD *)(a1 + 16) = &unk_24D5DBC48;
  boost::exception_detail::refcount_ptr<boost::exception_detail::error_info_container>::~refcount_ptr((uint64_t *)(a1 + 24));
  std::runtime_error::~runtime_error((std::runtime_error *)a1);
  JUMPOUT(0x2199FEAC4);
}

void `non-virtual thunk to'boost::wrapexcept<boost::bad_function_call>::~wrapexcept(_QWORD *a1)
{
  *a1 = &unk_24D5DBC48;
  boost::exception_detail::refcount_ptr<boost::exception_detail::error_info_container>::~refcount_ptr(a1 + 1);
  std::runtime_error::~runtime_error((std::runtime_error *)a1 - 1);
}

{
  *a1 = &unk_24D5DBC48;
  boost::exception_detail::refcount_ptr<boost::exception_detail::error_info_container>::~refcount_ptr(a1 + 1);
  std::runtime_error::~runtime_error((std::runtime_error *)a1 - 1);
  JUMPOUT(0x2199FEAC4);
}

void boost::bad_function_call::~bad_function_call(std::runtime_error *this)
{
  std::runtime_error::~runtime_error(this);
  JUMPOUT(0x2199FEAC4);
}

uint64_t *boost::exception_detail::refcount_ptr<boost::exception_detail::error_info_container>::~refcount_ptr(uint64_t *a1)
{
  uint64_t v2;

  v2 = *a1;
  if (v2 && (*(unsigned int (**)(uint64_t))(*(_QWORD *)v2 + 32))(v2))
    *a1 = 0;
  return a1;
}

uint64_t boost::wrapexcept<boost::bad_function_call>::wrapexcept(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  __int128 v5;

  *(_QWORD *)a1 = &unk_24D5DBBF0;
  std::runtime_error::runtime_error((std::runtime_error *)(a1 + 8), (const std::runtime_error *)(a2 + 8));
  *(_QWORD *)(a1 + 8) = &unk_24D5DBC20;
  v4 = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 24) = &unk_24D5DBC48;
  *(_QWORD *)(a1 + 32) = v4;
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
  v5 = *(_OWORD *)(a2 + 40);
  *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 56);
  *(_OWORD *)(a1 + 40) = v5;
  *(_QWORD *)a1 = &unk_24D5DBB78;
  *(_QWORD *)(a1 + 8) = &unk_24D5DBBA8;
  *(_QWORD *)(a1 + 24) = &unk_24D5DBBD0;
  return a1;
}

void sub_2169E4BB8(_Unwind_Exception *a1)
{
  std::runtime_error *v1;

  std::runtime_error::~runtime_error(v1);
  _Unwind_Resume(a1);
}

uint64_t boost::exception_detail::copy_boost_exception(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  uint64_t v7;

  v4 = *(_QWORD *)(a2 + 8);
  if (v4)
  {
    (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v4 + 40))(&v7);
    v5 = v7;
    if (v7)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v7 + 24))(v7);
      if (v7)
        (*(void (**)(uint64_t))(*(_QWORD *)v7 + 32))(v7);
    }
  }
  else
  {
    v5 = 0;
  }
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  result = *(_QWORD *)(a1 + 8);
  if (result)
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 32))(result);
  *(_QWORD *)(a1 + 8) = v5;
  if (v5)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 24))(v5);
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 32))(v5);
  }
  return result;
}

void sub_2169E4C98(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  uint64_t v10;

  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 32))(a10);
  if (v10)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 32))(v10);
  _Unwind_Resume(exception_object);
}

uint64_t boost::signals2::detail::garbage_collecting_lock<boost::signals2::detail::connection_body_base>::~garbage_collecting_lock(uint64_t a1)
{
  (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 184) + 32))(*(_QWORD *)(a1 + 184));
  boost::signals2::detail::auto_buffer<boost::shared_ptr<void>,boost::signals2::detail::store_n_objects<10u>,boost::signals2::detail::default_grow_policy,std::allocator<boost::shared_ptr<void>>>::auto_buffer_destroy((_QWORD *)a1);
  return a1;
}

_QWORD *boost::signals2::detail::garbage_collecting_lock<boost::signals2::detail::connection_body_base>::garbage_collecting_lock(_QWORD *a1, uint64_t a2)
{
  a1[20] = 10;
  a1[21] = a1;
  a1[22] = 0;
  a1[23] = a2;
  (*(void (**)(uint64_t))(*(_QWORD *)a2 + 24))(a2);
  return a1;
}

void sub_2169E4D68(_Unwind_Exception *a1)
{
  _QWORD *v1;

  boost::signals2::detail::auto_buffer<boost::shared_ptr<void>,boost::signals2::detail::store_n_objects<10u>,boost::signals2::detail::default_grow_policy,std::allocator<boost::shared_ptr<void>>>::auto_buffer_destroy(v1);
  _Unwind_Resume(a1);
}

void boost::signals2::detail::connection_body_base::dec_slot_refcount<boost::signals2::detail::connection_body_base>(_DWORD *a1, _QWORD *a2)
{
  int v2;
  int v3;
  __int128 v5;

  v2 = a1[7];
  if (!v2)
    __assert_rtn("dec_slot_refcount", "connection.hpp", 124, "m_slot_refcount != 0");
  v3 = v2 - 1;
  a1[7] = v3;
  if (!v3)
  {
    (*(void (**)(__int128 *__return_ptr))(*(_QWORD *)a1 + 40))(&v5);
    boost::signals2::detail::auto_buffer<boost::shared_ptr<void>,boost::signals2::detail::store_n_objects<10u>,boost::signals2::detail::default_grow_policy,std::allocator<boost::shared_ptr<void>>>::push_back(a2, &v5);
    boost::detail::shared_count::~shared_count((unsigned int **)&v5 + 1);
  }
}

void sub_2169E4E00(_Unwind_Exception *a1)
{
  uint64_t v1;

  boost::detail::shared_count::~shared_count((unsigned int **)(v1 + 8));
  _Unwind_Resume(a1);
}

void boost::signals2::detail::slot_call_iterator_t<boost::signals2::detail::variadic_slot_invoker<boost::signals2::detail::void_type,subscriber::SimSlot,subscriber::SimCard>,std::__list_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>,void *>,boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>::lock_next_callable(uint64_t *a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _DWORD **v10;
  unint64_t *v11;
  _DWORD *v12;
  unint64_t v13;
  unint64_t v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  const char *v29;
  const char *v30;
  char v31[8];
  unint64_t *v32;
  void (*v33)(int, void *, unint64_t);
  uint64_t v34;
  void *v35;
  unint64_t v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  _QWORD v49[5];

  v49[3] = *MEMORY[0x24BDAC8D0];
  v1 = *a1;
  if (*a1 != a1[3])
  {
    if (v1 == a1[1])
      goto LABEL_41;
    while (1)
    {
      v3 = a1[2];
      v4 = *(_QWORD *)(v3 + 264);
      if (v4)
      {
        if (v4 - 1 < 0)
        {
          v7 = *(_QWORD *)(v3 + 264);
        }
        else
        {
          v5 = *(_QWORD *)(v3 + 256);
          v6 = v5 + 24 * v4;
          do
          {
            v6 -= 24;
            boost::variant<boost::shared_ptr<void>,boost::signals2::detail::foreign_void_shared_ptr>::destroy_content(v6);
          }
          while (v6 > v5);
          v7 = *(_QWORD *)(v3 + 264);
          v1 = *a1;
        }
        *(_QWORD *)(v3 + 264) = v7 - v4;
      }
      v47 = 0u;
      v48 = 0u;
      v45 = 0u;
      v46 = 0u;
      v43 = 0u;
      v44 = 0u;
      v41 = 0u;
      v42 = 0u;
      v39 = 0u;
      v40 = 0u;
      v37 = 0u;
      v38 = 0u;
      v8 = *(_QWORD *)(v1 + 16);
      boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>::operator*(v8);
      boost::signals2::detail::garbage_collecting_lock<boost::signals2::detail::connection_body_base>::garbage_collecting_lock(&v37, v8);
      v9 = *(_QWORD *)(*a1 + 16);
      boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>::operator->(v9);
      v10 = *(_DWORD ***)(v9 + 32);
      if (v10)
      {
        v11 = (unint64_t *)a1[2];
        v12 = *v10;
        if (v12 != *(_DWORD **)(boost::shared_ptr<boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>>::operator*((uint64_t)v10)
                               + 8))
        {
          while (1)
          {
            memset(v49, 0, 24);
            boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>::apply_visitor<boost::signals2::detail::lock_weak_ptr_visitor const>(v12, (uint64_t)v49);
            if (boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>::apply_visitor<boost::signals2::detail::expired_weak_ptr_visitor const>((uint64_t)v12))
              break;
            v13 = v11[33];
            v14 = v11[31];
            if (v13 == v14)
            {
              if (v13 <= 9)
              {
                v28 = 793;
                v29 = "reserve";
                v30 = "members_.capacity_ >= N";
                goto LABEL_46;
              }
              if (v13 == -1)
                goto LABEL_47;
              if (4 * v13 <= v13 + 1)
                v14 = v13 + 1;
              else
                v14 = 4 * v13;
              if (v14 >= 0xAAAAAAAAAAAAAABLL)
                std::__throw_bad_array_new_length[abi:ne180100]();
              v15 = operator new(24 * v14);
              v16 = 0;
              v31[0] = 0;
              v32 = v11 + 1;
              v33 = boost::signals2::detail::auto_buffer<boost::variant<boost::shared_ptr<void>,boost::signals2::detail::foreign_void_shared_ptr>,boost::signals2::detail::store_n_objects<10u>,boost::signals2::detail::default_grow_policy,std::allocator<boost::variant<boost::shared_ptr<void>,boost::signals2::detail::foreign_void_shared_ptr>>>::deallocate;
              v34 = 0;
              v35 = v15;
              v36 = v14;
              v17 = 24 * v13;
              v18 = v11[32];
              do
              {
                boost::variant<boost::shared_ptr<void>,boost::signals2::detail::foreign_void_shared_ptr>::variant((uint64_t)v15 + v16, v18 + v16);
                v16 += 24;
              }
              while (v17 != v16);
              v31[0] = 1;
              boost::signals2::detail::scope_guard_impl_base::safe_execute<boost::signals2::detail::obj_scope_guard_impl2<boost::signals2::detail::auto_buffer<boost::variant<boost::shared_ptr<void>,boost::signals2::detail::foreign_void_shared_ptr>,boost::signals2::detail::store_n_objects<10u>,boost::signals2::detail::default_grow_policy,std::allocator<boost::variant<boost::shared_ptr<void>,boost::signals2::detail::foreign_void_shared_ptr>>>,void (boost::signals2::detail::auto_buffer<boost::variant<boost::shared_ptr<void>,boost::signals2::detail::foreign_void_shared_ptr>,boost::signals2::detail::store_n_objects<10u>,boost::signals2::detail::default_grow_policy,std::allocator<boost::variant<boost::shared_ptr<void>,boost::signals2::detail::foreign_void_shared_ptr>>>::*)(boost::variant<boost::shared_ptr<void>,boost::signals2::detail::foreign_void_shared_ptr>*,unsigned long),boost::variant<boost::shared_ptr<void>,boost::signals2::detail::foreign_void_shared_ptr>*,unsigned long>>((uint64_t)v31);
              boost::signals2::detail::auto_buffer<boost::variant<boost::shared_ptr<void>,boost::signals2::detail::foreign_void_shared_ptr>,boost::signals2::detail::store_n_objects<10u>,boost::signals2::detail::default_grow_policy,std::allocator<boost::variant<boost::shared_ptr<void>,boost::signals2::detail::foreign_void_shared_ptr>>>::auto_buffer_destroy(v11 + 1);
              v11[31] = v14;
              v11[32] = (unint64_t)v15;
              v13 = v11[33];
              if (v13 > v14)
              {
                v28 = 316;
                v29 = "reserve_impl";
                v30 = "size_ <= members_.capacity_";
                goto LABEL_46;
              }
            }
            if (v13 == v14)
            {
LABEL_47:
              v28 = 767;
              v29 = "unchecked_push_back";
              v30 = "!full()";
LABEL_46:
              __assert_rtn(v29, "auto_buffer.hpp", v28, v30);
            }
            boost::variant<boost::shared_ptr<void>,boost::signals2::detail::foreign_void_shared_ptr>::variant(v11[32] + 24 * v13, (uint64_t)v49);
            ++v11[33];
            boost::variant<boost::shared_ptr<void>,boost::signals2::detail::foreign_void_shared_ptr>::destroy_content((uint64_t)v49);
            v12 += 6;
            if (v12 == *(_DWORD **)(boost::shared_ptr<boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>>::operator*(*(_QWORD *)(v9 + 32))
                                   + 8))
              goto LABEL_29;
          }
          if (*(_BYTE *)(v9 + 24))
          {
            *(_BYTE *)(v9 + 24) = 0;
            boost::signals2::detail::connection_body_base::dec_slot_refcount<boost::signals2::detail::connection_body_base>((_DWORD *)v9, &v37);
          }
          boost::variant<boost::shared_ptr<void>,boost::signals2::detail::foreign_void_shared_ptr>::destroy_content((uint64_t)v49);
        }
      }
LABEL_29:
      v19 = boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>::operator->(*(_QWORD *)(*a1 + 16));
      v20 = a1[2];
      if (*(_BYTE *)(v19 + 24))
        ++*(_DWORD *)(v20 + 288);
      else
        ++*(_DWORD *)(v20 + 292);
      v21 = boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>::operator->(*(_QWORD *)(*a1 + 16));
      if (!*(_BYTE *)(v21 + 24)
        || (v22 = *(_QWORD *)(v21 + 16)) != 0 && (v23 = atomic_load((unsigned int *)(v22 + 8))) != 0)
      {
        v24 = 1;
      }
      else
      {
        boost::signals2::detail::slot_call_iterator_t<boost::signals2::detail::variadic_slot_invoker<boost::signals2::detail::void_type,subscriber::SimSlot,subscriber::SimCard>,std::__list_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>,void *>,boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>::set_callable_iter(a1, &v37, *a1);
        v24 = 0;
      }
      (*(void (**)(_QWORD))(**((_QWORD **)&v48 + 1) + 32))(*((_QWORD *)&v48 + 1));
      boost::signals2::detail::auto_buffer<boost::shared_ptr<void>,boost::signals2::detail::store_n_objects<10u>,boost::signals2::detail::default_grow_policy,std::allocator<boost::shared_ptr<void>>>::auto_buffer_destroy(&v37);
      v1 = *a1;
      v25 = a1[1];
      if (!v24)
        break;
      v1 = *(_QWORD *)(v1 + 8);
      *a1 = v1;
      if (v1 == v25)
      {
        v1 = v25;
        goto LABEL_41;
      }
    }
    if (v1 == v25)
    {
LABEL_41:
      v26 = a1[3];
      if (v26 != v1)
      {
        v47 = 0u;
        v48 = 0u;
        v45 = 0u;
        v46 = 0u;
        v43 = 0u;
        v44 = 0u;
        v41 = 0u;
        v42 = 0u;
        v39 = 0u;
        v40 = 0u;
        v37 = 0u;
        v38 = 0u;
        v27 = *(_QWORD *)(v26 + 16);
        boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>::operator*(v27);
        boost::signals2::detail::garbage_collecting_lock<boost::signals2::detail::connection_body_base>::garbage_collecting_lock(&v37, v27);
        boost::signals2::detail::slot_call_iterator_t<boost::signals2::detail::variadic_slot_invoker<boost::signals2::detail::void_type,subscriber::SimSlot,subscriber::SimCard>,std::__list_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>,void *>,boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>::set_callable_iter(a1, &v37, a1[1]);
        (*(void (**)(_QWORD))(**((_QWORD **)&v48 + 1) + 32))(*((_QWORD *)&v48 + 1));
        boost::signals2::detail::auto_buffer<boost::shared_ptr<void>,boost::signals2::detail::store_n_objects<10u>,boost::signals2::detail::default_grow_policy,std::allocator<boost::shared_ptr<void>>>::auto_buffer_destroy(&v37);
      }
    }
  }
}

void sub_2169E5228()
{
  JUMPOUT(0x2169E52BCLL);
}

void sub_2169E5258(void *a1, int a2)
{
  uint64_t v2;
  uint64_t v3;

  if (a2)
  {
    __cxa_begin_catch(a1);
    for (; v3; v3 -= 24)
    {
      boost::variant<boost::shared_ptr<void>,boost::signals2::detail::foreign_void_shared_ptr>::destroy_content(v2);
      v2 += 24;
    }
    __cxa_rethrow();
  }
  JUMPOUT(0x2169E52C4);
}

void sub_2169E5288(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  __cxa_end_catch();
  boost::signals2::detail::scope_guard_impl_base::safe_execute<boost::signals2::detail::obj_scope_guard_impl2<boost::signals2::detail::auto_buffer<boost::variant<boost::shared_ptr<void>,boost::signals2::detail::foreign_void_shared_ptr>,boost::signals2::detail::store_n_objects<10u>,boost::signals2::detail::default_grow_policy,std::allocator<boost::variant<boost::shared_ptr<void>,boost::signals2::detail::foreign_void_shared_ptr>>>,void (boost::signals2::detail::auto_buffer<boost::variant<boost::shared_ptr<void>,boost::signals2::detail::foreign_void_shared_ptr>,boost::signals2::detail::store_n_objects<10u>,boost::signals2::detail::default_grow_policy,std::allocator<boost::variant<boost::shared_ptr<void>,boost::signals2::detail::foreign_void_shared_ptr>>>::*)(boost::variant<boost::shared_ptr<void>,boost::signals2::detail::foreign_void_shared_ptr>*,unsigned long),boost::variant<boost::shared_ptr<void>,boost::signals2::detail::foreign_void_shared_ptr>*,unsigned long>>((uint64_t)&a9);
  JUMPOUT(0x2169E52B4);
}

void sub_2169E52A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

uint64_t boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>::operator*(uint64_t result)
{
  if (!result)
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  return result;
}

void boost::signals2::detail::slot_call_iterator_t<boost::signals2::detail::variadic_slot_invoker<boost::signals2::detail::void_type,subscriber::SimSlot,subscriber::SimCard>,std::__list_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>,void *>,boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>::set_callable_iter(_QWORD *a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  _DWORD *v5;
  int v6;
  _DWORD *v7;

  a1[3] = a3;
  v3 = a1[2];
  if (a1[1] == a3)
  {
    v7 = *(_DWORD **)(v3 + 296);
    if (v7)
      boost::signals2::detail::connection_body_base::dec_slot_refcount<boost::signals2::detail::connection_body_base>(v7, a2);
    *(_QWORD *)(v3 + 296) = 0;
  }
  else
  {
    v4 = *(_QWORD *)(a3 + 16);
    v5 = *(_DWORD **)(v3 + 296);
    if (v5)
      boost::signals2::detail::connection_body_base::dec_slot_refcount<boost::signals2::detail::connection_body_base>(v5, a2);
    *(_QWORD *)(v3 + 296) = v4;
    if (v4)
    {
      v6 = *(_DWORD *)(v4 + 28);
      if (!v6)
        __assert_rtn("inc_slot_refcount", "connection.hpp", 114, "m_slot_refcount != 0");
      *(_DWORD *)(v4 + 28) = v6 + 1;
    }
  }
}

void boost::variant<boost::shared_ptr<void>,boost::signals2::detail::foreign_void_shared_ptr>::destroy_content(uint64_t a1)
{
  int v1;
  uint64_t v2;

  v1 = *(_DWORD *)a1 ^ (*(int *)a1 >> 31);
  if (v1 == 1)
  {
    v2 = *(_QWORD *)(a1 + 8);
    if (v2)
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  }
  else
  {
    if (v1)
      boost::detail::variant::forced_return<void>();
    boost::detail::shared_count::~shared_count((unsigned int **)(a1 + 16));
  }
}

void boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>::apply_visitor<boost::signals2::detail::lock_weak_ptr_visitor const>(_DWORD *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t *v2;
  unsigned int *v3;

  v2 = (uint64_t *)(a1 + 2);
  switch(*a1 ^ ((int)*a1 >> 31))
  {
    case 0:
      *(_QWORD *)(a2 + 8) = 0;
      *(_QWORD *)(a2 + 16) = 0;
      v3 = 0;
      *(_DWORD *)a2 = 0;
      boost::detail::shared_count::~shared_count(&v3);
      break;
    case 1:
      boost::signals2::detail::lock_weak_ptr_visitor::operator()<boost::weak_ptr<void>>(v2, a2);
      break;
    case 2:
      boost::signals2::detail::lock_weak_ptr_visitor::operator()<boost::signals2::detail::foreign_void_weak_ptr>(v2, a2);
      break;
    default:
      boost::detail::variant::forced_return<void>();
  }
}

void boost::signals2::detail::lock_weak_ptr_visitor::operator()<boost::weak_ptr<void>>(uint64_t *a1@<X1>, uint64_t a2@<X8>)
{
  unsigned int *v2;
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;
  int v6;
  uint64_t v7;
  unsigned int *v8;

  v2 = (unsigned int *)a1[1];
  v8 = v2;
  if (!v2)
    goto LABEL_12;
  v3 = v2 + 2;
  v4 = v2[2];
  while (v4)
  {
    v5 = __ldxr(v3);
    if (v5 != v4)
    {
      __clrex();
LABEL_8:
      v6 = 0;
      goto LABEL_9;
    }
    if (__stxr(v4 + 1, v3))
      goto LABEL_8;
    v6 = 1;
LABEL_9:
    v4 = v5;
    if (v6)
    {
      v7 = *a1;
      goto LABEL_13;
    }
  }
  v2 = 0;
LABEL_12:
  v7 = 0;
LABEL_13:
  *(_QWORD *)(a2 + 8) = v7;
  *(_QWORD *)(a2 + 16) = v2;
  v8 = 0;
  *(_DWORD *)a2 = 0;
  boost::detail::shared_count::~shared_count(&v8);
}

uint64_t boost::signals2::detail::lock_weak_ptr_visitor::operator()<boost::signals2::detail::foreign_void_weak_ptr>@<X0>(uint64_t *a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v3;
  uint64_t result;
  uint64_t v5;

  v3 = boost::scoped_ptr<boost::signals2::detail::foreign_weak_ptr_impl_base>::operator->(a1);
  (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v3 + 16))(&v5);
  *(_QWORD *)(a2 + 8) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 16))(v5);
  *(_DWORD *)a2 = 1;
  result = v5;
  if (v5)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
  return result;
}

void sub_2169E555C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

uint64_t boost::variant<boost::shared_ptr<void>,boost::signals2::detail::foreign_void_shared_ptr>::variant(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  unsigned int *v5;
  unsigned int v6;

  switch(*(_DWORD *)a2 ^ (*(int *)a2 >> 31))
  {
    case 0:
      v4 = *(_QWORD *)(a2 + 16);
      *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
      *(_QWORD *)(a1 + 16) = v4;
      if (v4)
      {
        v5 = (unsigned int *)(v4 + 8);
        do
          v6 = __ldxr(v5);
        while (__stxr(v6 + 1, v5));
      }
      break;
    case 1:
      *(_QWORD *)(a1 + 8) = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a2 + 8) + 16))(*(_QWORD *)(a2 + 8));
      break;
    default:
      boost::detail::variant::forced_return<void>();
  }
  *(_DWORD *)a1 = *(_DWORD *)a2 ^ (*(int *)a2 >> 31);
  return a1;
}

void boost::signals2::detail::auto_buffer<boost::variant<boost::shared_ptr<void>,boost::signals2::detail::foreign_void_shared_ptr>,boost::signals2::detail::store_n_objects<10u>,boost::signals2::detail::default_grow_policy,std::allocator<boost::variant<boost::shared_ptr<void>,boost::signals2::detail::foreign_void_shared_ptr>>>::auto_buffer_destroy(unint64_t *a1)
{
  unint64_t v1;
  unint64_t v3;
  BOOL v4;
  unint64_t v5;
  unint64_t v6;

  v1 = a1[31];
  if (v1)
  {
    v3 = a1[30];
    if (v3 < 0xA || ((unint64_t *)v1 == a1 ? (v4 = v3 == 10) : (v4 = 1), !v4 || (v5 = a1[32], v5 > v3)))
      __assert_rtn("auto_buffer_destroy", "auto_buffer.hpp", 255, "is_valid()");
    if ((uint64_t)(v5 - 1) >= 0)
    {
      v6 = v1 + 24 * v5;
      do
      {
        v6 -= 24;
        boost::variant<boost::shared_ptr<void>,boost::signals2::detail::foreign_void_shared_ptr>::destroy_content(v6);
      }
      while (v6 > v1);
      v3 = a1[30];
    }
    if (v3 >= 0xB)
      operator delete((void *)a1[31]);
  }
}

void boost::signals2::detail::auto_buffer<boost::variant<boost::shared_ptr<void>,boost::signals2::detail::foreign_void_shared_ptr>,boost::signals2::detail::store_n_objects<10u>,boost::signals2::detail::default_grow_policy,std::allocator<boost::variant<boost::shared_ptr<void>,boost::signals2::detail::foreign_void_shared_ptr>>>::deallocate(int a1, void *__p, unint64_t a3)
{
  if (a3 >= 0xB)
    operator delete(__p);
}

uint64_t boost::signals2::detail::scope_guard_impl_base::safe_execute<boost::signals2::detail::obj_scope_guard_impl2<boost::signals2::detail::auto_buffer<boost::variant<boost::shared_ptr<void>,boost::signals2::detail::foreign_void_shared_ptr>,boost::signals2::detail::store_n_objects<10u>,boost::signals2::detail::default_grow_policy,std::allocator<boost::variant<boost::shared_ptr<void>,boost::signals2::detail::foreign_void_shared_ptr>>>,void (boost::signals2::detail::auto_buffer<boost::variant<boost::shared_ptr<void>,boost::signals2::detail::foreign_void_shared_ptr>,boost::signals2::detail::store_n_objects<10u>,boost::signals2::detail::default_grow_policy,std::allocator<boost::variant<boost::shared_ptr<void>,boost::signals2::detail::foreign_void_shared_ptr>>>::*)(boost::variant<boost::shared_ptr<void>,boost::signals2::detail::foreign_void_shared_ptr>*,unsigned long),boost::variant<boost::shared_ptr<void>,boost::signals2::detail::foreign_void_shared_ptr>*,unsigned long>>(uint64_t result)
{
  uint64_t (*v1)(_QWORD *, _QWORD, _QWORD);
  uint64_t v2;
  _QWORD *v3;

  if (!*(_BYTE *)result)
  {
    v1 = *(uint64_t (**)(_QWORD *, _QWORD, _QWORD))(result + 16);
    v2 = *(_QWORD *)(result + 24);
    v3 = (_QWORD *)(*(_QWORD *)(result + 8) + (v2 >> 1));
    if ((v2 & 1) != 0)
      v1 = *(uint64_t (**)(_QWORD *, _QWORD, _QWORD))(*v3 + v1);
    return v1(v3, *(_QWORD *)(result + 32), *(_QWORD *)(result + 40));
  }
  return result;
}

void sub_2169E5714(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
}

_QWORD *boost::signals2::detail::signal_impl<void ()(subscriber::SimSlot,subscriber::SimCard),boost::signals2::optional_last_value<void>,int,std::less<int>,boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>,boost::function<void ()(boost::signals2::connection const&,subscriber::SimSlot,subscriber::SimCard)>,boost::signals2::mutex>::invocation_janitor::~invocation_janitor(_QWORD *a1)
{
  uint64_t v2;
  uint64_t *v3;
  pthread_mutex_t *v4;
  uint64_t *v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  unsigned int *v19;
  unsigned int v20;
  uint64_t **v21;
  char v22;
  _QWORD *v23;
  _QWORD *v24;
  uint64_t *v25;
  uint64_t *v26;
  uint64_t *v27;
  BOOL v28;
  uint64_t *v29;
  uint64_t **v30;
  _QWORD *v31;
  __int128 v32;
  _QWORD *v33;
  _QWORD *v34;
  uint64_t **v35;
  uint64_t *v36;
  uint64_t v37;
  _QWORD *v38;
  _QWORD *v39;
  _QWORD *v40;
  _QWORD *v41;
  uint64_t v42;
  _QWORD *v43;
  uint64_t *v44;
  uint64_t **v45;
  _QWORD *v46;
  uint64_t *v47;
  uint64_t v48;
  unsigned int *v49;
  unsigned int v50;
  uint64_t v51;
  unsigned int *v52;
  uint64_t *v53;
  unsigned int *v54;
  uint64_t *v55;
  uint64_t v57;
  uint64_t *v58;
  uint64_t *v59;
  uint64_t *v60;
  unsigned int *v61;
  unsigned int *v62;
  _OWORD v63[11];
  __int128 v64;
  uint64_t v65;

  v65 = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)(*a1 + 292) > *(_DWORD *)(*a1 + 288))
  {
    v3 = (uint64_t *)a1[1];
    v2 = a1[2];
    v64 = 0u;
    memset(v63, 0, sizeof(v63));
    v4 = (pthread_mutex_t *)boost::shared_ptr<boost::signals2::mutex>::operator*(v3 + 3);
    boost::signals2::detail::garbage_collecting_lock<boost::signals2::mutex>::garbage_collecting_lock(v63, v4);
    v5 = (uint64_t *)boost::shared_ptr<boost::signals2::detail::signal_impl<void ()(subscriber::SimSlot,subscriber::SimCard),boost::signals2::optional_last_value<void>,int,std::less<int>,boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>,boost::function<void ()(boost::signals2::connection const&,subscriber::SimSlot,subscriber::SimCard)>,boost::signals2::mutex>::invocation_state>::operator->(*v3);
    if (boost::shared_ptr<boost::signals2::detail::grouped_list<int,std::less<int>,boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>>>::operator*(*v5) == v2)
    {
      v6 = v3[1];
      if (!v6 || (v7 = atomic_load((unsigned int *)(v6 + 8)), v7 != 1))
      {
        v8 = operator new();
        v9 = (uint64_t *)*v3;
        if (!*v3)
          __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
        v58 = v3;
        v59 = (uint64_t *)v8;
        v57 = *v3;
        v10 = *v9;
        boost::shared_ptr<boost::signals2::detail::grouped_list<int,std::less<int>,boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>>>::operator*(*v9);
        v11 = (_QWORD *)operator new();
        v12 = v11;
        *v11 = v11;
        v11[1] = v11;
        v11[2] = 0;
        v13 = *(_QWORD **)(v10 + 8);
        if (v13 != (_QWORD *)v10)
        {
          v14 = 0;
          v15 = v11;
          do
          {
            v17 = v13[2];
            v16 = v13[3];
            v18 = operator new(0x20uLL);
            v18[2] = v17;
            v18[3] = v16;
            if (v16)
            {
              v19 = (unsigned int *)(v16 + 8);
              do
                v20 = __ldxr(v19);
              while (__stxr(v20 + 1, v19));
              v15 = (_QWORD *)*v12;
              v14 = v12[2];
            }
            *v18 = v15;
            v18[1] = v12;
            v15[1] = v18;
            *v12 = v18;
            v12[2] = ++v14;
            v13 = (_QWORD *)v13[1];
            v15 = v18;
          }
          while (v13 != (_QWORD *)v10);
        }
        v12[5] = 0;
        v12[4] = 0;
        v21 = (uint64_t **)(v12 + 4);
        v22 = *(_BYTE *)(v10 + 48);
        v12[3] = v12 + 4;
        *((_BYTE *)v12 + 48) = v22;
        v23 = *(_QWORD **)(v10 + 24);
        v24 = (_QWORD *)(v10 + 32);
        if (v23 != (_QWORD *)(v10 + 32))
        {
          while (1)
          {
            v60 = 0;
            v25 = *v21;
            if ((uint64_t **)v12[3] == v21)
            {
              v27 = v12 + 4;
            }
            else
            {
              v26 = v12 + 4;
              if (v25)
              {
                do
                {
                  v27 = v25;
                  v25 = (uint64_t *)v25[1];
                }
                while (v25);
              }
              else
              {
                do
                {
                  v27 = (uint64_t *)v26[2];
                  v28 = *v27 == (_QWORD)v26;
                  v26 = v27;
                }
                while (v28);
              }
              if (!boost::signals2::detail::group_key_less<int,std::less<int>>::operator()((uint64_t)(v12 + 6), (uint64_t)(v27 + 4), (uint64_t)(v23 + 4)))
              {
                v30 = (uint64_t **)std::__tree<std::__value_type<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,std::__list_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>,void *>>,std::__map_value_compare<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,std::__value_type<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,std::__list_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>,void *>>,boost::signals2::detail::group_key_less<int,std::less<int>>,false>,std::allocator<std::__value_type<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,std::__list_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>,void *>>>>::__find_equal<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>>((uint64_t)(v12 + 3), &v60, (uint64_t)(v23 + 4));
                goto LABEL_25;
              }
              v25 = *v21;
            }
            v29 = v12 + 4;
            v30 = (uint64_t **)(v12 + 4);
            if (!v25)
              goto LABEL_27;
            v60 = v27;
            v30 = (uint64_t **)(v27 + 1);
LABEL_25:
            if (!*v30)
            {
              v29 = v60;
LABEL_27:
              v31 = operator new(0x38uLL);
              v32 = *((_OWORD *)v23 + 2);
              v31[6] = v23[6];
              *((_OWORD *)v31 + 2) = v32;
              std::__tree<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::less<unsigned short>,true>,std::allocator<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>>>::__insert_node_at((uint64_t **)v12 + 3, (uint64_t)v29, v30, v31);
            }
            v33 = (_QWORD *)v23[1];
            if (v33)
            {
              do
              {
                v34 = v33;
                v33 = (_QWORD *)*v33;
              }
              while (v33);
            }
            else
            {
              do
              {
                v34 = (_QWORD *)v23[2];
                v28 = *v34 == (_QWORD)v23;
                v23 = v34;
              }
              while (!v28);
            }
            v23 = v34;
            if (v34 == v24)
            {
              v23 = *(_QWORD **)(v10 + 24);
              break;
            }
          }
        }
        *((_BYTE *)v12 + 56) = *(_BYTE *)(v10 + 56);
        if (v23 != v24)
        {
          v35 = (uint64_t **)v12[3];
          v36 = (uint64_t *)v12[1];
          do
          {
            if (v35 == v21)
              __assert_rtn("grouped_list", "slot_groups.hpp", 80, "this_map_it != _group_map.end()");
            v35[6] = v36;
            v37 = v10;
            if (v23 != v24)
              v37 = v23[6];
            v38 = (_QWORD *)v23[1];
            v39 = v38;
            v40 = v23;
            if (v38)
            {
              do
              {
                v41 = v39;
                v39 = (_QWORD *)*v39;
              }
              while (v39);
            }
            else
            {
              do
              {
                v41 = (_QWORD *)v40[2];
                v28 = *v41 == (_QWORD)v40;
                v40 = v41;
              }
              while (!v28);
            }
            v42 = v10;
            if (v41 != v24)
              v42 = v41[6];
            while (v37 != v42)
            {
              v37 = *(_QWORD *)(v37 + 8);
              v36 = (uint64_t *)v36[1];
            }
            if (v38)
            {
              do
              {
                v43 = v38;
                v38 = (_QWORD *)*v38;
              }
              while (v38);
            }
            else
            {
              do
              {
                v43 = (_QWORD *)v23[2];
                v28 = *v43 == (_QWORD)v23;
                v23 = v43;
              }
              while (!v28);
            }
            v44 = v35[1];
            if (v44)
            {
              do
              {
                v45 = (uint64_t **)v44;
                v44 = (uint64_t *)*v44;
              }
              while (v44);
            }
            else
            {
              do
              {
                v45 = (uint64_t **)v35[2];
                v28 = *v45 == (uint64_t *)v35;
                v35 = v45;
              }
              while (!v28);
            }
            v23 = v43;
            v35 = v45;
          }
          while (v43 != v24);
        }
        *v59 = (uint64_t)v12;
        v59[1] = 0;
        v46 = (_QWORD *)operator new();
        v46[1] = 0x100000001;
        *v46 = &off_24D5DBCD8;
        v46[2] = v12;
        v47 = (uint64_t *)v59[1];
        v59[1] = (uint64_t)v46;
        v60 = v47;
        boost::detail::shared_count::~shared_count((unsigned int **)&v60);
        v3 = v58;
        v59[2] = *(_QWORD *)(v57 + 16);
        v48 = *(_QWORD *)(v57 + 24);
        v59[3] = v48;
        if (v48)
        {
          v49 = (unsigned int *)(v48 + 8);
          do
            v50 = __ldxr(v49);
          while (__stxr(v50 + 1, v49));
        }
        if ((uint64_t *)*v58 == v59)
          __assert_rtn("reset", "shared_ptr.hpp", 734, "p == 0 || p != px");
        v60 = v59;
        v61 = 0;
        v51 = operator new();
        *(_QWORD *)(v51 + 8) = 0x100000001;
        *(_QWORD *)v51 = &off_24D5DBC68;
        *(_QWORD *)(v51 + 16) = v59;
        v52 = v61;
        v61 = (unsigned int *)v51;
        v62 = v52;
        boost::detail::shared_count::~shared_count(&v62);
        v53 = v60;
        v54 = (unsigned int *)v58[1];
        v60 = (uint64_t *)*v58;
        *v58 = (uint64_t)v53;
        v58[1] = (uint64_t)v61;
        v61 = v54;
        boost::detail::shared_count::~shared_count(&v61);
      }
      v55 = (uint64_t *)boost::shared_ptr<boost::signals2::detail::signal_impl<void ()(subscriber::SimSlot,subscriber::SimCard),boost::signals2::optional_last_value<void>,int,std::less<int>,boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>,boost::function<void ()(boost::signals2::connection const&,subscriber::SimSlot,subscriber::SimCard)>,boost::signals2::mutex>::invocation_state>::operator->(*v3);
      v60 = *(uint64_t **)(boost::shared_ptr<boost::signals2::detail::grouped_list<int,std::less<int>,boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>>>::operator*(*v55)
                        + 8);
      boost::signals2::detail::signal_impl<void ()(subscriber::SimSlot,subscriber::SimCard),boost::signals2::optional_last_value<void>,int,std::less<int>,boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>,boost::function<void ()(boost::signals2::connection const&,subscriber::SimSlot,subscriber::SimCard)>,boost::signals2::mutex>::nolock_cleanup_connections_from(v3, &v60, 0);
    }
    boost::signals2::mutex::unlock(*((pthread_mutex_t **)&v64 + 1));
    boost::signals2::detail::auto_buffer<boost::shared_ptr<void>,boost::signals2::detail::store_n_objects<10u>,boost::signals2::detail::default_grow_policy,std::allocator<boost::shared_ptr<void>>>::auto_buffer_destroy(v63);
  }
  return a1;
}

void sub_2169E5CA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a2)
  {
    __cxa_begin_catch(exception_object);
    boost::checked_delete<boost::signals2::detail::signal_impl<void ()(subscriber::SimSlot,subscriber::SimCard),boost::signals2::optional_last_value<void>,int,std::less<int>,boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>,boost::function<void ()(boost::signals2::connection const&,subscriber::SimSlot,subscriber::SimCard)>,boost::signals2::mutex>::invocation_state>(a12);
    __cxa_rethrow();
  }
  _Unwind_Resume(exception_object);
}

void sub_2169E5CC4(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  unsigned int **v10;
  va_list va;

  va_start(va, a10);
  if (a2)
  {
    __cxa_end_catch();
    boost::detail::shared_count::~shared_count(v10);
    boost::signals2::detail::garbage_collecting_lock<boost::signals2::mutex>::~garbage_collecting_lock((uint64_t)va);
    __clang_call_terminate(a1);
  }
  _Unwind_Resume(a1);
}

void sub_2169E5CE0(_Unwind_Exception *a1, int a2)
{
  uint64_t v2;

  if (a2)
  {
    __cxa_begin_catch(a1);
    boost::checked_delete<boost::signals2::detail::grouped_list<int,std::less<int>,boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>>>(v2);
    __cxa_rethrow();
  }
  _Unwind_Resume(a1);
}

void sub_2169E5D00(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  unsigned int **v12;

  if (a2)
  {
    __cxa_end_catch();
    boost::detail::shared_count::~shared_count(v12);
    MEMORY[0x2199FEAC4](a12, 0x20C40DC1BFBCFLL);
    JUMPOUT(0x2169E5DB0);
  }
  _Unwind_Resume(a1);
}

void sub_2169E5D1C(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (!a2)
    _Unwind_Resume(a1);
  MEMORY[0x2199FEAC4](a12, 0x20C40DC1BFBCFLL);
  JUMPOUT(0x2169E5DB0);
}

void sub_2169E5D28(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_list va;

  va_start(va, a10);
  if (!a2)
    _Unwind_Resume(a1);
  boost::signals2::detail::garbage_collecting_lock<boost::signals2::mutex>::~garbage_collecting_lock((uint64_t)va);
  __clang_call_terminate(a1);
}

void sub_2169E5D54(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  JUMPOUT(0x2169E5DB8);
}

uint64_t boost::checked_delete<boost::signals2::detail::signal_impl<void ()(subscriber::SimSlot,subscriber::SimCard),boost::signals2::optional_last_value<void>,int,std::less<int>,boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>,boost::function<void ()(boost::signals2::connection const&,subscriber::SimSlot,subscriber::SimCard)>,boost::signals2::mutex>::invocation_state>(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    v1 = result;
    boost::detail::shared_count::~shared_count((unsigned int **)(result + 24));
    boost::detail::shared_count::~shared_count((unsigned int **)(v1 + 8));
    JUMPOUT(0x2199FEAC4);
  }
  return result;
}

void boost::detail::sp_counted_impl_p<boost::signals2::detail::signal_impl<void ()(subscriber::SimSlot,subscriber::SimCard),boost::signals2::optional_last_value<void>,int,std::less<int>,boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>,boost::function<void ()(boost::signals2::connection const&,subscriber::SimSlot,subscriber::SimCard)>,boost::signals2::mutex>::invocation_state>::~sp_counted_impl_p()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t boost::detail::sp_counted_impl_p<boost::signals2::detail::signal_impl<void ()(subscriber::SimSlot,subscriber::SimCard),boost::signals2::optional_last_value<void>,int,std::less<int>,boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>,boost::function<void ()(boost::signals2::connection const&,subscriber::SimSlot,subscriber::SimCard)>,boost::signals2::mutex>::invocation_state>::dispose(uint64_t result)
{
  uint64_t v1;

  v1 = *(_QWORD *)(result + 16);
  if (v1)
  {
    boost::detail::shared_count::~shared_count((unsigned int **)(v1 + 24));
    boost::detail::shared_count::~shared_count((unsigned int **)(v1 + 8));
    JUMPOUT(0x2199FEAC4);
  }
  return result;
}

uint64_t boost::detail::sp_counted_base::destroy(uint64_t this)
{
  if (this)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)this + 8))(this);
  return this;
}

uint64_t boost::detail::sp_counted_impl_p<boost::signals2::detail::signal_impl<void ()(subscriber::SimSlot,subscriber::SimCard),boost::signals2::optional_last_value<void>,int,std::less<int>,boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>,boost::function<void ()(boost::signals2::connection const&,subscriber::SimSlot,subscriber::SimCard)>,boost::signals2::mutex>::invocation_state>::get_deleter()
{
  return 0;
}

uint64_t boost::detail::sp_counted_impl_p<boost::signals2::detail::signal_impl<void ()(subscriber::SimSlot,subscriber::SimCard),boost::signals2::optional_last_value<void>,int,std::less<int>,boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>,boost::function<void ()(boost::signals2::connection const&,subscriber::SimSlot,subscriber::SimCard)>,boost::signals2::mutex>::invocation_state>::get_local_deleter()
{
  return 0;
}

uint64_t boost::detail::sp_counted_impl_p<boost::signals2::detail::signal_impl<void ()(subscriber::SimSlot,subscriber::SimCard),boost::signals2::optional_last_value<void>,int,std::less<int>,boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>,boost::function<void ()(boost::signals2::connection const&,subscriber::SimSlot,subscriber::SimCard)>,boost::signals2::mutex>::invocation_state>::get_untyped_deleter()
{
  return 0;
}

void std::__list_imp<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>>::clear(unsigned int **a1)
{
  unsigned int *v2;
  unsigned int **v3;
  unsigned int *v4;
  unsigned int **v5;

  if (a1[2])
  {
    v2 = *a1;
    v3 = (unsigned int **)a1[1];
    v4 = *v3;
    *((_QWORD *)v4 + 1) = *((_QWORD *)*a1 + 1);
    **((_QWORD **)v2 + 1) = v4;
    a1[2] = 0;
    if (v3 != a1)
    {
      do
      {
        v5 = (unsigned int **)v3[1];
        boost::detail::shared_count::~shared_count(v3 + 3);
        operator delete(v3);
        v3 = v5;
      }
      while (v5 != a1);
    }
  }
}

uint64_t boost::checked_delete<boost::signals2::detail::grouped_list<int,std::less<int>,boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>>>(uint64_t result)
{
  unsigned int **v1;

  if (result)
  {
    v1 = (unsigned int **)result;
    std::__tree<std::__value_type<AQMThroughputKey,unsigned int>,std::__map_value_compare<AQMThroughputKey,std::__value_type<AQMThroughputKey,unsigned int>,std::less<AQMThroughputKey>,true>,std::allocator<std::__value_type<AQMThroughputKey,unsigned int>>>::destroy(*(_QWORD **)(result + 32));
    std::__list_imp<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>>::clear(v1);
    JUMPOUT(0x2199FEAC4);
  }
  return result;
}

void boost::detail::sp_counted_impl_p<boost::signals2::detail::grouped_list<int,std::less<int>,boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>>>::~sp_counted_impl_p()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t boost::detail::sp_counted_impl_p<boost::signals2::detail::grouped_list<int,std::less<int>,boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>>>::dispose(uint64_t result)
{
  uint64_t v1;

  v1 = *(_QWORD *)(result + 16);
  if (v1)
  {
    std::__tree<std::__value_type<AQMThroughputKey,unsigned int>,std::__map_value_compare<AQMThroughputKey,std::__value_type<AQMThroughputKey,unsigned int>,std::less<AQMThroughputKey>,true>,std::allocator<std::__value_type<AQMThroughputKey,unsigned int>>>::destroy(*(_QWORD **)(v1 + 32));
    std::__list_imp<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>>::clear((unsigned int **)v1);
    JUMPOUT(0x2199FEAC4);
  }
  return result;
}

uint64_t boost::detail::sp_counted_impl_p<boost::signals2::detail::grouped_list<int,std::less<int>,boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>>>::get_deleter()
{
  return 0;
}

uint64_t boost::detail::sp_counted_impl_p<boost::signals2::detail::grouped_list<int,std::less<int>,boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>>>::get_local_deleter()
{
  return 0;
}

uint64_t boost::detail::sp_counted_impl_p<boost::signals2::detail::grouped_list<int,std::less<int>,boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group,boost::optional<int>>,boost::signals2::slot<void ()(subscriber::SimSlot,subscriber::SimCard),boost::function<void ()(subscriber::SimSlot,subscriber::SimCard)>>,boost::signals2::mutex>>>>::get_untyped_deleter()
{
  return 0;
}

uint64_t boost::signals2::detail::slot_call_iterator_cache<boost::signals2::detail::void_type,boost::signals2::detail::variadic_slot_invoker<boost::signals2::detail::void_type,subscriber::SimSlot,subscriber::SimCard>>::~slot_call_iterator_cache(uint64_t a1)
{
  uint64_t v2;
  _OWORD v4[11];
  __int128 v5;
  uint64_t v6;

  v6 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 296);
  if (v2)
  {
    v5 = 0u;
    memset(v4, 0, sizeof(v4));
    boost::signals2::detail::garbage_collecting_lock<boost::signals2::detail::connection_body_base>::garbage_collecting_lock(v4, v2);
    boost::signals2::detail::connection_body_base::dec_slot_refcount<boost::signals2::detail::connection_body_base>(*(_DWORD **)(a1 + 296), v4);
    (*(void (**)(_QWORD))(**((_QWORD **)&v5 + 1) + 32))(*((_QWORD *)&v5 + 1));
    boost::signals2::detail::auto_buffer<boost::shared_ptr<void>,boost::signals2::detail::store_n_objects<10u>,boost::signals2::detail::default_grow_policy,std::allocator<boost::shared_ptr<void>>>::auto_buffer_destroy(v4);
  }
  boost::signals2::detail::auto_buffer<boost::variant<boost::shared_ptr<void>,boost::signals2::detail::foreign_void_shared_ptr>,boost::signals2::detail::store_n_objects<10u>,boost::signals2::detail::default_grow_policy,std::allocator<boost::variant<boost::shared_ptr<void>,boost::signals2::detail::foreign_void_shared_ptr>>>::auto_buffer_destroy((unint64_t *)(a1 + 8));
  if (*(_BYTE *)a1)
    *(_BYTE *)a1 = 0;
  return a1;
}

void sub_2169E608C(_Unwind_Exception *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  _Unwind_Resume(a1);
}

void std::__function::__func<subscriber::EURSimCommandDriver::handleRefreshEnd(uim::tlv::Refresh const&)::$_0,std::allocator<subscriber::EURSimCommandDriver::handleRefreshEnd(uim::tlv::Refresh const&)::$_0>,void ()(subscriber::SimSlot)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<subscriber::EURSimCommandDriver::handleRefreshEnd(uim::tlv::Refresh const&)::$_0,std::allocator<subscriber::EURSimCommandDriver::handleRefreshEnd(uim::tlv::Refresh const&)::$_0>,void ()(subscriber::SimSlot)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_24D5DBD48;
  return result;
}

void std::__function::__func<subscriber::EURSimCommandDriver::handleRefreshEnd(uim::tlv::Refresh const&)::$_0,std::allocator<subscriber::EURSimCommandDriver::handleRefreshEnd(uim::tlv::Refresh const&)::$_0>,void ()(subscriber::SimSlot)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_24D5DBD48;
}

uint64_t std::__function::__func<subscriber::EURSimCommandDriver::handleRefreshEnd(uim::tlv::Refresh const&)::$_0,std::allocator<subscriber::EURSimCommandDriver::handleRefreshEnd(uim::tlv::Refresh const&)::$_0>,void ()(subscriber::SimSlot)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<subscriber::EURSimCommandDriver::handleRefreshEnd(uim::tlv::Refresh const&)::$_0,std::allocator<subscriber::EURSimCommandDriver::handleRefreshEnd(uim::tlv::Refresh const&)::$_0>,void ()(subscriber::SimSlot)>::target_type()
{
}

void std::__function::__func<subscriber::EURSimCommandDriver::handleRefreshAbortBeforeStart(uim::tlv::Refresh const&)::$_0,std::allocator<subscriber::EURSimCommandDriver::handleRefreshAbortBeforeStart(uim::tlv::Refresh const&)::$_0>,void ()(subscriber::SimSlot)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<subscriber::EURSimCommandDriver::handleRefreshAbortBeforeStart(uim::tlv::Refresh const&)::$_0,std::allocator<subscriber::EURSimCommandDriver::handleRefreshAbortBeforeStart(uim::tlv::Refresh const&)::$_0>,void ()(subscriber::SimSlot)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_24D5DBDC8;
  return result;
}

void std::__function::__func<subscriber::EURSimCommandDriver::handleRefreshAbortBeforeStart(uim::tlv::Refresh const&)::$_0,std::allocator<subscriber::EURSimCommandDriver::handleRefreshAbortBeforeStart(uim::tlv::Refresh const&)::$_0>,void ()(subscriber::SimSlot)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_24D5DBDC8;
}

uint64_t std::__function::__func<subscriber::EURSimCommandDriver::handleRefreshAbortBeforeStart(uim::tlv::Refresh const&)::$_0,std::allocator<subscriber::EURSimCommandDriver::handleRefreshAbortBeforeStart(uim::tlv::Refresh const&)::$_0>,void ()(subscriber::SimSlot)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<subscriber::EURSimCommandDriver::handleRefreshAbortBeforeStart(uim::tlv::Refresh const&)::$_0,std::allocator<subscriber::EURSimCommandDriver::handleRefreshAbortBeforeStart(uim::tlv::Refresh const&)::$_0>,void ()(subscriber::SimSlot)>::target_type()
{
}

void qmi::MutableMessageBase::TlvWrapper<uim::tlv::OkToRefresh>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<uim::tlv::OkToRefresh>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<uim::tlv::OkToRefresh>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<uim::tlv::OkToRefresh>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5DBE60;
  return result;
}

char *qmi::MutableMessageBase::getTLV<uim::tlv::FileId>(_QWORD *a1)
{
  const void **v2;
  const void **v3;
  char **v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  v4 = (char **)(a1 + 1);
  if (v2 != v3)
  {
    while (*((_BYTE *)*v2 + 8) != 2)
    {
      if (++v2 == v3)
        goto LABEL_8;
    }
  }
  if (v2 == v3)
  {
LABEL_8:
    v7 = operator new();
    *(_BYTE *)(v7 + 8) = 2;
    *(_QWORD *)v7 = &off_24D5DBEB0;
    *(_WORD *)(v7 + 16) = 0;
    v6 = v7 + 16;
    *(_QWORD *)(v7 + 32) = 0;
    *(_QWORD *)(v7 + 40) = 0;
    *(_QWORD *)(v7 + 24) = 0;
    v8 = a1[3];
    v9 = (uint64_t *)a1[2];
    if ((unint64_t)v9 >= v8)
    {
      v11 = ((char *)v9 - *v4) >> 3;
      if ((unint64_t)(v11 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v12 = v8 - (_QWORD)*v4;
      v13 = v12 >> 2;
      if (v12 >> 2 <= (unint64_t)(v11 + 1))
        v13 = v11 + 1;
      if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
        v14 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v14 = v13;
      if (v14)
        v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v14);
      else
        v15 = 0;
      v16 = (uint64_t *)&v15[8 * v11];
      v17 = &v15[8 * v14];
      *v16 = v7;
      v10 = v16 + 1;
      v19 = (char *)a1[1];
      v18 = (char *)a1[2];
      if (v18 != v19)
      {
        do
        {
          v20 = *((_QWORD *)v18 - 1);
          v18 -= 8;
          *--v16 = v20;
        }
        while (v18 != v19);
        v18 = *v4;
      }
      a1[1] = v16;
      a1[2] = v10;
      a1[3] = v17;
      if (v18)
        operator delete(v18);
    }
    else
    {
      *v9 = v7;
      v10 = v9 + 1;
    }
    a1[2] = v10;
  }
  else
  {
    if (!v5)
      __cxa_bad_cast();
    return v5 + 16;
  }
  return (char *)v6;
}

_QWORD *qmi::MutableMessageBase::TlvWrapper<uim::tlv::FileId>::~TlvWrapper(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24D5DBEB0;
  v2 = (void *)a1[3];
  if (v2)
  {
    a1[4] = v2;
    operator delete(v2);
  }
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<uim::tlv::FileId>::~TlvWrapper(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24D5DBEB0;
  v2 = (void *)a1[3];
  if (v2)
  {
    a1[4] = v2;
    operator delete(v2);
  }
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<uim::tlv::FileId>::getSize(uint64_t a1)
{
  return tlv::size<wms::tlv::RawSend>(a1 + 16);
}

void *qmi::MutableMessageBase::TlvWrapper<uim::tlv::FileId>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  uint64_t v4;
  uint64_t v5;
  void *result;
  uint64_t v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = *a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<uim::tlv::FileId>(a2, a1 + 16);
  v7 = *a2 - v5;
  *(_BYTE *)v4 = v3;
  *(_WORD *)(v4 + 1) = v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<uim::tlv::FileId>::clone(uint64_t a1)
{
  uint64_t v2;

  v2 = operator new();
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)v2 = &off_24D5DBEB0;
  *(_WORD *)(v2 + 16) = *(_WORD *)(a1 + 16);
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 40) = 0;
  *(_QWORD *)(v2 + 24) = 0;
  std::vector<unsigned short>::__init_with_size[abi:ne180100]<unsigned short *,unsigned short *>((_QWORD *)(v2 + 24), *(const void **)(a1 + 24), *(_QWORD *)(a1 + 32), (uint64_t)(*(_QWORD *)(a1 + 32) - *(_QWORD *)(a1 + 24)) >> 1);
  return v2;
}

void sub_2169E6588(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199FEAC4](v1, 0x1091C405E63A369);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<uim::tlv::ReadTransparent>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<uim::tlv::ReadTransparent>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

_WORD **qmi::MutableMessageBase::TlvWrapper<uim::tlv::ReadTransparent>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _WORD *v4;
  uint64_t v5;
  _WORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_WORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::TdFragmentInfo>((_WORD **)a2, (_WORD *)(a1 + 10));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<uim::tlv::ReadTransparent>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5DBF00;
  *(_DWORD *)(result + 10) = *(_DWORD *)(a1 + 10);
  return result;
}

void std::__shared_ptr_emplace<std::vector<unsigned char>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5DBF38;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<std::vector<unsigned char>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5DBF38;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void std::__shared_ptr_emplace<std::vector<unsigned char>>::__on_zero_shared(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(_QWORD *)(a1 + 32) = v2;
    operator delete(v2);
  }
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3uim15ReadTransparent8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2169E678C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

_QWORD *qmi::MutableMessageBase::TlvWrapper<uim::tlv::WriteTransparent>::~TlvWrapper(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24D5DBFC8;
  v2 = (void *)a1[3];
  if (v2)
  {
    a1[4] = v2;
    operator delete(v2);
  }
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<uim::tlv::WriteTransparent>::~TlvWrapper(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24D5DBFC8;
  v2 = (void *)a1[3];
  if (v2)
  {
    a1[4] = v2;
    operator delete(v2);
  }
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<uim::tlv::WriteTransparent>::getSize(uint64_t a1)
{
  return tlv::size<uim::tlv::WriteTransparent>(a1 + 16);
}

void *qmi::MutableMessageBase::TlvWrapper<uim::tlv::WriteTransparent>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _WORD *v4;
  uint64_t v5;
  void *result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_WORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<uim::tlv::WriteTransparent>((_WORD **)a2, a1 + 16);
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<uim::tlv::WriteTransparent>::clone(uint64_t a1)
{
  uint64_t v2;

  v2 = operator new();
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)v2 = &off_24D5DBFC8;
  *(_WORD *)(v2 + 16) = *(_WORD *)(a1 + 16);
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 40) = 0;
  *(_QWORD *)(v2 + 24) = 0;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>((_QWORD *)(v2 + 24), *(const void **)(a1 + 24), *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 32) - *(_QWORD *)(a1 + 24));
  return v2;
}

void sub_2169E6920(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199FEAC4](v1, 0x1091C405E63A369);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3uim16WriteTransparent8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2169E6A00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<std::map<unsigned short,std::vector<unsigned char>> *,std::shared_ptr<std::map<unsigned short,std::vector<unsigned char>>>::__shared_ptr_default_delete<std::map<unsigned short,std::vector<unsigned char>>,std::map<unsigned short,std::vector<unsigned char>>>,std::allocator<std::map<unsigned short,std::vector<unsigned char>>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

uint64_t std::__shared_ptr_pointer<std::map<unsigned short,std::vector<unsigned char>> *,std::shared_ptr<std::map<unsigned short,std::vector<unsigned char>>>::__shared_ptr_default_delete<std::map<unsigned short,std::vector<unsigned char>>,std::map<unsigned short,std::vector<unsigned char>>>,std::allocator<std::map<unsigned short,std::vector<unsigned char>>>>::__on_zero_shared(uint64_t result)
{
  uint64_t v1;

  v1 = *(_QWORD *)(result + 24);
  if (v1)
  {
    std::__tree<std::__value_type<unsigned int,std::vector<unsigned char>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<unsigned char>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::vector<unsigned char>>>>::destroy(*(_QWORD **)(v1 + 8));
    JUMPOUT(0x2199FEAC4);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<std::map<unsigned short,std::vector<unsigned char>> *,std::shared_ptr<std::map<unsigned short,std::vector<unsigned char>>>::__shared_ptr_default_delete<std::map<unsigned short,std::vector<unsigned char>>,std::map<unsigned short,std::vector<unsigned char>>>,std::allocator<std::map<unsigned short,std::vector<unsigned char>>>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t *std::unique_ptr<std::map<unsigned short,std::vector<unsigned char>>>::reset[abi:ne180100](uint64_t *result)
{
  uint64_t v1;

  v1 = *result;
  *result = 0;
  if (v1)
  {
    std::__tree<std::__value_type<unsigned int,std::vector<unsigned char>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<unsigned char>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::vector<unsigned char>>>>::destroy(*(_QWORD **)(v1 + 8));
    JUMPOUT(0x2199FEAC4);
  }
  return result;
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3uim17GetFileAttributes8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2169E6BF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<uim::tlv::ReadRecord>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<uim::tlv::ReadRecord>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

_WORD **qmi::MutableMessageBase::TlvWrapper<uim::tlv::ReadRecord>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _WORD *v4;
  uint64_t v5;
  _WORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_WORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::TdFragmentInfo>((_WORD **)a2, (_WORD *)(a1 + 10));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<uim::tlv::ReadRecord>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5DC0E0;
  *(_DWORD *)(result + 10) = *(_DWORD *)(a1 + 10);
  return result;
}

uint64_t **std::__tree<std::__value_type<subscriber::AuthInfo,std::vector<unsigned char>>,std::__map_value_compare<subscriber::AuthInfo,std::__value_type<subscriber::AuthInfo,std::vector<unsigned char>>,std::less<subscriber::AuthInfo>,true>,std::allocator<std::__value_type<subscriber::AuthInfo,std::vector<unsigned char>>>>::__emplace_unique_key_args<subscriber::AuthInfo,std::piecewise_construct_t const&,std::tuple<subscriber::AuthInfo&&>,std::tuple<>>(uint64_t **a1, int a2, _DWORD *a3)
{
  uint64_t *v5;
  uint64_t **v6;
  uint64_t **v7;
  int v8;
  _DWORD *v9;

  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v7 = (uint64_t **)v5;
        v8 = *((_DWORD *)v5 + 8);
        if (v8 <= a2)
          break;
        v5 = *v7;
        v6 = v7;
        if (!*v7)
          goto LABEL_9;
      }
      if (v8 >= a2)
        break;
      v5 = v7[1];
      if (!v5)
      {
        v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    v7 = a1 + 1;
LABEL_9:
    v9 = operator new(0x40uLL);
    v9[8] = *a3;
    *((_QWORD *)v9 + 6) = 0;
    *((_QWORD *)v9 + 7) = 0;
    *((_QWORD *)v9 + 5) = 0;
    std::__tree<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::less<unsigned short>,true>,std::allocator<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>>>::__insert_node_at(a1, (uint64_t)v7, v6, (uint64_t *)v9);
    return (uint64_t **)v9;
  }
  return v7;
}

_QWORD *qmi::MutableMessageBase::TlvWrapper<uim::tlv::AuthData>::~TlvWrapper(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24D5DC130;
  v2 = (void *)a1[3];
  if (v2)
  {
    a1[4] = v2;
    operator delete(v2);
  }
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<uim::tlv::AuthData>::~TlvWrapper(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24D5DC130;
  v2 = (void *)a1[3];
  if (v2)
  {
    a1[4] = v2;
    operator delete(v2);
  }
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<uim::tlv::AuthData>::getSize(uint64_t a1)
{
  return tlv::size<wms::tlv::RawSend>(a1 + 16);
}

void *qmi::MutableMessageBase::TlvWrapper<uim::tlv::AuthData>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  uint64_t v4;
  uint64_t v5;
  void *result;
  uint64_t v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = *a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<uim::tlv::AuthData>(a2, a1 + 16);
  v7 = *a2 - v5;
  *(_BYTE *)v4 = v3;
  *(_WORD *)(v4 + 1) = v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<uim::tlv::AuthData>::clone(uint64_t a1)
{
  uint64_t v2;

  v2 = operator new();
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)v2 = &off_24D5DC130;
  *(_DWORD *)(v2 + 16) = *(_DWORD *)(a1 + 16);
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 40) = 0;
  *(_QWORD *)(v2 + 24) = 0;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>((_QWORD *)(v2 + 24), *(const void **)(a1 + 24), *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 32) - *(_QWORD *)(a1 + 24));
  return v2;
}

void sub_2169E6F00(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199FEAC4](v1, 0x1091C40970CA704);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3uim12Authenticate8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2169E6FE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

char *qmi::MutableMessageBase::getTLV<uim::tlv::SlotId>(_QWORD *a1)
{
  const void **v2;
  const void **v3;
  char **v4;
  char *v5;
  char *result;
  uint64_t v7;
  unint64_t v8;
  uint64_t *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  v4 = (char **)(a1 + 1);
  if (v2 != v3)
  {
    while (*((_BYTE *)*v2 + 8) != 1)
    {
      if (++v2 == v3)
        goto LABEL_8;
    }
  }
  if (v2 == v3)
  {
LABEL_8:
    v7 = operator new();
    *(_WORD *)(v7 + 8) = 1;
    *(_QWORD *)v7 = &off_24D5DC1A8;
    v8 = a1[3];
    v9 = (uint64_t *)a1[2];
    if ((unint64_t)v9 >= v8)
    {
      v11 = ((char *)v9 - *v4) >> 3;
      if ((unint64_t)(v11 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v12 = v8 - (_QWORD)*v4;
      v13 = v12 >> 2;
      if (v12 >> 2 <= (unint64_t)(v11 + 1))
        v13 = v11 + 1;
      if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
        v14 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v14 = v13;
      if (v14)
        v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v14);
      else
        v15 = 0;
      v16 = (uint64_t *)&v15[8 * v11];
      v17 = &v15[8 * v14];
      *v16 = v7;
      v10 = v16 + 1;
      v19 = (char *)a1[1];
      v18 = (char *)a1[2];
      if (v18 != v19)
      {
        do
        {
          v20 = *((_QWORD *)v18 - 1);
          v18 -= 8;
          *--v16 = v20;
        }
        while (v18 != v19);
        v18 = *v4;
      }
      a1[1] = v16;
      a1[2] = v10;
      a1[3] = v17;
      if (v18)
        operator delete(v18);
    }
    else
    {
      *v9 = v7;
      v10 = v9 + 1;
    }
    result = (char *)(v7 + 9);
    a1[2] = v10;
  }
  else
  {
    if (!v5)
      __cxa_bad_cast();
    return v5 + 9;
  }
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<uim::tlv::SlotId>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<uim::tlv::SlotId>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<uim::tlv::SlotId>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<uim::tlv::SlotId>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5DC1A8;
  return result;
}

_QWORD *qmi::MutableMessageBase::TlvWrapper<uim::tlv::OpenLChannelData>::~TlvWrapper(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24D5DC1F8;
  v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<uim::tlv::OpenLChannelData>::~TlvWrapper(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24D5DC1F8;
  v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<uim::tlv::OpenLChannelData>::getSize(uint64_t a1)
{
  return tlv::size<wds::tlv::NextHdrProtList>((_QWORD *)(a1 + 16));
}

void *qmi::MutableMessageBase::TlvWrapper<uim::tlv::OpenLChannelData>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  void *result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::NextHdrProtList>((_BYTE **)a2, a1 + 16);
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<uim::tlv::OpenLChannelData>::clone(uint64_t a1)
{
  uint64_t v2;

  v2 = operator new();
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)v2 = &off_24D5DC1F8;
  *(_QWORD *)(v2 + 24) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 16) = 0;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>((_QWORD *)(v2 + 16), *(const void **)(a1 + 16), *(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 24) - *(_QWORD *)(a1 + 16));
  return v2;
}

void sub_2169E7398(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199FEAC4](v1, 0x1091C40A3A4EB6ALL);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3uim14LogicalChannel8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2169E7478(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

char *qmi::MutableMessageBase::getTLV<uim::tlv::APDU>(_QWORD *a1)
{
  const void **v2;
  const void **v3;
  char **v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  v4 = (char **)(a1 + 1);
  if (v2 != v3)
  {
    while (*((_BYTE *)*v2 + 8) != 2)
    {
      if (++v2 == v3)
        goto LABEL_8;
    }
  }
  if (v2 == v3)
  {
LABEL_8:
    v7 = operator new();
    *(_BYTE *)(v7 + 8) = 2;
    *(_QWORD *)v7 = &off_24D5DC270;
    *(_QWORD *)(v7 + 16) = 0;
    v6 = v7 + 16;
    *(_QWORD *)(v7 + 24) = 0;
    *(_QWORD *)(v7 + 32) = 0;
    v8 = a1[3];
    v9 = (uint64_t *)a1[2];
    if ((unint64_t)v9 >= v8)
    {
      v11 = ((char *)v9 - *v4) >> 3;
      if ((unint64_t)(v11 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v12 = v8 - (_QWORD)*v4;
      v13 = v12 >> 2;
      if (v12 >> 2 <= (unint64_t)(v11 + 1))
        v13 = v11 + 1;
      if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
        v14 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v14 = v13;
      if (v14)
        v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v14);
      else
        v15 = 0;
      v16 = (uint64_t *)&v15[8 * v11];
      v17 = &v15[8 * v14];
      *v16 = v7;
      v10 = v16 + 1;
      v19 = (char *)a1[1];
      v18 = (char *)a1[2];
      if (v18 != v19)
      {
        do
        {
          v20 = *((_QWORD *)v18 - 1);
          v18 -= 8;
          *--v16 = v20;
        }
        while (v18 != v19);
        v18 = *v4;
      }
      a1[1] = v16;
      a1[2] = v10;
      a1[3] = v17;
      if (v18)
        operator delete(v18);
    }
    else
    {
      *v9 = v7;
      v10 = v9 + 1;
    }
    a1[2] = v10;
  }
  else
  {
    if (!v5)
      __cxa_bad_cast();
    return v5 + 16;
  }
  return (char *)v6;
}

_QWORD *qmi::MutableMessageBase::TlvWrapper<uim::tlv::APDU>::~TlvWrapper(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24D5DC270;
  v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<uim::tlv::APDU>::~TlvWrapper(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24D5DC270;
  v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<uim::tlv::APDU>::getSize(uint64_t a1)
{
  return tlv::size<p2p::tlv::MessageData>((_QWORD *)(a1 + 16));
}

void *qmi::MutableMessageBase::TlvWrapper<uim::tlv::APDU>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _WORD *v4;
  uint64_t v5;
  void *result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_WORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<p2p::tlv::MessageData>((_WORD **)a2, a1 + 16);
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<uim::tlv::APDU>::clone(uint64_t a1)
{
  uint64_t v2;

  v2 = operator new();
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)v2 = &off_24D5DC270;
  *(_QWORD *)(v2 + 24) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 16) = 0;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>((_QWORD *)(v2 + 16), *(const void **)(a1 + 16), *(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 24) - *(_QWORD *)(a1 + 16));
  return v2;
}

void sub_2169E7784(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199FEAC4](v1, 0x1091C40A3A4EB6ALL);
  _Unwind_Resume(a1);
}

char *qmi::MutableMessageBase::getTLV<uim::tlv::LChannelId>(_QWORD *a1)
{
  const void **v2;
  const void **v3;
  char **v4;
  char *v5;
  char *result;
  uint64_t v7;
  unint64_t v8;
  uint64_t *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  v4 = (char **)(a1 + 1);
  if (v2 != v3)
  {
    while (*((_BYTE *)*v2 + 8) != 16)
    {
      if (++v2 == v3)
        goto LABEL_8;
    }
  }
  if (v2 == v3)
  {
LABEL_8:
    v7 = operator new();
    *(_WORD *)(v7 + 8) = 16;
    *(_QWORD *)v7 = &off_24D5DC2C0;
    v8 = a1[3];
    v9 = (uint64_t *)a1[2];
    if ((unint64_t)v9 >= v8)
    {
      v11 = ((char *)v9 - *v4) >> 3;
      if ((unint64_t)(v11 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v12 = v8 - (_QWORD)*v4;
      v13 = v12 >> 2;
      if (v12 >> 2 <= (unint64_t)(v11 + 1))
        v13 = v11 + 1;
      if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
        v14 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v14 = v13;
      if (v14)
        v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v14);
      else
        v15 = 0;
      v16 = (uint64_t *)&v15[8 * v11];
      v17 = &v15[8 * v14];
      *v16 = v7;
      v10 = v16 + 1;
      v19 = (char *)a1[1];
      v18 = (char *)a1[2];
      if (v18 != v19)
      {
        do
        {
          v20 = *((_QWORD *)v18 - 1);
          v18 -= 8;
          *--v16 = v20;
        }
        while (v18 != v19);
        v18 = *v4;
      }
      a1[1] = v16;
      a1[2] = v10;
      a1[3] = v17;
      if (v18)
        operator delete(v18);
    }
    else
    {
      *v9 = v7;
      v10 = v9 + 1;
    }
    result = (char *)(v7 + 9);
    a1[2] = v10;
  }
  else
  {
    if (!v5)
      __cxa_bad_cast();
    return v5 + 9;
  }
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<uim::tlv::LChannelId>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<uim::tlv::LChannelId>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<uim::tlv::LChannelId>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<uim::tlv::LChannelId>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5DC2C0;
  return result;
}

void qmi::MessageBase::applyTlv<uim::tlv::APDU,void({block_pointer}&)(uim::tlv::APDU const&)>(qmi::MessageBase *a1, uint64_t a2)
{
  uint64_t TlvValue;
  int v5;
  uint64_t v6;
  int v7;
  unint64_t v8;
  void *__p;
  void *v10;
  uint64_t v11;
  unint64_t v12;

  TlvValue = qmi::MessageBase::findTlvValue(a1);
  if (TlvValue)
  {
    v6 = TlvValue;
    v7 = v5;
    v11 = 0;
    v12 = TlvValue;
    __p = 0;
    v10 = 0;
    tlv::parseV<uim::tlv::APDU>(&v12, v5, &__p);
    v8 = v12;
    if (v12)
      (*(void (**)(void))(*(_QWORD *)a2 + 16))();
    if (__p)
    {
      v10 = __p;
      operator delete(__p);
    }
    if (!v8)
      ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, 16, v6, v7);
  }
}

void sub_2169E7A94(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3uim8SendAPDU8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2169E7B6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<uim::tlv::CloseLChannelData>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<uim::tlv::CloseLChannelData>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<uim::tlv::CloseLChannelData>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<uim::tlv::CloseLChannelData>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5DC338;
  return result;
}

void QMIProfileManager::~QMIProfileManager(QMIProfileManager *this)
{
  char *v2;
  std::__shared_weak_count *v3;

  *(_QWORD *)this = &off_24D5DC388;
  v2 = (char *)this + 56;
  ctu::RestModule::disconnect((QMIProfileManager *)((char *)this + 56));
  qmi::Client::~Client((QMIProfileManager *)((char *)this + 72));
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)v2);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)this + 32);
  v3 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (v3)
    std::__shared_weak_count::__release_weak(v3);
  MEMORY[0x2199FDF6C]((char *)this + 8);
}

{
  QMIProfileManager::~QMIProfileManager(this);
  JUMPOUT(0x2199FEAC4);
}

void ___ZN17QMIProfileManager22handleQmiClientStartedERN3qmi6ClientE_block_invoke(_QWORD *a1, qmi::MessageBase *a2)
{
  std::__shared_weak_count *v3;
  uint64_t v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  uint64_t TlvValue;
  int v9;
  uint64_t v10;
  int v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  _QWORD v14[5];
  unsigned __int8 v15;
  uint64_t v16;

  v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    v5 = a1[4];
    v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      v7 = v6;
      if (a1[5])
      {
        v14[0] = MEMORY[0x24BDAC760];
        v14[1] = 0x40000000;
        v14[2] = ___ZN17QMIProfileManager38handleDeleteAllProfilesIndication_syncERKN3wds17DeleteAllProfiles10IndicationE_block_invoke;
        v14[3] = &__block_descriptor_tmp_13_10;
        v14[4] = v5;
        TlvValue = qmi::MessageBase::findTlvValue(a2);
        v10 = TlvValue;
        if (TlvValue)
        {
          v11 = v9;
          v16 = TlvValue;
          v15 = tlv::parseV<wds::tlv::DeleteProfileStatus>((unint64_t *)&v16, v9);
          if (v16)
            ___ZN17QMIProfileManager38handleDeleteAllProfilesIndication_syncERKN3wds17DeleteAllProfiles10IndicationE_block_invoke((uint64_t)v14, &v15);
          else
            ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 1, v10, v11);
        }
        *(_BYTE *)(v5 + 104) = 1;
        LODWORD(v16) = *(_DWORD *)(v5 + 48);
        BYTE4(v16) = 1;
        ctu::rest::event_t<rest::mav16_data_profile_creation_ready,std::pair<subscriber::SimSlot,BOOL>>::send(v5 + 56, (int *)&v16);
      }
      p_shared_owners = (unint64_t *)&v7->__shared_owners_;
      do
        v13 = __ldaxr(p_shared_owners);
      while (__stlxr(v13 - 1, p_shared_owners));
      if (!v13)
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
    }
  }
}

void sub_2169E7E50(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_40c42_ZTSNSt3__18weak_ptrI17QMIProfileManagerEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 48) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 16);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void __destroy_helper_block_e8_40c42_ZTSNSt3__18weak_ptrI17QMIProfileManagerEE(uint64_t a1)
{
  std::__shared_weak_count *v1;

  v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1)
    std::__shared_weak_count::__release_weak(v1);
}

void ctu::rest::event_t<rest::mav16_data_profile_creation_ready,std::pair<subscriber::SimSlot,BOOL>>::send(uint64_t a1, int *a2)
{
  xpc_object_t v3;
  xpc_object_t v4;
  int v5;
  uint64_t v6;
  const char *v7;
  xpc_object_t v8;
  xpc_object_t v9;
  xpc_object_t v10;
  void *__p;
  char v12;
  xpc_object_t v13;
  xpc_object_t v14;
  xpc_object_t object;
  xpc_object_t v16;

  v3 = xpc_dictionary_create(0, 0, 0);
  if (v3 || (v3 = xpc_null_create()) != 0)
  {
    if (MEMORY[0x2199FEDD0](v3) == MEMORY[0x24BDACFA0])
    {
      xpc_retain(v3);
      v4 = v3;
    }
    else
    {
      v4 = xpc_null_create();
    }
  }
  else
  {
    v4 = xpc_null_create();
    v3 = 0;
  }
  xpc_release(v3);
  v5 = *a2;
  v6 = subscriber::asString();
  ctu::rest::detail::write_enum_string_value((ctu::rest::detail *)v5, v6, v7);
  xpc::dict::object_proxy::operator=(&v16, v4, "first", &object);
  xpc_release(v16);
  v16 = 0;
  xpc_release(object);
  object = 0;
  v13 = xpc_BOOL_create(*((_BYTE *)a2 + 4));
  if (!v13)
    v13 = xpc_null_create();
  xpc::dict::object_proxy::operator=(&v14, v4, "second", &v13);
  xpc_release(v14);
  v14 = 0;
  xpc_release(v13);
  v13 = 0;
  if (v4)
  {
    xpc_retain(v4);
    v8 = v4;
  }
  else
  {
    v8 = xpc_null_create();
  }
  xpc_release(v4);
  std::string::basic_string[abi:ne180100]<0>(&__p, "/cc/events/mav16_data_profile_creation_ready");
  v10 = v8;
  v9 = xpc_null_create();
  ctu::RestModule::sendEvent();
  xpc_release(v10);
  if (v12 < 0)
    operator delete(__p);
  xpc_release(v9);
}

void sub_2169E804C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  void *v15;

  xpc_release(object);
  if (a15 < 0)
    operator delete(__p);
  xpc_release(v15);
  _Unwind_Resume(a1);
}

void ___ZN17QMIProfileManager22deleteAllProfiles_syncEv_block_invoke_4(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  int v4;
  NSObject *v5;
  _BOOL4 v6;
  uint64_t v7;
  int v8;
  int v9;
  uint64_t v10;
  __int16 v11;
  int v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 + 32);
  v4 = *(_DWORD *)(a2 + 4);
  v5 = *(NSObject **)(v3 + 8);
  v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (v4)
  {
    if (v6)
    {
      v7 = qmi::asString();
      v8 = *(_DWORD *)(a2 + 4);
      v9 = 136315394;
      v10 = v7;
      v11 = 1024;
      v12 = v8;
      _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#I Failed to delete all non-persistent profiles. Error: %s (0x%x). This is a best effort. Future profile creation will be allowed", (uint8_t *)&v9, 0x12u);
    }
    *(_BYTE *)(v3 + 104) = 1;
    v9 = *(_DWORD *)(v3 + 48);
    LOBYTE(v10) = 1;
    ctu::rest::event_t<rest::mav16_data_profile_creation_ready,std::pair<subscriber::SimSlot,BOOL>>::send(v3 + 56, &v9);
  }
  else if (v6)
  {
    LOWORD(v9) = 0;
    _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#I Delete profiles response received. Waiting for indication...", (uint8_t *)&v9, 2u);
  }
}

void ___ZN17QMIProfileManager38handleDeleteAllProfilesIndication_syncERKN3wds17DeleteAllProfiles10IndicationE_block_invoke(uint64_t a1, unsigned __int8 *a2)
{
  NSObject *v3;
  const char *v4;
  int v5;
  int v6;
  const char *v7;
  __int16 v8;
  int v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v3 = *(NSObject **)(*(_QWORD *)(a1 + 32) + 8);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v4 = wds::asString(*a2);
    v5 = *a2;
    v6 = 136315394;
    v7 = v4;
    v8 = 1024;
    v9 = v5;
    _os_log_impl(&dword_216897000, v3, OS_LOG_TYPE_DEFAULT, "#I Deleting all profiles status: %s (%d)", (uint8_t *)&v6, 0x12u);
  }
}

uint64_t Mav16QMIDataContextIPAggregator::Mav16QMIDataContextIPAggregator(uint64_t a1, uint64_t *a2, dispatch_object_t *a3, char *a4, uint64_t *a5)
{
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  NSObject *v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  char *Name;
  uint64_t v23;
  _QWORD *v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  unint64_t *v28;
  unint64_t v29;
  std::__shared_weak_count *v31;
  NSObject *v32;
  void *__p;
  char v34;
  uint64_t v35;
  std::__shared_weak_count *v36;
  dispatch_object_t object;
  uint64_t v38;
  std::__shared_weak_count *v39;

  v9 = (std::__shared_weak_count *)a2[1];
  v38 = *a2;
  v39 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
  }
  v12 = *a3;
  object = v12;
  if (v12)
    dispatch_retain(v12);
  v13 = (std::__shared_weak_count *)a5[1];
  v35 = *a5;
  v36 = v13;
  if (v13)
  {
    v14 = (unint64_t *)&v13->__shared_owners_;
    do
      v15 = __ldxr(v14);
    while (__stxr(v15 + 1, v14));
  }
  QMIDataContextIPAggregator::QMIDataContextIPAggregator(a1, &v38, &object, a4, &v35);
  v16 = v36;
  if (v36)
  {
    v17 = (unint64_t *)&v36->__shared_owners_;
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
  if (object)
    dispatch_release(object);
  v19 = v39;
  if (v39)
  {
    v20 = (unint64_t *)&v39->__shared_owners_;
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }
  *(_QWORD *)a1 = &off_24D5DC418;
  *(_QWORD *)(a1 + 16) = &unk_24D5DC720;
  *(_QWORD *)(a1 + 288) = &unk_24D5DC8E0;
  Name = (char *)QMIDataContextIPAggregator::getName((std::__shared_weak_count **)a1);
  std::string::basic_string[abi:ne180100]<0>(&__p, Name);
  v32 = *a3;
  if (*a3)
    dispatch_retain(*a3);
  ctu::RestModule::RestModule();
  if (v32)
    dispatch_release(v32);
  if (v34 < 0)
    operator delete(__p);
  *(_BYTE *)(a1 + 313) = 0;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 368) = 0u;
  v23 = operator new();
  *(_WORD *)v23 = 0;
  *(_DWORD *)(v23 + 2) = -1;
  v24 = (_QWORD *)operator new();
  *v24 = &off_24D5DCF50;
  v24[1] = 0;
  v24[2] = 0;
  v24[3] = v23;
  v25 = *(std::__shared_weak_count **)(a1 + 360);
  *(_QWORD *)(a1 + 352) = v23;
  *(_QWORD *)(a1 + 360) = v24;
  if (v25)
  {
    v26 = (unint64_t *)&v25->__shared_owners_;
    do
      v27 = __ldaxr(v26);
    while (__stlxr(v27 - 1, v26));
    if (!v27)
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }
  Registry::createRestModuleOneTimeUseConnection(*(Registry **)(a1 + 64));
  ctu::RestModule::connect();
  if (v31)
  {
    v28 = (unint64_t *)&v31->__shared_owners_;
    do
      v29 = __ldaxr(v28);
    while (__stlxr(v29 - 1, v28));
    if (!v29)
    {
      ((void (*)())v31->__on_zero_shared)();
      std::__shared_weak_count::__release_weak(v31);
    }
  }
  return a1;
}

void sub_2169E852C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, dispatch_object_t object, dispatch_object_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19, uint64_t a20,dispatch_object_t a21)
{
  uint64_t v21;
  uint64_t v22;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v21 + 368);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v21 + 352);
  qmi::Client::~Client((qmi::Client *)(v21 + 320));
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v22);
  QMIDataContextIPAggregator::~QMIDataContextIPAggregator((QMIDataContextIPAggregator *)v21);
  _Unwind_Resume(a1);
}

void Mav16QMIDataContextIPAggregator::~Mav16QMIDataContextIPAggregator(Mav16QMIDataContextIPAggregator *this)
{
  char *v2;

  *(_QWORD *)this = &off_24D5DC418;
  *((_QWORD *)this + 2) = &unk_24D5DC720;
  *((_QWORD *)this + 36) = &unk_24D5DC8E0;
  v2 = (char *)this + 296;
  ctu::RestModule::disconnect((Mav16QMIDataContextIPAggregator *)((char *)this + 296));
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)this + 368);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)this + 352);
  qmi::Client::~Client((Mav16QMIDataContextIPAggregator *)((char *)this + 320));
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)v2);
  QMIDataContextIPAggregator::~QMIDataContextIPAggregator(this);
}

{
  Mav16QMIDataContextIPAggregator::~Mav16QMIDataContextIPAggregator(this);
  JUMPOUT(0x2199FEAC4);
}

void `non-virtual thunk to'Mav16QMIDataContextIPAggregator::~Mav16QMIDataContextIPAggregator(Mav16QMIDataContextIPAggregator *this)
{
  Mav16QMIDataContextIPAggregator::~Mav16QMIDataContextIPAggregator((Mav16QMIDataContextIPAggregator *)((char *)this - 16));
}

{
  Mav16QMIDataContextIPAggregator::~Mav16QMIDataContextIPAggregator((Mav16QMIDataContextIPAggregator *)((char *)this - 288));
}

{
  Mav16QMIDataContextIPAggregator::~Mav16QMIDataContextIPAggregator((Mav16QMIDataContextIPAggregator *)((char *)this - 16));
  JUMPOUT(0x2199FEAC4);
}

{
  Mav16QMIDataContextIPAggregator::~Mav16QMIDataContextIPAggregator((Mav16QMIDataContextIPAggregator *)((char *)this - 288));
  JUMPOUT(0x2199FEAC4);
}

void Mav16QMIDataContextIPAggregator::initialize(uint64_t a1, int a2, uint64_t *a3, uint64_t *a4, char a5)
{
  char v5;
  char v8;
  char *v10;
  std::__shared_weak_count *v11;
  std::__shared_weak_count *v12;
  unint64_t *p_shared_owners;
  unint64_t *v14;
  unint64_t v15;
  NSObject *v16;
  int v17;
  unint64_t *v18;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  std::__shared_weak_count *v26;
  unint64_t v27;
  unint64_t *v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t *p_shared_weak_owners;
  unint64_t v32;
  unint64_t v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  NSObject *v37;
  std::__shared_weak_count *v38;
  unint64_t *v39;
  unint64_t v40;
  uint64_t v41;
  unint64_t v42;
  NSObject *v43;
  uint8_t *v44;
  uint64_t v45;
  std::__shared_weak_count *v46;
  unint64_t *v47;
  unint64_t v48;
  char *v49;
  unint64_t *v50;
  unint64_t v51;
  uint64_t v52;
  unint64_t *v53;
  unint64_t v54;
  unint64_t *v55;
  unint64_t v56;
  NSObject *v57;
  uint64_t v58;
  unint64_t *v59;
  unint64_t v60;
  std::__shared_weak_count *v61;
  unint64_t *v62;
  unint64_t v63;
  std::__shared_weak_count *v64;
  unint64_t *v65;
  unint64_t v66;
  std::__shared_weak_count *v67;
  unint64_t *v68;
  unint64_t v69;
  std::__shared_weak_count *v70;
  unint64_t *v71;
  unint64_t v72;
  std::__shared_weak_count *v73;
  unint64_t *v74;
  unint64_t v75;
  std::__shared_weak_count *v76;
  unint64_t *v77;
  unint64_t v78;
  std::__shared_weak_count *v79;
  unint64_t *v80;
  unint64_t v81;
  char *v82;
  unint64_t *v83;
  unint64_t v84;
  uint64_t v85;
  unint64_t *v86;
  unint64_t v87;
  unint64_t *v88;
  unint64_t v89;
  NSObject *v90;
  uint64_t v91;
  unint64_t *v92;
  unint64_t v93;
  std::__shared_weak_count *v94;
  unint64_t *v95;
  unint64_t v96;
  std::__shared_weak_count *v97;
  unint64_t *v98;
  unint64_t v99;
  std::__shared_weak_count *v100;
  unint64_t *v101;
  unint64_t v102;
  std::__shared_weak_count *v103;
  unint64_t *v104;
  unint64_t v105;
  std::__shared_weak_count *v106;
  unint64_t *v107;
  unint64_t v108;
  std::__shared_weak_count *v109;
  unint64_t *v110;
  unint64_t v111;
  std::__shared_weak_count *v112;
  unint64_t *v113;
  unint64_t v114;
  std::__shared_weak_count *v115;
  unint64_t *v116;
  unint64_t v117;
  std::__shared_weak_count *v118;
  unint64_t *v119;
  unint64_t v120;
  char v121;
  uint64_t v123;
  std::__shared_weak_count *v124;
  dispatch_object_t v125;
  dispatch_object_t v126;
  std::__shared_weak_count *v127;
  uint64_t v128;
  std::__shared_weak_count *v129;
  char *v130;
  std::__shared_weak_count *v131;
  uint64_t v132;
  std::__shared_weak_count *v133;
  uint64_t v134;
  std::__shared_weak_count *v135;
  dispatch_object_t v136;
  uint64_t v137;
  std::__shared_weak_count *v138;
  uint64_t v139;
  std::__shared_weak_count *v140;
  char *v141;
  std::__shared_weak_count *v142;
  uint64_t v143;
  std::__shared_weak_count *v144;
  dispatch_object_t object;
  std::__shared_weak_count *v146;
  dispatch_object_t v147;
  std::__shared_weak_count *v148;
  void *v149;
  std::__shared_weak_count *v150;
  char v151;
  char *v152;
  std::__shared_weak_count *v153;
  uint8_t buf[24];
  uint8_t *v155;
  uint64_t v156;

  v5 = a5;
  v8 = a2;
  v156 = *MEMORY[0x24BDAC8D0];
  if (!a2)
    goto LABEL_47;
  v121 = a2;
  v10 = *(char **)(a1 + 64);
  v11 = *(std::__shared_weak_count **)(a1 + 72);
  v12 = (std::__shared_weak_count *)operator new(0x88uLL);
  v12->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v12->__shared_owners_;
  v12->__shared_weak_owners_ = 0;
  v12->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5DCFC8;
  v152 = v10;
  v153 = v11;
  if (v11)
  {
    v14 = (unint64_t *)&v11->__shared_owners_;
    do
      v15 = __ldxr(v14);
    while (__stxr(v15 + 1, v14));
  }
  v16 = *(NSObject **)(a1 + 40);
  if (v16)
    dispatch_retain(*(dispatch_object_t *)(a1 + 40));
  v17 = *(_DWORD *)(a1 + 8);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, (const char *)*MEMORY[0x24BDC3E90], "DATA.pfm");
  ctu::OsLogLogger::OsLogLogger();
  ctu::OsLogLogger::OsLogLogger();
  MEMORY[0x2199FDF6C](&v149);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  v12[2].__shared_owners_ = (uint64_t)v10;
  v12[1].__shared_weak_owners_ = 0;
  v12[2].__vftable = 0;
  v12[1].__vftable = (std::__shared_weak_count_vtbl *)&off_24D5DC388;
  v12[2].__shared_weak_owners_ = (uint64_t)v11;
  if (v11)
  {
    v18 = (unint64_t *)&v11->__shared_owners_;
    do
      v19 = __ldxr(v18);
    while (__stxr(v19 + 1, v18));
  }
  LODWORD(v12[3].__vftable) = v17;
  std::string::basic_string[abi:ne180100]<0>(buf, "QMIProfileManager");
  v147 = v16;
  if (v16)
    dispatch_retain(v16);
  object = 0;
  ctu::RestModule::RestModule();
  if (v147)
    dispatch_release(v147);
  if ((char)buf[23] < 0)
    operator delete(*(void **)buf);
  v12[4].std::__shared_count = 0u;
  LOBYTE(v12[5].__shared_owners_) = 0;
  *(_OWORD *)&v12[4].__shared_weak_owners_ = 0u;
  Registry::createRestModuleOneTimeUseConnection((Registry *)v12[2].__shared_owners_);
  ctu::RestModule::connect();
  v20 = v150;
  if (v150)
  {
    v21 = (unint64_t *)&v150->__shared_owners_;
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
  if (v16)
    dispatch_release(v16);
  v23 = v12 + 1;
  if (v11)
  {
    v24 = (unint64_t *)&v11->__shared_owners_;
    do
      v25 = __ldaxr(v24);
    while (__stlxr(v25 - 1, v24));
    if (!v25)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  v12[1].__vftable = (std::__shared_weak_count_vtbl *)&off_24D5DD018;
  v26 = (std::__shared_weak_count *)v12[2].__vftable;
  if (!v26)
  {
    v8 = v121;
    do
      v30 = __ldxr(p_shared_owners);
    while (__stxr(v30 + 1, p_shared_owners));
    p_shared_weak_owners = (unint64_t *)&v12->__shared_weak_owners_;
    do
      v32 = __ldxr(p_shared_weak_owners);
    while (__stxr(v32 + 1, p_shared_weak_owners));
    v12[1].__shared_weak_owners_ = (uint64_t)v23;
    v12[2].__vftable = (std::__shared_weak_count_vtbl *)v12;
    goto LABEL_39;
  }
  v8 = v121;
  if (v26->__shared_owners_ == -1)
  {
    do
      v27 = __ldxr(p_shared_owners);
    while (__stxr(v27 + 1, p_shared_owners));
    v28 = (unint64_t *)&v12->__shared_weak_owners_;
    do
      v29 = __ldxr(v28);
    while (__stxr(v29 + 1, v28));
    v12[1].__shared_weak_owners_ = (uint64_t)v23;
    v12[2].__vftable = (std::__shared_weak_count_vtbl *)v12;
    std::__shared_weak_count::__release_weak(v26);
    do
LABEL_39:
      v33 = __ldaxr(p_shared_owners);
    while (__stlxr(v33 - 1, p_shared_owners));
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  v34 = *(std::__shared_weak_count **)(a1 + 376);
  *(_QWORD *)(a1 + 368) = v23;
  *(_QWORD *)(a1 + 376) = v12;
  v5 = a5;
  if (v34)
  {
    v35 = (unint64_t *)&v34->__shared_owners_;
    do
      v36 = __ldaxr(v35);
    while (__stlxr(v36 - 1, v35));
    if (!v36)
    {
      ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
      std::__shared_weak_count::__release_weak(v34);
    }
  }
LABEL_47:
  v152 = 0;
  v153 = 0;
  std::shared_ptr<AttachApnCommandDriver>::shared_ptr[abi:ne180100]<AttachApnCommandDriver,void>(&v152, (_QWORD *)(a1 + 24));
  if (v152
  {
    v38 = v153;
    v147 = v37;
    v148 = v153;
    if (v153)
    {
      v39 = (unint64_t *)&v153->__shared_owners_;
      do
        v40 = __ldxr(v39);
      while (__stxr(v40 + 1, v39));
      v41 = (uint64_t)&v37[36];
      object = v37 + 36;
      v146 = v38;
      do
        v42 = __ldxr(v39);
      while (__stxr(v42 + 1, v39));
    }
    else
    {
      v41 = (uint64_t)&v37[36];
      object = v37 + 36;
      v146 = 0;
    }
  }
  else
  {
    v147 = 0;
    v148 = 0;
    v43 = *(NSObject **)(a1 + 56);
    if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = "initialize";
      _os_log_error_impl(&dword_216897000, v43, OS_LOG_TYPE_ERROR, "%s: dynamic cast failure: mav16Aggregator", buf, 0xCu);
      v43 = *(NSObject **)(a1 + 56);
    }
    object = 0;
    v146 = 0;
    v41 = 0;
    v38 = 0;
    if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = "initialize";
      _os_log_error_impl(&dword_216897000, v43, OS_LOG_TYPE_ERROR, "%s: dynamic cast failure: profileManager", buf, 0xCu);
      v41 = 0;
      v38 = 0;
    }
  }
  std::string::basic_string[abi:ne180100]<0>(&v149, "/cc/events/mav16_data_profile_creation_ready");
  *(_QWORD *)buf = &off_24D5DD050;
  *(_QWORD *)&buf[8] = a1;
  v155 = buf;
  ctu::RestModule::observeEvent();
  v44 = v155;
  if (v155 == buf)
  {
    v45 = 4;
    v44 = buf;
  }
  else
  {
    if (!v155)
      goto LABEL_65;
    v45 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v44 + 8 * v45))();
LABEL_65:
  if (v151 < 0)
    operator delete(v149);
  v46 = *(std::__shared_weak_count **)(a1 + 72);
  v143 = *(_QWORD *)(a1 + 64);
  v144 = v46;
  if (v46)
  {
    v47 = (unint64_t *)&v46->__shared_owners_;
    do
      v48 = __ldxr(v47);
    while (__stxr(v48 + 1, v47));
  }
  if (v152)
    v49 = v152 + 16;
  else
    v49 = 0;
  v141 = v49;
  v142 = v153;
  if (v153)
  {
    v50 = (unint64_t *)&v153->__shared_owners_;
    do
      v51 = __ldxr(v50);
    while (__stxr(v51 + 1, v50));
  }
  v52 = a3[1];
  v139 = *a3;
  v140 = (std::__shared_weak_count *)v52;
  if (v52)
  {
    v53 = (unint64_t *)(v52 + 8);
    do
      v54 = __ldxr(v53);
    while (__stxr(v54 + 1, v53));
  }
  v137 = v41;
  v138 = v38;
  if (v38)
  {
    v55 = (unint64_t *)&v38->__shared_owners_;
    do
      v56 = __ldxr(v55);
    while (__stxr(v56 + 1, v55));
  }
  v57 = *(NSObject **)(a1 + 40);
  v136 = v57;
  if (v57)
    dispatch_retain(v57);
  v58 = a4[1];
  v134 = *a4;
  v135 = (std::__shared_weak_count *)v58;
  if (v58)
  {
    v59 = (unint64_t *)(v58 + 8);
    do
      v60 = __ldxr(v59);
    while (__stxr(v60 + 1, v59));
  }
  Mav16QMIDataContextIP::create((uint64_t)buf, &v143, (uint64_t *)&v141, v8, &v139, &v137, 1, &v136, &v134, v5);
  std::shared_ptr<qmi::Client::State>::operator=[abi:ne180100](a1 + 96, (__int128 *)buf);
  v61 = *(std::__shared_weak_count **)&buf[8];
  if (*(_QWORD *)&buf[8])
  {
    v62 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
    do
      v63 = __ldaxr(v62);
    while (__stlxr(v63 - 1, v62));
    if (!v63)
    {
      ((void (*)(std::__shared_weak_count *))v61->__on_zero_shared)(v61);
      std::__shared_weak_count::__release_weak(v61);
    }
  }
  v64 = v135;
  if (v135)
  {
    v65 = (unint64_t *)&v135->__shared_owners_;
    do
      v66 = __ldaxr(v65);
    while (__stlxr(v66 - 1, v65));
    if (!v66)
    {
      ((void (*)(std::__shared_weak_count *))v64->__on_zero_shared)(v64);
      std::__shared_weak_count::__release_weak(v64);
    }
  }
  if (v136)
    dispatch_release(v136);
  v67 = v138;
  if (v138)
  {
    v68 = (unint64_t *)&v138->__shared_owners_;
    do
      v69 = __ldaxr(v68);
    while (__stlxr(v69 - 1, v68));
    if (!v69)
    {
      ((void (*)(std::__shared_weak_count *))v67->__on_zero_shared)(v67);
      std::__shared_weak_count::__release_weak(v67);
    }
  }
  v70 = v140;
  if (v140)
  {
    v71 = (unint64_t *)&v140->__shared_owners_;
    do
      v72 = __ldaxr(v71);
    while (__stlxr(v72 - 1, v71));
    if (!v72)
    {
      ((void (*)(std::__shared_weak_count *))v70->__on_zero_shared)(v70);
      std::__shared_weak_count::__release_weak(v70);
    }
  }
  v73 = v142;
  if (v142)
  {
    v74 = (unint64_t *)&v142->__shared_owners_;
    do
      v75 = __ldaxr(v74);
    while (__stlxr(v75 - 1, v74));
    if (!v75)
    {
      ((void (*)(std::__shared_weak_count *))v73->__on_zero_shared)(v73);
      std::__shared_weak_count::__release_weak(v73);
    }
  }
  v76 = v144;
  if (v144)
  {
    v77 = (unint64_t *)&v144->__shared_owners_;
    do
      v78 = __ldaxr(v77);
    while (__stlxr(v78 - 1, v77));
    if (!v78)
    {
      ((void (*)(std::__shared_weak_count *))v76->__on_zero_shared)(v76);
      std::__shared_weak_count::__release_weak(v76);
    }
  }
  v79 = *(std::__shared_weak_count **)(a1 + 72);
  v132 = *(_QWORD *)(a1 + 64);
  v133 = v79;
  if (v79)
  {
    v80 = (unint64_t *)&v79->__shared_owners_;
    do
      v81 = __ldxr(v80);
    while (__stxr(v81 + 1, v80));
  }
  if (v152)
    v82 = v152 + 16;
  else
    v82 = 0;
  v130 = v82;
  v131 = v153;
  if (v153)
  {
    v83 = (unint64_t *)&v153->__shared_owners_;
    do
      v84 = __ldxr(v83);
    while (__stxr(v84 + 1, v83));
  }
  v85 = a3[1];
  v128 = *a3;
  v129 = (std::__shared_weak_count *)v85;
  if (v85)
  {
    v86 = (unint64_t *)(v85 + 8);
    do
      v87 = __ldxr(v86);
    while (__stxr(v87 + 1, v86));
  }
  v126 = object;
  v127 = v146;
  if (v146)
  {
    v88 = (unint64_t *)&v146->__shared_owners_;
    do
      v89 = __ldxr(v88);
    while (__stxr(v89 + 1, v88));
  }
  v90 = *(NSObject **)(a1 + 40);
  v125 = v90;
  if (v90)
    dispatch_retain(v90);
  v91 = a4[1];
  v123 = *a4;
  v124 = (std::__shared_weak_count *)v91;
  if (v91)
  {
    v92 = (unint64_t *)(v91 + 8);
    do
      v93 = __ldxr(v92);
    while (__stxr(v93 + 1, v92));
  }
  Mav16QMIDataContextIP::create((uint64_t)buf, &v132, (uint64_t *)&v130, v8, &v128, (uint64_t *)&v126, 2, &v125, &v123, v5);
  std::shared_ptr<qmi::Client::State>::operator=[abi:ne180100](a1 + 112, (__int128 *)buf);
  v94 = *(std::__shared_weak_count **)&buf[8];
  if (*(_QWORD *)&buf[8])
  {
    v95 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
    do
      v96 = __ldaxr(v95);
    while (__stlxr(v96 - 1, v95));
    if (!v96)
    {
      ((void (*)(std::__shared_weak_count *))v94->__on_zero_shared)(v94);
      std::__shared_weak_count::__release_weak(v94);
    }
  }
  v97 = v124;
  if (v124)
  {
    v98 = (unint64_t *)&v124->__shared_owners_;
    do
      v99 = __ldaxr(v98);
    while (__stlxr(v99 - 1, v98));
    if (!v99)
    {
      ((void (*)(std::__shared_weak_count *))v97->__on_zero_shared)(v97);
      std::__shared_weak_count::__release_weak(v97);
    }
  }
  if (v125)
    dispatch_release(v125);
  v100 = v127;
  if (v127)
  {
    v101 = (unint64_t *)&v127->__shared_owners_;
    do
      v102 = __ldaxr(v101);
    while (__stlxr(v102 - 1, v101));
    if (!v102)
    {
      ((void (*)(std::__shared_weak_count *))v100->__on_zero_shared)(v100);
      std::__shared_weak_count::__release_weak(v100);
    }
  }
  v103 = v129;
  if (v129)
  {
    v104 = (unint64_t *)&v129->__shared_owners_;
    do
      v105 = __ldaxr(v104);
    while (__stlxr(v105 - 1, v104));
    if (!v105)
    {
      ((void (*)(std::__shared_weak_count *))v103->__on_zero_shared)(v103);
      std::__shared_weak_count::__release_weak(v103);
    }
  }
  v106 = v131;
  if (v131)
  {
    v107 = (unint64_t *)&v131->__shared_owners_;
    do
      v108 = __ldaxr(v107);
    while (__stlxr(v108 - 1, v107));
    if (!v108)
    {
      ((void (*)(std::__shared_weak_count *))v106->__on_zero_shared)(v106);
      std::__shared_weak_count::__release_weak(v106);
    }
  }
  v109 = v133;
  if (v133)
  {
    v110 = (unint64_t *)&v133->__shared_owners_;
    do
      v111 = __ldaxr(v110);
    while (__stlxr(v111 - 1, v110));
    if (!v111)
    {
      ((void (*)(std::__shared_weak_count *))v109->__on_zero_shared)(v109);
      std::__shared_weak_count::__release_weak(v109);
    }
  }
  v112 = v146;
  if (v146)
  {
    v113 = (unint64_t *)&v146->__shared_owners_;
    do
      v114 = __ldaxr(v113);
    while (__stlxr(v114 - 1, v113));
    if (!v114)
    {
      ((void (*)(std::__shared_weak_count *))v112->__on_zero_shared)(v112);
      std::__shared_weak_count::__release_weak(v112);
    }
  }
  v115 = v148;
  if (v148)
  {
    v116 = (unint64_t *)&v148->__shared_owners_;
    do
      v117 = __ldaxr(v116);
    while (__stlxr(v117 - 1, v116));
    if (!v117)
    {
      ((void (*)(std::__shared_weak_count *))v115->__on_zero_shared)(v115);
      std::__shared_weak_count::__release_weak(v115);
    }
  }
  v118 = v153;
  if (v153)
  {
    v119 = (unint64_t *)&v153->__shared_owners_;
    do
      v120 = __ldaxr(v119);
    while (__stlxr(v120 - 1, v119));
    if (!v120)
    {
      ((void (*)(std::__shared_weak_count *))v118->__on_zero_shared)(v118);
      std::__shared_weak_count::__release_weak(v118);
    }
  }
}

void sub_2169E9144(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, char a19, uint64_t a20,char a21,uint64_t a22,char a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29,char a30,uint64_t a31,char a32,uint64_t a33,char a34,uint64_t a35,dispatch_object_t object)
{
  uint64_t v36;
  qmi::Client *v37;
  NSObject *v38;
  std::__shared_weak_count *v39;
  uint64_t v40;
  uint64_t v41;
  std::__shared_weak_count *v43;
  void *v44;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v41 - 184);
  qmi::Client::~Client(v37);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v36);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v40);
  v43 = (std::__shared_weak_count *)v39[2].__vftable;
  if (v43)
    std::__shared_weak_count::__release_weak(v43);
  MEMORY[0x2199FDF6C](a12);
  if (v38)
    dispatch_release(v38);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v41 - 160);
  std::__shared_weak_count::~__shared_weak_count(v39);
  operator delete(v44);
  _Unwind_Resume(a1);
}

void Mav16QMIDataContextIP::create(uint64_t a1, uint64_t *a2, uint64_t *a3, char a4, uint64_t *a5, uint64_t *a6, int a7, NSObject **a8, uint64_t *a9, char a10)
{
  uint64_t v18;
  uint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t *v23;
  unint64_t v24;
  uint64_t v25;
  unint64_t *v26;
  unint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *p_shared_owners;
  unint64_t v30;
  NSObject *v31;
  uint64_t v32;
  unint64_t *v33;
  unint64_t v34;
  std::__shared_weak_count *v35;
  unint64_t *v36;
  std::__shared_weak_count *v37;
  unint64_t v38;
  unint64_t *p_shared_weak_owners;
  unint64_t v40;
  unint64_t v41;
  unint64_t *v42;
  unint64_t v43;
  unint64_t v44;
  std::__shared_weak_count *v45;
  unint64_t *v46;
  unint64_t v47;
  std::__shared_weak_count *v48;
  unint64_t *v49;
  unint64_t v50;
  std::__shared_weak_count *v51;
  unint64_t *v52;
  unint64_t v53;
  std::__shared_weak_count *v54;
  unint64_t *v55;
  unint64_t v56;
  std::__shared_weak_count *v57;
  unint64_t *v58;
  unint64_t v59;
  uint64_t v60;
  std::__shared_weak_count *v61;
  dispatch_object_t object;
  uint64_t v63;
  std::__shared_weak_count *v64;
  uint64_t v65;
  std::__shared_weak_count *v66;
  uint64_t v67;
  std::__shared_weak_count *v68;
  uint64_t v69;
  std::__shared_weak_count *v70;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  v18 = operator new();
  v19 = a2[1];
  v69 = *a2;
  v70 = (std::__shared_weak_count *)v19;
  if (v19)
  {
    v20 = (unint64_t *)(v19 + 8);
    do
      v21 = __ldxr(v20);
    while (__stxr(v21 + 1, v20));
  }
  v22 = a3[1];
  v67 = *a3;
  v68 = (std::__shared_weak_count *)v22;
  if (v22)
  {
    v23 = (unint64_t *)(v22 + 8);
    do
      v24 = __ldxr(v23);
    while (__stxr(v24 + 1, v23));
  }
  v25 = a5[1];
  v65 = *a5;
  v66 = (std::__shared_weak_count *)v25;
  if (v25)
  {
    v26 = (unint64_t *)(v25 + 8);
    do
      v27 = __ldxr(v26);
    while (__stxr(v27 + 1, v26));
  }
  v28 = (std::__shared_weak_count *)a6[1];
  v63 = *a6;
  v64 = v28;
  if (v28)
  {
    p_shared_owners = (unint64_t *)&v28->__shared_owners_;
    do
      v30 = __ldxr(p_shared_owners);
    while (__stxr(v30 + 1, p_shared_owners));
  }
  v31 = *a8;
  object = v31;
  if (v31)
    dispatch_retain(v31);
  v32 = a9[1];
  v60 = *a9;
  v61 = (std::__shared_weak_count *)v32;
  if (v32)
  {
    v33 = (unint64_t *)(v32 + 8);
    do
      v34 = __ldxr(v33);
    while (__stxr(v34 + 1, v33));
  }
  Mav16QMIDataContextIP::Mav16QMIDataContextIP(v18, &v69, &v67, a4, &v65, &v63, a7, &object, &v60);
  *(_QWORD *)a1 = v18;
  *(_QWORD *)(a1 + 8) = 0;
  v35 = (std::__shared_weak_count *)operator new();
  v35->__shared_owners_ = 0;
  v36 = (unint64_t *)&v35->__shared_owners_;
  v35->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5DCDB0;
  v35->__shared_weak_owners_ = 0;
  v35[1].__vftable = (std::__shared_weak_count_vtbl *)v18;
  *(_QWORD *)(a1 + 8) = v35;
  v37 = *(std::__shared_weak_count **)(v18 + 16);
  if (v37)
  {
    if (v37->__shared_owners_ != -1)
      goto LABEL_31;
    do
      v38 = __ldxr(v36);
    while (__stxr(v38 + 1, v36));
    p_shared_weak_owners = (unint64_t *)&v35->__shared_weak_owners_;
    do
      v40 = __ldxr(p_shared_weak_owners);
    while (__stxr(v40 + 1, p_shared_weak_owners));
    *(_QWORD *)(v18 + 8) = v18;
    *(_QWORD *)(v18 + 16) = v35;
    std::__shared_weak_count::__release_weak(v37);
  }
  else
  {
    do
      v41 = __ldxr(v36);
    while (__stxr(v41 + 1, v36));
    v42 = (unint64_t *)&v35->__shared_weak_owners_;
    do
      v43 = __ldxr(v42);
    while (__stxr(v43 + 1, v42));
    *(_QWORD *)(v18 + 8) = v18;
    *(_QWORD *)(v18 + 16) = v35;
  }
  do
    v44 = __ldaxr(v36);
  while (__stlxr(v44 - 1, v36));
  if (!v44)
  {
    ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
    std::__shared_weak_count::__release_weak(v35);
  }
LABEL_31:
  v45 = v61;
  if (v61)
  {
    v46 = (unint64_t *)&v61->__shared_owners_;
    do
      v47 = __ldaxr(v46);
    while (__stlxr(v47 - 1, v46));
    if (!v47)
    {
      ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
      std::__shared_weak_count::__release_weak(v45);
    }
  }
  if (object)
    dispatch_release(object);
  v48 = v64;
  if (v64)
  {
    v49 = (unint64_t *)&v64->__shared_owners_;
    do
      v50 = __ldaxr(v49);
    while (__stlxr(v50 - 1, v49));
    if (!v50)
    {
      ((void (*)(std::__shared_weak_count *))v48->__on_zero_shared)(v48);
      std::__shared_weak_count::__release_weak(v48);
    }
  }
  v51 = v66;
  if (v66)
  {
    v52 = (unint64_t *)&v66->__shared_owners_;
    do
      v53 = __ldaxr(v52);
    while (__stlxr(v53 - 1, v52));
    if (!v53)
    {
      ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
      std::__shared_weak_count::__release_weak(v51);
    }
  }
  v54 = v68;
  if (v68)
  {
    v55 = (unint64_t *)&v68->__shared_owners_;
    do
      v56 = __ldaxr(v55);
    while (__stlxr(v56 - 1, v55));
    if (!v56)
    {
      ((void (*)(std::__shared_weak_count *))v54->__on_zero_shared)(v54);
      std::__shared_weak_count::__release_weak(v54);
    }
  }
  v57 = v70;
  if (v70)
  {
    v58 = (unint64_t *)&v70->__shared_owners_;
    do
      v59 = __ldaxr(v58);
    while (__stlxr(v59 - 1, v58));
    if (!v59)
    {
      ((void (*)(std::__shared_weak_count *))v57->__on_zero_shared)(v57);
      std::__shared_weak_count::__release_weak(v57);
    }
  }
  QMIDataContextIPBase::initialize(*(QMIDataContextIPBase **)a1, a10);
}

void sub_2169E9658(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void Mav16QMIDataContextIPAggregator::qmiClientStarted(Mav16QMIDataContextIPAggregator *this, qmi::Client *a2)
{
  NSObject *v3;
  uint64_t *v4;
  NSObject *v5;
  uint64_t v6;
  NSObject *v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  std::__shared_weak_count *v10;
  std::__shared_weak_count *v11;
  unint64_t *p_shared_weak_owners;
  unint64_t v13;
  unint64_t *p_shared_owners;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  NSObject *v18;
  NSObject *v19;
  const void **v20;
  const void **v21;
  const void **v22;
  char *v23;
  _QWORD *v24;
  NSObject *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  unint64_t v31;
  char *v32;
  const void **v33;
  char *v34;
  char *v35;
  char *v36;
  const void *v37;
  const void **v38;
  char *v39;
  _QWORD *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  unint64_t v45;
  unint64_t v46;
  char *v47;
  const void **v48;
  char *v49;
  char *v50;
  char *v51;
  const void *v52;
  char *v53;
  _QWORD *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  _QWORD *v58;
  uint64_t v59;
  unint64_t v60;
  unint64_t v61;
  char *v62;
  uint64_t *v63;
  char *v64;
  char *v65;
  char *v66;
  uint64_t v67;
  void *v68;
  _QWORD v69[6];
  std::__shared_weak_count *v70;
  _QWORD v71[6];
  uint64_t v72;
  int v73;
  uint64_t v74;
  void *aBlock;
  void *__p[2];
  __int128 v77;
  uint8_t buf[8];
  uint64_t v79;
  void (*v80)(uint64_t, QMIServiceMsg *);
  void *v81;
  _QWORD *v82;

  if (*((_QWORD *)this + 42))
  {
    v3 = *((_QWORD *)this + 7);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v69[0]) = 0;
      _os_log_impl(&dword_216897000, v3, OS_LOG_TYPE_DEFAULT, "#I aggregator fWDSClient already set", (uint8_t *)v69, 2u);
    }
    return;
  }
  v4 = (uint64_t *)((char *)a2 + 16);
  std::shared_ptr<QMIDataContextIPActivationLock>::operator=[abi:ne180100]((_QWORD *)this + 42, (uint64_t *)a2 + 2);
  v5 = *((_QWORD *)this + 7);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v69[0]) = 0;
    _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#I aggregator fWDSClient created on-demand", (uint8_t *)v69, 2u);
  }
  v6 = *((_QWORD *)this + 46);
  if (v6)
  {
    v7 = *(NSObject **)(v6 + 8);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v69[0]) = 0;
      _os_log_impl(&dword_216897000, v7, OS_LOG_TYPE_DEFAULT, "#I lazy creation of fWDSClient", (uint8_t *)v69, 2u);
    }
    std::shared_ptr<QMIDataContextIPActivationLock>::operator=[abi:ne180100]((_QWORD *)(v6 + 88), v4);
    if (*(_QWORD *)(v6 + 88))
    {
      v8 = *(std::__shared_weak_count **)(v6 + 24);
      if (!v8 || (v9 = *(_QWORD *)(v6 + 16), (v10 = std::__shared_weak_count::lock(v8)) == 0))
        std::__throw_bad_weak_ptr[abi:ne180100]();
      v11 = v10;
      p_shared_weak_owners = (unint64_t *)&v10->__shared_weak_owners_;
      do
        v13 = __ldxr(p_shared_weak_owners);
      while (__stxr(v13 + 1, p_shared_weak_owners));
      p_shared_owners = (unint64_t *)&v10->__shared_owners_;
      do
        v15 = __ldaxr(p_shared_owners);
      while (__stlxr(v15 - 1, p_shared_owners));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v11);
      }
      v16 = MEMORY[0x24BDAC760];
      v69[0] = MEMORY[0x24BDAC760];
      v69[1] = 1174405120;
      v69[2] = ___ZN17QMIProfileManager22handleQmiClientStartedERN3qmi6ClientE_block_invoke;
      v69[3] = &__block_descriptor_tmp_31;
      v69[4] = v6;
      v69[5] = v9;
      v70 = v11;
      do
        v17 = __ldxr(p_shared_weak_owners);
      while (__stxr(v17 + 1, p_shared_weak_owners));
      *(_QWORD *)buf = v16;
      v79 = 0x40000000;
      v80 = ___ZNK3qmi6Client13setIndHandlerIRKN3wds17DeleteAllProfiles10IndicationEEEvtU13block_pointerFvT_E_block_invoke;
      v81 = &unk_24D5DCE08;
      v82 = v69;
      qmi::Client::setIndHandler();
      if (*(_BYTE *)(v6 + 104))
      {
        v18 = *(NSObject **)(v6 + 8);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_216897000, v18, OS_LOG_TYPE_DEFAULT, "#I Deleting all profiles was already done", buf, 2u);
        }
LABEL_107:
        if (v70)
          std::__shared_weak_count::__release_weak(v70);
        std::__shared_weak_count::__release_weak(v11);
        return;
      }
      if (!*(_QWORD *)(v6 + 88))
      {
        v25 = *(NSObject **)(v6 + 8);
        if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)buf = 0;
          _os_log_error_impl(&dword_216897000, v25, OS_LOG_TYPE_ERROR, "invalid QMI client", buf, 2u);
        }
        goto LABEL_107;
      }
      *(_OWORD *)__p = 0u;
      v77 = 0u;
      qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
      v20 = (const void **)__p[1];
      v21 = (const void **)v77;
      v22 = (const void **)__p[1];
      if (__p[1] != (void *)v77)
      {
        v22 = (const void **)__p[1];
        while (*((_BYTE *)*v22 + 8) != 1)
        {
          if (++v22 == (const void **)v77)
            goto LABEL_36;
        }
      }
      if (v22 == (const void **)v77)
      {
LABEL_36:
        v26 = operator new();
        v27 = v26;
        *(_BYTE *)(v26 + 8) = 1;
        *(_QWORD *)v26 = &off_24D5DCE50;
        *(_QWORD *)(v26 + 16) = 0;
        v24 = (_QWORD *)(v26 + 16);
        v28 = v77;
        if ((unint64_t)v77 >= *((_QWORD *)&v77 + 1))
        {
          v29 = (uint64_t)(v77 - (unint64_t)__p[1]) >> 3;
          if ((unint64_t)(v29 + 1) >> 61)
            goto LABEL_112;
          v30 = (uint64_t)(*((_QWORD *)&v77 + 1) - (unint64_t)__p[1]) >> 2;
          if (v30 <= v29 + 1)
            v30 = v29 + 1;
          if (*((_QWORD *)&v77 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
            v31 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v31 = v30;
          if (v31)
            v32 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v77 + 8, v31);
          else
            v32 = 0;
          v33 = (const void **)&v32[8 * v29];
          v34 = &v32[8 * v31];
          *v33 = (const void *)v27;
          v21 = v33 + 1;
          v36 = (char *)__p[1];
          v35 = (char *)v77;
          if ((void *)v77 != __p[1])
          {
            do
            {
              v37 = (const void *)*((_QWORD *)v35 - 1);
              v35 -= 8;
              *--v33 = v37;
            }
            while (v35 != v36);
            v35 = (char *)__p[1];
          }
          __p[1] = v33;
          *(_QWORD *)&v77 = v21;
          *((_QWORD *)&v77 + 1) = v34;
          if (v35)
            operator delete(v35);
        }
        else
        {
          *(_QWORD *)v77 = v26;
          v21 = (const void **)(v28 + 8);
        }
        *(_QWORD *)&v77 = v21;
        v20 = (const void **)__p[1];
      }
      else
      {
        if (!v23)
          goto LABEL_113;
        v24 = v23 + 16;
      }
      *v24 = 3;
      if (v20 == v21)
        goto LABEL_61;
      v38 = v20;
      while (*((_BYTE *)*v38 + 8) != 16)
      {
        if (++v38 == v21)
          goto LABEL_61;
      }
      if (v38 == v21)
      {
LABEL_61:
        v41 = operator new();
        v42 = v41;
        *(_BYTE *)(v41 + 8) = 16;
        *(_QWORD *)v41 = &off_24D5DCEA0;
        *(_QWORD *)(v41 + 16) = 0;
        v40 = (_QWORD *)(v41 + 16);
        v43 = v77;
        if ((unint64_t)v77 >= *((_QWORD *)&v77 + 1))
        {
          v44 = (uint64_t)(v77 - (unint64_t)__p[1]) >> 3;
          if ((unint64_t)(v44 + 1) >> 61)
            goto LABEL_112;
          v45 = (uint64_t)(*((_QWORD *)&v77 + 1) - (unint64_t)__p[1]) >> 2;
          if (v45 <= v44 + 1)
            v45 = v44 + 1;
          if (*((_QWORD *)&v77 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
            v46 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v46 = v45;
          if (v46)
            v47 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v77 + 8, v46);
          else
            v47 = 0;
          v48 = (const void **)&v47[8 * v44];
          v49 = &v47[8 * v46];
          *v48 = (const void *)v42;
          v21 = v48 + 1;
          v51 = (char *)__p[1];
          v50 = (char *)v77;
          if ((void *)v77 != __p[1])
          {
            do
            {
              v52 = (const void *)*((_QWORD *)v50 - 1);
              v50 -= 8;
              *--v48 = v52;
            }
            while (v50 != v51);
            v50 = (char *)__p[1];
          }
          __p[1] = v48;
          *(_QWORD *)&v77 = v21;
          *((_QWORD *)&v77 + 1) = v49;
          if (v50)
            operator delete(v50);
        }
        else
        {
          *(_QWORD *)v77 = v41;
          v21 = (const void **)(v43 + 8);
        }
        *(_QWORD *)&v77 = v21;
        v20 = (const void **)__p[1];
      }
      else
      {
        if (!v39)
          goto LABEL_113;
        v40 = v39 + 16;
      }
      *v40 = 1;
      while (1)
      {
        if (v20 == v21)
          goto LABEL_85;
        if (*((_BYTE *)*v20 + 8) == 17)
          break;
        ++v20;
      }
      if (v20 != v21)
      {
        if (v53)
        {
          v54 = v53 + 16;
LABEL_102:
          *v54 = 1;
          v71[5] = v6 + 72;
          v72 = QMIServiceMsg::create();
          v73 = 25000;
          v74 = 0;
          aBlock = 0;
          v71[0] = v16;
          v71[1] = 0x40000000;
          v71[2] = ___ZN17QMIProfileManager22deleteAllProfiles_syncEv_block_invoke_4;
          v71[3] = &__block_descriptor_tmp_11_10;
          v71[4] = v6;
          *(_QWORD *)buf = v16;
          v79 = 0x40000000;
          v80 = ___ZNO3qmi6Client9SendProxy8callbackIRKN3wds17DeleteAllProfiles8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
          v81 = &unk_24D5DCF20;
          v82 = v71;
          v68 = _Block_copy(buf);
          aBlock = v68;
          if (v72)
          {
            qmi::Client::send();
            v68 = aBlock;
          }
          if (v68)
            _Block_release(v68);
          qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
          goto LABEL_107;
        }
LABEL_113:
        __cxa_bad_cast();
      }
LABEL_85:
      v55 = operator new();
      v56 = v55;
      *(_BYTE *)(v55 + 8) = 17;
      *(_QWORD *)v55 = &off_24D5DCEF0;
      *(_QWORD *)(v55 + 16) = 0;
      v54 = (_QWORD *)(v55 + 16);
      v57 = v77;
      if ((unint64_t)v77 < *((_QWORD *)&v77 + 1))
      {
        *(_QWORD *)v77 = v55;
        v58 = (_QWORD *)(v57 + 8);
LABEL_101:
        *(_QWORD *)&v77 = v58;
        goto LABEL_102;
      }
      v59 = (uint64_t)(v77 - (unint64_t)__p[1]) >> 3;
      if (!((unint64_t)(v59 + 1) >> 61))
      {
        v60 = (uint64_t)(*((_QWORD *)&v77 + 1) - (unint64_t)__p[1]) >> 2;
        if (v60 <= v59 + 1)
          v60 = v59 + 1;
        if (*((_QWORD *)&v77 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v61 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v61 = v60;
        if (v61)
          v62 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v77 + 8, v61);
        else
          v62 = 0;
        v63 = (uint64_t *)&v62[8 * v59];
        v64 = &v62[8 * v61];
        *v63 = v56;
        v58 = v63 + 1;
        v66 = (char *)__p[1];
        v65 = (char *)v77;
        if ((void *)v77 != __p[1])
        {
          do
          {
            v67 = *((_QWORD *)v65 - 1);
            v65 -= 8;
            *--v63 = v67;
          }
          while (v65 != v66);
          v65 = (char *)__p[1];
        }
        __p[1] = v63;
        *(_QWORD *)&v77 = v58;
        *((_QWORD *)&v77 + 1) = v64;
        if (v65)
          operator delete(v65);
        goto LABEL_101;
      }
LABEL_112:
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    }
    v19 = *(NSObject **)(v6 + 8);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v69[0]) = 0;
      _os_log_error_impl(&dword_216897000, v19, OS_LOG_TYPE_ERROR, "handleQmiClientStarted() called with an invalid QMI client", (uint8_t *)v69, 2u);
    }
  }
}

void sub_2169E9E88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *aBlock,char a27)
{
  std::__shared_weak_count *v27;

  if (a23)
    qmi::Client::send();
  if (aBlock)
    _Block_release(aBlock);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a27);
  if (a15)
    std::__shared_weak_count::__release_weak(a15);
  std::__shared_weak_count::__release_weak(v27);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'Mav16QMIDataContextIPAggregator::qmiClientStarted(Mav16QMIDataContextIPAggregator *this, qmi::Client *a2)
{
  Mav16QMIDataContextIPAggregator::qmiClientStarted((Mav16QMIDataContextIPAggregator *)((char *)this - 16), a2);
}

void Mav16QMIDataContextIPAggregator::qmiClientStopped(Mav16QMIDataContextIPAggregator *this)
{
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  NSObject *v5;
  NSObject *v6;
  __int128 v7;
  __int128 v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  if (*((_QWORD *)this + 42))
  {
    v7 = 0u;
    v8 = 0u;
    std::shared_ptr<qmi::Client::State>::operator=[abi:ne180100]((uint64_t)this + 336, &v8);
    qmi::Client::~Client((qmi::Client *)&v7);
    v2 = *((_QWORD *)this + 44);
    *(_WORD *)v2 = 0;
    *(_DWORD *)(v2 + 2) = -1;
    v3 = *((_QWORD *)this + 7);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v7) = 136315138;
      *(_QWORD *)((char *)&v7 + 4) = "qmiClientStopped";
      _os_log_impl(&dword_216897000, v3, OS_LOG_TYPE_DEFAULT, "#I %s: Reset profiles", (uint8_t *)&v7, 0xCu);
    }
    v4 = *((_QWORD *)this + 46);
    if (v4)
    {
      v5 = *(NSObject **)(v4 + 8);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v7) = 0;
        _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#I handleQmiClientStop()", (uint8_t *)&v7, 2u);
      }
      *(_BYTE *)(v4 + 104) = 0;
      LODWORD(v7) = *(_DWORD *)(v4 + 48);
      BYTE4(v7) = 0;
      ctu::rest::event_t<rest::mav16_data_profile_creation_ready,std::pair<subscriber::SimSlot,BOOL>>::send(v4 + 56, (int *)&v7);
      v7 = 0u;
      v8 = 0u;
      std::shared_ptr<qmi::Client::State>::operator=[abi:ne180100](v4 + 88, &v8);
      qmi::Client::~Client((qmi::Client *)&v7);
    }
  }
  else
  {
    v6 = *((_QWORD *)this + 7);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v7) = 0;
      _os_log_impl(&dword_216897000, v6, OS_LOG_TYPE_DEFAULT, "#I null fWDSClient in aggreator client stop", (uint8_t *)&v7, 2u);
    }
  }
}

void `non-virtual thunk to'Mav16QMIDataContextIPAggregator::qmiClientStopped(Mav16QMIDataContextIPAggregator *this)
{
  Mav16QMIDataContextIPAggregator::qmiClientStopped((Mav16QMIDataContextIPAggregator *)((char *)this - 16));
}

void ___ZN31Mav16QMIDataContextIPAggregator17delete3gppProfileEv_block_invoke_16(uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  int v4;
  NSObject *v5;
  _BOOL8 v6;
  int v7;
  uint64_t v8;
  int v9;
  const char *v10;
  NSObject *v11;
  uint32_t v12;
  int v13;
  char *v14;
  int v15;
  NSObject *v16;
  void *v17;
  NSObject *v18;
  const char *v19;
  NSObject *v20;
  uint64_t v21;
  _QWORD v22[6];
  uint64_t v23;
  int v24;
  uint64_t v25;
  void *aBlock;
  _OWORD v27[2];
  uint8_t buf[8];
  __int128 v29;
  void *v30;
  _QWORD *v31;
  uint64_t v32;

  v32 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD **)(a1 + 32);
  v4 = *(_DWORD *)(a2 + 4);
  v5 = v3[7];
  v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (v4)
  {
    if (!v6)
      goto LABEL_7;
    v7 = *(unsigned __int8 *)(v3[44] + 2);
    v8 = qmi::asString();
    v9 = *(_DWORD *)(a2 + 4);
    *(_DWORD *)buf = 67109634;
    *(_DWORD *)&buf[4] = v7;
    LOWORD(v29) = 2080;
    *(_QWORD *)((char *)&v29 + 2) = v8;
    WORD5(v29) = 1024;
    HIDWORD(v29) = v9;
    v10 = "#I Failed to delete 3gpp profile %d. Error: %s (0x%x)";
    v11 = v5;
    v12 = 24;
  }
  else
  {
    if (!v6)
      goto LABEL_7;
    v13 = *(unsigned __int8 *)(v3[44] + 2);
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v13;
    v10 = "#I Delete 3gpp profile %d succeeded";
    v11 = v5;
    v12 = 8;
  }
  _os_log_impl(&dword_216897000, v11, OS_LOG_TYPE_DEFAULT, v10, buf, v12);
LABEL_7:
  if (!v3[42])
  {
    v18 = v3[7];
    if (!os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      return;
    *(_WORD *)buf = 0;
    v19 = "#I null fWDSClient after delete 3gpp profile";
    goto LABEL_24;
  }
  if (capabilities::ct::supportsCapabilityC2KDevice((capabilities::ct *)v6))
  {
    if (v3[42])
    {
      memset(v27, 0, sizeof(v27));
      qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v27);
      v14 = qmi::MutableMessageBase::getTLV<wds::tlv::ProfileIdentifer>(v27);
      *v14 = 1;
      v15 = *(unsigned __int8 *)(v3[44] + 4);
      v14[1] = v15;
      v16 = v3[7];
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&buf[4] = v15;
        _os_log_impl(&dword_216897000, v16, OS_LOG_TYPE_DEFAULT, "#I delete 3gpp2 profile %d", buf, 8u);
      }
      v22[5] = v3 + 40;
      v23 = QMIServiceMsg::create();
      v24 = 25000;
      v25 = 0;
      aBlock = 0;
      v22[0] = MEMORY[0x24BDAC760];
      v22[1] = 0x40000000;
      v22[2] = ___ZN31Mav16QMIDataContextIPAggregator18delete3gpp2ProfileEv_block_invoke_19;
      v22[3] = &__block_descriptor_tmp_20_11;
      v22[4] = v3;
      *(_QWORD *)buf = MEMORY[0x24BDAC760];
      *(_QWORD *)&v29 = 0x40000000;
      *((_QWORD *)&v29 + 1) = ___ZNO3qmi6Client9SendProxy8callbackIRKN3wds13DeleteProfile8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
      v30 = &unk_24D5DD118;
      v31 = v22;
      v17 = _Block_copy(buf);
      aBlock = v17;
      if (v23)
      {
        qmi::Client::send();
        v17 = aBlock;
      }
      if (v17)
        _Block_release(v17);
      qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v27);
      return;
    }
    v18 = v3[7];
    if (!os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      return;
    *(_WORD *)buf = 0;
    v19 = "#I null fWDSClient in delete3gpp2Profile";
LABEL_24:
    _os_log_impl(&dword_216897000, v18, OS_LOG_TYPE_DEFAULT, v19, buf, 2u);
    return;
  }
  v20 = v3[7];
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_216897000, v20, OS_LOG_TYPE_DEFAULT, "#I 3GPP2 profile not supported. ReleaseQmiClient: Reset profiles", buf, 2u);
  }
  v21 = v3[44];
  *(_WORD *)v21 = 0;
  *(_DWORD *)(v21 + 2) = -1;
  qmi::Client::release((qmi::Client *)(v3 + 40));
}

void sub_2169EA3B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  uint64_t v7;
  va_list va;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  va_list va1;

  va_start(va1, a6);
  va_start(va, a6);
  v7 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)va);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va1);
  _Unwind_Resume(a1);
}

void ___ZN31Mav16QMIDataContextIPAggregator18delete3gpp2ProfileEv_block_invoke_19(uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  int v4;
  NSObject *v5;
  _BOOL4 v6;
  int v7;
  uint64_t v8;
  int v9;
  const char *v10;
  NSObject *v11;
  uint32_t v12;
  int v13;
  uint64_t v14;
  NSObject *v15;
  _BOOL4 v16;
  uint64_t v17;
  int v18;
  int v19;
  __int16 v20;
  uint64_t v21;
  __int16 v22;
  int v23;
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD **)(a1 + 32);
  v4 = *(_DWORD *)(a2 + 4);
  v5 = v3[7];
  v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (v4)
  {
    if (!v6)
      goto LABEL_7;
    v7 = *(unsigned __int8 *)(v3[44] + 4);
    v8 = qmi::asString();
    v9 = *(_DWORD *)(a2 + 4);
    v18 = 67109634;
    v19 = v7;
    v20 = 2080;
    v21 = v8;
    v22 = 1024;
    v23 = v9;
    v10 = "#I Failed to delete 3gpp2 profile %d. Error: %s (0x%x)";
    v11 = v5;
    v12 = 24;
  }
  else
  {
    if (!v6)
      goto LABEL_7;
    v13 = *(unsigned __int8 *)(v3[44] + 4);
    v18 = 67109120;
    v19 = v13;
    v10 = "#I Delete 3gpp2 profile %d succeeded";
    v11 = v5;
    v12 = 8;
  }
  _os_log_impl(&dword_216897000, v11, OS_LOG_TYPE_DEFAULT, v10, (uint8_t *)&v18, v12);
LABEL_7:
  v14 = v3[42];
  v15 = v3[7];
  v16 = os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT);
  if (v14)
  {
    if (v16)
    {
      LOWORD(v18) = 0;
      _os_log_impl(&dword_216897000, v15, OS_LOG_TYPE_DEFAULT, "#I releaseQmiClient: Reset profiles", (uint8_t *)&v18, 2u);
    }
    v17 = v3[44];
    *(_WORD *)v17 = 0;
    *(_DWORD *)(v17 + 2) = -1;
    qmi::Client::release((qmi::Client *)(v3 + 40));
  }
  else if (v16)
  {
    LOWORD(v18) = 0;
    _os_log_impl(&dword_216897000, v15, OS_LOG_TYPE_DEFAULT, "#I null fWDSClient after delete 3gpp2 profile", (uint8_t *)&v18, 2u);
  }
}

void Mav16QMIDataContextIPAggregator::releaseQmiClient(Mav16QMIDataContextIPAggregator *this)
{
  unsigned __int8 *v2;
  NSObject *v3;
  char *v4;
  int v5;
  NSObject *v6;
  void *v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  NSObject *v11;
  NSObject *v12;
  NSObject *v13;
  _QWORD v14[6];
  uint64_t v15;
  int v16;
  uint64_t v17;
  void *aBlock;
  _OWORD v19[2];
  uint8_t buf[8];
  uint64_t v21;
  void (*v22)(uint64_t, QMIServiceMsg *);
  void *v23;
  _QWORD *v24;
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  if (*((_QWORD *)this + 42))
  {
    v2 = (unsigned __int8 *)*((_QWORD *)this + 44);
    if (v2[3] != 254 && v2[2] == 255 || v2[5] != 254 && v2[4] == 255)
    {
      qmi::Client::release((Mav16QMIDataContextIPAggregator *)((char *)this + 320));
      v12 = *((_QWORD *)this + 7);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_216897000, v12, OS_LOG_TYPE_DEFAULT, "#I No valid profile. fWDSClient deleted", buf, 2u);
      }
    }
    else
    {
      v3 = *((_QWORD *)this + 7);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT)
        && (*(_WORD *)buf = 0,
            _os_log_impl(&dword_216897000, v3, OS_LOG_TYPE_DEFAULT, "#I delete created Profile upon fWDSClient release", buf, 2u), !*((_QWORD *)this + 42)))
      {
        v13 = *((_QWORD *)this + 7);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_216897000, v13, OS_LOG_TYPE_DEFAULT, "#I null fWDSClient in delete3gppProfile", buf, 2u);
        }
      }
      else
      {
        memset(v19, 0, sizeof(v19));
        qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v19);
        v4 = qmi::MutableMessageBase::getTLV<wds::tlv::ProfileIdentifer>(v19);
        *v4 = 0;
        v5 = *(unsigned __int8 *)(*((_QWORD *)this + 44) + 2);
        v4[1] = v5;
        v6 = *((_QWORD *)this + 7);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&buf[4] = v5;
          _os_log_impl(&dword_216897000, v6, OS_LOG_TYPE_DEFAULT, "#I delete 3gpp profile %d", buf, 8u);
        }
        v14[5] = (char *)this + 320;
        v15 = QMIServiceMsg::create();
        v16 = 25000;
        v17 = 0;
        aBlock = 0;
        v14[0] = MEMORY[0x24BDAC760];
        v14[1] = 0x40000000;
        v14[2] = ___ZN31Mav16QMIDataContextIPAggregator17delete3gppProfileEv_block_invoke_16;
        v14[3] = &__block_descriptor_tmp_17_15;
        v14[4] = this;
        *(_QWORD *)buf = MEMORY[0x24BDAC760];
        v21 = 0x40000000;
        v22 = ___ZNO3qmi6Client9SendProxy8callbackIRKN3wds13DeleteProfile8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
        v23 = &unk_24D5DD118;
        v24 = v14;
        v7 = _Block_copy(buf);
        aBlock = v7;
        if (v15)
        {
          qmi::Client::send();
          v7 = aBlock;
        }
        if (v7)
          _Block_release(v7);
        qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v19);
      }
      v8 = std::__shared_weak_count::lock(*((std::__shared_weak_count **)this + 11));
      *(_QWORD *)buf = *((_QWORD *)this + 10);
      v21 = (uint64_t)v8;
      (*(void (**)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)buf + 424))(*(_QWORD *)buf, *((unsigned int *)this + 2), 0);
      p_shared_owners = (unint64_t *)&v8->__shared_owners_;
      do
        v10 = __ldaxr(p_shared_owners);
      while (__stlxr(v10 - 1, p_shared_owners));
      if (!v10)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }
    QMIDataContextIPAggregator::resetfActivationGuard(this);
  }
  else
  {
    v11 = *((_QWORD *)this + 7);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_216897000, v11, OS_LOG_TYPE_DEFAULT, "#I null fWDSClient in aggregator releaseQmiClient", buf, 2u);
    }
  }
}

void sub_2169EA8C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  uint64_t v7;
  va_list va;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  va_list va1;

  va_start(va1, a6);
  va_start(va, a6);
  v7 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)va);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va1);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'Mav16QMIDataContextIPAggregator::releaseQmiClient(Mav16QMIDataContextIPAggregator *this)
{
  Mav16QMIDataContextIPAggregator::releaseQmiClient((Mav16QMIDataContextIPAggregator *)((char *)this - 16));
}

void Mav16QMIDataContextIPAggregator::handleBasebandRefreshComplete(Mav16QMIDataContextIPAggregator *this)
{
  uint64_t v1;
  NSObject *v2;
  uint8_t v3[16];

  v1 = *((_QWORD *)this + 44);
  if (v1)
  {
    *(_WORD *)v1 = 0;
    *(_DWORD *)(v1 + 2) = -1;
    v2 = *((_QWORD *)this + 7);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v3 = 0;
      _os_log_impl(&dword_216897000, v2, OS_LOG_TYPE_DEFAULT, "#I Reset profiles", v3, 2u);
    }
  }
}

uint64_t Mav16QMIDataContextIPAggregator::canCreateProfile(Mav16QMIDataContextIPAggregator *this)
{
  return *((unsigned __int8 *)this + 313);
}

uint64_t `non-virtual thunk to'Mav16QMIDataContextIPAggregator::canCreateProfile(Mav16QMIDataContextIPAggregator *this)
{
  return *((unsigned __int8 *)this + 25);
}

uint64_t Mav16QMIDataContextIPAggregator::getProfileInfo@<X0>(uint64_t this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(this + 360);
  *a2 = *(_QWORD *)(this + 352);
  a2[1] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return this;
}

uint64_t `non-virtual thunk to'Mav16QMIDataContextIPAggregator::getProfileInfo@<X0>(uint64_t this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(this + 72);
  *a2 = *(_QWORD *)(this + 64);
  a2[1] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return this;
}

uint64_t Mav16QMIDataContextIPAggregator::createProfileIfNeeded(uint64_t a1, uint64_t *a2)
{
  unsigned __int8 *v4;
  NSObject *v6;
  const char *v7;
  NSObject *v8;
  _BOOL8 v9;
  void **v10;
  uint64_t v11;
  _BYTE *v12;
  capabilities::ct *v13;
  _QWORD v14[6];
  _QWORD v15[5];
  void *__p[2];
  char v17;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  uint64_t *v21;
  __int16 v22;
  void **v23;
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  if (!*(_BYTE *)(a1 + 313))
  {
    v6 = *(NSObject **)(a1 + 56);
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      return 2;
    *(_DWORD *)buf = 136315138;
    v19 = "createProfileIfNeeded";
    v7 = "#I %s: Baseband is not ready to support profile creation";
LABEL_9:
    _os_log_impl(&dword_216897000, v6, OS_LOG_TYPE_DEFAULT, v7, buf, 0xCu);
    return 2;
  }
  v4 = *(unsigned __int8 **)(a1 + 352);
  if ((v4[3] == 254 || v4[2] != 255) && (v4[5] == 254 || v4[4] != 255))
    return 0;
  if (*v4)
    return 1;
  v8 = *(NSObject **)(a1 + 56);
  v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
  if (v9)
  {
    if (*((char *)a2 + 23) < 0)
      a2 = (uint64_t *)*a2;
    QMIProfileInfo::asString((QMIProfileInfo *)v4, __p);
    if (v17 >= 0)
      v10 = __p;
    else
      v10 = (void **)__p[0];
    *(_DWORD *)buf = 136315650;
    v19 = "createProfileIfNeeded";
    v20 = 2080;
    v21 = a2;
    v22 = 2080;
    v23 = v10;
    _os_log_impl(&dword_216897000, v8, OS_LOG_TYPE_DEFAULT, "#I %s: %s Profiles not assigned. %s", buf, 0x20u);
    if (v17 < 0)
      operator delete(__p[0]);
  }
  if (!*(_QWORD *)(a1 + 336))
  {
    v6 = *(NSObject **)(a1 + 56);
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      return 2;
    *(_DWORD *)buf = 136315138;
    v19 = "createProfileIfNeeded";
    v7 = "#I %s: Invalid WDS client. Cannot create profiles";
    goto LABEL_9;
  }
  v11 = capabilities::ct::supportsCapabilityC2KDevice((capabilities::ct *)v9);
  v12 = *(_BYTE **)(a1 + 352);
  if ((v11 & 1) == 0)
    v12[5] = -2;
  v14[5] = a1;
  v15[0] = MEMORY[0x24BDAC760];
  v15[1] = 0x40000000;
  v15[2] = ___ZN31Mav16QMIDataContextIPAggregator21createProfileIfNeededERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE_block_invoke;
  v15[3] = &__block_descriptor_tmp_22_12;
  v15[4] = a1;
  v14[0] = MEMORY[0x24BDAC760];
  v14[1] = 0x40000000;
  v14[2] = ___ZN31Mav16QMIDataContextIPAggregator21createProfileIfNeededERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE_block_invoke_2;
  v14[3] = &unk_24D5DC9D0;
  v14[4] = v15;
  if (!*v12)
    *v12 = 1;
  if (capabilities::ct::supportsDataQMIExtensions((capabilities::ct *)v11))
  {
    (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 96) + 256))(*(_QWORD *)(a1 + 96), 255);
    (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 112) + 256))(*(_QWORD *)(a1 + 112), 255);
  }
  ___ZN31Mav16QMIDataContextIPAggregator21createProfileIfNeededERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE_block_invoke_2((uint64_t)v14, 0);
  if (capabilities::ct::supportsCapabilityC2KDevice(v13))
    ___ZN31Mav16QMIDataContextIPAggregator21createProfileIfNeededERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE_block_invoke_2((uint64_t)v14, 1);
  return 1;
}

void ___ZN31Mav16QMIDataContextIPAggregator21createProfileIfNeededERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE_block_invoke(uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  const void *v4;
  void *v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  const void *v11;
  void *v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t *v16;
  unint64_t v17;

  v3 = *(_QWORD **)(a1 + 32);
  v4 = (const void *)v3[12];
  if (v4)
  {
    if (v5)
    {
      v6 = (std::__shared_weak_count *)v3[13];
      if (v6)
      {
        p_shared_owners = (unint64_t *)&v6->__shared_owners_;
        do
          v8 = __ldxr(p_shared_owners);
        while (__stxr(v8 + 1, p_shared_owners));
      }
      (*(void (**)(void *, uint64_t))(*(_QWORD *)v5 + 16))(v5, a2);
      if (v6)
      {
        v9 = (unint64_t *)&v6->__shared_owners_;
        do
          v10 = __ldaxr(v9);
        while (__stlxr(v10 - 1, v9));
        if (!v10)
        {
          ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
          std::__shared_weak_count::__release_weak(v6);
        }
      }
    }
  }
  v11 = (const void *)v3[14];
  if (v11)
  {
    if (v12)
    {
      v13 = (std::__shared_weak_count *)v3[15];
      if (v13)
      {
        v14 = (unint64_t *)&v13->__shared_owners_;
        do
          v15 = __ldxr(v14);
        while (__stxr(v15 + 1, v14));
      }
      (*(void (**)(void *, uint64_t))(*(_QWORD *)v12 + 16))(v12, a2);
      if (v13)
      {
        v16 = (unint64_t *)&v13->__shared_owners_;
        do
          v17 = __ldaxr(v16);
        while (__stlxr(v17 - 1, v16));
        if (!v17)
        {
          ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
          std::__shared_weak_count::__release_weak(v13);
        }
      }
    }
  }
}

void sub_2169EADF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void ___ZN31Mav16QMIDataContextIPAggregator21createProfileIfNeededERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE_block_invoke_2(uint64_t a1, int a2)
{
  uint64_t v4;
  const void **v5;
  const void **v6;
  const void **v7;
  char *v8;
  _BYTE *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  char *v16;
  const void **v17;
  char *v18;
  char *v19;
  char *v20;
  const void *v21;
  char *v22;
  _BYTE *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  char *v31;
  uint64_t *v32;
  char *v33;
  char *v34;
  char *v35;
  uint64_t v36;
  std::__shared_weak_count *v37;
  int v38;
  int v39;
  unint64_t *p_shared_owners;
  unint64_t v41;
  const void **v42;
  char *v43;
  _QWORD *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  _QWORD *v48;
  uint64_t v49;
  unint64_t v50;
  unint64_t v51;
  char *v52;
  uint64_t *v53;
  char *v54;
  char *v55;
  char *v56;
  uint64_t v57;
  void *v58;
  _QWORD v59[6];
  int v60;
  uint64_t v61;
  uint64_t v62;
  int v63;
  uint64_t v64;
  void *v65;
  void *__p[2];
  __int128 v67;
  uint64_t aBlock;
  uint64_t v69;
  void (*v70)(uint64_t, QMIServiceMsg *);
  void *v71;
  _QWORD *v72;

  v4 = *(_QWORD *)(a1 + 40);
  *(_OWORD *)__p = 0u;
  v67 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  v5 = (const void **)__p[1];
  v6 = (const void **)v67;
  v7 = (const void **)__p[1];
  if (__p[1] != (void *)v67)
  {
    v7 = (const void **)__p[1];
    while (*((_BYTE *)*v7 + 8) != 1)
    {
      if (++v7 == (const void **)v67)
        goto LABEL_9;
    }
  }
  if (v7 == (const void **)v67)
  {
LABEL_9:
    v10 = operator new();
    v11 = v10;
    *(_WORD *)(v10 + 8) = 1;
    *(_QWORD *)v10 = &off_24D5DD160;
    v12 = v67;
    if ((unint64_t)v67 >= *((_QWORD *)&v67 + 1))
    {
      v13 = (uint64_t)(v67 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v13 + 1) >> 61)
        goto LABEL_87;
      v14 = (uint64_t)(*((_QWORD *)&v67 + 1) - (unint64_t)__p[1]) >> 2;
      if (v14 <= v13 + 1)
        v14 = v13 + 1;
      if (*((_QWORD *)&v67 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v15 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v15 = v14;
      if (v15)
        v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v67 + 8, v15);
      else
        v16 = 0;
      v17 = (const void **)&v16[8 * v13];
      v18 = &v16[8 * v15];
      *v17 = (const void *)v11;
      v6 = v17 + 1;
      v20 = (char *)__p[1];
      v19 = (char *)v67;
      if ((void *)v67 != __p[1])
      {
        do
        {
          v21 = (const void *)*((_QWORD *)v19 - 1);
          v19 -= 8;
          *--v17 = v21;
        }
        while (v19 != v20);
        v19 = (char *)__p[1];
      }
      __p[1] = v17;
      *(_QWORD *)&v67 = v6;
      *((_QWORD *)&v67 + 1) = v18;
      if (v19)
        operator delete(v19);
    }
    else
    {
      *(_QWORD *)v67 = v10;
      v6 = (const void **)(v12 + 8);
    }
    v9 = (_BYTE *)(v11 + 9);
    *(_QWORD *)&v67 = v6;
    v5 = (const void **)__p[1];
  }
  else
  {
    if (!v8)
      goto LABEL_86;
    v9 = v8 + 9;
  }
  *v9 = a2;
  while (1)
  {
    if (v5 == v6)
      goto LABEL_33;
    if (*((unsigned __int8 *)*v5 + 8) == 143)
      break;
    ++v5;
  }
  if (v5 == v6)
  {
LABEL_33:
    v24 = operator new();
    v25 = v24;
    *(_WORD *)(v24 + 8) = 143;
    *(_QWORD *)v24 = &off_24D5DD1B0;
    v26 = v67;
    if ((unint64_t)v67 >= *((_QWORD *)&v67 + 1))
    {
      v28 = (uint64_t)(v67 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v28 + 1) >> 61)
        goto LABEL_87;
      v29 = (uint64_t)(*((_QWORD *)&v67 + 1) - (unint64_t)__p[1]) >> 2;
      if (v29 <= v28 + 1)
        v29 = v28 + 1;
      if (*((_QWORD *)&v67 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v30 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v30 = v29;
      if (v30)
        v31 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v67 + 8, v30);
      else
        v31 = 0;
      v32 = (uint64_t *)&v31[8 * v28];
      v33 = &v31[8 * v30];
      *v32 = v25;
      v27 = v32 + 1;
      v35 = (char *)__p[1];
      v34 = (char *)v67;
      if ((void *)v67 != __p[1])
      {
        do
        {
          v36 = *((_QWORD *)v34 - 1);
          v34 -= 8;
          *--v32 = v36;
        }
        while (v34 != v35);
        v34 = (char *)__p[1];
      }
      __p[1] = v32;
      *(_QWORD *)&v67 = v27;
      *((_QWORD *)&v67 + 1) = v33;
      if (v34)
        operator delete(v34);
    }
    else
    {
      *(_QWORD *)v67 = v24;
      v27 = (_QWORD *)(v26 + 8);
    }
    v23 = (_BYTE *)(v25 + 9);
    *(_QWORD *)&v67 = v27;
  }
  else
  {
    if (!v22)
      goto LABEL_86;
    v23 = v22 + 9;
  }
  *v23 = 0;
  v37 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v4 + 88));
  aBlock = *(_QWORD *)(v4 + 80);
  v69 = (uint64_t)v37;
  v38 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)aBlock + 416))(aBlock);
  v39 = v38;
  p_shared_owners = (unint64_t *)&v37->__shared_owners_;
  do
    v41 = __ldaxr(p_shared_owners);
  while (__stlxr(v41 - 1, p_shared_owners));
  if (!v41)
  {
    ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
    std::__shared_weak_count::__release_weak(v37);
    if (!v39)
      goto LABEL_81;
    goto LABEL_56;
  }
  if (v38)
  {
LABEL_56:
    v42 = (const void **)__p[1];
    if (__p[1] != (void *)v67)
    {
      while (*((unsigned __int8 *)*v42 + 8) != 221)
      {
        if (++v42 == (const void **)v67)
          goto LABEL_63;
      }
    }
    if (v42 != (const void **)v67)
    {
      if (v43)
      {
        v44 = v43 + 16;
LABEL_80:
        *v44 = 1;
        goto LABEL_81;
      }
LABEL_86:
      __cxa_bad_cast();
    }
LABEL_63:
    v45 = operator new();
    v46 = v45;
    *(_BYTE *)(v45 + 8) = -35;
    *(_QWORD *)v45 = &off_24D5DD200;
    *(_QWORD *)(v45 + 16) = 0;
    v44 = (_QWORD *)(v45 + 16);
    v47 = v67;
    if ((unint64_t)v67 < *((_QWORD *)&v67 + 1))
    {
      *(_QWORD *)v67 = v45;
      v48 = (_QWORD *)(v47 + 8);
LABEL_79:
      *(_QWORD *)&v67 = v48;
      goto LABEL_80;
    }
    v49 = (uint64_t)(v67 - (unint64_t)__p[1]) >> 3;
    if (!((unint64_t)(v49 + 1) >> 61))
    {
      v50 = (uint64_t)(*((_QWORD *)&v67 + 1) - (unint64_t)__p[1]) >> 2;
      if (v50 <= v49 + 1)
        v50 = v49 + 1;
      if (*((_QWORD *)&v67 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v51 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v51 = v50;
      if (v51)
        v52 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v67 + 8, v51);
      else
        v52 = 0;
      v53 = (uint64_t *)&v52[8 * v49];
      v54 = &v52[8 * v51];
      *v53 = v46;
      v48 = v53 + 1;
      v56 = (char *)__p[1];
      v55 = (char *)v67;
      if ((void *)v67 != __p[1])
      {
        do
        {
          v57 = *((_QWORD *)v55 - 1);
          v55 -= 8;
          *--v53 = v57;
        }
        while (v55 != v56);
        v55 = (char *)__p[1];
      }
      __p[1] = v53;
      *(_QWORD *)&v67 = v48;
      *((_QWORD *)&v67 + 1) = v54;
      if (v55)
        operator delete(v55);
      goto LABEL_79;
    }
LABEL_87:
    std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
  }
LABEL_81:
  v61 = v4 + 320;
  v62 = QMIServiceMsg::create();
  v63 = 25000;
  v64 = 0;
  v65 = 0;
  v59[0] = MEMORY[0x24BDAC760];
  v59[1] = 0x40000000;
  v59[2] = ___ZN31Mav16QMIDataContextIPAggregator21createProfileIfNeededERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE_block_invoke_6;
  v59[3] = &unk_24D5DC9A8;
  v60 = a2;
  v59[4] = *(_QWORD *)(a1 + 32);
  v59[5] = v4;
  aBlock = MEMORY[0x24BDAC760];
  v69 = 0x40000000;
  v70 = ___ZNO3qmi6Client9SendProxy8callbackIRKN3wds13CreateProfile8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
  v71 = &unk_24D5DD230;
  v72 = v59;
  v58 = _Block_copy(&aBlock);
  v65 = v58;
  if (v62)
  {
    qmi::Client::send();
    v58 = v65;
  }
  if (v58)
    _Block_release(v58);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
}

void sub_2169EB348(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  uint64_t v9;
  va_list va;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a8);
  va_start(va, a8);
  v9 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)va);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va1);
  _Unwind_Resume(a1);
}

void ___ZN31Mav16QMIDataContextIPAggregator21createProfileIfNeededERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE_block_invoke_6(uint64_t a1, qmi::MessageBase *this)
{
  uint64_t v4;
  NSObject *v5;
  const char *v6;
  int v7;
  uint64_t v8;
  uint64_t TlvValue;
  int v10;
  uint64_t v11;
  int v12;
  _QWORD v13[6];
  int v14;
  uint64_t v15;
  _BYTE buf[12];
  __int16 v17;
  const char *v18;
  __int16 v19;
  int v20;
  __int16 v21;
  uint64_t v22;
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)(a1 + 40);
  if (*((_DWORD *)this + 1))
  {
    v5 = *(NSObject **)(v4 + 56);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = wds::asString(*(_DWORD *)(a1 + 48));
      v7 = *((_DWORD *)this + 1);
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = "createProfileIfNeeded_block_invoke_6";
      v17 = 2080;
      v18 = v6;
      v19 = 1024;
      v20 = v7;
      v21 = 2080;
      v22 = qmi::asString();
      _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#I %s: Failed to create profile %s. Error: 0x%x (%s). Profiles are reset", buf, 0x26u);
    }
    v8 = *(_QWORD *)(v4 + 352);
    *(_WORD *)v8 = 0;
    *(_DWORD *)(v8 + 2) = -1;
    (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  }
  else
  {
    v13[0] = MEMORY[0x24BDAC760];
    v13[1] = 0x40000000;
    v13[2] = ___ZN31Mav16QMIDataContextIPAggregator21createProfileIfNeededERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE_block_invoke_31;
    v13[3] = &unk_24D5DC980;
    v14 = *(_DWORD *)(a1 + 48);
    v13[4] = *(_QWORD *)(a1 + 32);
    v13[5] = v4;
    TlvValue = qmi::MessageBase::findTlvValue(this);
    if (TlvValue)
    {
      v11 = TlvValue;
      v12 = v10;
      *(_QWORD *)buf = TlvValue;
      v15 = tlv::parseV<wds::tlv::ProfileId>((unint64_t *)buf, v10);
      if (*(_QWORD *)buf)
        ___ZN31Mav16QMIDataContextIPAggregator21createProfileIfNeededERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE_block_invoke_31((uint64_t)v13, (uint64_t)&v15);
      else
        ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)this, 1, v11, v12);
    }
  }
}

void ___ZN31Mav16QMIDataContextIPAggregator21createProfileIfNeededERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE_block_invoke_31(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  NSObject *v5;
  _BOOL8 v6;
  const char *v7;
  int v8;
  int v9;
  NSObject *v10;
  const char *v11;
  int v12;
  _BYTE *v13;
  int v14;
  int v15;
  NSObject *v16;
  int v17;
  const char *v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  int v22;
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)(a1 + 40);
  v5 = *(NSObject **)(v4 + 56);
  v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (v6)
  {
    v7 = wds::asString(*(_DWORD *)(a1 + 48));
    v8 = *(unsigned __int8 *)(a2 + 4);
    v17 = 136315650;
    v18 = "createProfileIfNeeded_block_invoke";
    v19 = 2080;
    v20 = v7;
    v21 = 1024;
    v22 = v8;
    _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#I %s: Profile %s is assigned profileID: %d", (uint8_t *)&v17, 0x1Cu);
  }
  v9 = *(_DWORD *)(a1 + 48);
  if (v9 == 1)
  {
    *(_BYTE *)(*(_QWORD *)(v4 + 352) + 4) = *(_BYTE *)(a2 + 4);
  }
  else if (v9)
  {
    v10 = *(NSObject **)(v4 + 56);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      v11 = wds::asString(v9);
      v12 = *(unsigned __int8 *)(a2 + 4);
      v17 = 136315650;
      v18 = "createProfileIfNeeded_block_invoke";
      v19 = 2080;
      v20 = v11;
      v21 = 1024;
      v22 = v12;
      _os_log_impl(&dword_216897000, v10, OS_LOG_TYPE_DEFAULT, "#I %s: Unknown profile %s is assigned profileID: %d", (uint8_t *)&v17, 0x1Cu);
    }
  }
  else
  {
    *(_BYTE *)(*(_QWORD *)(v4 + 352) + 2) = *(_BYTE *)(a2 + 4);
    if (capabilities::ct::supportsDataQMIExtensions((capabilities::ct *)v6))
    {
      (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)(v4 + 96) + 256))(*(_QWORD *)(v4 + 96), *(unsigned __int8 *)(a2 + 4));
      (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)(v4 + 112) + 256))(*(_QWORD *)(v4 + 112), *(unsigned __int8 *)(a2 + 4));
    }
  }
  v13 = *(_BYTE **)(v4 + 352);
  v14 = v13[3];
  if (v14 != 254 && v13[2] == 255
    || (v15 = v13[5], v15 != 254) && v13[4] == 255)
  {
    v16 = *(NSObject **)(v4 + 56);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      v17 = 136315138;
      v18 = "createProfileIfNeeded_block_invoke";
      _os_log_impl(&dword_216897000, v16, OS_LOG_TYPE_DEFAULT, "#I %s: Still waiting for more profile creation result", (uint8_t *)&v17, 0xCu);
    }
  }
  else if ((v14 == 254 || v13[2] != 255) && (v15 == 254 || v13[4] != 255))
  {
    if (*v13)
      *v13 = 0;
    (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  }
}

uint64_t `non-virtual thunk to'Mav16QMIDataContextIPAggregator::createProfileIfNeeded(uint64_t a1, uint64_t *a2)
{
  return Mav16QMIDataContextIPAggregator::createProfileIfNeeded(a1 - 288, a2);
}

uint64_t Mav16QMIDataContextIPAggregator::isReconfigurationNeeded(Mav16QMIDataContextIPAggregator *this)
{
  int v2;
  int v3;
  uint64_t v4;
  int v5;
  uint64_t result;

  v2 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 12) + 96))(*((_QWORD *)this + 12));
  v3 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 14) + 96))(*((_QWORD *)this + 14));
  v4 = 112;
  if (v2 > v3)
    v4 = 96;
  v5 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)((char *)this + v4) + 96))(*(_QWORD *)((char *)this + v4));
  LODWORD(result) = (*(uint64_t (**)(Mav16QMIDataContextIPAggregator *))(*(_QWORD *)this + 304))(this);
  if (v5)
    return result;
  else
    return 1;
}

uint64_t `non-virtual thunk to'Mav16QMIDataContextIPAggregator::isReconfigurationNeeded(Mav16QMIDataContextIPAggregator *this)
{
  char *v2;
  int v3;
  int v4;
  uint64_t v5;
  int v6;
  uint64_t result;

  v2 = (char *)this - 288;
  v3 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this - 24) + 96))(*((_QWORD *)this - 24));
  v4 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this - 22) + 96))(*((_QWORD *)this - 22));
  v5 = -176;
  if (v3 > v4)
    v5 = -192;
  v6 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)((char *)this + v5) + 96))(*(_QWORD *)((char *)this + v5));
  LODWORD(result) = (*(uint64_t (**)(char *))(*(_QWORD *)v2 + 304))(v2);
  if (v6)
    return result;
  else
    return 1;
}

uint64_t Mav16QMIDataContextIPAggregator::configureProfileIfNeeded(uint64_t a1, uint64_t *a2, int a3)
{
  _BYTE *v3;
  uint64_t v4;
  NSObject *v8;
  int v9;
  int v10;
  NSObject *v11;
  uint64_t *v12;
  uint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *p_shared_owners;
  unint64_t v18;
  std::__shared_weak_count *v19;
  int v20;
  unint64_t *v21;
  unint64_t v22;
  unint64_t *v23;
  unint64_t v24;
  _BYTE *v25;
  unint64_t *v26;
  unint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  std::__shared_weak_count *v37;
  unint64_t *v38;
  unint64_t v39;
  NSObject *v40;
  _QWORD v41[2];
  uint64_t (*v42)(uint64_t, int, char);
  void *v43;
  uint64_t v44;
  uint64_t v45;
  std::__shared_weak_count *v46;
  uint64_t v47;
  std::__shared_weak_count *v48;
  int v49;
  uint64_t v50;
  std::__shared_weak_count *v51;
  uint64_t v52;
  std::__shared_weak_count *v53;
  _BYTE buf[22];
  uint64_t v55;

  v55 = *MEMORY[0x24BDAC8D0];
  v3 = *(_BYTE **)(a1 + 352);
  if (v3[1])
    return 1;
  if (a3)
  {
    v8 = *(NSObject **)(a1 + 56);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = "configureProfileIfNeeded";
      _os_log_impl(&dword_216897000, v8, OS_LOG_TYPE_DEFAULT, "#I %s: No IP family active. Reset profiles", buf, 0xCu);
      v3 = *(_BYTE **)(a1 + 352);
    }
    v3[3] = -1;
    v3[5] = -1;
    goto LABEL_14;
  }
  v9 = v3[3];
  if (v9 == 254)
  {
    v10 = v3[5];
    if (v10 != 254)
      goto LABEL_12;
  }
  else if (v9 == 1)
  {
    v10 = v3[5];
LABEL_12:
    v4 = 0;
    if (v10 == 1 || v10 == 254)
      return v4;
  }
LABEL_14:
  v11 = *(NSObject **)(a1 + 56);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) >= 0)
      v12 = a2;
    else
      v12 = (uint64_t *)*a2;
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = "configureProfileIfNeeded";
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = v12;
    _os_log_impl(&dword_216897000, v11, OS_LOG_TYPE_DEFAULT, "#I %s: %s Profiles not yet configured", buf, 0x16u);
  }
  if (*(_QWORD *)(a1 + 336))
  {
    v13 = *(_QWORD *)(a1 + 360);
    *(_QWORD *)buf = *(_QWORD *)(a1 + 352);
    *(_QWORD *)&buf[8] = v13;
    if (v13)
    {
      v14 = (unint64_t *)(v13 + 8);
      do
        v15 = __ldxr(v14);
      while (__stxr(v15 + 1, v14));
    }
    v52 = 0;
    v53 = 0;
    v16 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(a1 + 88));
    v50 = *(_QWORD *)(a1 + 80);
    v51 = v16;
    (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v50 + 32))(&v52);
    p_shared_owners = (unint64_t *)&v16->__shared_owners_;
    do
      v18 = __ldaxr(p_shared_owners);
    while (__stlxr(v18 - 1, p_shared_owners));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
    v19 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(a1 + 88));
    v50 = *(_QWORD *)(a1 + 80);
    v51 = v19;
    v20 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v50 + 24))(v50);
    v21 = (unint64_t *)&v19->__shared_owners_;
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
    v41[0] = MEMORY[0x24BDAC760];
    v41[1] = 1174405120;
    v42 = ___ZN31Mav16QMIDataContextIPAggregator24configureProfileIfNeededERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEEb_block_invoke;
    v43 = &__block_descriptor_tmp_46_6;
    v44 = a1;
    v45 = v52;
    v46 = v53;
    if (v53)
    {
      v23 = (unint64_t *)&v53->__shared_owners_;
      do
        v24 = __ldxr(v23);
      while (__stxr(v24 + 1, v23));
    }
    v49 = v20;
    v25 = *(_BYTE **)buf;
    v47 = *(_QWORD *)buf;
    v48 = *(std::__shared_weak_count **)&buf[8];
    if (*(_QWORD *)&buf[8])
    {
      v26 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
      do
        v27 = __ldxr(v26);
      while (__stxr(v27 + 1, v26));
    }
    if (___ZN31Mav16QMIDataContextIPAggregator24configureProfileIfNeededERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEEb_block_invoke((uint64_t)v41, 0, v25[2])&& v42((uint64_t)v41, 1, v25[4]))
    {
      v4 = 1;
      if (!v25[1])
        v25[1] = 1;
    }
    else
    {
      v4 = 2;
    }
    v28 = v48;
    if (v48)
    {
      v29 = (unint64_t *)&v48->__shared_owners_;
      do
        v30 = __ldaxr(v29);
      while (__stlxr(v30 - 1, v29));
      if (!v30)
      {
        ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
        std::__shared_weak_count::__release_weak(v28);
      }
    }
    v31 = v46;
    if (v46)
    {
      v32 = (unint64_t *)&v46->__shared_owners_;
      do
        v33 = __ldaxr(v32);
      while (__stlxr(v33 - 1, v32));
      if (!v33)
      {
        ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
        std::__shared_weak_count::__release_weak(v31);
      }
    }
    v34 = v53;
    if (v53)
    {
      v35 = (unint64_t *)&v53->__shared_owners_;
      do
        v36 = __ldaxr(v35);
      while (__stlxr(v36 - 1, v35));
      if (!v36)
      {
        ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
        std::__shared_weak_count::__release_weak(v34);
      }
    }
    v37 = *(std::__shared_weak_count **)&buf[8];
    if (*(_QWORD *)&buf[8])
    {
      v38 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
      do
        v39 = __ldaxr(v38);
      while (__stlxr(v39 - 1, v38));
      if (!v39)
      {
        ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
        std::__shared_weak_count::__release_weak(v37);
      }
    }
  }
  else
  {
    v40 = *(NSObject **)(a1 + 56);
    if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = "configureProfileIfNeeded";
      _os_log_impl(&dword_216897000, v40, OS_LOG_TYPE_DEFAULT, "#I %s: Invalid WDS client. Cannot configure profiles", buf, 0xCu);
    }
    return 2;
  }
  return v4;
}

void sub_2169EBD18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  uint64_t v11;
  va_list va;

  va_start(va, a11);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v11 - 80);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v11 - 64);
  _Unwind_Resume(a1);
}

uint64_t ___ZN31Mav16QMIDataContextIPAggregator24configureProfileIfNeededERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEEb_block_invoke(uint64_t a1, int a2, char a3)
{
  unint64_t v6;
  capabilities::ct *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  std::__shared_weak_count *v11;
  uint64_t v12;
  int v13;
  unint64_t *p_shared_owners;
  unint64_t v15;
  NSObject *v16;
  uint64_t v17;
  const char *v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  BOOL *v22;
  CFTypeID v23;
  const __CFBoolean *v24;
  NSObject *v25;
  int v26;
  NSObject *v27;
  NSObject *v28;
  void *v29;
  NSObject *v30;
  std::__shared_weak_count *v31;
  void *p_cf;
  uint64_t v33;
  uint64_t v34;
  unint64_t *v35;
  unint64_t v36;
  NSObject *v38;
  _QWORD v39[5];
  int v40;
  char v41;
  CFTypeRef cf;
  uint64_t v43;
  int v44;
  char v45;
  uint64_t v46;
  void *aBlock;
  _OWORD v48[2];
  _BYTE buf[24];
  void *v50;
  _QWORD *v51;
  uint64_t v52;

  v52 = *MEMORY[0x24BDAC8D0];
  v6 = *(_QWORD *)(a1 + 32);
  memset(v48, 0, sizeof(v48));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v48);
  v7 = (capabilities::ct *)qmi::MutableMessageBase::getTLV<wds::tlv::ProfileId>(v48, 1);
  *(_DWORD *)v7 = a2;
  *((_BYTE *)v7 + 4) = a3;
  if (*(_QWORD *)(a1 + 40) && capabilities::ct::supportsDataQMIExtensions(v7))
  {
    v8 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD))(**(_QWORD **)(a1 + 40) + 216))(*(_QWORD *)(a1 + 40), 0, 0, 0);
    v9 = (*(uint64_t (**)(_QWORD, uint64_t, _QWORD, _QWORD))(**(_QWORD **)(a1 + 40) + 216))(*(_QWORD *)(a1 + 40), 1, 0, 0);
    v10 = (_QWORD *)qmi::MutableMessageBase::getTLV<wds::tlv::ApnTypeMask>(v48, 221);
    *v10 = (*(uint64_t (**)(unint64_t, uint64_t))(*(_QWORD *)v6 + 704))(v6, v9 | v8);
  }
  v11 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v6 + 88));
  *(_QWORD *)buf = *(_QWORD *)(v6 + 80);
  *(_QWORD *)&buf[8] = v11;
  v12 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)buf + 256))(*(_QWORD *)buf);
  v13 = v12;
  p_shared_owners = (unint64_t *)&v11->__shared_owners_;
  do
    v15 = __ldaxr(p_shared_owners);
  while (__stlxr(v15 - 1, p_shared_owners));
  if (!v15)
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  switch(v13)
  {
    case 0:
      v12 = *(_QWORD *)(a1 + 40);
      if (!v12)
        goto LABEL_15;
      v12 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v12 + 88))(v12, 0);
      if ((v12 & 1) != 0)
        goto LABEL_15;
      v16 = *(NSObject **)(v6 + 56);
      v17 = 0;
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315138;
        *(_QWORD *)&buf[4] = "configureProfileIfNeeded_block_invoke";
        v18 = "#I %s: Wrong wireless technology, can't activate";
        goto LABEL_49;
      }
      goto LABEL_68;
    case 1:
      if (a2)
        goto LABEL_31;
      v26 = 1;
      goto LABEL_45;
    case 2:
      if (a2 == 1)
      {
        if ((capabilities::ct::supportsCapabilityeHRPDDevice((capabilities::ct *)v12) & 1) != 0)
LABEL_41:
          Mav16QMIDataContextIPAggregator::set3GPP2Parameters(v6, v48, *(_DWORD *)(a1 + 72));
        else
          *qmi::MutableMessageBase::getTLV<wds::tlv::Profile3GPP2_AuthPref>(v48) = 2;
      }
      else
      {
        if (a2)
          goto LABEL_35;
LABEL_46:
        Mav16QMIDataContextIPAggregator::set3GPPParameters(v6, v48, *(_DWORD *)(a1 + 72), 0, 0);
      }
      goto LABEL_53;
    case 3:
      if (!a2)
        goto LABEL_46;
      if (a2 == 1)
        goto LABEL_41;
      goto LABEL_35;
    case 4:
LABEL_15:
      if (!a2)
        goto LABEL_29;
      if (a2 != 1)
        goto LABEL_35;
      if (capabilities::ct::supportsCapabilityeHRPDDevice((capabilities::ct *)v12))
      {
        cf = 0;
        v19 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v6 + 88));
        *(_QWORD *)buf = *(_QWORD *)(v6 + 80);
        *(_QWORD *)&buf[8] = v19;
        (*(void (**)(CFTypeRef *__return_ptr, _QWORD, const __CFString *, _QWORD, _QWORD))(**(_QWORD **)buf + 368))(&cf, *(_QWORD *)buf, CFSTR("SupportsEHRPD"), *MEMORY[0x24BDBD268], 0);
        v20 = (unint64_t *)&v19->__shared_owners_;
        do
          v21 = __ldaxr(v20);
        while (__stlxr(v21 - 1, v20));
        if (!v21)
        {
          ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
          std::__shared_weak_count::__release_weak(v19);
        }
        v22 = (BOOL *)cf;
        buf[0] = 0;
        if (cf)
        {
          v23 = CFGetTypeID(cf);
          if (v23 == CFBooleanGetTypeID())
            ctu::cf::assign((ctu::cf *)buf, v22, v24);
          if (buf[0])
          {
            v25 = *(NSObject **)(v6 + 56);
            if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136315138;
              *(_QWORD *)&buf[4] = "configureProfileIfNeeded_block_invoke";
              _os_log_impl(&dword_216897000, v25, OS_LOG_TYPE_DEFAULT, "#I %s: The device supports eHRPD Capability and  carrier too filling 3GPP2 parameters", buf, 0xCu);
            }
            Mav16QMIDataContextIPAggregator::set3GPP2Parameters(v6, v48, *(_DWORD *)(a1 + 72));
            ctu::SharedRef<void const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,void const>::~SharedRef(&cf);
            goto LABEL_53;
          }
        }
        v38 = *(NSObject **)(v6 + 56);
        if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315138;
          *(_QWORD *)&buf[4] = "configureProfileIfNeeded_block_invoke";
          _os_log_impl(&dword_216897000, v38, OS_LOG_TYPE_DEFAULT, "#I %s: The device supports eHRPD Capability but carrier doesn't. No need to fill 3GPP2 parameters", buf, 0xCu);
        }
        ctu::SharedRef<void const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,void const>::~SharedRef(&cf);
      }
      else
      {
        v28 = *(NSObject **)(v6 + 56);
        if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315138;
          *(_QWORD *)&buf[4] = "configureProfileIfNeeded_block_invoke";
          _os_log_impl(&dword_216897000, v28, OS_LOG_TYPE_DEFAULT, "#I %s: The device doesn't support eHRPD Capability No need to fill 3GPP2 parameters", buf, 0xCu);
        }
      }
      goto LABEL_32;
    case 5:
    case 6:
      if (a2)
      {
LABEL_31:
        if (a2 == 1)
        {
LABEL_32:
          v27 = *(NSObject **)(v6 + 56);
          if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315138;
            *(_QWORD *)&buf[4] = "configureProfileIfNeeded_block_invoke";
            _os_log_impl(&dword_216897000, v27, OS_LOG_TYPE_DEFAULT, "#I %s: 3GPP2 profile activation not needed", buf, 0xCu);
          }
          *(_BYTE *)(*(_QWORD *)(a1 + 56) + 5) = -2;
        }
LABEL_35:
        Mav16QMIDataContextIPAggregator::handleProfileConfiguredResult(v6, a2, 0, 0);
      }
      else
      {
LABEL_29:
        v26 = 0;
LABEL_45:
        Mav16QMIDataContextIPAggregator::set3GPPParameters(v6, v48, *(_DWORD *)(a1 + 72), v26, 1);
LABEL_53:
        cf = (CFTypeRef)(v6 + 320);
        v43 = QMIServiceMsg::create();
        v46 = 0;
        aBlock = 0;
        v44 = 210000;
        v39[0] = MEMORY[0x24BDAC760];
        v39[1] = 0x40000000;
        v39[2] = ___ZN31Mav16QMIDataContextIPAggregator24configureProfileIfNeededERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEEb_block_invoke_43;
        v39[3] = &__block_descriptor_tmp_44_7;
        v39[4] = v6;
        v40 = a2;
        v41 = a3;
        *(_QWORD *)buf = MEMORY[0x24BDAC760];
        *(_QWORD *)&buf[8] = 0x40000000;
        *(_QWORD *)&buf[16] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3wds29ResetAndModifyProfileSettings8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
        v50 = &unk_24D5DD2A8;
        v51 = v39;
        v29 = _Block_copy(buf);
        aBlock = v29;
        if (v43)
        {
          qmi::Client::send();
          v29 = aBlock;
        }
        if (v29)
          _Block_release(v29);
        v30 = *(NSObject **)(v6 + 56);
        if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
        {
          v31 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v6 + 88));
          (*(void (**)(CFTypeRef *__return_ptr))(**(_QWORD **)(v6 + 80) + 312))(&cf);
          if (v45 >= 0)
            p_cf = &cf;
          else
            p_cf = (void *)cf;
          v33 = asString();
          v34 = asStringBool();
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = p_cf;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = v33;
          *(_WORD *)&buf[22] = 2080;
          v50 = (void *)v34;
          _os_log_impl(&dword_216897000, v30, OS_LOG_TYPE_DEFAULT, "#I configureProfileIfNeeded: apn=%{public}s: sent ResetAndModifyProfileSettings tech=%s eHRPD=%s", buf, 0x20u);
          if (v45 < 0)
            operator delete((void *)cf);
          v35 = (unint64_t *)&v31->__shared_owners_;
          do
            v36 = __ldaxr(v35);
          while (__stlxr(v36 - 1, v35));
          if (!v36)
          {
            ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
            std::__shared_weak_count::__release_weak(v31);
          }
        }
      }
      v17 = 1;
LABEL_68:
      qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v48);
      return v17;
    default:
      v16 = *(NSObject **)(v6 + 56);
      v17 = 0;
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315138;
        *(_QWORD *)&buf[4] = "configureProfileIfNeeded_block_invoke";
        v18 = "#I %s: Wrong wireless technology";
LABEL_49:
        _os_log_impl(&dword_216897000, v16, OS_LOG_TYPE_DEFAULT, v18, buf, 0xCu);
        v17 = 0;
      }
      goto LABEL_68;
  }
}

void sub_2169EC460(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,char a26)
{
  uint64_t v26;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v26 - 128);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a26);
  _Unwind_Resume(a1);
}

void Mav16QMIDataContextIPAggregator::set3GPPParameters(unint64_t a1, _QWORD *a2, int a3, int a4, int a5)
{
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  capabilities::ct *v13;
  std::string *v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  NSObject *v18;
  int v19;
  std::string::size_type v20;
  std::string *v21;
  std::string *v22;
  const void **v23;
  const void **v24;
  char **v25;
  char *v26;
  std::string *v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t *v30;
  _QWORD *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  char *v36;
  uint64_t *v37;
  char *v38;
  char *v39;
  char *v40;
  uint64_t v41;
  const void **v42;
  const void **v43;
  char **v44;
  int *v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t *v48;
  _QWORD *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  unint64_t v53;
  char *v54;
  uint64_t *v55;
  char *v56;
  char *v57;
  char *v58;
  uint64_t v59;
  const void **v60;
  const void **v61;
  char *v62;
  std::string *v63;
  uint64_t v64;
  unint64_t v65;
  uint64_t *v66;
  _QWORD *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  unint64_t v71;
  char *v72;
  uint64_t *v73;
  char *v74;
  char *v75;
  char *v76;
  uint64_t v77;
  const void **v78;
  const void **v79;
  char *v80;
  std::string *v81;
  uint64_t v82;
  unint64_t v83;
  uint64_t *v84;
  _QWORD *v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  unint64_t v89;
  char *v90;
  uint64_t *v91;
  char *v92;
  char *v93;
  char *v94;
  uint64_t v95;
  NSObject *v96;
  uint64_t v97;
  std::string::size_type size;
  std::string::size_type v99;
  unint64_t *v100;
  unint64_t v101;
  const void **v102;
  const void **v103;
  char *v104;
  char *v105;
  uint64_t v106;
  unint64_t v107;
  uint64_t *v108;
  _QWORD *v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  unint64_t v113;
  char *v114;
  uint64_t *v115;
  char *v116;
  char *v117;
  char *v118;
  uint64_t v119;
  std::__shared_weak_count *v120;
  unint64_t *v121;
  unint64_t v122;
  NSObject *v123;
  int v124;
  const void **v125;
  const void **v126;
  char *v127;
  _BYTE *v128;
  uint64_t v129;
  unint64_t v130;
  uint64_t *v131;
  _QWORD *v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  unint64_t v136;
  char *v137;
  uint64_t *v138;
  char *v139;
  char *v140;
  char *v141;
  uint64_t v142;
  std::__shared_weak_count *v143;
  unint64_t *v144;
  unint64_t v145;
  BOOL *v146;
  CFTypeID v147;
  const __CFBoolean *v148;
  NSObject *v149;
  const void **v150;
  const void **v151;
  NSObject *v152;
  char *v153;
  char *v154;
  uint64_t v155;
  unint64_t v156;
  uint64_t *v157;
  _QWORD *v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  unint64_t v162;
  char *v163;
  uint64_t *v164;
  char *v165;
  char *v166;
  char *v167;
  uint64_t v168;
  std::__shared_weak_count *v169;
  int v170;
  unint64_t *v171;
  unint64_t v172;
  NSObject *v173;
  const void **v174;
  const void **v175;
  char *v176;
  _BYTE *v177;
  uint64_t v178;
  unint64_t v179;
  uint64_t *v180;
  _QWORD *v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  unint64_t v185;
  char *v186;
  uint64_t *v187;
  char *v188;
  char *v189;
  char *v190;
  uint64_t v191;
  capabilities::ct *v192;
  NSObject *v193;
  unint64_t *v194;
  unint64_t v195;
  const void **v196;
  const void **v197;
  char *v198;
  _WORD *v199;
  uint64_t v200;
  unint64_t v201;
  uint64_t *v202;
  _QWORD *v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  unint64_t v207;
  char *v208;
  uint64_t *v209;
  char *v210;
  char *v211;
  char *v212;
  uint64_t v213;
  std::__shared_weak_count *v214;
  unint64_t *v215;
  unint64_t v216;
  capabilities::ct *v217;
  std::mutex *ServiceMap;
  uint64_t v219;
  uint64_t v220;
  _QWORD *v221;
  uint64_t v222;
  std::__shared_weak_count *v223;
  unint64_t *v224;
  unint64_t v225;
  void *v226;
  std::string::size_type v227;
  const __CFArray *v228;
  uint64_t (*v229)(uint64_t);
  BOOL v230;
  CFTypeID v231;
  std::mutex *v232;
  uint64_t v233;
  uint64_t v234;
  _QWORD *v235;
  std::__shared_weak_count *v236;
  unint64_t *v237;
  unint64_t v238;
  unsigned __int16 *v239;
  uint64_t (*v240)(uint64_t);
  CFTypeID v241;
  const __CFNumber *v242;
  int data_low;
  std::mutex *v244;
  uint64_t v245;
  uint64_t v246;
  _QWORD *v247;
  std::__shared_weak_count *v248;
  unint64_t *v249;
  unint64_t v250;
  unsigned __int16 *v251;
  uint64_t (*v252)(uint64_t);
  CFTypeID v253;
  const __CFNumber *v254;
  int v255;
  NSObject *v256;
  const void **v257;
  const void **v258;
  const void **v259;
  char *v260;
  _WORD *v261;
  uint64_t v262;
  unint64_t v263;
  uint64_t *v264;
  uint64_t v265;
  uint64_t v266;
  uint64_t v267;
  unint64_t v268;
  char *v269;
  uint64_t *v270;
  char *v271;
  char *v272;
  char *v273;
  uint64_t v274;
  char *v275;
  char *v276;
  uint64_t v277;
  unint64_t v278;
  uint64_t *v279;
  _QWORD *v280;
  uint64_t v281;
  uint64_t v282;
  uint64_t v283;
  unint64_t v284;
  char *v285;
  uint64_t *v286;
  char *v287;
  char *v288;
  char *v289;
  uint64_t v290;
  _QWORD *v291;
  NSObject *v292;
  uint64_t v293;
  const void **v294;
  const void **v295;
  char *v296;
  _BYTE *v297;
  uint64_t v298;
  unint64_t v299;
  uint64_t *v300;
  _QWORD *v301;
  uint64_t v302;
  uint64_t v303;
  uint64_t v304;
  unint64_t v305;
  char *v306;
  uint64_t *v307;
  char *v308;
  char *v309;
  char *v310;
  uint64_t v311;
  std::__shared_weak_count *v312;
  unint64_t *v313;
  unint64_t v314;
  CFTypeRef cf;
  _QWORD v316[2];
  uint64_t (*v317)(uint64_t, _WORD *);
  void *v318;
  uint64_t v319;
  std::__shared_weak_count *v320;
  _QWORD v321[2];
  void (*v322)(uint64_t, char *);
  void *v323;
  uint64_t v324;
  std::__shared_weak_count *v325;
  uint64_t v326;
  uint64_t v327;
  void (*v328)(uint64_t, std::string *);
  void *v329;
  std::string v330;
  uint64_t v331;
  uint64_t v332;
  void (*v333)(uint64_t, std::string *);
  void *v334;
  std::string v335;
  std::string __s;
  _QWORD v337[2];
  void (*v338)(uint64_t, int *);
  void *v339;
  unint64_t v340;
  int v341;
  uint64_t v342;
  uint64_t v343;
  void (*v344)(uint64_t, std::string *);
  void *v345;
  std::string __p;
  std::string v347;
  std::string v348;
  uint64_t v349;
  std::__shared_weak_count *v350;
  std::string buf;
  std::string *v352;
  unint64_t v353;
  __int128 context;
  uint64_t v355;
  CFRange v356;

  v355 = *MEMORY[0x24BDAC8D0];
  v10 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(a1 + 88));
  buf.__r_.__value_.__r.__words[0] = *(_QWORD *)(a1 + 80);
  buf.__r_.__value_.__l.__size_ = (std::string::size_type)v10;
  v349 = 0;
  v350 = 0;
  (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)buf.__r_.__value_.__l.__data_ + 32))(&v349);
  p_shared_owners = (unint64_t *)&v10->__shared_owners_;
  do
    v12 = __ldaxr(p_shared_owners);
  while (__stlxr(v12 - 1, p_shared_owners));
  if (!v12)
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  if (!v349)
    goto LABEL_471;
  memset(&v348, 0, sizeof(v348));
  std::string::basic_string[abi:ne180100]<0>(&v348, (char *)&unk_216AC4FCA);
  v13 = (capabilities::ct *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v349 + 88))(v349, 0);
  if ((v13 & 1) != 0)
  {
    if (capabilities::ct::supportsDataQMIExtensions(v13))
    {
      if (SHIBYTE(v348.__r_.__value_.__r.__words[2]) < 0)
      {
        v348.__r_.__value_.__l.__size_ = 3;
        v14 = (std::string *)v348.__r_.__value_.__r.__words[0];
      }
      else
      {
        *((_BYTE *)&v348.__r_.__value_.__s + 23) = 3;
        v14 = &v348;
      }
      LODWORD(v14->__r_.__value_.__l.__data_) = 7565171;
    }
  }
  else
  {
    v15 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(a1 + 88));
    v347.__r_.__value_.__r.__words[0] = *(_QWORD *)(a1 + 80);
    v347.__r_.__value_.__l.__size_ = (std::string::size_type)v15;
    (*(void (**)(std::string *__return_ptr))(*(_QWORD *)v347.__r_.__value_.__l.__data_ + 312))(&buf);
    if (SHIBYTE(v348.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v348.__r_.__value_.__l.__data_);
    v348 = buf;
    *((_BYTE *)&buf.__r_.__value_.__s + 23) = 0;
    buf.__r_.__value_.__s.__data_[0] = 0;
    v16 = (unint64_t *)&v15->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
    if ((*(unsigned int (**)(uint64_t, _QWORD))(*(_QWORD *)v349 + 104))(v349, 0)
      && (*(unsigned int (**)(uint64_t))(*(_QWORD *)v349 + 80))(v349))
    {
      v18 = *(NSObject **)(a1 + 56);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        v19 = SHIBYTE(v348.__r_.__value_.__r.__words[2]);
        v20 = v348.__r_.__value_.__r.__words[0];
        (*(void (**)(std::string *__return_ptr))(*(_QWORD *)v349 + 288))(&v347);
        v21 = &v348;
        if (v19 < 0)
          v21 = (std::string *)v20;
        if ((v347.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v22 = &v347;
        else
          v22 = (std::string *)v347.__r_.__value_.__r.__words[0];
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315650;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"set3GPPParameters";
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v21;
        HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
        v352 = v22;
        _os_log_impl(&dword_216897000, v18, OS_LOG_TYPE_DEFAULT, "#I %s: Modifying APN name %s to alt-name %s in 3GPP parameters", (uint8_t *)&buf, 0x20u);
        if (SHIBYTE(v347.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v347.__r_.__value_.__l.__data_);
      }
      (*(void (**)(std::string *__return_ptr))(*(_QWORD *)v349 + 288))(&buf);
      if (SHIBYTE(v348.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v348.__r_.__value_.__l.__data_);
      v348 = buf;
    }
  }
  if (SHIBYTE(v348.__r_.__value_.__r.__words[2]) < 0)
  {
    if (!v348.__r_.__value_.__l.__size_)
      goto LABEL_62;
    v342 = MEMORY[0x24BDAC760];
    v343 = 1174405120;
    v344 = ___ZN31Mav16QMIDataContextIPAggregator17set3GPPParametersERN3wds29ResetAndModifyProfileSettings7RequestE18DataProtocolFamily19AuthTypeRequirementb_block_invoke;
    v345 = &__block_descriptor_tmp_50_2;
    std::string::__init_copy_ctor_external(&__p, v348.__r_.__value_.__l.__data_, v348.__r_.__value_.__l.__size_);
  }
  else
  {
    if (!*((_BYTE *)&v348.__r_.__value_.__s + 23))
      goto LABEL_62;
    v342 = MEMORY[0x24BDAC760];
    v343 = 1174405120;
    v344 = ___ZN31Mav16QMIDataContextIPAggregator17set3GPPParametersERN3wds29ResetAndModifyProfileSettings7RequestE18DataProtocolFamily19AuthTypeRequirementb_block_invoke;
    v345 = &__block_descriptor_tmp_50_2;
    __p = v348;
  }
  v23 = (const void **)a2[1];
  v24 = (const void **)a2[2];
  v25 = (char **)(a2 + 1);
  if (v23 != v24)
  {
    while (*((_BYTE *)*v23 + 8) != 20)
    {
      if (++v23 == v24)
        goto LABEL_43;
    }
  }
  if (v23 == v24)
  {
LABEL_43:
    v28 = operator new();
    *(_BYTE *)(v28 + 8) = 20;
    *(_QWORD *)v28 = off_24D5DD2F0;
    *(_QWORD *)(v28 + 16) = 0;
    v27 = (std::string *)(v28 + 16);
    *(_QWORD *)(v28 + 24) = 0;
    *(_QWORD *)(v28 + 32) = 0;
    v29 = a2[3];
    v30 = (uint64_t *)a2[2];
    if ((unint64_t)v30 >= v29)
    {
      v32 = ((char *)v30 - *v25) >> 3;
      if ((unint64_t)(v32 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v33 = v29 - (_QWORD)*v25;
      v34 = v33 >> 2;
      if (v33 >> 2 <= (unint64_t)(v32 + 1))
        v34 = v32 + 1;
      if ((unint64_t)v33 >= 0x7FFFFFFFFFFFFFF8)
        v35 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v35 = v34;
      if (v35)
        v36 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a2 + 3), v35);
      else
        v36 = 0;
      v37 = (uint64_t *)&v36[8 * v32];
      v38 = &v36[8 * v35];
      *v37 = v28;
      v31 = v37 + 1;
      v40 = (char *)a2[1];
      v39 = (char *)a2[2];
      if (v39 != v40)
      {
        do
        {
          v41 = *((_QWORD *)v39 - 1);
          v39 -= 8;
          *--v37 = v41;
        }
        while (v39 != v40);
        v39 = *v25;
      }
      a2[1] = v37;
      a2[2] = v31;
      a2[3] = v38;
      if (v39)
        operator delete(v39);
    }
    else
    {
      *v30 = v28;
      v31 = v30 + 1;
    }
    a2[2] = v31;
  }
  else
  {
    if (!v26)
      __cxa_bad_cast();
    v27 = (std::string *)(v26 + 16);
  }
  v344((uint64_t)&v342, v27);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
LABEL_62:
  v337[0] = MEMORY[0x24BDAC760];
  v337[1] = 0x40000000;
  v338 = ___ZN31Mav16QMIDataContextIPAggregator17set3GPPParametersERN3wds29ResetAndModifyProfileSettings7RequestE18DataProtocolFamily19AuthTypeRequirementb_block_invoke_51;
  v339 = &__block_descriptor_tmp_55_6;
  v340 = a1;
  v341 = a3;
  v42 = (const void **)a2[1];
  v43 = (const void **)a2[2];
  v44 = (char **)(a2 + 1);
  if (v42 != v43)
  {
    while (*((_BYTE *)*v42 + 8) != 17)
    {
      if (++v42 == v43)
        goto LABEL_69;
    }
  }
  if (v42 == v43)
  {
LABEL_69:
    v46 = operator new();
    *(_BYTE *)(v46 + 8) = 17;
    *(_DWORD *)(v46 + 12) = 0;
    *(_QWORD *)v46 = &off_24D5DD340;
    v47 = a2[3];
    v48 = (uint64_t *)a2[2];
    if ((unint64_t)v48 >= v47)
    {
      v50 = ((char *)v48 - *v44) >> 3;
      if ((unint64_t)(v50 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v51 = v47 - (_QWORD)*v44;
      v52 = v51 >> 2;
      if (v51 >> 2 <= (unint64_t)(v50 + 1))
        v52 = v50 + 1;
      if ((unint64_t)v51 >= 0x7FFFFFFFFFFFFFF8)
        v53 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v53 = v52;
      if (v53)
        v54 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a2 + 3), v53);
      else
        v54 = 0;
      v55 = (uint64_t *)&v54[8 * v50];
      v56 = &v54[8 * v53];
      *v55 = v46;
      v49 = v55 + 1;
      v58 = (char *)a2[1];
      v57 = (char *)a2[2];
      if (v57 != v58)
      {
        do
        {
          v59 = *((_QWORD *)v57 - 1);
          v57 -= 8;
          *--v55 = v59;
        }
        while (v57 != v58);
        v57 = *v44;
      }
      a2[1] = v55;
      a2[2] = v49;
      a2[3] = v56;
      if (v57)
        operator delete(v57);
    }
    else
    {
      *v48 = v46;
      v49 = v48 + 1;
    }
    a2[2] = v49;
    v338((uint64_t)v337, (int *)(v46 + 12));
  }
  else
  {
    if (!v45)
      __cxa_bad_cast();
    ___ZN31Mav16QMIDataContextIPAggregator17set3GPPParametersERN3wds29ResetAndModifyProfileSettings7RequestE18DataProtocolFamily19AuthTypeRequirementb_block_invoke_51((uint64_t)v337, v45 + 3);
  }
  memset(&v347, 0, sizeof(v347));
  (*(void (**)(std::string *__return_ptr))(*(_QWORD *)v349 + 264))(&v347);
  memset(&__s, 0, sizeof(__s));
  (*(void (**)(std::string *__return_ptr))(*(_QWORD *)v349 + 272))(&__s);
  if (SHIBYTE(v347.__r_.__value_.__r.__words[2]) < 0)
  {
    if (!v347.__r_.__value_.__l.__size_)
      goto LABEL_117;
    v331 = MEMORY[0x24BDAC760];
    v332 = 1174405120;
    v333 = ___ZN31Mav16QMIDataContextIPAggregator17set3GPPParametersERN3wds29ResetAndModifyProfileSettings7RequestE18DataProtocolFamily19AuthTypeRequirementb_block_invoke_56;
    v334 = &__block_descriptor_tmp_57_4;
    std::string::__init_copy_ctor_external(&v335, v347.__r_.__value_.__l.__data_, v347.__r_.__value_.__l.__size_);
  }
  else
  {
    if (!*((_BYTE *)&v347.__r_.__value_.__s + 23))
      goto LABEL_117;
    v331 = MEMORY[0x24BDAC760];
    v332 = 1174405120;
    v333 = ___ZN31Mav16QMIDataContextIPAggregator17set3GPPParametersERN3wds29ResetAndModifyProfileSettings7RequestE18DataProtocolFamily19AuthTypeRequirementb_block_invoke_56;
    v334 = &__block_descriptor_tmp_57_4;
    v335 = v347;
  }
  v60 = (const void **)a2[1];
  v61 = (const void **)a2[2];
  if (v60 != v61)
  {
    while (*((_BYTE *)*v60 + 8) != 27)
    {
      if (++v60 == v61)
        goto LABEL_98;
    }
  }
  if (v60 == v61)
  {
LABEL_98:
    v64 = operator new();
    *(_BYTE *)(v64 + 8) = 27;
    *(_QWORD *)v64 = off_24D5DD390;
    *(_QWORD *)(v64 + 16) = 0;
    v63 = (std::string *)(v64 + 16);
    *(_QWORD *)(v64 + 24) = 0;
    *(_QWORD *)(v64 + 32) = 0;
    v65 = a2[3];
    v66 = (uint64_t *)a2[2];
    if ((unint64_t)v66 >= v65)
    {
      v68 = ((char *)v66 - *v44) >> 3;
      if ((unint64_t)(v68 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v69 = v65 - (_QWORD)*v44;
      v70 = v69 >> 2;
      if (v69 >> 2 <= (unint64_t)(v68 + 1))
        v70 = v68 + 1;
      if ((unint64_t)v69 >= 0x7FFFFFFFFFFFFFF8)
        v71 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v71 = v70;
      if (v71)
        v72 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a2 + 3), v71);
      else
        v72 = 0;
      v73 = (uint64_t *)&v72[8 * v68];
      v74 = &v72[8 * v71];
      *v73 = v64;
      v67 = v73 + 1;
      v76 = (char *)a2[1];
      v75 = (char *)a2[2];
      if (v75 != v76)
      {
        do
        {
          v77 = *((_QWORD *)v75 - 1);
          v75 -= 8;
          *--v73 = v77;
        }
        while (v75 != v76);
        v75 = *v44;
      }
      a2[1] = v73;
      a2[2] = v67;
      a2[3] = v74;
      if (v75)
        operator delete(v75);
    }
    else
    {
      *v66 = v64;
      v67 = v66 + 1;
    }
    a2[2] = v67;
  }
  else
  {
    if (!v62)
      __cxa_bad_cast();
    v63 = (std::string *)(v62 + 16);
  }
  v333((uint64_t)&v331, v63);
  if (SHIBYTE(v335.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v335.__r_.__value_.__l.__data_);
LABEL_117:
  if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0)
  {
    if (!__s.__r_.__value_.__l.__size_)
      goto LABEL_148;
    v326 = MEMORY[0x24BDAC760];
    v327 = 1174405120;
    v328 = ___ZN31Mav16QMIDataContextIPAggregator17set3GPPParametersERN3wds29ResetAndModifyProfileSettings7RequestE18DataProtocolFamily19AuthTypeRequirementb_block_invoke_58;
    v329 = &__block_descriptor_tmp_59_6;
    std::string::__init_copy_ctor_external(&v330, __s.__r_.__value_.__l.__data_, __s.__r_.__value_.__l.__size_);
  }
  else
  {
    if (!*((_BYTE *)&__s.__r_.__value_.__s + 23))
      goto LABEL_148;
    v326 = MEMORY[0x24BDAC760];
    v327 = 1174405120;
    v328 = ___ZN31Mav16QMIDataContextIPAggregator17set3GPPParametersERN3wds29ResetAndModifyProfileSettings7RequestE18DataProtocolFamily19AuthTypeRequirementb_block_invoke_58;
    v329 = &__block_descriptor_tmp_59_6;
    v330 = __s;
  }
  v78 = (const void **)a2[1];
  v79 = (const void **)a2[2];
  if (v78 != v79)
  {
    while (*((_BYTE *)*v78 + 8) != 28)
    {
      if (++v78 == v79)
        goto LABEL_129;
    }
  }
  if (v78 == v79)
  {
LABEL_129:
    v82 = operator new();
    *(_BYTE *)(v82 + 8) = 28;
    *(_QWORD *)v82 = off_24D5DD3E0;
    *(_QWORD *)(v82 + 16) = 0;
    v81 = (std::string *)(v82 + 16);
    *(_QWORD *)(v82 + 24) = 0;
    *(_QWORD *)(v82 + 32) = 0;
    v83 = a2[3];
    v84 = (uint64_t *)a2[2];
    if ((unint64_t)v84 >= v83)
    {
      v86 = ((char *)v84 - *v44) >> 3;
      if ((unint64_t)(v86 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v87 = v83 - (_QWORD)*v44;
      v88 = v87 >> 2;
      if (v87 >> 2 <= (unint64_t)(v86 + 1))
        v88 = v86 + 1;
      if ((unint64_t)v87 >= 0x7FFFFFFFFFFFFFF8)
        v89 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v89 = v88;
      if (v89)
        v90 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a2 + 3), v89);
      else
        v90 = 0;
      v91 = (uint64_t *)&v90[8 * v86];
      v92 = &v90[8 * v89];
      *v91 = v82;
      v85 = v91 + 1;
      v94 = (char *)a2[1];
      v93 = (char *)a2[2];
      if (v93 != v94)
      {
        do
        {
          v95 = *((_QWORD *)v93 - 1);
          v93 -= 8;
          *--v91 = v95;
        }
        while (v93 != v94);
        v93 = *v44;
      }
      a2[1] = v91;
      a2[2] = v85;
      a2[3] = v92;
      if (v93)
        operator delete(v93);
    }
    else
    {
      *v84 = v82;
      v85 = v84 + 1;
    }
    a2[2] = v85;
  }
  else
  {
    if (!v80)
      __cxa_bad_cast();
    v81 = (std::string *)(v80 + 16);
  }
  v328((uint64_t)&v326, v81);
  if (SHIBYTE(v330.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v330.__r_.__value_.__l.__data_);
LABEL_148:
  v96 = *(NSObject **)(a1 + 56);
  if (os_log_type_enabled(v96, OS_LOG_TYPE_DEFAULT))
  {
    v97 = asString();
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"set3GPPParameters";
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v97;
    _os_log_impl(&dword_216897000, v96, OS_LOG_TYPE_DEFAULT, "#I %s: Auth Type requirement = %s", (uint8_t *)&buf, 0x16u);
  }
  if (a4 == 1)
    goto LABEL_157;
  size = HIBYTE(v347.__r_.__value_.__r.__words[2]);
  if ((v347.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    size = v347.__r_.__value_.__l.__size_;
  if (size)
    goto LABEL_157;
  v99 = HIBYTE(__s.__r_.__value_.__r.__words[2]);
  if ((__s.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    v99 = __s.__r_.__value_.__l.__size_;
  if (v99)
  {
LABEL_157:
    v321[0] = MEMORY[0x24BDAC760];
    v321[1] = 1174405120;
    v322 = ___ZN31Mav16QMIDataContextIPAggregator17set3GPPParametersERN3wds29ResetAndModifyProfileSettings7RequestE18DataProtocolFamily19AuthTypeRequirementb_block_invoke_60;
    v323 = &__block_descriptor_tmp_64_3;
    v324 = v349;
    v325 = v350;
    if (v350)
    {
      v100 = (unint64_t *)&v350->__shared_owners_;
      do
        v101 = __ldxr(v100);
      while (__stxr(v101 + 1, v100));
    }
    v102 = (const void **)a2[1];
    v103 = (const void **)a2[2];
    if (v102 != v103)
    {
      while (*((_BYTE *)*v102 + 8) != 29)
      {
        if (++v102 == v103)
          goto LABEL_167;
      }
    }
    if (v102 == v103)
    {
LABEL_167:
      v106 = operator new();
      *(_WORD *)(v106 + 8) = 29;
      *(_QWORD *)v106 = &off_24D5DD430;
      v107 = a2[3];
      v108 = (uint64_t *)a2[2];
      if ((unint64_t)v108 >= v107)
      {
        v110 = ((char *)v108 - *v44) >> 3;
        if ((unint64_t)(v110 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v111 = v107 - (_QWORD)*v44;
        v112 = v111 >> 2;
        if (v111 >> 2 <= (unint64_t)(v110 + 1))
          v112 = v110 + 1;
        if ((unint64_t)v111 >= 0x7FFFFFFFFFFFFFF8)
          v113 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v113 = v112;
        if (v113)
          v114 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a2 + 3), v113);
        else
          v114 = 0;
        v115 = (uint64_t *)&v114[8 * v110];
        v116 = &v114[8 * v113];
        *v115 = v106;
        v109 = v115 + 1;
        v118 = (char *)a2[1];
        v117 = (char *)a2[2];
        if (v117 != v118)
        {
          do
          {
            v119 = *((_QWORD *)v117 - 1);
            v117 -= 8;
            *--v115 = v119;
          }
          while (v117 != v118);
          v117 = *v44;
        }
        a2[1] = v115;
        a2[2] = v109;
        a2[3] = v116;
        if (v117)
          operator delete(v117);
      }
      else
      {
        *v108 = v106;
        v109 = v108 + 1;
      }
      v105 = (char *)(v106 + 9);
      a2[2] = v109;
    }
    else
    {
      if (!v104)
        __cxa_bad_cast();
      v105 = v104 + 9;
    }
    v322((uint64_t)v321, v105);
    v120 = v325;
    if (v325)
    {
      v121 = (unint64_t *)&v325->__shared_owners_;
      do
        v122 = __ldaxr(v121);
      while (__stlxr(v122 - 1, v121));
      if (!v122)
      {
        ((void (*)(std::__shared_weak_count *))v120->__on_zero_shared)(v120);
        std::__shared_weak_count::__release_weak(v120);
      }
    }
  }
  v123 = *(NSObject **)(a1 + 56);
  if (os_log_type_enabled(v123, OS_LOG_TYPE_DEFAULT))
  {
    v124 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v349 + 56))(v349, 0);
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315650;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"set3GPPParameters";
    WORD2(buf.__r_.__value_.__r.__words[1]) = 1024;
    *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v124;
    WORD1(buf.__r_.__value_.__r.__words[2]) = 1024;
    HIDWORD(buf.__r_.__value_.__r.__words[2]) = a5;
    _os_log_impl(&dword_216897000, v123, OS_LOG_TYPE_DEFAULT, "#I %s: ims=%d, sigInd=%d", (uint8_t *)&buf, 0x18u);
  }
  if ((*(unsigned int (**)(uint64_t, _QWORD))(*(_QWORD *)v349 + 56))(v349, 0))
  {
    v125 = (const void **)a2[1];
    v126 = (const void **)a2[2];
    if (v125 != v126)
    {
      while (*((_BYTE *)*v125 + 8) != 31)
      {
        if (++v125 == v126)
          goto LABEL_199;
      }
    }
    if (v125 == v126)
    {
LABEL_199:
      v129 = operator new();
      *(_WORD *)(v129 + 8) = 31;
      *(_QWORD *)v129 = &off_24D5DD480;
      v130 = a2[3];
      v131 = (uint64_t *)a2[2];
      if ((unint64_t)v131 >= v130)
      {
        v133 = ((char *)v131 - *v44) >> 3;
        if ((unint64_t)(v133 + 1) >> 61)
          goto LABEL_486;
        v134 = v130 - (_QWORD)*v44;
        v135 = v134 >> 2;
        if (v134 >> 2 <= (unint64_t)(v133 + 1))
          v135 = v133 + 1;
        if ((unint64_t)v134 >= 0x7FFFFFFFFFFFFFF8)
          v136 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v136 = v135;
        if (v136)
          v137 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a2 + 3), v136);
        else
          v137 = 0;
        v138 = (uint64_t *)&v137[8 * v133];
        v139 = &v137[8 * v136];
        *v138 = v129;
        v132 = v138 + 1;
        v141 = (char *)a2[1];
        v140 = (char *)a2[2];
        if (v140 != v141)
        {
          do
          {
            v142 = *((_QWORD *)v140 - 1);
            v140 -= 8;
            *--v138 = v142;
          }
          while (v140 != v141);
          v140 = *v44;
        }
        a2[1] = v138;
        a2[2] = v132;
        a2[3] = v139;
        if (v140)
          operator delete(v140);
      }
      else
      {
        *v131 = v129;
        v132 = v131 + 1;
      }
      v128 = (_BYTE *)(v129 + 9);
      a2[2] = v132;
    }
    else
    {
      if (!v127)
        goto LABEL_479;
      v128 = v127 + 9;
    }
    *v128 = 1;
    if (a5)
    {
      *(_QWORD *)&context = 0;
      v143 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(a1 + 88));
      buf.__r_.__value_.__r.__words[0] = *(_QWORD *)(a1 + 80);
      buf.__r_.__value_.__l.__size_ = (std::string::size_type)v143;
      (*(void (**)(__int128 *__return_ptr, std::string::size_type, const __CFString *, _QWORD, _QWORD))(*(_QWORD *)buf.__r_.__value_.__l.__data_ + 368))(&context, buf.__r_.__value_.__r.__words[0], CFSTR("SupportsIMSSignalingIndication"), *MEMORY[0x24BDBD268], 0);
      v144 = (unint64_t *)&v143->__shared_owners_;
      do
        v145 = __ldaxr(v144);
      while (__stlxr(v145 - 1, v144));
      if (!v145)
      {
        ((void (*)(std::__shared_weak_count *))v143->__on_zero_shared)(v143);
        std::__shared_weak_count::__release_weak(v143);
      }
      v146 = (BOOL *)context;
      buf.__r_.__value_.__s.__data_[0] = 0;
      if (!(_QWORD)context)
        goto LABEL_231;
      v147 = CFGetTypeID((CFTypeRef)context);
      if (v147 == CFBooleanGetTypeID())
        ctu::cf::assign((ctu::cf *)&buf, v146, v148);
      if (buf.__r_.__value_.__s.__data_[0])
      {
        v149 = *(NSObject **)(a1 + 56);
        if (os_log_type_enabled(v149, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"set3GPPParameters";
          _os_log_impl(&dword_216897000, v149, OS_LOG_TYPE_DEFAULT, "#I %s: The carrier supports IMSSignalingIndication Capability", (uint8_t *)&buf, 0xCu);
        }
        v150 = (const void **)a2[1];
        v151 = (const void **)a2[2];
        if (v150 != v151)
        {
          while (*((_BYTE *)*v150 + 8) != 41)
          {
            if (++v150 == v151)
              goto LABEL_236;
          }
        }
        if (v150 == v151)
        {
LABEL_236:
          v155 = operator new();
          *(_BYTE *)(v155 + 8) = 41;
          *(_QWORD *)v155 = &off_24D5DD4D0;
          *(_BYTE *)(v155 + 12) = 0;
          v154 = (char *)(v155 + 12);
          *(_QWORD *)(v155 + 16) = 0;
          *(_QWORD *)(v155 + 24) = 0;
          *(_BYTE *)(v155 + 32) = 0;
          *(_DWORD *)(v155 + 36) = 0;
          *(_DWORD *)(v155 + 39) = 0;
          *(_QWORD *)(v155 + 44) = 0;
          *(_BYTE *)(v155 + 52) = 0;
          v156 = a2[3];
          v157 = (uint64_t *)a2[2];
          if ((unint64_t)v157 >= v156)
          {
            v159 = ((char *)v157 - *v44) >> 3;
            if ((unint64_t)(v159 + 1) >> 61)
              std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
            v160 = v156 - (_QWORD)*v44;
            v161 = v160 >> 2;
            if (v160 >> 2 <= (unint64_t)(v159 + 1))
              v161 = v159 + 1;
            if ((unint64_t)v160 >= 0x7FFFFFFFFFFFFFF8)
              v162 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v162 = v161;
            if (v162)
              v163 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a2 + 3), v162);
            else
              v163 = 0;
            v164 = (uint64_t *)&v163[8 * v159];
            v165 = &v163[8 * v162];
            *v164 = v155;
            v158 = v164 + 1;
            v167 = (char *)a2[1];
            v166 = (char *)a2[2];
            if (v166 != v167)
            {
              do
              {
                v168 = *((_QWORD *)v166 - 1);
                v166 -= 8;
                *--v164 = v168;
              }
              while (v166 != v167);
              v166 = *v44;
            }
            a2[1] = v164;
            a2[2] = v158;
            a2[3] = v165;
            if (v166)
              operator delete(v166);
          }
          else
          {
            *v157 = v155;
            v158 = v157 + 1;
          }
          a2[2] = v158;
        }
        else
        {
          if (!v153)
            __cxa_bad_cast();
          v154 = v153 + 12;
        }
        *v154 = 3;
        *((_DWORD *)v154 + 9) = 1;
        v154[40] = 1;
      }
      else
      {
LABEL_231:
        v152 = *(NSObject **)(a1 + 56);
        if (os_log_type_enabled(v152, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"set3GPPParameters";
          _os_log_impl(&dword_216897000, v152, OS_LOG_TYPE_DEFAULT, "#I %s: The device supports IMSSignalingIndication Capability but carrier doesn't. No need to fill SigInd parameters", (uint8_t *)&buf, 0xCu);
        }
      }
      ctu::SharedRef<void const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,void const>::~SharedRef((const void **)&context);
    }
  }
  if (!(*(unsigned int (**)(uint64_t, _QWORD))(*(_QWORD *)v349 + 88))(v349, 0))
    goto LABEL_288;
  v169 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(a1 + 88));
  buf.__r_.__value_.__r.__words[0] = *(_QWORD *)(a1 + 80);
  buf.__r_.__value_.__l.__size_ = (std::string::size_type)v169;
  v170 = (*(uint64_t (**)(std::string::size_type))(*(_QWORD *)buf.__r_.__value_.__l.__data_ + 256))(buf.__r_.__value_.__r.__words[0]);
  v171 = (unint64_t *)&v169->__shared_owners_;
  do
    v172 = __ldaxr(v171);
  while (__stlxr(v172 - 1, v171));
  if (!v172)
  {
    ((void (*)(std::__shared_weak_count *))v169->__on_zero_shared)(v169);
    std::__shared_weak_count::__release_weak(v169);
  }
  if (v170 == 2)
    goto LABEL_288;
  v173 = *(NSObject **)(a1 + 56);
  if (os_log_type_enabled(v173, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"set3GPPParameters";
    _os_log_impl(&dword_216897000, v173, OS_LOG_TYPE_DEFAULT, "#I %s: Applying SupportEm tlv to start network", (uint8_t *)&buf, 0xCu);
  }
  v174 = (const void **)a2[1];
  v175 = (const void **)a2[2];
  if (v174 != v175)
  {
    while (*((_BYTE *)*v174 + 8) != 54)
    {
      if (++v174 == v175)
        goto LABEL_270;
    }
  }
  if (v174 == v175)
  {
LABEL_270:
    v178 = operator new();
    *(_WORD *)(v178 + 8) = 54;
    *(_QWORD *)v178 = &off_24D5DD520;
    v179 = a2[3];
    v180 = (uint64_t *)a2[2];
    if ((unint64_t)v180 < v179)
    {
      *v180 = v178;
      v181 = v180 + 1;
LABEL_286:
      v177 = (_BYTE *)(v178 + 9);
      a2[2] = v181;
      goto LABEL_287;
    }
    v182 = ((char *)v180 - *v44) >> 3;
    if (!((unint64_t)(v182 + 1) >> 61))
    {
      v183 = v179 - (_QWORD)*v44;
      v184 = v183 >> 2;
      if (v183 >> 2 <= (unint64_t)(v182 + 1))
        v184 = v182 + 1;
      if ((unint64_t)v183 >= 0x7FFFFFFFFFFFFFF8)
        v185 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v185 = v184;
      if (v185)
        v186 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a2 + 3), v185);
      else
        v186 = 0;
      v187 = (uint64_t *)&v186[8 * v182];
      v188 = &v186[8 * v185];
      *v187 = v178;
      v181 = v187 + 1;
      v190 = (char *)a2[1];
      v189 = (char *)a2[2];
      if (v189 != v190)
      {
        do
        {
          v191 = *((_QWORD *)v189 - 1);
          v189 -= 8;
          *--v187 = v191;
        }
        while (v189 != v190);
        v189 = *v44;
      }
      a2[1] = v187;
      a2[2] = v181;
      a2[3] = v188;
      if (v189)
        operator delete(v189);
      goto LABEL_286;
    }
LABEL_486:
    std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
  }
  if (!v176)
LABEL_479:
    __cxa_bad_cast();
  v177 = v176 + 9;
LABEL_287:
  *v177 = 1;
LABEL_288:
  v192 = (capabilities::ct *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v349 + 152))(v349);
  if ((_DWORD)v192)
  {
    v193 = *(NSObject **)(a1 + 56);
    if (os_log_type_enabled(v193, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"set3GPPParameters";
      _os_log_impl(&dword_216897000, v193, OS_LOG_TYPE_DEFAULT, "#I %s: Applying PCO to SNI", (uint8_t *)&buf, 0xCu);
    }
    v316[0] = MEMORY[0x24BDAC760];
    v316[1] = 1174405120;
    v317 = ___ZN31Mav16QMIDataContextIPAggregator17set3GPPParametersERN3wds29ResetAndModifyProfileSettings7RequestE18DataProtocolFamily19AuthTypeRequirementb_block_invoke_79;
    v318 = &__block_descriptor_tmp_81_0;
    v319 = v349;
    v320 = v350;
    if (v350)
    {
      v194 = (unint64_t *)&v350->__shared_owners_;
      do
        v195 = __ldxr(v194);
      while (__stxr(v195 + 1, v194));
    }
    v196 = (const void **)a2[1];
    v197 = (const void **)a2[2];
    if (v196 != v197)
    {
      while (*((_BYTE *)*v196 + 8) != 55)
      {
        if (++v196 == v197)
          goto LABEL_301;
      }
    }
    if (v196 == v197)
    {
LABEL_301:
      v200 = operator new();
      *(_BYTE *)(v200 + 8) = 55;
      *(_WORD *)(v200 + 10) = 0;
      v199 = (_WORD *)(v200 + 10);
      *(_QWORD *)v200 = &off_24D5DD570;
      v201 = a2[3];
      v202 = (uint64_t *)a2[2];
      if ((unint64_t)v202 >= v201)
      {
        v204 = ((char *)v202 - *v44) >> 3;
        if ((unint64_t)(v204 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v205 = v201 - (_QWORD)*v44;
        v206 = v205 >> 2;
        if (v205 >> 2 <= (unint64_t)(v204 + 1))
          v206 = v204 + 1;
        if ((unint64_t)v205 >= 0x7FFFFFFFFFFFFFF8)
          v207 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v207 = v206;
        if (v207)
          v208 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a2 + 3), v207);
        else
          v208 = 0;
        v209 = (uint64_t *)&v208[8 * v204];
        v210 = &v208[8 * v207];
        *v209 = v200;
        v203 = v209 + 1;
        v212 = (char *)a2[1];
        v211 = (char *)a2[2];
        if (v211 != v212)
        {
          do
          {
            v213 = *((_QWORD *)v211 - 1);
            v211 -= 8;
            *--v209 = v213;
          }
          while (v211 != v212);
          v211 = *v44;
        }
        a2[1] = v209;
        a2[2] = v203;
        a2[3] = v210;
        if (v211)
          operator delete(v211);
      }
      else
      {
        *v202 = v200;
        v203 = v202 + 1;
      }
      a2[2] = v203;
    }
    else
    {
      if (!v198)
        __cxa_bad_cast();
      v199 = v198 + 10;
    }
    v192 = (capabilities::ct *)v317((uint64_t)v316, v199);
    v214 = v320;
    if (v320)
    {
      v215 = (unint64_t *)&v320->__shared_owners_;
      do
        v216 = __ldaxr(v215);
      while (__stlxr(v216 - 1, v215));
      if (!v216)
      {
        ((void (*)(std::__shared_weak_count *))v214->__on_zero_shared)(v214);
        std::__shared_weak_count::__release_weak(v214);
      }
    }
  }
  v217 = (capabilities::ct *)capabilities::ct::supports5G(v192);
  if ((_DWORD)v217)
  {
    cf = 0;
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 64));
    ctu::shared_ptr_map_impl<ctu::indexed_by_any_map_hashing_key>::get<CarrierSettingsInterface>(ServiceMap, &context);
    v219 = context;
    v220 = *(unsigned int *)(a1 + 8);
    v221 = operator new(0x10uLL);
    v222 = *MEMORY[0x24BDC3EE8];
    buf.__r_.__value_.__l.__size_ = (std::string::size_type)(v221 + 2);
    buf.__r_.__value_.__r.__words[2] = (std::string::size_type)(v221 + 2);
    *v221 = v222;
    v221[1] = CFSTR("ContainerIds");
    buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v221;
    (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint64_t, uint64_t, std::string *, _QWORD, _QWORD))(*(_QWORD *)v219 + 88))(&cf, v219, v220, 1, &buf, 0, 0);
    if (buf.__r_.__value_.__r.__words[0])
    {
      buf.__r_.__value_.__l.__size_ = buf.__r_.__value_.__r.__words[0];
      operator delete(buf.__r_.__value_.__l.__data_);
    }
    v223 = (std::__shared_weak_count *)*((_QWORD *)&context + 1);
    if (*((_QWORD *)&context + 1))
    {
      v224 = (unint64_t *)(*((_QWORD *)&context + 1) + 8);
      do
        v225 = __ldaxr(v224);
      while (__stlxr(v225 - 1, v224));
      if (!v225)
      {
        ((void (*)(std::__shared_weak_count *))v223->__on_zero_shared)(v223);
        std::__shared_weak_count::__release_weak(v223);
      }
    }
    v226 = 0;
    v227 = 0;
    v228 = (const __CFArray *)cf;
    if (cf)
      v229 = ctu::SharedRef<void const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,void const>::get;
    else
      v229 = 0;
    if (v229)
      v230 = cf == 0;
    else
      v230 = 1;
    if (!v230)
    {
      v231 = CFGetTypeID(cf);
      if (v231 == CFArrayGetTypeID())
      {
        memset(&buf, 0, sizeof(buf));
        *(_QWORD *)&context = &buf;
        v356.length = CFArrayGetCount(v228);
        v356.location = 0;
        CFArrayApplyFunction(v228, v356, (CFArrayApplierFunction)ctu::cf::_Applier_InsertArrayDefault<unsigned short,std::back_insert_iterator<std::vector<unsigned short>>>, &context);
        v227 = buf.__r_.__value_.__l.__size_;
        v226 = (void *)buf.__r_.__value_.__r.__words[0];
      }
      else
      {
        v226 = 0;
        v227 = 0;
      }
    }
    ctu::SharedRef<void const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,void const>::~SharedRef(&cf);
    cf = 0;
    v232 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 64));
    ctu::shared_ptr_map_impl<ctu::indexed_by_any_map_hashing_key>::get<CarrierSettingsInterface>(v232, &context);
    v233 = context;
    v234 = *(unsigned int *)(a1 + 8);
    v235 = operator new(0x10uLL);
    buf.__r_.__value_.__l.__size_ = (std::string::size_type)(v235 + 2);
    buf.__r_.__value_.__r.__words[2] = (std::string::size_type)(v235 + 2);
    *v235 = v222;
    v235[1] = CFSTR("PcoMcc");
    buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v235;
    (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint64_t, uint64_t, std::string *, _QWORD, _QWORD))(*(_QWORD *)v233 + 88))(&cf, v233, v234, 1, &buf, 0, 0);
    if (buf.__r_.__value_.__r.__words[0])
    {
      buf.__r_.__value_.__l.__size_ = buf.__r_.__value_.__r.__words[0];
      operator delete(buf.__r_.__value_.__l.__data_);
    }
    v236 = (std::__shared_weak_count *)*((_QWORD *)&context + 1);
    if (*((_QWORD *)&context + 1))
    {
      v237 = (unint64_t *)(*((_QWORD *)&context + 1) + 8);
      do
        v238 = __ldaxr(v237);
      while (__stlxr(v238 - 1, v237));
      if (!v238)
      {
        ((void (*)(std::__shared_weak_count *))v236->__on_zero_shared)(v236);
        std::__shared_weak_count::__release_weak(v236);
      }
    }
    v239 = (unsigned __int16 *)cf;
    if (cf)
      v240 = ctu::SharedRef<void const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,void const>::get;
    else
      v240 = 0;
    if (v240)
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      if (cf)
      {
        v241 = CFGetTypeID(cf);
        if (v241 == CFNumberGetTypeID())
          ctu::cf::assign((ctu::cf *)&buf, v239, v242);
      }
      data_low = LOWORD(buf.__r_.__value_.__l.__data_);
    }
    else
    {
      data_low = 0;
    }
    ctu::SharedRef<void const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,void const>::~SharedRef(&cf);
    cf = 0;
    v244 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 64));
    ctu::shared_ptr_map_impl<ctu::indexed_by_any_map_hashing_key>::get<CarrierSettingsInterface>(v244, &context);
    v245 = context;
    v246 = *(unsigned int *)(a1 + 8);
    v247 = operator new(0x10uLL);
    buf.__r_.__value_.__l.__size_ = (std::string::size_type)(v247 + 2);
    buf.__r_.__value_.__r.__words[2] = (std::string::size_type)(v247 + 2);
    *v247 = v222;
    v247[1] = CFSTR("PcoMnc");
    buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v247;
    (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint64_t, uint64_t, std::string *, _QWORD, _QWORD))(*(_QWORD *)v245 + 88))(&cf, v245, v246, 1, &buf, 0, 0);
    if (buf.__r_.__value_.__r.__words[0])
    {
      buf.__r_.__value_.__l.__size_ = buf.__r_.__value_.__r.__words[0];
      operator delete(buf.__r_.__value_.__l.__data_);
    }
    v248 = (std::__shared_weak_count *)*((_QWORD *)&context + 1);
    if (*((_QWORD *)&context + 1))
    {
      v249 = (unint64_t *)(*((_QWORD *)&context + 1) + 8);
      do
        v250 = __ldaxr(v249);
      while (__stlxr(v250 - 1, v249));
      if (!v250)
      {
        ((void (*)(std::__shared_weak_count *))v248->__on_zero_shared)(v248);
        std::__shared_weak_count::__release_weak(v248);
      }
    }
    v251 = (unsigned __int16 *)cf;
    if (cf)
      v252 = ctu::SharedRef<void const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,void const>::get;
    else
      v252 = 0;
    if (v252)
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      if (cf)
      {
        v253 = CFGetTypeID(cf);
        if (v253 == CFNumberGetTypeID())
          ctu::cf::assign((ctu::cf *)&buf, v251, v254);
      }
      v255 = LOWORD(buf.__r_.__value_.__l.__data_);
    }
    else
    {
      v255 = 0;
    }
    v217 = (capabilities::ct *)ctu::SharedRef<void const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,void const>::~SharedRef(&cf);
    if (data_low && v255 && (void *)v227 != v226)
    {
      v256 = *(NSObject **)(a1 + 56);
      if (os_log_type_enabled(v256, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"set3GPPParameters";
        _os_log_impl(&dword_216897000, v256, OS_LOG_TYPE_DEFAULT, "#I %s: Request PcoContainerIds", (uint8_t *)&buf, 0xCu);
      }
      v257 = (const void **)a2[1];
      v258 = (const void **)a2[2];
      v259 = v257;
      if (v257 != v258)
      {
        v259 = (const void **)a2[1];
        while (*((_BYTE *)*v259 + 8) != 56)
        {
          if (++v259 == v258)
            goto LABEL_386;
        }
      }
      if (v259 == v258)
      {
LABEL_386:
        v262 = operator new();
        *(_BYTE *)(v262 + 8) = 56;
        *(_WORD *)(v262 + 10) = 0;
        v261 = (_WORD *)(v262 + 10);
        *(_QWORD *)v262 = &off_24D5DD5C0;
        v263 = a2[3];
        v264 = (uint64_t *)a2[2];
        if ((unint64_t)v264 >= v263)
        {
          v265 = ((char *)v264 - *v44) >> 3;
          if ((unint64_t)(v265 + 1) >> 61)
            std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
          v266 = v263 - (_QWORD)*v44;
          v267 = v266 >> 2;
          if (v266 >> 2 <= (unint64_t)(v265 + 1))
            v267 = v265 + 1;
          if ((unint64_t)v266 >= 0x7FFFFFFFFFFFFFF8)
            v268 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v268 = v267;
          if (v268)
            v269 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a2 + 3), v268);
          else
            v269 = 0;
          v270 = (uint64_t *)&v269[8 * v265];
          v271 = &v269[8 * v268];
          *v270 = v262;
          v258 = (const void **)(v270 + 1);
          v273 = (char *)a2[1];
          v272 = (char *)a2[2];
          if (v272 != v273)
          {
            do
            {
              v274 = *((_QWORD *)v272 - 1);
              v272 -= 8;
              *--v270 = v274;
            }
            while (v272 != v273);
            v272 = *v44;
          }
          a2[1] = v270;
          a2[2] = v258;
          a2[3] = v271;
          if (v272)
            operator delete(v272);
        }
        else
        {
          *v264 = v262;
          v258 = (const void **)(v264 + 1);
        }
        a2[2] = v258;
        v257 = (const void **)a2[1];
      }
      else
      {
        if (!v260)
          __cxa_bad_cast();
        v261 = v260 + 10;
      }
      *v261 = data_low;
      while (v257 != v258)
      {
        if (*((_BYTE *)*v257 + 8) == 57)
        {
          if (v257 != v258)
          {
            if (!v275)
              __cxa_bad_cast();
            v276 = v275 + 10;
            goto LABEL_427;
          }
          break;
        }
        ++v257;
      }
      v277 = operator new();
      *(_BYTE *)(v277 + 8) = 57;
      *(_QWORD *)v277 = &off_24D5DD610;
      *(_WORD *)(v277 + 10) = 0;
      v276 = (char *)(v277 + 10);
      *(_BYTE *)(v277 + 12) = 0;
      v278 = a2[3];
      v279 = (uint64_t *)a2[2];
      if ((unint64_t)v279 >= v278)
      {
        v281 = ((char *)v279 - *v44) >> 3;
        if ((unint64_t)(v281 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v282 = v278 - (_QWORD)*v44;
        v283 = v282 >> 2;
        if (v282 >> 2 <= (unint64_t)(v281 + 1))
          v283 = v281 + 1;
        if ((unint64_t)v282 >= 0x7FFFFFFFFFFFFFF8)
          v284 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v284 = v283;
        if (v284)
          v285 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a2 + 3), v284);
        else
          v285 = 0;
        v286 = (uint64_t *)&v285[8 * v281];
        v287 = &v285[8 * v284];
        *v286 = v277;
        v280 = v286 + 1;
        v289 = (char *)a2[1];
        v288 = (char *)a2[2];
        if (v288 != v289)
        {
          do
          {
            v290 = *((_QWORD *)v288 - 1);
            v288 -= 8;
            *--v286 = v290;
          }
          while (v288 != v289);
          v288 = *v44;
        }
        a2[1] = v286;
        a2[2] = v280;
        a2[3] = v287;
        if (v288)
          operator delete(v288);
      }
      else
      {
        *v279 = v277;
        v280 = v279 + 1;
      }
      a2[2] = v280;
LABEL_427:
      *(_WORD *)v276 = v255;
      v276[2] = 1;
      *(_OWORD *)&buf.__r_.__value_.__l.__data_ = a1;
      buf.__r_.__value_.__r.__words[2] = 0;
      v352 = 0;
      std::vector<unsigned short>::__init_with_size[abi:ne180100]<unsigned short *,unsigned short *>(&buf.__r_.__value_.__l.__size_, v226, v227, (uint64_t)(v227 - (_QWORD)v226) >> 1);
      v353 = (uint64_t)(v227 - (_QWORD)v226) >> 1;
      v291 = (_QWORD *)qmi::MutableMessageBase::getTLV<wds::tlv::PcoContainerIds>(a2, 71);
      if (v353 >= 0xB)
      {
        v292 = *(NSObject **)(buf.__r_.__value_.__r.__words[0] + 56);
        if (os_log_type_enabled(v292, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(context) = 134217984;
          *(_QWORD *)((char *)&context + 4) = 10;
          _os_log_impl(&dword_216897000, v292, OS_LOG_TYPE_DEFAULT, "#E Too many container IDs in CB. Using only the first %lu IDs", (uint8_t *)&context, 0xCu);
        }
      }
      *v291 = 0;
      v291[1] = 0;
      *((_DWORD *)v291 + 4) = 0;
      v293 = v353;
      if (v353 >= 0xA)
        v293 = 10;
      if (v293)
        memmove(v291, (const void *)buf.__r_.__value_.__l.__size_, 2 * v293);
      v217 = (capabilities::ct *)buf.__r_.__value_.__l.__size_;
      if (buf.__r_.__value_.__l.__size_)
      {
        buf.__r_.__value_.__r.__words[2] = buf.__r_.__value_.__l.__size_;
        operator delete((void *)buf.__r_.__value_.__l.__size_);
      }
    }
    if (v226)
      operator delete(v226);
  }
  if (capabilities::ct::supportsDataQMIExtensions(v217)
    && (*(unsigned int (**)(uint64_t))(*(_QWORD *)v349 + 176))(v349))
  {
    v294 = (const void **)a2[1];
    v295 = (const void **)a2[2];
    if (v294 != v295)
    {
      while (*((_BYTE *)*v294 + 8) != 78)
      {
        if (++v294 == v295)
          goto LABEL_447;
      }
    }
    if (v294 == v295)
    {
LABEL_447:
      v298 = operator new();
      *(_WORD *)(v298 + 8) = 78;
      *(_QWORD *)v298 = &off_24D5DD660;
      v299 = a2[3];
      v300 = (uint64_t *)a2[2];
      if ((unint64_t)v300 >= v299)
      {
        v302 = ((char *)v300 - *v44) >> 3;
        if ((unint64_t)(v302 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v303 = v299 - (_QWORD)*v44;
        v304 = v303 >> 2;
        if (v303 >> 2 <= (unint64_t)(v302 + 1))
          v304 = v302 + 1;
        if ((unint64_t)v303 >= 0x7FFFFFFFFFFFFFF8)
          v305 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v305 = v304;
        if (v305)
          v306 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a2 + 3), v305);
        else
          v306 = 0;
        v307 = (uint64_t *)&v306[8 * v302];
        v308 = &v306[8 * v305];
        *v307 = v298;
        v301 = v307 + 1;
        v310 = (char *)a2[1];
        v309 = (char *)a2[2];
        if (v309 != v310)
        {
          do
          {
            v311 = *((_QWORD *)v309 - 1);
            v309 -= 8;
            *--v307 = v311;
          }
          while (v309 != v310);
          v309 = *v44;
        }
        a2[1] = v307;
        a2[2] = v301;
        a2[3] = v308;
        if (v309)
          operator delete(v309);
      }
      else
      {
        *v300 = v298;
        v301 = v300 + 1;
      }
      v297 = (_BYTE *)(v298 + 9);
      a2[2] = v301;
    }
    else
    {
      if (!v296)
        __cxa_bad_cast();
      v297 = v296 + 9;
    }
    *v297 = 1;
  }
  if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__s.__r_.__value_.__l.__data_);
  if (SHIBYTE(v347.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v347.__r_.__value_.__l.__data_);
  if (SHIBYTE(v348.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v348.__r_.__value_.__l.__data_);
LABEL_471:
  v312 = v350;
  if (v350)
  {
    v313 = (unint64_t *)&v350->__shared_owners_;
    do
      v314 = __ldaxr(v313);
    while (__stlxr(v314 - 1, v313));
    if (!v314)
    {
      ((void (*)(std::__shared_weak_count *))v312->__on_zero_shared)(v312);
      std::__shared_weak_count::__release_weak(v312);
    }
  }
}

void sub_2169EE474(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,int a38,__int16 a39,char a40,char a41,void *__p,uint64_t a43,int a44,__int16 a45,char a46,char a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,int a60,__int16 a61,char a62,char a63)
{
  uint64_t v63;

  if (*(char *)(v63 - 201) < 0)
    operator delete(*(void **)(v63 - 224));
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v63 - 192);
  _Unwind_Resume(a1);
}

void Mav16QMIDataContextIPAggregator::set3GPP2Parameters(uint64_t a1, _QWORD *a2, int a3)
{
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  NSObject *v12;
  int v13;
  std::string::size_type v14;
  std::string *v15;
  std::string *p_p;
  uint64_t v17;
  const void **v18;
  const void **v19;
  char **v20;
  char *v21;
  std::string *v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t *v25;
  _QWORD *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  char *v31;
  uint64_t *v32;
  char *v33;
  char *v34;
  char *v35;
  uint64_t v36;
  const void **v37;
  const void **v38;
  char **v39;
  int *v40;
  uint64_t v41;
  unint64_t v42;
  uint64_t *v43;
  _QWORD *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t v48;
  char *v49;
  uint64_t *v50;
  char *v51;
  char *v52;
  char *v53;
  uint64_t v54;
  int v55;
  std::__shared_weak_count *v56;
  char v57;
  unint64_t *v58;
  unint64_t v59;
  std::string::size_type v60;
  std::string::size_type v61;
  const void **v62;
  const void **v63;
  char *v64;
  std::string *v65;
  uint64_t v66;
  unint64_t v67;
  uint64_t *v68;
  _QWORD *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  unint64_t v73;
  char *v74;
  const void **v75;
  const void **v76;
  char *v77;
  std::string *v78;
  uint64_t v79;
  unint64_t v80;
  uint64_t *v81;
  _QWORD *v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  unint64_t v86;
  char *v87;
  uint64_t *v88;
  char *v89;
  char *v90;
  char *v91;
  uint64_t v92;
  const void **v93;
  const void **v94;
  char *v95;
  std::string *v96;
  uint64_t v97;
  unint64_t v98;
  uint64_t *v99;
  _QWORD *v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  unint64_t v104;
  char *v105;
  uint64_t *v106;
  char *v107;
  char *v108;
  char *v109;
  uint64_t v110;
  std::string::size_type size;
  std::string::size_type v112;
  char *v113;
  uint64_t *v114;
  char *v115;
  char *v116;
  char *v117;
  uint64_t v118;
  const void **v119;
  const void **v120;
  char *v121;
  std::string *v122;
  uint64_t v123;
  unint64_t v124;
  uint64_t *v125;
  _QWORD *v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  unint64_t v130;
  char *v131;
  uint64_t *v132;
  char *v133;
  char *v134;
  char *v135;
  uint64_t v136;
  const void **v137;
  const void **v138;
  _BYTE *v139;
  uint64_t v140;
  unint64_t v141;
  uint64_t *v142;
  _QWORD *v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  unint64_t v147;
  char *v148;
  uint64_t *v149;
  char *v150;
  char *v151;
  char *v152;
  uint64_t v153;
  const void **v154;
  const void **v155;
  _DWORD *v156;
  uint64_t v157;
  unint64_t v158;
  uint64_t *v159;
  _QWORD *v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  unint64_t v164;
  char *v165;
  uint64_t *v166;
  char *v167;
  char *v168;
  char *v169;
  uint64_t v170;
  const void **v171;
  const void **v172;
  char *v173;
  _BYTE *v174;
  uint64_t v175;
  unint64_t v176;
  uint64_t *v177;
  _QWORD *v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  unint64_t v182;
  char *v183;
  uint64_t *v184;
  char *v185;
  char *v186;
  char *v187;
  uint64_t v188;
  NSObject *v189;
  unint64_t *v190;
  unint64_t v191;
  const void **v192;
  const void **v193;
  char *v194;
  _WORD *v195;
  uint64_t v196;
  unint64_t v197;
  uint64_t *v198;
  _QWORD *v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  unint64_t v203;
  char *v204;
  uint64_t *v205;
  char *v206;
  char *v207;
  char *v208;
  uint64_t v209;
  std::__shared_weak_count *v210;
  unint64_t *v211;
  unint64_t v212;
  std::__shared_weak_count *v213;
  unint64_t *v214;
  unint64_t v215;
  _QWORD v216[2];
  uint64_t (*v217)(uint64_t, _WORD *);
  void *v218;
  uint64_t v219;
  std::__shared_weak_count *v220;
  _QWORD v221[2];
  const void **(*v222)(uint64_t, _DWORD *);
  void *v223;
  uint64_t v224;
  _QWORD v225[2];
  uint64_t (*v226)(uint64_t, _BYTE *);
  void *v227;
  int v228;
  _QWORD v229[2];
  void (*v230)(uint64_t, std::string *);
  void *v231;
  std::string v232;
  _QWORD v233[2];
  void (*v234)(uint64_t, std::string *);
  void *v235;
  std::string v236;
  _QWORD v237[4];
  int v238;
  uint64_t v239;
  uint64_t v240;
  void (*v241)(uint64_t, std::string *);
  void *v242;
  std::string v243;
  uint64_t v244;
  uint64_t v245;
  void (*v246)(uint64_t, std::string *);
  void *v247;
  std::string v248;
  _QWORD v249[2];
  void (*v250)(uint64_t, int *);
  void *v251;
  uint64_t v252;
  int v253;
  uint64_t v254;
  uint64_t v255;
  void (*v256)(uint64_t, std::string *);
  void *v257;
  std::string v258;
  std::string __p;
  std::string v260;
  uint64_t v261;
  std::__shared_weak_count *v262;
  std::string v263;
  std::string buf;
  std::string *v265;
  uint64_t v266;

  v266 = *MEMORY[0x24BDAC8D0];
  v6 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(a1 + 88));
  buf.__r_.__value_.__r.__words[0] = *(_QWORD *)(a1 + 80);
  buf.__r_.__value_.__l.__size_ = (std::string::size_type)v6;
  v261 = 0;
  v262 = 0;
  (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)buf.__r_.__value_.__l.__data_ + 32))(&v261);
  p_shared_owners = (unint64_t *)&v6->__shared_owners_;
  do
    v8 = __ldaxr(p_shared_owners);
  while (__stlxr(v8 - 1, p_shared_owners));
  if (!v8)
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
  if (!v261)
    goto LABEL_337;
  memset(&v260, 0, sizeof(v260));
  std::string::basic_string[abi:ne180100]<0>(&v260, (char *)&unk_216AC4FCA);
  if (((*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v261 + 88))(v261, 0) & 1) == 0)
  {
    v9 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(a1 + 88));
    __p.__r_.__value_.__r.__words[0] = *(_QWORD *)(a1 + 80);
    __p.__r_.__value_.__l.__size_ = (std::string::size_type)v9;
    (*(void (**)(std::string *__return_ptr))(*(_QWORD *)__p.__r_.__value_.__l.__data_ + 312))(&buf);
    if (SHIBYTE(v260.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v260.__r_.__value_.__l.__data_);
    v260 = buf;
    *((_BYTE *)&buf.__r_.__value_.__s + 23) = 0;
    buf.__r_.__value_.__s.__data_[0] = 0;
    v10 = (unint64_t *)&v9->__shared_owners_;
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
    if ((*(unsigned int (**)(uint64_t, _QWORD))(*(_QWORD *)v261 + 104))(v261, 0)
      && (*(unsigned int (**)(uint64_t))(*(_QWORD *)v261 + 80))(v261))
    {
      v12 = *(NSObject **)(a1 + 56);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        v13 = SHIBYTE(v260.__r_.__value_.__r.__words[2]);
        v14 = v260.__r_.__value_.__r.__words[0];
        (*(void (**)(std::string *__return_ptr))(*(_QWORD *)v261 + 288))(&__p);
        v15 = &v260;
        if (v13 < 0)
          v15 = (std::string *)v14;
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          p_p = &__p;
        else
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315650;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"set3GPP2Parameters";
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v15;
        HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
        v265 = p_p;
        _os_log_impl(&dword_216897000, v12, OS_LOG_TYPE_DEFAULT, "#I %s: Modifying APN name %s to alt-name %s in 3GPP2 parameters", (uint8_t *)&buf, 0x20u);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
      }
      (*(void (**)(std::string *__return_ptr))(*(_QWORD *)v261 + 288))(&buf);
      if (SHIBYTE(v260.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v260.__r_.__value_.__l.__data_);
      v260 = buf;
    }
  }
  v17 = MEMORY[0x24BDAC760];
  if (SHIBYTE(v260.__r_.__value_.__r.__words[2]) < 0)
  {
    if (!v260.__r_.__value_.__l.__size_)
      goto LABEL_57;
    v254 = MEMORY[0x24BDAC760];
    v255 = 1174405120;
    v256 = ___ZN31Mav16QMIDataContextIPAggregator18set3GPP2ParametersERN3wds29ResetAndModifyProfileSettings7RequestE18DataProtocolFamily_block_invoke;
    v257 = &__block_descriptor_tmp_92_1;
    std::string::__init_copy_ctor_external(&v258, v260.__r_.__value_.__l.__data_, v260.__r_.__value_.__l.__size_);
  }
  else
  {
    if (!*((_BYTE *)&v260.__r_.__value_.__s + 23))
      goto LABEL_57;
    v254 = MEMORY[0x24BDAC760];
    v255 = 1174405120;
    v256 = ___ZN31Mav16QMIDataContextIPAggregator18set3GPP2ParametersERN3wds29ResetAndModifyProfileSettings7RequestE18DataProtocolFamily_block_invoke;
    v257 = &__block_descriptor_tmp_92_1;
    v258 = v260;
  }
  v18 = (const void **)a2[1];
  v19 = (const void **)a2[2];
  v20 = (char **)(a2 + 1);
  if (v18 != v19)
  {
    while (*((unsigned __int8 *)*v18 + 8) != 161)
    {
      if (++v18 == v19)
        goto LABEL_38;
    }
  }
  if (v18 == v19)
  {
LABEL_38:
    v23 = operator new();
    *(_BYTE *)(v23 + 8) = -95;
    *(_QWORD *)v23 = off_24D5DD6B0;
    *(_QWORD *)(v23 + 16) = 0;
    v22 = (std::string *)(v23 + 16);
    *(_QWORD *)(v23 + 24) = 0;
    *(_QWORD *)(v23 + 32) = 0;
    v24 = a2[3];
    v25 = (uint64_t *)a2[2];
    if ((unint64_t)v25 >= v24)
    {
      v27 = ((char *)v25 - *v20) >> 3;
      if ((unint64_t)(v27 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v28 = v24 - (_QWORD)*v20;
      v29 = v28 >> 2;
      if (v28 >> 2 <= (unint64_t)(v27 + 1))
        v29 = v27 + 1;
      if ((unint64_t)v28 >= 0x7FFFFFFFFFFFFFF8)
        v30 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v30 = v29;
      if (v30)
        v31 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a2 + 3), v30);
      else
        v31 = 0;
      v32 = (uint64_t *)&v31[8 * v27];
      v33 = &v31[8 * v30];
      *v32 = v23;
      v26 = v32 + 1;
      v35 = (char *)a2[1];
      v34 = (char *)a2[2];
      if (v34 != v35)
      {
        do
        {
          v36 = *((_QWORD *)v34 - 1);
          v34 -= 8;
          *--v32 = v36;
        }
        while (v34 != v35);
        v34 = *v20;
      }
      a2[1] = v32;
      a2[2] = v26;
      a2[3] = v33;
      if (v34)
        operator delete(v34);
    }
    else
    {
      *v25 = v23;
      v26 = v25 + 1;
    }
    a2[2] = v26;
  }
  else
  {
    if (!v21)
      __cxa_bad_cast();
    v22 = (std::string *)(v21 + 16);
  }
  v256((uint64_t)&v254, v22);
  if (SHIBYTE(v258.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v258.__r_.__value_.__l.__data_);
LABEL_57:
  v249[0] = v17;
  v249[1] = 0x40000000;
  v250 = ___ZN31Mav16QMIDataContextIPAggregator18set3GPP2ParametersERN3wds29ResetAndModifyProfileSettings7RequestE18DataProtocolFamily_block_invoke_93;
  v251 = &__block_descriptor_tmp_95_1;
  v252 = a1;
  v253 = a3;
  v37 = (const void **)a2[1];
  v38 = (const void **)a2[2];
  v39 = (char **)(a2 + 1);
  if (v37 != v38)
  {
    while (*((unsigned __int8 *)*v37 + 8) != 162)
    {
      if (++v37 == v38)
        goto LABEL_64;
    }
  }
  if (v37 == v38)
  {
LABEL_64:
    v41 = operator new();
    *(_BYTE *)(v41 + 8) = -94;
    *(_DWORD *)(v41 + 12) = 0;
    *(_QWORD *)v41 = &off_24D5DD700;
    v42 = a2[3];
    v43 = (uint64_t *)a2[2];
    if ((unint64_t)v43 >= v42)
    {
      v45 = ((char *)v43 - *v39) >> 3;
      if ((unint64_t)(v45 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v46 = v42 - (_QWORD)*v39;
      v47 = v46 >> 2;
      if (v46 >> 2 <= (unint64_t)(v45 + 1))
        v47 = v45 + 1;
      if ((unint64_t)v46 >= 0x7FFFFFFFFFFFFFF8)
        v48 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v48 = v47;
      if (v48)
        v49 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a2 + 3), v48);
      else
        v49 = 0;
      v50 = (uint64_t *)&v49[8 * v45];
      v51 = &v49[8 * v48];
      *v50 = v41;
      v44 = v50 + 1;
      v53 = (char *)a2[1];
      v52 = (char *)a2[2];
      if (v52 != v53)
      {
        do
        {
          v54 = *((_QWORD *)v52 - 1);
          v52 -= 8;
          *--v50 = v54;
        }
        while (v52 != v53);
        v52 = *v39;
      }
      a2[1] = v50;
      a2[2] = v44;
      a2[3] = v51;
      if (v52)
        operator delete(v52);
    }
    else
    {
      *v43 = v41;
      v44 = v43 + 1;
    }
    a2[2] = v44;
    v250((uint64_t)v249, (int *)(v41 + 12));
  }
  else
  {
    if (!v40)
      __cxa_bad_cast();
    ___ZN31Mav16QMIDataContextIPAggregator18set3GPP2ParametersERN3wds29ResetAndModifyProfileSettings7RequestE18DataProtocolFamily_block_invoke_93((uint64_t)v249, v40 + 3);
  }
  memset(&buf, 0, sizeof(buf));
  (*(void (**)(std::string *__return_ptr))(*(_QWORD *)v261 + 264))(&buf);
  memset(&__p, 0, sizeof(__p));
  (*(void (**)(std::string *__return_ptr))(*(_QWORD *)v261 + 272))(&__p);
  (*(void (**)(std::string *__return_ptr))(*(_QWORD *)v261 + 280))(&v263);
  v55 = wds::apply(&v263);
  if (SHIBYTE(v263.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v263.__r_.__value_.__l.__data_);
  v56 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(a1 + 88));
  v263.__r_.__value_.__r.__words[0] = *(_QWORD *)(a1 + 80);
  v263.__r_.__value_.__l.__size_ = (std::string::size_type)v56;
  v57 = (*(uint64_t (**)(std::string::size_type))(*(_QWORD *)v263.__r_.__value_.__l.__data_ + 376))(v263.__r_.__value_.__r.__words[0]);
  v58 = (unint64_t *)&v56->__shared_owners_;
  do
    v59 = __ldaxr(v58);
  while (__stlxr(v59 - 1, v58));
  if (!v59)
  {
    ((void (*)(std::__shared_weak_count *))v56->__on_zero_shared)(v56);
    std::__shared_weak_count::__release_weak(v56);
  }
  if ((v57 & 1) == 0)
  {
    if ((*((_BYTE *)&buf.__r_.__value_.__s + 23) & 0x80) != 0)
    {
      if (!buf.__r_.__value_.__l.__size_)
        goto LABEL_146;
      v244 = v17;
      v245 = 1174405120;
      v246 = ___ZN31Mav16QMIDataContextIPAggregator18set3GPP2ParametersERN3wds29ResetAndModifyProfileSettings7RequestE18DataProtocolFamily_block_invoke_96;
      v247 = &__block_descriptor_tmp_97_2;
      std::string::__init_copy_ctor_external(&v248, buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_);
    }
    else
    {
      if (!*((_BYTE *)&buf.__r_.__value_.__s + 23))
        goto LABEL_146;
      v244 = v17;
      v245 = 1174405120;
      v246 = ___ZN31Mav16QMIDataContextIPAggregator18set3GPP2ParametersERN3wds29ResetAndModifyProfileSettings7RequestE18DataProtocolFamily_block_invoke_96;
      v247 = &__block_descriptor_tmp_97_2;
      v248 = buf;
    }
    v62 = (const void **)a2[1];
    v63 = (const void **)a2[2];
    if (v62 != v63)
    {
      while (*((unsigned __int8 *)*v62 + 8) != 155)
      {
        if (++v62 == v63)
          goto LABEL_109;
      }
    }
    if (v62 == v63)
    {
LABEL_109:
      v66 = operator new();
      *(_BYTE *)(v66 + 8) = -101;
      *(_QWORD *)v66 = off_24D5DD750;
      *(_QWORD *)(v66 + 16) = 0;
      v65 = (std::string *)(v66 + 16);
      *(_QWORD *)(v66 + 24) = 0;
      *(_QWORD *)(v66 + 32) = 0;
      v67 = a2[3];
      v68 = (uint64_t *)a2[2];
      if ((unint64_t)v68 >= v67)
      {
        v70 = ((char *)v68 - *v39) >> 3;
        if ((unint64_t)(v70 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v71 = v67 - (_QWORD)*v39;
        v72 = v71 >> 2;
        if (v71 >> 2 <= (unint64_t)(v70 + 1))
          v72 = v70 + 1;
        if ((unint64_t)v71 >= 0x7FFFFFFFFFFFFFF8)
          v73 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v73 = v72;
        if (v73)
          v74 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a2 + 3), v73);
        else
          v74 = 0;
        v88 = (uint64_t *)&v74[8 * v70];
        v89 = &v74[8 * v73];
        *v88 = v66;
        v69 = v88 + 1;
        v91 = (char *)a2[1];
        v90 = (char *)a2[2];
        if (v90 != v91)
        {
          do
          {
            v92 = *((_QWORD *)v90 - 1);
            v90 -= 8;
            *--v88 = v92;
          }
          while (v90 != v91);
          v90 = *v39;
        }
        a2[1] = v88;
        a2[2] = v69;
        a2[3] = v89;
        if (v90)
          operator delete(v90);
      }
      else
      {
        *v68 = v66;
        v69 = v68 + 1;
      }
      a2[2] = v69;
    }
    else
    {
      if (!v64)
        __cxa_bad_cast();
      v65 = (std::string *)(v64 + 16);
    }
    v246((uint64_t)&v244, v65);
    if (SHIBYTE(v248.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v248.__r_.__value_.__l.__data_);
LABEL_146:
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      if (__p.__r_.__value_.__l.__size_)
      {
        v239 = v17;
        v240 = 1174405120;
        v241 = ___ZN31Mav16QMIDataContextIPAggregator18set3GPP2ParametersERN3wds29ResetAndModifyProfileSettings7RequestE18DataProtocolFamily_block_invoke_98;
        v242 = &__block_descriptor_tmp_99_1;
        std::string::__init_copy_ctor_external(&v243, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
        goto LABEL_151;
      }
    }
    else if (*((_BYTE *)&__p.__r_.__value_.__s + 23))
    {
      v239 = v17;
      v240 = 1174405120;
      v241 = ___ZN31Mav16QMIDataContextIPAggregator18set3GPP2ParametersERN3wds29ResetAndModifyProfileSettings7RequestE18DataProtocolFamily_block_invoke_98;
      v242 = &__block_descriptor_tmp_99_1;
      v243 = __p;
LABEL_151:
      v93 = (const void **)a2[1];
      v94 = (const void **)a2[2];
      if (v93 != v94)
      {
        while (*((unsigned __int8 *)*v93 + 8) != 156)
        {
          if (++v93 == v94)
            goto LABEL_158;
        }
      }
      if (v93 == v94)
      {
LABEL_158:
        v97 = operator new();
        *(_BYTE *)(v97 + 8) = -100;
        *(_QWORD *)v97 = off_24D5DD7A0;
        *(_QWORD *)(v97 + 16) = 0;
        v96 = (std::string *)(v97 + 16);
        *(_QWORD *)(v97 + 24) = 0;
        *(_QWORD *)(v97 + 32) = 0;
        v98 = a2[3];
        v99 = (uint64_t *)a2[2];
        if ((unint64_t)v99 >= v98)
        {
          v101 = ((char *)v99 - *v39) >> 3;
          if ((unint64_t)(v101 + 1) >> 61)
            std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
          v102 = v98 - (_QWORD)*v39;
          v103 = v102 >> 2;
          if (v102 >> 2 <= (unint64_t)(v101 + 1))
            v103 = v101 + 1;
          if ((unint64_t)v102 >= 0x7FFFFFFFFFFFFFF8)
            v104 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v104 = v103;
          if (v104)
            v105 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a2 + 3), v104);
          else
            v105 = 0;
          v106 = (uint64_t *)&v105[8 * v101];
          v107 = &v105[8 * v104];
          *v106 = v97;
          v100 = v106 + 1;
          v109 = (char *)a2[1];
          v108 = (char *)a2[2];
          if (v108 != v109)
          {
            do
            {
              v110 = *((_QWORD *)v108 - 1);
              v108 -= 8;
              *--v106 = v110;
            }
            while (v108 != v109);
            v108 = *v39;
          }
          a2[1] = v106;
          a2[2] = v100;
          a2[3] = v107;
          if (v108)
            operator delete(v108);
        }
        else
        {
          *v99 = v97;
          v100 = v99 + 1;
        }
        a2[2] = v100;
      }
      else
      {
        if (!v95)
          __cxa_bad_cast();
        v96 = (std::string *)(v95 + 16);
      }
      v241((uint64_t)&v239, v96);
      if (SHIBYTE(v243.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v243.__r_.__value_.__l.__data_);
    }
    size = HIBYTE(buf.__r_.__value_.__r.__words[2]);
    if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      size = buf.__r_.__value_.__l.__size_;
    if (size)
      goto LABEL_183;
    v112 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      v112 = __p.__r_.__value_.__l.__size_;
    if (v112)
    {
LABEL_183:
      v237[0] = v17;
      v237[1] = 0x40000000;
      v237[2] = ___ZN31Mav16QMIDataContextIPAggregator18set3GPP2ParametersERN3wds29ResetAndModifyProfileSettings7RequestE18DataProtocolFamily_block_invoke_100;
      v237[3] = &__block_descriptor_tmp_101_1;
      v238 = v55;
      v113 = qmi::MutableMessageBase::getTLV<wds::tlv::Profile3GPP2_AuthPref>(a2);
      ___ZN31Mav16QMIDataContextIPAggregator18set3GPP2ParametersERN3wds29ResetAndModifyProfileSettings7RequestE18DataProtocolFamily_block_invoke_100((uint64_t)v237, v113);
    }
    goto LABEL_246;
  }
  if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v60 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
  else
    v60 = buf.__r_.__value_.__l.__size_;
  if (v60)
  {
    v61 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      v61 = __p.__r_.__value_.__l.__size_;
    if (v61)
    {
      v233[0] = v17;
      v233[1] = 1174405120;
      v234 = ___ZN31Mav16QMIDataContextIPAggregator18set3GPP2ParametersERN3wds29ResetAndModifyProfileSettings7RequestE18DataProtocolFamily_block_invoke_2;
      v235 = &__block_descriptor_tmp_102_1;
      if ((*((_BYTE *)&buf.__r_.__value_.__s + 23) & 0x80) != 0)
        std::string::__init_copy_ctor_external(&v236, buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_);
      else
        v236 = buf;
      v75 = (const void **)a2[1];
      v76 = (const void **)a2[2];
      if (v75 != v76)
      {
        while (*((unsigned __int8 *)*v75 + 8) != 174)
        {
          if (++v75 == v76)
            goto LABEL_127;
        }
      }
      if (v75 == v76)
      {
LABEL_127:
        v79 = operator new();
        *(_BYTE *)(v79 + 8) = -82;
        *(_QWORD *)v79 = off_24D5DD7F0;
        *(_QWORD *)(v79 + 16) = 0;
        v78 = (std::string *)(v79 + 16);
        *(_QWORD *)(v79 + 24) = 0;
        *(_QWORD *)(v79 + 32) = 0;
        v80 = a2[3];
        v81 = (uint64_t *)a2[2];
        if ((unint64_t)v81 >= v80)
        {
          v83 = ((char *)v81 - *v39) >> 3;
          if ((unint64_t)(v83 + 1) >> 61)
            std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
          v84 = v80 - (_QWORD)*v39;
          v85 = v84 >> 2;
          if (v84 >> 2 <= (unint64_t)(v83 + 1))
            v85 = v83 + 1;
          if ((unint64_t)v84 >= 0x7FFFFFFFFFFFFFF8)
            v86 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v86 = v85;
          if (v86)
            v87 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a2 + 3), v86);
          else
            v87 = 0;
          v114 = (uint64_t *)&v87[8 * v83];
          v115 = &v87[8 * v86];
          *v114 = v79;
          v82 = v114 + 1;
          v117 = (char *)a2[1];
          v116 = (char *)a2[2];
          if (v116 != v117)
          {
            do
            {
              v118 = *((_QWORD *)v116 - 1);
              v116 -= 8;
              *--v114 = v118;
            }
            while (v116 != v117);
            v116 = *v39;
          }
          a2[1] = v114;
          a2[2] = v82;
          a2[3] = v115;
          if (v116)
            operator delete(v116);
        }
        else
        {
          *v81 = v79;
          v82 = v81 + 1;
        }
        a2[2] = v82;
      }
      else
      {
        if (!v77)
          __cxa_bad_cast();
        v78 = (std::string *)(v77 + 16);
      }
      v234((uint64_t)v233, v78);
      v229[0] = v17;
      v229[1] = 1174405120;
      v230 = ___ZN31Mav16QMIDataContextIPAggregator18set3GPP2ParametersERN3wds29ResetAndModifyProfileSettings7RequestE18DataProtocolFamily_block_invoke_103;
      v231 = &__block_descriptor_tmp_104_1;
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        std::string::__init_copy_ctor_external(&v232, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
      else
        v232 = __p;
      v119 = (const void **)a2[1];
      v120 = (const void **)a2[2];
      if (v119 != v120)
      {
        while (*((unsigned __int8 *)*v119 + 8) != 175)
        {
          if (++v119 == v120)
            goto LABEL_201;
        }
      }
      if (v119 == v120)
      {
LABEL_201:
        v123 = operator new();
        *(_BYTE *)(v123 + 8) = -81;
        *(_QWORD *)v123 = off_24D5DD840;
        *(_QWORD *)(v123 + 16) = 0;
        v122 = (std::string *)(v123 + 16);
        *(_QWORD *)(v123 + 24) = 0;
        *(_QWORD *)(v123 + 32) = 0;
        v124 = a2[3];
        v125 = (uint64_t *)a2[2];
        if ((unint64_t)v125 >= v124)
        {
          v127 = ((char *)v125 - *v39) >> 3;
          if ((unint64_t)(v127 + 1) >> 61)
            std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
          v128 = v124 - (_QWORD)*v39;
          v129 = v128 >> 2;
          if (v128 >> 2 <= (unint64_t)(v127 + 1))
            v129 = v127 + 1;
          if ((unint64_t)v128 >= 0x7FFFFFFFFFFFFFF8)
            v130 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v130 = v129;
          if (v130)
            v131 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a2 + 3), v130);
          else
            v131 = 0;
          v132 = (uint64_t *)&v131[8 * v127];
          v133 = &v131[8 * v130];
          *v132 = v123;
          v126 = v132 + 1;
          v135 = (char *)a2[1];
          v134 = (char *)a2[2];
          if (v134 != v135)
          {
            do
            {
              v136 = *((_QWORD *)v134 - 1);
              v134 -= 8;
              *--v132 = v136;
            }
            while (v134 != v135);
            v134 = *v39;
          }
          a2[1] = v132;
          a2[2] = v126;
          a2[3] = v133;
          if (v134)
            operator delete(v134);
        }
        else
        {
          *v125 = v123;
          v126 = v125 + 1;
        }
        a2[2] = v126;
      }
      else
      {
        if (!v121)
          __cxa_bad_cast();
        v122 = (std::string *)(v121 + 16);
      }
      v230((uint64_t)v229, v122);
      v225[0] = v17;
      v225[1] = 0x40000000;
      v226 = ___ZN31Mav16QMIDataContextIPAggregator18set3GPP2ParametersERN3wds29ResetAndModifyProfileSettings7RequestE18DataProtocolFamily_block_invoke_105;
      v227 = &__block_descriptor_tmp_107_2;
      v228 = v55;
      v137 = (const void **)a2[1];
      v138 = (const void **)a2[2];
      if (v137 != v138)
      {
        while (*((unsigned __int8 *)*v137 + 8) != 173)
        {
          if (++v137 == v138)
            goto LABEL_225;
        }
      }
      if (v137 == v138)
      {
LABEL_225:
        v140 = operator new();
        *(_WORD *)(v140 + 8) = 173;
        *(_QWORD *)v140 = &off_24D5DD890;
        v141 = a2[3];
        v142 = (uint64_t *)a2[2];
        if ((unint64_t)v142 >= v141)
        {
          v144 = ((char *)v142 - *v39) >> 3;
          if ((unint64_t)(v144 + 1) >> 61)
            std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
          v145 = v141 - (_QWORD)*v39;
          v146 = v145 >> 2;
          if (v145 >> 2 <= (unint64_t)(v144 + 1))
            v146 = v144 + 1;
          if ((unint64_t)v145 >= 0x7FFFFFFFFFFFFFF8)
            v147 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v147 = v146;
          if (v147)
            v148 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a2 + 3), v147);
          else
            v148 = 0;
          v149 = (uint64_t *)&v148[8 * v144];
          v150 = &v148[8 * v147];
          *v149 = v140;
          v143 = v149 + 1;
          v152 = (char *)a2[1];
          v151 = (char *)a2[2];
          if (v151 != v152)
          {
            do
            {
              v153 = *((_QWORD *)v151 - 1);
              v151 -= 8;
              *--v149 = v153;
            }
            while (v151 != v152);
            v151 = *v39;
          }
          a2[1] = v149;
          a2[2] = v143;
          a2[3] = v150;
          if (v151)
            operator delete(v151);
        }
        else
        {
          *v142 = v140;
          v143 = v142 + 1;
        }
        a2[2] = v143;
        v226((uint64_t)v225, (_BYTE *)(v140 + 9));
      }
      else
      {
        if (!v139)
          __cxa_bad_cast();
        ___ZN31Mav16QMIDataContextIPAggregator18set3GPP2ParametersERN3wds29ResetAndModifyProfileSettings7RequestE18DataProtocolFamily_block_invoke_105((uint64_t)v225, v139 + 9);
      }
      if (SHIBYTE(v232.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v232.__r_.__value_.__l.__data_);
      if (SHIBYTE(v236.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v236.__r_.__value_.__l.__data_);
    }
  }
LABEL_246:
  v221[0] = v17;
  v221[1] = 0x40000000;
  v222 = ___ZN31Mav16QMIDataContextIPAggregator18set3GPP2ParametersERN3wds29ResetAndModifyProfileSettings7RequestE18DataProtocolFamily_block_invoke_2_108;
  v223 = &__block_descriptor_tmp_112_0;
  v224 = a1;
  v154 = (const void **)a2[1];
  v155 = (const void **)a2[2];
  if (v154 != v155)
  {
    while (*((unsigned __int8 *)*v154 + 8) != 170)
    {
      if (++v154 == v155)
        goto LABEL_253;
    }
  }
  if (v154 == v155)
  {
LABEL_253:
    v157 = operator new();
    *(_BYTE *)(v157 + 8) = -86;
    *(_DWORD *)(v157 + 12) = 0;
    *(_QWORD *)v157 = &off_24D5DD8E0;
    v158 = a2[3];
    v159 = (uint64_t *)a2[2];
    if ((unint64_t)v159 >= v158)
    {
      v161 = ((char *)v159 - *v39) >> 3;
      if ((unint64_t)(v161 + 1) >> 61)
        goto LABEL_345;
      v162 = v158 - (_QWORD)*v39;
      v163 = v162 >> 2;
      if (v162 >> 2 <= (unint64_t)(v161 + 1))
        v163 = v161 + 1;
      if ((unint64_t)v162 >= 0x7FFFFFFFFFFFFFF8)
        v164 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v164 = v163;
      if (v164)
        v165 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a2 + 3), v164);
      else
        v165 = 0;
      v166 = (uint64_t *)&v165[8 * v161];
      v167 = &v165[8 * v164];
      *v166 = v157;
      v160 = v166 + 1;
      v169 = (char *)a2[1];
      v168 = (char *)a2[2];
      if (v168 != v169)
      {
        do
        {
          v170 = *((_QWORD *)v168 - 1);
          v168 -= 8;
          *--v166 = v170;
        }
        while (v168 != v169);
        v168 = *v39;
      }
      a2[1] = v166;
      a2[2] = v160;
      a2[3] = v167;
      if (v168)
        operator delete(v168);
    }
    else
    {
      *v159 = v157;
      v160 = v159 + 1;
    }
    a2[2] = v160;
    v222((uint64_t)v221, (_DWORD *)(v157 + 12));
  }
  else
  {
    if (!v156)
      goto LABEL_343;
    ___ZN31Mav16QMIDataContextIPAggregator18set3GPP2ParametersERN3wds29ResetAndModifyProfileSettings7RequestE18DataProtocolFamily_block_invoke_2_108((uint64_t)v221, v156 + 3);
  }
  if ((*(unsigned int (**)(uint64_t, _QWORD))(*(_QWORD *)v261 + 56))(v261, 0))
  {
    v171 = (const void **)a2[1];
    v172 = (const void **)a2[2];
    if (v171 != v172)
    {
      while (*((unsigned __int8 *)*v171 + 8) != 163)
      {
        if (++v171 == v172)
          goto LABEL_278;
      }
    }
    if (v171 != v172)
    {
      if (v173)
      {
        v174 = v173 + 9;
LABEL_295:
        *v174 = 1;
        goto LABEL_296;
      }
LABEL_343:
      __cxa_bad_cast();
    }
LABEL_278:
    v175 = operator new();
    *(_WORD *)(v175 + 8) = 163;
    *(_QWORD *)v175 = &off_24D5DD930;
    v176 = a2[3];
    v177 = (uint64_t *)a2[2];
    if ((unint64_t)v177 < v176)
    {
      *v177 = v175;
      v178 = v177 + 1;
LABEL_294:
      v174 = (_BYTE *)(v175 + 9);
      a2[2] = v178;
      goto LABEL_295;
    }
    v179 = ((char *)v177 - *v39) >> 3;
    if (!((unint64_t)(v179 + 1) >> 61))
    {
      v180 = v176 - (_QWORD)*v39;
      v181 = v180 >> 2;
      if (v180 >> 2 <= (unint64_t)(v179 + 1))
        v181 = v179 + 1;
      if ((unint64_t)v180 >= 0x7FFFFFFFFFFFFFF8)
        v182 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v182 = v181;
      if (v182)
        v183 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a2 + 3), v182);
      else
        v183 = 0;
      v184 = (uint64_t *)&v183[8 * v179];
      v185 = &v183[8 * v182];
      *v184 = v175;
      v178 = v184 + 1;
      v187 = (char *)a2[1];
      v186 = (char *)a2[2];
      if (v186 != v187)
      {
        do
        {
          v188 = *((_QWORD *)v186 - 1);
          v186 -= 8;
          *--v184 = v188;
        }
        while (v186 != v187);
        v186 = *v39;
      }
      a2[1] = v184;
      a2[2] = v178;
      a2[3] = v185;
      if (v186)
        operator delete(v186);
      goto LABEL_294;
    }
LABEL_345:
    std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
  }
LABEL_296:
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v261 + 152))(v261))
  {
    v189 = *(NSObject **)(a1 + 56);
    if (os_log_type_enabled(v189, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v263.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)v263.__r_.__value_.__r.__words + 4) = (std::string::size_type)"set3GPP2Parameters";
      _os_log_impl(&dword_216897000, v189, OS_LOG_TYPE_DEFAULT, "#I %s: Applying PCO to SNI2", (uint8_t *)&v263, 0xCu);
    }
    v216[0] = v17;
    v216[1] = 1174405120;
    v217 = ___ZN31Mav16QMIDataContextIPAggregator18set3GPP2ParametersERN3wds29ResetAndModifyProfileSettings7RequestE18DataProtocolFamily_block_invoke_116;
    v218 = &__block_descriptor_tmp_118_2;
    v219 = v261;
    v220 = v262;
    if (v262)
    {
      v190 = (unint64_t *)&v262->__shared_owners_;
      do
        v191 = __ldxr(v190);
      while (__stxr(v191 + 1, v190));
    }
    v192 = (const void **)a2[1];
    v193 = (const void **)a2[2];
    if (v192 != v193)
    {
      while (*((unsigned __int8 *)*v192 + 8) != 189)
      {
        if (++v192 == v193)
          goto LABEL_309;
      }
    }
    if (v192 == v193)
    {
LABEL_309:
      v196 = operator new();
      *(_BYTE *)(v196 + 8) = -67;
      *(_WORD *)(v196 + 10) = 0;
      v195 = (_WORD *)(v196 + 10);
      *(_QWORD *)v196 = &off_24D5DD980;
      v197 = a2[3];
      v198 = (uint64_t *)a2[2];
      if ((unint64_t)v198 >= v197)
      {
        v200 = ((char *)v198 - *v39) >> 3;
        if ((unint64_t)(v200 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v201 = v197 - (_QWORD)*v39;
        v202 = v201 >> 2;
        if (v201 >> 2 <= (unint64_t)(v200 + 1))
          v202 = v200 + 1;
        if ((unint64_t)v201 >= 0x7FFFFFFFFFFFFFF8)
          v203 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v203 = v202;
        if (v203)
          v204 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a2 + 3), v203);
        else
          v204 = 0;
        v205 = (uint64_t *)&v204[8 * v200];
        v206 = &v204[8 * v203];
        *v205 = v196;
        v199 = v205 + 1;
        v208 = (char *)a2[1];
        v207 = (char *)a2[2];
        if (v207 != v208)
        {
          do
          {
            v209 = *((_QWORD *)v207 - 1);
            v207 -= 8;
            *--v205 = v209;
          }
          while (v207 != v208);
          v207 = *v39;
        }
        a2[1] = v205;
        a2[2] = v199;
        a2[3] = v206;
        if (v207)
          operator delete(v207);
      }
      else
      {
        *v198 = v196;
        v199 = v198 + 1;
      }
      a2[2] = v199;
    }
    else
    {
      if (!v194)
        __cxa_bad_cast();
      v195 = v194 + 10;
    }
    v217((uint64_t)v216, v195);
    v210 = v220;
    if (v220)
    {
      v211 = (unint64_t *)&v220->__shared_owners_;
      do
        v212 = __ldaxr(v211);
      while (__stlxr(v212 - 1, v211));
      if (!v212)
      {
        ((void (*)(std::__shared_weak_count *))v210->__on_zero_shared)(v210);
        std::__shared_weak_count::__release_weak(v210);
      }
    }
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
    operator delete(buf.__r_.__value_.__l.__data_);
  if (SHIBYTE(v260.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v260.__r_.__value_.__l.__data_);
LABEL_337:
  v213 = v262;
  if (v262)
  {
    v214 = (unint64_t *)&v262->__shared_owners_;
    do
      v215 = __ldaxr(v214);
    while (__stlxr(v215 - 1, v214));
    if (!v215)
    {
      ((void (*)(std::__shared_weak_count *))v213->__on_zero_shared)(v213);
      std::__shared_weak_count::__release_weak(v213);
    }
  }
}

void sub_2169EFC70(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 217) < 0)
    operator delete(*(void **)(v1 - 240));
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v1 - 208);
  _Unwind_Resume(a1);
}

uint64_t ctu::SharedRef<void const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,void const>::get(uint64_t a1)
{
  return *(_QWORD *)a1;
}

void ___ZN31Mav16QMIDataContextIPAggregator24configureProfileIfNeededERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEEb_block_invoke_43(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  int v4;
  NSObject *v6;
  const char *v7;
  int v8;
  int v9;
  int v10;
  const char *v11;
  __int16 v12;
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  int v17;
  __int16 v18;
  uint64_t v19;
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 + 32);
  v4 = *(_DWORD *)(a2 + 4);
  if (v4)
  {
    v6 = *(NSObject **)(v3 + 56);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      v7 = wds::asString(*(_DWORD *)(a1 + 40));
      v8 = *(unsigned __int8 *)(a1 + 44);
      v9 = *(_DWORD *)(a2 + 4);
      v10 = 136316162;
      v11 = "configureProfileIfNeeded_block_invoke";
      v12 = 2080;
      v13 = v7;
      v14 = 1024;
      v15 = v8;
      v16 = 1024;
      v17 = v9;
      v18 = 2080;
      v19 = qmi::asString();
      _os_log_impl(&dword_216897000, v6, OS_LOG_TYPE_DEFAULT, "#I %s: Failed to modify settings for profile %s (%d). Error: 0x%x(%s)", (uint8_t *)&v10, 0x2Cu);
    }
  }
  Mav16QMIDataContextIPAggregator::handleProfileConfiguredResult(v3, *(_DWORD *)(a1 + 40), 1, v4 == 0);
}

void Mav16QMIDataContextIPAggregator::handleProfileConfiguredResult(uint64_t a1, int a2, int a3, int a4)
{
  NSObject *v8;
  std::__shared_weak_count *v9;
  _BYTE *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  int v13;
  int v14;
  NSObject *v15;
  unint64_t *v16;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  NSObject *v23;
  uint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  uint64_t v31;
  NSObject *v32;
  const void *v33;
  void *v34;
  std::__shared_weak_count *v35;
  unint64_t *v36;
  unint64_t v37;
  unint64_t *v38;
  unint64_t v39;
  const void *v40;
  void *v41;
  std::__shared_weak_count *v42;
  unint64_t *v43;
  unint64_t v44;
  unint64_t *v45;
  unint64_t v46;
  uint64_t v47;
  std::__shared_weak_count *v48;
  _BYTE *v49;
  std::__shared_weak_count *v50;
  _BYTE buf[22];
  __int16 v52;
  int v53;
  __int16 v54;
  int v55;
  uint64_t v56;

  v56 = *MEMORY[0x24BDAC8D0];
  v8 = *(NSObject **)(a1 + 56);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315906;
    *(_QWORD *)&buf[4] = "handleProfileConfiguredResult";
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = wds::asString(a2);
    v52 = 1024;
    v53 = a3;
    v54 = 1024;
    v55 = a4;
    _os_log_impl(&dword_216897000, v8, OS_LOG_TYPE_DEFAULT, "#I %s: profileType: %s, activationNeeded: %d, success: %d", buf, 0x22u);
  }
  v10 = *(_BYTE **)(a1 + 352);
  v9 = *(std::__shared_weak_count **)(a1 + 360);
  v49 = v10;
  v50 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
  }
  if (a3)
  {
    if (a2 == 1)
    {
      v10[5] = a4;
    }
    else if (!a2)
    {
      v10[3] = a4;
    }
  }
  v13 = v10[3];
  if (v13 != 255)
  {
    v14 = v10[5];
    if (v14 != 255)
    {
      if (v10[1])
        v10[1] = 0;
      if (v13 == 1)
      {
        if (v14 != 1 && v14 != 254)
          goto LABEL_45;
      }
      else if (v13 != 254 || v14 != 1)
      {
LABEL_45:
        v32 = *(NSObject **)(a1 + 56);
        if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315138;
          *(_QWORD *)&buf[4] = "handleProfileConfiguredResult";
          _os_log_impl(&dword_216897000, v32, OS_LOG_TYPE_DEFAULT, "#I %s: Failed to configure profile. Reset profiles", buf, 0xCu);
        }
        v31 = 0;
        v10[3] = -1;
        v10[5] = -1;
        goto LABEL_48;
      }
      v47 = 0;
      v48 = 0;
      v18 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(a1 + 88));
      *(_QWORD *)buf = *(_QWORD *)(a1 + 80);
      *(_QWORD *)&buf[8] = v18;
      (*(void (**)(uint64_t *__return_ptr))(**(_QWORD **)buf + 32))(&v47);
      v19 = (unint64_t *)&v18->__shared_owners_;
      do
        v20 = __ldaxr(v19);
      while (__stlxr(v20 - 1, v19));
      if (!v20)
      {
        ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
        std::__shared_weak_count::__release_weak(v18);
      }
      if (v47)
      {
        v21 = (*(uint64_t (**)(uint64_t, _QWORD, _QWORD, _QWORD))(*(_QWORD *)v47 + 216))(v47, 0, 0, 0);
        v22 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD))(*(_QWORD *)v47 + 216))(v47, 1, 0, 0) | v21;
        v23 = *(NSObject **)(a1 + 56);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
        {
          v24 = subscriber::asString();
          *(_DWORD *)buf = 136315394;
          *(_QWORD *)&buf[4] = v24;
          *(_WORD *)&buf[12] = 2048;
          *(_QWORD *)&buf[14] = v22;
          _os_log_impl(&dword_216897000, v23, OS_LOG_TYPE_DEFAULT, "#I updateLastActiveProfileConnectionMask [Sim %s, 0x%llx]", buf, 0x16u);
        }
        v25 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(a1 + 88));
        *(_QWORD *)buf = *(_QWORD *)(a1 + 80);
        *(_QWORD *)&buf[8] = v25;
        (*(void (**)(_QWORD, _QWORD, uint64_t))(**(_QWORD **)buf + 424))(*(_QWORD *)buf, *(unsigned int *)(a1 + 8), v22);
        v26 = (unint64_t *)&v25->__shared_owners_;
        do
          v27 = __ldaxr(v26);
        while (__stlxr(v27 - 1, v26));
        if (!v27)
        {
          ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
          std::__shared_weak_count::__release_weak(v25);
        }
      }
      v28 = v48;
      if (v48)
      {
        v29 = (unint64_t *)&v48->__shared_owners_;
        do
          v30 = __ldaxr(v29);
        while (__stlxr(v30 - 1, v29));
        if (!v30)
        {
          ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
          std::__shared_weak_count::__release_weak(v28);
        }
      }
      v31 = 1;
LABEL_48:
      v33 = *(const void **)(a1 + 96);
      if (v33)
      {
        if (v34)
        {
          v35 = *(std::__shared_weak_count **)(a1 + 104);
          *(_QWORD *)buf = v34;
          *(_QWORD *)&buf[8] = v35;
          if (v35)
          {
            v36 = (unint64_t *)&v35->__shared_owners_;
            do
              v37 = __ldxr(v36);
            while (__stxr(v37 + 1, v36));
          }
          (*(void (**)(void *, uint64_t))(*(_QWORD *)v34 + 24))(v34, v31);
          if (v35)
          {
            v38 = (unint64_t *)&v35->__shared_owners_;
            do
              v39 = __ldaxr(v38);
            while (__stlxr(v39 - 1, v38));
            if (!v39)
            {
              ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
              std::__shared_weak_count::__release_weak(v35);
            }
          }
        }
      }
      v40 = *(const void **)(a1 + 112);
      if (v40)
      {
        if (v41)
        {
          v42 = *(std::__shared_weak_count **)(a1 + 120);
          *(_QWORD *)buf = v41;
          *(_QWORD *)&buf[8] = v42;
          if (v42)
          {
            v43 = (unint64_t *)&v42->__shared_owners_;
            do
              v44 = __ldxr(v43);
            while (__stxr(v44 + 1, v43));
          }
          (*(void (**)(void *, uint64_t))(*(_QWORD *)v41 + 24))(v41, v31);
          if (v42)
          {
            v45 = (unint64_t *)&v42->__shared_owners_;
            do
              v46 = __ldaxr(v45);
            while (__stlxr(v46 - 1, v45));
            if (!v46)
            {
              ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
              std::__shared_weak_count::__release_weak(v42);
            }
          }
        }
      }
      v9 = v50;
      if (v50)
        goto LABEL_16;
      return;
    }
  }
  v15 = *(NSObject **)(a1 + 56);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315138;
    *(_QWORD *)&buf[4] = "handleProfileConfiguredResult";
    _os_log_impl(&dword_216897000, v15, OS_LOG_TYPE_DEFAULT, "#I %s: Still waiting for more profile settings result", buf, 0xCu);
  }
  if (v9)
  {
LABEL_16:
    v16 = (unint64_t *)&v9->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
}

void sub_2169F03D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

_QWORD *__copy_helper_block_e8_40c57_ZTSNSt3__110shared_ptrIK28DataAPNSettingsInfoInterfaceEE56c42_ZTSNSt3__110shared_ptrI14QMIProfileInfoEE(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;

  v2 = a2[6];
  result[5] = a2[5];
  result[6] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  v5 = a2[8];
  result[7] = a2[7];
  result[8] = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_40c57_ZTSNSt3__110shared_ptrIK28DataAPNSettingsInfoInterfaceEE56c42_ZTSNSt3__110shared_ptrI14QMIProfileInfoEE(uint64_t a1)
{
  uint64_t v1;

  v1 = a1 + 40;
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 56);
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v1);
}

uint64_t `non-virtual thunk to'Mav16QMIDataContextIPAggregator::configureProfileIfNeeded(uint64_t a1, uint64_t *a2, int a3)
{
  return Mav16QMIDataContextIPAggregator::configureProfileIfNeeded(a1 - 288, a2, a3);
}

void ___ZN31Mav16QMIDataContextIPAggregator17set3GPPParametersERN3wds29ResetAndModifyProfileSettings7RequestE18DataProtocolFamily19AuthTypeRequirementb_block_invoke(uint64_t a1, std::string *this)
{
  std::string::value_type *v3;
  std::string::size_type v4;

  if (*(char *)(a1 + 55) < 0)
  {
    v3 = *(std::string::value_type **)(a1 + 32);
    v4 = *(_QWORD *)(a1 + 40);
  }
  else
  {
    v3 = (std::string::value_type *)(a1 + 32);
    v4 = *(unsigned __int8 *)(a1 + 55);
  }
  std::string::__assign_trivial[abi:ne180100]<unsigned char const*,unsigned char const*>(this, v3, &v3[v4], v4);
}

void ___ZN31Mav16QMIDataContextIPAggregator17set3GPPParametersERN3wds29ResetAndModifyProfileSettings7RequestE18DataProtocolFamily19AuthTypeRequirementb_block_invoke_51(uint64_t a1, int *a2)
{
  uint64_t v4;
  std::__shared_weak_count *v5;
  int v6;
  int v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  NSObject *v10;
  int v11;
  int v12;
  NSObject *v13;
  const char *v14;
  _BYTE v15[22];
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)(a1 + 32);
  v5 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v4 + 88));
  *(_QWORD *)v15 = *(_QWORD *)(v4 + 80);
  *(_QWORD *)&v15[8] = v5;
  v6 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)v15 + 384))(*(_QWORD *)v15);
  v7 = v6;
  p_shared_owners = (unint64_t *)&v5->__shared_owners_;
  do
    v9 = __ldaxr(p_shared_owners);
  while (__stlxr(v9 - 1, p_shared_owners));
  if (v9)
  {
    if (v6)
    {
LABEL_5:
      v10 = *(NSObject **)(v4 + 56);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)v15 = 136315138;
        *(_QWORD *)&v15[4] = "set3GPPParameters_block_invoke";
        _os_log_impl(&dword_216897000, v10, OS_LOG_TYPE_DEFAULT, "#I %s: Required to ask for v4 & v6 PDP types, asking for 3GPP types v4v6", v15, 0xCu);
      }
      v11 = 3;
      goto LABEL_15;
    }
  }
  else
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
    if (v7)
      goto LABEL_5;
  }
  v12 = *(_DWORD *)(a1 + 40);
  if ((v12 & 2) == 0)
    return;
  v13 = *(NSObject **)(v4 + 56);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    v14 = "v4v6";
    if ((v12 & 1) == 0)
      v14 = "v6";
    *(_DWORD *)v15 = 136315394;
    *(_QWORD *)&v15[4] = "set3GPPParameters_block_invoke";
    *(_WORD *)&v15[12] = 2080;
    *(_QWORD *)&v15[14] = v14;
    _os_log_impl(&dword_216897000, v13, OS_LOG_TYPE_DEFAULT, "#I %s: Asking for 3GPP type(s) %s", v15, 0x16u);
    v12 = *(_DWORD *)(a1 + 40);
  }
  v11 = v12 & 1 | 2;
LABEL_15:
  *a2 = v11;
}

void sub_2169F0668(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void ___ZN31Mav16QMIDataContextIPAggregator17set3GPPParametersERN3wds29ResetAndModifyProfileSettings7RequestE18DataProtocolFamily19AuthTypeRequirementb_block_invoke_56(uint64_t a1, std::string *this)
{
  std::string::value_type *v3;
  std::string::size_type v4;

  if (*(char *)(a1 + 55) < 0)
  {
    v3 = *(std::string::value_type **)(a1 + 32);
    v4 = *(_QWORD *)(a1 + 40);
  }
  else
  {
    v3 = (std::string::value_type *)(a1 + 32);
    v4 = *(unsigned __int8 *)(a1 + 55);
  }
  std::string::__assign_trivial[abi:ne180100]<unsigned char const*,unsigned char const*>(this, v3, &v3[v4], v4);
}

void ___ZN31Mav16QMIDataContextIPAggregator17set3GPPParametersERN3wds29ResetAndModifyProfileSettings7RequestE18DataProtocolFamily19AuthTypeRequirementb_block_invoke_58(uint64_t a1, std::string *this)
{
  std::string::value_type *v3;
  std::string::size_type v4;

  if (*(char *)(a1 + 55) < 0)
  {
    v3 = *(std::string::value_type **)(a1 + 32);
    v4 = *(_QWORD *)(a1 + 40);
  }
  else
  {
    v3 = (std::string::value_type *)(a1 + 32);
    v4 = *(unsigned __int8 *)(a1 + 55);
  }
  std::string::__assign_trivial[abi:ne180100]<unsigned char const*,unsigned char const*>(this, v3, &v3[v4], v4);
}

void ___ZN31Mav16QMIDataContextIPAggregator17set3GPPParametersERN3wds29ResetAndModifyProfileSettings7RequestE18DataProtocolFamily19AuthTypeRequirementb_block_invoke_60(uint64_t a1, char *a2)
{
  int v4;
  int v5;
  int v6;
  int v7;
  char v8;
  std::string v9;

  (*(void (**)(std::string *__return_ptr))(**(_QWORD **)(a1 + 32) + 280))(&v9);
  v4 = std::string::compare(&v9, "PAP");
  v5 = v4;
  if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v9.__r_.__value_.__l.__data_);
    if (v5)
      goto LABEL_3;
LABEL_7:
    v8 = 1;
    goto LABEL_10;
  }
  if (!v4)
    goto LABEL_7;
LABEL_3:
  (*(void (**)(std::string *__return_ptr))(**(_QWORD **)(a1 + 32) + 280))(&v9);
  v6 = std::string::compare(&v9, "CHAP");
  v7 = v6;
  if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v9.__r_.__value_.__l.__data_);
    if (v7)
      return;
  }
  else if (v6)
  {
    return;
  }
  v8 = 2;
LABEL_10:
  *a2 = v8;
}

uint64_t __copy_helper_block_e8_32c57_ZTSNSt3__110shared_ptrIK28DataAPNSettingsInfoInterfaceEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c57_ZTSNSt3__110shared_ptrIK28DataAPNSettingsInfoInterfaceEE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

uint64_t ___ZN31Mav16QMIDataContextIPAggregator17set3GPPParametersERN3wds29ResetAndModifyProfileSettings7RequestE18DataProtocolFamily19AuthTypeRequirementb_block_invoke_79(uint64_t a1, _WORD *a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 152))(*(_QWORD *)(a1 + 32));
  *a2 = result;
  return result;
}

void Mav16QMIDataContextIPAggregator::reportHandoverWwanPduSessionId(std::__shared_weak_count **this, uint64_t a2)
{
  std::__shared_weak_count *v4;
  capabilities::ct *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  uint64_t v12;
  std::__shared_weak_count *v13;

  v4 = std::__shared_weak_count::lock(this[11]);
  v11 = this[10];
  v12 = 0;
  v13 = 0;
  v5 = (capabilities::ct *)((capabilities::ct *(*)(uint64_t *__return_ptr))v11->__on_zero_shared_weak)(&v12);
  p_shared_owners = (unint64_t *)&v4->__shared_owners_;
  do
    v7 = __ldaxr(p_shared_owners);
  while (__stlxr(v7 - 1, p_shared_owners));
  if (!v7)
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  if (v12
    && capabilities::ct::supports5G(v5)
    && (*(unsigned int (**)(uint64_t))(*(_QWORD *)v12 + 192))(v12))
  {
    ((void (*)(std::__shared_weak_count *, uint64_t))this[12]->__vftable[6].__get_deleter)(this[12], a2);
    ((void (*)(std::__shared_weak_count *, uint64_t))this[14]->__vftable[6].__get_deleter)(this[14], a2);
  }
  v8 = v13;
  if (v13)
  {
    v9 = (unint64_t *)&v13->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
}

void sub_2169F08F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t Mav16QMIDataContextIPAggregator::updateAnbrFilters(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  _BYTE v9[168];
  _BYTE v10[168];
  _BYTE v11[168];
  _BYTE v12[168];

  v6 = *(_QWORD *)(a1 + 96);
  std::__optional_copy_base<DataIPFilter,false>::__optional_copy_base[abi:ne180100](v12, a2);
  std::__optional_copy_base<DataIPFilter,false>::__optional_copy_base[abi:ne180100](v11, a3);
  (*(void (**)(uint64_t, _BYTE *, _BYTE *))(*(_QWORD *)v6 + 272))(v6, v12, v11);
  std::__optional_destruct_base<DataIPFilter,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)v11);
  std::__optional_destruct_base<DataIPFilter,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)v12);
  v7 = *(_QWORD *)(a1 + 112);
  std::__optional_copy_base<DataIPFilter,false>::__optional_copy_base[abi:ne180100](v10, a2);
  std::__optional_copy_base<DataIPFilter,false>::__optional_copy_base[abi:ne180100](v9, a3);
  (*(void (**)(uint64_t, _BYTE *, _BYTE *))(*(_QWORD *)v7 + 272))(v7, v10, v9);
  std::__optional_destruct_base<DataIPFilter,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)v9);
  return std::__optional_destruct_base<DataIPFilter,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)v10);
}

void sub_2169F09DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
  std::__optional_destruct_base<DataIPFilter,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&a9);
  std::__optional_destruct_base<DataIPFilter,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&a30);
  _Unwind_Resume(a1);
}

uint64_t Mav16QMIDataContextIPAggregator::getAnbr(Mav16QMIDataContextIPAggregator *this, uint64_t a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 14) + 280))(*((_QWORD *)this + 14));
  if (!(_DWORD)result)
    return (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)this + 12) + 280))(*((_QWORD *)this + 12), a2);
  return result;
}

_BYTE *Mav16QMIDataContextIPAggregator::getAnbrActivationState(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  char v5;
  _BYTE *result;
  uint64_t v7;
  uint64_t v8;
  char v9;
  uint64_t v10;
  _BYTE v11[24];
  _BYTE *v12;
  _BYTE v13[24];
  _BYTE *v14;
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)(a1 + 112);
  std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100]((uint64_t)v13, a2);
  v5 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)v4 + 288))(v4, v13);
  result = v14;
  if (v14 == v13)
  {
    v7 = 4;
    result = v13;
  }
  else
  {
    if (!v14)
      goto LABEL_6;
    v7 = 5;
  }
  result = (_BYTE *)(*(uint64_t (**)(void))(*(_QWORD *)result + 8 * v7))();
LABEL_6:
  if ((v5 & 1) != 0)
    return result;
  v8 = *(_QWORD *)(a1 + 96);
  std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100]((uint64_t)v11, a2);
  v9 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)v8 + 288))(v8, v11);
  result = v12;
  if (v12 == v11)
  {
    v10 = 4;
    result = v11;
  }
  else
  {
    if (!v12)
      goto LABEL_12;
    v10 = 5;
  }
  result = (_BYTE *)(*(uint64_t (**)(void))(*(_QWORD *)result + 8 * v10))();
LABEL_12:
  if ((v9 & 1) == 0)
    return (_BYTE *)std::function<void ()(BOOL,BOOL)>::operator()(a2, 0, 0);
  return result;
}

void sub_2169F0B8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  char *v17;
  char *v19;
  uint64_t v20;

  v19 = a13;
  if (a13 == v17)
  {
    v20 = 4;
    v19 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v20 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v19 + 8 * v20))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

_BYTE *Mav16QMIDataContextIPAggregator::queryAnbrBitrate(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  char v9;
  _BYTE *result;
  uint64_t v11;
  uint64_t v12;
  char v13;
  uint64_t v14;
  NSObject *v15;
  uint64_t v16;
  uint8_t v17[8];
  _BYTE v18[24];
  _BYTE *v19;
  _BYTE v20[24];
  _BYTE *v21;
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  v8 = a1[14];
  std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100]((uint64_t)v20, a4);
  v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _BYTE *))(*(_QWORD *)v8 + 296))(v8, a2, a3, v20);
  result = v21;
  if (v21 == v20)
  {
    v11 = 4;
    result = v20;
  }
  else
  {
    if (!v21)
      goto LABEL_6;
    v11 = 5;
  }
  result = (_BYTE *)(*(uint64_t (**)(void))(*(_QWORD *)result + 8 * v11))();
LABEL_6:
  if ((v9 & 1) != 0)
    return result;
  v12 = a1[12];
  std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100]((uint64_t)v18, a4);
  v13 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _BYTE *))(*(_QWORD *)v12 + 296))(v12, a2, a3, v18);
  result = v19;
  if (v19 == v18)
  {
    v14 = 4;
    result = v18;
  }
  else
  {
    if (!v19)
      goto LABEL_12;
    v14 = 5;
  }
  result = (_BYTE *)(*(uint64_t (**)(void))(*(_QWORD *)result + 8 * v14))();
LABEL_12:
  if ((v13 & 1) == 0)
  {
    v15 = a1[7];
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v17 = 0;
      _os_log_impl(&dword_216897000, v15, OS_LOG_TYPE_DEFAULT, "#E ANBR cannot be queried by either QMI client", v17, 2u);
    }
    v17[0] = 0;
    v16 = *(_QWORD *)(a4 + 24);
    if (!v16)
      std::__throw_bad_function_call[abi:ne180100]();
    return (_BYTE *)(*(uint64_t (**)(uint64_t, uint8_t *))(*(_QWORD *)v16 + 48))(v16, v17);
  }
  return result;
}

void sub_2169F0D7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  char *v17;
  char *v19;
  uint64_t v20;

  v19 = a13;
  if (a13 == v17)
  {
    v20 = 4;
    v19 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v20 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v19 + 8 * v20))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t Mav16QMIDataContextIPAggregator::setCoalescing(uint64_t a1, unsigned __int16 a2)
{
  uint64_t v3;

  v3 = a2;
  (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 112) + 304))(*(_QWORD *)(a1 + 112), a2);
  return (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 96) + 304))(*(_QWORD *)(a1 + 96), v3);
}

void ___ZN31Mav16QMIDataContextIPAggregator18set3GPP2ParametersERN3wds29ResetAndModifyProfileSettings7RequestE18DataProtocolFamily_block_invoke(uint64_t a1, std::string *this)
{
  std::string::value_type *v3;
  std::string::size_type v4;

  if (*(char *)(a1 + 55) < 0)
  {
    v3 = *(std::string::value_type **)(a1 + 32);
    v4 = *(_QWORD *)(a1 + 40);
  }
  else
  {
    v3 = (std::string::value_type *)(a1 + 32);
    v4 = *(unsigned __int8 *)(a1 + 55);
  }
  std::string::__assign_trivial[abi:ne180100]<unsigned char const*,unsigned char const*>(this, v3, &v3[v4], v4);
}

void ___ZN31Mav16QMIDataContextIPAggregator18set3GPP2ParametersERN3wds29ResetAndModifyProfileSettings7RequestE18DataProtocolFamily_block_invoke_93(uint64_t a1, int *a2)
{
  uint64_t v4;
  std::__shared_weak_count *v5;
  int v6;
  int v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  NSObject *v10;
  int v11;
  int v12;
  NSObject *v13;
  const char *v14;
  _BYTE v15[22];
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)(a1 + 32);
  v5 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v4 + 88));
  *(_QWORD *)v15 = *(_QWORD *)(v4 + 80);
  *(_QWORD *)&v15[8] = v5;
  v6 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)v15 + 384))(*(_QWORD *)v15);
  v7 = v6;
  p_shared_owners = (unint64_t *)&v5->__shared_owners_;
  do
    v9 = __ldaxr(p_shared_owners);
  while (__stlxr(v9 - 1, p_shared_owners));
  if (v9)
  {
    if (v6)
    {
LABEL_5:
      v10 = *(NSObject **)(v4 + 56);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)v15 = 136315138;
        *(_QWORD *)&v15[4] = "set3GPP2Parameters_block_invoke";
        _os_log_impl(&dword_216897000, v10, OS_LOG_TYPE_DEFAULT, "#I %s: Required to ask for v4 & v6 PDP types, asking for 3GPP2 types v4v6", v15, 0xCu);
      }
      v11 = 2;
      goto LABEL_17;
    }
  }
  else
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
    if (v7)
      goto LABEL_5;
  }
  v12 = *(_DWORD *)(a1 + 40);
  if ((v12 & 2) == 0)
    return;
  v13 = *(NSObject **)(v4 + 56);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    v14 = "v4v6";
    if ((v12 & 1) == 0)
      v14 = "v6";
    *(_DWORD *)v15 = 136315394;
    *(_QWORD *)&v15[4] = "set3GPP2Parameters_block_invoke";
    *(_WORD *)&v15[12] = 2080;
    *(_QWORD *)&v15[14] = v14;
    _os_log_impl(&dword_216897000, v13, OS_LOG_TYPE_DEFAULT, "#I %s: Asking for 3GPP2 type(s) %s", v15, 0x16u);
    v12 = *(_DWORD *)(a1 + 40);
  }
  if ((v12 & 1) != 0)
    v11 = 2;
  else
    v11 = 1;
LABEL_17:
  *a2 = v11;
}

void sub_2169F0FF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void ___ZN31Mav16QMIDataContextIPAggregator18set3GPP2ParametersERN3wds29ResetAndModifyProfileSettings7RequestE18DataProtocolFamily_block_invoke_96(uint64_t a1, std::string *this)
{
  std::string::value_type *v3;
  std::string::size_type v4;

  if (*(char *)(a1 + 55) < 0)
  {
    v3 = *(std::string::value_type **)(a1 + 32);
    v4 = *(_QWORD *)(a1 + 40);
  }
  else
  {
    v3 = (std::string::value_type *)(a1 + 32);
    v4 = *(unsigned __int8 *)(a1 + 55);
  }
  std::string::__assign_trivial[abi:ne180100]<unsigned char const*,unsigned char const*>(this, v3, &v3[v4], v4);
}

void ___ZN31Mav16QMIDataContextIPAggregator18set3GPP2ParametersERN3wds29ResetAndModifyProfileSettings7RequestE18DataProtocolFamily_block_invoke_98(uint64_t a1, std::string *this)
{
  std::string::value_type *v3;
  std::string::size_type v4;

  if (*(char *)(a1 + 55) < 0)
  {
    v3 = *(std::string::value_type **)(a1 + 32);
    v4 = *(_QWORD *)(a1 + 40);
  }
  else
  {
    v3 = (std::string::value_type *)(a1 + 32);
    v4 = *(unsigned __int8 *)(a1 + 55);
  }
  std::string::__assign_trivial[abi:ne180100]<unsigned char const*,unsigned char const*>(this, v3, &v3[v4], v4);
}

uint64_t ___ZN31Mav16QMIDataContextIPAggregator18set3GPP2ParametersERN3wds29ResetAndModifyProfileSettings7RequestE18DataProtocolFamily_block_invoke_100(uint64_t result, _BYTE *a2)
{
  *a2 = *(_DWORD *)(result + 32);
  return result;
}

void ___ZN31Mav16QMIDataContextIPAggregator18set3GPP2ParametersERN3wds29ResetAndModifyProfileSettings7RequestE18DataProtocolFamily_block_invoke_2(uint64_t a1, std::string *this)
{
  std::string::value_type *v3;
  std::string::size_type v4;

  if (*(char *)(a1 + 55) < 0)
  {
    v3 = *(std::string::value_type **)(a1 + 32);
    v4 = *(_QWORD *)(a1 + 40);
  }
  else
  {
    v3 = (std::string::value_type *)(a1 + 32);
    v4 = *(unsigned __int8 *)(a1 + 55);
  }
  std::string::__assign_trivial[abi:ne180100]<unsigned char const*,unsigned char const*>(this, v3, &v3[v4], v4);
}

void ___ZN31Mav16QMIDataContextIPAggregator18set3GPP2ParametersERN3wds29ResetAndModifyProfileSettings7RequestE18DataProtocolFamily_block_invoke_103(uint64_t a1, std::string *this)
{
  std::string::value_type *v3;
  std::string::size_type v4;

  if (*(char *)(a1 + 55) < 0)
  {
    v3 = *(std::string::value_type **)(a1 + 32);
    v4 = *(_QWORD *)(a1 + 40);
  }
  else
  {
    v3 = (std::string::value_type *)(a1 + 32);
    v4 = *(unsigned __int8 *)(a1 + 55);
  }
  std::string::__assign_trivial[abi:ne180100]<unsigned char const*,unsigned char const*>(this, v3, &v3[v4], v4);
}

uint64_t ___ZN31Mav16QMIDataContextIPAggregator18set3GPP2ParametersERN3wds29ResetAndModifyProfileSettings7RequestE18DataProtocolFamily_block_invoke_105(uint64_t result, _BYTE *a2)
{
  *a2 = *(_DWORD *)(result + 32);
  return result;
}

void sub_2169F11B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  ctu::SharedRef<__CFNumber const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFNumber const>::~SharedRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN31Mav16QMIDataContextIPAggregator18set3GPP2ParametersERN3wds29ResetAndModifyProfileSettings7RequestE18DataProtocolFamily_block_invoke_116(uint64_t a1, _WORD *a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 152))(*(_QWORD *)(a1 + 32));
  *a2 = result;
  return result;
}

void Mav16QMIDataContextIPAggregator::createQoSClientOnDemand(uint64_t a1, uint64_t a2)
{
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;

  v4 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(a1 + 88));
  (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 80) + 440))(*(_QWORD *)(a1 + 80), a2);
  p_shared_owners = (unint64_t *)&v4->__shared_owners_;
  do
    v6 = __ldaxr(p_shared_owners);
  while (__stlxr(v6 - 1, p_shared_owners));
  if (!v6)
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
}

void sub_2169F12A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'Mav16QMIDataContextIPAggregator::createQoSClientOnDemand(uint64_t a1, uint64_t a2)
{
  Mav16QMIDataContextIPAggregator::createQoSClientOnDemand(a1 - 16, a2);
}

void Mav16QMIDataContextIPAggregator::releaseDataContextClient(Mav16QMIDataContextIPAggregator *this)
{
  int v2;
  int v3;
  uint64_t v4;
  NSObject *v5;
  const char *v6;
  int v7;
  int v8;
  NSObject *v9;
  _DWORD v10[2];
  __int16 v11;
  int v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  if (capabilities::ct::supportsDataQMIExtensions(this))
  {
    v2 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 12) + 96))(*((_QWORD *)this + 12));
    v3 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 14) + 96))(*((_QWORD *)this + 14));
    v4 = 112;
    if (v2 > v3)
      v4 = 96;
    if ((*(unsigned int (**)(_QWORD))(**(_QWORD **)((char *)this + v4) + 96))(*(_QWORD *)((char *)this + v4)))
    {
      v5 = *((_QWORD *)this + 7);
      if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
        return;
      LOWORD(v10[0]) = 0;
      v6 = "#I cannot destroy QMI client as context is not idle yet";
      goto LABEL_13;
    }
    v7 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 12) + 320))(*((_QWORD *)this + 12));
    v8 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 14) + 320))(*((_QWORD *)this + 14));
    v9 = *((_QWORD *)this + 7);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      v10[0] = 67109376;
      v10[1] = v7;
      v11 = 1024;
      v12 = v8;
      _os_log_impl(&dword_216897000, v9, OS_LOG_TYPE_DEFAULT, "#I release shadow fWDSClient in Aggregator ipv4released = %d, ipv6released = %d", (uint8_t *)v10, 0xEu);
    }
    if ((v7 & v8) == 1)
    {
      (*(void (**)(Mav16QMIDataContextIPAggregator *))(*(_QWORD *)this + 672))(this);
      return;
    }
    v5 = *((_QWORD *)this + 7);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v10[0]) = 0;
      v6 = "#I do not release shadow fWDSClient in Aggreator";
LABEL_13:
      _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, v6, (uint8_t *)v10, 2u);
    }
  }
}

void Mav16QMIDataContextIPAggregator::releaseQoSClient(uint64_t a1, uint64_t a2)
{
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;

  v4 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(a1 + 88));
  (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 80) + 448))(*(_QWORD *)(a1 + 80), a2);
  p_shared_owners = (unint64_t *)&v4->__shared_owners_;
  do
    v6 = __ldaxr(p_shared_owners);
  while (__stlxr(v6 - 1, p_shared_owners));
  if (!v6)
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
}

void sub_2169F1504(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'Mav16QMIDataContextIPAggregator::releaseQoSClient(uint64_t a1, uint64_t a2)
{
  Mav16QMIDataContextIPAggregator::releaseQoSClient(a1 - 16, a2);
}

void std::__shared_ptr_pointer<Mav16QMIDataContextIP *,std::shared_ptr<Mav16QMIDataContextIP> ctu::SharedSynchronizable<QMIDataContextIPBase>::make_shared_ptr<Mav16QMIDataContextIP>(Mav16QMIDataContextIP*)::{lambda(Mav16QMIDataContextIP *)#1},std::allocator<Mav16QMIDataContextIP>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void std::__shared_ptr_pointer<Mav16QMIDataContextIP *,std::shared_ptr<Mav16QMIDataContextIP> ctu::SharedSynchronizable<QMIDataContextIPBase>::make_shared_ptr<Mav16QMIDataContextIP>(Mav16QMIDataContextIP*)::{lambda(Mav16QMIDataContextIP *)#1},std::allocator<Mav16QMIDataContextIP>>::__on_zero_shared(uint64_t a1)
{
  dispatch_barrier_async_f(*(dispatch_queue_t *)(*(_QWORD *)(a1 + 24) + 24), *(void **)(a1 + 24), (dispatch_function_t)std::shared_ptr<Mav16QMIDataContextIP> ctu::SharedSynchronizable<QMIDataContextIPBase>::make_shared_ptr<Mav16QMIDataContextIP>(Mav16QMIDataContextIP*)::{lambda(Mav16QMIDataContextIP*)#1}::operator() const(Mav16QMIDataContextIP*)::{lambda(void *)#1}::__invoke);
}

uint64_t std::__shared_ptr_pointer<Mav16QMIDataContextIP *,std::shared_ptr<Mav16QMIDataContextIP> ctu::SharedSynchronizable<QMIDataContextIPBase>::make_shared_ptr<Mav16QMIDataContextIP>(Mav16QMIDataContextIP*)::{lambda(Mav16QMIDataContextIP *)#1},std::allocator<Mav16QMIDataContextIP>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t std::shared_ptr<Mav16QMIDataContextIP> ctu::SharedSynchronizable<QMIDataContextIPBase>::make_shared_ptr<Mav16QMIDataContextIP>(Mav16QMIDataContextIP*)::{lambda(Mav16QMIDataContextIP*)#1}::operator() const(Mav16QMIDataContextIP*)::{lambda(void *)#1}::__invoke(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

_BYTE *std::__optional_copy_base<DataIPFilter,false>::__optional_copy_base[abi:ne180100](_BYTE *a1, uint64_t a2)
{
  *a1 = 0;
  a1[160] = 0;
  if (*(_BYTE *)(a2 + 160))
  {
    std::construct_at[abi:ne180100]<DataIPFilter,DataIPFilter const&,DataIPFilter*>((uint64_t)a1, a2);
    a1[160] = 1;
  }
  return a1;
}

void sub_2169F15F0(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__optional_destruct_base<DataIPFilter,false>::~__optional_destruct_base[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

uint64_t std::__optional_destruct_base<DataIPFilter,false>::~__optional_destruct_base[abi:ne180100](uint64_t a1)
{
  if (*(_BYTE *)(a1 + 160))
  {
    std::__optional_destruct_base<DataIPFilterEndpoint,false>::~__optional_destruct_base[abi:ne180100](a1 + 88);
    std::__optional_destruct_base<DataIPFilterEndpoint,false>::~__optional_destruct_base[abi:ne180100](a1 + 32);
  }
  return a1;
}

void ___ZNK3qmi6Client13setIndHandlerIRKN3wds17DeleteAllProfiles10IndicationEEEvtU13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2169F16F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

xpc_object_t xpc::dict::object_proxy::operator=(xpc_object_t *a1, xpc_object_t xdict, char *key, xpc_object_t *a4)
{
  xpc_object_t result;

  xpc_dictionary_set_value(xdict, key, *a4);
  *a1 = *a4;
  result = xpc_null_create();
  *a4 = result;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::ProfileTypeMask>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::ProfileTypeMask>::getSize()
{
  return tlv::size<wds::tlv::ProfileTypeMask>();
}

_QWORD **qmi::MutableMessageBase::TlvWrapper<wds::tlv::ProfileTypeMask>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _QWORD *v4;
  uint64_t v5;
  _QWORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_QWORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::ProfileTypeMask>((_QWORD **)a2, (_QWORD *)(a1 + 16));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::ProfileTypeMask>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5DCE50;
  *(_QWORD *)(result + 16) = *(_QWORD *)(a1 + 16);
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::ProfilePersistenceMask>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::ProfilePersistenceMask>::getSize()
{
  return tlv::size<wds::tlv::ProfileTypeMask>();
}

_QWORD **qmi::MutableMessageBase::TlvWrapper<wds::tlv::ProfilePersistenceMask>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _QWORD *v4;
  uint64_t v5;
  _QWORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_QWORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::ProfileTypeMask>((_QWORD **)a2, (_QWORD *)(a1 + 16));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::ProfilePersistenceMask>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5DCEA0;
  *(_QWORD *)(result + 16) = *(_QWORD *)(a1 + 16);
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::ProfileClientTypeMask>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::ProfileClientTypeMask>::getSize()
{
  return tlv::size<wds::tlv::ProfileTypeMask>();
}

_QWORD **qmi::MutableMessageBase::TlvWrapper<wds::tlv::ProfileClientTypeMask>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _QWORD *v4;
  uint64_t v5;
  _QWORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_QWORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::ProfileTypeMask>((_QWORD **)a2, (_QWORD *)(a1 + 16));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::ProfileClientTypeMask>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5DCEF0;
  *(_QWORD *)(result + 16) = *(_QWORD *)(a1 + 16);
  return result;
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3wds17DeleteAllProfiles8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2169F1A98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<QMIProfileInfo *,std::shared_ptr<QMIProfileInfo>::__shared_ptr_default_delete<QMIProfileInfo,QMIProfileInfo>,std::allocator<QMIProfileInfo>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

uint64_t std::__shared_ptr_pointer<QMIProfileInfo *,std::shared_ptr<QMIProfileInfo>::__shared_ptr_default_delete<QMIProfileInfo,QMIProfileInfo>,std::allocator<QMIProfileInfo>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    JUMPOUT(0x2199FEAC4);
  return result;
}

uint64_t std::__shared_ptr_pointer<QMIProfileInfo *,std::shared_ptr<QMIProfileInfo>::__shared_ptr_default_delete<QMIProfileInfo,QMIProfileInfo>,std::allocator<QMIProfileInfo>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void std::__shared_ptr_emplace<std::shared_ptr<QMIProfileManager> ctu::enable_make_shared<QMIProfileManager>::make_shared<std::shared_ptr<Registry> &,dispatch::queue const&,subscriber::SimSlot &>(std::shared_ptr<Registry> &,dispatch::queue const&,subscriber::SimSlot &)::enabler,std::allocator<std::allocator>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5DCFC8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<std::shared_ptr<QMIProfileManager> ctu::enable_make_shared<QMIProfileManager>::make_shared<std::shared_ptr<Registry> &,dispatch::queue const&,subscriber::SimSlot &>(std::shared_ptr<Registry> &,dispatch::queue const&,subscriber::SimSlot &)::enabler,std::allocator<std::allocator>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5DCFC8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

uint64_t std::__shared_ptr_emplace<std::shared_ptr<QMIProfileManager> ctu::enable_make_shared<QMIProfileManager>::make_shared<std::shared_ptr<Registry> &,dispatch::queue const&,subscriber::SimSlot &>(std::shared_ptr<Registry> &,dispatch::queue const&,subscriber::SimSlot &)::enabler,std::allocator<std::allocator>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void ctu::enable_make_shared<QMIProfileManager>::make_shared<std::shared_ptr<Registry> &,dispatch::queue const&,subscriber::SimSlot &>(std::shared_ptr<Registry> &,dispatch::queue const&,subscriber::SimSlot &)::enabler::~enabler(QMIProfileManager *a1)
{
  QMIProfileManager::~QMIProfileManager(a1);
  JUMPOUT(0x2199FEAC4);
}

void std::__function::__func<void ctu::rest::event_sink_impl_t<std::pair<subscriber::SimSlot,BOOL>,ctu::rest::path_generator_t<rest::mav16_data_profile_creation_ready>>::bind_impl<Mav16QMIDataContextIPAggregator::initialize(BOOL,std::shared_ptr<QMIClientContextObserver>,std::shared_ptr<BBDataContextHelper>,BOOL)::$_0>(ctu::RestModule &,Mav16QMIDataContextIPAggregator::initialize(BOOL,std::shared_ptr<QMIClientContextObserver>,std::shared_ptr<BBDataContextHelper>,BOOL)::$_0 &&,std::integral_constant<BOOL,false>)::{lambda(xpc::object const&)#1},std::allocator<xpc::object const&>,void ()(xpc)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<void ctu::rest::event_sink_impl_t<std::pair<subscriber::SimSlot,BOOL>,ctu::rest::path_generator_t<rest::mav16_data_profile_creation_ready>>::bind_impl<Mav16QMIDataContextIPAggregator::initialize(BOOL,std::shared_ptr<QMIClientContextObserver>,std::shared_ptr<BBDataContextHelper>,BOOL)::$_0>(ctu::RestModule &,Mav16QMIDataContextIPAggregator::initialize(BOOL,std::shared_ptr<QMIClientContextObserver>,std::shared_ptr<BBDataContextHelper>,BOOL)::$_0 &&,std::integral_constant<BOOL,false>)::{lambda(xpc::object const&)#1},std::allocator<xpc::object const&>,void ()(xpc)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5DD050;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void ctu::rest::event_sink_impl_t<std::pair<subscriber::SimSlot,BOOL>,ctu::rest::path_generator_t<rest::mav16_data_profile_creation_ready>>::bind_impl<Mav16QMIDataContextIPAggregator::initialize(BOOL,std::shared_ptr<QMIClientContextObserver>,std::shared_ptr<BBDataContextHelper>,BOOL)::$_0>(ctu::RestModule &,Mav16QMIDataContextIPAggregator::initialize(BOOL,std::shared_ptr<QMIClientContextObserver>,std::shared_ptr<BBDataContextHelper>,BOOL)::$_0 &&,std::integral_constant<BOOL,false>)::{lambda(xpc::object const&)#1},std::allocator<xpc::object const&>,void ()(xpc)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5DD050;
  a2[1] = v2;
  return result;
}

void std::__function::__func<void ctu::rest::event_sink_impl_t<std::pair<subscriber::SimSlot,BOOL>,ctu::rest::path_generator_t<rest::mav16_data_profile_creation_ready>>::bind_impl<Mav16QMIDataContextIPAggregator::initialize(BOOL,std::shared_ptr<QMIClientContextObserver>,std::shared_ptr<BBDataContextHelper>,BOOL)::$_0>(ctu::RestModule &,Mav16QMIDataContextIPAggregator::initialize(BOOL,std::shared_ptr<QMIClientContextObserver>,std::shared_ptr<BBDataContextHelper>,BOOL)::$_0 &&,std::integral_constant<BOOL,false>)::{lambda(xpc::object const&)#1},std::allocator<xpc::object const&>,void ()(xpc)>::operator()(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  NSObject *v10;
  const char *v11;
  xpc_object_t object;
  xpc_object_t v13;
  int v14;
  _BYTE buf[22];
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  v3 = *a2;
  v13 = v3;
  v4 = MEMORY[0x24BDACFA0];
  if (v3 && MEMORY[0x2199FEDD0](v3) == v4)
  {
    xpc_retain(v3);
  }
  else
  {
    v3 = xpc_null_create();
    v13 = v3;
  }
  if (MEMORY[0x2199FEDD0](v3) == v4)
  {
    *(_QWORD *)buf = &v13;
    *(_QWORD *)&buf[8] = "first";
    xpc::dict::object_proxy::operator xpc::object((uint64_t)buf, &object);
    v7 = MEMORY[0x2199FEDD0](object);
    if (v7 == MEMORY[0x24BDACFF0])
    {
      v14 = 0;
      ctu::rest::detail::read_enum_string_value();
      v6 = v14;
    }
    else if (v7 == MEMORY[0x24BDACF80] || v7 == MEMORY[0x24BDACFD0] || v7 == MEMORY[0x24BDACFF8])
    {
      v6 = xpc::dyn_cast_or_default();
    }
    else
    {
      v6 = 0;
    }
    xpc_release(object);
    *(_QWORD *)buf = &v13;
    *(_QWORD *)&buf[8] = "second";
    xpc::dict::object_proxy::operator xpc::object((uint64_t)buf, &object);
    v8 = xpc::dyn_cast_or_default();
    xpc_release(object);
    v3 = v13;
    if (v8)
      v5 = 0x100000000;
    else
      v5 = 0;
  }
  else
  {
    v5 = 0;
    v6 = 0;
  }
  xpc_release(v3);
  v9 = *(_QWORD *)(a1 + 8);
  if (*(_DWORD *)(v9 + 8) == v6)
  {
    *(_BYTE *)(v9 + 313) = BYTE4(v5);
    v10 = *(NSObject **)(v9 + 56);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      v11 = "allowed";
      if (!v5)
        v11 = "NOT allowed";
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "operator()";
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = v11;
      _os_log_impl(&dword_216897000, v10, OS_LOG_TYPE_DEFAULT, "#I %s: Profile creation %s", buf, 0x16u);
    }
  }
}

void sub_2169F1E6C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, xpc_object_t a11)
{
  if (!a2)
    _Unwind_Resume(exception_object);
  __clang_call_terminate(exception_object);
}

uint64_t std::__function::__func<void ctu::rest::event_sink_impl_t<std::pair<subscriber::SimSlot,BOOL>,ctu::rest::path_generator_t<rest::mav16_data_profile_creation_ready>>::bind_impl<Mav16QMIDataContextIPAggregator::initialize(BOOL,std::shared_ptr<QMIClientContextObserver>,std::shared_ptr<BBDataContextHelper>,BOOL)::$_0>(ctu::RestModule &,Mav16QMIDataContextIPAggregator::initialize(BOOL,std::shared_ptr<QMIClientContextObserver>,std::shared_ptr<BBDataContextHelper>,BOOL)::$_0 &&,std::integral_constant<BOOL,false>)::{lambda(xpc::object const&)#1},std::allocator<xpc::object const&>,void ()(xpc)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void ctu::rest::event_sink_impl_t<std::pair<subscriber::SimSlot,BOOL>,ctu::rest::path_generator_t<rest::mav16_data_profile_creation_ready>>::bind_impl<Mav16QMIDataContextIPAggregator::initialize(BOOL,std::shared_ptr<QMIClientContextObserver>,std::shared_ptr<BBDataContextHelper>,BOOL)::$_0>(ctu::RestModule &,Mav16QMIDataContextIPAggregator::initialize(BOOL,std::shared_ptr<QMIClientContextObserver>,std::shared_ptr<BBDataContextHelper>,BOOL)::$_0 &&,std::integral_constant<BOOL,false>)::{lambda(xpc::object const&)#1},std::allocator<xpc::object const&>,void ()(xpc)>::target_type()
{
}

xpc_object_t xpc::dict::object_proxy::operator xpc::object@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  xpc_object_t value;
  xpc_object_t result;

  value = xpc_dictionary_get_value(**(xpc_object_t **)a1, *(const char **)(a1 + 8));
  *a2 = value;
  if (value)
    return xpc_retain(value);
  result = xpc_null_create();
  *a2 = result;
  return result;
}

char *qmi::MutableMessageBase::getTLV<wds::tlv::ProfileIdentifer>(_QWORD *a1)
{
  const void **v2;
  const void **v3;
  char **v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  v4 = (char **)(a1 + 1);
  if (v2 != v3)
  {
    while (*((_BYTE *)*v2 + 8) != 1)
    {
      if (++v2 == v3)
        goto LABEL_8;
    }
  }
  if (v2 == v3)
  {
LABEL_8:
    v7 = operator new();
    *(_BYTE *)(v7 + 8) = 1;
    *(_WORD *)(v7 + 9) = 0;
    v6 = v7 + 9;
    *(_QWORD *)v7 = &off_24D5DD0E8;
    v8 = a1[3];
    v9 = (uint64_t *)a1[2];
    if ((unint64_t)v9 >= v8)
    {
      v11 = ((char *)v9 - *v4) >> 3;
      if ((unint64_t)(v11 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v12 = v8 - (_QWORD)*v4;
      v13 = v12 >> 2;
      if (v12 >> 2 <= (unint64_t)(v11 + 1))
        v13 = v11 + 1;
      if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
        v14 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v14 = v13;
      if (v14)
        v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v14);
      else
        v15 = 0;
      v16 = (uint64_t *)&v15[8 * v11];
      v17 = &v15[8 * v14];
      *v16 = v7;
      v10 = v16 + 1;
      v19 = (char *)a1[1];
      v18 = (char *)a1[2];
      if (v18 != v19)
      {
        do
        {
          v20 = *((_QWORD *)v18 - 1);
          v18 -= 8;
          *--v16 = v20;
        }
        while (v18 != v19);
        v18 = *v4;
      }
      a1[1] = v16;
      a1[2] = v10;
      a1[3] = v17;
      if (v18)
        operator delete(v18);
    }
    else
    {
      *v9 = v7;
      v10 = v9 + 1;
    }
    a1[2] = v10;
  }
  else
  {
    if (!v5)
      __cxa_bad_cast();
    return v5 + 9;
  }
  return (char *)v6;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::ProfileIdentifer>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::ProfileIdentifer>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_PcoMcc>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<wds::tlv::ProfileIdentifer>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::ProfileIdentifer>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::ProfileIdentifer>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5DD0E8;
  *(_WORD *)(result + 9) = *(_WORD *)(a1 + 9);
  return result;
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3wds13DeleteProfile8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2169F2260(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::ProfileType>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::ProfileType>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<wds::tlv::ProfileType>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::ProfileType>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5DD160;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::Persistence>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Persistence>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<wds::tlv::Persistence>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Persistence>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5DD1B0;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::ApnType>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::ApnType>::getSize()
{
  return tlv::size<wds::tlv::ProfileTypeMask>();
}

_QWORD **qmi::MutableMessageBase::TlvWrapper<wds::tlv::ApnType>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _QWORD *v4;
  uint64_t v5;
  _QWORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_QWORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::ProfileTypeMask>((_QWORD **)a2, (_QWORD *)(a1 + 16));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::ApnType>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5DD200;
  *(_QWORD *)(result + 16) = *(_QWORD *)(a1 + 16);
  return result;
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3wds13CreateProfile8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2169F25A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

char *qmi::MutableMessageBase::getTLV<wds::tlv::Profile3GPP2_AuthPref>(_QWORD *a1)
{
  const void **v2;
  const void **v3;
  char **v4;
  char *v5;
  char *result;
  uint64_t v7;
  unint64_t v8;
  uint64_t *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  v4 = (char **)(a1 + 1);
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != 154)
    {
      if (++v2 == v3)
        goto LABEL_8;
    }
  }
  if (v2 == v3)
  {
LABEL_8:
    v7 = operator new();
    *(_WORD *)(v7 + 8) = 154;
    *(_QWORD *)v7 = &off_24D5DD278;
    v8 = a1[3];
    v9 = (uint64_t *)a1[2];
    if ((unint64_t)v9 >= v8)
    {
      v11 = ((char *)v9 - *v4) >> 3;
      if ((unint64_t)(v11 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v12 = v8 - (_QWORD)*v4;
      v13 = v12 >> 2;
      if (v12 >> 2 <= (unint64_t)(v11 + 1))
        v13 = v11 + 1;
      if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
        v14 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v14 = v13;
      if (v14)
        v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v14);
      else
        v15 = 0;
      v16 = (uint64_t *)&v15[8 * v11];
      v17 = &v15[8 * v14];
      *v16 = v7;
      v10 = v16 + 1;
      v19 = (char *)a1[1];
      v18 = (char *)a1[2];
      if (v18 != v19)
      {
        do
        {
          v20 = *((_QWORD *)v18 - 1);
          v18 -= 8;
          *--v16 = v20;
        }
        while (v18 != v19);
        v18 = *v4;
      }
      a1[1] = v16;
      a1[2] = v10;
      a1[3] = v17;
      if (v18)
        operator delete(v18);
    }
    else
    {
      *v9 = v7;
      v10 = v9 + 1;
    }
    result = (char *)(v7 + 9);
    a1[2] = v10;
  }
  else
  {
    if (!v5)
      __cxa_bad_cast();
    return v5 + 9;
  }
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP2_AuthPref>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP2_AuthPref>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_ProfileIdentifier>();
}

_BYTE *qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP2_AuthPref>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE *result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::Profile3GPP_ProfileIdentifier>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP2_AuthPref>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5DD278;
  return result;
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3wds29ResetAndModifyProfileSettings8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2169F28CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP_ApnName>::~TlvWrapper(uint64_t a1)
{
  *(_QWORD *)a1 = off_24D5DD2F0;
  if (*(char *)(a1 + 39) < 0)
    operator delete(*(void **)(a1 + 16));
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP_ApnName>::~TlvWrapper(uint64_t a1)
{
  *(_QWORD *)a1 = off_24D5DD2F0;
  if (*(char *)(a1 + 39) < 0)
    operator delete(*(void **)(a1 + 16));
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP_ApnName>::getSize(uint64_t a1)
{
  return tlv::size<wds::tlv::Profile3GPP_ApnName>(a1 + 16);
}

char *qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP_ApnName>::write(uint64_t a1, char **a2)
{
  char v3;
  char *v4;
  uint64_t v5;
  char *result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = *a2;
  v5 = (uint64_t)(*a2 + 3);
  *a2 = (char *)v5;
  result = tlv::writeV<wds::tlv::Profile3GPP_ApnName>(a2, (_QWORD *)(a1 + 16));
  v7 = &(*a2)[-v5];
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP_ApnName>::clone(uint64_t a1)
{
  uint64_t v2;
  std::string *v3;

  v2 = operator new();
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)v2 = off_24D5DD2F0;
  v3 = (std::string *)(v2 + 16);
  if (*(char *)(a1 + 39) < 0)
  {
    std::string::__init_copy_ctor_external(v3, *(const std::string::value_type **)(a1 + 16), *(_QWORD *)(a1 + 24));
  }
  else
  {
    *(_OWORD *)&v3->__r_.__value_.__l.__data_ = *(_OWORD *)(a1 + 16);
    *(_QWORD *)(v2 + 32) = *(_QWORD *)(a1 + 32);
  }
  return v2;
}

void sub_2169F2A6C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199FEAC4](v1, 0x1093C4081B1C094);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP_PdpType>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP_PdpType>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_ProfileIdentifier>();
}

_BYTE *qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP_PdpType>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE *result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::Profile3GPP_PdpType>((_BYTE **)a2, (_DWORD *)(a1 + 12));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP_PdpType>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5DD340;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a1 + 12);
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP_UserName>::~TlvWrapper(uint64_t a1)
{
  *(_QWORD *)a1 = off_24D5DD390;
  if (*(char *)(a1 + 39) < 0)
    operator delete(*(void **)(a1 + 16));
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP_UserName>::~TlvWrapper(uint64_t a1)
{
  *(_QWORD *)a1 = off_24D5DD390;
  if (*(char *)(a1 + 39) < 0)
    operator delete(*(void **)(a1 + 16));
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP_UserName>::getSize(uint64_t a1)
{
  return tlv::size<wds::tlv::Profile3GPP_ApnName>(a1 + 16);
}

char *qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP_UserName>::write(uint64_t a1, char **a2)
{
  char v3;
  char *v4;
  uint64_t v5;
  char *result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = *a2;
  v5 = (uint64_t)(*a2 + 3);
  *a2 = (char *)v5;
  result = tlv::writeV<wds::tlv::Profile3GPP_ApnName>(a2, (_QWORD *)(a1 + 16));
  v7 = &(*a2)[-v5];
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP_UserName>::clone(uint64_t a1)
{
  uint64_t v2;
  std::string *v3;

  v2 = operator new();
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)v2 = off_24D5DD390;
  v3 = (std::string *)(v2 + 16);
  if (*(char *)(a1 + 39) < 0)
  {
    std::string::__init_copy_ctor_external(v3, *(const std::string::value_type **)(a1 + 16), *(_QWORD *)(a1 + 24));
  }
  else
  {
    *(_OWORD *)&v3->__r_.__value_.__l.__data_ = *(_OWORD *)(a1 + 16);
    *(_QWORD *)(v2 + 32) = *(_QWORD *)(a1 + 32);
  }
  return v2;
}

void sub_2169F2CB8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199FEAC4](v1, 0x1093C4081B1C094);
  _Unwind_Resume(a1);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP_Password>::~TlvWrapper(uint64_t a1)
{
  *(_QWORD *)a1 = off_24D5DD3E0;
  if (*(char *)(a1 + 39) < 0)
    operator delete(*(void **)(a1 + 16));
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP_Password>::~TlvWrapper(uint64_t a1)
{
  *(_QWORD *)a1 = off_24D5DD3E0;
  if (*(char *)(a1 + 39) < 0)
    operator delete(*(void **)(a1 + 16));
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP_Password>::getSize(uint64_t a1)
{
  return tlv::size<wds::tlv::Profile3GPP_ApnName>(a1 + 16);
}

char *qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP_Password>::write(uint64_t a1, char **a2)
{
  char v3;
  char *v4;
  uint64_t v5;
  char *result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = *a2;
  v5 = (uint64_t)(*a2 + 3);
  *a2 = (char *)v5;
  result = tlv::writeV<wds::tlv::Profile3GPP_ApnName>(a2, (_QWORD *)(a1 + 16));
  v7 = &(*a2)[-v5];
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP_Password>::clone(uint64_t a1)
{
  uint64_t v2;
  std::string *v3;

  v2 = operator new();
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)v2 = off_24D5DD3E0;
  v3 = (std::string *)(v2 + 16);
  if (*(char *)(a1 + 39) < 0)
  {
    std::string::__init_copy_ctor_external(v3, *(const std::string::value_type **)(a1 + 16), *(_QWORD *)(a1 + 24));
  }
  else
  {
    *(_OWORD *)&v3->__r_.__value_.__l.__data_ = *(_OWORD *)(a1 + 16);
    *(_QWORD *)(v2 + 32) = *(_QWORD *)(a1 + 32);
  }
  return v2;
}

void sub_2169F2E3C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199FEAC4](v1, 0x1093C4081B1C094);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP_AuthPref>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP_AuthPref>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_ProfileIdentifier>();
}

_BYTE *qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP_AuthPref>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE *result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::Profile3GPP_ProfileIdentifier>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP_AuthPref>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5DD430;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP_ProxyAddrUsingPco>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP_ProxyAddrUsingPco>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_ProfileIdentifier>();
}

_BYTE *qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP_ProxyAddrUsingPco>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE *result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::Profile3GPP_ProfileIdentifier>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP_ProxyAddrUsingPco>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5DD480;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP_IMSRequestQoSWithSigInd>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP_IMSRequestQoSWithSigInd>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_IMSRequestQoSWithSigInd>();
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP_IMSRequestQoSWithSigInd>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  uint64_t v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = *a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::Profile3GPP_IMSRequestQoSWithSigInd>(a2, a1 + 12);
  v7 = *a2 - v5;
  *(_BYTE *)v4 = v3;
  *(_WORD *)(v4 + 1) = v7;
  return result;
}

__n128 qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP_IMSRequestQoSWithSigInd>::clone(uint64_t a1)
{
  uint64_t v2;
  __n128 result;

  v2 = operator new();
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)v2 = &off_24D5DD4D0;
  *(_OWORD *)(v2 + 12) = *(_OWORD *)(a1 + 12);
  *(_OWORD *)(v2 + 28) = *(_OWORD *)(a1 + 28);
  result = *(__n128 *)(a1 + 40);
  *(__n128 *)(v2 + 40) = result;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP_SupportEmergencyCalls>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP_SupportEmergencyCalls>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP_SupportEmergencyCalls>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP_SupportEmergencyCalls>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5DD520;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP_OperatorReservedPcoId>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP_OperatorReservedPcoId>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_OperatorReservedPcoId>();
}

_WORD *qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP_OperatorReservedPcoId>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _WORD *v4;
  uint64_t v5;
  _WORD *result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_WORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::Profile3GPP_OperatorReservedPcoId>((_WORD **)a2, (_WORD *)(a1 + 10));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP_OperatorReservedPcoId>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5DD570;
  *(_WORD *)(result + 10) = *(_WORD *)(a1 + 10);
  return result;
}

void ctu::cf::_Applier_InsertArrayDefault<unsigned short,std::back_insert_iterator<std::vector<unsigned short>>>(void *a1, uint64_t *a2)
{
  CFTypeID v4;
  const __CFNumber *v5;
  uint64_t v6;
  _WORD *v7;
  unint64_t v8;
  _WORD *v9;
  _WORD *v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  char *v16;
  char *v17;
  char *v18;
  __int16 v19;
  __int16 v20;

  v20 = 0;
  if (a1)
  {
    v4 = CFGetTypeID(a1);
    if (v4 == CFNumberGetTypeID())
      ctu::cf::assign((ctu::cf *)&v20, (unsigned __int16 *)a1, v5);
  }
  v6 = *a2;
  v7 = *(_WORD **)(v6 + 8);
  v8 = *(_QWORD *)(v6 + 16);
  if ((unint64_t)v7 >= v8)
  {
    v10 = *(_WORD **)v6;
    v11 = (uint64_t)v7 - *(_QWORD *)v6;
    if (v11 <= -3)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v12 = v11 >> 1;
    v13 = v8 - (_QWORD)v10;
    if (v13 <= (v11 >> 1) + 1)
      v14 = v12 + 1;
    else
      v14 = v13;
    if (v13 >= 0x7FFFFFFFFFFFFFFELL)
      v15 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v15 = v14;
    if (v15)
    {
      v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned short>>(v6 + 16, v15);
      v10 = *(_WORD **)v6;
      v7 = *(_WORD **)(v6 + 8);
    }
    else
    {
      v16 = 0;
    }
    v17 = &v16[2 * v12];
    v18 = &v16[2 * v15];
    *(_WORD *)v17 = v20;
    v9 = v17 + 2;
    while (v7 != v10)
    {
      v19 = *--v7;
      *((_WORD *)v17 - 1) = v19;
      v17 -= 2;
    }
    *(_QWORD *)v6 = v17;
    *(_QWORD *)(v6 + 8) = v9;
    *(_QWORD *)(v6 + 16) = v18;
    if (v10)
      operator delete(v10);
  }
  else
  {
    *v7 = v20;
    v9 = v7 + 1;
  }
  *(_QWORD *)(v6 + 8) = v9;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP_PcoMcc>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP_PcoMcc>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_PcoMcc>();
}

_WORD **qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP_PcoMcc>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _WORD *v4;
  uint64_t v5;
  _WORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_WORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::Profile3GPP_PcoMcc>((_WORD **)a2, (_WORD *)(a1 + 10));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP_PcoMcc>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5DD5C0;
  *(_WORD *)(result + 10) = *(_WORD *)(a1 + 10);
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP_PcoMnc>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP_PcoMnc>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_PcoMnc>();
}

uint64_t *qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP_PcoMnc>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t *result;
  uint64_t v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = *a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::Profile3GPP_PcoMnc>(a2, a1 + 10);
  v7 = *a2 - v5;
  *(_BYTE *)v4 = v3;
  *(_WORD *)(v4 + 1) = v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP_PcoMnc>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5DD610;
  *(_DWORD *)(result + 10) = *(_DWORD *)(a1 + 10);
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::AlwaysOnPdu>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::AlwaysOnPdu>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<wds::tlv::AlwaysOnPdu>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::AlwaysOnPdu>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5DD660;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP2_ApnName>::~TlvWrapper(uint64_t a1)
{
  *(_QWORD *)a1 = off_24D5DD6B0;
  if (*(char *)(a1 + 39) < 0)
    operator delete(*(void **)(a1 + 16));
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP2_ApnName>::~TlvWrapper(uint64_t a1)
{
  *(_QWORD *)a1 = off_24D5DD6B0;
  if (*(char *)(a1 + 39) < 0)
    operator delete(*(void **)(a1 + 16));
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP2_ApnName>::getSize(uint64_t a1)
{
  return tlv::size<wds::tlv::Profile3GPP_ApnName>(a1 + 16);
}

char *qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP2_ApnName>::write(uint64_t a1, char **a2)
{
  char v3;
  char *v4;
  uint64_t v5;
  char *result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = *a2;
  v5 = (uint64_t)(*a2 + 3);
  *a2 = (char *)v5;
  result = tlv::writeV<wds::tlv::Profile3GPP_ApnName>(a2, (_QWORD *)(a1 + 16));
  v7 = &(*a2)[-v5];
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP2_ApnName>::clone(uint64_t a1)
{
  uint64_t v2;
  std::string *v3;

  v2 = operator new();
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)v2 = off_24D5DD6B0;
  v3 = (std::string *)(v2 + 16);
  if (*(char *)(a1 + 39) < 0)
  {
    std::string::__init_copy_ctor_external(v3, *(const std::string::value_type **)(a1 + 16), *(_QWORD *)(a1 + 24));
  }
  else
  {
    *(_OWORD *)&v3->__r_.__value_.__l.__data_ = *(_OWORD *)(a1 + 16);
    *(_QWORD *)(v2 + 32) = *(_QWORD *)(a1 + 32);
  }
  return v2;
}

void sub_2169F3704(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199FEAC4](v1, 0x1093C4081B1C094);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP2_PdpType>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP2_PdpType>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_ProfileIdentifier>();
}

_BYTE *qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP2_PdpType>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE *result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::Profile3GPP_PdpType>((_BYTE **)a2, (_DWORD *)(a1 + 12));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP2_PdpType>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5DD700;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a1 + 12);
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP2_UserName>::~TlvWrapper(uint64_t a1)
{
  *(_QWORD *)a1 = off_24D5DD750;
  if (*(char *)(a1 + 39) < 0)
    operator delete(*(void **)(a1 + 16));
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP2_UserName>::~TlvWrapper(uint64_t a1)
{
  *(_QWORD *)a1 = off_24D5DD750;
  if (*(char *)(a1 + 39) < 0)
    operator delete(*(void **)(a1 + 16));
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP2_UserName>::getSize(uint64_t a1)
{
  return tlv::size<wds::tlv::Profile3GPP_ApnName>(a1 + 16);
}

char *qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP2_UserName>::write(uint64_t a1, char **a2)
{
  char v3;
  char *v4;
  uint64_t v5;
  char *result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = *a2;
  v5 = (uint64_t)(*a2 + 3);
  *a2 = (char *)v5;
  result = tlv::writeV<wds::tlv::Profile3GPP_ApnName>(a2, (_QWORD *)(a1 + 16));
  v7 = &(*a2)[-v5];
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP2_UserName>::clone(uint64_t a1)
{
  uint64_t v2;
  std::string *v3;

  v2 = operator new();
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)v2 = off_24D5DD750;
  v3 = (std::string *)(v2 + 16);
  if (*(char *)(a1 + 39) < 0)
  {
    std::string::__init_copy_ctor_external(v3, *(const std::string::value_type **)(a1 + 16), *(_QWORD *)(a1 + 24));
  }
  else
  {
    *(_OWORD *)&v3->__r_.__value_.__l.__data_ = *(_OWORD *)(a1 + 16);
    *(_QWORD *)(v2 + 32) = *(_QWORD *)(a1 + 32);
  }
  return v2;
}

void sub_2169F3950(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199FEAC4](v1, 0x1093C4081B1C094);
  _Unwind_Resume(a1);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP2_Password>::~TlvWrapper(uint64_t a1)
{
  *(_QWORD *)a1 = off_24D5DD7A0;
  if (*(char *)(a1 + 39) < 0)
    operator delete(*(void **)(a1 + 16));
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP2_Password>::~TlvWrapper(uint64_t a1)
{
  *(_QWORD *)a1 = off_24D5DD7A0;
  if (*(char *)(a1 + 39) < 0)
    operator delete(*(void **)(a1 + 16));
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP2_Password>::getSize(uint64_t a1)
{
  return tlv::size<wds::tlv::Profile3GPP_ApnName>(a1 + 16);
}

char *qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP2_Password>::write(uint64_t a1, char **a2)
{
  char v3;
  char *v4;
  uint64_t v5;
  char *result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = *a2;
  v5 = (uint64_t)(*a2 + 3);
  *a2 = (char *)v5;
  result = tlv::writeV<wds::tlv::Profile3GPP_ApnName>(a2, (_QWORD *)(a1 + 16));
  v7 = &(*a2)[-v5];
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP2_Password>::clone(uint64_t a1)
{
  uint64_t v2;
  std::string *v3;

  v2 = operator new();
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)v2 = off_24D5DD7A0;
  v3 = (std::string *)(v2 + 16);
  if (*(char *)(a1 + 39) < 0)
  {
    std::string::__init_copy_ctor_external(v3, *(const std::string::value_type **)(a1 + 16), *(_QWORD *)(a1 + 24));
  }
  else
  {
    *(_OWORD *)&v3->__r_.__value_.__l.__data_ = *(_OWORD *)(a1 + 16);
    *(_QWORD *)(v2 + 32) = *(_QWORD *)(a1 + 32);
  }
  return v2;
}

void sub_2169F3AD4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199FEAC4](v1, 0x1093C4081B1C094);
  _Unwind_Resume(a1);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP2_PDNUserName>::~TlvWrapper(uint64_t a1)
{
  *(_QWORD *)a1 = off_24D5DD7F0;
  if (*(char *)(a1 + 39) < 0)
    operator delete(*(void **)(a1 + 16));
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP2_PDNUserName>::~TlvWrapper(uint64_t a1)
{
  *(_QWORD *)a1 = off_24D5DD7F0;
  if (*(char *)(a1 + 39) < 0)
    operator delete(*(void **)(a1 + 16));
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP2_PDNUserName>::getSize(uint64_t a1)
{
  return tlv::size<wds::tlv::Profile3GPP_ApnName>(a1 + 16);
}

char *qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP2_PDNUserName>::write(uint64_t a1, char **a2)
{
  char v3;
  char *v4;
  uint64_t v5;
  char *result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = *a2;
  v5 = (uint64_t)(*a2 + 3);
  *a2 = (char *)v5;
  result = tlv::writeV<wds::tlv::Profile3GPP_ApnName>(a2, (_QWORD *)(a1 + 16));
  v7 = &(*a2)[-v5];
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP2_PDNUserName>::clone(uint64_t a1)
{
  uint64_t v2;
  std::string *v3;

  v2 = operator new();
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)v2 = off_24D5DD7F0;
  v3 = (std::string *)(v2 + 16);
  if (*(char *)(a1 + 39) < 0)
  {
    std::string::__init_copy_ctor_external(v3, *(const std::string::value_type **)(a1 + 16), *(_QWORD *)(a1 + 24));
  }
  else
  {
    *(_OWORD *)&v3->__r_.__value_.__l.__data_ = *(_OWORD *)(a1 + 16);
    *(_QWORD *)(v2 + 32) = *(_QWORD *)(a1 + 32);
  }
  return v2;
}

void sub_2169F3C58(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199FEAC4](v1, 0x1093C4081B1C094);
  _Unwind_Resume(a1);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP2_PDNPassword>::~TlvWrapper(uint64_t a1)
{
  *(_QWORD *)a1 = off_24D5DD840;
  if (*(char *)(a1 + 39) < 0)
    operator delete(*(void **)(a1 + 16));
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP2_PDNPassword>::~TlvWrapper(uint64_t a1)
{
  *(_QWORD *)a1 = off_24D5DD840;
  if (*(char *)(a1 + 39) < 0)
    operator delete(*(void **)(a1 + 16));
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP2_PDNPassword>::getSize(uint64_t a1)
{
  return tlv::size<wds::tlv::Profile3GPP_ApnName>(a1 + 16);
}

char *qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP2_PDNPassword>::write(uint64_t a1, char **a2)
{
  char v3;
  char *v4;
  uint64_t v5;
  char *result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = *a2;
  v5 = (uint64_t)(*a2 + 3);
  *a2 = (char *)v5;
  result = tlv::writeV<wds::tlv::Profile3GPP_ApnName>(a2, (_QWORD *)(a1 + 16));
  v7 = &(*a2)[-v5];
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP2_PDNPassword>::clone(uint64_t a1)
{
  uint64_t v2;
  std::string *v3;

  v2 = operator new();
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)v2 = off_24D5DD840;
  v3 = (std::string *)(v2 + 16);
  if (*(char *)(a1 + 39) < 0)
  {
    std::string::__init_copy_ctor_external(v3, *(const std::string::value_type **)(a1 + 16), *(_QWORD *)(a1 + 24));
  }
  else
  {
    *(_OWORD *)&v3->__r_.__value_.__l.__data_ = *(_OWORD *)(a1 + 16);
    *(_QWORD *)(v2 + 32) = *(_QWORD *)(a1 + 32);
  }
  return v2;
}

void sub_2169F3DDC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199FEAC4](v1, 0x1093C4081B1C094);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP2_PDNAuthPref>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP2_PDNAuthPref>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_ProfileIdentifier>();
}

_BYTE *qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP2_PDNAuthPref>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE *result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::Profile3GPP_ProfileIdentifier>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP2_PDNAuthPref>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5DD890;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP2_InactivityTimer>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP2_InactivityTimer>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP2_InactivityTimer>();
}

_DWORD *qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP2_InactivityTimer>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _DWORD *v4;
  uint64_t v5;
  _DWORD *result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_DWORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::Profile3GPP2_InactivityTimer>((_DWORD **)a2, (_DWORD *)(a1 + 12));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP2_InactivityTimer>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5DD8E0;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a1 + 12);
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP2_ProxyAddrNeeded>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP2_ProxyAddrNeeded>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_ProfileIdentifier>();
}

_BYTE *qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP2_ProxyAddrNeeded>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE *result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::Profile3GPP_ProfileIdentifier>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP2_ProxyAddrNeeded>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5DD930;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP2_OperatorReservedPcoId>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP2_OperatorReservedPcoId>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_OperatorReservedPcoId>();
}

_WORD *qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP2_OperatorReservedPcoId>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _WORD *v4;
  uint64_t v5;
  _WORD *result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_WORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::Profile3GPP_OperatorReservedPcoId>((_WORD **)a2, (_WORD *)(a1 + 10));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP2_OperatorReservedPcoId>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5DD980;
  *(_WORD *)(result + 10) = *(_WORD *)(a1 + 10);
  return result;
}

void QMIQOSClientIPInterface::createQMIQOSClientIP(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, int a4@<W3>, NSObject **a5@<X4>, _OWORD *a6@<X8>)
{
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  NSObject *v15;
  std::__shared_weak_count *v16;
  unint64_t *p_shared_owners;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  dispatch_object_t object;
  uint64_t v23;
  std::__shared_weak_count *v24;
  uint64_t v25;
  std::__shared_weak_count *v26;
  __int128 v27;

  v9 = a1[1];
  v25 = *a1;
  v26 = (std::__shared_weak_count *)v9;
  if (v9)
  {
    v10 = (unint64_t *)(v9 + 8);
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }
  v12 = a3[1];
  v23 = *a3;
  v24 = (std::__shared_weak_count *)v12;
  if (v12)
  {
    v13 = (unint64_t *)(v12 + 8);
    do
      v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
  }
  v15 = *a5;
  object = v15;
  if (v15)
    dispatch_retain(v15);
  QMIQOSClientIP::create(&v25, a2, &v23, a4, &object, (uint64_t *)&v27);
  *a6 = v27;
  v27 = 0uLL;
  if (object)
    dispatch_release(object);
  v16 = v24;
  if (v24)
  {
    p_shared_owners = (unint64_t *)&v24->__shared_owners_;
    do
      v18 = __ldaxr(p_shared_owners);
    while (__stlxr(v18 - 1, p_shared_owners));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
  v19 = v26;
  if (v26)
  {
    v20 = (unint64_t *)&v26->__shared_owners_;
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }
}

void sub_2169F4238(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, char a11, uint64_t a12, char a13)
{
  if (object)
    dispatch_release(object);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  _Unwind_Resume(a1);
}

void QMIQOSClientIP::create(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, int a4@<W3>, NSObject **a5@<X4>, uint64_t *a6@<X8>)
{
  uint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *p_shared_owners;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  NSObject *v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  std::__shared_weak_count *v22;
  unint64_t v23;
  unint64_t *p_shared_weak_owners;
  unint64_t v25;
  unint64_t v26;
  unint64_t *v27;
  unint64_t v28;
  unint64_t v29;
  capabilities::ct *v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  QMIQOSClientIP *v37;
  dispatch_object_t object;
  uint64_t v39;
  std::__shared_weak_count *v40;
  uint64_t v41;
  std::__shared_weak_count *v42;

  *a6 = 0;
  a6[1] = 0;
  v12 = operator new();
  v13 = (std::__shared_weak_count *)a1[1];
  v41 = *a1;
  v42 = v13;
  if (v13)
  {
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      v15 = __ldxr(p_shared_owners);
    while (__stxr(v15 + 1, p_shared_owners));
  }
  v16 = (std::__shared_weak_count *)a3[1];
  v39 = *a3;
  v40 = v16;
  if (v16)
  {
    v17 = (unint64_t *)&v16->__shared_owners_;
    do
      v18 = __ldxr(v17);
    while (__stxr(v18 + 1, v17));
  }
  v19 = *a5;
  object = v19;
  if (v19)
    dispatch_retain(v19);
  QMIQOSClientIP::QMIQOSClientIP(v12, &v41, a2, &v39, a4, &object);
  *a6 = v12;
  a6[1] = 0;
  v20 = (std::__shared_weak_count *)operator new();
  v20->__shared_owners_ = 0;
  v21 = (unint64_t *)&v20->__shared_owners_;
  v20->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5DD9B8;
  v20->__shared_weak_owners_ = 0;
  v20[1].__vftable = (std::__shared_weak_count_vtbl *)v12;
  a6[1] = (uint64_t)v20;
  v22 = *(std::__shared_weak_count **)(v12 + 16);
  if (v22)
  {
    if (v22->__shared_owners_ != -1)
      goto LABEL_22;
    do
      v23 = __ldxr(v21);
    while (__stxr(v23 + 1, v21));
    p_shared_weak_owners = (unint64_t *)&v20->__shared_weak_owners_;
    do
      v25 = __ldxr(p_shared_weak_owners);
    while (__stxr(v25 + 1, p_shared_weak_owners));
    *(_QWORD *)(v12 + 8) = v12;
    *(_QWORD *)(v12 + 16) = v20;
    std::__shared_weak_count::__release_weak(v22);
  }
  else
  {
    do
      v26 = __ldxr(v21);
    while (__stxr(v26 + 1, v21));
    v27 = (unint64_t *)&v20->__shared_weak_owners_;
    do
      v28 = __ldxr(v27);
    while (__stxr(v28 + 1, v27));
    *(_QWORD *)(v12 + 8) = v12;
    *(_QWORD *)(v12 + 16) = v20;
  }
  do
    v29 = __ldaxr(v21);
  while (__stlxr(v29 - 1, v21));
  if (!v29)
  {
    ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
    std::__shared_weak_count::__release_weak(v20);
  }
LABEL_22:
  v30 = (capabilities::ct *)object;
  if (object)
    dispatch_release(object);
  v31 = v40;
  if (v40)
  {
    v32 = (unint64_t *)&v40->__shared_owners_;
    do
      v33 = __ldaxr(v32);
    while (__stlxr(v33 - 1, v32));
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
      std::__shared_weak_count::__release_weak(v31);
    }
  }
  v34 = v42;
  if (v42)
  {
    v35 = (unint64_t *)&v42->__shared_owners_;
    do
      v36 = __ldaxr(v35);
    while (__stlxr(v36 - 1, v35));
    if (!v36)
    {
      ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
      std::__shared_weak_count::__release_weak(v34);
    }
  }
  v37 = (QMIQOSClientIP *)*a6;
  if ((capabilities::ct::supportsDataQMIExtensions(v30) & 1) == 0)
    QMIQOSClientIP::createQoSClientOnDemand(v37);
}

void sub_2169F44A0(void *a1)
{
  dispatch_queue_t *v1;

  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)std::shared_ptr<QMIQOSClientIP> ctu::SharedSynchronizable<QMIQOSClientIP>::make_shared_ptr<QMIQOSClientIP>(QMIQOSClientIP*)::{lambda(QMIQOSClientIP*)#1}::operator() const(QMIQOSClientIP*)::{lambda(void *)#1}::__invoke);
  __cxa_rethrow();
}

void sub_2169F44C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, char a11, uint64_t a12, char a13)
{
  __cxa_end_catch();
  if (object)
    dispatch_release(object);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<QMIQOSClientIP *,std::shared_ptr<QMIQOSClientIP> ctu::SharedSynchronizable<QMIQOSClientIP>::make_shared_ptr<QMIQOSClientIP>(QMIQOSClientIP*)::{lambda(QMIQOSClientIP *)#1},std::allocator<QMIQOSClientIP>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void std::__shared_ptr_pointer<QMIQOSClientIP *,std::shared_ptr<QMIQOSClientIP> ctu::SharedSynchronizable<QMIQOSClientIP>::make_shared_ptr<QMIQOSClientIP>(QMIQOSClientIP*)::{lambda(QMIQOSClientIP *)#1},std::allocator<QMIQOSClientIP>>::__on_zero_shared(uint64_t a1)
{
  dispatch_barrier_async_f(*(dispatch_queue_t *)(*(_QWORD *)(a1 + 24) + 24), *(void **)(a1 + 24), (dispatch_function_t)std::shared_ptr<QMIQOSClientIP> ctu::SharedSynchronizable<QMIQOSClientIP>::make_shared_ptr<QMIQOSClientIP>(QMIQOSClientIP*)::{lambda(QMIQOSClientIP*)#1}::operator() const(QMIQOSClientIP*)::{lambda(void *)#1}::__invoke);
}

uint64_t std::__shared_ptr_pointer<QMIQOSClientIP *,std::shared_ptr<QMIQOSClientIP> ctu::SharedSynchronizable<QMIQOSClientIP>::make_shared_ptr<QMIQOSClientIP>(QMIQOSClientIP*)::{lambda(QMIQOSClientIP *)#1},std::allocator<QMIQOSClientIP>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t std::shared_ptr<QMIQOSClientIP> ctu::SharedSynchronizable<QMIQOSClientIP>::make_shared_ptr<QMIQOSClientIP>(QMIQOSClientIP*)::{lambda(QMIQOSClientIP*)#1}::operator() const(QMIQOSClientIP*)::{lambda(void *)#1}::__invoke(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

void QMIDesenseCommandDriver::create(uint64_t a1@<X0>, NSObject **a2@<X1>, uint64_t *a3@<X8>)
{
  _QWORD *v6;
  NSObject *v7;
  dispatch_object_t v8;

  v6 = (_QWORD *)operator new();
  v7 = *a2;
  v8 = v7;
  if (v7)
    dispatch_retain(v7);
  QMIDesenseCommandDriver::QMIDesenseCommandDriver(v6, a1, &v8);
  *a3 = 0;
  a3[1] = 0;
  std::shared_ptr<QMIDesenseCommandDriver>::shared_ptr[abi:ne180100]<QMIDesenseCommandDriver,std::shared_ptr<QMIDesenseCommandDriver> ctu::SharedSynchronizable<DesenseCommandDriver>::make_shared_ptr<QMIDesenseCommandDriver>(QMIDesenseCommandDriver*)::{lambda(QMIDesenseCommandDriver*)#1},void>(a3, (uint64_t)v6);
  if (v7)
    dispatch_release(v7);
}

void sub_2169F4670(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  NSObject *v2;
  int v3;

  if (v2)
    dispatch_release(v2);
  if (v3)
    MEMORY[0x2199FEAC4](v1, 0xF1C40FB9B6D2BLL);
  _Unwind_Resume(exception_object);
}

_QWORD *QMIDesenseCommandDriver::QMIDesenseCommandDriver(_QWORD *a1, uint64_t a2, dispatch_object_t *a3)
{
  NSObject *object;

  object = *a3;
  if (*a3)
    dispatch_retain(*a3);
  DesenseCommandDriver::DesenseCommandDriver();
  if (object)
    dispatch_release(object);
  *a1 = &off_24D5DDA28;
  a1[12] = 0;
  a1[13] = 0;
  a1[11] = &unk_24D5DDA80;
  return a1;
}

void sub_2169F4724(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object)
{
  if (object)
    dispatch_release(object);
  _Unwind_Resume(exception_object);
}

void QMIDesenseCommandDriver::~QMIDesenseCommandDriver(QMIDesenseCommandDriver *this)
{
  *(_QWORD *)this = &off_24D5DDA28;
  *((_QWORD *)this + 11) = &unk_24D5DDA80;
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)this + 96);
  DesenseCommandDriver::~DesenseCommandDriver(this);
}

{
  *(_QWORD *)this = &off_24D5DDA28;
  *((_QWORD *)this + 11) = &unk_24D5DDA80;
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)this + 96);
  DesenseCommandDriver::~DesenseCommandDriver(this);
  JUMPOUT(0x2199FEAC4);
}

void `non-virtual thunk to'QMIDesenseCommandDriver::~QMIDesenseCommandDriver(QMIDesenseCommandDriver *this)
{
  DesenseCommandDriver *v1;

  *((_QWORD *)this - 11) = &off_24D5DDA28;
  v1 = (QMIDesenseCommandDriver *)((char *)this - 88);
  *(_QWORD *)this = &unk_24D5DDA80;
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
  DesenseCommandDriver::~DesenseCommandDriver(v1);
}

{
  QMIDesenseCommandDriver::~QMIDesenseCommandDriver((QMIDesenseCommandDriver *)((char *)this - 88));
}

void QMIDesenseCommandDriver::bootstrap(uint64_t a1, uint64_t *a2, xpc_endpoint_t *a3, NSObject **a4)
{
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  xpc_endpoint_t v10;
  NSObject *v11;
  uint64_t *v12;
  unint64_t v13;
  std::mutex *ServiceMap;
  _QWORD *v15;
  xpc_object_t v16;
  void *v17;
  xpc_object_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  std::__shared_weak_count *v27;
  std::__shared_weak_count *v28;
  std::__shared_weak_count *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unsigned int v33;
  BOOL v34;
  uint64_t *v35;
  uint64_t *v36;
  uint64_t **v37;
  uint64_t *v38;
  uint64_t v39;
  unint64_t *v40;
  unint64_t v41;
  unint64_t *v42;
  unint64_t v43;
  _QWORD v44[5];
  xpc_object_t v45;
  void *__p[2];
  char v47;
  dispatch_group_t group;
  xpc_object_t object;
  uint64_t v50;
  std::__shared_weak_count *v51;
  _QWORD *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  unsigned __int16 v56;
  __int128 aBlock;
  void (*v58)(uint64_t, _QWORD *);
  void *v59;
  _QWORD *v60;
  uint64_t v61;
  std::__shared_weak_count *v62;
  unsigned __int16 *v63;

  v7 = (std::__shared_weak_count *)a2[1];
  v50 = *a2;
  v51 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }
  v10 = *a3;
  object = v10;
  if (v10)
    xpc_retain(v10);
  else
    object = xpc_null_create();
  v11 = *a4;
  group = v11;
  if (v11)
  {
    dispatch_retain(v11);
    dispatch_group_enter(v11);
  }
  DesenseCommandDriver::bootstrap();
  if (group)
  {
    dispatch_group_leave(group);
    dispatch_release(group);
  }
  xpc_release(object);
  object = 0;
  if (v51)
  {
    v12 = &v51->__shared_owners_;
    do
      v13 = __ldaxr((unint64_t *)v12);
    while (__stlxr(v13 - 1, (unint64_t *)v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
      std::__shared_weak_count::__release_weak(v51);
    }
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 56));
  ctu::shared_ptr_map_impl<ctu::indexed_by_any_map_hashing_key>::get<QMIClientPool>(ServiceMap, &v52);
  v15 = v52;
  std::string::basic_string[abi:ne180100]<0>(__p, "registration");
  v16 = xpc_null_create();
  v45 = v16;
  if (MEMORY[0x2199FEDD0](*a3) == MEMORY[0x24BDACFB0])
  {
    v17 = xpc_connection_create_from_endpoint(*a3);
    if (!v17)
      v17 = xpc_null_create();
    v18 = xpc_null_create();
    v45 = v17;
    xpc_release(v16);
    xpc_release(v18);
  }
  QMIClientPool::requestClient(v15, 3u, (uint64_t *)__p, a1 + 88, (uint64_t)&v45, &aBlock);
  std::shared_ptr<qmi::Client::State>::operator=[abi:ne180100](a1 + 96, &aBlock);
  v19 = (std::__shared_weak_count *)*((_QWORD *)&aBlock + 1);
  if (*((_QWORD *)&aBlock + 1))
  {
    v20 = (unint64_t *)(*((_QWORD *)&aBlock + 1) + 8);
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }
  xpc_release(v45);
  v45 = 0;
  if (v47 < 0)
    operator delete(__p[0]);
  v22 = (std::__shared_weak_count *)v53;
  if (v53)
  {
    v23 = (unint64_t *)(v53 + 8);
    do
      v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
  }
  v25 = *(_QWORD *)(a1 + 96);
  v26 = MEMORY[0x24BDAC760];
  v44[0] = MEMORY[0x24BDAC760];
  v44[1] = 0x40000000;
  v44[2] = ___ZN23QMIDesenseCommandDriver9bootstrapENSt3__110shared_ptrI37DesenseCommandDriverDelegateInterfaceEEN3xpc8endpointEN8dispatch13group_sessionE_block_invoke;
  v44[3] = &__block_descriptor_tmp_32;
  v44[4] = a1;
  v27 = *(std::__shared_weak_count **)(v25 + 8);
  if (v27)
  {
    v28 = std::__shared_weak_count::lock(v27);
    v62 = v28;
    if (v28)
    {
      v29 = v28;
      v61 = *(_QWORD *)v25;
      v30 = v61;
      if (v61)
      {
        v52 = (_QWORD *)(v25 + 88);
        v53 = 1;
        MEMORY[0x2199FDF3C]();
        v31 = *(_QWORD *)(v25 + 24);
        if (v31)
        {
          v32 = v25 + 24;
          do
          {
            v33 = *(unsigned __int16 *)(v31 + 32);
            v34 = v33 >= 0x555B;
            if (v33 >= 0x555B)
              v35 = (uint64_t *)v31;
            else
              v35 = (uint64_t *)(v31 + 8);
            if (v34)
              v32 = v31;
            v31 = *v35;
          }
          while (*v35);
          if (v32 != v25 + 24 && *(unsigned __int16 *)(v32 + 32) <= 0x555Bu)
            __TUAssertTrigger();
        }
        *(_QWORD *)&aBlock = v26;
        *((_QWORD *)&aBlock + 1) = 0x40000000;
        v58 = ___ZN16QMIVirtualClient26registerUnsolicitedHandlerIN3nas17SetFreqReportMode10IndicationEEEvU13block_pointerFvRKT_E_block_invoke;
        v59 = &unk_24D5DDCF8;
        v60 = v44;
        v36 = (uint64_t *)_Block_copy(&aBlock);
        v56 = 21851;
        v63 = &v56;
        v37 = std::__tree<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::less<unsigned short>,true>,std::allocator<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>>>::__emplace_unique_key_args<unsigned short,std::piecewise_construct_t const&,std::tuple<unsigned short &&>,std::tuple<>>((uint64_t **)(v25 + 16), &v56, (uint64_t)&std::piecewise_construct, &v63);
        v38 = v37[5];
        v37[5] = v36;
        if (v38)
          _Block_release(v38);
        std::unique_lock<ctu::UnfairLock>::~unique_lock[abi:ne180100]((uint64_t)&v52);
        v52 = 0;
        v53 = 0;
        v39 = *(_QWORD *)(v25 + 64);
        v54 = *(_QWORD *)(v25 + 56);
        v55 = v39;
        if (v39)
        {
          v40 = (unint64_t *)(v39 + 8);
          do
            v41 = __ldxr(v40);
          while (__stxr(v41 + 1, v40));
        }
        QMIClientPool::registerUnsolicitedHandler(v30, (uint64_t)&v52, v25, 0x555Bu);
        qmi::Client::~Client((qmi::Client *)&v52);
      }
      v42 = (unint64_t *)&v29->__shared_owners_;
      do
        v43 = __ldaxr(v42);
      while (__stlxr(v43 - 1, v42));
      if (!v43)
      {
        ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
        std::__shared_weak_count::__release_weak(v29);
      }
    }
  }
}

void sub_2169F4BEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, xpc_object_t object, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  uint64_t v26;

  std::unique_lock<ctu::UnfairLock>::~unique_lock[abi:ne180100]((uint64_t)&a26);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v26 - 96);
  _Unwind_Resume(a1);
}

void sub_2169F4C90(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, dispatch_group_t group, xpc_object_t object,char a21)
{
  if (group)
  {
    dispatch_group_leave(group);
    dispatch_release(group);
  }
  xpc_release(object);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a21);
  JUMPOUT(0x2169F4C84);
}

void ___ZN23QMIDesenseCommandDriver9bootstrapENSt3__110shared_ptrI37DesenseCommandDriverDelegateInterfaceEEN3xpc8endpointEN8dispatch13group_sessionE_block_invoke(uint64_t a1, uint64_t *a2)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  std::__shared_weak_count *v10;
  std::__shared_weak_count *v11;
  _QWORD *v12;
  unint64_t *v13;
  unint64_t v14;
  NSObject *v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  _QWORD *v18;
  unint64_t v19;
  _QWORD v20[3];
  uint64_t v21;
  uint64_t v22;

  v2 = *(_QWORD **)(a1 + 32);
  v3 = *a2;
  v4 = a2[1];
  v20[0] = *a2;
  v5 = a2[2];
  v20[1] = v4;
  v20[2] = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  v8 = (std::__shared_weak_count *)v2[2];
  if (!v8 || (v9 = v2[1], (v10 = std::__shared_weak_count::lock(v8)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v11 = v10;
  v12 = (_QWORD *)operator new();
  *v12 = v2;
  v12[1] = v3;
  v12[2] = v4;
  v12[3] = v5;
  if (v5)
  {
    v13 = (unint64_t *)(v5 + 8);
    do
      v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
  }
  v15 = v2[3];
  p_shared_owners = (unint64_t *)&v11->__shared_owners_;
  do
    v17 = __ldxr(p_shared_owners);
  while (__stxr(v17 + 1, p_shared_owners));
  v18 = (_QWORD *)operator new();
  *v18 = v12;
  v18[1] = v9;
  v18[2] = v11;
  v21 = 0;
  v22 = 0;
  dispatch_async_f(v15, v18, (dispatch_function_t)_ZZN8dispatch5asyncIZNK3ctu20SharedSynchronizableI20DesenseCommandDriverE15execute_wrappedIZZN23QMIDesenseCommandDriver9bootstrapENSt3__110shared_ptrI37DesenseCommandDriverDelegateInterfaceEEN3xpc8endpointENS_13group_sessionEEUb_E3__0EEvOT_EUlvE_EEvP16dispatch_queue_sNS7_10unique_ptrISF_NS7_14default_deleteISF_EEEEENUlPvE_8__invokeESO_);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v21);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v22);
  do
    v19 = __ldaxr(p_shared_owners);
  while (__stlxr(v19 - 1, p_shared_owners));
  if (!v19)
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v20);
}

uint64_t QMIDesenseCommandDriver::shutdown(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD v4[2];

  v2 = *(_QWORD *)(a1 + 96);
  v4[0] = v2 + 88;
  v4[1] = 1;
  MEMORY[0x2199FDF3C](v2 + 88, a2);
  *(_BYTE *)(v2 + 74) = 0;
  return std::unique_lock<ctu::UnfairLock>::~unique_lock[abi:ne180100]((uint64_t)v4);
}

void QMIDesenseCommandDriver::registered(_QWORD *a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  std::__shared_weak_count *v10;
  _QWORD *v11;
  unint64_t *p_shared_owners;
  NSObject *v13;
  unint64_t v14;
  _QWORD *v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v3 = *a2;
  v4 = a2[1];
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  v7 = (std::__shared_weak_count *)a1[2];
  if (!v7 || (v8 = a1[1], (v9 = std::__shared_weak_count::lock(v7)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v10 = v9;
  v11 = (_QWORD *)operator new();
  *v11 = v3;
  v11[1] = v4;
  v11[2] = a1;
  p_shared_owners = (unint64_t *)&v10->__shared_owners_;
  v13 = a1[3];
  do
    v14 = __ldxr(p_shared_owners);
  while (__stxr(v14 + 1, p_shared_owners));
  v15 = (_QWORD *)operator new();
  *v15 = v11;
  v15[1] = v8;
  v15[2] = v10;
  v17 = 0;
  v18 = 0;
  dispatch_async_f(v13, v15, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<DesenseCommandDriver>::execute_wrapped<QMIDesenseCommandDriver::registered(std::shared_ptr<QMIVirtualClient>)::$_0>(QMIDesenseCommandDriver::registered(std::shared_ptr<QMIVirtualClient>)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIDesenseCommandDriver::registered(std::shared_ptr<QMIVirtualClient>)::$_0,std::default_delete<QMIDesenseCommandDriver::registered(std::shared_ptr<QMIVirtualClient>)::$_0>>)::{lambda(void *)#1}::__invoke);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v17);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v18);
  do
    v16 = __ldaxr(p_shared_owners);
  while (__stlxr(v16 - 1, p_shared_owners));
  if (!v16)
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
}

void `non-virtual thunk to'QMIDesenseCommandDriver::registered(uint64_t a1, uint64_t *a2)
{
  QMIDesenseCommandDriver::registered((_QWORD *)(a1 - 88), a2);
}

void QMIDesenseCommandDriver::deregistered(_QWORD *a1)
{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  _QWORD *v6;
  NSObject *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v2 = (std::__shared_weak_count *)a1[2];
  if (!v2 || (v3 = a1[1], (v4 = std::__shared_weak_count::lock(v2)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v5 = v4;
  v6 = (_QWORD *)operator new();
  *v6 = a1;
  v7 = a1[3];
  p_shared_owners = (unint64_t *)&v5->__shared_owners_;
  do
    v9 = __ldxr(p_shared_owners);
  while (__stxr(v9 + 1, p_shared_owners));
  v10 = (_QWORD *)operator new();
  *v10 = v6;
  v10[1] = v3;
  v10[2] = v5;
  v12 = 0;
  v13 = 0;
  dispatch_async_f(v7, v10, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<DesenseCommandDriver>::execute_wrapped<QMIDesenseCommandDriver::deregistered(std::shared_ptr<QMIVirtualClient>)::$_0>(QMIDesenseCommandDriver::deregistered(std::shared_ptr<QMIVirtualClient>)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIDesenseCommandDriver::deregistered(std::shared_ptr<QMIVirtualClient>)::$_0,std::default_delete<QMIDesenseCommandDriver::deregistered(std::shared_ptr<QMIVirtualClient>)::$_0>>)::{lambda(void *)#1}::__invoke);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v12);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v13);
  do
    v11 = __ldaxr(p_shared_owners);
  while (__stlxr(v11 - 1, p_shared_owners));
  if (!v11)
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
}

void `non-virtual thunk to'QMIDesenseCommandDriver::deregistered(uint64_t a1)
{
  QMIDesenseCommandDriver::deregistered((_QWORD *)(a1 - 88));
}

void QMIDesenseCommandDriver::registerFrequencyReporting(_QWORD *a1)
{
  NSObject *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  uint64_t v10;
  unint64_t *p_shared_weak_owners;
  unint64_t v12;
  void *v13;
  _OWORD v14[2];
  uint8_t buf[8];
  uint64_t v16;
  void (*v17)(_QWORD *, uint64_t);
  void *v18;
  uint64_t v19;
  std::__shared_weak_count *v20;
  _QWORD *v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  void *v26;
  _QWORD aBlock[5];

  v2 = a1[5];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_216897000, v2, OS_LOG_TYPE_DEFAULT, "#I Register for Frequency Reporting", buf, 2u);
  }
  memset(v14, 0, sizeof(v14));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v14);
  *(_BYTE *)qmi::MutableMessageBase::getTLV<nas::tlv::FrequencyRegistering>(v14, 176) = 2;
  v3 = a1[12];
  std::shared_ptr<AttachApnCommandDriver>::shared_ptr[abi:ne180100]<AttachApnCommandDriver,void>(buf, a1 + 1);
  v5 = *(_QWORD *)buf;
  v4 = (std::__shared_weak_count *)v16;
  if (v16)
  {
    v6 = (unint64_t *)(v16 + 16);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  if (!*(_BYTE *)(v3 + 72) || !*(_QWORD *)(v3 + 56))
    __TUAssertTrigger();
  v22 = v3 + 40;
  v23 = QMIServiceMsg::create();
  v24 = 25000;
  v25 = 0;
  v26 = 0;
  v10 = MEMORY[0x24BDAC760];
  *(_QWORD *)buf = MEMORY[0x24BDAC760];
  v16 = 1174405120;
  v17 = ___ZN16QMIVirtualClient4sendIN3nas18IndicationRegister7RequestE20DesenseCommandDriverZN23QMIDesenseCommandDriver26registerFrequencyReportingEN10subscriber7SimSlotEE3__0EENSt3__19enable_ifIXntsr3std26is_member_function_pointerIT1_EE5valueEvE4typeERKT_NS9_8weak_ptrIT0_EESB__block_invoke;
  v18 = &__block_descriptor_tmp_31_4;
  v19 = v5;
  v20 = v4;
  if (v4)
  {
    p_shared_weak_owners = (unint64_t *)&v4->__shared_weak_owners_;
    do
      v12 = __ldxr(p_shared_weak_owners);
    while (__stxr(v12 + 1, p_shared_weak_owners));
  }
  v21 = a1;
  aBlock[0] = v10;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_22;
  aBlock[3] = &unk_24D5DDD50;
  aBlock[4] = buf;
  v13 = _Block_copy(aBlock);
  v26 = v13;
  if (v23)
  {
    qmi::Client::send();
    v13 = v26;
  }
  if (v13)
    _Block_release(v13);
  if (v20)
    std::__shared_weak_count::__release_weak(v20);
  if (v4)
    std::__shared_weak_count::__release_weak(v4);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v14);
}

void sub_2169F52A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18, uint64_t a19, uint64_t a20,char a21)
{
  std::__shared_weak_count *v21;

  if (a18)
    std::__shared_weak_count::__release_weak(a18);
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)&a21);
  if (v21)
    std::__shared_weak_count::__release_weak(v21);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a9);
  _Unwind_Resume(a1);
}

void QMIDesenseCommandDriver::setFrequencyReportingMode(_QWORD *a1, uint64_t a2, char a3)
{
  NSObject *v5;
  uint64_t v6;
  __int128 v7;
  unint64_t *v8;
  unint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  void *v15;
  _OWORD v16[2];
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  void *v21;
  _QWORD aBlock[5];
  __int128 buf;
  void (*v24)(_QWORD *, uint64_t *);
  void *v25;
  __int128 v26;
  _QWORD *v27;
  uint64_t v28;

  v28 = *MEMORY[0x24BDAC8D0];
  v5 = a1[5];
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 136315138;
    *(_QWORD *)((char *)&buf + 4) = asString();
    _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#I Set Frequency reporting mode: %s", (uint8_t *)&buf, 0xCu);
  }
  memset(v16, 0, sizeof(v16));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v16);
  *(_BYTE *)qmi::MutableMessageBase::getTLV<nas::tlv::FrequencyReporting>(v16, 176) = a3;
  v6 = a1[12];
  std::shared_ptr<AttachApnCommandDriver>::shared_ptr[abi:ne180100]<AttachApnCommandDriver,void>(&buf, a1 + 1);
  v7 = buf;
  if (*((_QWORD *)&buf + 1))
  {
    v8 = (unint64_t *)(*((_QWORD *)&buf + 1) + 16);
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
    v10 = (unint64_t *)(*((_QWORD *)&v7 + 1) + 8);
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      (*(void (**)(_QWORD))(**((_QWORD **)&v7 + 1) + 16))(*((_QWORD *)&v7 + 1));
      std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v7 + 1));
    }
  }
  if (!*(_BYTE *)(v6 + 72) || !*(_QWORD *)(v6 + 56))
    __TUAssertTrigger();
  v17 = v6 + 40;
  v18 = QMIServiceMsg::create();
  v19 = 25000;
  v20 = 0;
  v21 = 0;
  v12 = MEMORY[0x24BDAC760];
  *(_QWORD *)&buf = MEMORY[0x24BDAC760];
  *((_QWORD *)&buf + 1) = 1174405120;
  v24 = ___ZN16QMIVirtualClient4sendIN3nas17SetFreqReportMode7RequestE20DesenseCommandDriverZN23QMIDesenseCommandDriver25setFrequencyReportingModeEN10subscriber7SimSlotE22FrequencyReportingModeE3__0EENSt3__19enable_ifIXntsr3std26is_member_function_pointerIT1_EE5valueEvE4typeERKT_NSA_8weak_ptrIT0_EESC__block_invoke;
  v25 = &__block_descriptor_tmp_33_8;
  v26 = v7;
  if (*((_QWORD *)&v7 + 1))
  {
    v13 = (unint64_t *)(*((_QWORD *)&v7 + 1) + 16);
    do
      v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
  }
  v27 = a1;
  aBlock[0] = v12;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_22;
  aBlock[3] = &unk_24D5DDD50;
  aBlock[4] = &buf;
  v15 = _Block_copy(aBlock);
  v21 = v15;
  if (v18)
  {
    qmi::Client::send();
    v15 = v21;
  }
  if (v15)
    _Block_release(v15);
  if (*((_QWORD *)&v26 + 1))
    std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v26 + 1));
  if (*((_QWORD *)&v7 + 1))
    std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v7 + 1));
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v16);
}

void sub_2169F5518(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  std::__shared_weak_count *v13;
  uint64_t v14;
  std::__shared_weak_count *v16;

  v16 = *(std::__shared_weak_count **)(v14 - 56);
  if (v16)
    std::__shared_weak_count::__release_weak(v16);
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)&a13);
  if (v13)
    std::__shared_weak_count::__release_weak(v13);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a9);
  _Unwind_Resume(a1);
}

void QMIDesenseCommandDriver::processFrequencyInd_sync(QMIDesenseCommandDriver *this, const nas::SetFreqReportMode::RespInd *a2)
{
  uint64_t v4;
  uint64_t TlvValue;
  int v6;
  uint64_t v7;
  int v8;
  void *v9;
  int v10;
  void *v11;
  int v12;
  uint64_t *v13;
  unsigned __int8 *v14;
  int v15;
  unsigned __int8 *v16;
  int v17;
  void *v18;
  unsigned __int8 *v19;
  int v20;
  unsigned __int8 *v21;
  int v22;
  void *v23;
  unsigned __int8 *v24;
  int v25;
  unsigned __int8 *v26;
  int v27;
  unsigned __int8 *v28;
  unsigned __int8 *v29;
  int v30;
  unsigned __int8 *v31;
  int v32;
  unsigned __int8 *v33;
  unsigned __int8 *v34;
  int v35;
  unsigned __int8 *v36;
  int v37;
  unsigned __int8 *v38;
  unsigned __int8 *v39;
  int v40;
  unsigned __int8 *v41;
  int v42;
  void *v43;
  unsigned __int8 *v44;
  int v45;
  unsigned __int8 *v46;
  int v47;
  unsigned __int8 *v48;
  unsigned __int8 *v49;
  int v50;
  unsigned __int8 *v51;
  int v52;
  unsigned __int8 *v53;
  uint64_t v54;
  uint64_t v55[3];
  _QWORD v56[6];
  _QWORD v57[6];
  _QWORD v58[2];
  uint64_t (*v59)();
  void *v60;
  uint64_t *v61;
  QMIDesenseCommandDriver *v62;
  _QWORD v63[2];
  uint64_t (*v64)(uint64_t, uint64_t *);
  void *v65;
  uint64_t *v66;
  QMIDesenseCommandDriver *v67;
  _QWORD v68[2];
  uint64_t (*v69)(uint64_t, uint64_t *);
  void *v70;
  uint64_t *v71;
  QMIDesenseCommandDriver *v72;
  _QWORD v73[2];
  uint64_t (*v74)(uint64_t, uint64_t *);
  void *v75;
  uint64_t *v76;
  QMIDesenseCommandDriver *v77;
  _QWORD v78[2];
  uint64_t (*v79)();
  void *v80;
  uint64_t *v81;
  QMIDesenseCommandDriver *v82;
  _QWORD v83[2];
  uint64_t (*v84)();
  void *v85;
  uint64_t *v86;
  QMIDesenseCommandDriver *v87;
  uint64_t v88;
  uint64_t *v89;
  uint64_t v90;
  _QWORD *(*v91)(_QWORD *, _QWORD *);
  void (*v92)(uint64_t);
  _QWORD **v93;
  _QWORD *v94[2];
  _QWORD v95[2];
  uint64_t (*v96)(uint64_t, uint64_t);
  void *v97;
  QMIDesenseCommandDriver *v98;
  _QWORD v99[2];
  uint64_t (*v100)(uint64_t, unsigned __int8 *);
  void *v101;
  uint64_t *v102;
  uint64_t v103;
  uint64_t *v104;
  uint64_t v105;
  int v106;
  void *v107;
  void *v108;
  uint64_t v109;
  unsigned __int8 *v110;

  v103 = 0;
  v104 = &v103;
  v105 = 0x2000000000;
  v4 = MEMORY[0x24BDAC760];
  v106 = 0;
  v99[0] = MEMORY[0x24BDAC760];
  v99[1] = 0x40000000;
  v100 = ___ZN23QMIDesenseCommandDriver24processFrequencyInd_syncERKN3nas17SetFreqReportMode7RespIndE_block_invoke;
  v101 = &unk_24D5DDAD8;
  v102 = &v103;
  TlvValue = qmi::MessageBase::findTlvValue(a2);
  v7 = TlvValue;
  if (TlvValue)
  {
    v8 = v6;
    v88 = TlvValue;
    LOBYTE(v107) = tlv::parseV<nas::tlv::BBStatus>((unint64_t *)&v88, v6);
    if (v88)
      v100((uint64_t)v99, (unsigned __int8 *)&v107);
    else
      ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 177, v7, v8);
  }
  if ((*((_DWORD *)v104 + 6) | 2) == 2)
  {
    v95[0] = v4;
    v95[1] = 0x40000000;
    v96 = ___ZN23QMIDesenseCommandDriver24processFrequencyInd_syncERKN3nas17SetFreqReportMode7RespIndE_block_invoke_2;
    v97 = &__block_descriptor_tmp_12_15;
    v98 = this;
    v9 = (void *)qmi::MessageBase::findTlvValue(a2);
    v11 = v9;
    if (v9)
    {
      v12 = v10;
      v107 = v9;
      v88 = tlv::parseV<nas::tlv::BBCampUplinkFreq>((unint64_t *)&v107, v10);
      v89 = v13;
      if (v107)
        v96((uint64_t)v95, (uint64_t)&v88);
      else
        ((void (*)(_QWORD, uint64_t, void *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 187, v11, v12);
    }
  }
  else
  {
    (*(void (**)(_QWORD, uint64_t))(**((_QWORD **)this + 9) + 48))(*((_QWORD *)this + 9), 1);
  }
  v88 = 0;
  v89 = &v88;
  v90 = 0x4002000000;
  v91 = __Block_byref_object_copy__7;
  v92 = __Block_byref_object_dispose__7;
  v94[0] = 0;
  v94[1] = 0;
  v93 = v94;
  v83[0] = v4;
  v83[1] = 0x40000000;
  v84 = ___ZN23QMIDesenseCommandDriver24processFrequencyInd_syncERKN3nas17SetFreqReportMode7RespIndE_block_invoke_13;
  v85 = &unk_24D5DDB20;
  v86 = &v88;
  v87 = this;
  v14 = (unsigned __int8 *)qmi::MessageBase::findTlvValue(a2);
  v16 = v14;
  if (v14)
  {
    v17 = v15;
    v110 = v14;
    v107 = (void *)tlv::parseV<nas::tlv::BBCampFreq>((unint64_t *)&v110, v15);
    v108 = v18;
    if (v110)
      ((void (*)(_QWORD *, void **))v84)(v83, &v107);
    else
      ((void (*)(_QWORD, uint64_t, unsigned __int8 *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 178, v16, v17);
  }
  v78[0] = v4;
  v78[1] = 0x40000000;
  v79 = ___ZN23QMIDesenseCommandDriver24processFrequencyInd_syncERKN3nas17SetFreqReportMode7RespIndE_block_invoke_2_16;
  v80 = &unk_24D5DDB48;
  v81 = &v88;
  v82 = this;
  v19 = (unsigned __int8 *)qmi::MessageBase::findTlvValue(a2);
  v21 = v19;
  if (v19)
  {
    v22 = v20;
    v110 = v19;
    v107 = (void *)tlv::parseV<nas::tlv::BBSearchFreq>((unint64_t *)&v110, v20);
    v108 = v23;
    if (v110)
      ((void (*)(_QWORD *, void **))v79)(v78, &v107);
    else
      ((void (*)(_QWORD, uint64_t, unsigned __int8 *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 179, v21, v22);
  }
  v73[0] = v4;
  v73[1] = 0x40000000;
  v74 = ___ZN23QMIDesenseCommandDriver24processFrequencyInd_syncERKN3nas17SetFreqReportMode7RespIndE_block_invoke_3;
  v75 = &unk_24D5DDB70;
  v76 = &v88;
  v77 = this;
  v24 = (unsigned __int8 *)qmi::MessageBase::findTlvValue(a2);
  v26 = v24;
  if (v24)
  {
    v27 = v25;
    v109 = 0;
    v110 = v24;
    v107 = 0;
    v108 = 0;
    tlv::parseV<nas::tlv::BBHoppingList>(&v110, v25, (uint64_t *)&v107);
    v28 = v110;
    if (v110)
      v74((uint64_t)v73, (uint64_t *)&v107);
    if (v107)
    {
      v108 = v107;
      operator delete(v107);
    }
    if (!v28)
      ((void (*)(_QWORD, uint64_t, unsigned __int8 *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 180, v26, v27);
  }
  v68[0] = v4;
  v68[1] = 0x40000000;
  v69 = ___ZN23QMIDesenseCommandDriver24processFrequencyInd_syncERKN3nas17SetFreqReportMode7RespIndE_block_invoke_4;
  v70 = &unk_24D5DDB98;
  v71 = &v88;
  v72 = this;
  v29 = (unsigned __int8 *)qmi::MessageBase::findTlvValue(a2);
  v31 = v29;
  if (v29)
  {
    v32 = v30;
    v109 = 0;
    v110 = v29;
    v107 = 0;
    v108 = 0;
    tlv::parseV<nas::tlv::BBNeighborList>(&v110, v30, (uint64_t *)&v107);
    v33 = v110;
    if (v110)
      v69((uint64_t)v68, (uint64_t *)&v107);
    if (v107)
    {
      v108 = v107;
      operator delete(v107);
    }
    if (!v33)
      ((void (*)(_QWORD, uint64_t, unsigned __int8 *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 181, v31, v32);
  }
  v63[0] = v4;
  v63[1] = 0x40000000;
  v64 = ___ZN23QMIDesenseCommandDriver24processFrequencyInd_syncERKN3nas17SetFreqReportMode7RespIndE_block_invoke_5;
  v65 = &unk_24D5DDBC0;
  v66 = &v88;
  v67 = this;
  v34 = (unsigned __int8 *)qmi::MessageBase::findTlvValue(a2);
  v36 = v34;
  if (v34)
  {
    v37 = v35;
    v109 = 0;
    v110 = v34;
    v107 = 0;
    v108 = 0;
    tlv::parseV<nas::tlv::BBHRPLMNList>(&v110, v35, (uint64_t *)&v107);
    v38 = v110;
    if (v110)
      v64((uint64_t)v63, (uint64_t *)&v107);
    if (v107)
    {
      v108 = v107;
      operator delete(v107);
    }
    if (!v38)
      ((void (*)(_QWORD, uint64_t, unsigned __int8 *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 182, v36, v37);
  }
  v58[0] = v4;
  v58[1] = 0x40000000;
  v59 = ___ZN23QMIDesenseCommandDriver24processFrequencyInd_syncERKN3nas17SetFreqReportMode7RespIndE_block_invoke_6;
  v60 = &unk_24D5DDBE8;
  v61 = &v88;
  v62 = this;
  v39 = (unsigned __int8 *)qmi::MessageBase::findTlvValue(a2);
  v41 = v39;
  if (v39)
  {
    v42 = v40;
    v110 = v39;
    v107 = (void *)tlv::parseV<nas::tlv::BBCampSecondFreq>((unint64_t *)&v110, v40);
    v108 = v43;
    if (v110)
      ((void (*)(_QWORD *, void **))v59)(v58, &v107);
    else
      ((void (*)(_QWORD, uint64_t, unsigned __int8 *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 185, v41, v42);
  }
  v57[0] = v4;
  v57[1] = 0x40000000;
  v57[2] = ___ZN23QMIDesenseCommandDriver24processFrequencyInd_syncERKN3nas17SetFreqReportMode7RespIndE_block_invoke_7;
  v57[3] = &unk_24D5DDC10;
  v57[4] = &v88;
  v57[5] = this;
  v44 = (unsigned __int8 *)qmi::MessageBase::findTlvValue(a2);
  v46 = v44;
  if (v44)
  {
    v47 = v45;
    v109 = 0;
    v110 = v44;
    v107 = 0;
    v108 = 0;
    tlv::parseV<nas::tlv::BBNeighborSecondList>(&v110, v45, (uint64_t *)&v107);
    v48 = v110;
    if (v110)
      ___ZN23QMIDesenseCommandDriver24processFrequencyInd_syncERKN3nas17SetFreqReportMode7RespIndE_block_invoke_7((uint64_t)v57, (uint64_t *)&v107);
    if (v107)
    {
      v108 = v107;
      operator delete(v107);
    }
    if (!v48)
      ((void (*)(_QWORD, uint64_t, unsigned __int8 *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 186, v46, v47);
  }
  v56[0] = v4;
  v56[1] = 0x40000000;
  v56[2] = ___ZN23QMIDesenseCommandDriver24processFrequencyInd_syncERKN3nas17SetFreqReportMode7RespIndE_block_invoke_8;
  v56[3] = &unk_24D5DDC38;
  v56[4] = &v88;
  v56[5] = this;
  v49 = (unsigned __int8 *)qmi::MessageBase::findTlvValue(a2);
  v51 = v49;
  if (v49)
  {
    v52 = v50;
    v109 = 0;
    v110 = v49;
    v107 = 0;
    v108 = 0;
    tlv::parseV<nas::tlv::DLSCellFrequencyList>(&v110, v50, (uint64_t *)&v107);
    v53 = v110;
    if (v110)
      ___ZN23QMIDesenseCommandDriver24processFrequencyInd_syncERKN3nas17SetFreqReportMode7RespIndE_block_invoke_8((uint64_t)v56, (uint64_t *)&v107);
    if (v107)
    {
      v108 = v107;
      operator delete(v107);
    }
    if (!v53)
      ((void (*)(_QWORD, uint64_t, unsigned __int8 *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 188, v51, v52);
  }
  v54 = *((_QWORD *)this + 9);
  std::map<unsigned long long,DesenseFreq>::map[abi:ne180100](v55, (uint64_t)(v89 + 5));
  (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(_QWORD *)v54 + 32))(v54, 1, v55);
  std::__tree<std::__value_type<std::pair<Technology,Type>,InputThreshold>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,InputThreshold>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,InputThreshold>>>::destroy((uint64_t)v55, (_QWORD *)v55[1]);
  _Block_object_dispose(&v88, 8);
  std::__tree<std::__value_type<std::pair<Technology,Type>,InputThreshold>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,InputThreshold>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,InputThreshold>>>::destroy((uint64_t)&v93, v94[0]);
  _Block_object_dispose(&v103, 8);
}

void sub_2169F5C44(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 144), 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZN23QMIDesenseCommandDriver24processFrequencyInd_syncERKN3nas17SetFreqReportMode7RespIndE_block_invoke(uint64_t result, unsigned __int8 *a2)
{
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = *a2;
  return result;
}

uint64_t ___ZN23QMIDesenseCommandDriver24processFrequencyInd_syncERKN3nas17SetFreqReportMode7RespIndE_block_invoke_2(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(_QWORD, uint64_t, _QWORD, _QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 32) + 72) + 40))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 72), 1, *(_QWORD *)a2, *(unsigned int *)(a2 + 8));
}

_QWORD *__Block_byref_object_copy__7(_QWORD *result, _QWORD *a2)
{
  _QWORD *v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;

  result[5] = a2[5];
  v2 = a2 + 6;
  v3 = a2[6];
  result[6] = v3;
  v4 = result + 6;
  v5 = a2[7];
  result[7] = v5;
  if (v5)
  {
    *(_QWORD *)(v3 + 16) = v4;
    a2[5] = v2;
    *v2 = 0;
    a2[7] = 0;
  }
  else
  {
    result[5] = v4;
  }
  return result;
}

void __Block_byref_object_dispose__7(uint64_t a1)
{
  std::__tree<std::__value_type<std::pair<Technology,Type>,InputThreshold>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,InputThreshold>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,InputThreshold>>>::destroy(a1 + 40, *(_QWORD **)(a1 + 48));
}

uint64_t ___ZN23QMIDesenseCommandDriver24processFrequencyInd_syncERKN3nas17SetFreqReportMode7RespIndE_block_invoke_13()
{
  return DesenseCommandDriver::addSingleFrequencyToMap();
}

uint64_t ___ZN23QMIDesenseCommandDriver24processFrequencyInd_syncERKN3nas17SetFreqReportMode7RespIndE_block_invoke_2_16()
{
  return DesenseCommandDriver::addSingleFrequencyToMap();
}

uint64_t ___ZN23QMIDesenseCommandDriver24processFrequencyInd_syncERKN3nas17SetFreqReportMode7RespIndE_block_invoke_3(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t result;

  v2 = *a2;
  v3 = a2[1];
  if (*a2 != v3)
  {
    do
    {
      result = DesenseCommandDriver::addSingleFrequencyToMap();
      v2 += 16;
    }
    while (v2 != v3);
  }
  return result;
}

uint64_t ___ZN23QMIDesenseCommandDriver24processFrequencyInd_syncERKN3nas17SetFreqReportMode7RespIndE_block_invoke_4(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t result;

  v2 = *a2;
  v3 = a2[1];
  if (*a2 != v3)
  {
    do
    {
      result = DesenseCommandDriver::addSingleFrequencyToMap();
      v2 += 16;
    }
    while (v2 != v3);
  }
  return result;
}

uint64_t ___ZN23QMIDesenseCommandDriver24processFrequencyInd_syncERKN3nas17SetFreqReportMode7RespIndE_block_invoke_5(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t result;

  v2 = *a2;
  v3 = a2[1];
  if (*a2 != v3)
  {
    do
    {
      result = DesenseCommandDriver::addSingleFrequencyToMap();
      v2 += 16;
    }
    while (v2 != v3);
  }
  return result;
}

uint64_t ___ZN23QMIDesenseCommandDriver24processFrequencyInd_syncERKN3nas17SetFreqReportMode7RespIndE_block_invoke_6()
{
  return DesenseCommandDriver::addSingleFrequencyToMap();
}

uint64_t ___ZN23QMIDesenseCommandDriver24processFrequencyInd_syncERKN3nas17SetFreqReportMode7RespIndE_block_invoke_7(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t result;

  v2 = *a2;
  v3 = a2[1];
  if (*a2 != v3)
  {
    do
    {
      result = DesenseCommandDriver::addSingleFrequencyToMap();
      v2 += 16;
    }
    while (v2 != v3);
  }
  return result;
}

uint64_t ___ZN23QMIDesenseCommandDriver24processFrequencyInd_syncERKN3nas17SetFreqReportMode7RespIndE_block_invoke_8(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t result;

  v2 = *a2;
  v3 = a2[1];
  if (*a2 != v3)
  {
    do
    {
      result = DesenseCommandDriver::addSingleFrequencyToMap();
      v2 += 16;
    }
    while (v2 != v3);
  }
  return result;
}

uint64_t *std::shared_ptr<QMIDesenseCommandDriver>::shared_ptr[abi:ne180100]<QMIDesenseCommandDriver,std::shared_ptr<QMIDesenseCommandDriver> ctu::SharedSynchronizable<DesenseCommandDriver>::make_shared_ptr<QMIDesenseCommandDriver>(QMIDesenseCommandDriver*)::{lambda(QMIDesenseCommandDriver*)#1},void>(uint64_t *a1, uint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24D5DDCA0;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = (uint64_t)v4;
  if (a2)
    v5 = (_QWORD *)(a2 + 8);
  else
    v5 = 0;
  std::shared_ptr<QMIDataSystemDeterminationManager>::__enable_weak_this[abi:ne180100]<QMIDataSystemDeterminationManager,QMIDataSystemDeterminationManager,void>((uint64_t)a1, v5, a2);
  return a1;
}

void sub_2169F6004(void *a1)
{
  dispatch_queue_t *v1;

  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)std::shared_ptr<QMIDesenseCommandDriver> ctu::SharedSynchronizable<DesenseCommandDriver>::make_shared_ptr<QMIDesenseCommandDriver>(QMIDesenseCommandDriver*)::{lambda(QMIDesenseCommandDriver*)#1}::operator() const(QMIDesenseCommandDriver*)::{lambda(void *)#1}::__invoke);
  __cxa_rethrow();
}

void sub_2169F6024(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<QMIDesenseCommandDriver *,std::shared_ptr<QMIDesenseCommandDriver> ctu::SharedSynchronizable<DesenseCommandDriver>::make_shared_ptr<QMIDesenseCommandDriver>(QMIDesenseCommandDriver*)::{lambda(QMIDesenseCommandDriver *)#1},std::allocator<QMIDesenseCommandDriver>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void std::__shared_ptr_pointer<QMIDesenseCommandDriver *,std::shared_ptr<QMIDesenseCommandDriver> ctu::SharedSynchronizable<DesenseCommandDriver>::make_shared_ptr<QMIDesenseCommandDriver>(QMIDesenseCommandDriver*)::{lambda(QMIDesenseCommandDriver *)#1},std::allocator<QMIDesenseCommandDriver>>::__on_zero_shared(uint64_t a1)
{
  dispatch_barrier_async_f(*(dispatch_queue_t *)(*(_QWORD *)(a1 + 24) + 24), *(void **)(a1 + 24), (dispatch_function_t)std::shared_ptr<QMIDesenseCommandDriver> ctu::SharedSynchronizable<DesenseCommandDriver>::make_shared_ptr<QMIDesenseCommandDriver>(QMIDesenseCommandDriver*)::{lambda(QMIDesenseCommandDriver*)#1}::operator() const(QMIDesenseCommandDriver*)::{lambda(void *)#1}::__invoke);
}

uint64_t std::__shared_ptr_pointer<QMIDesenseCommandDriver *,std::shared_ptr<QMIDesenseCommandDriver> ctu::SharedSynchronizable<DesenseCommandDriver>::make_shared_ptr<QMIDesenseCommandDriver>(QMIDesenseCommandDriver*)::{lambda(QMIDesenseCommandDriver *)#1},std::allocator<QMIDesenseCommandDriver>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t std::shared_ptr<QMIDesenseCommandDriver> ctu::SharedSynchronizable<DesenseCommandDriver>::make_shared_ptr<QMIDesenseCommandDriver>(QMIDesenseCommandDriver*)::{lambda(QMIDesenseCommandDriver*)#1}::operator() const(QMIDesenseCommandDriver*)::{lambda(void *)#1}::__invoke(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t *_ZZN8dispatch5asyncIZNK3ctu20SharedSynchronizableI20DesenseCommandDriverE15execute_wrappedIZZN23QMIDesenseCommandDriver9bootstrapENSt3__110shared_ptrI37DesenseCommandDriverDelegateInterfaceEEN3xpc8endpointENS_13group_sessionEEUb_E3__0EEvOT_EUlvE_EEvP16dispatch_queue_sNS7_10unique_ptrISF_NS7_14default_deleteISF_EEEEENUlPvE_8__invokeESO_(uint64_t *a1)
{
  uint64_t v1;
  QMIDesenseCommandDriver *v2;
  uint64_t *v4;
  uint64_t v5;
  _BYTE v6[24];

  v1 = *a1;
  v4 = a1;
  v5 = v1;
  v2 = *(QMIDesenseCommandDriver **)v1;
  nas::SetFreqReportMode::RespInd::RespInd((qmi::MessageBase *)v6, (_QWORD *)(v1 + 8));
  QMIDesenseCommandDriver::processFrequencyInd_sync(v2, (const nas::SetFreqReportMode::RespInd *)v6);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v6);
  _ZNSt3__110unique_ptrIZZN19QMIAQMCommandDriver9bootstrapEN8dispatch13group_sessionEN3xpc10connectionENS_10shared_ptrI33AQMCommandDriverDelegateInterfaceEEEUb_E3__0NS_14default_deleteIS9_EEED1B8ne180100Ev(&v5);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v4);
}

void sub_2169F6120(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3;
  va_list va;
  uint64_t v5;
  va_list va1;
  va_list va2;

  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v5 = va_arg(va2, _QWORD);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va2);
  _ZNSt3__110unique_ptrIZZN19QMIAQMCommandDriver9bootstrapEN8dispatch13group_sessionEN3xpc10connectionENS_10shared_ptrI33AQMCommandDriverDelegateInterfaceEEEUb_E3__0NS_14default_deleteIS9_EEED1B8ne180100Ev((uint64_t *)va1);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void ___ZN16QMIVirtualClient26registerUnsolicitedHandlerIN3nas17SetFreqReportMode10IndicationEEEvU13block_pointerFvRKT_E_block_invoke(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;
  _BYTE v3[24];

  v2 = *(_QWORD *)(a1 + 32);
  qmi::Indication<(unsigned short)21851,nas::SetFreqReportMode::RespIndTLVList>::Indication((qmi::MessageBase *)v3, a2);
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_2169F6190(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<DesenseCommandDriver>::execute_wrapped<QMIDesenseCommandDriver::registered(std::shared_ptr<QMIVirtualClient>)::$_0>(QMIDesenseCommandDriver::registered(std::shared_ptr<QMIVirtualClient>)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIDesenseCommandDriver::registered(std::shared_ptr<QMIVirtualClient>)::$_0,std::default_delete<QMIDesenseCommandDriver::registered(std::shared_ptr<QMIVirtualClient>)::$_0>>)::{lambda(void *)#1}::__invoke(uint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t *v4;
  uint64_t v5;

  v1 = *a1;
  v4 = a1;
  v5 = v1;
  v2 = *(_QWORD *)(v1 + 16);
  QMIVirtualClient::disableNasServingSystemIndications(*(QMIVirtualClient **)v1, (const ctu::OsLogLogger *)(v2 + 40));
  (*(void (**)(_QWORD, uint64_t, uint64_t))(**(_QWORD **)(v2 + 72) + 16))(*(_QWORD *)(v2 + 72), 1, 1);
  std::unique_ptr<QMIPreferredNetworksCommandDriver::registered(std::shared_ptr<QMIVirtualClient>)::$_0,std::default_delete<QMIPreferredNetworksCommandDriver::registered(std::shared_ptr<QMIVirtualClient>)::$_0>>::~unique_ptr[abi:ne180100](&v5);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v4);
}

void sub_2169F6204(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  std::unique_ptr<QMIPreferredNetworksCommandDriver::registered(std::shared_ptr<QMIVirtualClient>)::$_0,std::default_delete<QMIPreferredNetworksCommandDriver::registered(std::shared_ptr<QMIVirtualClient>)::$_0>>::~unique_ptr[abi:ne180100](&a10);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<DesenseCommandDriver>::execute_wrapped<QMIDesenseCommandDriver::deregistered(std::shared_ptr<QMIVirtualClient>)::$_0>(QMIDesenseCommandDriver::deregistered(std::shared_ptr<QMIVirtualClient>)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIDesenseCommandDriver::deregistered(std::shared_ptr<QMIVirtualClient>)::$_0,std::default_delete<QMIDesenseCommandDriver::deregistered(std::shared_ptr<QMIVirtualClient>)::$_0>>)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;

  v3 = a1;
  v1 = *(_QWORD *)a1;
  (*(void (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(**(_QWORD **)a1 + 72) + 16))(*(_QWORD *)(**(_QWORD **)a1 + 72), 1, 0);
  MEMORY[0x2199FEAC4](v1, 0x20C4093837F09);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v3);
}

void sub_2169F6284(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  va_list va;

  va_start(va, a2);
  MEMORY[0x2199FEAC4](v2, 0x20C4093837F09);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void ___ZN16QMIVirtualClient4sendIN3nas18IndicationRegister7RequestE20DesenseCommandDriverZN23QMIDesenseCommandDriver26registerFrequencyReportingEN10subscriber7SimSlotEE3__0EENSt3__19enable_ifIXntsr3std26is_member_function_pointerIT1_EE5valueEvE4typeERKT_NS9_8weak_ptrIT0_EESB__block_invoke(_QWORD *a1, uint64_t a2)
{
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  _QWORD *v7;
  int v8;
  NSObject *v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  std::__shared_weak_count *v12;
  std::__shared_weak_count *v13;
  _QWORD *v14;
  NSObject *v15;
  unint64_t *v16;
  unint64_t v17;
  _QWORD *v18;
  unint64_t v19;
  unint64_t *p_shared_owners;
  unint64_t v21;
  std::__shared_weak_count *v22;
  uint64_t v23;
  uint8_t buf[8];
  __int16 v25;
  uint64_t v26;
  uint64_t v27;

  v27 = *MEMORY[0x24BDAC8D0];
  v3 = (std::__shared_weak_count *)a1[5];
  if (v3)
  {
    v5 = std::__shared_weak_count::lock(v3);
    v22 = v5;
    if (v5)
    {
      v6 = v5;
      if (!a1[4])
      {
LABEL_16:
        p_shared_owners = (unint64_t *)&v6->__shared_owners_;
        do
          v21 = __ldaxr(p_shared_owners);
        while (__stlxr(v21 - 1, p_shared_owners));
        if (!v21)
        {
          ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
          std::__shared_weak_count::__release_weak(v6);
        }
        return;
      }
      v7 = (_QWORD *)a1[6];
      v8 = *(_DWORD *)(a2 + 4);
      if (v8)
      {
        v9 = v7[5];
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 67109378;
          *(_DWORD *)&buf[4] = v8;
          v25 = 2080;
          v26 = qmi::asString();
          _os_log_impl(&dword_216897000, v9, OS_LOG_TYPE_DEFAULT, "#N Could not register with stop report: 0x%x (%s)", buf, 0x12u);
        }
        goto LABEL_16;
      }
      v10 = (std::__shared_weak_count *)v7[2];
      if (!v10 || (v11 = v7[1], (v12 = std::__shared_weak_count::lock(v10)) == 0))
        std::__throw_bad_weak_ptr[abi:ne180100]();
      v13 = v12;
      v14 = (_QWORD *)operator new();
      *v14 = v7;
      v15 = v7[3];
      v16 = (unint64_t *)&v13->__shared_owners_;
      do
        v17 = __ldxr(v16);
      while (__stxr(v17 + 1, v16));
      v18 = (_QWORD *)operator new();
      *v18 = v14;
      v18[1] = v11;
      v18[2] = v13;
      v23 = 0;
      *(_QWORD *)buf = 0;
      dispatch_async_f(v15, v18, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<DesenseCommandDriver>::execute_wrapped<QMIDesenseCommandDriver::registerFrequencyReporting(subscriber::SimSlot)::$_0::operator() const(qmi::ResponseBase const&)::{lambda(void)#1}>(QMIDesenseCommandDriver::registerFrequencyReporting(subscriber::SimSlot)::$_0::operator() const(qmi::ResponseBase const&)::{lambda(void)#1} &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIDesenseCommandDriver::registerFrequencyReporting(subscriber::SimSlot)::$_0::operator() const(qmi::ResponseBase const&)::{lambda(void)#1},dispatch_queue_s *::default_delete<QMIDesenseCommandDriver::registerFrequencyReporting(subscriber::SimSlot)::$_0::operator() const(qmi::ResponseBase const&)::{lambda(void)#1}>>)::{lambda(void *)#1}::__invoke);
      std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v23);
      std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)buf);
      do
        v19 = __ldaxr(v16);
      while (__stlxr(v19 - 1, v16));
      if (!v19)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
      v6 = v22;
      if (v22)
        goto LABEL_16;
    }
  }
}

void sub_2169F64A8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_32c45_ZTSNSt3__18weak_ptrI20DesenseCommandDriverEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 16);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void __destroy_helper_block_e8_32c45_ZTSNSt3__18weak_ptrI20DesenseCommandDriverEE(uint64_t a1)
{
  std::__shared_weak_count *v1;

  v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1)
    std::__shared_weak_count::__release_weak(v1);
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<DesenseCommandDriver>::execute_wrapped<QMIDesenseCommandDriver::registerFrequencyReporting(subscriber::SimSlot)::$_0::operator() const(qmi::ResponseBase const&)::{lambda(void)#1}>(QMIDesenseCommandDriver::registerFrequencyReporting(subscriber::SimSlot)::$_0::operator() const(qmi::ResponseBase const&)::{lambda(void)#1} &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIDesenseCommandDriver::registerFrequencyReporting(subscriber::SimSlot)::$_0::operator() const(qmi::ResponseBase const&)::{lambda(void)#1},dispatch_queue_s *::default_delete<QMIDesenseCommandDriver::registerFrequencyReporting(subscriber::SimSlot)::$_0::operator() const(qmi::ResponseBase const&)::{lambda(void)#1}>>)::{lambda(void *)#1}::__invoke(_QWORD **a1)
{
  _QWORD *v1;
  _QWORD **v3;

  v3 = a1;
  v1 = *a1;
  (*(void (**)(_QWORD, uint64_t, uint64_t))(*(_QWORD *)**a1 + 24))(**a1, 1, 1);
  MEMORY[0x2199FEAC4](v1, 0x20C4093837F09);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v3);
}

void sub_2169F6568(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  va_list va;

  va_start(va, a2);
  MEMORY[0x2199FEAC4](v2, 0x20C4093837F09);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void ___ZN16QMIVirtualClient4sendIN3nas17SetFreqReportMode7RequestE20DesenseCommandDriverZN23QMIDesenseCommandDriver25setFrequencyReportingModeEN10subscriber7SimSlotE22FrequencyReportingModeE3__0EENSt3__19enable_ifIXntsr3std26is_member_function_pointerIT1_EE5valueEvE4typeERKT_NSA_8weak_ptrIT0_EESC__block_invoke(_QWORD *a1, uint64_t *a2)
{
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  _QWORD *v7;
  int v8;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  uint64_t v16;
  std::__shared_weak_count *v17;
  std::__shared_weak_count *v18;
  _QWORD *v19;
  unint64_t *v20;
  unint64_t v21;
  NSObject *v22;
  unint64_t *v23;
  unint64_t v24;
  _QWORD *v25;
  unint64_t v26;
  unint64_t *p_shared_owners;
  unint64_t v28;
  std::__shared_weak_count *v29;
  uint64_t v30;
  uint64_t v31;
  uint8_t buf[8];
  __int128 v33;
  uint64_t v34;
  uint64_t v35;

  v35 = *MEMORY[0x24BDAC8D0];
  v3 = (std::__shared_weak_count *)a1[5];
  if (v3)
  {
    v5 = std::__shared_weak_count::lock(v3);
    v29 = v5;
    if (v5)
    {
      v6 = v5;
      if (!a1[4])
      {
LABEL_22:
        p_shared_owners = (unint64_t *)&v6->__shared_owners_;
        do
          v28 = __ldaxr(p_shared_owners);
        while (__stlxr(v28 - 1, p_shared_owners));
        if (!v28)
        {
          ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
          std::__shared_weak_count::__release_weak(v6);
        }
        return;
      }
      v7 = (_QWORD *)a1[6];
      v8 = *((_DWORD *)a2 + 1);
      if (v8)
      {
        v9 = v7[5];
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 67109378;
          *(_DWORD *)&buf[4] = v8;
          LOWORD(v33) = 2080;
          *(_QWORD *)((char *)&v33 + 2) = qmi::asString();
          _os_log_impl(&dword_216897000, v9, OS_LOG_TYPE_DEFAULT, "#N Could not set frequency reporting mode: 0x%x (%s)", buf, 0x12u);
        }
        goto LABEL_22;
      }
      v10 = *a2;
      v11 = a2[1];
      *(_QWORD *)buf = v7;
      *(_QWORD *)&v33 = v10;
      v12 = a2[2];
      *((_QWORD *)&v33 + 1) = v11;
      v34 = v12;
      if (v12)
      {
        v13 = (unint64_t *)(v12 + 8);
        do
          v14 = __ldxr(v13);
        while (__stxr(v14 + 1, v13));
      }
      v15 = (std::__shared_weak_count *)v7[2];
      if (!v15 || (v16 = v7[1], (v17 = std::__shared_weak_count::lock(v15)) == 0))
        std::__throw_bad_weak_ptr[abi:ne180100]();
      v18 = v17;
      v19 = (_QWORD *)operator new();
      *v19 = v7;
      v19[1] = v10;
      v19[2] = v11;
      v19[3] = v12;
      if (v12)
      {
        v20 = (unint64_t *)(v12 + 8);
        do
          v21 = __ldxr(v20);
        while (__stxr(v21 + 1, v20));
      }
      v22 = v7[3];
      v23 = (unint64_t *)&v18->__shared_owners_;
      do
        v24 = __ldxr(v23);
      while (__stxr(v24 + 1, v23));
      v25 = (_QWORD *)operator new();
      *v25 = v19;
      v25[1] = v16;
      v25[2] = v18;
      v30 = 0;
      v31 = 0;
      dispatch_async_f(v22, v25, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<DesenseCommandDriver>::execute_wrapped<QMIDesenseCommandDriver::setFrequencyReportingMode(subscriber::SimSlot,FrequencyReportingMode)::$_0::operator() const(qmi::ResponseBase const&)::{lambda(void)#1}>(QMIDesenseCommandDriver::setFrequencyReportingMode(subscriber::SimSlot,FrequencyReportingMode)::$_0::operator() const(qmi::ResponseBase const&)::{lambda(void)#1} &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIDesenseCommandDriver::setFrequencyReportingMode(subscriber::SimSlot,FrequencyReportingMode)::$_0::operator() const(qmi::ResponseBase const&)::{lambda(void)#1},dispatch_queue_s *::default_delete<QMIDesenseCommandDriver::setFrequencyReportingMode(subscriber::SimSlot,FrequencyReportingMode)::$_0::operator() const(qmi::ResponseBase const&)::{lambda(void)#1}>>)::{lambda(void *)#1}::__invoke);
      std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v30);
      std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v31);
      do
        v26 = __ldaxr(v23);
      while (__stlxr(v26 - 1, v23));
      if (!v26)
      {
        ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
        std::__shared_weak_count::__release_weak(v18);
      }
      qmi::MessageBase::~MessageBase((qmi::MessageBase *)&v33);
      v6 = v29;
      if (v29)
        goto LABEL_22;
    }
  }
}

void sub_2169F67E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<DesenseCommandDriver>::execute_wrapped<QMIDesenseCommandDriver::setFrequencyReportingMode(subscriber::SimSlot,FrequencyReportingMode)::$_0::operator() const(qmi::ResponseBase const&)::{lambda(void)#1}>(QMIDesenseCommandDriver::setFrequencyReportingMode(subscriber::SimSlot,FrequencyReportingMode)::$_0::operator() const(qmi::ResponseBase const&)::{lambda(void)#1} &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIDesenseCommandDriver::setFrequencyReportingMode(subscriber::SimSlot,FrequencyReportingMode)::$_0::operator() const(qmi::ResponseBase const&)::{lambda(void)#1},dispatch_queue_s *::default_delete<QMIDesenseCommandDriver::setFrequencyReportingMode(subscriber::SimSlot,FrequencyReportingMode)::$_0::operator() const(qmi::ResponseBase const&)::{lambda(void)#1}>>)::{lambda(void *)#1}::__invoke(QMIDesenseCommandDriver ***a1)
{
  QMIDesenseCommandDriver **v1;
  QMIDesenseCommandDriver *v2;
  QMIDesenseCommandDriver ***v4;
  QMIDesenseCommandDriver **v5;
  _BYTE v6[24];

  v1 = *a1;
  v4 = a1;
  v5 = v1;
  v2 = *v1;
  nas::SetFreqReportMode::RespInd::RespInd((nas::SetFreqReportMode::RespInd *)v6, (const qmi::ResponseBase *)(v1 + 1));
  QMIDesenseCommandDriver::processFrequencyInd_sync(v2, (const nas::SetFreqReportMode::RespInd *)v6);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v6);
  _ZNSt3__110unique_ptrIZZN19QMIAQMCommandDriver9bootstrapEN8dispatch13group_sessionEN3xpc10connectionENS_10shared_ptrI33AQMCommandDriverDelegateInterfaceEEEUb_E3__0NS_14default_deleteIS9_EEED1B8ne180100Ev((uint64_t *)&v5);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v4);
}

void sub_2169F686C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3;
  va_list va;
  uint64_t v5;
  va_list va1;
  va_list va2;

  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v5 = va_arg(va2, _QWORD);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va2);
  _ZNSt3__110unique_ptrIZZN19QMIAQMCommandDriver9bootstrapEN8dispatch13group_sessionEN3xpc10connectionENS_10shared_ptrI33AQMCommandDriverDelegateInterfaceEEEUb_E3__0NS_14default_deleteIS9_EEED1B8ne180100Ev((uint64_t *)va1);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *QMIClientPool::create@<X0>(_QWORD *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v4;

  *a2 = 0;
  a2[1] = 0;
  v4 = operator new();
  QMIClientPool::QMIClientPool(v4, a1);
  return std::shared_ptr<QMIClientPool>::shared_ptr[abi:ne180100]<QMIClientPool,void>(a2, v4);
}

void sub_2169F68F8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199FEAC4](v1, 0x10E1C40E9888AC1);
  _Unwind_Resume(a1);
}

uint64_t QMIClientPool::QMIClientPool(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  NSObject *v7;
  _BYTE v9[16];
  _BYTE v10[8];

  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)v9, (const char *)*MEMORY[0x24BDC3E90], "qmi.pool");
  ctu::OsLogLogger::OsLogLogger();
  ctu::OsLogLogger::OsLogLogger();
  MEMORY[0x2199FDF6C](v10);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v9);
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)a1 = &off_24D5DDDB0;
  *(_QWORD *)(a1 + 32) = *a2;
  v4 = a2[1];
  *(_QWORD *)(a1 + 40) = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  v7 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_UTILITY, 0);
  *(_QWORD *)(a1 + 48) = dispatch_queue_create("QMIClientPool.QMIClient.Callback", v7);
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 80) = 0;
  return a1;
}

void QMIClientPool::~QMIClientPool(QMIClientPool *this)
{
  void **v2;
  void **v3;
  void **v4;
  NSObject *v5;
  std::__shared_weak_count *v6;

  *(_QWORD *)this = &off_24D5DDDB0;
  v2 = (void **)*((_QWORD *)this + 7);
  if (v2)
  {
    v3 = (void **)*((_QWORD *)this + 8);
    v4 = v2;
    if (v3 != v2)
    {
      do
        QMIClientPool::QMIClientInfo::~QMIClientInfo(v3 - 9);
      while (v3 != v2);
      v4 = (void **)*((_QWORD *)this + 7);
    }
    *((_QWORD *)this + 8) = v2;
    operator delete(v4);
  }
  v5 = *((_QWORD *)this + 6);
  if (v5)
    dispatch_release(v5);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)this + 32);
  v6 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (v6)
    std::__shared_weak_count::__release_weak(v6);
  MEMORY[0x2199FDF6C]((char *)this + 8);
}

{
  QMIClientPool::~QMIClientPool(this);
  JUMPOUT(0x2199FEAC4);
}

uint64_t QMIClientPool::requestClient@<X0>(_QWORD *a1@<X0>, unsigned __int8 a2@<W1>, uint64_t *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, _QWORD *a6@<X8>)
{
  uint64_t v10;
  void **v11;
  std::string *v12;
  std::string::size_type size;
  std::string *v14;
  std::string *v15;
  std::string *v16;
  std::string::size_type v17;
  std::string::size_type v18;
  std::string::size_type v19;
  unint64_t *v20;
  unint64_t v21;
  std::__shared_weak_count *v22;
  __int128 *v23;
  __int128 *v24;
  __int128 *v25;
  uint64_t v26;
  __int128 *v28;
  uint64_t v29;
  __int128 v30;
  std::__shared_weak_count *v31;
  std::__shared_weak_count *v32;
  int SvcType;
  int v34;
  const char *v35;
  size_t v36;
  NSObject *v37;
  uint64_t v38;
  uint64_t *v39;
  std::string *v40;
  NSObject *v41;
  std::string *v42;
  NSObject *v43;
  std::__shared_weak_count *v44;
  unint64_t *v45;
  unint64_t v46;
  NSObject *v47;
  std::__shared_weak_count *v48;
  uint64_t v49;
  std::__shared_weak_count *v50;
  __int128 v51;
  std::__shared_weak_count *v52;
  unint64_t *p_shared_owners;
  unint64_t v54;
  std::__shared_weak_count *v55;
  unint64_t *v56;
  unint64_t v57;
  unint64_t *v58;
  unint64_t v59;
  std::__shared_weak_count *v60;
  uint64_t v61;
  unint64_t *v62;
  unint64_t v63;
  unint64_t v64;
  _QWORD *v65;
  _QWORD *v66;
  uint64_t v67;
  uint64_t v68;
  unint64_t v69;
  uint64_t v70;
  unint64_t v71;
  char *v72;
  uint64_t v73;
  char *v74;
  _QWORD *v75;
  _QWORD *v76;
  __int128 v77;
  int64x2_t v78;
  uint64_t v79;
  NSObject *v80;
  unint64_t *v81;
  unint64_t v82;
  std::__shared_weak_count *v83;
  unint64_t *v84;
  unint64_t v85;
  uint64_t v87;
  dispatch_object_t object;
  std::string v89;
  _QWORD v90[5];
  std::__shared_weak_count *v91;
  __int128 v92;
  _QWORD v93[2];
  uint64_t v94;
  unsigned __int8 v95;
  __int128 block;
  __int128 v97;
  _QWORD *v98;
  _BYTE *v99;
  _BYTE buf[40];
  uint64_t *v101;
  uint64_t v102;
  uint64_t v103;

  v103 = *MEMORY[0x24BDAC8D0];
  v95 = a2;
  v93[1] = 1;
  v94 = a4;
  v93[0] = a1 + 10;
  MEMORY[0x2199FDF3C]();
  v92 = 0uLL;
  v10 = a1[7];
  v11 = (void **)a1[8];
  if ((void **)v10 == v11)
    goto LABEL_57;
  v12 = (std::string *)a1[7];
  while (1)
  {
    size = v12->__r_.__value_.__l.__size_;
    if (!size || *(_QWORD *)(size + 8) == -1)
      break;
    v12 += 3;
    if (v12 == (std::string *)v11)
      goto LABEL_28;
  }
  if (v12 == (std::string *)v11 || (v14 = v12 + 3, &v12[3] == (std::string *)v11))
  {
    v15 = v12;
  }
  else
  {
    v15 = v12;
    do
    {
      v16 = v12;
      v12 = v14;
      v17 = v14->__r_.__value_.__l.__size_;
      if (v17 && *(_QWORD *)(v17 + 8) != -1)
      {
        v18 = v12->__r_.__value_.__r.__words[0];
        v19 = v16[3].__r_.__value_.__l.__size_;
        if (v19)
        {
          v20 = (unint64_t *)(v19 + 16);
          do
            v21 = __ldxr(v20);
          while (__stxr(v21 + 1, v20));
        }
        v22 = (std::__shared_weak_count *)v15->__r_.__value_.__l.__size_;
        v15->__r_.__value_.__r.__words[0] = v18;
        v15->__r_.__value_.__l.__size_ = v19;
        if (v22)
          std::__shared_weak_count::__release_weak(v22);
        v15->__r_.__value_.__s.__data_[16] = v16[3].__r_.__value_.__s.__data_[16];
        std::string::operator=(v15 + 1, v16 + 4);
        if (v15 != v12)
          std::vector<std::weak_ptr<QMIVirtualClient>>::__assign_with_size[abi:ne180100]<std::weak_ptr<QMIVirtualClient>*,std::weak_ptr<QMIVirtualClient>*>((uint64_t *)&v15[2], (uint64_t *)v16[5].__r_.__value_.__l.__data_, (uint64_t *)v16[5].__r_.__value_.__l.__size_, (uint64_t)(v16[5].__r_.__value_.__l.__size_ - v16[5].__r_.__value_.__r.__words[0]) >> 4);
        v15 += 3;
      }
      v14 = v12 + 3;
    }
    while (&v12[3] != (std::string *)v11);
    v10 = a1[7];
    v11 = (void **)a1[8];
  }
  if (v15 == (std::string *)v11)
  {
LABEL_28:
    v15 = (std::string *)v11;
    goto LABEL_29;
  }
  while (v11 != (void **)v15)
  {
    v11 -= 9;
    QMIClientPool::QMIClientInfo::~QMIClientInfo(v11);
  }
  a1[8] = v15;
  v10 = a1[7];
LABEL_29:
  if ((std::string *)v10 == v15)
  {
LABEL_57:
    memset(&v89, 0, sizeof(v89));
    std::string::basic_string[abi:ne180100]<0>(&v89, "QMIClientPool: ");
    v34 = v95;
    v35 = (const char *)qmi::asShortString();
    v36 = strlen(v35);
    std::string::append(&v89, v35, v36);
    v37 = a1[1];
    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
    {
      v38 = qmi::asShortString();
      v39 = a3;
      if (*((char *)a3 + 23) < 0)
        v39 = (uint64_t *)*a3;
      v40 = &v89;
      if ((v89.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v40 = (std::string *)v89.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = v38;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v34;
      *(_WORD *)&buf[18] = 2082;
      *(_QWORD *)&buf[20] = v39;
      *(_WORD *)&buf[28] = 2082;
      *(_QWORD *)&buf[30] = v40;
      _os_log_impl(&dword_216897000, v37, OS_LOG_TYPE_DEFAULT, "#I Create QMI client of type=%s(%d) for service=%{public}s, clientName='%{public}s'", buf, 0x26u);
    }
    v41 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_UTILITY, 0);
    if ((v89.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v42 = &v89;
    else
      v42 = (std::string *)v89.__r_.__value_.__r.__words[0];
    v43 = dispatch_queue_create((const char *)v42, v41);
    object = v43;
    *(_QWORD *)buf = a1;
    *(_QWORD *)&buf[8] = &object;
    *(_QWORD *)&buf[16] = &v89;
    *(_QWORD *)&buf[24] = &v95;
    *(_QWORD *)&buf[32] = a3;
    v101 = &v94;
    v102 = a5;
    *a6 = 0;
    a6[1] = 0;
    *(_QWORD *)&block = MEMORY[0x24BDAC760];
    *((_QWORD *)&block + 1) = 0x40000000;
    *(_QWORD *)&v97 = ___ZN8dispatch9sync_implIZN13QMIClientPool13requestClientEN3qmi11ServiceTypeENSt3__112basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEEP24QMIVirtualClientCallbackN3xpc10connectionEE3__0EENS4_5decayIDTclfp0_EEE4typeEP16dispatch_queue_sOT_NS4_17integral_constantIbLb0EEE_block_invoke;
    *((_QWORD *)&v97 + 1) = &__block_descriptor_tmp_23_8;
    v98 = a6;
    v99 = buf;
    dispatch_sync(v43, &block);
    if (object)
      dispatch_release(object);
    if (SHIBYTE(v89.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v89.__r_.__value_.__l.__data_);
    v44 = (std::__shared_weak_count *)*((_QWORD *)&v92 + 1);
    if (*((_QWORD *)&v92 + 1))
    {
      v45 = (unint64_t *)(*((_QWORD *)&v92 + 1) + 8);
      do
        v46 = __ldaxr(v45);
      while (__stlxr(v46 - 1, v45));
      if (!v46)
      {
        ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
        std::__shared_weak_count::__release_weak(v44);
      }
    }
    return std::unique_lock<ctu::UnfairLock>::~unique_lock[abi:ne180100]((uint64_t)v93);
  }
  while (1)
  {
    v23 = *(__int128 **)(v10 + 48);
    v24 = *(__int128 **)(v10 + 56);
    if (v23 != v24)
    {
      v25 = v23 + 1;
      while (1)
      {
        v26 = *((_QWORD *)v25 - 1);
        if (!v26 || *(_QWORD *)(v26 + 8) == -1)
          break;
        if (v25++ == v24)
          goto LABEL_53;
      }
      v28 = v25 - 1;
      if (v25 - 1 != v24 && v25 != v24)
      {
        do
        {
          v29 = *((_QWORD *)v25 + 1);
          if (v29 && *(_QWORD *)(v29 + 8) != -1)
          {
            v30 = *v25;
            *(_QWORD *)v25 = 0;
            *((_QWORD *)v25 + 1) = 0;
            v31 = (std::__shared_weak_count *)*((_QWORD *)v28 + 1);
            *v28 = v30;
            if (v31)
              std::__shared_weak_count::__release_weak(v31);
            ++v28;
          }
          ++v25;
        }
        while (v25 != v24);
        v24 = *(__int128 **)(v10 + 56);
      }
      if (v28 != v24)
      {
        while (v24 != v28)
        {
          v32 = (std::__shared_weak_count *)*((_QWORD *)v24 - 1);
          if (v32)
            std::__shared_weak_count::__release_weak(v32);
          --v24;
        }
        *(_QWORD *)(v10 + 56) = v28;
      }
    }
LABEL_53:
    block = 0u;
    v97 = 0u;
    qmi::Client::Client();
    if (!(_QWORD)v97)
      goto LABEL_56;
    SvcType = qmi::Client::getSvcType((qmi::Client *)&block);
    if (SvcType == v95)
      break;
    qmi::Client::release((qmi::Client *)&block);
LABEL_56:
    qmi::Client::~Client((qmi::Client *)&block);
    v10 += 72;
    if (v10 == a1[8])
      goto LABEL_57;
  }
  v47 = a1[1];
  if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a3 + 23) < 0)
      a3 = (uint64_t *)*a3;
    *(_DWORD *)buf = 67109378;
    *(_DWORD *)&buf[4] = SvcType;
    *(_WORD *)&buf[8] = 2082;
    *(_QWORD *)&buf[10] = a3;
    _os_log_impl(&dword_216897000, v47, OS_LOG_TYPE_DEFAULT, "#I Reuse existing QMI client of type=%d for service=%{public}s", buf, 0x12u);
  }
  v49 = a1[2];
  v48 = (std::__shared_weak_count *)a1[3];
  v89.__r_.__value_.__r.__words[0] = v49;
  if (!v48
    || (v50 = std::__shared_weak_count::lock(v48), (v89.__r_.__value_.__l.__size_ = (std::string::size_type)v50) == 0))
  {
    std::__throw_bad_weak_ptr[abi:ne180100]();
  }
  std::allocate_shared[abi:ne180100]<QMIVirtualClient,std::allocator<QMIVirtualClient>,std::shared_ptr<QMIClientPool>,qmi::Client &,QMIVirtualClientCallback *&,void>(buf, v49, v50, (uint64_t)&block, &v94);
  v51 = *(_OWORD *)buf;
  *(_QWORD *)buf = 0;
  *(_QWORD *)&buf[8] = 0;
  v52 = (std::__shared_weak_count *)*((_QWORD *)&v92 + 1);
  v92 = v51;
  if (v52)
  {
    p_shared_owners = (unint64_t *)&v52->__shared_owners_;
    do
      v54 = __ldaxr(p_shared_owners);
    while (__stlxr(v54 - 1, p_shared_owners));
    if (!v54)
    {
      ((void (*)(std::__shared_weak_count *))v52->__on_zero_shared)(v52);
      std::__shared_weak_count::__release_weak(v52);
    }
  }
  v55 = *(std::__shared_weak_count **)&buf[8];
  if (*(_QWORD *)&buf[8])
  {
    v56 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
    do
      v57 = __ldaxr(v56);
    while (__stlxr(v57 - 1, v56));
    if (!v57)
    {
      ((void (*)(std::__shared_weak_count *))v55->__on_zero_shared)(v55);
      std::__shared_weak_count::__release_weak(v55);
    }
  }
  if (v89.__r_.__value_.__l.__size_)
  {
    v58 = (unint64_t *)(v89.__r_.__value_.__l.__size_ + 8);
    do
      v59 = __ldaxr(v58);
    while (__stlxr(v59 - 1, v58));
    if (!v59)
    {
      (*(void (**)(std::string::size_type))(*(_QWORD *)v89.__r_.__value_.__l.__size_ + 16))(v89.__r_.__value_.__l.__size_);
      std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v89.__r_.__value_.__l.__size_);
    }
  }
  v60 = (std::__shared_weak_count *)*((_QWORD *)&v92 + 1);
  v61 = v92;
  if (*((_QWORD *)&v92 + 1))
  {
    v62 = (unint64_t *)(*((_QWORD *)&v92 + 1) + 16);
    do
      v63 = __ldxr(v62);
    while (__stxr(v63 + 1, v62));
  }
  v64 = *(_QWORD *)(v10 + 64);
  v65 = *(_QWORD **)(v10 + 56);
  if ((unint64_t)v65 >= v64)
  {
    v87 = v92;
    v67 = *(_QWORD *)(v10 + 48);
    v68 = ((uint64_t)v65 - v67) >> 4;
    v69 = v68 + 1;
    if ((unint64_t)(v68 + 1) >> 60)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v70 = v64 - v67;
    if (v70 >> 3 > v69)
      v69 = v70 >> 3;
    if ((unint64_t)v70 >= 0x7FFFFFFFFFFFFFF0)
      v71 = 0xFFFFFFFFFFFFFFFLL;
    else
      v71 = v69;
    *(_QWORD *)&buf[32] = v10 + 64;
    v72 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::weak_ptr<QMIVirtualClient>>>(v71);
    v74 = &v72[16 * v68];
    *(_OWORD *)v74 = v92;
    v66 = v74 + 16;
    v76 = *(_QWORD **)(v10 + 48);
    v75 = *(_QWORD **)(v10 + 56);
    if (v75 == v76)
    {
      v78 = vdupq_n_s64((unint64_t)v75);
    }
    else
    {
      do
      {
        v77 = *((_OWORD *)v75 - 1);
        v75 -= 2;
        *((_OWORD *)v74 - 1) = v77;
        v74 -= 16;
        *v75 = 0;
        v75[1] = 0;
      }
      while (v75 != v76);
      v78 = *(int64x2_t *)(v10 + 48);
    }
    *(_QWORD *)(v10 + 48) = v74;
    *(_QWORD *)(v10 + 56) = v66;
    *(int64x2_t *)&buf[8] = v78;
    v79 = *(_QWORD *)(v10 + 64);
    *(_QWORD *)(v10 + 64) = &v72[16 * v73];
    *(_QWORD *)&buf[24] = v79;
    *(_QWORD *)buf = v78.i64[0];
    std::__split_buffer<std::weak_ptr<QMIVirtualClient>>::~__split_buffer((uint64_t)buf);
    v61 = v87;
  }
  else
  {
    *v65 = v92;
    v65[1] = v60;
    v66 = v65 + 2;
    *(_QWORD *)(v10 + 56) = v65 + 2;
  }
  *(_QWORD *)(v10 + 56) = v66;
  if (*(_BYTE *)(v10 + 16))
  {
    v80 = a1[6];
    v90[0] = MEMORY[0x24BDAC760];
    v90[1] = 1174405120;
    v90[2] = ___ZN13QMIClientPool13requestClientEN3qmi11ServiceTypeENSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEP24QMIVirtualClientCallbackN3xpc10connectionE_block_invoke;
    v90[3] = &__block_descriptor_tmp_33;
    v90[4] = v61;
    v91 = v60;
    if (v60)
    {
      v81 = (unint64_t *)&v60->__shared_owners_;
      do
        v82 = __ldxr(v81);
      while (__stxr(v82 + 1, v81));
    }
    dispatch_async(v80, v90);
    v83 = v91;
    if (v91)
    {
      v84 = (unint64_t *)&v91->__shared_owners_;
      do
        v85 = __ldaxr(v84);
      while (__stlxr(v85 - 1, v84));
      if (!v85)
      {
        ((void (*)(std::__shared_weak_count *))v83->__on_zero_shared)(v83);
        std::__shared_weak_count::__release_weak(v83);
      }
    }
  }
  *(_OWORD *)a6 = v92;
  qmi::Client::~Client((qmi::Client *)&block);
  return std::unique_lock<ctu::UnfairLock>::~unique_lock[abi:ne180100]((uint64_t)v93);
}

void sub_2169F72FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
  std::__shared_weak_count *v30;

  if (v30)
    std::__shared_weak_count::__release_weak(v30);
  qmi::Client::~Client((qmi::Client *)&a30);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a24);
  std::unique_lock<ctu::UnfairLock>::~unique_lock[abi:ne180100]((uint64_t)&a26);
  _Unwind_Resume(a1);
}

void ___ZN13QMIClientPool13requestClientEN3qmi11ServiceTypeENSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEP24QMIVirtualClientCallbackN3xpc10connectionE_block_invoke(uint64_t a1)
{
  uint64_t v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  uint64_t v8[2];

  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(std::__shared_weak_count **)(a1 + 40);
  v8[0] = v2;
  v8[1] = (uint64_t)v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  QMIVirtualClient::dispatchRegistered(v2, v8);
  if (v3)
  {
    v6 = (unint64_t *)&v3->__shared_owners_;
    do
      v7 = __ldaxr(v6);
    while (__stlxr(v7 - 1, v6));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void sub_2169F7408(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t QMIVirtualClient::dispatchRegistered(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  uint64_t v12;
  std::__shared_weak_count *v13;
  _QWORD v14[2];

  v14[0] = a1 + 88;
  v14[1] = 1;
  MEMORY[0x2199FDF3C]();
  if (*(_BYTE *)(a1 + 74))
  {
    if (!*(_BYTE *)(a1 + 73))
    {
      v4 = *(_QWORD *)(a1 + 80);
      if (v4)
      {
        v5 = (std::__shared_weak_count *)a2[1];
        v12 = *a2;
        v13 = v5;
        if (v5)
        {
          p_shared_owners = (unint64_t *)&v5->__shared_owners_;
          do
            v7 = __ldxr(p_shared_owners);
          while (__stxr(v7 + 1, p_shared_owners));
        }
        (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v4 + 16))(v4, &v12);
        v8 = v13;
        if (v13)
        {
          v9 = (unint64_t *)&v13->__shared_owners_;
          do
            v10 = __ldaxr(v9);
          while (__stlxr(v10 - 1, v9));
          if (!v10)
          {
            ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
            std::__shared_weak_count::__release_weak(v8);
          }
        }
        *(_BYTE *)(a1 + 73) = 1;
      }
    }
  }
  return std::unique_lock<ctu::UnfairLock>::~unique_lock[abi:ne180100]((uint64_t)v14);
}

void sub_2169F74E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::unique_lock<ctu::UnfairLock>::~unique_lock[abi:ne180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_32c44_ZTSNSt3__110shared_ptrI16QMIVirtualClientEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c44_ZTSNSt3__110shared_ptrI16QMIVirtualClientEE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void ___ZN13QMIClientPool26createVirtualClientOnQueueEN8dispatch5queueERKNSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEN3qmi11ServiceTypeESA_P24QMIVirtualClientCallbackN3xpc10connectionE_block_invoke(_QWORD *a1)
{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  uint64_t QMIClientInfo;
  uint64_t *i;
  std::__shared_weak_count *v8;
  std::__shared_weak_count *v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  uint64_t v21[2];
  uint64_t v22;
  std::__shared_weak_count *v23;
  _BYTE v24[32];
  std::__shared_weak_count *v26;

  v2 = (std::__shared_weak_count *)a1[6];
  if (!v2)
    return;
  v3 = a1[4];
  v4 = std::__shared_weak_count::lock(v2);
  v26 = v4;
  if (!v4)
    return;
  if (!a1[5])
  {
    v18 = v4;
    goto LABEL_26;
  }
  v5 = v3 + 80;
  MEMORY[0x2199FDF3C](v3 + 80);
  qmi::Client::Client();
  QMIClientInfo = QMIClientPool::findQMIClientInfo(v3, (uint64_t)v24);
  qmi::Client::~Client((qmi::Client *)v24);
  if (*(_QWORD *)(v3 + 64) == QMIClientInfo)
    __TUAssertTrigger();
  for (i = *(uint64_t **)(QMIClientInfo + 48); i != *(uint64_t **)(QMIClientInfo + 56); i += 2)
  {
    v22 = 0;
    v23 = 0;
    v8 = (std::__shared_weak_count *)i[1];
    if (v8)
    {
      v9 = std::__shared_weak_count::lock(v8);
      v23 = v9;
      if (!v9)
        continue;
      v10 = v9;
      v11 = *i;
      v22 = v11;
      if (v11)
      {
        v21[0] = v11;
        v21[1] = (uint64_t)v10;
        p_shared_owners = (unint64_t *)&v10->__shared_owners_;
        do
          v13 = __ldxr(p_shared_owners);
        while (__stxr(v13 + 1, p_shared_owners));
        QMIVirtualClient::dispatchRegistered(v11, v21);
        do
          v14 = __ldaxr(p_shared_owners);
        while (__stlxr(v14 - 1, p_shared_owners));
        if (!v14)
        {
          ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
          std::__shared_weak_count::__release_weak(v10);
        }
      }
    }
    v15 = v23;
    if (v23)
    {
      v16 = (unint64_t *)&v23->__shared_owners_;
      do
        v17 = __ldaxr(v16);
      while (__stlxr(v17 - 1, v16));
      if (!v17)
      {
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v15);
      }
    }
  }
  *(_BYTE *)(QMIClientInfo + 16) = 1;
  MEMORY[0x2199FDF48](v5);
  v18 = v26;
  if (!v26)
    return;
LABEL_26:
  v19 = (unint64_t *)&v18->__shared_owners_;
  do
    v20 = __ldaxr(v19);
  while (__stlxr(v20 - 1, v19));
  if (!v20)
  {
    ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
    std::__shared_weak_count::__release_weak(v18);
  }
}

void sub_2169F76E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t QMIClientPool::findQMIClientInfo(uint64_t a1, uint64_t a2)
{
  uint64_t i;
  uint64_t v5;
  uint64_t v6;
  __int128 v8;
  __int128 v9;

  if (!*(_QWORD *)(a2 + 16))
    return *(_QWORD *)(a1 + 64);
  for (i = *(_QWORD *)(a1 + 56); i != *(_QWORD *)(a1 + 64); i += 72)
  {
    v8 = 0u;
    v9 = 0u;
    qmi::Client::Client();
    v5 = *(_QWORD *)(a2 + 16);
    v6 = v9;
    qmi::Client::~Client((qmi::Client *)&v8);
    if (v5 == v6)
      break;
  }
  return i;
}

uint64_t __copy_helper_block_e8_40c42_ZTSNSt3__18weak_ptrIN3qmi6Client5StateEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 48) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 16);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void __destroy_helper_block_e8_40c42_ZTSNSt3__18weak_ptrIN3qmi6Client5StateEEE(uint64_t a1)
{
  std::__shared_weak_count *v1;

  v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1)
    std::__shared_weak_count::__release_weak(v1);
}

void ___ZN13QMIClientPool26createVirtualClientOnQueueEN8dispatch5queueERKNSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEN3qmi11ServiceTypeESA_P24QMIVirtualClientCallbackN3xpc10connectionE_block_invoke_9(_QWORD *a1)
{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  uint64_t QMIClientInfo;
  uint64_t *i;
  std::__shared_weak_count *v8;
  std::__shared_weak_count *v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  uint64_t v21[2];
  uint64_t v22;
  std::__shared_weak_count *v23;
  _BYTE v24[32];
  std::__shared_weak_count *v26;

  v2 = (std::__shared_weak_count *)a1[6];
  if (!v2)
    return;
  v3 = a1[4];
  v4 = std::__shared_weak_count::lock(v2);
  v26 = v4;
  if (!v4)
    return;
  if (!a1[5])
  {
    v18 = v4;
    goto LABEL_26;
  }
  v5 = v3 + 80;
  MEMORY[0x2199FDF3C](v3 + 80);
  qmi::Client::Client();
  QMIClientInfo = QMIClientPool::findQMIClientInfo(v3, (uint64_t)v24);
  qmi::Client::~Client((qmi::Client *)v24);
  if (*(_QWORD *)(v3 + 64) == QMIClientInfo)
    __TUAssertTrigger();
  for (i = *(uint64_t **)(QMIClientInfo + 48); i != *(uint64_t **)(QMIClientInfo + 56); i += 2)
  {
    v22 = 0;
    v23 = 0;
    v8 = (std::__shared_weak_count *)i[1];
    if (v8)
    {
      v9 = std::__shared_weak_count::lock(v8);
      v23 = v9;
      if (!v9)
        continue;
      v10 = v9;
      v11 = *i;
      v22 = v11;
      if (v11)
      {
        v21[0] = v11;
        v21[1] = (uint64_t)v10;
        p_shared_owners = (unint64_t *)&v10->__shared_owners_;
        do
          v13 = __ldxr(p_shared_owners);
        while (__stxr(v13 + 1, p_shared_owners));
        QMIVirtualClient::dispatchDeregistered(v11, v21);
        do
          v14 = __ldaxr(p_shared_owners);
        while (__stlxr(v14 - 1, p_shared_owners));
        if (!v14)
        {
          ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
          std::__shared_weak_count::__release_weak(v10);
        }
      }
    }
    v15 = v23;
    if (v23)
    {
      v16 = (unint64_t *)&v23->__shared_owners_;
      do
        v17 = __ldaxr(v16);
      while (__stlxr(v17 - 1, v16));
      if (!v17)
      {
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v15);
      }
    }
  }
  *(_BYTE *)(QMIClientInfo + 16) = 0;
  MEMORY[0x2199FDF48](v5);
  v18 = v26;
  if (!v26)
    return;
LABEL_26:
  v19 = (unint64_t *)&v18->__shared_owners_;
  do
    v20 = __ldaxr(v19);
  while (__stlxr(v20 - 1, v19));
  if (!v20)
  {
    ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
    std::__shared_weak_count::__release_weak(v18);
  }
}

void sub_2169F79A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t QMIVirtualClient::dispatchDeregistered(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  uint64_t v12;
  std::__shared_weak_count *v13;
  _QWORD v14[2];

  v14[0] = a1 + 88;
  v14[1] = 1;
  MEMORY[0x2199FDF3C]();
  if (*(_BYTE *)(a1 + 74))
  {
    if (*(_BYTE *)(a1 + 73))
    {
      v4 = *(_QWORD *)(a1 + 80);
      if (v4)
      {
        v5 = (std::__shared_weak_count *)a2[1];
        v12 = *a2;
        v13 = v5;
        if (v5)
        {
          p_shared_owners = (unint64_t *)&v5->__shared_owners_;
          do
            v7 = __ldxr(p_shared_owners);
          while (__stxr(v7 + 1, p_shared_owners));
        }
        (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v4 + 24))(v4, &v12);
        v8 = v13;
        if (v13)
        {
          v9 = (unint64_t *)&v13->__shared_owners_;
          do
            v10 = __ldaxr(v9);
          while (__stlxr(v10 - 1, v9));
          if (!v10)
          {
            ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
            std::__shared_weak_count::__release_weak(v8);
          }
        }
        *(_BYTE *)(a1 + 73) = 0;
      }
    }
  }
  return std::unique_lock<ctu::UnfairLock>::~unique_lock[abi:ne180100]((uint64_t)v14);
}

void sub_2169F7AA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::unique_lock<ctu::UnfairLock>::~unique_lock[abi:ne180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

void ___ZN13QMIClientPool26createVirtualClientOnQueueEN8dispatch5queueERKNSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEN3qmi11ServiceTypeESA_P24QMIVirtualClientCallbackN3xpc10connectionE_block_invoke_11(_QWORD *a1, uint64_t a2)
{
  std::__shared_weak_count *v3;
  uint64_t v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  uint64_t QMIClientInfo;
  uint64_t *v9;
  std::__shared_weak_count *v10;
  std::__shared_weak_count *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t *v24;
  unint64_t v25;
  std::__shared_weak_count *v26;
  unint64_t *p_shared_owners;
  unint64_t v28;
  std::__shared_weak_count *v29;
  _BYTE v30[32];
  std::__shared_weak_count *v32;
  uint64_t v33;
  std::__shared_weak_count *v34;
  _QWORD v35[2];

  v3 = (std::__shared_weak_count *)a1[6];
  if (!v3)
    return;
  v5 = a1[4];
  v6 = std::__shared_weak_count::lock(v3);
  v32 = v6;
  if (!v6)
    return;
  if (!a1[5])
  {
    v26 = v6;
LABEL_35:
    p_shared_owners = (unint64_t *)&v26->__shared_owners_;
    do
      v28 = __ldaxr(p_shared_owners);
    while (__stlxr(v28 - 1, p_shared_owners));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
      std::__shared_weak_count::__release_weak(v26);
    }
    return;
  }
  v7 = v5 + 80;
  MEMORY[0x2199FDF3C](v5 + 80);
  qmi::Client::Client();
  QMIClientInfo = QMIClientPool::findQMIClientInfo(v5, (uint64_t)v30);
  qmi::Client::~Client((qmi::Client *)v30);
  if (*(_QWORD *)(v5 + 64) == QMIClientInfo)
    __TUAssertTrigger();
  v9 = *(uint64_t **)(QMIClientInfo + 48);
  if (v9 != *(uint64_t **)(QMIClientInfo + 56))
  {
    while (1)
    {
      v29 = 0;
      v10 = (std::__shared_weak_count *)v9[1];
      if (!v10)
        goto LABEL_26;
      v11 = std::__shared_weak_count::lock(v10);
      v29 = v11;
      if (v11)
        break;
LABEL_31:
      v9 += 2;
      if (v9 == *(uint64_t **)(QMIClientInfo + 56))
        goto LABEL_32;
    }
    v14 = *v9;
    if (*v9)
    {
      v15 = v11;
      v16 = (unint64_t *)&v11->__shared_owners_;
      do
        v17 = __ldxr(v16);
      while (__stxr(v17 + 1, v16));
      v35[0] = v14 + 88;
      v35[1] = 1;
      MEMORY[0x2199FDF3C](v14 + 88, v12, v13);
      if (*(_BYTE *)(v14 + 74))
      {
        if (*(_BYTE *)(v14 + 73))
        {
          v18 = *(_QWORD *)(v14 + 80);
          if (v18)
          {
            v33 = v14;
            v34 = v15;
            do
              v19 = __ldxr(v16);
            while (__stxr(v19 + 1, v16));
            (*(void (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(*(_QWORD *)v18 + 32))(v18, &v33, a2, 1);
            v20 = v34;
            if (v34)
            {
              v21 = (unint64_t *)&v34->__shared_owners_;
              do
                v22 = __ldaxr(v21);
              while (__stlxr(v22 - 1, v21));
              if (!v22)
              {
                ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
                std::__shared_weak_count::__release_weak(v20);
              }
            }
          }
        }
      }
      std::unique_lock<ctu::UnfairLock>::~unique_lock[abi:ne180100]((uint64_t)v35);
      do
        v23 = __ldaxr(v16);
      while (__stlxr(v23 - 1, v16));
      if (!v23)
      {
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v15);
      }
    }
LABEL_26:
    if (v29)
    {
      v24 = (unint64_t *)&v29->__shared_owners_;
      do
        v25 = __ldaxr(v24);
      while (__stlxr(v25 - 1, v24));
      if (!v25)
      {
        ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
        std::__shared_weak_count::__release_weak(v29);
      }
    }
    goto LABEL_31;
  }
LABEL_32:
  MEMORY[0x2199FDF48](v7);
  v26 = v32;
  if (v32)
    goto LABEL_35;
}

void sub_2169F7D0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void ___ZN13QMIClientPool26createVirtualClientOnQueueEN8dispatch5queueERKNSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEN3qmi11ServiceTypeESA_P24QMIVirtualClientCallbackN3xpc10connectionE_block_invoke_14(_QWORD *a1)
{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  uint64_t QMIClientInfo;
  uint64_t *v7;
  uint64_t *v8;
  std::__shared_weak_count *v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t *v23;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *p_shared_owners;
  unint64_t v27;
  std::__shared_weak_count *v28;
  _BYTE v29[32];
  std::__shared_weak_count *v31;
  uint64_t v32;
  std::__shared_weak_count *v33;
  _QWORD v34[2];

  v2 = (std::__shared_weak_count *)a1[6];
  if (!v2)
    return;
  v3 = a1[4];
  v4 = std::__shared_weak_count::lock(v2);
  v31 = v4;
  if (!v4)
    return;
  if (!a1[5])
  {
    v25 = v4;
LABEL_35:
    p_shared_owners = (unint64_t *)&v25->__shared_owners_;
    do
      v27 = __ldaxr(p_shared_owners);
    while (__stlxr(v27 - 1, p_shared_owners));
    if (!v27)
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
    return;
  }
  v5 = v3 + 80;
  MEMORY[0x2199FDF3C](v3 + 80);
  qmi::Client::Client();
  QMIClientInfo = QMIClientPool::findQMIClientInfo(v3, (uint64_t)v29);
  qmi::Client::~Client((qmi::Client *)v29);
  if (*(_QWORD *)(v3 + 64) == QMIClientInfo)
    __TUAssertTrigger();
  v7 = *(uint64_t **)(QMIClientInfo + 48);
  v8 = *(uint64_t **)(QMIClientInfo + 56);
  if (v7 != v8)
  {
    while (1)
    {
      v28 = 0;
      v9 = (std::__shared_weak_count *)v7[1];
      if (!v9)
        goto LABEL_26;
      v10 = std::__shared_weak_count::lock(v9);
      v28 = v10;
      if (v10)
        break;
LABEL_31:
      v7 += 2;
      if (v7 == v8)
        goto LABEL_32;
    }
    v13 = *v7;
    if (*v7)
    {
      v14 = v10;
      v15 = (unint64_t *)&v10->__shared_owners_;
      do
        v16 = __ldxr(v15);
      while (__stxr(v16 + 1, v15));
      v34[0] = v13 + 88;
      v34[1] = 1;
      MEMORY[0x2199FDF3C](v13 + 88, v11, v12);
      if (*(_BYTE *)(v13 + 74))
      {
        if (*(_BYTE *)(v13 + 73))
        {
          v17 = *(_QWORD *)(v13 + 80);
          if (v17)
          {
            v32 = v13;
            v33 = v14;
            do
              v18 = __ldxr(v15);
            while (__stxr(v18 + 1, v15));
            (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v17 + 40))(v17, &v32);
            v19 = v33;
            if (v33)
            {
              v20 = (unint64_t *)&v33->__shared_owners_;
              do
                v21 = __ldaxr(v20);
              while (__stlxr(v21 - 1, v20));
              if (!v21)
              {
                ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
                std::__shared_weak_count::__release_weak(v19);
              }
            }
          }
        }
      }
      std::unique_lock<ctu::UnfairLock>::~unique_lock[abi:ne180100]((uint64_t)v34);
      do
        v22 = __ldaxr(v15);
      while (__stlxr(v22 - 1, v15));
      if (!v22)
      {
        ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
        std::__shared_weak_count::__release_weak(v14);
      }
    }
LABEL_26:
    if (v28)
    {
      v23 = (unint64_t *)&v28->__shared_owners_;
      do
        v24 = __ldaxr(v23);
      while (__stlxr(v24 - 1, v23));
      if (!v24)
      {
        ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
        std::__shared_weak_count::__release_weak(v28);
      }
    }
    goto LABEL_31;
  }
LABEL_32:
  MEMORY[0x2199FDF48](v5);
  v25 = v31;
  if (v31)
    goto LABEL_35;
}

void sub_2169F7FA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  uint64_t v6;
  va_list va;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  va_list va1;

  va_start(va1, a5);
  va_start(va, a5);
  v6 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  qmi::Client::~Client((qmi::Client *)va);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t QMIClientPool::registerUnsolicitedHandler(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  uint64_t QMIClientInfo;
  uint64_t *i;
  std::__shared_weak_count *v13;
  std::__shared_weak_count *v14;
  std::__shared_weak_count *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  BOOL v22;
  uint64_t *v23;
  unint64_t *p_shared_owners;
  unint64_t v25;
  std::__shared_weak_count *v26;
  unint64_t *v28;
  unint64_t v29;
  _QWORD v30[6];
  std::__shared_weak_count *v31;
  uint64_t v32;
  std::__shared_weak_count *v33;
  _QWORD v34[4];
  _QWORD v35[7];

  v35[0] = a1 + 80;
  v35[1] = 1;
  MEMORY[0x2199FDF3C]();
  v34[0] = 0;
  v34[1] = 0;
  v8 = *(_QWORD *)(a2 + 24);
  v34[2] = *(_QWORD *)(a2 + 16);
  v34[3] = v8;
  if (v8)
  {
    v9 = (unint64_t *)(v8 + 8);
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }
  QMIClientInfo = QMIClientPool::findQMIClientInfo(a1, (uint64_t)v34);
  qmi::Client::~Client((qmi::Client *)v34);
  if (*(_QWORD *)(a1 + 64) == QMIClientInfo)
    __TUAssertTrigger();
  for (i = *(uint64_t **)(QMIClientInfo + 48); ; i += 2)
  {
    if (i == *(uint64_t **)(QMIClientInfo + 56))
    {
      if (*(_QWORD *)(a2 + 16))
      {
        v32 = 0;
        v33 = 0;
        qmi::Client::operator std::weak_ptr<qmi::Client::State>();
        v30[0] = MEMORY[0x24BDAC760];
        v30[1] = 1174405120;
        v30[2] = ___ZN13QMIClientPool26registerUnsolicitedHandlerEN3qmi6ClientEPK16QMIVirtualClientt_block_invoke;
        v30[3] = &__block_descriptor_tmp_19_13;
        v30[4] = a1;
        v30[5] = 0;
        v31 = 0;
        v35[2] = MEMORY[0x24BDAC760];
        v35[3] = 0x40000000;
        v35[4] = ___ZNK3qmi6Client13setIndHandlerIRKNS_14IndicationBaseEEEvtU13block_pointerFvT_E_block_invoke;
        v35[5] = &unk_24D5DE0B8;
        v35[6] = v30;
        qmi::Client::setIndHandler();
        if (v31)
          std::__shared_weak_count::__release_weak(v31);
        v26 = v33;
        if (v33)
          goto LABEL_32;
      }
      return std::unique_lock<ctu::UnfairLock>::~unique_lock[abi:ne180100]((uint64_t)v35);
    }
    v13 = (std::__shared_weak_count *)i[1];
    if (v13)
    {
      v14 = std::__shared_weak_count::lock(v13);
      if (v14)
        break;
    }
LABEL_27:
    ;
  }
  v15 = v14;
  v16 = *i;
  if (!*i)
    goto LABEL_23;
  if (v16 == a3)
    goto LABEL_23;
  v19 = *(_QWORD *)(v16 + 24);
  v17 = v16 + 24;
  v18 = v19;
  if (!v19)
    goto LABEL_23;
  v20 = v17;
  do
  {
    v21 = *(unsigned __int16 *)(v18 + 32);
    v22 = v21 >= a4;
    if (v21 >= a4)
      v23 = (uint64_t *)v18;
    else
      v23 = (uint64_t *)(v18 + 8);
    if (v22)
      v20 = v18;
    v18 = *v23;
  }
  while (*v23);
  if (v20 == v17 || *(unsigned __int16 *)(v20 + 32) > a4)
  {
LABEL_23:
    p_shared_owners = (unint64_t *)&v14->__shared_owners_;
    do
      v25 = __ldaxr(p_shared_owners);
    while (__stlxr(v25 - 1, p_shared_owners));
    if (!v25)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v15);
    }
    goto LABEL_27;
  }
  v28 = (unint64_t *)&v14->__shared_owners_;
  do
    v29 = __ldaxr(v28);
  while (__stlxr(v29 - 1, v28));
  if (!v29)
  {
    ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
    v26 = v15;
LABEL_32:
    std::__shared_weak_count::__release_weak(v26);
  }
  return std::unique_lock<ctu::UnfairLock>::~unique_lock[abi:ne180100]((uint64_t)v35);
}

void sub_2169F8244(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, uint64_t a16, std::__shared_weak_count *a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22)
{
  std::unique_lock<ctu::UnfairLock>::~unique_lock[abi:ne180100]((uint64_t)&a22);
  _Unwind_Resume(a1);
}

void ___ZN13QMIClientPool26registerUnsolicitedHandlerEN3qmi6ClientEPK16QMIVirtualClientt_block_invoke(uint64_t a1, unsigned __int16 *a2)
{
  uint64_t v3;
  unint64_t *v4;
  unint64_t v5;
  uint64_t QMIClientInfo;
  uint64_t *i;
  std::__shared_weak_count *v8;
  std::__shared_weak_count *v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t *v13;
  uint64_t *v14;
  unsigned int v15;
  uint64_t *v16;
  uint64_t *v17;
  unsigned int v18;
  BOOL v19;
  uint64_t **v20;
  uint64_t **v21;
  unsigned int v22;
  uint64_t **v23;
  _WORD *v24;
  uint64_t *v25;
  void *v26;
  const void *v27;
  unint64_t *p_shared_owners;
  unint64_t v29;
  unsigned __int16 *v30;
  char v31[16];
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  std::__shared_weak_count *v35;
  _QWORD v36[4];
  _QWORD v37[2];
  _QWORD v38[2];
  _QWORD v39[3];

  v3 = *(_QWORD *)(a1 + 32);
  qmi::Client::Client();
  v37[0] = v3 + 80;
  v37[1] = 1;
  MEMORY[0x2199FDF3C]();
  v36[0] = 0;
  v36[1] = 0;
  v36[2] = v32;
  v36[3] = v33;
  if (v33)
  {
    v4 = (unint64_t *)(v33 + 8);
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }
  QMIClientInfo = QMIClientPool::findQMIClientInfo(v3, (uint64_t)v36);
  qmi::Client::~Client((qmi::Client *)v36);
  if (*(_QWORD *)(v3 + 64) == QMIClientInfo)
    __TUAssertTrigger();
  for (i = *(uint64_t **)(QMIClientInfo + 48); i != *(uint64_t **)(QMIClientInfo + 56); i += 2)
  {
    v8 = (std::__shared_weak_count *)i[1];
    if (v8)
    {
      v9 = std::__shared_weak_count::lock(v8);
      v35 = v9;
      if (v9)
      {
        v10 = v9;
        v11 = *i;
        v34 = v11;
        if (v11)
        {
          v38[0] = v11 + 88;
          v38[1] = 1;
          MEMORY[0x2199FDF3C]();
          if (*(_BYTE *)(v11 + 74))
          {
            if (*(_BYTE *)(v11 + 72))
            {
              v14 = *(uint64_t **)(v11 + 24);
              v13 = (uint64_t *)(v11 + 24);
              v12 = v14;
              if (v14)
              {
                v15 = *a2;
                v16 = v13;
                v17 = v12;
                do
                {
                  v18 = *((unsigned __int16 *)v17 + 16);
                  v19 = v18 >= v15;
                  if (v18 >= v15)
                    v20 = (uint64_t **)v17;
                  else
                    v20 = (uint64_t **)(v17 + 1);
                  if (v19)
                    v16 = v17;
                  v17 = *v20;
                }
                while (*v20);
                if (v16 != v13 && v15 >= *((unsigned __int16 *)v16 + 16))
                {
                  do
                  {
                    while (1)
                    {
                      v21 = (uint64_t **)v12;
                      v22 = *((unsigned __int16 *)v12 + 16);
                      if (v22 <= v15)
                        break;
                      v12 = *v21;
                      if (!*v21)
                      {
                        v30 = a2;
                        v23 = v21;
                        goto LABEL_29;
                      }
                    }
                    if (v22 >= v15)
                      goto LABEL_30;
                    v12 = v21[1];
                  }
                  while (v12);
                  v30 = a2;
                  v23 = v21 + 1;
LABEL_29:
                  v39[2] = 1;
                  v24 = operator new(0x30uLL);
                  v39[1] = v13;
                  v24[16] = v15;
                  *((_QWORD *)v24 + 5) = 0;
                  std::__tree<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::less<unsigned short>,true>,std::allocator<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>>>::__insert_node_at((uint64_t **)v13 - 1, (uint64_t)v21, v23, (uint64_t *)v24);
                  v39[0] = 0;
                  std::unique_ptr<std::__tree_node<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,void *>>>>::reset[abi:ne180100]((uint64_t)v39, 0);
                  v21 = (uint64_t **)v24;
                  a2 = v30;
LABEL_30:
                  v25 = v21[5];
                  if (v25)
                  {
                    v26 = _Block_copy(v25);
                    v27 = v26;
                    if (v26)
                    {
                      (*((void (**)(void *, unsigned __int16 *))v26 + 2))(v26, a2);
                      _Block_release(v27);
                    }
                  }
                }
              }
            }
          }
          std::unique_lock<ctu::UnfairLock>::~unique_lock[abi:ne180100]((uint64_t)v38);
        }
        p_shared_owners = (unint64_t *)&v10->__shared_owners_;
        do
          v29 = __ldaxr(p_shared_owners);
        while (__stlxr(v29 - 1, p_shared_owners));
        if (!v29)
        {
          ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
          std::__shared_weak_count::__release_weak(v10);
        }
      }
    }
  }
  std::unique_lock<ctu::UnfairLock>::~unique_lock[abi:ne180100]((uint64_t)v37);
  qmi::Client::~Client((qmi::Client *)v31);
}

void sub_2169F84E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,char a22)
{
  const void *v22;

  _Block_release(v22);
  std::unique_lock<ctu::UnfairLock>::~unique_lock[abi:ne180100]((uint64_t)&a22);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a14);
  std::unique_lock<ctu::UnfairLock>::~unique_lock[abi:ne180100]((uint64_t)&a20);
  qmi::Client::~Client((qmi::Client *)&a10);
  _Unwind_Resume(a1);
}

void QMIClientPool::QMIClientInfo::~QMIClientInfo(void **this)
{
  std::__shared_weak_count *v2;
  void **v3;

  v3 = this + 6;
  std::vector<std::weak_ptr<QMIVirtualClient>>::__destroy_vector::operator()[abi:ne180100](&v3);
  if (*((char *)this + 47) < 0)
    operator delete(this[3]);
  v2 = (std::__shared_weak_count *)this[1];
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
}

uint64_t QMIVirtualClient::disconnect(QMIVirtualClient *this, uint64_t a2)
{
  _QWORD v4[2];

  v4[0] = (char *)this + 88;
  v4[1] = 1;
  MEMORY[0x2199FDF3C]((char *)this + 88, a2);
  *((_BYTE *)this + 74) = 0;
  return std::unique_lock<ctu::UnfairLock>::~unique_lock[abi:ne180100]((uint64_t)v4);
}

void QMIVirtualClient::disableNasServingSystemIndications(QMIVirtualClient *this, const ctu::OsLogLogger *a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;
  _QWORD v5[4];

  v5[0] = 0;
  v5[1] = 0;
  v2 = *((_QWORD *)this + 8);
  v5[2] = *((_QWORD *)this + 7);
  v5[3] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  disableNasServingSystemIndications((uint64_t)a2, (qmi::Client *)v5);
  qmi::Client::~Client((qmi::Client *)v5);
}

void sub_2169F8644(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  qmi::Client::~Client((qmi::Client *)&a9);
  _Unwind_Resume(a1);
}

void std::vector<std::weak_ptr<QMIVirtualClient>>::__assign_with_size[abi:ne180100]<std::weak_ptr<QMIVirtualClient>*,std::weak_ptr<QMIVirtualClient>*>(uint64_t *a1, uint64_t *a2, uint64_t *a3, unint64_t a4)
{
  uint64_t *v6;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  _QWORD *v21;
  _QWORD *i;
  std::__shared_weak_count *v23;

  v6 = a2;
  v8 = a1[2];
  v9 = (_QWORD *)*a1;
  if (a4 > (v8 - *a1) >> 4)
  {
    if (v9)
    {
      std::vector<std::weak_ptr<QMIVirtualClient>>::__clear[abi:ne180100](a1);
      operator delete((void *)*a1);
      v8 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    if (a4 >> 60)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 3;
    if (v8 >> 3 <= a4)
      v10 = a4;
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0)
      v11 = 0xFFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    std::vector<std::weak_ptr<QMIVirtualClient>>::__vallocate[abi:ne180100](a1, v11);
    v12 = (uint64_t *)a1[1];
    while (v6 != a3)
    {
      v13 = v6[1];
      *v12 = *v6;
      v12[1] = v13;
      if (v13)
      {
        v14 = (unint64_t *)(v13 + 16);
        do
          v15 = __ldxr(v14);
        while (__stxr(v15 + 1, v14));
      }
      v6 += 2;
      v12 += 2;
    }
LABEL_23:
    a1[1] = (uint64_t)v12;
    return;
  }
  v16 = (a1[1] - (uint64_t)v9) >> 4;
  if (v16 < a4)
  {
    v17 = &a2[2 * v16];
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::weak_ptr<QMIVirtualClient> *,std::weak_ptr<QMIVirtualClient> *,std::weak_ptr<QMIVirtualClient> *>(a2, v17, v9);
    v12 = (uint64_t *)a1[1];
    while (v17 != a3)
    {
      v18 = v17[1];
      *v12 = *v17;
      v12[1] = v18;
      if (v18)
      {
        v19 = (unint64_t *)(v18 + 16);
        do
          v20 = __ldxr(v19);
        while (__stxr(v20 + 1, v19));
      }
      v17 += 2;
      v12 += 2;
    }
    goto LABEL_23;
  }
  v21 = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::weak_ptr<QMIVirtualClient> *,std::weak_ptr<QMIVirtualClient> *,std::weak_ptr<QMIVirtualClient> *>(a2, a3, v9);
  for (i = (_QWORD *)a1[1]; i != v21; i -= 2)
  {
    v23 = (std::__shared_weak_count *)*(i - 1);
    if (v23)
      std::__shared_weak_count::__release_weak(v23);
  }
  a1[1] = (uint64_t)v21;
}

char *std::vector<std::weak_ptr<QMIVirtualClient>>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 60)
    std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::weak_ptr<QMIVirtualClient>>>(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[16 * v4];
  return result;
}

_QWORD *std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::weak_ptr<QMIVirtualClient> *,std::weak_ptr<QMIVirtualClient> *,std::weak_ptr<QMIVirtualClient> *>(uint64_t *a1, uint64_t *a2, _QWORD *a3)
{
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  std::__shared_weak_count *v10;

  if (a1 != a2)
  {
    v5 = a1;
    do
    {
      v7 = *v5;
      v6 = v5[1];
      if (v6)
      {
        v8 = (unint64_t *)(v6 + 16);
        do
          v9 = __ldxr(v8);
        while (__stxr(v9 + 1, v8));
      }
      v10 = (std::__shared_weak_count *)a3[1];
      *a3 = v7;
      a3[1] = v6;
      if (v10)
        std::__shared_weak_count::__release_weak(v10);
      v5 += 2;
      a3 += 2;
    }
    while (v5 != a2);
  }
  return a3;
}

void std::vector<std::weak_ptr<QMIVirtualClient>>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v2;
  uint64_t i;
  std::__shared_weak_count *v4;

  v2 = *a1;
  for (i = a1[1]; i != v2; i -= 16)
  {
    v4 = *(std::__shared_weak_count **)(i - 8);
    if (v4)
      std::__shared_weak_count::__release_weak(v4);
  }
  a1[1] = v2;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<std::weak_ptr<QMIVirtualClient>>>(unint64_t a1)
{
  if (a1 >> 60)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(16 * a1);
}

uint64_t std::__split_buffer<std::weak_ptr<QMIVirtualClient>>::~__split_buffer(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  v3 = *(_QWORD *)(a1 + 8);
  v2 = *(_QWORD *)(a1 + 16);
  while (v2 != v3)
  {
    *(_QWORD *)(a1 + 16) = v2 - 16;
    v4 = *(std::__shared_weak_count **)(v2 - 8);
    if (v4)
    {
      std::__shared_weak_count::__release_weak(v4);
      v2 = *(_QWORD *)(a1 + 16);
    }
    else
    {
      v2 -= 16;
    }
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

std::string *std::construct_at[abi:ne180100]<QMIClientPool::QMIClientInfo,QMIClientPool::QMIClientInfo,QMIClientPool::QMIClientInfo*>(std::string *a1, uint64_t a2)
{
  std::string::size_type v4;
  unint64_t *v5;
  unint64_t v6;
  __int128 v7;

  v4 = *(_QWORD *)(a2 + 8);
  a1->__r_.__value_.__r.__words[0] = *(_QWORD *)a2;
  a1->__r_.__value_.__l.__size_ = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 16);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  a1->__r_.__value_.__s.__data_[16] = *(_BYTE *)(a2 + 16);
  if (*(char *)(a2 + 47) < 0)
  {
    std::string::__init_copy_ctor_external(a1 + 1, *(const std::string::value_type **)(a2 + 24), *(_QWORD *)(a2 + 32));
  }
  else
  {
    v7 = *(_OWORD *)(a2 + 24);
    a1[1].__r_.__value_.__r.__words[2] = *(_QWORD *)(a2 + 40);
    *(_OWORD *)&a1[1].__r_.__value_.__l.__data_ = v7;
  }
  a1[2].__r_.__value_.__r.__words[0] = 0;
  a1[2].__r_.__value_.__l.__size_ = 0;
  a1[2].__r_.__value_.__r.__words[2] = 0;
  std::vector<std::weak_ptr<QMIVirtualClient>>::__init_with_size[abi:ne180100]<std::weak_ptr<QMIVirtualClient>*,std::weak_ptr<QMIVirtualClient>*>((char *)&a1[2], *(_QWORD **)(a2 + 48), *(_QWORD **)(a2 + 56), (uint64_t)(*(_QWORD *)(a2 + 56) - *(_QWORD *)(a2 + 48)) >> 4);
  return a1;
}

void sub_2169F89F0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  std::__shared_weak_count *v3;

  v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3)
    std::__shared_weak_count::__release_weak(v3);
  _Unwind_Resume(exception_object);
}

char *std::vector<std::weak_ptr<QMIVirtualClient>>::__init_with_size[abi:ne180100]<std::weak_ptr<QMIVirtualClient>*,std::weak_ptr<QMIVirtualClient>*>(char *result, _QWORD *a2, _QWORD *a3, unint64_t a4)
{
  char *v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;

  if (a4)
  {
    v6 = result;
    result = std::vector<std::weak_ptr<QMIVirtualClient>>::__vallocate[abi:ne180100](result, a4);
    v7 = (_QWORD *)*((_QWORD *)v6 + 1);
    while (a2 != a3)
    {
      *v7 = *a2;
      v8 = a2[1];
      v7[1] = v8;
      if (v8)
      {
        v9 = (unint64_t *)(v8 + 16);
        do
          v10 = __ldxr(v9);
        while (__stxr(v10 + 1, v9));
      }
      a2 += 2;
      v7 += 2;
    }
    *((_QWORD *)v6 + 1) = v7;
  }
  return result;
}

void sub_2169F8AAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  std::vector<std::weak_ptr<QMIVirtualClient>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

void std::vector<std::weak_ptr<QMIVirtualClient>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<std::weak_ptr<QMIVirtualClient>>::__clear[abi:ne180100]((uint64_t *)v2);
    operator delete(**a1);
  }
}

uint64_t std::__split_buffer<QMIClientPool::QMIClientInfo>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 72;
    QMIClientPool::QMIClientInfo::~QMIClientInfo((void **)(i - 72));
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t *std::shared_ptr<QMIClientPool>::shared_ptr[abi:ne180100]<QMIClientPool,void>(uint64_t *a1, uint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24D5DDFD8;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = (uint64_t)v4;
  if (a2)
    v5 = (_QWORD *)(a2 + 16);
  else
    v5 = 0;
  std::shared_ptr<QMIDataSystemDeterminationManager>::__enable_weak_this[abi:ne180100]<QMIDataSystemDeterminationManager,QMIDataSystemDeterminationManager,void>((uint64_t)a1, v5, a2);
  return a1;
}

void sub_2169F8BB8(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<QMIClientPool *,std::shared_ptr<QMIClientPool>::__shared_ptr_default_delete<QMIClientPool,QMIClientPool>,std::allocator<QMIClientPool>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

uint64_t std::__shared_ptr_pointer<QMIClientPool *,std::shared_ptr<QMIClientPool>::__shared_ptr_default_delete<QMIClientPool,QMIClientPool>,std::allocator<QMIClientPool>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t std::__shared_ptr_pointer<QMIClientPool *,std::shared_ptr<QMIClientPool>::__shared_ptr_default_delete<QMIClientPool,QMIClientPool>,std::allocator<QMIClientPool>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void std::allocate_shared[abi:ne180100]<QMIVirtualClient,std::allocator<QMIVirtualClient>,std::shared_ptr<QMIClientPool>,qmi::Client &,QMIVirtualClientCallback *&,void>(_QWORD *a1, uint64_t a2, std::__shared_weak_count *a3, uint64_t a4, uint64_t *a5)
{
  _QWORD *v10;
  _QWORD *v11;
  unint64_t *p_shared_weak_owners;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  unint64_t *v21;
  unint64_t v22;
  _QWORD v23[4];

  v10 = operator new(0x78uLL);
  v11 = v10;
  v10[1] = 0;
  v10[2] = 0;
  *v10 = &off_24D5DE050;
  if (a3)
  {
    p_shared_weak_owners = (unint64_t *)&a3->__shared_weak_owners_;
    do
      v13 = __ldxr(p_shared_weak_owners);
    while (__stxr(v13 + 1, p_shared_weak_owners));
  }
  v23[0] = 0;
  v23[1] = 0;
  v14 = *(_QWORD *)(a4 + 16);
  v15 = *(_QWORD *)(a4 + 24);
  v23[2] = v14;
  v23[3] = v15;
  if (v15)
  {
    v16 = (unint64_t *)(v15 + 8);
    do
      v17 = __ldxr(v16);
    while (__stxr(v17 + 1, v16));
  }
  v18 = *a5;
  v10[3] = a2;
  v10[4] = a3;
  if (a3)
  {
    v19 = (unint64_t *)&a3->__shared_weak_owners_;
    do
      v20 = __ldxr(v19);
    while (__stxr(v20 + 1, v19));
  }
  v10[8] = 0;
  v10[7] = 0;
  v10[6] = 0;
  v10[5] = v10 + 6;
  v10[9] = 0;
  v10[10] = v14;
  v10[11] = v15;
  if (v15)
  {
    v21 = (unint64_t *)(v15 + 8);
    do
      v22 = __ldxr(v21);
    while (__stxr(v22 + 1, v21));
  }
  *((_WORD *)v10 + 48) = 1;
  *((_BYTE *)v10 + 98) = 1;
  v10[13] = v18;
  *((_DWORD *)v10 + 28) = 0;
  if (!v14)
    __TUAssertTrigger();
  qmi::Client::~Client((qmi::Client *)v23);
  if (a3)
    std::__shared_weak_count::__release_weak(a3);
  *a1 = v11 + 3;
  a1[1] = v11;
}

void sub_2169F8D8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__shared_weak_count *v9;
  std::__shared_weak_count *v10;
  qmi::Client *v11;
  std::__shared_weak_count *shared_owners;
  void *v14;

  qmi::Client::~Client(v11);
  std::__tree<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::less<unsigned short>,true>,std::allocator<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>>>::destroy(&v9[2].~__shared_weak_count);
  shared_owners = (std::__shared_weak_count *)v9[1].__shared_owners_;
  if (shared_owners)
    std::__shared_weak_count::__release_weak(shared_owners);
  qmi::Client::~Client((qmi::Client *)&a9);
  if (v10)
    std::__shared_weak_count::__release_weak(v10);
  std::__shared_weak_count::~__shared_weak_count(v9);
  operator delete(v14);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<QMIVirtualClient>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5DE050;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMIVirtualClient>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5DE050;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void std::__shared_ptr_emplace<QMIVirtualClient>::__on_zero_shared(uint64_t a1)
{
  std::__shared_weak_count *v2;
  uint64_t v3[2];

  if (*(_QWORD *)(a1 + 104))
  {
    v3[0] = 0;
    v3[1] = 0;
    QMIVirtualClient::dispatchDeregistered(a1 + 24, v3);
  }
  qmi::Client::~Client((qmi::Client *)(a1 + 64));
  std::__tree<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::less<unsigned short>,true>,std::allocator<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>>>::destroy(*(_QWORD **)(a1 + 48));
  v2 = *(std::__shared_weak_count **)(a1 + 32);
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
}

void ___ZN8dispatch9sync_implIZN13QMIClientPool13requestClientEN3qmi11ServiceTypeENSt3__112basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEEP24QMIVirtualClientCallbackN3xpc10connectionEE3__0EENS4_5decayIDTclfp0_EEE4typeEP16dispatch_queue_sOT_NS4_17integral_constantIbLb0EEE_block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t *v2;
  dispatch_object_t *v3;
  uint64_t v4;
  NSObject *v5;
  __int128 *v6;
  uint64_t v7;
  xpc_object_t *v8;
  xpc_object_t v9;
  std::__shared_weak_count *v10;
  void *v11;
  std::__shared_weak_count *v12;
  std::__shared_weak_count *v13;
  unint64_t *p_shared_weak_owners;
  unint64_t v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  uint64_t v18;
  std::__shared_weak_count *v19;
  void *v20;
  std::__shared_weak_count *v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  uint64_t *v28;
  unint64_t v29;
  __int128 v30;
  unint64_t *v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  _OWORD *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  char *v41;
  uint64_t v42;
  __int128 *v43;
  _QWORD *v44;
  _QWORD *v45;
  __int128 v46;
  int64x2_t v47;
  uint64_t v48;
  unint64_t v49;
  unint64_t v50;
  unint64_t v51;
  uint64_t v52;
  unint64_t v53;
  unint64_t v54;
  uint64_t v55;
  unint64_t v56;
  char *v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  unint64_t *v64;
  unint64_t v65;
  __int128 v66;
  uint64_t v67;
  __int128 v68;
  __int128 v69;
  unint64_t *v70;
  unint64_t v71;
  std::__shared_weak_count *v72;
  unint64_t *v73;
  unint64_t v74;
  unint64_t v75;
  __int128 v76;
  uint64_t v77;
  xpc_object_t v78;
  NSObject *v79;
  __int128 v80[2];
  void *v81;
  std::__shared_weak_count *v82;
  void *v83;
  std::__shared_weak_count *v84;
  char v85;
  std::string v86;
  int64x2_t v87;
  _QWORD v88[7];
  std::__shared_weak_count *v89;
  uint64_t v90;
  uint64_t v91;
  void (*v92)(_QWORD *, uint64_t);
  void *v93;
  uint64_t v94;
  uint64_t v95;
  std::__shared_weak_count *v96;
  uint64_t v97;
  uint64_t v98;
  void (*v99)(_QWORD *);
  void *v100;
  uint64_t v101;
  uint64_t v102;
  std::__shared_weak_count *v103;
  uint64_t v104;
  uint64_t v105;
  void (*v106)(_QWORD *);
  void *v107;
  uint64_t v108;
  uint64_t v109;
  std::__shared_weak_count *v110;
  uint64_t v111;
  std::__shared_weak_count *v112;
  xpc_object_t v113;
  void *v114;
  std::__shared_weak_count *v115;
  dispatch_object_t v116;
  __int128 v117;
  __int128 v118;
  uint64_t v119;
  char *v120;
  _BYTE v121[24];
  _QWORD *v122;

  v1 = a1;
  v2 = *(uint64_t **)(a1 + 40);
  v4 = *v2;
  v3 = (dispatch_object_t *)v2[1];
  v5 = *v3;
  if (*v3)
    dispatch_retain(*v3);
  v6 = (__int128 *)v2[4];
  v7 = *(_QWORD *)v2[5];
  v8 = (xpc_object_t *)v2[6];
  v9 = *v8;
  if (*v8)
    xpc_retain(*v8);
  else
    v9 = xpc_null_create();
  v119 = v7;
  v116 = v5;
  if (v5)
    dispatch_retain(v5);
  v78 = v9;
  v79 = v5;
  v117 = 0u;
  v118 = 0u;
  v11 = *(void **)(v4 + 16);
  v10 = *(std::__shared_weak_count **)(v4 + 24);
  v83 = v11;
  if (!v10 || (v12 = std::__shared_weak_count::lock(v10), (v84 = v12) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v13 = v12;
  v114 = v11;
  v115 = v12;
  p_shared_weak_owners = (unint64_t *)&v12->__shared_weak_owners_;
  do
    v15 = __ldxr(p_shared_weak_owners);
  while (__stxr(v15 + 1, p_shared_weak_owners));
  if (MEMORY[0x2199FEDD0](v9) == MEMORY[0x24BDACF88] && (v113 = v9) != 0)
    xpc_retain(v9);
  else
    v113 = xpc_null_create();
  qmi::Client::createWithQueue();
  xpc_release(v113);
  v113 = 0;
  std::__shared_weak_count::__release_weak(v115);
  p_shared_owners = (unint64_t *)&v13->__shared_owners_;
  do
    v17 = __ldaxr(p_shared_owners);
  while (__stlxr(v17 - 1, p_shared_owners));
  if (!v17)
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
  if (v116)
    dispatch_release(v116);
  if (!(_QWORD)v118)
    __TUAssertTrigger();
  v111 = 0;
  v112 = 0;
  qmi::Client::operator std::weak_ptr<qmi::Client::State>();
  v18 = MEMORY[0x24BDAC760];
  v104 = MEMORY[0x24BDAC760];
  v105 = 1174405120;
  v106 = ___ZN13QMIClientPool26createVirtualClientOnQueueEN8dispatch5queueERKNSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEN3qmi11ServiceTypeESA_P24QMIVirtualClientCallbackN3xpc10connectionE_block_invoke;
  v107 = &__block_descriptor_tmp_8_14;
  v108 = v4;
  v109 = 0;
  v110 = 0;
  qmi::Client::setHandler();
  v97 = v18;
  v98 = 1174405120;
  v99 = ___ZN13QMIClientPool26createVirtualClientOnQueueEN8dispatch5queueERKNSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEN3qmi11ServiceTypeESA_P24QMIVirtualClientCallbackN3xpc10connectionE_block_invoke_9;
  v100 = &__block_descriptor_tmp_10_11;
  v101 = v4;
  v102 = 0;
  v103 = 0;
  qmi::Client::setHandler();
  v90 = v18;
  v91 = 1174405120;
  v92 = ___ZN13QMIClientPool26createVirtualClientOnQueueEN8dispatch5queueERKNSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEN3qmi11ServiceTypeESA_P24QMIVirtualClientCallbackN3xpc10connectionE_block_invoke_11;
  v93 = &__block_descriptor_tmp_13_11;
  v94 = v4;
  v95 = 0;
  v96 = 0;
  qmi::Client::setHandler();
  v88[1] = v18;
  v88[2] = 1174405120;
  v88[3] = ___ZN13QMIClientPool26createVirtualClientOnQueueEN8dispatch5queueERKNSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEN3qmi11ServiceTypeESA_P24QMIVirtualClientCallbackN3xpc10connectionE_block_invoke_14;
  v88[4] = &__block_descriptor_tmp_15_19;
  v88[5] = v4;
  v88[6] = 0;
  v89 = 0;
  qmi::Client::setHandler();
  qmi::Client::setHandler();
  v80[0] = 0uLL;
  v20 = *(void **)(v4 + 16);
  v19 = *(std::__shared_weak_count **)(v4 + 24);
  v83 = v20;
  if (!v19 || (v21 = std::__shared_weak_count::lock(v19), (v84 = v21) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v22 = v21;
  std::allocate_shared[abi:ne180100]<QMIVirtualClient,std::allocator<QMIVirtualClient>,std::shared_ptr<QMIClientPool>,qmi::Client &,QMIVirtualClientCallback *&,void>(v80, (uint64_t)v20, v21, (uint64_t)&v117, &v119);
  v23 = (unint64_t *)&v22->__shared_owners_;
  do
    v24 = __ldaxr(v23);
  while (__stlxr(v24 - 1, v23));
  if (!v24)
  {
    ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
    std::__shared_weak_count::__release_weak(v22);
  }
  qmi::Client::operator std::weak_ptr<qmi::Client::State>();
  v80[1] = v80[0];
  v76 = v80[0];
  v25 = (std::__shared_weak_count *)*((_QWORD *)&v80[0] + 1);
  if (*((_QWORD *)&v80[0] + 1))
  {
    v26 = (unint64_t *)(*((_QWORD *)&v80[0] + 1) + 8);
    do
      v27 = __ldxr(v26);
    while (__stxr(v27 + 1, v26));
  }
  v83 = v81;
  v84 = v82;
  if (v82)
  {
    v28 = &v82->__shared_weak_owners_;
    do
      v29 = __ldxr((unint64_t *)v28);
    while (__stxr(v29 + 1, (unint64_t *)v28));
  }
  v85 = 0;
  if (*((char *)v6 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(&v86, *(const std::string::value_type **)v6, *((_QWORD *)v6 + 1));
  }
  else
  {
    v30 = *v6;
    v86.__r_.__value_.__r.__words[2] = *((_QWORD *)v6 + 2);
    *(_OWORD *)&v86.__r_.__value_.__l.__data_ = v30;
  }
  v87 = 0uLL;
  v88[0] = 0;
  if (v25)
  {
    v31 = (unint64_t *)&v25->__shared_weak_owners_;
    do
      v32 = __ldxr(v31);
    while (__stxr(v32 + 1, v31));
    v34 = v87.i64[1];
    v33 = v88[0];
    if (v87.i64[1] < v88[0])
    {
      *(_OWORD *)v87.i64[1] = v76;
      v35 = (_OWORD *)(v34 + 16);
      v87.i64[1] = (uint64_t)v35;
      goto LABEL_58;
    }
    v36 = v87.i64[0];
  }
  else
  {
    v36 = 0;
    v34 = 0;
    v33 = 0;
  }
  v37 = (v34 - v36) >> 4;
  if ((unint64_t)(v37 + 1) >> 60)
    std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
  v38 = v33 - v36;
  v39 = v38 >> 3;
  if (v38 >> 3 <= (unint64_t)(v37 + 1))
    v39 = v37 + 1;
  if ((unint64_t)v38 >= 0x7FFFFFFFFFFFFFF0)
    v40 = 0xFFFFFFFFFFFFFFFLL;
  else
    v40 = v39;
  v122 = v88;
  v41 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::weak_ptr<QMIVirtualClient>>>(v40);
  v43 = (__int128 *)&v41[16 * v37];
  *v43 = v76;
  v35 = v43 + 1;
  v44 = (_QWORD *)v87.i64[1];
  v45 = (_QWORD *)v87.i64[0];
  if (v87.i64[1] == v87.i64[0])
  {
    v47 = vdupq_n_s64(v87.u64[1]);
    v9 = v78;
  }
  else
  {
    v9 = v78;
    do
    {
      v46 = *((_OWORD *)v44 - 1);
      v44 -= 2;
      *--v43 = v46;
      *v44 = 0;
      v44[1] = 0;
    }
    while (v44 != v45);
    v47 = v87;
  }
  v87.i64[0] = (uint64_t)v43;
  v87.i64[1] = (uint64_t)v35;
  *(int64x2_t *)v121 = v47;
  v48 = v88[0];
  v88[0] = &v41[16 * v42];
  *(_QWORD *)&v121[16] = v48;
  v120 = (char *)v47.i64[0];
  std::__split_buffer<std::weak_ptr<QMIVirtualClient>>::~__split_buffer((uint64_t)&v120);
LABEL_58:
  v87.i64[1] = (uint64_t)v35;
  v49 = *(_QWORD *)(v4 + 72);
  v50 = *(_QWORD *)(v4 + 64);
  if (v50 >= v49)
  {
    v52 = *(_QWORD *)(v4 + 56);
    v53 = 0x8E38E38E38E38E39 * ((uint64_t)(v50 - v52) >> 3);
    if (v53 + 1 > 0x38E38E38E38E38ELL)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v54 = 0x8E38E38E38E38E39 * ((uint64_t)(v49 - v52) >> 3);
    v55 = 2 * v54;
    if (2 * v54 <= v53 + 1)
      v55 = v53 + 1;
    if (v54 >= 0x1C71C71C71C71C7)
      v56 = 0x38E38E38E38E38ELL;
    else
      v56 = v55;
    v122 = (_QWORD *)(v4 + 72);
    if (v56)
    {
      if (v56 > 0x38E38E38E38E38ELL)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v57 = (char *)operator new(72 * v56);
    }
    else
    {
      v57 = 0;
    }
    v77 = v1;
    v120 = v57;
    *(_QWORD *)v121 = &v57[72 * v53];
    *(_QWORD *)&v121[8] = *(_QWORD *)v121;
    *(_QWORD *)&v121[16] = &v57[72 * v56];
    std::construct_at[abi:ne180100]<QMIClientPool::QMIClientInfo,QMIClientPool::QMIClientInfo,QMIClientPool::QMIClientInfo*>(*(std::string **)v121, (uint64_t)&v83);
    v58 = 0;
    *(_QWORD *)&v121[8] += 72;
    v60 = *(_QWORD *)(v4 + 56);
    v59 = *(_QWORD *)(v4 + 64);
    v61 = *(_QWORD *)v121;
    while (1)
    {
      v62 = v61;
      if (v59 == v60)
        break;
      *(_QWORD *)(v61 - 72) = *(_QWORD *)(v59 - 72);
      v61 -= 72;
      v63 = *(_QWORD *)(v59 - 64);
      *(_QWORD *)(v62 - 64) = v63;
      if (v63)
      {
        v64 = (unint64_t *)(v63 + 16);
        do
          v65 = __ldxr(v64);
        while (__stxr(v65 + 1, v64));
      }
      *(_BYTE *)(v62 - 56) = *(_BYTE *)(v59 - 56);
      if (*(char *)(v59 - 25) < 0)
      {
        std::string::__init_copy_ctor_external((std::string *)(v62 - 48), *(const std::string::value_type **)(v59 - 48), *(_QWORD *)(v59 - 40));
      }
      else
      {
        v66 = *(_OWORD *)(v59 - 48);
        *(_QWORD *)(v62 - 32) = *(_QWORD *)(v59 - 32);
        *(_OWORD *)(v62 - 48) = v66;
      }
      *(_QWORD *)(v62 - 24) = 0;
      *(_QWORD *)(v62 - 16) = 0;
      *(_QWORD *)(v62 - 8) = 0;
      v58 -= 72;
      std::vector<std::weak_ptr<QMIVirtualClient>>::__init_with_size[abi:ne180100]<std::weak_ptr<QMIVirtualClient>*,std::weak_ptr<QMIVirtualClient>*>((char *)(v62 - 24), *(_QWORD **)(v59 - 24), *(_QWORD **)(v59 - 16), (uint64_t)(*(_QWORD *)(v59 - 16) - *(_QWORD *)(v59 - 24)) >> 4);
      v59 -= 72;
    }
    v67 = *(_QWORD *)(v4 + 72);
    v75 = *(_QWORD *)&v121[8];
    v68 = *(_OWORD *)&v121[8];
    v69 = *(_OWORD *)(v4 + 56);
    *(_QWORD *)(v4 + 56) = v61;
    *(_OWORD *)v121 = v69;
    *(_OWORD *)(v4 + 64) = v68;
    *(_QWORD *)&v121[16] = v67;
    v120 = (char *)v69;
    std::__split_buffer<QMIClientPool::QMIClientInfo>::~__split_buffer((uint64_t)&v120);
    v51 = v75;
    v9 = v78;
    v5 = v79;
    v1 = v77;
  }
  else
  {
    std::construct_at[abi:ne180100]<QMIClientPool::QMIClientInfo,QMIClientPool::QMIClientInfo,QMIClientPool::QMIClientInfo*>(*(std::string **)(v4 + 64), (uint64_t)&v83);
    v51 = v50 + 72;
    *(_QWORD *)(v4 + 64) = v50 + 72;
  }
  *(_QWORD *)(v4 + 64) = v51;
  QMIClientPool::QMIClientInfo::~QMIClientInfo(&v83);
  if (v25)
  {
    v70 = (unint64_t *)&v25->__shared_owners_;
    do
      v71 = __ldaxr(v70);
    while (__stlxr(v71 - 1, v70));
    if (!v71)
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }
  if (v82)
    std::__shared_weak_count::__release_weak(v82);
  qmi::Client::start((qmi::Client *)&v117);
  if (v89)
    std::__shared_weak_count::__release_weak(v89);
  if (v96)
    std::__shared_weak_count::__release_weak(v96);
  if (v103)
    std::__shared_weak_count::__release_weak(v103);
  if (v110)
    std::__shared_weak_count::__release_weak(v110);
  if (v112)
    std::__shared_weak_count::__release_weak(v112);
  qmi::Client::~Client((qmi::Client *)&v117);
  xpc_release(v9);
  if (v5)
    dispatch_release(v5);
  std::shared_ptr<qmi::Client::State>::operator=[abi:ne180100](*(_QWORD *)(v1 + 32), v80);
  v72 = (std::__shared_weak_count *)*((_QWORD *)&v80[0] + 1);
  if (*((_QWORD *)&v80[0] + 1))
  {
    v73 = (unint64_t *)(*((_QWORD *)&v80[0] + 1) + 8);
    do
      v74 = __ldaxr(v73);
    while (__stlxr(v74 - 1, v73));
    if (!v74)
    {
      ((void (*)(std::__shared_weak_count *))v72->__on_zero_shared)(v72);
      std::__shared_weak_count::__release_weak(v72);
    }
  }
}

void sub_2169F96A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, xpc_object_t object, dispatch_object_t a16, char a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,std::__shared_weak_count *a23,char a24,std::__shared_weak_count *a25,uint64_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,std::__shared_weak_count *a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,std::__shared_weak_count *a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,std::__shared_weak_count *a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,std::__shared_weak_count *a63)
{
  uint64_t v63;
  std::__shared_weak_count *v65;

  if (a25)
    std::__shared_weak_count::__release_weak(a25);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a19);
  if (a23)
    std::__shared_weak_count::__release_weak(a23);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a17);
  if (a42)
    std::__shared_weak_count::__release_weak(a42);
  if (a49)
    std::__shared_weak_count::__release_weak(a49);
  if (a56)
    std::__shared_weak_count::__release_weak(a56);
  if (a63)
    std::__shared_weak_count::__release_weak(a63);
  v65 = *(std::__shared_weak_count **)(v63 - 248);
  if (v65)
    std::__shared_weak_count::__release_weak(v65);
  qmi::Client::~Client((qmi::Client *)(v63 - 208));
  xpc_release(object);
  if (a16)
    dispatch_release(a16);
  _Unwind_Resume(a1);
}

void ___ZNK3qmi6Client13setIndHandlerIRKNS_14IndicationBaseEEEvtU13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v4, 0);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2169F9944(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void std::__tree<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::less<unsigned short>,true>,std::allocator<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>>>::destroy(_QWORD *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::less<unsigned short>,true>,std::allocator<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>>>::destroy(*a1);
    std::__tree<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::less<unsigned short>,true>,std::allocator<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>>>::destroy(a1[1]);
    std::__destroy_at[abi:ne180100]<std::pair<unsigned short const,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,0>((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

uint64_t Mav16QMIDataContextIP::Mav16QMIDataContextIP(uint64_t a1, uint64_t *a2, uint64_t *a3, char a4, uint64_t *a5, _QWORD *a6, int a7, NSObject **a8, uint64_t *a9)
{
  std::__shared_weak_count *v13;
  unint64_t *p_shared_owners;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  NSObject *v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  std::__shared_weak_count *v29;
  unint64_t *v30;
  unint64_t v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  std::__shared_weak_count *v35;
  unint64_t *v36;
  unint64_t v37;
  uint64_t v38;
  unint64_t *v39;
  unint64_t v40;
  uint64_t v42;
  std::__shared_weak_count *v43;
  dispatch_object_t object;
  uint64_t v45;
  std::__shared_weak_count *v46;
  uint64_t v47;
  std::__shared_weak_count *v48;
  uint64_t v49;
  std::__shared_weak_count *v50;

  v13 = (std::__shared_weak_count *)a2[1];
  v49 = *a2;
  v50 = v13;
  if (v13)
  {
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      v15 = __ldxr(p_shared_owners);
    while (__stxr(v15 + 1, p_shared_owners));
  }
  v16 = (std::__shared_weak_count *)a3[1];
  v47 = *a3;
  v48 = v16;
  if (v16)
  {
    v17 = (unint64_t *)&v16->__shared_owners_;
    do
      v18 = __ldxr(v17);
    while (__stxr(v18 + 1, v17));
  }
  v19 = (std::__shared_weak_count *)a5[1];
  v45 = *a5;
  v46 = v19;
  if (v19)
  {
    v20 = (unint64_t *)&v19->__shared_owners_;
    do
      v21 = __ldxr(v20);
    while (__stxr(v21 + 1, v20));
  }
  v22 = *a8;
  object = v22;
  if (v22)
    dispatch_retain(v22);
  v23 = (std::__shared_weak_count *)a9[1];
  v42 = *a9;
  v43 = v23;
  if (v23)
  {
    v24 = (unint64_t *)&v23->__shared_owners_;
    do
      v25 = __ldxr(v24);
    while (__stxr(v25 + 1, v24));
  }
  QMIDataContextIPBase::QMIDataContextIPBase(a1, &v49, &v47, a4, &v45, a7, &object, &v42);
  v26 = v43;
  if (v43)
  {
    v27 = (unint64_t *)&v43->__shared_owners_;
    do
      v28 = __ldaxr(v27);
    while (__stlxr(v28 - 1, v27));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
      std::__shared_weak_count::__release_weak(v26);
    }
  }
  if (object)
    dispatch_release(object);
  v29 = v46;
  if (v46)
  {
    v30 = (unint64_t *)&v46->__shared_owners_;
    do
      v31 = __ldaxr(v30);
    while (__stlxr(v31 - 1, v30));
    if (!v31)
    {
      ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
      std::__shared_weak_count::__release_weak(v29);
    }
  }
  v32 = v48;
  if (v48)
  {
    v33 = (unint64_t *)&v48->__shared_owners_;
    do
      v34 = __ldaxr(v33);
    while (__stlxr(v34 - 1, v33));
    if (!v34)
    {
      ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
      std::__shared_weak_count::__release_weak(v32);
    }
  }
  v35 = v50;
  if (v50)
  {
    v36 = (unint64_t *)&v50->__shared_owners_;
    do
      v37 = __ldaxr(v36);
    while (__stlxr(v37 - 1, v36));
    if (!v37)
    {
      ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
      std::__shared_weak_count::__release_weak(v35);
    }
  }
  *(_QWORD *)a1 = &off_24D5DE0E8;
  *(_QWORD *)(a1 + 864) = &unk_24D5DE270;
  v38 = a6[1];
  *(_QWORD *)(a1 + 872) = *a6;
  *(_QWORD *)(a1 + 880) = v38;
  if (v38)
  {
    v39 = (unint64_t *)(v38 + 16);
    do
      v40 = __ldxr(v39);
    while (__stxr(v40 + 1, v39));
  }
  *(_WORD *)(a1 + 888) = 0;
  *(_BYTE *)(a1 + 890) = 0;
  return a1;
}

void sub_2169F9BD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, dispatch_object_t object, char a13, uint64_t a14, char a15, uint64_t a16, char a17)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a10);
  if (object)
    dispatch_release(object);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a15);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a17);
  _Unwind_Resume(a1);
}

void Mav16QMIDataContextIP::~Mav16QMIDataContextIP(Mav16QMIDataContextIP *this)
{
  std::__shared_weak_count *v2;

  *(_QWORD *)this = &off_24D5DE0E8;
  *((_QWORD *)this + 108) = &unk_24D5DE270;
  v2 = (std::__shared_weak_count *)*((_QWORD *)this + 110);
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  QMIDataContextIPBase::~QMIDataContextIPBase(this);
}

{
  Mav16QMIDataContextIP::~Mav16QMIDataContextIP(this);
  JUMPOUT(0x2199FEAC4);
}

void `non-virtual thunk to'Mav16QMIDataContextIP::~Mav16QMIDataContextIP(Mav16QMIDataContextIP *this)
{
  Mav16QMIDataContextIP::~Mav16QMIDataContextIP((Mav16QMIDataContextIP *)((char *)this - 864));
}

{
  Mav16QMIDataContextIP::~Mav16QMIDataContextIP((Mav16QMIDataContextIP *)((char *)this - 864));
  JUMPOUT(0x2199FEAC4);
}

void Mav16QMIDataContextIP::handleBasebandOff_sync(std::__shared_weak_count **this)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  NSObject *v11;
  _QWORD v12[2];

  QMIDataContextIPBase::handleBasebandOff_sync((QMIDataContextIPBase *)this);
  v2 = this[13];
  if (v2)
  {
    v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      v4 = v3;
      v5 = this[12];
      p_shared_owners = (unint64_t *)&v3->__shared_owners_;
      do
        v7 = __ldaxr(p_shared_owners);
      while (__stlxr(v7 - 1, p_shared_owners));
      if (v7)
      {
        if (v5)
          goto LABEL_7;
      }
      else
      {
        ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
        std::__shared_weak_count::__release_weak(v4);
        if (v5)
        {
LABEL_7:
          v8 = std::__shared_weak_count::lock(this[13]);
          v12[0] = this[12];
          v12[1] = v8;
          (*(void (**)(_QWORD))(*(_QWORD *)v12[0] + 24))(v12[0]);
          v9 = (unint64_t *)&v8->__shared_owners_;
          do
            v10 = __ldaxr(v9);
          while (__stlxr(v10 - 1, v9));
          if (!v10)
          {
            ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
            std::__shared_weak_count::__release_weak(v8);
          }
          return;
        }
      }
    }
  }
  v11 = this[5];
  if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v12[0]) = 0;
    _os_log_error_impl(&dword_216897000, v11, OS_LOG_TYPE_ERROR, "Observer not ready", (uint8_t *)v12, 2u);
  }
}

void sub_2169F9DBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void Mav16QMIDataContextIP::handleQmiClientStarted(std::__shared_weak_count **this)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  NSObject *v11;
  _QWORD v12[2];

  QMIDataContextIPBase::handleQmiClientStarted(this);
  v2 = this[13];
  if (v2)
  {
    v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      v4 = v3;
      v5 = this[12];
      p_shared_owners = (unint64_t *)&v3->__shared_owners_;
      do
        v7 = __ldaxr(p_shared_owners);
      while (__stlxr(v7 - 1, p_shared_owners));
      if (v7)
      {
        if (v5)
          goto LABEL_7;
      }
      else
      {
        ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
        std::__shared_weak_count::__release_weak(v4);
        if (v5)
        {
LABEL_7:
          v8 = std::__shared_weak_count::lock(this[13]);
          v12[0] = this[12];
          v12[1] = v8;
          (*(void (**)(_QWORD, char *))(*(_QWORD *)v12[0] + 16))(v12[0], (char *)this + 144);
          v9 = (unint64_t *)&v8->__shared_owners_;
          do
            v10 = __ldaxr(v9);
          while (__stlxr(v10 - 1, v9));
          if (!v10)
          {
            ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
            std::__shared_weak_count::__release_weak(v8);
          }
          return;
        }
      }
    }
  }
  v11 = this[5];
  if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v12[0]) = 0;
    _os_log_error_impl(&dword_216897000, v11, OS_LOG_TYPE_ERROR, "lazy fWDSClient skipped in handleQmiClientStarted", (uint8_t *)v12, 2u);
  }
}

void sub_2169F9EE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t Mav16QMIDataContextIP::activateDataContextIP_Internal(uint64_t a1, int a2, uint64_t *a3, char a4)
{
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  std::__shared_weak_count *v11;
  std::__shared_weak_count *v12;
  uint64_t v13;
  NSObject *v14;
  uint64_t v15;
  const char *v16;
  char *v17;
  int v18;
  unint64_t *v19;
  unint64_t v20;
  std::__shared_weak_count *v21;
  uint64_t v22;
  unint64_t *v23;
  unint64_t v24;
  NSObject *v25;
  BOOL v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  unint64_t *v30;
  unint64_t v31;
  BOOL v32;
  std::__shared_weak_count *v33;
  unint64_t *v34;
  unint64_t v35;
  unint64_t *v36;
  unint64_t v37;
  std::__shared_weak_count *v38;
  unint64_t *v39;
  unint64_t v40;
  std::__shared_weak_count *v42;
  std::__shared_weak_count *v43;
  uint64_t v44;
  std::__shared_weak_count *v45;
  _BYTE __p[22];
  __int16 v47;
  int v48;
  uint64_t v49;

  v49 = *MEMORY[0x24BDAC8D0];
  v8 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(a1 + 104));
  *(_QWORD *)__p = *(_QWORD *)(a1 + 96);
  *(_QWORD *)&__p[8] = v8;
  v44 = 0;
  v45 = 0;
  (*(void (**)(uint64_t *__return_ptr))(**(_QWORD **)__p + 240))(&v44);
  p_shared_owners = (unint64_t *)&v8->__shared_owners_;
  do
    v10 = __ldaxr(p_shared_owners);
  while (__stlxr(v10 - 1, p_shared_owners));
  if (!v10)
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
  if (v44)
  {
    v11 = *(std::__shared_weak_count **)(a1 + 880);
    if (v11)
    {
      v12 = std::__shared_weak_count::lock(v11);
      if (v12)
      {
        v13 = *(_QWORD *)(a1 + 872);
        goto LABEL_13;
      }
    }
    else
    {
      v12 = 0;
    }
    v13 = 0;
LABEL_13:
    if (*(_DWORD *)(a1 + 140) == 1)
      v17 = "IPv4:";
    else
      v17 = "IPv6:";
    std::string::basic_string[abi:ne180100]<0>(__p, v17);
    v18 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)v13 + 32))(v13, __p);
    if (SHIBYTE(v47) < 0)
      operator delete(*(void **)__p);
    if (v12)
    {
      v19 = (unint64_t *)&v12->__shared_owners_;
      do
        v20 = __ldaxr(v19);
      while (__stlxr(v20 - 1, v19));
      if (!v20)
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }
    if (v18 == 2)
    {
      v14 = *(NSObject **)(a1 + 40);
      v15 = 0;
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__p = 136315138;
        *(_QWORD *)&__p[4] = "activateDataContextIP_Internal";
        v16 = "#I %s: Failed to create profiles";
        goto LABEL_26;
      }
      goto LABEL_78;
    }
    if ((a4 & 1) == 0)
      std::shared_ptr<QMIDataContextIPActivationLock>::operator=[abi:ne180100]((_QWORD *)(a1 + 560), a3);
    v21 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(a1 + 880));
    *(_QWORD *)__p = *(_QWORD *)(a1 + 872);
    *(_QWORD *)&__p[8] = v21;
    v22 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)__p + 40))(*(_QWORD *)__p);
    v23 = (unint64_t *)&v21->__shared_owners_;
    do
      v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
    QMIDataContextIPBase::setDataContextIPState(a1, 4u);
    *(_BYTE *)(a1 + 888) = v18 == 1;
    if (v18 == 1)
    {
      v25 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__p = 136315138;
        *(_QWORD *)&__p[4] = "activateDataContextIP_Internal";
        _os_log_impl(&dword_216897000, v25, OS_LOG_TYPE_DEFAULT, "#I %s: Profile creation pending...", __p, 0xCu);
      }
      *(_BYTE *)(a1 + 890) = a2;
      goto LABEL_77;
    }
    v42 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(a1 + 880));
    (*(void (**)(_BYTE *__return_ptr, _QWORD))(**(_QWORD **)(a1 + 872) + 24))(__p, *(_QWORD *)(a1 + 872));
    v26 = (*(unsigned __int8 *)(*(_QWORD *)__p + 3) == 254 || *(unsigned __int8 *)(*(_QWORD *)__p + 2) != 255)
       && (*(unsigned __int8 *)(*(_QWORD *)__p + 5) == 254 || *(unsigned __int8 *)(*(_QWORD *)__p + 4) != 255);
    v27 = *(std::__shared_weak_count **)&__p[8];
    if (*(_QWORD *)&__p[8])
    {
      v28 = (unint64_t *)(*(_QWORD *)&__p[8] + 8);
      do
        v29 = __ldaxr(v28);
      while (__stlxr(v29 - 1, v28));
      if (!v29)
      {
        ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
        std::__shared_weak_count::__release_weak(v27);
      }
    }
    if (!v42)
      goto LABEL_53;
    v30 = (unint64_t *)&v42->__shared_owners_;
    do
      v31 = __ldaxr(v30);
    while (__stlxr(v31 - 1, v30));
    if (!v31)
    {
      ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
      std::__shared_weak_count::__release_weak(v42);
      if (!v26)
        goto LABEL_54;
    }
    else
    {
LABEL_53:
      if (!v26)
      {
LABEL_54:
        if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)__p = 136315650;
          *(_QWORD *)&__p[4] = "Profile not created";
          *(_WORD *)&__p[12] = 2080;
          *(_QWORD *)&__p[14] = "/Library/Caches/com.apple.xbs/Sources/CoreTelephony/CommCenter/CommCenterCommandDrivers/"
                                "Data/QMI/Context/Mav16QMIDataContextIP.cpp";
          v47 = 1024;
          v48 = 103;
          _os_log_error_impl(&dword_216897000, MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR, "\n**********\n   ASSERT getProfileManager()->getProfileInfo()->isProfileCreated()\n %s\n at %s:%d\n**********", __p, 0x1Cu);
        }
        v43 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(a1 + 880));
        (*(void (**)(_BYTE *__return_ptr, _QWORD))(**(_QWORD **)(a1 + 872) + 24))(__p, *(_QWORD *)(a1 + 872));
        v32 = (*(unsigned __int8 *)(*(_QWORD *)__p + 3) == 254 || *(unsigned __int8 *)(*(_QWORD *)__p + 2) != 255)
           && (*(unsigned __int8 *)(*(_QWORD *)__p + 5) == 254 || *(unsigned __int8 *)(*(_QWORD *)__p + 4) != 255);
        v33 = *(std::__shared_weak_count **)&__p[8];
        if (*(_QWORD *)&__p[8])
        {
          v34 = (unint64_t *)(*(_QWORD *)&__p[8] + 8);
          do
            v35 = __ldaxr(v34);
          while (__stlxr(v35 - 1, v34));
          if (!v35)
          {
            ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
            std::__shared_weak_count::__release_weak(v33);
          }
        }
        if (v43)
        {
          v36 = (unint64_t *)&v43->__shared_owners_;
          do
            v37 = __ldaxr(v36);
          while (__stlxr(v37 - 1, v36));
          if (!v37)
          {
            ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
            std::__shared_weak_count::__release_weak(v43);
          }
        }
        if (!v32)
          __TUAssertTrigger();
      }
    }
    Mav16QMIDataContextIP::activateDataContextIPAfterProfileCreation(a1, a2, v22);
LABEL_77:
    v15 = 1;
    goto LABEL_78;
  }
  v14 = *(NSObject **)(a1 + 40);
  v15 = 0;
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__p = 136315138;
    *(_QWORD *)&__p[4] = "activateDataContextIP_Internal";
    v16 = "#E %s: Do not expect activation at this point !";
LABEL_26:
    _os_log_impl(&dword_216897000, v14, OS_LOG_TYPE_DEFAULT, v16, __p, 0xCu);
    v15 = 0;
  }
LABEL_78:
  v38 = v45;
  if (v45)
  {
    v39 = (unint64_t *)&v45->__shared_owners_;
    do
      v40 = __ldaxr(v39);
    while (__stlxr(v40 - 1, v39));
    if (!v40)
    {
      ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
      std::__shared_weak_count::__release_weak(v38);
    }
  }
  return v15;
}

void sub_2169FA490(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

void Mav16QMIDataContextIP::activateDataContextIPAfterProfileCreation(uint64_t a1, int a2, uint64_t a3)
{
  NSObject *v6;
  std::__shared_weak_count *v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  char *v10;
  int v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  NSObject *v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  NSObject *v18;
  int v19;
  int v20;
  BOOL v21;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  unint64_t *v26;
  unint64_t v27;
  int v28;
  int v29;
  BOOL v30;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  unint64_t *v35;
  unint64_t v36;
  std::__shared_weak_count *v37;
  std::__shared_weak_count *v38;
  _BYTE buf[22];
  __int16 v40;
  int v41;
  uint64_t v42;

  v42 = *MEMORY[0x24BDAC8D0];
  v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315138;
    *(_QWORD *)&buf[4] = "activateDataContextIPAfterProfileCreation";
    _os_log_impl(&dword_216897000, v6, OS_LOG_TYPE_DEFAULT, "#I %s: start", buf, 0xCu);
  }
  v7 = *(std::__shared_weak_count **)(a1 + 880);
  if (v7)
  {
    v8 = std::__shared_weak_count::lock(v7);
    if (v8)
    {
      v9 = *(_QWORD *)(a1 + 872);
      goto LABEL_8;
    }
  }
  else
  {
    v8 = 0;
  }
  v9 = 0;
LABEL_8:
  if (*(_DWORD *)(a1 + 140) == 1)
    v10 = "IPv4:";
  else
    v10 = "IPv6:";
  std::string::basic_string[abi:ne180100]<0>(buf, v10);
  v11 = (*(uint64_t (**)(uint64_t, _BYTE *, uint64_t))(*(_QWORD *)v9 + 48))(v9, buf, a3);
  if (SHIBYTE(v40) < 0)
    operator delete(*(void **)buf);
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v13 = __ldaxr(p_shared_owners);
    while (__stlxr(v13 - 1, p_shared_owners));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  if (v11 == 2)
  {
    v14 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = "activateDataContextIPAfterProfileCreation";
      _os_log_impl(&dword_216897000, v14, OS_LOG_TYPE_DEFAULT, "#I %s: Failed to configure profiles", buf, 0xCu);
    }
    QMIDataContextIPBase::setDataContextIPState(a1, 1u);
    v15 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(a1 + 104));
    *(_QWORD *)buf = *(_QWORD *)(a1 + 96);
    *(_QWORD *)&buf[8] = v15;
    (*(void (**)(_QWORD, _QWORD, uint64_t, _QWORD, _QWORD, uint64_t, _QWORD))(**(_QWORD **)buf + 64))(*(_QWORD *)buf, *(unsigned int *)(a1 + 140), 18, 0, 0, 2, 0);
    v16 = (unint64_t *)&v15->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
    return;
  }
  *(_BYTE *)(a1 + 889) = v11 == 1;
  if (v11 != 1)
  {
    v37 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(a1 + 880));
    (*(void (**)(_BYTE *__return_ptr, _QWORD))(**(_QWORD **)(a1 + 872) + 24))(buf, *(_QWORD *)(a1 + 872));
    v19 = *(unsigned __int8 *)(*(_QWORD *)buf + 3);
    if (v19 == 254)
    {
      v20 = *(unsigned __int8 *)(*(_QWORD *)buf + 5);
      if (v20 != 254)
        goto LABEL_35;
    }
    else if (v19 == 1)
    {
      v20 = *(unsigned __int8 *)(*(_QWORD *)buf + 5);
LABEL_35:
      v21 = v20 == 254 || v20 == 1;
LABEL_41:
      v23 = *(std::__shared_weak_count **)&buf[8];
      if (*(_QWORD *)&buf[8])
      {
        v24 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
        do
          v25 = __ldaxr(v24);
        while (__stlxr(v25 - 1, v24));
        if (!v25)
        {
          ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
          std::__shared_weak_count::__release_weak(v23);
        }
      }
      if (!v37)
        goto LABEL_50;
      v26 = (unint64_t *)&v37->__shared_owners_;
      do
        v27 = __ldaxr(v26);
      while (__stlxr(v27 - 1, v26));
      if (!v27)
      {
        ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
        std::__shared_weak_count::__release_weak(v37);
        if (!v21)
        {
LABEL_51:
          if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315650;
            *(_QWORD *)&buf[4] = "Profile not configured";
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "/Library/Caches/com.apple.xbs/Sources/CoreTelephony/CommCenter/CommCenterCommandDriver"
                                  "s/Data/QMI/Context/Mav16QMIDataContextIP.cpp";
            v40 = 1024;
            v41 = 174;
            _os_log_error_impl(&dword_216897000, MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR, "\n**********\n   ASSERT getProfileManager()->getProfileInfo()->isProfileConfigured()\n %s\n at %s:%d\n**********", buf, 0x1Cu);
          }
          v38 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(a1 + 880));
          (*(void (**)(_BYTE *__return_ptr, _QWORD))(**(_QWORD **)(a1 + 872) + 24))(buf, *(_QWORD *)(a1 + 872));
          v28 = *(unsigned __int8 *)(*(_QWORD *)buf + 3);
          if (v28 == 254)
          {
            v29 = *(unsigned __int8 *)(*(_QWORD *)buf + 5);
            if (v29 != 254)
              goto LABEL_60;
          }
          else if (v28 == 1)
          {
            v29 = *(unsigned __int8 *)(*(_QWORD *)buf + 5);
LABEL_60:
            v30 = v29 == 254 || v29 == 1;
            goto LABEL_66;
          }
          v30 = 0;
LABEL_66:
          v32 = *(std::__shared_weak_count **)&buf[8];
          if (*(_QWORD *)&buf[8])
          {
            v33 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
            do
              v34 = __ldaxr(v33);
            while (__stlxr(v34 - 1, v33));
            if (!v34)
            {
              ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
              std::__shared_weak_count::__release_weak(v32);
            }
          }
          if (v38)
          {
            v35 = (unint64_t *)&v38->__shared_owners_;
            do
              v36 = __ldaxr(v35);
            while (__stlxr(v36 - 1, v35));
            if (!v36)
            {
              ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
              std::__shared_weak_count::__release_weak(v38);
            }
          }
          if (!v30)
            __TUAssertTrigger();
        }
      }
      else
      {
LABEL_50:
        if (!v21)
          goto LABEL_51;
      }
      Mav16QMIDataContextIP::activateDataContextIPAfterProfileConfiguration(a1, *(_DWORD *)(a1 + 284), a2);
      return;
    }
    v21 = 0;
    goto LABEL_41;
  }
  v18 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315138;
    *(_QWORD *)&buf[4] = "activateDataContextIPAfterProfileCreation";
    _os_log_impl(&dword_216897000, v18, OS_LOG_TYPE_DEFAULT, "#I %s: Profile configuration pending...", buf, 0xCu);
  }
  *(_BYTE *)(a1 + 890) = a2;
}

void sub_2169FA9E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void Mav16QMIDataContextIP::handleProfileCreated(Mav16QMIDataContextIP *this, int a2)
{
  NSObject *v4;
  NSObject *v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  _BYTE v9[22];
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v4 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)v9 = 136315394;
    *(_QWORD *)&v9[4] = "handleProfileCreated";
    *(_WORD *)&v9[12] = 2080;
    *(_QWORD *)&v9[14] = asStringBool();
    _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I %s: profile created: %s", v9, 0x16u);
  }
  if (*((_BYTE *)this + 888)
    && (*(unsigned int (**)(Mav16QMIDataContextIP *))(*(_QWORD *)this + 96))(this) == 4)
  {
    *((_BYTE *)this + 888) = 0;
    if (a2)
    {
      Mav16QMIDataContextIP::activateDataContextIPAfterProfileCreation((uint64_t)this, *((unsigned __int8 *)this + 890), 1);
    }
    else
    {
      QMIDataContextIPBase::setDataContextIPState((uint64_t)this, 1u);
      v6 = std::__shared_weak_count::lock(*((std::__shared_weak_count **)this + 13));
      *(_QWORD *)v9 = *((_QWORD *)this + 12);
      *(_QWORD *)&v9[8] = v6;
      (*(void (**)(_QWORD, _QWORD, uint64_t, _QWORD, _QWORD, uint64_t, _QWORD))(**(_QWORD **)v9 + 64))(*(_QWORD *)v9, *((unsigned int *)this + 35), 18, 0, 0, 2, 0);
      p_shared_owners = (unint64_t *)&v6->__shared_owners_;
      do
        v8 = __ldaxr(p_shared_owners);
      while (__stlxr(v8 - 1, p_shared_owners));
      if (!v8)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
  }
  else
  {
    v5 = *((_QWORD *)this + 5);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)v9 = 136315138;
      *(_QWORD *)&v9[4] = "handleProfileCreated";
      _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#I %s: Not waiting for profile creation, nothing to be done", v9, 0xCu);
    }
  }
}

void sub_2169FABF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'Mav16QMIDataContextIP::handleProfileCreated(Mav16QMIDataContextIP *this, int a2)
{
  Mav16QMIDataContextIP::handleProfileCreated((Mav16QMIDataContextIP *)((char *)this - 864), a2);
}

void Mav16QMIDataContextIP::handleProfileConfigured(Mav16QMIDataContextIP *this, int a2)
{
  NSObject *v4;
  NSObject *v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  __int128 v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  if (*((_BYTE *)this + 889)
    && (*(unsigned int (**)(Mav16QMIDataContextIP *))(*(_QWORD *)this + 96))(this) == 4)
  {
    *((_BYTE *)this + 889) = 0;
    if (a2)
    {
      Mav16QMIDataContextIP::activateDataContextIPAfterProfileConfiguration((uint64_t)this, *((_DWORD *)this + 71), *((unsigned __int8 *)this + 890));
    }
    else
    {
      v5 = *((_QWORD *)this + 5);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(v9) = 136315138;
        *(_QWORD *)((char *)&v9 + 4) = "handleProfileConfigured";
        _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#I %s: Profile configuration failed", (uint8_t *)&v9, 0xCu);
      }
      QMIDataContextIPBase::setDataContextIPState((uint64_t)this, 1u);
      v6 = std::__shared_weak_count::lock(*((std::__shared_weak_count **)this + 13));
      *(_QWORD *)&v9 = *((_QWORD *)this + 12);
      *((_QWORD *)&v9 + 1) = v6;
      (*(void (**)(_QWORD, _QWORD, uint64_t, _QWORD, _QWORD, uint64_t, _QWORD))(*(_QWORD *)v9 + 64))(v9, *((unsigned int *)this + 35), 18, 0, 0, 2, 0);
      p_shared_owners = (unint64_t *)&v6->__shared_owners_;
      do
        v8 = __ldaxr(p_shared_owners);
      while (__stlxr(v8 - 1, p_shared_owners));
      if (!v8)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
  }
  else
  {
    v4 = *((_QWORD *)this + 5);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v9) = 136315138;
      *(_QWORD *)((char *)&v9 + 4) = "handleProfileConfigured";
      _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I %s: Not waiting for profile configuration, nothing to be done", (uint8_t *)&v9, 0xCu);
    }
  }
}

void sub_2169FADE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void Mav16QMIDataContextIP::activateDataContextIPAfterProfileConfiguration(uint64_t a1, char a2, int a3)
{
  NSObject *v6;
  std::__shared_weak_count *v7;
  _BYTE *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  std::__shared_weak_count *v11;
  capabilities::ct *v12;
  unint64_t *v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  NSObject *v21;
  uint64_t v22;
  unint64_t *v23;
  unint64_t v24;
  char *v25;
  const void **v26;
  char *v27;
  _QWORD *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  _QWORD *v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  char *v36;
  uint64_t *v37;
  char *v38;
  char *v39;
  char *v40;
  uint64_t v41;
  void *v42;
  std::__shared_weak_count *v43;
  unint64_t *v44;
  unint64_t v45;
  std::__shared_weak_count *v46;
  unint64_t *v47;
  unint64_t v48;
  uint64_t v49;
  unint64_t *v50;
  unint64_t v51;
  char *v52;
  std::__shared_weak_count *v53;
  unint64_t *v54;
  unint64_t v55;
  unint64_t *v56;
  unint64_t v57;
  const void **v58;
  char *v59;
  _BYTE *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  _QWORD *v64;
  uint64_t v65;
  unint64_t v66;
  unint64_t v67;
  char *v68;
  uint64_t *v69;
  char *v70;
  char *v71;
  char *v72;
  uint64_t v73;
  std::__shared_weak_count *v74;
  unint64_t *v75;
  unint64_t v76;
  std::__shared_weak_count *v77;
  unint64_t *v78;
  unint64_t v79;
  unint64_t *v80;
  unint64_t v81;
  uint64_t v82;
  std::__shared_weak_count *v83;
  capabilities::ct *v84;
  int v85;
  unint64_t *v86;
  unint64_t v87;
  int v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  NSObject *v92;
  uint64_t v93;
  capabilities::ct *v94;
  std::__shared_weak_count *v95;
  int v96;
  unint64_t *v97;
  unint64_t v98;
  std::__shared_weak_count *v99;
  uint64_t v100;
  unint64_t *v101;
  unint64_t v102;
  NSObject *v103;
  const void **v104;
  int v105;
  int v106;
  NSObject *v107;
  NSObject *v108;
  _BOOL8 v109;
  uint64_t v110;
  uint64_t v111;
  std::__shared_weak_count *v112;
  void *v113;
  unint64_t *v114;
  unint64_t v115;
  int isZeroIP;
  NSObject *v117;
  _BOOL8 v118;
  void *v119;
  const char *v120;
  std::__shared_weak_count *v121;
  void *v122;
  unint64_t *v123;
  unint64_t v124;
  int v125;
  _BOOL8 v126;
  void *v127;
  void *v128;
  uint64_t v129;
  int v130;
  void **v131;
  int PrefixLen;
  void **v133;
  char *v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  _QWORD *v138;
  void **v139;
  char *v140;
  const void **v141;
  const __CFBoolean *v142;
  uint64_t (*v143)(uint64_t);
  _BOOL4 v144;
  uint64_t v145;
  unint64_t v146;
  unint64_t v147;
  char *v148;
  NSObject *v149;
  uint64_t v150;
  uint64_t v151;
  capabilities::ct *v152;
  int v153;
  std::__shared_weak_count *v154;
  unint64_t *v155;
  unint64_t v156;
  std::__shared_weak_count *v157;
  unint64_t *v158;
  unint64_t v159;
  void *v160;
  std::__shared_weak_count *v161;
  unint64_t *v162;
  unint64_t v163;
  NSObject *v164;
  _BYTE *v165;
  uint64_t *v166;
  char *v167;
  char *v168;
  char *v169;
  uint64_t v170;
  _QWORD v171[5];
  _QWORD v172[2];
  uint64_t (*v173)(uint64_t, _BYTE *);
  void *v174;
  uint64_t v175;
  std::__shared_weak_count *v176;
  _QWORD v177[2];
  uint64_t (*v178)(uint64_t, char *);
  void *v179;
  uint64_t v180;
  std::__shared_weak_count *v181;
  __int128 v182;
  __int128 v183;
  _QWORD v184[5];
  _QWORD v185[2];
  uint64_t (*v186)(uint64_t, char *);
  void *v187;
  uint64_t v188;
  std::__shared_weak_count *v189;
  uint64_t v190;
  std::__shared_weak_count *v191;
  _QWORD v192[6];
  int v193;
  _QWORD v194[2];
  void (*v195)(uint64_t, _QWORD *);
  void *v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  void (*v201)(uint64_t, char *);
  void *v202;
  uint64_t v203;
  uint64_t *v204;
  std::__shared_weak_count *v205;
  uint64_t *v206;
  std::__shared_weak_count *v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t (*v210)(uint64_t, unsigned __int8 *);
  void *v211;
  void *v212;
  BOOL *v213;
  void *v214;
  void *v215;
  uint64_t v216;
  __int128 buf;
  __int128 v218;
  uint64_t v219;
  _BYTE aBlock[24];
  void *v221;
  _QWORD *v222;
  _BYTE v223[18];
  uint8_t v224[24];
  uint64_t v225;

  v225 = *MEMORY[0x24BDAC8D0];
  v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    v7 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(a1 + 104));
    v208 = *(_QWORD *)(a1 + 96);
    v209 = (uint64_t)v7;
    (*(void (**)(_BYTE *__return_ptr))(*(_QWORD *)v208 + 304))(aBlock);
    if (aBlock[23] >= 0)
      v8 = aBlock;
    else
      v8 = *(_BYTE **)aBlock;
    LODWORD(buf) = 136446210;
    *(_QWORD *)((char *)&buf + 4) = v8;
    _os_log_impl(&dword_216897000, v6, OS_LOG_TYPE_DEFAULT, "#I activateDataContextIPAfterProfileConfiguration: start apn=%{public}s", (uint8_t *)&buf, 0xCu);
    if ((aBlock[23] & 0x80000000) != 0)
      operator delete(*(void **)aBlock);
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v10 = __ldaxr(p_shared_owners);
    while (__stlxr(v10 - 1, p_shared_owners));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  v190 = 0;
  v191 = 0;
  v11 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(a1 + 880));
  *(_QWORD *)aBlock = *(_QWORD *)(a1 + 872);
  *(_QWORD *)&aBlock[8] = v11;
  v12 = (capabilities::ct *)(*(_QWORD *(**)(uint64_t *__return_ptr))(**(_QWORD **)aBlock + 24))(&v190);
  v13 = (unint64_t *)&v11->__shared_owners_;
  do
    v14 = __ldaxr(v13);
  while (__stlxr(v14 - 1, v13));
  if (!v14)
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  if (capabilities::ct::supports5G(v12))
  {
    v199 = 0;
    v200 = 0;
    v15 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(a1 + 104));
    *(_QWORD *)aBlock = *(_QWORD *)(a1 + 96);
    *(_QWORD *)&aBlock[8] = v15;
    (*(void (**)(uint64_t *__return_ptr))(**(_QWORD **)aBlock + 240))(&v199);
    v16 = (unint64_t *)&v15->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
    if (!v199 || *(unsigned __int8 *)(v190 + 3) == 254)
    {
      v18 = (std::__shared_weak_count *)v200;
      if (v200)
      {
        v19 = (unint64_t *)(v200 + 8);
        do
          v20 = __ldaxr(v19);
        while (__stlxr(v20 - 1, v19));
        if (!v20)
        {
          ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
          std::__shared_weak_count::__release_weak(v18);
        }
      }
      goto LABEL_245;
    }
    if ((*(unsigned int (**)(void))(*(_QWORD *)v199 + 184))())
    {
      v21 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)aBlock = 0;
        _os_log_impl(&dword_216897000, v21, OS_LOG_TYPE_DEFAULT, "#I Suppress PDN tear-down", aBlock, 2u);
      }
      buf = 0u;
      v218 = 0u;
      qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)&buf);
      v22 = MEMORY[0x24BDAC760];
      v185[0] = MEMORY[0x24BDAC760];
      v185[1] = 1174405120;
      v186 = ___ZN21Mav16QMIDataContextIP46activateDataContextIPAfterProfileConfigurationE18DataProtocolFamilyb_block_invoke;
      v187 = &__block_descriptor_tmp_34;
      v188 = v190;
      v189 = v191;
      if (v191)
      {
        v23 = (unint64_t *)&v191->__shared_owners_;
        do
          v24 = __ldxr(v23);
        while (__stxr(v24 + 1, v23));
      }
      v25 = qmi::MutableMessageBase::getTLV<wds::tlv::Profile3GPP_ProfileIdentifier>(&buf, 16);
      v186((uint64_t)v185, v25);
      v26 = (const void **)*((_QWORD *)&buf + 1);
      if (*((_QWORD *)&buf + 1) != (_QWORD)v218)
      {
        while (*((_BYTE *)*v26 + 8) != 17)
        {
          if (++v26 == (const void **)v218)
            goto LABEL_40;
        }
      }
      if (v26 == (const void **)v218)
      {
LABEL_40:
        v29 = operator new();
        v30 = v29;
        *(_BYTE *)(v29 + 8) = 17;
        *(_QWORD *)v29 = &off_24D5DE510;
        *(_QWORD *)(v29 + 16) = 0;
        v28 = (_QWORD *)(v29 + 16);
        v31 = v218;
        if ((unint64_t)v218 >= *((_QWORD *)&v218 + 1))
        {
          v33 = (uint64_t)(v218 - *((_QWORD *)&buf + 1)) >> 3;
          if ((unint64_t)(v33 + 1) >> 61)
            std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
          v34 = (uint64_t)(*((_QWORD *)&v218 + 1) - *((_QWORD *)&buf + 1)) >> 2;
          if (v34 <= v33 + 1)
            v34 = v33 + 1;
          if (*((_QWORD *)&v218 + 1) - *((_QWORD *)&buf + 1) >= 0x7FFFFFFFFFFFFFF8uLL)
            v35 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v35 = v34;
          if (v35)
            v36 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v218 + 8, v35);
          else
            v36 = 0;
          v37 = (uint64_t *)&v36[8 * v33];
          v38 = &v36[8 * v35];
          *v37 = v30;
          v32 = v37 + 1;
          v39 = (char *)v218;
          v40 = (char *)*((_QWORD *)&buf + 1);
          if ((_QWORD)v218 != *((_QWORD *)&buf + 1))
          {
            do
            {
              v41 = *((_QWORD *)v39 - 1);
              v39 -= 8;
              *--v37 = v41;
            }
            while (v39 != v40);
            v39 = (char *)*((_QWORD *)&buf + 1);
          }
          *((_QWORD *)&buf + 1) = v37;
          *(_QWORD *)&v218 = v32;
          *((_QWORD *)&v218 + 1) = v38;
          if (v39)
            operator delete(v39);
        }
        else
        {
          *(_QWORD *)v218 = v29;
          v32 = (_QWORD *)(v31 + 8);
        }
        *(_QWORD *)&v218 = v32;
      }
      else
      {
        if (!v27)
          __cxa_bad_cast();
        v28 = v27 + 16;
      }
      *v28 = 0x8000000000000000;
      v208 = a1 + 144;
      v209 = QMIServiceMsg::create();
      v211 = (void *)(a1 + 176);
      v212 = 0;
      LODWORD(v210) = 210000;
      v184[0] = v22;
      v184[1] = 0x40000000;
      v184[2] = ___ZN21Mav16QMIDataContextIP46activateDataContextIPAfterProfileConfigurationE18DataProtocolFamilyb_block_invoke_2;
      v184[3] = &__block_descriptor_tmp_13_12;
      v184[4] = a1;
      *(_QWORD *)aBlock = v22;
      *(_QWORD *)&aBlock[8] = 0x40000000;
      *(_QWORD *)&aBlock[16] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3wds14SetAlwaysOnPdu8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
      v221 = &unk_24D5DE540;
      v222 = v184;
      v42 = _Block_copy(aBlock);
      v212 = v42;
      if (v209)
      {
        qmi::Client::send();
        v42 = v212;
      }
      if (v42)
        _Block_release(v42);
      v43 = v189;
      if (v189)
      {
        v44 = (unint64_t *)&v189->__shared_owners_;
        do
          v45 = __ldaxr(v44);
        while (__stlxr(v45 - 1, v44));
        if (!v45)
        {
          ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
          std::__shared_weak_count::__release_weak(v43);
        }
      }
      qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&buf);
    }
    v46 = (std::__shared_weak_count *)v200;
    if (v200)
    {
      v47 = (unint64_t *)(v200 + 8);
      do
        v48 = __ldaxr(v47);
      while (__stlxr(v48 - 1, v47));
      if (!v48)
      {
        ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
        std::__shared_weak_count::__release_weak(v46);
      }
    }
  }
  v182 = 0u;
  v183 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)&v182);
  v49 = MEMORY[0x24BDAC760];
  if (*(unsigned __int8 *)(v190 + 3) != 254)
  {
    v177[0] = MEMORY[0x24BDAC760];
    v177[1] = 1174405120;
    v178 = ___ZN21Mav16QMIDataContextIP46activateDataContextIPAfterProfileConfigurationE18DataProtocolFamilyb_block_invoke_14;
    v179 = &__block_descriptor_tmp_15_20;
    v180 = v190;
    v181 = v191;
    if (v191)
    {
      v50 = (unint64_t *)&v191->__shared_owners_;
      do
        v51 = __ldxr(v50);
      while (__stxr(v51 + 1, v50));
    }
    v52 = qmi::MutableMessageBase::getTLV<wds::tlv::Profile3GPP_ProfileIdentifier>(&v182, 49);
    v178((uint64_t)v177, v52);
    v53 = v181;
    if (v181)
    {
      v54 = (unint64_t *)&v181->__shared_owners_;
      do
        v55 = __ldaxr(v54);
      while (__stlxr(v55 - 1, v54));
      if (!v55)
      {
        ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
        std::__shared_weak_count::__release_weak(v53);
      }
    }
  }
  if (*(unsigned __int8 *)(v190 + 5) != 254)
  {
    v172[0] = v49;
    v172[1] = 1174405120;
    v173 = ___ZN21Mav16QMIDataContextIP46activateDataContextIPAfterProfileConfigurationE18DataProtocolFamilyb_block_invoke_16;
    v174 = &__block_descriptor_tmp_18_16;
    v175 = v190;
    v176 = v191;
    if (v191)
    {
      v56 = (unint64_t *)&v191->__shared_owners_;
      do
        v57 = __ldxr(v56);
      while (__stxr(v57 + 1, v56));
    }
    v58 = (const void **)*((_QWORD *)&v182 + 1);
    if (*((_QWORD *)&v182 + 1) != (_QWORD)v183)
    {
      while (*((_BYTE *)*v58 + 8) != 50)
      {
        if (++v58 == (const void **)v183)
          goto LABEL_92;
      }
    }
    if (v58 == (const void **)v183)
    {
LABEL_92:
      v61 = operator new();
      v62 = v61;
      *(_WORD *)(v61 + 8) = 50;
      *(_QWORD *)v61 = &off_24D5DE588;
      v63 = v183;
      if ((unint64_t)v183 >= *((_QWORD *)&v183 + 1))
      {
        v65 = (uint64_t)(v183 - *((_QWORD *)&v182 + 1)) >> 3;
        if ((unint64_t)(v65 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v66 = (uint64_t)(*((_QWORD *)&v183 + 1) - *((_QWORD *)&v182 + 1)) >> 2;
        if (v66 <= v65 + 1)
          v66 = v65 + 1;
        if (*((_QWORD *)&v183 + 1) - *((_QWORD *)&v182 + 1) >= 0x7FFFFFFFFFFFFFF8uLL)
          v67 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v67 = v66;
        if (v67)
          v68 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v183 + 8, v67);
        else
          v68 = 0;
        v69 = (uint64_t *)&v68[8 * v65];
        v70 = &v68[8 * v67];
        *v69 = v62;
        v64 = v69 + 1;
        v72 = (char *)*((_QWORD *)&v182 + 1);
        v71 = (char *)v183;
        if ((_QWORD)v183 != *((_QWORD *)&v182 + 1))
        {
          do
          {
            v73 = *((_QWORD *)v71 - 1);
            v71 -= 8;
            *--v69 = v73;
          }
          while (v71 != v72);
          v71 = (char *)*((_QWORD *)&v182 + 1);
        }
        *((_QWORD *)&v182 + 1) = v69;
        *(_QWORD *)&v183 = v64;
        *((_QWORD *)&v183 + 1) = v70;
        if (v71)
          operator delete(v71);
      }
      else
      {
        *(_QWORD *)v183 = v61;
        v64 = (_QWORD *)(v63 + 8);
      }
      v60 = (_BYTE *)(v62 + 9);
      *(_QWORD *)&v183 = v64;
    }
    else
    {
      if (!v59)
        __cxa_bad_cast();
      v60 = v59 + 9;
    }
    v173((uint64_t)v172, v60);
    v74 = v176;
    if (v176)
    {
      v75 = (unint64_t *)&v176->__shared_owners_;
      do
        v76 = __ldaxr(v75);
      while (__stlxr(v76 - 1, v75));
      if (!v76)
      {
        ((void (*)(std::__shared_weak_count *))v74->__on_zero_shared)(v74);
        std::__shared_weak_count::__release_weak(v74);
      }
    }
  }
  v77 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(a1 + 104));
  *(_QWORD *)aBlock = *(_QWORD *)(a1 + 96);
  *(_QWORD *)&aBlock[8] = v77;
  v206 = 0;
  v207 = 0;
  (*(void (**)(uint64_t **__return_ptr))(**(_QWORD **)aBlock + 240))(&v206);
  v78 = (unint64_t *)&v77->__shared_owners_;
  do
    v79 = __ldaxr(v78);
  while (__stlxr(v79 - 1, v78));
  if (!v79)
  {
    ((void (*)(std::__shared_weak_count *))v77->__on_zero_shared)(v77);
    std::__shared_weak_count::__release_weak(v77);
  }
  if (v206)
  {
    v199 = v49;
    v200 = 1174405120;
    v201 = ___ZN21Mav16QMIDataContextIP26setDataExtensionParametersERN3wds19StartNetworkIfaceV27RequestE18DataProtocolFamilyb_block_invoke;
    v202 = &__block_descriptor_tmp_22_13;
    v203 = a1;
    v204 = v206;
    v205 = v207;
    if (v207)
    {
      v80 = (unint64_t *)&v207->__shared_owners_;
      do
        v81 = __ldxr(v80);
      while (__stxr(v81 + 1, v80));
    }
    v82 = qmi::MutableMessageBase::getTLV<wds::tlv::CallType>(&v182, 53);
    v201((uint64_t)&v199, (char *)v82);
    v83 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(a1 + 104));
    *(_QWORD *)aBlock = *(_QWORD *)(a1 + 96);
    *(_QWORD *)&aBlock[8] = v83;
    v84 = (capabilities::ct *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)aBlock + 248))(*(_QWORD *)aBlock);
    v85 = (int)v84;
    v86 = (unint64_t *)&v83->__shared_owners_;
    do
      v87 = __ldaxr(v86);
    while (__stlxr(v87 - 1, v86));
    if (!v87)
    {
      ((void (*)(std::__shared_weak_count *))v83->__on_zero_shared)(v83);
      std::__shared_weak_count::__release_weak(v83);
    }
    v88 = capabilities::ct::supportsDataQMIExtensions(v84);
    v89 = *v206;
    if (v88)
    {
      v90 = (*(uint64_t (**)(void))(v89 + 216))();
      v91 = (*(uint64_t (**)(uint64_t *, uint64_t, _QWORD, _QWORD))(*v206 + 216))(v206, 1, 0, 0) | v90;
      v92 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v92, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)aBlock = 136315394;
        *(_QWORD *)&aBlock[4] = "setDataExtensionParameters";
        *(_WORD *)&aBlock[12] = 2048;
        *(_QWORD *)&aBlock[14] = v91;
        _os_log_impl(&dword_216897000, v92, OS_LOG_TYPE_DEFAULT, "#I %s: Applying ApnTypeMask tlv connectionMask=%llu", aBlock, 0x16u);
      }
      v194[0] = v49;
      v194[1] = 0x40000000;
      v195 = ___ZN21Mav16QMIDataContextIP26setDataExtensionParametersERN3wds19StartNetworkIfaceV27RequestE18DataProtocolFamilyb_block_invoke_23;
      v196 = &__block_descriptor_tmp_25_8;
      v197 = a1;
      v198 = v91;
      v93 = qmi::MutableMessageBase::getTLV<wds::tlv::ApnTypeMask>(&v182, 62);
      v94 = (capabilities::ct *)((uint64_t (*)(_QWORD *, uint64_t))v195)(v194, v93);
      if (a3
        && capabilities::ct::supports5G(v94)
        && (*(unsigned int (**)(uint64_t *))(*v206 + 192))(v206))
      {
        v95 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(a1 + 104));
        *(_QWORD *)aBlock = *(_QWORD *)(a1 + 96);
        *(_QWORD *)&aBlock[8] = v95;
        v96 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)aBlock + 280))(*(_QWORD *)aBlock);
        v97 = (unint64_t *)&v95->__shared_owners_;
        do
          v98 = __ldaxr(v97);
        while (__stlxr(v98 - 1, v97));
        if (!v98)
        {
          ((void (*)(std::__shared_weak_count *))v95->__on_zero_shared)(v95);
          std::__shared_weak_count::__release_weak(v95);
        }
        v99 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(a1 + 104));
        *(_QWORD *)aBlock = *(_QWORD *)(a1 + 96);
        *(_QWORD *)&aBlock[8] = v99;
        v100 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)aBlock + 296))(*(_QWORD *)aBlock);
        v101 = (unint64_t *)&v99->__shared_owners_;
        do
          v102 = __ldaxr(v101);
        while (__stlxr(v102 - 1, v101));
        if (!v102)
        {
          ((void (*)(std::__shared_weak_count *))v99->__on_zero_shared)(v99);
          std::__shared_weak_count::__release_weak(v99);
        }
        v103 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v103, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)aBlock = 67109120;
          *(_DWORD *)&aBlock[4] = v96;
          _os_log_impl(&dword_216897000, v103, OS_LOG_TYPE_DEFAULT, "#I Applying ExtendedHandoffContext pduSessionId=%d", aBlock, 8u);
        }
        if ((v96 & 0x80000000) == 0)
        {
          v192[0] = v49;
          v192[1] = 0x40000000;
          v192[2] = ___ZN21Mav16QMIDataContextIP26setDataExtensionParametersERN3wds19StartNetworkIfaceV27RequestE18DataProtocolFamilyb_block_invoke_26;
          v192[3] = &__block_descriptor_tmp_28_10;
          v193 = v96;
          v192[4] = a1;
          v192[5] = v100;
          v104 = (const void **)*((_QWORD *)&v182 + 1);
          if (*((_QWORD *)&v182 + 1) != (_QWORD)v183)
          {
            while (*((_BYTE *)*v104 + 8) != 63)
            {
              if (++v104 == (const void **)v183)
                goto LABEL_196;
            }
          }
          if (v104 == (const void **)v183)
          {
LABEL_196:
            v135 = operator new();
            v136 = v135;
            *(_BYTE *)(v135 + 8) = 63;
            *(_QWORD *)v135 = off_24D5DE600;
            *(_QWORD *)(v135 + 16) = 0;
            v129 = v135 + 16;
            *(_QWORD *)(v135 + 23) = 0;
            *(_QWORD *)(v135 + 40) = 0;
            *(_QWORD *)(v135 + 48) = 0;
            *(_QWORD *)(v135 + 32) = 0;
            *(_BYTE *)(v135 + 56) = 0;
            v137 = v183;
            if ((unint64_t)v183 >= *((_QWORD *)&v183 + 1))
            {
              v145 = (uint64_t)(v183 - *((_QWORD *)&v182 + 1)) >> 3;
              if ((unint64_t)(v145 + 1) >> 61)
                std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
              v146 = (uint64_t)(*((_QWORD *)&v183 + 1) - *((_QWORD *)&v182 + 1)) >> 2;
              if (v146 <= v145 + 1)
                v146 = v145 + 1;
              if (*((_QWORD *)&v183 + 1) - *((_QWORD *)&v182 + 1) >= 0x7FFFFFFFFFFFFFF8uLL)
                v147 = 0x1FFFFFFFFFFFFFFFLL;
              else
                v147 = v146;
              if (v147)
                v148 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v183 + 8, v147);
              else
                v148 = 0;
              v166 = (uint64_t *)&v148[8 * v145];
              v167 = &v148[8 * v147];
              *v166 = v136;
              v138 = v166 + 1;
              v169 = (char *)*((_QWORD *)&v182 + 1);
              v168 = (char *)v183;
              if ((_QWORD)v183 != *((_QWORD *)&v182 + 1))
              {
                do
                {
                  v170 = *((_QWORD *)v168 - 1);
                  v168 -= 8;
                  *--v166 = v170;
                }
                while (v168 != v169);
                v168 = (char *)*((_QWORD *)&v182 + 1);
              }
              *((_QWORD *)&v182 + 1) = v166;
              *(_QWORD *)&v183 = v138;
              *((_QWORD *)&v183 + 1) = v167;
              if (v168)
                operator delete(v168);
            }
            else
            {
              *(_QWORD *)v183 = v135;
              v138 = (_QWORD *)(v137 + 8);
            }
            *(_QWORD *)&v183 = v138;
          }
          else
          {
            if (!v128)
              __cxa_bad_cast();
            v129 = (uint64_t)v128 + 16;
          }
          ___ZN21Mav16QMIDataContextIP26setDataExtensionParametersERN3wds19StartNetworkIfaceV27RequestE18DataProtocolFamilyb_block_invoke_26((uint64_t)v192, v129);
        }
      }
    }
    else
    {
      v105 = (*(uint64_t (**)(void))(v89 + 56))();
      if (v85 == 2)
        v106 = 0;
      else
        v106 = v105;
      if (v106 == 1)
      {
        v107 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v107, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)aBlock = 136315138;
          *(_QWORD *)&aBlock[4] = "setDataExtensionParameters";
          _os_log_impl(&dword_216897000, v107, OS_LOG_TYPE_DEFAULT, "#I %s: Applying IDataCall tlv", aBlock, 0xCu);
        }
        *(_BYTE *)qmi::MutableMessageBase::getTLV<wds::tlv::IDataCall>(&v182, 194) = 1;
      }
    }
    if (v85 != 4 && !is5GDataTechnology())
      goto LABEL_230;
    v108 = *(NSObject **)(a1 + 40);
    v109 = os_log_type_enabled(v108, OS_LOG_TYPE_DEFAULT);
    if (v109)
    {
      v110 = asStringBool();
      v111 = asString();
      *(_DWORD *)v224 = 136315394;
      *(_QWORD *)&v224[4] = v110;
      *(_WORD *)&v224[12] = 2080;
      *(_QWORD *)&v224[14] = v111;
      _os_log_impl(&dword_216897000, v108, OS_LOG_TYPE_DEFAULT, "#I setHandoverAddress: handover: %s, allowedIpFamily: %s", v224, 0x16u);
    }
    if (!a3 || !capabilities::ct::supportsHandoverPDN((capabilities::ct *)v109))
      goto LABEL_228;
    if ((a2 & 2) != 0 && *(_DWORD *)(a1 + 140) == 2)
    {
      memset(v224, 0, sizeof(v224));
      v112 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(a1 + 104));
      v113 = *(void **)(a1 + 96);
      v215 = v112;
      v214 = v113;
      (*(void (**)(uint8_t *__return_ptr, void *, uint64_t))(*(_QWORD *)v113 + 216))(v224, v113, 2);
      v114 = (unint64_t *)&v112->__shared_owners_;
      do
        v115 = __ldaxr(v114);
      while (__stlxr(v115 - 1, v114));
      if (!v115)
      {
        ((void (*)(std::__shared_weak_count *))v112->__on_zero_shared)(v112);
        std::__shared_weak_count::__release_weak(v112);
      }
      isZeroIP = CSIPacketAddress::isZeroIP((CSIPacketAddress *)v224);
      v117 = *(NSObject **)(a1 + 40);
      v118 = os_log_type_enabled(v117, OS_LOG_TYPE_DEFAULT);
      if (isZeroIP)
      {
        if (v118)
        {
          CSIPacketAddress::operator std::string();
          if (v216 >= 0)
            v119 = &v214;
          else
            v119 = v214;
          *(_DWORD *)v223 = 136315138;
          *(_QWORD *)&v223[4] = v119;
          v120 = "#E IPv6Service: ** ipv6Addr: %s handover impossible, going with regular activation";
          goto LABEL_184;
        }
        goto LABEL_228;
      }
      if (v118)
      {
        CSIPacketAddress::operator std::string();
        v130 = SHIBYTE(v216);
        v131 = (void **)v214;
        PrefixLen = CSIPacketAddress::getPrefixLen((CSIPacketAddress *)v224);
        v133 = &v214;
        if (v130 < 0)
          v133 = v131;
        *(_DWORD *)v223 = 136315394;
        *(_QWORD *)&v223[4] = v133;
        *(_WORD *)&v223[12] = 1024;
        *(_DWORD *)&v223[14] = PrefixLen;
        _os_log_impl(&dword_216897000, v117, OS_LOG_TYPE_DEFAULT, "#I IPv6Service: ** ipv6Addr: %s, prefixLen: %d", v223, 0x12u);
        if (SHIBYTE(v216) < 0)
          operator delete(v214);
      }
      if (capabilities::ct::supportsDataQMIExtensions((capabilities::ct *)v118))
      {
        *(_QWORD *)aBlock = v49;
        *(_QWORD *)&aBlock[8] = 1174405120;
        *(_QWORD *)&aBlock[16] = ___ZN21Mav16QMIDataContextIP18setHandoverAddressERN3wds19StartNetworkIfaceV27RequestE18DataProtocolFamilyb_block_invoke;
        v221 = &__block_descriptor_tmp_37_10;
        CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)&v222, (const CSIPacketAddress *)v224);
        v134 = qmi::MutableMessageBase::getTLV<wds::tlv::HandOverContext>(&v182);
        (*(void (**)(_BYTE *, char *))&aBlock[16])(aBlock, v134);
      }
      else
      {
        v215 = 0;
        v214 = 0;
        v216 = 0;
        *(_QWORD *)v223 = *MEMORY[0x24BDC3EB8];
        *(_QWORD *)&v223[8] = CFSTR("SetHandOverIPv6Prefix");
        std::vector<__CFString const*>::vector[abi:ne180100](&v214, v223, 2uLL);
        v213 = 0;
        (*(void (**)(_BYTE *__return_ptr, _QWORD, void **, _QWORD, _QWORD))(**(_QWORD **)(a1 + 616) + 96))(v223, *(_QWORD *)(a1 + 616), &v214, *MEMORY[0x24BDBD268], 0);
        ctu::cf::CFSharedRef<__CFBoolean const>::CFSharedRef<void const,void>(&v213, (CFTypeRef *)v223);
        v141 = ctu::SharedRef<void const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,void const>::~SharedRef((const void **)v223);
        v143 = ctu::SharedRef<__CFBoolean const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFBoolean const>::get;
        if (!v213)
          v143 = 0;
        if (v143)
        {
          v223[0] = 0;
          ctu::cf::assign((ctu::cf *)v141, v213, v142);
          v144 = v223[0] != 0;
        }
        else
        {
          v144 = 0;
        }
        v149 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v149, OS_LOG_TYPE_DEFAULT))
        {
          v150 = asStringBool();
          *(_DWORD *)v223 = 136315138;
          *(_QWORD *)&v223[4] = v150;
          _os_log_impl(&dword_216897000, v149, OS_LOG_TYPE_DEFAULT, "#I IPv6Service: setIPv6Prefix: %s", v223, 0xCu);
        }
        if (v144)
        {
          v208 = v49;
          v209 = 1174405120;
          v210 = ___ZN21Mav16QMIDataContextIP18setHandoverAddressERN3wds19StartNetworkIfaceV27RequestE18DataProtocolFamilyb_block_invoke_39;
          v211 = &__block_descriptor_tmp_40_4;
          CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)&v212, (const CSIPacketAddress *)v224);
          v151 = qmi::MutableMessageBase::getTLV<wds::tlv::HandOverIPv6Prefix>(&v182, 208);
          v210((uint64_t)&v208, (unsigned __int8 *)v151);
        }
        ctu::SharedRef<__CFBoolean const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFBoolean const>::~SharedRef((const void **)&v213);
        if (v214)
        {
          v215 = v214;
          operator delete(v214);
        }
      }
    }
    else if ((a2 & 1) != 0 && *(_DWORD *)(a1 + 140) == 1)
    {
      memset(v224, 0, sizeof(v224));
      v121 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(a1 + 104));
      v122 = *(void **)(a1 + 96);
      v215 = v121;
      v214 = v122;
      (*(void (**)(uint8_t *__return_ptr, void *, uint64_t))(*(_QWORD *)v122 + 216))(v224, v122, 1);
      v123 = (unint64_t *)&v121->__shared_owners_;
      do
        v124 = __ldaxr(v123);
      while (__stlxr(v124 - 1, v123));
      if (!v124)
      {
        ((void (*)(std::__shared_weak_count *))v121->__on_zero_shared)(v121);
        std::__shared_weak_count::__release_weak(v121);
      }
      v125 = CSIPacketAddress::isZeroIP((CSIPacketAddress *)v224);
      v117 = *(NSObject **)(a1 + 40);
      v126 = os_log_type_enabled(v117, OS_LOG_TYPE_DEFAULT);
      if (v125)
      {
        if (v126)
        {
          CSIPacketAddress::operator std::string();
          if (v216 >= 0)
            v127 = &v214;
          else
            v127 = v214;
          *(_DWORD *)v223 = 136315138;
          *(_QWORD *)&v223[4] = v127;
          v120 = "#E ipv4Addr: %s handover impossible, going with regular activation";
LABEL_184:
          _os_log_impl(&dword_216897000, v117, OS_LOG_TYPE_DEFAULT, v120, v223, 0xCu);
          if (SHIBYTE(v216) < 0)
            operator delete(v214);
        }
LABEL_228:
        v153 = 0;
LABEL_229:
        QMIDataContextIPBase::setHandoverActivation((QMIDataContextIPBase *)a1, v153);
LABEL_230:
        v154 = v205;
        if (v205)
        {
          v155 = (unint64_t *)&v205->__shared_owners_;
          do
            v156 = __ldaxr(v155);
          while (__stlxr(v156 - 1, v155));
          if (!v156)
          {
            ((void (*)(std::__shared_weak_count *))v154->__on_zero_shared)(v154);
            std::__shared_weak_count::__release_weak(v154);
          }
        }
        goto LABEL_235;
      }
      if (v126)
      {
        CSIPacketAddress::operator std::string();
        v139 = v216 >= 0 ? &v214 : (void **)v214;
        *(_DWORD *)v223 = 136315138;
        *(_QWORD *)&v223[4] = v139;
        _os_log_impl(&dword_216897000, v117, OS_LOG_TYPE_DEFAULT, "#I ipv4Addr: %s", v223, 0xCu);
        if (SHIBYTE(v216) < 0)
          operator delete(v214);
      }
      if (capabilities::ct::supportsDataQMIExtensions((capabilities::ct *)v126))
      {
        *(_QWORD *)&buf = v49;
        *((_QWORD *)&buf + 1) = 1174405120;
        *(_QWORD *)&v218 = ___ZN21Mav16QMIDataContextIP18setHandoverAddressERN3wds19StartNetworkIfaceV27RequestE18DataProtocolFamilyb_block_invoke_41;
        *((_QWORD *)&v218 + 1) = &__block_descriptor_tmp_42_7;
        CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)&v219, (const CSIPacketAddress *)v224);
        v140 = qmi::MutableMessageBase::getTLV<wds::tlv::HandOverContext>(&v182);
        ((void (*)(uint64_t, uint64_t))v218)((uint64_t)&buf, (uint64_t)v140);
      }
    }
    v152 = (capabilities::ct *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 616) + 40))(*(_QWORD *)(a1 + 616));
    if ((_DWORD)v152)
    {
      if ((capabilities::ct::supportsDataQMIExtensions(v152) & 1) != 0)
      {
        v153 = 1;
      }
      else
      {
        v164 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v164, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)aBlock = 136315138;
          *(_QWORD *)&aBlock[4] = "setDataExtensionParameters";
          _os_log_impl(&dword_216897000, v164, OS_LOG_TYPE_DEFAULT, "#I %s: Set ITechHandoverPDN", aBlock, 0xCu);
        }
        v165 = (_BYTE *)qmi::MutableMessageBase::getTLV<wds::tlv::ITechHandoverPDN>(&v182, 209);
        v153 = 1;
        *v165 = 1;
      }
      goto LABEL_229;
    }
    goto LABEL_228;
  }
LABEL_235:
  v157 = v207;
  if (v207)
  {
    v158 = (unint64_t *)&v207->__shared_owners_;
    do
      v159 = __ldaxr(v158);
    while (__stlxr(v159 - 1, v158));
    if (!v159)
    {
      ((void (*)(std::__shared_weak_count *))v157->__on_zero_shared)(v157);
      std::__shared_weak_count::__release_weak(v157);
    }
  }
  v208 = a1 + 144;
  v209 = QMIServiceMsg::create();
  v211 = (void *)(a1 + 176);
  v212 = 0;
  LODWORD(v210) = 210000;
  v171[0] = v49;
  v171[1] = 0x40000000;
  v171[2] = ___ZN21Mav16QMIDataContextIP46activateDataContextIPAfterProfileConfigurationE18DataProtocolFamilyb_block_invoke_19;
  v171[3] = &__block_descriptor_tmp_20_13;
  v171[4] = a1;
  *(_QWORD *)aBlock = v49;
  *(_QWORD *)&aBlock[8] = 0x40000000;
  *(_QWORD *)&aBlock[16] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3wds21StartNetworkIfaceBase8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke_0;
  v221 = &unk_24D5DE5B8;
  v222 = v171;
  v160 = _Block_copy(aBlock);
  v212 = v160;
  if (v209)
  {
    qmi::Client::send();
    v160 = v212;
  }
  if (v160)
    _Block_release(v160);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&v182);
LABEL_245:
  v161 = v191;
  if (v191)
  {
    v162 = (unint64_t *)&v191->__shared_owners_;
    do
      v163 = __ldaxr(v162);
    while (__stlxr(v163 - 1, v162));
    if (!v163)
    {
      ((void (*)(std::__shared_weak_count *))v161->__on_zero_shared)(v161);
      std::__shared_weak_count::__release_weak(v161);
    }
  }
}

void sub_2169FC2AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,char a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  char a64;
  void *v65;

  ctu::SharedRef<__CFBoolean const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFBoolean const>::~SharedRef((const void **)&STACK[0x200]);
  v65 = (void *)STACK[0x208];
  if (STACK[0x208])
  {
    STACK[0x210] = (unint64_t)v65;
    operator delete(v65);
  }
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a62);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a64);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a27);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a42);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'Mav16QMIDataContextIP::handleProfileConfigured(Mav16QMIDataContextIP *this, int a2)
{
  Mav16QMIDataContextIP::handleProfileConfigured((Mav16QMIDataContextIP *)((char *)this - 864), a2);
}

uint64_t ___ZN21Mav16QMIDataContextIP46activateDataContextIPAfterProfileConfigurationE18DataProtocolFamilyb_block_invoke(uint64_t result, _BYTE *a2)
{
  *a2 = *(_BYTE *)(*(_QWORD *)(result + 32) + 2);
  return result;
}

uint64_t __copy_helper_block_e8_32c42_ZTSNSt3__110shared_ptrI14QMIProfileInfoEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c42_ZTSNSt3__110shared_ptrI14QMIProfileInfoEE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void ___ZN21Mav16QMIDataContextIP46activateDataContextIPAfterProfileConfigurationE18DataProtocolFamilyb_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  NSObject *v4;
  _DWORD v5[2];
  __int16 v6;
  uint64_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)(v2 + 257))
  {
    v3 = *(_DWORD *)(a2 + 4);
    v4 = *(NSObject **)(v2 + 40);
    if (v3)
    {
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        v5[0] = 67109378;
        v5[1] = v3;
        v6 = 2080;
        v7 = qmi::asString();
        _os_log_error_impl(&dword_216897000, v4, OS_LOG_TYPE_ERROR, "wds::SetAlwaysOnPdu::Response error: 0x%x (%s)", (uint8_t *)v5, 0x12u);
      }
    }
    else if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v5[0]) = 0;
      _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I wds::SetAlwaysOnPdu::Response successful", (uint8_t *)v5, 2u);
    }
  }
}

uint64_t ___ZN21Mav16QMIDataContextIP46activateDataContextIPAfterProfileConfigurationE18DataProtocolFamilyb_block_invoke_14(uint64_t result, _BYTE *a2)
{
  *a2 = *(_BYTE *)(*(_QWORD *)(result + 32) + 2);
  return result;
}

uint64_t ___ZN21Mav16QMIDataContextIP46activateDataContextIPAfterProfileConfigurationE18DataProtocolFamilyb_block_invoke_16(uint64_t result, _BYTE *a2)
{
  *a2 = *(_BYTE *)(*(_QWORD *)(result + 32) + 4);
  return result;
}

void ___ZN21Mav16QMIDataContextIP46activateDataContextIPAfterProfileConfigurationE18DataProtocolFamilyb_block_invoke_19(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)(v2 + 257))
    QMIDataContextIPBase::handleActivateResponse(v2, a2);
}

void ___ZN21Mav16QMIDataContextIP26setDataExtensionParametersERN3wds19StartNetworkIfaceV27RequestE18DataProtocolFamilyb_block_invoke(uint64_t a1, char *a2)
{
  uint64_t v3;
  int v4;
  NSObject *v5;
  _BOOL4 v6;
  char v7;
  int v8;
  const char *v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 + 32);
  v4 = (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 40) + 128))(*(_QWORD *)(a1 + 40), 0);
  v5 = *(NSObject **)(v3 + 40);
  v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (v4)
  {
    if (v6)
    {
      v8 = 136315138;
      v9 = "setDataExtensionParameters_block_invoke";
      _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#I %s: Using Tethering NAI", (uint8_t *)&v8, 0xCu);
    }
    v7 = 0;
  }
  else
  {
    if (v6)
    {
      v8 = 136315138;
      v9 = "setDataExtensionParameters_block_invoke";
      _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#I %s: Using Embedded NAI", (uint8_t *)&v8, 0xCu);
    }
    v7 = 1;
  }
  *a2 = v7;
}

void ___ZN21Mav16QMIDataContextIP26setDataExtensionParametersERN3wds19StartNetworkIfaceV27RequestE18DataProtocolFamilyb_block_invoke_23(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;

  v4 = *(_QWORD *)(a1 + 32);
  v5 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v4 + 104));
  *a2 = (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(v4 + 96) + 400))(*(_QWORD *)(v4 + 96), *(_QWORD *)(a1 + 40));
  p_shared_owners = (unint64_t *)&v5->__shared_owners_;
  do
    v7 = __ldaxr(p_shared_owners);
  while (__stlxr(v7 - 1, p_shared_owners));
  if (!v7)
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
}

void sub_2169FC750(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void ___ZN21Mav16QMIDataContextIP26setDataExtensionParametersERN3wds19StartNetworkIfaceV27RequestE18DataProtocolFamilyb_block_invoke_26(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BYTE *v3;
  NSObject *v6;
  int v7;
  int v8;
  int v9;
  int v10;
  unsigned __int8 v11;
  _DWORD v12[2];
  __int16 v13;
  int v14;
  __int16 v15;
  int v16;
  __int16 v17;
  int v18;
  uint64_t v19;

  v19 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 32);
  *(_BYTE *)a2 = *(_DWORD *)(a1 + 48);
  *(_BYTE *)(a2 + 1) = 0;
  *(_BYTE *)(a2 + 11) = 0;
  *(_BYTE *)(a2 + 40) = 0;
  v3 = *(_BYTE **)(a1 + 40);
  if (*v3)
  {
    v6 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      v7 = v3[1];
      v8 = v3[2];
      v9 = v3[3];
      v10 = v3[4];
      v12[0] = 67109888;
      v12[1] = v7;
      v13 = 1024;
      v14 = v8;
      v15 = 1024;
      v16 = v9;
      v17 = 1024;
      v18 = v10;
      _os_log_impl(&dword_216897000, v6, OS_LOG_TYPE_DEFAULT, "#I Applying ExtendedHandoffContext snssaiInfo sst=%d. sd=[%d,%d,%d]", (uint8_t *)v12, 0x1Au);
      v3 = *(_BYTE **)(a1 + 40);
    }
    *(_BYTE *)(a2 + 1) = 1;
    *(_BYTE *)(a2 + 11) = 1;
    *(_BYTE *)(a2 + 2) = v3[1];
    v11 = v3[4];
    *(_WORD *)(a2 + 3) = *((_WORD *)v3 + 1);
    *(_WORD *)(a2 + 5) = v11;
  }
}

uint64_t ___ZN21Mav16QMIDataContextIP18setHandoverAddressERN3wds19StartNetworkIfaceV27RequestE18DataProtocolFamilyb_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = CSIPacketAddress::toIPv6((CSIPacketAddress *)(a1 + 32), (unsigned __int8 *)(a2 + 4));
  *(_BYTE *)(a2 + 20) = 1;
  return result;
}

_QWORD *std::vector<__CFString const*>::vector[abi:ne180100](_QWORD *a1, const void *a2, unint64_t a3)
{
  size_t v6;
  char *v7;
  char *v8;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a3)
  {
    if (a3 >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v6 = 8 * a3;
    v7 = (char *)operator new(8 * a3);
    *a1 = v7;
    a1[1] = v7;
    v8 = &v7[8 * a3];
    a1[2] = v8;
    memmove(v7, a2, v6);
    a1[1] = v8;
  }
  return a1;
}

void sub_2169FC928(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t ___ZN21Mav16QMIDataContextIP18setHandoverAddressERN3wds19StartNetworkIfaceV27RequestE18DataProtocolFamilyb_block_invoke_39(uint64_t a1, unsigned __int8 *a2)
{
  CSIPacketAddress *v3;
  uint64_t result;

  v3 = (CSIPacketAddress *)(a1 + 32);
  CSIPacketAddress::toIPv6((CSIPacketAddress *)(a1 + 32), a2);
  result = CSIPacketAddress::getPrefixLen(v3);
  a2[16] = result;
  return result;
}

uint64_t ___ZN21Mav16QMIDataContextIP18setHandoverAddressERN3wds19StartNetworkIfaceV27RequestE18DataProtocolFamilyb_block_invoke_41(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = CSIPacketAddress::toIPv4LE((CSIPacketAddress *)(a1 + 32));
  *(_DWORD *)a2 = result;
  *(_BYTE *)(a2 + 20) = 0;
  return result;
}

void Mav16QMIDataContextIP::stopNetworkIface(Mav16QMIDataContextIP *this, int a2)
{
  int v3;
  NSObject *v4;
  const char *v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  _BYTE v9[22];
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v3 = *((unsigned __int8 *)this + 888);
  if (*((_BYTE *)this + 888) || *((_BYTE *)this + 889))
  {
    v4 = *((_QWORD *)this + 5);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      v5 = "creation";
      if (!v3)
        v5 = "configuration";
      *(_DWORD *)v9 = 136315394;
      *(_QWORD *)&v9[4] = "stopNetworkIface";
      *(_WORD *)&v9[12] = 2080;
      *(_QWORD *)&v9[14] = v5;
      _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I %s: called while pending profile %s. Declaring activation failure", v9, 0x16u);
    }
    *((_WORD *)this + 444) = 0;
    QMIDataContextIPBase::setDataContextIPState((uint64_t)this, 1u);
    v6 = std::__shared_weak_count::lock(*((std::__shared_weak_count **)this + 13));
    *(_QWORD *)v9 = *((_QWORD *)this + 12);
    *(_QWORD *)&v9[8] = v6;
    (*(void (**)(_QWORD, _QWORD, uint64_t, _QWORD, _QWORD, uint64_t, _QWORD))(**(_QWORD **)v9 + 64))(*(_QWORD *)v9, *((unsigned int *)this + 35), 1, 0, 0, 2, 0);
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
    QMIDataContextIPBase::doneWithContext(this);
  }
  else
  {
    QMIDataContextIPBase::stopNetworkIface(this, a2);
  }
}

void sub_2169FCB34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

char *qmi::MutableMessageBase::getTLV<wds::tlv::Profile3GPP_ProfileIdentifier>(_QWORD *a1, int a2)
{
  char v2;
  const void **v4;
  const void **v5;
  char **v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t *v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  char *v17;
  uint64_t *v18;
  char *v19;
  char *v20;
  char *v21;
  uint64_t v22;

  v2 = a2;
  v4 = (const void **)a1[1];
  v5 = (const void **)a1[2];
  v6 = (char **)(a1 + 1);
  if (v4 != v5)
  {
    while (*((unsigned __int8 *)*v4 + 8) != a2)
    {
      if (++v4 == v5)
        goto LABEL_8;
    }
  }
  if (v4 == v5)
  {
LABEL_8:
    v9 = operator new();
    *(_BYTE *)(v9 + 8) = v2;
    *(_BYTE *)(v9 + 9) = 0;
    v8 = v9 + 9;
    *(_QWORD *)v9 = &off_24D5DE4C0;
    v10 = a1[3];
    v11 = (uint64_t *)a1[2];
    if ((unint64_t)v11 >= v10)
    {
      v13 = ((char *)v11 - *v6) >> 3;
      if ((unint64_t)(v13 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v14 = v10 - (_QWORD)*v6;
      v15 = v14 >> 2;
      if (v14 >> 2 <= (unint64_t)(v13 + 1))
        v15 = v13 + 1;
      if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8)
        v16 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v16 = v15;
      if (v16)
        v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v16);
      else
        v17 = 0;
      v18 = (uint64_t *)&v17[8 * v13];
      v19 = &v17[8 * v16];
      *v18 = v9;
      v12 = v18 + 1;
      v21 = (char *)a1[1];
      v20 = (char *)a1[2];
      if (v20 != v21)
      {
        do
        {
          v22 = *((_QWORD *)v20 - 1);
          v20 -= 8;
          *--v18 = v22;
        }
        while (v20 != v21);
        v20 = *v6;
      }
      a1[1] = v18;
      a1[2] = v12;
      a1[3] = v19;
      if (v20)
        operator delete(v20);
    }
    else
    {
      *v11 = v9;
      v12 = v11 + 1;
    }
    a1[2] = v12;
  }
  else
  {
    if (!v7)
      __cxa_bad_cast();
    return v7 + 9;
  }
  return (char *)v8;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP_ProfileIdentifier>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP_ProfileIdentifier>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_ProfileIdentifier>();
}

_BYTE *qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP_ProfileIdentifier>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE *result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::Profile3GPP_ProfileIdentifier>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP_ProfileIdentifier>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5DE4C0;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::ProfileRatMask>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::ProfileRatMask>::getSize()
{
  return tlv::size<wds::tlv::ProfileTypeMask>();
}

_QWORD **qmi::MutableMessageBase::TlvWrapper<wds::tlv::ProfileRatMask>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _QWORD *v4;
  uint64_t v5;
  _QWORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_QWORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::ProfileTypeMask>((_QWORD **)a2, (_QWORD *)(a1 + 16));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::ProfileRatMask>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5DE510;
  *(_QWORD *)(result + 16) = *(_QWORD *)(a1 + 16);
  return result;
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3wds14SetAlwaysOnPdu8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_2169FCF10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP2_ProfileIdentifier>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP2_ProfileIdentifier>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_ProfileIdentifier>();
}

_BYTE *qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP2_ProfileIdentifier>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE *result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::Profile3GPP_ProfileIdentifier>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Profile3GPP2_ProfileIdentifier>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5DE588;
  return result;
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3wds21StartNetworkIfaceBase8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke_0(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BYTE v3[24];

  v2 = *(_QWORD *)(a1 + 32);
  cast_message_type<wds::StartNetworkIfaceBase::Response const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_2169FD058(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::ExtendedHandoffContext>::~TlvWrapper(uint64_t a1)
{
  void **v3;

  *(_QWORD *)a1 = off_24D5DE600;
  v3 = (void **)(a1 + 32);
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&v3);
  return a1;
}

{
  void **v3;

  *(_QWORD *)a1 = off_24D5DE600;
  v3 = (void **)(a1 + 32);
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&v3);
  return MEMORY[0x2199FEAC4](a1, 0x10A1C407FF270E1);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::ExtendedHandoffContext>::getSize(uint64_t a1)
{
  return tlv::size<wds::tlv::ExtendedHandoffContext>(a1 + 16);
}

char *qmi::MutableMessageBase::TlvWrapper<wds::tlv::ExtendedHandoffContext>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  uint64_t v4;
  uint64_t v5;
  char *result;
  uint64_t v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = *a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::ExtendedHandoffContext>(a2, a1 + 16);
  v7 = *a2 - v5;
  *(_BYTE *)v4 = v3;
  *(_WORD *)(v4 + 1) = v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::ExtendedHandoffContext>::clone(uint64_t a1)
{
  uint64_t v2;

  v2 = operator new();
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)v2 = off_24D5DE600;
  *(_QWORD *)(v2 + 16) = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(v2 + 23) = *(_QWORD *)(a1 + 23);
  *(_QWORD *)(v2 + 40) = 0;
  *(_QWORD *)(v2 + 48) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  std::vector<std::string>::__init_with_size[abi:ne180100]<std::string*,std::string*>((std::string *)(v2 + 32), *(__int128 **)(a1 + 32), *(__int128 **)(a1 + 40), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a1 + 40) - *(_QWORD *)(a1 + 32)) >> 3));
  *(_BYTE *)(v2 + 56) = *(_BYTE *)(a1 + 56);
  return v2;
}

void sub_2169FD1F4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199FEAC4](v1, 0x10A1C407FF270E1);
  _Unwind_Resume(a1);
}

char *qmi::MutableMessageBase::getTLV<wds::tlv::HandOverContext>(_QWORD *a1)
{
  const void **v2;
  const void **v3;
  char **v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  v4 = (char **)(a1 + 1);
  if (v2 != v3)
  {
    while (*((_BYTE *)*v2 + 8) != 54)
    {
      if (++v2 == v3)
        goto LABEL_8;
    }
  }
  if (v2 == v3)
  {
LABEL_8:
    v7 = operator new();
    *(_BYTE *)(v7 + 8) = 54;
    *(_QWORD *)v7 = &off_24D5DE650;
    *(_QWORD *)(v7 + 12) = 0;
    v6 = v7 + 12;
    *(_QWORD *)(v7 + 20) = 0;
    *(_QWORD *)(v7 + 25) = 0;
    v8 = a1[3];
    v9 = (uint64_t *)a1[2];
    if ((unint64_t)v9 >= v8)
    {
      v11 = ((char *)v9 - *v4) >> 3;
      if ((unint64_t)(v11 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v12 = v8 - (_QWORD)*v4;
      v13 = v12 >> 2;
      if (v12 >> 2 <= (unint64_t)(v11 + 1))
        v13 = v11 + 1;
      if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
        v14 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v14 = v13;
      if (v14)
        v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v14);
      else
        v15 = 0;
      v16 = (uint64_t *)&v15[8 * v11];
      v17 = &v15[8 * v14];
      *v16 = v7;
      v10 = v16 + 1;
      v19 = (char *)a1[1];
      v18 = (char *)a1[2];
      if (v18 != v19)
      {
        do
        {
          v20 = *((_QWORD *)v18 - 1);
          v18 -= 8;
          *--v16 = v20;
        }
        while (v18 != v19);
        v18 = *v4;
      }
      a1[1] = v16;
      a1[2] = v10;
      a1[3] = v17;
      if (v18)
        operator delete(v18);
    }
    else
    {
      *v9 = v7;
      v10 = v9 + 1;
    }
    a1[2] = v10;
  }
  else
  {
    if (!v5)
      __cxa_bad_cast();
    return v5 + 12;
  }
  return (char *)v6;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::HandOverContext>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::HandOverContext>::getSize()
{
  return tlv::size<wds::tlv::HandOverContext>();
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::HandOverContext>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = *a2;
  v5 = *a2 + 3;
  *a2 = v5;
  tlv::writeV<wds::tlv::HandOverContext>(a2, a1 + 12);
  v6 = *a2 - v5;
  *(_BYTE *)v4 = v3;
  *(_WORD *)(v4 + 1) = v6;
}

__n128 qmi::MutableMessageBase::TlvWrapper<wds::tlv::HandOverContext>::clone(uint64_t a1)
{
  uint64_t v2;
  __n128 result;

  v2 = operator new();
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)v2 = &off_24D5DE650;
  result = *(__n128 *)(a1 + 12);
  *(__n128 *)(v2 + 12) = result;
  *(_QWORD *)(v2 + 28) = *(_QWORD *)(a1 + 28);
  return result;
}

uint64_t convertFromQMIVocoderType(uint64_t result)
{
  switch((int)result)
  {
    case 0:
      return result;
    case 1:
      result = 1;
      break;
    case 2:
      result = 2;
      break;
    case 3:
      result = 3;
      break;
    case 4:
      result = 4;
      break;
    case 5:
      result = 5;
      break;
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
      goto LABEL_5;
    case 16:
      result = 6;
      break;
    case 17:
      result = 7;
      break;
    case 18:
      result = 8;
      break;
    case 19:
      result = 9;
      break;
    case 20:
      result = 10;
      break;
    case 21:
      result = 11;
      break;
    case 32:
      result = 12;
      break;
    case 33:
      result = 13;
      break;
    case 34:
      result = 14;
      break;
    case 35:
      result = 15;
      break;
    case 36:
      result = 16;
      break;
    default:
      if ((_DWORD)result == 48)
        result = 17;
      else
LABEL_5:
        result = 18;
      break;
  }
  return result;
}

uint64_t convertToQMIVocoderType(unsigned int a1)
{
  if (a1 > 0x11)
    return 255;
  else
    return byte_216AB2A70[a1];
}

uint64_t QMIDataContextIPBase::QMIDataContextIPBase(uint64_t a1, _QWORD *a2, _QWORD *a3, char a4, _QWORD *a5, int a6, NSObject **a7, _QWORD *a8)
{
  _QWORD *v15;
  int v16;
  unsigned int v17;
  const char *v18;
  NSObject *v19;
  uint64_t v20;
  unint64_t *v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t *v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t *v27;
  unint64_t v28;
  int v29;
  unsigned int v30;
  uint64_t v31;
  unint64_t *v32;
  unint64_t v33;
  _BYTE v36[16];
  _BYTE v37[8];

  *(_QWORD *)a1 = off_24D5DE688;
  v15 = (_QWORD *)(a1 + 8);
  if (*a5)
    v16 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(*a5 + *(_QWORD *)(*(_QWORD *)*a5 - 56)) + 24))(*a5 + *(_QWORD *)(*(_QWORD *)*a5 - 56));
  else
    v16 = 1;
  if (*a3)
    v17 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a3 + 40))(*a3);
  else
    v17 = 0;
  v18 = QMIDataContextIPBase::nameForFamily(a1, v16, v17, a6);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)v36, (const char *)*MEMORY[0x24BDC3E90], v18);
  *v15 = 0;
  v15[1] = 0;
  v19 = *a7;
  *(_QWORD *)(a1 + 24) = *a7;
  if (v19)
    dispatch_retain(v19);
  *(_QWORD *)(a1 + 32) = 0;
  ctu::OsLogLogger::OsLogLogger();
  ctu::OsLogLogger::OsLogLogger();
  MEMORY[0x2199FDF6C](v37);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v36);
  *(_QWORD *)a1 = off_24D5DE688;
  *(_QWORD *)(a1 + 48) = &off_24D5DF0E0;
  *(_QWORD *)(a1 + 72) = a1 + 48;
  *(_QWORD *)(a1 + 80) = *a2;
  v20 = a2[1];
  *(_QWORD *)(a1 + 88) = v20;
  if (v20)
  {
    v21 = (unint64_t *)(v20 + 8);
    do
      v22 = __ldxr(v21);
    while (__stxr(v22 + 1, v21));
  }
  *(_QWORD *)(a1 + 96) = *a3;
  v23 = a3[1];
  *(_QWORD *)(a1 + 104) = v23;
  if (v23)
  {
    v24 = (unint64_t *)(v23 + 16);
    do
      v25 = __ldxr(v24);
    while (__stxr(v25 + 1, v24));
  }
  *(_BYTE *)(a1 + 112) = a4;
  *(_QWORD *)(a1 + 120) = *a5;
  v26 = a5[1];
  *(_QWORD *)(a1 + 128) = v26;
  if (v26)
  {
    v27 = (unint64_t *)(v26 + 16);
    do
      v28 = __ldxr(v27);
    while (__stxr(v28 + 1, v27));
  }
  *(_OWORD *)(a1 + 144) = 0u;
  *(_DWORD *)(a1 + 136) = 0;
  *(_DWORD *)(a1 + 140) = a6;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_WORD *)(a1 + 176) = 0;
  *(_DWORD *)(a1 + 180) = -1;
  CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)(a1 + 184));
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_WORD *)(a1 + 256) = 255;
  *(_QWORD *)(a1 + 264) = 0;
  *(_BYTE *)(a1 + 272) = 0;
  *(_QWORD *)(a1 + 312) = 0;
  *(_QWORD *)(a1 + 320) = 0;
  *(_QWORD *)(a1 + 328) = 0;
  *(_QWORD *)(a1 + 276) = 0;
  *(_QWORD *)(a1 + 292) = 0;
  *(_QWORD *)(a1 + 284) = 0;
  *(_QWORD *)(a1 + 299) = 0;
  CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)(a1 + 336));
  CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)(a1 + 360));
  *(_QWORD *)(a1 + 384) = MEMORY[0x24BDC3D28] + 16;
  *(_QWORD *)(a1 + 544) = 0;
  *(_DWORD *)(a1 + 552) = 0;
  *(_DWORD *)(a1 + 536) = 0;
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 408) = 0u;
  *(_OWORD *)(a1 + 424) = 0u;
  *(_OWORD *)(a1 + 440) = 0u;
  *(_OWORD *)(a1 + 456) = 0u;
  *(_OWORD *)(a1 + 472) = 0u;
  *(_OWORD *)(a1 + 488) = 0u;
  *(_OWORD *)(a1 + 504) = 0u;
  *(_OWORD *)(a1 + 520) = 0u;
  *(_OWORD *)(a1 + 560) = 0u;
  if (*a5)
    v29 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(*a5 + *(_QWORD *)(*(_QWORD *)*a5 - 56)) + 24))(*a5 + *(_QWORD *)(*(_QWORD *)*a5 - 56));
  else
    v29 = 1;
  if (*a3)
    v30 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a3 + 40))(*a3);
  else
    v30 = 0;
  *(_QWORD *)(a1 + 576) = QMIDataContextIPBase::nameForFamily(a1, v29, v30, a6);
  *(_QWORD *)(a1 + 592) = 0;
  *(_QWORD *)(a1 + 608) = 0;
  *(_QWORD *)(a1 + 600) = 0;
  *(_QWORD *)(a1 + 616) = *a8;
  v31 = a8[1];
  *(_QWORD *)(a1 + 624) = v31;
  if (v31)
  {
    v32 = (unint64_t *)(v31 + 8);
    do
      v33 = __ldxr(v32);
    while (__stxr(v33 + 1, v32));
  }
  *(_DWORD *)(a1 + 632) = 0;
  *(_DWORD *)(a1 + 635) = 0;
  std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100](a1 + 640, a1 + 48);
  *(_BYTE *)(a1 + 672) = 0;
  *(_BYTE *)(a1 + 680) = 0;
  *(_BYTE *)(a1 + 856) = 0;
  return a1;
}

void sub_2169FD898(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  _QWORD *v12;
  _QWORD *v13;
  uint64_t v14;
  _QWORD *v15;
  void **v16;
  void **v17;
  uint64_t v18;
  qmi::Client *v19;
  void **v20;
  void *v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  void *v27;
  std::__shared_weak_count *v28;
  std::__shared_weak_count *v29;
  _QWORD *v30;
  uint64_t v31;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v18);
  v22 = *v20;
  if (*v20)
  {
    v13[75] = v22;
    operator delete(v22);
  }
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)(v13 + 70));
  MEMORY[0x2199FD75C](v14);
  v23 = *v17;
  if (*v17)
  {
    v13[40] = v23;
    operator delete(v23);
  }
  v24 = v13[37];
  v13[37] = 0;
  if (v24)
    (*(void (**)(uint64_t))(*(_QWORD *)v24 + 8))(v24);
  v25 = v13[36];
  v13[36] = 0;
  if (v25)
    (*(void (**)(uint64_t))(*(_QWORD *)v25 + 8))(v25);
  v26 = v13[33];
  v13[33] = 0;
  if (v26)
    (*(void (**)(uint64_t))(*(_QWORD *)v26 + 8))(v26);
  a12 = v16 + 3;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&a12);
  v27 = *v16;
  if (*v16)
  {
    v13[27] = v27;
    operator delete(v27);
  }
  qmi::Client::~Client(v19);
  v28 = (std::__shared_weak_count *)v13[16];
  if (v28)
    std::__shared_weak_count::__release_weak(v28);
  v29 = (std::__shared_weak_count *)v13[13];
  if (v29)
    std::__shared_weak_count::__release_weak(v29);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a9);
  v30 = (_QWORD *)v13[9];
  if (v30 == v15)
  {
    v31 = 4;
  }
  else
  {
    if (!v30)
      goto LABEL_22;
    v31 = 5;
    v15 = (_QWORD *)v13[9];
  }
  (*(void (**)(_QWORD *))(*v15 + 8 * v31))(v15);
LABEL_22:
  MEMORY[0x2199FDF6C](a10);
  ctu::SharedSynchronizable<QMIDataSystemDeterminationManager>::~SharedSynchronizable(v12);
  _Unwind_Resume(a1);
}

const char *QMIDataContextIPBase::nameForFamily(uint64_t a1, int a2, unsigned int a3, int a4)
{
  char **v5;
  NSObject *v6;
  NSObject *v8;
  NSObject *v9;
  int v10;
  uint64_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  if (a2 == 2)
  {
    if (a4 == 2)
    {
      if (a3 < 0xA)
      {
        v5 = off_24D5E0228;
        return v5[a3];
      }
      return "DATA.QMIContext.2:N:IPv6";
    }
    else if (a4 == 1)
    {
      if (a3 < 0xA)
      {
        v5 = off_24D5E01D8;
        return v5[a3];
      }
      return "DATA.QMIContext.2:N:IPv4";
    }
    else
    {
      v9 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        v10 = 136315138;
        v11 = asString();
        _os_log_error_impl(&dword_216897000, v9, OS_LOG_TYPE_ERROR, "Wrong IP family: %s", (uint8_t *)&v10, 0xCu);
      }
      if (a3 < 0xA)
      {
        v5 = off_24D5E0278;
        return v5[a3];
      }
      return "DATA.QMIContext.2:N:IPvX";
    }
  }
  else if (a2 == 1)
  {
    if (a4 == 2)
    {
      if (a3 < 0xA)
      {
        v5 = off_24D5E0138;
        return v5[a3];
      }
      return "DATA.QMIContext.1:N:IPv6";
    }
    else if (a4 == 1)
    {
      if (a3 < 0xA)
      {
        v5 = off_24D5E00E8;
        return v5[a3];
      }
      return "DATA.QMIContext.1:N:IPv4";
    }
    else
    {
      v8 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        v10 = 136315138;
        v11 = asString();
        _os_log_error_impl(&dword_216897000, v8, OS_LOG_TYPE_ERROR, "Wrong IP family: %s", (uint8_t *)&v10, 0xCu);
      }
      if (a3 < 0xA)
      {
        v5 = off_24D5E0188;
        return v5[a3];
      }
      return "DATA.QMIContext.1:N:IPvX";
    }
  }
  else
  {
    v6 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      v10 = 136315138;
      v11 = subscriber::asString();
      _os_log_error_impl(&dword_216897000, v6, OS_LOG_TYPE_ERROR, "Wrong SIM: %s", (uint8_t *)&v10, 0xCu);
    }
    return "DATA.QMIContext.X:X:IPvX";
  }
}

void QMIDataContextIPBase::initialize(QMIDataContextIPBase *this, char a2)
{
  NSObject *v3;
  NSObject *v4;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_weak_owners;
  unint64_t v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  std::__shared_weak_count *v14;
  std::__shared_weak_count *v15;
  void *__p;
  char v17;
  void *v18[2];
  uint64_t v19;
  uint8_t buf[4];
  const char *v21;
  __int16 v22;
  const char *v23;
  __int16 v24;
  int v25;
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  if (*((_BYTE *)this + 112) || (a2 & 1) != 0 || (capabilities::ct::supportsDataQMIExtensions(this) & 1) == 0)
  {
    if ((*((_DWORD *)this + 35) - 1) < 2)
      goto LABEL_9;
    if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315650;
      v21 = "called with wrong ipFamily";
      v22 = 2080;
      v23 = "/Library/Caches/com.apple.xbs/Sources/CoreTelephony/CommCenter/CommCenterCommandDrivers/Data/QMI/Context/QMI"
            "DataContextIPBase.cpp";
      v24 = 1024;
      v25 = 546;
      _os_log_error_impl(&dword_216897000, MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR, "\n**********\n   ASSERT kDataProtocolFamilyIPv4 == fIpFamilyType || kDataProtocolFamilyIPv6 == fIpFamilyType\n %s\n at %s:%d\n**********", buf, 0x1Cu);
      if ((*((_DWORD *)this + 35) - 1) < 2)
        goto LABEL_9;
    }
    __TUAssertTrigger();
    if ((*((_DWORD *)this + 35) - 1) <= 1)
    {
LABEL_9:
      v18[0] = 0;
      v18[1] = 0;
      v19 = 0;
      std::string::basic_string[abi:ne180100]<0>(v18, "data_1");
      std::string::basic_string[abi:ne180100]<0>(&__p, *((char **)this + 72));
      v4 = *((_QWORD *)this + 3);
      if (v4)
        dispatch_retain(v4);
      v5 = (std::__shared_weak_count *)*((_QWORD *)this + 2);
      if (!v5 || (v6 = std::__shared_weak_count::lock(v5), (v14 = v6) == 0))
        std::__throw_bad_weak_ptr[abi:ne180100]();
      v15 = v6;
      p_shared_weak_owners = (unint64_t *)&v6->__shared_weak_owners_;
      do
        v8 = __ldxr(p_shared_weak_owners);
      while (__stxr(v8 + 1, p_shared_weak_owners));
      Registry::getServerConnection(*((Registry **)this + 10));
      qmi::Client::createWithQueueLocal();
      std::shared_ptr<qmi::Client::State>::operator=[abi:ne180100]((uint64_t)this + 160, (__int128 *)((char *)&v23 + 2));
      qmi::Client::~Client((qmi::Client *)buf);
      if (v13)
      {
        p_shared_owners = (unint64_t *)&v13->__shared_owners_;
        do
          v10 = __ldaxr(p_shared_owners);
        while (__stlxr(v10 - 1, p_shared_owners));
        if (!v10)
        {
          ((void (*)())v13->__on_zero_shared)();
          std::__shared_weak_count::__release_weak(v13);
        }
      }
      std::__shared_weak_count::__release_weak(v15);
      if (v14)
      {
        v11 = (unint64_t *)&v14->__shared_owners_;
        do
          v12 = __ldaxr(v11);
        while (__stlxr(v12 - 1, v11));
        if (!v12)
        {
          ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
          std::__shared_weak_count::__release_weak(v14);
        }
      }
      if (v4)
        dispatch_release(v4);
      if (v17 < 0)
        operator delete(__p);
      if (SHIBYTE(v19) < 0)
        operator delete(v18[0]);
    }
  }
  else
  {
    v3 = *((_QWORD *)this + 5);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_216897000, v3, OS_LOG_TYPE_DEFAULT, "#I fWDSClient creation delayed", buf, 2u);
    }
  }
}

void sub_2169FDF10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, dispatch_object_t object, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a10);
  if (a15)
    std::__shared_weak_count::__release_weak(a15);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a12);
  if (object)
    dispatch_release(object);
  if (a22 < 0)
    operator delete(__p);
  if (a28 < 0)
    operator delete(a23);
  _Unwind_Resume(a1);
}

void QMIDataContextIPBase::bootstrapBBCtxCmdDriver(QMIDataContextIPBase *this)
{
  uint64_t v2;
  capabilities::ct *v3;
  NSObject *v4;
  _QWORD v5[5];
  _QWORD v6[25];
  _QWORD v7[5];
  _QWORD v8[5];
  _QWORD v9[5];
  uint8_t buf[8];
  uint64_t v11;
  void (*v12)(uint64_t, QMIServiceMsg *);
  void *v13;
  _QWORD *v14;

  if (*((_QWORD *)this + 20))
  {
    v2 = MEMORY[0x24BDAC760];
    v9[0] = MEMORY[0x24BDAC760];
    v9[1] = 0x40000000;
    v9[2] = ___ZN20QMIDataContextIPBase23bootstrapBBCtxCmdDriverEv_block_invoke;
    v9[3] = &__block_descriptor_tmp_35;
    v9[4] = this;
    *(_QWORD *)buf = MEMORY[0x24BDAC760];
    v11 = 0x40000000;
    v12 = ___ZNK3qmi6Client13setIndHandlerIRKN3wds22ExtendedIPConfigChange10IndicationEEEvtU13block_pointerFvT_E_block_invoke;
    v13 = &unk_24D5DF168;
    v14 = v9;
    v3 = (capabilities::ct *)qmi::Client::setIndHandler();
    if (capabilities::ct::supportsThroughputEngineering(v3))
    {
      v8[0] = v2;
      v8[1] = 0x40000000;
      v8[2] = ___ZN20QMIDataContextIPBase23bootstrapBBCtxCmdDriverEv_block_invoke_2;
      v8[3] = &__block_descriptor_tmp_73_4;
      v8[4] = this;
      *(_QWORD *)buf = v2;
      v11 = 0x40000000;
      v12 = ___ZNK3qmi6Client13setIndHandlerIRKN3wds8ANBRInfo10IndicationEEEvtU13block_pointerFvT_E_block_invoke;
      v13 = &unk_24D5DF190;
      v14 = v8;
      qmi::Client::setIndHandler();
      v7[0] = v2;
      v7[1] = 0x40000000;
      v7[2] = ___ZN20QMIDataContextIPBase23bootstrapBBCtxCmdDriverEv_block_invoke_3;
      v7[3] = &__block_descriptor_tmp_74_5;
      v7[4] = this;
      *(_QWORD *)buf = v2;
      v11 = 0x40000000;
      v12 = ___ZNK3qmi6Client13setIndHandlerIRKN3wds21ANBRProhibitTimerInfo10IndicationEEEvtU13block_pointerFvT_E_block_invoke;
      v13 = &unk_24D5DF1B8;
      v14 = v7;
      qmi::Client::setIndHandler();
    }
    v6[20] = v2;
    v6[21] = 0x40000000;
    v6[22] = ___ZN20QMIDataContextIPBase23bootstrapBBCtxCmdDriverEv_block_invoke_4;
    v6[23] = &__block_descriptor_tmp_76_2;
    v6[24] = this;
    qmi::Client::setHandler();
    v6[15] = v2;
    v6[16] = 0x40000000;
    v6[17] = ___ZN20QMIDataContextIPBase23bootstrapBBCtxCmdDriverEv_block_invoke_5;
    v6[18] = &__block_descriptor_tmp_77_1;
    v6[19] = this;
    qmi::Client::setHandler();
    v6[10] = v2;
    v6[11] = 0x40000000;
    v6[12] = ___ZN20QMIDataContextIPBase23bootstrapBBCtxCmdDriverEv_block_invoke_6;
    v6[13] = &__block_descriptor_tmp_79_1;
    v6[14] = this;
    qmi::Client::setHandler();
    v6[5] = v2;
    v6[6] = 0x40000000;
    v6[7] = ___ZN20QMIDataContextIPBase23bootstrapBBCtxCmdDriverEv_block_invoke_7;
    v6[8] = &__block_descriptor_tmp_80_2;
    v6[9] = this;
    qmi::Client::setHandler();
    v6[0] = v2;
    v6[1] = 0x40000000;
    v6[2] = ___ZN20QMIDataContextIPBase23bootstrapBBCtxCmdDriverEv_block_invoke_8;
    v6[3] = &__block_descriptor_tmp_81_1;
    v6[4] = this;
    *(_QWORD *)buf = v2;
    v11 = 0x40000000;
    v12 = ___ZNK3qmi6Client13setIndHandlerIRKN3wds13PktSrvcStatus10IndicationEEEvtU13block_pointerFvT_E_block_invoke;
    v13 = &unk_24D5DF1E0;
    v14 = v6;
    qmi::Client::setIndHandler();
    v5[0] = v2;
    v5[1] = 0x40000000;
    v5[2] = ___ZN20QMIDataContextIPBase23bootstrapBBCtxCmdDriverEv_block_invoke_9;
    v5[3] = &__block_descriptor_tmp_82_1;
    v5[4] = this;
    *(_QWORD *)buf = v2;
    v11 = 0x40000000;
    v12 = ___ZNK3qmi6Client13setIndHandlerIRKN3wds11DadComplete10IndicationEEEvtU13block_pointerFvT_E_block_invoke;
    v13 = &unk_24D5DF208;
    v14 = v5;
    qmi::Client::setIndHandler();
    qmi::Client::setIndShouldWake((QMIDataContextIPBase *)((char *)this + 144));
  }
  else
  {
    v4 = *((_QWORD *)this + 5);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I fWDSClient bootstrap delayed", buf, 2u);
    }
  }
}

void ___ZN20QMIDataContextIPBase23bootstrapBBCtxCmdDriverEv_block_invoke(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  void *v3;
  NSObject *v4;
  _QWORD v5[6];
  uint64_t v6;
  int v7;
  uint64_t v8;
  void *aBlock;
  _OWORD v10[2];
  __int128 buf;
  void (*v12)(uint64_t, QMIServiceMsg *);
  void *v13;
  _QWORD *v14;
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v1 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)(v1 + 257))
  {
    v2 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 136315138;
      *(_QWORD *)((char *)&buf + 4) = "handleWdsExtendedIPConfigChangeInd";
      _os_log_impl(&dword_216897000, v2, OS_LOG_TYPE_DEFAULT, "#I %s: start", (uint8_t *)&buf, 0xCu);
    }
    if (*(_QWORD *)(v1 + 160))
    {
      memset(v10, 0, sizeof(v10));
      qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v10);
      *(_DWORD *)qmi::MutableMessageBase::getTLV<wds::tlv::Settings>(v10) = 268288;
      v5[5] = v1 + 144;
      v6 = QMIServiceMsg::create();
      v7 = 25000;
      v8 = 0;
      aBlock = 0;
      v5[0] = MEMORY[0x24BDAC760];
      v5[1] = 0x40000000;
      v5[2] = ___ZN20QMIDataContextIPBase34handleWdsExtendedIPConfigChangeIndERKN3wds22ExtendedIPConfigChange10IndicationE_block_invoke_2;
      v5[3] = &__block_descriptor_tmp_191_0;
      v5[4] = v1;
      *(_QWORD *)&buf = MEMORY[0x24BDAC760];
      *((_QWORD *)&buf + 1) = 0x40000000;
      v12 = ___ZNO3qmi6Client9SendProxy8callbackIN3wds18GetRuntimeSettings8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
      v13 = &unk_24D5DF860;
      v14 = v5;
      v3 = _Block_copy(&buf);
      aBlock = v3;
      if (v6)
      {
        qmi::Client::send();
        v3 = aBlock;
      }
      if (v3)
        _Block_release(v3);
      qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v10);
    }
    else
    {
      v4 = *(NSObject **)(v1 + 40);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buf) = 0;
        _os_log_error_impl(&dword_216897000, v4, OS_LOG_TYPE_ERROR, "ipconfig after client is deleted", (uint8_t *)&buf, 2u);
      }
    }
  }
}

void sub_2169FE458(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *aBlock, char a19)
{
  if (a15)
    qmi::Client::send();
  if (aBlock)
    _Block_release(aBlock);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a19);
  _Unwind_Resume(a1);
}

void ___ZN20QMIDataContextIPBase23bootstrapBBCtxCmdDriverEv_block_invoke_2(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v2;
  NSObject *v4;
  uint64_t TlvValue;
  int v6;
  uint64_t v7;
  int v8;
  unint64_t v9;
  unint64_t v10;
  char v11;
  NSObject *v12;
  const char *v13;
  NSObject *v14;
  uint32_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  int v20;
  std::__shared_weak_count *v21;
  std::__shared_weak_count *v22;
  std::__shared_weak_count *v23;
  uint64_t v24;
  unint64_t *p_shared_owners;
  unint64_t v26;
  NSObject *v27;
  const char *v28;
  NSObject *v29;
  std::__shared_weak_count *v30;
  std::__shared_weak_count *v31;
  uint64_t v32;
  unint64_t *v33;
  uint64_t v34;
  _BYTE buf[24];
  uint64_t v36;

  v36 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 32);
  if (*(_BYTE *)(v2 + 257))
    return;
  v4 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315138;
    *(_QWORD *)&buf[4] = "handleWdsANBRInfoInd";
    _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I %s: start", buf, 0xCu);
  }
  if (!*(_QWORD *)(v2 + 160))
  {
    v12 = *(NSObject **)(v2 + 40);
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      return;
    *(_WORD *)buf = 0;
    v13 = "ANBRInfo after client is deleted";
    v14 = v12;
    v15 = 2;
    goto LABEL_16;
  }
  TlvValue = qmi::MessageBase::findTlvValue(a2);
  v7 = TlvValue;
  if (!TlvValue)
    return;
  v8 = v6;
  v34 = TlvValue;
  v9 = tlv::parseV<wds::tlv::BitRateInfo>((unint64_t *)&v34, v6);
  if (!v34)
  {
    ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 1, v7, v8);
    return;
  }
  v10 = HIDWORD(v9);
  if (!HIDWORD(v9))
  {
    v27 = *(NSObject **)(v2 + 40);
    if (!os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      return;
    *(_WORD *)buf = 0;
    v28 = "#N We got ABNR information for an unknown direction";
    goto LABEL_45;
  }
  if (HIDWORD(v9) == 2)
  {
    if (*(_BYTE *)(v2 + 856))
    {
      if (*(_DWORD *)(v2 + 840) == (_DWORD)v9)
      {
        v11 = 1;
        goto LABEL_21;
      }
      v27 = *(NSObject **)(v2 + 40);
      if (!os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
        return;
      *(_WORD *)buf = 0;
      v28 = "#N We got downlink ABNR information for an unknown filter";
    }
    else
    {
      v27 = *(NSObject **)(v2 + 40);
      if (!os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
        return;
      *(_WORD *)buf = 0;
      v28 = "#N We got downlink ABNR information but we do not have a registered downlink filter";
    }
LABEL_45:
    _os_log_impl(&dword_216897000, v27, OS_LOG_TYPE_DEFAULT, v28, buf, 2u);
    return;
  }
  if (HIDWORD(v9) != 1)
  {
    v29 = *(NSObject **)(v2 + 40);
    if (!os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
      return;
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v10;
    v13 = "We got ABNR information for an unknown direction value: %d";
    v14 = v29;
    v15 = 8;
LABEL_16:
    _os_log_error_impl(&dword_216897000, v14, OS_LOG_TYPE_ERROR, v13, buf, v15);
    return;
  }
  if (!*(_BYTE *)(v2 + 856))
  {
    v27 = *(NSObject **)(v2 + 40);
    if (!os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      return;
    *(_WORD *)buf = 0;
    v28 = "#N We got uplink ABNR information but we do not have a registered uplink filter";
    goto LABEL_45;
  }
  if (*(_DWORD *)(v2 + 840) != (_DWORD)v9)
  {
    v27 = *(NSObject **)(v2 + 40);
    if (!os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      return;
    *(_WORD *)buf = 0;
    v28 = "#N We got uplink ABNR information for an unknown filter";
    goto LABEL_45;
  }
  v11 = 0;
LABEL_21:
  v16 = qmi::MessageBase::findTlvValue(a2);
  v18 = v16;
  if (v16)
  {
    v19 = v17;
    *(_QWORD *)buf = v16;
    v20 = tlv::parseV<wds::tlv::BitrateBps>((unint64_t *)buf, v17);
    if (!*(_QWORD *)buf)
    {
      ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 193, v18, v19);
      return;
    }
    if (*(_BYTE *)(v2 + 856))
    {
      if ((v11 & 1) != 0)
      {
        *(_DWORD *)(v2 + 848) = v20;
        v21 = *(std::__shared_weak_count **)(v2 + 104);
        if (!v21)
          return;
        v22 = std::__shared_weak_count::lock(v21);
        if (!v22)
          return;
        v23 = v22;
        v24 = *(_QWORD *)(v2 + 96);
        if (v24)
        {
          if (!*(_BYTE *)(v2 + 856))
            std::__throw_bad_optional_access[abi:ne180100]();
          (*(void (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)v24 + 112))(v24, *(unsigned int *)(v2 + 848), 0);
        }
        p_shared_owners = (unint64_t *)&v23->__shared_owners_;
        do
          v26 = __ldaxr(p_shared_owners);
        while (__stlxr(v26 - 1, p_shared_owners));
      }
      else
      {
        *(_DWORD *)(v2 + 844) = v20;
        v30 = *(std::__shared_weak_count **)(v2 + 104);
        if (!v30)
          return;
        v31 = std::__shared_weak_count::lock(v30);
        if (!v31)
          return;
        v23 = v31;
        v32 = *(_QWORD *)(v2 + 96);
        if (v32)
        {
          if (!*(_BYTE *)(v2 + 856))
            std::__throw_bad_optional_access[abi:ne180100]();
          (*(void (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)v32 + 112))(v32, *(unsigned int *)(v2 + 844), 1);
        }
        v33 = (unint64_t *)&v23->__shared_owners_;
        do
          v26 = __ldaxr(v33);
        while (__stlxr(v26 - 1, v33));
      }
      if (!v26)
      {
        ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
        std::__shared_weak_count::__release_weak(v23);
      }
    }
  }
}

void sub_2169FE8C0(_Unwind_Exception *exception_object)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v4;

  p_shared_owners = (unint64_t *)&v1->__shared_owners_;
  do
    v4 = __ldaxr(p_shared_owners);
  while (__stlxr(v4 - 1, p_shared_owners));
  if (!v4)
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN20QMIDataContextIPBase23bootstrapBBCtxCmdDriverEv_block_invoke_3(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v2;
  NSObject *v4;
  uint64_t TlvValue;
  int v6;
  uint64_t v7;
  int v8;
  int v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;
  unint64_t v14;
  BOOL v15;
  __int16 v16;
  NSObject *v17;
  std::__shared_weak_count *v18;
  std::__shared_weak_count *v19;
  std::__shared_weak_count *v20;
  uint64_t v21;
  unint64_t *p_shared_owners;
  unint64_t v23;
  _BYTE v24[24];
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 32);
  if (*(_BYTE *)(v2 + 257))
    return;
  v4 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)v24 = 136315138;
    *(_QWORD *)&v24[4] = "handleWdsANBRProhibitTimerInfoInd";
    _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I %s: start", v24, 0xCu);
  }
  if (*(_QWORD *)(v2 + 160))
  {
    TlvValue = qmi::MessageBase::findTlvValue(a2);
    v7 = TlvValue;
    if (TlvValue)
    {
      v8 = v6;
      *(_QWORD *)v24 = TlvValue;
      v9 = tlv::parseV<wds::tlv::ProhibitTimerHandle>((unint64_t *)v24, v6);
      if (*(_QWORD *)v24)
        goto LABEL_10;
      ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 1, v7, v8);
    }
    v9 = 0;
LABEL_10:
    v10 = qmi::MessageBase::findTlvValue(a2);
    v12 = v10;
    if (v10)
    {
      v13 = v11;
      *(_QWORD *)v24 = v10;
      v14 = tlv::parseV<wds::tlv::ProhibitTimerInfo>((unint64_t *)v24, v11);
      if (*(_QWORD *)v24)
      {
        if ((_BYTE)v14)
          v15 = HIDWORD(v14) == 0;
        else
          v15 = 1;
        v16 = !v15;
LABEL_22:
        if (*(_BYTE *)(v2 + 856))
        {
          if (*(_DWORD *)(v2 + 840) == v9)
          {
            *(_WORD *)(v2 + 852) = v16 | 0x100;
            v18 = *(std::__shared_weak_count **)(v2 + 104);
            if (v18)
            {
              v19 = std::__shared_weak_count::lock(v18);
              if (v19)
              {
                v20 = v19;
                v21 = *(_QWORD *)(v2 + 96);
                if (v21)
                {
                  if (!*(_BYTE *)(v2 + 856) || !*(_BYTE *)(v2 + 853))
                    std::__throw_bad_optional_access[abi:ne180100]();
                  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v21 + 104))(v21, *(unsigned __int8 *)(v2 + 852));
                }
                p_shared_owners = (unint64_t *)&v20->__shared_owners_;
                do
                  v23 = __ldaxr(p_shared_owners);
                while (__stlxr(v23 - 1, p_shared_owners));
                if (!v23)
                {
                  ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
                  std::__shared_weak_count::__release_weak(v20);
                }
              }
            }
          }
        }
        return;
      }
      ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 2, v12, v13);
    }
    v16 = 0;
    goto LABEL_22;
  }
  v17 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)v24 = 0;
    _os_log_error_impl(&dword_216897000, v17, OS_LOG_TYPE_ERROR, "ANBRProhibitTimerInfo after client is deleted", v24, 2u);
  }
}

void sub_2169FEB70(_Unwind_Exception *exception_object)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v4;

  p_shared_owners = (unint64_t *)&v1->__shared_owners_;
  do
    v4 = __ldaxr(p_shared_owners);
  while (__stlxr(v4 - 1, p_shared_owners));
  if (!v4)
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN20QMIDataContextIPBase23bootstrapBBCtxCmdDriverEv_block_invoke_5(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  _WORD *v3;
  _QWORD *v4;
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  _BYTE *v8;
  std::__shared_weak_count *v9;
  int v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  const void **v13;
  NSObject *v14;
  void *v15;
  char *v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  char *v25;
  uint64_t *v26;
  char *v27;
  char *v28;
  char *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  _QWORD *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  void *v37;
  void *v38;
  uint64_t v39;
  uint64_t v40;
  void *v41;
  void *v42;
  uint64_t v43;
  void *__p[2];
  __int128 v45;
  uint64_t aBlock;
  uint64_t v47;
  void (*v48)(uint64_t, QMIServiceMsg *);
  void *v49;
  uint8_t *v50;
  uint8_t buf[8];
  uint64_t v52;
  uint64_t (*v53)(uint64_t, uint64_t);
  void *v54;
  uint64_t v55;
  _BYTE v56[24];
  _BYTE *v57;
  _QWORD v58[3];
  _QWORD *v59;
  uint64_t v60;

  v60 = *MEMORY[0x24BDAC8D0];
  v1 = *(_QWORD *)(a1 + 32);
  if (*(_BYTE *)(v1 + 257))
    return;
  if (!*(_QWORD *)(v1 + 160))
  {
    v6 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_216897000, v6, OS_LOG_TYPE_DEFAULT, "#I received kEventStarted after client is deleted", buf, 2u);
    }
    return;
  }
  QMIDataContextIPBase::setQMIChannelState(*(_QWORD *)(a1 + 32), 0);
  v58[0] = &off_24D5DF470;
  v58[1] = v1;
  v58[2] = 0;
  v59 = v58;
  if (!(*(unsigned int (**)(_QWORD))(**(_QWORD **)(v1 + 616) + 184))(*(_QWORD *)(v1 + 616)))
  {
    if (!(*(unsigned int (**)(_QWORD))(**(_QWORD **)(v1 + 616) + 192))(*(_QWORD *)(v1 + 616)))
    {
      v14 = *(NSObject **)(v1 + 40);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_216897000, v14, OS_LOG_TYPE_ERROR, "Unknown baseband type", buf, 2u);
      }
      if (!v59)
        std::__throw_bad_function_call[abi:ne180100]();
      (*(void (**)(_QWORD *))(*v59 + 48))(v59);
      goto LABEL_65;
    }
    *(_OWORD *)__p = 0u;
    v45 = 0u;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
    v7 = MEMORY[0x24BDAC760];
    v39 = MEMORY[0x24BDAC760];
    v40 = 0x40000000;
    v41 = ___ZN20QMIDataContextIPBase12bindDataPortEv_block_invoke_115;
    v42 = &__block_descriptor_tmp_117_1;
    v43 = v1;
    v8 = (_BYTE *)qmi::MutableMessageBase::getTLV<wds::tlv::MuxId>(__p, 17);
    ___ZN20QMIDataContextIPBase12bindDataPortEv_block_invoke_115((uint64_t)&v39, v8);
    v9 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v1 + 104));
    v10 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v1 + 96) + 392))(*(_QWORD *)(v1 + 96));
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v12 = __ldaxr(p_shared_owners);
    while (__stlxr(v12 - 1, p_shared_owners));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
    if (v10)
    {
      v13 = (const void **)__p[1];
      if (__p[1] != (void *)v45)
      {
        while (*((_BYTE *)*v13 + 8) != 16)
        {
          if (++v13 == (const void **)v45)
            goto LABEL_32;
        }
      }
      if (v13 == (const void **)v45)
      {
LABEL_32:
        v18 = operator new();
        v19 = v18;
        *(_BYTE *)(v18 + 8) = 16;
        *(_QWORD *)v18 = &off_24D5DF5B0;
        *(_DWORD *)(v18 + 12) = 0;
        v17 = (_QWORD *)(v18 + 12);
        *(_DWORD *)(v18 + 16) = 0;
        v20 = v45;
        if ((unint64_t)v45 >= *((_QWORD *)&v45 + 1))
        {
          v22 = (uint64_t)(v45 - (unint64_t)__p[1]) >> 3;
          if ((unint64_t)(v22 + 1) >> 61)
            std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
          v23 = (uint64_t)(*((_QWORD *)&v45 + 1) - (unint64_t)__p[1]) >> 2;
          if (v23 <= v22 + 1)
            v23 = v22 + 1;
          if (*((_QWORD *)&v45 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
            v24 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v24 = v23;
          if (v24)
            v25 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v45 + 8, v24);
          else
            v25 = 0;
          v26 = (uint64_t *)&v25[8 * v22];
          v27 = &v25[8 * v24];
          *v26 = v19;
          v21 = v26 + 1;
          v29 = (char *)__p[1];
          v28 = (char *)v45;
          if ((void *)v45 != __p[1])
          {
            do
            {
              v30 = *((_QWORD *)v28 - 1);
              v28 -= 8;
              *--v26 = v30;
            }
            while (v28 != v29);
            v28 = (char *)__p[1];
          }
          __p[1] = v26;
          *(_QWORD *)&v45 = v21;
          *((_QWORD *)&v45 + 1) = v27;
          if (v28)
            operator delete(v28);
        }
        else
        {
          *(_QWORD *)v45 = v18;
          v21 = (_QWORD *)(v20 + 8);
        }
        *(_QWORD *)&v45 = v21;
      }
      else
      {
        if (!v16)
          __cxa_bad_cast();
        v17 = v16 + 12;
      }
      *v17 = 0x400000003;
    }
    QMIDataContextIPBase::setQMIChannelState(v1, 1u);
    v36 = QMIServiceMsg::create();
    *(_QWORD *)buf = v7;
    v52 = 1174405120;
    v53 = ___ZN20QMIDataContextIPBase12bindDataPortEv_block_invoke_2_118;
    v54 = &__block_descriptor_tmp_120_1;
    v55 = v1;
    v4 = v56;
    v31 = (uint64_t)v59;
    if (v59)
    {
      if (v59 == v58)
      {
        v57 = v56;
        (*(void (**)(_QWORD *, _BYTE *))(v58[0] + 24))(v58, v56);
LABEL_55:
        aBlock = v7;
        v47 = 0x40000000;
        v48 = ___ZNO3qmi6Client9SendProxy8callbackIRKN3wds15BindMuxDataPort8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
        v49 = &unk_24D5DF5E0;
        v50 = buf;
        v15 = _Block_copy(&aBlock);
        v38 = v15;
        if (v36)
        {
          qmi::Client::send();
          v15 = v38;
        }
        if (v15)
          goto LABEL_58;
        goto LABEL_59;
      }
      v31 = (*(uint64_t (**)(_QWORD *))(*v59 + 16))(v59);
    }
    v57 = (_BYTE *)v31;
    goto LABEL_55;
  }
  *(_OWORD *)__p = 0u;
  v45 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  v2 = MEMORY[0x24BDAC760];
  v39 = MEMORY[0x24BDAC760];
  v40 = 0x40000000;
  v41 = ___ZN20QMIDataContextIPBase12bindDataPortEv_block_invoke;
  v42 = &__block_descriptor_tmp_113_2;
  v43 = v1;
  v3 = (_WORD *)qmi::MutableMessageBase::getTLV<wds::tlv::DataPort>(__p, 1);
  ___ZN20QMIDataContextIPBase12bindDataPortEv_block_invoke((uint64_t)&v39, v3);
  QMIDataContextIPBase::setQMIChannelState(v1, 1u);
  v35 = QMIServiceMsg::create();
  *(_QWORD *)buf = v2;
  v52 = 1174405120;
  v53 = ___ZN20QMIDataContextIPBase12bindDataPortEv_block_invoke_2;
  v54 = &__block_descriptor_tmp_114_1;
  v55 = v1;
  v4 = v56;
  v5 = (uint64_t)v59;
  if (!v59)
  {
LABEL_7:
    v57 = (_BYTE *)v5;
    goto LABEL_25;
  }
  if (v59 != v58)
  {
    v5 = (*(uint64_t (**)(_QWORD *))(*v59 + 16))(v59);
    goto LABEL_7;
  }
  v57 = v56;
  (*(void (**)(_QWORD *, _BYTE *))(v58[0] + 24))(v58, v56);
LABEL_25:
  aBlock = v2;
  v47 = 0x40000000;
  v48 = ___ZNO3qmi6Client9SendProxy8callbackIRKN3wds12BindDataPort8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
  v49 = &unk_24D5DF568;
  v50 = buf;
  v15 = _Block_copy(&aBlock);
  v37 = v15;
  if (v35)
  {
    qmi::Client::send();
    v15 = v37;
  }
  if (v15)
LABEL_58:
    _Block_release(v15);
LABEL_59:
  if (v57 == v56)
  {
    v32 = 4;
    goto LABEL_63;
  }
  if (v57)
  {
    v32 = 5;
    v4 = v57;
LABEL_63:
    (*(void (**)(_QWORD *))(*v4 + 8 * v32))(v4);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
LABEL_65:
  v33 = v59;
  if (v59 == v58)
  {
    v34 = 4;
    v33 = v58;
  }
  else
  {
    if (!v59)
      return;
    v34 = 5;
  }
  (*(void (**)(_QWORD *))(*v33 + 8 * v34))(v33);
}

void sub_2169FF1EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *aBlock, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37)
{
  uint64_t v37;
  _QWORD *v39;
  uint64_t v40;

  if (a10)
    qmi::Client::send();
  if (aBlock)
    _Block_release(aBlock);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a19);
  v39 = *(_QWORD **)(v37 - 80);
  if (v39 == (_QWORD *)(v37 - 104))
  {
    v40 = 4;
    v39 = (_QWORD *)(v37 - 104);
  }
  else
  {
    if (!v39)
      goto LABEL_10;
    v40 = 5;
  }
  (*(void (**)(void))(*v39 + 8 * v40))();
LABEL_10:
  _Unwind_Resume(a1);
}

void ___ZN20QMIDataContextIPBase23bootstrapBBCtxCmdDriverEv_block_invoke_6(uint64_t a1, dispatch_object_t object)
{
  uint64_t v3;
  NSObject *v4;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  uint64_t v9;
  _BOOL8 v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  dispatch_group_t group;
  __int128 buf;
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 + 32);
  if (object)
  {
    dispatch_retain(object);
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  v4 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 136315138;
    *(_QWORD *)((char *)&buf + 4) = "handleWDSEnterLowPower_sync";
    _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I %s: (WDS) Entering low power", (uint8_t *)&buf, 0xCu);
  }
  v5 = *(std::__shared_weak_count **)(v3 + 128);
  if (!v5)
    goto LABEL_19;
  v6 = std::__shared_weak_count::lock(v5);
  *((_QWORD *)&buf + 1) = v6;
  if (!v6)
    goto LABEL_19;
  v7 = v6;
  v8 = *(_QWORD *)(v3 + 120);
  *(_QWORD *)&buf = v8;
  if (v8)
  {
    v9 = *(_QWORD *)(v3 + 576);
    if (*(_BYTE *)(v3 + 112))
      v10 = *(_DWORD *)(v3 + 140) == 1;
    else
      v10 = 0;
    group = object;
    if (object)
    {
      dispatch_retain(object);
      dispatch_group_enter(object);
    }
    (*(void (**)(uint64_t, uint64_t, _BOOL8, dispatch_group_t *))(*(_QWORD *)v8 + 56))(v8, v9, v10, &group);
    if (group)
    {
      dispatch_group_leave(group);
      if (group)
        dispatch_release(group);
    }
  }
  p_shared_owners = (unint64_t *)&v7->__shared_owners_;
  do
    v12 = __ldaxr(p_shared_owners);
  while (__stlxr(v12 - 1, p_shared_owners));
  if (v12)
  {
LABEL_19:
    if (!object)
      return;
    goto LABEL_20;
  }
  ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
  std::__shared_weak_count::__release_weak(v7);
  if (object)
  {
LABEL_20:
    dispatch_group_leave(object);
    dispatch_release(object);
    dispatch_release(object);
  }
}

void sub_2169FF548(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_group_t group, char a11)
{
  NSObject *v11;

  if (group)
  {
    dispatch_group_leave(group);
    dispatch_release(group);
  }
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  if (v11)
  {
    dispatch_group_leave(v11);
    dispatch_release(v11);
    dispatch_release(v11);
  }
  _Unwind_Resume(a1);
}

void ___ZN20QMIDataContextIPBase23bootstrapBBCtxCmdDriverEv_block_invoke_7(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  uint64_t v6;
  _BOOL8 v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  int v10;
  const char *v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v10 = 136315138;
    v11 = "handleWDSExitLowPower_sync";
    _os_log_impl(&dword_216897000, v2, OS_LOG_TYPE_DEFAULT, "#I %s: (WDS) Exiting low power", (uint8_t *)&v10, 0xCu);
  }
  v3 = *(std::__shared_weak_count **)(v1 + 128);
  if (v3)
  {
    v4 = std::__shared_weak_count::lock(v3);
    if (v4)
    {
      v5 = v4;
      v6 = *(_QWORD *)(v1 + 120);
      if (v6)
      {
        if (*(_BYTE *)(v1 + 112))
          v7 = *(_DWORD *)(v1 + 140) == 1;
        else
          v7 = 0;
        (*(void (**)(uint64_t, _QWORD, _BOOL8))(*(_QWORD *)v6 + 64))(v6, *(_QWORD *)(v1 + 576), v7);
      }
      p_shared_owners = (unint64_t *)&v5->__shared_owners_;
      do
        v9 = __ldaxr(p_shared_owners);
      while (__stlxr(v9 - 1, p_shared_owners));
      if (!v9)
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
    }
  }
}

void sub_2169FF6A8(_Unwind_Exception *exception_object)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v4;

  p_shared_owners = (unint64_t *)&v1->__shared_owners_;
  do
    v4 = __ldaxr(p_shared_owners);
  while (__stlxr(v4 - 1, p_shared_owners));
  if (!v4)
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN20QMIDataContextIPBase23bootstrapBBCtxCmdDriverEv_block_invoke_8(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v2;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  uint64_t v7;
  uint64_t TlvValue;
  int v9;
  uint64_t v10;
  int v11;
  NSObject *v12;
  int v13;
  NSObject *v14;
  _BOOL4 v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  NSObject *v19;
  int v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  int v24;
  NSObject *v25;
  int v26;
  int v27;
  const char *v28;
  NSObject *v29;
  uint32_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  char v34;
  uint64_t v35;
  uint64_t CSIError;
  int v37;
  int v38;
  NSObject *v39;
  NSObject *v40;
  NSObject *v41;
  capabilities::ct *v42;
  NSObject *v43;
  uint64_t v44;
  NSObject *v45;
  std::__shared_weak_count *v46;
  unint64_t *v47;
  unint64_t v48;
  void *v49;
  std::__shared_weak_count *v50;
  std::__shared_weak_count *v51;
  uint64_t v52;
  std::__shared_weak_count *v53;
  std::__shared_weak_count *v54;
  std::__shared_weak_count *v55;
  char v56;
  char *v57;
  unint64_t *v58;
  unint64_t v59;
  unint64_t *v60;
  unint64_t v61;
  uint64_t v62;
  std::__shared_weak_count *v63;
  uint64_t v64;
  uint64_t v65;
  std::__shared_weak_count *v66;
  unint64_t *v67;
  unint64_t v68;
  std::__shared_weak_count *v69;
  unint64_t *v70;
  unint64_t v71;
  unint64_t *v72;
  unint64_t v73;
  uint64_t v74;
  NSObject *v75;
  unsigned __int8 v76;
  int v77;
  const char *v78;
  int v79;
  void **v80;
  int v81;
  uint64_t v82;
  void **v83;
  uint64_t v84;
  NSObject *v85;
  const char *v86;
  void **v87;
  const std::string::value_type *v88;
  std::__shared_weak_count *v89;
  unint64_t *v90;
  unint64_t v91;
  char v92;
  uint64_t v93;
  std::__shared_weak_count *v94;
  unint64_t *v95;
  unint64_t v96;
  int v97;
  capabilities::ct *v99;
  NSObject *v100;
  uint64_t v101;
  std::__shared_weak_count *v102;
  unint64_t *v103;
  unint64_t v104;
  std::__shared_weak_count *v105;
  unint64_t *v106;
  unint64_t v107;
  unint64_t *v108;
  char v109;
  int v110;
  int v111;
  int v112;
  NSObject *v113;
  const char *v114;
  int v115;
  void **v116;
  int v117;
  uint64_t v118;
  void **v119;
  int v120;
  NSObject *v121;
  const char *v122;
  NSObject *v123;
  uint32_t v124;
  unint64_t *v125;
  unint64_t *v126;
  unint64_t *v127;
  int v128;
  NSObject *v129;
  uint64_t v130;
  uint64_t v131;
  int v132;
  char v133;
  NSObject *v134;
  uint64_t v135;
  std::__shared_weak_count *v136;
  unint64_t *v137;
  unint64_t v138;
  int v139;
  NSObject *v140;
  int v141;
  NSObject *v142;
  unsigned int v143;
  char v144;
  unsigned int v145;
  unsigned int v146;
  unsigned int DSReason;
  unsigned int v148;
  int v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  void *v153;
  uint64_t v154;
  void *__p[2];
  char v156;
  uint64_t v157;
  uint64_t v158;
  void *v159;
  void *v160;
  uint64_t *v161;
  __int128 *v162;
  uint64_t v163;
  uint64_t *v164;
  uint64_t v165;
  __int16 v166;
  __int128 v167;
  __int128 v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t (*v171)(uint64_t, _WORD *);
  void *v172;
  void *aBlock;
  _QWORD v174[2];
  void (*v175)(_QWORD *, uint64_t *);
  void *v176;
  uint64_t *v177;
  uint64_t *v178;
  uint64_t *v179;
  uint64_t v180;
  uint64_t *v181;
  uint64_t v182;
  int v183;
  uint64_t v184;
  uint64_t *v185;
  uint64_t v186;
  int v187;
  uint64_t v188;
  uint64_t *v189;
  uint64_t v190;
  char v191;
  _QWORD v192[2];
  uint64_t (*v193)(uint64_t, _BYTE *);
  void *v194;
  uint64_t *v195;
  uint64_t *v196;
  uint64_t v197;
  std::__shared_weak_count *v198;
  uint64_t v199;
  uint64_t *v200;
  uint64_t v201;
  char v202;
  uint64_t v203;
  uint64_t *v204;
  uint64_t v205;
  char v206;
  _BYTE buf[64];
  uint64_t v208;
  uint64_t v209;

  v209 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)(v2 + 257))
  {
    v203 = 0;
    v204 = &v203;
    v205 = 0x2000000000;
    v206 = 0;
    v199 = 0;
    v200 = &v199;
    v201 = 0x2000000000;
    v202 = 0;
    if (!*(_QWORD *)(v2 + 160))
    {
      v12 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_216897000, v12, OS_LOG_TYPE_ERROR, "received pktSvcStatInd after client is deleted", buf, 2u);
      }
      goto LABEL_45;
    }
    v197 = 0;
    v198 = 0;
    v4 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v2 + 104));
    (*(void (**)(uint64_t *__return_ptr))(**(_QWORD **)(v2 + 96) + 240))(&v197);
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
    if (!v197)
    {
      v13 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 96))(v2);
      v14 = *(NSObject **)(v2 + 40);
      v15 = os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT);
      if (v13 == 3)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136315138;
          *(_QWORD *)&buf[4] = "handleWdsPacketSvcStatusInd";
          _os_log_impl(&dword_216897000, v14, OS_LOG_TYPE_DEFAULT, "#N %s: Stale deactivation ?", buf, 0xCu);
        }
        QMIDataContextIPBase::setDataContextIPState(v2, 0);
        v16 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v2 + 104));
        (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)(v2 + 96) + 72))(*(_QWORD *)(v2 + 96), *(unsigned int *)(v2 + 140));
        v17 = (unint64_t *)&v16->__shared_owners_;
        do
          v18 = __ldaxr(v17);
        while (__stlxr(v18 - 1, v17));
        if (!v18)
        {
          ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
          std::__shared_weak_count::__release_weak(v16);
        }
        QMIDataContextIPBase::doneWithContext((QMIDataContextIPBase *)v2);
      }
      else if (v15)
      {
        *(_DWORD *)buf = 136315138;
        *(_QWORD *)&buf[4] = "handleWdsPacketSvcStatusInd";
        _os_log_impl(&dword_216897000, v14, OS_LOG_TYPE_DEFAULT, "#E %s: WdsPacketSvcStatusInd not expected at this point !", buf, 0xCu);
      }
      goto LABEL_40;
    }
    v7 = MEMORY[0x24BDAC760];
    v192[0] = MEMORY[0x24BDAC760];
    v192[1] = 0x40000000;
    v193 = ___ZN20QMIDataContextIPBase27handleWdsPacketSvcStatusIndERKN3wds13PktSrvcStatus10IndicationE_block_invoke;
    v194 = &unk_24D5DEB08;
    v195 = &v203;
    v196 = &v199;
    TlvValue = qmi::MessageBase::findTlvValue(a2);
    v10 = TlvValue;
    if (TlvValue)
    {
      v11 = v9;
      *(_QWORD *)buf = TlvValue;
      LOWORD(v174[0]) = tlv::parseV<wds::tlv::PktStatus>((unint64_t *)buf, v9);
      if (*(_QWORD *)buf)
        v193((uint64_t)v192, v174);
      else
        ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 1, v10, v11);
    }
    if (*((_BYTE *)v200 + 24))
    {
      v19 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315138;
        *(_QWORD *)&buf[4] = "handleWdsPacketSvcStatusInd";
        _os_log_impl(&dword_216897000, v19, OS_LOG_TYPE_DEFAULT, "#I %s: Deactivating due to IP reconfiguration", buf, 0xCu);
      }
      QMIDataContextIPBase::deactivateDataContextIP((QMIDataContextIPBase *)v2, 1, 0);
      goto LABEL_40;
    }
    v188 = 0;
    v189 = &v188;
    v190 = 0x2000000000;
    v191 = 0;
    v184 = 0;
    v185 = &v184;
    v186 = 0x2000000000;
    if (*(_DWORD *)(v2 + 140) == 2)
      v20 = 6;
    else
      v20 = 4;
    v187 = v20;
    v180 = 0;
    v181 = &v180;
    v182 = 0x2000000000;
    v183 = 0;
    v174[0] = v7;
    v174[1] = 0x40000000;
    v175 = (void (*)(_QWORD *, uint64_t *))___ZN20QMIDataContextIPBase27handleWdsPacketSvcStatusIndERKN3wds13PktSrvcStatus10IndicationE_block_invoke_147;
    v176 = &unk_24D5DEB30;
    v177 = &v180;
    v178 = &v188;
    v179 = &v184;
    v21 = qmi::MessageBase::findTlvValue(a2);
    v23 = v21;
    if (v21)
    {
      v24 = v22;
      *(_QWORD *)buf = v21;
      LODWORD(v157) = tlv::parseV<wds::tlv::IPPref>((unint64_t *)buf, v22);
      if (*(_QWORD *)buf)
        v175(v174, &v157);
      else
        ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 18, v23, v24);
    }
    if (*((_BYTE *)v189 + 24))
    {
      v25 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
        v26 = *((_DWORD *)v181 + 6);
        v27 = *((_DWORD *)v185 + 6);
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = "handleWdsPacketSvcStatusInd";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v26;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v27;
        v28 = "#I %s: Received QMI_WDS_PKT_SRVC_STATUS_IND for IP Family %d but the model is %d - Bailing out";
        v29 = v25;
        v30 = 24;
LABEL_38:
        _os_log_impl(&dword_216897000, v29, OS_LOG_TYPE_DEFAULT, v28, buf, v30);
      }
      goto LABEL_39;
    }
    switch(*((_BYTE *)v204 + 24))
    {
      case 1:
        v150 = 0;
        v151 = (uint64_t)&v150;
        v152 = 0x2000000000;
        LOWORD(v153) = 0;
        v169 = v7;
        v170 = 0x40000000;
        v171 = ___ZN20QMIDataContextIPBase27handleWdsPacketSvcStatusIndERKN3wds13PktSrvcStatus10IndicationE_block_invoke_149;
        v172 = &unk_24D5DEB58;
        aBlock = &v150;
        *(_QWORD *)buf = &v169;
        qmi::MessageBase::applyTlv<wds::tlv::CallEndReason,void({block_pointer})(wds::tlv::CallEndReason const&)>(a2, (uint64_t)buf);
        *(_QWORD *)&v167 = 0;
        *((_QWORD *)&v167 + 1) = &v167;
        *(_QWORD *)&v168 = 0x2000000000;
        WORD4(v168) = 0;
        v163 = 0;
        v164 = &v163;
        v165 = 0x2000000000;
        v166 = 0;
        v157 = v7;
        v158 = 0x40000000;
        v159 = ___ZN20QMIDataContextIPBase27handleWdsPacketSvcStatusIndERKN3wds13PktSrvcStatus10IndicationE_block_invoke_2;
        v160 = &unk_24D5DEB80;
        v161 = &v163;
        v162 = &v167;
        *(_QWORD *)buf = &v157;
        qmi::MessageBase::applyTlv<wds::tlv::VerboseCallEndReasonType,void({block_pointer})(wds::tlv::VerboseCallEndReasonType const&)>(a2, (uint64_t)buf);
        v34 = 0;
        if ((*(_WORD *)(*((_QWORD *)&v167 + 1) + 24) & 0xFEu) <= 9)
          LOWORD(v35) = *(_WORD *)(*((_QWORD *)&v167 + 1) + 24);
        else
          LOBYTE(v35) = 0;
        break;
      case 2:
        if (*(_DWORD *)(v2 + 140) == 2)
        {
          v157 = v7;
          v158 = 0x40000000;
          v159 = ___ZN20QMIDataContextIPBase27handleWdsPacketSvcStatusIndERKN3wds13PktSrvcStatus10IndicationE_block_invoke_153;
          v160 = &__block_descriptor_tmp_154_0;
          v161 = (uint64_t *)v2;
          *(_QWORD *)buf = &v157;
          qmi::MessageBase::applyTlv<wds::tlv::CarrierIPv6,void({block_pointer})(wds::tlv::CarrierIPv6 const&)>(a2, (uint64_t)buf);
        }
        *(_WORD *)(v2 + 176) = 0;
        v41 = *(NSObject **)(v2 + 40);
        if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315138;
          *(_QWORD *)&buf[4] = "handleWdsPacketSvcStatusInd";
          _os_log_impl(&dword_216897000, v41, OS_LOG_TYPE_DEFAULT, "#I %s: Connection is connected", buf, 0xCu);
        }
        v42 = (capabilities::ct *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 96))(v2);
        if (v42 > 6)
          goto LABEL_39;
        if ((_DWORD)v42 == 4)
        {
          if (*(_BYTE *)(v2 + 272)
            && capabilities::ct::supports5G(v42)
            && (*(unsigned int (**)(uint64_t))(*(_QWORD *)v197 + 192))(v197))
          {
            v45 = *(NSObject **)(v2 + 40);
            if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_impl(&dword_216897000, v45, OS_LOG_TYPE_DEFAULT, "#I WiFi->Cellular HO: free PduSessionId before getruntimesettings", buf, 2u);
            }
            v46 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v2 + 104));
            (*(void (**)(_QWORD))(**(_QWORD **)(v2 + 96) + 288))(*(_QWORD *)(v2 + 96));
            v47 = (unint64_t *)&v46->__shared_owners_;
            do
              v48 = __ldaxr(v47);
            while (__stlxr(v48 - 1, v47));
            if (!v48)
            {
              ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
              std::__shared_weak_count::__release_weak(v46);
            }
          }
          v167 = 0u;
          v168 = 0u;
          qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)&v167);
          *(_DWORD *)qmi::MutableMessageBase::getTLV<wds::tlv::Settings>(&v167) = 8666385;
          v169 = v2 + 144;
          v170 = QMIServiceMsg::create();
          LODWORD(v171) = 25000;
          v172 = 0;
          aBlock = 0;
          v150 = v7;
          v151 = 0x40000000;
          v152 = (uint64_t)___ZN20QMIDataContextIPBase27handleWdsPacketSvcStatusIndERKN3wds13PktSrvcStatus10IndicationE_block_invoke_2_159;
          v153 = &__block_descriptor_tmp_161_1;
          v154 = v2;
          *(_QWORD *)buf = v7;
          *(_QWORD *)&buf[8] = 0x40000000;
          *(_QWORD *)&buf[16] = ___ZNO3qmi6Client9SendProxy8callbackIN3wds18GetRuntimeSettings8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
          *(_QWORD *)&buf[24] = &unk_24D5DF860;
          *(_QWORD *)&buf[32] = &v150;
          v49 = _Block_copy(buf);
          aBlock = v49;
          if (v170)
          {
            qmi::Client::send();
            v49 = aBlock;
          }
          if (v49)
            _Block_release(v49);
          qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&v167);
          goto LABEL_39;
        }
        v43 = *(NSObject **)(v2 + 40);
        if (!os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
          goto LABEL_39;
        (*(void (**)(uint64_t))(*(_QWORD *)v2 + 96))(v2);
        v44 = asString();
        *(_DWORD *)buf = 136315394;
        *(_QWORD *)&buf[4] = "handleWdsPacketSvcStatusInd";
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = v44;
        v28 = "#I %s: ERR: QMI_WDS_PACKET_DATA_CONNECTED at wrong state %s";
        v29 = v43;
        v30 = 22;
        goto LABEL_38;
      case 3:
        v39 = *(NSObject **)(v2 + 40);
        if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315138;
          *(_QWORD *)&buf[4] = "handleWdsPacketSvcStatusInd";
          _os_log_impl(&dword_216897000, v39, OS_LOG_TYPE_DEFAULT, "#I %s: Connection is suspended", buf, 0xCu);
        }
        if (*(_DWORD *)(v2 + 180) == -1)
        {
          if (!os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR)
            || (*(_DWORD *)buf = 136315650,
                *(_QWORD *)&buf[4] = "packet handle should not be invalid here",
                *(_WORD *)&buf[12] = 2080,
                *(_QWORD *)&buf[14] = "/Library/Caches/com.apple.xbs/Sources/CoreTelephony/CommCenter/CommCenterCommandDr"
                                      "ivers/Data/QMI/Context/QMIDataContextIPBase.cpp",
                *(_WORD *)&buf[22] = 1024,
                *(_DWORD *)&buf[24] = 1753,
                _os_log_error_impl(&dword_216897000, MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR, "\n**********\n   ASSERT fPacketDataHandle != kInvalidPacketHandle\n %s\n at %s:%d\n**********", buf, 0x1Cu), *(_DWORD *)(v2 + 180) == -1))
          {
            __TUAssertTrigger();
          }
        }
        goto LABEL_39;
      case 4:
        v40 = *(NSObject **)(v2 + 40);
        if (!os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
          goto LABEL_39;
        *(_DWORD *)buf = 136315138;
        *(_QWORD *)&buf[4] = "handleWdsPacketSvcStatusInd";
        v28 = "#I %s: Connection is authenticating";
        v29 = v40;
        v30 = 12;
        goto LABEL_38;
      default:
        goto LABEL_39;
    }
    CSIError = 1;
    v37 = *((__int16 *)v164 + 12);
    v38 = *((unsigned __int16 *)v164 + 12);
    switch((char)v35)
    {
      case 1:
        v34 = 0;
        if (v37 > 127)
        {
          switch(*((_WORD *)v164 + 12))
          {
            case 0x80:
              goto LABEL_257;
            case 0x81:
            case 0x83:
            case 0x84:
              goto LABEL_114;
            case 0x82:
              goto LABEL_113;
            default:
              goto LABEL_115;
          }
          goto LABEL_115;
        }
        if ((v37 - 67) < 2 || v37 == 65)
          goto LABEL_114;
        if (v37 != 66)
          goto LABEL_115;
        goto LABEL_113;
      case 2:
        v34 = 0;
        switch(*((_WORD *)v164 + 12))
        {
          case 0xCE:
            goto LABEL_94;
          case 0xD0:
            v34 = 0;
            CSIError = 91;
            goto LABEL_115;
          case 0xD1:
          case 0xD3:
            goto LABEL_88;
          case 0xD2:
            v34 = 0;
            CSIError = 92;
            goto LABEL_115;
          default:
            goto LABEL_115;
        }
      case 3:
        v34 = 0;
        if (v37 <= 1068)
        {
          switch(*((_WORD *)v164 + 12))
          {
            case 0x3EA:
              goto LABEL_265;
            case 0x3EB:
LABEL_257:
              v34 = 0;
              CSIError = 67;
              break;
            case 0x3EC:
              v34 = 0;
              CSIError = 55;
              break;
            case 0x3ED:
              v34 = 0;
              CSIError = 56;
              break;
            case 0x3EE:
            case 0x3EF:
              v34 = 0;
              CSIError = 57;
              break;
            case 0x3F0:
            case 0x3F1:
            case 0x3F5:
            case 0x3F6:
              goto LABEL_115;
            case 0x3F2:
            case 0x3F4:
              v34 = 0;
              CSIError = 58;
              break;
            case 0x3F3:
              v34 = 0;
              CSIError = 59;
              break;
            case 0x3F7:
              v34 = 0;
              CSIError = 5;
              break;
            default:
              if (v37 == 515)
                goto LABEL_265;
              if (v37 == 524)
              {
LABEL_88:
                v34 = 0;
                CSIError = 101;
              }
              break;
          }
          goto LABEL_115;
        }
        if (v37 <= 1517)
        {
          if (v37 <= 1151)
          {
            if (v37 == 1069)
            {
              v34 = 0;
              CSIError = 90;
              goto LABEL_115;
            }
            if (v37 != 1121 && v37 != 1130)
              goto LABEL_115;
LABEL_269:
            v34 = 0;
            CSIError = 102;
            goto LABEL_115;
          }
          if (v37 == 1152)
          {
            v34 = 0;
            CSIError = 103;
            goto LABEL_115;
          }
          if (v37 != 1504 && v37 != 1510)
          {
LABEL_115:
            v50 = *(std::__shared_weak_count **)(v2 + 104);
            if (v50)
            {
              v51 = std::__shared_weak_count::lock(v50);
              if (v51)
              {
                v52 = *(_QWORD *)(v2 + 96);
                goto LABEL_120;
              }
            }
            else
            {
              v51 = 0;
            }
            v52 = 0;
LABEL_120:
            v53 = *(std::__shared_weak_count **)(v2 + 128);
            if (v53)
            {
              v54 = std::__shared_weak_count::lock(v53);
              if (v54)
              {
                v55 = v54;
                v56 = v34;
                if (v52)
                {
                  v57 = *(char **)(v2 + 120);
                  if (v57)
                  {
                    v208 = 0;
                    memset(buf, 0, sizeof(buf));
                    (*(void (**)(_BYTE *__return_ptr, uint64_t))(*(_QWORD *)v52 + 304))(&buf[8], v52);
                    buf[32] = (*(unsigned int (**)(uint64_t))(*(_QWORD *)v2 + 96))(v2) == 4;
                    *(_QWORD *)&buf[40] = (*(uint64_t (**)(uint64_t, _QWORD, _QWORD, _QWORD))(*(_QWORD *)v197 + 216))(v197, 0, 0, 0);
                    *(_DWORD *)&buf[48] = CSIError;
                    *(_QWORD *)&buf[56] = *((unsigned __int16 *)v164 + 12);
                    LODWORD(v208) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v52 + 40))(v52);
                    HIDWORD(v208) = (*(uint64_t (**)(char *))(*(_QWORD *)&v57[*(_QWORD *)(*(_QWORD *)v57 - 56)]
                                                                      + 24))(&v57[*(_QWORD *)(*(_QWORD *)v57 - 56)]);
                    (*(void (**)(uint64_t, _BYTE *))(*(_QWORD *)v52 + 408))(v52, buf);
                    if ((buf[31] & 0x80000000) != 0)
                      operator delete(*(void **)&buf[8]);
                  }
                }
                v58 = (unint64_t *)&v55->__shared_owners_;
                do
                  v59 = __ldaxr(v58);
                while (__stlxr(v59 - 1, v58));
                v34 = v56;
                if (!v59)
                {
                  ((void (*)(std::__shared_weak_count *))v55->__on_zero_shared)(v55);
                  std::__shared_weak_count::__release_weak(v55);
                }
              }
            }
            if (v51)
            {
              v60 = (unint64_t *)&v51->__shared_owners_;
              do
                v61 = __ldaxr(v60);
              while (__stlxr(v61 - 1, v60));
              if (!v61)
              {
                ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
                std::__shared_weak_count::__release_weak(v51);
              }
            }
            LOWORD(v38) = *((_WORD *)v164 + 12);
            goto LABEL_136;
          }
LABEL_265:
          v34 = 0;
          CSIError = 24;
          goto LABEL_115;
        }
        if (v37 <= 2000)
        {
          if (v37 == 1518)
            goto LABEL_269;
          if (v37 != 2000)
            goto LABEL_115;
        }
        else
        {
          if ((v37 - 2001) < 2)
            goto LABEL_265;
          if (v37 != 2003)
            goto LABEL_115;
        }
LABEL_94:
        CSIError = 0;
        v34 = 1;
        if (v38 == 206)
          goto LABEL_115;
LABEL_136:
        v62 = 0;
        switch((char)v35)
        {
          case 1:
            v62 = 1;
            break;
          case 2:
            v62 = 2;
            break;
          case 3:
            v66 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v2 + 104));
            (*(void (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(v2 + 96) + 264))(*(_QWORD *)(v2 + 96), 4, (__int16)v38);
            v67 = (unint64_t *)&v66->__shared_owners_;
            do
              v68 = __ldaxr(v67);
            while (__stlxr(v68 - 1, v67));
            if (!v68)
            {
              ((void (*)(std::__shared_weak_count *))v66->__on_zero_shared)(v66);
              std::__shared_weak_count::__release_weak(v66);
            }
            v62 = 3;
            break;
          case 6:
            v69 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v2 + 104));
            (*(void (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(v2 + 96) + 264))(*(_QWORD *)(v2 + 96), 1, (__int16)v38);
            v70 = (unint64_t *)&v69->__shared_owners_;
            do
              v71 = __ldaxr(v70);
            while (__stlxr(v71 - 1, v70));
            if (!v71)
            {
              ((void (*)(std::__shared_weak_count *))v69->__on_zero_shared)(v69);
              std::__shared_weak_count::__release_weak(v69);
            }
            v62 = 4;
            break;
          case 7:
            v62 = 5;
            break;
          case 8:
            v63 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v2 + 104));
            v64 = (__int16)v38 - 7;
            if (v64 > 0xC)
              v65 = 0;
            else
              v65 = dword_216AB38EC[v64];
            (*(void (**)(_QWORD, uint64_t, uint64_t))(**(_QWORD **)(v2 + 96) + 264))(*(_QWORD *)(v2 + 96), 2, v65);
            v72 = (unint64_t *)&v63->__shared_owners_;
            do
              v73 = __ldaxr(v72);
            while (__stlxr(v73 - 1, v72));
            if (!v73)
            {
              ((void (*)(std::__shared_weak_count *))v63->__on_zero_shared)(v63);
              std::__shared_weak_count::__release_weak(v63);
            }
            v62 = 6;
            break;
          case 9:
            v62 = 7;
            break;
          default:
            break;
        }
        DSReason = getDSReason();
        v149 = v35;
        if (v35 == 6)
          v74 = 1;
        else
          v74 = 2 * (v35 == 8);
        v75 = *(NSObject **)(v2 + 40);
        if (os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT))
        {
          v144 = v34;
          v145 = v74;
          v76 = v35;
          v77 = *(unsigned __int16 *)(v151 + 24);
          v78 = wds::asString(v35);
          v143 = v62;
          v35 = CSIError;
          wds::asString(v76, *((__int16 *)v164 + 12), __p);
          v79 = v156;
          v80 = (void **)__p[0];
          v81 = *((unsigned __int16 *)v164 + 12);
          v82 = CSIErrorString();
          *(_QWORD *)&buf[4] = "handleWdsPacketSvcStatusInd";
          v83 = __p;
          *(_DWORD *)buf = 136316674;
          if (v79 < 0)
            v83 = v80;
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v77;
          *(_WORD *)&buf[18] = 2080;
          *(_QWORD *)&buf[20] = v78;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = v149;
          *(_WORD *)&buf[34] = 2082;
          *(_QWORD *)&buf[36] = v83;
          *(_WORD *)&buf[44] = 1024;
          *(_DWORD *)&buf[46] = v81;
          *(_WORD *)&buf[50] = 2080;
          *(_QWORD *)&buf[52] = v82;
          _os_log_impl(&dword_216897000, v75, OS_LOG_TYPE_DEFAULT, "#I %s: Connection is disconnected. WDS (Reason = %d Verbose Reason Type = %s (%d) Verbose Reason = %{public}s (%d)) converted to %s", buf, 0x3Cu);
          if (v156 < 0)
            operator delete(__p[0]);
          CSIError = v35;
          LOBYTE(v35) = v76;
          v34 = v144;
          v74 = v145;
          v62 = v143;
        }
        *(_WORD *)(v2 + 176) = 0;
        if (v197 && (*(unsigned int (**)(uint64_t, _QWORD))(*(_QWORD *)v197 + 56))(v197, 0))
          std::vector<std::string>::__clear[abi:ne180100]((uint64_t *)(v2 + 232));
        v84 = *(_QWORD *)(v2 + 264);
        if (!v84)
          goto LABEL_177;
        v85 = *(NSObject **)(v2 + 40);
        if (os_log_type_enabled(v85, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315138;
          *(_QWORD *)&buf[4] = "handleWdsPacketSvcStatusInd";
          _os_log_impl(&dword_216897000, v85, OS_LOG_TYPE_DEFAULT, "#I %s: DeactivateDelayTimer already scheduled. Disposing it since we got disconnected", buf, 0xCu);
          v84 = *(_QWORD *)(v2 + 264);
          *(_QWORD *)(v2 + 264) = 0;
          if (!v84)
            goto LABEL_177;
        }
        else
        {
          *(_QWORD *)(v2 + 264) = 0;
        }
        (*(void (**)(uint64_t))(*(_QWORD *)v84 + 8))(v84);
LABEL_177:
        v86 = wds::asString(v35);
        std::string::__assign_external((std::string *)(v2 + 464), v86);
        wds::asString(v35, *((__int16 *)v164 + 12), buf);
        v87 = (void **)(v2 + 488);
        if (*(char *)(v2 + 511) < 0)
          operator delete(*v87);
        *(_OWORD *)v87 = *(_OWORD *)buf;
        *(_QWORD *)(v2 + 504) = *(_QWORD *)&buf[16];
        v88 = (const std::string::value_type *)CSIErrorString();
        std::string::__assign_external((std::string *)(v2 + 512), v88);
        if (*(_WORD *)(*((_QWORD *)&v167 + 1) + 24) == 6 && (DSReason == 33 || DSReason == 9))
        {
          v89 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v2 + 104));
          (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)(v2 + 96) + 80))(*(_QWORD *)(v2 + 96), *(unsigned int *)(v2 + 140));
          v90 = (unint64_t *)&v89->__shared_owners_;
          do
            v91 = __ldaxr(v90);
          while (__stlxr(v91 - 1, v90));
          if (!v91)
          {
            ((void (*)(std::__shared_weak_count *))v89->__on_zero_shared)(v89);
            std::__shared_weak_count::__release_weak(v89);
          }
          v92 = 1;
        }
        else
        {
          v92 = 0;
        }
        if (*(_BYTE *)(v2 + 272))
        {
          v93 = 2;
        }
        else if ((_DWORD)CSIError == 101)
        {
          v94 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v2 + 104));
          (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)(v2 + 96) + 312))(*(_QWORD *)(v2 + 96), 0);
          v95 = (unint64_t *)&v94->__shared_owners_;
          do
            v96 = __ldaxr(v95);
          while (__stlxr(v96 - 1, v95));
          if (!v96)
          {
            ((void (*)(std::__shared_weak_count *))v94->__on_zero_shared)(v94);
            std::__shared_weak_count::__release_weak(v94);
          }
          v93 = 3;
        }
        else
        {
          v97 = *(unsigned __int16 *)(*((_QWORD *)&v167 + 1) + 24);
          v93 = v97 != 6 && v97 != 8 && (_DWORD)CSIError != 90;
        }
        v99 = (capabilities::ct *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 96))(v2);
        switch((int)v99)
        {
          case 0:
          case 1:
            v100 = *(NSObject **)(v2 + 40);
            if (os_log_type_enabled(v100, OS_LOG_TYPE_DEFAULT))
            {
              (*(void (**)(uint64_t))(*(_QWORD *)v2 + 96))(v2);
              v101 = asString();
              *(_DWORD *)buf = 136315394;
              *(_QWORD *)&buf[4] = "handleWdsPacketSvcStatusInd";
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = v101;
              _os_log_impl(&dword_216897000, v100, OS_LOG_TYPE_DEFAULT, "#I %s: ERR: QMI_WDS_PACKET_DATA_DISCONNECTED at wrong state %s", buf, 0x16u);
            }
            goto LABEL_247;
          case 2:
            v102 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v2 + 104));
            (*(void (**)(_QWORD))(**(_QWORD **)(v2 + 96) + 64))(*(_QWORD *)(v2 + 96));
            v103 = (unint64_t *)&v102->__shared_owners_;
            do
              v104 = __ldaxr(v103);
            while (__stlxr(v104 - 1, v103));
            if (!v104)
            {
              ((void (*)(std::__shared_weak_count *))v102->__on_zero_shared)(v102);
              std::__shared_weak_count::__release_weak(v102);
            }
            v105 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v2 + 104));
            (*(void (**)(_QWORD))(**(_QWORD **)(v2 + 96) + 96))(*(_QWORD *)(v2 + 96));
            v106 = (unint64_t *)&v105->__shared_owners_;
            do
              v107 = __ldaxr(v106);
            while (__stlxr(v107 - 1, v106));
            goto LABEL_244;
          case 3:
            if (QMIDataContextIPBase::transitionalStateMaskIP((QMIDataContextIPBase *)v2))
            {
              QMIDataContextIPBase::setDataContextIPState(v2, 1u);
              v105 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v2 + 104));
              (*(void (**)(_QWORD, _QWORD, uint64_t, _QWORD, uint64_t, uint64_t, _QWORD))(**(_QWORD **)(v2 + 96)
                                                                                                + 64))(*(_QWORD *)(v2 + 96), *(unsigned int *)(v2 + 140), CSIError, *((unsigned __int16 *)v164 + 12), v74, v93, 0);
              v108 = (unint64_t *)&v105->__shared_owners_;
              do
                v107 = __ldaxr(v108);
              while (__stlxr(v107 - 1, v108));
            }
            else
            {
              QMIDataContextIPBase::setDataContextIPState(v2, 0);
              v105 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v2 + 104));
              (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)(v2 + 96) + 72))(*(_QWORD *)(v2 + 96), *(unsigned int *)(v2 + 140));
              v127 = (unint64_t *)&v105->__shared_owners_;
              do
                v107 = __ldaxr(v127);
              while (__stlxr(v107 - 1, v127));
            }
            goto LABEL_244;
          case 4:
            if (*(_BYTE *)(v2 + 272))
              v109 = v92;
            else
              v109 = 1;
            if ((v109 & 1) != 0)
              goto LABEL_281;
            v110 = *((unsigned __int16 *)v164 + 12);
            v111 = capabilities::ct::supportsGemini(v99);
            if ((v34 & 1) != 0)
              goto LABEL_281;
            if (v35 != 6)
            {
              v112 = v35 == 3 ? v111 : 0;
              if (v110 != 1090 || !v112)
                goto LABEL_281;
            }
            v146 = v74;
            v148 = CSIError;
            v113 = *(NSObject **)(v2 + 40);
            if (os_log_type_enabled(v113, OS_LOG_TYPE_DEFAULT))
            {
              v114 = wds::asString(v35);
              wds::asString(v35, *((__int16 *)v164 + 12), __p);
              v115 = v156;
              v116 = (void **)__p[0];
              v117 = *((unsigned __int16 *)v164 + 12);
              v118 = CSIErrorString();
              *(_QWORD *)&buf[4] = "handleWdsPacketSvcStatusInd";
              v119 = __p;
              *(_DWORD *)buf = 136316418;
              if (v115 < 0)
                v119 = v116;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = v114;
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)&buf[24] = v149;
              *(_WORD *)&buf[28] = 2082;
              *(_QWORD *)&buf[30] = v119;
              *(_WORD *)&buf[38] = 1024;
              *(_DWORD *)&buf[40] = v117;
              *(_WORD *)&buf[44] = 2080;
              *(_QWORD *)&buf[46] = v118;
              _os_log_impl(&dword_216897000, v113, OS_LOG_TYPE_DEFAULT, "#I %s: DOUBLE TAP: Handover activation failed (Reason Type = %s (%d) Reason = %{public}s (%d)) converted to %s", buf, 0x36u);
              if (v156 < 0)
                operator delete(__p[0]);
            }
            v120 = *(_DWORD *)(v2 + 276);
            if (v120 > 0)
            {
              v121 = *(NSObject **)(v2 + 40);
              v74 = v146;
              CSIError = v148;
              if (!os_log_type_enabled(v121, OS_LOG_TYPE_DEFAULT))
                goto LABEL_281;
              *(_DWORD *)buf = 136315394;
              *(_QWORD *)&buf[4] = "handleWdsPacketSvcStatusInd";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v120;
              v122 = "#I %s: DOUBLE TAP: reached maximum attempts #%d, giving up";
              v123 = v121;
              v124 = 18;
              goto LABEL_280;
            }
            v128 = v120 + 1;
            *(_DWORD *)(v2 + 276) = v128;
            v129 = *(NSObject **)(v2 + 40);
            if (os_log_type_enabled(v129, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136315394;
              *(_QWORD *)&buf[4] = "handleWdsPacketSvcStatusInd";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v128;
              _os_log_impl(&dword_216897000, v129, OS_LOG_TYPE_DEFAULT, "#I %s: DOUBLE TAP: attempt #%d", buf, 0x12u);
              v129 = *(NSObject **)(v2 + 40);
            }
            if (os_log_type_enabled(v129, OS_LOG_TYPE_DEFAULT))
            {
              v130 = asString();
              v131 = asString();
              *(_DWORD *)buf = 136315650;
              *(_QWORD *)&buf[4] = "handleWdsPacketSvcStatusInd";
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = v130;
              *(_WORD *)&buf[22] = 2080;
              *(_QWORD *)&buf[24] = v131;
              _os_log_impl(&dword_216897000, v129, OS_LOG_TYPE_DEFAULT, "#I %s: (change states) stealth: %s to %s", buf, 0x20u);
            }
            *(_DWORD *)(v2 + 136) = 0;
            v132 = *(_DWORD *)(v2 + 284);
            std::string::basic_string[abi:ne180100]<0>(buf, "DOUBLE TAP");
            __p[0] = 0;
            __p[1] = 0;
            v133 = QMIDataContextIPBase::activateDataContextIP(v2, v132, (const std::string *)buf, 1, __p, 1);
            if ((buf[23] & 0x80000000) != 0)
              operator delete(*(void **)buf);
            if ((v133 & 1) != 0)
              goto LABEL_247;
            v134 = *(NSObject **)(v2 + 40);
            v74 = v146;
            CSIError = v148;
            if (os_log_type_enabled(v134, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136315138;
              *(_QWORD *)&buf[4] = "handleWdsPacketSvcStatusInd";
              v122 = "#I %s: DOUBLE TAP: failed to activate";
              v123 = v134;
              v124 = 12;
LABEL_280:
              _os_log_impl(&dword_216897000, v123, OS_LOG_TYPE_DEFAULT, v122, buf, v124);
            }
LABEL_281:
            if (*(_WORD *)(*((_QWORD *)&v167 + 1) + 24) != 2 || *((_WORD *)v164 + 12) != 214 || *(_BYTE *)(v2 + 272))
              goto LABEL_284;
            v139 = *(_DWORD *)(v2 + 280);
            if (v139 <= 0)
            {
              v141 = v139 + 1;
              *(_DWORD *)(v2 + 280) = v141;
              v142 = *(NSObject **)(v2 + 40);
              if (os_log_type_enabled(v142, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136315394;
                *(_QWORD *)&buf[4] = "handleWdsPacketSvcStatusInd";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = v141;
                _os_log_impl(&dword_216897000, v142, OS_LOG_TYPE_DEFAULT, "#I %s: Activation rejected because of UNPREFERRED_RAT. Internal failure. Retry %d", buf, 0x12u);
              }
              v135 = 1;
            }
            else
            {
              v140 = *(NSObject **)(v2 + 40);
              v135 = 0;
              if (os_log_type_enabled(v140, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136315394;
                *(_QWORD *)&buf[4] = "handleWdsPacketSvcStatusInd";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = v139;
                _os_log_impl(&dword_216897000, v140, OS_LOG_TYPE_DEFAULT, "#I %s: Activation rejected because of UNPREFERRED_RAT. Internal failure. Reached maximum attempts %d, giving up", buf, 0x12u);
LABEL_284:
                v135 = 0;
              }
            }
            QMIDataContextIPBase::setDataContextIPState(v2, 1u);
            v136 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v2 + 104));
            (*(void (**)(_QWORD, _QWORD, uint64_t, _QWORD, uint64_t, uint64_t, uint64_t))(**(_QWORD **)(v2 + 96)
                                                                                               + 64))(*(_QWORD *)(v2 + 96), *(unsigned int *)(v2 + 140), CSIError, *((unsigned __int16 *)v164 + 12), v74, v93, v135);
            v137 = (unint64_t *)&v136->__shared_owners_;
            do
              v138 = __ldaxr(v137);
            while (__stlxr(v138 - 1, v137));
            if (!v138)
            {
              ((void (*)(std::__shared_weak_count *))v136->__on_zero_shared)(v136);
              std::__shared_weak_count::__release_weak(v136);
            }
LABEL_246:
            QMIDataContextIPBase::doneWithContext((QMIDataContextIPBase *)v2);
LABEL_247:
            _Block_object_dispose(&v163, 8);
            _Block_object_dispose(&v167, 8);
            _Block_object_dispose(&v150, 8);
LABEL_39:
            _Block_object_dispose(&v180, 8);
            _Block_object_dispose(&v184, 8);
            _Block_object_dispose(&v188, 8);
LABEL_40:
            v31 = v198;
            if (v198)
            {
              v32 = (unint64_t *)&v198->__shared_owners_;
              do
                v33 = __ldaxr(v32);
              while (__stlxr(v33 - 1, v32));
              if (!v33)
              {
                ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
                std::__shared_weak_count::__release_weak(v31);
              }
            }
LABEL_45:
            _Block_object_dispose(&v199, 8);
            _Block_object_dispose(&v203, 8);
            return;
          case 5:
            goto LABEL_239;
          case 6:
            if (QMIDataContextIPBase::transitionalStateMaskIP((QMIDataContextIPBase *)v2))
            {
              QMIDataContextIPBase::setDataContextIPState(v2, 1u);
              v105 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v2 + 104));
              (*(void (**)(_QWORD, _QWORD, uint64_t, _QWORD, uint64_t, uint64_t, _QWORD))(**(_QWORD **)(v2 + 96)
                                                                                                + 64))(*(_QWORD *)(v2 + 96), *(unsigned int *)(v2 + 140), CSIError, *((unsigned __int16 *)v164 + 12), v74, v93, 0);
              v125 = (unint64_t *)&v105->__shared_owners_;
              do
                v107 = __ldaxr(v125);
              while (__stlxr(v107 - 1, v125));
            }
            else
            {
LABEL_239:
              QMIDataContextIPBase::setDataContextIPState(v2, 0);
              v105 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v2 + 104));
              (*(void (**)(_QWORD, _QWORD, uint64_t, _QWORD))(**(_QWORD **)(v2 + 96) + 88))(*(_QWORD *)(v2 + 96), *(unsigned int *)(v2 + 140), v62, DSReason);
              v126 = (unint64_t *)&v105->__shared_owners_;
              do
                v107 = __ldaxr(v126);
              while (__stlxr(v107 - 1, v126));
            }
LABEL_244:
            if (!v107)
            {
              ((void (*)(std::__shared_weak_count *))v105->__on_zero_shared)(v105);
              std::__shared_weak_count::__release_weak(v105);
            }
            goto LABEL_246;
          default:
            goto LABEL_247;
        }
      case 6:
        CSIError = getCSIError();
        if ((_DWORD)CSIError)
          goto LABEL_100;
        v38 = *((unsigned __int16 *)v164 + 12);
        goto LABEL_94;
      case 7:
        v34 = 0;
        if (v38 == 3)
          CSIError = 67;
        else
          CSIError = 1;
        goto LABEL_115;
      case 8:
        v34 = 0;
        if (v37 > 13)
        {
          if (v37 != 14)
          {
            if (v37 == 19)
            {
              v34 = 0;
              CSIError = 94;
            }
            goto LABEL_115;
          }
        }
        else if (v37 != 7)
        {
          if (v37 == 13)
          {
LABEL_113:
            v34 = 0;
            CSIError = 18;
          }
          goto LABEL_115;
        }
LABEL_114:
        v34 = 0;
        CSIError = 63;
        goto LABEL_115;
      case 9:
        if (v37 == 1)
        {
          v34 = 0;
          CSIError = 89;
        }
        else
        {
LABEL_100:
          v34 = 0;
        }
        goto LABEL_115;
      default:
        goto LABEL_115;
    }
  }
}

void sub_216A01164(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,void *aBlock,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47,uint64_t a48,uint64_t a49,uint64_t a50,char a51,uint64_t a52,uint64_t a53,uint64_t a54,char a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  uint64_t a66;
  uint64_t v66;
  std::__shared_weak_count *v68;
  unint64_t *v69;
  unint64_t v70;

  if (*(char *)(v66 - 169) < 0)
    operator delete(*(void **)(v66 - 192));
  _Block_object_dispose(&a27, 8);
  _Block_object_dispose(&a31, 8);
  _Block_object_dispose(&a13, 8);
  _Block_object_dispose(&a47, 8);
  _Block_object_dispose(&a51, 8);
  _Block_object_dispose(&a55, 8);
  v68 = (std::__shared_weak_count *)a66;
  if (a66)
  {
    v69 = (unint64_t *)(a66 + 8);
    do
      v70 = __ldaxr(v69);
    while (__stlxr(v70 - 1, v69));
    if (!v70)
    {
      ((void (*)(std::__shared_weak_count *))v68->__on_zero_shared)(v68);
      std::__shared_weak_count::__release_weak(v68);
    }
  }
  _Block_object_dispose((const void *)(v66 - 256), 8);
  _Block_object_dispose((const void *)(v66 - 224), 8);
  _Unwind_Resume(a1);
}

void ___ZN20QMIDataContextIPBase23bootstrapBBCtxCmdDriverEv_block_invoke_9(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v2;
  NSObject *v4;
  uint64_t TlvValue;
  int v6;
  uint64_t v7;
  int v8;
  NSObject *v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  _BYTE buf[24];
  void *v14;
  uint64_t v15;
  _QWORD v16[2];
  char v17;
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)(v2 + 257))
  {
    v4 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = "handleWdsDadCompleteInd";
      _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I %s: start", buf, 0xCu);
    }
    if (*(_QWORD *)(v2 + 160))
    {
      if (*(_DWORD *)(v2 + 140) == 2)
      {
        *(_QWORD *)buf = MEMORY[0x24BDAC760];
        *(_QWORD *)&buf[8] = 0x40000000;
        *(_QWORD *)&buf[16] = ___ZN20QMIDataContextIPBase23handleWdsDadCompleteIndERKN3wds11DadComplete10IndicationE_block_invoke;
        v14 = &__block_descriptor_tmp_167_0;
        v15 = v2;
        TlvValue = qmi::MessageBase::findTlvValue(a2);
        if (TlvValue)
        {
          v7 = TlvValue;
          v8 = v6;
          v12 = TlvValue;
          v16[0] = 0;
          v16[1] = 0;
          v17 = 0;
          tlv::parseV<wds::tlv::IPv6>((unint64_t *)&v12, v6, (uint64_t)v16);
          if (v12)
            ___ZN20QMIDataContextIPBase23handleWdsDadCompleteIndERKN3wds11DadComplete10IndicationE_block_invoke((uint64_t)buf, (const unsigned __int8 *)v16);
          else
            ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 1, v7, v8);
        }
      }
      else
      {
        v10 = *(NSObject **)(v2 + 40);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          v11 = asString();
          *(_DWORD *)buf = 136315394;
          *(_QWORD *)&buf[4] = "handleWdsDadCompleteInd";
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = v11;
          _os_log_impl(&dword_216897000, v10, OS_LOG_TYPE_DEFAULT, "#I %s: Received DAD complete indication but the model is %s - Bailing out", buf, 0x16u);
        }
      }
    }
    else
    {
      v9 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_216897000, v9, OS_LOG_TYPE_ERROR, "received DadCompleteInd after client is deleted", buf, 2u);
      }
    }
  }
}

uint64_t QMIDataContextIPBase::startBBCtxCmdDriver(uint64_t this)
{
  if (*(_QWORD *)(this + 160))
    return qmi::Client::start((qmi::Client *)(this + 144));
  return this;
}

void QMIDataContextIPBase::stopBBCtxCmdDriver(QMIDataContextIPBase *this)
{
  char *v1;
  __int128 v3;
  __int128 v4;

  v1 = (char *)this + 160;
  if (*((_QWORD *)this + 20))
  {
    qmi::Client::stop((QMIDataContextIPBase *)((char *)this + 144));
    v3 = 0u;
    v4 = 0u;
    std::shared_ptr<qmi::Client::State>::operator=[abi:ne180100]((uint64_t)v1, &v4);
    qmi::Client::~Client((qmi::Client *)&v3);
    *((_BYTE *)this + 257) = 1;
  }
}

void QMIDataContextIPBase::~QMIDataContextIPBase(QMIDataContextIPBase *this)
{
  uint64_t v2;
  QMIDataContextIPBase *v3;
  uint64_t v4;
  void *v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  std::__shared_weak_count *v11;
  std::__shared_weak_count *v12;
  QMIDataContextIPBase *v13;
  uint64_t v14;
  void **v15;

  *(_QWORD *)this = off_24D5DE688;
  QMIDataContextIPBase::stopBBCtxCmdDriver(this);
  v2 = *((_QWORD *)this + 33);
  *((_QWORD *)this + 33) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  QMIDataContextIPBase::clearIPv6ConfigTimer(this);
  QMIDataContextIPBase::clearIPv4ConfigTimer(this);
  std::__optional_destruct_base<AnbrFilterInfo,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)this + 680);
  v3 = (QMIDataContextIPBase *)*((_QWORD *)this + 83);
  if (v3 == (QMIDataContextIPBase *)((char *)this + 640))
  {
    v4 = 4;
    v3 = (QMIDataContextIPBase *)((char *)this + 640);
  }
  else
  {
    if (!v3)
      goto LABEL_8;
    v4 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
LABEL_8:
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)this + 616);
  v5 = (void *)*((_QWORD *)this + 74);
  if (v5)
  {
    *((_QWORD *)this + 75) = v5;
    operator delete(v5);
  }
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)this + 560);
  MEMORY[0x2199FD75C]((char *)this + 384);
  v6 = (void *)*((_QWORD *)this + 39);
  if (v6)
  {
    *((_QWORD *)this + 40) = v6;
    operator delete(v6);
  }
  v7 = *((_QWORD *)this + 37);
  *((_QWORD *)this + 37) = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  v8 = *((_QWORD *)this + 36);
  *((_QWORD *)this + 36) = 0;
  if (v8)
    (*(void (**)(uint64_t))(*(_QWORD *)v8 + 8))(v8);
  v9 = *((_QWORD *)this + 33);
  *((_QWORD *)this + 33) = 0;
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  v15 = (void **)((char *)this + 232);
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&v15);
  v10 = (void *)*((_QWORD *)this + 26);
  if (v10)
  {
    *((_QWORD *)this + 27) = v10;
    operator delete(v10);
  }
  qmi::Client::~Client((QMIDataContextIPBase *)((char *)this + 144));
  v11 = (std::__shared_weak_count *)*((_QWORD *)this + 16);
  if (v11)
    std::__shared_weak_count::__release_weak(v11);
  v12 = (std::__shared_weak_count *)*((_QWORD *)this + 13);
  if (v12)
    std::__shared_weak_count::__release_weak(v12);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)this + 80);
  v13 = (QMIDataContextIPBase *)*((_QWORD *)this + 9);
  if (v13 == (QMIDataContextIPBase *)((char *)this + 48))
  {
    v14 = 4;
    v13 = (QMIDataContextIPBase *)((char *)this + 48);
    goto LABEL_28;
  }
  if (v13)
  {
    v14 = 5;
LABEL_28:
    (*(void (**)(void))(*(_QWORD *)v13 + 8 * v14))();
  }
  MEMORY[0x2199FDF6C]((char *)this + 40);
  ctu::SharedSynchronizable<QMIDataSystemDeterminationManager>::~SharedSynchronizable((_QWORD *)this + 1);
}

uint64_t QMIDataContextIPBase::clearIPv6ConfigTimer(QMIDataContextIPBase *this)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t result;
  int v5;
  const char *v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v2 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v5 = 136315138;
    v6 = "clearIPv6ConfigTimer";
    _os_log_impl(&dword_216897000, v2, OS_LOG_TYPE_DEFAULT, "#I %s: ", (uint8_t *)&v5, 0xCu);
  }
  v3 = *((_QWORD *)this + 36);
  *((_QWORD *)this + 36) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  *((_BYTE *)this + 304) = 0;
  *((_BYTE *)this + 306) = 0;
  CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)&v5);
  result = CSIPacketAddress::operator=();
  *((_QWORD *)this + 40) = *((_QWORD *)this + 39);
  return result;
}

uint64_t QMIDataContextIPBase::clearIPv4ConfigTimer(QMIDataContextIPBase *this)
{
  NSObject *v2;
  uint64_t v3;
  int v5;
  const char *v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v2 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v5 = 136315138;
    v6 = "clearIPv4ConfigTimer";
    _os_log_impl(&dword_216897000, v2, OS_LOG_TYPE_DEFAULT, "#I %s: ", (uint8_t *)&v5, 0xCu);
  }
  v3 = *((_QWORD *)this + 37);
  *((_QWORD *)this + 37) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  *((_BYTE *)this + 305) = 0;
  CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)&v5);
  return CSIPacketAddress::operator=();
}

void QMIDataContextIPBase::setDataContextIPState(uint64_t a1, unsigned int a2)
{
  unsigned int v2;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  unint64_t *v10;
  std::__shared_weak_count *v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  NSObject *v18;
  NSObject *v19;
  uint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  _BYTE v30[22];
  __int16 v31;
  uint64_t v32;
  __int16 v33;
  uint64_t v34;
  char v35;
  uint64_t v36;

  v2 = a2;
  v36 = *MEMORY[0x24BDAC8D0];
  if (a2 != 4)
  {
    *(_BYTE *)(a1 + 637) = 0;
    std::function<BOOL ()(void)>::operator=((_QWORD *)(a1 + 640), a1 + 48);
    if (v2 - 5 >= 2)
    {
      if (v2)
        goto LABEL_10;
      *(_BYTE *)(a1 + 636) = 0;
    }
    v4 = *(std::__shared_weak_count **)(a1 + 568);
    *(_OWORD *)(a1 + 560) = 0u;
    if (v4)
    {
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v6 = __ldaxr(p_shared_owners);
      while (__stlxr(v6 - 1, p_shared_owners));
      if (!v6)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
LABEL_10:
  if (*(_DWORD *)(a1 + 136) == v2)
    return;
  if (v2 == 3)
  {
    v7 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(a1 + 104));
    *(_QWORD *)v30 = *(_QWORD *)(a1 + 96);
    *(_QWORD *)&v30[8] = v7;
    (*(void (**)(_QWORD))(**(_QWORD **)v30 + 344))(*(_QWORD *)v30);
    v10 = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldaxr(v10);
    while (__stlxr(v9 - 1, v10));
LABEL_18:
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
    goto LABEL_20;
  }
  if (v2 == 6)
  {
    v7 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(a1 + 104));
    *(_QWORD *)v30 = *(_QWORD *)(a1 + 96);
    *(_QWORD *)&v30[8] = v7;
    (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)v30 + 336))(*(_QWORD *)v30, *(unsigned int *)(a1 + 140));
    v8 = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    goto LABEL_18;
  }
LABEL_20:
  *(_QWORD *)v30 = 0;
  *(_QWORD *)&v30[8] = 0;
  v11 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(a1 + 104));
  v12 = *(_QWORD *)(a1 + 96);
  *(_QWORD *)v30 = v12;
  *(_QWORD *)&v30[8] = v11;
  if (v2 < 7)
    v13 = v2 + 1;
  else
    v13 = 0;
  v14 = *(_DWORD *)(a1 + 140) & 1;
  if (*(int *)(a1 + 140) >= 0)
    v15 = v14;
  else
    v15 = -v14;
  (*(void (**)(uint64_t, uint64_t, BOOL, uint64_t))(*(_QWORD *)v12 + 368))(v12, v13, v2 == 4, v15);
  v16 = (unint64_t *)&v11->__shared_owners_;
  do
    v17 = __ldaxr(v16);
  while (__stlxr(v17 - 1, v16));
  if (!v17)
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  v18 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)v30 = 136315906;
    *(_QWORD *)&v30[4] = "setDataContextIPState";
    *(_WORD *)&v30[12] = 2080;
    *(_QWORD *)&v30[14] = asString();
    v31 = 2080;
    v32 = asString();
    v33 = 2080;
    v34 = asStringBool();
    _os_log_impl(&dword_216897000, v18, OS_LOG_TYPE_DEFAULT, "#I %s: Changing state (change states) %s->%s, fStopRequestSent = %s", v30, 0x2Au);
  }
  *(_DWORD *)(a1 + 136) = v2;
  switch(v2)
  {
    case 0u:
    case 1u:
    case 2u:
    case 3u:
      if (*(_BYTE *)(a1 + 856))
      {
        QMIDataContextIPBase::shutdownAnbrHandle((QMIDataContextIPBase *)a1, (int *)(a1 + 680));
        v19 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
          if (!*(_BYTE *)(a1 + 856))
            std::__throw_bad_optional_access[abi:ne180100]();
          v20 = *(unsigned int *)(a1 + 840);
          *(_DWORD *)v30 = 134217984;
          *(_QWORD *)&v30[4] = v20;
          _os_log_impl(&dword_216897000, v19, OS_LOG_TYPE_DEFAULT, "#I ANBRFilter: handle %lu removed (1)", v30, 0xCu);
        }
      }
      v30[0] = 0;
      v35 = 0;
      std::__optional_storage_base<AnbrFilterInfo,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<AnbrFilterInfo,false>>(a1 + 680, (uint64_t)v30);
      std::__optional_destruct_base<AnbrFilterInfo,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)v30);
      goto LABEL_38;
    case 4u:
      goto LABEL_39;
    case 5u:
LABEL_38:
      *(_DWORD *)(a1 + 280) = 0;
LABEL_39:
      v21 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(a1 + 104));
      *(_QWORD *)v30 = *(_QWORD *)(a1 + 96);
      *(_QWORD *)&v30[8] = v21;
      (*(void (**)(_QWORD, _QWORD, _QWORD, _QWORD))(**(_QWORD **)v30 + 256))(*(_QWORD *)v30, *(unsigned int *)(a1 + 140), 0, 0);
      v22 = (unint64_t *)&v21->__shared_owners_;
      do
        v23 = __ldaxr(v22);
      while (__stlxr(v23 - 1, v22));
      if (!v23)
      {
        ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
        std::__shared_weak_count::__release_weak(v21);
      }
      QMIDataContextIPBase::clearIPv6ConfigTimer((QMIDataContextIPBase *)a1);
      QMIDataContextIPBase::clearIPv4ConfigTimer((QMIDataContextIPBase *)a1);
      goto LABEL_44;
    case 6u:
      v27 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(a1 + 104));
      *(_QWORD *)v30 = *(_QWORD *)(a1 + 96);
      *(_QWORD *)&v30[8] = v27;
      (*(void (**)(_QWORD, _QWORD, uint64_t, _QWORD))(**(_QWORD **)v30 + 256))(*(_QWORD *)v30, *(unsigned int *)(a1 + 140), 1, 0);
      v28 = (unint64_t *)&v27->__shared_owners_;
      do
        v29 = __ldaxr(v28);
      while (__stlxr(v29 - 1, v28));
      if (!v29)
      {
        ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
        std::__shared_weak_count::__release_weak(v27);
      }
      *(_DWORD *)(a1 + 280) = 0;
LABEL_44:
      v2 = *(_DWORD *)(a1 + 136);
      break;
    default:
      break;
  }
  if ((v2 | 2) != 6)
  {
    QMIDataContextIPBase::setHandoverActivation((QMIDataContextIPBase *)a1, 0);
    *(_DWORD *)(a1 + 284) = 0;
  }
  v24 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(a1 + 104));
  *(_QWORD *)v30 = *(_QWORD *)(a1 + 96);
  *(_QWORD *)&v30[8] = v24;
  (*(void (**)(_QWORD))(**(_QWORD **)v30 + 352))(*(_QWORD *)v30);
  v25 = (unint64_t *)&v24->__shared_owners_;
  do
    v26 = __ldaxr(v25);
  while (__stlxr(v26 - 1, v25));
  if (!v26)
  {
    ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
    std::__shared_weak_count::__release_weak(v24);
  }
}

void sub_216A01FFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

_QWORD *std::function<BOOL ()(void)>::operator=(_QWORD *a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;
  _QWORD v6[3];
  _QWORD *v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100]((uint64_t)v6, a2);
  std::__function::__value_func<BOOL ()(void)>::swap[abi:ne180100](v6, a1);
  v3 = v7;
  if (v7 == v6)
  {
    v4 = 4;
    v3 = v6;
    goto LABEL_5;
  }
  if (v7)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return a1;
}

void QMIDataContextIPBase::setHandoverActivation(QMIDataContextIPBase *this, int a2)
{
  NSObject *v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  const char *v9;
  __int16 v10;
  uint64_t v11;
  __int16 v12;
  uint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v4 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v8 = 136315394;
    v9 = "setHandoverActivation";
    v10 = 2080;
    v11 = asStringBool();
    _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I %s:  %s ", (uint8_t *)&v8, 0x16u);
  }
  if (*((unsigned __int8 *)this + 272) != a2)
  {
    v5 = *((_QWORD *)this + 5);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = asStringBool();
      v7 = asStringBool();
      v8 = 136315650;
      v9 = "setHandoverActivation";
      v10 = 2080;
      v11 = v6;
      v12 = 2080;
      v13 = v7;
      _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#I %s: changing fHandoverActivation from %s to %s", (uint8_t *)&v8, 0x20u);
    }
    *((_BYTE *)this + 272) = a2;
  }
  if ((a2 & 1) == 0)
    *((_DWORD *)this + 69) = 0;
}

uint64_t QMIDataContextIPBase::createWdsClientOnDemand_sync(QMIDataContextIPBase *this)
{
  QMIDataContextIPBase::initialize(this, 1);
  (*(void (**)(QMIDataContextIPBase *))(*(_QWORD *)this + 16))(this);
  return (*(uint64_t (**)(QMIDataContextIPBase *))(*(_QWORD *)this + 24))(this);
}

uint64_t QMIDataContextIPBase::activateDataContextIP(uint64_t a1, int a2, const std::string *a3, uint64_t a4, _QWORD *a5, uint64_t a6)
{
  NSObject *v12;
  std::__shared_weak_count *v13;
  std::__shared_weak_count *v14;
  std::__shared_weak_count *v15;
  uint64_t v16;
  unint64_t *p_shared_owners;
  unint64_t v18;
  std::__shared_weak_count *v19;
  std::__shared_weak_count *v20;
  std::__shared_weak_count *v21;
  uint64_t v22;
  unint64_t *v23;
  unint64_t v24;
  std::__shared_weak_count *v25;
  std::__shared_weak_count *v26;
  std::__shared_weak_count *v27;
  uint64_t v28;
  unint64_t *v29;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  uint64_t v34;
  NSObject *v35;
  uint64_t v36;
  NSObject *v38;
  const char *v39;
  NSObject *v40;
  uint32_t v41;
  unsigned int v42;
  NSObject *v43;
  uint64_t v44;
  std::__shared_weak_count *v45;
  unint64_t *v46;
  unint64_t v47;
  NSObject *v48;
  uint64_t v49;
  _QWORD *v50;
  int v51;
  uint64_t v52;
  uint64_t v53;
  unint64_t *v54;
  unint64_t v55;
  NSObject *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  unint64_t *v60;
  unint64_t v61;
  capabilities::ct *v62;
  NSObject *v63;
  uint64_t v64;
  int v65;
  NSObject *v66;
  std::__shared_weak_count *v67;
  unint64_t *p_shared_weak_owners;
  unint64_t v69;
  unint64_t *v70;
  unint64_t v71;
  NSObject *v72;
  unint64_t *v73;
  unint64_t v74;
  _QWORD v75[2];
  uint64_t v76;
  std::__shared_weak_count *v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  std::__shared_weak_count *v81;
  _BYTE buf[24];
  int v83;
  uint64_t v84;
  uint64_t v85;
  char v86;
  uint64_t v87;

  v87 = *MEMORY[0x24BDAC8D0];
  v12 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315138;
    *(_QWORD *)&buf[4] = "activateDataContextIP";
    _os_log_impl(&dword_216897000, v12, OS_LOG_TYPE_DEFAULT, "#I %s: start", buf, 0xCu);
  }
  v13 = *(std::__shared_weak_count **)(a1 + 104);
  if (v13)
  {
    v14 = std::__shared_weak_count::lock(v13);
    if (v14)
    {
      v15 = v14;
      v16 = *(_QWORD *)(a1 + 96);
      p_shared_owners = (unint64_t *)&v14->__shared_owners_;
      do
        v18 = __ldaxr(p_shared_owners);
      while (__stlxr(v18 - 1, p_shared_owners));
      if (v18)
      {
        if (v16)
          goto LABEL_22;
      }
      else
      {
        ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
        std::__shared_weak_count::__release_weak(v15);
        if (v16)
          goto LABEL_22;
      }
    }
  }
  if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136315650;
    *(_QWORD *)&buf[4] = "should have observer here";
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = "/Library/Caches/com.apple.xbs/Sources/CoreTelephony/CommCenter/CommCenterCommandDrivers/Data/Q"
                          "MI/Context/QMIDataContextIPBase.cpp";
    *(_WORD *)&buf[22] = 1024;
    v83 = 706;
    _os_log_error_impl(&dword_216897000, MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR, "\n**********\n   ASSERT getObserver()\n %s\n at %s:%d\n**********", buf, 0x1Cu);
  }
  v19 = *(std::__shared_weak_count **)(a1 + 104);
  if (!v19)
    goto LABEL_21;
  v20 = std::__shared_weak_count::lock(v19);
  if (!v20)
    goto LABEL_21;
  v21 = v20;
  v22 = *(_QWORD *)(a1 + 96);
  v23 = (unint64_t *)&v20->__shared_owners_;
  do
    v24 = __ldaxr(v23);
  while (__stlxr(v24 - 1, v23));
  if (v24)
  {
    if (!v22)
      goto LABEL_21;
  }
  else
  {
    ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
    std::__shared_weak_count::__release_weak(v21);
    if (!v22)
LABEL_21:
      __TUAssertTrigger();
  }
LABEL_22:
  v25 = *(std::__shared_weak_count **)(a1 + 104);
  if (!v25)
    return 0;
  v26 = std::__shared_weak_count::lock(v25);
  if (!v26)
    return 0;
  v27 = v26;
  v28 = *(_QWORD *)(a1 + 96);
  v29 = (unint64_t *)&v26->__shared_owners_;
  do
    v30 = __ldaxr(v29);
  while (__stlxr(v30 - 1, v29));
  if (!v30)
  {
    ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
    std::__shared_weak_count::__release_weak(v27);
    if (v28)
      goto LABEL_28;
    return 0;
  }
  if (!v28)
    return 0;
LABEL_28:
  v80 = 0;
  v81 = 0;
  v31 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(a1 + 104));
  *(_QWORD *)buf = *(_QWORD *)(a1 + 96);
  *(_QWORD *)&buf[8] = v31;
  (*(void (**)(uint64_t *__return_ptr))(**(_QWORD **)buf + 240))(&v80);
  v32 = (unint64_t *)&v31->__shared_owners_;
  do
    v33 = __ldaxr(v32);
  while (__stlxr(v33 - 1, v32));
  if (!v33)
  {
    ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
    std::__shared_weak_count::__release_weak(v31);
  }
  if (v80)
  {
    if (*(_BYTE *)(a1 + 257))
    {
LABEL_50:
      v36 = 0;
      goto LABEL_51;
    }
    v34 = *(_QWORD *)(a1 + 264);
    if (v34)
    {
      v35 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315138;
        *(_QWORD *)&buf[4] = "activateDataContextIP";
        _os_log_impl(&dword_216897000, v35, OS_LOG_TYPE_DEFAULT, "#I %s: DeactivateDelayTimer already scheduled. Dispose it", buf, 0xCu);
        v34 = *(_QWORD *)(a1 + 264);
        *(_QWORD *)(a1 + 264) = 0;
        if (!v34)
          goto LABEL_45;
      }
      else
      {
        *(_QWORD *)(a1 + 264) = 0;
      }
      (*(void (**)(uint64_t))(*(_QWORD *)v34 + 8))(v34);
    }
LABEL_45:
    v42 = *(_DWORD *)(a1 + 136);
    if (v42 <= 6)
    {
      if (((1 << v42) & 0x2E) != 0)
      {
        v43 = *(NSObject **)(a1 + 40);
        v36 = 0;
        if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
        {
          v44 = asString();
          *(_DWORD *)buf = 136315394;
          *(_QWORD *)&buf[4] = "activateDataContextIP";
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = v44;
          v39 = "#I %s:  can not activate at %s, nothing to be done";
          v40 = v43;
          v41 = 22;
          goto LABEL_49;
        }
        goto LABEL_51;
      }
      if (((1 << v42) & 0x50) != 0)
      {
        v48 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
        {
          v49 = asString();
          *(_DWORD *)buf = 136315394;
          *(_QWORD *)&buf[4] = "activateDataContextIP";
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = v49;
          _os_log_impl(&dword_216897000, v48, OS_LOG_TYPE_DEFAULT, "#I %s:  can not activate at %s, nothing to be done", buf, 0x16u);
        }
        v36 = 1;
        goto LABEL_51;
      }
    }
    v78 = 0;
    v79 = 0;
    if ((a6 & 1) == 0)
    {
      v50 = (_QWORD *)*a5;
      if (!*a5)
      {
        v56 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
        {
          v57 = asString();
          *(_DWORD *)buf = 136315394;
          *(_QWORD *)&buf[4] = "activateDataContextIP";
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = v57;
          _os_log_impl(&dword_216897000, v56, OS_LOG_TYPE_DEFAULT, "#I %s:  can not activate at %s, another activation in process", buf, 0x16u);
        }
        goto LABEL_103;
      }
      v51 = *(_DWORD *)(a1 + 140);
      if (v51 == 2)
      {
        v59 = v50[3];
        v58 = v50[4];
        *(_QWORD *)buf = v59;
        *(_QWORD *)&buf[8] = v58;
        if (v58)
        {
          v60 = (unint64_t *)(v58 + 8);
          do
            v61 = __ldxr(v60);
          while (__stxr(v61 + 1, v60));
        }
      }
      else if (v51 == 1)
      {
        v53 = v50[1];
        v52 = v50[2];
        *(_QWORD *)buf = v53;
        *(_QWORD *)&buf[8] = v52;
        if (v52)
        {
          v54 = (unint64_t *)(v52 + 8);
          do
            v55 = __ldxr(v54);
          while (__stxr(v55 + 1, v54));
        }
      }
      else
      {
        *(_QWORD *)buf = 0;
        *(_QWORD *)&buf[8] = 0;
      }
      std::shared_ptr<qmi::Client::State>::operator=[abi:ne180100]((uint64_t)&v78, (__int128 *)buf);
      std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)buf);
    }
    PDPMetricInfo::clear((PDPMetricInfo *)(a1 + 384));
    *(_DWORD *)(a1 + 552) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 232))(a1);
    std::string::operator=((std::string *)(a1 + 392), a3);
    *(_QWORD *)(a1 + 544) = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 616) + 80))(*(_QWORD *)(a1 + 616));
    *(_DWORD *)(a1 + 284) = a2;
    v62 = (capabilities::ct *)std::function<BOOL ()(void)>::operator=((_QWORD *)(a1 + 640), a1 + 48);
    *(_BYTE *)(a1 + 638) = 0;
    if (capabilities::ct::supportsDataQMIExtensions(v62) && !*(_BYTE *)(a1 + 672))
    {
      v63 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_216897000, v63, OS_LOG_TYPE_DEFAULT, "#I lazy creation of fQOSClient", buf, 2u);
      }
      *(_QWORD *)buf = 0;
      *(_QWORD *)&buf[8] = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(a1 + 104));
      if (*(_QWORD *)&buf[8])
      {
        v64 = *(_QWORD *)(a1 + 96);
        *(_QWORD *)buf = v64;
      }
      else
      {
        v64 = *(_QWORD *)buf;
      }
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v64 + 416))(v64, *(unsigned int *)(a1 + 140));
      std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)buf);
      *(_BYTE *)(a1 + 672) = 1;
    }
    v65 = *(_DWORD *)(a1 + 632) != 4;
    *(_BYTE *)(a1 + 637) = v65;
    if (!*(_QWORD *)(a1 + 160))
    {
      *(_BYTE *)(a1 + 637) = 1;
      v66 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
      {
LABEL_89:
        if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315138;
          *(_QWORD *)&buf[4] = "activateDataContextIP";
          _os_log_impl(&dword_216897000, v66, OS_LOG_TYPE_DEFAULT, "#N %s: PendingChannelInitialization: Too early!!! Context comm channel is not initialized yet. Initiating pending activation.", buf, 0xCu);
        }
        v76 = 0;
        v77 = 0;
        ctu::SharedSynchronizable<QMIDataContextIPBase>::weak_from_this(&v76, *(_QWORD *)(a1 + 8), *(std::__shared_weak_count **)(a1 + 16));
        v67 = v77;
        *(_QWORD *)buf = a1;
        *(_QWORD *)&buf[8] = v76;
        *(_QWORD *)&buf[16] = v77;
        if (v77)
        {
          p_shared_weak_owners = (unint64_t *)&v77->__shared_weak_owners_;
          do
            v69 = __ldxr(p_shared_weak_owners);
          while (__stxr(v69 + 1, p_shared_weak_owners));
        }
        LOBYTE(v83) = a4;
        v84 = v78;
        v85 = v79;
        if (v79)
        {
          v70 = (unint64_t *)(v79 + 8);
          do
            v71 = __ldxr(v70);
          while (__stxr(v71 + 1, v70));
        }
        v86 = a6;
        std::function<BOOL ()(void)>::operator=<QMIDataContextIPBase::activateDataContextIP(DataProtocolFamily,std::string const&,BOOL,std::shared_ptr<QMIActivationLock>,BOOL)::$_0,void>((_QWORD *)(a1 + 640), (uint64_t *)buf);
        QMIDataContextIPBase::activateDataContextIP(DataProtocolFamily,std::string const&,BOOL,std::shared_ptr<QMIActivationLock>,BOOL)::$_0::~$_0((uint64_t)buf);
        if (!*(_QWORD *)(a1 + 160))
        {
          v72 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl(&dword_216897000, v72, OS_LOG_TYPE_DEFAULT, "#I create fWDSClient on-demand", buf, 2u);
          }
          QMIDataContextIPBase::createWdsClientOnDemand_sync((QMIDataContextIPBase *)a1);
        }
        if (v67)
          std::__shared_weak_count::__release_weak(v67);
LABEL_103:
        v36 = 1;
LABEL_108:
        std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&v78);
        goto LABEL_51;
      }
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_216897000, v66, OS_LOG_TYPE_DEFAULT, "#I force fPendingChannelInitialization to true", buf, 2u);
      v65 = *(unsigned __int8 *)(a1 + 637);
    }
    if (!v65)
    {
      v75[0] = v78;
      v75[1] = v79;
      if (v79)
      {
        v73 = (unint64_t *)(v79 + 8);
        do
          v74 = __ldxr(v73);
        while (__stxr(v74 + 1, v73));
      }
      v36 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 328))(a1, a4, v75, a6);
      std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)v75);
      goto LABEL_108;
    }
    v66 = *(NSObject **)(a1 + 40);
    goto LABEL_89;
  }
  v38 = *(NSObject **)(a1 + 40);
  v36 = 0;
  if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    v39 = "#N activateDataContextIP: probably other IP family activation already failed and settings was cleaned";
    v40 = v38;
    v41 = 2;
LABEL_49:
    _os_log_impl(&dword_216897000, v40, OS_LOG_TYPE_DEFAULT, v39, buf, v41);
    goto LABEL_50;
  }
LABEL_51:
  v45 = v81;
  if (v81)
  {
    v46 = (unint64_t *)&v81->__shared_owners_;
    do
      v47 = __ldaxr(v46);
    while (__stlxr(v47 - 1, v46));
    if (!v47)
    {
      ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
      std::__shared_weak_count::__release_weak(v45);
    }
  }
  return v36;
}

void sub_216A02AB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  uint64_t v6;
  va_list va;
  uint64_t v8;
  va_list va1;

  va_start(va1, a5);
  va_start(va, a5);
  v6 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

void ctu::SharedSynchronizable<QMIDataContextIPBase>::weak_from_this(_QWORD *a1, uint64_t a2, std::__shared_weak_count *this)
{
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_weak_owners;
  unint64_t v8;
  unint64_t *p_shared_owners;
  unint64_t v10;

  if (!this || (v5 = std::__shared_weak_count::lock(this)) == 0)
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v6 = v5;
  *a1 = a2;
  a1[1] = v5;
  p_shared_weak_owners = (unint64_t *)&v5->__shared_weak_owners_;
  do
    v8 = __ldxr(p_shared_weak_owners);
  while (__stxr(v8 + 1, p_shared_weak_owners));
  p_shared_owners = (unint64_t *)&v5->__shared_owners_;
  do
    v10 = __ldaxr(p_shared_owners);
  while (__stlxr(v10 - 1, p_shared_owners));
  if (!v10)
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v6);
  }
}

_QWORD *std::function<BOOL ()(void)>::operator=<QMIDataContextIPBase::activateDataContextIP(DataProtocolFamily,std::string const&,BOOL,std::shared_ptr<QMIActivationLock>,BOOL)::$_0,void>(_QWORD *a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  _QWORD v20[3];
  _QWORD *v21;
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  v3 = *a2;
  v4 = a2[1];
  v5 = a2[2];
  a2[1] = 0;
  a2[2] = 0;
  v6 = *((_BYTE *)a2 + 24);
  v7 = a2[4];
  v8 = a2[5];
  a2[4] = 0;
  a2[5] = 0;
  v9 = *((_BYTE *)a2 + 48);
  v10 = operator new(0x40uLL);
  *v10 = &off_24D5DF238;
  v10[1] = v3;
  v10[2] = v4;
  v10[3] = v5;
  *((_BYTE *)v10 + 32) = v6;
  v10[5] = v7;
  v10[6] = v8;
  *((_BYTE *)v10 + 56) = v9;
  v21 = v10;
  std::__function::__value_func<BOOL ()(void)>::swap[abi:ne180100](v20, a1);
  v17 = v21;
  if (v21 == v20)
  {
    v18 = 4;
    v17 = v20;
    goto LABEL_5;
  }
  if (v21)
  {
    v18 = 5;
LABEL_5:
    (*(void (**)(_QWORD *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*v17 + 8 * v18))(v17, v11, v12, v13, v14, v15, v16);
  }
  return a1;
}

void sub_216A02CD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  QMIDataContextIPBase::activateDataContextIP(DataProtocolFamily,std::string const&,BOOL,std::shared_ptr<QMIActivationLock>,BOOL)::$_0::~$_0((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t QMIDataContextIPBase::activateDataContextIP(DataProtocolFamily,std::string const&,BOOL,std::shared_ptr<QMIActivationLock>,BOOL)::$_0::~$_0(uint64_t a1)
{
  std::__shared_weak_count *v2;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
  v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  return a1;
}

void QMIDataContextIPBase::stopNetworkIface(QMIDataContextIPBase *this, int a2)
{
  NSObject *v4;
  int v5;
  NSObject *v6;
  const void **v7;
  char *v8;
  _DWORD *v9;
  int v10;
  NSObject *v11;
  _BOOL4 v12;
  const void **v13;
  char *v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  char *v20;
  char *v21;
  _WORD *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  char *v30;
  char *v31;
  char *v32;
  char *v33;
  uint64_t v34;
  uint64_t v35;
  const void **v36;
  char *v37;
  _BYTE *v38;
  uint64_t v39;
  uint64_t v40;
  _QWORD *v41;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  char *v45;
  uint64_t *v46;
  char *v47;
  char *v48;
  char *v49;
  uint64_t v50;
  void *v51;
  uint64_t *v52;
  char *v53;
  char *v54;
  char *v55;
  uint64_t v56;
  const void **v57;
  char *v58;
  _BYTE *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  _QWORD *v63;
  uint64_t v64;
  unint64_t v65;
  unint64_t v66;
  char *v67;
  uint64_t *v68;
  char *v69;
  char *v70;
  char *v71;
  uint64_t v72;
  unsigned __int16 *v73;
  void *v74;
  NSObject *v75;
  int v76;
  _QWORD v77[5];
  char v78;
  _QWORD v79[5];
  char *v80;
  uint64_t v81;
  int v82;
  char *v83;
  void *aBlock;
  void *__p[2];
  __int128 v86;
  _BYTE buf[24];
  void *v88;
  _QWORD *v89;
  uint64_t v90;

  v90 = *MEMORY[0x24BDAC8D0];
  v4 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = "stopNetworkIface";
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = asStringBool();
    _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I %s: start, stopRequestSent=%s", buf, 0x16u);
  }
  if (!*((_BYTE *)this + 636))
  {
    v5 = *((_DWORD *)this + 45);
    if (v5 != -1)
    {
      v6 = *((_QWORD *)this + 5);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315394;
        *(_QWORD *)&buf[4] = "stopNetworkIface";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v5;
        _os_log_impl(&dword_216897000, v6, OS_LOG_TYPE_DEFAULT, "#I %s: Deactivating fPacketDataHandle=%d", buf, 0x12u);
      }
      *(_OWORD *)__p = 0u;
      v86 = 0u;
      qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
      v7 = (const void **)__p[1];
      if (__p[1] != (void *)v86)
      {
        while (*((_BYTE *)*v7 + 8) != 1)
        {
          if (++v7 == (const void **)v86)
            goto LABEL_21;
        }
      }
      if (v7 == (const void **)v86)
      {
LABEL_21:
        v8 = (char *)operator new();
        v14 = v8;
        v8[8] = 1;
        *(_QWORD *)v8 = &off_24D5DF2D0;
        *((_DWORD *)v8 + 3) = 0;
        v9 = v8 + 12;
        v15 = v86;
        if ((unint64_t)v86 >= *((_QWORD *)&v86 + 1))
        {
          v17 = (uint64_t)(v86 - (unint64_t)__p[1]) >> 3;
          if ((unint64_t)(v17 + 1) >> 61)
            goto LABEL_128;
          v18 = (uint64_t)(*((_QWORD *)&v86 + 1) - (unint64_t)__p[1]) >> 2;
          if (v18 <= v17 + 1)
            v18 = v17 + 1;
          if (*((_QWORD *)&v86 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
            v19 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v19 = v18;
          if (v19)
            v20 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v86 + 8, v19);
          else
            v20 = 0;
          v31 = &v20[8 * v17];
          v32 = &v20[8 * v19];
          *(_QWORD *)v31 = v14;
          v16 = v31 + 8;
          v33 = (char *)__p[1];
          v8 = (char *)v86;
          if ((void *)v86 != __p[1])
          {
            do
            {
              v34 = *((_QWORD *)v8 - 1);
              v8 -= 8;
              *((_QWORD *)v31 - 1) = v34;
              v31 -= 8;
            }
            while (v8 != v33);
            v8 = (char *)__p[1];
          }
          __p[1] = v31;
          *(_QWORD *)&v86 = v16;
          *((_QWORD *)&v86 + 1) = v32;
          if (v8)
            operator delete(v8);
        }
        else
        {
          *(_QWORD *)v86 = v8;
          v16 = (_QWORD *)(v15 + 8);
        }
        *(_QWORD *)&v86 = v16;
      }
      else
      {
        if (!v8)
          goto LABEL_127;
        v9 = v8 + 12;
      }
      *v9 = *((_DWORD *)this + 45);
      if ((capabilities::ct::supportsDataQMIExtensions((capabilities::ct *)v8) & 1) == 0)
      {
        LODWORD(v35) = *((unsigned __int8 *)this + 256);
        if ((_DWORD)v35 != 255)
        {
          v36 = (const void **)__p[1];
          if (__p[1] != (void *)v86)
          {
            while (*((unsigned __int8 *)*v36 + 8) != 195)
            {
              if (++v36 == (const void **)v86)
                goto LABEL_62;
            }
          }
          if (v36 == (const void **)v86)
          {
LABEL_62:
            v39 = operator new();
            v35 = v39;
            *(_WORD *)(v39 + 8) = 195;
            *(_QWORD *)v39 = &off_24D5DF320;
            v40 = v86;
            if ((unint64_t)v86 >= *((_QWORD *)&v86 + 1))
            {
              v42 = (uint64_t)(v86 - (unint64_t)__p[1]) >> 3;
              if ((unint64_t)(v42 + 1) >> 61)
                goto LABEL_128;
              v43 = (uint64_t)(*((_QWORD *)&v86 + 1) - (unint64_t)__p[1]) >> 2;
              if (v43 <= v42 + 1)
                v43 = v42 + 1;
              if (*((_QWORD *)&v86 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
                v44 = 0x1FFFFFFFFFFFFFFFLL;
              else
                v44 = v43;
              if (v44)
                v45 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v86 + 8, v44);
              else
                v45 = 0;
              v52 = (uint64_t *)&v45[8 * v42];
              v53 = &v45[8 * v44];
              *v52 = v35;
              v41 = v52 + 1;
              v55 = (char *)__p[1];
              v54 = (char *)v86;
              if ((void *)v86 != __p[1])
              {
                do
                {
                  v56 = *((_QWORD *)v54 - 1);
                  v54 -= 8;
                  *--v52 = v56;
                }
                while (v54 != v55);
                v54 = (char *)__p[1];
              }
              __p[1] = v52;
              *(_QWORD *)&v86 = v41;
              *((_QWORD *)&v86 + 1) = v53;
              if (v54)
                operator delete(v54);
            }
            else
            {
              *(_QWORD *)v86 = v39;
              v41 = (_QWORD *)(v40 + 8);
            }
            v38 = (_BYTE *)(v35 + 9);
            *(_QWORD *)&v86 = v41;
            LOBYTE(v35) = *((_BYTE *)this + 256);
          }
          else
          {
            if (!v37)
              goto LABEL_127;
            v38 = v37 + 9;
          }
          *v38 = v35;
        }
        *((_BYTE *)this + 256) = -1;
      }
      if (!a2)
      {
LABEL_119:
        *((_BYTE *)this + 636) = 1;
        v80 = (char *)this + 144;
        v81 = QMIServiceMsg::create();
        v82 = 25000;
        v73 = (unsigned __int16 *)((char *)this + 176);
        v83 = (char *)this + 176;
        aBlock = 0;
        v79[0] = MEMORY[0x24BDAC760];
        v79[1] = 0x40000000;
        v79[2] = ___ZN20QMIDataContextIPBase16stopNetworkIfaceEb_block_invoke_4;
        v79[3] = &__block_descriptor_tmp_91_0;
        v79[4] = this;
        *(_QWORD *)buf = MEMORY[0x24BDAC760];
        *(_QWORD *)&buf[8] = 0x40000000;
        *(_QWORD *)&buf[16] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3wds16StopNetworkIface8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
        v88 = &unk_24D5DF3A0;
        v89 = v79;
        v74 = _Block_copy(buf);
        aBlock = v74;
        if (v81)
        {
          qmi::Client::send();
          v74 = aBlock;
        }
        if (v74)
          _Block_release(v74);
        v75 = *((_QWORD *)this + 5);
        if (os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT))
        {
          v76 = *v73;
          *(_DWORD *)buf = 136315394;
          *(_QWORD *)&buf[4] = "stopNetworkIface";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v76;
          _os_log_impl(&dword_216897000, v75, OS_LOG_TYPE_DEFAULT, "#I %s: Sent StopNetworkIface fActivateTxId=%d", buf, 0x12u);
        }
LABEL_125:
        qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
        return;
      }
      v57 = (const void **)__p[1];
      if (__p[1] != (void *)v86)
      {
        while (*((_BYTE *)*v57 + 8) != 17)
        {
          if (++v57 == (const void **)v86)
            goto LABEL_101;
        }
      }
      if (v57 != (const void **)v86)
      {
        if (v58)
        {
          v59 = v58 + 9;
LABEL_118:
          *v59 = 1;
          goto LABEL_119;
        }
LABEL_127:
        __cxa_bad_cast();
      }
LABEL_101:
      v60 = operator new();
      v61 = v60;
      *(_WORD *)(v60 + 8) = 17;
      *(_QWORD *)v60 = &off_24D5DF370;
      v62 = v86;
      if ((unint64_t)v86 < *((_QWORD *)&v86 + 1))
      {
        *(_QWORD *)v86 = v60;
        v63 = (_QWORD *)(v62 + 8);
LABEL_117:
        v59 = (_BYTE *)(v61 + 9);
        *(_QWORD *)&v86 = v63;
        goto LABEL_118;
      }
      v64 = (uint64_t)(v86 - (unint64_t)__p[1]) >> 3;
      if (!((unint64_t)(v64 + 1) >> 61))
      {
        v65 = (uint64_t)(*((_QWORD *)&v86 + 1) - (unint64_t)__p[1]) >> 2;
        if (v65 <= v64 + 1)
          v65 = v64 + 1;
        if (*((_QWORD *)&v86 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v66 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v66 = v65;
        if (v66)
          v67 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v86 + 8, v66);
        else
          v67 = 0;
        v68 = (uint64_t *)&v67[8 * v64];
        v69 = &v67[8 * v66];
        *v68 = v61;
        v63 = v68 + 1;
        v71 = (char *)__p[1];
        v70 = (char *)v86;
        if ((void *)v86 != __p[1])
        {
          do
          {
            v72 = *((_QWORD *)v70 - 1);
            v70 -= 8;
            *--v68 = v72;
          }
          while (v70 != v71);
          v70 = (char *)__p[1];
        }
        __p[1] = v68;
        *(_QWORD *)&v86 = v63;
        *((_QWORD *)&v86 + 1) = v69;
        if (v70)
          operator delete(v70);
        goto LABEL_117;
      }
LABEL_128:
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    }
    v10 = *((unsigned __int16 *)this + 88);
    v11 = *((_QWORD *)this + 5);
    v12 = os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT);
    if (v10)
    {
      if (v12)
      {
        *(_DWORD *)buf = 136315394;
        *(_QWORD *)&buf[4] = "stopNetworkIface";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v10;
        _os_log_impl(&dword_216897000, v11, OS_LOG_TYPE_DEFAULT, "#I %s: Aborting transaction fActivateTxId=%d", buf, 0x12u);
      }
      *(_OWORD *)__p = 0u;
      v86 = 0u;
      qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
      v13 = (const void **)__p[1];
      if (__p[1] != (void *)v86)
      {
        while (*((_BYTE *)*v13 + 8) != 1)
        {
          if (++v13 == (const void **)v86)
            goto LABEL_36;
        }
      }
      if (v13 == (const void **)v86)
      {
LABEL_36:
        v23 = operator new();
        v24 = v23;
        *(_BYTE *)(v23 + 8) = 1;
        *(_QWORD *)v23 = &off_24D5DF3E8;
        *(_WORD *)(v23 + 10) = 0;
        v22 = (_WORD *)(v23 + 10);
        v25 = v86;
        if ((unint64_t)v86 >= *((_QWORD *)&v86 + 1))
        {
          v27 = (uint64_t)(v86 - (unint64_t)__p[1]) >> 3;
          if ((unint64_t)(v27 + 1) >> 61)
            std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
          v28 = (uint64_t)(*((_QWORD *)&v86 + 1) - (unint64_t)__p[1]) >> 2;
          if (v28 <= v27 + 1)
            v28 = v27 + 1;
          if (*((_QWORD *)&v86 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
            v29 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v29 = v28;
          if (v29)
            v30 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v86 + 8, v29);
          else
            v30 = 0;
          v46 = (uint64_t *)&v30[8 * v27];
          v47 = &v30[8 * v29];
          *v46 = v24;
          v26 = v46 + 1;
          v49 = (char *)__p[1];
          v48 = (char *)v86;
          if ((void *)v86 != __p[1])
          {
            do
            {
              v50 = *((_QWORD *)v48 - 1);
              v48 -= 8;
              *--v46 = v50;
            }
            while (v48 != v49);
            v48 = (char *)__p[1];
          }
          __p[1] = v46;
          *(_QWORD *)&v86 = v26;
          *((_QWORD *)&v86 + 1) = v47;
          if (v48)
            operator delete(v48);
        }
        else
        {
          *(_QWORD *)v86 = v23;
          v26 = (_QWORD *)(v25 + 8);
        }
        *(_QWORD *)&v86 = v26;
      }
      else
      {
        if (!v21)
          __cxa_bad_cast();
        v22 = v21 + 10;
      }
      *v22 = *((_WORD *)this + 88);
      v80 = (char *)this + 144;
      v81 = QMIServiceMsg::create();
      v82 = 25000;
      v83 = 0;
      aBlock = 0;
      v77[0] = MEMORY[0x24BDAC760];
      v77[1] = 0x40000000;
      v77[2] = ___ZN20QMIDataContextIPBase16stopNetworkIfaceEb_block_invoke_2_95;
      v77[3] = &__block_descriptor_tmp_96_1;
      v77[4] = this;
      v78 = a2;
      *(_QWORD *)buf = MEMORY[0x24BDAC760];
      *(_QWORD *)&buf[8] = 0x40000000;
      *(_QWORD *)&buf[16] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3wds16AbortTransaction8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
      v88 = &unk_24D5DF418;
      v89 = v77;
      v51 = _Block_copy(buf);
      aBlock = v51;
      if (v81)
      {
        qmi::Client::send();
        v51 = aBlock;
      }
      if (v51)
        _Block_release(v51);
      *((_WORD *)this + 88) = 0;
      goto LABEL_125;
    }
    if (v12)
    {
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = "stopNetworkIface";
      _os_log_impl(&dword_216897000, v11, OS_LOG_TYPE_DEFAULT, "#I %s: Both fPacketDataHandle and fActivateTxId are invalid, not doing anything", buf, 0xCu);
    }
  }
}

void sub_216A0364C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  uint64_t v13;
  va_list va;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  va_list va1;

  va_start(va1, a12);
  va_start(va, a12);
  v13 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  v18 = va_arg(va1, _QWORD);
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)va);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va1);
  _Unwind_Resume(a1);
}

void ___ZN20QMIDataContextIPBase16stopNetworkIfaceEb_block_invoke_4(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  NSObject *v4;
  int v5;
  NSObject *v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  unsigned int v11;
  NSObject *v12;
  uint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  int v23;
  const char *v24;
  __int16 v25;
  _WORD v26[17];

  *(_QWORD *)&v26[13] = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)(v2 + 257))
  {
    v4 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      v23 = 136315138;
      v24 = "handleDeactivateResponse";
      _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I %s: start", (uint8_t *)&v23, 0xCu);
    }
    v5 = *(_DWORD *)(a2 + 4);
    if (v5)
    {
      v6 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        v7 = qmi::asString();
        v23 = 136315650;
        v24 = "handleDeactivateResponse";
        v25 = 1024;
        *(_DWORD *)v26 = v5;
        v26[2] = 2080;
        *(_QWORD *)&v26[3] = v7;
        _os_log_impl(&dword_216897000, v6, OS_LOG_TYPE_DEFAULT, "#I %s: Error deactivating: 0x%x (%s)", (uint8_t *)&v23, 0x1Cu);
      }
      if (QMIDataContextIPBase::transitionalStateMaskIP((QMIDataContextIPBase *)v2)
        || (*(unsigned int (**)(uint64_t))(*(_QWORD *)v2 + 96))(v2) == 4)
      {
        QMIDataContextIPBase::setDataContextIPState(v2, 1u);
        v8 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v2 + 104));
        (*(void (**)(_QWORD, _QWORD, uint64_t, _QWORD, _QWORD, uint64_t, _QWORD))(**(_QWORD **)(v2 + 96) + 64))(*(_QWORD *)(v2 + 96), *(unsigned int *)(v2 + 140), 1, 0, 0, 2, 0);
        p_shared_owners = (unint64_t *)&v8->__shared_owners_;
        do
          v10 = __ldaxr(p_shared_owners);
        while (__stlxr(v10 - 1, p_shared_owners));
        if (!v10)
        {
          ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
          std::__shared_weak_count::__release_weak(v8);
        }
LABEL_13:
        QMIDataContextIPBase::doneWithContext((QMIDataContextIPBase *)v2);
        return;
      }
      v11 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 96))(v2);
      if (v11 <= 6)
      {
        if (((1 << v11) & 0x73) != 0)
        {
          v12 = *(NSObject **)(v2 + 40);
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
          {
            (*(void (**)(uint64_t))(*(_QWORD *)v2 + 96))(v2);
            v13 = asString();
            v23 = 136315394;
            v24 = "handleDeactivateResponse";
            v25 = 2080;
            *(_QWORD *)v26 = v13;
            _os_log_impl(&dword_216897000, v12, OS_LOG_TYPE_DEFAULT, "#I %s: At wrong state %s", (uint8_t *)&v23, 0x16u);
          }
        }
        else
        {
          if (v11 == 2)
          {
            v14 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v2 + 104));
            (*(void (**)(_QWORD, _QWORD, uint64_t, _QWORD, _QWORD, uint64_t, _QWORD))(**(_QWORD **)(v2 + 96)
                                                                                             + 64))(*(_QWORD *)(v2 + 96), *(unsigned int *)(v2 + 140), 93, 0, 0, 2, 0);
            v15 = (unint64_t *)&v14->__shared_owners_;
            do
              v16 = __ldaxr(v15);
            while (__stlxr(v16 - 1, v15));
            if (!v16)
            {
              ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
              std::__shared_weak_count::__release_weak(v14);
            }
            v17 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v2 + 104));
            (*(void (**)(_QWORD))(**(_QWORD **)(v2 + 96) + 96))(*(_QWORD *)(v2 + 96));
            v18 = (unint64_t *)&v17->__shared_owners_;
            do
              v19 = __ldaxr(v18);
            while (__stlxr(v19 - 1, v18));
            if (!v19)
            {
              ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
              std::__shared_weak_count::__release_weak(v17);
            }
            goto LABEL_13;
          }
          QMIDataContextIPBase::setDataContextIPState(v2, 0);
          v20 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v2 + 104));
          (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)(v2 + 96) + 72))(*(_QWORD *)(v2 + 96), *(unsigned int *)(v2 + 140));
          v21 = (unint64_t *)&v20->__shared_owners_;
          do
            v22 = __ldaxr(v21);
          while (__stlxr(v22 - 1, v21));
          if (!v22)
          {
            ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
            std::__shared_weak_count::__release_weak(v20);
          }
          QMIDataContextIPBase::doneWithContext((QMIDataContextIPBase *)v2);
        }
      }
    }
  }
}

void sub_216A03A30(_Unwind_Exception *exception_object)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v4;

  p_shared_owners = (unint64_t *)&v1->__shared_owners_;
  do
    v4 = __ldaxr(p_shared_owners);
  while (__stlxr(v4 - 1, p_shared_owners));
  if (!v4)
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN20QMIDataContextIPBase16stopNetworkIfaceEb_block_invoke_2_95(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v4;
  int v5;
  NSObject *v6;
  NSObject *v7;
  uint64_t v8;
  NSObject *v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  unsigned int v13;
  NSObject *v14;
  uint64_t v15;
  std::__shared_weak_count *v16;
  NSObject *v17;
  std::__shared_weak_count *v18;
  NSObject *v19;
  std::__shared_weak_count *v20;
  _BYTE v21[28];
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)(v2 + 257))
  {
    v4 = *(_DWORD *)(a2 + 4);
    if (!v4)
      *(_BYTE *)(v2 + 636) = 1;
    v5 = *(unsigned __int8 *)(a1 + 40);
    v6 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)v21 = 136315138;
      *(_QWORD *)&v21[4] = "handleAbortActivateResponse";
      _os_log_impl(&dword_216897000, v6, OS_LOG_TYPE_DEFAULT, "#I %s: start", v21, 0xCu);
      v4 = *(_DWORD *)(a2 + 4);
    }
    if (v4)
    {
      v7 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        v8 = qmi::asString();
        *(_DWORD *)v21 = 136315650;
        *(_QWORD *)&v21[4] = "handleAbortActivateResponse";
        *(_WORD *)&v21[12] = 1024;
        *(_DWORD *)&v21[14] = v4;
        *(_WORD *)&v21[18] = 2080;
        *(_QWORD *)&v21[20] = v8;
        _os_log_impl(&dword_216897000, v7, OS_LOG_TYPE_DEFAULT, "#E %s: Activation abort failed 0x%x (%s)", v21, 0x1Cu);
      }
      if (*(_DWORD *)(v2 + 180) != -1)
      {
        v9 = *(NSObject **)(v2 + 40);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)v21 = 136315138;
          *(_QWORD *)&v21[4] = "handleAbortActivateResponse";
          _os_log_impl(&dword_216897000, v9, OS_LOG_TYPE_DEFAULT, "#I %s: trying normal deactivation...", v21, 0xCu);
        }
        if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v2 + 96))(v2) == 6)
          QMIDataContextIPBase::setDataContextIPState(v2, 3u);
        (*(void (**)(uint64_t, BOOL))(*(_QWORD *)v2 + 336))(v2, v5 != 0);
      }
    }
    else if (QMIDataContextIPBase::transitionalStateMaskIP((QMIDataContextIPBase *)v2)
           || (*(unsigned int (**)(uint64_t))(*(_QWORD *)v2 + 96))(v2) == 4)
    {
      QMIDataContextIPBase::setDataContextIPState(v2, 1u);
      v10 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v2 + 104));
      *(_QWORD *)v21 = *(_QWORD *)(v2 + 96);
      *(_QWORD *)&v21[8] = v10;
      (*(void (**)(_QWORD, _QWORD, uint64_t, _QWORD, _QWORD, uint64_t, _QWORD))(**(_QWORD **)v21 + 64))(*(_QWORD *)v21, *(unsigned int *)(v2 + 140), 1, 0, 0, 2, 0);
      p_shared_owners = (unint64_t *)&v10->__shared_owners_;
      do
        v12 = __ldaxr(p_shared_owners);
      while (__stlxr(v12 - 1, p_shared_owners));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
      QMIDataContextIPBase::doneWithContext((QMIDataContextIPBase *)v2);
    }
    else
    {
      v13 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 96))(v2);
      if (v13 <= 6)
      {
        if (((1 << v13) & 0x73) != 0)
        {
          v14 = *(NSObject **)(v2 + 40);
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
          {
            (*(void (**)(uint64_t))(*(_QWORD *)v2 + 96))(v2);
            v15 = asString();
            *(_DWORD *)v21 = 136315394;
            *(_QWORD *)&v21[4] = "handleAbortActivateResponse";
            *(_WORD *)&v21[12] = 2080;
            *(_QWORD *)&v21[14] = v15;
            _os_log_impl(&dword_216897000, v14, OS_LOG_TYPE_DEFAULT, "#I %s: Activation aborted but in %s", v21, 0x16u);
          }
        }
        else if (v13 == 2)
        {
          v16 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v2 + 104));
          *(_QWORD *)v21 = *(_QWORD *)(v2 + 96);
          *(_QWORD *)&v21[8] = v16;
          (*(void (**)(_QWORD, _QWORD, uint64_t, _QWORD, _QWORD, uint64_t, _QWORD))(**(_QWORD **)v21 + 64))(*(_QWORD *)v21, *(unsigned int *)(v2 + 140), 93, 0, 0, 2, 0);
          std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)v21);
          v17 = *(NSObject **)(v2 + 40);
          if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)v21 = 136315138;
            *(_QWORD *)&v21[4] = "handleAbortActivateResponse";
            _os_log_impl(&dword_216897000, v17, OS_LOG_TYPE_DEFAULT, "#I %s: Activation aborted successfully", v21, 0xCu);
          }
          v18 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v2 + 104));
          *(_QWORD *)v21 = *(_QWORD *)(v2 + 96);
          *(_QWORD *)&v21[8] = v18;
          (*(void (**)(_QWORD))(**(_QWORD **)v21 + 96))(*(_QWORD *)v21);
          std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)v21);
          QMIDataContextIPBase::doneWithContext((QMIDataContextIPBase *)v2);
        }
        else
        {
          v19 = *(NSObject **)(v2 + 40);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)v21 = 136315138;
            *(_QWORD *)&v21[4] = "handleAbortActivateResponse";
            _os_log_impl(&dword_216897000, v19, OS_LOG_TYPE_DEFAULT, "#I %s: Activation aborted successfully", v21, 0xCu);
          }
          QMIDataContextIPBase::setDataContextIPState(v2, 0);
          v20 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v2 + 104));
          *(_QWORD *)v21 = *(_QWORD *)(v2 + 96);
          *(_QWORD *)&v21[8] = v20;
          (*(void (**)(_QWORD))(**(_QWORD **)v21 + 120))(*(_QWORD *)v21);
          std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)v21);
          QMIDataContextIPBase::doneWithContext((QMIDataContextIPBase *)v2);
        }
      }
    }
  }
}

void sub_216A03F4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void QMIDataContextIPBase::reportHandoverWwanPduSessionId(QMIDataContextIPBase *this, char a2)
{
  void *v4;
  NSObject *v5;
  _QWORD v6[6];
  uint64_t v7;
  int v8;
  uint64_t v9;
  void *v10;
  _OWORD v11[2];
  _QWORD aBlock[6];

  if (capabilities::ct::supports5G(this)
    && (*(unsigned int (**)(QMIDataContextIPBase *))(*(_QWORD *)this + 96))(this))
  {
    if (*((_QWORD *)this + 20))
    {
      memset(v11, 0, sizeof(v11));
      qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v11);
      *(_BYTE *)qmi::MutableMessageBase::getTLV<wds::tlv::PduSessionId>(v11, 16) = a2;
      v6[5] = (char *)this + 144;
      v7 = QMIServiceMsg::create();
      v8 = 25000;
      v9 = 0;
      v10 = 0;
      v6[0] = MEMORY[0x24BDAC760];
      v6[1] = 0x40000000;
      v6[2] = ___ZN20QMIDataContextIPBase30reportHandoverWwanPduSessionIdEj_block_invoke_2;
      v6[3] = &__block_descriptor_tmp_99_2;
      v6[4] = this;
      aBlock[0] = MEMORY[0x24BDAC760];
      aBlock[1] = 0x40000000;
      aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3wds26SetHandoffWwanPduSessionId8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
      aBlock[3] = &unk_24D5DF440;
      aBlock[4] = v6;
      v4 = _Block_copy(aBlock);
      v10 = v4;
      if (v7)
      {
        qmi::Client::send();
        v4 = v10;
      }
      if (v4)
        _Block_release(v4);
      qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v11);
    }
    else
    {
      v5 = *((_QWORD *)this + 5);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        LOWORD(aBlock[0]) = 0;
        _os_log_error_impl(&dword_216897000, v5, OS_LOG_TYPE_ERROR, "invalid fWDSClient when SetHandoffWwanPduSessionId", (uint8_t *)aBlock, 2u);
      }
    }
  }
}

void sub_216A040D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  uint64_t v7;
  va_list va;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  va_list va1;

  va_start(va1, a6);
  va_start(va, a6);
  v7 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)va);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va1);
  _Unwind_Resume(a1);
}

void ___ZN20QMIDataContextIPBase30reportHandoverWwanPduSessionIdEj_block_invoke_2(uint64_t a1, uint64_t a2)
{
  int v2;
  NSObject *v3;
  _BOOL4 v4;
  const char *v5;
  NSObject *v6;
  uint32_t v7;
  _DWORD v8[2];
  __int16 v9;
  uint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v2 = *(_DWORD *)(a2 + 4);
  v3 = *(NSObject **)(*(_QWORD *)(a1 + 32) + 40);
  v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (!v4)
      return;
    v8[0] = 67109378;
    v8[1] = v2;
    v9 = 2080;
    v10 = qmi::asString();
    v5 = "#I Error Response to SetHandoffWwanPduSessionId: %d(%s)";
    v6 = v3;
    v7 = 18;
  }
  else
  {
    if (!v4)
      return;
    LOWORD(v8[0]) = 0;
    v5 = "#I Successful Response to SetHandoffWwanPduSessionId";
    v6 = v3;
    v7 = 2;
  }
  _os_log_impl(&dword_216897000, v6, OS_LOG_TYPE_DEFAULT, v5, (uint8_t *)v8, v7);
}

uint64_t QMIDataContextIPBase::processDeactivation(QMIDataContextIPBase *this, uint64_t a2)
{
  NSObject *v4;
  int v6;
  const char *v7;
  __int16 v8;
  uint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v4 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v6 = 136315394;
    v7 = "processDeactivation";
    v8 = 2080;
    v9 = asStringBool();
    _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I %s: handoverToOther=%s", (uint8_t *)&v6, 0x16u);
  }
  if ((*(unsigned int (**)(QMIDataContextIPBase *))(*(_QWORD *)this + 96))(this) != 4)
    QMIDataContextIPBase::setDataContextIPState((uint64_t)this, 3u);
  return (*(uint64_t (**)(QMIDataContextIPBase *, uint64_t))(*(_QWORD *)this + 336))(this, a2);
}

uint64_t QMIDataContextIPBase::isPendingChannelInitialization(QMIDataContextIPBase *this)
{
  NSObject *v2;
  int v3;
  _DWORD v5[2];
  uint64_t v6;

  v6 = *MEMORY[0x24BDAC8D0];
  v2 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v3 = *((unsigned __int8 *)this + 637);
    v5[0] = 67109120;
    v5[1] = v3;
    _os_log_impl(&dword_216897000, v2, OS_LOG_TYPE_DEFAULT, "#I fPendingChannelInitialization = %d", (uint8_t *)v5, 8u);
  }
  return *((unsigned __int8 *)this + 637);
}

uint64_t QMIDataContextIPBase::releaseDataContextClient(QMIDataContextIPBase *this)
{
  NSObject *v2;
  _BOOL4 v3;
  uint64_t result;
  const char *v5;
  NSObject *v6;
  const char *v7;
  _BOOL4 v8;
  std::__shared_weak_count *v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  std::__shared_weak_count *v12;
  uint64_t v13;
  unint64_t *p_shared_owners;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  std::__shared_weak_count *v19;
  std::__shared_weak_count *v20;
  std::__shared_weak_count *v21;
  uint64_t v22;
  unint64_t *v23;
  unint64_t v24;
  uint8_t buf[8];
  std::__shared_weak_count *v26;

  if (!*((_QWORD *)this + 20))
  {
    v6 = *((_QWORD *)this + 5);
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      return 1;
    *(_WORD *)buf = 0;
    v7 = "#I Null fWDSClient";
LABEL_7:
    _os_log_impl(&dword_216897000, v6, OS_LOG_TYPE_DEFAULT, v7, buf, 2u);
    return 1;
  }
  if (*((_DWORD *)this + 34))
  {
    v2 = *((_QWORD *)this + 5);
    v3 = os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT);
    result = 0;
    if (!v3)
      return result;
    *(_WORD *)buf = 0;
    v5 = "#I contextIPBase not idle yet";
    goto LABEL_12;
  }
  if (!*((_BYTE *)this + 112))
  {
    v9 = (std::__shared_weak_count *)*((_QWORD *)this + 16);
    if (v9)
    {
      v10 = std::__shared_weak_count::lock(v9);
      v26 = v10;
      if (v10)
      {
        v11 = *((_QWORD *)this + 15);
        *(_QWORD *)buf = v11;
        if (v11)
        {
          v12 = std::__shared_weak_count::lock(*((std::__shared_weak_count **)this + 13));
          v13 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 12) + 40))(*((_QWORD *)this + 12));
          (*(void (**)(uint64_t, _QWORD, char *, uint64_t, _QWORD))(*(_QWORD *)v11 + 48))(v11, 0, (char *)this + 144, v13, *((unsigned int *)this + 35));
          p_shared_owners = (unint64_t *)&v12->__shared_owners_;
          do
            v15 = __ldaxr(p_shared_owners);
          while (__stlxr(v15 - 1, p_shared_owners));
          if (!v15)
          {
            ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
            std::__shared_weak_count::__release_weak(v12);
          }
          v16 = v26;
          if (!v26)
            goto LABEL_28;
        }
        else
        {
          v16 = v10;
        }
        v17 = (unint64_t *)&v16->__shared_owners_;
        do
          v18 = __ldaxr(v17);
        while (__stlxr(v18 - 1, v17));
        if (!v18)
        {
          ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
          std::__shared_weak_count::__release_weak(v16);
        }
      }
    }
LABEL_28:
    v19 = (std::__shared_weak_count *)*((_QWORD *)this + 13);
    if (v19)
    {
      v20 = std::__shared_weak_count::lock(v19);
      v26 = v20;
      if (v20)
      {
        v21 = v20;
        v22 = *((_QWORD *)this + 12);
        *(_QWORD *)buf = v22;
        if (v22)
        {
          (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v22 + 424))(v22, *((unsigned int *)this + 35));
          *((_BYTE *)this + 672) = 0;
        }
        v23 = (unint64_t *)&v21->__shared_owners_;
        do
          v24 = __ldaxr(v23);
        while (__stlxr(v24 - 1, v23));
        if (!v24)
        {
          ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
          std::__shared_weak_count::__release_weak(v21);
        }
      }
    }
    qmi::Client::release((QMIDataContextIPBase *)((char *)this + 144));
    v6 = *((_QWORD *)this + 5);
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      return 1;
    *(_WORD *)buf = 0;
    v7 = "#I fWDSClient deleted";
    goto LABEL_7;
  }
  v2 = *((_QWORD *)this + 5);
  v8 = os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT);
  result = 0;
  if (!v8)
    return result;
  *(_WORD *)buf = 0;
  v5 = "#I Primary client, do not destroy fWDSClient";
LABEL_12:
  _os_log_impl(&dword_216897000, v2, OS_LOG_TYPE_DEFAULT, v5, buf, 2u);
  return 0;
}

void sub_216A045E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t QMIDataContextIPBase::deactivateDataContextIP(QMIDataContextIPBase *this, int a2, uint64_t a3)
{
  NSObject *v6;
  unsigned int v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  std::__shared_weak_count *v11;
  std::__shared_weak_count *v12;
  int v13;
  std::__shared_weak_count *v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  uint64_t *v17;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  uint64_t v25;
  NSObject *v26;
  _BOOL4 v27;
  uint64_t v28;
  NSObject *v29;
  std::__shared_weak_count *v31;
  uint64_t v32;
  std::__shared_weak_count *v33;
  std::__shared_weak_count *v34;
  unint64_t *p_shared_weak_owners;
  unint64_t v36;
  unint64_t *v37;
  unint64_t v38;
  uint64_t v39;
  uint64_t v40;
  NSObject *v41;
  unint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  std::__shared_weak_count *v46;
  unint64_t *v47;
  unint64_t v48;
  _QWORD v49[6];
  std::__shared_weak_count *v50;
  char v51;
  void *aBlock;
  dispatch_object_t object;
  void *__p[2];
  char v55;
  uint64_t v56;
  std::__shared_weak_count *v57;
  uint64_t v58;
  std::__shared_weak_count *v59;
  uint64_t v60;
  std::__shared_weak_count *v61;
  uint64_t v62;
  _BYTE buf[22];
  __int16 v64;
  uint64_t v65;
  uint64_t v66;

  v66 = *MEMORY[0x24BDAC8D0];
  v6 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315650;
    *(_QWORD *)&buf[4] = "deactivateDataContextIP";
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = asStringBool();
    v64 = 2080;
    v65 = asStringBool();
    _os_log_impl(&dword_216897000, v6, OS_LOG_TYPE_DEFAULT, "#I %s: allowDelay=%s, handoverToOther=%s", buf, 0x20u);
  }
  v7 = *((_DWORD *)this + 34);
  if (v7 < 4)
  {
    v8 = *((_QWORD *)this + 5);
    v9 = 0;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v10 = asString();
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "deactivateDataContextIP";
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = v10;
      _os_log_impl(&dword_216897000, v8, OS_LOG_TYPE_DEFAULT, "#I %s: already at %s", buf, 0x16u);
      v9 = 0;
    }
    goto LABEL_39;
  }
  if (v7 - 4 > 2)
  {
LABEL_38:
    v9 = 1;
LABEL_39:
    if (*((_BYTE *)this + 637))
    {
      v29 = *((_QWORD *)this + 5);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_216897000, v29, OS_LOG_TYPE_DEFAULT, "#I set fDeactivatedWhilePendingChannelInit", buf, 2u);
      }
      *((_BYTE *)this + 638) = 1;
    }
    return v9;
  }
  v62 = 0;
  if (!a2)
    goto LABEL_35;
  v11 = std::__shared_weak_count::lock(*((std::__shared_weak_count **)this + 13));
  v60 = *((_QWORD *)this + 12);
  v61 = v11;
  (*(void (**)(_BYTE *__return_ptr, uint64_t))(*(_QWORD *)v60 + 240))(buf, v60);
  if (*(_QWORD *)buf)
  {
    v12 = std::__shared_weak_count::lock(*((std::__shared_weak_count **)this + 13));
    v56 = *((_QWORD *)this + 12);
    v57 = v12;
    (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(_QWORD *)v56 + 240))(&v58, v56);
    v13 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t *))(*(_QWORD *)v58 + 120))(v58, 0, &v62);
    v14 = v59;
    if (v59)
    {
      p_shared_owners = (unint64_t *)&v59->__shared_owners_;
      do
        v16 = __ldaxr(p_shared_owners);
      while (__stlxr(v16 - 1, p_shared_owners));
      if (!v16)
      {
        ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
        std::__shared_weak_count::__release_weak(v14);
      }
    }
    if (v57)
    {
      v17 = &v57->__shared_owners_;
      do
        v18 = __ldaxr((unint64_t *)v17);
      while (__stlxr(v18 - 1, (unint64_t *)v17));
      if (!v18)
      {
        ((void (*)(std::__shared_weak_count *))v57->__on_zero_shared)(v57);
        std::__shared_weak_count::__release_weak(v57);
      }
    }
  }
  else
  {
    v13 = 0;
  }
  v19 = *(std::__shared_weak_count **)&buf[8];
  if (*(_QWORD *)&buf[8])
  {
    v20 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }
  v22 = v61;
  if (!v61)
    goto LABEL_29;
  v23 = (unint64_t *)&v61->__shared_owners_;
  do
    v24 = __ldaxr(v23);
  while (__stlxr(v24 - 1, v23));
  if (v24)
  {
LABEL_29:
    if (v13)
      goto LABEL_30;
LABEL_35:
    v28 = *((_QWORD *)this + 33);
    *((_QWORD *)this + 33) = 0;
    if (v28)
      (*(void (**)(uint64_t))(*(_QWORD *)v28 + 8))(v28);
    QMIDataContextIPBase::processDeactivation(this, a3);
    goto LABEL_38;
  }
  ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
  std::__shared_weak_count::__release_weak(v22);
  if (!v13)
    goto LABEL_35;
LABEL_30:
  v25 = *((_QWORD *)this + 33);
  v26 = *((_QWORD *)this + 5);
  v27 = os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT);
  if (!v25)
  {
    if (v27)
    {
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "deactivateDataContextIP";
      *(_WORD *)&buf[12] = 2048;
      *(_QWORD *)&buf[14] = v62;
      _os_log_impl(&dword_216897000, v26, OS_LOG_TYPE_DEFAULT, "#I %s: Deactivate delay timer set to %lld msecs", buf, 0x16u);
    }
    v31 = (std::__shared_weak_count *)*((_QWORD *)this + 2);
    if (!v31 || (v32 = *((_QWORD *)this + 1), (v33 = std::__shared_weak_count::lock(v31)) == 0))
      std::__throw_bad_weak_ptr[abi:ne180100]();
    v34 = v33;
    p_shared_weak_owners = (unint64_t *)&v33->__shared_weak_owners_;
    do
      v36 = __ldxr(p_shared_weak_owners);
    while (__stxr(v36 + 1, p_shared_weak_owners));
    v37 = (unint64_t *)&v33->__shared_owners_;
    do
      v38 = __ldaxr(v37);
    while (__stlxr(v38 - 1, v37));
    if (!v38)
    {
      ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
      std::__shared_weak_count::__release_weak(v34);
    }
    Registry::getTimerService(*((Registry **)this + 10));
    v39 = *(_QWORD *)buf;
    std::string::basic_string[abi:ne180100]<0>(__p, "Deactivate Delay timer for PDP");
    v40 = 1000 * v62;
    v41 = *((_QWORD *)this + 3);
    object = v41;
    if (v41)
      dispatch_retain(v41);
    v49[0] = MEMORY[0x24BDAC760];
    v49[1] = 1174405120;
    v49[2] = ___ZN20QMIDataContextIPBase23deactivateDataContextIPEbb_block_invoke;
    v49[3] = &__block_descriptor_tmp_101_2;
    v49[4] = this;
    v49[5] = v32;
    v50 = v34;
    do
      v42 = __ldxr(p_shared_weak_owners);
    while (__stxr(v42 + 1, p_shared_weak_owners));
    v51 = a3;
    aBlock = _Block_copy(v49);
    ctu::TimerService::createOneShotTimer(v39, (uint64_t)__p, 0, v40, &object, &aBlock);
    v43 = v60;
    v60 = 0;
    v44 = *((_QWORD *)this + 33);
    *((_QWORD *)this + 33) = v43;
    if (v44)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v44 + 8))(v44);
      v45 = v60;
      v60 = 0;
      if (v45)
        (*(void (**)(uint64_t))(*(_QWORD *)v45 + 8))(v45);
    }
    if (aBlock)
      _Block_release(aBlock);
    if (object)
      dispatch_release(object);
    if (v55 < 0)
      operator delete(__p[0]);
    v46 = *(std::__shared_weak_count **)&buf[8];
    if (*(_QWORD *)&buf[8])
    {
      v47 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
      do
        v48 = __ldaxr(v47);
      while (__stlxr(v48 - 1, v47));
      if (!v48)
      {
        ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
        std::__shared_weak_count::__release_weak(v46);
      }
    }
    if (v50)
      std::__shared_weak_count::__release_weak(v50);
    std::__shared_weak_count::__release_weak(v34);
    goto LABEL_38;
  }
  if (v27)
  {
    *(_DWORD *)buf = 136315138;
    *(_QWORD *)&buf[4] = "deactivateDataContextIP";
    _os_log_impl(&dword_216897000, v26, OS_LOG_TYPE_DEFAULT, "#I %s: DeactivateDelayTimer already scheduled", buf, 0xCu);
  }
  return 1;
}

void sub_216A04BD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, uint64_t a16, void *aBlock, dispatch_object_t object, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,char a25,uint64_t a26,char a27,uint64_t a28,char a29)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

void ctu::TimerService::createOneShotTimer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, NSObject **a5, void **a6)
{
  NSObject *v6;
  void *aBlock;
  dispatch_object_t object;
  void *__p[2];
  uint64_t v10;

  v10 = *(_QWORD *)(a2 + 16);
  *(_OWORD *)__p = *(_OWORD *)a2;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  v6 = *a5;
  *a5 = 0;
  aBlock = *a6;
  object = v6;
  *a6 = 0;
  (*(void (**)(uint64_t, void **, uint64_t, uint64_t, _QWORD, dispatch_object_t *, void **))(*(_QWORD *)a1 + 16))(a1, __p, a3, a4, 0, &object, &aBlock);
  if (aBlock)
    _Block_release(aBlock);
  if (object)
    dispatch_release(object);
  if (SHIBYTE(v10) < 0)
    operator delete(__p[0]);
}

void sub_216A04D20(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *aBlock, dispatch_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (aBlock)
    _Block_release(aBlock);
  if (object)
    dispatch_release(object);
  if (a16 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void ___ZN20QMIDataContextIPBase23deactivateDataContextIPEbb_block_invoke(uint64_t a1)
{
  std::__shared_weak_count *v2;
  QMIDataContextIPBase *v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  NSObject *v6;
  uint64_t v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  uint8_t buf[4];
  const char *v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    v3 = *(QMIDataContextIPBase **)(a1 + 32);
    v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      v5 = v4;
      if (*(_QWORD *)(a1 + 40))
      {
        v6 = *((_QWORD *)v3 + 5);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315138;
          v11 = "deactivateDataContextIP_block_invoke";
          _os_log_impl(&dword_216897000, v6, OS_LOG_TYPE_DEFAULT, "#I %s: Deactivate delay timer fired", buf, 0xCu);
        }
        v7 = *((_QWORD *)v3 + 33);
        *((_QWORD *)v3 + 33) = 0;
        if (v7)
          (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
        QMIDataContextIPBase::processDeactivation(v3, *(unsigned __int8 *)(a1 + 56));
      }
      p_shared_owners = (unint64_t *)&v5->__shared_owners_;
      do
        v9 = __ldaxr(p_shared_owners);
      while (__stlxr(v9 - 1, p_shared_owners));
      if (!v9)
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
    }
  }
}

void sub_216A04E7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_40c45_ZTSNSt3__18weak_ptrI20QMIDataContextIPBaseEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 48) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 16);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void __destroy_helper_block_e8_40c45_ZTSNSt3__18weak_ptrI20QMIDataContextIPBaseEE(uint64_t a1)
{
  std::__shared_weak_count *v1;

  v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1)
    std::__shared_weak_count::__release_weak(v1);
}

uint64_t QMIDataContextIPBase::transitionalStateMaskIP(QMIDataContextIPBase *this)
{
  NSObject *v2;
  int v3;
  NSObject *v4;
  std::__shared_weak_count *v5;
  int v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  std::__shared_weak_count *v9;
  int v10;
  unint64_t *v11;
  unint64_t v12;
  unsigned int v13;
  __int128 v15;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  if (*((_QWORD *)this + 36))
  {
    v2 = *((_QWORD *)this + 5);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v15) = 136315138;
      *(_QWORD *)((char *)&v15 + 4) = "transitionalStateMaskIP";
      _os_log_impl(&dword_216897000, v2, OS_LOG_TYPE_DEFAULT, "#I %s: waiting for IPv6 config to complete", (uint8_t *)&v15, 0xCu);
    }
    v3 = 1;
  }
  else
  {
    v3 = 0;
  }
  if (*((_QWORD *)this + 37))
  {
    v4 = *((_QWORD *)this + 5);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v15) = 136315138;
      *(_QWORD *)((char *)&v15 + 4) = "transitionalStateMaskIP";
      _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I %s: waiting for IPv4 config to complete", (uint8_t *)&v15, 0xCu);
    }
    v3 |= 8u;
  }
  v5 = std::__shared_weak_count::lock(*((std::__shared_weak_count **)this + 13));
  *(_QWORD *)&v15 = *((_QWORD *)this + 12);
  *((_QWORD *)&v15 + 1) = v5;
  v6 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v15 + 320))(v15);
  p_shared_owners = (unint64_t *)&v5->__shared_owners_;
  do
    v8 = __ldaxr(p_shared_owners);
  while (__stlxr(v8 - 1, p_shared_owners));
  if (!v8)
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  v9 = std::__shared_weak_count::lock(*((std::__shared_weak_count **)this + 13));
  *(_QWORD *)&v15 = *((_QWORD *)this + 12);
  *((_QWORD *)&v15 + 1) = v9;
  v10 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v15 + 328))(v15);
  v11 = (unint64_t *)&v9->__shared_owners_;
  do
    v12 = __ldaxr(v11);
  while (__stlxr(v12 - 1, v11));
  if (!v12)
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
  v13 = v3 | 2;
  if (!v6)
    v13 = v3;
  if (v10)
    return v13 | 4;
  else
    return v13;
}

void sub_216A0509C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void QMIDataContextIPBase::handleActivateResponse(uint64_t a1, qmi::MessageBase *a2)
{
  NSObject *v4;
  int v5;
  NSObject *v6;
  capabilities::ct *TlvValue;
  int v8;
  capabilities::ct *v9;
  int v10;
  uint64_t v11;
  NSObject *v12;
  int v13;
  int v14;
  int v15;
  int v16;
  NSObject *v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int v21;
  char v22;
  NSObject *v23;
  uint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *p_shared_owners;
  unint64_t v27;
  unsigned int v28;
  NSObject *v29;
  uint64_t v30;
  const char *v31;
  NSObject *v32;
  uint32_t v33;
  NSObject *v34;
  int v35;
  NSObject *v36;
  int v37;
  int v38;
  _QWORD v39[6];
  uint64_t v40;
  uint64_t *v41;
  uint64_t v42;
  __int16 v43;
  _QWORD *v44;
  _QWORD **v45;
  uint64_t v46;
  __int16 v47;
  _QWORD v48[5];
  _BYTE v49[24];
  __int16 v50;
  int v51;
  _BYTE buf[24];
  __int16 v53;
  uint64_t v54;

  v54 = *MEMORY[0x24BDAC8D0];
  v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315138;
    *(_QWORD *)&buf[4] = "handleActivateResponse";
    _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I %s: start", buf, 0xCu);
  }
  v5 = *((_DWORD *)a2 + 1);
  if (v5)
  {
    if (v5 != 26)
    {
      *(_QWORD *)buf = 0;
      *(_QWORD *)&buf[8] = buf;
      *(_QWORD *)&buf[16] = 0x2000000000;
      v53 = 0;
      v11 = MEMORY[0x24BDAC760];
      v48[0] = MEMORY[0x24BDAC760];
      v48[1] = 0x40000000;
      v48[2] = ___ZN20QMIDataContextIPBase22handleActivateResponseERKN3wds21StartNetworkIfaceBase8ResponseE_block_invoke;
      v48[3] = &unk_24D5DE9A8;
      v48[4] = buf;
      v44 = v48;
      qmi::MessageBase::applyTlv<wds::tlv::CallEndReason,void({block_pointer})(wds::tlv::CallEndReason const&)>(a2, (uint64_t)&v44);
      v44 = 0;
      v45 = &v44;
      v46 = 0x2000000000;
      v47 = 0;
      v40 = 0;
      v41 = &v40;
      v42 = 0x2000000000;
      v43 = 0;
      v39[0] = v11;
      v39[1] = 0x40000000;
      v39[2] = ___ZN20QMIDataContextIPBase22handleActivateResponseERKN3wds21StartNetworkIfaceBase8ResponseE_block_invoke_2;
      v39[3] = &unk_24D5DE9D0;
      v39[4] = &v40;
      v39[5] = &v44;
      *(_QWORD *)v49 = v39;
      qmi::MessageBase::applyTlv<wds::tlv::VerboseCallEndReasonType,void({block_pointer})(wds::tlv::VerboseCallEndReasonType const&)>(a2, (uint64_t)v49);
      v12 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        v13 = *(unsigned __int16 *)(*(_QWORD *)&buf[8] + 24);
        v14 = *((unsigned __int16 *)v45 + 12);
        v15 = *((unsigned __int16 *)v41 + 12);
        *(_DWORD *)v49 = 136315906;
        *(_QWORD *)&v49[4] = "handleActivateResponse";
        *(_WORD *)&v49[12] = 1024;
        *(_DWORD *)&v49[14] = v13;
        *(_WORD *)&v49[18] = 1024;
        *(_DWORD *)&v49[20] = v14;
        v50 = 1024;
        v51 = v15;
        _os_log_impl(&dword_216897000, v12, OS_LOG_TYPE_DEFAULT, "#I %s: Error activating reason = %d verboseReasonType = %d verboseReason = %d", v49, 0x1Eu);
      }
      v16 = *((unsigned __int16 *)v45 + 12);
      if (v16 == 6 || v16 == 1)
      {
        v17 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)v49 = 136315138;
          *(_QWORD *)&v49[4] = "handleActivateResponse";
          _os_log_impl(&dword_216897000, v17, OS_LOG_TYPE_DEFAULT, "#I %s: wds::kErrorTypeMobileIP or wds::kErrorType3GPP received handling those in indications", v49, 0xCu);
        }
      }
      else
      {
        v23 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
        {
          v24 = qmi::asString();
          *(_DWORD *)v49 = 136315394;
          *(_QWORD *)&v49[4] = "handleActivateResponse";
          *(_WORD *)&v49[12] = 2080;
          *(_QWORD *)&v49[14] = v24;
          _os_log_impl(&dword_216897000, v23, OS_LOG_TYPE_DEFAULT, "#I %s: response is an error result code is %s", v49, 0x16u);
        }
        QMIDataContextIPBase::setDataContextIPState(a1, 1u);
        v25 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(a1 + 104));
        *(_QWORD *)v49 = *(_QWORD *)(a1 + 96);
        *(_QWORD *)&v49[8] = v25;
        (*(void (**)(_QWORD, _QWORD, uint64_t, _QWORD, _QWORD, uint64_t, _QWORD))(**(_QWORD **)v49 + 64))(*(_QWORD *)v49, *(unsigned int *)(a1 + 140), 62, 0, 0, 2, 0);
        p_shared_owners = (unint64_t *)&v25->__shared_owners_;
        do
          v27 = __ldaxr(p_shared_owners);
        while (__stlxr(v27 - 1, p_shared_owners));
        if (!v27)
        {
          ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
          std::__shared_weak_count::__release_weak(v25);
        }
        QMIDataContextIPBase::doneWithContext((QMIDataContextIPBase *)a1);
      }
      _Block_object_dispose(&v40, 8);
      _Block_object_dispose(&v44, 8);
      _Block_object_dispose(buf, 8);
      return;
    }
    v6 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = "handleActivateResponse";
      _os_log_impl(&dword_216897000, v6, OS_LOG_TYPE_DEFAULT, "#I %s: Activating the baseband network interface has no effect", buf, 0xCu);
    }
  }
  TlvValue = (capabilities::ct *)qmi::MessageBase::findTlvValue(a2);
  v9 = TlvValue;
  if (TlvValue)
  {
    v10 = v8;
    *(_QWORD *)buf = TlvValue;
    TlvValue = (capabilities::ct *)tlv::parseV<wds::tlv::PktDataHandle>((unint64_t *)buf, v8);
    if (*(_QWORD *)buf)
      *(_DWORD *)(a1 + 180) = (_DWORD)TlvValue;
    else
      TlvValue = (capabilities::ct *)((uint64_t (*)(_QWORD, uint64_t, capabilities::ct *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 1, v9, v10);
  }
  if ((capabilities::ct::supportsDataQMIExtensions(TlvValue) & 1) == 0)
  {
    *(_BYTE *)(a1 + 256) = -1;
    v18 = qmi::MessageBase::findTlvValue(a2);
    v20 = v18;
    if (v18)
    {
      v21 = v19;
      *(_QWORD *)buf = v18;
      v22 = tlv::parseV<wds::tlv::IDataCallAppId>((unint64_t *)buf, v19);
      if (*(_QWORD *)buf)
        *(_BYTE *)(a1 + 256) = v22;
      else
        ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 195, v20, v21);
    }
  }
  v28 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 96))(a1);
  if (v28 <= 6)
  {
    if (((1 << v28) & 0x67) != 0)
    {
      v29 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
        return;
      (*(void (**)(uint64_t))(*(_QWORD *)a1 + 96))(a1);
      v30 = asString();
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "handleActivateResponse";
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = v30;
      v31 = "#I %s: At wrong state %s";
      v32 = v29;
      v33 = 22;
      goto LABEL_34;
    }
    if (v28 == 3)
    {
      v34 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
      {
        v35 = *(_DWORD *)(a1 + 180);
        *(_DWORD *)buf = 136315394;
        *(_QWORD *)&buf[4] = "handleActivateResponse";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v35;
        _os_log_impl(&dword_216897000, v34, OS_LOG_TYPE_DEFAULT, "#I %s: Activated fPacketDataHandle=%d. But we are disconnecting", buf, 0x12u);
      }
      QMIDataContextIPBase::setDataContextIPState(a1, 4u);
      QMIDataContextIPBase::deactivateDataContextIP((QMIDataContextIPBase *)a1, 1, 0);
    }
    else
    {
      v36 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
      {
        v37 = *(_DWORD *)(a1 + 180);
        v38 = *(unsigned __int8 *)(a1 + 256);
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = "handleActivateResponse";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v37;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v38;
        v31 = "#I %s: Activated fPacketDataHandle=%d, fAppId=%d";
        v32 = v36;
        v33 = 24;
LABEL_34:
        _os_log_impl(&dword_216897000, v32, OS_LOG_TYPE_DEFAULT, v31, buf, v33);
      }
    }
  }
}

void sub_216A056C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  uint64_t v8;
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a8);
  va_start(va, a8);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Block_object_dispose((const void *)(v8 - 112), 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZN20QMIDataContextIPBase22handleActivateResponseERKN3wds21StartNetworkIfaceBase8ResponseE_block_invoke(uint64_t result, _WORD *a2)
{
  *(_WORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = *a2;
  return result;
}

uint64_t ___ZN20QMIDataContextIPBase22handleActivateResponseERKN3wds21StartNetworkIfaceBase8ResponseE_block_invoke_2(uint64_t result, _WORD *a2)
{
  *(_WORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = a2[1];
  *(_WORD *)(*(_QWORD *)(*(_QWORD *)(result + 40) + 8) + 24) = *a2;
  return result;
}

uint64_t QMIDataContextIPBase::doneWithContext(QMIDataContextIPBase *this)
{
  NSObject *v2;
  _BOOL8 v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  uint64_t v7;
  __int128 v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v2 = *((_QWORD *)this + 5);
  v3 = os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT);
  if (v3)
  {
    LODWORD(v9) = 136315138;
    *(_QWORD *)((char *)&v9 + 4) = "doneWithContext";
    _os_log_impl(&dword_216897000, v2, OS_LOG_TYPE_DEFAULT, "#I %s: start", (uint8_t *)&v9, 0xCu);
  }
  *((_WORD *)this + 88) = 0;
  *((_DWORD *)this + 45) = -1;
  if ((capabilities::ct::supportsDataQMIExtensions((capabilities::ct *)v3) & 1) == 0)
    *((_BYTE *)this + 256) = -1;
  v4 = std::__shared_weak_count::lock(*((std::__shared_weak_count **)this + 13));
  *(_QWORD *)&v9 = *((_QWORD *)this + 12);
  *((_QWORD *)&v9 + 1) = v4;
  (*(void (**)(_QWORD))(*(_QWORD *)v9 + 128))(v9);
  p_shared_owners = (unint64_t *)&v4->__shared_owners_;
  do
    v6 = __ldaxr(p_shared_owners);
  while (__stlxr(v6 - 1, p_shared_owners));
  if (!v6)
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  v7 = *((_QWORD *)this + 33);
  *((_QWORD *)this + 33) = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  QMIDataContextIPBase::clearIPv6ConfigTimer(this);
  return QMIDataContextIPBase::clearIPv4ConfigTimer(this);
}

void sub_216A0588C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void QMIDataContextIPBase::setQMIChannelState(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  NSObject *v5;
  _BOOL4 v6;
  const char *v7;
  const char *v8;
  const char *v9;
  int v10;
  const char *v11;
  __int16 v12;
  const char *v13;
  __int16 v14;
  const char *v15;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  v4 = *(int *)(a1 + 632);
  v5 = *(NSObject **)(a1 + 40);
  v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if ((_DWORD)v4 == a2)
  {
    if (v6)
    {
      if (a2 > 4)
        v7 = "Unknown QMIContextCommunicationChannelState";
      else
        v7 = off_24D5E02C8[a2];
      v10 = 136315394;
      v11 = "setQMIChannelState";
      v12 = 2080;
      v13 = v7;
      _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#I %s: Keeping the same state: %s", (uint8_t *)&v10, 0x16u);
    }
  }
  else
  {
    if (v6)
    {
      if (v4 > 4)
        v8 = "Unknown QMIContextCommunicationChannelState";
      else
        v8 = off_24D5E02C8[v4];
      if (a2 > 4)
        v9 = "Unknown QMIContextCommunicationChannelState";
      else
        v9 = off_24D5E02C8[a2];
      v10 = 136315650;
      v11 = "setQMIChannelState";
      v12 = 2080;
      v13 = v8;
      v14 = 2080;
      v15 = v9;
      _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#I %s: Changing state from %s to %s", (uint8_t *)&v10, 0x20u);
    }
    *(_DWORD *)(a1 + 632) = a2;
  }
}

void ___ZN20QMIDataContextIPBase12bindDataPortEv_block_invoke(uint64_t a1, _WORD *a2)
{
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;

  v3 = *(_QWORD *)(a1 + 32);
  v4 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v3 + 104));
  *a2 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v3 + 96) + 40))(*(_QWORD *)(v3 + 96));
  p_shared_owners = (unint64_t *)&v4->__shared_owners_;
  do
    v6 = __ldaxr(p_shared_owners);
  while (__stlxr(v6 - 1, p_shared_owners));
  if (!v6)
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
}

void sub_216A05AB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t ___ZN20QMIDataContextIPBase12bindDataPortEv_block_invoke_2(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  NSObject *v5;
  uint64_t v6;
  _DWORD v7[2];
  __int16 v8;
  uint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(result + 32);
  if (!*(_BYTE *)(v2 + 257))
  {
    v3 = result;
    v4 = *(_DWORD *)(a2 + 4);
    v5 = *(NSObject **)(v2 + 40);
    if (v4)
    {
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        v7[0] = 67109378;
        v7[1] = v4;
        v8 = 2080;
        v9 = qmi::asString();
        _os_log_error_impl(&dword_216897000, v5, OS_LOG_TYPE_ERROR, "Error in response to BindDataPort with code = 0x%x (%s)", (uint8_t *)v7, 0x12u);
      }
    }
    else if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v7[0]) = 0;
      _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#I Response to BindDataPort received", (uint8_t *)v7, 2u);
    }
    v6 = *(_QWORD *)(v3 + 64);
    if (!v6)
      std::__throw_bad_function_call[abi:ne180100]();
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 48))(v6);
  }
  return result;
}

void ___ZN20QMIDataContextIPBase12bindDataPortEv_block_invoke_115(uint64_t a1, _BYTE *a2)
{
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;

  v3 = *(_QWORD *)(a1 + 32);
  v4 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v3 + 104));
  *a2 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v3 + 96) + 40))(*(_QWORD *)(v3 + 96)) + 1;
  p_shared_owners = (unint64_t *)&v4->__shared_owners_;
  do
    v6 = __ldaxr(p_shared_owners);
  while (__stlxr(v6 - 1, p_shared_owners));
  if (!v6)
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
}

void sub_216A05C78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t ___ZN20QMIDataContextIPBase12bindDataPortEv_block_invoke_2_118(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  NSObject *v5;
  _BOOL4 v6;
  const char *v7;
  NSObject *v8;
  uint32_t v9;
  uint64_t v10;
  int v11;
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(result + 32);
  if (*(_BYTE *)(v2 + 257))
    return result;
  v3 = result;
  v4 = *(_DWORD *)(a2 + 4);
  v5 = *(NSObject **)(v2 + 40);
  v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (v4)
  {
    if (v6)
    {
      v11 = 136315650;
      v12 = "bindDataPort_block_invoke_2";
      v13 = 1024;
      v14 = v4;
      v15 = 2080;
      v16 = qmi::asString();
      v7 = "#I %s: Error in response to BindMuxDataPort with code = 0x%x (%s)";
      v8 = v5;
      v9 = 28;
LABEL_7:
      _os_log_impl(&dword_216897000, v8, OS_LOG_TYPE_DEFAULT, v7, (uint8_t *)&v11, v9);
    }
  }
  else if (v6)
  {
    v11 = 136315138;
    v12 = "bindDataPort_block_invoke";
    v7 = "#I %s: Response to BindMuxDataPort received";
    v8 = v5;
    v9 = 12;
    goto LABEL_7;
  }
  v10 = *(_QWORD *)(v3 + 64);
  if (!v10)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v10 + 48))(v10);
}

uint64_t ___ZN20QMIDataContextIPBase21bindSubscription_syncENSt3__18functionIFvvEEE_block_invoke(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v7;
  int v8;
  int v9;
  uint64_t v10;
  __int16 v11;
  int v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)(a2 + 4))
  {
    v4 = *(NSObject **)(*(_QWORD *)(a1 + 32) + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v7 = qmi::asString();
      v8 = *(_DWORD *)(a2 + 4);
      v9 = 136315394;
      v10 = v7;
      v11 = 1024;
      v12 = v8;
      _os_log_error_impl(&dword_216897000, v4, OS_LOG_TYPE_ERROR, "Binding subscription: %s (0x%x)", (uint8_t *)&v9, 0x12u);
    }
  }
  v5 = *(_QWORD *)(a1 + 64);
  if (!v5)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 48))(v5);
}

void ___ZN20QMIDataContextIPBase14setupQMIClientEv_block_invoke_129(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  NSObject *v4;
  _BOOL4 v5;
  const char *v6;
  NSObject *v7;
  uint32_t v8;
  const void **v9;
  char *v10;
  _BYTE *v11;
  char *v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  char *v18;
  char *v19;
  char *v20;
  char *v21;
  uint64_t v22;
  const void **v23;
  const void **v24;
  const void **v25;
  char *v26;
  _BYTE *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  char *v34;
  const void **v35;
  char *v36;
  char *v37;
  char *v38;
  const void *v39;
  char *v40;
  _BYTE *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  unint64_t v47;
  char *v48;
  const void **v49;
  char *v50;
  char *v51;
  char *v52;
  const void *v53;
  const void **i;
  char *v55;
  _BYTE *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  _QWORD *v60;
  uint64_t v61;
  unint64_t v62;
  unint64_t v63;
  char *v64;
  uint64_t *v65;
  char *v66;
  char *v67;
  char *v68;
  uint64_t v69;
  void *v70;
  NSObject *v71;
  std::__shared_weak_count *v72;
  char v73;
  unint64_t *p_shared_owners;
  unint64_t v75;
  std::__shared_weak_count *v76;
  unint64_t *v77;
  unint64_t v78;
  NSObject *v79;
  NSObject *v80;
  std::__shared_weak_count *v81;
  unint64_t *v82;
  unint64_t v83;
  NSObject *v84;
  const char *v85;
  NSObject *v86;
  char v87;
  NSObject *v88;
  _BOOL4 v89;
  unint64_t *v90;
  std::__shared_weak_count *v91;
  unint64_t *v92;
  unint64_t v93;
  uint8_t *v94;
  uint64_t v95;
  _QWORD v96[5];
  uint64_t v97;
  uint64_t v98;
  int v99;
  uint64_t v100;
  void *aBlock;
  void *__p[2];
  __int128 v103;
  __int128 v104;
  uint8_t buf[32];
  _QWORD *v106;
  uint64_t v107;

  v107 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)(v2 + 257))
  {
    v3 = *(_DWORD *)(a2 + 4);
    v4 = *(NSObject **)(v2 + 40);
    v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
    if (v3)
    {
      if (!v5)
        goto LABEL_8;
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = "setupQMIClient_block_invoke";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v3;
      *(_WORD *)&buf[18] = 2080;
      *(_QWORD *)&buf[20] = qmi::asString();
      v6 = "#I %s: Error in response to SetClientIpFamilyPref with code = 0x%x (%s)";
      v7 = v4;
      v8 = 28;
    }
    else
    {
      if (!v5)
        goto LABEL_8;
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = "setupQMIClient_block_invoke";
      v6 = "#I %s: Response to SetClientIpFamilyPref received";
      v7 = v4;
      v8 = 12;
    }
    _os_log_impl(&dword_216897000, v7, OS_LOG_TYPE_DEFAULT, v6, buf, v8);
LABEL_8:
    *(_OWORD *)__p = 0u;
    v103 = 0u;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
    v9 = (const void **)__p[1];
    if (__p[1] != (void *)v103)
    {
      while (*((_BYTE *)*v9 + 8) != 18)
      {
        if (++v9 == (const void **)v103)
          goto LABEL_15;
      }
    }
    if (v9 == (const void **)v103)
    {
LABEL_15:
      v10 = (char *)operator new();
      v12 = v10;
      *((_WORD *)v10 + 4) = 18;
      *(_QWORD *)v10 = &off_24D5DF6C8;
      v13 = v103;
      if ((unint64_t)v103 >= *((_QWORD *)&v103 + 1))
      {
        v15 = (uint64_t)(v103 - (unint64_t)__p[1]) >> 3;
        if ((unint64_t)(v15 + 1) >> 61)
          goto LABEL_158;
        v16 = (uint64_t)(*((_QWORD *)&v103 + 1) - (unint64_t)__p[1]) >> 2;
        if (v16 <= v15 + 1)
          v16 = v15 + 1;
        if (*((_QWORD *)&v103 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v17 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v17 = v16;
        if (v17)
          v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v103 + 8, v17);
        else
          v18 = 0;
        v19 = &v18[8 * v15];
        v20 = &v18[8 * v17];
        *(_QWORD *)v19 = v12;
        v14 = v19 + 8;
        v21 = (char *)__p[1];
        v10 = (char *)v103;
        if ((void *)v103 != __p[1])
        {
          do
          {
            v22 = *((_QWORD *)v10 - 1);
            v10 -= 8;
            *((_QWORD *)v19 - 1) = v22;
            v19 -= 8;
          }
          while (v10 != v21);
          v10 = (char *)__p[1];
        }
        __p[1] = v19;
        *(_QWORD *)&v103 = v14;
        *((_QWORD *)&v103 + 1) = v20;
        if (v10)
          operator delete(v10);
      }
      else
      {
        *(_QWORD *)v103 = v10;
        v14 = (_QWORD *)(v13 + 8);
      }
      v11 = v12 + 9;
      *(_QWORD *)&v103 = v14;
    }
    else
    {
      if (!v10)
        goto LABEL_157;
      v11 = v10 + 9;
    }
    *v11 = 1;
    if (!capabilities::ct::supportsThroughputEngineering((capabilities::ct *)v10))
      goto LABEL_107;
    v23 = (const void **)__p[1];
    v24 = (const void **)v103;
    v25 = (const void **)__p[1];
    if (__p[1] != (void *)v103)
    {
      v25 = (const void **)__p[1];
      while (*((_BYTE *)*v25 + 8) != 61)
      {
        if (++v25 == (const void **)v103)
          goto LABEL_41;
      }
    }
    if (v25 == (const void **)v103)
    {
LABEL_41:
      v28 = operator new();
      v29 = v28;
      *(_WORD *)(v28 + 8) = 61;
      *(_QWORD *)v28 = &off_24D5DF718;
      v30 = v103;
      if ((unint64_t)v103 >= *((_QWORD *)&v103 + 1))
      {
        v31 = (uint64_t)(v103 - (unint64_t)__p[1]) >> 3;
        if ((unint64_t)(v31 + 1) >> 61)
          goto LABEL_158;
        v32 = (uint64_t)(*((_QWORD *)&v103 + 1) - (unint64_t)__p[1]) >> 2;
        if (v32 <= v31 + 1)
          v32 = v31 + 1;
        if (*((_QWORD *)&v103 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v33 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v33 = v32;
        if (v33)
          v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v103 + 8, v33);
        else
          v34 = 0;
        v35 = (const void **)&v34[8 * v31];
        v36 = &v34[8 * v33];
        *v35 = (const void *)v29;
        v24 = v35 + 1;
        v38 = (char *)__p[1];
        v37 = (char *)v103;
        if ((void *)v103 != __p[1])
        {
          do
          {
            v39 = (const void *)*((_QWORD *)v37 - 1);
            v37 -= 8;
            *--v35 = v39;
          }
          while (v37 != v38);
          v37 = (char *)__p[1];
        }
        __p[1] = v35;
        *(_QWORD *)&v103 = v24;
        *((_QWORD *)&v103 + 1) = v36;
        if (v37)
          operator delete(v37);
      }
      else
      {
        *(_QWORD *)v103 = v28;
        v24 = (const void **)(v30 + 8);
      }
      v27 = (_BYTE *)(v29 + 9);
      *(_QWORD *)&v103 = v24;
      v23 = (const void **)__p[1];
    }
    else
    {
      if (!v26)
        goto LABEL_157;
      v27 = v26 + 9;
    }
    *v27 = 1;
    while (1)
    {
      if (v23 == v24)
        goto LABEL_65;
      if (*((_BYTE *)*v23 + 8) == 62)
        break;
      ++v23;
    }
    if (v23 == v24)
    {
LABEL_65:
      v42 = operator new();
      v43 = v42;
      *(_WORD *)(v42 + 8) = 62;
      *(_QWORD *)v42 = &off_24D5DF768;
      v44 = v103;
      if ((unint64_t)v103 >= *((_QWORD *)&v103 + 1))
      {
        v45 = (uint64_t)(v103 - (unint64_t)__p[1]) >> 3;
        if ((unint64_t)(v45 + 1) >> 61)
          goto LABEL_158;
        v46 = (uint64_t)(*((_QWORD *)&v103 + 1) - (unint64_t)__p[1]) >> 2;
        if (v46 <= v45 + 1)
          v46 = v45 + 1;
        if (*((_QWORD *)&v103 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v47 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v47 = v46;
        if (v47)
          v48 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v103 + 8, v47);
        else
          v48 = 0;
        v49 = (const void **)&v48[8 * v45];
        v50 = &v48[8 * v47];
        *v49 = (const void *)v43;
        v24 = v49 + 1;
        v52 = (char *)__p[1];
        v51 = (char *)v103;
        if ((void *)v103 != __p[1])
        {
          do
          {
            v53 = (const void *)*((_QWORD *)v51 - 1);
            v51 -= 8;
            *--v49 = v53;
          }
          while (v51 != v52);
          v51 = (char *)__p[1];
        }
        __p[1] = v49;
        *(_QWORD *)&v103 = v24;
        *((_QWORD *)&v103 + 1) = v50;
        if (v51)
          operator delete(v51);
      }
      else
      {
        *(_QWORD *)v103 = v42;
        v24 = (const void **)(v44 + 8);
      }
      v41 = (_BYTE *)(v43 + 9);
      *(_QWORD *)&v103 = v24;
    }
    else
    {
      if (!v40)
        goto LABEL_157;
      v41 = v40 + 9;
    }
    *v41 = 1;
    for (i = (const void **)__p[1]; ; ++i)
    {
      if (i == v24)
        goto LABEL_89;
      if (*((_BYTE *)*i + 8) == 44)
        break;
    }
    if (i != v24)
    {
      if (v55)
      {
        v56 = v55 + 9;
LABEL_106:
        *v56 = 1;
LABEL_107:
        QMIDataContextIPBase::setQMIChannelState(v2, 2u);
        v97 = v2 + 144;
        v98 = QMIServiceMsg::create();
        v99 = 25000;
        v100 = 0;
        aBlock = 0;
        v96[0] = MEMORY[0x24BDAC760];
        v96[1] = 0x40000000;
        v96[2] = ___ZN20QMIDataContextIPBase22registerQMIIndicationsEv_block_invoke_5;
        v96[3] = &__block_descriptor_tmp_144_0;
        v96[4] = v2;
        *(_QWORD *)buf = MEMORY[0x24BDAC760];
        *(_QWORD *)&buf[8] = 0x40000000;
        *(_QWORD *)&buf[16] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3wds18IndicationRegister8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke_0;
        *(_QWORD *)&buf[24] = &unk_24D5DF7E8;
        v106 = v96;
        v70 = _Block_copy(buf);
        aBlock = v70;
        if (v98)
        {
          qmi::Client::send();
          v70 = aBlock;
        }
        if (v70)
          _Block_release(v70);
        (*(void (**)(uint64_t))(*(_QWORD *)v2 + 352))(v2);
        QMIDataContextIPBase::setQMIChannelState(v2, 4u);
        if (!*(_BYTE *)(v2 + 637))
          goto LABEL_155;
        v71 = *(NSObject **)(v2 + 40);
        if (os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315138;
          *(_QWORD *)&buf[4] = "registerQMIIndications";
          _os_log_impl(&dword_216897000, v71, OS_LOG_TYPE_DEFAULT, "#I %s: PendingChannelInitialization: found one", buf, 0xCu);
        }
        memset(buf, 0, sizeof(buf));
        std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100]((uint64_t)buf, v2 + 640);
        *(_BYTE *)(v2 + 637) = 0;
        std::function<BOOL ()(void)>::operator=((_QWORD *)(v2 + 640), v2 + 48);
        v72 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v2 + 104));
        v97 = *(_QWORD *)(v2 + 96);
        v98 = (uint64_t)v72;
        v73 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v97 + 184))(v97);
        p_shared_owners = (unint64_t *)&v72->__shared_owners_;
        do
          v75 = __ldaxr(p_shared_owners);
        while (__stlxr(v75 - 1, p_shared_owners));
        if (!v75)
        {
          ((void (*)(std::__shared_weak_count *))v72->__on_zero_shared)(v72);
          std::__shared_weak_count::__release_weak(v72);
        }
        v97 = 0;
        v98 = 0;
        v76 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v2 + 104));
        *(_QWORD *)&v104 = *(_QWORD *)(v2 + 96);
        *((_QWORD *)&v104 + 1) = v76;
        (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v104 + 240))(&v97);
        v77 = (unint64_t *)&v76->__shared_owners_;
        do
          v78 = __ldaxr(v77);
        while (__stlxr(v78 - 1, v77));
        if (!v78)
        {
          ((void (*)(std::__shared_weak_count *))v76->__on_zero_shared)(v76);
          std::__shared_weak_count::__release_weak(v76);
        }
        if (v97)
        {
          if (*(_BYTE *)(v2 + 638))
          {
            *(_BYTE *)(v2 + 638) = 0;
            v79 = *(NSObject **)(v2 + 40);
            if (os_log_type_enabled(v79, OS_LOG_TYPE_DEFAULT))
            {
              LODWORD(v104) = 136315138;
              *(_QWORD *)((char *)&v104 + 4) = "registerQMIIndications";
              _os_log_impl(&dword_216897000, v79, OS_LOG_TYPE_DEFAULT, "#I %s: PendingChannelInitialization: Context has been deactivated during init.", (uint8_t *)&v104, 0xCu);
            }
            if ((v73 & 1) != 0)
            {
LABEL_145:
              v91 = (std::__shared_weak_count *)v98;
              if (v98)
              {
                v92 = (unint64_t *)(v98 + 8);
                do
                  v93 = __ldaxr(v92);
                while (__stlxr(v93 - 1, v92));
                if (!v93)
                {
                  ((void (*)(std::__shared_weak_count *))v91->__on_zero_shared)(v91);
                  std::__shared_weak_count::__release_weak(v91);
                }
              }
              v94 = *(uint8_t **)&buf[24];
              if (*(uint8_t **)&buf[24] == buf)
              {
                v95 = 4;
                v94 = buf;
              }
              else
              {
                if (!*(_QWORD *)&buf[24])
                {
LABEL_155:
                  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
                  return;
                }
                v95 = 5;
              }
              (*(void (**)(void))(*(_QWORD *)v94 + 8 * v95))();
              goto LABEL_155;
            }
            v80 = *(NSObject **)(v2 + 40);
            if (os_log_type_enabled(v80, OS_LOG_TYPE_DEFAULT))
            {
              LODWORD(v104) = 136315138;
              *(_QWORD *)((char *)&v104 + 4) = "registerQMIIndications";
              _os_log_impl(&dword_216897000, v80, OS_LOG_TYPE_DEFAULT, "#I %s: PendingChannelInitialization: report error with retry", (uint8_t *)&v104, 0xCu);
            }
            QMIDataContextIPBase::setDataContextIPState(v2, 1u);
            v81 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v2 + 104));
            *(_QWORD *)&v104 = *(_QWORD *)(v2 + 96);
            *((_QWORD *)&v104 + 1) = v81;
            (*(void (**)(_QWORD, _QWORD, uint64_t, _QWORD, _QWORD, uint64_t, uint64_t))(*(_QWORD *)v104 + 64))(v104, *(unsigned int *)(v2 + 140), 1, 0, 0, 2, 1);
            v82 = (unint64_t *)&v81->__shared_owners_;
            do
              v83 = __ldaxr(v82);
            while (__stlxr(v83 - 1, v82));
LABEL_143:
            if (!v83)
            {
              ((void (*)(std::__shared_weak_count *))v81->__on_zero_shared)(v81);
              std::__shared_weak_count::__release_weak(v81);
            }
            goto LABEL_145;
          }
          if (!*(_QWORD *)&buf[24])
            std::__throw_bad_function_call[abi:ne180100]();
          v87 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)&buf[24] + 48))(*(_QWORD *)&buf[24]);
          v88 = *(NSObject **)(v2 + 40);
          v89 = os_log_type_enabled(v88, OS_LOG_TYPE_DEFAULT);
          if ((v87 & 1) == 0)
          {
            if (v89)
            {
              LODWORD(v104) = 136315138;
              *(_QWORD *)((char *)&v104 + 4) = "registerQMIIndications";
              _os_log_impl(&dword_216897000, v88, OS_LOG_TYPE_DEFAULT, "#I %s: PendingChannelInitialization: failed", (uint8_t *)&v104, 0xCu);
            }
            QMIDataContextIPBase::setDataContextIPState(v2, 1u);
            v81 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v2 + 104));
            *(_QWORD *)&v104 = *(_QWORD *)(v2 + 96);
            *((_QWORD *)&v104 + 1) = v81;
            (*(void (**)(_QWORD, _QWORD, uint64_t, _QWORD, _QWORD, uint64_t, _QWORD))(*(_QWORD *)v104 + 64))(v104, *(unsigned int *)(v2 + 140), 18, 0, 0, 2, 0);
            v90 = (unint64_t *)&v81->__shared_owners_;
            do
              v83 = __ldaxr(v90);
            while (__stlxr(v83 - 1, v90));
            goto LABEL_143;
          }
          if (!v89)
            goto LABEL_145;
          LODWORD(v104) = 136315138;
          *(_QWORD *)((char *)&v104 + 4) = "registerQMIIndications";
          v85 = "#I %s: PendingChannelInitialization: success";
          v86 = v88;
        }
        else
        {
          *(_BYTE *)(v2 + 638) = 0;
          v84 = *(NSObject **)(v2 + 40);
          if (!os_log_type_enabled(v84, OS_LOG_TYPE_DEFAULT))
            goto LABEL_145;
          LODWORD(v104) = 136315138;
          *(_QWORD *)((char *)&v104 + 4) = "registerQMIIndications";
          v85 = "#I %s: PendingChannelInitialization: not continuing abandoned pending activation (1)";
          v86 = v84;
        }
        _os_log_impl(&dword_216897000, v86, OS_LOG_TYPE_DEFAULT, v85, (uint8_t *)&v104, 0xCu);
        goto LABEL_145;
      }
LABEL_157:
      __cxa_bad_cast();
    }
LABEL_89:
    v57 = operator new();
    v58 = v57;
    *(_WORD *)(v57 + 8) = 44;
    *(_QWORD *)v57 = &off_24D5DF7B8;
    v59 = v103;
    if ((unint64_t)v103 < *((_QWORD *)&v103 + 1))
    {
      *(_QWORD *)v103 = v57;
      v60 = (_QWORD *)(v59 + 8);
LABEL_105:
      v56 = (_BYTE *)(v58 + 9);
      *(_QWORD *)&v103 = v60;
      goto LABEL_106;
    }
    v61 = (uint64_t)(v103 - (unint64_t)__p[1]) >> 3;
    if (!((unint64_t)(v61 + 1) >> 61))
    {
      v62 = (uint64_t)(*((_QWORD *)&v103 + 1) - (unint64_t)__p[1]) >> 2;
      if (v62 <= v61 + 1)
        v62 = v61 + 1;
      if (*((_QWORD *)&v103 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v63 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v63 = v62;
      if (v63)
        v64 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v103 + 8, v63);
      else
        v64 = 0;
      v65 = (uint64_t *)&v64[8 * v61];
      v66 = &v64[8 * v63];
      *v65 = v58;
      v60 = v65 + 1;
      v68 = (char *)__p[1];
      v67 = (char *)v103;
      if ((void *)v103 != __p[1])
      {
        do
        {
          v69 = *((_QWORD *)v67 - 1);
          v67 -= 8;
          *--v65 = v69;
        }
        while (v67 != v68);
        v67 = (char *)__p[1];
      }
      __p[1] = v65;
      *(_QWORD *)&v103 = v60;
      *((_QWORD *)&v103 + 1) = v66;
      if (v67)
        operator delete(v67);
      goto LABEL_105;
    }
LABEL_158:
    std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
  }
}

void sub_216A069DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  uint64_t v6;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  va_list va1;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  va_list va2;

  va_start(va2, a6);
  va_start(va1, a6);
  va_start(va, a6);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v16 = va_arg(va2, _QWORD);
  v18 = va_arg(va2, _QWORD);
  v19 = va_arg(va2, _QWORD);
  v20 = va_arg(va2, _QWORD);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va2);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va);
  v8 = *(_QWORD **)(v6 - 72);
  if (v8 == (_QWORD *)(v6 - 96))
  {
    v9 = 4;
    v8 = (_QWORD *)(v6 - 96);
  }
  else
  {
    if (!v8)
      goto LABEL_6;
    v9 = 5;
  }
  (*(void (**)(void))(*v8 + 8 * v9))();
LABEL_6:
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va1);
  _Unwind_Resume(a1);
}

void ___ZN20QMIDataContextIPBase22registerQMIIndicationsEv_block_invoke_5(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  NSObject *v4;
  _BOOL4 v5;
  const char *v6;
  NSObject *v7;
  uint32_t v8;
  int v9;
  const char *v10;
  __int16 v11;
  int v12;
  __int16 v13;
  uint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)(v2 + 257))
  {
    v3 = *(_DWORD *)(a2 + 4);
    v4 = *(NSObject **)(v2 + 40);
    v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
    if (v3)
    {
      if (!v5)
        return;
      v9 = 136315650;
      v10 = "registerQMIIndications_block_invoke_5";
      v11 = 1024;
      v12 = v3;
      v13 = 2080;
      v14 = qmi::asString();
      v6 = "#I %s: Error registering for WDS indications: %d(%s)";
      v7 = v4;
      v8 = 28;
    }
    else
    {
      if (!v5)
        return;
      v9 = 136315138;
      v10 = "registerQMIIndications_block_invoke";
      v6 = "#I %s: Response to IndicationRegister received";
      v7 = v4;
      v8 = 12;
    }
    _os_log_impl(&dword_216897000, v7, OS_LOG_TYPE_DEFAULT, v6, (uint8_t *)&v9, v8);
  }
}

void QMIDataContextIPBase::handleQmiClientStarted(std::__shared_weak_count **this)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  _BOOL8 v8;
  std::__shared_weak_count *v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  std::__shared_weak_count *v16;

  v2 = std::__shared_weak_count::lock(this[13]);
  ((void (*)(std::__shared_weak_count *, _QWORD, _QWORD, uint64_t))this[12]->__vftable[6].__on_zero_shared)(this[12], *((unsigned int *)this + 35), 0, 1);
  p_shared_owners = (unint64_t *)&v2->__shared_owners_;
  do
    v4 = __ldaxr(p_shared_owners);
  while (__stlxr(v4 - 1, p_shared_owners));
  if (!v4)
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  v5 = this[16];
  if (v5)
  {
    v6 = std::__shared_weak_count::lock(v5);
    v16 = v6;
    if (v6)
    {
      v7 = this[15];
      if (!v7)
      {
        v9 = v6;
LABEL_17:
        v14 = (unint64_t *)&v9->__shared_owners_;
        do
          v15 = __ldaxr(v14);
        while (__stlxr(v15 - 1, v14));
        if (!v15)
        {
          ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
          std::__shared_weak_count::__release_weak(v9);
        }
        return;
      }
      if (*((_BYTE *)this + 112))
        v8 = *((_DWORD *)this + 35) == 1;
      else
        v8 = 0;
      v10 = std::__shared_weak_count::lock(this[13]);
      v11 = ((uint64_t (*)(std::__shared_weak_count *))this[12]->__vftable[1].~__shared_weak_count)(this[12]);
      ((void (*)(std::__shared_weak_count *, _BOOL8, char *, uint64_t, _QWORD))v7->__vftable[1].~__shared_weak_count)(v7, v8, (char *)this + 144, v11, *((unsigned int *)this + 35));
      v12 = (unint64_t *)&v10->__shared_owners_;
      do
        v13 = __ldaxr(v12);
      while (__stlxr(v13 - 1, v12));
      if (!v13)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
      v9 = v16;
      if (v16)
        goto LABEL_17;
    }
  }
}

void sub_216A06D30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

void QMIDataContextIPBase::handleBasebandOff_sync(QMIDataContextIPBase *this)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  uint64_t v4;
  _BOOL8 v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  std::__shared_weak_count *v13;

  v2 = (std::__shared_weak_count *)*((_QWORD *)this + 16);
  if (v2)
  {
    v3 = std::__shared_weak_count::lock(v2);
    v13 = v3;
    if (v3)
    {
      v4 = *((_QWORD *)this + 15);
      if (!v4)
      {
        v6 = v3;
LABEL_13:
        p_shared_owners = (unint64_t *)&v6->__shared_owners_;
        do
          v12 = __ldaxr(p_shared_owners);
        while (__stlxr(v12 - 1, p_shared_owners));
        if (!v12)
        {
          ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
          std::__shared_weak_count::__release_weak(v6);
        }
        return;
      }
      if (*((_BYTE *)this + 112))
        v5 = *((_DWORD *)this + 35) == 1;
      else
        v5 = 0;
      v7 = std::__shared_weak_count::lock(*((std::__shared_weak_count **)this + 13));
      v8 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 12) + 40))(*((_QWORD *)this + 12));
      (*(void (**)(uint64_t, _BOOL8, char *, uint64_t, _QWORD))(*(_QWORD *)v4 + 48))(v4, v5, (char *)this + 144, v8, *((unsigned int *)this + 35));
      v9 = (unint64_t *)&v7->__shared_owners_;
      do
        v10 = __ldaxr(v9);
      while (__stlxr(v10 - 1, v9));
      if (!v10)
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
      v6 = v13;
      if (v13)
        goto LABEL_13;
    }
  }
}

void sub_216A06E84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

uint64_t ___ZN20QMIDataContextIPBase27handleWdsPacketSvcStatusIndERKN3wds13PktSrvcStatus10IndicationE_block_invoke(uint64_t result, _BYTE *a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = *a2;
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 40) + 8) + 24) = a2[1];
  return result;
}

uint64_t ___ZN20QMIDataContextIPBase27handleWdsPacketSvcStatusIndERKN3wds13PktSrvcStatus10IndicationE_block_invoke_149(uint64_t result, _WORD *a2)
{
  *(_WORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = *a2;
  return result;
}

uint64_t ___ZN20QMIDataContextIPBase27handleWdsPacketSvcStatusIndERKN3wds13PktSrvcStatus10IndicationE_block_invoke_2(uint64_t result, _WORD *a2)
{
  *(_WORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = a2[1];
  *(_WORD *)(*(_QWORD *)(*(_QWORD *)(result + 40) + 8) + 24) = *a2;
  return result;
}

uint64_t ___ZN20QMIDataContextIPBase27handleWdsPacketSvcStatusIndERKN3wds13PktSrvcStatus10IndicationE_block_invoke_153(uint64_t a1, const unsigned __int8 *a2)
{
  CSIPacketAddress *v2;

  v2 = (CSIPacketAddress *)(*(_QWORD *)(a1 + 32) + 184);
  CSIPacketAddress::setIPv6Address(v2, a2);
  return CSIPacketAddress::setPrefixLen(v2);
}

void ___ZN20QMIDataContextIPBase27handleWdsPacketSvcStatusIndERKN3wds13PktSrvcStatus10IndicationE_block_invoke_2_159(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v2;
  NSObject *v4;
  int v5;
  NSObject *v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  __int128 *v11;
  uint64_t TlvValue;
  int v13;
  std::__shared_weak_count *v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  unsigned int v17;
  NSObject *v18;
  uint64_t v19;
  NSObject *v20;
  std::__shared_weak_count *v21;
  capabilities::ipc *v22;
  unint64_t *v23;
  unint64_t v24;
  capabilities::ct *v25;
  int v26;
  _OWORD *v27;
  int v28;
  _OWORD *v29;
  int v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  int v34;
  _OWORD *v35;
  int v36;
  _OWORD *v37;
  int v38;
  uint64_t v39;
  int v40;
  uint64_t v41;
  int v42;
  uint64_t v43;
  int v44;
  uint64_t v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  uint64_t v50;
  int v51;
  uint64_t v52;
  std::__shared_weak_count *v53;
  unint64_t *v54;
  unint64_t v55;
  capabilities::ct *v56;
  std::__shared_weak_count *v57;
  unint64_t *v58;
  unint64_t v59;
  std::__shared_weak_count *v60;
  unint64_t *v61;
  unint64_t v62;
  unsigned __int16 v63;
  NSObject *v64;
  _BOOL4 v65;
  const char *v66;
  std::__shared_weak_count *v67;
  unint64_t *v68;
  unint64_t v69;
  std::__shared_weak_count *v70;
  unsigned int v71;
  unint64_t *v72;
  unint64_t v73;
  NSObject *v74;
  std::__shared_weak_count *v75;
  unint64_t *v76;
  unint64_t v77;
  std::__shared_weak_count *v78;
  unint64_t *v79;
  unint64_t v80;
  _QWORD *v81;
  uint64_t v82;
  _QWORD v83[2];
  uint64_t (*v84)(uint64_t, __int128 *);
  void *v85;
  uint64_t *v86;
  uint64_t v87;
  uint64_t *v88;
  uint64_t v89;
  int v90;
  uint64_t *v91;
  unint64_t v92[3];
  __int128 *v93;
  uint64_t v94;
  void (*v95)(__int128 **, uint64_t *);
  void *v96;
  uint64_t v97;
  _QWORD v98[3];
  uint64_t v99;
  std::__shared_weak_count *v100;
  uint64_t v101;
  uint64_t v102;
  void (*v103)(uint64_t, unsigned __int8 *);
  void *v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t (*v108)(uint64_t, const unsigned __int8 *);
  void *v109;
  uint64_t v110;
  __int128 v111;
  void (*v112)(__int128 *, uint64_t *);
  void *v113;
  uint64_t v114;
  _BYTE buf[32];
  uint64_t v116;
  uint64_t v117;

  v117 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 32);
  if (*(_BYTE *)(v2 + 257))
    return;
  v4 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315138;
    *(_QWORD *)&buf[4] = "handleSettingsResponse";
    _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I %s: start", buf, 0xCu);
  }
  v5 = *((_DWORD *)a2 + 1);
  if (!v5)
  {
    v11 = (__int128 *)MEMORY[0x24BDAC760];
    *(_QWORD *)buf = MEMORY[0x24BDAC760];
    *(_QWORD *)&buf[8] = 0x40000000;
    *(_QWORD *)&buf[16] = ___ZN20QMIDataContextIPBase17handlePcoResponseERKN3wds18GetRuntimeSettings8ResponseE_block_invoke;
    *(_QWORD *)&buf[24] = &__block_descriptor_tmp_174;
    v116 = v2;
    *(_QWORD *)&v111 = buf;
    qmi::MessageBase::tryTlv<wds::tlv::OperatorReservedProtocolInformation,void({block_pointer})(wds::tlv::OperatorReservedProtocolInformation const&)>(a2, (uint64_t)&v111);
    v87 = 0;
    v88 = &v87;
    v89 = 0x2000000000;
    v90 = 0;
    v83[0] = v11;
    v83[1] = 0x40000000;
    v84 = (uint64_t (*)(uint64_t, __int128 *))___ZN20QMIDataContextIPBase22handleSettingsResponseERKN3wds18GetRuntimeSettings8ResponseE_block_invoke;
    v85 = &unk_24D5DEC78;
    v86 = &v87;
    TlvValue = qmi::MessageBase::findTlvValue(a2);
    if (TlvValue)
    {
      *(_QWORD *)buf = TlvValue;
      LODWORD(v111) = tlv::parseV<wds::tlv::MTU>((unint64_t *)buf, v13);
      if (*(_QWORD *)buf)
        v84((uint64_t)v83, &v111);
    }
    v14 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v2 + 104));
    (*(void (**)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)(v2 + 96) + 160))(*(_QWORD *)(v2 + 96), *(unsigned int *)(v2 + 140), *((unsigned int *)v88 + 6));
    p_shared_owners = (unint64_t *)&v14->__shared_owners_;
    do
      v16 = __ldaxr(p_shared_owners);
    while (__stlxr(v16 - 1, p_shared_owners));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
    v17 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 96))(v2);
    if (v17 > 6)
      goto LABEL_116;
    if (v17 != 4)
    {
      v18 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        (*(void (**)(uint64_t))(*(_QWORD *)v2 + 96))(v2);
        v19 = asString();
        *(_DWORD *)buf = 136315394;
        *(_QWORD *)&buf[4] = "handleSettingsResponse";
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = v19;
        _os_log_impl(&dword_216897000, v18, OS_LOG_TYPE_DEFAULT, "#I %s: ERR: at wrong state %s", buf, 0x16u);
      }
      goto LABEL_116;
    }
    v20 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = "parseSettingsResponse";
      _os_log_impl(&dword_216897000, v20, OS_LOG_TYPE_DEFAULT, "#I %s: start", buf, 0xCu);
    }
    v99 = 0;
    v100 = 0;
    v21 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v2 + 104));
    v22 = (capabilities::ipc *)(*(_QWORD *(**)(uint64_t *__return_ptr))(**(_QWORD **)(v2 + 96) + 240))(&v99);
    v23 = (unint64_t *)&v21->__shared_owners_;
    do
      v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
    if (v99)
    {
      memset(v98, 0, sizeof(v98));
      CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)v98, (const CSIPacketAddress *)(v2 + 184));
      v26 = *(_DWORD *)(v2 + 140);
      if (v26 == 1)
      {
        *(_QWORD *)buf = v11;
        *(_QWORD *)&buf[8] = 0x40000000;
        *(_QWORD *)&buf[16] = ___ZN20QMIDataContextIPBase21parseSettingsResponseERKN3wds18GetRuntimeSettings8ResponseE_block_invoke;
        *(_QWORD *)&buf[24] = &__block_descriptor_tmp_175_1;
        v116 = v2;
        v31 = qmi::MessageBase::findTlvValue(a2);
        v33 = v31;
        if (v31)
        {
          v34 = v32;
          *(_QWORD *)&v111 = v31;
          LODWORD(v93) = tlv::parseV<wds::tlv::IPv4>((unint64_t *)&v111, v32);
          if ((_QWORD)v111)
            (*(void (**)(_BYTE *, __int128 **))&buf[16])(buf, &v93);
          else
            ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 30, v33, v34);
        }
        *(_QWORD *)&v111 = v11;
        *((_QWORD *)&v111 + 1) = 0x40000000;
        v112 = (void (*)(__int128 *, uint64_t *))___ZN20QMIDataContextIPBase21parseSettingsResponseERKN3wds18GetRuntimeSettings8ResponseE_block_invoke_2;
        v113 = &__block_descriptor_tmp_176_0;
        v114 = v2;
        v35 = (_OWORD *)qmi::MessageBase::findTlvValue(a2);
        v37 = v35;
        if (v35)
        {
          v38 = v36;
          v93 = v35;
          LODWORD(v106) = tlv::parseV<wds::tlv::PrimaryDNSIPv4>((unint64_t *)&v93, v36);
          if (v93)
            v112(&v111, &v106);
          else
            ((void (*)(_QWORD, uint64_t, _OWORD *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 21, v37, v38);
        }
        v93 = v11;
        v94 = 0x40000000;
        v95 = (void (*)(__int128 **, uint64_t *))___ZN20QMIDataContextIPBase21parseSettingsResponseERKN3wds18GetRuntimeSettings8ResponseE_block_invoke_3;
        v96 = &__block_descriptor_tmp_177;
        v97 = v2;
        v39 = qmi::MessageBase::findTlvValue(a2);
        v41 = v39;
        if (v39)
        {
          v42 = v40;
          v106 = v39;
          LODWORD(v101) = tlv::parseV<wds::tlv::SecondaryDNSIPv4>((unint64_t *)&v106, v40);
          if (v106)
            ___ZN20QMIDataContextIPBase21parseSettingsResponseERKN3wds18GetRuntimeSettings8ResponseE_block_invoke_3((uint64_t)&v93);
          else
            ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 22, v41, v42);
        }
      }
      else if (v26 == 2)
      {
        if (capabilities::ct::supportsDataQMIExtensions(v25))
        {
          *(_QWORD *)buf = v11;
          *(_QWORD *)&buf[8] = 0x40000000;
          *(_QWORD *)&buf[16] = ___ZN20QMIDataContextIPBase21parseSettingsResponseERKN3wds18GetRuntimeSettings8ResponseE_block_invoke_4;
          *(_QWORD *)&buf[24] = &__block_descriptor_tmp_178_1;
          v116 = v2;
          v27 = (_OWORD *)qmi::MessageBase::findTlvValue(a2);
          v29 = v27;
          if (v27)
          {
            v30 = v28;
            v93 = v27;
            v111 = 0uLL;
            LOBYTE(v112) = 0;
            tlv::parseV<wds::tlv::IPv6>((unint64_t *)&v93, v28, (uint64_t)&v111);
            if (v93)
              (*(void (**)(_BYTE *, __int128 *))&buf[16])(buf, &v111);
            else
              ((void (*)(_QWORD, uint64_t, _OWORD *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 37, v29, v30);
          }
        }
        *(_QWORD *)&v111 = v11;
        *((_QWORD *)&v111 + 1) = 0x40000000;
        v112 = (void (*)(__int128 *, uint64_t *))___ZN20QMIDataContextIPBase21parseSettingsResponseERKN3wds18GetRuntimeSettings8ResponseE_block_invoke_5;
        v113 = &__block_descriptor_tmp_179;
        v114 = v2;
        v93 = &v111;
        qmi::MessageBase::applyTlv<wds::tlv::CarrierIPv6,void({block_pointer})(wds::tlv::CarrierIPv6 const&)>(a2, (uint64_t)&v93);
        v93 = v11;
        v94 = 0x40000000;
        v95 = (void (*)(__int128 **, uint64_t *))___ZN20QMIDataContextIPBase21parseSettingsResponseERKN3wds18GetRuntimeSettings8ResponseE_block_invoke_6;
        v96 = &__block_descriptor_tmp_180_1;
        v97 = v2;
        v43 = qmi::MessageBase::findTlvValue(a2);
        v45 = v43;
        if (v43)
        {
          v46 = v44;
          v101 = v43;
          v106 = tlv::parseV<wds::tlv::PrimaryDNSIPv6>((unint64_t *)&v101, v44);
          v107 = v47;
          if (v101)
            v95(&v93, &v106);
          else
            ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 39, v45, v46);
        }
        v106 = (uint64_t)v11;
        v107 = 0x40000000;
        v108 = ___ZN20QMIDataContextIPBase21parseSettingsResponseERKN3wds18GetRuntimeSettings8ResponseE_block_invoke_7;
        v109 = &__block_descriptor_tmp_181_0;
        v110 = v2;
        v48 = qmi::MessageBase::findTlvValue(a2);
        v50 = v48;
        if (v48)
        {
          v51 = v49;
          v92[0] = v48;
          v101 = tlv::parseV<wds::tlv::SecondaryDNSIPv6>(v92, v49);
          v102 = v52;
          if (v92[0])
            ___ZN20QMIDataContextIPBase21parseSettingsResponseERKN3wds18GetRuntimeSettings8ResponseE_block_invoke_7((uint64_t)&v106, (const unsigned __int8 *)&v101);
          else
            ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 40, v50, v51);
        }
      }
      else
      {
        if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315650;
          *(_QWORD *)&buf[4] = "wrong ip family";
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "/Library/Caches/com.apple.xbs/Sources/CoreTelephony/CommCenter/CommCenterCommandDrivers/"
                                "Data/QMI/Context/QMIDataContextIPBase.cpp";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 2081;
          _os_log_error_impl(&dword_216897000, MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR, "\n**********\n   ASSERT false\n %s\n at %s:%d\n**********", buf, 0x1Cu);
        }
        __TUAssertTrigger();
      }
      memset(v92, 0, sizeof(v92));
      CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)v92, (const CSIPacketAddress *)(v2 + 184));
      if (*(_DWORD *)(v2 + 140) == 1 && (CSIPacketAddress::operator==() & 1) == 0)
      {
        v53 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v2 + 104));
        (*(void (**)(_QWORD))(**(_QWORD **)(v2 + 96) + 232))(*(_QWORD *)(v2 + 96));
        v54 = (unint64_t *)&v53->__shared_owners_;
        do
          v55 = __ldaxr(v54);
        while (__stlxr(v55 - 1, v54));
        if (!v55)
        {
          ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
          std::__shared_weak_count::__release_weak(v53);
        }
      }
      v56 = (capabilities::ct *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v99 + 56))(v99, 0);
      if ((_DWORD)v56)
      {
        v22 = (capabilities::ipc *)QMIDataContextIPBase::parseImsSettingsFromResponse((_QWORD *)v2, a2);
      }
      else
      {
        v22 = (capabilities::ipc *)capabilities::ct::supports5G(v56);
        if ((_DWORD)v22)
        {
          v22 = (capabilities::ipc *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v99 + 192))(v99);
          if ((_DWORD)v22)
          {
            v101 = (uint64_t)v11;
            v102 = 0x40000000;
            v103 = ___ZN20QMIDataContextIPBase21parseSettingsResponseERKN3wds18GetRuntimeSettings8ResponseE_block_invoke_183;
            v104 = &__block_descriptor_tmp_184_0;
            v105 = v2;
            v91 = &v101;
            v22 = (capabilities::ipc *)qmi::MessageBase::applyTlv<wds::tlv::SnssaiPdnInfo,void({block_pointer})(wds::tlv::SnssaiPdnInfo const&)>(a2, (uint64_t)&v91);
          }
        }
      }
    }
    v57 = v100;
    if (v100)
    {
      v58 = (unint64_t *)&v100->__shared_owners_;
      do
        v59 = __ldaxr(v58);
      while (__stlxr(v59 - 1, v58));
      if (!v59)
      {
        ((void (*)(std::__shared_weak_count *))v57->__on_zero_shared)(v57);
        std::__shared_weak_count::__release_weak(v57);
      }
    }
    if (!capabilities::ipc::supportsCoalescing(v22))
    {
LABEL_96:
      QMIDataContextIPBase::setDataContextIPState(v2, 6u);
      v70 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v2 + 104));
      v71 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v2 + 96) + 224))(*(_QWORD *)(v2 + 96));
      v72 = (unint64_t *)&v70->__shared_owners_;
      do
        v73 = __ldaxr(v72);
      while (__stlxr(v73 - 1, v72));
      if (!v73)
      {
        ((void (*)(std::__shared_weak_count *))v70->__on_zero_shared)(v70);
        std::__shared_weak_count::__release_weak(v70);
      }
      if (v71)
      {
        v74 = *(NSObject **)(v2 + 40);
        if (os_log_type_enabled(v74, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315138;
          *(_QWORD *)&buf[4] = "handleSettingsResponse";
          _os_log_impl(&dword_216897000, v74, OS_LOG_TYPE_DEFAULT, "#I %s: is Entering Low Power Mode for 'No WoW' case.", buf, 0xCu);
        }
      }
      v75 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v2 + 104));
      (*(void (**)(_QWORD, _QWORD, uint64_t, _QWORD))(**(_QWORD **)(v2 + 96) + 200))(*(_QWORD *)(v2 + 96), *(unsigned int *)(v2 + 140), v2 + 232, *(unsigned __int8 *)(v2 + 272));
      v76 = (unint64_t *)&v75->__shared_owners_;
      do
        v77 = __ldaxr(v76);
      while (__stlxr(v77 - 1, v76));
      if (!v77)
      {
        ((void (*)(std::__shared_weak_count *))v75->__on_zero_shared)(v75);
        std::__shared_weak_count::__release_weak(v75);
      }
      *(_QWORD *)buf = &off_24D5DF890;
      *(_QWORD *)&buf[8] = v2;
      *(_QWORD *)&buf[16] = v71;
      *(_QWORD *)&buf[24] = buf;
      v78 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v2 + 104));
      (*(void (**)(_QWORD, _QWORD, _BYTE *))(**(_QWORD **)(v2 + 96) + 168))(*(_QWORD *)(v2 + 96), *(unsigned int *)(v2 + 140), buf);
      v79 = (unint64_t *)&v78->__shared_owners_;
      do
        v80 = __ldaxr(v79);
      while (__stlxr(v80 - 1, v79));
      if (!v80)
      {
        ((void (*)(std::__shared_weak_count *))v78->__on_zero_shared)(v78);
        std::__shared_weak_count::__release_weak(v78);
      }
      v81 = *(_QWORD **)&buf[24];
      if (*(_BYTE **)&buf[24] == buf)
      {
        v82 = 4;
        v81 = buf;
      }
      else
      {
        if (!*(_QWORD *)&buf[24])
        {
LABEL_116:
          _Block_object_dispose(&v87, 8);
          return;
        }
        v82 = 5;
      }
      (*(void (**)(void))(*v81 + 8 * v82))();
      goto LABEL_116;
    }
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = 0;
    v60 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v2 + 104));
    (*(void (**)(_BYTE *__return_ptr))(**(_QWORD **)(v2 + 96) + 240))(buf);
    v61 = (unint64_t *)&v60->__shared_owners_;
    do
      v62 = __ldaxr(v61);
    while (__stlxr(v62 - 1, v61));
    if (!v62)
    {
      ((void (*)(std::__shared_weak_count *))v60->__on_zero_shared)(v60);
      std::__shared_weak_count::__release_weak(v60);
    }
    if (*(_QWORD *)buf)
    {
      v63 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)buf + 256))(*(_QWORD *)buf);
      v64 = *(NSObject **)(v2 + 40);
      v65 = os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT);
      if ((v63 & 0x101) != 0)
      {
        if (v65)
        {
          LODWORD(v111) = 136315138;
          *(_QWORD *)((char *)&v111 + 4) = "setCoalescing";
          _os_log_impl(&dword_216897000, v64, OS_LOG_TYPE_DEFAULT, "#I %s: coalescing to be set", (uint8_t *)&v111, 0xCu);
        }
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 304))(v2, v63);
        goto LABEL_91;
      }
      if (v65)
      {
        LODWORD(v111) = 136315138;
        *(_QWORD *)((char *)&v111 + 4) = "setCoalescing";
        v66 = "#I %s: no coalescing";
        goto LABEL_90;
      }
    }
    else
    {
      v64 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(v111) = 136315138;
        *(_QWORD *)((char *)&v111 + 4) = "setCoalescing";
        v66 = "#E %s: no settings !";
LABEL_90:
        _os_log_impl(&dword_216897000, v64, OS_LOG_TYPE_DEFAULT, v66, (uint8_t *)&v111, 0xCu);
      }
    }
LABEL_91:
    v67 = *(std::__shared_weak_count **)&buf[8];
    if (*(_QWORD *)&buf[8])
    {
      v68 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
      do
        v69 = __ldaxr(v68);
      while (__stlxr(v69 - 1, v68));
      if (!v69)
      {
        ((void (*)(std::__shared_weak_count *))v67->__on_zero_shared)(v67);
        std::__shared_weak_count::__release_weak(v67);
      }
    }
    goto LABEL_96;
  }
  v6 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    v7 = qmi::asString();
    *(_DWORD *)buf = 136315650;
    *(_QWORD *)&buf[4] = "handleSettingsResponse";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v5;
    *(_WORD *)&buf[18] = 2080;
    *(_QWORD *)&buf[20] = v7;
    _os_log_impl(&dword_216897000, v6, OS_LOG_TYPE_DEFAULT, "#I %s: Error getting runtime setting for %d(%s), trying to deactivating now", buf, 0x1Cu);
  }
  QMIDataContextIPBase::deactivateDataContextIP((QMIDataContextIPBase *)v2, 1, 0);
  QMIDataContextIPBase::setDataContextIPState(v2, 1u);
  v8 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v2 + 104));
  (*(void (**)(_QWORD, _QWORD, uint64_t, _QWORD, _QWORD, uint64_t, _QWORD))(**(_QWORD **)(v2 + 96) + 64))(*(_QWORD *)(v2 + 96), *(unsigned int *)(v2 + 140), 18, 0, 0, 2, 0);
  v9 = (unint64_t *)&v8->__shared_owners_;
  do
    v10 = __ldaxr(v9);
  while (__stlxr(v10 - 1, v9));
  if (!v10)
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
  QMIDataContextIPBase::doneWithContext((QMIDataContextIPBase *)v2);
}

void sub_216A07C2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,std::__shared_weak_count *a32)
{
  std::__shared_weak_count *v33;
  unint64_t *p_shared_owners;
  unint64_t v35;

  v33 = a32;
  if (a32)
  {
    p_shared_owners = (unint64_t *)&a32->__shared_owners_;
    do
      v35 = __ldaxr(p_shared_owners);
    while (__stlxr(v35 - 1, p_shared_owners));
    if (!v35)
    {
      ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
      std::__shared_weak_count::__release_weak(v33);
    }
  }
  _Block_object_dispose(&a15, 8);
  _Unwind_Resume(a1);
}

void ___ZN20QMIDataContextIPBase23handleWdsDadCompleteIndERKN3wds11DadComplete10IndicationE_block_invoke(uint64_t a1, const unsigned __int8 *a2)
{
  uint64_t v3;
  NSObject *v4;
  int PrefixLen;
  void *p_p;
  NSObject *v7;
  const char *v8;
  NSObject *v9;
  uint32_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  NSObject *v15;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  char *v23;
  void *__p;
  char v25;
  _QWORD v26[3];
  _BYTE buf[24];
  char *v28;
  uint64_t v29;
  uint64_t v30;

  v30 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 + 32);
  memset(v26, 0, sizeof(v26));
  CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)v26);
  CSIPacketAddress::setIPv6Address((CSIPacketAddress *)v26, a2);
  CSIPacketAddress::setPrefixLen((CSIPacketAddress *)v26);
  v4 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    CSIPacketAddress::operator std::string();
    PrefixLen = CSIPacketAddress::getPrefixLen((CSIPacketAddress *)v26);
    p_p = &__p;
    *(_DWORD *)buf = 136315650;
    *(_QWORD *)&buf[4] = "handleWdsDadCompleteInd_block_invoke";
    if (v25 < 0)
      p_p = __p;
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = p_p;
    *(_WORD *)&buf[22] = 1024;
    LODWORD(v28) = PrefixLen;
    _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I %s: IPv6Service: ** ipv6Addr: %s, prefixLen: %d", buf, 0x1Cu);
    if (v25 < 0)
      operator delete(__p);
  }
  if (CSIPacketAddress::isLinkLocal((CSIPacketAddress *)v26))
  {
    v7 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = "handleWdsDadCompleteInd_block_invoke";
      v8 = "#I %s: IPv6Service: ignoring Link Local DAD";
      v9 = v7;
      v10 = 12;
LABEL_18:
      _os_log_impl(&dword_216897000, v9, OS_LOG_TYPE_DEFAULT, v8, buf, v10);
    }
  }
  else
  {
    v11 = *(_QWORD *)(v3 + 288);
    if (v11 && *(_BYTE *)(v3 + 306))
    {
      v13 = *(_QWORD *)(v3 + 320);
      v12 = *(_QWORD *)(v3 + 328);
      if (v13 >= v12)
      {
        v18 = *(_QWORD *)(v3 + 312);
        v19 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v13 - v18) >> 3);
        if (v19 + 1 > 0xAAAAAAAAAAAAAAALL)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v20 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v12 - v18) >> 3);
        v21 = 2 * v20;
        if (2 * v20 <= v19 + 1)
          v21 = v19 + 1;
        if (v20 >= 0x555555555555555)
          v22 = 0xAAAAAAAAAAAAAAALL;
        else
          v22 = v21;
        v29 = v3 + 328;
        if (v22)
          v23 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>(v3 + 328, v22);
        else
          v23 = 0;
        *(_QWORD *)buf = v23;
        *(_QWORD *)&buf[8] = &v23[24 * v19];
        *(_QWORD *)&buf[16] = *(_QWORD *)&buf[8];
        v28 = &v23[24 * v22];
        CSIPacketAddress::CSIPacketAddress(*(CSIPacketAddress **)&buf[8], (const CSIPacketAddress *)v26);
        *(_QWORD *)&buf[16] += 24;
        std::vector<CSIPacketAddress>::__swap_out_circular_buffer((const CSIPacketAddress **)(v3 + 312), buf);
        if (*(_QWORD *)&buf[16] != *(_QWORD *)&buf[8])
          *(_QWORD *)&buf[16] = (*(_QWORD *)&buf[16] - *(_QWORD *)&buf[8] - 24) % 0x18uLL + *(_QWORD *)&buf[8];
        v14 = *(_QWORD *)(v3 + 320);
        if (*(_QWORD *)buf)
          operator delete(*(void **)buf);
      }
      else
      {
        CSIPacketAddress::CSIPacketAddress(*(CSIPacketAddress **)(v3 + 320), (const CSIPacketAddress *)v26);
        v14 = v13 + 24;
        *(_QWORD *)(v3 + 320) = v13 + 24;
      }
      *(_QWORD *)(v3 + 320) = v14;
      QMIDataContextIPBase::checkIPv6ConfigTimer((QMIDataContextIPBase *)v3);
    }
    else
    {
      v15 = *(NSObject **)(v3 + 40);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        if (v11)
          v16 = "present";
        else
          v16 = "not present";
        v17 = asStringBool();
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = "handleWdsDadCompleteInd_block_invoke";
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = v16;
        *(_WORD *)&buf[22] = 2080;
        v28 = (char *)v17;
        v8 = "#I %s: IPv6Service: ignoring timer %s, fIPv6DadRequired %s";
        v9 = v15;
        v10 = 32;
        goto LABEL_18;
      }
    }
  }
}

void sub_216A081A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, uint64_t a20)
{
  uint64_t v20;
  uint64_t v21;

  *(_QWORD *)(v20 + 320) = v21;
  _Unwind_Resume(exception_object);
}

void QMIDataContextIPBase::checkIPv6ConfigTimer(QMIDataContextIPBase *this)
{
  NSObject *v2;
  NSObject *v3;
  const char *v4;
  uint64_t v5;
  int v6;
  NSObject *v7;
  _BOOL4 v8;
  int v9;
  _BYTE *v10;
  _BYTE *v11;
  void *p_p;
  NSObject *v13;
  _BYTE *v14;
  const char *v15;
  NSObject *v16;
  _BYTE *v17;
  NSObject *v18;
  BOOL v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  unint64_t *p_shared_owners;
  void *__p;
  char v25;
  _BYTE v26[12];
  __int16 v27;
  _BYTE *v28;
  char v29;
  _BYTE buf[22];
  __int16 v31;
  void *v32;
  uint64_t v33;

  v33 = *MEMORY[0x24BDAC8D0];
  v2 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315138;
    *(_QWORD *)&buf[4] = "checkIPv6ConfigTimer";
    _os_log_impl(&dword_216897000, v2, OS_LOG_TYPE_DEFAULT, "#I %s: IPv6Service", buf, 0xCu);
  }
  if (CSIPacketAddress::isZeroIP((QMIDataContextIPBase *)((char *)this + 336)))
  {
    v3 = *((_QWORD *)this + 5);
    if (!os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      return;
    *(_DWORD *)buf = 136315138;
    *(_QWORD *)&buf[4] = "checkIPv6ConfigTimer";
    v4 = "#I %s: IPv6Service: fIPv6ConfigAddress is empty";
    goto LABEL_6;
  }
  if (!*((_BYTE *)this + 306))
  {
    v13 = *((_QWORD *)this + 5);
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
LABEL_36:
      v18 = *((_QWORD *)this + 5);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315138;
        *(_QWORD *)&buf[4] = "checkIPv6ConfigTimer";
        _os_log_impl(&dword_216897000, v18, OS_LOG_TYPE_DEFAULT, "#I %s: IPv6Service: completed", buf, 0xCu);
      }
      v19 = *((_BYTE *)this + 304) == 0;
      QMIDataContextIPBase::clearIPv6ConfigTimer(this);
      if (v19)
      {
        v20 = std::__shared_weak_count::lock(*((std::__shared_weak_count **)this + 13));
        *(_QWORD *)buf = *((_QWORD *)this + 12);
        *(_QWORD *)&buf[8] = v20;
        (*(void (**)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)buf + 56))(*(_QWORD *)buf, *((unsigned int *)this + 35), 0);
        p_shared_owners = (unint64_t *)&v20->__shared_owners_;
        do
          v22 = __ldaxr(p_shared_owners);
        while (__stlxr(v22 - 1, p_shared_owners));
      }
      else
      {
        v20 = std::__shared_weak_count::lock(*((std::__shared_weak_count **)this + 13));
        *(_QWORD *)buf = *((_QWORD *)this + 12);
        *(_QWORD *)&buf[8] = v20;
        (*(void (**)(_QWORD))(**(_QWORD **)buf + 144))(*(_QWORD *)buf);
        v21 = (unint64_t *)&v20->__shared_owners_;
        do
          v22 = __ldaxr(v21);
        while (__stlxr(v22 - 1, v21));
      }
      if (!v22)
      {
        ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
        std::__shared_weak_count::__release_weak(v20);
      }
      return;
    }
    CSIPacketAddress::operator std::string();
    if (v31 >= 0)
      v14 = buf;
    else
      v14 = *(_BYTE **)buf;
    *(_DWORD *)v26 = 136315394;
    *(_QWORD *)&v26[4] = "checkIPv6ConfigTimer";
    v27 = 2080;
    v28 = v14;
    v15 = "#I %s: IPv6Service: fIPv6ConfigAddress: %s";
    v16 = v13;
LABEL_34:
    _os_log_impl(&dword_216897000, v16, OS_LOG_TYPE_DEFAULT, v15, v26, 0x16u);
    if (SHIBYTE(v31) < 0)
      operator delete(*(void **)buf);
    goto LABEL_36;
  }
  v5 = *((_QWORD *)this + 39);
  if (v5 != *((_QWORD *)this + 40))
  {
    while (1)
    {
      v6 = CSIPacketAddress::operator==();
      v7 = *((_QWORD *)this + 5);
      v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
      if (v6)
        break;
      if (v8)
      {
        CSIPacketAddress::operator std::string();
        v9 = v29;
        v10 = *(_BYTE **)v26;
        CSIPacketAddress::operator std::string();
        v11 = v26;
        if (v9 < 0)
          v11 = v10;
        if (v25 >= 0)
          p_p = &__p;
        else
          p_p = __p;
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = "checkIPv6ConfigTimer";
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = v11;
        v31 = 2080;
        v32 = p_p;
        _os_log_impl(&dword_216897000, v7, OS_LOG_TYPE_DEFAULT, "#I %s: IPv6Service: no match %s != %s", buf, 0x20u);
        if (v25 < 0)
          operator delete(__p);
        if (v29 < 0)
          operator delete(*(void **)v26);
      }
      v5 += 24;
      if (v5 == *((_QWORD *)this + 40))
        return;
    }
    if (!v8)
      goto LABEL_36;
    CSIPacketAddress::operator std::string();
    if (v31 >= 0)
      v17 = buf;
    else
      v17 = *(_BYTE **)buf;
    *(_DWORD *)v26 = 136315394;
    *(_QWORD *)&v26[4] = "checkIPv6ConfigTimer";
    v27 = 2080;
    v28 = v17;
    v15 = "#I %s: IPv6Service: match found %s";
    v16 = v7;
    goto LABEL_34;
  }
  v3 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315138;
    *(_QWORD *)&buf[4] = "checkIPv6ConfigTimer";
    v4 = "#I %s: IPv6Service: no DAD address yet";
LABEL_6:
    _os_log_impl(&dword_216897000, v3, OS_LOG_TYPE_DEFAULT, v4, buf, 0xCu);
  }
}

void sub_216A08670(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,char a22)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a22);
  _Unwind_Resume(a1);
}

void QMIDataContextIPBase::setIPv6ConfigTimer(uint64_t a1, char a2, char a3, uint64_t a4)
{
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  std::__shared_weak_count *v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  std::__shared_weak_count *v14;
  unint64_t *p_shared_weak_owners;
  unint64_t v16;
  unint64_t *p_shared_owners;
  unint64_t v18;
  uint64_t v19;
  NSObject *v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  _QWORD v28[7];
  std::__shared_weak_count *v29;
  void *aBlock;
  dispatch_object_t object;
  void *__p[2];
  char v33;
  uint64_t v34;
  _BYTE buf[22];
  __int16 v36;
  uint64_t v37;
  uint64_t v38;

  v38 = *MEMORY[0x24BDAC8D0];
  CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)buf);
  CSIPacketAddress::operator=();
  *(_QWORD *)(a1 + 320) = *(_QWORD *)(a1 + 312);
  *(_BYTE *)(a1 + 304) = a2;
  *(_BYTE *)(a1 + 306) = a3;
  v8 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    v9 = asStringBool();
    v10 = asStringBool();
    *(_DWORD *)buf = 136315650;
    *(_QWORD *)&buf[4] = "setIPv6ConfigTimer";
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = v9;
    v36 = 2080;
    v37 = v10;
    _os_log_impl(&dword_216897000, v8, OS_LOG_TYPE_DEFAULT, "#I %s: resume=%s, dadRequired=%s", buf, 0x20u);
  }
  v11 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v11 || (v12 = *(_QWORD *)(a1 + 8), (v13 = std::__shared_weak_count::lock(v11)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v14 = v13;
  p_shared_weak_owners = (unint64_t *)&v13->__shared_weak_owners_;
  do
    v16 = __ldxr(p_shared_weak_owners);
  while (__stxr(v16 + 1, p_shared_weak_owners));
  p_shared_owners = (unint64_t *)&v13->__shared_owners_;
  do
    v18 = __ldaxr(p_shared_owners);
  while (__stlxr(v18 - 1, p_shared_owners));
  if (!v18)
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v14);
  }
  Registry::getTimerService(*(Registry **)(a1 + 80));
  v19 = *(_QWORD *)buf;
  std::string::basic_string[abi:ne180100]<0>(__p, "IPv6 Configuration timer");
  v20 = *(NSObject **)(a1 + 24);
  object = v20;
  if (v20)
    dispatch_retain(v20);
  v28[0] = MEMORY[0x24BDAC760];
  v28[1] = 1174405120;
  v28[2] = ___ZN20QMIDataContextIPBase18setIPv6ConfigTimerEbbU13block_pointerFvvE_block_invoke;
  v28[3] = &unk_24D5DEC08;
  v28[5] = a1;
  v28[6] = v12;
  v29 = v14;
  do
    v21 = __ldxr(p_shared_weak_owners);
  while (__stxr(v21 + 1, p_shared_weak_owners));
  v28[4] = a4;
  aBlock = _Block_copy(v28);
  ctu::TimerService::createOneShotTimer(v19, (uint64_t)__p, 0, 10000000, &object, &aBlock);
  v22 = v34;
  v34 = 0;
  v23 = *(_QWORD *)(a1 + 288);
  *(_QWORD *)(a1 + 288) = v22;
  if (v23)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v23 + 8))(v23);
    v24 = v34;
    v34 = 0;
    if (v24)
      (*(void (**)(uint64_t))(*(_QWORD *)v24 + 8))(v24);
  }
  if (aBlock)
    _Block_release(aBlock);
  if (object)
    dispatch_release(object);
  if (v33 < 0)
    operator delete(__p[0]);
  v25 = *(std::__shared_weak_count **)&buf[8];
  if (*(_QWORD *)&buf[8])
  {
    v26 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
    do
      v27 = __ldaxr(v26);
    while (__stlxr(v27 - 1, v26));
    if (!v27)
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }
  if (v29)
    std::__shared_weak_count::__release_weak(v29);
  std::__shared_weak_count::__release_weak(v14);
}

void sub_216A08968(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, void *aBlock, dispatch_object_t object, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

void ___ZN20QMIDataContextIPBase18setIPv6ConfigTimerEbbU13block_pointerFvvE_block_invoke(_QWORD *a1)
{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  std::__shared_weak_count *v12;

  v2 = (std::__shared_weak_count *)a1[7];
  if (!v2)
    return;
  v3 = a1[5];
  v4 = std::__shared_weak_count::lock(v2);
  v12 = v4;
  if (!v4)
    return;
  if (!a1[6])
  {
    v9 = v4;
LABEL_13:
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v11 = __ldaxr(p_shared_owners);
    while (__stlxr(v11 - 1, p_shared_owners));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
    return;
  }
  v5 = *(_QWORD *)(v3 + 288);
  *(_QWORD *)(v3 + 288) = 0;
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
  v6 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v3 + 104));
  (*(void (**)(_QWORD, uint64_t, uint64_t))(**(_QWORD **)(v3 + 96) + 376))(*(_QWORD *)(v3 + 96), 2, 1);
  v7 = (unint64_t *)&v6->__shared_owners_;
  do
    v8 = __ldaxr(v7);
  while (__stlxr(v8 - 1, v7));
  if (!v8)
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
  (*(void (**)(void))(a1[4] + 16))();
  v9 = v12;
  if (v12)
    goto LABEL_13;
}

void sub_216A08B04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_48c45_ZTSNSt3__18weak_ptrI20QMIDataContextIPBaseEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(result + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 56) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 16);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void __destroy_helper_block_e8_48c45_ZTSNSt3__18weak_ptrI20QMIDataContextIPBaseEE(uint64_t a1)
{
  std::__shared_weak_count *v1;

  v1 = *(std::__shared_weak_count **)(a1 + 56);
  if (v1)
    std::__shared_weak_count::__release_weak(v1);
}

void QMIDataContextIPBase::setIPv4ConfigTimer(uint64_t a1, char a2, uint64_t a3)
{
  NSObject *v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  std::__shared_weak_count *v10;
  std::__shared_weak_count *v11;
  unint64_t *p_shared_weak_owners;
  unint64_t v13;
  unint64_t *p_shared_owners;
  unint64_t v15;
  uint64_t v16;
  NSObject *v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  _QWORD v25[7];
  std::__shared_weak_count *v26;
  void *aBlock;
  dispatch_object_t object;
  void *__p[2];
  char v30;
  uint64_t v31;
  _BYTE buf[22];
  uint64_t v33;

  v33 = *MEMORY[0x24BDAC8D0];
  CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)buf);
  CSIPacketAddress::operator=();
  *(_BYTE *)(a1 + 305) = a2;
  v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    v7 = asStringBool();
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = "setIPv4ConfigTimer";
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = v7;
    _os_log_impl(&dword_216897000, v6, OS_LOG_TYPE_DEFAULT, "#I %s: resume=%s", buf, 0x16u);
  }
  v8 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v8 || (v9 = *(_QWORD *)(a1 + 8), (v10 = std::__shared_weak_count::lock(v8)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v11 = v10;
  p_shared_weak_owners = (unint64_t *)&v10->__shared_weak_owners_;
  do
    v13 = __ldxr(p_shared_weak_owners);
  while (__stxr(v13 + 1, p_shared_weak_owners));
  p_shared_owners = (unint64_t *)&v10->__shared_owners_;
  do
    v15 = __ldaxr(p_shared_owners);
  while (__stlxr(v15 - 1, p_shared_owners));
  if (!v15)
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v11);
  }
  Registry::getTimerService(*(Registry **)(a1 + 80));
  v16 = *(_QWORD *)buf;
  std::string::basic_string[abi:ne180100]<0>(__p, "IPv4 Configuration timer");
  v17 = *(NSObject **)(a1 + 24);
  object = v17;
  if (v17)
    dispatch_retain(v17);
  v25[0] = MEMORY[0x24BDAC760];
  v25[1] = 1174405120;
  v25[2] = ___ZN20QMIDataContextIPBase18setIPv4ConfigTimerEbU13block_pointerFvvE_block_invoke;
  v25[3] = &unk_24D5DEC40;
  v25[5] = a1;
  v25[6] = v9;
  v26 = v11;
  do
    v18 = __ldxr(p_shared_weak_owners);
  while (__stxr(v18 + 1, p_shared_weak_owners));
  v25[4] = a3;
  aBlock = _Block_copy(v25);
  ctu::TimerService::createOneShotTimer(v16, (uint64_t)__p, 0, 10000000, &object, &aBlock);
  v19 = v31;
  v31 = 0;
  v20 = *(_QWORD *)(a1 + 296);
  *(_QWORD *)(a1 + 296) = v19;
  if (v20)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v20 + 8))(v20);
    v21 = v31;
    v31 = 0;
    if (v21)
      (*(void (**)(uint64_t))(*(_QWORD *)v21 + 8))(v21);
  }
  if (aBlock)
    _Block_release(aBlock);
  if (object)
    dispatch_release(object);
  if (v30 < 0)
    operator delete(__p[0]);
  v22 = *(std::__shared_weak_count **)&buf[8];
  if (*(_QWORD *)&buf[8])
  {
    v23 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
    do
      v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
  }
  if (v26)
    std::__shared_weak_count::__release_weak(v26);
  std::__shared_weak_count::__release_weak(v11);
}

void sub_216A08DF8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, void *aBlock, dispatch_object_t object, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

void ___ZN20QMIDataContextIPBase18setIPv4ConfigTimerEbU13block_pointerFvvE_block_invoke(_QWORD *a1)
{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  std::__shared_weak_count *v12;

  v2 = (std::__shared_weak_count *)a1[7];
  if (!v2)
    return;
  v3 = a1[5];
  v4 = std::__shared_weak_count::lock(v2);
  v12 = v4;
  if (!v4)
    return;
  if (!a1[6])
  {
    v9 = v4;
LABEL_13:
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v11 = __ldaxr(p_shared_owners);
    while (__stlxr(v11 - 1, p_shared_owners));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
    return;
  }
  v5 = *(_QWORD *)(v3 + 296);
  *(_QWORD *)(v3 + 296) = 0;
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
  v6 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v3 + 104));
  (*(void (**)(_QWORD, uint64_t, uint64_t))(**(_QWORD **)(v3 + 96) + 376))(*(_QWORD *)(v3 + 96), 1, 1);
  v7 = (unint64_t *)&v6->__shared_owners_;
  do
    v8 = __ldaxr(v7);
  while (__stlxr(v8 - 1, v7));
  if (!v8)
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
  (*(void (**)(void))(a1[4] + 16))();
  v9 = v12;
  if (v12)
    goto LABEL_13;
}

void sub_216A08F94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN20QMIDataContextIPBase22handleSettingsResponseERKN3wds18GetRuntimeSettings8ResponseE_block_invoke(uint64_t result, _DWORD *a2)
{
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = *a2;
  return result;
}

void ___ZN20QMIDataContextIPBase17handlePcoResponseERKN3wds18GetRuntimeSettings8ResponseE_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  int v4;
  NSObject *v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  _BYTE v9[18];
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 + 32);
  if (v3 + 592 != a2 + 8)
    std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((_QWORD *)(v3 + 592), *(char **)(a2 + 8), *(char **)(a2 + 16), *(_QWORD *)(a2 + 16) - *(_QWORD *)(a2 + 8));
  v4 = *(unsigned __int16 *)(a2 + 32);
  *(_WORD *)(v3 + 584) = v4;
  v5 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)v9 = 136315394;
    *(_QWORD *)&v9[4] = "handlePcoResponse_block_invoke";
    *(_WORD *)&v9[12] = 1024;
    *(_DWORD *)&v9[14] = v4;
    _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#I %s: PCO: %04x, Call observer", v9, 0x12u);
  }
  v6 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v3 + 104));
  *(_QWORD *)v9 = *(_QWORD *)(v3 + 96);
  *(_QWORD *)&v9[8] = v6;
  (*(void (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)v9 + 152))(*(_QWORD *)v9, v3 + 592, *(unsigned __int16 *)(v3 + 584));
  p_shared_owners = (unint64_t *)&v6->__shared_owners_;
  do
    v8 = __ldaxr(p_shared_owners);
  while (__stlxr(v8 - 1, p_shared_owners));
  if (!v8)
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
}

void sub_216A09104(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t ___ZN20QMIDataContextIPBase21parseSettingsResponseERKN3wds18GetRuntimeSettings8ResponseE_block_invoke(uint64_t a1)
{
  return CSIPacketAddress::setIPv4AddressLE((CSIPacketAddress *)(*(_QWORD *)(a1 + 32) + 184));
}

uint64_t ___ZN20QMIDataContextIPBase21parseSettingsResponseERKN3wds18GetRuntimeSettings8ResponseE_block_invoke_2(uint64_t a1)
{
  _QWORD *v1;
  uint64_t result;
  unint64_t v3;
  _QWORD v4[3];

  v1 = *(_QWORD **)(a1 + 32);
  memset(v4, 0, sizeof(v4));
  CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)v4);
  CSIPacketAddress::setIPv4AddressLE((CSIPacketAddress *)v4);
  result = CSIPacketAddress::isZeroIP((CSIPacketAddress *)v4);
  if ((result & 1) == 0)
  {
    v3 = v1[27];
    if (v3 == v1[26])
    {
      if (v3 >= v1[28])
      {
        result = std::vector<CSIPacketAddress>::__emplace_back_slow_path<CSIPacketAddress&>((uint64_t)(v1 + 26), (const CSIPacketAddress *)v4);
      }
      else
      {
        CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)v1[27], (const CSIPacketAddress *)v4);
        result = v3 + 24;
        v1[27] = v3 + 24;
      }
      v1[27] = result;
    }
    else
    {
      return CSIPacketAddress::operator=();
    }
  }
  return result;
}

void sub_216A091C8(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v2 + 216) = v1;
  _Unwind_Resume(a1);
}

uint64_t ___ZN20QMIDataContextIPBase21parseSettingsResponseERKN3wds18GetRuntimeSettings8ResponseE_block_invoke_3(uint64_t a1)
{
  _QWORD *v1;
  uint64_t result;
  unint64_t v3;
  uint64_t v4;
  _BYTE v5[24];
  _QWORD v6[3];

  v1 = *(_QWORD **)(a1 + 32);
  memset(v6, 0, sizeof(v6));
  CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)v6);
  CSIPacketAddress::setIPv4AddressLE((CSIPacketAddress *)v6);
  result = CSIPacketAddress::isZeroIP((CSIPacketAddress *)v6);
  if ((result & 1) == 0)
  {
    if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v1[27] - v1[26]) >> 3) <= 1)
    {
      do
      {
        CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)v5);
        v3 = v1[27];
        if (v3 >= v1[28])
        {
          v4 = std::vector<CSIPacketAddress>::__push_back_slow_path<CSIPacketAddress>((uint64_t)(v1 + 26), (const CSIPacketAddress *)v5);
        }
        else
        {
          CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)v1[27], (const CSIPacketAddress *)v5);
          v4 = v3 + 24;
          v1[27] = v3 + 24;
        }
        v1[27] = v4;
      }
      while (0xAAAAAAAAAAAAAAABLL * ((v4 - v1[26]) >> 3) < 2);
    }
    return CSIPacketAddress::operator=();
  }
  return result;
}

void sub_216A092AC(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v2 + 216) = v1;
  _Unwind_Resume(a1);
}

uint64_t ___ZN20QMIDataContextIPBase21parseSettingsResponseERKN3wds18GetRuntimeSettings8ResponseE_block_invoke_4(uint64_t a1, const unsigned __int8 *a2)
{
  CSIPacketAddress *v2;

  v2 = (CSIPacketAddress *)(*(_QWORD *)(a1 + 32) + 184);
  CSIPacketAddress::setIPv6Address(v2, a2);
  return CSIPacketAddress::setPrefixLen(v2);
}

uint64_t ___ZN20QMIDataContextIPBase21parseSettingsResponseERKN3wds18GetRuntimeSettings8ResponseE_block_invoke_5(uint64_t a1, const unsigned __int8 *a2)
{
  CSIPacketAddress *v2;

  v2 = (CSIPacketAddress *)(*(_QWORD *)(a1 + 32) + 184);
  CSIPacketAddress::setIPv6Address(v2, a2);
  return CSIPacketAddress::setPrefixLen(v2);
}

uint64_t ___ZN20QMIDataContextIPBase21parseSettingsResponseERKN3wds18GetRuntimeSettings8ResponseE_block_invoke_6(uint64_t a1, const unsigned __int8 *a2)
{
  _QWORD *v3;
  uint64_t result;
  unint64_t v5;
  _QWORD v6[3];

  v3 = *(_QWORD **)(a1 + 32);
  memset(v6, 0, sizeof(v6));
  CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)v6);
  CSIPacketAddress::setIPv6Address((CSIPacketAddress *)v6, a2);
  result = CSIPacketAddress::isZeroIP((CSIPacketAddress *)v6);
  if ((result & 1) == 0)
  {
    v5 = v3[27];
    if (v5 == v3[26])
    {
      if (v5 >= v3[28])
      {
        result = std::vector<CSIPacketAddress>::__emplace_back_slow_path<CSIPacketAddress&>((uint64_t)(v3 + 26), (const CSIPacketAddress *)v6);
      }
      else
      {
        CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)v3[27], (const CSIPacketAddress *)v6);
        result = v5 + 24;
        v3[27] = v5 + 24;
      }
      v3[27] = result;
    }
    else
    {
      return CSIPacketAddress::operator=();
    }
  }
  return result;
}

void sub_216A093C8(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v2 + 216) = v1;
  _Unwind_Resume(a1);
}

uint64_t ___ZN20QMIDataContextIPBase21parseSettingsResponseERKN3wds18GetRuntimeSettings8ResponseE_block_invoke_7(uint64_t a1, const unsigned __int8 *a2)
{
  _QWORD *v3;
  uint64_t result;
  unint64_t v5;
  uint64_t v6;
  _BYTE v7[24];
  _QWORD v8[3];

  v3 = *(_QWORD **)(a1 + 32);
  memset(v8, 0, sizeof(v8));
  CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)v8);
  CSIPacketAddress::setIPv6Address((CSIPacketAddress *)v8, a2);
  result = CSIPacketAddress::isZeroIP((CSIPacketAddress *)v8);
  if ((result & 1) == 0)
  {
    if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v3[27] - v3[26]) >> 3) <= 1)
    {
      do
      {
        CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)v7);
        v5 = v3[27];
        if (v5 >= v3[28])
        {
          v6 = std::vector<CSIPacketAddress>::__push_back_slow_path<CSIPacketAddress>((uint64_t)(v3 + 26), (const CSIPacketAddress *)v7);
        }
        else
        {
          CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)v3[27], (const CSIPacketAddress *)v7);
          v6 = v5 + 24;
          v3[27] = v5 + 24;
        }
        v3[27] = v6;
      }
      while (0xAAAAAAAAAAAAAAABLL * ((v6 - v3[26]) >> 3) < 2);
    }
    return CSIPacketAddress::operator=();
  }
  return result;
}

void sub_216A094B0(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v2 + 216) = v1;
  _Unwind_Resume(a1);
}

uint64_t QMIDataContextIPBase::parseImsSettingsFromResponse(_QWORD *a1, qmi::MessageBase *a2)
{
  NSObject *v4;
  uint64_t v5;
  unsigned __int8 *TlvValue;
  int v7;
  unsigned __int8 *v8;
  int v9;
  unsigned __int8 *v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  int v14;
  unsigned __int8 *v15;
  NSObject *v16;
  unint64_t v17;
  uint64_t v18;
  _QWORD v20[5];
  _QWORD v21[6];
  _QWORD v22[2];
  void (*v23)(uint64_t, uint64_t *);
  void *v24;
  __int128 *p_buf;
  _QWORD *v26;
  unsigned __int8 *v27;
  __int128 buf;
  uint64_t v29;
  char v30;
  uint8_t v31[24];
  uint64_t v32;

  v32 = *MEMORY[0x24BDAC8D0];
  v4 = a1[5];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 136315138;
    *(_QWORD *)((char *)&buf + 4) = "parseImsSettingsFromResponse";
    _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I %s: Read out tlv for Proxy Addrs", (uint8_t *)&buf, 0xCu);
  }
  std::vector<std::string>::__clear[abi:ne180100](a1 + 29);
  *(_QWORD *)&buf = 0;
  *((_QWORD *)&buf + 1) = &buf;
  v29 = 0x2000000000;
  v30 = 0;
  v5 = MEMORY[0x24BDAC760];
  v22[0] = MEMORY[0x24BDAC760];
  v22[1] = 0x40000000;
  v23 = ___ZN20QMIDataContextIPBase28parseImsSettingsFromResponseERKN3wds18GetRuntimeSettings8ResponseE_block_invoke;
  v24 = &unk_24D5DEDC0;
  p_buf = &buf;
  v26 = a1;
  TlvValue = (unsigned __int8 *)qmi::MessageBase::findTlvValue(a2);
  v8 = TlvValue;
  if (TlvValue)
  {
    v9 = v7;
    v27 = TlvValue;
    memset(v31, 0, sizeof(v31));
    tlv::parseV<wds::tlv::ProxyIPv4List>(&v27, v7, v31);
    v10 = v27;
    if (v27)
      v23((uint64_t)v22, (uint64_t *)v31);
    if (*(_QWORD *)v31)
    {
      *(_QWORD *)&v31[8] = *(_QWORD *)v31;
      operator delete(*(void **)v31);
    }
    if (!v10)
      ((void (*)(_QWORD, uint64_t, unsigned __int8 *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 35, v8, v9);
  }
  v21[0] = v5;
  v21[1] = 0x40000000;
  v21[2] = ___ZN20QMIDataContextIPBase28parseImsSettingsFromResponseERKN3wds18GetRuntimeSettings8ResponseE_block_invoke_2;
  v21[3] = &unk_24D5DEDE8;
  v21[4] = &buf;
  v21[5] = a1;
  v11 = qmi::MessageBase::findTlvValue(a2);
  v13 = v11;
  if (v11)
  {
    v14 = v12;
    v27 = (unsigned __int8 *)v11;
    memset(v31, 0, sizeof(v31));
    tlv::parseV<wds::tlv::ProxyIPv6List>(&v27, v12, v31);
    v15 = v27;
    if (v27)
      ___ZN20QMIDataContextIPBase28parseImsSettingsFromResponseERKN3wds18GetRuntimeSettings8ResponseE_block_invoke_2((uint64_t)v21, (uint64_t)v31);
    v11 = *(_QWORD *)v31;
    if (*(_QWORD *)v31)
    {
      *(_QWORD *)&v31[8] = *(_QWORD *)v31;
      operator delete(*(void **)v31);
    }
    if (!v15)
      v11 = ((uint64_t (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 46, v13, v14);
  }
  if (*(_BYTE *)(*((_QWORD *)&buf + 1) + 24))
  {
    v16 = a1[5];
    v11 = os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT);
    if ((_DWORD)v11)
    {
      v17 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a1[30] - a1[29]) >> 3);
      *(_DWORD *)v31 = 136315394;
      *(_QWORD *)&v31[4] = "parseImsSettingsFromResponse";
      *(_WORD *)&v31[12] = 2048;
      *(_QWORD *)&v31[14] = v17;
      _os_log_impl(&dword_216897000, v16, OS_LOG_TYPE_DEFAULT, "#I %s: Read %lu Proxies. Proxy update found", v31, 0x16u);
    }
  }
  if (capabilities::ct::supports5G((capabilities::ct *)v11))
  {
    v20[0] = v5;
    v20[1] = 0x40000000;
    v20[2] = ___ZN20QMIDataContextIPBase28parseImsSettingsFromResponseERKN3wds18GetRuntimeSettings8ResponseE_block_invoke_187;
    v20[3] = &__block_descriptor_tmp_188_0;
    v20[4] = a1;
    *(_QWORD *)v31 = v20;
    qmi::MessageBase::applyTlv<wds::tlv::SnssaiPdnInfo,void({block_pointer})(wds::tlv::SnssaiPdnInfo const&)>(a2, (uint64_t)v31);
  }
  v18 = *(unsigned __int8 *)(*((_QWORD *)&buf + 1) + 24);
  _Block_object_dispose(&buf, 8);
  return v18;
}

void sub_216A097B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  uint64_t v27;
  void *v29;

  v29 = *(void **)(v27 - 112);
  if (v29)
  {
    *(_QWORD *)(v27 - 104) = v29;
    operator delete(v29);
  }
  _Block_object_dispose(&a27, 8);
  _Unwind_Resume(a1);
}

void ___ZN20QMIDataContextIPBase21parseSettingsResponseERKN3wds18GetRuntimeSettings8ResponseE_block_invoke_183(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v3;
  NSObject *v4;
  int v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  _BYTE v9[18];
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 + 32);
  v4 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v5 = *a2;
    *(_DWORD *)v9 = 136315394;
    *(_QWORD *)&v9[4] = "parseSettingsResponse_block_invoke";
    *(_WORD *)&v9[12] = 1024;
    *(_DWORD *)&v9[14] = v5;
    _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I %s: non-IMS: received cellular pduSessionId %d", v9, 0x12u);
  }
  v6 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v3 + 104));
  *(_QWORD *)v9 = *(_QWORD *)(v3 + 96);
  *(_QWORD *)&v9[8] = v6;
  (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)v9 + 272))(*(_QWORD *)v9, *a2);
  p_shared_owners = (unint64_t *)&v6->__shared_owners_;
  do
    v8 = __ldaxr(p_shared_owners);
  while (__stlxr(v8 - 1, p_shared_owners));
  if (!v8)
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
}

void sub_216A09908(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void ___ZN20QMIDataContextIPBase28parseImsSettingsFromResponseERKN3wds18GetRuntimeSettings8ResponseE_block_invoke(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  std::string *v12;
  std::string *v13;
  uint64_t v14;
  void *__p[2];
  std::string::size_type v16;
  _QWORD v17[3];
  std::__split_buffer<std::string> __v;

  v2 = *a2;
  v3 = a2[1];
  if (*a2 != v3)
  {
    v4 = *(_QWORD *)(a1 + 40);
    v5 = (_QWORD *)(v4 + 232);
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
    do
    {
      memset(v17, 0, sizeof(v17));
      CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)v17);
      CSIPacketAddress::setIPv4AddressLE((CSIPacketAddress *)v17);
      CSIPacketAddress::operator std::string();
      v7 = *(_QWORD *)(v4 + 240);
      v6 = *(_QWORD *)(v4 + 248);
      if (v7 >= v6)
      {
        v8 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v7 - *v5) >> 3);
        v9 = v8 + 1;
        if (v8 + 1 > 0xAAAAAAAAAAAAAAALL)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v10 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v6 - *v5) >> 3);
        if (2 * v10 > v9)
          v9 = 2 * v10;
        if (v10 >= 0x555555555555555)
          v11 = 0xAAAAAAAAAAAAAAALL;
        else
          v11 = v9;
        __v.__end_cap_.__value_ = (std::allocator<std::string> *)(v4 + 248);
        if (v11)
          v12 = (std::string *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>(v4 + 248, v11);
        else
          v12 = 0;
        v13 = v12 + v8;
        __v.__first_ = v12;
        __v.__begin_ = v13;
        __v.__end_cap_.__value_ = &v12[v11];
        v13->__r_.__value_.__r.__words[2] = v16;
        *(_OWORD *)&v13->__r_.__value_.__l.__data_ = *(_OWORD *)__p;
        v16 = 0;
        *(_OWORD *)__p = 0uLL;
        __v.__end_ = v13 + 1;
        std::vector<std::string>::__swap_out_circular_buffer((std::vector<std::string> *)(v4 + 232), &__v);
        v14 = *(_QWORD *)(v4 + 240);
        std::__split_buffer<std::string>::~__split_buffer(&__v);
        *(_QWORD *)(v4 + 240) = v14;
      }
      else
      {
        *(_QWORD *)(v7 + 16) = v16;
        *(_OWORD *)v7 = *(_OWORD *)__p;
        *(_QWORD *)(v4 + 240) = v7 + 24;
      }
      v2 += 4;
    }
    while (v2 != v3);
  }
}

void sub_216A09AB4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, std::__split_buffer<std::string> *a19)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void ___ZN20QMIDataContextIPBase28parseImsSettingsFromResponseERKN3wds18GetRuntimeSettings8ResponseE_block_invoke_2(uint64_t a1, uint64_t a2)
{
  _OWORD *v2;
  _OWORD *v3;
  uint64_t v4;
  _QWORD *v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  std::string *v12;
  std::string *v13;
  uint64_t v14;
  void *__p[2];
  std::string::size_type v16;
  _QWORD v17[3];
  std::__split_buffer<std::string> __v;
  unsigned __int8 v19[24];
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  v2 = *(_OWORD **)a2;
  v3 = *(_OWORD **)(a2 + 8);
  if (*(_OWORD **)a2 != v3)
  {
    v4 = *(_QWORD *)(a1 + 40);
    v5 = (_QWORD *)(v4 + 232);
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
    do
    {
      *(_OWORD *)v19 = *v2;
      memset(v17, 0, sizeof(v17));
      CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)v17);
      CSIPacketAddress::setIPv6Address((CSIPacketAddress *)v17, v19);
      CSIPacketAddress::operator std::string();
      v7 = *(_QWORD *)(v4 + 240);
      v6 = *(_QWORD *)(v4 + 248);
      if (v7 >= v6)
      {
        v8 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v7 - *v5) >> 3);
        v9 = v8 + 1;
        if (v8 + 1 > 0xAAAAAAAAAAAAAAALL)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v10 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v6 - *v5) >> 3);
        if (2 * v10 > v9)
          v9 = 2 * v10;
        if (v10 >= 0x555555555555555)
          v11 = 0xAAAAAAAAAAAAAAALL;
        else
          v11 = v9;
        __v.__end_cap_.__value_ = (std::allocator<std::string> *)(v4 + 248);
        if (v11)
          v12 = (std::string *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>(v4 + 248, v11);
        else
          v12 = 0;
        v13 = v12 + v8;
        __v.__first_ = v12;
        __v.__begin_ = v13;
        __v.__end_cap_.__value_ = &v12[v11];
        v13->__r_.__value_.__r.__words[2] = v16;
        *(_OWORD *)&v13->__r_.__value_.__l.__data_ = *(_OWORD *)__p;
        v16 = 0;
        *(_OWORD *)__p = 0uLL;
        __v.__end_ = v13 + 1;
        std::vector<std::string>::__swap_out_circular_buffer((std::vector<std::string> *)(v4 + 232), &__v);
        v14 = *(_QWORD *)(v4 + 240);
        std::__split_buffer<std::string>::~__split_buffer(&__v);
        *(_QWORD *)(v4 + 240) = v14;
      }
      else
      {
        *(_QWORD *)(v7 + 16) = v16;
        *(_OWORD *)v7 = *(_OWORD *)__p;
        *(_QWORD *)(v4 + 240) = v7 + 24;
      }
      ++v2;
    }
    while (v2 != v3);
  }
}

void sub_216A09CB0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, std::__split_buffer<std::string> *a19)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void ___ZN20QMIDataContextIPBase28parseImsSettingsFromResponseERKN3wds18GetRuntimeSettings8ResponseE_block_invoke_187(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v3;
  NSObject *v4;
  int v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  _BYTE v9[18];
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 + 32);
  v4 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v5 = *a2;
    *(_DWORD *)v9 = 136315394;
    *(_QWORD *)&v9[4] = "parseImsSettingsFromResponse_block_invoke";
    *(_WORD *)&v9[12] = 1024;
    *(_DWORD *)&v9[14] = v5;
    _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I %s: Received SnssaiPdnInfo from getRuntimeSettings %d", v9, 0x12u);
  }
  v6 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v3 + 104));
  *(_QWORD *)v9 = *(_QWORD *)(v3 + 96);
  *(_QWORD *)&v9[8] = v6;
  (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)v9 + 272))(*(_QWORD *)v9, *a2);
  p_shared_owners = (unint64_t *)&v6->__shared_owners_;
  do
    v8 = __ldaxr(p_shared_owners);
  while (__stlxr(v8 - 1, p_shared_owners));
  if (!v8)
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
}

void sub_216A09DF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void ___ZN20QMIDataContextIPBase34handleWdsExtendedIPConfigChangeIndERKN3wds22ExtendedIPConfigChange10IndicationE_block_invoke_2(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v3;
  NSObject *v4;
  int v5;
  NSObject *v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  _BYTE *v14;
  _BYTE buf[32];
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 + 32);
  v4 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315138;
    *(_QWORD *)&buf[4] = "handleImsSettingsResponse";
    _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I %s: start", buf, 0xCu);
  }
  v5 = *((_DWORD *)a2 + 1);
  if (v5)
  {
    v6 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      v7 = qmi::asString();
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = "handleImsSettingsResponse";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v5;
      *(_WORD *)&buf[18] = 2080;
      *(_QWORD *)&buf[20] = v7;
      _os_log_impl(&dword_216897000, v6, OS_LOG_TYPE_DEFAULT, "#I %s: Error getting runtime setting for Proxy restoration: %d(%s)", buf, 0x1Cu);
    }
  }
  else
  {
    *(_QWORD *)&buf[8] = 0x40000000;
    *(_QWORD *)&buf[16] = ___ZN20QMIDataContextIPBase17handlePcoResponseERKN3wds18GetRuntimeSettings8ResponseE_block_invoke;
    *(_QWORD *)&buf[24] = &__block_descriptor_tmp_174;
    v16 = v3;
    v14 = buf;
    *(_QWORD *)buf = MEMORY[0x24BDAC760];
    qmi::MessageBase::tryTlv<wds::tlv::OperatorReservedProtocolInformation,void({block_pointer})(wds::tlv::OperatorReservedProtocolInformation const&)>(a2, (uint64_t)&v14);
    if (QMIDataContextIPBase::parseImsSettingsFromResponse((_QWORD *)v3, a2))
    {
      v8 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v3 + 104));
      (*(void (**)(_QWORD, _QWORD, uint64_t, _QWORD))(**(_QWORD **)(v3 + 96) + 200))(*(_QWORD *)(v3 + 96), *(unsigned int *)(v3 + 140), v3 + 232, 0);
      p_shared_owners = (unint64_t *)&v8->__shared_owners_;
      do
        v10 = __ldaxr(p_shared_owners);
      while (__stlxr(v10 - 1, p_shared_owners));
      if (!v10)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
      v11 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v3 + 104));
      (*(void (**)(_QWORD))(**(_QWORD **)(v3 + 96) + 192))(*(_QWORD *)(v3 + 96));
      v12 = (unint64_t *)&v11->__shared_owners_;
      do
        v13 = __ldaxr(v12);
      while (__stlxr(v13 - 1, v12));
      if (!v13)
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
    }
  }
}

void sub_216A0A028(_Unwind_Exception *exception_object)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v4;

  p_shared_owners = (unint64_t *)&v1->__shared_owners_;
  do
    v4 = __ldaxr(p_shared_owners);
  while (__stlxr(v4 - 1, p_shared_owners));
  if (!v4)
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL QMIDataContextIPBase::suspendDataContextIP(QMIDataContextIPBase *this)
{
  NSObject *v2;
  int v3;
  NSObject *v4;
  int v6;
  const char *v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  v2 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v6 = 136315138;
    v7 = "suspendDataContextIP";
    _os_log_impl(&dword_216897000, v2, OS_LOG_TYPE_DEFAULT, "#I %s: start", (uint8_t *)&v6, 0xCu);
  }
  v3 = (*(uint64_t (**)(QMIDataContextIPBase *))(*(_QWORD *)this + 96))(this);
  if (v3 == 6)
  {
    QMIDataContextIPBase::setDataContextIPState((uint64_t)this, 5u);
  }
  else if (*((_QWORD *)this + 33))
  {
    v4 = *((_QWORD *)this + 5);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      v6 = 136315138;
      v7 = "suspendDataContextIP";
      _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I %s: DeactivateDelayTimer already scheduled. Don't do anything. Let timer be fired", (uint8_t *)&v6, 0xCu);
    }
  }
  return v3 == 6;
}

void QMIDataContextIPBase::resumeDataContextIP(QMIDataContextIPBase *this)
{
  NSObject *v2;
  std::__shared_weak_count *v3;
  int v4;
  int v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  int v8;
  NSObject *v9;
  _QWORD v10[5];
  _QWORD v11[5];
  __int128 buf;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v2 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 136315138;
    *(_QWORD *)((char *)&buf + 4) = "resumeDataContextIP";
    _os_log_impl(&dword_216897000, v2, OS_LOG_TYPE_DEFAULT, "#I %s: start", (uint8_t *)&buf, 0xCu);
  }
  if ((*(unsigned int (**)(QMIDataContextIPBase *))(*(_QWORD *)this + 96))(this) == 5)
  {
    QMIDataContextIPBase::setDataContextIPState((uint64_t)this, 6u);
    v3 = std::__shared_weak_count::lock(*((std::__shared_weak_count **)this + 13));
    *(_QWORD *)&buf = *((_QWORD *)this + 12);
    *((_QWORD *)&buf + 1) = v3;
    v4 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)buf + 136))(buf, *((unsigned int *)this + 35), 0);
    v5 = v4;
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (v7)
    {
      if (!v4)
        goto LABEL_14;
    }
    else
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
      if (!v5)
        goto LABEL_14;
    }
    v8 = *((_DWORD *)this + 35);
    if (v8 == 1)
    {
      v10[0] = MEMORY[0x24BDAC760];
      v10[1] = 0x40000000;
      v10[2] = ___ZN20QMIDataContextIPBase19resumeDataContextIPEv_block_invoke_2;
      v10[3] = &__block_descriptor_tmp_193_0;
      v10[4] = this;
      QMIDataContextIPBase::setIPv4ConfigTimer((uint64_t)this, 1, (uint64_t)v10);
    }
    else if (v8 == 2)
    {
      v11[0] = MEMORY[0x24BDAC760];
      v11[1] = 0x40000000;
      v11[2] = ___ZN20QMIDataContextIPBase19resumeDataContextIPEv_block_invoke;
      v11[3] = &__block_descriptor_tmp_192_0;
      v11[4] = this;
      QMIDataContextIPBase::setIPv6ConfigTimer((uint64_t)this, 1, 0, (uint64_t)v11);
    }
  }
LABEL_14:
  if (*((_QWORD *)this + 33))
  {
    v9 = *((_QWORD *)this + 5);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 136315138;
      *(_QWORD *)((char *)&buf + 4) = "resumeDataContextIP";
      _os_log_impl(&dword_216897000, v9, OS_LOG_TYPE_DEFAULT, "#I %s: DeactivateDelayTimer already scheduled. Don't do anything. Let timer be fired", (uint8_t *)&buf, 0xCu);
    }
  }
}

void sub_216A0A3DC(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v1 - 64);
  _Unwind_Resume(a1);
}

void ___ZN20QMIDataContextIPBase19resumeDataContextIPEv_block_invoke(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  std::__shared_weak_count *v6;
  char v7;
  unint64_t *v8;
  unint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  std::__shared_weak_count *v13;
  uint64_t v14;
  NSObject *v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v21 = 136315138;
    v22 = "resumeIPv6TimerFired";
    _os_log_impl(&dword_216897000, v2, OS_LOG_TYPE_DEFAULT, "#I %s: IPv6Service: fIPv6ConfigTimer timer(resume) fired", (uint8_t *)&v21, 0xCu);
  }
  v3 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v1 + 104));
  if (((*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(v1 + 96) + 384))(*(_QWORD *)(v1 + 96), *(unsigned int *)(v1 + 140)) & 1) != 0)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
    goto LABEL_16;
  }
  v6 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v1 + 104));
  v7 = (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(v1 + 96) + 176))(*(_QWORD *)(v1 + 96), *(unsigned int *)(v1 + 140));
  v8 = (unint64_t *)&v6->__shared_owners_;
  do
    v9 = __ldaxr(v8);
  while (__stlxr(v9 - 1, v8));
  if (!v9)
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
  v10 = (unint64_t *)&v3->__shared_owners_;
  do
    v11 = __ldaxr(v10);
  while (__stlxr(v11 - 1, v10));
  if (v11)
  {
    if ((v7 & 1) != 0)
    {
LABEL_16:
      QMIDataContextIPBase::setDataContextIPState(v1, 2u);
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v1 + 336))(v1, 0);
      return;
    }
  }
  else
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    if ((v7 & 1) != 0)
      goto LABEL_16;
  }
  v12 = *(std::__shared_weak_count **)(v1 + 128);
  if (v12)
  {
    v13 = std::__shared_weak_count::lock(v12);
    if (v13)
    {
      v14 = *(_QWORD *)(v1 + 120);
      if (v14)
      {
        if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v14 + 72))(v14))
        {
          v15 = *(NSObject **)(v1 + 40);
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(v21) = 0;
            _os_log_impl(&dword_216897000, v15, OS_LOG_TYPE_DEFAULT, "#I IPv6Service: IPv6 configuration failed in marginal traffic conditions, let's try that later", (uint8_t *)&v21, 2u);
          }
          QMIDataContextIPBase::setDataContextIPState(v1, 2u);
          (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v1 + 336))(v1, 0);
LABEL_32:
          v19 = (unint64_t *)&v13->__shared_owners_;
          do
            v20 = __ldaxr(v19);
          while (__stlxr(v20 - 1, v19));
          if (!v20)
          {
            ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
            std::__shared_weak_count::__release_weak(v13);
          }
          return;
        }
      }
    }
  }
  else
  {
    v13 = 0;
  }
  QMIDataContextIPBase::clearIPv6ConfigTimer((QMIDataContextIPBase *)v1);
  v16 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v1 + 104));
  (*(void (**)(_QWORD))(**(_QWORD **)(v1 + 96) + 144))(*(_QWORD *)(v1 + 96));
  v17 = (unint64_t *)&v16->__shared_owners_;
  do
    v18 = __ldaxr(v17);
  while (__stlxr(v18 - 1, v17));
  if (!v18)
  {
    ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
    std::__shared_weak_count::__release_weak(v16);
  }
  if (v13)
    goto LABEL_32;
}

void sub_216A0A6C0(_Unwind_Exception *exception_object)
{
  std::__shared_weak_count *v1;
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v5;
  unint64_t *v6;
  unint64_t v7;

  p_shared_owners = (unint64_t *)&v2->__shared_owners_;
  do
    v5 = __ldaxr(p_shared_owners);
  while (__stlxr(v5 - 1, p_shared_owners));
  if (!v5)
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  if (v1)
  {
    v6 = (unint64_t *)&v1->__shared_owners_;
    do
      v7 = __ldaxr(v6);
    while (__stlxr(v7 - 1, v6));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
  _Unwind_Resume(exception_object);
}

void ___ZN20QMIDataContextIPBase19resumeDataContextIPEv_block_invoke_2(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  std::__shared_weak_count *v6;
  char v7;
  unint64_t *v8;
  unint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  std::__shared_weak_count *v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  int v19;
  const char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v19 = 136315138;
    v20 = "resumeIPv4TimerFired";
    _os_log_impl(&dword_216897000, v2, OS_LOG_TYPE_DEFAULT, "#I %s: IPv4Service: fIPv4ConfigTimer timer(resume) fired", (uint8_t *)&v19, 0xCu);
  }
  v3 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v1 + 104));
  if (((*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(v1 + 96) + 384))(*(_QWORD *)(v1 + 96), *(unsigned int *)(v1 + 140)) & 1) != 0)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
    goto LABEL_16;
  }
  v6 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v1 + 104));
  v7 = (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(v1 + 96) + 176))(*(_QWORD *)(v1 + 96), *(unsigned int *)(v1 + 140));
  v8 = (unint64_t *)&v6->__shared_owners_;
  do
    v9 = __ldaxr(v8);
  while (__stlxr(v9 - 1, v8));
  if (!v9)
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
  v10 = (unint64_t *)&v3->__shared_owners_;
  do
    v11 = __ldaxr(v10);
  while (__stlxr(v11 - 1, v10));
  if (v11)
  {
    if ((v7 & 1) != 0)
    {
LABEL_16:
      QMIDataContextIPBase::setDataContextIPState(v1, 2u);
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v1 + 336))(v1, 0);
      return;
    }
  }
  else
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    if ((v7 & 1) != 0)
      goto LABEL_16;
  }
  v12 = *(std::__shared_weak_count **)(v1 + 128);
  if (v12)
    v13 = std::__shared_weak_count::lock(v12);
  else
    v13 = 0;
  QMIDataContextIPBase::clearIPv4ConfigTimer((QMIDataContextIPBase *)v1);
  v14 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v1 + 104));
  (*(void (**)(_QWORD))(**(_QWORD **)(v1 + 96) + 144))(*(_QWORD *)(v1 + 96));
  v15 = (unint64_t *)&v14->__shared_owners_;
  do
    v16 = __ldaxr(v15);
  while (__stlxr(v16 - 1, v15));
  if (!v16)
  {
    ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
    std::__shared_weak_count::__release_weak(v14);
  }
  if (v13)
  {
    v17 = (unint64_t *)&v13->__shared_owners_;
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
}

void sub_216A0A9E4(_Unwind_Exception *exception_object)
{
  std::__shared_weak_count *v1;
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v5;
  unint64_t *v6;
  unint64_t v7;

  p_shared_owners = (unint64_t *)&v2->__shared_owners_;
  do
    v5 = __ldaxr(p_shared_owners);
  while (__stlxr(v5 - 1, p_shared_owners));
  if (!v5)
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  if (v1)
  {
    v6 = (unint64_t *)&v1->__shared_owners_;
    do
      v7 = __ldaxr(v6);
    while (__stlxr(v7 - 1, v6));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
  _Unwind_Resume(exception_object);
}

void QMIDataContextIPBase::resetDataContextIP(QMIDataContextIPBase *this)
{
  NSObject *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  NSObject *v10;
  uint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  _BYTE v15[22];
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  v2 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)v15 = 136315138;
    *(_QWORD *)&v15[4] = "resetDataContextIP";
    _os_log_impl(&dword_216897000, v2, OS_LOG_TYPE_DEFAULT, "#I %s: start", v15, 0xCu);
  }
  *((_DWORD *)this + 45) = -1;
  *((_WORD *)this + 88) = 0;
  v3 = *((_QWORD *)this + 33);
  *((_QWORD *)this + 33) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  switch((*(unsigned int (**)(QMIDataContextIPBase *))(*(_QWORD *)this + 96))(this))
  {
    case 1u:
      v10 = *((_QWORD *)this + 5);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        (*(void (**)(QMIDataContextIPBase *))(*(_QWORD *)this + 96))(this);
        v11 = asString();
        *(_DWORD *)v15 = 136315394;
        *(_QWORD *)&v15[4] = "resetDataContextIP";
        *(_WORD *)&v15[12] = 2080;
        *(_QWORD *)&v15[14] = v11;
        _os_log_impl(&dword_216897000, v10, OS_LOG_TYPE_DEFAULT, "#I %s: ERR: at wrong state %s", v15, 0x16u);
      }
      return;
    case 2u:
    case 5u:
      goto LABEL_12;
    case 3u:
    case 6u:
      if (QMIDataContextIPBase::transitionalStateMaskIP(this))
      {
        QMIDataContextIPBase::setDataContextIPState((uint64_t)this, 1u);
        v4 = std::__shared_weak_count::lock(*((std::__shared_weak_count **)this + 13));
        *(_QWORD *)v15 = *((_QWORD *)this + 12);
        *(_QWORD *)&v15[8] = v4;
        (*(void (**)(_QWORD, _QWORD, uint64_t, _QWORD, _QWORD, uint64_t, _QWORD))(**(_QWORD **)v15 + 64))(*(_QWORD *)v15, *((unsigned int *)this + 35), 18, 0, 0, 2, 0);
        p_shared_owners = (unint64_t *)&v4->__shared_owners_;
        do
          v6 = __ldaxr(p_shared_owners);
        while (__stlxr(v6 - 1, p_shared_owners));
        if (!v6)
        {
          ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
          std::__shared_weak_count::__release_weak(v4);
        }
      }
      else
      {
LABEL_12:
        QMIDataContextIPBase::setDataContextIPState((uint64_t)this, 0);
        v7 = std::__shared_weak_count::lock(*((std::__shared_weak_count **)this + 13));
        *(_QWORD *)v15 = *((_QWORD *)this + 12);
        *(_QWORD *)&v15[8] = v7;
        (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)v15 + 72))(*(_QWORD *)v15, *((unsigned int *)this + 35));
        v8 = (unint64_t *)&v7->__shared_owners_;
        do
          v9 = __ldaxr(v8);
        while (__stlxr(v9 - 1, v8));
        if (!v9)
        {
          ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
          std::__shared_weak_count::__release_weak(v7);
        }
      }
      goto LABEL_23;
    case 4u:
      QMIDataContextIPBase::setDataContextIPState((uint64_t)this, 1u);
      v12 = std::__shared_weak_count::lock(*((std::__shared_weak_count **)this + 13));
      *(_QWORD *)v15 = *((_QWORD *)this + 12);
      *(_QWORD *)&v15[8] = v12;
      (*(void (**)(_QWORD, _QWORD, uint64_t, _QWORD, _QWORD, uint64_t, _QWORD))(**(_QWORD **)v15 + 64))(*(_QWORD *)v15, *((unsigned int *)this + 35), 18, 0, 0, 2, 0);
      v13 = (unint64_t *)&v12->__shared_owners_;
      do
        v14 = __ldaxr(v13);
      while (__stlxr(v14 - 1, v13));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
LABEL_23:
      QMIDataContextIPBase::doneWithContext(this);
      break;
    default:
      return;
  }
}

void sub_216A0AD98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void QMIDataContextIPBase::activateFailureHandlingCompleteIP(QMIDataContextIPBase *this)
{
  NSObject *v2;
  int v3;
  const char *v4;
  uint64_t v5;

  v5 = *MEMORY[0x24BDAC8D0];
  v2 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v3 = 136315138;
    v4 = "activateFailureHandlingCompleteIP";
    _os_log_impl(&dword_216897000, v2, OS_LOG_TYPE_DEFAULT, "#I %s: start", (uint8_t *)&v3, 0xCu);
  }
  QMIDataContextIPBase::setDataContextIPState((uint64_t)this, 0);
}

void QMIDataContextIPBase::setPacketNotificationFilter(uint64_t a1, int a2, const __CFDictionary **a3)
{
  NSObject *v6;
  const __CFDictionary *v7;
  int v8;
  const __CFDictionary *v9;
  const __CFDictionary *v10;
  CFTypeID v11;
  const void **v12;
  NSObject *v13;
  int v14;
  const __CFDictionary *v15;
  const __CFDictionary *v16;
  CFTypeID v17;
  const void **v18;
  const __CFDictionary *Value;
  const __CFDictionary *v20;
  CFTypeID v21;
  const void **v22;
  const __CFDictionary *v23;
  const __CFDictionary *v24;
  CFTypeID v25;
  const void **v26;
  NSObject *v27;
  const char *v28;
  char *v29;
  char *v30;
  char *v31;
  char *v32;
  char *v33;
  char *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  _QWORD *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  _QWORD *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  _QWORD *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  _QWORD *v50;
  uint64_t v51;
  unint64_t v52;
  unint64_t v53;
  char *v54;
  uint64_t v55;
  unint64_t v56;
  unint64_t v57;
  char *v58;
  uint64_t v59;
  unint64_t v60;
  unint64_t v61;
  char *v62;
  uint64_t v63;
  unint64_t v64;
  unint64_t v65;
  char *v66;
  uint64_t *v67;
  char *v68;
  char *v69;
  char *v70;
  uint64_t v71;
  const __CFData *v72;
  const __CFData *v73;
  CFTypeID v74;
  const __CFData *v75;
  const __CFData *v76;
  CFTypeID v77;
  int *v78;
  int *v79;
  CFTypeID v80;
  int *v81;
  const __CFNumber *v82;
  int *v83;
  CFTypeID v84;
  int *TypeID;
  int *v86;
  CFTypeID v87;
  const __CFNumber *v88;
  uint64_t *v89;
  char *v90;
  char *v91;
  char *v92;
  uint64_t v93;
  const __CFData *v94;
  const __CFData *v95;
  CFTypeID v96;
  const __CFData *v97;
  const __CFData *v98;
  CFTypeID v99;
  int *v100;
  int *v101;
  CFTypeID v102;
  int *v103;
  const __CFNumber *v104;
  int *v105;
  CFTypeID v106;
  uint64_t *v107;
  char *v108;
  char *v109;
  char *v110;
  uint64_t v111;
  const __CFData *v112;
  const __CFData *v113;
  CFTypeID v114;
  const __CFData *v115;
  const __CFData *v116;
  CFTypeID v117;
  int *v118;
  int *v119;
  CFTypeID v120;
  int *v121;
  const __CFNumber *v122;
  int *v123;
  CFTypeID v124;
  int *v125;
  CFTypeID v126;
  const __CFNumber *v127;
  unsigned __int8 *v128;
  unsigned __int8 *v129;
  CFTypeID v130;
  char *v131;
  const __CFNumber *v132;
  void *v133;
  uint64_t *v134;
  char *v135;
  char *v136;
  char *v137;
  uint64_t v138;
  const __CFData *v139;
  const __CFData *v140;
  CFTypeID v141;
  const __CFData *v142;
  const __CFData *v143;
  CFTypeID v144;
  int *v145;
  int *v146;
  CFTypeID v147;
  int *v148;
  const __CFNumber *v149;
  int *v150;
  CFTypeID v151;
  void *v152;
  char *v153;
  char *v154;
  _QWORD v155[5];
  char v156;
  _QWORD v157[5];
  char v158;
  uint64_t v159;
  uint64_t v160;
  int v161;
  uint64_t v162;
  void *aBlock;
  __int128 v164;
  __int128 v165;
  _BYTE buf[24];
  void *v167;
  _QWORD *v168;
  uint64_t v169;

  v169 = *MEMORY[0x24BDAC8D0];
  v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315138;
    *(_QWORD *)&buf[4] = "setPacketNotificationFilter";
    _os_log_impl(&dword_216897000, v6, OS_LOG_TYPE_DEFAULT, "#I %s: start", buf, 0xCu);
  }
  if (*(_QWORD *)(a1 + 160))
  {
    v7 = *a3;
    if (!v7)
      return;
    if (a2)
    {
      v164 = 0uLL;
      v165 = 0uLL;
      qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)&v164);
      v8 = *(_DWORD *)(a1 + 140);
      if (v8 == 2)
      {
        Value = (const __CFDictionary *)CFDictionaryGetValue(v7, (const void *)*MEMORY[0x24BDC3E28]);
        v20 = Value;
        if (Value)
        {
          v21 = CFGetTypeID(Value);
          if (v21 == CFDictionaryGetTypeID())
          {
            v22 = (const void **)*((_QWORD *)&v164 + 1);
            if (*((_QWORD *)&v164 + 1) != (_QWORD)v165)
            {
              while (*((_BYTE *)*v22 + 8) != 17)
              {
                if (++v22 == (const void **)v165)
                  goto LABEL_69;
              }
            }
            if (v22 == (const void **)v165)
            {
LABEL_69:
              v43 = operator new();
              v44 = v43;
              *(_BYTE *)(v43 + 8) = 17;
              *(_OWORD *)(v43 + 12) = 0u;
              v154 = (char *)(v43 + 12);
              *(_QWORD *)v43 = &off_24D5DF9B8;
              *(_OWORD *)(v43 + 28) = 0u;
              *(_QWORD *)(v43 + 44) = 0;
              v45 = v165;
              if ((unint64_t)v165 >= *((_QWORD *)&v165 + 1))
              {
                v59 = (uint64_t)(v165 - *((_QWORD *)&v164 + 1)) >> 3;
                if ((unint64_t)(v59 + 1) >> 61)
                  std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
                v60 = (uint64_t)(*((_QWORD *)&v165 + 1) - *((_QWORD *)&v164 + 1)) >> 2;
                if (v60 <= v59 + 1)
                  v60 = v59 + 1;
                if (*((_QWORD *)&v165 + 1) - *((_QWORD *)&v164 + 1) >= 0x7FFFFFFFFFFFFFF8uLL)
                  v61 = 0x1FFFFFFFFFFFFFFFLL;
                else
                  v61 = v60;
                if (v61)
                  v62 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v165 + 8, v61);
                else
                  v62 = 0;
                v107 = (uint64_t *)&v62[8 * v59];
                v108 = &v62[8 * v61];
                *v107 = v44;
                v46 = v107 + 1;
                v110 = (char *)*((_QWORD *)&v164 + 1);
                v109 = (char *)v165;
                if ((_QWORD)v165 != *((_QWORD *)&v164 + 1))
                {
                  do
                  {
                    v111 = *((_QWORD *)v109 - 1);
                    v109 -= 8;
                    *--v107 = v111;
                  }
                  while (v109 != v110);
                  v109 = (char *)*((_QWORD *)&v164 + 1);
                }
                *((_QWORD *)&v164 + 1) = v107;
                *(_QWORD *)&v165 = v46;
                *((_QWORD *)&v165 + 1) = v108;
                if (v109)
                  operator delete(v109);
              }
              else
              {
                *(_QWORD *)v165 = v43;
                v46 = (_QWORD *)(v45 + 8);
              }
              *(_QWORD *)&v165 = v46;
            }
            else
            {
              if (!v32)
                __cxa_bad_cast();
              v154 = v32 + 12;
            }
            v112 = (const __CFData *)CFDictionaryGetValue(v20, (const void *)*MEMORY[0x24BDC3E40]);
            v113 = v112;
            if (v112)
            {
              v114 = CFGetTypeID(v112);
              if (v114 != CFDataGetTypeID())
                v113 = 0;
            }
            v115 = (const __CFData *)CFDictionaryGetValue(v20, (const void *)*MEMORY[0x24BDC3E00]);
            v116 = v115;
            if (v115)
            {
              v117 = CFGetTypeID(v115);
              if (v117 != CFDataGetTypeID())
                v116 = 0;
            }
            v118 = (int *)CFDictionaryGetValue(v20, (const void *)*MEMORY[0x24BDC3E48]);
            v119 = v118;
            if (v118)
            {
              v120 = CFGetTypeID(v118);
              if (v120 != CFNumberGetTypeID())
                v119 = 0;
            }
            v121 = (int *)CFDictionaryGetValue(v20, (const void *)*MEMORY[0x24BDC3E08]);
            v123 = v121;
            if (v121)
            {
              v124 = CFGetTypeID(v121);
              if (v124 != CFNumberGetTypeID())
                v123 = 0;
            }
            if (v113 && CFDataGetLength(v113) == 16)
              *(_OWORD *)v154 = *(_OWORD *)CFDataGetBytePtr(v113);
            if (v116 && CFDataGetLength(v116) == 16)
              *((_OWORD *)v154 + 1) = *(_OWORD *)CFDataGetBytePtr(v116);
            if (v119)
            {
              *(_DWORD *)buf = 0;
              ctu::cf::assign((ctu::cf *)buf, v119, v122);
              *((_WORD *)v154 + 16) = *(_WORD *)buf;
            }
            if (v123)
            {
              *(_DWORD *)buf = 0;
              ctu::cf::assign((ctu::cf *)buf, v123, v122);
              *((_WORD *)v154 + 17) = *(_WORD *)buf;
            }
            TypeID = (int *)CFDictionaryGetValue(v20, (const void *)*MEMORY[0x24BDC3E60]);
            v125 = TypeID;
            if (TypeID)
            {
              v126 = CFGetTypeID(TypeID);
              TypeID = (int *)CFNumberGetTypeID();
              if ((int *)v126 == TypeID)
              {
                *(_DWORD *)buf = 0;
                TypeID = (int *)ctu::cf::assign((ctu::cf *)buf, v125, v127);
                *((_DWORD *)v154 + 9) = *(_DWORD *)buf;
              }
            }
            goto LABEL_198;
          }
        }
        v27 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315138;
          *(_QWORD *)&buf[4] = "setPacketNotificationFilter";
          v28 = "#I %s: no IPv6 is present in the request, not sending anything";
          goto LABEL_52;
        }
        goto LABEL_239;
      }
      if (v8 == 1)
      {
        v9 = (const __CFDictionary *)CFDictionaryGetValue(v7, (const void *)*MEMORY[0x24BDC3E20]);
        v10 = v9;
        if (v9)
        {
          v11 = CFGetTypeID(v9);
          if (v11 == CFDictionaryGetTypeID())
          {
            v12 = (const void **)*((_QWORD *)&v164 + 1);
            if (*((_QWORD *)&v164 + 1) != (_QWORD)v165)
            {
              while (*((_BYTE *)*v12 + 8) != 16)
              {
                if (++v12 == (const void **)v165)
                  goto LABEL_65;
              }
            }
            if (v12 == (const void **)v165)
            {
LABEL_65:
              v35 = operator new();
              v36 = v35;
              *(_BYTE *)(v35 + 8) = 16;
              *(_QWORD *)v35 = &off_24D5DF968;
              *(_QWORD *)(v35 + 12) = 0;
              v153 = (char *)(v35 + 12);
              *(_QWORD *)(v35 + 20) = 0;
              v37 = v165;
              if ((unint64_t)v165 >= *((_QWORD *)&v165 + 1))
              {
                v51 = (uint64_t)(v165 - *((_QWORD *)&v164 + 1)) >> 3;
                if ((unint64_t)(v51 + 1) >> 61)
                  std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
                v52 = (uint64_t)(*((_QWORD *)&v165 + 1) - *((_QWORD *)&v164 + 1)) >> 2;
                if (v52 <= v51 + 1)
                  v52 = v51 + 1;
                if (*((_QWORD *)&v165 + 1) - *((_QWORD *)&v164 + 1) >= 0x7FFFFFFFFFFFFFF8uLL)
                  v53 = 0x1FFFFFFFFFFFFFFFLL;
                else
                  v53 = v52;
                if (v53)
                  v54 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v165 + 8, v53);
                else
                  v54 = 0;
                v67 = (uint64_t *)&v54[8 * v51];
                v68 = &v54[8 * v53];
                *v67 = v36;
                v38 = v67 + 1;
                v70 = (char *)*((_QWORD *)&v164 + 1);
                v69 = (char *)v165;
                if ((_QWORD)v165 != *((_QWORD *)&v164 + 1))
                {
                  do
                  {
                    v71 = *((_QWORD *)v69 - 1);
                    v69 -= 8;
                    *--v67 = v71;
                  }
                  while (v69 != v70);
                  v69 = (char *)*((_QWORD *)&v164 + 1);
                }
                *((_QWORD *)&v164 + 1) = v67;
                *(_QWORD *)&v165 = v38;
                *((_QWORD *)&v165 + 1) = v68;
                if (v69)
                  operator delete(v69);
              }
              else
              {
                *(_QWORD *)v165 = v35;
                v38 = (_QWORD *)(v37 + 8);
              }
              *(_QWORD *)&v165 = v38;
            }
            else
            {
              if (!v29)
                __cxa_bad_cast();
              v153 = v29 + 12;
            }
            v72 = (const __CFData *)CFDictionaryGetValue(v10, (const void *)*MEMORY[0x24BDC3E40]);
            v73 = v72;
            if (v72)
            {
              v74 = CFGetTypeID(v72);
              if (v74 != CFDataGetTypeID())
                v73 = 0;
            }
            v75 = (const __CFData *)CFDictionaryGetValue(v10, (const void *)*MEMORY[0x24BDC3E00]);
            v76 = v75;
            if (v75)
            {
              v77 = CFGetTypeID(v75);
              if (v77 != CFDataGetTypeID())
                v76 = 0;
            }
            v78 = (int *)CFDictionaryGetValue(v10, (const void *)*MEMORY[0x24BDC3E48]);
            v79 = v78;
            if (v78)
            {
              v80 = CFGetTypeID(v78);
              if (v80 != CFNumberGetTypeID())
                v79 = 0;
            }
            v81 = (int *)CFDictionaryGetValue(v10, (const void *)*MEMORY[0x24BDC3E08]);
            v83 = v81;
            if (v81)
            {
              v84 = CFGetTypeID(v81);
              if (v84 != CFNumberGetTypeID())
                v83 = 0;
            }
            if (v73 && CFDataGetLength(v73) == 4)
              *(_DWORD *)v153 = *(_DWORD *)CFDataGetBytePtr(v73);
            if (v76 && CFDataGetLength(v76) == 4)
              *((_DWORD *)v153 + 1) = *(_DWORD *)CFDataGetBytePtr(v76);
            if (v79)
            {
              *(_DWORD *)buf = 0;
              ctu::cf::assign((ctu::cf *)buf, v79, v82);
              *((_WORD *)v153 + 4) = *(_WORD *)buf;
            }
            if (v83)
            {
              *(_DWORD *)buf = 0;
              ctu::cf::assign((ctu::cf *)buf, v83, v82);
              *((_WORD *)v153 + 5) = *(_WORD *)buf;
            }
            TypeID = (int *)CFDictionaryGetValue(v10, (const void *)*MEMORY[0x24BDC3E60]);
            v86 = TypeID;
            if (TypeID)
            {
              v87 = CFGetTypeID(TypeID);
              TypeID = (int *)CFNumberGetTypeID();
              if ((int *)v87 == TypeID)
              {
                *(_DWORD *)buf = 0;
                TypeID = (int *)ctu::cf::assign((ctu::cf *)buf, v86, v88);
                *((_DWORD *)v153 + 3) = *(_DWORD *)buf;
              }
            }
LABEL_198:
            if (capabilities::ct::supportsPacketFilterCallType((capabilities::ct *)TypeID))
            {
              v128 = (unsigned __int8 *)CFDictionaryGetValue(v7, (const void *)*MEMORY[0x24BDC3DF8]);
              v129 = v128;
              if (v128)
              {
                v130 = CFGetTypeID(v128);
                if (v130 == CFNumberGetTypeID())
                {
                  v131 = qmi::MutableMessageBase::getTLV<wds::tlv::FilterCallType>(&v164);
                  buf[0] = 0;
                  ctu::cf::assign((ctu::cf *)buf, v129, v132);
                  *v131 = buf[0];
                }
              }
            }
            v159 = a1 + 144;
            v160 = QMIServiceMsg::create();
            v161 = 25000;
            v162 = 0;
            aBlock = 0;
            v157[0] = MEMORY[0x24BDAC760];
            v157[1] = 0x40000000;
            v157[2] = ___ZN20QMIDataContextIPBase27setPacketNotificationFilterEbN3ctu2cf11CFSharedRefIK14__CFDictionaryEE_block_invoke_2;
            v157[3] = &__block_descriptor_tmp_201;
            v157[4] = a1;
            v158 = a2;
            *(_QWORD *)buf = MEMORY[0x24BDAC760];
            *(_QWORD *)&buf[8] = 0x40000000;
            *(_QWORD *)&buf[16] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_23;
            v167 = &unk_24D5DF608;
            v168 = v157;
            v133 = _Block_copy(buf);
            aBlock = v133;
            if (v160)
            {
              qmi::Client::send();
              v133 = aBlock;
            }
            if (v133)
              _Block_release(v133);
            goto LABEL_239;
          }
        }
        v27 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315138;
          *(_QWORD *)&buf[4] = "setPacketNotificationFilter";
          v28 = "#I %s: no IPv4 is present in the request, not sending anything";
LABEL_52:
          _os_log_impl(&dword_216897000, v27, OS_LOG_TYPE_DEFAULT, v28, buf, 0xCu);
          goto LABEL_239;
        }
        goto LABEL_239;
      }
      if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = "wrong ip family";
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "/Library/Caches/com.apple.xbs/Sources/CoreTelephony/CommCenter/CommCenterCommandDrivers/Da"
                              "ta/QMI/Context/QMIDataContextIPBase.cpp";
        *(_WORD *)&buf[22] = 1024;
        LODWORD(v167) = 2487;
        _os_log_error_impl(&dword_216897000, MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR, "\n**********\n   ASSERT fIpFamilyType == kDataProtocolFamilyIPv4 || fIpFamilyType == kDataProtocolFamilyIPv6\n %s\n at %s:%d\n**********", buf, 0x1Cu);
        v8 = *(_DWORD *)(a1 + 140);
      }
      if ((v8 - 1) < 2)
        goto LABEL_239;
LABEL_39:
      __TUAssertTrigger();
      goto LABEL_239;
    }
    v164 = 0uLL;
    v165 = 0uLL;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)&v164);
    v14 = *(_DWORD *)(a1 + 140);
    if (v14 == 2)
    {
      v23 = (const __CFDictionary *)CFDictionaryGetValue(v7, (const void *)*MEMORY[0x24BDC3E28]);
      v24 = v23;
      if (!v23 || (v25 = CFGetTypeID(v23), v25 != CFDictionaryGetTypeID()))
      {
        v27 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315138;
          *(_QWORD *)&buf[4] = "setPacketNotificationFilter";
          v28 = "#I %s: no IPv6 is present in the request, not sending anything";
          goto LABEL_52;
        }
        goto LABEL_239;
      }
      v26 = (const void **)*((_QWORD *)&v164 + 1);
      if (*((_QWORD *)&v164 + 1) != (_QWORD)v165)
      {
        while (*((_BYTE *)*v26 + 8) != 17)
        {
          if (++v26 == (const void **)v165)
            goto LABEL_71;
        }
      }
      if (v26 == (const void **)v165)
      {
LABEL_71:
        v47 = operator new();
        v48 = v47;
        *(_BYTE *)(v47 + 8) = 17;
        *(_OWORD *)(v47 + 10) = 0u;
        v34 = (char *)(v47 + 10);
        *(_QWORD *)v47 = &off_24D5DFAA8;
        *(_OWORD *)(v47 + 26) = 0u;
        *(_DWORD *)(v47 + 42) = 0;
        v49 = v165;
        if ((unint64_t)v165 >= *((_QWORD *)&v165 + 1))
        {
          v63 = (uint64_t)(v165 - *((_QWORD *)&v164 + 1)) >> 3;
          if ((unint64_t)(v63 + 1) >> 61)
            std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
          v64 = (uint64_t)(*((_QWORD *)&v165 + 1) - *((_QWORD *)&v164 + 1)) >> 2;
          if (v64 <= v63 + 1)
            v64 = v63 + 1;
          if (*((_QWORD *)&v165 + 1) - *((_QWORD *)&v164 + 1) >= 0x7FFFFFFFFFFFFFF8uLL)
            v65 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v65 = v64;
          if (v65)
            v66 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v165 + 8, v65);
          else
            v66 = 0;
          v134 = (uint64_t *)&v66[8 * v63];
          v135 = &v66[8 * v65];
          *v134 = v48;
          v50 = v134 + 1;
          v137 = (char *)*((_QWORD *)&v164 + 1);
          v136 = (char *)v165;
          if ((_QWORD)v165 != *((_QWORD *)&v164 + 1))
          {
            do
            {
              v138 = *((_QWORD *)v136 - 1);
              v136 -= 8;
              *--v134 = v138;
            }
            while (v136 != v137);
            v136 = (char *)*((_QWORD *)&v164 + 1);
          }
          *((_QWORD *)&v164 + 1) = v134;
          *(_QWORD *)&v165 = v50;
          *((_QWORD *)&v165 + 1) = v135;
          if (v136)
            operator delete(v136);
        }
        else
        {
          *(_QWORD *)v165 = v47;
          v50 = (_QWORD *)(v49 + 8);
        }
        *(_QWORD *)&v165 = v50;
      }
      else
      {
        if (!v33)
          __cxa_bad_cast();
        v34 = v33 + 10;
      }
      v139 = (const __CFData *)CFDictionaryGetValue(v24, (const void *)*MEMORY[0x24BDC3E40]);
      v140 = v139;
      if (v139)
      {
        v141 = CFGetTypeID(v139);
        if (v141 != CFDataGetTypeID())
          v140 = 0;
      }
      v142 = (const __CFData *)CFDictionaryGetValue(v24, (const void *)*MEMORY[0x24BDC3E00]);
      v143 = v142;
      if (v142)
      {
        v144 = CFGetTypeID(v142);
        if (v144 != CFDataGetTypeID())
          v143 = 0;
      }
      v145 = (int *)CFDictionaryGetValue(v24, (const void *)*MEMORY[0x24BDC3E48]);
      v146 = v145;
      if (v145)
      {
        v147 = CFGetTypeID(v145);
        if (v147 != CFNumberGetTypeID())
          v146 = 0;
      }
      v148 = (int *)CFDictionaryGetValue(v24, (const void *)*MEMORY[0x24BDC3E08]);
      v150 = v148;
      if (v148)
      {
        v151 = CFGetTypeID(v148);
        if (v151 != CFNumberGetTypeID())
          v150 = 0;
      }
      if (v140 && CFDataGetLength(v140) == 16)
        *(_OWORD *)v34 = *(_OWORD *)CFDataGetBytePtr(v140);
      if (v143 && CFDataGetLength(v143) == 16)
        *((_OWORD *)v34 + 1) = *(_OWORD *)CFDataGetBytePtr(v143);
      if (v146)
      {
        *(_DWORD *)buf = 0;
        ctu::cf::assign((ctu::cf *)buf, v146, v149);
        *((_WORD *)v34 + 16) = *(_WORD *)buf;
      }
      if (v150)
      {
        *(_DWORD *)buf = 0;
        ctu::cf::assign((ctu::cf *)buf, v150, v149);
        *((_WORD *)v34 + 17) = *(_WORD *)buf;
      }
    }
    else
    {
      if (v14 != 1)
      {
        if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315650;
          *(_QWORD *)&buf[4] = "wrong ip family";
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "/Library/Caches/com.apple.xbs/Sources/CoreTelephony/CommCenter/CommCenterCommandDrivers/"
                                "Data/QMI/Context/QMIDataContextIPBase.cpp";
          *(_WORD *)&buf[22] = 1024;
          LODWORD(v167) = 2548;
          _os_log_error_impl(&dword_216897000, MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR, "\n**********\n   ASSERT fIpFamilyType == kDataProtocolFamilyIPv4 || fIpFamilyType == kDataProtocolFamilyIPv6\n %s\n at %s:%d\n**********", buf, 0x1Cu);
          v14 = *(_DWORD *)(a1 + 140);
        }
        if ((v14 - 1) < 2)
          goto LABEL_239;
        goto LABEL_39;
      }
      v15 = (const __CFDictionary *)CFDictionaryGetValue(v7, (const void *)*MEMORY[0x24BDC3E20]);
      v16 = v15;
      if (!v15 || (v17 = CFGetTypeID(v15), v17 != CFDictionaryGetTypeID()))
      {
        v27 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315138;
          *(_QWORD *)&buf[4] = "setPacketNotificationFilter";
          v28 = "#I %s: no IPv4 is present in the request, not sending anything";
          goto LABEL_52;
        }
LABEL_239:
        qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&v164);
        return;
      }
      v18 = (const void **)*((_QWORD *)&v164 + 1);
      if (*((_QWORD *)&v164 + 1) != (_QWORD)v165)
      {
        while (*((_BYTE *)*v18 + 8) != 16)
        {
          if (++v18 == (const void **)v165)
            goto LABEL_67;
        }
      }
      if (v18 == (const void **)v165)
      {
LABEL_67:
        v39 = operator new();
        v40 = v39;
        *(_BYTE *)(v39 + 8) = 16;
        *(_QWORD *)v39 = &off_24D5DFA58;
        *(_QWORD *)(v39 + 10) = 0;
        v31 = (char *)(v39 + 10);
        *(_DWORD *)(v39 + 18) = 0;
        v41 = v165;
        if ((unint64_t)v165 >= *((_QWORD *)&v165 + 1))
        {
          v55 = (uint64_t)(v165 - *((_QWORD *)&v164 + 1)) >> 3;
          if ((unint64_t)(v55 + 1) >> 61)
            std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
          v56 = (uint64_t)(*((_QWORD *)&v165 + 1) - *((_QWORD *)&v164 + 1)) >> 2;
          if (v56 <= v55 + 1)
            v56 = v55 + 1;
          if (*((_QWORD *)&v165 + 1) - *((_QWORD *)&v164 + 1) >= 0x7FFFFFFFFFFFFFF8uLL)
            v57 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v57 = v56;
          if (v57)
            v58 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v165 + 8, v57);
          else
            v58 = 0;
          v89 = (uint64_t *)&v58[8 * v55];
          v90 = &v58[8 * v57];
          *v89 = v40;
          v42 = v89 + 1;
          v92 = (char *)*((_QWORD *)&v164 + 1);
          v91 = (char *)v165;
          if ((_QWORD)v165 != *((_QWORD *)&v164 + 1))
          {
            do
            {
              v93 = *((_QWORD *)v91 - 1);
              v91 -= 8;
              *--v89 = v93;
            }
            while (v91 != v92);
            v91 = (char *)*((_QWORD *)&v164 + 1);
          }
          *((_QWORD *)&v164 + 1) = v89;
          *(_QWORD *)&v165 = v42;
          *((_QWORD *)&v165 + 1) = v90;
          if (v91)
            operator delete(v91);
        }
        else
        {
          *(_QWORD *)v165 = v39;
          v42 = (_QWORD *)(v41 + 8);
        }
        *(_QWORD *)&v165 = v42;
      }
      else
      {
        if (!v30)
          __cxa_bad_cast();
        v31 = v30 + 10;
      }
      v94 = (const __CFData *)CFDictionaryGetValue(v16, (const void *)*MEMORY[0x24BDC3E40]);
      v95 = v94;
      if (v94)
      {
        v96 = CFGetTypeID(v94);
        if (v96 != CFDataGetTypeID())
          v95 = 0;
      }
      v97 = (const __CFData *)CFDictionaryGetValue(v16, (const void *)*MEMORY[0x24BDC3E00]);
      v98 = v97;
      if (v97)
      {
        v99 = CFGetTypeID(v97);
        if (v99 != CFDataGetTypeID())
          v98 = 0;
      }
      v100 = (int *)CFDictionaryGetValue(v16, (const void *)*MEMORY[0x24BDC3E48]);
      v101 = v100;
      if (v100)
      {
        v102 = CFGetTypeID(v100);
        if (v102 != CFNumberGetTypeID())
          v101 = 0;
      }
      v103 = (int *)CFDictionaryGetValue(v16, (const void *)*MEMORY[0x24BDC3E08]);
      v105 = v103;
      if (v103)
      {
        v106 = CFGetTypeID(v103);
        if (v106 != CFNumberGetTypeID())
          v105 = 0;
      }
      if (v95 && CFDataGetLength(v95) == 4)
        *(_DWORD *)v31 = *(_DWORD *)CFDataGetBytePtr(v95);
      if (v98 && CFDataGetLength(v98) == 4)
        *((_DWORD *)v31 + 1) = *(_DWORD *)CFDataGetBytePtr(v98);
      if (v101)
      {
        *(_DWORD *)buf = 0;
        ctu::cf::assign((ctu::cf *)buf, v101, v104);
        *((_WORD *)v31 + 4) = *(_WORD *)buf;
      }
      if (v105)
      {
        *(_DWORD *)buf = 0;
        ctu::cf::assign((ctu::cf *)buf, v105, v104);
        *((_WORD *)v31 + 5) = *(_WORD *)buf;
      }
    }
    v159 = a1 + 144;
    v160 = QMIServiceMsg::create();
    v161 = 25000;
    v162 = 0;
    aBlock = 0;
    v155[0] = MEMORY[0x24BDAC760];
    v155[1] = 0x40000000;
    v155[2] = ___ZN20QMIDataContextIPBase27setPacketNotificationFilterEbN3ctu2cf11CFSharedRefIK14__CFDictionaryEE_block_invoke_206;
    v155[3] = &__block_descriptor_tmp_207_0;
    v155[4] = a1;
    v156 = 0;
    *(_QWORD *)buf = MEMORY[0x24BDAC760];
    *(_QWORD *)&buf[8] = 0x40000000;
    *(_QWORD *)&buf[16] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_23;
    v167 = &unk_24D5DF608;
    v168 = v155;
    v152 = _Block_copy(buf);
    aBlock = v152;
    if (v160)
    {
      qmi::Client::send();
      v152 = aBlock;
    }
    if (v152)
      _Block_release(v152);
    goto LABEL_239;
  }
  v13 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl(&dword_216897000, v13, OS_LOG_TYPE_ERROR, "setPacketNotificationFilter with NULL fWDSClient", buf, 2u);
  }
}

void sub_216A0C028(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a27);
  _Unwind_Resume(a1);
}

void ___ZN20QMIDataContextIPBase27setPacketNotificationFilterEbN3ctu2cf11CFSharedRefIK14__CFDictionaryEE_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v4;
  NSObject *v5;
  _BOOL4 v6;
  const char *v7;
  NSObject *v8;
  uint32_t v9;
  int v10;
  int v11;
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)(v2 + 257))
  {
    v4 = *(_DWORD *)(a2 + 4);
    v5 = *(NSObject **)(v2 + 40);
    v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
    if (v4)
    {
      if (!v6)
        return;
      v11 = 136315650;
      v12 = "setPacketNotificationFilter_block_invoke";
      v13 = 1024;
      v14 = v4;
      v15 = 2080;
      v16 = qmi::asString();
      v7 = "#I %s: RegisterDataNotificationFilter:Error in response with code = 0x%x (%s)";
      v8 = v5;
      v9 = 28;
    }
    else
    {
      if (!v6)
        return;
      v10 = *(unsigned __int8 *)(a1 + 40);
      v11 = 136315394;
      v12 = "setPacketNotificationFilter_block_invoke_2";
      v13 = 1024;
      v14 = v10;
      v7 = "#I %s: RegisterDataNotificationFilter: No Error. Enable = %d";
      v8 = v5;
      v9 = 18;
    }
    _os_log_impl(&dword_216897000, v8, OS_LOG_TYPE_DEFAULT, v7, (uint8_t *)&v11, v9);
  }
}

void ___ZN20QMIDataContextIPBase27setPacketNotificationFilterEbN3ctu2cf11CFSharedRefIK14__CFDictionaryEE_block_invoke_206(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v4;
  NSObject *v5;
  _BOOL4 v6;
  const char *v7;
  NSObject *v8;
  uint32_t v9;
  int v10;
  int v11;
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)(v2 + 257))
  {
    v4 = *(_DWORD *)(a2 + 4);
    v5 = *(NSObject **)(v2 + 40);
    v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
    if (v4)
    {
      if (!v6)
        return;
      v11 = 136315650;
      v12 = "setPacketNotificationFilter_block_invoke";
      v13 = 1024;
      v14 = v4;
      v15 = 2080;
      v16 = qmi::asString();
      v7 = "#I %s: DeregisterDataNotificationFilter:Error in response with code = 0x%x (%s)";
      v8 = v5;
      v9 = 28;
    }
    else
    {
      if (!v6)
        return;
      v10 = *(unsigned __int8 *)(a1 + 40);
      v11 = 136315394;
      v12 = "setPacketNotificationFilter_block_invoke";
      v13 = 1024;
      v14 = v10;
      v7 = "#I %s: DeregisterDataNotificationFilter: No Error. Enable = %d";
      v8 = v5;
      v9 = 18;
    }
    _os_log_impl(&dword_216897000, v8, OS_LOG_TYPE_DEFAULT, v7, (uint8_t *)&v11, v9);
  }
}

void QMIDataContextIPBase::dropIPPackets(uint64_t a1, const __CFArray **a2, int a3)
{
  NSObject *v6;
  const __CFArray *v7;
  CFIndex Count;
  char v9;
  CFIndex v10;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v12;
  CFTypeID v13;
  int *Value;
  int *v15;
  CFTypeID v16;
  const __CFNumber *v17;
  int v18;
  int v19;
  int *v20;
  int *v21;
  CFTypeID v22;
  const __CFNumber *v23;
  char v24;
  int *v25;
  int *v26;
  CFTypeID v27;
  const __CFNumber *v28;
  char v29;
  int *v30;
  int *v31;
  CFTypeID v32;
  const __CFNumber *v33;
  int *v34;
  int *v35;
  CFTypeID v36;
  const __CFNumber *v37;
  int *v38;
  int *v39;
  CFTypeID v40;
  const __CFNumber *v41;
  __int16 v42;
  int *v43;
  int *v44;
  CFTypeID v45;
  const __CFNumber *v46;
  char v47;
  __int16 v48;
  int *v49;
  int *v50;
  CFTypeID v51;
  const __CFNumber *v52;
  int v53;
  const void **v54;
  void **v55;
  uint64_t v56;
  uint64_t v57;
  void **v58;
  uint64_t v59;
  _QWORD *v60;
  uint64_t v61;
  unint64_t v62;
  unint64_t v63;
  char *v64;
  uint64_t *v65;
  char *v66;
  char *v67;
  uint64_t v68;
  NSObject *v70;
  void *v71;
  NSObject *v72;
  uint64_t v73;
  __int16 v74;
  char v75;
  __int16 v76;
  __int16 v77;
  void *v78;
  void *v79;
  void *v80;
  void *v81;
  void *v82;
  void *v83;
  void *v84;
  void *key;
  _QWORD v86[6];
  uint64_t v87;
  int v88;
  uint64_t v89;
  void *aBlock;
  _QWORD v91[2];
  void (*v92)(uint64_t, void **);
  void *v93;
  char v94;
  char v95;
  __int16 v96;
  __int16 v97;
  __int16 v98;
  __int16 v99;
  __int16 v100;
  int v101;
  __int128 v102;
  __int128 v103;
  _BYTE buf[24];
  void *v105;
  _QWORD *v106;
  uint64_t v107;

  v107 = *MEMORY[0x24BDAC8D0];
  v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315138;
    *(_QWORD *)&buf[4] = "dropIPPackets";
    _os_log_impl(&dword_216897000, v6, OS_LOG_TYPE_DEFAULT, "#I %s: start", buf, 0xCu);
  }
  if (*(_QWORD *)(a1 + 160))
  {
    v7 = *a2;
    if (v7)
    {
      Count = CFArrayGetCount(v7);
      v102 = 0u;
      v103 = 0u;
      qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)&v102);
      if (Count < 1)
      {
LABEL_87:
        v72 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT))
        {
          v73 = asString();
          *(_DWORD *)buf = 136315394;
          *(_QWORD *)&buf[4] = "dropIPPackets";
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = v73;
          _os_log_impl(&dword_216897000, v72, OS_LOG_TYPE_DEFAULT, "#I %s: Not found any records matching %s protocol. Message not sent", buf, 0x16u);
        }
      }
      else
      {
        v9 = 0;
        v10 = 0;
        key = (void *)*MEMORY[0x24BDC3E18];
        v84 = (void *)*MEMORY[0x24BDC3E38];
        v83 = (void *)*MEMORY[0x24BDC3E30];
        v82 = (void *)*MEMORY[0x24BDC3E48];
        v81 = (void *)*MEMORY[0x24BDC3E08];
        v80 = (void *)*MEMORY[0x24BDC3E58];
        v79 = (void *)*MEMORY[0x24BDC3E10];
        v78 = (void *)*MEMORY[0x24BDC3E50];
        do
        {
          while (1)
          {
            ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v7, v10);
            v12 = ValueAtIndex;
            if (!ValueAtIndex)
              break;
            v13 = CFGetTypeID(ValueAtIndex);
            if (v13 != CFDictionaryGetTypeID())
              break;
            Value = (int *)CFDictionaryGetValue(v12, key);
            v15 = Value;
            if (Value && (v16 = CFGetTypeID(Value), v16 == CFNumberGetTypeID()))
            {
              *(_DWORD *)buf = 0;
              ctu::cf::assign((ctu::cf *)buf, v15, v17);
              if (*(_DWORD *)buf == 2)
                v18 = 2;
              else
                v18 = 1;
              if (*(_DWORD *)buf == 2)
                v19 = 0;
              else
                v19 = a3;
            }
            else
            {
              v18 = 1;
              v19 = a3;
            }
            if (a3)
              v18 = 2;
            if (v18 != *(_DWORD *)(a1 + 140))
              break;
            v20 = (int *)CFDictionaryGetValue(v12, v84);
            v21 = v20;
            if (v20 && (v22 = CFGetTypeID(v20), v22 == CFNumberGetTypeID()))
            {
              *(_DWORD *)buf = 0;
              ctu::cf::assign((ctu::cf *)buf, v21, v23);
              v24 = buf[0];
            }
            else
            {
              v24 = 0;
            }
            v25 = (int *)CFDictionaryGetValue(v12, v83);
            v26 = v25;
            if (v25 && (v27 = CFGetTypeID(v25), v27 == CFNumberGetTypeID()))
            {
              *(_DWORD *)buf = 0;
              ctu::cf::assign((ctu::cf *)buf, v26, v28);
              if (v19)
                v29 = buf[0] + 20;
              else
                v29 = buf[0];
            }
            else
            {
              v29 = 0;
            }
            v30 = (int *)CFDictionaryGetValue(v12, v82);
            v31 = v30;
            if (v30 && (v32 = CFGetTypeID(v30), v32 == CFNumberGetTypeID()))
            {
              *(_DWORD *)buf = 0;
              ctu::cf::assign((ctu::cf *)buf, v31, v33);
              v77 = *(_WORD *)buf;
            }
            else
            {
              v77 = 0;
            }
            v34 = (int *)CFDictionaryGetValue(v12, v81);
            v35 = v34;
            if (v34 && (v36 = CFGetTypeID(v34), v36 == CFNumberGetTypeID()))
            {
              *(_DWORD *)buf = 0;
              ctu::cf::assign((ctu::cf *)buf, v35, v37);
              v76 = *(_WORD *)buf;
            }
            else
            {
              v76 = 0;
            }
            v38 = (int *)CFDictionaryGetValue(v12, v80);
            v39 = v38;
            v75 = v24;
            if (v38 && (v40 = CFGetTypeID(v38), v40 == CFNumberGetTypeID()))
            {
              *(_DWORD *)buf = 0;
              ctu::cf::assign((ctu::cf *)buf, v39, v41);
              v42 = *(_WORD *)buf;
            }
            else
            {
              v42 = 0;
            }
            v43 = (int *)CFDictionaryGetValue(v12, v79);
            v44 = v43;
            v74 = v42;
            if (v43 && (v45 = CFGetTypeID(v43), v45 == CFNumberGetTypeID()))
            {
              *(_DWORD *)buf = 0;
              ctu::cf::assign((ctu::cf *)buf, v44, v46);
              v47 = v29;
              v48 = *(_WORD *)buf;
            }
            else
            {
              v47 = v29;
              v48 = 0;
            }
            v49 = (int *)CFDictionaryGetValue(v12, v78);
            v50 = v49;
            if (v49 && (v51 = CFGetTypeID(v49), v51 == CFNumberGetTypeID()))
            {
              *(_DWORD *)buf = 0;
              ctu::cf::assign((ctu::cf *)buf, v50, v52);
              v53 = *(_DWORD *)buf;
            }
            else
            {
              v53 = 0;
            }
            v91[0] = MEMORY[0x24BDAC760];
            v91[1] = 0x40000000;
            v92 = ___ZN20QMIDataContextIPBase13dropIPPacketsEN3ctu2cf11CFSharedRefIK9__CFArrayEEb_block_invoke;
            v93 = &__block_descriptor_tmp_208;
            v94 = v75;
            v95 = v47;
            v96 = v77;
            v97 = v76;
            v98 = v74;
            v99 = v48;
            v100 = 0;
            v101 = v53;
            v54 = (const void **)*((_QWORD *)&v102 + 1);
            if (*((_QWORD *)&v102 + 1) != (_QWORD)v103)
            {
              while (*((_BYTE *)*v54 + 8) != 1)
              {
                if (++v54 == (const void **)v103)
                  goto LABEL_60;
              }
            }
            if (v54 == (const void **)v103)
            {
LABEL_60:
              v56 = operator new();
              v57 = v56;
              *(_BYTE *)(v56 + 8) = 1;
              *(_QWORD *)(v56 + 16) = 0;
              v58 = (void **)(v56 + 16);
              *(_QWORD *)v56 = &off_24D5DFAF8;
              *(_QWORD *)(v56 + 24) = 0;
              *(_QWORD *)(v56 + 32) = 0;
              v59 = v103;
              if ((unint64_t)v103 >= *((_QWORD *)&v103 + 1))
              {
                v61 = (uint64_t)(v103 - *((_QWORD *)&v102 + 1)) >> 3;
                if ((unint64_t)(v61 + 1) >> 61)
                  std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
                v62 = (uint64_t)(*((_QWORD *)&v103 + 1) - *((_QWORD *)&v102 + 1)) >> 2;
                if (v62 <= v61 + 1)
                  v62 = v61 + 1;
                if (*((_QWORD *)&v103 + 1) - *((_QWORD *)&v102 + 1) >= 0x7FFFFFFFFFFFFFF8uLL)
                  v63 = 0x1FFFFFFFFFFFFFFFLL;
                else
                  v63 = v62;
                if (v63)
                  v64 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v103 + 8, v63);
                else
                  v64 = 0;
                v65 = (uint64_t *)&v64[8 * v61];
                *v65 = v57;
                v60 = v65 + 1;
                v67 = (char *)*((_QWORD *)&v102 + 1);
                v66 = (char *)v103;
                if ((_QWORD)v103 != *((_QWORD *)&v102 + 1))
                {
                  do
                  {
                    v68 = *((_QWORD *)v66 - 1);
                    v66 -= 8;
                    *--v65 = v68;
                  }
                  while (v66 != v67);
                  v66 = (char *)*((_QWORD *)&v102 + 1);
                }
                *((_QWORD *)&v102 + 1) = v65;
                *(_QWORD *)&v103 = v60;
                *((_QWORD *)&v103 + 1) = &v64[8 * v63];
                if (v66)
                  operator delete(v66);
              }
              else
              {
                *(_QWORD *)v103 = v56;
                v60 = (_QWORD *)(v59 + 8);
              }
              *(_QWORD *)&v103 = v60;
              v92((uint64_t)v91, v58);
            }
            else
            {
              if (!v55)
                __cxa_bad_cast();
              ___ZN20QMIDataContextIPBase13dropIPPacketsEN3ctu2cf11CFSharedRefIK9__CFArrayEEb_block_invoke((uint64_t)v91, v55 + 2);
            }
            v9 = 1;
            if (Count - 1 == v10++)
              goto LABEL_83;
          }
          ++v10;
        }
        while (Count != v10);
        if ((v9 & 1) == 0)
          goto LABEL_87;
LABEL_83:
        v86[5] = a1 + 144;
        v87 = QMIServiceMsg::create();
        v88 = 25000;
        v89 = 0;
        aBlock = 0;
        v86[0] = MEMORY[0x24BDAC760];
        v86[1] = 0x40000000;
        v86[2] = ___ZN20QMIDataContextIPBase13dropIPPacketsEN3ctu2cf11CFSharedRefIK9__CFArrayEEb_block_invoke_2;
        v86[3] = &__block_descriptor_tmp_210_0;
        v86[4] = a1;
        *(_QWORD *)buf = MEMORY[0x24BDAC760];
        *(_QWORD *)&buf[8] = 0x40000000;
        *(_QWORD *)&buf[16] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_23;
        v105 = &unk_24D5DF608;
        v106 = v86;
        v71 = _Block_copy(buf);
        aBlock = v71;
        if (v87)
        {
          qmi::Client::send();
          v71 = aBlock;
        }
        if (v71)
          _Block_release(v71);
      }
      qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&v102);
    }
  }
  else
  {
    v70 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v70, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_216897000, v70, OS_LOG_TYPE_ERROR, "dropIPPackets after client is deleted", buf, 2u);
    }
  }
}

void sub_216A0CA94(_Unwind_Exception *a1)
{
  uint64_t v1;

  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)(v1 - 192));
  _Unwind_Resume(a1);
}

void ___ZN20QMIDataContextIPBase13dropIPPacketsEN3ctu2cf11CFSharedRefIK9__CFArrayEEb_block_invoke(uint64_t a1, void **a2)
{
  _OWORD *v3;
  uint64_t v4;
  unint64_t v5;
  _OWORD *v6;
  _OWORD *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;

  v3 = (_OWORD *)(a1 + 32);
  v4 = (uint64_t)(a2 + 2);
  v5 = (unint64_t)a2[2];
  v6 = a2[1];
  if ((unint64_t)v6 >= v5)
  {
    v8 = ((char *)v6 - (_BYTE *)*a2) >> 4;
    v9 = v8 + 1;
    if ((unint64_t)(v8 + 1) >> 60)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v5 - (_QWORD)*a2;
    if (v10 >> 3 > v9)
      v9 = v10 >> 3;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF0)
      v11 = 0xFFFFFFFFFFFFFFFLL;
    else
      v11 = v9;
    if (v11)
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::array<unsigned char,16ul>>>(v4, v11);
    else
      v12 = 0;
    v13 = &v12[16 * v8];
    v14 = &v12[16 * v11];
    *(_OWORD *)v13 = *v3;
    v7 = v13 + 16;
    v16 = (char *)*a2;
    v15 = (char *)a2[1];
    if (v15 != *a2)
    {
      do
      {
        *((_OWORD *)v13 - 1) = *((_OWORD *)v15 - 1);
        v13 -= 16;
        v15 -= 16;
      }
      while (v15 != v16);
      v15 = (char *)*a2;
    }
    *a2 = v13;
    a2[1] = v7;
    a2[2] = v14;
    if (v15)
      operator delete(v15);
  }
  else
  {
    *v6 = *v3;
    v7 = v6 + 1;
  }
  a2[1] = v7;
}

void ___ZN20QMIDataContextIPBase13dropIPPacketsEN3ctu2cf11CFSharedRefIK9__CFArrayEEb_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  NSObject *v4;
  _BOOL4 v5;
  const char *v6;
  NSObject *v7;
  uint32_t v8;
  int v9;
  const char *v10;
  __int16 v11;
  int v12;
  __int16 v13;
  uint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)(v2 + 257))
  {
    v3 = *(_DWORD *)(a2 + 4);
    v4 = *(NSObject **)(v2 + 40);
    v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
    if (v3)
    {
      if (!v5)
        return;
      v9 = 136315650;
      v10 = "dropIPPackets_block_invoke";
      v11 = 1024;
      v12 = v3;
      v13 = 2080;
      v14 = qmi::asString();
      v6 = "#I %s: DropIpPackets:Error in response with code = 0x%x (%s)";
      v7 = v4;
      v8 = 28;
    }
    else
    {
      if (!v5)
        return;
      v9 = 136315138;
      v10 = "dropIPPackets_block_invoke_2";
      v6 = "#I %s: DropIpPackets: No Error";
      v7 = v4;
      v8 = 12;
    }
    _os_log_impl(&dword_216897000, v7, OS_LOG_TYPE_DEFAULT, v6, (uint8_t *)&v9, v8);
  }
}

void QMIDataContextIPBase::dropIMSPackets(QMIDataContextIPBase *this)
{
  void *v2;
  NSObject *v3;
  _QWORD v4[6];
  uint64_t v5;
  int v6;
  uint64_t v7;
  void *v8;
  _OWORD v9[2];
  _QWORD aBlock[6];

  if ((*(unsigned int (**)(QMIDataContextIPBase *))(*(_QWORD *)this + 96))(this) == 6)
  {
    if (*((_QWORD *)this + 20))
    {
      memset(v9, 0, sizeof(v9));
      qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v9);
      v4[5] = (char *)this + 144;
      v5 = QMIServiceMsg::create();
      v6 = 25000;
      v7 = 0;
      v8 = 0;
      v4[0] = MEMORY[0x24BDAC760];
      v4[1] = 0x40000000;
      v4[2] = ___ZNK20QMIDataContextIPBase14dropIMSPacketsEv_block_invoke;
      v4[3] = &__block_descriptor_tmp_211;
      v4[4] = this;
      aBlock[0] = MEMORY[0x24BDAC760];
      aBlock[1] = 0x40000000;
      aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3wds12DropIPackets8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
      aBlock[3] = &unk_24D5DFB28;
      aBlock[4] = v4;
      v2 = _Block_copy(aBlock);
      v8 = v2;
      if (v5)
      {
        qmi::Client::send();
        v2 = v8;
      }
      if (v2)
        _Block_release(v2);
      qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v9);
    }
    else
    {
      v3 = *((_QWORD *)this + 5);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      {
        LOWORD(aBlock[0]) = 0;
        _os_log_error_impl(&dword_216897000, v3, OS_LOG_TYPE_ERROR, "dropIMSpkt after client is deleted", (uint8_t *)aBlock, 2u);
      }
    }
  }
}

void sub_216A0CE40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  uint64_t v7;
  va_list va;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  va_list va1;

  va_start(va1, a6);
  va_start(va, a6);
  v7 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)va);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va1);
  _Unwind_Resume(a1);
}

void ___ZNK20QMIDataContextIPBase14dropIMSPacketsEv_block_invoke(uint64_t a1, uint64_t a2)
{
  int v2;
  NSObject *v3;
  _BOOL4 v4;
  const char *v5;
  NSObject *v6;
  uint32_t v7;
  int v8;
  const char *v9;
  __int16 v10;
  int v11;
  __int16 v12;
  uint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v2 = *(_DWORD *)(a2 + 4);
  v3 = *(NSObject **)(*(_QWORD *)(a1 + 32) + 40);
  v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (!v4)
      return;
    v8 = 136315650;
    v9 = "dropIMSPackets_block_invoke";
    v10 = 1024;
    v11 = v2;
    v12 = 2080;
    v13 = qmi::asString();
    v5 = "#I %s: Failed QMI Request - DropIMSPackets (DropIPackets) : 0x%x (%s)";
    v6 = v3;
    v7 = 28;
  }
  else
  {
    if (!v4)
      return;
    v8 = 136315138;
    v9 = "dropIMSPackets_block_invoke";
    v5 = "#I %s: DropIMSPackets (DropIPackets) invoked successfully";
    v6 = v3;
    v7 = 12;
  }
  _os_log_impl(&dword_216897000, v6, OS_LOG_TYPE_DEFAULT, v5, (uint8_t *)&v8, v7);
}

void QMIDataContextIPBase::setQuality(QMIDataContextIPBase *this, int a2)
{
  NSObject *v4;
  _BOOL8 v5;
  char v6;
  capabilities::ct *v7;
  int v8;
  char *v9;
  NSObject *v10;
  const void *v11;
  const struct __class_type_info *v12;
  char *v13;
  char *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  char *v20;
  _QWORD *v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  char *v25;
  uint64_t *v26;
  char *v27;
  char *v28;
  char *v29;
  uint64_t v30;
  char *v31;
  uint64_t v32;
  void *v33;
  _QWORD v34[6];
  uint64_t v35;
  int v36;
  uint64_t v37;
  void *aBlock;
  void *__p[2];
  __int128 v40;
  __int128 buf;
  void (*v42)(uint64_t, uint64_t);
  void *v43;
  _QWORD *v44;
  uint64_t v45;

  v45 = *MEMORY[0x24BDAC8D0];
  v4 = *((_QWORD *)this + 5);
  v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (v5)
  {
    LODWORD(buf) = 136315138;
    *(_QWORD *)((char *)&buf + 4) = "setQuality";
    _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I %s: start", (uint8_t *)&buf, 0xCu);
  }
  if (*((_QWORD *)this + 20))
  {
    if (!capabilities::ct::supportsQualityIndication((capabilities::ct *)v5))
      return;
    if (a2)
      v6 = 1;
    else
      v6 = 2;
    *(_OWORD *)__p = 0u;
    v40 = 0u;
    v7 = (capabilities::ct *)qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
    v8 = capabilities::ct::supports2StepDataCallBringUp(v7);
    v9 = (char *)__p[1];
    if (v8)
    {
      if (__p[1] != (void *)v40)
      {
        while (*(_BYTE *)(*(_QWORD *)v9 + 8) != 1)
        {
          v9 += 8;
          if (v9 == (char *)v40)
            goto LABEL_25;
        }
      }
      if (v9 != (char *)v40)
      {
        v11 = *(const void **)v9;
LABEL_23:
        if (!v13)
          __cxa_bad_cast();
        v14 = v13 + 9;
        goto LABEL_55;
      }
LABEL_25:
      v15 = operator new();
      *(_WORD *)(v15 + 8) = 1;
      *(_QWORD *)v15 = &off_24D5DFB70;
      v16 = (uint64_t *)v40;
      if ((unint64_t)v40 >= *((_QWORD *)&v40 + 1))
      {
        v17 = (uint64_t)(v40 - (unint64_t)__p[1]) >> 3;
        if (!((unint64_t)(v17 + 1) >> 61))
        {
          v18 = (uint64_t)(*((_QWORD *)&v40 + 1) - (unint64_t)__p[1]) >> 2;
          if (v18 <= v17 + 1)
            v18 = v17 + 1;
          if (*((_QWORD *)&v40 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
            v19 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v19 = v18;
          if (v19)
            v20 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v40 + 8, v19);
          else
            v20 = 0;
          v26 = (uint64_t *)&v20[8 * v17];
          v27 = &v20[8 * v19];
          *v26 = v15;
          v21 = v26 + 1;
          v29 = (char *)__p[1];
          v28 = (char *)v40;
          if ((void *)v40 == __p[1])
            goto LABEL_52;
          do
          {
            v30 = *((_QWORD *)v28 - 1);
            v28 -= 8;
            *--v26 = v30;
          }
          while (v28 != v29);
LABEL_51:
          v28 = (char *)__p[1];
LABEL_52:
          __p[1] = v26;
          *(_QWORD *)&v40 = v21;
          *((_QWORD *)&v40 + 1) = v27;
          if (v28)
            operator delete(v28);
          goto LABEL_54;
        }
        goto LABEL_62;
      }
    }
    else
    {
      if (__p[1] != (void *)v40)
      {
        while (*(_BYTE *)(*(_QWORD *)v9 + 8))
        {
          v9 += 8;
          if (v9 == (char *)v40)
            goto LABEL_34;
        }
      }
      if (v9 != (char *)v40)
      {
        v11 = *(const void **)v9;
        goto LABEL_23;
      }
LABEL_34:
      v15 = operator new();
      *(_WORD *)(v15 + 8) = 0;
      *(_QWORD *)v15 = &off_24D5DFBC0;
      v16 = (uint64_t *)v40;
      if ((unint64_t)v40 >= *((_QWORD *)&v40 + 1))
      {
        v22 = (uint64_t)(v40 - (unint64_t)__p[1]) >> 3;
        if (!((unint64_t)(v22 + 1) >> 61))
        {
          v23 = (uint64_t)(*((_QWORD *)&v40 + 1) - (unint64_t)__p[1]) >> 2;
          if (v23 <= v22 + 1)
            v23 = v22 + 1;
          if (*((_QWORD *)&v40 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
            v24 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v24 = v23;
          if (v24)
            v25 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v40 + 8, v24);
          else
            v25 = 0;
          v26 = (uint64_t *)&v25[8 * v22];
          v27 = &v25[8 * v24];
          *v26 = v15;
          v21 = v26 + 1;
          v31 = (char *)__p[1];
          v28 = (char *)v40;
          if ((void *)v40 == __p[1])
            goto LABEL_52;
          do
          {
            v32 = *((_QWORD *)v28 - 1);
            v28 -= 8;
            *--v26 = v32;
          }
          while (v28 != v31);
          goto LABEL_51;
        }
LABEL_62:
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      }
    }
    *v16 = v15;
    v21 = v16 + 1;
LABEL_54:
    v14 = (char *)(v15 + 9);
    *(_QWORD *)&v40 = v21;
LABEL_55:
    *v14 = v6;
    v34[5] = (char *)this + 144;
    v35 = QMIServiceMsg::create();
    v36 = 25000;
    v37 = 0;
    aBlock = 0;
    v34[0] = MEMORY[0x24BDAC760];
    v34[1] = 0x40000000;
    v34[2] = ___ZN20QMIDataContextIPBase10setQualityEb_block_invoke_3;
    v34[3] = &__block_descriptor_tmp_216;
    v34[4] = this;
    *(_QWORD *)&buf = MEMORY[0x24BDAC760];
    *((_QWORD *)&buf + 1) = 0x40000000;
    v42 = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_23;
    v43 = &unk_24D5DF608;
    v44 = v34;
    v33 = _Block_copy(&buf);
    aBlock = v33;
    if (v35)
    {
      qmi::Client::send();
      v33 = aBlock;
    }
    if (v33)
      _Block_release(v33);
    qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
    return;
  }
  v10 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf) = 0;
    _os_log_error_impl(&dword_216897000, v10, OS_LOG_TYPE_ERROR, "setQuality after client is deleted", (uint8_t *)&buf, 2u);
  }
}

void sub_216A0D388(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  uint64_t v7;
  va_list va;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  va_list va1;

  va_start(va1, a6);
  va_start(va, a6);
  v7 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)va);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va1);
  _Unwind_Resume(a1);
}

void ___ZN20QMIDataContextIPBase10setQualityEb_block_invoke_3(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  NSObject *v4;
  int v5;
  const char *v6;
  __int16 v7;
  int v8;
  __int16 v9;
  uint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)(v2 + 257))
  {
    v3 = *(_DWORD *)(a2 + 4);
    if (v3)
    {
      v4 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        v5 = 136315650;
        v6 = "setQuality_block_invoke_3";
        v7 = 1024;
        v8 = v3;
        v9 = 2080;
        v10 = qmi::asString();
        _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I %s: Quality Indication<FT> failed with error 0x%x(%s)", (uint8_t *)&v5, 0x1Cu);
      }
    }
  }
}

void QMIDataContextIPBase::shutDownContextIP(QMIDataContextIPBase *this)
{
  NSObject *v2;
  uint64_t v3;
  int v4;
  const char *v5;
  uint64_t v6;

  v6 = *MEMORY[0x24BDAC8D0];
  v2 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v4 = 136315138;
    v5 = "shutDownContextIP";
    _os_log_impl(&dword_216897000, v2, OS_LOG_TYPE_DEFAULT, "#I %s: start", (uint8_t *)&v4, 0xCu);
  }
  v3 = *((_QWORD *)this + 33);
  *((_QWORD *)this + 33) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  *((_BYTE *)this + 257) = 1;
  QMIDataContextIPBase::deactivateDataContextIP(this, 0, 0);
  QMIDataContextIPBase::resetDataContextIP(this);
}

void QMIDataContextIPBase::ipv6ServiceUp(QMIDataContextIPBase *this, const CSIPacketAddress *a2)
{
  NSObject *v3;
  void **v4;
  void *__p;
  char v6;
  uint8_t buf[4];
  const char *v8;
  __int16 v9;
  void **v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v3 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    CSIPacketAddress::operator std::string();
    v4 = v6 >= 0 ? &__p : (void **)__p;
    *(_DWORD *)buf = 136315394;
    v8 = "ipv6ServiceUp";
    v9 = 2080;
    v10 = v4;
    _os_log_impl(&dword_216897000, v3, OS_LOG_TYPE_DEFAULT, "#I %s: IPv6 address: %s", buf, 0x16u);
    if (v6 < 0)
      operator delete(__p);
  }
  if (*((_QWORD *)this + 36))
  {
    CSIPacketAddress::operator=();
    QMIDataContextIPBase::checkIPv6ConfigTimer(this);
  }
}

void QMIDataContextIPBase::ipv4ServiceUp(QMIDataContextIPBase *this, const CSIPacketAddress *a2)
{
  NSObject *v3;
  _BYTE *v4;
  int isZeroIP;
  NSObject *v6;
  _BOOL4 v7;
  BOOL v8;
  std::__shared_weak_count *v9;
  uint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  unint64_t *p_shared_owners;
  _BYTE __p[12];
  char v15;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  _BYTE *v19;
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  v3 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    CSIPacketAddress::operator std::string();
    v4 = v15 >= 0 ? __p : *(_BYTE **)__p;
    *(_DWORD *)buf = 136315394;
    v17 = "ipv4ServiceUp";
    v18 = 2080;
    v19 = v4;
    _os_log_impl(&dword_216897000, v3, OS_LOG_TYPE_DEFAULT, "#I %s: IPv4 address: %s", buf, 0x16u);
    if (v15 < 0)
      operator delete(*(void **)__p);
  }
  if (*((_QWORD *)this + 37))
  {
    CSIPacketAddress::operator=();
    isZeroIP = CSIPacketAddress::isZeroIP((QMIDataContextIPBase *)((char *)this + 360));
    v6 = *((_QWORD *)this + 5);
    v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
    if (isZeroIP)
    {
      if (v7)
      {
        *(_DWORD *)__p = 136315138;
        *(_QWORD *)&__p[4] = "checkIPv4ConfigTimer";
        _os_log_impl(&dword_216897000, v6, OS_LOG_TYPE_DEFAULT, "#I %s: IPv4Service: fIPv4ConfigAddress is empty", __p, 0xCu);
      }
    }
    else
    {
      if (v7)
      {
        *(_DWORD *)__p = 136315138;
        *(_QWORD *)&__p[4] = "checkIPv4ConfigTimer";
        _os_log_impl(&dword_216897000, v6, OS_LOG_TYPE_DEFAULT, "#I %s: IPv4Service: completed", __p, 0xCu);
      }
      v8 = *((_BYTE *)this + 305) == 0;
      QMIDataContextIPBase::clearIPv4ConfigTimer(this);
      v9 = std::__shared_weak_count::lock(*((std::__shared_weak_count **)this + 13));
      v10 = *((_QWORD *)this + 12);
      if (v8)
      {
        (*(void (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)v10 + 56))(v10, *((unsigned int *)this + 35), 0);
        p_shared_owners = (unint64_t *)&v9->__shared_owners_;
        do
          v12 = __ldaxr(p_shared_owners);
        while (__stlxr(v12 - 1, p_shared_owners));
      }
      else
      {
        (*(void (**)(uint64_t))(*(_QWORD *)v10 + 144))(v10);
        v11 = (unint64_t *)&v9->__shared_owners_;
        do
          v12 = __ldaxr(v11);
        while (__stlxr(v12 - 1, v11));
      }
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
  }
}

void sub_216A0D8B0(_Unwind_Exception *exception_object)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v4;

  p_shared_owners = (unint64_t *)&v1->__shared_owners_;
  do
    v4 = __ldaxr(p_shared_owners);
  while (__stlxr(v4 - 1, p_shared_owners));
  if (!v4)
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t QMIDataContextIPBase::getPDPMetricInfo(QMIDataContextIPBase *this)
{
  NSObject *v2;
  int v4;
  uint64_t v5;
  uint64_t v6;

  v6 = *MEMORY[0x24BDAC8D0];
  v2 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v4 = 136315138;
    v5 = asString();
    _os_log_impl(&dword_216897000, v2, OS_LOG_TYPE_DEFAULT, "#I getPDPMetricInfo() for %s", (uint8_t *)&v4, 0xCu);
  }
  return (uint64_t)this + 384;
}

uint64_t QMIDataContextIPBase::isActivationFinished(QMIDataContextIPBase *this)
{
  uint64_t v1;
  NSObject *v2;
  uint64_t v3;
  const char *v4;
  int v6;
  const char *v7;
  __int16 v8;
  uint64_t v9;
  __int16 v10;
  const char *v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v1 = (*((_DWORD *)this + 34) < 7u) & (0x69u >> *((_DWORD *)this + 34));
  v2 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v3 = asString();
    v4 = "not finished yet";
    v7 = "isActivationFinished";
    v6 = 136315650;
    v9 = v3;
    v8 = 2080;
    if ((_DWORD)v1)
      v4 = "finished";
    v10 = 2080;
    v11 = v4;
    _os_log_impl(&dword_216897000, v2, OS_LOG_TYPE_DEFAULT, "#I %s: in state %s, activation %s", (uint8_t *)&v6, 0x20u);
  }
  return v1;
}

BOOL QMIDataContextIPBase::isActive(QMIDataContextIPBase *this)
{
  unsigned int v1;
  NSObject *v2;
  int v4;
  const char *v5;
  __int16 v6;
  uint64_t v7;
  __int16 v8;
  uint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v1 = *((_DWORD *)this + 34) & 0xFFFFFFFD;
  v2 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v4 = 136315650;
    v5 = "isActive";
    v6 = 2080;
    v7 = asString();
    v8 = 2080;
    v9 = asStringBool();
    _os_log_impl(&dword_216897000, v2, OS_LOG_TYPE_DEFAULT, "#I %s: in state %s, active: %s", (uint8_t *)&v4, 0x20u);
  }
  return v1 == 4;
}

void QMIDataContextIPBase::updateVoLTEDataCallType(QMIDataContextIPBase *this, int a2)
{
  const void **v4;
  char *v5;
  int *v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;
  NSObject *v21;
  uint64_t v22;
  const char *v23;
  void *v24;
  _QWORD v25[6];
  uint64_t v26;
  int v27;
  uint64_t v28;
  void *aBlock;
  void *__p[2];
  __int128 v31;
  _BYTE buf[24];
  void *v33;
  _QWORD *v34;
  uint64_t v35;

  v35 = *MEMORY[0x24BDAC8D0];
  if (capabilities::ct::supportsDataQMIExtensions(this))
  {
    if (*((_QWORD *)this + 20))
    {
      *(_OWORD *)__p = 0u;
      v31 = 0u;
      qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
      v4 = (const void **)__p[1];
      if (__p[1] != (void *)v31)
      {
        while (*((_BYTE *)*v4 + 8) != 1)
        {
          if (++v4 == (const void **)v31)
            goto LABEL_12;
        }
      }
      if (v4 == (const void **)v31)
      {
LABEL_12:
        v8 = operator new();
        v9 = v8;
        *(_BYTE *)(v8 + 8) = 1;
        *(_QWORD *)v8 = &off_24D5DFC10;
        *(_DWORD *)(v8 + 12) = 0;
        v6 = (int *)(v8 + 12);
        v10 = v31;
        if ((unint64_t)v31 >= *((_QWORD *)&v31 + 1))
        {
          v12 = (uint64_t)(v31 - (unint64_t)__p[1]) >> 3;
          if ((unint64_t)(v12 + 1) >> 61)
            std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
          v13 = (uint64_t)(*((_QWORD *)&v31 + 1) - (unint64_t)__p[1]) >> 2;
          if (v13 <= v12 + 1)
            v13 = v12 + 1;
          if (*((_QWORD *)&v31 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
            v14 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v14 = v13;
          if (v14)
            v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v31 + 8, v14);
          else
            v15 = 0;
          v16 = (uint64_t *)&v15[8 * v12];
          v17 = &v15[8 * v14];
          *v16 = v9;
          v11 = v16 + 1;
          v19 = (char *)__p[1];
          v18 = (char *)v31;
          if ((void *)v31 != __p[1])
          {
            do
            {
              v20 = *((_QWORD *)v18 - 1);
              v18 -= 8;
              *--v16 = v20;
            }
            while (v18 != v19);
            v18 = (char *)__p[1];
          }
          __p[1] = v16;
          *(_QWORD *)&v31 = v11;
          *((_QWORD *)&v31 + 1) = v17;
          if (v18)
            operator delete(v18);
        }
        else
        {
          *(_QWORD *)v31 = v8;
          v11 = (_QWORD *)(v10 + 8);
        }
        *(_QWORD *)&v31 = v11;
      }
      else
      {
        if (!v5)
          __cxa_bad_cast();
        v6 = (int *)(v5 + 12);
      }
      *v6 = a2;
      v21 = *((_QWORD *)this + 5);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        v22 = CSIBOOLAsString();
        v23 = wds::asString(a2);
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = v22;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = v23;
        *(_WORD *)&buf[22] = 1024;
        LODWORD(v33) = a2;
        _os_log_impl(&dword_216897000, v21, OS_LOG_TYPE_DEFAULT, "#I Sending VoLTE data call type to BB: isCallActive: %s data call type: %s (%u)", buf, 0x1Cu);
      }
      v25[5] = (char *)this + 144;
      v26 = QMIServiceMsg::create();
      v27 = 25000;
      v28 = 0;
      aBlock = 0;
      v25[0] = MEMORY[0x24BDAC760];
      v25[1] = 0x40000000;
      v25[2] = ___ZNK20QMIDataContextIPBase23updateVoLTEDataCallTypeEb_block_invoke;
      v25[3] = &__block_descriptor_tmp_219;
      v25[4] = this;
      *(_QWORD *)buf = MEMORY[0x24BDAC760];
      *(_QWORD *)&buf[8] = 0x40000000;
      *(_QWORD *)&buf[16] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_23;
      v33 = &unk_24D5DF608;
      v34 = v25;
      v24 = _Block_copy(buf);
      aBlock = v24;
      if (v26)
      {
        qmi::Client::send();
        v24 = aBlock;
      }
      if (v24)
        _Block_release(v24);
      qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
    }
    else
    {
      v7 = *((_QWORD *)this + 5);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_216897000, v7, OS_LOG_TYPE_ERROR, "updateVoLTEDataCallType after client is deleted", buf, 2u);
      }
    }
  }
}

void sub_216A0DEC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  uint64_t v7;
  va_list va;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  va_list va1;

  va_start(va1, a6);
  va_start(va, a6);
  v7 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)va);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va1);
  _Unwind_Resume(a1);
}

void ___ZNK20QMIDataContextIPBase23updateVoLTEDataCallTypeEb_block_invoke(uint64_t a1, uint64_t a2)
{
  NSObject *v3;
  uint64_t v4;
  int v5;
  int v6;
  uint64_t v7;
  __int16 v8;
  int v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)(a2 + 4))
  {
    v3 = *(NSObject **)(*(_QWORD *)(a1 + 32) + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      v4 = qmi::asString();
      v5 = *(_DWORD *)(a2 + 4);
      v6 = 136315394;
      v7 = v4;
      v8 = 1024;
      v9 = v5;
      _os_log_error_impl(&dword_216897000, v3, OS_LOG_TYPE_ERROR, "Send VoLTE call status info failed: %s (%d)", (uint8_t *)&v6, 0x12u);
    }
  }
}

void QMIDataContextIPBase::shutdownAnbrHandle(QMIDataContextIPBase *a1, int *a2)
{
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  std::__shared_weak_count *v10;
  std::__shared_weak_count *v11;
  std::__shared_weak_count *v12;
  uint64_t v13;
  unint64_t *v14;
  unint64_t v15;

  QMIDataContextIPBase::shutdownAnbrHandle(a1, a2[40]);
  if (a2[41])
  {
    v4 = (std::__shared_weak_count *)*((_QWORD *)a1 + 13);
    if (v4)
    {
      v5 = std::__shared_weak_count::lock(v4);
      if (v5)
      {
        v6 = v5;
        v7 = *((_QWORD *)a1 + 12);
        if (v7)
          (*(void (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)v7 + 112))(v7, 0, 1);
        p_shared_owners = (unint64_t *)&v6->__shared_owners_;
        do
          v9 = __ldaxr(p_shared_owners);
        while (__stlxr(v9 - 1, p_shared_owners));
        if (!v9)
        {
          ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
          std::__shared_weak_count::__release_weak(v6);
        }
      }
    }
  }
  if (a2[42])
  {
    v10 = (std::__shared_weak_count *)*((_QWORD *)a1 + 13);
    if (v10)
    {
      v11 = std::__shared_weak_count::lock(v10);
      if (v11)
      {
        v12 = v11;
        v13 = *((_QWORD *)a1 + 12);
        if (v13)
          (*(void (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)v13 + 112))(v13, 0, 0);
        v14 = (unint64_t *)&v12->__shared_owners_;
        do
          v15 = __ldaxr(v14);
        while (__stlxr(v15 - 1, v14));
        if (!v15)
        {
          ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
          std::__shared_weak_count::__release_weak(v12);
        }
      }
    }
  }
}

void sub_216A0E0EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void QMIDataContextIPBase::shutdownAnbrHandle(QMIDataContextIPBase *this, int a2)
{
  const void **v4;
  char *v5;
  _DWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  char *v14;
  uint64_t *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;
  void *v20;
  _QWORD v21[6];
  uint64_t v22;
  int v23;
  uint64_t v24;
  void *v25;
  void *__p[2];
  __int128 v27;
  _QWORD aBlock[5];

  *(_OWORD *)__p = 0u;
  v27 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  v4 = (const void **)__p[1];
  if (__p[1] != (void *)v27)
  {
    while (*((_BYTE *)*v4 + 8) != 1)
    {
      if (++v4 == (const void **)v27)
        goto LABEL_8;
    }
  }
  if (v4 == (const void **)v27)
  {
LABEL_8:
    v7 = operator new();
    v8 = v7;
    *(_BYTE *)(v7 + 8) = 1;
    *(_QWORD *)v7 = &off_24D5DFC60;
    *(_DWORD *)(v7 + 12) = 0;
    v6 = (_DWORD *)(v7 + 12);
    v9 = v27;
    if ((unint64_t)v27 >= *((_QWORD *)&v27 + 1))
    {
      v11 = (uint64_t)(v27 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v11 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v12 = (uint64_t)(*((_QWORD *)&v27 + 1) - (unint64_t)__p[1]) >> 2;
      if (v12 <= v11 + 1)
        v12 = v11 + 1;
      if (*((_QWORD *)&v27 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v13 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v13 = v12;
      if (v13)
        v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v27 + 8, v13);
      else
        v14 = 0;
      v15 = (uint64_t *)&v14[8 * v11];
      v16 = &v14[8 * v13];
      *v15 = v8;
      v10 = v15 + 1;
      v18 = (char *)__p[1];
      v17 = (char *)v27;
      if ((void *)v27 != __p[1])
      {
        do
        {
          v19 = *((_QWORD *)v17 - 1);
          v17 -= 8;
          *--v15 = v19;
        }
        while (v17 != v18);
        v17 = (char *)__p[1];
      }
      __p[1] = v15;
      *(_QWORD *)&v27 = v10;
      *((_QWORD *)&v27 + 1) = v16;
      if (v17)
        operator delete(v17);
    }
    else
    {
      *(_QWORD *)v27 = v7;
      v10 = (_QWORD *)(v9 + 8);
    }
    *(_QWORD *)&v27 = v10;
  }
  else
  {
    if (!v5)
      __cxa_bad_cast();
    v6 = v5 + 12;
  }
  *v6 = a2;
  v21[5] = (char *)this + 144;
  v22 = QMIServiceMsg::create();
  v23 = 25000;
  v24 = 0;
  v25 = 0;
  v21[0] = MEMORY[0x24BDAC760];
  v21[1] = 0x40000000;
  v21[2] = ___ZN20QMIDataContextIPBase18shutdownAnbrHandleEj_block_invoke;
  v21[3] = &__block_descriptor_tmp_226_0;
  v21[4] = this;
  aBlock[0] = MEMORY[0x24BDAC760];
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_23;
  aBlock[3] = &unk_24D5DF608;
  aBlock[4] = v21;
  v20 = _Block_copy(aBlock);
  v25 = v20;
  if (v22)
  {
    qmi::Client::send();
    v20 = v25;
  }
  if (v20)
    _Block_release(v20);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
}

void sub_216A0E350(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  uint64_t v7;
  va_list va;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  va_list va1;

  va_start(va1, a6);
  va_start(va, a6);
  v7 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)va);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va1);
  _Unwind_Resume(a1);
}

void ___ZN20QMIDataContextIPBase18shutdownAnbrHandleEj_block_invoke(uint64_t a1, uint64_t a2)
{
  NSObject *v3;
  uint64_t v4;
  int v5;
  int v6;
  uint64_t v7;
  __int16 v8;
  int v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)(a2 + 4))
  {
    v3 = *(NSObject **)(*(_QWORD *)(a1 + 32) + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      v4 = qmi::asString();
      v5 = *(_DWORD *)(a2 + 4);
      v6 = 136315394;
      v7 = v4;
      v8 = 1024;
      v9 = v5;
      _os_log_error_impl(&dword_216897000, v3, OS_LOG_TYPE_ERROR, "ANBRDeregisterFilter failed: %s (%d)", (uint8_t *)&v6, 0x12u);
    }
  }
}

uint64_t QMIDataContextIPBase::getAnbr(QMIDataContextIPBase *this, int a2)
{
  if (!*((_BYTE *)this + 856))
    return 0;
  if (a2)
    return *((unsigned int *)this + 211);
  return *((unsigned int *)this + 212);
}

uint64_t QMIDataContextIPBase::getAnbrActivationState(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  NSObject *v4;
  uint8_t v6[16];

  if (!*(_QWORD *)(a1 + 160))
    return 0;
  if (!*(_BYTE *)(a1 + 856) || !*(_BYTE *)(a1 + 853))
  {
    v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v6 = 0;
      _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#N No prohibited timer information available", v6, 2u);
    }
    std::function<void ()(BOOL,BOOL)>::operator()(a2, 0, 1);
    return 0;
  }
  v3 = 1;
  std::function<void ()(BOOL,BOOL)>::operator()(a2, *(_BYTE *)(a1 + 852), 1);
  return v3;
}

void ___ZN20QMIDataContextIPBase24queryAnbrActivationStateEj_block_invoke(uint64_t a1, qmi::MessageBase *this)
{
  uint64_t v3;
  NSObject *v4;
  int v5;
  uint64_t TlvValue;
  int v7;
  uint64_t v8;
  int v9;
  unint64_t v10;
  BOOL v11;
  __int16 v12;
  std::__shared_weak_count *v13;
  std::__shared_weak_count *v14;
  std::__shared_weak_count *v15;
  uint64_t v16;
  unint64_t *p_shared_owners;
  unint64_t v18;
  NSObject *v19;
  const char *v20;
  uint64_t v21;
  int v22;
  uint8_t v23[16];
  _BYTE buf[12];
  __int16 v25;
  int v26;
  uint64_t v27;

  v27 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 1))
  {
    v4 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v21 = qmi::asString();
      v22 = *((_DWORD *)this + 1);
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = v21;
      v25 = 1024;
      v26 = v22;
      _os_log_error_impl(&dword_216897000, v4, OS_LOG_TYPE_ERROR, "GetANBRProhibitTimerInfo failed: %s (%d)", buf, 0x12u);
    }
    return;
  }
  v5 = *(_DWORD *)(a1 + 40);
  TlvValue = qmi::MessageBase::findTlvValue(this);
  if (!TlvValue)
    return;
  v8 = TlvValue;
  v9 = v7;
  *(_QWORD *)buf = TlvValue;
  v10 = tlv::parseV<wds::tlv::ProhibitTimerInfo>((unint64_t *)buf, v7);
  if (!*(_QWORD *)buf)
  {
    ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)this, 16, v8, v9);
    return;
  }
  if (!*(_BYTE *)(v3 + 856))
  {
    v19 = *(NSObject **)(v3 + 40);
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      return;
    *(_WORD *)v23 = 0;
    v20 = "#E GetANBRProhibitTimerInfo: empty filter";
    goto LABEL_30;
  }
  if (*(_DWORD *)(v3 + 840) != v5)
  {
    v19 = *(NSObject **)(v3 + 40);
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      return;
    *(_WORD *)v23 = 0;
    v20 = "#E GetANBRProhibitTimerInfo: wrong handle";
LABEL_30:
    _os_log_impl(&dword_216897000, v19, OS_LOG_TYPE_DEFAULT, v20, v23, 2u);
    return;
  }
  if ((_BYTE)v10)
    v11 = HIDWORD(v10) == 0;
  else
    v11 = 1;
  v12 = !v11;
  *(_WORD *)(v3 + 852) = v12 | 0x100;
  v13 = *(std::__shared_weak_count **)(v3 + 104);
  if (v13)
  {
    v14 = std::__shared_weak_count::lock(v13);
    if (v14)
    {
      v15 = v14;
      v16 = *(_QWORD *)(v3 + 96);
      if (v16)
      {
        if (!*(_BYTE *)(v3 + 856) || !*(_BYTE *)(v3 + 853))
          std::__throw_bad_optional_access[abi:ne180100]();
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v16 + 104))(v16, *(unsigned __int8 *)(v3 + 852));
      }
      p_shared_owners = (unint64_t *)&v15->__shared_owners_;
      do
        v18 = __ldaxr(p_shared_owners);
      while (__stlxr(v18 - 1, p_shared_owners));
      if (!v18)
      {
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v15);
      }
    }
  }
}

void sub_216A0E744(_Unwind_Exception *exception_object)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v4;

  p_shared_owners = (unint64_t *)&v1->__shared_owners_;
  do
    v4 = __ldaxr(p_shared_owners);
  while (__stlxr(v4 - 1, p_shared_owners));
  if (!v4)
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
  _Unwind_Resume(exception_object);
}

void QMIDataContextIPBase::setCoalescing(capabilities::ipc *a1, __int16 a2)
{
  const void **v4;
  char *v5;
  _WORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  char *v14;
  uint64_t *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;
  void *v20;
  _QWORD v21[6];
  uint64_t v22;
  int v23;
  uint64_t v24;
  void *v25;
  void *__p[2];
  __int128 v27;
  _QWORD aBlock[5];

  if (*((_QWORD *)a1 + 20) && capabilities::ipc::supportsCoalescing(a1))
  {
    *(_OWORD *)__p = 0u;
    v27 = 0u;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
    v4 = (const void **)__p[1];
    if (__p[1] != (void *)v27)
    {
      while (*((_BYTE *)*v4 + 8) != 1)
      {
        if (++v4 == (const void **)v27)
          goto LABEL_10;
      }
    }
    if (v4 == (const void **)v27)
    {
LABEL_10:
      v7 = operator new();
      v8 = v7;
      *(_WORD *)(v7 + 8) = 1;
      *(_QWORD *)v7 = &off_24D5DFD28;
      *(_BYTE *)(v7 + 10) = 0;
      v9 = v27;
      if ((unint64_t)v27 >= *((_QWORD *)&v27 + 1))
      {
        v11 = (uint64_t)(v27 - (unint64_t)__p[1]) >> 3;
        if ((unint64_t)(v11 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v12 = (uint64_t)(*((_QWORD *)&v27 + 1) - (unint64_t)__p[1]) >> 2;
        if (v12 <= v11 + 1)
          v12 = v11 + 1;
        if (*((_QWORD *)&v27 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v13 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v13 = v12;
        if (v13)
          v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v27 + 8, v13);
        else
          v14 = 0;
        v15 = (uint64_t *)&v14[8 * v11];
        v16 = &v14[8 * v13];
        *v15 = v8;
        v10 = v15 + 1;
        v18 = (char *)__p[1];
        v17 = (char *)v27;
        if ((void *)v27 != __p[1])
        {
          do
          {
            v19 = *((_QWORD *)v17 - 1);
            v17 -= 8;
            *--v15 = v19;
          }
          while (v17 != v18);
          v17 = (char *)__p[1];
        }
        __p[1] = v15;
        *(_QWORD *)&v27 = v10;
        *((_QWORD *)&v27 + 1) = v16;
        if (v17)
          operator delete(v17);
      }
      else
      {
        *(_QWORD *)v27 = v7;
        v10 = (_QWORD *)(v9 + 8);
      }
      v6 = (_WORD *)(v8 + 9);
      *(_QWORD *)&v27 = v10;
    }
    else
    {
      if (!v5)
        __cxa_bad_cast();
      v6 = v5 + 9;
    }
    *v6 = a2;
    v21[5] = (char *)a1 + 144;
    v22 = QMIServiceMsg::create();
    v23 = 25000;
    v24 = 0;
    v25 = 0;
    v21[0] = MEMORY[0x24BDAC760];
    v21[1] = 0x40000000;
    v21[2] = ___ZNK20QMIDataContextIPBase13setCoalescingENSt3__14pairIbbEE_block_invoke;
    v21[3] = &__block_descriptor_tmp_228_0;
    v21[4] = a1;
    aBlock[0] = MEMORY[0x24BDAC760];
    aBlock[1] = 0x40000000;
    aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3wds13SetCoalescing8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
    aBlock[3] = &unk_24D5DFD58;
    aBlock[4] = v21;
    v20 = _Block_copy(aBlock);
    v25 = v20;
    if (v22)
    {
      qmi::Client::send();
      v20 = v25;
    }
    if (v20)
      _Block_release(v20);
    qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
  }
}

void sub_216A0E9E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  uint64_t v7;
  va_list va;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  va_list va1;

  va_start(va1, a6);
  va_start(va, a6);
  v7 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)va);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va1);
  _Unwind_Resume(a1);
}

void ___ZNK20QMIDataContextIPBase13setCoalescingENSt3__14pairIbbEE_block_invoke(uint64_t a1, uint64_t a2)
{
  NSObject *v3;
  uint64_t v4;
  int v5;
  int v6;
  uint64_t v7;
  __int16 v8;
  int v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)(a2 + 4))
  {
    v3 = *(NSObject **)(*(_QWORD *)(a1 + 32) + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      v4 = qmi::asString();
      v5 = *(_DWORD *)(a2 + 4);
      v6 = 136315394;
      v7 = v4;
      v8 = 1024;
      v9 = v5;
      _os_log_error_impl(&dword_216897000, v3, OS_LOG_TYPE_ERROR, "SetCoalescing failed: %s (%d)", (uint8_t *)&v6, 0x12u);
    }
  }
}

uint64_t QMIDataContextIPBase::queryAnbrBitrate(uint64_t a1, int a2, int a3, uint64_t a4)
{
  int v8;
  const void **v9;
  char *v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  char *v20;
  uint64_t *v21;
  char *v22;
  char *v23;
  char *v24;
  uint64_t v25;
  int v26;
  const void **v27;
  char *v28;
  _DWORD *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  _QWORD *v33;
  uint64_t v34;
  unint64_t v35;
  unint64_t v36;
  char *v37;
  uint64_t *v38;
  char *v39;
  char *v40;
  char *v41;
  uint64_t v42;
  uint64_t v43;
  _QWORD *v44;
  void *v45;
  uint64_t v46;
  uint64_t v47;
  void *v48;
  void *__p[2];
  __int128 v50;
  _QWORD aBlock[5];
  _QWORD v52[5];
  _BYTE v53[24];
  _BYTE *v54;
  uint64_t v55;

  v55 = *MEMORY[0x24BDAC8D0];
  if (!*(_QWORD *)(a1 + 160) || !*(_BYTE *)(a1 + 856))
    return 0;
  v8 = *(_DWORD *)(a1 + 840);
  *(_OWORD *)__p = 0u;
  v50 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  v9 = (const void **)__p[1];
  if (__p[1] != (void *)v50)
  {
    while (*((_BYTE *)*v9 + 8) != 1)
    {
      if (++v9 == (const void **)v50)
        goto LABEL_11;
    }
  }
  if (v9 == (const void **)v50)
  {
LABEL_11:
    v13 = operator new();
    v14 = v13;
    *(_BYTE *)(v13 + 8) = 1;
    *(_QWORD *)v13 = &off_24D5DFDA0;
    *(_QWORD *)(v13 + 12) = 0;
    v12 = (char *)(v13 + 12);
    *(_BYTE *)(v13 + 20) = 0;
    v15 = v50;
    if ((unint64_t)v50 >= *((_QWORD *)&v50 + 1))
    {
      v17 = (uint64_t)(v50 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v17 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v18 = (uint64_t)(*((_QWORD *)&v50 + 1) - (unint64_t)__p[1]) >> 2;
      if (v18 <= v17 + 1)
        v18 = v17 + 1;
      if (*((_QWORD *)&v50 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v19 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v19 = v18;
      if (v19)
        v20 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v50 + 8, v19);
      else
        v20 = 0;
      v21 = (uint64_t *)&v20[8 * v17];
      v22 = &v20[8 * v19];
      *v21 = v14;
      v16 = v21 + 1;
      v24 = (char *)__p[1];
      v23 = (char *)v50;
      if ((void *)v50 != __p[1])
      {
        do
        {
          v25 = *((_QWORD *)v23 - 1);
          v23 -= 8;
          *--v21 = v25;
        }
        while (v23 != v24);
        v23 = (char *)__p[1];
      }
      __p[1] = v21;
      *(_QWORD *)&v50 = v16;
      *((_QWORD *)&v50 + 1) = v22;
      if (v23)
        operator delete(v23);
    }
    else
    {
      *(_QWORD *)v50 = v13;
      v16 = (_QWORD *)(v15 + 8);
    }
    *(_QWORD *)&v50 = v16;
  }
  else
  {
    if (!v11)
      __cxa_bad_cast();
    v12 = v11 + 12;
  }
  v12[8] = 0;
  if (a3)
    v26 = 1;
  else
    v26 = 2;
  *(_DWORD *)v12 = v8;
  *((_DWORD *)v12 + 1) = v26;
  v27 = (const void **)__p[1];
  if (__p[1] != (void *)v50)
  {
    while (*((unsigned __int8 *)*v27 + 8) != 193)
    {
      if (++v27 == (const void **)v50)
        goto LABEL_38;
    }
  }
  if (v27 == (const void **)v50)
  {
LABEL_38:
    v30 = operator new();
    v31 = v30;
    *(_BYTE *)(v30 + 8) = -63;
    *(_QWORD *)v30 = &off_24D5DFDF0;
    *(_DWORD *)(v30 + 12) = 0;
    v29 = (_DWORD *)(v30 + 12);
    v32 = v50;
    if ((unint64_t)v50 >= *((_QWORD *)&v50 + 1))
    {
      v34 = (uint64_t)(v50 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v34 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v35 = (uint64_t)(*((_QWORD *)&v50 + 1) - (unint64_t)__p[1]) >> 2;
      if (v35 <= v34 + 1)
        v35 = v34 + 1;
      if (*((_QWORD *)&v50 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v36 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v36 = v35;
      if (v36)
        v37 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v50 + 8, v36);
      else
        v37 = 0;
      v38 = (uint64_t *)&v37[8 * v34];
      v39 = &v37[8 * v36];
      *v38 = v31;
      v33 = v38 + 1;
      v41 = (char *)__p[1];
      v40 = (char *)v50;
      if ((void *)v50 != __p[1])
      {
        do
        {
          v42 = *((_QWORD *)v40 - 1);
          v40 -= 8;
          *--v38 = v42;
        }
        while (v40 != v41);
        v40 = (char *)__p[1];
      }
      __p[1] = v38;
      *(_QWORD *)&v50 = v33;
      *((_QWORD *)&v50 + 1) = v39;
      if (v40)
        operator delete(v40);
    }
    else
    {
      *(_QWORD *)v50 = v30;
      v33 = (_QWORD *)(v32 + 8);
    }
    *(_QWORD *)&v50 = v33;
  }
  else
  {
    if (!v28)
      __cxa_bad_cast();
    v29 = v28 + 12;
  }
  *v29 = a2;
  v47 = QMIServiceMsg::create();
  v43 = MEMORY[0x24BDAC760];
  v52[0] = MEMORY[0x24BDAC760];
  v52[1] = 1174405120;
  v52[2] = ___ZNK20QMIDataContextIPBase16queryAnbrBitrateEjbNSt3__18functionIFvbEEE_block_invoke;
  v52[3] = &__block_descriptor_tmp_229_0;
  v52[4] = a1;
  v44 = v53;
  std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100]((uint64_t)v53, a4);
  aBlock[0] = v43;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3wds16ANBRQueryBitrate8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
  aBlock[3] = &unk_24D5DFE20;
  aBlock[4] = v52;
  v45 = _Block_copy(aBlock);
  v48 = v45;
  if (v47)
  {
    qmi::Client::send();
    v45 = v48;
  }
  if (v45)
    _Block_release(v45);
  if (v54 == v53)
  {
    v46 = 4;
    goto LABEL_63;
  }
  if (v54)
  {
    v46 = 5;
    v44 = v54;
LABEL_63:
    (*(void (**)(_QWORD *))(*v44 + 8 * v46))(v44);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
  return 1;
}

void sub_216A0EF3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,_QWORD *a33)
{
  _QWORD *v33;
  uint64_t v35;

  if (a33 == v33)
  {
    v35 = 4;
  }
  else
  {
    if (!a33)
      goto LABEL_6;
    v35 = 5;
    v33 = a33;
  }
  (*(void (**)(_QWORD *))(*v33 + 8 * v35))(v33);
LABEL_6:
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)&a10);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a15);
  _Unwind_Resume(a1);
}

uint64_t ___ZNK20QMIDataContextIPBase16queryAnbrBitrateEjbNSt3__18functionIFvbEEE_block_invoke(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v7;
  int v8;
  int v9;
  uint64_t v10;
  __int16 v11;
  int v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)(a2 + 4))
  {
    v4 = *(NSObject **)(*(_QWORD *)(a1 + 32) + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v7 = qmi::asString();
      v8 = *(_DWORD *)(a2 + 4);
      v9 = 136315394;
      v10 = v7;
      v11 = 1024;
      v12 = v8;
      _os_log_error_impl(&dword_216897000, v4, OS_LOG_TYPE_ERROR, "ANBRQueryBitrate failed: %s (%d)", (uint8_t *)&v9, 0x12u);
    }
    LOBYTE(v9) = 0;
  }
  else
  {
    LOBYTE(v9) = 1;
  }
  v5 = *(_QWORD *)(a1 + 64);
  if (!v5)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, int *))(*(_QWORD *)v5 + 48))(v5, &v9);
}

void QMIDataContextIPBase::updateAnbrFilters(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6;
  NSObject *v7;
  uint64_t v8;
  __int128 v9;
  void *v10;
  __int128 v11;
  __int128 v12;
  NSObject *v13;
  uint64_t v14;
  __int128 v15;
  __int128 v16[2];
  std::string v17;
  char v18;
  char v19;
  std::string v20;
  char v21;
  char v22;
  _QWORD v23[2];
  __int128 v24[2];
  std::string v25;
  char v26;
  char v27;
  std::string __p;
  char v29;
  char v30;
  _QWORD v31[2];
  void *v32[2];
  __int128 v33;
  __int128 v34;
  uint8_t buf[16];
  __int128 v36;
  __n128 v37;
  __int128 v38;
  __int128 v39;
  __n128 v40[2];
  __int128 v41;
  __int128 v42;
  __int128 v43;
  char v44;
  char v45;
  uint64_t v46;

  v46 = *MEMORY[0x24BDAC8D0];
  if (!*(_QWORD *)(a1 + 160))
    return;
  if (*(_BYTE *)(a2 + 160))
    goto LABEL_3;
  if (*(_BYTE *)(a3 + 160))
  {
    v42 = 0u;
    v43 = 0u;
    v41 = 0u;
    v39 = 0u;
    memset(v40, 0, sizeof(v40));
    v37 = 0u;
    v38 = 0u;
    v11 = *(_OWORD *)(a3 + 16);
    *(_OWORD *)buf = *(_OWORD *)a3;
    v36 = v11;
    std::__optional_copy_base<DataIPFilterEndpoint,false>::__optional_copy_base[abi:ne180100]((std::string *)&v37, a3 + 32);
    std::__optional_copy_base<DataIPFilterEndpoint,false>::__optional_copy_base[abi:ne180100]((std::string *)&v40[0].n128_i8[8], a3 + 88);
    *(_QWORD *)&v43 = *(_QWORD *)(a3 + 144);
    *(_QWORD *)((char *)&v43 + 6) = *(_QWORD *)(a3 + 150);
    if ((v40[0].n128_u8[0] != 0) != (BYTE8(v42) != 0))
    {
      if (v40[0].n128_u8[0])
      {
        v40[0].n128_u8[8] = 0;
        LOBYTE(v41) = 0;
        if (BYTE8(v38))
        {
          *(__n128 *)((char *)v40 + 8) = v37;
          v40[1].n128_u64[1] = v38;
          *(_QWORD *)&v38 = 0;
          v37 = 0uLL;
          LOBYTE(v41) = 1;
        }
        *((_QWORD *)&v41 + 1) = v39;
        LOBYTE(v42) = BYTE8(v39);
        BYTE8(v42) = 1;
        if (BYTE8(v38) && SBYTE7(v38) < 0)
          operator delete((void *)v37.n128_u64[0]);
        v40[0].n128_u8[0] = 0;
      }
      else
      {
        v37.n128_u8[0] = 0;
        BYTE8(v38) = 0;
        if ((_BYTE)v41)
        {
          v37 = *(__n128 *)((char *)v40 + 8);
          *(_QWORD *)&v38 = v40[1].n128_u64[1];
          memset(&v40[0].n128_i8[8], 0, 24);
          BYTE8(v38) = 1;
        }
        *(_QWORD *)&v39 = *((_QWORD *)&v41 + 1);
        BYTE8(v39) = v42;
        v40[0].n128_u8[0] = 1;
        if (BYTE8(v42))
        {
          if ((_BYTE)v41 && v40[1].n128_i8[15] < 0)
            operator delete((void *)v40[0].n128_u64[1]);
          BYTE8(v42) = 0;
        }
      }
    }
    else if (v40[0].n128_u8[0])
    {
      v33 = 0u;
      v34 = 0u;
      *(_OWORD *)v32 = 0u;
      if (BYTE8(v38))
      {
        *(__n128 *)v32 = v37;
        *(_QWORD *)&v33 = v38;
        *(_QWORD *)&v38 = 0;
        v37 = 0uLL;
        BYTE8(v33) = 1;
      }
      *(_QWORD *)&v34 = v39;
      BYTE8(v34) = BYTE8(v39);
      std::__optional_storage_base<std::string,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<std::string,false>>((uint64_t)&v37, (__n128 *)&v40[0].n128_i8[8]);
      *(_QWORD *)&v39 = *((_QWORD *)&v41 + 1);
      BYTE8(v39) = v42;
      std::__optional_storage_base<std::string,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<std::string,false>>((uint64_t)&v40[0].n128_i64[1], (__n128 *)v32);
      *((_QWORD *)&v41 + 1) = v34;
      LOBYTE(v42) = BYTE8(v34);
      if (BYTE8(v33) && SBYTE7(v33) < 0)
        operator delete(v32[0]);
    }
    if (*(_BYTE *)(a2 + 160))
    {
      v15 = v36;
      *(_OWORD *)a2 = *(_OWORD *)buf;
      *(_OWORD *)(a2 + 16) = v15;
      std::__optional_storage_base<DataIPFilterEndpoint,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<DataIPFilterEndpoint,false>>(a2 + 32, &v37);
      std::__optional_storage_base<DataIPFilterEndpoint,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<DataIPFilterEndpoint,false>>(a2 + 88, (__n128 *)&v40[0].n128_i8[8]);
      *(_QWORD *)(a2 + 144) = v43;
      *(_QWORD *)(a2 + 150) = *(_QWORD *)((char *)&v43 + 6);
    }
    else
    {
      std::construct_at[abi:ne180100]<DataIPFilter,DataIPFilter,DataIPFilter*>(a2, (uint64_t)buf);
      *(_BYTE *)(a2 + 160) = 1;
    }
    if (BYTE8(v42) && (_BYTE)v41 && v40[1].n128_i8[15] < 0)
      operator delete((void *)v40[0].n128_u64[1]);
    if (v40[0].n128_u8[0] && BYTE8(v38) && SBYTE7(v38) < 0)
      operator delete((void *)v37.n128_u64[0]);
LABEL_3:
    buf[0] = 0;
    v44 = 0;
    std::__optional_storage_base<DataIPFilter,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<DataIPFilter,false>>(a3, (uint64_t)buf);
    std::__optional_destruct_base<DataIPFilter,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)buf);
  }
  v6 = *(unsigned __int8 *)(a2 + 160);
  if (*(_BYTE *)(a2 + 160))
  {
    DataIPFilter::adjust((DataIPFilter *)a2);
    v6 = *(unsigned __int8 *)(a2 + 160);
  }
  if (*(_BYTE *)(a1 + 856))
  {
    if (v6)
    {
      if (!DataIPFilter::equivalent((DataIPFilter *)a2, (const DataIPFilter *)(a1 + 680), 0))
      {
        if (!*(_BYTE *)(a1 + 856))
          std::__throw_bad_optional_access[abi:ne180100]();
        QMIDataContextIPBase::shutdownAnbrHandle((QMIDataContextIPBase *)a1, *(_DWORD *)(a1 + 840));
        v7 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          if (!*(_BYTE *)(a1 + 856))
            std::__throw_bad_optional_access[abi:ne180100]();
          v8 = *(unsigned int *)(a1 + 840);
          *(_DWORD *)buf = 134217984;
          *(_QWORD *)&buf[4] = v8;
          _os_log_impl(&dword_216897000, v7, OS_LOG_TYPE_DEFAULT, "#I ANBRFilter: handle %lu removed (2)", buf, 0xCu);
        }
        buf[0] = 0;
        v45 = 0;
        std::__optional_storage_base<AnbrFilterInfo,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<AnbrFilterInfo,false>>(a1 + 680, (uint64_t)buf);
        std::__optional_destruct_base<AnbrFilterInfo,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)buf);
        if (!*(_BYTE *)(a2 + 160))
          std::__throw_bad_optional_access[abi:ne180100]();
        v9 = *(_OWORD *)(a2 + 16);
        v24[0] = *(_OWORD *)a2;
        v24[1] = v9;
        std::__optional_copy_base<DataIPFilterEndpoint,false>::__optional_copy_base[abi:ne180100](&v25, a2 + 32);
        std::__optional_copy_base<DataIPFilterEndpoint,false>::__optional_copy_base[abi:ne180100](&__p, a2 + 88);
        v31[0] = *(_QWORD *)(a2 + 144);
        *(_QWORD *)((char *)v31 + 6) = *(_QWORD *)(a2 + 150);
        QMIDataContextIPBase::setAnbrFilter((_QWORD *)a1, v24);
        if (v30 && v29 && SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
        if (v27 && v26 && SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0)
        {
          v10 = (void *)v25.__r_.__value_.__r.__words[0];
LABEL_40:
          operator delete(v10);
        }
      }
    }
    else
    {
      QMIDataContextIPBase::shutdownAnbrHandle((QMIDataContextIPBase *)a1, (int *)(a1 + 680));
      v13 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        if (!*(_BYTE *)(a1 + 856))
          std::__throw_bad_optional_access[abi:ne180100]();
        v14 = *(unsigned int *)(a1 + 840);
        *(_DWORD *)buf = 134217984;
        *(_QWORD *)&buf[4] = v14;
        _os_log_impl(&dword_216897000, v13, OS_LOG_TYPE_DEFAULT, "#I ANBRFilter: handle %lu removed (3)", buf, 0xCu);
      }
      buf[0] = 0;
      v45 = 0;
      std::__optional_storage_base<AnbrFilterInfo,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<AnbrFilterInfo,false>>(a1 + 680, (uint64_t)buf);
      std::__optional_destruct_base<AnbrFilterInfo,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)buf);
    }
  }
  else if (v6)
  {
    v12 = *(_OWORD *)(a2 + 16);
    v16[0] = *(_OWORD *)a2;
    v16[1] = v12;
    std::__optional_copy_base<DataIPFilterEndpoint,false>::__optional_copy_base[abi:ne180100](&v17, a2 + 32);
    std::__optional_copy_base<DataIPFilterEndpoint,false>::__optional_copy_base[abi:ne180100](&v20, a2 + 88);
    v23[0] = *(_QWORD *)(a2 + 144);
    *(_QWORD *)((char *)v23 + 6) = *(_QWORD *)(a2 + 150);
    QMIDataContextIPBase::setAnbrFilter((_QWORD *)a1, v16);
    if (v22 && v21 && SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v20.__r_.__value_.__l.__data_);
    if (v19 && v18 && SHIBYTE(v17.__r_.__value_.__r.__words[2]) < 0)
    {
      v10 = (void *)v17.__r_.__value_.__r.__words[0];
      goto LABEL_40;
    }
  }
}

void sub_216A0F64C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19, uint64_t a20,uint64_t a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,char a29,uint64_t a30,uint64_t a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,int a41,__int16 a42,char a43,char a44,char a45,uint64_t a46,uint64_t a47,char a48,void *__p,uint64_t a50,int a51,__int16 a52,char a53,char a54,char a55,uint64_t a56,uint64_t a57,char a58)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

void QMIDataContextIPBase::setAnbrFilter(_QWORD *a1, __int128 *a2)
{
  NSObject *v4;
  int v5;
  int v6;
  int v7;
  NSObject *v8;
  const void **v9;
  __int128 v10;
  const void **v11;
  char *v12;
  _DWORD *v13;
  char *v14;
  unsigned __int8 *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD *v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  char *v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  char *v31;
  uint64_t *v32;
  char *v33;
  char *v34;
  char *v35;
  uint64_t v36;
  const void **v37;
  char *v38;
  _DWORD *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  _QWORD *v43;
  uint64_t v44;
  unint64_t v45;
  unint64_t v46;
  char *v47;
  uint64_t *v48;
  char *v49;
  char *v50;
  char *v51;
  uint64_t v52;
  uint64_t *v53;
  char *v54;
  char *v55;
  char *v56;
  uint64_t v57;
  std::string::value_type v58;
  __int128 v59;
  const void **v60;
  char *v61;
  unsigned __int8 *v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  _QWORD *v66;
  uint64_t v67;
  unint64_t v68;
  unint64_t v69;
  char *v70;
  uint64_t *v71;
  char *v72;
  char *v73;
  char *v74;
  uint64_t v75;
  char v76;
  int v77;
  char *v78;
  int v79;
  __int128 v80;
  const void **v81;
  char *v82;
  _WORD *v83;
  NSObject *v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  _QWORD *v88;
  uint64_t v89;
  unint64_t v90;
  unint64_t v91;
  char *v92;
  uint64_t *v93;
  char *v94;
  char *v95;
  char *v96;
  uint64_t v97;
  int v98;
  __int128 v99;
  const void **v100;
  char *v101;
  _WORD *v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  _QWORD *v106;
  uint64_t v107;
  unint64_t v108;
  unint64_t v109;
  char *v110;
  uint64_t *v111;
  char *v112;
  char *v113;
  char *v114;
  uint64_t v115;
  uint64_t v116;
  __int128 v117;
  uint64_t v118;
  void *v119;
  _QWORD v120[5];
  __int128 v121;
  __int128 v122;
  std::string v123;
  char v124;
  char v125;
  std::string v126;
  char v127;
  char v128;
  _QWORD v129[2];
  _QWORD *v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  void *aBlock;
  void *__p[2];
  __int128 v136;
  uint8_t buf[16];
  _BYTE v138[24];
  __int128 v139;
  std::string v140;
  unsigned __int8 v141;
  std::string v142;
  std::string v143;
  char v144;
  _QWORD v145[2];
  char v146;
  _QWORD v147[3];

  v147[2] = *MEMORY[0x24BDAC8D0];
  if (!a1[20])
  {
    v8 = a1[5];
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_216897000, v8, OS_LOG_TYPE_ERROR, "setAnbrFilter after client is deleted", buf, 2u);
    }
    return;
  }
  DataIPFilter::adjust((DataIPFilter *)a2);
  v4 = a1[5];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v5 = *((_DWORD *)a2 + 7);
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v5;
    _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I setting filter for family: %d", buf, 8u);
  }
  v6 = (*(uint64_t (**)(_QWORD *))(*a1 + 232))(a1);
  v7 = *((_DWORD *)a2 + 7);
  if (v6 == 1)
  {
    if (v7 != 4)
      return;
  }
  else if (v7 != 41)
  {
    return;
  }
  *(_OWORD *)__p = 0u;
  v136 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  if ((*(unsigned int (**)(_QWORD *))(*a1 + 232))(a1) == 1)
  {
    *(_DWORD *)qmi::MutableMessageBase::getTLV<wds::tlv::IpType>(__p) = 4;
    if (*((_BYTE *)a2 + 80) && *((_BYTE *)a2 + 56))
    {
      memset(buf, 0, sizeof(buf));
      *(_QWORD *)v138 = 0;
      MEMORY[0x2199FD8E8](buf, a2 + 2);
      CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)&v130, (const CSIPacketAddress *)buf);
      v9 = (const void **)__p[1];
      if (__p[1] != (void *)v136)
      {
        while (*((_BYTE *)*v9 + 8) != 17)
        {
          if (++v9 == (const void **)v136)
            goto LABEL_29;
        }
      }
      if (v9 == (const void **)v136)
      {
LABEL_29:
        v16 = operator new();
        v17 = v16;
        *(_BYTE *)(v16 + 8) = 17;
        *(_QWORD *)v16 = &off_24D5DFEB8;
        *(_DWORD *)(v16 + 12) = 0;
        v13 = (_DWORD *)(v16 + 12);
        v18 = v136;
        if ((unint64_t)v136 >= *((_QWORD *)&v136 + 1))
        {
          v24 = (uint64_t)(v136 - (unint64_t)__p[1]) >> 3;
          if ((unint64_t)(v24 + 1) >> 61)
            std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
          v25 = (uint64_t)(*((_QWORD *)&v136 + 1) - (unint64_t)__p[1]) >> 2;
          if (v25 <= v24 + 1)
            v25 = v24 + 1;
          if (*((_QWORD *)&v136 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
            v26 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v26 = v25;
          if (v26)
            v27 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v136 + 8, v26);
          else
            v27 = 0;
          v32 = (uint64_t *)&v27[8 * v24];
          v33 = &v27[8 * v26];
          *v32 = v17;
          v19 = v32 + 1;
          v35 = (char *)__p[1];
          v34 = (char *)v136;
          if ((void *)v136 != __p[1])
          {
            do
            {
              v36 = *((_QWORD *)v34 - 1);
              v34 -= 8;
              *--v32 = v36;
            }
            while (v34 != v35);
            v34 = (char *)__p[1];
          }
          __p[1] = v32;
          *(_QWORD *)&v136 = v19;
          *((_QWORD *)&v136 + 1) = v33;
          if (v34)
            operator delete(v34);
        }
        else
        {
          *(_QWORD *)v136 = v16;
          v19 = (_QWORD *)(v18 + 8);
        }
        *(_QWORD *)&v136 = v19;
      }
      else
      {
        if (!v12)
          __cxa_bad_cast();
        v13 = v12 + 12;
      }
      *v13 = CSIPacketAddress::toIPv4LE((CSIPacketAddress *)&v130);
    }
    if (*((_BYTE *)a2 + 136) && *((_BYTE *)a2 + 112))
    {
      memset(buf, 0, sizeof(buf));
      *(_QWORD *)v138 = 0;
      MEMORY[0x2199FD8E8](buf, (char *)a2 + 88);
      CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)&v130, (const CSIPacketAddress *)buf);
      v37 = (const void **)__p[1];
      if (__p[1] != (void *)v136)
      {
        while (*((_BYTE *)*v37 + 8) != 19)
        {
          if (++v37 == (const void **)v136)
            goto LABEL_66;
        }
      }
      if (v37 == (const void **)v136)
      {
LABEL_66:
        v40 = operator new();
        v41 = v40;
        *(_BYTE *)(v40 + 8) = 19;
        *(_QWORD *)v40 = &off_24D5DFF08;
        *(_DWORD *)(v40 + 12) = 0;
        v39 = (_DWORD *)(v40 + 12);
        v42 = v136;
        if ((unint64_t)v136 >= *((_QWORD *)&v136 + 1))
        {
          v44 = (uint64_t)(v136 - (unint64_t)__p[1]) >> 3;
          if ((unint64_t)(v44 + 1) >> 61)
            std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
          v45 = (uint64_t)(*((_QWORD *)&v136 + 1) - (unint64_t)__p[1]) >> 2;
          if (v45 <= v44 + 1)
            v45 = v44 + 1;
          if (*((_QWORD *)&v136 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
            v46 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v46 = v45;
          if (v46)
            v47 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v136 + 8, v46);
          else
            v47 = 0;
          v48 = (uint64_t *)&v47[8 * v44];
          v49 = &v47[8 * v46];
          *v48 = v41;
          v43 = v48 + 1;
          v51 = (char *)__p[1];
          v50 = (char *)v136;
          if ((void *)v136 != __p[1])
          {
            do
            {
              v52 = *((_QWORD *)v50 - 1);
              v50 -= 8;
              *--v48 = v52;
            }
            while (v50 != v51);
            v50 = (char *)__p[1];
          }
          __p[1] = v48;
          *(_QWORD *)&v136 = v43;
          *((_QWORD *)&v136 + 1) = v49;
          if (v50)
            operator delete(v50);
        }
        else
        {
          *(_QWORD *)v136 = v40;
          v43 = (_QWORD *)(v42 + 8);
        }
        *(_QWORD *)&v136 = v43;
      }
      else
      {
        if (!v38)
          __cxa_bad_cast();
        v39 = v38 + 12;
      }
      *v39 = CSIPacketAddress::toIPv4LE((CSIPacketAddress *)&v130);
    }
  }
  else
  {
    *(_DWORD *)qmi::MutableMessageBase::getTLV<wds::tlv::IpType>(__p) = 6;
    if (*((_BYTE *)a2 + 80) && *((_BYTE *)a2 + 56))
    {
      v130 = 0;
      v131 = 0;
      v132 = 0;
      MEMORY[0x2199FD8E8](&v130, a2 + 2);
      CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)buf, (const CSIPacketAddress *)&v130);
      v10 = a2[1];
      *(_OWORD *)&v138[8] = *a2;
      v139 = v10;
      std::__optional_copy_base<DataIPFilterEndpoint,false>::__optional_copy_base[abi:ne180100](&v140, (uint64_t)(a2 + 2));
      std::__optional_copy_base<DataIPFilterEndpoint,false>::__optional_copy_base[abi:ne180100](&v143, (uint64_t)a2 + 88);
      v147[0] = *((_QWORD *)a2 + 18);
      *(_QWORD *)((char *)v147 + 6) = *(_QWORD *)((char *)a2 + 150);
      v11 = (const void **)__p[1];
      if (__p[1] != (void *)v136)
      {
        while (*((_BYTE *)*v11 + 8) != 18)
        {
          if (++v11 == (const void **)v136)
            goto LABEL_31;
        }
      }
      if (v11 == (const void **)v136)
      {
LABEL_31:
        v20 = operator new();
        v21 = v20;
        *(_BYTE *)(v20 + 8) = 18;
        *(_QWORD *)(v20 + 9) = 0;
        v15 = (unsigned __int8 *)(v20 + 9);
        *(_QWORD *)v20 = &off_24D5DFF58;
        *(_QWORD *)(v20 + 17) = 0;
        *(_BYTE *)(v20 + 25) = 0;
        v22 = v136;
        if ((unint64_t)v136 >= *((_QWORD *)&v136 + 1))
        {
          v28 = (uint64_t)(v136 - (unint64_t)__p[1]) >> 3;
          if ((unint64_t)(v28 + 1) >> 61)
            std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
          v29 = (uint64_t)(*((_QWORD *)&v136 + 1) - (unint64_t)__p[1]) >> 2;
          if (v29 <= v28 + 1)
            v29 = v28 + 1;
          if (*((_QWORD *)&v136 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
            v30 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v30 = v29;
          if (v30)
            v31 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v136 + 8, v30);
          else
            v31 = 0;
          v53 = (uint64_t *)&v31[8 * v28];
          v54 = &v31[8 * v30];
          *v53 = v21;
          v23 = v53 + 1;
          v56 = (char *)__p[1];
          v55 = (char *)v136;
          if ((void *)v136 != __p[1])
          {
            do
            {
              v57 = *((_QWORD *)v55 - 1);
              v55 -= 8;
              *--v53 = v57;
            }
            while (v55 != v56);
            v55 = (char *)__p[1];
          }
          __p[1] = v53;
          *(_QWORD *)&v136 = v23;
          *((_QWORD *)&v136 + 1) = v54;
          if (v55)
            operator delete(v55);
        }
        else
        {
          *(_QWORD *)v136 = v20;
          v23 = (_QWORD *)(v22 + 8);
        }
        *(_QWORD *)&v136 = v23;
      }
      else
      {
        if (!v14)
          __cxa_bad_cast();
        v15 = (unsigned __int8 *)(v14 + 9);
      }
      CSIPacketAddress::toIPv6((CSIPacketAddress *)buf, v15);
      if (!v142.__r_.__value_.__s.__data_[16])
        std::__throw_bad_optional_access[abi:ne180100]();
      if (v142.__r_.__value_.__s.__data_[1])
        v58 = v142.__r_.__value_.__s.__data_[0];
      else
        v58 = 0x80;
      v15[16] = v58;
      if (v146 && v144 && SHIBYTE(v143.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v143.__r_.__value_.__l.__data_);
      if (v142.__r_.__value_.__s.__data_[16] && v141 && SHIBYTE(v140.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v140.__r_.__value_.__l.__data_);
    }
    if (*((_BYTE *)a2 + 136) && *((_BYTE *)a2 + 112))
    {
      v130 = 0;
      v131 = 0;
      v132 = 0;
      MEMORY[0x2199FD8E8](&v130, (char *)a2 + 88);
      CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)buf, (const CSIPacketAddress *)&v130);
      v59 = a2[1];
      *(_OWORD *)&v138[8] = *a2;
      v139 = v59;
      std::__optional_copy_base<DataIPFilterEndpoint,false>::__optional_copy_base[abi:ne180100](&v140, (uint64_t)(a2 + 2));
      std::__optional_copy_base<DataIPFilterEndpoint,false>::__optional_copy_base[abi:ne180100](&v143, (uint64_t)a2 + 88);
      v147[0] = *((_QWORD *)a2 + 18);
      *(_QWORD *)((char *)v147 + 6) = *(_QWORD *)((char *)a2 + 150);
      v60 = (const void **)__p[1];
      if (__p[1] != (void *)v136)
      {
        while (*((_BYTE *)*v60 + 8) != 20)
        {
          if (++v60 == (const void **)v136)
            goto LABEL_112;
        }
      }
      if (v60 == (const void **)v136)
      {
LABEL_112:
        v63 = operator new();
        v64 = v63;
        *(_BYTE *)(v63 + 8) = 20;
        *(_QWORD *)(v63 + 9) = 0;
        v62 = (unsigned __int8 *)(v63 + 9);
        *(_QWORD *)v63 = &off_24D5DFFA8;
        *(_QWORD *)(v63 + 17) = 0;
        *(_BYTE *)(v63 + 25) = 0;
        v65 = v136;
        if ((unint64_t)v136 >= *((_QWORD *)&v136 + 1))
        {
          v67 = (uint64_t)(v136 - (unint64_t)__p[1]) >> 3;
          if ((unint64_t)(v67 + 1) >> 61)
            std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
          v68 = (uint64_t)(*((_QWORD *)&v136 + 1) - (unint64_t)__p[1]) >> 2;
          if (v68 <= v67 + 1)
            v68 = v67 + 1;
          if (*((_QWORD *)&v136 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
            v69 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v69 = v68;
          if (v69)
            v70 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v136 + 8, v69);
          else
            v70 = 0;
          v71 = (uint64_t *)&v70[8 * v67];
          v72 = &v70[8 * v69];
          *v71 = v64;
          v66 = v71 + 1;
          v74 = (char *)__p[1];
          v73 = (char *)v136;
          if ((void *)v136 != __p[1])
          {
            do
            {
              v75 = *((_QWORD *)v73 - 1);
              v73 -= 8;
              *--v71 = v75;
            }
            while (v73 != v74);
            v73 = (char *)__p[1];
          }
          __p[1] = v71;
          *(_QWORD *)&v136 = v66;
          *((_QWORD *)&v136 + 1) = v72;
          if (v73)
            operator delete(v73);
        }
        else
        {
          *(_QWORD *)v136 = v63;
          v66 = (_QWORD *)(v65 + 8);
        }
        *(_QWORD *)&v136 = v66;
      }
      else
      {
        if (!v61)
          __cxa_bad_cast();
        v62 = (unsigned __int8 *)(v61 + 9);
      }
      CSIPacketAddress::toIPv6((CSIPacketAddress *)buf, v62);
      if (!v146)
        std::__throw_bad_optional_access[abi:ne180100]();
      if (BYTE1(v145[0]))
        v76 = v145[0];
      else
        v76 = 0x80;
      v62[16] = v76;
      if (v146 && v144 && SHIBYTE(v143.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v143.__r_.__value_.__l.__data_);
      if (v142.__r_.__value_.__s.__data_[16] && v141 && SHIBYTE(v140.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v140.__r_.__value_.__l.__data_);
    }
  }
  v77 = *((_DWORD *)a2 + 6);
  if (v77)
  {
    if (v77 == 17)
    {
      v78 = qmi::MutableMessageBase::getTLV<wds::tlv::IpProtoType>(__p);
      v79 = 2;
    }
    else
    {
      if (v77 != 6)
      {
        v84 = a1[5];
        if (os_log_type_enabled(v84, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&buf[4] = v77;
          _os_log_impl(&dword_216897000, v84, OS_LOG_TYPE_DEFAULT, "#E Wrong ipProtocol: %d", buf, 8u);
        }
        goto LABEL_148;
      }
      v78 = qmi::MutableMessageBase::getTLV<wds::tlv::IpProtoType>(__p);
      v79 = 1;
    }
  }
  else
  {
    v78 = qmi::MutableMessageBase::getTLV<wds::tlv::IpProtoType>(__p);
    v79 = 3;
  }
  *(_DWORD *)v78 = v79;
LABEL_148:
  if (*((_BYTE *)a2 + 80) && *((_BYTE *)a2 + 68))
  {
    v80 = a2[1];
    *(_OWORD *)buf = *a2;
    *(_OWORD *)v138 = v80;
    std::__optional_copy_base<DataIPFilterEndpoint,false>::__optional_copy_base[abi:ne180100]((std::string *)&v138[16], (uint64_t)(a2 + 2));
    std::__optional_copy_base<DataIPFilterEndpoint,false>::__optional_copy_base[abi:ne180100](&v142, (uint64_t)a2 + 88);
    v145[0] = *((_QWORD *)a2 + 18);
    *(_QWORD *)((char *)v145 + 6) = *(_QWORD *)((char *)a2 + 150);
    v81 = (const void **)__p[1];
    if (__p[1] != (void *)v136)
    {
      while (*((_BYTE *)*v81 + 8) != 22)
      {
        if (++v81 == (const void **)v136)
          goto LABEL_159;
      }
    }
    if (v81 == (const void **)v136)
    {
LABEL_159:
      v85 = operator new();
      v86 = v85;
      *(_BYTE *)(v85 + 8) = 22;
      *(_QWORD *)v85 = &off_24D5E0048;
      *(_WORD *)(v85 + 10) = 0;
      v83 = (_WORD *)(v85 + 10);
      v87 = v136;
      if ((unint64_t)v136 >= *((_QWORD *)&v136 + 1))
      {
        v89 = (uint64_t)(v136 - (unint64_t)__p[1]) >> 3;
        if ((unint64_t)(v89 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v90 = (uint64_t)(*((_QWORD *)&v136 + 1) - (unint64_t)__p[1]) >> 2;
        if (v90 <= v89 + 1)
          v90 = v89 + 1;
        if (*((_QWORD *)&v136 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v91 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v91 = v90;
        if (v91)
          v92 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v136 + 8, v91);
        else
          v92 = 0;
        v93 = (uint64_t *)&v92[8 * v89];
        v94 = &v92[8 * v91];
        *v93 = v86;
        v88 = v93 + 1;
        v96 = (char *)__p[1];
        v95 = (char *)v136;
        if ((void *)v136 != __p[1])
        {
          do
          {
            v97 = *((_QWORD *)v95 - 1);
            v95 -= 8;
            *--v93 = v97;
          }
          while (v95 != v96);
          v95 = (char *)__p[1];
        }
        __p[1] = v93;
        *(_QWORD *)&v136 = v88;
        *((_QWORD *)&v136 + 1) = v94;
        if (v95)
          operator delete(v95);
      }
      else
      {
        *(_QWORD *)v136 = v85;
        v88 = (_QWORD *)(v87 + 8);
      }
      *(_QWORD *)&v136 = v88;
    }
    else
    {
      if (!v82)
        __cxa_bad_cast();
      v83 = v82 + 10;
    }
    if (!v141 || !v140.__r_.__value_.__s.__data_[12])
      std::__throw_bad_optional_access[abi:ne180100]();
    *v83 = WORD1(v140.__r_.__value_.__r.__words[1]);
    v98 = 1;
    if (v144 && v143.__r_.__value_.__s.__data_[0] && SHIBYTE(v142.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v142.__r_.__value_.__l.__data_);
      v98 = v141;
    }
    if (v98 && v140.__r_.__value_.__s.__data_[0] && SHIBYTE(v139) < 0)
      operator delete(*(void **)&v138[16]);
  }
  if (*((_BYTE *)a2 + 136) && *((_BYTE *)a2 + 124))
  {
    v99 = a2[1];
    *(_OWORD *)buf = *a2;
    *(_OWORD *)v138 = v99;
    std::__optional_copy_base<DataIPFilterEndpoint,false>::__optional_copy_base[abi:ne180100]((std::string *)&v138[16], (uint64_t)(a2 + 2));
    std::__optional_copy_base<DataIPFilterEndpoint,false>::__optional_copy_base[abi:ne180100](&v142, (uint64_t)a2 + 88);
    v145[0] = *((_QWORD *)a2 + 18);
    *(_QWORD *)((char *)v145 + 6) = *(_QWORD *)((char *)a2 + 150);
    v100 = (const void **)__p[1];
    if (__p[1] != (void *)v136)
    {
      while (*((_BYTE *)*v100 + 8) != 23)
      {
        if (++v100 == (const void **)v136)
          goto LABEL_195;
      }
    }
    if (v100 == (const void **)v136)
    {
LABEL_195:
      v103 = operator new();
      v104 = v103;
      *(_BYTE *)(v103 + 8) = 23;
      *(_QWORD *)v103 = &off_24D5E0098;
      *(_WORD *)(v103 + 10) = 0;
      v102 = (_WORD *)(v103 + 10);
      v105 = v136;
      if ((unint64_t)v136 >= *((_QWORD *)&v136 + 1))
      {
        v107 = (uint64_t)(v136 - (unint64_t)__p[1]) >> 3;
        if ((unint64_t)(v107 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v108 = (uint64_t)(*((_QWORD *)&v136 + 1) - (unint64_t)__p[1]) >> 2;
        if (v108 <= v107 + 1)
          v108 = v107 + 1;
        if (*((_QWORD *)&v136 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v109 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v109 = v108;
        if (v109)
          v110 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v136 + 8, v109);
        else
          v110 = 0;
        v111 = (uint64_t *)&v110[8 * v107];
        v112 = &v110[8 * v109];
        *v111 = v104;
        v106 = v111 + 1;
        v114 = (char *)__p[1];
        v113 = (char *)v136;
        if ((void *)v136 != __p[1])
        {
          do
          {
            v115 = *((_QWORD *)v113 - 1);
            v113 -= 8;
            *--v111 = v115;
          }
          while (v113 != v114);
          v113 = (char *)__p[1];
        }
        __p[1] = v111;
        *(_QWORD *)&v136 = v106;
        *((_QWORD *)&v136 + 1) = v112;
        if (v113)
          operator delete(v113);
      }
      else
      {
        *(_QWORD *)v136 = v103;
        v106 = (_QWORD *)(v105 + 8);
      }
      *(_QWORD *)&v136 = v106;
    }
    else
    {
      if (!v101)
        __cxa_bad_cast();
      v102 = v101 + 10;
    }
    if (!v144 || !v143.__r_.__value_.__s.__data_[12])
      std::__throw_bad_optional_access[abi:ne180100]();
    *v102 = WORD1(v143.__r_.__value_.__r.__words[1]);
    if (v143.__r_.__value_.__s.__data_[0] && SHIBYTE(v142.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v142.__r_.__value_.__l.__data_);
    if (v141 && v140.__r_.__value_.__s.__data_[0] && SHIBYTE(v139) < 0)
      operator delete(*(void **)&v138[16]);
  }
  v130 = a1 + 18;
  v116 = QMIServiceMsg::create();
  v120[1] = 1174405120;
  v117 = a2[1];
  v121 = *a2;
  v131 = v116;
  LODWORD(v132) = 25000;
  v118 = MEMORY[0x24BDAC760];
  v133 = 0;
  aBlock = 0;
  v120[0] = MEMORY[0x24BDAC760];
  v120[2] = ___ZN20QMIDataContextIPBase13setAnbrFilterE12DataIPFilterb_block_invoke;
  v120[3] = &__block_descriptor_tmp_230_0;
  v120[4] = a1;
  v122 = v117;
  std::__optional_copy_base<DataIPFilterEndpoint,false>::__optional_copy_base[abi:ne180100](&v123, (uint64_t)(a2 + 2));
  std::__optional_copy_base<DataIPFilterEndpoint,false>::__optional_copy_base[abi:ne180100](&v126, (uint64_t)a2 + 88);
  v129[0] = *((_QWORD *)a2 + 18);
  *(_QWORD *)((char *)v129 + 6) = *(_QWORD *)((char *)a2 + 150);
  *(_QWORD *)buf = v118;
  *(_QWORD *)&buf[8] = 0x40000000;
  *(_QWORD *)v138 = ___ZNO3qmi6Client9SendProxy8callbackIRKN3wds18ANBRRegisterFilter8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
  *(_QWORD *)&v138[8] = &unk_24D5E00C8;
  *(_QWORD *)&v138[16] = v120;
  v119 = _Block_copy(buf);
  aBlock = v119;
  if (v131)
  {
    qmi::Client::send();
    v119 = aBlock;
  }
  if (v119)
    _Block_release(v119);
  if (v128 && v127 && SHIBYTE(v126.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v126.__r_.__value_.__l.__data_);
  if (v125 && v124 && SHIBYTE(v123.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v123.__r_.__value_.__l.__data_);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
}

void sub_216A10610(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,char a24,uint64_t a25,uint64_t a26,char a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33,char a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,char a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45)
{
  uint64_t v45;

  if (*(_BYTE *)(v45 - 152) && *(_BYTE *)(v45 - 176) && *(char *)(v45 - 177) < 0)
    operator delete(*(void **)(v45 - 200));
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a45);
  _Unwind_Resume(a1);
}

void sub_216A10770(void *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  JUMPOUT(0x216A10768);
}

void sub_216A10780()
{
  JUMPOUT(0x216A10768);
}

void ___ZN20QMIDataContextIPBase13setAnbrFilterE12DataIPFilterb_block_invoke(uint64_t a1, qmi::MessageBase *a2)
{
  NSObject *v3;
  uint64_t v4;
  int v5;
  uint64_t TlvValue;
  int v8;
  uint64_t v9;
  int v10;
  unsigned int v11;
  unsigned int v12;
  _OWORD *v13;
  int v14;
  NSObject *v15;
  uint64_t v16;
  __int128 v17;
  NSObject *v18;
  const void **v19;
  char *v20;
  unsigned int *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  _QWORD *v25;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;
  char *v29;
  uint64_t *v30;
  char *v31;
  char *v32;
  char *v33;
  uint64_t v34;
  void *v35;
  QMIDataContextIPBase *v36;
  __int128 v37;
  __int128 v38;
  std::string v39;
  char v40;
  char v41;
  std::string v42;
  char v43;
  char v44;
  _QWORD v45[2];
  uint64_t v46;
  __int128 v47;
  __int128 v48;
  std::string v49;
  char v50;
  char v51;
  std::string __p;
  char v53;
  char v54;
  _QWORD v55[4];
  uint64_t v56;
  int v57;
  uint64_t v58;
  void *v59;
  void *v60[2];
  __int128 v61;
  _QWORD aBlock[5];
  uint8_t buf[32];
  void *v64[2];
  __int128 v65;
  __int128 v66;
  void *v67[2];
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  char v73;
  __int128 v74;
  void (*v75)(uint64_t, qmi::MessageBase *);
  void *v76;
  QMIDataContextIPBase *v77;
  unsigned int v78;
  uint64_t v79;

  v79 = *MEMORY[0x24BDAC8D0];
  if (*((_DWORD *)a2 + 1))
  {
    v3 = *(NSObject **)(*(_QWORD *)(a1 + 32) + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      v4 = qmi::asString();
      v5 = *((_DWORD *)a2 + 1);
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = v4;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v5;
      _os_log_error_impl(&dword_216897000, v3, OS_LOG_TYPE_ERROR, "ANBRRegisterFilter failed: %s (%d)", buf, 0x12u);
    }
  }
  else
  {
    v36 = *(QMIDataContextIPBase **)(a1 + 32);
    v37 = *(_OWORD *)(a1 + 40);
    v38 = *(_OWORD *)(a1 + 56);
    std::__optional_copy_base<DataIPFilterEndpoint,false>::__optional_copy_base[abi:ne180100](&v39, a1 + 72);
    std::__optional_copy_base<DataIPFilterEndpoint,false>::__optional_copy_base[abi:ne180100](&v42, a1 + 128);
    v45[0] = *(_QWORD *)(a1 + 184);
    *(_QWORD *)((char *)v45 + 6) = *(_QWORD *)(a1 + 190);
    TlvValue = qmi::MessageBase::findTlvValue(a2);
    v9 = TlvValue;
    if (TlvValue)
    {
      v10 = v8;
      v46 = TlvValue;
      v11 = tlv::parseV<wds::tlv::ResultHandle>((unint64_t *)&v46, v8);
      if (v46)
      {
        v12 = v11;
        v13 = (_OWORD *)((char *)v36 + 680);
        if (*((_BYTE *)v36 + 856))
        {
          v14 = *((_DWORD *)v36 + 210);
          if (v14)
          {
            if (v14 != v11)
            {
              QMIDataContextIPBase::shutdownAnbrHandle(v36, v14);
              v15 = *((_QWORD *)v36 + 5);
              if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
              {
                if (!*((_BYTE *)v36 + 856))
                  std::__throw_bad_optional_access[abi:ne180100]();
                v16 = *((unsigned int *)v36 + 210);
                *(_DWORD *)buf = 134217984;
                *(_QWORD *)&buf[4] = v16;
                _os_log_impl(&dword_216897000, v15, OS_LOG_TYPE_DEFAULT, "#I ANBRFilter: handle %lu removed (4)", buf, 0xCu);
              }
            }
          }
          buf[0] = 0;
          v73 = 0;
          std::__optional_storage_base<AnbrFilterInfo,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<AnbrFilterInfo,false>>((uint64_t)v13, (uint64_t)buf);
          std::__optional_destruct_base<AnbrFilterInfo,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)buf);
        }
        v71 = 0u;
        v72 = 0u;
        v69 = 0u;
        v70 = 0u;
        *(_OWORD *)v67 = 0u;
        v68 = 0u;
        v65 = 0u;
        v66 = 0u;
        *(_OWORD *)v64 = 0u;
        memset(buf, 0, sizeof(buf));
        v47 = v37;
        v48 = v38;
        std::__optional_copy_base<DataIPFilterEndpoint,false>::__optional_copy_base[abi:ne180100](&v49, (uint64_t)&v39);
        std::__optional_copy_base<DataIPFilterEndpoint,false>::__optional_copy_base[abi:ne180100](&__p, (uint64_t)&v42);
        v55[0] = v45[0];
        *(_QWORD *)((char *)v55 + 6) = *(_QWORD *)((char *)v45 + 6);
        *(_OWORD *)buf = v47;
        *(_OWORD *)&buf[16] = v48;
        std::__optional_copy_base<DataIPFilterEndpoint,false>::__optional_copy_base[abi:ne180100]((std::string *)v64, (uint64_t)&v49);
        std::__optional_copy_base<DataIPFilterEndpoint,false>::__optional_copy_base[abi:ne180100]((std::string *)&v67[1], (uint64_t)&__p);
        *(_QWORD *)&v71 = v55[0];
        *(_QWORD *)((char *)&v71 + 6) = *(_QWORD *)((char *)v55 + 6);
        LODWORD(v72) = v12;
        *(_QWORD *)((char *)&v72 + 4) = 0;
        WORD6(v72) = 0;
        if (v54 && v53 && SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
        if (v51 && v50 && SHIBYTE(v49.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v49.__r_.__value_.__l.__data_);
        if (*((_BYTE *)v36 + 856))
        {
          v17 = *(_OWORD *)&buf[16];
          *v13 = *(_OWORD *)buf;
          *(_OWORD *)((char *)v36 + 696) = v17;
          std::__optional_storage_base<DataIPFilterEndpoint,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<DataIPFilterEndpoint,false>>((uint64_t)v36 + 712, (__n128 *)v64);
          std::__optional_storage_base<DataIPFilterEndpoint,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<DataIPFilterEndpoint,false>>((uint64_t)v36 + 768, (__n128 *)&v67[1]);
          *((_QWORD *)v36 + 103) = v71;
          *(_QWORD *)((char *)v36 + 830) = *(_QWORD *)((char *)&v71 + 6);
          *((_QWORD *)v36 + 105) = v72;
          *(_QWORD *)((char *)v36 + 846) = *(_QWORD *)((char *)&v72 + 6);
        }
        else
        {
          std::construct_at[abi:ne180100]<AnbrFilterInfo,AnbrFilterInfo,AnbrFilterInfo*>((uint64_t)v13, (uint64_t)buf);
          *((_BYTE *)v36 + 856) = 1;
        }
        v18 = *((_QWORD *)v36 + 5);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(v74) = 134217984;
          *(_QWORD *)((char *)&v74 + 4) = v12;
          _os_log_impl(&dword_216897000, v18, OS_LOG_TYPE_DEFAULT, "#I ANBRFilter: handle %lu added", (uint8_t *)&v74, 0xCu);
        }
        if (*((_QWORD *)v36 + 20))
        {
          *(_OWORD *)v60 = 0u;
          v61 = 0u;
          qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v60);
          v19 = (const void **)v60[1];
          if (v60[1] != (void *)v61)
          {
            while (*((_BYTE *)*v19 + 8) != 1)
            {
              if (++v19 == (const void **)v61)
                goto LABEL_35;
            }
          }
          if (v19 == (const void **)v61)
          {
LABEL_35:
            v22 = operator new();
            v23 = v22;
            *(_BYTE *)(v22 + 8) = 1;
            *(_QWORD *)v22 = &off_24D5DFCB0;
            *(_DWORD *)(v22 + 12) = 0;
            v21 = (unsigned int *)(v22 + 12);
            v24 = v61;
            if ((unint64_t)v61 >= *((_QWORD *)&v61 + 1))
            {
              v26 = (uint64_t)(v61 - (unint64_t)v60[1]) >> 3;
              if ((unint64_t)(v26 + 1) >> 61)
                std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
              v27 = (uint64_t)(*((_QWORD *)&v61 + 1) - (unint64_t)v60[1]) >> 2;
              if (v27 <= v26 + 1)
                v27 = v26 + 1;
              if (*((_QWORD *)&v61 + 1) - (unint64_t)v60[1] >= 0x7FFFFFFFFFFFFFF8)
                v28 = 0x1FFFFFFFFFFFFFFFLL;
              else
                v28 = v27;
              if (v28)
                v29 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v61 + 8, v28);
              else
                v29 = 0;
              v30 = (uint64_t *)&v29[8 * v26];
              v31 = &v29[8 * v28];
              *v30 = v23;
              v25 = v30 + 1;
              v33 = (char *)v60[1];
              v32 = (char *)v61;
              if ((void *)v61 != v60[1])
              {
                do
                {
                  v34 = *((_QWORD *)v32 - 1);
                  v32 -= 8;
                  *--v30 = v34;
                }
                while (v32 != v33);
                v32 = (char *)v60[1];
              }
              v60[1] = v30;
              *(_QWORD *)&v61 = v25;
              *((_QWORD *)&v61 + 1) = v31;
              if (v32)
                operator delete(v32);
            }
            else
            {
              *(_QWORD *)v61 = v22;
              v25 = (_QWORD *)(v24 + 8);
            }
            *(_QWORD *)&v61 = v25;
          }
          else
          {
            if (!v20)
              __cxa_bad_cast();
            v21 = (unsigned int *)(v20 + 12);
          }
          *v21 = v12;
          v55[3] = (char *)v36 + 144;
          v56 = QMIServiceMsg::create();
          v57 = 25000;
          v58 = 0;
          v59 = 0;
          *(_QWORD *)&v74 = MEMORY[0x24BDAC760];
          *((_QWORD *)&v74 + 1) = 0x40000000;
          v75 = ___ZN20QMIDataContextIPBase24queryAnbrActivationStateEj_block_invoke;
          v76 = &__block_descriptor_tmp_227_1;
          v77 = v36;
          v78 = v12;
          aBlock[0] = MEMORY[0x24BDAC760];
          aBlock[1] = 0x40000000;
          aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3wds24GetANBRProhibitTimerInfo8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
          aBlock[3] = &unk_24D5DFCE0;
          aBlock[4] = &v74;
          v35 = _Block_copy(aBlock);
          v59 = v35;
          if (v56)
          {
            qmi::Client::send();
            v35 = v59;
          }
          if (v35)
            _Block_release(v35);
          qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v60);
        }
        if (BYTE8(v70) && (_BYTE)v69 && SHIBYTE(v68) < 0)
          operator delete(v67[1]);
        if (LOBYTE(v67[0]) && BYTE8(v65) && SBYTE7(v65) < 0)
          operator delete(v64[0]);
      }
      else
      {
        ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 16, v9, v10);
      }
    }
    if (v44 && v43 && SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v42.__r_.__value_.__l.__data_);
    if (v41 && v40 && SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v39.__r_.__value_.__l.__data_);
  }
}

void sub_216A10DF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, char a20,uint64_t a21,uint64_t a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,char a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,void *a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,char a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,char a63)
{
  void **v63;

  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)&a58);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a63);
  if (LOBYTE(STACK[0x258]) && LOBYTE(STACK[0x240]) && SLOBYTE(STACK[0x23F]) < 0)
    operator delete((void *)STACK[0x228]);
  if (LOBYTE(STACK[0x220]) && LOBYTE(STACK[0x208]) && SLOBYTE(STACK[0x207]) < 0)
    operator delete(*v63);
  if (a33 && a30 && a29 < 0)
    operator delete(a24);
  if (a23 && a20 && a19 < 0)
    operator delete(a14);
  _Unwind_Resume(a1);
}

uint64_t QMIDataContextIPBase::dumpState(QMIDataContextIPBase *this)
{
  NSObject *v2;
  uint64_t v3;
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  const char *v7;
  size_t v8;
  _QWORD *v9;
  const std::locale::facet *v10;
  NSObject *v11;
  std::locale *v12;
  _QWORD *v13;
  _QWORD *v14;
  const char *v15;
  size_t v16;
  _QWORD *v17;
  _QWORD *v18;
  _QWORD *v19;
  const char *v20;
  size_t v21;
  _QWORD *v22;
  const std::locale::facet *v23;
  NSObject *v24;
  std::locale *v25;
  _QWORD *v26;
  _QWORD *v27;
  std::__shared_weak_count *v28;
  unint64_t *p_shared_owners;
  unint64_t v30;
  void *locale;
  uint64_t locale_high;
  _QWORD *v33;
  const std::locale::facet *v34;
  std::__shared_weak_count *v35;
  unint64_t *v36;
  unint64_t v37;
  NSObject *v38;
  std::locale *v39;
  _QWORD *v40;
  _QWORD *v41;
  const char *v42;
  size_t v43;
  _QWORD *v44;
  const std::locale::facet *v45;
  NSObject *v46;
  void *v47;
  int v48;
  _BOOL4 v49;
  std::locale::__imp *v50;
  int v51;
  int v52;
  uint64_t v53;
  const char *v54;
  NSObject *v55;
  uint32_t v56;
  _QWORD *v57;
  _QWORD *v58;
  const char *v59;
  size_t v60;
  _QWORD *v61;
  const std::locale::facet *v62;
  NSObject *v63;
  std::locale *v64;
  _QWORD *v65;
  _QWORD *v66;
  _QWORD *v67;
  _QWORD *v68;
  _QWORD *v69;
  _QWORD *v70;
  const std::locale::facet *v71;
  NSObject *v72;
  std::locale *v73;
  _QWORD *v74;
  _QWORD *v75;
  void *v76;
  uint64_t v77;
  _QWORD *v78;
  const std::locale::facet *v79;
  uint64_t v80;
  uint64_t v81;
  std::locale::id *v82;
  _QWORD *v83;
  const std::locale::facet *v84;
  NSObject *v85;
  std::locale *v86;
  _QWORD *v87;
  _QWORD *v88;
  const char *v89;
  size_t v90;
  _QWORD *v91;
  _QWORD *v92;
  _QWORD *v93;
  const char *v94;
  size_t v95;
  _QWORD *v96;
  const std::locale::facet *v97;
  NSObject *v98;
  std::locale *v99;
  _QWORD *v100;
  _QWORD *v101;
  _QWORD *v102;
  _QWORD *v103;
  const char *v104;
  size_t v105;
  _QWORD *v106;
  _QWORD *v107;
  _QWORD *v108;
  const char *v109;
  size_t v110;
  _QWORD *v111;
  const std::locale::facet *v112;
  NSObject *v113;
  std::locale *v114;
  _QWORD *v115;
  _QWORD *v116;
  _QWORD *v117;
  _QWORD *v118;
  void *v119;
  uint64_t v120;
  _QWORD *v121;
  const std::locale::facet *v122;
  NSObject *v123;
  std::locale *v124;
  const CSIPacketAddress *i;
  __int128 *v126;
  uint64_t v127;
  _QWORD *v128;
  const std::locale::facet *v129;
  NSObject *v130;
  std::locale *v131;
  _QWORD *v132;
  _QWORD *v133;
  const char *v134;
  size_t v135;
  _QWORD *v136;
  _QWORD *v137;
  _QWORD *v138;
  const std::locale::facet *v139;
  NSObject *v140;
  std::locale *v141;
  uint64_t j;
  int v143;
  uint64_t v144;
  uint64_t v145;
  _QWORD *v146;
  const std::locale::facet *v147;
  NSObject *v148;
  std::locale *v149;
  _QWORD *v150;
  _QWORD *v151;
  void *v152;
  uint64_t v153;
  NSObject *v154;
  std::locale *v155;
  uint64_t v157;
  std::__shared_weak_count *v158;
  __int128 v159;
  unsigned __int8 v160;
  std::locale v161[3];
  __int16 v162;
  uint64_t v163;
  uint8_t buf[16];
  __int128 v165;
  __int128 v166;
  __int128 v167;
  __int128 v168;
  __int128 v169;
  __int128 v170;
  _BYTE v171[144];
  uint64_t v172;
  uint64_t v173;

  v173 = *MEMORY[0x24BDAC8D0];
  v2 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v3 = *((_QWORD *)this + 72);
    *(_DWORD *)buf = 136315138;
    *(_QWORD *)&buf[4] = v3;
    _os_log_impl(&dword_216897000, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: %s:", buf, 0xCu);
  }
  v172 = 0;
  v170 = 0u;
  memset(v171, 0, sizeof(v171));
  v168 = 0u;
  v169 = 0u;
  v166 = 0u;
  v167 = 0u;
  *(_OWORD *)buf = 0u;
  v165 = 0u;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)buf);
  v4 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(buf, (uint64_t)"\t", 1);
  v5 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v4, (uint64_t)"fChannelState=", 14);
  v6 = *((int *)this + 158);
  if (v6 > 4)
    v7 = "Unknown QMIContextCommunicationChannelState";
  else
    v7 = off_24D5E02C8[v6];
  v8 = strlen(v7);
  v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)v7, v8);
  std::ios_base::getloc((const std::ios_base *)((char *)v9 + *(_QWORD *)(*v9 - 24)));
  v10 = std::locale::use_facet(v161, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 10);
  std::locale::~locale(v161);
  std::ostream::put();
  std::ostream::flush();
  v11 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)&buf[8], v161);
    v12 = SHIBYTE(v161[2].__locale_) >= 0 ? v161 : (std::locale *)v161[0].__locale_;
    LODWORD(v159) = 136315138;
    *(_QWORD *)((char *)&v159 + 4) = v12;
    _os_log_impl(&dword_216897000, v11, OS_LOG_TYPE_DEFAULT, "#I DATA:: %s", (uint8_t *)&v159, 0xCu);
    if (SHIBYTE(v161[2].__locale_) < 0)
      operator delete(v161[0].__locale_);
  }
  memset(v161, 0, sizeof(v161));
  std::stringbuf::str[abi:ne180100]((uint64_t)&buf[8], (__int128 *)v161);
  if (SHIBYTE(v161[2].__locale_) < 0)
    operator delete(v161[0].__locale_);
  v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(buf, (uint64_t)"\t", 1);
  v14 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, (uint64_t)"fDataContextIPState=", 20);
  v15 = (const char *)asString();
  v16 = strlen(v15);
  v17 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v14, (uint64_t)v15, v16);
  v18 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)", ", 2);
  v19 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)"fIpFamilyType=", 14);
  v20 = (const char *)asString();
  v21 = strlen(v20);
  v22 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)v20, v21);
  std::ios_base::getloc((const std::ios_base *)((char *)v22 + *(_QWORD *)(*v22 - 24)));
  v23 = std::locale::use_facet(v161, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v23->__vftable[2].~facet_0)(v23, 10);
  std::locale::~locale(v161);
  std::ostream::put();
  std::ostream::flush();
  v24 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
  {
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)&buf[8], v161);
    v25 = SHIBYTE(v161[2].__locale_) >= 0 ? v161 : (std::locale *)v161[0].__locale_;
    LODWORD(v159) = 136315138;
    *(_QWORD *)((char *)&v159 + 4) = v25;
    _os_log_impl(&dword_216897000, v24, OS_LOG_TYPE_DEFAULT, "#I DATA:: %s", (uint8_t *)&v159, 0xCu);
    if (SHIBYTE(v161[2].__locale_) < 0)
      operator delete(v161[0].__locale_);
  }
  memset(v161, 0, sizeof(v161));
  std::stringbuf::str[abi:ne180100]((uint64_t)&buf[8], (__int128 *)v161);
  if (SHIBYTE(v161[2].__locale_) < 0)
    operator delete(v161[0].__locale_);
  v26 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(buf, (uint64_t)"\t", 1);
  v27 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v26, (uint64_t)"fLock=", 6);
  v28 = (std::__shared_weak_count *)*((_QWORD *)this + 71);
  v157 = *((_QWORD *)this + 70);
  v158 = v28;
  if (v28)
  {
    p_shared_owners = (unint64_t *)&v28->__shared_owners_;
    do
      v30 = __ldxr(p_shared_owners);
    while (__stxr(v30 + 1, p_shared_owners));
  }
  asString((uint64_t)&v157, v161);
  if (SHIBYTE(v161[2].__locale_) >= 0)
    locale = v161;
  else
    locale = v161[0].__locale_;
  if (SHIBYTE(v161[2].__locale_) >= 0)
    locale_high = HIBYTE(v161[2].__locale_);
  else
    locale_high = (uint64_t)v161[1].__locale_;
  v33 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v27, (uint64_t)locale, locale_high);
  std::ios_base::getloc((const std::ios_base *)((char *)v33 + *(_QWORD *)(*v33 - 24)));
  v34 = std::locale::use_facet((const std::locale *)&v159, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v34->__vftable[2].~facet_0)(v34, 10);
  std::locale::~locale((std::locale *)&v159);
  std::ostream::put();
  std::ostream::flush();
  if (SHIBYTE(v161[2].__locale_) < 0)
    operator delete(v161[0].__locale_);
  v35 = v158;
  if (v158)
  {
    v36 = (unint64_t *)&v158->__shared_owners_;
    do
      v37 = __ldaxr(v36);
    while (__stlxr(v37 - 1, v36));
    if (!v37)
    {
      ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
      std::__shared_weak_count::__release_weak(v35);
    }
  }
  v38 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
  {
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)&buf[8], v161);
    v39 = SHIBYTE(v161[2].__locale_) >= 0 ? v161 : (std::locale *)v161[0].__locale_;
    LODWORD(v159) = 136315138;
    *(_QWORD *)((char *)&v159 + 4) = v39;
    _os_log_impl(&dword_216897000, v38, OS_LOG_TYPE_DEFAULT, "#I DATA:: %s", (uint8_t *)&v159, 0xCu);
    if (SHIBYTE(v161[2].__locale_) < 0)
      operator delete(v161[0].__locale_);
  }
  memset(v161, 0, sizeof(v161));
  std::stringbuf::str[abi:ne180100]((uint64_t)&buf[8], (__int128 *)v161);
  if (SHIBYTE(v161[2].__locale_) < 0)
    operator delete(v161[0].__locale_);
  v40 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(buf, (uint64_t)"\t", 1);
  v41 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v40, (uint64_t)"fStopRequestSent=", 17);
  v42 = (const char *)asStringBool();
  v43 = strlen(v42);
  v44 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v41, (uint64_t)v42, v43);
  std::ios_base::getloc((const std::ios_base *)((char *)v44 + *(_QWORD *)(*v44 - 24)));
  v45 = std::locale::use_facet(v161, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v45->__vftable[2].~facet_0)(v45, 10);
  std::locale::~locale(v161);
  std::ostream::put();
  std::ostream::flush();
  v46 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
  {
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)&buf[8], v161);
    if (SHIBYTE(v161[2].__locale_) >= 0)
      v47 = v161;
    else
      v47 = v161[0].__locale_;
    LODWORD(v159) = 136315138;
    *(_QWORD *)((char *)&v159 + 4) = v47;
    _os_log_impl(&dword_216897000, v46, OS_LOG_TYPE_DEFAULT, "#I DATA:: %s", (uint8_t *)&v159, 0xCu);
    if (SHIBYTE(v161[2].__locale_) < 0)
      operator delete(v161[0].__locale_);
    v46 = *((_QWORD *)this + 5);
  }
  v48 = *((unsigned __int8 *)this + 856);
  v49 = os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT);
  if (v48)
  {
    if (!v49)
      goto LABEL_59;
    v50 = (std::locale::__imp *)*((unsigned int *)this + 210);
    v51 = *((_DWORD *)this + 211);
    v52 = *((_DWORD *)this + 212);
    v53 = asStringBool();
    LODWORD(v161[0].__locale_) = 134218754;
    *(std::locale::__imp **)((char *)&v161[0].__locale_ + 4) = v50;
    WORD2(v161[1].__locale_) = 1024;
    *(_DWORD *)((char *)&v161[1].__locale_ + 6) = v51;
    WORD1(v161[2].__locale_) = 1024;
    HIDWORD(v161[2].__locale_) = v52;
    v162 = 2080;
    v163 = v53;
    v54 = "#I DATA:: fAnbrFilter: handle=%lu, bitrateUplink=%d, bitrateDownlink=%d, configured=%s";
    v55 = v46;
    v56 = 34;
  }
  else
  {
    if (!v49)
      goto LABEL_59;
    LOWORD(v161[0].__locale_) = 0;
    v54 = "#I DATA:: fAnbrFilter empty";
    v55 = v46;
    v56 = 2;
  }
  _os_log_impl(&dword_216897000, v55, OS_LOG_TYPE_DEFAULT, v54, (uint8_t *)v161, v56);
LABEL_59:
  memset(v161, 0, sizeof(v161));
  std::stringbuf::str[abi:ne180100]((uint64_t)&buf[8], (__int128 *)v161);
  if (SHIBYTE(v161[2].__locale_) < 0)
    operator delete(v161[0].__locale_);
  v57 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(buf, (uint64_t)"\t", 1);
  v58 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v57, (uint64_t)"fPendingChannelInitialization=", 30);
  v59 = (const char *)asStringBool();
  v60 = strlen(v59);
  v61 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v58, (uint64_t)v59, v60);
  std::ios_base::getloc((const std::ios_base *)((char *)v61 + *(_QWORD *)(*v61 - 24)));
  v62 = std::locale::use_facet(v161, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v62->__vftable[2].~facet_0)(v62, 10);
  std::locale::~locale(v161);
  std::ostream::put();
  std::ostream::flush();
  v63 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
  {
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)&buf[8], v161);
    v64 = SHIBYTE(v161[2].__locale_) >= 0 ? v161 : (std::locale *)v161[0].__locale_;
    LODWORD(v159) = 136315138;
    *(_QWORD *)((char *)&v159 + 4) = v64;
    _os_log_impl(&dword_216897000, v63, OS_LOG_TYPE_DEFAULT, "#I DATA:: %s", (uint8_t *)&v159, 0xCu);
    if (SHIBYTE(v161[2].__locale_) < 0)
      operator delete(v161[0].__locale_);
  }
  memset(v161, 0, sizeof(v161));
  std::stringbuf::str[abi:ne180100]((uint64_t)&buf[8], (__int128 *)v161);
  if (SHIBYTE(v161[2].__locale_) < 0)
    operator delete(v161[0].__locale_);
  v65 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(buf, (uint64_t)"\t", 1);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v65, (uint64_t)"fActivateTxId=", 14);
  v66 = (_QWORD *)std::ostream::operator<<();
  v67 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v66, (uint64_t)", ", 2);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v67, (uint64_t)"fPacketDataHandle=", 18);
  v68 = (_QWORD *)std::ostream::operator<<();
  v69 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v68, (uint64_t)", ", 2);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v69, (uint64_t)"fHandoverActivation=", 20);
  v70 = (_QWORD *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v70 + *(_QWORD *)(*v70 - 24)));
  v71 = std::locale::use_facet(v161, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v71->__vftable[2].~facet_0)(v71, 10);
  std::locale::~locale(v161);
  std::ostream::put();
  std::ostream::flush();
  v72 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT))
  {
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)&buf[8], v161);
    v73 = SHIBYTE(v161[2].__locale_) >= 0 ? v161 : (std::locale *)v161[0].__locale_;
    LODWORD(v159) = 136315138;
    *(_QWORD *)((char *)&v159 + 4) = v73;
    _os_log_impl(&dword_216897000, v72, OS_LOG_TYPE_DEFAULT, "#I DATA:: %s", (uint8_t *)&v159, 0xCu);
    if (SHIBYTE(v161[2].__locale_) < 0)
      operator delete(v161[0].__locale_);
  }
  memset(v161, 0, sizeof(v161));
  std::stringbuf::str[abi:ne180100]((uint64_t)&buf[8], (__int128 *)v161);
  if (SHIBYTE(v161[2].__locale_) < 0)
    operator delete(v161[0].__locale_);
  v74 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(buf, (uint64_t)"\t", 1);
  v75 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v74, (uint64_t)"fAddress=", 9);
  CSIPacketAddress::operator std::string();
  if (SHIBYTE(v161[2].__locale_) >= 0)
    v76 = v161;
  else
    v76 = v161[0].__locale_;
  if (SHIBYTE(v161[2].__locale_) >= 0)
    v77 = HIBYTE(v161[2].__locale_);
  else
    v77 = (uint64_t)v161[1].__locale_;
  v78 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v75, (uint64_t)v76, v77);
  std::ios_base::getloc((const std::ios_base *)((char *)v78 + *(_QWORD *)(*v78 - 24)));
  v79 = std::locale::use_facet((const std::locale *)&v159, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v79->__vftable[2].~facet_0)(v79, 10);
  std::locale::~locale((std::locale *)&v159);
  std::ostream::put();
  std::ostream::flush();
  if (SHIBYTE(v161[2].__locale_) < 0)
    operator delete(v161[0].__locale_);
  v80 = *((_QWORD *)this + 26);
  v81 = *((_QWORD *)this + 27);
  if (v80 != v81)
  {
    v82 = (std::locale::id *)MEMORY[0x24BEDB350];
    do
    {
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(buf, (uint64_t)"\t dns = ", 8);
      v83 = (_QWORD *)operator<<();
      std::ios_base::getloc((const std::ios_base *)((char *)v83 + *(_QWORD *)(*v83 - 24)));
      v84 = std::locale::use_facet(v161, v82);
      ((void (*)(const std::locale::facet *, uint64_t))v84->__vftable[2].~facet_0)(v84, 10);
      std::locale::~locale(v161);
      std::ostream::put();
      std::ostream::flush();
      v80 += 24;
    }
    while (v80 != v81);
  }
  v85 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v85, OS_LOG_TYPE_DEFAULT))
  {
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)&buf[8], v161);
    v86 = SHIBYTE(v161[2].__locale_) >= 0 ? v161 : (std::locale *)v161[0].__locale_;
    LODWORD(v159) = 136315138;
    *(_QWORD *)((char *)&v159 + 4) = v86;
    _os_log_impl(&dword_216897000, v85, OS_LOG_TYPE_DEFAULT, "#I DATA:: %s", (uint8_t *)&v159, 0xCu);
    if (SHIBYTE(v161[2].__locale_) < 0)
      operator delete(v161[0].__locale_);
  }
  memset(v161, 0, sizeof(v161));
  std::stringbuf::str[abi:ne180100]((uint64_t)&buf[8], (__int128 *)v161);
  if (SHIBYTE(v161[2].__locale_) < 0)
    operator delete(v161[0].__locale_);
  v87 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(buf, (uint64_t)"\t", 1);
  v88 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v87, (uint64_t)"fIPv4ConfigTimer=", 17);
  v89 = (const char *)asStringBool();
  v90 = strlen(v89);
  v91 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v88, (uint64_t)v89, v90);
  v92 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v91, (uint64_t)", ", 2);
  v93 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v92, (uint64_t)"fIPv4ConfigResume=", 18);
  v94 = (const char *)asStringBool();
  v95 = strlen(v94);
  v96 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v93, (uint64_t)v94, v95);
  std::ios_base::getloc((const std::ios_base *)((char *)v96 + *(_QWORD *)(*v96 - 24)));
  v97 = std::locale::use_facet(v161, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v97->__vftable[2].~facet_0)(v97, 10);
  std::locale::~locale(v161);
  std::ostream::put();
  std::ostream::flush();
  v98 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v98, OS_LOG_TYPE_DEFAULT))
  {
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)&buf[8], v161);
    v99 = SHIBYTE(v161[2].__locale_) >= 0 ? v161 : (std::locale *)v161[0].__locale_;
    LODWORD(v159) = 136315138;
    *(_QWORD *)((char *)&v159 + 4) = v99;
    _os_log_impl(&dword_216897000, v98, OS_LOG_TYPE_DEFAULT, "#I DATA:: %s", (uint8_t *)&v159, 0xCu);
    if (SHIBYTE(v161[2].__locale_) < 0)
      operator delete(v161[0].__locale_);
  }
  memset(v161, 0, sizeof(v161));
  std::stringbuf::str[abi:ne180100]((uint64_t)&buf[8], (__int128 *)v161);
  if (SHIBYTE(v161[2].__locale_) < 0)
    operator delete(v161[0].__locale_);
  v100 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(buf, (uint64_t)"\t", 1);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v100, (uint64_t)"fAppId=", 7);
  v101 = (_QWORD *)std::ostream::operator<<();
  v102 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v101, (uint64_t)", ", 2);
  v103 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v102, (uint64_t)"fIPv6ConfigTimer=", 17);
  v104 = (const char *)asStringBool();
  v105 = strlen(v104);
  v106 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v103, (uint64_t)v104, v105);
  v107 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v106, (uint64_t)", ", 2);
  v108 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v107, (uint64_t)"fIPv6ConfigResume=", 18);
  v109 = (const char *)asStringBool();
  v110 = strlen(v109);
  v111 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v108, (uint64_t)v109, v110);
  std::ios_base::getloc((const std::ios_base *)((char *)v111 + *(_QWORD *)(*v111 - 24)));
  v112 = std::locale::use_facet(v161, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v112->__vftable[2].~facet_0)(v112, 10);
  std::locale::~locale(v161);
  std::ostream::put();
  std::ostream::flush();
  v113 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v113, OS_LOG_TYPE_DEFAULT))
  {
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)&buf[8], v161);
    v114 = SHIBYTE(v161[2].__locale_) >= 0 ? v161 : (std::locale *)v161[0].__locale_;
    LODWORD(v159) = 136315138;
    *(_QWORD *)((char *)&v159 + 4) = v114;
    _os_log_impl(&dword_216897000, v113, OS_LOG_TYPE_DEFAULT, "#I DATA:: %s", (uint8_t *)&v159, 0xCu);
    if (SHIBYTE(v161[2].__locale_) < 0)
      operator delete(v161[0].__locale_);
  }
  memset(v161, 0, sizeof(v161));
  std::stringbuf::str[abi:ne180100]((uint64_t)&buf[8], (__int128 *)v161);
  if (SHIBYTE(v161[2].__locale_) < 0)
    operator delete(v161[0].__locale_);
  v115 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(buf, (uint64_t)"\t", 1);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v115, (uint64_t)"fIPv6DadRequired=", 17);
  v116 = (_QWORD *)std::ostream::operator<<();
  v117 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v116, (uint64_t)", ", 2);
  v118 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v117, (uint64_t)"fIPv6ConfigAddress=", 19);
  CSIPacketAddress::operator std::string();
  if (SHIBYTE(v161[2].__locale_) >= 0)
    v119 = v161;
  else
    v119 = v161[0].__locale_;
  if (SHIBYTE(v161[2].__locale_) >= 0)
    v120 = HIBYTE(v161[2].__locale_);
  else
    v120 = (uint64_t)v161[1].__locale_;
  v121 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v118, (uint64_t)v119, v120);
  std::ios_base::getloc((const std::ios_base *)((char *)v121 + *(_QWORD *)(*v121 - 24)));
  v122 = std::locale::use_facet((const std::locale *)&v159, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v122->__vftable[2].~facet_0)(v122, 10);
  std::locale::~locale((std::locale *)&v159);
  std::ostream::put();
  std::ostream::flush();
  if (SHIBYTE(v161[2].__locale_) < 0)
    operator delete(v161[0].__locale_);
  v123 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v123, OS_LOG_TYPE_DEFAULT))
  {
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)&buf[8], v161);
    v124 = SHIBYTE(v161[2].__locale_) >= 0 ? v161 : (std::locale *)v161[0].__locale_;
    LODWORD(v159) = 136315138;
    *(_QWORD *)((char *)&v159 + 4) = v124;
    _os_log_impl(&dword_216897000, v123, OS_LOG_TYPE_DEFAULT, "#I DATA:: %s", (uint8_t *)&v159, 0xCu);
    if (SHIBYTE(v161[2].__locale_) < 0)
      operator delete(v161[0].__locale_);
  }
  memset(v161, 0, sizeof(v161));
  std::stringbuf::str[abi:ne180100]((uint64_t)&buf[8], (__int128 *)v161);
  if (SHIBYTE(v161[2].__locale_) < 0)
    operator delete(v161[0].__locale_);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(buf, (uint64_t)"\tfDadAddress(", 13);
  for (i = (const CSIPacketAddress *)*((_QWORD *)this + 39);
        i != *((const CSIPacketAddress **)this + 40);
        i = (const CSIPacketAddress *)((char *)i + 24))
  {
    if (i != *((const CSIPacketAddress **)this + 39))
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(buf, (uint64_t)", ", 2);
    memset(v161, 0, sizeof(v161));
    CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)v161, i);
    CSIPacketAddress::operator std::string();
    if ((v160 & 0x80u) == 0)
      v126 = &v159;
    else
      v126 = (__int128 *)v159;
    if ((v160 & 0x80u) == 0)
      v127 = v160;
    else
      v127 = *((_QWORD *)&v159 + 1);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(buf, (uint64_t)v126, v127);
    if ((char)v160 < 0)
      operator delete((void *)v159);
  }
  v128 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(buf, (uint64_t)")", 1);
  std::ios_base::getloc((const std::ios_base *)((char *)v128 + *(_QWORD *)(*v128 - 24)));
  v129 = std::locale::use_facet(v161, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v129->__vftable[2].~facet_0)(v129, 10);
  std::locale::~locale(v161);
  std::ostream::put();
  std::ostream::flush();
  v130 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v130, OS_LOG_TYPE_DEFAULT))
  {
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)&buf[8], v161);
    v131 = SHIBYTE(v161[2].__locale_) >= 0 ? v161 : (std::locale *)v161[0].__locale_;
    LODWORD(v159) = 136315138;
    *(_QWORD *)((char *)&v159 + 4) = v131;
    _os_log_impl(&dword_216897000, v130, OS_LOG_TYPE_DEFAULT, "#I DATA:: %s", (uint8_t *)&v159, 0xCu);
    if (SHIBYTE(v161[2].__locale_) < 0)
      operator delete(v161[0].__locale_);
  }
  memset(v161, 0, sizeof(v161));
  std::stringbuf::str[abi:ne180100]((uint64_t)&buf[8], (__int128 *)v161);
  if (SHIBYTE(v161[2].__locale_) < 0)
    operator delete(v161[0].__locale_);
  v132 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(buf, (uint64_t)"\t", 1);
  v133 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v132, (uint64_t)"fAllowedIpFamily=", 17);
  v134 = (const char *)asString();
  v135 = strlen(v134);
  v136 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v133, (uint64_t)v134, v135);
  v137 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v136, (uint64_t)", ", 2);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v137, (uint64_t)"fHandoverDoubleTapAttempt=", 26);
  v138 = (_QWORD *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v138 + *(_QWORD *)(*v138 - 24)));
  v139 = std::locale::use_facet(v161, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v139->__vftable[2].~facet_0)(v139, 10);
  std::locale::~locale(v161);
  std::ostream::put();
  std::ostream::flush();
  v140 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v140, OS_LOG_TYPE_DEFAULT))
  {
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)&buf[8], v161);
    v141 = SHIBYTE(v161[2].__locale_) >= 0 ? v161 : (std::locale *)v161[0].__locale_;
    LODWORD(v159) = 136315138;
    *(_QWORD *)((char *)&v159 + 4) = v141;
    _os_log_impl(&dword_216897000, v140, OS_LOG_TYPE_DEFAULT, "#I DATA:: %s", (uint8_t *)&v159, 0xCu);
    if (SHIBYTE(v161[2].__locale_) < 0)
      operator delete(v161[0].__locale_);
  }
  memset(v161, 0, sizeof(v161));
  std::stringbuf::str[abi:ne180100]((uint64_t)&buf[8], (__int128 *)v161);
  if (SHIBYTE(v161[2].__locale_) < 0)
    operator delete(v161[0].__locale_);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(buf, (uint64_t)"\tfProxyAddrs(", 13);
  for (j = *((_QWORD *)this + 29); j != *((_QWORD *)this + 30); j += 24)
  {
    if (j != *((_QWORD *)this + 29))
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(buf, (uint64_t)", ", 2);
    v143 = *(char *)(j + 23);
    if (v143 >= 0)
      v144 = j;
    else
      v144 = *(_QWORD *)j;
    if (v143 >= 0)
      v145 = *(unsigned __int8 *)(j + 23);
    else
      v145 = *(_QWORD *)(j + 8);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(buf, v144, v145);
  }
  v146 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(buf, (uint64_t)")", 1);
  std::ios_base::getloc((const std::ios_base *)((char *)v146 + *(_QWORD *)(*v146 - 24)));
  v147 = std::locale::use_facet(v161, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v147->__vftable[2].~facet_0)(v147, 10);
  std::locale::~locale(v161);
  std::ostream::put();
  std::ostream::flush();
  v148 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v148, OS_LOG_TYPE_DEFAULT))
  {
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)&buf[8], v161);
    v149 = SHIBYTE(v161[2].__locale_) >= 0 ? v161 : (std::locale *)v161[0].__locale_;
    LODWORD(v159) = 136315138;
    *(_QWORD *)((char *)&v159 + 4) = v149;
    _os_log_impl(&dword_216897000, v148, OS_LOG_TYPE_DEFAULT, "#I DATA:: %s", (uint8_t *)&v159, 0xCu);
    if (SHIBYTE(v161[2].__locale_) < 0)
      operator delete(v161[0].__locale_);
  }
  memset(v161, 0, sizeof(v161));
  std::stringbuf::str[abi:ne180100]((uint64_t)&buf[8], (__int128 *)v161);
  if (SHIBYTE(v161[2].__locale_) < 0)
    operator delete(v161[0].__locale_);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(buf, (uint64_t)"\t pco info containerId: ", 24);
  v150 = (_QWORD *)std::ostream::operator<<();
  v151 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v150, (uint64_t)", data: ", 8);
  ctu::hex();
  if (SHIBYTE(v161[2].__locale_) >= 0)
    v152 = v161;
  else
    v152 = v161[0].__locale_;
  if (SHIBYTE(v161[2].__locale_) >= 0)
    v153 = HIBYTE(v161[2].__locale_);
  else
    v153 = (uint64_t)v161[1].__locale_;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v151, (uint64_t)v152, v153);
  if (SHIBYTE(v161[2].__locale_) < 0)
    operator delete(v161[0].__locale_);
  v154 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v154, OS_LOG_TYPE_DEFAULT))
  {
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)&buf[8], v161);
    v155 = SHIBYTE(v161[2].__locale_) >= 0 ? v161 : (std::locale *)v161[0].__locale_;
    LODWORD(v159) = 136315138;
    *(_QWORD *)((char *)&v159 + 4) = v155;
    _os_log_impl(&dword_216897000, v154, OS_LOG_TYPE_DEFAULT, "#I DATA:: %s", (uint8_t *)&v159, 0xCu);
    if (SHIBYTE(v161[2].__locale_) < 0)
      operator delete(v161[0].__locale_);
  }
  *(_QWORD *)buf = *MEMORY[0x24BEDB800];
  *(_QWORD *)&buf[*(_QWORD *)(*(_QWORD *)buf - 24)] = *(_QWORD *)(MEMORY[0x24BEDB800] + 24);
  *(_QWORD *)&buf[8] = MEMORY[0x24BEDB848] + 16;
  if (SHIBYTE(v169) < 0)
    operator delete(*((void **)&v168 + 1));
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x2199FEA70](v171);
}

void sub_216A12640(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, std::locale a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  std::ostringstream::~ostringstream((uint64_t)&a29);
  _Unwind_Resume(a1);
}

uint64_t std::__optional_destruct_base<AnbrFilterInfo,false>::~__optional_destruct_base[abi:ne180100](uint64_t a1)
{
  if (*(_BYTE *)(a1 + 176))
  {
    std::__optional_destruct_base<DataIPFilterEndpoint,false>::~__optional_destruct_base[abi:ne180100](a1 + 88);
    std::__optional_destruct_base<DataIPFilterEndpoint,false>::~__optional_destruct_base[abi:ne180100](a1 + 32);
  }
  return a1;
}

std::string *__cdecl std::string::__assign_external(std::string *this, const std::string::value_type *__s, std::string::size_type __n)
{
  unint64_t v6;
  std::string *v7;
  std::string::size_type size;
  unint64_t v9;
  unint64_t v10;

  LODWORD(v6) = SHIBYTE(this->__r_.__value_.__r.__words[2]);
  if ((v6 & 0x80000000) != 0)
  {
    v10 = this->__r_.__value_.__r.__words[2];
    v9 = (v10 & 0x7FFFFFFFFFFFFFFFLL) - 1;
    if (v9 < __n)
    {
      size = this->__r_.__value_.__l.__size_;
      goto LABEL_6;
    }
    v6 = HIBYTE(v10);
    v7 = (std::string *)this->__r_.__value_.__r.__words[0];
  }
  else
  {
    v7 = this;
    if (__n > 0x16)
    {
      size = HIBYTE(this->__r_.__value_.__r.__words[2]);
      v9 = 22;
LABEL_6:
      std::string::__grow_by_and_replace(this, v9, __n - v9, size, 0, size, __n, __s);
      return this;
    }
  }
  if (__n)
  {
    memmove(v7, __s, __n);
    LOBYTE(v6) = *((_BYTE *)&this->__r_.__value_.__s + 23);
  }
  if ((v6 & 0x80) != 0)
    this->__r_.__value_.__l.__size_ = __n;
  else
    *((_BYTE *)&this->__r_.__value_.__s + 23) = __n & 0x7F;
  v7->__r_.__value_.__s.__data_[__n] = 0;
  return this;
}

std::string *__cdecl std::string::__assign_external(std::string *this, const std::string::value_type *__s)
{
  size_t v4;

  v4 = strlen(__s);
  return std::string::__assign_external(this, __s, v4);
}

uint64_t std::vector<CSIPacketAddress>::__push_back_slow_path<CSIPacketAddress>(uint64_t a1, const CSIPacketAddress *a2)
{
  const CSIPacketAddress *v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  uint64_t v11;
  void *__p;
  CSIPacketAddress *v14;
  CSIPacketAddress *v15;
  char *v16;
  uint64_t v17;

  v3 = *(const CSIPacketAddress **)a1;
  v4 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 3);
  v5 = v4 + 1;
  if (v4 + 1 > 0xAAAAAAAAAAAAAAALL)
    std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
  v7 = a1 + 16;
  v8 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a1 + 16) - (_QWORD)v3) >> 3);
  if (2 * v8 > v5)
    v5 = 2 * v8;
  if (v8 >= 0x555555555555555)
    v9 = 0xAAAAAAAAAAAAAAALL;
  else
    v9 = v5;
  v17 = a1 + 16;
  if (v9)
    v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>(v7, v9);
  else
    v10 = 0;
  __p = v10;
  v14 = (CSIPacketAddress *)&v10[24 * v4];
  v16 = &v10[24 * v9];
  CSIPacketAddress::CSIPacketAddress(v14, a2);
  v15 = (CSIPacketAddress *)((char *)v14 + 24);
  std::vector<CSIPacketAddress>::__swap_out_circular_buffer((const CSIPacketAddress **)a1, &__p);
  v11 = *(_QWORD *)(a1 + 8);
  if (v15 != v14)
    v15 = (CSIPacketAddress *)((char *)v14 + (v15 - v14 - 24) % 0x18uLL);
  if (__p)
    operator delete(__p);
  return v11;
}

void sub_216A129F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void std::__optional_storage_base<AnbrFilterInfo,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<AnbrFilterInfo,false>>(uint64_t a1, uint64_t a2)
{
  __int128 v4;
  uint64_t v5;
  uint64_t v6;

  if (*(unsigned __int8 *)(a1 + 176) == *(unsigned __int8 *)(a2 + 176))
  {
    if (*(_BYTE *)(a1 + 176))
    {
      v4 = *(_OWORD *)(a2 + 16);
      *(_OWORD *)a1 = *(_OWORD *)a2;
      *(_OWORD *)(a1 + 16) = v4;
      std::__optional_storage_base<DataIPFilterEndpoint,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<DataIPFilterEndpoint,false>>(a1 + 32, (__n128 *)(a2 + 32));
      std::__optional_storage_base<DataIPFilterEndpoint,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<DataIPFilterEndpoint,false>>(a1 + 88, (__n128 *)(a2 + 88));
      v5 = *(_QWORD *)(a2 + 144);
      *(_QWORD *)(a1 + 150) = *(_QWORD *)(a2 + 150);
      *(_QWORD *)(a1 + 144) = v5;
      v6 = *(_QWORD *)(a2 + 160);
      *(_QWORD *)(a1 + 166) = *(_QWORD *)(a2 + 166);
      *(_QWORD *)(a1 + 160) = v6;
    }
  }
  else if (*(_BYTE *)(a1 + 176))
  {
    std::__optional_destruct_base<DataIPFilterEndpoint,false>::~__optional_destruct_base[abi:ne180100](a1 + 88);
    std::__optional_destruct_base<DataIPFilterEndpoint,false>::~__optional_destruct_base[abi:ne180100](a1 + 32);
    *(_BYTE *)(a1 + 176) = 0;
  }
  else
  {
    std::construct_at[abi:ne180100]<AnbrFilterInfo,AnbrFilterInfo,AnbrFilterInfo*>(a1, a2);
    *(_BYTE *)(a1 + 176) = 1;
  }
}

uint64_t std::construct_at[abi:ne180100]<AnbrFilterInfo,AnbrFilterInfo,AnbrFilterInfo*>(uint64_t result, uint64_t a2)
{
  __int128 v2;
  __int128 v3;
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v2 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)result = *(_OWORD *)a2;
  *(_OWORD *)(result + 16) = v2;
  *(_BYTE *)(result + 32) = 0;
  *(_BYTE *)(result + 80) = 0;
  if (*(_BYTE *)(a2 + 80))
  {
    *(_BYTE *)(result + 56) = 0;
    if (*(_BYTE *)(a2 + 56))
    {
      v3 = *(_OWORD *)(a2 + 32);
      *(_QWORD *)(result + 48) = *(_QWORD *)(a2 + 48);
      *(_OWORD *)(result + 32) = v3;
      *(_QWORD *)(a2 + 40) = 0;
      *(_QWORD *)(a2 + 48) = 0;
      *(_QWORD *)(a2 + 32) = 0;
      *(_BYTE *)(result + 56) = 1;
    }
    v4 = *(_QWORD *)(a2 + 64);
    *(_BYTE *)(result + 72) = *(_BYTE *)(a2 + 72);
    *(_QWORD *)(result + 64) = v4;
    *(_BYTE *)(result + 80) = 1;
  }
  *(_BYTE *)(result + 88) = 0;
  *(_BYTE *)(result + 136) = 0;
  if (*(_BYTE *)(a2 + 136))
  {
    *(_BYTE *)(result + 112) = 0;
    if (*(_BYTE *)(a2 + 112))
    {
      v5 = *(_OWORD *)(a2 + 88);
      *(_QWORD *)(result + 104) = *(_QWORD *)(a2 + 104);
      *(_OWORD *)(result + 88) = v5;
      *(_QWORD *)(a2 + 96) = 0;
      *(_QWORD *)(a2 + 104) = 0;
      *(_QWORD *)(a2 + 88) = 0;
      *(_BYTE *)(result + 112) = 1;
    }
    v6 = *(_QWORD *)(a2 + 120);
    *(_BYTE *)(result + 128) = *(_BYTE *)(a2 + 128);
    *(_QWORD *)(result + 120) = v6;
    *(_BYTE *)(result + 136) = 1;
  }
  v7 = *(_QWORD *)(a2 + 144);
  *(_QWORD *)(result + 150) = *(_QWORD *)(a2 + 150);
  *(_QWORD *)(result + 144) = v7;
  v8 = *(_QWORD *)(a2 + 160);
  *(_QWORD *)(result + 166) = *(_QWORD *)(a2 + 166);
  *(_QWORD *)(result + 160) = v8;
  return result;
}

void std::__optional_storage_base<DataIPFilter,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<DataIPFilter,false>>(uint64_t a1, uint64_t a2)
{
  __int128 v4;
  uint64_t v5;

  if (*(unsigned __int8 *)(a1 + 160) == *(unsigned __int8 *)(a2 + 160))
  {
    if (*(_BYTE *)(a1 + 160))
    {
      v4 = *(_OWORD *)(a2 + 16);
      *(_OWORD *)a1 = *(_OWORD *)a2;
      *(_OWORD *)(a1 + 16) = v4;
      std::__optional_storage_base<DataIPFilterEndpoint,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<DataIPFilterEndpoint,false>>(a1 + 32, (__n128 *)(a2 + 32));
      std::__optional_storage_base<DataIPFilterEndpoint,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<DataIPFilterEndpoint,false>>(a1 + 88, (__n128 *)(a2 + 88));
      v5 = *(_QWORD *)(a2 + 144);
      *(_QWORD *)(a1 + 150) = *(_QWORD *)(a2 + 150);
      *(_QWORD *)(a1 + 144) = v5;
    }
  }
  else if (*(_BYTE *)(a1 + 160))
  {
    std::__optional_destruct_base<DataIPFilterEndpoint,false>::~__optional_destruct_base[abi:ne180100](a1 + 88);
    std::__optional_destruct_base<DataIPFilterEndpoint,false>::~__optional_destruct_base[abi:ne180100](a1 + 32);
    *(_BYTE *)(a1 + 160) = 0;
  }
  else
  {
    std::construct_at[abi:ne180100]<DataIPFilter,DataIPFilter,DataIPFilter*>(a1, a2);
    *(_BYTE *)(a1 + 160) = 1;
  }
}

void _ZNSt3__110__function6__funcIN20QMIDataContextIPBase20fDefaultPendingBlockMUlvE_ENS_9allocatorIS3_EEFbvEED0Ev()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *_ZNKSt3__110__function6__funcIN20QMIDataContextIPBase20fDefaultPendingBlockMUlvE_ENS_9allocatorIS3_EEFbvEE7__cloneEv()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_24D5DF0E0;
  return result;
}

void _ZNKSt3__110__function6__funcIN20QMIDataContextIPBase20fDefaultPendingBlockMUlvE_ENS_9allocatorIS3_EEFbvEE7__cloneEPNS0_6__baseIS6_EE(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_24D5DF0E0;
}

uint64_t _ZNSt3__110__function6__funcIN20QMIDataContextIPBase20fDefaultPendingBlockMUlvE_ENS_9allocatorIS3_EEFbvEEclEv()
{
  return 0;
}

uint64_t _ZNKSt3__110__function6__funcIN20QMIDataContextIPBase20fDefaultPendingBlockMUlvE_ENS_9allocatorIS3_EEFbvEE6targetERKSt9type_info(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](a2, (uint64_t)&_ZTIN20QMIDataContextIPBase20fDefaultPendingBlockMUlvE_E))
    return a1 + 8;
  else
    return 0;
}

void *_ZNKSt3__110__function6__funcIN20QMIDataContextIPBase20fDefaultPendingBlockMUlvE_ENS_9allocatorIS3_EEFbvEE11target_typeEv()
{
  return &_ZTIN20QMIDataContextIPBase20fDefaultPendingBlockMUlvE_E;
}

void ___ZNK3qmi6Client13setIndHandlerIRKN3wds22ExtendedIPConfigChange10IndicationEEEvtU13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A12DD4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ___ZNK3qmi6Client13setIndHandlerIRKN3wds8ANBRInfo10IndicationEEEvtU13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A12ED0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ___ZNK3qmi6Client13setIndHandlerIRKN3wds21ANBRProhibitTimerInfo10IndicationEEEvtU13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A12FCC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ___ZNK3qmi6Client13setIndHandlerIRKN3wds13PktSrvcStatus10IndicationEEEvtU13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A130C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ___ZNK3qmi6Client13setIndHandlerIRKN3wds11DadComplete10IndicationEEEvtU13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A131C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

_QWORD *std::__function::__value_func<BOOL ()(void)>::swap[abi:ne180100](_QWORD *result, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD v6[4];

  v6[3] = *MEMORY[0x24BDAC8D0];
  if (a2 != result)
  {
    v3 = result;
    v4 = (_QWORD *)result[3];
    v5 = (_QWORD *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        memset(v6, 0, 24);
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, v6);
        (*(void (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(_QWORD *, _QWORD *))(v6[0] + 24))(v6, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(_QWORD *, _QWORD *))(*a2 + 24))(a2, result);
      result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_216A13374(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

_QWORD *std::__function::__func<QMIDataContextIPBase::activateDataContextIP(DataProtocolFamily,std::string const&,BOOL,std::shared_ptr<QMIActivationLock>,BOOL)::$_0,std::allocator<QMIDataContextIPBase::activateDataContextIP(DataProtocolFamily,std::string const&,BOOL,std::shared_ptr<QMIActivationLock>,BOOL)::$_0>,BOOL ()(void)>::~__func(_QWORD *a1)
{
  std::__shared_weak_count *v2;

  *a1 = &off_24D5DF238;
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)(a1 + 5));
  v2 = (std::__shared_weak_count *)a1[3];
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  return a1;
}

void std::__function::__func<QMIDataContextIPBase::activateDataContextIP(DataProtocolFamily,std::string const&,BOOL,std::shared_ptr<QMIActivationLock>,BOOL)::$_0,std::allocator<QMIDataContextIPBase::activateDataContextIP(DataProtocolFamily,std::string const&,BOOL,std::shared_ptr<QMIActivationLock>,BOOL)::$_0>,BOOL ()(void)>::~__func(_QWORD *a1)
{
  std::__shared_weak_count *v2;

  *a1 = &off_24D5DF238;
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)(a1 + 5));
  v2 = (std::__shared_weak_count *)a1[3];
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<QMIDataContextIPBase::activateDataContextIP(DataProtocolFamily,std::string const&,BOOL,std::shared_ptr<QMIActivationLock>,BOOL)::$_0,std::allocator<QMIDataContextIPBase::activateDataContextIP(DataProtocolFamily,std::string const&,BOOL,std::shared_ptr<QMIActivationLock>,BOOL)::$_0>,BOOL ()(void)>::__clone(uint64_t a1)
{
  uint64_t v1;
  _QWORD *v2;

  v1 = a1 + 8;
  v2 = operator new(0x40uLL);
  *v2 = &off_24D5DF238;
  std::__compressed_pair_elem<QMIDataContextIPBase::activateDataContextIP(DataProtocolFamily,std::string const&,BOOL,std::shared_ptr<QMIActivationLock>,BOOL)::$_0,0,false>::__compressed_pair_elem[abi:ne180100]<QMIDataContextIPBase::activateDataContextIP(DataProtocolFamily,std::string const&,BOOL,std::shared_ptr<QMIActivationLock>,BOOL)::$_0 const&,0ul>((uint64_t)(v2 + 1), v1);
  return v2;
}

uint64_t std::__function::__func<QMIDataContextIPBase::activateDataContextIP(DataProtocolFamily,std::string const&,BOOL,std::shared_ptr<QMIActivationLock>,BOOL)::$_0,std::allocator<QMIDataContextIPBase::activateDataContextIP(DataProtocolFamily,std::string const&,BOOL,std::shared_ptr<QMIActivationLock>,BOOL)::$_0>,BOOL ()(void)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_24D5DF238;
  return std::__compressed_pair_elem<QMIDataContextIPBase::activateDataContextIP(DataProtocolFamily,std::string const&,BOOL,std::shared_ptr<QMIActivationLock>,BOOL)::$_0,0,false>::__compressed_pair_elem[abi:ne180100]<QMIDataContextIPBase::activateDataContextIP(DataProtocolFamily,std::string const&,BOOL,std::shared_ptr<QMIActivationLock>,BOOL)::$_0 const&,0ul>((uint64_t)(a2 + 1), a1 + 8);
}

void std::__function::__func<QMIDataContextIPBase::activateDataContextIP(DataProtocolFamily,std::string const&,BOOL,std::shared_ptr<QMIActivationLock>,BOOL)::$_0,std::allocator<QMIDataContextIPBase::activateDataContextIP(DataProtocolFamily,std::string const&,BOOL,std::shared_ptr<QMIActivationLock>,BOOL)::$_0>,BOOL ()(void)>::destroy(uint64_t a1)
{
  std::__function::__alloc_func<QMIDataContextIPBase::activateDataContextIP(DataProtocolFamily,std::string const&,BOOL,std::shared_ptr<QMIActivationLock>,BOOL)::$_0,std::allocator<QMIDataContextIPBase::activateDataContextIP(DataProtocolFamily,std::string const&,BOOL,std::shared_ptr<QMIActivationLock>,BOOL)::$_0>,BOOL ()(void)>::destroy[abi:ne180100](a1 + 8);
}

void std::__function::__func<QMIDataContextIPBase::activateDataContextIP(DataProtocolFamily,std::string const&,BOOL,std::shared_ptr<QMIActivationLock>,BOOL)::$_0,std::allocator<QMIDataContextIPBase::activateDataContextIP(DataProtocolFamily,std::string const&,BOOL,std::shared_ptr<QMIActivationLock>,BOOL)::$_0>,BOOL ()(void)>::destroy_deallocate(void *a1)
{
  std::__function::__alloc_func<QMIDataContextIPBase::activateDataContextIP(DataProtocolFamily,std::string const&,BOOL,std::shared_ptr<QMIActivationLock>,BOOL)::$_0,std::allocator<QMIDataContextIPBase::activateDataContextIP(DataProtocolFamily,std::string const&,BOOL,std::shared_ptr<QMIActivationLock>,BOOL)::$_0>,BOOL ()(void)>::destroy[abi:ne180100]((uint64_t)a1 + 8);
  operator delete(a1);
}

uint64_t std::__function::__func<QMIDataContextIPBase::activateDataContextIP(DataProtocolFamily,std::string const&,BOOL,std::shared_ptr<QMIActivationLock>,BOOL)::$_0,std::allocator<QMIDataContextIPBase::activateDataContextIP(DataProtocolFamily,std::string const&,BOOL,std::shared_ptr<QMIActivationLock>,BOOL)::$_0>,BOOL ()(void)>::operator()(uint64_t a1)
{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  uint64_t v9;
  NSObject *v10;
  _BOOL4 v11;
  int v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  uint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  NSObject *v20;
  uint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  unint64_t *v25;
  unint64_t v26;
  uint64_t v28;
  std::__shared_weak_count *v29;
  uint64_t v30;
  std::__shared_weak_count *v31;
  uint8_t buf[4];
  const char *v33;
  __int16 v34;
  uint64_t v35;
  uint64_t v36;

  v36 = *MEMORY[0x24BDAC8D0];
  v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (!v2)
    return 0;
  v3 = *(_QWORD *)(a1 + 8);
  v4 = std::__shared_weak_count::lock(v2);
  if (!v4)
    return 0;
  v5 = v4;
  if (*(_QWORD *)(a1 + 16))
  {
    v30 = 0;
    v31 = 0;
    v6 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v3 + 104));
    (*(void (**)(uint64_t *__return_ptr))(**(_QWORD **)(v3 + 96) + 240))(&v30);
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
    v9 = v30;
    v10 = *(NSObject **)(v3 + 40);
    v11 = os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT);
    if (v9)
    {
      if (v11)
      {
        *(_DWORD *)buf = 136315138;
        v33 = "operator()";
        _os_log_impl(&dword_216897000, v10, OS_LOG_TYPE_DEFAULT, "#I %s: PendingChannelInitialization: Continuing pending activation", buf, 0xCu);
      }
      v12 = *(unsigned __int8 *)(a1 + 32);
      v13 = *(std::__shared_weak_count **)(a1 + 48);
      v28 = *(_QWORD *)(a1 + 40);
      v29 = v13;
      if (v13)
      {
        v14 = (unint64_t *)&v13->__shared_owners_;
        do
          v15 = __ldxr(v14);
        while (__stxr(v15 + 1, v14));
      }
      v16 = (*(uint64_t (**)(uint64_t, BOOL, uint64_t *, _QWORD))(*(_QWORD *)v3 + 328))(v3, v12 != 0, &v28, *(unsigned __int8 *)(a1 + 56));
      v17 = v29;
      if (v29)
      {
        v18 = (unint64_t *)&v29->__shared_owners_;
        do
          v19 = __ldaxr(v18);
        while (__stlxr(v19 - 1, v18));
        if (!v19)
        {
          ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
          std::__shared_weak_count::__release_weak(v17);
        }
      }
      v20 = *(NSObject **)(v3 + 40);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        v21 = asStringBool();
        *(_DWORD *)buf = 136315394;
        v33 = "operator()";
        v34 = 2080;
        v35 = v21;
        _os_log_impl(&dword_216897000, v20, OS_LOG_TYPE_DEFAULT, "#I %s: PendingChannelInitialization: result of pending activation is %s", buf, 0x16u);
      }
    }
    else
    {
      if (v11)
      {
        *(_DWORD *)buf = 136315138;
        v33 = "operator()";
        _os_log_impl(&dword_216897000, v10, OS_LOG_TYPE_DEFAULT, "#I %s: PendingChannelInitialization: not continuing abandoned pending activation (2)", buf, 0xCu);
      }
      v16 = 0;
    }
    v22 = v31;
    if (v31)
    {
      v23 = (unint64_t *)&v31->__shared_owners_;
      do
        v24 = __ldaxr(v23);
      while (__stlxr(v24 - 1, v23));
      if (!v24)
      {
        ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
        std::__shared_weak_count::__release_weak(v22);
      }
    }
  }
  else
  {
    v16 = 0;
  }
  v25 = (unint64_t *)&v5->__shared_owners_;
  do
    v26 = __ldaxr(v25);
  while (__stlxr(v26 - 1, v25));
  if (!v26)
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  return v16;
}

void sub_216A13768(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  std::__shared_weak_count *v12;
  unint64_t *p_shared_owners;
  unint64_t v15;
  unint64_t *v16;
  unint64_t v17;

  if (a12)
  {
    p_shared_owners = (unint64_t *)&a12->__shared_owners_;
    do
      v15 = __ldaxr(p_shared_owners);
    while (__stlxr(v15 - 1, p_shared_owners));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))a12->__on_zero_shared)(a12);
      std::__shared_weak_count::__release_weak(a12);
    }
  }
  v16 = (unint64_t *)&v12->__shared_owners_;
  do
    v17 = __ldaxr(v16);
  while (__stlxr(v17 - 1, v16));
  if (!v17)
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__function::__func<QMIDataContextIPBase::activateDataContextIP(DataProtocolFamily,std::string const&,BOOL,std::shared_ptr<QMIActivationLock>,BOOL)::$_0,std::allocator<QMIDataContextIPBase::activateDataContextIP(DataProtocolFamily,std::string const&,BOOL,std::shared_ptr<QMIActivationLock>,BOOL)::$_0>,BOOL ()(void)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<QMIDataContextIPBase::activateDataContextIP(DataProtocolFamily,std::string const&,BOOL,std::shared_ptr<QMIActivationLock>,BOOL)::$_0,std::allocator<QMIDataContextIPBase::activateDataContextIP(DataProtocolFamily,std::string const&,BOOL,std::shared_ptr<QMIActivationLock>,BOOL)::$_0>,BOOL ()(void)>::target_type()
{
}

uint64_t std::__compressed_pair_elem<QMIDataContextIPBase::activateDataContextIP(DataProtocolFamily,std::string const&,BOOL,std::shared_ptr<QMIActivationLock>,BOOL)::$_0,0,false>::__compressed_pair_elem[abi:ne180100]<QMIDataContextIPBase::activateDataContextIP(DataProtocolFamily,std::string const&,BOOL,std::shared_ptr<QMIActivationLock>,BOOL)::$_0 const&,0ul>(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;

  *(_OWORD *)result = *(_OWORD *)a2;
  v2 = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(result + 16) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 16);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  *(_BYTE *)(result + 24) = *(_BYTE *)(a2 + 24);
  v5 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  *(_BYTE *)(result + 48) = *(_BYTE *)(a2 + 48);
  return result;
}

void std::__function::__alloc_func<QMIDataContextIPBase::activateDataContextIP(DataProtocolFamily,std::string const&,BOOL,std::shared_ptr<QMIActivationLock>,BOOL)::$_0,std::allocator<QMIDataContextIPBase::activateDataContextIP(DataProtocolFamily,std::string const&,BOOL,std::shared_ptr<QMIActivationLock>,BOOL)::$_0>,BOOL ()(void)>::destroy[abi:ne180100](uint64_t a1)
{
  std::__shared_weak_count *v2;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
  v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::PktDataHandle>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::PktDataHandle>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

_DWORD **qmi::MutableMessageBase::TlvWrapper<wds::tlv::PktDataHandle>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _DWORD *v4;
  uint64_t v5;
  _DWORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_DWORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::PktDataHandle>((_DWORD **)a2, (_DWORD *)(a1 + 12));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::PktDataHandle>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5DF2D0;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a1 + 12);
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::IDataCallAppId>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::IDataCallAppId>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<wds::tlv::IDataCallAppId>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::IDataCallAppId>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5DF320;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::LocalAbort>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::LocalAbort>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<wds::tlv::LocalAbort>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::LocalAbort>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5DF370;
  return result;
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3wds16StopNetworkIface8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A13C18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::Transaction>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Transaction>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_PcoMcc>();
}

_WORD **qmi::MutableMessageBase::TlvWrapper<wds::tlv::Transaction>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _WORD *v4;
  uint64_t v5;
  _WORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_WORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::Profile3GPP_PcoMcc>((_WORD **)a2, (_WORD *)(a1 + 10));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Transaction>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5DF3E8;
  *(_WORD *)(result + 10) = *(_WORD *)(a1 + 10);
  return result;
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3wds16AbortTransaction8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A13DDC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3wds26SetHandoffWwanPduSessionId8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A13ED8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

uint64_t qmi::MessageBase::applyTlv<wds::tlv::CallEndReason,void({block_pointer})(wds::tlv::CallEndReason const&)>(qmi::MessageBase *a1, uint64_t a2)
{
  uint64_t result;
  int v5;
  uint64_t v6;
  int v7;
  __int16 v8;
  uint64_t v9;

  result = qmi::MessageBase::findTlvValue(a1);
  if (result)
  {
    v6 = result;
    v7 = v5;
    v9 = result;
    v8 = tlv::parseV<wds::tlv::CallEndReason>((unint64_t *)&v9, v5);
    if (v9)
      return (*(uint64_t (**)(void))(*(_QWORD *)a2 + 16))();
    else
      return ((uint64_t (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, 16, v6, v7);
  }
  return result;
}

uint64_t qmi::MessageBase::applyTlv<wds::tlv::VerboseCallEndReasonType,void({block_pointer})(wds::tlv::VerboseCallEndReasonType const&)>(qmi::MessageBase *a1, uint64_t a2)
{
  uint64_t result;
  int v5;
  uint64_t v6;
  int v7;
  int v8;
  uint64_t v9;

  result = qmi::MessageBase::findTlvValue(a1);
  if (result)
  {
    v6 = result;
    v7 = v5;
    v9 = result;
    v8 = tlv::parseV<wds::tlv::VerboseCallEndReasonType>((unint64_t *)&v9, v5);
    if (v9)
      return (*(uint64_t (**)(void))(*(_QWORD *)a2 + 16))();
    else
      return ((uint64_t (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, 17, v6, v7);
  }
  return result;
}

void std::__function::__func<QMIDataContextIPBase::bindDataPort(void)::$_0,std::allocator<QMIDataContextIPBase::bindDataPort(void)::$_0>,void ()(void)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<QMIDataContextIPBase::bindDataPort(void)::$_0,std::allocator<QMIDataContextIPBase::bindDataPort(void)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5DF470;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<QMIDataContextIPBase::bindDataPort(void)::$_0,std::allocator<QMIDataContextIPBase::bindDataPort(void)::$_0>,void ()(void)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5DF470;
  a2[1] = v2;
  return result;
}

_QWORD *std::__function::__func<QMIDataContextIPBase::bindDataPort(void)::$_0,std::allocator<QMIDataContextIPBase::bindDataPort(void)::$_0>,void ()(void)>::operator()(capabilities::ct *a1)
{
  _QWORD *v1;
  int v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  _QWORD *v7;
  int v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  _DWORD *v11;
  int v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  _QWORD *result;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  _OWORD v24[2];
  _QWORD aBlock[5];
  _QWORD v26[3];
  _QWORD *v27;
  _QWORD v28[3];
  _QWORD *v29;
  _QWORD *v30;
  uint64_t v31;
  uint64_t (*v32)(uint64_t, uint64_t);
  void *v33;
  _QWORD *v34;
  _BYTE v35[24];
  _BYTE *v36;
  uint64_t v37;

  v37 = *MEMORY[0x24BDAC8D0];
  v1 = (_QWORD *)*((_QWORD *)a1 + 1);
  v28[0] = &off_24D5DF4E0;
  v28[1] = v1;
  v28[2] = 0;
  v29 = v28;
  v2 = capabilities::ct::supportsGemini(a1);
  v3 = (uint64_t)v29;
  if (!v2)
  {
    if (!v29)
      std::__throw_bad_function_call[abi:ne180100]();
    (*(void (**)(void))(*v29 + 48))();
    goto LABEL_41;
  }
  if (v29)
  {
    if (v29 == v28)
    {
      v27 = v26;
      (*(void (**)(_QWORD *, _QWORD *))(v28[0] + 24))(v28, v26);
      goto LABEL_9;
    }
    v3 = (*(uint64_t (**)(void))(*v29 + 16))();
  }
  v27 = (_QWORD *)v3;
LABEL_9:
  v4 = (std::__shared_weak_count *)v1[16];
  if (v4 && (v5 = std::__shared_weak_count::lock(v4), (v31 = (uint64_t)v5) != 0))
  {
    v6 = v5;
    v7 = (_QWORD *)v1[15];
    v30 = v7;
    if (v7)
      v8 = (*(uint64_t (**)(char *))(*(_QWORD *)((char *)v7 + *(_QWORD *)(*v7 - 56)) + 24))((char *)v7 + *(_QWORD *)(*v7 - 56));
    else
      v8 = 1;
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v10 = __ldaxr(p_shared_owners);
    while (__stlxr(v10 - 1, p_shared_owners));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  else
  {
    v8 = 1;
  }
  subscriber::simSlotAsInstance();
  qmi::Client::set((qmi::Client *)(v1 + 18), (const char *)*MEMORY[0x24BED1E20]);
  memset(v24, 0, sizeof(v24));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v24);
  v11 = (_DWORD *)qmi::MutableMessageBase::getTLV<wds::tlv::SubscriptionType>(v24, 1);
  if (v8 == 2)
    v12 = 2;
  else
    v12 = 1;
  *v11 = v12;
  v22 = QMIServiceMsg::create();
  v13 = MEMORY[0x24BDAC760];
  v30 = (_QWORD *)MEMORY[0x24BDAC760];
  v31 = 1174405120;
  v32 = ___ZN20QMIDataContextIPBase21bindSubscription_syncENSt3__18functionIFvvEEE_block_invoke;
  v33 = &__block_descriptor_tmp_121_1;
  v34 = v1;
  v14 = v35;
  v15 = (uint64_t)v27;
  if (!v27)
    goto LABEL_25;
  if (v27 != v26)
  {
    v15 = (*(uint64_t (**)(void))(*v27 + 16))();
LABEL_25:
    v36 = (_BYTE *)v15;
    goto LABEL_27;
  }
  v36 = v35;
  (*(void (**)(_QWORD *, _BYTE *))(v26[0] + 24))(v26, v35);
LABEL_27:
  aBlock[0] = v13;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_23;
  aBlock[3] = &unk_24D5DF608;
  aBlock[4] = &v30;
  v16 = _Block_copy(aBlock);
  v23 = v16;
  if (v22)
  {
    qmi::Client::send();
    v16 = v23;
  }
  if (v16)
    _Block_release(v16);
  if (v36 == v35)
  {
    v17 = 4;
    goto LABEL_35;
  }
  if (v36)
  {
    v17 = 5;
    v14 = v36;
LABEL_35:
    (*(void (**)(_QWORD *))(*v14 + 8 * v17))(v14);
  }
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v24);
  v18 = v27;
  if (v27 == v26)
  {
    v19 = 4;
    v18 = v26;
  }
  else
  {
    if (!v27)
      goto LABEL_41;
    v19 = 5;
  }
  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_41:
  result = v29;
  if (v29 == v28)
  {
    v21 = 4;
    result = v28;
  }
  else
  {
    if (!v29)
      return result;
    v21 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v21))();
}

void sub_216A143F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,char *a28,char a29,uint64_t a30,uint64_t a31,char *a32)
{
  uint64_t v32;
  char *v34;
  uint64_t v35;
  char *v36;
  uint64_t v37;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v32 - 128);
  v34 = a28;
  if (a28 == &a25)
  {
    v35 = 4;
    v34 = &a25;
  }
  else
  {
    if (!a28)
      goto LABEL_6;
    v35 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v34 + 8 * v35))();
LABEL_6:
  v36 = a32;
  if (a32 == &a29)
  {
    v37 = 4;
    v36 = &a29;
  }
  else
  {
    if (!a32)
      goto LABEL_11;
    v37 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v36 + 8 * v37))();
LABEL_11:
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<QMIDataContextIPBase::bindDataPort(void)::$_0,std::allocator<QMIDataContextIPBase::bindDataPort(void)::$_0>,void ()(void)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<QMIDataContextIPBase::bindDataPort(void)::$_0,std::allocator<QMIDataContextIPBase::bindDataPort(void)::$_0>,void ()(void)>::target_type()
{
}

void std::__function::__func<QMIDataContextIPBase::bindDataPort(void)::$_0::operator() const(void)::{lambda(void)#1},std::allocator<QMIDataContextIPBase::bindDataPort(void)::$_0::operator() const(void)::{lambda(void)#1}>,void ()(void)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<QMIDataContextIPBase::bindDataPort(void)::$_0::operator() const(void)::{lambda(void)#1},std::allocator<QMIDataContextIPBase::bindDataPort(void)::$_0::operator() const(void)::{lambda(void)#1}>,void ()(void)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5DF4E0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<QMIDataContextIPBase::bindDataPort(void)::$_0::operator() const(void)::{lambda(void)#1},std::allocator<QMIDataContextIPBase::bindDataPort(void)::$_0::operator() const(void)::{lambda(void)#1}>,void ()(void)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5DF4E0;
  a2[1] = v2;
  return result;
}

void std::__function::__func<QMIDataContextIPBase::bindDataPort(void)::$_0::operator() const(void)::{lambda(void)#1},std::allocator<QMIDataContextIPBase::bindDataPort(void)::$_0::operator() const(void)::{lambda(void)#1}>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v1;
  int v2;
  char *v3;
  int v4;
  NSObject *v5;
  void *v6;
  _QWORD v7[6];
  uint64_t v8;
  int v9;
  uint64_t v10;
  void *aBlock;
  _OWORD v12[2];
  _BYTE buf[24];
  void *v14;
  _QWORD *v15;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  v1 = *(_QWORD *)(a1 + 8);
  if (*(_QWORD *)(v1 + 160))
  {
    if (qmi::Client::getSvcType((qmi::Client *)(v1 + 144)) != 1)
      return;
    memset(v12, 0, sizeof(v12));
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v12);
    v2 = *(_DWORD *)(v1 + 140);
    if (v2 == 2)
    {
      v3 = qmi::MutableMessageBase::getTLV<wds::tlv::IPPref>(v12);
      v4 = 6;
    }
    else
    {
      if (v2 != 1)
      {
        *(_DWORD *)(v1 + 632) = 0;
        if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315650;
          *(_QWORD *)&buf[4] = "wrong ip family";
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "/Library/Caches/com.apple.xbs/Sources/CoreTelephony/CommCenter/CommCenterCommandDrivers/"
                                "Data/QMI/Context/QMIDataContextIPBase.cpp";
          *(_WORD *)&buf[22] = 1024;
          LODWORD(v14) = 1329;
          _os_log_error_impl(&dword_216897000, MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR, "\n**********\n   ASSERT fIpFamilyType == kDataProtocolFamilyIPv4 || fIpFamilyType == kDataProtocolFamilyIPv6\n %s\n at %s:%d\n**********", buf, 0x1Cu);
          v2 = *(_DWORD *)(v1 + 140);
        }
        if ((v2 - 1) >= 2)
          __TUAssertTrigger();
        goto LABEL_17;
      }
      v3 = qmi::MutableMessageBase::getTLV<wds::tlv::IPPref>(v12);
      v4 = 4;
    }
    *(_DWORD *)v3 = v4;
    QMIDataContextIPBase::setQMIChannelState(v1, 2u);
    v7[5] = v1 + 144;
    v8 = QMIServiceMsg::create();
    v9 = 25000;
    v10 = 0;
    aBlock = 0;
    v7[0] = MEMORY[0x24BDAC760];
    v7[1] = 0x40000000;
    v7[2] = ___ZN20QMIDataContextIPBase14setupQMIClientEv_block_invoke_129;
    v7[3] = &__block_descriptor_tmp_130_4;
    v7[4] = v1;
    *(_QWORD *)buf = MEMORY[0x24BDAC760];
    *(_QWORD *)&buf[8] = 0x40000000;
    *(_QWORD *)&buf[16] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3wds21SetClientIpFamilyPref8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
    v14 = &unk_24D5DF680;
    v15 = v7;
    v6 = _Block_copy(buf);
    aBlock = v6;
    if (v8)
    {
      qmi::Client::send();
      v6 = aBlock;
    }
    if (v6)
      _Block_release(v6);
LABEL_17:
    qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v12);
    return;
  }
  v5 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#I setupQMIClient after client is deleted", buf, 2u);
  }
}

void sub_216A147E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *aBlock, char a19)
{
  if (a15)
    qmi::Client::send();
  if (aBlock)
    _Block_release(aBlock);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a19);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<QMIDataContextIPBase::bindDataPort(void)::$_0::operator() const(void)::{lambda(void)#1},std::allocator<QMIDataContextIPBase::bindDataPort(void)::$_0::operator() const(void)::{lambda(void)#1}>,void ()(void)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<QMIDataContextIPBase::bindDataPort(void)::$_0::operator() const(void)::{lambda(void)#1},std::allocator<QMIDataContextIPBase::bindDataPort(void)::$_0::operator() const(void)::{lambda(void)#1}>,void ()(void)>::target_type()
{
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3wds12BindDataPort8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A14940(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::PeripheralEndPoint>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::PeripheralEndPoint>::getSize()
{
  return tlv::size<wds::tlv::ProfileTypeMask>();
}

_DWORD **qmi::MutableMessageBase::TlvWrapper<wds::tlv::PeripheralEndPoint>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _DWORD *v4;
  uint64_t v5;
  _DWORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_DWORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::PeripheralEndPoint>((_DWORD **)a2, (_DWORD *)(a1 + 12));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::PeripheralEndPoint>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5DF5B0;
  *(_QWORD *)(result + 12) = *(_QWORD *)(a1 + 12);
  return result;
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3wds15BindMuxDataPort8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A14B04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

char *qmi::MutableMessageBase::getTLV<wds::tlv::IPPref>(_QWORD *a1)
{
  const void **v2;
  const void **v3;
  char **v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  v4 = (char **)(a1 + 1);
  if (v2 != v3)
  {
    while (*((_BYTE *)*v2 + 8) != 1)
    {
      if (++v2 == v3)
        goto LABEL_8;
    }
  }
  if (v2 == v3)
  {
LABEL_8:
    v7 = operator new();
    *(_BYTE *)(v7 + 8) = 1;
    *(_DWORD *)(v7 + 12) = 0;
    v6 = v7 + 12;
    *(_QWORD *)v7 = &off_24D5DF650;
    v8 = a1[3];
    v9 = (uint64_t *)a1[2];
    if ((unint64_t)v9 >= v8)
    {
      v11 = ((char *)v9 - *v4) >> 3;
      if ((unint64_t)(v11 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v12 = v8 - (_QWORD)*v4;
      v13 = v12 >> 2;
      if (v12 >> 2 <= (unint64_t)(v11 + 1))
        v13 = v11 + 1;
      if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
        v14 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v14 = v13;
      if (v14)
        v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v14);
      else
        v15 = 0;
      v16 = (uint64_t *)&v15[8 * v11];
      v17 = &v15[8 * v14];
      *v16 = v7;
      v10 = v16 + 1;
      v19 = (char *)a1[1];
      v18 = (char *)a1[2];
      if (v18 != v19)
      {
        do
        {
          v20 = *((_QWORD *)v18 - 1);
          v18 -= 8;
          *--v16 = v20;
        }
        while (v18 != v19);
        v18 = *v4;
      }
      a1[1] = v16;
      a1[2] = v10;
      a1[3] = v17;
      if (v18)
        operator delete(v18);
    }
    else
    {
      *v9 = v7;
      v10 = v9 + 1;
    }
    a1[2] = v10;
  }
  else
  {
    if (!v5)
      __cxa_bad_cast();
    return v5 + 12;
  }
  return (char *)v6;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::IPPref>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::IPPref>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<wds::tlv::IPPref>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::IPPref>((_BYTE **)a2, (_DWORD *)(a1 + 12));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::IPPref>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5DF650;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a1 + 12);
  return result;
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3wds21SetClientIpFamilyPref8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A14E44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::ReportExtendedIPConfigChange>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::ReportExtendedIPConfigChange>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<wds::tlv::ReportExtendedIPConfigChange>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::ReportExtendedIPConfigChange>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5DF6C8;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::ReportAnbrProhibitTimer>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::ReportAnbrProhibitTimer>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<wds::tlv::ReportAnbrProhibitTimer>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::ReportAnbrProhibitTimer>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5DF718;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::ReportAnbrRohcInfo>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::ReportAnbrRohcInfo>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<wds::tlv::ReportAnbrRohcInfo>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::ReportAnbrRohcInfo>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5DF768;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::ReportAnbr>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::ReportAnbr>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<wds::tlv::ReportAnbr>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::ReportAnbr>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5DF7B8;
  return result;
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3wds18IndicationRegister8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke_0(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BYTE v3[24];

  v2 = *(_QWORD *)(a1 + 32);
  cast_message_type<wds::IndicationRegister::Response const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_216A151CC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

uint64_t qmi::MessageBase::applyTlv<wds::tlv::CarrierIPv6,void({block_pointer})(wds::tlv::CarrierIPv6 const&)>(qmi::MessageBase *a1, uint64_t a2)
{
  uint64_t result;
  int v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  _QWORD v9[2];
  char v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  result = qmi::MessageBase::findTlvValue(a1);
  if (result)
  {
    v6 = result;
    v7 = v5;
    v8 = result;
    v9[0] = 0;
    v9[1] = 0;
    v10 = 0;
    tlv::parseV<wds::tlv::CarrierIPv6>((unint64_t *)&v8, v5, (uint64_t)v9);
    if (v8)
      return (*(uint64_t (**)(void))(*(_QWORD *)a2 + 16))();
    else
      return ((uint64_t (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, 192, v6, v7);
  }
  return result;
}

char *qmi::MutableMessageBase::getTLV<wds::tlv::Settings>(_QWORD *a1)
{
  const void **v2;
  const void **v3;
  char **v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  v4 = (char **)(a1 + 1);
  if (v2 != v3)
  {
    while (*((_BYTE *)*v2 + 8) != 16)
    {
      if (++v2 == v3)
        goto LABEL_8;
    }
  }
  if (v2 == v3)
  {
LABEL_8:
    v7 = operator new();
    *(_BYTE *)(v7 + 8) = 16;
    *(_DWORD *)(v7 + 12) = 0;
    v6 = v7 + 12;
    *(_QWORD *)v7 = &off_24D5DF830;
    v8 = a1[3];
    v9 = (uint64_t *)a1[2];
    if ((unint64_t)v9 >= v8)
    {
      v11 = ((char *)v9 - *v4) >> 3;
      if ((unint64_t)(v11 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v12 = v8 - (_QWORD)*v4;
      v13 = v12 >> 2;
      if (v12 >> 2 <= (unint64_t)(v11 + 1))
        v13 = v11 + 1;
      if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
        v14 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v14 = v13;
      if (v14)
        v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v14);
      else
        v15 = 0;
      v16 = (uint64_t *)&v15[8 * v11];
      v17 = &v15[8 * v14];
      *v16 = v7;
      v10 = v16 + 1;
      v19 = (char *)a1[1];
      v18 = (char *)a1[2];
      if (v18 != v19)
      {
        do
        {
          v20 = *((_QWORD *)v18 - 1);
          v18 -= 8;
          *--v16 = v20;
        }
        while (v18 != v19);
        v18 = *v4;
      }
      a1[1] = v16;
      a1[2] = v10;
      a1[3] = v17;
      if (v18)
        operator delete(v18);
    }
    else
    {
      *v9 = v7;
      v10 = v9 + 1;
    }
    a1[2] = v10;
  }
  else
  {
    if (!v5)
      __cxa_bad_cast();
    return v5 + 12;
  }
  return (char *)v6;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::Settings>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Settings>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

_DWORD **qmi::MutableMessageBase::TlvWrapper<wds::tlv::Settings>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _DWORD *v4;
  uint64_t v5;
  _DWORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_DWORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::PktDataHandle>((_DWORD **)a2, (_DWORD *)(a1 + 12));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Settings>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5DF830;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a1 + 12);
  return result;
}

void ___ZNO3qmi6Client9SendProxy8callbackIN3wds18GetRuntimeSettings8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A155C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void std::__function::__func<QMIDataContextIPBase::handleSettingsResponse(wds::GetRuntimeSettings::Response const&)::$_0,std::allocator<QMIDataContextIPBase::handleSettingsResponse(wds::GetRuntimeSettings::Response const&)::$_0>,void ()(void)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

__n128 std::__function::__func<QMIDataContextIPBase::handleSettingsResponse(wds::GetRuntimeSettings::Response const&)::$_0,std::allocator<QMIDataContextIPBase::handleSettingsResponse(wds::GetRuntimeSettings::Response const&)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_24D5DF890;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<QMIDataContextIPBase::handleSettingsResponse(wds::GetRuntimeSettings::Response const&)::$_0,std::allocator<QMIDataContextIPBase::handleSettingsResponse(wds::GetRuntimeSettings::Response const&)::$_0>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_24D5DF890;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<QMIDataContextIPBase::handleSettingsResponse(wds::GetRuntimeSettings::Response const&)::$_0,std::allocator<QMIDataContextIPBase::handleSettingsResponse(wds::GetRuntimeSettings::Response const&)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  int v6;
  char v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t *v14;
  _QWORD v15[3];
  uint64_t v16;
  uint64_t v17;
  void (*v18)(uint64_t);
  void *v19;
  uint64_t v20;

  v2 = *(_QWORD *)(a1 + 8);
  v3 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v2 + 104));
  (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)(v2 + 96) + 208))(*(_QWORD *)(v2 + 96), *(unsigned __int8 *)(v2 + 256));
  p_shared_owners = (unint64_t *)&v3->__shared_owners_;
  do
    v5 = __ldaxr(p_shared_owners);
  while (__stlxr(v5 - 1, p_shared_owners));
  if (!v5)
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  v6 = *(_DWORD *)(v2 + 140);
  if (v6 == 1)
  {
    v16 = MEMORY[0x24BDAC760];
    v17 = 0x40000000;
    v18 = ___ZZN20QMIDataContextIPBase22handleSettingsResponseERKN3wds18GetRuntimeSettings8ResponseEENK3__0clEv_block_invoke_2;
    v19 = &__block_descriptor_tmp_275;
    v20 = v2;
    QMIDataContextIPBase::setIPv4ConfigTimer(v2, 0, (uint64_t)&v16);
    if (!*(_BYTE *)(v2 + 272))
      return;
    v8 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v2 + 104));
    (*(void (**)(_QWORD *__return_ptr, _QWORD, uint64_t))(**(_QWORD **)(v2 + 96) + 216))(v15, *(_QWORD *)(v2 + 96), 1);
    CSIPacketAddress::operator=();
    v9 = (unint64_t *)&v8->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    goto LABEL_20;
  }
  if (v6 == 2)
  {
    if (*(_BYTE *)(a1 + 16))
    {
      v7 = 0;
    }
    else
    {
      v11 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v2 + 104));
      v16 = *(_QWORD *)(v2 + 96);
      v17 = (uint64_t)v11;
      v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v16 + 48))(v16);
      v12 = (unint64_t *)&v11->__shared_owners_;
      do
        v13 = __ldaxr(v12);
      while (__stlxr(v13 - 1, v12));
      if (!v13)
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
    }
    v16 = MEMORY[0x24BDAC760];
    v17 = 0x40000000;
    v18 = ___ZZN20QMIDataContextIPBase22handleSettingsResponseERKN3wds18GetRuntimeSettings8ResponseEENK3__0clEv_block_invoke;
    v19 = &__block_descriptor_tmp_274;
    v20 = v2;
    QMIDataContextIPBase::setIPv6ConfigTimer(v2, 0, v7, (uint64_t)&v16);
    if (*(_BYTE *)(v2 + 272))
    {
      v8 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v2 + 104));
      (*(void (**)(_QWORD *__return_ptr, _QWORD, uint64_t))(**(_QWORD **)(v2 + 96) + 216))(v15, *(_QWORD *)(v2 + 96), 2);
      CSIPacketAddress::operator=();
      v14 = (unint64_t *)&v8->__shared_owners_;
      do
        v10 = __ldaxr(v14);
      while (__stlxr(v10 - 1, v14));
LABEL_20:
      if (!v10)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }
  }
}

void sub_216A158AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<QMIDataContextIPBase::handleSettingsResponse(wds::GetRuntimeSettings::Response const&)::$_0,std::allocator<QMIDataContextIPBase::handleSettingsResponse(wds::GetRuntimeSettings::Response const&)::$_0>,void ()(void)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<QMIDataContextIPBase::handleSettingsResponse(wds::GetRuntimeSettings::Response const&)::$_0,std::allocator<QMIDataContextIPBase::handleSettingsResponse(wds::GetRuntimeSettings::Response const&)::$_0>,void ()(void)>::target_type()
{
}

void ___ZZN20QMIDataContextIPBase22handleSettingsResponseERKN3wds18GetRuntimeSettings8ResponseEENK3__0clEv_block_invoke(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  NSObject *v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  std::__shared_weak_count *v7;
  char v8;
  unint64_t *v9;
  unint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  std::__shared_weak_count *v14;
  uint64_t v15;
  NSObject *v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  int v22;
  const char *v23;
  __int16 v24;
  uint64_t v25;
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v22 = 136315394;
    v23 = "activateIPv6TimerFired";
    v24 = 2080;
    v25 = asStringBool();
    _os_log_impl(&dword_216897000, v2, OS_LOG_TYPE_DEFAULT, "#I %s: IPv6Service: fIPv6ConfigTimer timer fired DadRequired: %s", (uint8_t *)&v22, 0x16u);
  }
  if (*(_BYTE *)(v1 + 306))
    goto LABEL_4;
  v4 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v1 + 104));
  if (((*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(v1 + 96) + 384))(*(_QWORD *)(v1 + 96), *(unsigned int *)(v1 + 140)) & 1) != 0)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
LABEL_4:
    v3 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v22) = 0;
      _os_log_impl(&dword_216897000, v3, OS_LOG_TYPE_DEFAULT, "#I IPv6Service: IPv6 is a must-have", (uint8_t *)&v22, 2u);
    }
    QMIDataContextIPBase::setDataContextIPState(v1, 2u);
    (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v1 + 336))(v1, 0);
    return;
  }
  v7 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v1 + 104));
  v8 = (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(v1 + 96) + 176))(*(_QWORD *)(v1 + 96), *(unsigned int *)(v1 + 140));
  v9 = (unint64_t *)&v7->__shared_owners_;
  do
    v10 = __ldaxr(v9);
  while (__stlxr(v10 - 1, v9));
  if (!v10)
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  v11 = (unint64_t *)&v4->__shared_owners_;
  do
    v12 = __ldaxr(v11);
  while (__stlxr(v12 - 1, v11));
  if (!v12)
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  if ((v8 & 1) != 0)
    goto LABEL_4;
  v13 = *(std::__shared_weak_count **)(v1 + 128);
  if (v13)
  {
    v14 = std::__shared_weak_count::lock(v13);
    if (v14)
    {
      v15 = *(_QWORD *)(v1 + 120);
      if (v15)
      {
        if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v15 + 72))(v15))
        {
          v16 = *(NSObject **)(v1 + 40);
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(v22) = 0;
            _os_log_impl(&dword_216897000, v16, OS_LOG_TYPE_DEFAULT, "#I IPv6Service: IPv6 configuration failed in marginal traffic conditions, let's try that later", (uint8_t *)&v22, 2u);
          }
          QMIDataContextIPBase::setDataContextIPState(v1, 2u);
          (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v1 + 336))(v1, 0);
LABEL_35:
          v20 = (unint64_t *)&v14->__shared_owners_;
          do
            v21 = __ldaxr(v20);
          while (__stlxr(v21 - 1, v20));
          if (!v21)
          {
            ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
            std::__shared_weak_count::__release_weak(v14);
          }
          return;
        }
      }
    }
  }
  else
  {
    v14 = 0;
  }
  QMIDataContextIPBase::clearIPv6ConfigTimer((QMIDataContextIPBase *)v1);
  v17 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v1 + 104));
  (*(void (**)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)(v1 + 96) + 56))(*(_QWORD *)(v1 + 96), *(unsigned int *)(v1 + 140), 0);
  v18 = (unint64_t *)&v17->__shared_owners_;
  do
    v19 = __ldaxr(v18);
  while (__stlxr(v19 - 1, v18));
  if (!v19)
  {
    ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
    std::__shared_weak_count::__release_weak(v17);
  }
  if (v14)
    goto LABEL_35;
}

void sub_216A15C9C(_Unwind_Exception *exception_object)
{
  std::__shared_weak_count *v1;
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v5;
  unint64_t *v6;
  unint64_t v7;

  p_shared_owners = (unint64_t *)&v2->__shared_owners_;
  do
    v5 = __ldaxr(p_shared_owners);
  while (__stlxr(v5 - 1, p_shared_owners));
  if (!v5)
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  if (v1)
  {
    v6 = (unint64_t *)&v1->__shared_owners_;
    do
      v7 = __ldaxr(v6);
    while (__stlxr(v7 - 1, v6));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
  _Unwind_Resume(exception_object);
}

void ___ZZN20QMIDataContextIPBase22handleSettingsResponseERKN3wds18GetRuntimeSettings8ResponseEENK3__0clEv_block_invoke_2(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  std::__shared_weak_count *v6;
  char v7;
  unint64_t *v8;
  unint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  NSObject *v12;
  std::__shared_weak_count *v13;
  std::__shared_weak_count *v14;
  uint64_t v15;
  NSObject *v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  int v22;
  const char *v23;
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v22 = 136315138;
    v23 = "activateIPv4TimerFired";
    _os_log_impl(&dword_216897000, v2, OS_LOG_TYPE_DEFAULT, "#I %s: IPv4Service: fIPv4ConfigTimer timer fired", (uint8_t *)&v22, 0xCu);
  }
  v3 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v1 + 104));
  if (((*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(v1 + 96) + 384))(*(_QWORD *)(v1 + 96), *(unsigned int *)(v1 + 140)) & 1) != 0)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
    goto LABEL_16;
  }
  v6 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v1 + 104));
  v7 = (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(v1 + 96) + 176))(*(_QWORD *)(v1 + 96), *(unsigned int *)(v1 + 140));
  v8 = (unint64_t *)&v6->__shared_owners_;
  do
    v9 = __ldaxr(v8);
  while (__stlxr(v9 - 1, v8));
  if (!v9)
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
  v10 = (unint64_t *)&v3->__shared_owners_;
  do
    v11 = __ldaxr(v10);
  while (__stlxr(v11 - 1, v10));
  if (v11)
  {
    if ((v7 & 1) != 0)
    {
LABEL_16:
      v12 = *(NSObject **)(v1 + 40);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v22) = 0;
        _os_log_impl(&dword_216897000, v12, OS_LOG_TYPE_DEFAULT, "#I IPv4Service: IPv4 is a must-have", (uint8_t *)&v22, 2u);
      }
      QMIDataContextIPBase::setDataContextIPState(v1, 2u);
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v1 + 336))(v1, 0);
      return;
    }
  }
  else
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    if ((v7 & 1) != 0)
      goto LABEL_16;
  }
  v13 = *(std::__shared_weak_count **)(v1 + 128);
  if (v13)
  {
    v14 = std::__shared_weak_count::lock(v13);
    if (v14)
    {
      v15 = *(_QWORD *)(v1 + 120);
      if (v15)
      {
        if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v15 + 72))(v15))
        {
          v16 = *(NSObject **)(v1 + 40);
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(v22) = 0;
            _os_log_impl(&dword_216897000, v16, OS_LOG_TYPE_DEFAULT, "#I IPv4Service: IPv4 configuration failed in marginal traffic conditions, let's try that later", (uint8_t *)&v22, 2u);
          }
          QMIDataContextIPBase::setDataContextIPState(v1, 2u);
          (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v1 + 336))(v1, 0);
LABEL_34:
          v20 = (unint64_t *)&v14->__shared_owners_;
          do
            v21 = __ldaxr(v20);
          while (__stlxr(v21 - 1, v20));
          if (!v21)
          {
            ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
            std::__shared_weak_count::__release_weak(v14);
          }
          return;
        }
      }
    }
  }
  else
  {
    v14 = 0;
  }
  QMIDataContextIPBase::clearIPv4ConfigTimer((QMIDataContextIPBase *)v1);
  v17 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v1 + 104));
  (*(void (**)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)(v1 + 96) + 56))(*(_QWORD *)(v1 + 96), *(unsigned int *)(v1 + 140), 0);
  v18 = (unint64_t *)&v17->__shared_owners_;
  do
    v19 = __ldaxr(v18);
  while (__stlxr(v19 - 1, v18));
  if (!v19)
  {
    ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
    std::__shared_weak_count::__release_weak(v17);
  }
  if (v14)
    goto LABEL_34;
}

void sub_216A1607C(_Unwind_Exception *exception_object)
{
  std::__shared_weak_count *v1;
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v5;
  unint64_t *v6;
  unint64_t v7;

  p_shared_owners = (unint64_t *)&v2->__shared_owners_;
  do
    v5 = __ldaxr(p_shared_owners);
  while (__stlxr(v5 - 1, p_shared_owners));
  if (!v5)
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  if (v1)
  {
    v6 = (unint64_t *)&v1->__shared_owners_;
    do
      v7 = __ldaxr(v6);
    while (__stlxr(v7 - 1, v6));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
  _Unwind_Resume(exception_object);
}

void qmi::MessageBase::tryTlv<wds::tlv::OperatorReservedProtocolInformation,void({block_pointer})(wds::tlv::OperatorReservedProtocolInformation const&)>(qmi::MessageBase *a1, uint64_t a2)
{
  uint64_t TlvValue;
  int v4;
  void *__p[2];
  __int128 v6;
  uint64_t v7;
  uint64_t v8;

  TlvValue = qmi::MessageBase::findTlvValue(a1);
  if (TlvValue)
  {
    v8 = TlvValue;
    v7 = 0;
    *(_OWORD *)__p = 0u;
    v6 = 0u;
    tlv::parseV<wds::tlv::OperatorReservedProtocolInformation>((unint64_t *)&v8, v4, (uint64_t)__p);
    if (v8)
      (*(void (**)(void))(*(_QWORD *)a2 + 16))();
    if (__p[1])
    {
      *(void **)&v6 = __p[1];
      operator delete(__p[1]);
    }
  }
}

void sub_216A161C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t qmi::MessageBase::applyTlv<wds::tlv::SnssaiPdnInfo,void({block_pointer})(wds::tlv::SnssaiPdnInfo const&)>(qmi::MessageBase *a1, uint64_t a2)
{
  uint64_t result;
  int v5;
  uint64_t v6;
  int v7;
  int v8;
  char v9;
  __int16 v10;
  uint64_t v11;
  int v12;
  __int16 v13;
  char v14;
  uint64_t v15;

  result = qmi::MessageBase::findTlvValue(a1);
  if (result)
  {
    v6 = result;
    v7 = v5;
    v15 = result;
    v11 = tlv::parseV<wds::tlv::SnssaiPdnInfo>((unint64_t *)&v15, v5);
    v12 = v8;
    v14 = v9;
    v13 = v10;
    if (v15)
      return (*(uint64_t (**)(void))(*(_QWORD *)a2 + 16))();
    else
      return ((uint64_t (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a1, 50, v6, v7);
  }
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::Ipv4AddressExtended>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Ipv4AddressExtended>::getSize()
{
  return tlv::size<wds::tlv::Ipv4AddressExtended>();
}

uint64_t *qmi::MutableMessageBase::TlvWrapper<wds::tlv::Ipv4AddressExtended>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t *result;
  uint64_t v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = *a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::Ipv4AddressExtended>(a2, a1 + 12);
  v7 = *a2 - v5;
  *(_BYTE *)v4 = v3;
  *(_WORD *)(v4 + 1) = v7;
  return result;
}

__n128 qmi::MutableMessageBase::TlvWrapper<wds::tlv::Ipv4AddressExtended>::clone(uint64_t a1)
{
  uint64_t v2;
  __n128 result;

  v2 = operator new();
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)v2 = &off_24D5DF968;
  result = *(__n128 *)(a1 + 12);
  *(__n128 *)(v2 + 12) = result;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::Ipv6AddressExtended>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Ipv6AddressExtended>::getSize()
{
  return tlv::size<wds::tlv::Ipv6AddressExtended>();
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::Ipv6AddressExtended>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = *a2;
  v5 = *a2 + 3;
  *a2 = v5;
  tlv::writeV<wds::tlv::Ipv6AddressExtended>(a2, a1 + 12);
  v6 = *a2 - v5;
  *(_BYTE *)v4 = v3;
  *(_WORD *)(v4 + 1) = v6;
}

__n128 qmi::MutableMessageBase::TlvWrapper<wds::tlv::Ipv6AddressExtended>::clone(uint64_t a1)
{
  uint64_t v2;
  __n128 result;

  v2 = operator new();
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)v2 = &off_24D5DF9B8;
  *(_OWORD *)(v2 + 12) = *(_OWORD *)(a1 + 12);
  result = *(__n128 *)(a1 + 28);
  *(__n128 *)(v2 + 28) = result;
  *(_QWORD *)(v2 + 44) = *(_QWORD *)(a1 + 44);
  return result;
}

char *qmi::MutableMessageBase::getTLV<wds::tlv::FilterCallType>(_QWORD *a1)
{
  const void **v2;
  const void **v3;
  char **v4;
  char *v5;
  char *result;
  uint64_t v7;
  unint64_t v8;
  uint64_t *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  v4 = (char **)(a1 + 1);
  if (v2 != v3)
  {
    while (*((_BYTE *)*v2 + 8) != 18)
    {
      if (++v2 == v3)
        goto LABEL_8;
    }
  }
  if (v2 == v3)
  {
LABEL_8:
    v7 = operator new();
    *(_WORD *)(v7 + 8) = 18;
    *(_QWORD *)v7 = &off_24D5DFA08;
    v8 = a1[3];
    v9 = (uint64_t *)a1[2];
    if ((unint64_t)v9 >= v8)
    {
      v11 = ((char *)v9 - *v4) >> 3;
      if ((unint64_t)(v11 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v12 = v8 - (_QWORD)*v4;
      v13 = v12 >> 2;
      if (v12 >> 2 <= (unint64_t)(v11 + 1))
        v13 = v11 + 1;
      if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
        v14 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v14 = v13;
      if (v14)
        v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v14);
      else
        v15 = 0;
      v16 = (uint64_t *)&v15[8 * v11];
      v17 = &v15[8 * v14];
      *v16 = v7;
      v10 = v16 + 1;
      v19 = (char *)a1[1];
      v18 = (char *)a1[2];
      if (v18 != v19)
      {
        do
        {
          v20 = *((_QWORD *)v18 - 1);
          v18 -= 8;
          *--v16 = v20;
        }
        while (v18 != v19);
        v18 = *v4;
      }
      a1[1] = v16;
      a1[2] = v10;
      a1[3] = v17;
      if (v18)
        operator delete(v18);
    }
    else
    {
      *v9 = v7;
      v10 = v9 + 1;
    }
    result = (char *)(v7 + 9);
    a1[2] = v10;
  }
  else
  {
    if (!v5)
      __cxa_bad_cast();
    return v5 + 9;
  }
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::FilterCallType>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::FilterCallType>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<wds::tlv::FilterCallType>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::FilterCallType>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5DFA08;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::Ipv4Address>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Ipv4Address>::getSize()
{
  return tlv::size<wds::tlv::Ipv4Address>();
}

uint64_t *qmi::MutableMessageBase::TlvWrapper<wds::tlv::Ipv4Address>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t *result;
  uint64_t v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = *a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::Ipv4Address>(a2, a1 + 10);
  v7 = *a2 - v5;
  *(_BYTE *)v4 = v3;
  *(_WORD *)(v4 + 1) = v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Ipv4Address>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5DFA58;
  *(_QWORD *)(result + 10) = *(_QWORD *)(a1 + 10);
  *(_DWORD *)(result + 18) = *(_DWORD *)(a1 + 18);
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::Ipv6Address>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::Ipv6Address>::getSize()
{
  return tlv::size<wds::tlv::Ipv6Address>();
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::Ipv6Address>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = *a2;
  v5 = *a2 + 3;
  *a2 = v5;
  tlv::writeV<wds::tlv::Ipv6Address>(a2, a1 + 10);
  v6 = *a2 - v5;
  *(_BYTE *)v4 = v3;
  *(_WORD *)(v4 + 1) = v6;
}

__n128 qmi::MutableMessageBase::TlvWrapper<wds::tlv::Ipv6Address>::clone(uint64_t a1)
{
  uint64_t v2;
  __n128 result;

  v2 = operator new();
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)v2 = &off_24D5DFAA8;
  *(_OWORD *)(v2 + 10) = *(_OWORD *)(a1 + 10);
  result = *(__n128 *)(a1 + 26);
  *(__n128 *)(v2 + 26) = result;
  *(_DWORD *)(v2 + 42) = *(_DWORD *)(a1 + 42);
  return result;
}

_QWORD *qmi::MutableMessageBase::TlvWrapper<wds::tlv::PacketList>::~TlvWrapper(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24D5DFAF8;
  v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::PacketList>::~TlvWrapper(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24D5DFAF8;
  v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  JUMPOUT(0x2199FEAC4);
}

unint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::PacketList>::getSize(uint64_t a1)
{
  return tlv::size<wds::tlv::PacketList>((_QWORD *)(a1 + 16));
}

_BYTE *qmi::MutableMessageBase::TlvWrapper<wds::tlv::PacketList>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE *result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::PacketList>((_BYTE **)a2, (_DWORD *)(a1 + 16));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

_QWORD *qmi::MutableMessageBase::TlvWrapper<wds::tlv::PacketList>::clone(uint64_t a1)
{
  uint64_t v2;
  _QWORD *v3;
  _BYTE *v4;
  _BYTE *v5;
  int64_t v6;
  char *v7;
  uint64_t v8;

  v2 = operator new();
  v3 = (_QWORD *)v2;
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)(v2 + 16) = 0;
  *(_QWORD *)v2 = &off_24D5DFAF8;
  *(_QWORD *)(v2 + 24) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  v5 = *(_BYTE **)(a1 + 16);
  v4 = *(_BYTE **)(a1 + 24);
  v6 = v4 - v5;
  if (v4 != v5)
  {
    if (v6 < 0)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v7 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::array<unsigned char,16ul>>>(v2 + 32, v6 >> 4);
    v3[2] = v7;
    v3[4] = &v7[16 * v8];
    memmove(v7, v5, v6);
    v3[3] = &v7[16 * (v6 >> 4)];
  }
  return v3;
}

void sub_216A169A8(_Unwind_Exception *a1)
{
  uint64_t v1;
  void **v2;
  void *v4;

  v4 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 24) = v4;
    operator delete(v4);
  }
  MEMORY[0x2199FEAC4](v1, 0x10A1C403082B835);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3wds12DropIPackets8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A16A98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::QualityStatusV2>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::QualityStatusV2>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<wds::tlv::QualityStatusV2>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::QualityStatusV2>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5DFB70;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::QualityStatus>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::QualityStatus>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<wds::tlv::QualityStatus>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::QualityStatus>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5DFBC0;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::LteDataCallType>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::LteDataCallType>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

_DWORD **qmi::MutableMessageBase::TlvWrapper<wds::tlv::LteDataCallType>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _DWORD *v4;
  uint64_t v5;
  _DWORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_DWORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::PktDataHandle>((_DWORD **)a2, (_DWORD *)(a1 + 12));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::LteDataCallType>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5DFC10;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a1 + 12);
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::RemoveHandle>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::RemoveHandle>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

_DWORD **qmi::MutableMessageBase::TlvWrapper<wds::tlv::RemoveHandle>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _DWORD *v4;
  uint64_t v5;
  _DWORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_DWORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::PktDataHandle>((_DWORD **)a2, (_DWORD *)(a1 + 12));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::RemoveHandle>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5DFC60;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a1 + 12);
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::ProhibitTimerHandle>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::ProhibitTimerHandle>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

_DWORD **qmi::MutableMessageBase::TlvWrapper<wds::tlv::ProhibitTimerHandle>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _DWORD *v4;
  uint64_t v5;
  _DWORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_DWORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::PktDataHandle>((_DWORD **)a2, (_DWORD *)(a1 + 12));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::ProhibitTimerHandle>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5DFCB0;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a1 + 12);
  return result;
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3wds24GetANBRProhibitTimerInfo8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A16F6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::CoalescingInfo>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::CoalescingInfo>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_PcoMcc>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<wds::tlv::CoalescingInfo>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::ProfileIdentifer>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::CoalescingInfo>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5DFD28;
  *(_WORD *)(result + 9) = *(_WORD *)(a1 + 9);
  return result;
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3wds13SetCoalescing8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A17130(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::RequestedBitrate>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::RequestedBitrate>::getSize()
{
  return tlv::size<wds::tlv::RequestedBitrate>();
}

uint64_t *qmi::MutableMessageBase::TlvWrapper<wds::tlv::RequestedBitrate>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t *result;
  uint64_t v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = *a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::RequestedBitrate>(a2, a1 + 12);
  v7 = *a2 - v5;
  *(_BYTE *)v4 = v3;
  *(_WORD *)(v4 + 1) = v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::RequestedBitrate>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5DFDA0;
  *(_QWORD *)(result + 12) = *(_QWORD *)(a1 + 12);
  *(_DWORD *)(result + 20) = *(_DWORD *)(a1 + 20);
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::RequestedBitrateBps>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::RequestedBitrateBps>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

_DWORD **qmi::MutableMessageBase::TlvWrapper<wds::tlv::RequestedBitrateBps>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _DWORD *v4;
  uint64_t v5;
  _DWORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_DWORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::PktDataHandle>((_DWORD **)a2, (_DWORD *)(a1 + 12));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::RequestedBitrateBps>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5DFDF0;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a1 + 12);
  return result;
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3wds16ANBRQueryBitrate8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A173C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

char *qmi::MutableMessageBase::getTLV<wds::tlv::IpType>(_QWORD *a1)
{
  const void **v2;
  const void **v3;
  char **v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  v4 = (char **)(a1 + 1);
  if (v2 != v3)
  {
    while (*((_BYTE *)*v2 + 8) != 16)
    {
      if (++v2 == v3)
        goto LABEL_8;
    }
  }
  if (v2 == v3)
  {
LABEL_8:
    v7 = operator new();
    *(_BYTE *)(v7 + 8) = 16;
    *(_DWORD *)(v7 + 12) = 0;
    v6 = v7 + 12;
    *(_QWORD *)v7 = &off_24D5DFE68;
    v8 = a1[3];
    v9 = (uint64_t *)a1[2];
    if ((unint64_t)v9 >= v8)
    {
      v11 = ((char *)v9 - *v4) >> 3;
      if ((unint64_t)(v11 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v12 = v8 - (_QWORD)*v4;
      v13 = v12 >> 2;
      if (v12 >> 2 <= (unint64_t)(v11 + 1))
        v13 = v11 + 1;
      if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
        v14 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v14 = v13;
      if (v14)
        v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v14);
      else
        v15 = 0;
      v16 = (uint64_t *)&v15[8 * v11];
      v17 = &v15[8 * v14];
      *v16 = v7;
      v10 = v16 + 1;
      v19 = (char *)a1[1];
      v18 = (char *)a1[2];
      if (v18 != v19)
      {
        do
        {
          v20 = *((_QWORD *)v18 - 1);
          v18 -= 8;
          *--v16 = v20;
        }
        while (v18 != v19);
        v18 = *v4;
      }
      a1[1] = v16;
      a1[2] = v10;
      a1[3] = v17;
      if (v18)
        operator delete(v18);
    }
    else
    {
      *v9 = v7;
      v10 = v9 + 1;
    }
    a1[2] = v10;
  }
  else
  {
    if (!v5)
      __cxa_bad_cast();
    return v5 + 12;
  }
  return (char *)v6;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::IpType>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::IpType>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<wds::tlv::IpType>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::IPPref>((_BYTE **)a2, (_DWORD *)(a1 + 12));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::IpType>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5DFE68;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a1 + 12);
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::IPv4Src>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::IPv4Src>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

_DWORD **qmi::MutableMessageBase::TlvWrapper<wds::tlv::IPv4Src>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _DWORD *v4;
  uint64_t v5;
  _DWORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_DWORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::PktDataHandle>((_DWORD **)a2, (_DWORD *)(a1 + 12));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::IPv4Src>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5DFEB8;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a1 + 12);
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::IPv4Dst>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::IPv4Dst>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

_DWORD **qmi::MutableMessageBase::TlvWrapper<wds::tlv::IPv4Dst>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _DWORD *v4;
  uint64_t v5;
  _DWORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_DWORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::PktDataHandle>((_DWORD **)a2, (_DWORD *)(a1 + 12));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::IPv4Dst>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5DFF08;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a1 + 12);
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::IPv6Src>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::IPv6Src>::getSize()
{
  return tlv::size<wds::tlv::HandOverIPv6Prefix>();
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::IPv6Src>::write(uint64_t a1, __n128 **a2)
{
  unsigned __int8 v3;
  __n128 *v4;
  uint64_t v5;
  char *v6;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = *a2;
  v5 = (uint64_t)(*a2)->n128_i64 + 3;
  *a2 = (__n128 *)v5;
  tlv::writeV<wds::tlv::HandOverIPv6Prefix>(a2, (__n128 *)(a1 + 9));
  v6 = (char *)*a2 - v5;
  v4->n128_u8[0] = v3;
  *(unsigned __int16 *)((char *)v4->n128_u16 + 1) = (unsigned __int16)v6;
}

__n128 qmi::MutableMessageBase::TlvWrapper<wds::tlv::IPv6Src>::clone(uint64_t a1)
{
  uint64_t v2;
  __n128 result;

  v2 = operator new();
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)v2 = &off_24D5DFF58;
  result = *(__n128 *)(a1 + 9);
  *(__n128 *)(v2 + 9) = result;
  *(_BYTE *)(v2 + 25) = *(_BYTE *)(a1 + 25);
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::IPv6Dst>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::IPv6Dst>::getSize()
{
  return tlv::size<wds::tlv::HandOverIPv6Prefix>();
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::IPv6Dst>::write(uint64_t a1, __n128 **a2)
{
  unsigned __int8 v3;
  __n128 *v4;
  uint64_t v5;
  char *v6;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = *a2;
  v5 = (uint64_t)(*a2)->n128_i64 + 3;
  *a2 = (__n128 *)v5;
  tlv::writeV<wds::tlv::HandOverIPv6Prefix>(a2, (__n128 *)(a1 + 9));
  v6 = (char *)*a2 - v5;
  v4->n128_u8[0] = v3;
  *(unsigned __int16 *)((char *)v4->n128_u16 + 1) = (unsigned __int16)v6;
}

__n128 qmi::MutableMessageBase::TlvWrapper<wds::tlv::IPv6Dst>::clone(uint64_t a1)
{
  uint64_t v2;
  __n128 result;

  v2 = operator new();
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)v2 = &off_24D5DFFA8;
  result = *(__n128 *)(a1 + 9);
  *(__n128 *)(v2 + 9) = result;
  *(_BYTE *)(v2 + 25) = *(_BYTE *)(a1 + 25);
  return result;
}

char *qmi::MutableMessageBase::getTLV<wds::tlv::IpProtoType>(_QWORD *a1)
{
  const void **v2;
  const void **v3;
  char **v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  v4 = (char **)(a1 + 1);
  if (v2 != v3)
  {
    while (*((_BYTE *)*v2 + 8) != 21)
    {
      if (++v2 == v3)
        goto LABEL_8;
    }
  }
  if (v2 == v3)
  {
LABEL_8:
    v7 = operator new();
    *(_BYTE *)(v7 + 8) = 21;
    *(_DWORD *)(v7 + 12) = 0;
    v6 = v7 + 12;
    *(_QWORD *)v7 = &off_24D5DFFF8;
    v8 = a1[3];
    v9 = (uint64_t *)a1[2];
    if ((unint64_t)v9 >= v8)
    {
      v11 = ((char *)v9 - *v4) >> 3;
      if ((unint64_t)(v11 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v12 = v8 - (_QWORD)*v4;
      v13 = v12 >> 2;
      if (v12 >> 2 <= (unint64_t)(v11 + 1))
        v13 = v11 + 1;
      if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
        v14 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v14 = v13;
      if (v14)
        v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v14);
      else
        v15 = 0;
      v16 = (uint64_t *)&v15[8 * v11];
      v17 = &v15[8 * v14];
      *v16 = v7;
      v10 = v16 + 1;
      v19 = (char *)a1[1];
      v18 = (char *)a1[2];
      if (v18 != v19)
      {
        do
        {
          v20 = *((_QWORD *)v18 - 1);
          v18 -= 8;
          *--v16 = v20;
        }
        while (v18 != v19);
        v18 = *v4;
      }
      a1[1] = v16;
      a1[2] = v10;
      a1[3] = v17;
      if (v18)
        operator delete(v18);
    }
    else
    {
      *v9 = v7;
      v10 = v9 + 1;
    }
    a1[2] = v10;
  }
  else
  {
    if (!v5)
      __cxa_bad_cast();
    return v5 + 12;
  }
  return (char *)v6;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::IpProtoType>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::IpProtoType>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

_DWORD **qmi::MutableMessageBase::TlvWrapper<wds::tlv::IpProtoType>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _DWORD *v4;
  uint64_t v5;
  _DWORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_DWORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::PktDataHandle>((_DWORD **)a2, (_DWORD *)(a1 + 12));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::IpProtoType>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5DFFF8;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a1 + 12);
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::PortSrc>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::PortSrc>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_PcoMcc>();
}

_WORD **qmi::MutableMessageBase::TlvWrapper<wds::tlv::PortSrc>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _WORD *v4;
  uint64_t v5;
  _WORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_WORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::Profile3GPP_PcoMcc>((_WORD **)a2, (_WORD *)(a1 + 10));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::PortSrc>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E0048;
  *(_WORD *)(result + 10) = *(_WORD *)(a1 + 10);
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<wds::tlv::PortDst>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::PortDst>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_PcoMcc>();
}

_WORD **qmi::MutableMessageBase::TlvWrapper<wds::tlv::PortDst>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _WORD *v4;
  uint64_t v5;
  _WORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_WORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::Profile3GPP_PcoMcc>((_WORD **)a2, (_WORD *)(a1 + 10));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<wds::tlv::PortDst>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E0098;
  *(_WORD *)(result + 10) = *(_WORD *)(a1 + 10);
  return result;
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3wds18ANBRRegisterFilter8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A17E08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

double QMIStewieCommandDriver::create@<D0>(uint64_t a1@<X0>, NSObject **a2@<X1>, _OWORD *a3@<X8>)
{
  uint64_t v6;
  double result;
  __int128 v8;

  v6 = operator new();
  QMIStewieCommandDriver::QMIStewieCommandDriver(v6, a1, a2);
  v8 = 0uLL;
  std::shared_ptr<QMIStewieCommandDriver>::shared_ptr[abi:ne180100]<QMIStewieCommandDriver,std::shared_ptr<QMIStewieCommandDriver> ctu::SharedSynchronizable<QMIStewieCommandDriver>::make_shared_ptr<QMIStewieCommandDriver>(QMIStewieCommandDriver*)::{lambda(QMIStewieCommandDriver*)#1},void>((uint64_t *)&v8, v6);
  result = *(double *)&v8;
  *a3 = v8;
  return result;
}

void sub_216A17EBC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199FEAC4](v1, 0x10E1C40758A9DC5);
  _Unwind_Resume(a1);
}

uint64_t QMIStewieCommandDriver::QMIStewieCommandDriver(uint64_t a1, uint64_t a2, NSObject **a3)
{
  _BYTE v7[16];

  *(_QWORD *)a1 = MEMORY[0x24BDC45D8] + 16;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)v7, (const char *)*MEMORY[0x24BDC3E90], "stw.qmi");
  ctu::SharedLoggable<QMIStewieCommandDriver,ctu::OsLogLogger>::SharedLoggable<ctu::OsLogContext>((_QWORD *)(a1 + 8), a3);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v7);
  *(_QWORD *)a1 = &off_24D5E0300;
  *(_OWORD *)(a1 + 48) = *(_OWORD *)a2;
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_BYTE *)(a1 + 116) = 0;
  *(_BYTE *)(a1 + 120) = 0;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_BYTE *)(a1 + 112) = 0;
  return a1;
}

void sub_216A17F8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  StewieCommandDriver *v9;

  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&a9);
  StewieCommandDriver::~StewieCommandDriver(v9);
  _Unwind_Resume(a1);
}

_QWORD *ctu::SharedLoggable<QMIStewieCommandDriver,ctu::OsLogLogger>::SharedLoggable<ctu::OsLogContext>(_QWORD *a1, NSObject **a2)
{
  NSObject *v3;
  _BYTE v5[8];

  *a1 = 0;
  a1[1] = 0;
  v3 = *a2;
  a1[2] = *a2;
  if (v3)
    dispatch_retain(v3);
  a1[3] = 0;
  ctu::OsLogLogger::OsLogLogger();
  ctu::OsLogLogger::OsLogLogger();
  MEMORY[0x2199FDF6C](v5);
  return a1;
}

uint64_t QMIStewieCommandDriver::bootstrap(uint64_t a1, __int128 *a2)
{
  NSObject *v4;
  __int128 v5;
  std::__shared_weak_count *v6;
  NSObject *v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  std::__shared_weak_count *v10;
  std::__shared_weak_count *v11;
  unint64_t *p_shared_weak_owners;
  unint64_t v13;
  unint64_t *p_shared_owners;
  unint64_t v15;
  std::__shared_weak_count *v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  uint64_t *v22;
  unint64_t v23;
  uint64_t v24;
  _QWORD v26[5];
  _QWORD v27[5];
  _QWORD v28[5];
  _QWORD v29[5];
  _QWORD v30[5];
  _QWORD v31[5];
  _QWORD v32[5];
  _QWORD v33[5];
  _QWORD v34[5];
  _QWORD v35[25];
  std::__shared_weak_count *v36;
  uint64_t v37;
  std::__shared_weak_count *v38;
  void *v39;
  char v40;
  dispatch_object_t v41;
  void *v42;
  char v43;
  uint8_t buf[8];
  uint64_t v45;
  __int128 v46;
  _QWORD *v47;

  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  if (*(_QWORD *)(a1 + 80))
    __TUAssertTrigger();
  v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I Bootstrap", buf, 2u);
  }
  v5 = *a2;
  *(_QWORD *)a2 = 0;
  *((_QWORD *)a2 + 1) = 0;
  v6 = *(std::__shared_weak_count **)(a1 + 104);
  *(_OWORD *)(a1 + 96) = v5;
  if (v6)
    std::__shared_weak_count::__release_weak(v6);
  std::string::basic_string[abi:ne180100]<0>(&v42, "STW QMI Driver");
  v7 = *(NSObject **)(a1 + 24);
  v41 = v7;
  if (v7)
    dispatch_retain(v7);
  std::string::basic_string[abi:ne180100]<0>(&v39, "stw");
  v8 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v8 || (v9 = *(_QWORD *)(a1 + 8), (v10 = std::__shared_weak_count::lock(v8)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v11 = v10;
  p_shared_weak_owners = (unint64_t *)&v10->__shared_weak_owners_;
  do
    v13 = __ldxr(p_shared_weak_owners);
  while (__stxr(v13 + 1, p_shared_weak_owners));
  p_shared_owners = (unint64_t *)&v10->__shared_owners_;
  do
    v15 = __ldaxr(p_shared_owners);
  while (__stlxr(v15 - 1, p_shared_owners));
  if (!v15)
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v11);
  }
  v16 = std::__shared_weak_count::lock(v11);
  if (!v16)
  {
    v37 = 0;
    v38 = 0;
    goto LABEL_25;
  }
  v17 = v16;
  v18 = (unint64_t *)&v16->__shared_weak_owners_;
  do
    v19 = __ldxr(v18);
  while (__stxr(v19 + 1, v18));
  v37 = v9;
  v38 = v16;
  std::__shared_weak_count::__release_weak(v11);
  v20 = (unint64_t *)&v17->__shared_owners_;
  do
    v21 = __ldaxr(v20);
  while (__stlxr(v21 - 1, v20));
  if (!v21)
  {
    ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
    v11 = v17;
LABEL_25:
    std::__shared_weak_count::__release_weak(v11);
  }
  Registry::getServerConnection(*(Registry **)(a1 + 48));
  qmi::Client::createWithQueueLocal();
  std::shared_ptr<qmi::Client::State>::operator=[abi:ne180100](a1 + 80, &v46);
  qmi::Client::~Client((qmi::Client *)buf);
  if (v36)
  {
    v22 = &v36->__shared_owners_;
    do
      v23 = __ldaxr((unint64_t *)v22);
    while (__stlxr(v23 - 1, (unint64_t *)v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
      std::__shared_weak_count::__release_weak(v36);
    }
  }
  if (v38)
    std::__shared_weak_count::__release_weak(v38);
  if (v40 < 0)
    operator delete(v39);
  if (v41)
    dispatch_release(v41);
  if (v43 < 0)
    operator delete(v42);
  v24 = MEMORY[0x24BDAC760];
  v35[20] = MEMORY[0x24BDAC760];
  v35[21] = 0x40000000;
  v35[22] = ___ZN22QMIStewieCommandDriver9bootstrapEONSt3__18weak_ptrI27StewieCommandDriverDelegateEE_block_invoke;
  v35[23] = &__block_descriptor_tmp_36;
  v35[24] = a1;
  qmi::Client::setHandler();
  v35[15] = v24;
  v35[16] = 0x40000000;
  v35[17] = ___ZN22QMIStewieCommandDriver9bootstrapEONSt3__18weak_ptrI27StewieCommandDriverDelegateEE_block_invoke_2;
  v35[18] = &__block_descriptor_tmp_7_10;
  v35[19] = a1;
  qmi::Client::setHandler();
  v35[10] = v24;
  v35[11] = 0x40000000;
  v35[12] = ___ZN22QMIStewieCommandDriver9bootstrapEONSt3__18weak_ptrI27StewieCommandDriverDelegateEE_block_invoke_3;
  v35[13] = &__block_descriptor_tmp_8_15;
  v35[14] = a1;
  qmi::Client::setHandler();
  v35[5] = v24;
  v35[6] = 0x40000000;
  v35[7] = ___ZN22QMIStewieCommandDriver9bootstrapEONSt3__18weak_ptrI27StewieCommandDriverDelegateEE_block_invoke_4;
  v35[8] = &__block_descriptor_tmp_9_8;
  v35[9] = a1;
  qmi::Client::setHandler();
  v35[0] = v24;
  v35[1] = 0x40000000;
  v35[2] = ___ZN22QMIStewieCommandDriver9bootstrapEONSt3__18weak_ptrI27StewieCommandDriverDelegateEE_block_invoke_5;
  v35[3] = &__block_descriptor_tmp_11_11;
  v35[4] = a1;
  *(_QWORD *)buf = v24;
  v45 = 0x40000000;
  *(_QWORD *)&v46 = ___ZNK3qmi6Client13setIndHandlerIRKN3sft11ServiceInfo10IndicationEEEvtU13block_pointerFvT_E_block_invoke;
  *((_QWORD *)&v46 + 1) = &unk_24D5E0690;
  v47 = v35;
  qmi::Client::setIndHandler();
  v34[0] = v24;
  v34[1] = 0x40000000;
  v34[2] = ___ZN22QMIStewieCommandDriver9bootstrapEONSt3__18weak_ptrI27StewieCommandDriverDelegateEE_block_invoke_6;
  v34[3] = &__block_descriptor_tmp_12_16;
  v34[4] = a1;
  *(_QWORD *)buf = v24;
  v45 = 0x40000000;
  *(_QWORD *)&v46 = ___ZNK3qmi6Client13setIndHandlerIRKN3sft20DeactivationComplete10IndicationEEEvtU13block_pointerFvT_E_block_invoke;
  *((_QWORD *)&v46 + 1) = &unk_24D5E06B8;
  v47 = v34;
  qmi::Client::setIndHandler();
  v33[0] = v24;
  v33[1] = 0x40000000;
  v33[2] = ___ZN22QMIStewieCommandDriver9bootstrapEONSt3__18weak_ptrI27StewieCommandDriverDelegateEE_block_invoke_7;
  v33[3] = &__block_descriptor_tmp_13_13;
  v33[4] = a1;
  *(_QWORD *)buf = v24;
  v45 = 0x40000000;
  *(_QWORD *)&v46 = ___ZNK3qmi6Client13setIndHandlerIRKN3sft18RequestStateChange10IndicationEEEvtU13block_pointerFvT_E_block_invoke;
  *((_QWORD *)&v46 + 1) = &unk_24D5E06E0;
  v47 = v33;
  qmi::Client::setIndHandler();
  v32[0] = v24;
  v32[1] = 0x40000000;
  v32[2] = ___ZN22QMIStewieCommandDriver9bootstrapEONSt3__18weak_ptrI27StewieCommandDriverDelegateEE_block_invoke_8;
  v32[3] = &__block_descriptor_tmp_14_12;
  v32[4] = a1;
  *(_QWORD *)buf = v24;
  v45 = 0x40000000;
  *(_QWORD *)&v46 = ___ZNK3qmi6Client13setIndHandlerIRKN3sft26SecurityConfigUpdateNeeded10IndicationEEEvtU13block_pointerFvT_E_block_invoke;
  *((_QWORD *)&v46 + 1) = &unk_24D5E0708;
  v47 = v32;
  qmi::Client::setIndHandler();
  v31[0] = v24;
  v31[1] = 0x40000000;
  v31[2] = ___ZN22QMIStewieCommandDriver9bootstrapEONSt3__18weak_ptrI27StewieCommandDriverDelegateEE_block_invoke_9;
  v31[3] = &__block_descriptor_tmp_15_21;
  v31[4] = a1;
  *(_QWORD *)buf = v24;
  v45 = 0x40000000;
  *(_QWORD *)&v46 = ___ZNK3qmi6Client13setIndHandlerIRKN3sft19SecurityConfigUsage10IndicationEEEvtU13block_pointerFvT_E_block_invoke;
  *((_QWORD *)&v46 + 1) = &unk_24D5E0730;
  v47 = v31;
  qmi::Client::setIndHandler();
  v30[0] = v24;
  v30[1] = 0x40000000;
  v30[2] = ___ZN22QMIStewieCommandDriver9bootstrapEONSt3__18weak_ptrI27StewieCommandDriverDelegateEE_block_invoke_10;
  v30[3] = &__block_descriptor_tmp_16_14;
  v30[4] = a1;
  *(_QWORD *)buf = v24;
  v45 = 0x40000000;
  *(_QWORD *)&v46 = ___ZNK3qmi6Client13setIndHandlerIRKN3sft15MessageTXStatus10IndicationEEEvtU13block_pointerFvT_E_block_invoke;
  *((_QWORD *)&v46 + 1) = &unk_24D5E0758;
  v47 = v30;
  qmi::Client::setIndHandler();
  v29[0] = v24;
  v29[1] = 0x40000000;
  v29[2] = ___ZN22QMIStewieCommandDriver9bootstrapEONSt3__18weak_ptrI27StewieCommandDriverDelegateEE_block_invoke_11;
  v29[3] = &__block_descriptor_tmp_17_17;
  v29[4] = a1;
  *(_QWORD *)buf = v24;
  v45 = 0x40000000;
  *(_QWORD *)&v46 = ___ZNK3qmi6Client13setIndHandlerIRKN3sft9MessageRX10IndicationEEEvtU13block_pointerFvT_E_block_invoke;
  *((_QWORD *)&v46 + 1) = &unk_24D5E0780;
  v47 = v29;
  qmi::Client::setIndHandler();
  v28[0] = v24;
  v28[1] = 0x40000000;
  v28[2] = ___ZN22QMIStewieCommandDriver9bootstrapEONSt3__18weak_ptrI27StewieCommandDriverDelegateEE_block_invoke_12;
  v28[3] = &__block_descriptor_tmp_18_17;
  v28[4] = a1;
  *(_QWORD *)buf = v24;
  v45 = 0x40000000;
  *(_QWORD *)&v46 = ___ZNK3qmi6Client13setIndHandlerIRKN3sft18FileTransferStatus10IndicationEEEvtU13block_pointerFvT_E_block_invoke;
  *((_QWORD *)&v46 + 1) = &unk_24D5E07A8;
  v47 = v28;
  qmi::Client::setIndHandler();
  v27[0] = v24;
  v27[1] = 0x40000000;
  v27[2] = ___ZN22QMIStewieCommandDriver9bootstrapEONSt3__18weak_ptrI27StewieCommandDriverDelegateEE_block_invoke_13;
  v27[3] = &__block_descriptor_tmp_19_14;
  v27[4] = a1;
  *(_QWORD *)buf = v24;
  v45 = 0x40000000;
  *(_QWORD *)&v46 = ___ZNK3qmi6Client13setIndHandlerIRKN3sft17ServiceOutageInfo10IndicationEEEvtU13block_pointerFvT_E_block_invoke;
  *((_QWORD *)&v46 + 1) = &unk_24D5E07D0;
  v47 = v27;
  qmi::Client::setIndHandler();
  v26[0] = v24;
  v26[1] = 0x40000000;
  v26[2] = ___ZN22QMIStewieCommandDriver9bootstrapEONSt3__18weak_ptrI27StewieCommandDriverDelegateEE_block_invoke_14;
  v26[3] = &__block_descriptor_tmp_20_14;
  v26[4] = a1;
  *(_QWORD *)buf = v24;
  v45 = 0x40000000;
  *(_QWORD *)&v46 = ___ZNK3qmi6Client13setIndHandlerIRKN3sft21SaveBroadcastInfoBlob10IndicationEEEvtU13block_pointerFvT_E_block_invoke;
  *((_QWORD *)&v46 + 1) = &unk_24D5E07F8;
  v47 = v26;
  qmi::Client::setIndHandler();
  qmi::Client::setIndShouldWake((qmi::Client *)(a1 + 64));
  qmi::Client::setIndShouldWake((qmi::Client *)(a1 + 64));
  qmi::Client::setIndShouldWake((qmi::Client *)(a1 + 64));
  qmi::Client::setIndShouldWake((qmi::Client *)(a1 + 64));
  qmi::Client::setIndShouldWake((qmi::Client *)(a1 + 64));
  qmi::Client::setIndShouldWake((qmi::Client *)(a1 + 64));
  qmi::Client::setIndShouldWake((qmi::Client *)(a1 + 64));
  qmi::Client::setIndShouldWake((qmi::Client *)(a1 + 64));
  return qmi::Client::setIndShouldWake((qmi::Client *)(a1 + 64));
}

void sub_216A1874C(_Unwind_Exception *a1)
{
  uint64_t v1;
  std::__shared_weak_count *v3;
  NSObject *v4;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v1 - 200);
  v3 = *(std::__shared_weak_count **)(v1 - 176);
  if (v3)
    std::__shared_weak_count::__release_weak(v3);
  if (*(char *)(v1 - 145) < 0)
    operator delete(*(void **)(v1 - 168));
  v4 = *(NSObject **)(v1 - 144);
  if (v4)
    dispatch_release(v4);
  if (*(char *)(v1 - 113) < 0)
    operator delete(*(void **)(v1 - 136));
  _Unwind_Resume(a1);
}

void ___ZN22QMIStewieCommandDriver9bootstrapEONSt3__18weak_ptrI27StewieCommandDriverDelegateEE_block_invoke(uint64_t a1)
{
  uint64_t v1;
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  void (***v5)(_QWORD, uint64_t);
  unint64_t *p_shared_owners;
  unint64_t v7;

  v1 = *(_QWORD *)(a1 + 32);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v1 + 24));
  *(_BYTE *)(v1 + 112) = 1;
  v2 = *(std::__shared_weak_count **)(v1 + 104);
  if (v2)
  {
    v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      v4 = v3;
      v5 = *(void (****)(_QWORD, uint64_t))(v1 + 96);
      if (v5)
        (**v5)(v5, 1);
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v7 = __ldaxr(p_shared_owners);
      while (__stlxr(v7 - 1, p_shared_owners));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
}

void sub_216A18840(_Unwind_Exception *exception_object)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v4;

  p_shared_owners = (unint64_t *)&v1->__shared_owners_;
  do
    v4 = __ldaxr(p_shared_owners);
  while (__stlxr(v4 - 1, p_shared_owners));
  if (!v4)
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN22QMIStewieCommandDriver9bootstrapEONSt3__18weak_ptrI27StewieCommandDriverDelegateEE_block_invoke_2(uint64_t a1)
{
  QMIStewieCommandDriver::notReady(*(dispatch_queue_t **)(a1 + 32));
}

void QMIStewieCommandDriver::notReady(dispatch_queue_t *this)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  void (***v5)(_QWORD, _QWORD);
  unint64_t *p_shared_owners;
  unint64_t v7;

  dispatch_assert_queue_V2(this[3]);
  *((_BYTE *)this + 112) = 0;
  v2 = (std::__shared_weak_count *)this[13];
  if (v2)
  {
    v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      v4 = v3;
      v5 = (void (***)(_QWORD, _QWORD))this[12];
      if (v5)
        (**v5)(v5, 0);
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v7 = __ldaxr(p_shared_owners);
      while (__stlxr(v7 - 1, p_shared_owners));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
}

void sub_216A18924(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void ___ZN22QMIStewieCommandDriver9bootstrapEONSt3__18weak_ptrI27StewieCommandDriverDelegateEE_block_invoke_3(uint64_t a1)
{
  QMIStewieCommandDriver::notReady(*(dispatch_queue_t **)(a1 + 32));
}

void ___ZN22QMIStewieCommandDriver9bootstrapEONSt3__18weak_ptrI27StewieCommandDriverDelegateEE_block_invoke_4(uint64_t a1)
{
  uint64_t v1;
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  unint64_t *p_shared_owners;
  unint64_t v7;

  v1 = *(_QWORD *)(a1 + 32);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v1 + 24));
  v2 = *(std::__shared_weak_count **)(v1 + 104);
  if (v2)
  {
    v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      v4 = v3;
      v5 = *(_QWORD *)(v1 + 96);
      if (v5)
        (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v7 = __ldaxr(p_shared_owners);
      while (__stlxr(v7 - 1, p_shared_owners));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
}

void sub_216A189C4(_Unwind_Exception *exception_object)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v4;

  p_shared_owners = (unint64_t *)&v1->__shared_owners_;
  do
    v4 = __ldaxr(p_shared_owners);
  while (__stlxr(v4 - 1, p_shared_owners));
  if (!v4)
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN22QMIStewieCommandDriver9bootstrapEONSt3__18weak_ptrI27StewieCommandDriverDelegateEE_block_invoke_5(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v3;
  int v4;
  NSObject *v5;
  uint64_t TlvValue;
  int v7;
  uint64_t v8;
  int v9;
  char v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  char v17;
  int v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  int v22;
  int v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  int v27;
  unsigned __int8 v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  int v32;
  unsigned __int8 v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  int v37;
  int v38;
  int v39;
  NSObject *v40;
  std::__shared_weak_count *v41;
  std::__shared_weak_count *v42;
  std::__shared_weak_count *v43;
  uint64_t v44;
  unint64_t *p_shared_owners;
  unint64_t v46;
  uint64_t v47;
  uint8_t buf[8];
  __int128 v49;
  int v50;
  uint8_t v51[8];
  uint64_t v52;

  v52 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 + 32);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v3 + 24));
  v4 = *((_DWORD *)a2 + 1);
  v5 = *(NSObject **)(v3 + 40);
  if (v4)
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109378;
      *(_DWORD *)&buf[4] = v4;
      LOWORD(v49) = 2080;
      *(_QWORD *)((char *)&v49 + 2) = qmi::asString();
      _os_log_error_impl(&dword_216897000, v5, OS_LOG_TYPE_ERROR, "Received ServiceInfo indication with error code:0x%x (%s)", buf, 0x12u);
    }
  }
  else
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#I Received ServiceInfo indication", buf, 2u);
    }
    *(_QWORD *)buf = 0;
    v49 = 0uLL;
    v50 = 0;
    TlvValue = qmi::MessageBase::findTlvValue(a2);
    v8 = TlvValue;
    if (TlvValue)
    {
      v9 = v7;
      *(_QWORD *)v51 = TlvValue;
      v10 = tlv::parseV<sft::tlv::ConnectionStatus>((unint64_t *)v51, v7);
      if (*(_QWORD *)v51)
      {
        v11 = (v10 - 1);
        if (v11 < 3)
          v12 = v11 + 1;
        else
          v12 = 0;
        *(_DWORD *)buf = v12;
      }
      else
      {
        ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 1, v8, v9);
      }
    }
    v13 = qmi::MessageBase::findTlvValue(a2);
    v15 = v13;
    if (v13)
    {
      v16 = v14;
      *(_QWORD *)v51 = v13;
      v17 = tlv::parseV<sft::tlv::RegistrationStatus>((unint64_t *)v51, v14);
      if (*(_QWORD *)v51)
      {
        v18 = 2 * (v17 == 1);
        if (!v17)
          v18 = 1;
        *(_DWORD *)&buf[4] = v18;
      }
      else
      {
        ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 2, v15, v16);
      }
    }
    v19 = qmi::MessageBase::findTlvValue(a2);
    v21 = v19;
    if (v19)
    {
      v22 = v20;
      *(_QWORD *)v51 = v19;
      v23 = tlv::parseV<sft::tlv::RSSI>((unint64_t *)v51, v20);
      if (*(_QWORD *)v51)
      {
        LODWORD(v49) = v23;
        BYTE4(v49) = 1;
      }
      else
      {
        ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 16, v21, v22);
      }
    }
    v24 = qmi::MessageBase::findTlvValue(a2);
    v26 = v24;
    if (v24)
    {
      v27 = v25;
      *(_QWORD *)v51 = v24;
      v28 = tlv::parseV<sft::tlv::CongestionStatus>((unint64_t *)v51, v25);
      if (*(_QWORD *)v51)
      {
        if (v28 <= 3u)
        {
          DWORD2(v49) = v28 + 1;
          BYTE12(v49) = 1;
        }
      }
      else
      {
        ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 17, v26, v27);
      }
    }
    v29 = qmi::MessageBase::findTlvValue(a2);
    v31 = v29;
    if (v29)
    {
      v32 = v30;
      *(_QWORD *)v51 = v29;
      v33 = tlv::parseV<sft::tlv::CurrentFMNum>((unint64_t *)v51, v30);
      if (*(_QWORD *)v51)
        LOWORD(v50) = v33 | 0x100;
      else
        ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 18, v31, v32);
    }
    v34 = qmi::MessageBase::findTlvValue(a2);
    v36 = v34;
    if (v34)
    {
      v37 = v35;
      v47 = v34;
      v38 = tlv::parseV<sft::tlv::BBUID>((unint64_t *)&v47, v35);
      if (v47)
      {
        v39 = v38;
        v40 = *(NSObject **)(v3 + 40);
        if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)v51 = 67109120;
          *(_DWORD *)&v51[4] = v39;
          _os_log_impl(&dword_216897000, v40, OS_LOG_TYPE_DEFAULT, "#I BBUID: %u", v51, 8u);
        }
        *(_DWORD *)(v3 + 116) = v39;
        *(_BYTE *)(v3 + 120) = 1;
      }
      else
      {
        ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 20, v36, v37);
      }
    }
    v41 = *(std::__shared_weak_count **)(v3 + 104);
    if (v41)
    {
      v42 = std::__shared_weak_count::lock(v41);
      if (v42)
      {
        v43 = v42;
        v44 = *(_QWORD *)(v3 + 96);
        if (v44)
          (*(void (**)(uint64_t, uint8_t *))(*(_QWORD *)v44 + 16))(v44, buf);
        p_shared_owners = (unint64_t *)&v43->__shared_owners_;
        do
          v46 = __ldaxr(p_shared_owners);
        while (__stlxr(v46 - 1, p_shared_owners));
        if (!v46)
        {
          ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
          std::__shared_weak_count::__release_weak(v43);
        }
      }
    }
  }
}

void sub_216A18E0C(_Unwind_Exception *exception_object)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v4;

  p_shared_owners = (unint64_t *)&v1->__shared_owners_;
  do
    v4 = __ldaxr(p_shared_owners);
  while (__stlxr(v4 - 1, p_shared_owners));
  if (!v4)
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN22QMIStewieCommandDriver9bootstrapEONSt3__18weak_ptrI27StewieCommandDriverDelegateEE_block_invoke_6(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v3;
  int v4;
  NSObject *v5;
  uint64_t TlvValue;
  int v7;
  uint64_t v8;
  int v9;
  unsigned __int8 v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  char v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  unsigned int v21;
  unint64_t v22;
  NSObject *v23;
  std::__shared_weak_count *v24;
  std::__shared_weak_count *v25;
  std::__shared_weak_count *v26;
  uint64_t v27;
  unint64_t *p_shared_owners;
  unint64_t v29;
  __int16 v30;
  uint64_t v31;
  __n128 __p;
  uint64_t v33;
  uint8_t buf[32];
  uint8_t v35[8];
  char v36;
  _BYTE v37[23];

  *(_QWORD *)&v37[15] = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 + 32);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v3 + 24));
  v4 = *((_DWORD *)a2 + 1);
  v5 = *(NSObject **)(v3 + 40);
  if (!v4)
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#I Received DeactivationComplete indication", buf, 2u);
    }
    TlvValue = qmi::MessageBase::findTlvValue(a2);
    v8 = TlvValue;
    if (TlvValue)
    {
      v9 = v7;
      *(_QWORD *)buf = TlvValue;
      v10 = tlv::parseV<sft::tlv::DeactivationReason>((unint64_t *)buf, v7);
      if (*(_QWORD *)buf)
      {
        if (v10 <= 5u)
        {
          v8 = dword_216AB4E3C[(char)v10];
          goto LABEL_10;
        }
      }
      else
      {
        ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 1, v8, v9);
      }
      v8 = 0;
    }
LABEL_10:
    v30 = 0;
    memset(buf, 0, sizeof(buf));
    v11 = qmi::MessageBase::findTlvValue(a2);
    v13 = v11;
    if (v11)
    {
      v14 = v12;
      v31 = v11;
      v15 = tlv::parseV<sft::tlv::SharedSecredUsage>((unint64_t *)&v31, v12);
      *(_QWORD *)v35 = v15;
      v36 = v16;
      if (v31)
      {
        v30 = (v15 == 0) | 0x100;
        __p = 0uLL;
        v33 = 0;
        std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((uint64_t)&__p, &v35[1], (uint64_t)v37, 8uLL);
        std::optional<std::vector<unsigned char>>::operator=[abi:ne180100]<std::vector<unsigned char>,void>((uint64_t)buf, &__p);
        if (__p.n128_u64[0])
        {
          __p.n128_u64[1] = __p.n128_u64[0];
          operator delete((void *)__p.n128_u64[0]);
        }
      }
      else
      {
        ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 16, v13, v14);
      }
    }
    __p = 0uLL;
    v17 = qmi::MessageBase::findTlvValue(a2);
    v19 = v17;
    if (v17)
    {
      v20 = v18;
      *(_QWORD *)v35 = v17;
      v21 = tlv::parseV<sft::tlv::CellularTXDeferTime>((unint64_t *)v35, v18);
      if (*(_QWORD *)v35)
      {
        __p.n128_u8[8] = 1;
        v22 = v21;
LABEL_22:
        __p.n128_u64[0] = v22;
        v24 = *(std::__shared_weak_count **)(v3 + 104);
        if (v24)
        {
          v25 = std::__shared_weak_count::lock(v24);
          if (v25)
          {
            v26 = v25;
            v27 = *(_QWORD *)(v3 + 96);
            if (v27)
              (*(void (**)(uint64_t, uint64_t, __int16 *, uint8_t *, __n128 *))(*(_QWORD *)v27 + 24))(v27, v8, &v30, buf, &__p);
            p_shared_owners = (unint64_t *)&v26->__shared_owners_;
            do
              v29 = __ldaxr(p_shared_owners);
            while (__stlxr(v29 - 1, p_shared_owners));
            if (!v29)
            {
              ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
              std::__shared_weak_count::__release_weak(v26);
            }
          }
        }
        if (buf[24])
        {
          if (*(_QWORD *)buf)
          {
            *(_QWORD *)&buf[8] = *(_QWORD *)buf;
            operator delete(*(void **)buf);
          }
        }
        return;
      }
      ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 2, v19, v20);
    }
    v23 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v35 = 0;
      _os_log_error_impl(&dword_216897000, v23, OS_LOG_TYPE_ERROR, "[CellularTx] BB did not populate defer time tlv, will unlock using max time", v35, 2u);
    }
    __p.n128_u8[8] = 1;
    v22 = 10000;
    goto LABEL_22;
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 67109378;
    *(_DWORD *)&buf[4] = v4;
    *(_WORD *)&buf[8] = 2080;
    *(_QWORD *)&buf[10] = qmi::asString();
    _os_log_error_impl(&dword_216897000, v5, OS_LOG_TYPE_ERROR, "Received DeactivationComplete indication with error code:0x%x (%s)", buf, 0x12u);
  }
}

void sub_216A191A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, char a18)
{
  std::__shared_weak_count *v18;
  unint64_t *p_shared_owners;
  unint64_t v21;

  p_shared_owners = (unint64_t *)&v18->__shared_owners_;
  do
    v21 = __ldaxr(p_shared_owners);
  while (__stlxr(v21 - 1, p_shared_owners));
  if (!v21)
  {
    ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
    std::__shared_weak_count::__release_weak(v18);
  }
  if (a18)
  {
    if (__p)
      operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN22QMIStewieCommandDriver9bootstrapEONSt3__18weak_ptrI27StewieCommandDriverDelegateEE_block_invoke_7(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v3;
  int v4;
  NSObject *v5;
  uint64_t TlvValue;
  int v7;
  uint64_t v8;
  int v9;
  char v10;
  int v11;
  std::__shared_weak_count *v12;
  std::__shared_weak_count *v13;
  std::__shared_weak_count *v14;
  uint64_t v15;
  NSObject *v16;
  NSObject *v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int v21;
  unsigned __int8 v22;
  uint64_t v23;
  NSObject *v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  int v28;
  unsigned __int8 v29;
  uint64_t v30;
  unint64_t *p_shared_owners;
  unint64_t v32;
  uint64_t v33;
  __int16 v34;
  uint64_t v35;
  uint64_t v36;

  v36 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 + 32);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v3 + 24));
  v4 = *((_DWORD *)a2 + 1);
  v5 = *(NSObject **)(v3 + 40);
  if (v4)
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      LODWORD(v33) = 67109378;
      HIDWORD(v33) = v4;
      v34 = 2080;
      v35 = qmi::asString();
      _os_log_error_impl(&dword_216897000, v5, OS_LOG_TYPE_ERROR, "Received RequestStateChange indication with error code:0x%x (%s)", (uint8_t *)&v33, 0x12u);
    }
    return;
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v33) = 0;
    _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#I Received RequestStateChange indication", (uint8_t *)&v33, 2u);
  }
  TlvValue = qmi::MessageBase::findTlvValue(a2);
  v8 = TlvValue;
  if (!TlvValue)
    goto LABEL_10;
  v9 = v7;
  v33 = TlvValue;
  v10 = tlv::parseV<sft::tlv::RequestedAction>((unint64_t *)&v33, v7);
  if (!v33)
  {
    ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 1, v8, v9);
LABEL_10:
    v11 = 0;
    goto LABEL_11;
  }
  if (v10)
    v11 = 2 * (v10 == 1);
  else
    v11 = 1;
LABEL_11:
  v12 = *(std::__shared_weak_count **)(v3 + 104);
  if (v12)
  {
    v13 = std::__shared_weak_count::lock(v12);
    if (v13)
    {
      v14 = v13;
      v15 = *(_QWORD *)(v3 + 96);
      if (!v15)
        goto LABEL_37;
      if (v11 != 2)
      {
        if (v11 != 1)
        {
          if (!v11)
          {
            v16 = *(NSObject **)(v3 + 40);
            if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
            {
              LOWORD(v33) = 0;
              _os_log_error_impl(&dword_216897000, v16, OS_LOG_TYPE_ERROR, "Received RequestStateChange indication for unsupported action", (uint8_t *)&v33, 2u);
            }
          }
          goto LABEL_37;
        }
        v24 = *(NSObject **)(v3 + 40);
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v33) = 0;
          _os_log_impl(&dword_216897000, v24, OS_LOG_TYPE_DEFAULT, "#I Received RequestStateChange indication for suspension", (uint8_t *)&v33, 2u);
        }
        v25 = qmi::MessageBase::findTlvValue(a2);
        v27 = v25;
        if (v25)
        {
          v28 = v26;
          v33 = v25;
          v29 = tlv::parseV<sft::tlv::SuspendReason>((unint64_t *)&v33, v26);
          if (v33)
          {
            if (v29 <= 2u)
            {
              v30 = dword_216AB4E30[(char)v29];
LABEL_36:
              (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v15 + 40))(v15, v30);
LABEL_37:
              p_shared_owners = (unint64_t *)&v14->__shared_owners_;
              do
                v32 = __ldaxr(p_shared_owners);
              while (__stlxr(v32 - 1, p_shared_owners));
              if (!v32)
              {
                ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
                std::__shared_weak_count::__release_weak(v14);
              }
              return;
            }
          }
          else
          {
            ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 2, v27, v28);
          }
        }
        v30 = 0;
        goto LABEL_36;
      }
      v17 = *(NSObject **)(v3 + 40);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v33) = 0;
        _os_log_impl(&dword_216897000, v17, OS_LOG_TYPE_DEFAULT, "#I Received RequestStateChange indication for deactivation", (uint8_t *)&v33, 2u);
      }
      v18 = qmi::MessageBase::findTlvValue(a2);
      v20 = v18;
      if (v18)
      {
        v21 = v19;
        v33 = v18;
        v22 = tlv::parseV<sft::tlv::DeactivationReason>((unint64_t *)&v33, v19);
        if (v33)
        {
          if (v22 <= 5u)
          {
            v23 = dword_216AB4E3C[(char)v22];
LABEL_33:
            (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v15 + 32))(v15, v23);
            goto LABEL_37;
          }
        }
        else
        {
          ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 3, v20, v21);
        }
      }
      v23 = 0;
      goto LABEL_33;
    }
  }
}

void sub_216A195A0(_Unwind_Exception *exception_object)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v4;

  p_shared_owners = (unint64_t *)&v1->__shared_owners_;
  do
    v4 = __ldaxr(p_shared_owners);
  while (__stlxr(v4 - 1, p_shared_owners));
  if (!v4)
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN22QMIStewieCommandDriver9bootstrapEONSt3__18weak_ptrI27StewieCommandDriverDelegateEE_block_invoke_8(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  int v4;
  NSObject *v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  _DWORD v12[2];
  __int16 v13;
  uint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 + 32);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v3 + 24));
  v4 = *(_DWORD *)(a2 + 4);
  v5 = *(NSObject **)(v3 + 40);
  if (v4)
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v12[0] = 67109378;
      v12[1] = v4;
      v13 = 2080;
      v14 = qmi::asString();
      _os_log_error_impl(&dword_216897000, v5, OS_LOG_TYPE_ERROR, "Received SecurityConfigUpdateNeeded indication with error code:0x%x (%s)", (uint8_t *)v12, 0x12u);
    }
  }
  else
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v12[0]) = 0;
      _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#I Received SecurityConfigUpdateNeeded indication", (uint8_t *)v12, 2u);
    }
    v6 = *(std::__shared_weak_count **)(v3 + 104);
    if (v6)
    {
      v7 = std::__shared_weak_count::lock(v6);
      if (v7)
      {
        v8 = v7;
        v9 = *(_QWORD *)(v3 + 96);
        if (v9)
          (*(void (**)(uint64_t))(*(_QWORD *)v9 + 48))(v9);
        p_shared_owners = (unint64_t *)&v8->__shared_owners_;
        do
          v11 = __ldaxr(p_shared_owners);
        while (__stlxr(v11 - 1, p_shared_owners));
        if (!v11)
        {
          ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
          std::__shared_weak_count::__release_weak(v8);
        }
      }
    }
  }
}

void sub_216A19748(_Unwind_Exception *exception_object)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v4;

  p_shared_owners = (unint64_t *)&v1->__shared_owners_;
  do
    v4 = __ldaxr(p_shared_owners);
  while (__stlxr(v4 - 1, p_shared_owners));
  if (!v4)
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN22QMIStewieCommandDriver9bootstrapEONSt3__18weak_ptrI27StewieCommandDriverDelegateEE_block_invoke_9(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v3;
  int v4;
  NSObject *v5;
  uint64_t TlvValue;
  int v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint8_t v11;
  uint64_t v12;
  uint64_t i;
  uint64_t v14;
  std::__shared_weak_count *v15;
  std::__shared_weak_count *v16;
  std::__shared_weak_count *v17;
  uint64_t v18;
  unint64_t *p_shared_owners;
  unint64_t v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  int v24;
  __n128 v25;
  void *__p[2];
  __int128 v27;
  void *v28;
  void *v29;
  uint64_t v30;
  uint64_t v31;
  __n128 v32;
  uint64_t v33;
  uint8_t buf[32];
  _QWORD v35[2];

  v35[1] = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 + 32);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v3 + 24));
  v4 = *((_DWORD *)a2 + 1);
  v5 = *(NSObject **)(v3 + 40);
  if (!v4)
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#I Received SecurityConfigUsage indication", buf, 2u);
    }
    v28 = 0;
    v29 = 0;
    v30 = 0;
    TlvValue = qmi::MessageBase::findTlvValue(a2);
    v8 = TlvValue;
    if (TlvValue)
    {
      v9 = v7;
      v32.n128_u64[0] = TlvValue;
      v10 = tlv::parseV<sft::tlv::SharedSecredUsage>(v32.n128_u64, v7);
      *(_QWORD *)buf = v10;
      buf[8] = v11;
      if (v32.n128_u64[0])
      {
        v12 = v10;
        __p[0] = &v28;
        for (i = 1; i != 9; ++i)
          std::back_insert_iterator<std::vector<unsigned char>>::operator=[abi:ne180100]((unint64_t **)__p, &buf[i]);
        *(_OWORD *)__p = 0u;
        v27 = 0u;
        if (v12)
        {
          v14 = 0;
        }
        else
        {
          v21 = qmi::MessageBase::findTlvValue(a2);
          v23 = v21;
          if (v21)
          {
            v24 = v22;
            v31 = v21;
            memset(buf, 0, sizeof(buf));
            v25 = tlv::parseV<sft::tlv::GeneratedAppKey>((unint64_t *)&v31, v22, buf);
            if (v31)
            {
              v32 = 0uLL;
              v33 = 0;
              std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((uint64_t)&v32, buf, (uint64_t)v35, 0x20uLL);
              std::optional<std::vector<unsigned char>>::operator=[abi:ne180100]<std::vector<unsigned char>,void>((uint64_t)__p, &v32);
              if (v32.n128_u64[0])
              {
                v32.n128_u64[1] = v32.n128_u64[0];
                operator delete((void *)v32.n128_u64[0]);
              }
            }
            else
            {
              ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD, __n128))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 2, v23, v24, v25);
            }
          }
          v14 = 1;
        }
        goto LABEL_12;
      }
      ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 1, v8, v9);
    }
    v14 = 0;
    *(_OWORD *)__p = 0u;
    v27 = 0u;
LABEL_12:
    v15 = *(std::__shared_weak_count **)(v3 + 104);
    if (v15)
    {
      v16 = std::__shared_weak_count::lock(v15);
      if (v16)
      {
        v17 = v16;
        v18 = *(_QWORD *)(v3 + 96);
        if (v18)
          (*(void (**)(uint64_t, uint64_t, void **, void **))(*(_QWORD *)v18 + 56))(v18, v14, &v28, __p);
        p_shared_owners = (unint64_t *)&v17->__shared_owners_;
        do
          v20 = __ldaxr(p_shared_owners);
        while (__stlxr(v20 - 1, p_shared_owners));
        if (!v20)
        {
          ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
          std::__shared_weak_count::__release_weak(v17);
        }
      }
    }
    if (BYTE8(v27) && __p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    if (v28)
    {
      v29 = v28;
      operator delete(v28);
    }
    return;
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 67109378;
    *(_DWORD *)&buf[4] = v4;
    *(_WORD *)&buf[8] = 2080;
    *(_QWORD *)&buf[10] = qmi::asString();
    _os_log_error_impl(&dword_216897000, v5, OS_LOG_TYPE_ERROR, "Received SecurityConfigUsage indication with error code:0x%x (%s)", buf, 0x12u);
  }
}

void sub_216A19A60(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, char a12, uint64_t a13, void *a14, uint64_t a15)
{
  if (a12 && __p)
    operator delete(__p);
  if (a14)
    operator delete(a14);
  _Unwind_Resume(exception_object);
}

void ___ZN22QMIStewieCommandDriver9bootstrapEONSt3__18weak_ptrI27StewieCommandDriverDelegateEE_block_invoke_10(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v3;
  int v4;
  NSObject *v5;
  uint64_t TlvValue;
  int v7;
  uint64_t v8;
  int v9;
  uint64_t byte7;
  uint64_t byte8;
  CFUUIDRef v12;
  uint64_t (*v13)(uint64_t);
  uint64_t v14;
  int v15;
  _BOOL8 v16;
  int v17;
  char v18;
  NSObject *v19;
  std::__shared_weak_count *v20;
  std::__shared_weak_count *v21;
  std::__shared_weak_count *v22;
  uint64_t v23;
  unint64_t *p_shared_owners;
  unint64_t v25;
  CFUUIDRef v26;
  uint64_t v27;
  const void *v28;
  uint8_t buf[8];
  __int16 v30;
  uint64_t v31;
  uint64_t v32;

  v32 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 + 32);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v3 + 24));
  v4 = *((_DWORD *)a2 + 1);
  v5 = *(NSObject **)(v3 + 40);
  if (v4)
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109378;
      *(_DWORD *)&buf[4] = v4;
      v30 = 2080;
      v31 = qmi::asString();
      _os_log_error_impl(&dword_216897000, v5, OS_LOG_TYPE_ERROR, "Received MessageTXStatus indication with error code:0x%x (%s)", buf, 0x12u);
    }
  }
  else
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#I Received MessageTXStatus indication", buf, 2u);
    }
    v26 = 0;
    TlvValue = qmi::MessageBase::findTlvValue(a2);
    v8 = TlvValue;
    if (TlvValue)
    {
      v9 = v7;
      v27 = TlvValue;
      byte7 = tlv::parseV<sft::tlv::GUID>((unint64_t *)&v27, v7);
      if (v27)
      {
        v12 = CFUUIDCreateWithBytes((CFAllocatorRef)*MEMORY[0x24BDBD240], byte7, BYTE1(byte7), BYTE2(byte7), BYTE3(byte7), BYTE4(byte7), BYTE5(byte7), BYTE6(byte7), HIBYTE(byte7), byte8, BYTE1(byte8), BYTE2(byte8), BYTE3(byte8), BYTE4(byte8), BYTE5(byte8), BYTE6(byte8), HIBYTE(byte8));
        v28 = 0;
        *(_QWORD *)buf = v26;
        v26 = v12;
        ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::~SharedRef((const void **)buf);
        ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::~SharedRef(&v28);
      }
      else
      {
        ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 1, v8, v9);
      }
    }
    if (v26)
      v13 = ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::get;
    else
      v13 = 0;
    if (v13)
    {
      v14 = qmi::MessageBase::findTlvValue(a2);
      v16 = v14;
      if (v14)
      {
        v17 = v15;
        *(_QWORD *)buf = v14;
        v18 = tlv::parseV<sft::tlv::MessageSendResult>((unint64_t *)buf, v15);
        if (*(_QWORD *)buf)
        {
          v16 = v18 == 0;
        }
        else
        {
          ((void (*)(_QWORD, uint64_t, _BOOL8, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 2, v16, v17);
          v16 = 0;
        }
      }
      v20 = *(std::__shared_weak_count **)(v3 + 104);
      if (v20)
      {
        v21 = std::__shared_weak_count::lock(v20);
        if (v21)
        {
          v22 = v21;
          v23 = *(_QWORD *)(v3 + 96);
          if (v23)
            (*(void (**)(uint64_t, CFUUIDRef *, _BOOL8))(*(_QWORD *)v23 + 64))(v23, &v26, v16);
          p_shared_owners = (unint64_t *)&v22->__shared_owners_;
          do
            v25 = __ldaxr(p_shared_owners);
          while (__stlxr(v25 - 1, p_shared_owners));
          if (!v25)
          {
            ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
            std::__shared_weak_count::__release_weak(v22);
          }
        }
      }
    }
    else
    {
      v19 = *(NSObject **)(v3 + 40);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_216897000, v19, OS_LOG_TYPE_ERROR, "Received MessageTXStatus indication without valid messageId", buf, 2u);
      }
    }
    ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::~SharedRef((const void **)&v26);
  }
}

void sub_216A19DE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v7;
  va_list va;

  va_start(va, a4);
  p_shared_owners = (unint64_t *)&v4->__shared_owners_;
  do
    v7 = __ldaxr(p_shared_owners);
  while (__stlxr(v7 - 1, p_shared_owners));
  if (!v7)
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::~SharedRef((const void **)va);
  _Unwind_Resume(a1);
}

void ___ZN22QMIStewieCommandDriver9bootstrapEONSt3__18weak_ptrI27StewieCommandDriverDelegateEE_block_invoke_11(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v3;
  int v4;
  NSObject *v5;
  uint64_t TlvValue;
  int v7;
  uint64_t v8;
  int v9;
  unsigned __int16 v10;
  unsigned __int16 v11;
  char *v12;
  int v13;
  char *v14;
  int v15;
  char *v16;
  std::__shared_weak_count *v17;
  std::__shared_weak_count *v18;
  std::__shared_weak_count *v19;
  uint64_t v20;
  unint64_t *p_shared_owners;
  unint64_t v22;
  NSObject *v23;
  const char *v24;
  NSObject *v25;
  uint32_t v26;
  void *__p;
  void *v28;
  uint64_t v29;
  char *v30;
  uint8_t buf[8];
  __int128 v32;
  uint64_t v33;

  v33 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 + 32);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v3 + 24));
  v4 = *((_DWORD *)a2 + 1);
  v5 = *(NSObject **)(v3 + 40);
  if (v4)
  {
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      return;
    *(_DWORD *)buf = 67109378;
    *(_DWORD *)&buf[4] = v4;
    LOWORD(v32) = 2080;
    *(_QWORD *)((char *)&v32 + 2) = qmi::asString();
    v24 = "Received MessageRX indication with error code:0x%x (%s)";
    v25 = v5;
    v26 = 18;
LABEL_27:
    _os_log_error_impl(&dword_216897000, v25, OS_LOG_TYPE_ERROR, v24, buf, v26);
    return;
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#I Received MessageRX indication", buf, 2u);
  }
  TlvValue = qmi::MessageBase::findTlvValue(a2);
  v8 = TlvValue;
  if (!TlvValue)
  {
LABEL_24:
    v23 = *(NSObject **)(v3 + 40);
    if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      return;
    *(_WORD *)buf = 0;
    v24 = "Received MessageRX indication without messageId";
    v25 = v23;
    v26 = 2;
    goto LABEL_27;
  }
  v9 = v7;
  *(_QWORD *)buf = TlvValue;
  v10 = tlv::parseV<sft::tlv::BBMessageID>((unint64_t *)buf, v7);
  if (!*(_QWORD *)buf)
  {
    ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 1, v8, v9);
    goto LABEL_24;
  }
  v11 = v10;
  __p = 0;
  v28 = 0;
  v29 = 0;
  v12 = (char *)qmi::MessageBase::findTlvValue(a2);
  v14 = v12;
  if (v12)
  {
    v15 = v13;
    v30 = v12;
    *(_QWORD *)buf = 0;
    v32 = 0uLL;
    tlv::parseV<sft::tlv::Message>(&v30, v13, buf);
    v16 = v30;
    if (v30)
      std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(&__p, *(char **)buf, (char *)v32, v32 - *(_QWORD *)buf);
    if (*(_QWORD *)buf)
    {
      *(_QWORD *)&v32 = *(_QWORD *)buf;
      operator delete(*(void **)buf);
    }
    if (!v16)
      ((void (*)(_QWORD, uint64_t, char *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 2, v14, v15);
  }
  v17 = *(std::__shared_weak_count **)(v3 + 104);
  if (v17)
  {
    v18 = std::__shared_weak_count::lock(v17);
    if (v18)
    {
      v19 = v18;
      v20 = *(_QWORD *)(v3 + 96);
      if (v20)
        (*(void (**)(uint64_t, _QWORD, void **))(*(_QWORD *)v20 + 72))(v20, v11, &__p);
      p_shared_owners = (unint64_t *)&v19->__shared_owners_;
      do
        v22 = __ldaxr(p_shared_owners);
      while (__stlxr(v22 - 1, p_shared_owners));
      if (!v22)
      {
        ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
        std::__shared_weak_count::__release_weak(v19);
      }
    }
  }
  if (__p)
  {
    v28 = __p;
    operator delete(__p);
  }
}

void sub_216A1A0B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14)
{
  std::__shared_weak_count *v14;
  unint64_t *p_shared_owners;
  unint64_t v17;

  p_shared_owners = (unint64_t *)&v14->__shared_owners_;
  do
    v17 = __ldaxr(p_shared_owners);
  while (__stlxr(v17 - 1, p_shared_owners));
  if (!v17)
  {
    ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
    std::__shared_weak_count::__release_weak(v14);
  }
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void ___ZN22QMIStewieCommandDriver9bootstrapEONSt3__18weak_ptrI27StewieCommandDriverDelegateEE_block_invoke_12(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v3;
  int v4;
  NSObject *v5;
  uint64_t TlvValue;
  int v7;
  uint64_t v8;
  int v9;
  unsigned __int16 v10;
  _BOOL8 v11;
  std::__shared_weak_count *v12;
  std::__shared_weak_count *v13;
  std::__shared_weak_count *v14;
  uint64_t v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  uint64_t v18;
  __int16 v19;
  uint64_t v20;
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 + 32);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v3 + 24));
  v4 = *((_DWORD *)a2 + 1);
  v5 = *(NSObject **)(v3 + 40);
  if (!v4)
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v18) = 0;
      _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#I Received FileTransferStatus indication", (uint8_t *)&v18, 2u);
    }
    TlvValue = qmi::MessageBase::findTlvValue(a2);
    v8 = TlvValue;
    if (TlvValue)
    {
      v9 = v7;
      v18 = TlvValue;
      v10 = tlv::parseV<sft::tlv::TransferStatus>((unint64_t *)&v18, v7);
      if (v18)
      {
        if (v10 == 13)
          v8 = 2;
        else
          v8 = v10 == 12;
        v11 = v10 < 0x100u;
LABEL_12:
        v12 = *(std::__shared_weak_count **)(v3 + 104);
        if (v12)
        {
          v13 = std::__shared_weak_count::lock(v12);
          if (v13)
          {
            v14 = v13;
            v15 = *(_QWORD *)(v3 + 96);
            if (v15)
              (*(void (**)(uint64_t, uint64_t, _BOOL8))(*(_QWORD *)v15 + 80))(v15, v8, v11);
            p_shared_owners = (unint64_t *)&v14->__shared_owners_;
            do
              v17 = __ldaxr(p_shared_owners);
            while (__stlxr(v17 - 1, p_shared_owners));
            if (!v17)
            {
              ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
              std::__shared_weak_count::__release_weak(v14);
            }
          }
        }
        return;
      }
      ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 1, v8, v9);
      v8 = 0;
    }
    v11 = 0;
    goto LABEL_12;
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    LODWORD(v18) = 67109378;
    HIDWORD(v18) = v4;
    v19 = 2080;
    v20 = qmi::asString();
    _os_log_error_impl(&dword_216897000, v5, OS_LOG_TYPE_ERROR, "Received FileTransferStatus indication with error code:0x%x (%s)", (uint8_t *)&v18, 0x12u);
  }
}

void sub_216A1A308(_Unwind_Exception *exception_object)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v4;

  p_shared_owners = (unint64_t *)&v1->__shared_owners_;
  do
    v4 = __ldaxr(p_shared_owners);
  while (__stlxr(v4 - 1, p_shared_owners));
  if (!v4)
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN22QMIStewieCommandDriver9bootstrapEONSt3__18weak_ptrI27StewieCommandDriverDelegateEE_block_invoke_13(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v3;
  int v4;
  NSObject *v5;
  void *TlvValue;
  int v7;
  void *v8;
  int v9;
  int v10;
  unsigned __int8 *v11;
  int v12;
  unsigned __int8 *v13;
  int v14;
  unsigned __int8 *v15;
  _QWORD *v16;
  _QWORD *v17;
  _QWORD *v18;
  char v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  _QWORD *v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  char *v27;
  char *v28;
  char *v29;
  __int128 v30;
  char *v31;
  std::__shared_weak_count *v32;
  std::__shared_weak_count *v33;
  std::__shared_weak_count *v34;
  uint64_t v35;
  unint64_t *p_shared_owners;
  unint64_t v37;
  unsigned __int8 *v38;
  int v39;
  unsigned __int8 *v40;
  qmi::MessageBase *v41;
  uint64_t v42;
  void *__p;
  _QWORD *v44;
  uint64_t v45;
  unsigned __int8 *v46;
  uint8_t buf[40];
  uint64_t v48;

  v48 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 + 32);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v3 + 24));
  v4 = *((_DWORD *)a2 + 1);
  v5 = *(NSObject **)(v3 + 40);
  if (v4)
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109378;
      *(_DWORD *)&buf[4] = v4;
      *(_WORD *)&buf[8] = 2080;
      *(_QWORD *)&buf[10] = qmi::asString();
      _os_log_error_impl(&dword_216897000, v5, OS_LOG_TYPE_ERROR, "Received ServiceOutageInfo indication with error code:0x%x (%s)", buf, 0x12u);
    }
  }
  else
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#I Received ServiceOutageInfo indication", buf, 2u);
    }
    memset(buf, 0, 32);
    TlvValue = (void *)qmi::MessageBase::findTlvValue(a2);
    v8 = TlvValue;
    if (TlvValue)
    {
      v9 = v7;
      __p = TlvValue;
      v10 = tlv::parseV<sft::tlv::ServiceOutageInfoIdentifier>((unint64_t *)&__p, v7);
      if (__p)
        *(_DWORD *)buf = v10;
      else
        ((void (*)(_QWORD, uint64_t, void *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 1, v8, v9);
    }
    v11 = (unsigned __int8 *)qmi::MessageBase::findTlvValue(a2);
    v13 = v11;
    if (v11)
    {
      v14 = v12;
      v45 = 0;
      v46 = v11;
      __p = 0;
      v44 = 0;
      tlv::parseV<sft::tlv::SatelliteOutages>(&v46, v12, (uint64_t *)&__p);
      v15 = v46;
      v16 = __p;
      if (v46)
      {
        v17 = v44;
        if (__p != v44)
        {
          v38 = v46;
          v39 = v14;
          v40 = v13;
          v41 = a2;
          v42 = v3;
          v18 = 0;
          do
          {
            v19 = *(_BYTE *)v16;
            v20 = v16[1];
            v21 = v16[2];
            if ((unint64_t)v18 >= *(_QWORD *)&buf[24])
            {
              v23 = *(_QWORD **)&buf[8];
              v24 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v18 - *(_QWORD *)&buf[8]) >> 3);
              v25 = v24 + 1;
              if (v24 + 1 > 0xAAAAAAAAAAAAAAALL)
                std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
              if (0x5555555555555556 * ((uint64_t)(*(_QWORD *)&buf[24] - *(_QWORD *)&buf[8]) >> 3) > v25)
                v25 = 0x5555555555555556 * ((uint64_t)(*(_QWORD *)&buf[24] - *(_QWORD *)&buf[8]) >> 3);
              if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)&buf[24] - *(_QWORD *)&buf[8]) >> 3) >= 0x555555555555555)
                v26 = 0xAAAAAAAAAAAAAAALL;
              else
                v26 = v25;
              if (v26)
              {
                if (v26 > 0xAAAAAAAAAAAAAAALL)
                  std::__throw_bad_array_new_length[abi:ne180100]();
                v27 = (char *)operator new(24 * v26);
              }
              else
              {
                v27 = 0;
              }
              v28 = &v27[24 * v24];
              *v28 = v19;
              *((_QWORD *)v28 + 1) = v20;
              *((_QWORD *)v28 + 2) = v21;
              v29 = v28;
              if (v18 != v23)
              {
                do
                {
                  v30 = *(_OWORD *)(v18 - 3);
                  *((_QWORD *)v29 - 1) = *(v18 - 1);
                  *(_OWORD *)(v29 - 24) = v30;
                  v29 -= 24;
                  v18 -= 3;
                }
                while (v18 != v23);
                v18 = *(_QWORD **)&buf[8];
              }
              v31 = &v27[24 * v26];
              v22 = v28 + 24;
              *(_QWORD *)&buf[8] = v29;
              *(_QWORD *)&buf[16] = v28 + 24;
              *(_QWORD *)&buf[24] = v31;
              if (v18)
                operator delete(v18);
            }
            else
            {
              *(_BYTE *)v18 = v19;
              v22 = v18 + 3;
              v18[1] = v20;
              v18[2] = v21;
            }
            *(_QWORD *)&buf[16] = v22;
            v16 += 3;
            v18 = v22;
          }
          while (v16 != v17);
          v3 = v42;
          v16 = __p;
          v13 = v40;
          a2 = v41;
          v15 = v38;
          v14 = v39;
        }
      }
      if (v16)
      {
        v44 = v16;
        operator delete(v16);
      }
      if (!v15)
        ((void (*)(_QWORD, uint64_t, unsigned __int8 *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 2, v13, v14);
    }
    v32 = *(std::__shared_weak_count **)(v3 + 104);
    if (v32)
    {
      v33 = std::__shared_weak_count::lock(v32);
      if (v33)
      {
        v34 = v33;
        v35 = *(_QWORD *)(v3 + 96);
        if (v35)
          (*(void (**)(uint64_t, uint8_t *))(*(_QWORD *)v35 + 88))(v35, buf);
        p_shared_owners = (unint64_t *)&v34->__shared_owners_;
        do
          v37 = __ldaxr(p_shared_owners);
        while (__stlxr(v37 - 1, p_shared_owners));
        if (!v37)
        {
          ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
          std::__shared_weak_count::__release_weak(v34);
        }
      }
    }
    if (*(_QWORD *)&buf[8])
    {
      *(_QWORD *)&buf[16] = *(_QWORD *)&buf[8];
      operator delete(*(void **)&buf[8]);
    }
  }
}

void sub_216A1A6E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  std::__shared_weak_count *v21;
  unint64_t *p_shared_owners;
  unint64_t v24;

  p_shared_owners = (unint64_t *)&v21->__shared_owners_;
  do
    v24 = __ldaxr(p_shared_owners);
  while (__stlxr(v24 - 1, p_shared_owners));
  if (!v24)
  {
    ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
    std::__shared_weak_count::__release_weak(v21);
  }
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void ___ZN22QMIStewieCommandDriver9bootstrapEONSt3__18weak_ptrI27StewieCommandDriverDelegateEE_block_invoke_14(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v3;
  int v4;
  NSObject *v5;
  char *TlvValue;
  int v7;
  char *v8;
  int v9;
  char *v10;
  std::__shared_weak_count *v11;
  std::__shared_weak_count *v12;
  std::__shared_weak_count *v13;
  uint64_t v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  void *__p;
  void *v18;
  uint64_t v19;
  char *v20;
  uint8_t buf[8];
  __int128 v22;
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 + 32);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v3 + 24));
  v4 = *((_DWORD *)a2 + 1);
  v5 = *(NSObject **)(v3 + 40);
  if (v4)
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109378;
      *(_DWORD *)&buf[4] = v4;
      LOWORD(v22) = 2080;
      *(_QWORD *)((char *)&v22 + 2) = qmi::asString();
      _os_log_error_impl(&dword_216897000, v5, OS_LOG_TYPE_ERROR, "Received SaveBroadcastInfoBlob indication with error code:0x%x (%s)", buf, 0x12u);
    }
  }
  else
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#I Received SaveBroadcastInfoBlob indication", buf, 2u);
    }
    __p = 0;
    v18 = 0;
    v19 = 0;
    TlvValue = (char *)qmi::MessageBase::findTlvValue(a2);
    v8 = TlvValue;
    if (TlvValue)
    {
      v9 = v7;
      v20 = TlvValue;
      *(_QWORD *)buf = 0;
      v22 = 0uLL;
      tlv::parseV<sft::tlv::BroadcastInfoBlob>(&v20, v7, buf);
      v10 = v20;
      if (v20)
        std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(&__p, *(char **)buf, (char *)v22, v22 - *(_QWORD *)buf);
      if (*(_QWORD *)buf)
      {
        *(_QWORD *)&v22 = *(_QWORD *)buf;
        operator delete(*(void **)buf);
      }
      if (!v10)
        ((void (*)(_QWORD, uint64_t, char *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 1, v8, v9);
    }
    v11 = *(std::__shared_weak_count **)(v3 + 104);
    if (v11)
    {
      v12 = std::__shared_weak_count::lock(v11);
      if (v12)
      {
        v13 = v12;
        v14 = *(_QWORD *)(v3 + 96);
        if (v14)
          (*(void (**)(uint64_t, void **))(*(_QWORD *)v14 + 96))(v14, &__p);
        p_shared_owners = (unint64_t *)&v13->__shared_owners_;
        do
          v16 = __ldaxr(p_shared_owners);
        while (__stlxr(v16 - 1, p_shared_owners));
        if (!v16)
        {
          ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
          std::__shared_weak_count::__release_weak(v13);
        }
      }
    }
    if (__p)
    {
      v18 = __p;
      operator delete(__p);
    }
  }
}

void sub_216A1A954(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14)
{
  std::__shared_weak_count *v14;
  unint64_t *p_shared_owners;
  unint64_t v17;

  p_shared_owners = (unint64_t *)&v14->__shared_owners_;
  do
    v17 = __ldaxr(p_shared_owners);
  while (__stlxr(v17 - 1, p_shared_owners));
  if (!v17)
  {
    ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
    std::__shared_weak_count::__release_weak(v14);
  }
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t QMIStewieCommandDriver::start(dispatch_queue_t *this)
{
  NSObject *v2;
  uint8_t v4[16];

  dispatch_assert_queue_V2(this[3]);
  if (!this[10])
    __TUAssertTrigger();
  v2 = this[5];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v4 = 0;
    _os_log_impl(&dword_216897000, v2, OS_LOG_TYPE_DEFAULT, "#I Start", v4, 2u);
  }
  return qmi::Client::start((qmi::Client *)(this + 8));
}

void QMIStewieCommandDriver::stop(dispatch_queue_t *this)
{
  NSObject *v2;
  std::__shared_weak_count *v3;
  uint8_t v4[16];

  dispatch_assert_queue_V2(this[3]);
  if (!this[10])
    __TUAssertTrigger();
  v2 = this[5];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v4 = 0;
    _os_log_impl(&dword_216897000, v2, OS_LOG_TYPE_DEFAULT, "#I Stop", v4, 2u);
  }
  *((_BYTE *)this + 112) = 0;
  qmi::Client::stop((qmi::Client *)(this + 8));
  qmi::Client::release((qmi::Client *)(this + 8));
  v3 = (std::__shared_weak_count *)this[13];
  this[12] = 0;
  this[13] = 0;
  if (v3)
    std::__shared_weak_count::__release_weak(v3);
}

void QMIStewieCommandDriver::getCapabilities(std::__shared_weak_count_vtbl *a1, uint64_t a2)
{
  _QWORD *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  uint64_t v7;
  unint64_t v8;
  void *v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  NSObject *v18;
  uint8_t *v19;
  uint64_t v20;
  _OWORD v21[2];
  const void *(__cdecl **p_get_deleter)(const std::__shared_weak_count *__hidden, const std::type_info *);
  uint64_t v23;
  int v24;
  uint64_t v25;
  void *v26;
  _QWORD *v27;
  std::__shared_weak_count *v28;
  _QWORD aBlock[5];
  std::__shared_weak_count_vtbl *v30;
  _BYTE v31[24];
  _BYTE *v32;
  uint8_t buf[8];
  uint64_t v34;
  uint64_t (*v35)(uint64_t, qmi::MessageBase *);
  uint8_t *v36;
  _QWORD *v37;
  std::__shared_weak_count *v38;
  uint64_t v39;

  v39 = *MEMORY[0x24BDAC8D0];
  dispatch_assert_queue_V2((dispatch_queue_t)a1->__get_deleter);
  if (LOBYTE(a1[2].__on_zero_shared_weak))
  {
    memset(v21, 0, sizeof(v21));
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v21);
    v30 = a1;
    v4 = v31;
    std::__function::__value_func<void ()(BOOL,StewieHWSupportType)>::__value_func[abi:ne180100]((uint64_t)v31, a2);
    dispatch_assert_queue_V2((dispatch_queue_t)a1->__get_deleter);
    v5 = (std::__shared_weak_count *)operator new(0x40uLL);
    v5->__shared_owners_ = 0;
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    v5->__shared_weak_owners_ = 0;
    v5->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E0858;
    v5[1].__vftable = v30;
    std::__function::__value_func<void ()(BOOL,StewieHWSupportType)>::__value_func[abi:ne180100]((uint64_t)&v5[1].__shared_owners_, (uint64_t)v31);
    v27 = &v5[1].__vftable;
    v28 = v5;
    p_get_deleter = &a1[1].__get_deleter;
    v23 = QMIServiceMsg::create();
    v24 = 25000;
    v25 = 0;
    v26 = 0;
    v7 = MEMORY[0x24BDAC760];
    *(_QWORD *)buf = MEMORY[0x24BDAC760];
    v34 = 1174405120;
    v35 = ___ZN22QMIStewieCommandDriver4sendIN3sft15GetCapabilities7RequestEZNS_15getCapabilitiesEONSt3__18functionIFvb19StewieHWSupportTypeEEEE3__1EEvRKT_OT0__block_invoke;
    v36 = (uint8_t *)&__block_descriptor_tmp_43_10;
    v37 = &v5[1].__vftable;
    v38 = v5;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
    aBlock[0] = v7;
    aBlock[1] = 0x40000000;
    aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3sft15GetCapabilities8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
    aBlock[3] = &unk_24D5E08A0;
    aBlock[4] = buf;
    v9 = _Block_copy(aBlock);
    v26 = v9;
    if (v23)
    {
      qmi::Client::send();
      v9 = v26;
    }
    if (v9)
      _Block_release(v9);
    v10 = v38;
    if (v38)
    {
      v11 = (unint64_t *)&v38->__shared_owners_;
      do
        v12 = __ldaxr(v11);
      while (__stlxr(v12 - 1, v11));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
    v13 = v28;
    if (v28)
    {
      v14 = (unint64_t *)&v28->__shared_owners_;
      do
        v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }
    if (v32 == v31)
    {
      v16 = 4;
    }
    else
    {
      if (!v32)
      {
LABEL_23:
        qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v21);
        return;
      }
      v16 = 5;
      v4 = v32;
    }
    (*(void (**)(_QWORD *))(*v4 + 8 * v16))(v4);
    goto LABEL_23;
  }
  v17 = (uint64_t *)&a1->~__shared_weak_count_0;
  v18 = a1[1].~__shared_weak_count;
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl(&dword_216897000, v18, OS_LOG_TYPE_ERROR, "Failed to execute GetCapabilities. Client is not ready", buf, 2u);
  }
  std::__function::__value_func<void ()(BOOL,StewieHWSupportType)>::__value_func[abi:ne180100]((uint64_t)buf, a2);
  ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::getCapabilities(std::function<void ()(BOOL,StewieHWSupportType)> &&)::$_0>(v17, (uint64_t)buf);
  v19 = v36;
  if (v36 == buf)
  {
    v20 = 4;
    v19 = buf;
    goto LABEL_31;
  }
  if (v36)
  {
    v20 = 5;
LABEL_31:
    (*(void (**)(void))(*(_QWORD *)v19 + 8 * v20))();
  }
}

void sub_216A1ADD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,_QWORD *a30)
{
  _QWORD *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v34;

  v32 = v31;
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v32);
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)&a14);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a19);
  if (a30 == v30)
  {
    v34 = 4;
  }
  else
  {
    if (!a30)
      goto LABEL_6;
    v34 = 5;
    v30 = a30;
  }
  (*(void (**)(_QWORD *))(*v30 + 8 * v34))(v30);
LABEL_6:
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::getCapabilities(std::function<void ()(BOOL,StewieHWSupportType)> &&)::$_0>(uint64_t *a1, uint64_t a2)
{
  std::__shared_weak_count *v3;
  uint64_t v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  NSObject *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v3 = (std::__shared_weak_count *)a1[1];
  if (!v3 || (v5 = *a1, (v6 = std::__shared_weak_count::lock(v3)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v7 = v6;
  v8 = operator new();
  std::__function::__value_func<void ()(BOOL,StewieHWSupportType)>::__value_func[abi:ne180100](v8, a2);
  v9 = a1[2];
  p_shared_owners = (unint64_t *)&v7->__shared_owners_;
  do
    v11 = __ldxr(p_shared_owners);
  while (__stxr(v11 + 1, p_shared_owners));
  v12 = (_QWORD *)operator new();
  *v12 = v8;
  v12[1] = v5;
  v12[2] = v7;
  v14 = 0;
  v15 = 0;
  dispatch_async_f(v9, v12, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute_wrapped<QMIStewieCommandDriver::getCapabilities(std::function<void ()(BOOL,StewieHWSupportType)> &&)::$_0>(QMIStewieCommandDriver::getCapabilities(std::function<void ()(BOOL,StewieHWSupportType)> &&)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIStewieCommandDriver::getCapabilities(std::function<void ()(BOOL,StewieHWSupportType)> &&)::$_0,std::default_delete<QMIStewieCommandDriver::getCapabilities(std::function<void ()(BOOL,StewieHWSupportType)> &&)::$_0>>)::{lambda(void *)#1}::__invoke);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v14);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v15);
  do
    v13 = __ldaxr(p_shared_owners);
  while (__stlxr(v13 - 1, p_shared_owners));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
}

void QMIStewieCommandDriver::sendS4ConfigSegment(uint64_t a1, char *a2, unint64_t a3, unint64_t a4, unsigned int a5, unsigned int a6, uint64_t a7)
{
  uint64_t v13;
  const void **v14;
  const void **v15;
  char *v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  char *v24;
  const void **v25;
  char *v26;
  char *v27;
  char *v28;
  const void *v29;
  char **v30;
  uint64_t v31;
  char *v32;
  char *v33;
  uint64_t v34;
  char v35;
  char *v36;
  uint64_t v37;
  size_t v38;
  size_t v39;
  unint64_t v40;
  unint64_t v41;
  char *v42;
  uint64_t v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t v46;
  char *v47;
  char *v48;
  char *v49;
  char *v50;
  char *v51;
  char *v52;
  char *v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  const void **i;
  char *v61;
  _WORD *v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  _QWORD *v66;
  uint64_t v67;
  unint64_t v68;
  unint64_t v69;
  char *v70;
  uint64_t *v71;
  char *v72;
  char *v73;
  char *v74;
  uint64_t v75;
  _QWORD *v76;
  _QWORD *v77;
  unint64_t *v78;
  uint64_t v79;
  unint64_t v80;
  void *v81;
  std::__shared_weak_count *v82;
  unint64_t *v83;
  unint64_t v84;
  std::__shared_weak_count *v85;
  unint64_t *p_shared_owners;
  unint64_t v87;
  uint64_t v88;
  NSObject *v89;
  __int128 *p_dst;
  uint64_t v91;
  __int16 v92;
  uint64_t v93;
  void *__p[2];
  __int128 v95;
  uint64_t v96;
  uint64_t v97;
  int v98;
  uint64_t v99;
  void *v100;
  char *v101;
  std::__shared_weak_count *v102;
  _QWORD aBlock[5];
  uint64_t v104;
  _BYTE v105[24];
  _BYTE *v106;
  int v107;
  __int128 __dst;
  __int128 v109;
  __int128 v110;
  __int128 v111;
  __int128 v112;
  __int128 v113;
  __int128 v114;
  _OWORD v115[2];
  uint64_t v116;

  v13 = a1;
  v116 = *MEMORY[0x24BDAC8D0];
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  if (a5 >= a6)
  {
    __TUAssertTrigger();
    if (!a6)
      __TUAssertTrigger();
  }
  if (a3 >= a4)
    __TUAssertTrigger();
  if (0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((_QWORD *)a2 + 2) - *((_QWORD *)a2 + 1)) >> 3) < a4)
    __TUAssertTrigger();
  if (*(_BYTE *)(v13 + 112))
  {
    *(_OWORD *)__p = 0u;
    v95 = 0u;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
    v14 = (const void **)__p[1];
    v15 = (const void **)v95;
    if (__p[1] != (void *)v95)
    {
      while (*((_BYTE *)*v14 + 8) != 1)
      {
        if (++v14 == (const void **)v95)
          goto LABEL_16;
      }
    }
    if (v14 == (const void **)v95)
    {
LABEL_16:
      v18 = operator new();
      v19 = v18;
      *(_BYTE *)(v18 + 8) = 1;
      *(_QWORD *)v18 = &off_24D5E08E8;
      *(_BYTE *)(v18 + 16) = 0;
      v17 = (char *)(v18 + 16);
      *(_QWORD *)(v18 + 32) = 0;
      *(_QWORD *)(v18 + 40) = 0;
      *(_QWORD *)(v18 + 24) = 0;
      v20 = v95;
      if ((unint64_t)v95 >= *((_QWORD *)&v95 + 1))
      {
        v21 = (uint64_t)(v95 - (unint64_t)__p[1]) >> 3;
        if ((unint64_t)(v21 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v22 = (uint64_t)(*((_QWORD *)&v95 + 1) - (unint64_t)__p[1]) >> 2;
        if (v22 <= v21 + 1)
          v22 = v21 + 1;
        if (*((_QWORD *)&v95 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v23 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v23 = v22;
        if (v23)
          v24 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v95 + 8, v23);
        else
          v24 = 0;
        v25 = (const void **)&v24[8 * v21];
        v26 = &v24[8 * v23];
        *v25 = (const void *)v19;
        v15 = v25 + 1;
        v28 = (char *)__p[1];
        v27 = (char *)v95;
        if ((void *)v95 != __p[1])
        {
          do
          {
            v29 = (const void *)*((_QWORD *)v27 - 1);
            v27 -= 8;
            *--v25 = v29;
          }
          while (v27 != v28);
          v27 = (char *)__p[1];
        }
        __p[1] = v25;
        *(_QWORD *)&v95 = v15;
        *((_QWORD *)&v95 + 1) = v26;
        if (v27)
          operator delete(v27);
      }
      else
      {
        *(_QWORD *)v95 = v18;
        v15 = (const void **)(v20 + 8);
      }
      *(_QWORD *)&v95 = v15;
    }
    else
    {
      if (!v16)
        __cxa_bad_cast();
      v17 = v16 + 16;
    }
    *v17 = *a2;
    if (a3 < a4)
    {
      v92 = a6;
      v93 = v13;
      v30 = (char **)(v17 + 8);
      while (1)
      {
        v31 = *((_QWORD *)a2 + 1);
        v32 = (char *)(v31 + 56 * a3);
        v114 = 0u;
        memset(v115, 0, 26);
        v112 = 0u;
        v113 = 0u;
        v110 = 0u;
        v111 = 0u;
        __dst = 0u;
        v109 = 0u;
        v33 = v32 + 8;
        if (v32[31] < 0)
          v34 = *((_QWORD *)v32 + 2);
        else
          v34 = v32[31];
        v35 = *v32;
        if (v34 != 69)
          __TUAssertTrigger();
        v37 = v31 + 56 * a3;
        v36 = (char *)(v37 + 32);
        LODWORD(v37) = *(char *)(v37 + 55);
        if ((v37 & 0x80000000) != 0)
          v37 = *((_QWORD *)v36 + 1);
        else
          v37 = v37;
        if (v37 != 69)
          __TUAssertTrigger();
        if ((v33[23] & 0x80000000) == 0)
          break;
        v48 = v33;
        v33 = *(char **)v33;
        v38 = *((_QWORD *)v48 + 1);
        if (v38)
          goto LABEL_47;
LABEL_48:
        if (v36[23] < 0)
        {
          v49 = v36;
          v36 = *(char **)v36;
          v39 = *((_QWORD *)v49 + 1);
          if (!v39)
            goto LABEL_51;
LABEL_50:
          memcpy((char *)&v112 + 5, v36, v39);
          goto LABEL_51;
        }
        v39 = v36[23];
        if (v36[23])
          goto LABEL_50;
LABEL_51:
        v40 = *((_QWORD *)v17 + 2);
        v41 = *((_QWORD *)v17 + 3);
        if (v40 >= v41)
        {
          v43 = 0x3AEF6CA970586723 * (v40 - (_QWORD)*v30);
          v44 = v43 + 1;
          if ((unint64_t)(v43 + 1) > 0x1D77B654B82C339)
            std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
          v45 = 0x3AEF6CA970586723 * (v41 - (_QWORD)*v30);
          if (2 * v45 > v44)
            v44 = 2 * v45;
          if (v45 >= 0xEBBDB2A5C1619CLL)
            v46 = 0x1D77B654B82C339;
          else
            v46 = v44;
          if (v46)
            v47 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<sft::tlv::TargetLineSet>>((uint64_t)(v17 + 24), v46);
          else
            v47 = 0;
          v50 = &v47[139 * v43];
          *v50 = v35;
          *(_OWORD *)(v50 + 65) = v112;
          *(_OWORD *)(v50 + 49) = v111;
          *(_OWORD *)(v50 + 33) = v110;
          *(_OWORD *)(v50 + 17) = v109;
          *(_OWORD *)(v50 + 123) = *(_OWORD *)((char *)v115 + 10);
          *(_OWORD *)(v50 + 113) = v115[0];
          *(_OWORD *)(v50 + 97) = v114;
          *(_OWORD *)(v50 + 81) = v113;
          *(_OWORD *)(v50 + 1) = __dst;
          v52 = (char *)*((_QWORD *)v17 + 1);
          v51 = (char *)*((_QWORD *)v17 + 2);
          v53 = v50;
          if (v51 != v52)
          {
            do
            {
              *(_OWORD *)(v53 - 139) = *(_OWORD *)(v51 - 139);
              v54 = *(_OWORD *)(v51 - 123);
              v55 = *(_OWORD *)(v51 - 107);
              v56 = *(_OWORD *)(v51 - 91);
              *(_OWORD *)(v53 - 75) = *(_OWORD *)(v51 - 75);
              *(_OWORD *)(v53 - 91) = v56;
              *(_OWORD *)(v53 - 107) = v55;
              *(_OWORD *)(v53 - 123) = v54;
              v57 = *(_OWORD *)(v51 - 59);
              v58 = *(_OWORD *)(v51 - 43);
              v59 = *(_OWORD *)(v51 - 27);
              *((_OWORD *)v53 - 1) = *((_OWORD *)v51 - 1);
              *(_OWORD *)(v53 - 27) = v59;
              *(_OWORD *)(v53 - 43) = v58;
              *(_OWORD *)(v53 - 59) = v57;
              v53 -= 139;
              v51 -= 139;
            }
            while (v51 != v52);
            v51 = *v30;
          }
          v42 = v50 + 139;
          *((_QWORD *)v17 + 1) = v53;
          *((_QWORD *)v17 + 2) = v50 + 139;
          *((_QWORD *)v17 + 3) = &v47[139 * v46];
          if (v51)
            operator delete(v51);
        }
        else
        {
          *(_BYTE *)v40 = v35;
          *(_OWORD *)(v40 + 81) = v113;
          *(_OWORD *)(v40 + 97) = v114;
          *(_OWORD *)(v40 + 113) = v115[0];
          *(_OWORD *)(v40 + 123) = *(_OWORD *)((char *)v115 + 10);
          *(_OWORD *)(v40 + 17) = v109;
          *(_OWORD *)(v40 + 33) = v110;
          *(_OWORD *)(v40 + 49) = v111;
          *(_OWORD *)(v40 + 65) = v112;
          *(_OWORD *)(v40 + 1) = __dst;
          v42 = (char *)(v40 + 139);
        }
        *((_QWORD *)v17 + 2) = v42;
        if (++a3 == a4)
        {
          v15 = (const void **)v95;
          v13 = v93;
          LOWORD(a6) = v92;
          goto LABEL_73;
        }
      }
      v38 = v33[23];
      if (!v33[23])
        goto LABEL_48;
LABEL_47:
      memcpy(&__dst, v33, v38);
      goto LABEL_48;
    }
LABEL_73:
    for (i = (const void **)__p[1]; i != v15; ++i)
    {
      if (*((_BYTE *)*i + 8) == 17)
      {
        if (i != v15)
        {
          if (!v61)
            __cxa_bad_cast();
          v62 = v61 + 10;
          goto LABEL_97;
        }
        break;
      }
    }
    v63 = operator new();
    v64 = v63;
    *(_BYTE *)(v63 + 8) = 17;
    *(_QWORD *)v63 = &off_24D5E0938;
    *(_DWORD *)(v63 + 10) = 0;
    v62 = (_WORD *)(v63 + 10);
    v65 = v95;
    if ((unint64_t)v95 >= *((_QWORD *)&v95 + 1))
    {
      v67 = (uint64_t)(v95 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v67 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v68 = (uint64_t)(*((_QWORD *)&v95 + 1) - (unint64_t)__p[1]) >> 2;
      if (v68 <= v67 + 1)
        v68 = v67 + 1;
      if (*((_QWORD *)&v95 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v69 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v69 = v68;
      if (v69)
        v70 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v95 + 8, v69);
      else
        v70 = 0;
      v71 = (uint64_t *)&v70[8 * v67];
      v72 = &v70[8 * v69];
      *v71 = v64;
      v66 = v71 + 1;
      v74 = (char *)__p[1];
      v73 = (char *)v95;
      if ((void *)v95 != __p[1])
      {
        do
        {
          v75 = *((_QWORD *)v73 - 1);
          v73 -= 8;
          *--v71 = v75;
        }
        while (v73 != v74);
        v73 = (char *)__p[1];
      }
      __p[1] = v71;
      *(_QWORD *)&v95 = v66;
      *((_QWORD *)&v95 + 1) = v72;
      if (v73)
        operator delete(v73);
    }
    else
    {
      *(_QWORD *)v95 = v63;
      v66 = (_QWORD *)(v65 + 8);
    }
    *(_QWORD *)&v95 = v66;
LABEL_97:
    *v62 = a5;
    v62[1] = a6;
    v104 = v13;
    v76 = v105;
    std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)v105, a7);
    LOWORD(v107) = a5;
    HIWORD(v107) = a6;
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(v13 + 24));
    v77 = operator new(0x48uLL);
    v77[1] = 0;
    v78 = v77 + 1;
    v77[2] = 0;
    *v77 = &off_24D5E09A0;
    v77[3] = v104;
    std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)(v77 + 4), (uint64_t)v105);
    *((_DWORD *)v77 + 16) = v107;
    v101 = (char *)(v77 + 3);
    v102 = (std::__shared_weak_count *)v77;
    v96 = v13 + 64;
    v97 = QMIServiceMsg::create();
    v98 = 25000;
    v99 = 0;
    v100 = 0;
    v79 = MEMORY[0x24BDAC760];
    *(_QWORD *)&__dst = MEMORY[0x24BDAC760];
    *((_QWORD *)&__dst + 1) = 1174405120;
    *(_QWORD *)&v109 = ___ZN22QMIStewieCommandDriver4sendIN3sft11SetS4Config7RequestEZNS_19sendS4ConfigSegmentERK20StewieTargetLineSetsmmttONSt3__18functionIFvbEEEE3__3EEvRKT_OT0__block_invoke;
    *((_QWORD *)&v109 + 1) = &__block_descriptor_tmp_48_8;
    *(_QWORD *)&v110 = v77 + 3;
    *((_QWORD *)&v110 + 1) = v77;
    do
      v80 = __ldxr(v78);
    while (__stxr(v80 + 1, v78));
    aBlock[0] = v79;
    aBlock[1] = 0x40000000;
    aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_24;
    aBlock[3] = &unk_24D5E09E8;
    aBlock[4] = &__dst;
    v81 = _Block_copy(aBlock);
    v100 = v81;
    if (v97)
    {
      qmi::Client::send();
      v81 = v100;
    }
    if (v81)
      _Block_release(v81);
    v82 = (std::__shared_weak_count *)*((_QWORD *)&v110 + 1);
    if (*((_QWORD *)&v110 + 1))
    {
      v83 = (unint64_t *)(*((_QWORD *)&v110 + 1) + 8);
      do
        v84 = __ldaxr(v83);
      while (__stlxr(v84 - 1, v83));
      if (!v84)
      {
        ((void (*)(std::__shared_weak_count *))v82->__on_zero_shared)(v82);
        std::__shared_weak_count::__release_weak(v82);
      }
    }
    v85 = v102;
    if (v102)
    {
      p_shared_owners = (unint64_t *)&v102->__shared_owners_;
      do
        v87 = __ldaxr(p_shared_owners);
      while (__stlxr(v87 - 1, p_shared_owners));
      if (!v87)
      {
        ((void (*)(std::__shared_weak_count *))v85->__on_zero_shared)(v85);
        std::__shared_weak_count::__release_weak(v85);
      }
    }
    if (v106 == v105)
    {
      v88 = 4;
    }
    else
    {
      if (!v106)
      {
LABEL_118:
        qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
        return;
      }
      v88 = 5;
      v76 = v106;
    }
    (*(void (**)(_QWORD *))(*v76 + 8 * v88))(v76);
    goto LABEL_118;
  }
  v89 = *(NSObject **)(v13 + 40);
  if (os_log_type_enabled(v89, OS_LOG_TYPE_ERROR))
  {
    LOWORD(__dst) = 0;
    _os_log_error_impl(&dword_216897000, v89, OS_LOG_TYPE_ERROR, "Failed to execute SetS4Config. Client is not ready", (uint8_t *)&__dst, 2u);
  }
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)&__dst, a7);
  ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::sendS4ConfigSegment(StewieTargetLineSets const&,unsigned long,unsigned long,unsigned short,unsigned short,std::function<void ()(BOOL)> &&)::$_0>((uint64_t *)(v13 + 8), (uint64_t)&__dst);
  p_dst = (__int128 *)*((_QWORD *)&v109 + 1);
  if (*((__int128 **)&v109 + 1) == &__dst)
  {
    v91 = 4;
    p_dst = &__dst;
    goto LABEL_126;
  }
  if (*((_QWORD *)&v109 + 1))
  {
    v91 = 5;
LABEL_126:
    (*(void (**)(void))(*(_QWORD *)p_dst + 8 * v91))();
  }
}

void sub_216A1B880(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,_QWORD *a35)
{
  _QWORD *v35;
  uint64_t v36;
  uint64_t v38;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v36);
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)&a19);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a24);
  if (a35 == v35)
  {
    v38 = 4;
  }
  else
  {
    if (!a35)
      goto LABEL_6;
    v38 = 5;
    v35 = a35;
  }
  (*(void (**)(_QWORD *))(*v35 + 8 * v38))(v35);
LABEL_6:
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a15);
  _Unwind_Resume(a1);
}

void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::sendS4ConfigSegment(StewieTargetLineSets const&,unsigned long,unsigned long,unsigned short,unsigned short,std::function<void ()(BOOL)> &&)::$_0>(uint64_t *a1, uint64_t a2)
{
  std::__shared_weak_count *v3;
  uint64_t v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  NSObject *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v3 = (std::__shared_weak_count *)a1[1];
  if (!v3 || (v5 = *a1, (v6 = std::__shared_weak_count::lock(v3)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v7 = v6;
  v8 = operator new();
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100](v8, a2);
  v9 = a1[2];
  p_shared_owners = (unint64_t *)&v7->__shared_owners_;
  do
    v11 = __ldxr(p_shared_owners);
  while (__stxr(v11 + 1, p_shared_owners));
  v12 = (_QWORD *)operator new();
  *v12 = v8;
  v12[1] = v5;
  v12[2] = v7;
  v14 = 0;
  v15 = 0;
  dispatch_async_f(v9, v12, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute_wrapped<QMIStewieCommandDriver::sendS4ConfigSegment(StewieTargetLineSets const&,unsigned long,unsigned long,unsigned short,unsigned short,std::function<void ()(BOOL)> &&)::$_0>(QMIStewieCommandDriver::sendS4ConfigSegment(StewieTargetLineSets const&,unsigned long,unsigned long,unsigned short,unsigned short,std::function<void ()(BOOL)> &&)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIStewieCommandDriver::sendS4ConfigSegment(StewieTargetLineSets const&,unsigned long,unsigned long,unsigned short,unsigned short,std::function<void ()(BOOL)> &&)::$_0,std::default_delete<QMIStewieCommandDriver::sendS4ConfigSegment(StewieTargetLineSets const&,unsigned long,unsigned long,unsigned short,unsigned short,std::function<void ()(BOOL)> &&)::$_0>>)::{lambda(void *)#1}::__invoke);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v14);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v15);
  do
    v13 = __ldaxr(p_shared_owners);
  while (__stlxr(v13 - 1, p_shared_owners));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
}

void QMIStewieCommandDriver::activate(std::__shared_weak_count_vtbl *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t *a8, char a9, uint64_t a10)
{
  const void **v17;
  const void **v18;
  const void **v19;
  char *v20;
  BOOL *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t v27;
  char *v28;
  const void **v29;
  char *v30;
  char *v31;
  char *v32;
  const void *v33;
  char *v34;
  _BYTE *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  unint64_t v41;
  char *v42;
  const void **v43;
  char *v44;
  char *v45;
  char *v46;
  const void *v47;
  const void **i;
  char *v49;
  _BYTE *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  _QWORD *v54;
  uint64_t v55;
  unint64_t v56;
  unint64_t v57;
  char *v58;
  uint64_t *v59;
  char *v60;
  char *v61;
  char *v62;
  uint64_t v63;
  char *v64;
  char *v65;
  uint64_t v66;
  _BYTE *v67;
  _BYTE *v68;
  char *v69;
  char *v70;
  char *v71;
  const void **v72;
  const void **v73;
  const void **v74;
  char *v75;
  _BYTE *v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  unint64_t v81;
  unint64_t v82;
  char *v83;
  const void **v84;
  char *v85;
  char *v86;
  char *v87;
  const void *v88;
  char *v89;
  _BYTE *v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  _QWORD *v94;
  uint64_t v95;
  unint64_t v96;
  unint64_t v97;
  char *v98;
  uint64_t *v99;
  char *v100;
  char *v101;
  char *v102;
  uint64_t v103;
  char *v104;
  _QWORD *v105;
  std::__shared_weak_count *v106;
  unint64_t *p_shared_owners;
  uint64_t v108;
  unint64_t v109;
  void *v110;
  std::__shared_weak_count *v111;
  unint64_t *v112;
  unint64_t v113;
  std::__shared_weak_count *v114;
  unint64_t *v115;
  unint64_t v116;
  uint64_t v117;
  uint64_t *v118;
  NSObject *v119;
  uint8_t *v120;
  uint64_t v121;
  void *__p[2];
  __int128 v123;
  const void *(__cdecl **p_get_deleter)(const std::__shared_weak_count *__hidden, const std::type_info *);
  uint64_t v125;
  int v126;
  uint64_t v127;
  void *v128;
  _QWORD *v129;
  std::__shared_weak_count *v130;
  _QWORD aBlock[5];
  std::__shared_weak_count_vtbl *v132;
  _BYTE v133[24];
  _BYTE *v134;
  uint8_t buf[8];
  uint64_t v136;
  uint64_t (*v137)(uint64_t, qmi::MessageBase *);
  uint8_t *v138;
  _QWORD *v139;
  std::__shared_weak_count *v140;
  uint64_t v141;

  v141 = *MEMORY[0x24BDAC8D0];
  dispatch_assert_queue_V2((dispatch_queue_t)a1->__get_deleter);
  if (LOBYTE(a1[2].__on_zero_shared_weak))
  {
    *(_OWORD *)__p = 0u;
    v123 = 0u;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
    v18 = (const void **)__p[1];
    v17 = (const void **)v123;
    v19 = (const void **)__p[1];
    if (__p[1] != (void *)v123)
    {
      v19 = (const void **)__p[1];
      while (*((_BYTE *)*v19 + 8) != 1)
      {
        if (++v19 == (const void **)v123)
          goto LABEL_10;
      }
    }
    if (v19 == (const void **)v123)
    {
LABEL_10:
      v22 = operator new();
      v23 = v22;
      *(_WORD *)(v22 + 8) = 1;
      *(_QWORD *)v22 = &off_24D5E0A30;
      v24 = v123;
      if ((unint64_t)v123 >= *((_QWORD *)&v123 + 1))
      {
        v25 = (uint64_t)(v123 - (unint64_t)__p[1]) >> 3;
        if ((unint64_t)(v25 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v26 = (uint64_t)(*((_QWORD *)&v123 + 1) - (unint64_t)__p[1]) >> 2;
        if (v26 <= v25 + 1)
          v26 = v25 + 1;
        if (*((_QWORD *)&v123 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v27 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v27 = v26;
        if (v27)
          v28 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v123 + 8, v27);
        else
          v28 = 0;
        v29 = (const void **)&v28[8 * v25];
        v30 = &v28[8 * v27];
        *v29 = (const void *)v23;
        v17 = v29 + 1;
        v32 = (char *)__p[1];
        v31 = (char *)v123;
        if ((void *)v123 != __p[1])
        {
          do
          {
            v33 = (const void *)*((_QWORD *)v31 - 1);
            v31 -= 8;
            *--v29 = v33;
          }
          while (v31 != v32);
          v31 = (char *)__p[1];
        }
        __p[1] = v29;
        *(_QWORD *)&v123 = v17;
        *((_QWORD *)&v123 + 1) = v30;
        if (v31)
          operator delete(v31);
      }
      else
      {
        *(_QWORD *)v123 = v22;
        v17 = (const void **)(v24 + 8);
      }
      v21 = (BOOL *)(v23 + 9);
      *(_QWORD *)&v123 = v17;
      v18 = (const void **)__p[1];
    }
    else
    {
      if (!v20)
        __cxa_bad_cast();
      v21 = (BOOL *)(v20 + 9);
    }
    *v21 = (a2 - 5) < 0xFFFFFFFE;
    while (v18 != v17)
    {
      if (*((_BYTE *)*v18 + 8) == 2)
      {
        if (v18 != v17)
        {
          if (!v34)
            __cxa_bad_cast();
          v35 = v34 + 9;
          goto LABEL_51;
        }
        break;
      }
      ++v18;
    }
    v36 = operator new();
    v37 = v36;
    *(_WORD *)(v36 + 8) = 2;
    *(_QWORD *)v36 = &off_24D5E0A80;
    v38 = v123;
    if ((unint64_t)v123 >= *((_QWORD *)&v123 + 1))
    {
      v39 = (uint64_t)(v123 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v39 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v40 = (uint64_t)(*((_QWORD *)&v123 + 1) - (unint64_t)__p[1]) >> 2;
      if (v40 <= v39 + 1)
        v40 = v39 + 1;
      if (*((_QWORD *)&v123 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v41 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v41 = v40;
      if (v41)
        v42 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v123 + 8, v41);
      else
        v42 = 0;
      v43 = (const void **)&v42[8 * v39];
      v44 = &v42[8 * v41];
      *v43 = (const void *)v37;
      v17 = v43 + 1;
      v46 = (char *)__p[1];
      v45 = (char *)v123;
      if ((void *)v123 != __p[1])
      {
        do
        {
          v47 = (const void *)*((_QWORD *)v45 - 1);
          v45 -= 8;
          *--v43 = v47;
        }
        while (v45 != v46);
        v45 = (char *)__p[1];
      }
      __p[1] = v43;
      *(_QWORD *)&v123 = v17;
      *((_QWORD *)&v123 + 1) = v44;
      if (v45)
        operator delete(v45);
    }
    else
    {
      *(_QWORD *)v123 = v36;
      v17 = (const void **)(v38 + 8);
    }
    v35 = (_BYTE *)(v37 + 9);
    *(_QWORD *)&v123 = v17;
LABEL_51:
    *v35 = 2 * (a2 == 5);
    for (i = (const void **)__p[1]; i != v17; ++i)
    {
      if (*((_BYTE *)*i + 8) == 3)
      {
        if (i != v17)
        {
          if (!v49)
            __cxa_bad_cast();
          v50 = v49 + 9;
          goto LABEL_75;
        }
        break;
      }
    }
    v51 = operator new();
    v52 = v51;
    *(_WORD *)(v51 + 8) = 3;
    *(_QWORD *)v51 = &off_24D5E0AD0;
    v53 = v123;
    if ((unint64_t)v123 >= *((_QWORD *)&v123 + 1))
    {
      v55 = (uint64_t)(v123 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v55 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v56 = (uint64_t)(*((_QWORD *)&v123 + 1) - (unint64_t)__p[1]) >> 2;
      if (v56 <= v55 + 1)
        v56 = v55 + 1;
      if (*((_QWORD *)&v123 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v57 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v57 = v56;
      if (v57)
        v58 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v123 + 8, v57);
      else
        v58 = 0;
      v59 = (uint64_t *)&v58[8 * v55];
      v60 = &v58[8 * v57];
      *v59 = v52;
      v54 = v59 + 1;
      v62 = (char *)__p[1];
      v61 = (char *)v123;
      if ((void *)v123 != __p[1])
      {
        do
        {
          v63 = *((_QWORD *)v61 - 1);
          v61 -= 8;
          *--v59 = v63;
        }
        while (v61 != v62);
        v61 = (char *)__p[1];
      }
      __p[1] = v59;
      *(_QWORD *)&v123 = v54;
      *((_QWORD *)&v123 + 1) = v60;
      if (v61)
        operator delete(v61);
    }
    else
    {
      *(_QWORD *)v123 = v51;
      v54 = (_QWORD *)(v53 + 8);
    }
    v50 = (_BYTE *)(v52 + 9);
    *(_QWORD *)&v123 = v54;
LABEL_75:
    *v50 = 0;
    if (*(_QWORD *)(a7 + 8) - *(_QWORD *)a7 != 8)
      __TUAssertTrigger();
    if (*(_QWORD *)(a7 + 32) - *(_QWORD *)(a7 + 24) != 32)
      __TUAssertTrigger();
    v64 = qmi::MutableMessageBase::getTLV<sft::tlv::SecurityCredentials>(__p, 4);
    v65 = v64;
    v66 = *(_QWORD *)(a7 + 8);
    if (v66 != *(_QWORD *)a7)
      memmove(v64, *(const void **)a7, v66 - *(_QWORD *)a7);
    v67 = *(_BYTE **)(a7 + 24);
    v68 = *(_BYTE **)(a7 + 32);
    if (v68 != v67)
      memmove(v65 + 8, v67, v68 - v67);
    v69 = qmi::MutableMessageBase::getTLV<sft::tlv::EARFCN>(__p, 5);
    v70 = v69;
    if (v69 != (char *)a4)
      std::vector<wds::tlv::DestPortRangeInfo>::__assign_with_size[abi:ne180100]<wds::tlv::DestPortRangeInfo*,wds::tlv::DestPortRangeInfo*>(v69, *(char **)a4, *(_QWORD *)(a4 + 8), (uint64_t)(*(_QWORD *)(a4 + 8) - *(_QWORD *)a4) >> 2);
    if (v70 != (char *)a4)
      std::vector<wds::tlv::DestPortRangeInfo>::__assign_with_size[abi:ne180100]<wds::tlv::DestPortRangeInfo*,wds::tlv::DestPortRangeInfo*>(v70 + 24, *(char **)(a4 + 24), *(_QWORD *)(a4 + 32), (uint64_t)(*(_QWORD *)(a4 + 32) - *(_QWORD *)(a4 + 24)) >> 2);
    v71 = qmi::MutableMessageBase::getTLV<sft::tlv::LocationData>(__p, 6);
    v73 = (const void **)__p[1];
    v72 = (const void **)v123;
    v74 = (const void **)__p[1];
    if (__p[1] != (void *)v123)
    {
      v74 = (const void **)__p[1];
      while (*((_BYTE *)*v74 + 8) != 7)
      {
        if (++v74 == (const void **)v123)
          goto LABEL_95;
      }
    }
    if (v74 == (const void **)v123)
    {
LABEL_95:
      v77 = operator new();
      v78 = v77;
      *(_WORD *)(v77 + 8) = 7;
      *(_QWORD *)v77 = &off_24D5E0C10;
      v79 = v123;
      if ((unint64_t)v123 >= *((_QWORD *)&v123 + 1))
      {
        v80 = (uint64_t)(v123 - (unint64_t)__p[1]) >> 3;
        if ((unint64_t)(v80 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v81 = (uint64_t)(*((_QWORD *)&v123 + 1) - (unint64_t)__p[1]) >> 2;
        if (v81 <= v80 + 1)
          v81 = v80 + 1;
        if (*((_QWORD *)&v123 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v82 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v82 = v81;
        if (v82)
          v83 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v123 + 8, v82);
        else
          v83 = 0;
        v84 = (const void **)&v83[8 * v80];
        v85 = &v83[8 * v82];
        *v84 = (const void *)v78;
        v72 = v84 + 1;
        v87 = (char *)__p[1];
        v86 = (char *)v123;
        if ((void *)v123 != __p[1])
        {
          do
          {
            v88 = (const void *)*((_QWORD *)v86 - 1);
            v86 -= 8;
            *--v84 = v88;
          }
          while (v86 != v87);
          v86 = (char *)__p[1];
        }
        __p[1] = v84;
        *(_QWORD *)&v123 = v72;
        *((_QWORD *)&v123 + 1) = v85;
        if (v86)
          operator delete(v86);
      }
      else
      {
        *(_QWORD *)v123 = v77;
        v72 = (const void **)(v79 + 8);
      }
      v76 = (_BYTE *)(v78 + 9);
      *(_QWORD *)&v123 = v72;
      v73 = (const void **)__p[1];
    }
    else
    {
      if (!v75)
        __cxa_bad_cast();
      v76 = v75 + 9;
    }
    *v76 = 1;
    while (v73 != v72)
    {
      if (*((_BYTE *)*v73 + 8) == 17)
      {
        if (v73 != v72)
        {
          if (!v89)
            __cxa_bad_cast();
          v90 = v89 + 9;
          goto LABEL_136;
        }
        break;
      }
      ++v73;
    }
    v91 = operator new();
    v92 = v91;
    *(_WORD *)(v91 + 8) = 17;
    *(_QWORD *)v91 = &off_24D5E0C60;
    v93 = v123;
    if ((unint64_t)v123 >= *((_QWORD *)&v123 + 1))
    {
      v95 = (uint64_t)(v123 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v95 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v96 = (uint64_t)(*((_QWORD *)&v123 + 1) - (unint64_t)__p[1]) >> 2;
      if (v96 <= v95 + 1)
        v96 = v95 + 1;
      if (*((_QWORD *)&v123 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v97 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v97 = v96;
      if (v97)
        v98 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v123 + 8, v97);
      else
        v98 = 0;
      v99 = (uint64_t *)&v98[8 * v95];
      v100 = &v98[8 * v97];
      *v99 = v92;
      v94 = v99 + 1;
      v102 = (char *)__p[1];
      v101 = (char *)v123;
      if ((void *)v123 != __p[1])
      {
        do
        {
          v103 = *((_QWORD *)v101 - 1);
          v101 -= 8;
          *--v99 = v103;
        }
        while (v101 != v102);
        v101 = (char *)__p[1];
      }
      __p[1] = v99;
      *(_QWORD *)&v123 = v94;
      *((_QWORD *)&v123 + 1) = v100;
      if (v101)
        operator delete(v101);
    }
    else
    {
      *(_QWORD *)v123 = v91;
      v94 = (_QWORD *)(v93 + 8);
    }
    v90 = (_BYTE *)(v92 + 9);
    *(_QWORD *)&v123 = v94;
LABEL_136:
    *v90 = a9;
    if (*a8)
    {
      v104 = qmi::MutableMessageBase::getTLV<sft::tlv::HeatMapData>(__p, 16);
    }
    v132 = a1;
    v105 = v133;
    std::__function::__value_func<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)>::__value_func[abi:ne180100]((uint64_t)v133, a10);
    dispatch_assert_queue_V2((dispatch_queue_t)a1->__get_deleter);
    v106 = (std::__shared_weak_count *)operator new(0x40uLL);
    v106->__shared_owners_ = 0;
    p_shared_owners = (unint64_t *)&v106->__shared_owners_;
    v106->__shared_weak_owners_ = 0;
    v106->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E0D18;
    v106[1].__vftable = v132;
    std::__function::__value_func<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)>::__value_func[abi:ne180100]((uint64_t)&v106[1].__shared_owners_, (uint64_t)v133);
    v129 = &v106[1].__vftable;
    v130 = v106;
    p_get_deleter = &a1[1].__get_deleter;
    v125 = QMIServiceMsg::create();
    v126 = 25000;
    v127 = 0;
    v128 = 0;
    v108 = MEMORY[0x24BDAC760];
    *(_QWORD *)buf = MEMORY[0x24BDAC760];
    v136 = 1174405120;
    v137 = ___ZN22QMIStewieCommandDriver4sendIN3sft10Activation7RequestEZNS_8activateE19StewieRequestReason24StewieSPSEnvironmentTypeRK22StewieProvisioningDataRK18StewieTimeFreqDataRK18StewieLocationDataRK25StewieSecurityCredentialsRKNSt3__110shared_ptrIK13StewieHeatMapEEbONSI_8functionIFvbONSI_8optionalINSI_6chrono8durationIxNSI_5ratioILl1ELl1000EEEEEEEEEEE4__10EEvRKT_OT0__block_invoke;
    v138 = (uint8_t *)&__block_descriptor_tmp_50_3;
    v139 = &v106[1].__vftable;
    v140 = v106;
    do
      v109 = __ldxr(p_shared_owners);
    while (__stxr(v109 + 1, p_shared_owners));
    aBlock[0] = v108;
    aBlock[1] = 0x40000000;
    aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3sft10Activation8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
    aBlock[3] = &unk_24D5E0D60;
    aBlock[4] = buf;
    v110 = _Block_copy(aBlock);
    v128 = v110;
    if (v125)
    {
      qmi::Client::send();
      v110 = v128;
    }
    if (v110)
      _Block_release(v110);
    v111 = v140;
    if (v140)
    {
      v112 = (unint64_t *)&v140->__shared_owners_;
      do
        v113 = __ldaxr(v112);
      while (__stlxr(v113 - 1, v112));
      if (!v113)
      {
        ((void (*)(std::__shared_weak_count *))v111->__on_zero_shared)(v111);
        std::__shared_weak_count::__release_weak(v111);
      }
    }
    v114 = v130;
    if (v130)
    {
      v115 = (unint64_t *)&v130->__shared_owners_;
      do
        v116 = __ldaxr(v115);
      while (__stlxr(v116 - 1, v115));
      if (!v116)
      {
        ((void (*)(std::__shared_weak_count *))v114->__on_zero_shared)(v114);
        std::__shared_weak_count::__release_weak(v114);
      }
    }
    if (v134 == v133)
    {
      v117 = 4;
    }
    else
    {
      if (!v134)
      {
LABEL_159:
        qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
        return;
      }
      v117 = 5;
      v105 = v134;
    }
    (*(void (**)(_QWORD *))(*v105 + 8 * v117))(v105);
    goto LABEL_159;
  }
  v118 = (uint64_t *)&a1->~__shared_weak_count_0;
  v119 = a1[1].~__shared_weak_count;
  if (os_log_type_enabled(v119, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl(&dword_216897000, v119, OS_LOG_TYPE_ERROR, "Failed to execute Activation request. Client is not ready", buf, 2u);
  }
  std::__function::__value_func<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)>::__value_func[abi:ne180100]((uint64_t)buf, a10);
  ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::activate(StewieRequestReason,StewieSPSEnvironmentType,StewieProvisioningData const&,StewieTimeFreqData const&,StewieLocationData const&,StewieSecurityCredentials const&,std::shared_ptr<StewieHeatMap const> const&,BOOL,std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &&)::$_0>(v118, (uint64_t)buf);
  v120 = v138;
  if (v138 == buf)
  {
    v121 = 4;
    v120 = buf;
    goto LABEL_167;
  }
  if (v138)
  {
    v121 = 5;
LABEL_167:
    (*(void (**)(void))(*(_QWORD *)v120 + 8 * v121))();
  }
}

void sub_216A1C4CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,_QWORD *a32)
{
  _QWORD *v32;
  uint64_t v33;
  uint64_t v35;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v33);
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)&a16);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a21);
  if (a32 == v32)
  {
    v35 = 4;
  }
  else
  {
    if (!a32)
      goto LABEL_6;
    v35 = 5;
    v32 = a32;
  }
  (*(void (**)(_QWORD *))(*v32 + 8 * v35))(v32);
LABEL_6:
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a11);
  _Unwind_Resume(a1);
}

void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::activate(StewieRequestReason,StewieSPSEnvironmentType,StewieProvisioningData const&,StewieTimeFreqData const&,StewieLocationData const&,StewieSecurityCredentials const&,std::shared_ptr<StewieHeatMap const> const&,BOOL,std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &&)::$_0>(uint64_t *a1, uint64_t a2)
{
  std::__shared_weak_count *v3;
  uint64_t v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  NSObject *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v3 = (std::__shared_weak_count *)a1[1];
  if (!v3 || (v5 = *a1, (v6 = std::__shared_weak_count::lock(v3)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v7 = v6;
  v8 = operator new();
  std::__function::__value_func<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)>::__value_func[abi:ne180100](v8, a2);
  v9 = a1[2];
  p_shared_owners = (unint64_t *)&v7->__shared_owners_;
  do
    v11 = __ldxr(p_shared_owners);
  while (__stxr(v11 + 1, p_shared_owners));
  v12 = (_QWORD *)operator new();
  *v12 = v8;
  v12[1] = v5;
  v12[2] = v7;
  v14 = 0;
  v15 = 0;
  dispatch_async_f(v9, v12, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute_wrapped<QMIStewieCommandDriver::activate(StewieRequestReason,StewieSPSEnvironmentType,StewieProvisioningData const&,StewieTimeFreqData const&,StewieLocationData const&,StewieSecurityCredentials const&,std::shared_ptr<StewieHeatMap const> const&,BOOL,std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &&)::$_0>(QMIStewieCommandDriver::activate(StewieRequestReason,StewieSPSEnvironmentType,StewieProvisioningData const&,StewieTimeFreqData const&,StewieLocationData const&,StewieSecurityCredentials const&,std::shared_ptr<StewieHeatMap const> const&,BOOL,std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &&)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &&,std::default_delete<std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &&>>)::{lambda(void *)#1}::__invoke);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v14);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v15);
  do
    v13 = __ldaxr(p_shared_owners);
  while (__stlxr(v13 - 1, p_shared_owners));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
}

void QMIStewieCommandDriver::deactivate(std::__shared_weak_count_vtbl *a1, unsigned int a2, uint64_t a3)
{
  const void **v6;
  char *v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  char *v16;
  uint64_t *v17;
  char *v18;
  char *v19;
  char *v20;
  uint64_t v21;
  char v22;
  _QWORD *v23;
  std::__shared_weak_count *v24;
  unint64_t *p_shared_owners;
  uint64_t v26;
  unint64_t v27;
  void *v28;
  std::__shared_weak_count *v29;
  unint64_t *v30;
  unint64_t v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t *v36;
  NSObject *v37;
  uint8_t *v38;
  uint64_t v39;
  void *__p[2];
  __int128 v41;
  const void *(__cdecl **p_get_deleter)(const std::__shared_weak_count *__hidden, const std::type_info *);
  uint64_t v43;
  int v44;
  uint64_t v45;
  void *v46;
  _QWORD *v47;
  std::__shared_weak_count *v48;
  _QWORD aBlock[5];
  std::__shared_weak_count_vtbl *v50;
  _BYTE v51[24];
  _BYTE *v52;
  uint8_t buf[8];
  uint64_t v54;
  uint64_t (*v55)(uint64_t, uint64_t);
  uint8_t *v56;
  _QWORD *v57;
  std::__shared_weak_count *v58;
  uint64_t v59;

  v59 = *MEMORY[0x24BDAC8D0];
  dispatch_assert_queue_V2((dispatch_queue_t)a1->__get_deleter);
  if (LOBYTE(a1[2].__on_zero_shared_weak))
  {
    *(_OWORD *)__p = 0u;
    v41 = 0u;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
    v6 = (const void **)__p[1];
    if (__p[1] != (void *)v41)
    {
      while (*((_BYTE *)*v6 + 8) != 1)
      {
        if (++v6 == (const void **)v41)
          goto LABEL_9;
      }
    }
    if (v6 == (const void **)v41)
    {
LABEL_9:
      v9 = operator new();
      v10 = v9;
      *(_WORD *)(v9 + 8) = 1;
      *(_QWORD *)v9 = &off_24D5E0DA8;
      v11 = v41;
      if ((unint64_t)v41 >= *((_QWORD *)&v41 + 1))
      {
        v13 = (uint64_t)(v41 - (unint64_t)__p[1]) >> 3;
        if ((unint64_t)(v13 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v14 = (uint64_t)(*((_QWORD *)&v41 + 1) - (unint64_t)__p[1]) >> 2;
        if (v14 <= v13 + 1)
          v14 = v13 + 1;
        if (*((_QWORD *)&v41 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v15 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v15 = v14;
        if (v15)
          v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v41 + 8, v15);
        else
          v16 = 0;
        v17 = (uint64_t *)&v16[8 * v13];
        v18 = &v16[8 * v15];
        *v17 = v10;
        v12 = v17 + 1;
        v20 = (char *)__p[1];
        v19 = (char *)v41;
        if ((void *)v41 != __p[1])
        {
          do
          {
            v21 = *((_QWORD *)v19 - 1);
            v19 -= 8;
            *--v17 = v21;
          }
          while (v19 != v20);
          v19 = (char *)__p[1];
        }
        __p[1] = v17;
        *(_QWORD *)&v41 = v12;
        *((_QWORD *)&v41 + 1) = v18;
        if (v19)
          operator delete(v19);
      }
      else
      {
        *(_QWORD *)v41 = v9;
        v12 = (_QWORD *)(v11 + 8);
      }
      v8 = (char *)(v10 + 9);
      *(_QWORD *)&v41 = v12;
    }
    else
    {
      if (!v7)
        __cxa_bad_cast();
      v8 = v7 + 9;
    }
    if (a2 > 0x10)
      v22 = 3;
    else
      v22 = byte_216AB4E54[a2];
    *v8 = v22;
    v50 = a1;
    v23 = v51;
    std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)v51, a3);
    dispatch_assert_queue_V2((dispatch_queue_t)a1->__get_deleter);
    v24 = (std::__shared_weak_count *)operator new(0x40uLL);
    v24->__shared_owners_ = 0;
    p_shared_owners = (unint64_t *)&v24->__shared_owners_;
    v24->__shared_weak_owners_ = 0;
    v24->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E0E10;
    v24[1].__vftable = v50;
    std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)&v24[1].__shared_owners_, (uint64_t)v51);
    v47 = &v24[1].__vftable;
    v48 = v24;
    p_get_deleter = &a1[1].__get_deleter;
    v43 = QMIServiceMsg::create();
    v44 = 25000;
    v45 = 0;
    v46 = 0;
    v26 = MEMORY[0x24BDAC760];
    *(_QWORD *)buf = MEMORY[0x24BDAC760];
    v54 = 1174405120;
    v55 = ___ZN22QMIStewieCommandDriver4sendIN3sft12Deactivation7RequestEZNS_10deactivateE16StewieExitReasonONSt3__18functionIFvbEEEE3__2EEvRKT_OT0__block_invoke;
    v56 = (uint8_t *)&__block_descriptor_tmp_52_5;
    v57 = &v24[1].__vftable;
    v58 = v24;
    do
      v27 = __ldxr(p_shared_owners);
    while (__stxr(v27 + 1, p_shared_owners));
    aBlock[0] = v26;
    aBlock[1] = 0x40000000;
    aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_24;
    aBlock[3] = &unk_24D5E09E8;
    aBlock[4] = buf;
    v28 = _Block_copy(aBlock);
    v46 = v28;
    if (v43)
    {
      qmi::Client::send();
      v28 = v46;
    }
    if (v28)
      _Block_release(v28);
    v29 = v58;
    if (v58)
    {
      v30 = (unint64_t *)&v58->__shared_owners_;
      do
        v31 = __ldaxr(v30);
      while (__stlxr(v31 - 1, v30));
      if (!v31)
      {
        ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
        std::__shared_weak_count::__release_weak(v29);
      }
    }
    v32 = v48;
    if (v48)
    {
      v33 = (unint64_t *)&v48->__shared_owners_;
      do
        v34 = __ldaxr(v33);
      while (__stlxr(v34 - 1, v33));
      if (!v34)
      {
        ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
        std::__shared_weak_count::__release_weak(v32);
      }
    }
    if (v52 == v51)
    {
      v35 = 4;
    }
    else
    {
      if (!v52)
      {
LABEL_50:
        qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
        return;
      }
      v35 = 5;
      v23 = v52;
    }
    (*(void (**)(_QWORD *))(*v23 + 8 * v35))(v23);
    goto LABEL_50;
  }
  v36 = (uint64_t *)&a1->~__shared_weak_count_0;
  v37 = a1[1].~__shared_weak_count;
  if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl(&dword_216897000, v37, OS_LOG_TYPE_ERROR, "Failed to execute Deactivation request. Client is not ready", buf, 2u);
  }
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)buf, a3);
  ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::deactivate(StewieExitReason,std::function<void ()(BOOL)> &&)::$_0>(v36, (uint64_t)buf);
  v38 = v56;
  if (v56 == buf)
  {
    v39 = 4;
    v38 = buf;
    goto LABEL_58;
  }
  if (v56)
  {
    v39 = 5;
LABEL_58:
    (*(void (**)(void))(*(_QWORD *)v38 + 8 * v39))();
  }
}

void sub_216A1CAE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,_QWORD *a30)
{
  _QWORD *v30;
  uint64_t v31;
  uint64_t v33;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v31);
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)&a14);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a19);
  if (a30 == v30)
  {
    v33 = 4;
  }
  else
  {
    if (!a30)
      goto LABEL_6;
    v33 = 5;
    v30 = a30;
  }
  (*(void (**)(_QWORD *))(*v30 + 8 * v33))(v30);
LABEL_6:
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::deactivate(StewieExitReason,std::function<void ()(BOOL)> &&)::$_0>(uint64_t *a1, uint64_t a2)
{
  std::__shared_weak_count *v3;
  uint64_t v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  NSObject *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v3 = (std::__shared_weak_count *)a1[1];
  if (!v3 || (v5 = *a1, (v6 = std::__shared_weak_count::lock(v3)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v7 = v6;
  v8 = operator new();
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100](v8, a2);
  v9 = a1[2];
  p_shared_owners = (unint64_t *)&v7->__shared_owners_;
  do
    v11 = __ldxr(p_shared_owners);
  while (__stxr(v11 + 1, p_shared_owners));
  v12 = (_QWORD *)operator new();
  *v12 = v8;
  v12[1] = v5;
  v12[2] = v7;
  v14 = 0;
  v15 = 0;
  dispatch_async_f(v9, v12, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute_wrapped<QMIStewieCommandDriver::deactivate(StewieExitReason,std::function<void ()(BOOL)> &&)::$_0>(QMIStewieCommandDriver::deactivate(StewieExitReason,std::function<void ()(BOOL)> &&)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIStewieCommandDriver::deactivate(StewieExitReason,std::function<void ()(BOOL)> &&)::$_0,std::default_delete<QMIStewieCommandDriver::deactivate(StewieExitReason,std::function<void ()(BOOL)> &&)::$_0>>)::{lambda(void *)#1}::__invoke);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v14);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v15);
  do
    v13 = __ldaxr(p_shared_owners);
  while (__stlxr(v13 - 1, p_shared_owners));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
}

void QMIStewieCommandDriver::setConcurrencyConfig(std::__shared_weak_count_vtbl *a1, char a2, uint64_t a3)
{
  const void **v6;
  char *v7;
  _BYTE *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  char *v16;
  uint64_t *v17;
  char *v18;
  char *v19;
  char *v20;
  uint64_t v21;
  _QWORD *v22;
  std::__shared_weak_count *v23;
  unint64_t *p_shared_owners;
  uint64_t v25;
  unint64_t v26;
  void *v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t *v35;
  NSObject *v36;
  uint8_t *v37;
  uint64_t v38;
  void *__p[2];
  __int128 v40;
  const void *(__cdecl **p_get_deleter)(const std::__shared_weak_count *__hidden, const std::type_info *);
  uint64_t v42;
  int v43;
  uint64_t v44;
  void *v45;
  _QWORD *v46;
  std::__shared_weak_count *v47;
  _QWORD aBlock[5];
  std::__shared_weak_count_vtbl *v49;
  _BYTE v50[24];
  _BYTE *v51;
  uint8_t buf[8];
  uint64_t v53;
  uint64_t (*v54)(uint64_t, uint64_t);
  uint8_t *v55;
  _QWORD *v56;
  std::__shared_weak_count *v57;
  uint64_t v58;

  v58 = *MEMORY[0x24BDAC8D0];
  dispatch_assert_queue_V2((dispatch_queue_t)a1->__get_deleter);
  if (LOBYTE(a1[2].__on_zero_shared_weak))
  {
    *(_OWORD *)__p = 0u;
    v40 = 0u;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
    v6 = (const void **)__p[1];
    if (__p[1] != (void *)v40)
    {
      while (*((_BYTE *)*v6 + 8) != 1)
      {
        if (++v6 == (const void **)v40)
          goto LABEL_9;
      }
    }
    if (v6 == (const void **)v40)
    {
LABEL_9:
      v9 = operator new();
      v10 = v9;
      *(_WORD *)(v9 + 8) = 1;
      *(_QWORD *)v9 = &off_24D5E0E78;
      v11 = v40;
      if ((unint64_t)v40 >= *((_QWORD *)&v40 + 1))
      {
        v13 = (uint64_t)(v40 - (unint64_t)__p[1]) >> 3;
        if ((unint64_t)(v13 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v14 = (uint64_t)(*((_QWORD *)&v40 + 1) - (unint64_t)__p[1]) >> 2;
        if (v14 <= v13 + 1)
          v14 = v13 + 1;
        if (*((_QWORD *)&v40 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v15 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v15 = v14;
        if (v15)
          v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v40 + 8, v15);
        else
          v16 = 0;
        v17 = (uint64_t *)&v16[8 * v13];
        v18 = &v16[8 * v15];
        *v17 = v10;
        v12 = v17 + 1;
        v20 = (char *)__p[1];
        v19 = (char *)v40;
        if ((void *)v40 != __p[1])
        {
          do
          {
            v21 = *((_QWORD *)v19 - 1);
            v19 -= 8;
            *--v17 = v21;
          }
          while (v19 != v20);
          v19 = (char *)__p[1];
        }
        __p[1] = v17;
        *(_QWORD *)&v40 = v12;
        *((_QWORD *)&v40 + 1) = v18;
        if (v19)
          operator delete(v19);
      }
      else
      {
        *(_QWORD *)v40 = v9;
        v12 = (_QWORD *)(v11 + 8);
      }
      v8 = (_BYTE *)(v10 + 9);
      *(_QWORD *)&v40 = v12;
    }
    else
    {
      if (!v7)
        __cxa_bad_cast();
      v8 = v7 + 9;
    }
    *v8 = a2;
    v49 = a1;
    v22 = v50;
    std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)v50, a3);
    dispatch_assert_queue_V2((dispatch_queue_t)a1->__get_deleter);
    v23 = (std::__shared_weak_count *)operator new(0x40uLL);
    v23->__shared_owners_ = 0;
    p_shared_owners = (unint64_t *)&v23->__shared_owners_;
    v23->__shared_weak_owners_ = 0;
    v23->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E0EE0;
    v23[1].__vftable = v49;
    std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)&v23[1].__shared_owners_, (uint64_t)v50);
    v46 = &v23[1].__vftable;
    v47 = v23;
    p_get_deleter = &a1[1].__get_deleter;
    v42 = QMIServiceMsg::create();
    v43 = 25000;
    v44 = 0;
    v45 = 0;
    v25 = MEMORY[0x24BDAC760];
    *(_QWORD *)buf = MEMORY[0x24BDAC760];
    v53 = 1174405120;
    v54 = ___ZN22QMIStewieCommandDriver4sendIN3sft20SetConcurrencyConfig7RequestEZNS_20setConcurrencyConfigEbONSt3__18functionIFvbEEEE3__2EEvRKT_OT0__block_invoke;
    v55 = (uint8_t *)&__block_descriptor_tmp_53_5;
    v56 = &v23[1].__vftable;
    v57 = v23;
    do
      v26 = __ldxr(p_shared_owners);
    while (__stxr(v26 + 1, p_shared_owners));
    aBlock[0] = v25;
    aBlock[1] = 0x40000000;
    aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_24;
    aBlock[3] = &unk_24D5E09E8;
    aBlock[4] = buf;
    v27 = _Block_copy(aBlock);
    v45 = v27;
    if (v42)
    {
      qmi::Client::send();
      v27 = v45;
    }
    if (v27)
      _Block_release(v27);
    v28 = v57;
    if (v57)
    {
      v29 = (unint64_t *)&v57->__shared_owners_;
      do
        v30 = __ldaxr(v29);
      while (__stlxr(v30 - 1, v29));
      if (!v30)
      {
        ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
        std::__shared_weak_count::__release_weak(v28);
      }
    }
    v31 = v47;
    if (v47)
    {
      v32 = (unint64_t *)&v47->__shared_owners_;
      do
        v33 = __ldaxr(v32);
      while (__stlxr(v33 - 1, v32));
      if (!v33)
      {
        ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
        std::__shared_weak_count::__release_weak(v31);
      }
    }
    if (v51 == v50)
    {
      v34 = 4;
    }
    else
    {
      if (!v51)
      {
LABEL_47:
        qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
        return;
      }
      v34 = 5;
      v22 = v51;
    }
    (*(void (**)(_QWORD *))(*v22 + 8 * v34))(v22);
    goto LABEL_47;
  }
  v35 = (uint64_t *)&a1->~__shared_weak_count_0;
  v36 = a1[1].~__shared_weak_count;
  if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl(&dword_216897000, v36, OS_LOG_TYPE_ERROR, "Failed to execute SetConcurrencyConfig request. Client is not ready. Will retry later", buf, 2u);
  }
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)buf, a3);
  ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::setConcurrencyConfig(BOOL,std::function<void ()(BOOL)> &&)::$_0>(v35, (uint64_t)buf);
  v37 = v55;
  if (v55 == buf)
  {
    v38 = 4;
    v37 = buf;
    goto LABEL_55;
  }
  if (v55)
  {
    v38 = 5;
LABEL_55:
    (*(void (**)(void))(*(_QWORD *)v37 + 8 * v38))();
  }
}

void sub_216A1D0C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,_QWORD *a30)
{
  _QWORD *v30;
  uint64_t v31;
  uint64_t v33;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v31);
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)&a14);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a19);
  if (a30 == v30)
  {
    v33 = 4;
  }
  else
  {
    if (!a30)
      goto LABEL_6;
    v33 = 5;
    v30 = a30;
  }
  (*(void (**)(_QWORD *))(*v30 + 8 * v33))(v30);
LABEL_6:
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::setConcurrencyConfig(BOOL,std::function<void ()(BOOL)> &&)::$_0>(uint64_t *a1, uint64_t a2)
{
  std::__shared_weak_count *v3;
  uint64_t v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  NSObject *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v3 = (std::__shared_weak_count *)a1[1];
  if (!v3 || (v5 = *a1, (v6 = std::__shared_weak_count::lock(v3)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v7 = v6;
  v8 = operator new();
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100](v8, a2);
  v9 = a1[2];
  p_shared_owners = (unint64_t *)&v7->__shared_owners_;
  do
    v11 = __ldxr(p_shared_owners);
  while (__stxr(v11 + 1, p_shared_owners));
  v12 = (_QWORD *)operator new();
  *v12 = v8;
  v12[1] = v5;
  v12[2] = v7;
  v14 = 0;
  v15 = 0;
  dispatch_async_f(v9, v12, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute_wrapped<QMIStewieCommandDriver::setConcurrencyConfig(BOOL,std::function<void ()(BOOL)> &&)::$_0>(QMIStewieCommandDriver::setConcurrencyConfig(BOOL,std::function<void ()(BOOL)> &&)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIStewieCommandDriver::setConcurrencyConfig(BOOL,std::function<void ()(BOOL)> &&)::$_0,std::default_delete<QMIStewieCommandDriver::setConcurrencyConfig(BOOL,std::function<void ()(BOOL)> &&)::$_0>>)::{lambda(void *)#1}::__invoke);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v14);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v15);
  do
    v13 = __ldaxr(p_shared_owners);
  while (__stlxr(v13 - 1, p_shared_owners));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
}

void QMIStewieCommandDriver::suspend(std::__shared_weak_count_vtbl *a1, unsigned int a2, uint64_t a3)
{
  const void **v6;
  const void **v7;
  char *v8;
  _BYTE *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  char *v16;
  const void **v17;
  char *v18;
  char *v19;
  char *v20;
  const void *v21;
  unsigned int v22;
  const void **i;
  char *v24;
  _BYTE *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  _QWORD *v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  char *v33;
  uint64_t *v34;
  char *v35;
  char *v36;
  char *v37;
  uint64_t v38;
  _QWORD *v39;
  std::__shared_weak_count *v40;
  unint64_t *p_shared_owners;
  uint64_t v42;
  unint64_t v43;
  void *v44;
  std::__shared_weak_count *v45;
  unint64_t *v46;
  unint64_t v47;
  std::__shared_weak_count *v48;
  unint64_t *v49;
  unint64_t v50;
  uint64_t v51;
  uint64_t *v52;
  NSObject *v53;
  uint8_t *v54;
  uint64_t v55;
  void *__p[2];
  __int128 v57;
  const void *(__cdecl **p_get_deleter)(const std::__shared_weak_count *__hidden, const std::type_info *);
  uint64_t v59;
  int v60;
  uint64_t v61;
  void *v62;
  _QWORD *v63;
  std::__shared_weak_count *v64;
  _QWORD aBlock[5];
  std::__shared_weak_count_vtbl *v66;
  _BYTE v67[24];
  _BYTE *v68;
  uint8_t buf[8];
  uint64_t v70;
  uint64_t (*v71)(uint64_t, uint64_t);
  uint8_t *v72;
  _QWORD *v73;
  std::__shared_weak_count *v74;
  uint64_t v75;

  v75 = *MEMORY[0x24BDAC8D0];
  dispatch_assert_queue_V2((dispatch_queue_t)a1->__get_deleter);
  if (LOBYTE(a1[2].__on_zero_shared_weak))
  {
    *(_OWORD *)__p = 0u;
    v57 = 0u;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
    v6 = (const void **)__p[1];
    v7 = (const void **)v57;
    if (__p[1] != (void *)v57)
    {
      while (*((_BYTE *)*v6 + 8) != 1)
      {
        if (++v6 == (const void **)v57)
          goto LABEL_9;
      }
    }
    if (v6 == (const void **)v57)
    {
LABEL_9:
      v10 = operator new();
      v11 = v10;
      *(_WORD *)(v10 + 8) = 1;
      *(_QWORD *)v10 = &off_24D5E0F48;
      v12 = v57;
      if ((unint64_t)v57 >= *((_QWORD *)&v57 + 1))
      {
        v13 = (uint64_t)(v57 - (unint64_t)__p[1]) >> 3;
        if ((unint64_t)(v13 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v14 = (uint64_t)(*((_QWORD *)&v57 + 1) - (unint64_t)__p[1]) >> 2;
        if (v14 <= v13 + 1)
          v14 = v13 + 1;
        if (*((_QWORD *)&v57 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v15 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v15 = v14;
        if (v15)
          v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v57 + 8, v15);
        else
          v16 = 0;
        v17 = (const void **)&v16[8 * v13];
        v18 = &v16[8 * v15];
        *v17 = (const void *)v11;
        v7 = v17 + 1;
        v20 = (char *)__p[1];
        v19 = (char *)v57;
        if ((void *)v57 != __p[1])
        {
          do
          {
            v21 = (const void *)*((_QWORD *)v19 - 1);
            v19 -= 8;
            *--v17 = v21;
          }
          while (v19 != v20);
          v19 = (char *)__p[1];
        }
        __p[1] = v17;
        *(_QWORD *)&v57 = v7;
        *((_QWORD *)&v57 + 1) = v18;
        if (v19)
          operator delete(v19);
      }
      else
      {
        *(_QWORD *)v57 = v10;
        v7 = (const void **)(v12 + 8);
      }
      v9 = (_BYTE *)(v11 + 9);
      *(_QWORD *)&v57 = v7;
    }
    else
    {
      if (!v8)
        __cxa_bad_cast();
      v9 = v8 + 9;
    }
    v22 = 0x10002u >> (8 * a2);
    if (a2 >= 3)
      LOBYTE(v22) = 2;
    *v9 = v22;
    for (i = (const void **)__p[1]; i != v7; ++i)
    {
      if (*((_BYTE *)*i + 8) == 2)
      {
        if (i != v7)
        {
          if (!v24)
            __cxa_bad_cast();
          v25 = v24 + 9;
          goto LABEL_52;
        }
        break;
      }
    }
    v26 = operator new();
    v27 = v26;
    *(_WORD *)(v26 + 8) = 2;
    *(_QWORD *)v26 = &off_24D5E0F98;
    v28 = v57;
    if ((unint64_t)v57 >= *((_QWORD *)&v57 + 1))
    {
      v30 = (uint64_t)(v57 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v30 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v31 = (uint64_t)(*((_QWORD *)&v57 + 1) - (unint64_t)__p[1]) >> 2;
      if (v31 <= v30 + 1)
        v31 = v30 + 1;
      if (*((_QWORD *)&v57 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v32 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v32 = v31;
      if (v32)
        v33 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v57 + 8, v32);
      else
        v33 = 0;
      v34 = (uint64_t *)&v33[8 * v30];
      v35 = &v33[8 * v32];
      *v34 = v27;
      v29 = v34 + 1;
      v37 = (char *)__p[1];
      v36 = (char *)v57;
      if ((void *)v57 != __p[1])
      {
        do
        {
          v38 = *((_QWORD *)v36 - 1);
          v36 -= 8;
          *--v34 = v38;
        }
        while (v36 != v37);
        v36 = (char *)__p[1];
      }
      __p[1] = v34;
      *(_QWORD *)&v57 = v29;
      *((_QWORD *)&v57 + 1) = v35;
      if (v36)
        operator delete(v36);
    }
    else
    {
      *(_QWORD *)v57 = v26;
      v29 = (_QWORD *)(v28 + 8);
    }
    v25 = (_BYTE *)(v27 + 9);
    *(_QWORD *)&v57 = v29;
LABEL_52:
    *v25 = 0;
    v66 = a1;
    v39 = v67;
    std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)v67, a3);
    dispatch_assert_queue_V2((dispatch_queue_t)a1->__get_deleter);
    v40 = (std::__shared_weak_count *)operator new(0x40uLL);
    v40->__shared_owners_ = 0;
    p_shared_owners = (unint64_t *)&v40->__shared_owners_;
    v40->__shared_weak_owners_ = 0;
    v40->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E1000;
    v40[1].__vftable = v66;
    std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)&v40[1].__shared_owners_, (uint64_t)v67);
    v63 = &v40[1].__vftable;
    v64 = v40;
    p_get_deleter = &a1[1].__get_deleter;
    v59 = QMIServiceMsg::create();
    v60 = 25000;
    v61 = 0;
    v62 = 0;
    v42 = MEMORY[0x24BDAC760];
    *(_QWORD *)buf = MEMORY[0x24BDAC760];
    v70 = 1174405120;
    v71 = ___ZN22QMIStewieCommandDriver4sendIN3sft7Suspend7RequestEZNS_7suspendE19StewieSuspendReasonONSt3__18functionIFvbEEEE3__3EEvRKT_OT0__block_invoke;
    v72 = (uint8_t *)&__block_descriptor_tmp_54_5;
    v73 = &v40[1].__vftable;
    v74 = v40;
    do
      v43 = __ldxr(p_shared_owners);
    while (__stxr(v43 + 1, p_shared_owners));
    aBlock[0] = v42;
    aBlock[1] = 0x40000000;
    aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_24;
    aBlock[3] = &unk_24D5E09E8;
    aBlock[4] = buf;
    v44 = _Block_copy(aBlock);
    v62 = v44;
    if (v59)
    {
      qmi::Client::send();
      v44 = v62;
    }
    if (v44)
      _Block_release(v44);
    v45 = v74;
    if (v74)
    {
      v46 = (unint64_t *)&v74->__shared_owners_;
      do
        v47 = __ldaxr(v46);
      while (__stlxr(v47 - 1, v46));
      if (!v47)
      {
        ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
        std::__shared_weak_count::__release_weak(v45);
      }
    }
    v48 = v64;
    if (v64)
    {
      v49 = (unint64_t *)&v64->__shared_owners_;
      do
        v50 = __ldaxr(v49);
      while (__stlxr(v50 - 1, v49));
      if (!v50)
      {
        ((void (*)(std::__shared_weak_count *))v48->__on_zero_shared)(v48);
        std::__shared_weak_count::__release_weak(v48);
      }
    }
    if (v68 == v67)
    {
      v51 = 4;
    }
    else
    {
      if (!v68)
      {
LABEL_73:
        qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
        return;
      }
      v51 = 5;
      v39 = v68;
    }
    (*(void (**)(_QWORD *))(*v39 + 8 * v51))(v39);
    goto LABEL_73;
  }
  v52 = (uint64_t *)&a1->~__shared_weak_count_0;
  v53 = a1[1].~__shared_weak_count;
  if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl(&dword_216897000, v53, OS_LOG_TYPE_ERROR, "Failed to execute Suspend. Client is not ready", buf, 2u);
  }
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)buf, a3);
  ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::suspend(StewieSuspendReason,std::function<void ()(BOOL)> &&)::$_0>(v52, (uint64_t)buf);
  v54 = v72;
  if (v72 == buf)
  {
    v55 = 4;
    v54 = buf;
    goto LABEL_81;
  }
  if (v72)
  {
    v55 = 5;
LABEL_81:
    (*(void (**)(void))(*(_QWORD *)v54 + 8 * v55))();
  }
}

void sub_216A1D804(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,_QWORD *a30)
{
  _QWORD *v30;
  uint64_t v31;
  uint64_t v33;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v31);
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)&a14);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a19);
  if (a30 == v30)
  {
    v33 = 4;
  }
  else
  {
    if (!a30)
      goto LABEL_6;
    v33 = 5;
    v30 = a30;
  }
  (*(void (**)(_QWORD *))(*v30 + 8 * v33))(v30);
LABEL_6:
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::suspend(StewieSuspendReason,std::function<void ()(BOOL)> &&)::$_0>(uint64_t *a1, uint64_t a2)
{
  std::__shared_weak_count *v3;
  uint64_t v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  NSObject *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v3 = (std::__shared_weak_count *)a1[1];
  if (!v3 || (v5 = *a1, (v6 = std::__shared_weak_count::lock(v3)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v7 = v6;
  v8 = operator new();
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100](v8, a2);
  v9 = a1[2];
  p_shared_owners = (unint64_t *)&v7->__shared_owners_;
  do
    v11 = __ldxr(p_shared_owners);
  while (__stxr(v11 + 1, p_shared_owners));
  v12 = (_QWORD *)operator new();
  *v12 = v8;
  v12[1] = v5;
  v12[2] = v7;
  v14 = 0;
  v15 = 0;
  dispatch_async_f(v9, v12, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute_wrapped<QMIStewieCommandDriver::suspend(StewieSuspendReason,std::function<void ()(BOOL)> &&)::$_0>(QMIStewieCommandDriver::suspend(StewieSuspendReason,std::function<void ()(BOOL)> &&)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIStewieCommandDriver::suspend(StewieSuspendReason,std::function<void ()(BOOL)> &&)::$_0,std::default_delete<QMIStewieCommandDriver::suspend(StewieSuspendReason,std::function<void ()(BOOL)> &&)::$_0>>)::{lambda(void *)#1}::__invoke);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v14);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v15);
  do
    v13 = __ldaxr(p_shared_owners);
  while (__stlxr(v13 - 1, p_shared_owners));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
}

void QMIStewieCommandDriver::resume(std::__shared_weak_count_vtbl *a1, uint64_t a2, uint64_t a3, uint64_t a4, char **a5, uint64_t *a6, uint64_t a7)
{
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  _QWORD *v18;
  std::__shared_weak_count *v19;
  unint64_t *p_shared_owners;
  uint64_t v21;
  unint64_t v22;
  void *v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t *v31;
  NSObject *v32;
  uint8_t *v33;
  uint64_t v34;
  _OWORD v35[2];
  const void *(__cdecl **p_get_deleter)(const std::__shared_weak_count *__hidden, const std::type_info *);
  uint64_t v37;
  int v38;
  uint64_t v39;
  void *v40;
  _QWORD *v41;
  std::__shared_weak_count *v42;
  _QWORD aBlock[5];
  std::__shared_weak_count_vtbl *v44;
  _BYTE v45[24];
  _BYTE *v46;
  uint8_t buf[8];
  uint64_t v48;
  uint64_t (*v49)(uint64_t, uint64_t);
  uint8_t *v50;
  _QWORD *v51;
  std::__shared_weak_count *v52;
  uint64_t v53;

  v53 = *MEMORY[0x24BDAC8D0];
  dispatch_assert_queue_V2((dispatch_queue_t)a1->__get_deleter);
  if (LOBYTE(a1[2].__on_zero_shared_weak))
  {
    memset(v35, 0, sizeof(v35));
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v35);
    v14 = qmi::MutableMessageBase::getTLV<sft::tlv::LocationData>(v35, 1);
    v15 = qmi::MutableMessageBase::getTLV<sft::tlv::EARFCN>(v35, 2);
    v16 = v15;
    if (v15 != (char *)a4)
      std::vector<wds::tlv::DestPortRangeInfo>::__assign_with_size[abi:ne180100]<wds::tlv::DestPortRangeInfo*,wds::tlv::DestPortRangeInfo*>(v15, *(char **)a4, *(_QWORD *)(a4 + 8), (uint64_t)(*(_QWORD *)(a4 + 8) - *(_QWORD *)a4) >> 2);
    if (v16 != (char *)a4)
      std::vector<wds::tlv::DestPortRangeInfo>::__assign_with_size[abi:ne180100]<wds::tlv::DestPortRangeInfo*,wds::tlv::DestPortRangeInfo*>(v16 + 24, *(char **)(a4 + 24), *(_QWORD *)(a4 + 32), (uint64_t)(*(_QWORD *)(a4 + 32) - *(_QWORD *)(a4 + 24)) >> 2);
    if (*a6)
    {
      v17 = qmi::MutableMessageBase::getTLV<sft::tlv::HeatMapData>(v35, 16);
    }
    v44 = a1;
    v18 = v45;
    std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)v45, a7);
    dispatch_assert_queue_V2((dispatch_queue_t)a1->__get_deleter);
    v19 = (std::__shared_weak_count *)operator new(0x40uLL);
    v19->__shared_owners_ = 0;
    p_shared_owners = (unint64_t *)&v19->__shared_owners_;
    v19->__shared_weak_owners_ = 0;
    v19->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E1080;
    v19[1].__vftable = v44;
    std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)&v19[1].__shared_owners_, (uint64_t)v45);
    v41 = &v19[1].__vftable;
    v42 = v19;
    p_get_deleter = &a1[1].__get_deleter;
    v37 = QMIServiceMsg::create();
    v38 = 25000;
    v39 = 0;
    v40 = 0;
    v21 = MEMORY[0x24BDAC760];
    *(_QWORD *)buf = MEMORY[0x24BDAC760];
    v48 = 1174405120;
    v49 = ___ZN22QMIStewieCommandDriver4sendIN3sft6Resume7RequestEZNS_6resumeERK18StewieTimeFreqDataRK18StewieLocationDataRK12StewieEARFCNRKNSt3__16vectorIhNSD_9allocatorIhEEEERKNSD_10shared_ptrIK13StewieHeatMapEEONSD_8functionIFvbEEEE3__4EEvRKT_OT0__block_invoke;
    v50 = (uint8_t *)&__block_descriptor_tmp_55_7;
    v51 = &v19[1].__vftable;
    v52 = v19;
    do
      v22 = __ldxr(p_shared_owners);
    while (__stxr(v22 + 1, p_shared_owners));
    aBlock[0] = v21;
    aBlock[1] = 0x40000000;
    aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_24;
    aBlock[3] = &unk_24D5E09E8;
    aBlock[4] = buf;
    v23 = _Block_copy(aBlock);
    v40 = v23;
    if (v37)
    {
      qmi::Client::send();
      v23 = v40;
    }
    if (v23)
      _Block_release(v23);
    v24 = v52;
    if (v52)
    {
      v25 = (unint64_t *)&v52->__shared_owners_;
      do
        v26 = __ldaxr(v25);
      while (__stlxr(v26 - 1, v25));
      if (!v26)
      {
        ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
        std::__shared_weak_count::__release_weak(v24);
      }
    }
    v27 = v42;
    if (v42)
    {
      v28 = (unint64_t *)&v42->__shared_owners_;
      do
        v29 = __ldaxr(v28);
      while (__stlxr(v29 - 1, v28));
      if (!v29)
      {
        ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
        std::__shared_weak_count::__release_weak(v27);
      }
    }
    if (v46 == v45)
    {
      v30 = 4;
    }
    else
    {
      if (!v46)
      {
LABEL_29:
        qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v35);
        return;
      }
      v30 = 5;
      v18 = v46;
    }
    (*(void (**)(_QWORD *))(*v18 + 8 * v30))(v18);
    goto LABEL_29;
  }
  v31 = (uint64_t *)&a1->~__shared_weak_count_0;
  v32 = a1[1].~__shared_weak_count;
  if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl(&dword_216897000, v32, OS_LOG_TYPE_ERROR, "Failed to execute Resume. Client is not ready", buf, 2u);
  }
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)buf, a7);
  ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::resume(StewieTimeFreqData const&,StewieLocationData const&,StewieEARFCN const&,std::vector<unsigned char> const&,std::shared_ptr<StewieHeatMap const> const&,std::function<void ()(BOOL)> &&)::$_0>(v31, (uint64_t)buf);
  v33 = v50;
  if (v50 == buf)
  {
    v34 = 4;
    v33 = buf;
    goto LABEL_37;
  }
  if (v50)
  {
    v34 = 5;
LABEL_37:
    (*(void (**)(void))(*(_QWORD *)v33 + 8 * v34))();
  }
}

void sub_216A1DD28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,_QWORD *a30)
{
  _QWORD *v30;
  uint64_t v31;
  uint64_t v33;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v31);
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)&a14);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a19);
  if (a30 == v30)
  {
    v33 = 4;
  }
  else
  {
    if (!a30)
      goto LABEL_6;
    v33 = 5;
    v30 = a30;
  }
  (*(void (**)(_QWORD *))(*v30 + 8 * v33))(v30);
LABEL_6:
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::resume(StewieTimeFreqData const&,StewieLocationData const&,StewieEARFCN const&,std::vector<unsigned char> const&,std::shared_ptr<StewieHeatMap const> const&,std::function<void ()(BOOL)> &&)::$_0>(uint64_t *a1, uint64_t a2)
{
  std::__shared_weak_count *v3;
  uint64_t v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  NSObject *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v3 = (std::__shared_weak_count *)a1[1];
  if (!v3 || (v5 = *a1, (v6 = std::__shared_weak_count::lock(v3)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v7 = v6;
  v8 = operator new();
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100](v8, a2);
  v9 = a1[2];
  p_shared_owners = (unint64_t *)&v7->__shared_owners_;
  do
    v11 = __ldxr(p_shared_owners);
  while (__stxr(v11 + 1, p_shared_owners));
  v12 = (_QWORD *)operator new();
  *v12 = v8;
  v12[1] = v5;
  v12[2] = v7;
  v14 = 0;
  v15 = 0;
  dispatch_async_f(v9, v12, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute_wrapped<QMIStewieCommandDriver::resume(StewieTimeFreqData const&,StewieLocationData const&,StewieEARFCN const&,std::vector<unsigned char> const&,std::shared_ptr<StewieHeatMap const> const&,std::function<void ()(BOOL)> &&)::$_0>(QMIStewieCommandDriver::resume(StewieTimeFreqData const&,StewieLocationData const&,StewieEARFCN const&,std::vector<unsigned char> const&,std::shared_ptr<StewieHeatMap const> const&,std::function<void ()(BOOL)> &&)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIStewieCommandDriver::resume(StewieTimeFreqData const&,StewieLocationData const&,StewieEARFCN const&,std::vector<unsigned char> const&,std::shared_ptr<StewieHeatMap const> const&,std::function<void ()(BOOL)> &&)::$_0,std::default_delete<QMIStewieCommandDriver::resume(StewieTimeFreqData const&,StewieLocationData const&,StewieEARFCN const&,std::vector<unsigned char> const&,std::shared_ptr<StewieHeatMap const> const&,std::function<void ()(BOOL)> &&)::$_0>>)::{lambda(void *)#1}::__invoke);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v14);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v15);
  do
    v13 = __ldaxr(p_shared_owners);
  while (__stlxr(v13 - 1, p_shared_owners));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
}

void QMIStewieCommandDriver::initiateRegistration(std::__shared_weak_count_vtbl *a1, uint64_t a2)
{
  _QWORD *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  uint64_t v7;
  unint64_t v8;
  void *v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  uint64_t v16;
  NSObject *v17;
  uint8_t *v18;
  uint64_t v19;
  _OWORD v20[2];
  const void *(__cdecl **p_get_deleter)(const std::__shared_weak_count *__hidden, const std::type_info *);
  uint64_t v22;
  int v23;
  uint64_t v24;
  void *v25;
  _QWORD *v26;
  std::__shared_weak_count *v27;
  _QWORD aBlock[5];
  std::__shared_weak_count_vtbl *v29;
  _BYTE v30[24];
  _BYTE *v31;
  uint8_t buf[8];
  uint64_t v33;
  uint64_t (*v34)(uint64_t, uint64_t);
  uint8_t *v35;
  _QWORD *v36;
  std::__shared_weak_count *v37;
  uint64_t v38;

  v38 = *MEMORY[0x24BDAC8D0];
  if (LOBYTE(a1[2].__on_zero_shared_weak))
  {
    memset(v20, 0, sizeof(v20));
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v20);
    v29 = a1;
    v4 = v30;
    std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)v30, a2);
    dispatch_assert_queue_V2((dispatch_queue_t)a1->__get_deleter);
    v5 = (std::__shared_weak_count *)operator new(0x40uLL);
    v5->__shared_owners_ = 0;
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    v5->__shared_weak_owners_ = 0;
    v5->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E1100;
    v5[1].__vftable = v29;
    std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)&v5[1].__shared_owners_, (uint64_t)v30);
    v26 = &v5[1].__vftable;
    v27 = v5;
    p_get_deleter = &a1[1].__get_deleter;
    v22 = QMIServiceMsg::create();
    v23 = 25000;
    v24 = 0;
    v25 = 0;
    v7 = MEMORY[0x24BDAC760];
    *(_QWORD *)buf = MEMORY[0x24BDAC760];
    v33 = 1174405120;
    v34 = ___ZN22QMIStewieCommandDriver4sendIN3sft20InitiateRegistration7RequestEZNS_20initiateRegistrationEONSt3__18functionIFvbEEEE3__1EEvRKT_OT0__block_invoke;
    v35 = (uint8_t *)&__block_descriptor_tmp_56_5;
    v36 = &v5[1].__vftable;
    v37 = v5;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
    aBlock[0] = v7;
    aBlock[1] = 0x40000000;
    aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_24;
    aBlock[3] = &unk_24D5E09E8;
    aBlock[4] = buf;
    v9 = _Block_copy(aBlock);
    v25 = v9;
    if (v22)
    {
      qmi::Client::send();
      v9 = v25;
    }
    if (v9)
      _Block_release(v9);
    v10 = v37;
    if (v37)
    {
      v11 = (unint64_t *)&v37->__shared_owners_;
      do
        v12 = __ldaxr(v11);
      while (__stlxr(v12 - 1, v11));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
    v13 = v27;
    if (v27)
    {
      v14 = (unint64_t *)&v27->__shared_owners_;
      do
        v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }
    if (v31 == v30)
    {
      v16 = 4;
    }
    else
    {
      if (!v31)
      {
LABEL_23:
        qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v20);
        return;
      }
      v16 = 5;
      v4 = v31;
    }
    (*(void (**)(_QWORD *))(*v4 + 8 * v16))(v4);
    goto LABEL_23;
  }
  v17 = a1[1].~__shared_weak_count;
  if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl(&dword_216897000, v17, OS_LOG_TYPE_ERROR, "Failed to execute InitiateRegistration. Client is not ready", buf, 2u);
  }
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)buf, a2);
  ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::initiateRegistration(std::function<void ()(BOOL)> &&)::$_0>((uint64_t *)&a1->~__shared_weak_count_0, (uint64_t)buf);
  v18 = v35;
  if (v35 == buf)
  {
    v19 = 4;
    v18 = buf;
    goto LABEL_31;
  }
  if (v35)
  {
    v19 = 5;
LABEL_31:
    (*(void (**)(void))(*(_QWORD *)v18 + 8 * v19))();
  }
}

void sub_216A1E1A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,_QWORD *a30)
{
  _QWORD *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v34;

  v32 = v31;
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v32);
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)&a14);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a19);
  if (a30 == v30)
  {
    v34 = 4;
  }
  else
  {
    if (!a30)
      goto LABEL_6;
    v34 = 5;
    v30 = a30;
  }
  (*(void (**)(_QWORD *))(*v30 + 8 * v34))(v30);
LABEL_6:
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::initiateRegistration(std::function<void ()(BOOL)> &&)::$_0>(uint64_t *a1, uint64_t a2)
{
  std::__shared_weak_count *v3;
  uint64_t v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  NSObject *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v3 = (std::__shared_weak_count *)a1[1];
  if (!v3 || (v5 = *a1, (v6 = std::__shared_weak_count::lock(v3)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v7 = v6;
  v8 = operator new();
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100](v8, a2);
  v9 = a1[2];
  p_shared_owners = (unint64_t *)&v7->__shared_owners_;
  do
    v11 = __ldxr(p_shared_owners);
  while (__stxr(v11 + 1, p_shared_owners));
  v12 = (_QWORD *)operator new();
  *v12 = v8;
  v12[1] = v5;
  v12[2] = v7;
  v14 = 0;
  v15 = 0;
  dispatch_async_f(v9, v12, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute_wrapped<QMIStewieCommandDriver::initiateRegistration(std::function<void ()(BOOL)> &&)::$_0>(QMIStewieCommandDriver::initiateRegistration(std::function<void ()(BOOL)> &&)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIStewieCommandDriver::initiateRegistration(std::function<void ()(BOOL)> &&)::$_0,std::default_delete<QMIStewieCommandDriver::initiateRegistration(std::function<void ()(BOOL)> &&)::$_0>>)::{lambda(void *)#1}::__invoke);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v14);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v15);
  do
    v13 = __ldaxr(p_shared_owners);
  while (__stlxr(v13 - 1, p_shared_owners));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
}

void QMIStewieCommandDriver::requestServiceInfo(std::__shared_weak_count_vtbl *a1, uint64_t a2)
{
  _QWORD *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  uint64_t v7;
  unint64_t v8;
  void *v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  NSObject *v18;
  uint8_t *v19;
  uint64_t v20;
  _OWORD v21[2];
  const void *(__cdecl **p_get_deleter)(const std::__shared_weak_count *__hidden, const std::type_info *);
  uint64_t v23;
  int v24;
  uint64_t v25;
  void *v26;
  _QWORD *v27;
  std::__shared_weak_count *v28;
  _QWORD aBlock[5];
  std::__shared_weak_count_vtbl *v30;
  _BYTE v31[24];
  _BYTE *v32;
  uint8_t buf[8];
  uint64_t v34;
  uint64_t (*v35)(uint64_t, uint64_t);
  uint8_t *v36;
  _QWORD *v37;
  std::__shared_weak_count *v38;
  uint64_t v39;

  v39 = *MEMORY[0x24BDAC8D0];
  dispatch_assert_queue_V2((dispatch_queue_t)a1->__get_deleter);
  if (LOBYTE(a1[2].__on_zero_shared_weak))
  {
    memset(v21, 0, sizeof(v21));
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v21);
    v30 = a1;
    v4 = v31;
    std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)v31, a2);
    dispatch_assert_queue_V2((dispatch_queue_t)a1->__get_deleter);
    v5 = (std::__shared_weak_count *)operator new(0x40uLL);
    v5->__shared_owners_ = 0;
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    v5->__shared_weak_owners_ = 0;
    v5->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E1180;
    v5[1].__vftable = v30;
    std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)&v5[1].__shared_owners_, (uint64_t)v31);
    v27 = &v5[1].__vftable;
    v28 = v5;
    p_get_deleter = &a1[1].__get_deleter;
    v23 = QMIServiceMsg::create();
    v24 = 25000;
    v25 = 0;
    v26 = 0;
    v7 = MEMORY[0x24BDAC760];
    *(_QWORD *)buf = MEMORY[0x24BDAC760];
    v34 = 1174405120;
    v35 = ___ZN22QMIStewieCommandDriver4sendIN3sft14GetServiceInfo7RequestEZNS_18requestServiceInfoEONSt3__18functionIFvbEEEE3__1EEvRKT_OT0__block_invoke;
    v36 = (uint8_t *)&__block_descriptor_tmp_57_5;
    v37 = &v5[1].__vftable;
    v38 = v5;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
    aBlock[0] = v7;
    aBlock[1] = 0x40000000;
    aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_24;
    aBlock[3] = &unk_24D5E09E8;
    aBlock[4] = buf;
    v9 = _Block_copy(aBlock);
    v26 = v9;
    if (v23)
    {
      qmi::Client::send();
      v9 = v26;
    }
    if (v9)
      _Block_release(v9);
    v10 = v38;
    if (v38)
    {
      v11 = (unint64_t *)&v38->__shared_owners_;
      do
        v12 = __ldaxr(v11);
      while (__stlxr(v12 - 1, v11));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
    v13 = v28;
    if (v28)
    {
      v14 = (unint64_t *)&v28->__shared_owners_;
      do
        v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }
    if (v32 == v31)
    {
      v16 = 4;
    }
    else
    {
      if (!v32)
      {
LABEL_23:
        qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v21);
        return;
      }
      v16 = 5;
      v4 = v32;
    }
    (*(void (**)(_QWORD *))(*v4 + 8 * v16))(v4);
    goto LABEL_23;
  }
  v17 = (uint64_t *)&a1->~__shared_weak_count_0;
  v18 = a1[1].~__shared_weak_count;
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl(&dword_216897000, v18, OS_LOG_TYPE_ERROR, "Failed to execute GetServiceInfo. Client is not ready", buf, 2u);
  }
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)buf, a2);
  ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::requestServiceInfo(std::function<void ()(BOOL)> &&)::$_0>(v17, (uint64_t)buf);
  v19 = v36;
  if (v36 == buf)
  {
    v20 = 4;
    v19 = buf;
    goto LABEL_31;
  }
  if (v36)
  {
    v20 = 5;
LABEL_31:
    (*(void (**)(void))(*(_QWORD *)v19 + 8 * v20))();
  }
}

void sub_216A1E61C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,_QWORD *a30)
{
  _QWORD *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v34;

  v32 = v31;
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v32);
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)&a14);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a19);
  if (a30 == v30)
  {
    v34 = 4;
  }
  else
  {
    if (!a30)
      goto LABEL_6;
    v34 = 5;
    v30 = a30;
  }
  (*(void (**)(_QWORD *))(*v30 + 8 * v34))(v30);
LABEL_6:
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::requestServiceInfo(std::function<void ()(BOOL)> &&)::$_0>(uint64_t *a1, uint64_t a2)
{
  std::__shared_weak_count *v3;
  uint64_t v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  NSObject *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v3 = (std::__shared_weak_count *)a1[1];
  if (!v3 || (v5 = *a1, (v6 = std::__shared_weak_count::lock(v3)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v7 = v6;
  v8 = operator new();
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100](v8, a2);
  v9 = a1[2];
  p_shared_owners = (unint64_t *)&v7->__shared_owners_;
  do
    v11 = __ldxr(p_shared_owners);
  while (__stxr(v11 + 1, p_shared_owners));
  v12 = (_QWORD *)operator new();
  *v12 = v8;
  v12[1] = v5;
  v12[2] = v7;
  v14 = 0;
  v15 = 0;
  dispatch_async_f(v9, v12, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute_wrapped<QMIStewieCommandDriver::requestServiceInfo(std::function<void ()(BOOL)> &&)::$_0>(QMIStewieCommandDriver::requestServiceInfo(std::function<void ()(BOOL)> &&)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIStewieCommandDriver::requestServiceInfo(std::function<void ()(BOOL)> &&)::$_0,std::default_delete<QMIStewieCommandDriver::requestServiceInfo(std::function<void ()(BOOL)> &&)::$_0>>)::{lambda(void *)#1}::__invoke);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v14);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v15);
  do
    v13 = __ldaxr(p_shared_owners);
  while (__stlxr(v13 - 1, p_shared_owners));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
}

void QMIStewieCommandDriver::setSecurityConfig(std::__shared_weak_count_vtbl *a1, uint64_t a2, uint64_t a3)
{
  char *v6;
  char *v7;
  uint64_t v8;
  _BYTE *v9;
  _BYTE *v10;
  _QWORD *v11;
  std::__shared_weak_count *v12;
  unint64_t *p_shared_owners;
  uint64_t v14;
  unint64_t v15;
  void *v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  NSObject *v25;
  uint8_t *v26;
  uint64_t v27;
  _OWORD v28[2];
  const void *(__cdecl **p_get_deleter)(const std::__shared_weak_count *__hidden, const std::type_info *);
  uint64_t v30;
  int v31;
  uint64_t v32;
  void *v33;
  _QWORD *v34;
  std::__shared_weak_count *v35;
  _QWORD aBlock[5];
  std::__shared_weak_count_vtbl *v37;
  _BYTE v38[24];
  _BYTE *v39;
  uint8_t buf[8];
  uint64_t v41;
  uint64_t (*v42)(uint64_t, uint64_t);
  uint8_t *v43;
  _QWORD *v44;
  std::__shared_weak_count *v45;
  uint64_t v46;

  v46 = *MEMORY[0x24BDAC8D0];
  dispatch_assert_queue_V2((dispatch_queue_t)a1->__get_deleter);
  if (LOBYTE(a1[2].__on_zero_shared_weak))
  {
    if (*(_QWORD *)(a2 + 8) - *(_QWORD *)a2 != 8)
      __TUAssertTrigger();
    if (*(_QWORD *)(a2 + 32) - *(_QWORD *)(a2 + 24) != 32)
      __TUAssertTrigger();
    memset(v28, 0, sizeof(v28));
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v28);
    v6 = qmi::MutableMessageBase::getTLV<sft::tlv::SecurityCredentials>(v28, 1);
    v7 = v6;
    v8 = *(_QWORD *)(a2 + 8);
    if (v8 != *(_QWORD *)a2)
      memmove(v6, *(const void **)a2, v8 - *(_QWORD *)a2);
    v9 = *(_BYTE **)(a2 + 24);
    v10 = *(_BYTE **)(a2 + 32);
    if (v10 != v9)
      memmove(v7 + 8, v9, v10 - v9);
    v37 = a1;
    v11 = v38;
    std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)v38, a3);
    dispatch_assert_queue_V2((dispatch_queue_t)a1->__get_deleter);
    v12 = (std::__shared_weak_count *)operator new(0x40uLL);
    v12->__shared_owners_ = 0;
    p_shared_owners = (unint64_t *)&v12->__shared_owners_;
    v12->__shared_weak_owners_ = 0;
    v12->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E1200;
    v12[1].__vftable = v37;
    std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)&v12[1].__shared_owners_, (uint64_t)v38);
    v34 = &v12[1].__vftable;
    v35 = v12;
    p_get_deleter = &a1[1].__get_deleter;
    v30 = QMIServiceMsg::create();
    v31 = 25000;
    v32 = 0;
    v33 = 0;
    v14 = MEMORY[0x24BDAC760];
    *(_QWORD *)buf = MEMORY[0x24BDAC760];
    v41 = 1174405120;
    v42 = ___ZN22QMIStewieCommandDriver4sendIN3sft17SetSecurityConfig7RequestEZNS_17setSecurityConfigERK25StewieSecurityCredentialsONSt3__18functionIFvbEEEE3__2EEvRKT_OT0__block_invoke;
    v43 = (uint8_t *)&__block_descriptor_tmp_58_4;
    v44 = &v12[1].__vftable;
    v45 = v12;
    do
      v15 = __ldxr(p_shared_owners);
    while (__stxr(v15 + 1, p_shared_owners));
    aBlock[0] = v14;
    aBlock[1] = 0x40000000;
    aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_24;
    aBlock[3] = &unk_24D5E09E8;
    aBlock[4] = buf;
    v16 = _Block_copy(aBlock);
    v33 = v16;
    if (v30)
    {
      qmi::Client::send();
      v16 = v33;
    }
    if (v16)
      _Block_release(v16);
    v17 = v45;
    if (v45)
    {
      v18 = (unint64_t *)&v45->__shared_owners_;
      do
        v19 = __ldaxr(v18);
      while (__stlxr(v19 - 1, v18));
      if (!v19)
      {
        ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
        std::__shared_weak_count::__release_weak(v17);
      }
    }
    v20 = v35;
    if (v35)
    {
      v21 = (unint64_t *)&v35->__shared_owners_;
      do
        v22 = __ldaxr(v21);
      while (__stlxr(v22 - 1, v21));
      if (!v22)
      {
        ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
        std::__shared_weak_count::__release_weak(v20);
      }
    }
    if (v39 == v38)
    {
      v23 = 4;
    }
    else
    {
      if (!v39)
      {
LABEL_31:
        qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v28);
        return;
      }
      v23 = 5;
      v11 = v39;
    }
    (*(void (**)(_QWORD *))(*v11 + 8 * v23))(v11);
    goto LABEL_31;
  }
  v24 = (uint64_t *)&a1->~__shared_weak_count_0;
  v25 = a1[1].~__shared_weak_count;
  if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl(&dword_216897000, v25, OS_LOG_TYPE_ERROR, "Failed to execute SetSecurityConfig. Client is not ready", buf, 2u);
  }
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)buf, a3);
  ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::setSecurityConfig(StewieSecurityCredentials const&,std::function<void ()(BOOL)> &&)::$_0>(v24, (uint64_t)buf);
  v26 = v43;
  if (v43 == buf)
  {
    v27 = 4;
    v26 = buf;
    goto LABEL_39;
  }
  if (v43)
  {
    v27 = 5;
LABEL_39:
    (*(void (**)(void))(*(_QWORD *)v26 + 8 * v27))();
  }
}

void sub_216A1EB08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,_QWORD *a30)
{
  _QWORD *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v34;

  v32 = v31;
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v32);
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)&a14);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a19);
  if (a30 == v30)
  {
    v34 = 4;
  }
  else
  {
    if (!a30)
      goto LABEL_6;
    v34 = 5;
    v30 = a30;
  }
  (*(void (**)(_QWORD *))(*v30 + 8 * v34))(v30);
LABEL_6:
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::setSecurityConfig(StewieSecurityCredentials const&,std::function<void ()(BOOL)> &&)::$_0>(uint64_t *a1, uint64_t a2)
{
  std::__shared_weak_count *v3;
  uint64_t v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  NSObject *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v3 = (std::__shared_weak_count *)a1[1];
  if (!v3 || (v5 = *a1, (v6 = std::__shared_weak_count::lock(v3)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v7 = v6;
  v8 = operator new();
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100](v8, a2);
  v9 = a1[2];
  p_shared_owners = (unint64_t *)&v7->__shared_owners_;
  do
    v11 = __ldxr(p_shared_owners);
  while (__stxr(v11 + 1, p_shared_owners));
  v12 = (_QWORD *)operator new();
  *v12 = v8;
  v12[1] = v5;
  v12[2] = v7;
  v14 = 0;
  v15 = 0;
  dispatch_async_f(v9, v12, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute_wrapped<QMIStewieCommandDriver::setSecurityConfig(StewieSecurityCredentials const&,std::function<void ()(BOOL)> &&)::$_0>(QMIStewieCommandDriver::setSecurityConfig(StewieSecurityCredentials const&,std::function<void ()(BOOL)> &&)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIStewieCommandDriver::setSecurityConfig(StewieSecurityCredentials const&,std::function<void ()(BOOL)> &&)::$_0,std::default_delete<QMIStewieCommandDriver::setSecurityConfig(StewieSecurityCredentials const&,std::function<void ()(BOOL)> &&)::$_0>>)::{lambda(void *)#1}::__invoke);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v14);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v15);
  do
    v13 = __ldaxr(p_shared_owners);
  while (__stlxr(v13 - 1, p_shared_owners));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
}

void QMIStewieCommandDriver::updateOrientation(std::__shared_weak_count_vtbl *a1, uint64_t a2, uint64_t a3)
{
  const void **v6;
  const void **v7;
  const void **v8;
  char *v9;
  _BYTE *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  char *v17;
  const void **v18;
  char *v19;
  char *v20;
  char *v21;
  const void *v22;
  char *v23;
  _BYTE *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  char *v31;
  const void **v32;
  char *v33;
  char *v34;
  char *v35;
  const void *v36;
  const void **i;
  char *v38;
  float *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  _QWORD *v43;
  uint64_t v44;
  unint64_t v45;
  unint64_t v46;
  char *v47;
  uint64_t *v48;
  char *v49;
  char *v50;
  char *v51;
  uint64_t v52;
  _QWORD *v53;
  std::__shared_weak_count *v54;
  unint64_t *p_shared_owners;
  uint64_t v56;
  unint64_t v57;
  void *v58;
  std::__shared_weak_count *v59;
  unint64_t *v60;
  unint64_t v61;
  std::__shared_weak_count *v62;
  unint64_t *v63;
  unint64_t v64;
  uint64_t v65;
  uint64_t *v66;
  NSObject *v67;
  uint8_t *v68;
  uint64_t v69;
  void *__p[2];
  __int128 v71;
  const void *(__cdecl **p_get_deleter)(const std::__shared_weak_count *__hidden, const std::type_info *);
  uint64_t v73;
  int v74;
  uint64_t v75;
  void *v76;
  _QWORD *v77;
  std::__shared_weak_count *v78;
  _QWORD aBlock[5];
  std::__shared_weak_count_vtbl *v80;
  _BYTE v81[24];
  _BYTE *v82;
  uint8_t buf[8];
  uint64_t v84;
  uint64_t (*v85)(uint64_t, uint64_t);
  uint8_t *v86;
  _QWORD *v87;
  std::__shared_weak_count *v88;
  uint64_t v89;

  v89 = *MEMORY[0x24BDAC8D0];
  dispatch_assert_queue_V2((dispatch_queue_t)a1->__get_deleter);
  if (LOBYTE(a1[2].__on_zero_shared_weak))
  {
    *(_OWORD *)__p = 0u;
    v71 = 0u;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
    v6 = (const void **)__p[1];
    v7 = (const void **)v71;
    v8 = (const void **)__p[1];
    if (__p[1] != (void *)v71)
    {
      v8 = (const void **)__p[1];
      while (*((_BYTE *)*v8 + 8) != 1)
      {
        if (++v8 == (const void **)v71)
          goto LABEL_10;
      }
    }
    if (v8 == (const void **)v71)
    {
LABEL_10:
      v11 = operator new();
      v12 = v11;
      *(_WORD *)(v11 + 8) = 1;
      *(_QWORD *)v11 = &off_24D5E1268;
      v13 = v71;
      if ((unint64_t)v71 >= *((_QWORD *)&v71 + 1))
      {
        v14 = (uint64_t)(v71 - (unint64_t)__p[1]) >> 3;
        if ((unint64_t)(v14 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v15 = (uint64_t)(*((_QWORD *)&v71 + 1) - (unint64_t)__p[1]) >> 2;
        if (v15 <= v14 + 1)
          v15 = v14 + 1;
        if (*((_QWORD *)&v71 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v16 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v16 = v15;
        if (v16)
          v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v71 + 8, v16);
        else
          v17 = 0;
        v18 = (const void **)&v17[8 * v14];
        v19 = &v17[8 * v16];
        *v18 = (const void *)v12;
        v7 = v18 + 1;
        v21 = (char *)__p[1];
        v20 = (char *)v71;
        if ((void *)v71 != __p[1])
        {
          do
          {
            v22 = (const void *)*((_QWORD *)v20 - 1);
            v20 -= 8;
            *--v18 = v22;
          }
          while (v20 != v21);
          v20 = (char *)__p[1];
        }
        __p[1] = v18;
        *(_QWORD *)&v71 = v7;
        *((_QWORD *)&v71 + 1) = v19;
        if (v20)
          operator delete(v20);
      }
      else
      {
        *(_QWORD *)v71 = v11;
        v7 = (const void **)(v13 + 8);
      }
      v10 = (_BYTE *)(v12 + 9);
      *(_QWORD *)&v71 = v7;
      v6 = (const void **)__p[1];
    }
    else
    {
      if (!v9)
        __cxa_bad_cast();
      v10 = v9 + 9;
    }
    *v10 = *(_BYTE *)(a2 + 8);
    while (v6 != v7)
    {
      if (*((_BYTE *)*v6 + 8) == 2)
      {
        if (v6 != v7)
        {
          if (!v23)
            __cxa_bad_cast();
          v24 = v23 + 9;
          goto LABEL_51;
        }
        break;
      }
      ++v6;
    }
    v25 = operator new();
    v26 = v25;
    *(_WORD *)(v25 + 8) = 2;
    *(_QWORD *)v25 = &off_24D5E12B8;
    v27 = v71;
    if ((unint64_t)v71 >= *((_QWORD *)&v71 + 1))
    {
      v28 = (uint64_t)(v71 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v28 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v29 = (uint64_t)(*((_QWORD *)&v71 + 1) - (unint64_t)__p[1]) >> 2;
      if (v29 <= v28 + 1)
        v29 = v28 + 1;
      if (*((_QWORD *)&v71 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v30 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v30 = v29;
      if (v30)
        v31 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v71 + 8, v30);
      else
        v31 = 0;
      v32 = (const void **)&v31[8 * v28];
      v33 = &v31[8 * v30];
      *v32 = (const void *)v26;
      v7 = v32 + 1;
      v35 = (char *)__p[1];
      v34 = (char *)v71;
      if ((void *)v71 != __p[1])
      {
        do
        {
          v36 = (const void *)*((_QWORD *)v34 - 1);
          v34 -= 8;
          *--v32 = v36;
        }
        while (v34 != v35);
        v34 = (char *)__p[1];
      }
      __p[1] = v32;
      *(_QWORD *)&v71 = v7;
      *((_QWORD *)&v71 + 1) = v33;
      if (v34)
        operator delete(v34);
    }
    else
    {
      *(_QWORD *)v71 = v25;
      v7 = (const void **)(v27 + 8);
    }
    v24 = (_BYTE *)(v26 + 9);
    *(_QWORD *)&v71 = v7;
LABEL_51:
    *v24 = *(_BYTE *)(a2 + 9);
    for (i = (const void **)__p[1]; i != v7; ++i)
    {
      if (*((_BYTE *)*i + 8) == 3)
      {
        if (i != v7)
        {
          if (!v38)
            __cxa_bad_cast();
          v39 = (float *)(v38 + 12);
          goto LABEL_75;
        }
        break;
      }
    }
    v40 = operator new();
    v41 = v40;
    *(_BYTE *)(v40 + 8) = 3;
    *(_QWORD *)v40 = &off_24D5E1308;
    *(_DWORD *)(v40 + 12) = 0;
    v39 = (float *)(v40 + 12);
    v42 = v71;
    if ((unint64_t)v71 >= *((_QWORD *)&v71 + 1))
    {
      v44 = (uint64_t)(v71 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v44 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v45 = (uint64_t)(*((_QWORD *)&v71 + 1) - (unint64_t)__p[1]) >> 2;
      if (v45 <= v44 + 1)
        v45 = v44 + 1;
      if (*((_QWORD *)&v71 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v46 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v46 = v45;
      if (v46)
        v47 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v71 + 8, v46);
      else
        v47 = 0;
      v48 = (uint64_t *)&v47[8 * v44];
      v49 = &v47[8 * v46];
      *v48 = v41;
      v43 = v48 + 1;
      v51 = (char *)__p[1];
      v50 = (char *)v71;
      if ((void *)v71 != __p[1])
      {
        do
        {
          v52 = *((_QWORD *)v50 - 1);
          v50 -= 8;
          *--v48 = v52;
        }
        while (v50 != v51);
        v50 = (char *)__p[1];
      }
      __p[1] = v48;
      *(_QWORD *)&v71 = v43;
      *((_QWORD *)&v71 + 1) = v49;
      if (v50)
        operator delete(v50);
    }
    else
    {
      *(_QWORD *)v71 = v40;
      v43 = (_QWORD *)(v42 + 8);
    }
    *(_QWORD *)&v71 = v43;
LABEL_75:
    *v39 = (float)*(int *)(a2 + 12);
    v80 = a1;
    v53 = v81;
    std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)v81, a3);
    dispatch_assert_queue_V2((dispatch_queue_t)a1->__get_deleter);
    v54 = (std::__shared_weak_count *)operator new(0x40uLL);
    v54->__shared_owners_ = 0;
    p_shared_owners = (unint64_t *)&v54->__shared_owners_;
    v54->__shared_weak_owners_ = 0;
    v54->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E1370;
    v54[1].__vftable = v80;
    std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)&v54[1].__shared_owners_, (uint64_t)v81);
    v77 = &v54[1].__vftable;
    v78 = v54;
    p_get_deleter = &a1[1].__get_deleter;
    v73 = QMIServiceMsg::create();
    v74 = 25000;
    v75 = 0;
    v76 = 0;
    v56 = MEMORY[0x24BDAC760];
    *(_QWORD *)buf = MEMORY[0x24BDAC760];
    v84 = 1174405120;
    v85 = ___ZN22QMIStewieCommandDriver4sendIN3sft23UpdateDeviceOrientation7RequestEZNS_17updateOrientationERK27StewieDeviceOrientationDataONSt3__18functionIFvbEEEE3__4EEvRKT_OT0__block_invoke;
    v86 = (uint8_t *)&__block_descriptor_tmp_59_7;
    v87 = &v54[1].__vftable;
    v88 = v54;
    do
      v57 = __ldxr(p_shared_owners);
    while (__stxr(v57 + 1, p_shared_owners));
    aBlock[0] = v56;
    aBlock[1] = 0x40000000;
    aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_24;
    aBlock[3] = &unk_24D5E09E8;
    aBlock[4] = buf;
    v58 = _Block_copy(aBlock);
    v76 = v58;
    if (v73)
    {
      qmi::Client::send();
      v58 = v76;
    }
    if (v58)
      _Block_release(v58);
    v59 = v88;
    if (v88)
    {
      v60 = (unint64_t *)&v88->__shared_owners_;
      do
        v61 = __ldaxr(v60);
      while (__stlxr(v61 - 1, v60));
      if (!v61)
      {
        ((void (*)(std::__shared_weak_count *))v59->__on_zero_shared)(v59);
        std::__shared_weak_count::__release_weak(v59);
      }
    }
    v62 = v78;
    if (v78)
    {
      v63 = (unint64_t *)&v78->__shared_owners_;
      do
        v64 = __ldaxr(v63);
      while (__stlxr(v64 - 1, v63));
      if (!v64)
      {
        ((void (*)(std::__shared_weak_count *))v62->__on_zero_shared)(v62);
        std::__shared_weak_count::__release_weak(v62);
      }
    }
    if (v82 == v81)
    {
      v65 = 4;
    }
    else
    {
      if (!v82)
      {
LABEL_96:
        qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
        return;
      }
      v65 = 5;
      v53 = v82;
    }
    (*(void (**)(_QWORD *))(*v53 + 8 * v65))(v53);
    goto LABEL_96;
  }
  v66 = (uint64_t *)&a1->~__shared_weak_count_0;
  v67 = a1[1].~__shared_weak_count;
  if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl(&dword_216897000, v67, OS_LOG_TYPE_ERROR, "Failed to execute UpdateDeviceOrientation. Client is not ready", buf, 2u);
  }
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)buf, a3);
  ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::updateOrientation(StewieDeviceOrientationData const&,std::function<void ()(BOOL)> &&)::$_0>(v66, (uint64_t)buf);
  v68 = v86;
  if (v86 == buf)
  {
    v69 = 4;
    v68 = buf;
    goto LABEL_104;
  }
  if (v86)
  {
    v69 = 5;
LABEL_104:
    (*(void (**)(void))(*(_QWORD *)v68 + 8 * v69))();
  }
}

void sub_216A1F390(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,_QWORD *a30)
{
  _QWORD *v30;
  uint64_t v31;
  uint64_t v33;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v31);
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)&a14);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a19);
  if (a30 == v30)
  {
    v33 = 4;
  }
  else
  {
    if (!a30)
      goto LABEL_6;
    v33 = 5;
    v30 = a30;
  }
  (*(void (**)(_QWORD *))(*v30 + 8 * v33))(v30);
LABEL_6:
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::updateOrientation(StewieDeviceOrientationData const&,std::function<void ()(BOOL)> &&)::$_0>(uint64_t *a1, uint64_t a2)
{
  std::__shared_weak_count *v3;
  uint64_t v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  NSObject *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v3 = (std::__shared_weak_count *)a1[1];
  if (!v3 || (v5 = *a1, (v6 = std::__shared_weak_count::lock(v3)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v7 = v6;
  v8 = operator new();
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100](v8, a2);
  v9 = a1[2];
  p_shared_owners = (unint64_t *)&v7->__shared_owners_;
  do
    v11 = __ldxr(p_shared_owners);
  while (__stxr(v11 + 1, p_shared_owners));
  v12 = (_QWORD *)operator new();
  *v12 = v8;
  v12[1] = v5;
  v12[2] = v7;
  v14 = 0;
  v15 = 0;
  dispatch_async_f(v9, v12, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute_wrapped<QMIStewieCommandDriver::updateOrientation(StewieDeviceOrientationData const&,std::function<void ()(BOOL)> &&)::$_0>(QMIStewieCommandDriver::updateOrientation(StewieDeviceOrientationData const&,std::function<void ()(BOOL)> &&)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIStewieCommandDriver::updateOrientation(StewieDeviceOrientationData const&,std::function<void ()(BOOL)> &&)::$_0,std::default_delete<QMIStewieCommandDriver::updateOrientation(StewieDeviceOrientationData const&,std::function<void ()(BOOL)> &&)::$_0>>)::{lambda(void *)#1}::__invoke);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v14);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v15);
  do
    v13 = __ldaxr(p_shared_owners);
  while (__stlxr(v13 - 1, p_shared_owners));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
}

void QMIStewieCommandDriver::sendMessage(std::__shared_weak_count_vtbl *a1, CFUUIDRef *a2, char **a3, int a4, uint64_t a5)
{
  CFUUIDBytes *v10;
  const void **v11;
  const void **v12;
  char *v13;
  char **v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  char *v21;
  const void **v22;
  char *v23;
  char *v24;
  char *v25;
  const void *v26;
  const void **i;
  char *v28;
  int *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  _QWORD *v33;
  uint64_t v34;
  unint64_t v35;
  unint64_t v36;
  char *v37;
  uint64_t *v38;
  char *v39;
  char *v40;
  char *v41;
  uint64_t v42;
  int v43;
  _QWORD *v44;
  std::__shared_weak_count *v45;
  unint64_t *p_shared_owners;
  uint64_t v47;
  unint64_t v48;
  void *v49;
  std::__shared_weak_count *v50;
  unint64_t *v51;
  unint64_t v52;
  std::__shared_weak_count *v53;
  unint64_t *v54;
  unint64_t v55;
  uint64_t v56;
  uint64_t *v57;
  NSObject *v58;
  uint8_t *v59;
  uint64_t v60;
  void *__p[2];
  __int128 v62;
  const void *(__cdecl **p_get_deleter)(const std::__shared_weak_count *__hidden, const std::type_info *);
  uint64_t v64;
  int v65;
  uint64_t v66;
  void *v67;
  _QWORD *v68;
  std::__shared_weak_count *v69;
  _QWORD aBlock[5];
  std::__shared_weak_count_vtbl *v71;
  _BYTE v72[24];
  _BYTE *v73;
  uint8_t buf[8];
  uint64_t v75;
  uint64_t (*v76)(uint64_t, uint64_t);
  uint8_t *v77;
  _QWORD *v78;
  std::__shared_weak_count *v79;
  uint64_t v80;

  v80 = *MEMORY[0x24BDAC8D0];
  dispatch_assert_queue_V2((dispatch_queue_t)a1->__get_deleter);
  if (LOBYTE(a1[2].__on_zero_shared_weak))
  {
    *(_OWORD *)__p = 0u;
    v62 = 0u;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
    v10 = (CFUUIDBytes *)qmi::MutableMessageBase::getTLV<sft::tlv::GUID>(__p, 1);
    *v10 = CFUUIDGetUUIDBytes(*a2);
    v11 = (const void **)__p[1];
    v12 = (const void **)v62;
    if (__p[1] != (void *)v62)
    {
      while (*((_BYTE *)*v11 + 8) != 2)
      {
        if (++v11 == (const void **)v62)
          goto LABEL_9;
      }
    }
    if (v11 == (const void **)v62)
    {
LABEL_9:
      v15 = operator new();
      v16 = v15;
      *(_BYTE *)(v15 + 8) = 2;
      *(_QWORD *)(v15 + 16) = 0;
      v14 = (char **)(v15 + 16);
      *(_QWORD *)v15 = &off_24D5E1428;
      *(_QWORD *)(v15 + 24) = 0;
      *(_QWORD *)(v15 + 32) = 0;
      v17 = v62;
      if ((unint64_t)v62 >= *((_QWORD *)&v62 + 1))
      {
        v18 = (uint64_t)(v62 - (unint64_t)__p[1]) >> 3;
        if ((unint64_t)(v18 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v19 = (uint64_t)(*((_QWORD *)&v62 + 1) - (unint64_t)__p[1]) >> 2;
        if (v19 <= v18 + 1)
          v19 = v18 + 1;
        if (*((_QWORD *)&v62 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v20 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v20 = v19;
        if (v20)
          v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v62 + 8, v20);
        else
          v21 = 0;
        v22 = (const void **)&v21[8 * v18];
        v23 = &v21[8 * v20];
        *v22 = (const void *)v16;
        v12 = v22 + 1;
        v25 = (char *)__p[1];
        v24 = (char *)v62;
        if ((void *)v62 != __p[1])
        {
          do
          {
            v26 = (const void *)*((_QWORD *)v24 - 1);
            v24 -= 8;
            *--v22 = v26;
          }
          while (v24 != v25);
          v24 = (char *)__p[1];
        }
        __p[1] = v22;
        *(_QWORD *)&v62 = v12;
        *((_QWORD *)&v62 + 1) = v23;
        if (v24)
          operator delete(v24);
      }
      else
      {
        *(_QWORD *)v62 = v15;
        v12 = (const void **)(v17 + 8);
      }
      *(_QWORD *)&v62 = v12;
    }
    else
    {
      if (!v13)
        __cxa_bad_cast();
      v14 = (char **)(v13 + 16);
    }
    if (v14 != a3)
    {
      std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(v14, *a3, a3[1], a3[1] - *a3);
      v12 = (const void **)v62;
    }
    for (i = (const void **)__p[1]; i != v12; ++i)
    {
      if (*((_BYTE *)*i + 8) == 16)
      {
        if (i != v12)
        {
          if (!v28)
            __cxa_bad_cast();
          v29 = (int *)(v28 + 12);
          goto LABEL_52;
        }
        break;
      }
    }
    v30 = operator new();
    v31 = v30;
    *(_BYTE *)(v30 + 8) = 16;
    *(_QWORD *)v30 = &off_24D5E1478;
    *(_DWORD *)(v30 + 12) = 0;
    v29 = (int *)(v30 + 12);
    v32 = v62;
    if ((unint64_t)v62 >= *((_QWORD *)&v62 + 1))
    {
      v34 = (uint64_t)(v62 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v34 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v35 = (uint64_t)(*((_QWORD *)&v62 + 1) - (unint64_t)__p[1]) >> 2;
      if (v35 <= v34 + 1)
        v35 = v34 + 1;
      if (*((_QWORD *)&v62 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v36 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v36 = v35;
      if (v36)
        v37 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v62 + 8, v36);
      else
        v37 = 0;
      v38 = (uint64_t *)&v37[8 * v34];
      v39 = &v37[8 * v36];
      *v38 = v31;
      v33 = v38 + 1;
      v41 = (char *)__p[1];
      v40 = (char *)v62;
      if ((void *)v62 != __p[1])
      {
        do
        {
          v42 = *((_QWORD *)v40 - 1);
          v40 -= 8;
          *--v38 = v42;
        }
        while (v40 != v41);
        v40 = (char *)__p[1];
      }
      __p[1] = v38;
      *(_QWORD *)&v62 = v33;
      *((_QWORD *)&v62 + 1) = v39;
      if (v40)
        operator delete(v40);
    }
    else
    {
      *(_QWORD *)v62 = v30;
      v33 = (_QWORD *)(v32 + 8);
    }
    *(_QWORD *)&v62 = v33;
LABEL_52:
    if (a4 == 1)
      v43 = 1;
    else
      v43 = 2;
    if (a4 == 2)
      v43 = 0;
    *v29 = v43;
    v71 = a1;
    v44 = v72;
    std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)v72, a5);
    dispatch_assert_queue_V2((dispatch_queue_t)a1->__get_deleter);
    v45 = (std::__shared_weak_count *)operator new(0x40uLL);
    v45->__shared_owners_ = 0;
    p_shared_owners = (unint64_t *)&v45->__shared_owners_;
    v45->__shared_weak_owners_ = 0;
    v45->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E14E0;
    v45[1].__vftable = v71;
    std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)&v45[1].__shared_owners_, (uint64_t)v72);
    v68 = &v45[1].__vftable;
    v69 = v45;
    p_get_deleter = &a1[1].__get_deleter;
    v64 = QMIServiceMsg::create();
    v65 = 25000;
    v66 = 0;
    v67 = 0;
    v47 = MEMORY[0x24BDAC760];
    *(_QWORD *)buf = MEMORY[0x24BDAC760];
    v75 = 1174405120;
    v76 = ___ZN22QMIStewieCommandDriver4sendIN3sft9MessageTX7RequestEZNS_11sendMessageERKN3ctu2cf11CFSharedRefIK8__CFUUIDEERKNSt3__16vectorIhNSC_9allocatorIhEEEE24StewieTrafficQosPriorityONSC_8functionIFvbEEEE3__4EEvRKT_OT0__block_invoke;
    v77 = (uint8_t *)&__block_descriptor_tmp_60_5;
    v78 = &v45[1].__vftable;
    v79 = v45;
    do
      v48 = __ldxr(p_shared_owners);
    while (__stxr(v48 + 1, p_shared_owners));
    aBlock[0] = v47;
    aBlock[1] = 0x40000000;
    aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_24;
    aBlock[3] = &unk_24D5E09E8;
    aBlock[4] = buf;
    v49 = _Block_copy(aBlock);
    v67 = v49;
    if (v64)
    {
      qmi::Client::send();
      v49 = v67;
    }
    if (v49)
      _Block_release(v49);
    v50 = v79;
    if (v79)
    {
      v51 = (unint64_t *)&v79->__shared_owners_;
      do
        v52 = __ldaxr(v51);
      while (__stlxr(v52 - 1, v51));
      if (!v52)
      {
        ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
        std::__shared_weak_count::__release_weak(v50);
      }
    }
    v53 = v69;
    if (v69)
    {
      v54 = (unint64_t *)&v69->__shared_owners_;
      do
        v55 = __ldaxr(v54);
      while (__stlxr(v55 - 1, v54));
      if (!v55)
      {
        ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
        std::__shared_weak_count::__release_weak(v53);
      }
    }
    if (v73 == v72)
    {
      v56 = 4;
    }
    else
    {
      if (!v73)
      {
LABEL_78:
        qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
        return;
      }
      v56 = 5;
      v44 = v73;
    }
    (*(void (**)(_QWORD *))(*v44 + 8 * v56))(v44);
    goto LABEL_78;
  }
  v57 = (uint64_t *)&a1->~__shared_weak_count_0;
  v58 = a1[1].~__shared_weak_count;
  if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl(&dword_216897000, v58, OS_LOG_TYPE_ERROR, "Failed to execute MessageTX. Client is not ready", buf, 2u);
  }
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)buf, a5);
  ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::sendMessage(ctu::cf::CFSharedRef<__CFUUID const> const&,std::vector<unsigned char> const&,StewieTrafficQosPriority,std::function<void ()(BOOL)> &&)::$_0>(v57, (uint64_t)buf);
  v59 = v77;
  if (v77 == buf)
  {
    v60 = 4;
    v59 = buf;
    goto LABEL_86;
  }
  if (v77)
  {
    v60 = 5;
LABEL_86:
    (*(void (**)(void))(*(_QWORD *)v59 + 8 * v60))();
  }
}

void sub_216A1FB94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,_QWORD *a30)
{
  _QWORD *v30;
  uint64_t v31;
  uint64_t v33;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v31);
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)&a14);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a19);
  if (a30 == v30)
  {
    v33 = 4;
  }
  else
  {
    if (!a30)
      goto LABEL_6;
    v33 = 5;
    v30 = a30;
  }
  (*(void (**)(_QWORD *))(*v30 + 8 * v33))(v30);
LABEL_6:
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::sendMessage(ctu::cf::CFSharedRef<__CFUUID const> const&,std::vector<unsigned char> const&,StewieTrafficQosPriority,std::function<void ()(BOOL)> &&)::$_0>(uint64_t *a1, uint64_t a2)
{
  std::__shared_weak_count *v3;
  uint64_t v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  NSObject *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v3 = (std::__shared_weak_count *)a1[1];
  if (!v3 || (v5 = *a1, (v6 = std::__shared_weak_count::lock(v3)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v7 = v6;
  v8 = operator new();
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100](v8, a2);
  v9 = a1[2];
  p_shared_owners = (unint64_t *)&v7->__shared_owners_;
  do
    v11 = __ldxr(p_shared_owners);
  while (__stxr(v11 + 1, p_shared_owners));
  v12 = (_QWORD *)operator new();
  *v12 = v8;
  v12[1] = v5;
  v12[2] = v7;
  v14 = 0;
  v15 = 0;
  dispatch_async_f(v9, v12, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute_wrapped<QMIStewieCommandDriver::sendMessage(ctu::cf::CFSharedRef<__CFUUID const> const&,std::vector<unsigned char> const&,StewieTrafficQosPriority,std::function<void ()(BOOL)> &&)::$_0>(QMIStewieCommandDriver::sendMessage(ctu::cf::CFSharedRef<__CFUUID const> const&,std::vector<unsigned char> const&,StewieTrafficQosPriority,std::function<void ()(BOOL)> &&)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIStewieCommandDriver::sendMessage(ctu::cf::CFSharedRef<__CFUUID const> const&,std::vector<unsigned char> const&,StewieTrafficQosPriority,std::function<void ()(BOOL)> &&)::$_0,std::default_delete<QMIStewieCommandDriver::sendMessage(ctu::cf::CFSharedRef<__CFUUID const> const&,std::vector<unsigned char> const&,StewieTrafficQosPriority,std::function<void ()(BOOL)> &&)::$_0>>)::{lambda(void *)#1}::__invoke);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v14);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v15);
  do
    v13 = __ldaxr(p_shared_owners);
  while (__stlxr(v13 - 1, p_shared_owners));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
}

void QMIStewieCommandDriver::cancelMessageTx(std::__shared_weak_count_vtbl *a1, CFUUIDRef *a2, uint64_t a3)
{
  const void **v6;
  char *v7;
  _BYTE *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  char *v16;
  uint64_t *v17;
  char *v18;
  char *v19;
  char *v20;
  uint64_t v21;
  CFUUIDBytes *v22;
  _QWORD *v23;
  std::__shared_weak_count *v24;
  unint64_t *p_shared_owners;
  uint64_t v26;
  unint64_t v27;
  void *v28;
  std::__shared_weak_count *v29;
  unint64_t *v30;
  unint64_t v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t *v36;
  NSObject *v37;
  uint8_t *v38;
  uint64_t v39;
  void *__p[2];
  __int128 v41;
  const void *(__cdecl **p_get_deleter)(const std::__shared_weak_count *__hidden, const std::type_info *);
  uint64_t v43;
  int v44;
  uint64_t v45;
  void *v46;
  _QWORD *v47;
  std::__shared_weak_count *v48;
  _QWORD aBlock[5];
  std::__shared_weak_count_vtbl *v50;
  _BYTE v51[24];
  _BYTE *v52;
  uint8_t buf[8];
  uint64_t v54;
  uint64_t (*v55)(uint64_t, uint64_t);
  uint8_t *v56;
  _QWORD *v57;
  std::__shared_weak_count *v58;
  uint64_t v59;

  v59 = *MEMORY[0x24BDAC8D0];
  dispatch_assert_queue_V2((dispatch_queue_t)a1->__get_deleter);
  if (LOBYTE(a1[2].__on_zero_shared_weak))
  {
    *(_OWORD *)__p = 0u;
    v41 = 0u;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
    v6 = (const void **)__p[1];
    if (__p[1] != (void *)v41)
    {
      while (*((_BYTE *)*v6 + 8) != 1)
      {
        if (++v6 == (const void **)v41)
          goto LABEL_9;
      }
    }
    if (v6 == (const void **)v41)
    {
LABEL_9:
      v9 = operator new();
      v10 = v9;
      *(_WORD *)(v9 + 8) = 1;
      *(_QWORD *)v9 = &off_24D5E1548;
      v11 = v41;
      if ((unint64_t)v41 >= *((_QWORD *)&v41 + 1))
      {
        v13 = (uint64_t)(v41 - (unint64_t)__p[1]) >> 3;
        if ((unint64_t)(v13 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v14 = (uint64_t)(*((_QWORD *)&v41 + 1) - (unint64_t)__p[1]) >> 2;
        if (v14 <= v13 + 1)
          v14 = v13 + 1;
        if (*((_QWORD *)&v41 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v15 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v15 = v14;
        if (v15)
          v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v41 + 8, v15);
        else
          v16 = 0;
        v17 = (uint64_t *)&v16[8 * v13];
        v18 = &v16[8 * v15];
        *v17 = v10;
        v12 = v17 + 1;
        v20 = (char *)__p[1];
        v19 = (char *)v41;
        if ((void *)v41 != __p[1])
        {
          do
          {
            v21 = *((_QWORD *)v19 - 1);
            v19 -= 8;
            *--v17 = v21;
          }
          while (v19 != v20);
          v19 = (char *)__p[1];
        }
        __p[1] = v17;
        *(_QWORD *)&v41 = v12;
        *((_QWORD *)&v41 + 1) = v18;
        if (v19)
          operator delete(v19);
      }
      else
      {
        *(_QWORD *)v41 = v9;
        v12 = (_QWORD *)(v11 + 8);
      }
      v8 = (_BYTE *)(v10 + 9);
      *(_QWORD *)&v41 = v12;
    }
    else
    {
      if (!v7)
        __cxa_bad_cast();
      v8 = v7 + 9;
    }
    *v8 = 0;
    v22 = (CFUUIDBytes *)qmi::MutableMessageBase::getTLV<sft::tlv::GUID>(__p, 16);
    *v22 = CFUUIDGetUUIDBytes(*a2);
    v23 = v51;
    v50 = a1;
    std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)v51, a3);
    dispatch_assert_queue_V2((dispatch_queue_t)a1->__get_deleter);
    v24 = (std::__shared_weak_count *)operator new(0x40uLL);
    v24->__shared_owners_ = 0;
    p_shared_owners = (unint64_t *)&v24->__shared_owners_;
    v24->__shared_weak_owners_ = 0;
    v24->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E15B0;
    v24[1].__vftable = v50;
    std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)&v24[1].__shared_owners_, (uint64_t)v51);
    v47 = &v24[1].__vftable;
    v48 = v24;
    p_get_deleter = &a1[1].__get_deleter;
    v43 = QMIServiceMsg::create();
    v44 = 25000;
    v45 = 0;
    v46 = 0;
    v26 = MEMORY[0x24BDAC760];
    *(_QWORD *)buf = MEMORY[0x24BDAC760];
    v54 = 1174405120;
    v55 = ___ZN22QMIStewieCommandDriver4sendIN3sft15CancelMessageTX7RequestEZNS_15cancelMessageTxERKN3ctu2cf11CFSharedRefIK8__CFUUIDEEONSt3__18functionIFvbEEEE3__3EEvRKT_OT0__block_invoke;
    v56 = (uint8_t *)&__block_descriptor_tmp_61_6;
    v57 = &v24[1].__vftable;
    v58 = v24;
    do
      v27 = __ldxr(p_shared_owners);
    while (__stxr(v27 + 1, p_shared_owners));
    aBlock[0] = v26;
    aBlock[1] = 0x40000000;
    aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_24;
    aBlock[3] = &unk_24D5E09E8;
    aBlock[4] = buf;
    v28 = _Block_copy(aBlock);
    v46 = v28;
    if (v43)
    {
      qmi::Client::send();
      v28 = v46;
    }
    if (v28)
      _Block_release(v28);
    v29 = v58;
    if (v58)
    {
      v30 = (unint64_t *)&v58->__shared_owners_;
      do
        v31 = __ldaxr(v30);
      while (__stlxr(v31 - 1, v30));
      if (!v31)
      {
        ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
        std::__shared_weak_count::__release_weak(v29);
      }
    }
    v32 = v48;
    if (v48)
    {
      v33 = (unint64_t *)&v48->__shared_owners_;
      do
        v34 = __ldaxr(v33);
      while (__stlxr(v34 - 1, v33));
      if (!v34)
      {
        ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
        std::__shared_weak_count::__release_weak(v32);
      }
    }
    if (v52 == v51)
    {
      v35 = 4;
    }
    else
    {
      if (!v52)
      {
LABEL_47:
        qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
        return;
      }
      v35 = 5;
      v23 = v52;
    }
    (*(void (**)(_QWORD *))(*v23 + 8 * v35))(v23);
    goto LABEL_47;
  }
  v36 = (uint64_t *)&a1->~__shared_weak_count_0;
  v37 = a1[1].~__shared_weak_count;
  if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl(&dword_216897000, v37, OS_LOG_TYPE_ERROR, "Failed to execute CancelMessageTX. Client is not ready", buf, 2u);
  }
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)buf, a3);
  ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::cancelMessageTx(ctu::cf::CFSharedRef<__CFUUID const> const&,std::function<void ()(BOOL)> &&)::$_0>(v36, (uint64_t)buf);
  v38 = v56;
  if (v56 == buf)
  {
    v39 = 4;
    v38 = buf;
    goto LABEL_55;
  }
  if (v56)
  {
    v39 = 5;
LABEL_55:
    (*(void (**)(void))(*(_QWORD *)v38 + 8 * v39))();
  }
}

void sub_216A20208(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,_QWORD *a30)
{
  _QWORD *v30;
  uint64_t v31;
  uint64_t v33;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v31);
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)&a14);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a19);
  if (a30 == v30)
  {
    v33 = 4;
  }
  else
  {
    if (!a30)
      goto LABEL_6;
    v33 = 5;
    v30 = a30;
  }
  (*(void (**)(_QWORD *))(*v30 + 8 * v33))(v30);
LABEL_6:
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::cancelMessageTx(ctu::cf::CFSharedRef<__CFUUID const> const&,std::function<void ()(BOOL)> &&)::$_0>(uint64_t *a1, uint64_t a2)
{
  std::__shared_weak_count *v3;
  uint64_t v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  NSObject *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v3 = (std::__shared_weak_count *)a1[1];
  if (!v3 || (v5 = *a1, (v6 = std::__shared_weak_count::lock(v3)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v7 = v6;
  v8 = operator new();
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100](v8, a2);
  v9 = a1[2];
  p_shared_owners = (unint64_t *)&v7->__shared_owners_;
  do
    v11 = __ldxr(p_shared_owners);
  while (__stxr(v11 + 1, p_shared_owners));
  v12 = (_QWORD *)operator new();
  *v12 = v8;
  v12[1] = v5;
  v12[2] = v7;
  v14 = 0;
  v15 = 0;
  dispatch_async_f(v9, v12, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute_wrapped<QMIStewieCommandDriver::cancelMessageTx(ctu::cf::CFSharedRef<__CFUUID const> const&,std::function<void ()(BOOL)> &&)::$_0>(QMIStewieCommandDriver::cancelMessageTx(ctu::cf::CFSharedRef<__CFUUID const> const&,std::function<void ()(BOOL)> &&)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIStewieCommandDriver::cancelMessageTx(ctu::cf::CFSharedRef<__CFUUID const> const&,std::function<void ()(BOOL)> &&)::$_0,std::default_delete<QMIStewieCommandDriver::cancelMessageTx(ctu::cf::CFSharedRef<__CFUUID const> const&,std::function<void ()(BOOL)> &&)::$_0>>)::{lambda(void *)#1}::__invoke);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v14);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v15);
  do
    v13 = __ldaxr(p_shared_owners);
  while (__stlxr(v13 - 1, p_shared_owners));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
}

void QMIStewieCommandDriver::ackReceivedMessage(std::__shared_weak_count_vtbl *a1, __int16 a2, uint64_t a3)
{
  const void **v6;
  char *v7;
  _WORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  char *v16;
  uint64_t *v17;
  char *v18;
  char *v19;
  char *v20;
  uint64_t v21;
  _QWORD *v22;
  std::__shared_weak_count *v23;
  unint64_t *p_shared_owners;
  uint64_t v25;
  unint64_t v26;
  void *v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t *v35;
  NSObject *v36;
  uint8_t *v37;
  uint64_t v38;
  void *__p[2];
  __int128 v40;
  const void *(__cdecl **p_get_deleter)(const std::__shared_weak_count *__hidden, const std::type_info *);
  uint64_t v42;
  int v43;
  uint64_t v44;
  void *v45;
  _QWORD *v46;
  std::__shared_weak_count *v47;
  _QWORD aBlock[5];
  std::__shared_weak_count_vtbl *v49;
  _BYTE v50[24];
  _BYTE *v51;
  uint8_t buf[8];
  uint64_t v53;
  uint64_t (*v54)(uint64_t, uint64_t);
  uint8_t *v55;
  _QWORD *v56;
  std::__shared_weak_count *v57;
  uint64_t v58;

  v58 = *MEMORY[0x24BDAC8D0];
  dispatch_assert_queue_V2((dispatch_queue_t)a1->__get_deleter);
  if (LOBYTE(a1[2].__on_zero_shared_weak))
  {
    *(_OWORD *)__p = 0u;
    v40 = 0u;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
    v6 = (const void **)__p[1];
    if (__p[1] != (void *)v40)
    {
      while (*((_BYTE *)*v6 + 8) != 1)
      {
        if (++v6 == (const void **)v40)
          goto LABEL_9;
      }
    }
    if (v6 == (const void **)v40)
    {
LABEL_9:
      v9 = operator new();
      v10 = v9;
      *(_BYTE *)(v9 + 8) = 1;
      *(_QWORD *)v9 = &off_24D5E1618;
      *(_WORD *)(v9 + 10) = 0;
      v8 = (_WORD *)(v9 + 10);
      v11 = v40;
      if ((unint64_t)v40 >= *((_QWORD *)&v40 + 1))
      {
        v13 = (uint64_t)(v40 - (unint64_t)__p[1]) >> 3;
        if ((unint64_t)(v13 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v14 = (uint64_t)(*((_QWORD *)&v40 + 1) - (unint64_t)__p[1]) >> 2;
        if (v14 <= v13 + 1)
          v14 = v13 + 1;
        if (*((_QWORD *)&v40 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v15 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v15 = v14;
        if (v15)
          v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v40 + 8, v15);
        else
          v16 = 0;
        v17 = (uint64_t *)&v16[8 * v13];
        v18 = &v16[8 * v15];
        *v17 = v10;
        v12 = v17 + 1;
        v20 = (char *)__p[1];
        v19 = (char *)v40;
        if ((void *)v40 != __p[1])
        {
          do
          {
            v21 = *((_QWORD *)v19 - 1);
            v19 -= 8;
            *--v17 = v21;
          }
          while (v19 != v20);
          v19 = (char *)__p[1];
        }
        __p[1] = v17;
        *(_QWORD *)&v40 = v12;
        *((_QWORD *)&v40 + 1) = v18;
        if (v19)
          operator delete(v19);
      }
      else
      {
        *(_QWORD *)v40 = v9;
        v12 = (_QWORD *)(v11 + 8);
      }
      *(_QWORD *)&v40 = v12;
    }
    else
    {
      if (!v7)
        __cxa_bad_cast();
      v8 = v7 + 10;
    }
    *v8 = a2;
    v49 = a1;
    v22 = v50;
    std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)v50, a3);
    dispatch_assert_queue_V2((dispatch_queue_t)a1->__get_deleter);
    v23 = (std::__shared_weak_count *)operator new(0x40uLL);
    v23->__shared_owners_ = 0;
    p_shared_owners = (unint64_t *)&v23->__shared_owners_;
    v23->__shared_weak_owners_ = 0;
    v23->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E1680;
    v23[1].__vftable = v49;
    std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)&v23[1].__shared_owners_, (uint64_t)v50);
    v46 = &v23[1].__vftable;
    v47 = v23;
    p_get_deleter = &a1[1].__get_deleter;
    v42 = QMIServiceMsg::create();
    v43 = 25000;
    v44 = 0;
    v45 = 0;
    v25 = MEMORY[0x24BDAC760];
    *(_QWORD *)buf = MEMORY[0x24BDAC760];
    v53 = 1174405120;
    v54 = ___ZN22QMIStewieCommandDriver4sendIN3sft12MessageRXAck7RequestEZNS_18ackReceivedMessageEtONSt3__18functionIFvbEEEE3__2EEvRKT_OT0__block_invoke;
    v55 = (uint8_t *)&__block_descriptor_tmp_62_6;
    v56 = &v23[1].__vftable;
    v57 = v23;
    do
      v26 = __ldxr(p_shared_owners);
    while (__stxr(v26 + 1, p_shared_owners));
    aBlock[0] = v25;
    aBlock[1] = 0x40000000;
    aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_24;
    aBlock[3] = &unk_24D5E09E8;
    aBlock[4] = buf;
    v27 = _Block_copy(aBlock);
    v45 = v27;
    if (v42)
    {
      qmi::Client::send();
      v27 = v45;
    }
    if (v27)
      _Block_release(v27);
    v28 = v57;
    if (v57)
    {
      v29 = (unint64_t *)&v57->__shared_owners_;
      do
        v30 = __ldaxr(v29);
      while (__stlxr(v30 - 1, v29));
      if (!v30)
      {
        ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
        std::__shared_weak_count::__release_weak(v28);
      }
    }
    v31 = v47;
    if (v47)
    {
      v32 = (unint64_t *)&v47->__shared_owners_;
      do
        v33 = __ldaxr(v32);
      while (__stlxr(v33 - 1, v32));
      if (!v33)
      {
        ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
        std::__shared_weak_count::__release_weak(v31);
      }
    }
    if (v51 == v50)
    {
      v34 = 4;
    }
    else
    {
      if (!v51)
      {
LABEL_47:
        qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
        return;
      }
      v34 = 5;
      v22 = v51;
    }
    (*(void (**)(_QWORD *))(*v22 + 8 * v34))(v22);
    goto LABEL_47;
  }
  v35 = (uint64_t *)&a1->~__shared_weak_count_0;
  v36 = a1[1].~__shared_weak_count;
  if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl(&dword_216897000, v36, OS_LOG_TYPE_ERROR, "Failed to execute MessageRXAck. Client is not ready", buf, 2u);
  }
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)buf, a3);
  ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::ackReceivedMessage(unsigned short,std::function<void ()(BOOL)> &&)::$_0>(v35, (uint64_t)buf);
  v37 = v55;
  if (v55 == buf)
  {
    v38 = 4;
    v37 = buf;
    goto LABEL_55;
  }
  if (v55)
  {
    v38 = 5;
LABEL_55:
    (*(void (**)(void))(*(_QWORD *)v37 + 8 * v38))();
  }
}

void sub_216A207EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,_QWORD *a30)
{
  _QWORD *v30;
  uint64_t v31;
  uint64_t v33;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v31);
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)&a14);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a19);
  if (a30 == v30)
  {
    v33 = 4;
  }
  else
  {
    if (!a30)
      goto LABEL_6;
    v33 = 5;
    v30 = a30;
  }
  (*(void (**)(_QWORD *))(*v30 + 8 * v33))(v30);
LABEL_6:
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::ackReceivedMessage(unsigned short,std::function<void ()(BOOL)> &&)::$_0>(uint64_t *a1, uint64_t a2)
{
  std::__shared_weak_count *v3;
  uint64_t v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  NSObject *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v3 = (std::__shared_weak_count *)a1[1];
  if (!v3 || (v5 = *a1, (v6 = std::__shared_weak_count::lock(v3)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v7 = v6;
  v8 = operator new();
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100](v8, a2);
  v9 = a1[2];
  p_shared_owners = (unint64_t *)&v7->__shared_owners_;
  do
    v11 = __ldxr(p_shared_owners);
  while (__stxr(v11 + 1, p_shared_owners));
  v12 = (_QWORD *)operator new();
  *v12 = v8;
  v12[1] = v5;
  v12[2] = v7;
  v14 = 0;
  v15 = 0;
  dispatch_async_f(v9, v12, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute_wrapped<QMIStewieCommandDriver::ackReceivedMessage(unsigned short,std::function<void ()(BOOL)> &&)::$_0>(QMIStewieCommandDriver::ackReceivedMessage(unsigned short,std::function<void ()(BOOL)> &&)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIStewieCommandDriver::ackReceivedMessage(unsigned short,std::function<void ()(BOOL)> &&)::$_0,std::default_delete<QMIStewieCommandDriver::ackReceivedMessage(unsigned short,std::function<void ()(BOOL)> &&)::$_0>>)::{lambda(void *)#1}::__invoke);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v14);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v15);
  do
    v13 = __ldaxr(p_shared_owners);
  while (__stlxr(v13 - 1, p_shared_owners));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
}

void QMIStewieCommandDriver::sendFileSegment(uint64_t a1, int a2, unsigned int a3, unsigned int a4, char **a5, uint64_t a6)
{
  char *v12;
  char *v13;
  const void **v14;
  char *v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  char *v24;
  uint64_t *v25;
  char *v26;
  char *v27;
  char *v28;
  uint64_t v29;
  char v30;
  _QWORD *v31;
  _QWORD *v32;
  unint64_t *v33;
  uint64_t v34;
  unint64_t v35;
  void *v36;
  std::__shared_weak_count *v37;
  unint64_t *p_shared_owners;
  unint64_t v39;
  std::__shared_weak_count *v40;
  unint64_t *v41;
  unint64_t v42;
  uint64_t v43;
  uint64_t *v44;
  NSObject *v45;
  uint8_t *v46;
  uint64_t v47;
  void *__p[2];
  __int128 v49;
  uint64_t v50;
  uint64_t v51;
  int v52;
  uint64_t v53;
  void *v54;
  char *v55;
  std::__shared_weak_count *v56;
  _QWORD aBlock[5];
  uint64_t v58;
  int v59;
  _BYTE v60[24];
  _BYTE *v61;
  uint8_t buf[8];
  uint64_t v63;
  uint64_t (*v64)(uint64_t, qmi::MessageBase *);
  uint8_t *v65;
  char *v66;
  std::__shared_weak_count *v67;
  uint64_t v68;

  v68 = *MEMORY[0x24BDAC8D0];
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  if (*a5 == a5[1])
    __TUAssertTrigger();
  if (a3 < a4 || (__TUAssertTrigger(), a4))
  {
    if (a2)
      goto LABEL_7;
    goto LABEL_6;
  }
  __TUAssertTrigger();
  if (!a2)
LABEL_6:
    __TUAssertTrigger();
LABEL_7:
  if (*(_BYTE *)(a1 + 112))
  {
    *(_OWORD *)__p = 0u;
    v49 = 0u;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
    v12 = *a5;
    v13 = a5[1];
    a5[1] = 0;
    a5[2] = 0;
    *a5 = 0;
    v14 = (const void **)__p[1];
    if (__p[1] != (void *)v49)
    {
      while (*((_BYTE *)*v14 + 8) != 1)
      {
        if (++v14 == (const void **)v49)
          goto LABEL_15;
      }
    }
    if (v14 == (const void **)v49)
    {
LABEL_15:
      v17 = operator new();
      v18 = v17;
      *(_BYTE *)(v17 + 8) = 1;
      *(_QWORD *)v17 = &off_24D5E16E8;
      *(_DWORD *)(v17 + 16) = 0;
      v16 = (char *)(v17 + 16);
      *(_QWORD *)(v17 + 32) = 0;
      *(_QWORD *)(v17 + 40) = 0;
      *(_QWORD *)(v17 + 24) = 0;
      *(_WORD *)(v17 + 20) = 0;
      v19 = v49;
      if ((unint64_t)v49 >= *((_QWORD *)&v49 + 1))
      {
        v21 = (uint64_t)(v49 - (unint64_t)__p[1]) >> 3;
        if ((unint64_t)(v21 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v22 = (uint64_t)(*((_QWORD *)&v49 + 1) - (unint64_t)__p[1]) >> 2;
        if (v22 <= v21 + 1)
          v22 = v21 + 1;
        if (*((_QWORD *)&v49 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v23 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v23 = v22;
        if (v23)
          v24 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v49 + 8, v23);
        else
          v24 = 0;
        v25 = (uint64_t *)&v24[8 * v21];
        v26 = &v24[8 * v23];
        *v25 = v18;
        v20 = v25 + 1;
        v28 = (char *)__p[1];
        v27 = (char *)v49;
        if ((void *)v49 != __p[1])
        {
          do
          {
            v29 = *((_QWORD *)v27 - 1);
            v27 -= 8;
            *--v25 = v29;
          }
          while (v27 != v28);
          v27 = (char *)__p[1];
        }
        __p[1] = v25;
        *(_QWORD *)&v49 = v20;
        *((_QWORD *)&v49 + 1) = v26;
        if (v27)
          operator delete(v27);
      }
      else
      {
        *(_QWORD *)v49 = v17;
        v20 = (_QWORD *)(v19 + 8);
      }
      *(_QWORD *)&v49 = v20;
    }
    else
    {
      if (!v15)
        __cxa_bad_cast();
      v16 = v15 + 16;
    }
    if (a2 == 1)
      v30 = 12;
    else
      v30 = -1;
    if (a2 == 2)
      v30 = 13;
    *v16 = v30;
    v16[1] = 0;
    *((_WORD *)v16 + 1) = a3;
    *((_WORD *)v16 + 2) = a4;
    std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((_QWORD *)v16 + 1, v12, v13, v13 - v12);
    if (v12)
      operator delete(v12);
    v58 = a1;
    LOWORD(v59) = a3;
    HIWORD(v59) = a4;
    v31 = v60;
    std::__function::__value_func<void ()(BOOL,unsigned short)>::__value_func[abi:ne180100]((uint64_t)v60, a6);
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
    v32 = operator new(0x48uLL);
    v32[1] = 0;
    v33 = v32 + 1;
    v32[2] = 0;
    *v32 = &off_24D5E1750;
    v32[3] = v58;
    *((_DWORD *)v32 + 8) = v59;
    std::__function::__value_func<void ()(BOOL,unsigned short)>::__value_func[abi:ne180100]((uint64_t)(v32 + 5), (uint64_t)v60);
    v55 = (char *)(v32 + 3);
    v56 = (std::__shared_weak_count *)v32;
    v50 = a1 + 64;
    v51 = QMIServiceMsg::create();
    v52 = 25000;
    v53 = 0;
    v54 = 0;
    v34 = MEMORY[0x24BDAC760];
    *(_QWORD *)buf = MEMORY[0x24BDAC760];
    v63 = 1174405120;
    v64 = ___ZN22QMIStewieCommandDriver4sendIN3sft8SendFile7RequestEZNS_15sendFileSegmentE14StewieFileTypettONSt3__16vectorIhNS5_9allocatorIhEEEEONS5_8functionIFvbtEEEE3__2EEvRKT_OT0__block_invoke;
    v65 = (uint8_t *)&__block_descriptor_tmp_63_1;
    v66 = (char *)(v32 + 3);
    v67 = (std::__shared_weak_count *)v32;
    do
      v35 = __ldxr(v33);
    while (__stxr(v35 + 1, v33));
    aBlock[0] = v34;
    aBlock[1] = 0x40000000;
    aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3sft8SendFile8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
    aBlock[3] = &unk_24D5E1798;
    aBlock[4] = buf;
    v36 = _Block_copy(aBlock);
    v54 = v36;
    if (v51)
    {
      qmi::Client::send();
      v36 = v54;
    }
    if (v36)
      _Block_release(v36);
    v37 = v67;
    if (v67)
    {
      p_shared_owners = (unint64_t *)&v67->__shared_owners_;
      do
        v39 = __ldaxr(p_shared_owners);
      while (__stlxr(v39 - 1, p_shared_owners));
      if (!v39)
      {
        ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
        std::__shared_weak_count::__release_weak(v37);
      }
    }
    v40 = v56;
    if (v56)
    {
      v41 = (unint64_t *)&v56->__shared_owners_;
      do
        v42 = __ldaxr(v41);
      while (__stlxr(v42 - 1, v41));
      if (!v42)
      {
        ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
        std::__shared_weak_count::__release_weak(v40);
      }
    }
    if (v61 == v60)
    {
      v43 = 4;
    }
    else
    {
      if (!v61)
      {
LABEL_62:
        qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
        return;
      }
      v43 = 5;
      v31 = v61;
    }
    (*(void (**)(_QWORD *))(*v31 + 8 * v43))(v31);
    goto LABEL_62;
  }
  v44 = (uint64_t *)(a1 + 8);
  v45 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 67109376;
    *(_DWORD *)&buf[4] = a3;
    LOWORD(v63) = 1024;
    *(_DWORD *)((char *)&v63 + 2) = a4 - 1;
    _os_log_error_impl(&dword_216897000, v45, OS_LOG_TYPE_ERROR, "Failed to execute SendFile (%d/%d). Client is not ready", buf, 0xEu);
  }
  std::__function::__value_func<void ()(BOOL,unsigned short)>::__value_func[abi:ne180100]((uint64_t)buf, a6);
  ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::sendFileSegment(StewieFileType,unsigned short,unsigned short,std::vector<unsigned char> &&,std::function<void ()(BOOL,unsigned short)> &&)::$_0>(v44, (uint64_t)buf);
  v46 = v65;
  if (v65 == buf)
  {
    v47 = 4;
    v46 = buf;
    goto LABEL_70;
  }
  if (v65)
  {
    v47 = 5;
LABEL_70:
    (*(void (**)(void))(*(_QWORD *)v46 + 8 * v47))();
  }
}

void sub_216A20EBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,_QWORD *a30)
{
  uint64_t v30;
  _QWORD *v31;
  uint64_t v33;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v30);
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)&a13);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a18);
  if (a30 == v31)
  {
    v33 = 4;
  }
  else
  {
    if (!a30)
      goto LABEL_6;
    v33 = 5;
    v31 = a30;
  }
  (*(void (**)(_QWORD *))(*v31 + 8 * v33))(v31);
LABEL_6:
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::sendFileSegment(StewieFileType,unsigned short,unsigned short,std::vector<unsigned char> &&,std::function<void ()(BOOL,unsigned short)> &&)::$_0>(uint64_t *a1, uint64_t a2)
{
  std::__shared_weak_count *v3;
  uint64_t v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  NSObject *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v3 = (std::__shared_weak_count *)a1[1];
  if (!v3 || (v5 = *a1, (v6 = std::__shared_weak_count::lock(v3)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v7 = v6;
  v8 = operator new();
  std::__function::__value_func<void ()(BOOL,unsigned short)>::__value_func[abi:ne180100](v8, a2);
  v9 = a1[2];
  p_shared_owners = (unint64_t *)&v7->__shared_owners_;
  do
    v11 = __ldxr(p_shared_owners);
  while (__stxr(v11 + 1, p_shared_owners));
  v12 = (_QWORD *)operator new();
  *v12 = v8;
  v12[1] = v5;
  v12[2] = v7;
  v14 = 0;
  v15 = 0;
  dispatch_async_f(v9, v12, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute_wrapped<QMIStewieCommandDriver::sendFileSegment(StewieFileType,unsigned short,unsigned short,std::vector<unsigned char> &&,std::function<void ()(BOOL,unsigned short)> &&)::$_0>(QMIStewieCommandDriver::sendFileSegment(StewieFileType,unsigned short,unsigned short,std::vector<unsigned char> &&,std::function<void ()(BOOL,unsigned short)> &&)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<std::function<void ()(BOOL,unsigned short)> &&,std::default_delete<std::function<void ()(BOOL,unsigned short)> &&>>)::{lambda(void *)#1}::__invoke);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v14);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v15);
  do
    v13 = __ldaxr(p_shared_owners);
  while (__stlxr(v13 - 1, p_shared_owners));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
}

void QMIStewieCommandDriver::sendGPSDataUpdate(std::__shared_weak_count_vtbl *a1, uint64_t a2, uint64_t a3, uint64_t a4, char **a5, uint64_t *a6, uint64_t a7)
{
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  _QWORD *v18;
  std::__shared_weak_count *v19;
  unint64_t *p_shared_owners;
  uint64_t v21;
  unint64_t v22;
  void *v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t *v31;
  NSObject *v32;
  uint8_t *v33;
  uint64_t v34;
  _OWORD v35[2];
  const void *(__cdecl **p_get_deleter)(const std::__shared_weak_count *__hidden, const std::type_info *);
  uint64_t v37;
  int v38;
  uint64_t v39;
  void *v40;
  _QWORD *v41;
  std::__shared_weak_count *v42;
  _QWORD aBlock[5];
  std::__shared_weak_count_vtbl *v44;
  _BYTE v45[24];
  _BYTE *v46;
  uint8_t buf[8];
  uint64_t v48;
  uint64_t (*v49)(uint64_t, uint64_t);
  uint8_t *v50;
  _QWORD *v51;
  std::__shared_weak_count *v52;
  uint64_t v53;

  v53 = *MEMORY[0x24BDAC8D0];
  dispatch_assert_queue_V2((dispatch_queue_t)a1->__get_deleter);
  if (LOBYTE(a1[2].__on_zero_shared_weak))
  {
    memset(v35, 0, sizeof(v35));
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v35);
    v14 = qmi::MutableMessageBase::getTLV<sft::tlv::LocationData>(v35, 1);
    v15 = qmi::MutableMessageBase::getTLV<sft::tlv::EARFCN>(v35, 16);
    v16 = v15;
    if (v15 != (char *)a4)
      std::vector<wds::tlv::DestPortRangeInfo>::__assign_with_size[abi:ne180100]<wds::tlv::DestPortRangeInfo*,wds::tlv::DestPortRangeInfo*>(v15, *(char **)a4, *(_QWORD *)(a4 + 8), (uint64_t)(*(_QWORD *)(a4 + 8) - *(_QWORD *)a4) >> 2);
    if (v16 != (char *)a4)
      std::vector<wds::tlv::DestPortRangeInfo>::__assign_with_size[abi:ne180100]<wds::tlv::DestPortRangeInfo*,wds::tlv::DestPortRangeInfo*>(v16 + 24, *(char **)(a4 + 24), *(_QWORD *)(a4 + 32), (uint64_t)(*(_QWORD *)(a4 + 32) - *(_QWORD *)(a4 + 24)) >> 2);
    if (*a6)
    {
      v17 = qmi::MutableMessageBase::getTLV<sft::tlv::HeatMapData>(v35, 17);
    }
    v44 = a1;
    v18 = v45;
    std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)v45, a7);
    dispatch_assert_queue_V2((dispatch_queue_t)a1->__get_deleter);
    v19 = (std::__shared_weak_count *)operator new(0x40uLL);
    v19->__shared_owners_ = 0;
    p_shared_owners = (unint64_t *)&v19->__shared_owners_;
    v19->__shared_weak_owners_ = 0;
    v19->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E17F8;
    v19[1].__vftable = v44;
    std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)&v19[1].__shared_owners_, (uint64_t)v45);
    v41 = &v19[1].__vftable;
    v42 = v19;
    p_get_deleter = &a1[1].__get_deleter;
    v37 = QMIServiceMsg::create();
    v38 = 25000;
    v39 = 0;
    v40 = 0;
    v21 = MEMORY[0x24BDAC760];
    *(_QWORD *)buf = MEMORY[0x24BDAC760];
    v48 = 1174405120;
    v49 = ___ZN22QMIStewieCommandDriver4sendIN3sft13GPSDataUpdate7RequestEZNS_17sendGPSDataUpdateERK18StewieTimeFreqDataRK18StewieLocationDataRK12StewieEARFCNRKNSt3__16vectorIhNSD_9allocatorIhEEEERKNSD_10shared_ptrIK13StewieHeatMapEEONSD_8functionIFvbEEEE3__4EEvRKT_OT0__block_invoke;
    v50 = (uint8_t *)&__block_descriptor_tmp_65_5;
    v51 = &v19[1].__vftable;
    v52 = v19;
    do
      v22 = __ldxr(p_shared_owners);
    while (__stxr(v22 + 1, p_shared_owners));
    aBlock[0] = v21;
    aBlock[1] = 0x40000000;
    aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_24;
    aBlock[3] = &unk_24D5E09E8;
    aBlock[4] = buf;
    v23 = _Block_copy(aBlock);
    v40 = v23;
    if (v37)
    {
      qmi::Client::send();
      v23 = v40;
    }
    if (v23)
      _Block_release(v23);
    v24 = v52;
    if (v52)
    {
      v25 = (unint64_t *)&v52->__shared_owners_;
      do
        v26 = __ldaxr(v25);
      while (__stlxr(v26 - 1, v25));
      if (!v26)
      {
        ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
        std::__shared_weak_count::__release_weak(v24);
      }
    }
    v27 = v42;
    if (v42)
    {
      v28 = (unint64_t *)&v42->__shared_owners_;
      do
        v29 = __ldaxr(v28);
      while (__stlxr(v29 - 1, v28));
      if (!v29)
      {
        ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
        std::__shared_weak_count::__release_weak(v27);
      }
    }
    if (v46 == v45)
    {
      v30 = 4;
    }
    else
    {
      if (!v46)
      {
LABEL_29:
        qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v35);
        return;
      }
      v30 = 5;
      v18 = v46;
    }
    (*(void (**)(_QWORD *))(*v18 + 8 * v30))(v18);
    goto LABEL_29;
  }
  v31 = (uint64_t *)&a1->~__shared_weak_count_0;
  v32 = a1[1].~__shared_weak_count;
  if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl(&dword_216897000, v32, OS_LOG_TYPE_ERROR, "Failed to execute GPSDataUpdate. Client is not ready", buf, 2u);
  }
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)buf, a7);
  ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::sendGPSDataUpdate(StewieTimeFreqData const&,StewieLocationData const&,StewieEARFCN const&,std::vector<unsigned char> const&,std::shared_ptr<StewieHeatMap const> const&,std::function<void ()(BOOL)> &&)::$_0>(v31, (uint64_t)buf);
  v33 = v50;
  if (v50 == buf)
  {
    v34 = 4;
    v33 = buf;
    goto LABEL_37;
  }
  if (v50)
  {
    v34 = 5;
LABEL_37:
    (*(void (**)(void))(*(_QWORD *)v33 + 8 * v34))();
  }
}

void sub_216A213E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,_QWORD *a30)
{
  _QWORD *v30;
  uint64_t v31;
  uint64_t v33;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v31);
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)&a14);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a19);
  if (a30 == v30)
  {
    v33 = 4;
  }
  else
  {
    if (!a30)
      goto LABEL_6;
    v33 = 5;
    v30 = a30;
  }
  (*(void (**)(_QWORD *))(*v30 + 8 * v33))(v30);
LABEL_6:
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::sendGPSDataUpdate(StewieTimeFreqData const&,StewieLocationData const&,StewieEARFCN const&,std::vector<unsigned char> const&,std::shared_ptr<StewieHeatMap const> const&,std::function<void ()(BOOL)> &&)::$_0>(uint64_t *a1, uint64_t a2)
{
  std::__shared_weak_count *v3;
  uint64_t v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  NSObject *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v3 = (std::__shared_weak_count *)a1[1];
  if (!v3 || (v5 = *a1, (v6 = std::__shared_weak_count::lock(v3)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v7 = v6;
  v8 = operator new();
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100](v8, a2);
  v9 = a1[2];
  p_shared_owners = (unint64_t *)&v7->__shared_owners_;
  do
    v11 = __ldxr(p_shared_owners);
  while (__stxr(v11 + 1, p_shared_owners));
  v12 = (_QWORD *)operator new();
  *v12 = v8;
  v12[1] = v5;
  v12[2] = v7;
  v14 = 0;
  v15 = 0;
  dispatch_async_f(v9, v12, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute_wrapped<QMIStewieCommandDriver::sendGPSDataUpdate(StewieTimeFreqData const&,StewieLocationData const&,StewieEARFCN const&,std::vector<unsigned char> const&,std::shared_ptr<StewieHeatMap const> const&,std::function<void ()(BOOL)> &&)::$_0>(QMIStewieCommandDriver::sendGPSDataUpdate(StewieTimeFreqData const&,StewieLocationData const&,StewieEARFCN const&,std::vector<unsigned char> const&,std::shared_ptr<StewieHeatMap const> const&,std::function<void ()(BOOL)> &&)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIStewieCommandDriver::sendGPSDataUpdate(StewieTimeFreqData const&,StewieLocationData const&,StewieEARFCN const&,std::vector<unsigned char> const&,std::shared_ptr<StewieHeatMap const> const&,std::function<void ()(BOOL)> &&)::$_0,std::default_delete<QMIStewieCommandDriver::sendGPSDataUpdate(StewieTimeFreqData const&,StewieLocationData const&,StewieEARFCN const&,std::vector<unsigned char> const&,std::shared_ptr<StewieHeatMap const> const&,std::function<void ()(BOOL)> &&)::$_0>>)::{lambda(void *)#1}::__invoke);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v14);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v15);
  do
    v13 = __ldaxr(p_shared_owners);
  while (__stlxr(v13 - 1, p_shared_owners));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
}

void QMIStewieCommandDriver::getCellularTxDeferTime(std::__shared_weak_count_vtbl *a1, char **a2, uint64_t a3)
{
  const void **v6;
  char *v7;
  char **v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  char *v16;
  uint64_t *v17;
  char *v18;
  char *v19;
  char *v20;
  uint64_t v21;
  _QWORD *v22;
  std::__shared_weak_count *v23;
  unint64_t *p_shared_owners;
  uint64_t v25;
  unint64_t v26;
  void *v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t *v35;
  NSObject *v36;
  uint8_t *v37;
  uint64_t v38;
  void *__p[2];
  __int128 v40;
  const void *(__cdecl **p_get_deleter)(const std::__shared_weak_count *__hidden, const std::type_info *);
  uint64_t v42;
  int v43;
  uint64_t v44;
  void *v45;
  _QWORD *v46;
  std::__shared_weak_count *v47;
  _QWORD aBlock[5];
  std::__shared_weak_count_vtbl *v49;
  _BYTE v50[24];
  _BYTE *v51;
  uint8_t buf[8];
  uint64_t v53;
  uint64_t (*v54)(uint64_t, qmi::MessageBase *);
  uint8_t *v55;
  _QWORD *v56;
  std::__shared_weak_count *v57;
  uint64_t v58;

  v58 = *MEMORY[0x24BDAC8D0];
  dispatch_assert_queue_V2((dispatch_queue_t)a1->__get_deleter);
  if (LOBYTE(a1[2].__on_zero_shared_weak))
  {
    *(_OWORD *)__p = 0u;
    v40 = 0u;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
    v6 = (const void **)__p[1];
    if (__p[1] != (void *)v40)
    {
      while (*((_BYTE *)*v6 + 8) != 1)
      {
        if (++v6 == (const void **)v40)
          goto LABEL_9;
      }
    }
    if (v6 == (const void **)v40)
    {
LABEL_9:
      v9 = operator new();
      v10 = v9;
      *(_BYTE *)(v9 + 8) = 1;
      *(_QWORD *)(v9 + 16) = 0;
      v8 = (char **)(v9 + 16);
      *(_QWORD *)v9 = &off_24D5E1860;
      *(_QWORD *)(v9 + 24) = 0;
      *(_QWORD *)(v9 + 32) = 0;
      v11 = v40;
      if ((unint64_t)v40 >= *((_QWORD *)&v40 + 1))
      {
        v13 = (uint64_t)(v40 - (unint64_t)__p[1]) >> 3;
        if ((unint64_t)(v13 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v14 = (uint64_t)(*((_QWORD *)&v40 + 1) - (unint64_t)__p[1]) >> 2;
        if (v14 <= v13 + 1)
          v14 = v13 + 1;
        if (*((_QWORD *)&v40 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v15 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v15 = v14;
        if (v15)
          v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v40 + 8, v15);
        else
          v16 = 0;
        v17 = (uint64_t *)&v16[8 * v13];
        v18 = &v16[8 * v15];
        *v17 = v10;
        v12 = v17 + 1;
        v20 = (char *)__p[1];
        v19 = (char *)v40;
        if ((void *)v40 != __p[1])
        {
          do
          {
            v21 = *((_QWORD *)v19 - 1);
            v19 -= 8;
            *--v17 = v21;
          }
          while (v19 != v20);
          v19 = (char *)__p[1];
        }
        __p[1] = v17;
        *(_QWORD *)&v40 = v12;
        *((_QWORD *)&v40 + 1) = v18;
        if (v19)
          operator delete(v19);
      }
      else
      {
        *(_QWORD *)v40 = v9;
        v12 = (_QWORD *)(v11 + 8);
      }
      *(_QWORD *)&v40 = v12;
    }
    else
    {
      if (!v7)
        __cxa_bad_cast();
      v8 = (char **)(v7 + 16);
    }
    if (v8 != a2)
      std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(v8, *a2, a2[1], a2[1] - *a2);
    v49 = a1;
    v22 = v50;
    std::__function::__value_func<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)>::__value_func[abi:ne180100]((uint64_t)v50, a3);
    dispatch_assert_queue_V2((dispatch_queue_t)a1->__get_deleter);
    v23 = (std::__shared_weak_count *)operator new(0x40uLL);
    v23->__shared_owners_ = 0;
    p_shared_owners = (unint64_t *)&v23->__shared_owners_;
    v23->__shared_weak_owners_ = 0;
    v23->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E18C8;
    v23[1].__vftable = v49;
    std::__function::__value_func<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)>::__value_func[abi:ne180100]((uint64_t)&v23[1].__shared_owners_, (uint64_t)v50);
    v46 = &v23[1].__vftable;
    v47 = v23;
    p_get_deleter = &a1[1].__get_deleter;
    v42 = QMIServiceMsg::create();
    v43 = 25000;
    v44 = 0;
    v45 = 0;
    v25 = MEMORY[0x24BDAC760];
    *(_QWORD *)buf = MEMORY[0x24BDAC760];
    v53 = 1174405120;
    v54 = ___ZN22QMIStewieCommandDriver4sendIN3sft22GetCellularTxDeferTime7RequestEZNS_22getCellularTxDeferTimeERKNSt3__16vectorIhNS4_9allocatorIhEEEEONS4_8functionIFvbONS4_8optionalINS4_6chrono8durationIxNS4_5ratioILl1ELl1000EEEEEEEEEEE3__2EEvRKT_OT0__block_invoke;
    v55 = (uint8_t *)&__block_descriptor_tmp_66_4;
    v56 = &v23[1].__vftable;
    v57 = v23;
    do
      v26 = __ldxr(p_shared_owners);
    while (__stxr(v26 + 1, p_shared_owners));
    aBlock[0] = v25;
    aBlock[1] = 0x40000000;
    aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3sft22GetCellularTxDeferTime8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
    aBlock[3] = &unk_24D5E1910;
    aBlock[4] = buf;
    v27 = _Block_copy(aBlock);
    v45 = v27;
    if (v42)
    {
      qmi::Client::send();
      v27 = v45;
    }
    if (v27)
      _Block_release(v27);
    v28 = v57;
    if (v57)
    {
      v29 = (unint64_t *)&v57->__shared_owners_;
      do
        v30 = __ldaxr(v29);
      while (__stlxr(v30 - 1, v29));
      if (!v30)
      {
        ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
        std::__shared_weak_count::__release_weak(v28);
      }
    }
    v31 = v47;
    if (v47)
    {
      v32 = (unint64_t *)&v47->__shared_owners_;
      do
        v33 = __ldaxr(v32);
      while (__stlxr(v33 - 1, v32));
      if (!v33)
      {
        ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
        std::__shared_weak_count::__release_weak(v31);
      }
    }
    if (v51 == v50)
    {
      v34 = 4;
    }
    else
    {
      if (!v51)
      {
LABEL_49:
        qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
        return;
      }
      v34 = 5;
      v22 = v51;
    }
    (*(void (**)(_QWORD *))(*v22 + 8 * v34))(v22);
    goto LABEL_49;
  }
  v35 = (uint64_t *)&a1->~__shared_weak_count_0;
  v36 = a1[1].~__shared_weak_count;
  if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl(&dword_216897000, v36, OS_LOG_TYPE_ERROR, "Failed to execute GetCellularTxDeferTime. Client is not ready", buf, 2u);
  }
  std::__function::__value_func<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)>::__value_func[abi:ne180100]((uint64_t)buf, a3);
  ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::getCellularTxDeferTime(std::vector<unsigned char> const&,std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &&)::$_0>(v35, (uint64_t)buf);
  v37 = v55;
  if (v55 == buf)
  {
    v38 = 4;
    v37 = buf;
    goto LABEL_57;
  }
  if (v55)
  {
    v38 = 5;
LABEL_57:
    (*(void (**)(void))(*(_QWORD *)v37 + 8 * v38))();
  }
}

void sub_216A219E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,_QWORD *a30)
{
  _QWORD *v30;
  uint64_t v31;
  uint64_t v33;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v31);
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)&a14);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a19);
  if (a30 == v30)
  {
    v33 = 4;
  }
  else
  {
    if (!a30)
      goto LABEL_6;
    v33 = 5;
    v30 = a30;
  }
  (*(void (**)(_QWORD *))(*v30 + 8 * v33))(v30);
LABEL_6:
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::getCellularTxDeferTime(std::vector<unsigned char> const&,std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &&)::$_0>(uint64_t *a1, uint64_t a2)
{
  std::__shared_weak_count *v3;
  uint64_t v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  NSObject *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v3 = (std::__shared_weak_count *)a1[1];
  if (!v3 || (v5 = *a1, (v6 = std::__shared_weak_count::lock(v3)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v7 = v6;
  v8 = operator new();
  std::__function::__value_func<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)>::__value_func[abi:ne180100](v8, a2);
  v9 = a1[2];
  p_shared_owners = (unint64_t *)&v7->__shared_owners_;
  do
    v11 = __ldxr(p_shared_owners);
  while (__stxr(v11 + 1, p_shared_owners));
  v12 = (_QWORD *)operator new();
  *v12 = v8;
  v12[1] = v5;
  v12[2] = v7;
  v14 = 0;
  v15 = 0;
  dispatch_async_f(v9, v12, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute_wrapped<QMIStewieCommandDriver::getCellularTxDeferTime(std::vector<unsigned char> const&,std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &&)::$_0>(QMIStewieCommandDriver::getCellularTxDeferTime(std::vector<unsigned char> const&,std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &&)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &&,std::default_delete<std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &&>>)::{lambda(void *)#1}::__invoke);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v14);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v15);
  do
    v13 = __ldaxr(p_shared_owners);
  while (__stlxr(v13 - 1, p_shared_owners));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
}

void QMIStewieCommandDriver::~QMIStewieCommandDriver(QMIStewieCommandDriver *this)
{
  std::__shared_weak_count *v2;

  *(_QWORD *)this = &off_24D5E0300;
  v2 = (std::__shared_weak_count *)*((_QWORD *)this + 13);
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  qmi::Client::~Client((QMIStewieCommandDriver *)((char *)this + 64));
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)this + 48);
  MEMORY[0x2199FDF6C]((char *)this + 40);
  ctu::SharedSynchronizable<QMIDataSystemDeterminationManager>::~SharedSynchronizable((_QWORD *)this + 1);
  StewieCommandDriver::~StewieCommandDriver(this);
}

{
  QMIStewieCommandDriver::~QMIStewieCommandDriver(this);
  JUMPOUT(0x2199FEAC4);
}

void QMIStewieCommandDriver::setBroadcastInfoBlob(std::__shared_weak_count_vtbl *a1, char **a2, uint64_t a3)
{
  const void **v6;
  char *v7;
  char **v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  char *v16;
  uint64_t *v17;
  char *v18;
  char *v19;
  char *v20;
  uint64_t v21;
  _QWORD *v22;
  std::__shared_weak_count *v23;
  unint64_t *p_shared_owners;
  uint64_t v25;
  unint64_t v26;
  void *v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t *v35;
  NSObject *v36;
  uint8_t *v37;
  uint64_t v38;
  void *__p[2];
  __int128 v40;
  const void *(__cdecl **p_get_deleter)(const std::__shared_weak_count *__hidden, const std::type_info *);
  uint64_t v42;
  int v43;
  uint64_t v44;
  void *v45;
  _QWORD *v46;
  std::__shared_weak_count *v47;
  _QWORD aBlock[5];
  std::__shared_weak_count_vtbl *v49;
  _BYTE v50[24];
  _BYTE *v51;
  uint8_t buf[8];
  uint64_t v53;
  uint64_t (*v54)(uint64_t, uint64_t);
  uint8_t *v55;
  _QWORD *v56;
  std::__shared_weak_count *v57;
  uint64_t v58;

  v58 = *MEMORY[0x24BDAC8D0];
  dispatch_assert_queue_V2((dispatch_queue_t)a1->__get_deleter);
  if (LOBYTE(a1[2].__on_zero_shared_weak))
  {
    *(_OWORD *)__p = 0u;
    v40 = 0u;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
    v6 = (const void **)__p[1];
    if (__p[1] != (void *)v40)
    {
      while (*((_BYTE *)*v6 + 8) != 1)
      {
        if (++v6 == (const void **)v40)
          goto LABEL_9;
      }
    }
    if (v6 == (const void **)v40)
    {
LABEL_9:
      v9 = operator new();
      v10 = v9;
      *(_BYTE *)(v9 + 8) = 1;
      *(_QWORD *)(v9 + 16) = 0;
      v8 = (char **)(v9 + 16);
      *(_QWORD *)v9 = &off_24D5E1958;
      *(_QWORD *)(v9 + 24) = 0;
      *(_QWORD *)(v9 + 32) = 0;
      v11 = v40;
      if ((unint64_t)v40 >= *((_QWORD *)&v40 + 1))
      {
        v13 = (uint64_t)(v40 - (unint64_t)__p[1]) >> 3;
        if ((unint64_t)(v13 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v14 = (uint64_t)(*((_QWORD *)&v40 + 1) - (unint64_t)__p[1]) >> 2;
        if (v14 <= v13 + 1)
          v14 = v13 + 1;
        if (*((_QWORD *)&v40 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v15 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v15 = v14;
        if (v15)
          v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v40 + 8, v15);
        else
          v16 = 0;
        v17 = (uint64_t *)&v16[8 * v13];
        v18 = &v16[8 * v15];
        *v17 = v10;
        v12 = v17 + 1;
        v20 = (char *)__p[1];
        v19 = (char *)v40;
        if ((void *)v40 != __p[1])
        {
          do
          {
            v21 = *((_QWORD *)v19 - 1);
            v19 -= 8;
            *--v17 = v21;
          }
          while (v19 != v20);
          v19 = (char *)__p[1];
        }
        __p[1] = v17;
        *(_QWORD *)&v40 = v12;
        *((_QWORD *)&v40 + 1) = v18;
        if (v19)
          operator delete(v19);
      }
      else
      {
        *(_QWORD *)v40 = v9;
        v12 = (_QWORD *)(v11 + 8);
      }
      *(_QWORD *)&v40 = v12;
    }
    else
    {
      if (!v7)
        __cxa_bad_cast();
      v8 = (char **)(v7 + 16);
    }
    if (v8 != a2)
      std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(v8, *a2, a2[1], a2[1] - *a2);
    v49 = a1;
    v22 = v50;
    std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)v50, a3);
    dispatch_assert_queue_V2((dispatch_queue_t)a1->__get_deleter);
    v23 = (std::__shared_weak_count *)operator new(0x40uLL);
    v23->__shared_owners_ = 0;
    p_shared_owners = (unint64_t *)&v23->__shared_owners_;
    v23->__shared_weak_owners_ = 0;
    v23->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E19C0;
    v23[1].__vftable = v49;
    std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)&v23[1].__shared_owners_, (uint64_t)v50);
    v46 = &v23[1].__vftable;
    v47 = v23;
    p_get_deleter = &a1[1].__get_deleter;
    v42 = QMIServiceMsg::create();
    v43 = 25000;
    v44 = 0;
    v45 = 0;
    v25 = MEMORY[0x24BDAC760];
    *(_QWORD *)buf = MEMORY[0x24BDAC760];
    v53 = 1174405120;
    v54 = ___ZN22QMIStewieCommandDriver4sendIN3sft20SetBroadcastInfoBlob7RequestEZNS_20setBroadcastInfoBlobERKNSt3__16vectorIhNS4_9allocatorIhEEEEONS4_8functionIFvbEEEE3__2EEvRKT_OT0__block_invoke;
    v55 = (uint8_t *)&__block_descriptor_tmp_68_3;
    v56 = &v23[1].__vftable;
    v57 = v23;
    do
      v26 = __ldxr(p_shared_owners);
    while (__stxr(v26 + 1, p_shared_owners));
    aBlock[0] = v25;
    aBlock[1] = 0x40000000;
    aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_24;
    aBlock[3] = &unk_24D5E09E8;
    aBlock[4] = buf;
    v27 = _Block_copy(aBlock);
    v45 = v27;
    if (v42)
    {
      qmi::Client::send();
      v27 = v45;
    }
    if (v27)
      _Block_release(v27);
    v28 = v57;
    if (v57)
    {
      v29 = (unint64_t *)&v57->__shared_owners_;
      do
        v30 = __ldaxr(v29);
      while (__stlxr(v30 - 1, v29));
      if (!v30)
      {
        ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
        std::__shared_weak_count::__release_weak(v28);
      }
    }
    v31 = v47;
    if (v47)
    {
      v32 = (unint64_t *)&v47->__shared_owners_;
      do
        v33 = __ldaxr(v32);
      while (__stlxr(v33 - 1, v32));
      if (!v33)
      {
        ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
        std::__shared_weak_count::__release_weak(v31);
      }
    }
    if (v51 == v50)
    {
      v34 = 4;
    }
    else
    {
      if (!v51)
      {
LABEL_49:
        qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
        return;
      }
      v34 = 5;
      v22 = v51;
    }
    (*(void (**)(_QWORD *))(*v22 + 8 * v34))(v22);
    goto LABEL_49;
  }
  v35 = (uint64_t *)&a1->~__shared_weak_count_0;
  v36 = a1[1].~__shared_weak_count;
  if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl(&dword_216897000, v36, OS_LOG_TYPE_ERROR, "Failed to execute SetBroadcastInfoBlob. Client is not ready", buf, 2u);
  }
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)buf, a3);
  ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::setBroadcastInfoBlob(std::vector<unsigned char> const&,std::function<void ()(BOOL)> &&)::$_0>(v35, (uint64_t)buf);
  v37 = v55;
  if (v55 == buf)
  {
    v38 = 4;
    v37 = buf;
    goto LABEL_57;
  }
  if (v55)
  {
    v38 = 5;
LABEL_57:
    (*(void (**)(void))(*(_QWORD *)v37 + 8 * v38))();
  }
}

void sub_216A22064(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,_QWORD *a30)
{
  _QWORD *v30;
  uint64_t v31;
  uint64_t v33;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v31);
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)&a14);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a19);
  if (a30 == v30)
  {
    v33 = 4;
  }
  else
  {
    if (!a30)
      goto LABEL_6;
    v33 = 5;
    v30 = a30;
  }
  (*(void (**)(_QWORD *))(*v30 + 8 * v33))(v30);
LABEL_6:
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute<QMIStewieCommandDriver::setBroadcastInfoBlob(std::vector<unsigned char> const&,std::function<void ()(BOOL)> &&)::$_0>(uint64_t *a1, uint64_t a2)
{
  std::__shared_weak_count *v3;
  uint64_t v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  NSObject *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v3 = (std::__shared_weak_count *)a1[1];
  if (!v3 || (v5 = *a1, (v6 = std::__shared_weak_count::lock(v3)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v7 = v6;
  v8 = operator new();
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100](v8, a2);
  v9 = a1[2];
  p_shared_owners = (unint64_t *)&v7->__shared_owners_;
  do
    v11 = __ldxr(p_shared_owners);
  while (__stxr(v11 + 1, p_shared_owners));
  v12 = (_QWORD *)operator new();
  *v12 = v8;
  v12[1] = v5;
  v12[2] = v7;
  v14 = 0;
  v15 = 0;
  dispatch_async_f(v9, v12, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute_wrapped<QMIStewieCommandDriver::setBroadcastInfoBlob(std::vector<unsigned char> const&,std::function<void ()(BOOL)> &&)::$_0>(QMIStewieCommandDriver::setBroadcastInfoBlob(std::vector<unsigned char> const&,std::function<void ()(BOOL)> &&)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIStewieCommandDriver::setBroadcastInfoBlob(std::vector<unsigned char> const&,std::function<void ()(BOOL)> &&)::$_0,std::default_delete<QMIStewieCommandDriver::setBroadcastInfoBlob(std::vector<unsigned char> const&,std::function<void ()(BOOL)> &&)::$_0>>)::{lambda(void *)#1}::__invoke);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v14);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v15);
  do
    v13 = __ldaxr(p_shared_owners);
  while (__stlxr(v13 - 1, p_shared_owners));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
}

void QMIStewieCommandDriver::handleDumpState(dispatch_queue_t *this)
{
  NSObject *v2;
  const char *v3;
  NSObject *v4;
  int v5;
  int v6;
  const char *v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  dispatch_assert_queue_V2(this[3]);
  v2 = this[5];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v6) = 0;
    _os_log_impl(&dword_216897000, v2, OS_LOG_TYPE_DEFAULT, "#I [d] ********************************", (uint8_t *)&v6, 2u);
    v2 = this[5];
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v6) = 0;
    _os_log_impl(&dword_216897000, v2, OS_LOG_TYPE_DEFAULT, "#I [d] * QMIStewieCommandDriver state *", (uint8_t *)&v6, 2u);
    v2 = this[5];
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v6) = 0;
    _os_log_impl(&dword_216897000, v2, OS_LOG_TYPE_DEFAULT, "#I [d] ********************************", (uint8_t *)&v6, 2u);
    v2 = this[5];
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*((_BYTE *)this + 112))
      v3 = "true";
    else
      v3 = "false";
    v6 = 136315138;
    v7 = v3;
    _os_log_impl(&dword_216897000, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Ready: %s", (uint8_t *)&v6, 0xCu);
  }
  if (*((_BYTE *)this + 120))
  {
    v4 = this[5];
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      v5 = *((_DWORD *)this + 29);
      v6 = 67240192;
      LODWORD(v7) = v5;
      _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I [d] fLastKnownBBUID: %{public}u", (uint8_t *)&v6, 8u);
    }
  }
}

uint64_t *std::shared_ptr<QMIStewieCommandDriver>::shared_ptr[abi:ne180100]<QMIStewieCommandDriver,std::shared_ptr<QMIStewieCommandDriver> ctu::SharedSynchronizable<QMIStewieCommandDriver>::make_shared_ptr<QMIStewieCommandDriver>(QMIStewieCommandDriver*)::{lambda(QMIStewieCommandDriver*)#1},void>(uint64_t *a1, uint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24D5E0638;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = (uint64_t)v4;
  if (a2)
    v5 = (_QWORD *)(a2 + 8);
  else
    v5 = 0;
  std::shared_ptr<QMIDataSystemDeterminationManager>::__enable_weak_this[abi:ne180100]<QMIDataSystemDeterminationManager,QMIDataSystemDeterminationManager,void>((uint64_t)a1, v5, a2);
  return a1;
}

void sub_216A22430(void *a1)
{
  dispatch_queue_t *v1;

  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)std::shared_ptr<QMIStewieCommandDriver> ctu::SharedSynchronizable<QMIStewieCommandDriver>::make_shared_ptr<QMIStewieCommandDriver>(QMIStewieCommandDriver*)::{lambda(QMIStewieCommandDriver*)#1}::operator() const(QMIStewieCommandDriver*)::{lambda(void *)#1}::__invoke);
  __cxa_rethrow();
}

void sub_216A22450(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<QMIStewieCommandDriver *,std::shared_ptr<QMIStewieCommandDriver> ctu::SharedSynchronizable<QMIStewieCommandDriver>::make_shared_ptr<QMIStewieCommandDriver>(QMIStewieCommandDriver*)::{lambda(QMIStewieCommandDriver *)#1},std::allocator<QMIStewieCommandDriver>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void std::__shared_ptr_pointer<QMIStewieCommandDriver *,std::shared_ptr<QMIStewieCommandDriver> ctu::SharedSynchronizable<QMIStewieCommandDriver>::make_shared_ptr<QMIStewieCommandDriver>(QMIStewieCommandDriver*)::{lambda(QMIStewieCommandDriver *)#1},std::allocator<QMIStewieCommandDriver>>::__on_zero_shared(uint64_t a1)
{
  dispatch_barrier_async_f(*(dispatch_queue_t *)(*(_QWORD *)(a1 + 24) + 24), *(void **)(a1 + 24), (dispatch_function_t)std::shared_ptr<QMIStewieCommandDriver> ctu::SharedSynchronizable<QMIStewieCommandDriver>::make_shared_ptr<QMIStewieCommandDriver>(QMIStewieCommandDriver*)::{lambda(QMIStewieCommandDriver*)#1}::operator() const(QMIStewieCommandDriver*)::{lambda(void *)#1}::__invoke);
}

uint64_t std::__shared_ptr_pointer<QMIStewieCommandDriver *,std::shared_ptr<QMIStewieCommandDriver> ctu::SharedSynchronizable<QMIStewieCommandDriver>::make_shared_ptr<QMIStewieCommandDriver>(QMIStewieCommandDriver*)::{lambda(QMIStewieCommandDriver *)#1},std::allocator<QMIStewieCommandDriver>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t std::shared_ptr<QMIStewieCommandDriver> ctu::SharedSynchronizable<QMIStewieCommandDriver>::make_shared_ptr<QMIStewieCommandDriver>(QMIStewieCommandDriver*)::{lambda(QMIStewieCommandDriver*)#1}::operator() const(QMIStewieCommandDriver*)::{lambda(void *)#1}::__invoke(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 184))(result);
  return result;
}

void ___ZNK3qmi6Client13setIndHandlerIRKN3sft11ServiceInfo10IndicationEEEvtU13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A225B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ___ZNK3qmi6Client13setIndHandlerIRKN3sft20DeactivationComplete10IndicationEEEvtU13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A226AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ___ZNK3qmi6Client13setIndHandlerIRKN3sft18RequestStateChange10IndicationEEEvtU13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A227A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ___ZNK3qmi6Client13setIndHandlerIRKN3sft26SecurityConfigUpdateNeeded10IndicationEEEvtU13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A228A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ___ZNK3qmi6Client13setIndHandlerIRKN3sft19SecurityConfigUsage10IndicationEEEvtU13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A229A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ___ZNK3qmi6Client13setIndHandlerIRKN3sft15MessageTXStatus10IndicationEEEvtU13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A22A9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ___ZNK3qmi6Client13setIndHandlerIRKN3sft9MessageRX10IndicationEEEvtU13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A22B98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ___ZNK3qmi6Client13setIndHandlerIRKN3sft18FileTransferStatus10IndicationEEEvtU13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A22C94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ___ZNK3qmi6Client13setIndHandlerIRKN3sft17ServiceOutageInfo10IndicationEEEvtU13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A22D90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

void ___ZNK3qmi6Client13setIndHandlerIRKN3sft21SaveBroadcastInfoBlob10IndicationEEEvtU13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A22E8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__value_func<void ()(BOOL,StewieHWSupportType)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;

  v3 = (_QWORD *)(a2 + 24);
  v4 = *(_QWORD *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(_QWORD *)(a1 + 24) = a1;
      (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(_QWORD *)(a1 + 24) = v4;
  }
  else
  {
    v3 = (_QWORD *)(a1 + 24);
  }
  *v3 = 0;
  return a1;
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute_wrapped<QMIStewieCommandDriver::getCapabilities(std::function<void ()(BOOL,StewieHWSupportType)> &&)::$_0>(QMIStewieCommandDriver::getCapabilities(std::function<void ()(BOOL,StewieHWSupportType)> &&)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIStewieCommandDriver::getCapabilities(std::function<void ()(BOOL,StewieHWSupportType)> &&)::$_0,std::default_delete<QMIStewieCommandDriver::getCapabilities(std::function<void ()(BOOL,StewieHWSupportType)> &&)::$_0>>)::{lambda(void *)#1}::__invoke(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  _QWORD *v4;
  uint64_t v5;
  int v6;
  char v7;

  v1 = *a1;
  v4 = a1;
  v5 = v1;
  v2 = *(_QWORD *)(v1 + 24);
  v7 = 0;
  v6 = 2;
  if (!v2)
    std::__throw_bad_function_call[abi:ne180100]();
  (*(void (**)(uint64_t, char *, int *))(*(_QWORD *)v2 + 48))(v2, &v7, &v6);
  std::unique_ptr<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0,std::default_delete<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0>>::~unique_ptr[abi:ne180100](&v5);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v4);
}

void sub_216A22F98(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3;
  va_list va;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  std::unique_ptr<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0,std::default_delete<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0>>::~unique_ptr[abi:ne180100]((uint64_t *)va1);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t std::function<void ()(BOOL,StewieHWSupportType)>::operator()(uint64_t a1, char a2, int a3)
{
  int v4;
  char v5;

  v5 = a2;
  v4 = a3;
  if (!a1)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, char *, int *))(*(_QWORD *)a1 + 48))(a1, &v5, &v4);
}

uint64_t ___ZN22QMIStewieCommandDriver4sendIN3sft15GetCapabilities7RequestEZNS_15getCapabilitiesEONSt3__18functionIFvb19StewieHWSupportTypeEEEE3__1EEvRKT_OT0__block_invoke(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t *v2;
  int v3;
  NSObject *v4;
  uint64_t TlvValue;
  int v7;
  uint64_t v8;
  int v9;
  BOOL v10;
  int v11;
  uint64_t v12;
  char v14;
  uint8_t buf[8];
  __int16 v16;
  uint64_t v17;
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  v2 = *(uint64_t **)(a1 + 32);
  v3 = *((_DWORD *)a2 + 1);
  v4 = *(NSObject **)(*v2 + 40);
  if (!v3)
  {
    if (os_log_type_enabled(*(os_log_t *)(*v2 + 40), OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I GetCapabilities succeeded", buf, 2u);
    }
    TlvValue = qmi::MessageBase::findTlvValue(a2);
    if (TlvValue)
    {
      v8 = TlvValue;
      v9 = v7;
      *(_QWORD *)buf = TlvValue;
      v10 = tlv::parseV<sft::tlv::HWSupport>((unint64_t *)buf, v7);
      if (*(_QWORD *)buf)
      {
        v11 = v10;
LABEL_9:
        v12 = v2[4];
        v14 = 1;
        *(_DWORD *)buf = v11;
        if (!v12)
          std::__throw_bad_function_call[abi:ne180100]();
        return (*(uint64_t (**)(uint64_t, char *, uint8_t *))(*(_QWORD *)v12 + 48))(v12, &v14, buf);
      }
      ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 3, v8, v9);
    }
    v11 = 2;
    goto LABEL_9;
  }
  if (os_log_type_enabled(*(os_log_t *)(*v2 + 40), OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 67109378;
    *(_DWORD *)&buf[4] = v3;
    v16 = 2080;
    v17 = qmi::asString();
    _os_log_error_impl(&dword_216897000, v4, OS_LOG_TYPE_ERROR, "Failed to execute GetCapabilities. Error code:0x%x (%s)", buf, 0x12u);
  }
  return std::function<void ()(BOOL,StewieHWSupportType)>::operator()(v2[4], 0, 2);
}

uint64_t __copy_helper_block_e8_32c116_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver15getCapabilitiesEONS_8functionIFvb19StewieHWSupportTypeEEEE3__1EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c116_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver15getCapabilitiesEONS_8functionIFvb19StewieHWSupportTypeEEEE3__1EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::getCapabilities(std::function<void ()(BOOL,StewieHWSupportType)> &&)::$_1,std::allocator<std::function<void ()(BOOL,StewieHWSupportType)> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E0858;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::getCapabilities(std::function<void ()(BOOL,StewieHWSupportType)> &&)::$_1,std::allocator<std::function<void ()(BOOL,StewieHWSupportType)> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E0858;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__shared_ptr_emplace<QMIStewieCommandDriver::getCapabilities(std::function<void ()(BOOL,StewieHWSupportType)> &&)::$_1,std::allocator<std::function<void ()(BOOL,StewieHWSupportType)> &&>>::__on_zero_shared(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *result;
  uint64_t v3;

  v1 = (_QWORD *)(a1 + 32);
  result = *(_QWORD **)(a1 + 56);
  if (result == v1)
  {
    v3 = 4;
    result = v1;
  }
  else
  {
    if (!result)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3sft15GetCapabilities8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A232E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute_wrapped<QMIStewieCommandDriver::sendS4ConfigSegment(StewieTargetLineSets const&,unsigned long,unsigned long,unsigned short,unsigned short,std::function<void ()(BOOL)> &&)::$_0>(QMIStewieCommandDriver::sendS4ConfigSegment(StewieTargetLineSets const&,unsigned long,unsigned long,unsigned short,unsigned short,std::function<void ()(BOOL)> &&)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIStewieCommandDriver::sendS4ConfigSegment(StewieTargetLineSets const&,unsigned long,unsigned long,unsigned short,unsigned short,std::function<void ()(BOOL)> &&)::$_0,std::default_delete<QMIStewieCommandDriver::sendS4ConfigSegment(StewieTargetLineSets const&,unsigned long,unsigned long,unsigned short,unsigned short,std::function<void ()(BOOL)> &&)::$_0>>)::{lambda(void *)#1}::__invoke(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  _QWORD *v4;
  uint64_t v5;
  char v6;

  v1 = *a1;
  v4 = a1;
  v5 = v1;
  v6 = 0;
  v2 = *(_QWORD *)(v1 + 24);
  if (!v2)
    std::__throw_bad_function_call[abi:ne180100]();
  (*(void (**)(uint64_t, char *))(*(_QWORD *)v2 + 48))(v2, &v6);
  std::unique_ptr<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0,std::default_delete<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0>>::~unique_ptr[abi:ne180100](&v5);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v4);
}

void sub_216A23384(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3;
  va_list va;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  std::unique_ptr<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0,std::default_delete<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0>>::~unique_ptr[abi:ne180100]((uint64_t *)va1);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

_QWORD *qmi::MutableMessageBase::TlvWrapper<sft::tlv::TargetLineSets>::~TlvWrapper(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24D5E08E8;
  v2 = (void *)a1[3];
  if (v2)
  {
    a1[4] = v2;
    operator delete(v2);
  }
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::TargetLineSets>::~TlvWrapper(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24D5E08E8;
  v2 = (void *)a1[3];
  if (v2)
  {
    a1[4] = v2;
    operator delete(v2);
  }
  JUMPOUT(0x2199FEAC4);
}

unint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::TargetLineSets>::getSize(uint64_t a1)
{
  return tlv::size<sft::tlv::TargetLineSets>(a1 + 16);
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<sft::tlv::TargetLineSets>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<sft::tlv::TargetLineSets>((_BYTE **)a2, a1 + 16);
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

_QWORD *qmi::MutableMessageBase::TlvWrapper<sft::tlv::TargetLineSets>::clone(uint64_t a1)
{
  uint64_t v2;
  _QWORD *v3;
  char v4;
  _BYTE *v5;
  _BYTE *v6;
  size_t v7;
  char *v8;
  uint64_t v9;

  v2 = operator new();
  v3 = (_QWORD *)v2;
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)v2 = &off_24D5E08E8;
  v4 = *(_BYTE *)(a1 + 16);
  *(_QWORD *)(v2 + 24) = 0;
  *(_BYTE *)(v2 + 16) = v4;
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 40) = 0;
  v6 = *(_BYTE **)(a1 + 24);
  v5 = *(_BYTE **)(a1 + 32);
  v7 = v5 - v6;
  if (v5 != v6)
  {
    if (0x3AEF6CA970586723 * v7 >= 0x1D77B654B82C33ALL)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v8 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<sft::tlv::TargetLineSet>>(v2 + 40, 0x3AEF6CA970586723 * v7);
    v3[3] = v8;
    v3[5] = &v8[139 * v9];
    memmove(v8, v6, v7);
    v3[4] = &v8[v7];
  }
  return v3;
}

void sub_216A23574(_Unwind_Exception *a1)
{
  uint64_t v1;
  void **v2;
  void *v4;

  v4 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 32) = v4;
    operator delete(v4);
  }
  MEMORY[0x2199FEAC4](v1, 0x10A1C40FDE69906);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::S4ConfigSegmentInfo>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::S4ConfigSegmentInfo>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

_WORD **qmi::MutableMessageBase::TlvWrapper<sft::tlv::S4ConfigSegmentInfo>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _WORD *v4;
  uint64_t v5;
  _WORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_WORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::TdFragmentInfo>((_WORD **)a2, (_WORD *)(a1 + 10));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::S4ConfigSegmentInfo>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E0938;
  *(_DWORD *)(result + 10) = *(_DWORD *)(a1 + 10);
  return result;
}

uint64_t ___ZN22QMIStewieCommandDriver4sendIN3sft11SetS4Config7RequestEZNS_19sendS4ConfigSegmentERK20StewieTargetLineSetsmmttONSt3__18functionIFvbEEEE3__3EEvRKT_OT0__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  NSObject *v4;
  int v5;
  int v6;
  uint64_t v7;
  int v9;
  int v10;
  int v11;
  int v12;
  __int16 v13;
  int v14;
  __int16 v15;
  int v16;
  __int16 v17;
  uint64_t v18;
  uint64_t v19;

  v19 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(_DWORD *)(a2 + 4);
  v4 = *(NSObject **)(*(_QWORD *)v2 + 40);
  if (v3)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v9 = *(unsigned __int16 *)(v2 + 40);
      v10 = *(unsigned __int16 *)(v2 + 42) - 1;
      v11 = 67109890;
      v12 = v9;
      v13 = 1024;
      v14 = v10;
      v15 = 1024;
      v16 = v3;
      v17 = 2080;
      v18 = qmi::asString();
      _os_log_error_impl(&dword_216897000, v4, OS_LOG_TYPE_ERROR, "Failed to execute SetS4Config (%d/%d). Error code:0x%x (%s)", (uint8_t *)&v11, 0x1Eu);
    }
    LOBYTE(v11) = 0;
  }
  else
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      v5 = *(unsigned __int16 *)(v2 + 40);
      v6 = *(unsigned __int16 *)(v2 + 42) - 1;
      v11 = 67109376;
      v12 = v5;
      v13 = 1024;
      v14 = v6;
      _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I SetS4Config (%d/%d) succeeded", (uint8_t *)&v11, 0xEu);
    }
    LOBYTE(v11) = 1;
  }
  v7 = *(_QWORD *)(v2 + 32);
  if (!v7)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, int *))(*(_QWORD *)v7 + 48))(v7, &v11);
}

uint64_t __copy_helper_block_e8_32c127_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver19sendS4ConfigSegmentERK20StewieTargetLineSetsmmttONS_8functionIFvbEEEE3__3EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c127_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver19sendS4ConfigSegmentERK20StewieTargetLineSetsmmttONS_8functionIFvbEEEE3__3EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::sendS4ConfigSegment(StewieTargetLineSets const&,unsigned long,unsigned long,unsigned short,unsigned short,std::function<void ()(BOOL)> &&)::$_3,std::allocator<std::function<void ()(BOOL)> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E09A0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::sendS4ConfigSegment(StewieTargetLineSets const&,unsigned long,unsigned long,unsigned short,unsigned short,std::function<void ()(BOOL)> &&)::$_3,std::allocator<std::function<void ()(BOOL)> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E09A0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__shared_ptr_emplace<QMIStewieCommandDriver::sendS4ConfigSegment(StewieTargetLineSets const&,unsigned long,unsigned long,unsigned short,unsigned short,std::function<void ()(BOOL)> &&)::$_3,std::allocator<std::function<void ()(BOOL)> &&>>::__on_zero_shared(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *result;
  uint64_t v3;

  v1 = (_QWORD *)(a1 + 32);
  result = *(_QWORD **)(a1 + 56);
  if (result == v1)
  {
    v3 = 4;
    result = v1;
  }
  else
  {
    if (!result)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

uint64_t std::__function::__value_func<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;

  v3 = (_QWORD *)(a2 + 24);
  v4 = *(_QWORD *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(_QWORD *)(a1 + 24) = a1;
      (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(_QWORD *)(a1 + 24) = v4;
  }
  else
  {
    v3 = (_QWORD *)(a1 + 24);
  }
  *v3 = 0;
  return a1;
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute_wrapped<QMIStewieCommandDriver::activate(StewieRequestReason,StewieSPSEnvironmentType,StewieProvisioningData const&,StewieTimeFreqData const&,StewieLocationData const&,StewieSecurityCredentials const&,std::shared_ptr<StewieHeatMap const> const&,BOOL,std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &&)::$_0>(QMIStewieCommandDriver::activate(StewieRequestReason,StewieSPSEnvironmentType,StewieProvisioningData const&,StewieTimeFreqData const&,StewieLocationData const&,StewieSecurityCredentials const&,std::shared_ptr<StewieHeatMap const> const&,BOOL,std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &&)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &&,std::default_delete<std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &&>>)::{lambda(void *)#1}::__invoke(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  _QWORD *v4;
  uint64_t v5;
  _BYTE v6[23];
  char v7;

  v1 = *a1;
  v4 = a1;
  v5 = v1;
  v6[0] = 0;
  v6[8] = 0;
  v7 = 0;
  v2 = *(_QWORD *)(v1 + 24);
  if (!v2)
    std::__throw_bad_function_call[abi:ne180100]();
  (*(void (**)(uint64_t, char *, _BYTE *))(*(_QWORD *)v2 + 48))(v2, &v7, v6);
  std::unique_ptr<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0,std::default_delete<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0>>::~unique_ptr[abi:ne180100](&v5);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v4);
}

void sub_216A23950(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3;
  va_list va;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  std::unique_ptr<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0,std::default_delete<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0>>::~unique_ptr[abi:ne180100]((uint64_t *)va1);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::ServiceType>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::ServiceType>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<sft::tlv::ServiceType>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::ServiceType>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E0A30;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::ProtocolMode>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::ProtocolMode>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<sft::tlv::ProtocolMode>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::ProtocolMode>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E0A80;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::SPSEnvironmentType>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::SPSEnvironmentType>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<sft::tlv::SPSEnvironmentType>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::SPSEnvironmentType>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E0AD0;
  return result;
}

char *qmi::MutableMessageBase::getTLV<sft::tlv::SecurityCredentials>(_QWORD *a1, int a2)
{
  char v2;
  const void **v4;
  const void **v5;
  char **v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t *v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  char *v17;
  uint64_t *v18;
  char *v19;
  char *v20;
  char *v21;
  uint64_t v22;

  v2 = a2;
  v4 = (const void **)a1[1];
  v5 = (const void **)a1[2];
  v6 = (char **)(a1 + 1);
  if (v4 != v5)
  {
    while (*((unsigned __int8 *)*v4 + 8) != a2)
    {
      if (++v4 == v5)
        goto LABEL_8;
    }
  }
  if (v4 == v5)
  {
LABEL_8:
    v9 = operator new();
    *(_BYTE *)(v9 + 8) = v2;
    *(_QWORD *)v9 = &off_24D5E0B20;
    *(_OWORD *)(v9 + 9) = 0u;
    v8 = v9 + 9;
    *(_OWORD *)(v9 + 25) = 0u;
    *(_QWORD *)(v9 + 41) = 0;
    v10 = a1[3];
    v11 = (uint64_t *)a1[2];
    if ((unint64_t)v11 >= v10)
    {
      v13 = ((char *)v11 - *v6) >> 3;
      if ((unint64_t)(v13 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v14 = v10 - (_QWORD)*v6;
      v15 = v14 >> 2;
      if (v14 >> 2 <= (unint64_t)(v13 + 1))
        v15 = v13 + 1;
      if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8)
        v16 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v16 = v15;
      if (v16)
        v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v16);
      else
        v17 = 0;
      v18 = (uint64_t *)&v17[8 * v13];
      v19 = &v17[8 * v16];
      *v18 = v9;
      v12 = v18 + 1;
      v21 = (char *)a1[1];
      v20 = (char *)a1[2];
      if (v20 != v21)
      {
        do
        {
          v22 = *((_QWORD *)v20 - 1);
          v20 -= 8;
          *--v18 = v22;
        }
        while (v20 != v21);
        v20 = *v6;
      }
      a1[1] = v18;
      a1[2] = v12;
      a1[3] = v19;
      if (v20)
        operator delete(v20);
    }
    else
    {
      *v11 = v9;
      v12 = v11 + 1;
    }
    a1[2] = v12;
  }
  else
  {
    if (!v7)
      __cxa_bad_cast();
    return v7 + 9;
  }
  return (char *)v8;
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::SecurityCredentials>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::SecurityCredentials>::getSize()
{
  return tlv::size<wds::tlv::Ipv6AddressExtended>();
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::SecurityCredentials>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = *a2;
  v5 = *a2 + 3;
  *a2 = v5;
  tlv::writeV<sft::tlv::SecurityCredentials>(a2, a1 + 9);
  v6 = *a2 - v5;
  *(_BYTE *)v4 = v3;
  *(_WORD *)(v4 + 1) = v6;
}

__n128 qmi::MutableMessageBase::TlvWrapper<sft::tlv::SecurityCredentials>::clone(uint64_t a1)
{
  uint64_t v2;
  __n128 result;

  v2 = operator new();
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)v2 = &off_24D5E0B20;
  *(_OWORD *)(v2 + 9) = *(_OWORD *)(a1 + 9);
  result = *(__n128 *)(a1 + 25);
  *(__n128 *)(v2 + 25) = result;
  *(_QWORD *)(v2 + 41) = *(_QWORD *)(a1 + 41);
  return result;
}

char *qmi::MutableMessageBase::getTLV<sft::tlv::EARFCN>(_QWORD *a1, int a2)
{
  char v2;
  const void **v4;
  const void **v5;
  char **v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t *v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  char *v17;
  uint64_t *v18;
  char *v19;
  char *v20;
  char *v21;
  uint64_t v22;

  v2 = a2;
  v4 = (const void **)a1[1];
  v5 = (const void **)a1[2];
  v6 = (char **)(a1 + 1);
  if (v4 != v5)
  {
    while (*((unsigned __int8 *)*v4 + 8) != a2)
    {
      if (++v4 == v5)
        goto LABEL_8;
    }
  }
  if (v4 == v5)
  {
LABEL_8:
    v9 = operator new();
    *(_BYTE *)(v9 + 8) = v2;
    *(_QWORD *)v9 = &off_24D5E0B70;
    *(_OWORD *)(v9 + 16) = 0u;
    v8 = v9 + 16;
    *(_OWORD *)(v9 + 32) = 0u;
    *(_OWORD *)(v9 + 48) = 0u;
    v10 = a1[3];
    v11 = (uint64_t *)a1[2];
    if ((unint64_t)v11 >= v10)
    {
      v13 = ((char *)v11 - *v6) >> 3;
      if ((unint64_t)(v13 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v14 = v10 - (_QWORD)*v6;
      v15 = v14 >> 2;
      if (v14 >> 2 <= (unint64_t)(v13 + 1))
        v15 = v13 + 1;
      if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8)
        v16 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v16 = v15;
      if (v16)
        v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v16);
      else
        v17 = 0;
      v18 = (uint64_t *)&v17[8 * v13];
      v19 = &v17[8 * v16];
      *v18 = v9;
      v12 = v18 + 1;
      v21 = (char *)a1[1];
      v20 = (char *)a1[2];
      if (v20 != v21)
      {
        do
        {
          v22 = *((_QWORD *)v20 - 1);
          v20 -= 8;
          *--v18 = v22;
        }
        while (v20 != v21);
        v20 = *v6;
      }
      a1[1] = v18;
      a1[2] = v12;
      a1[3] = v19;
      if (v20)
        operator delete(v20);
    }
    else
    {
      *v11 = v9;
      v12 = v11 + 1;
    }
    a1[2] = v12;
  }
  else
  {
    if (!v7)
      __cxa_bad_cast();
    return v7 + 16;
  }
  return (char *)v8;
}

_QWORD *qmi::MutableMessageBase::TlvWrapper<sft::tlv::EARFCN>::~TlvWrapper(_QWORD *a1)
{
  void *v2;
  void *v3;

  *a1 = &off_24D5E0B70;
  v2 = (void *)a1[5];
  if (v2)
  {
    a1[6] = v2;
    operator delete(v2);
  }
  v3 = (void *)a1[2];
  if (v3)
  {
    a1[3] = v3;
    operator delete(v3);
  }
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::EARFCN>::~TlvWrapper(_QWORD *a1)
{
  void *v2;
  void *v3;

  *a1 = &off_24D5E0B70;
  v2 = (void *)a1[5];
  if (v2)
  {
    a1[6] = v2;
    operator delete(v2);
  }
  v3 = (void *)a1[2];
  if (v3)
  {
    a1[3] = v3;
    operator delete(v3);
  }
  JUMPOUT(0x2199FEAC4);
}

unint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::EARFCN>::getSize(uint64_t a1)
{
  return tlv::size<sft::tlv::EARFCN>((_QWORD *)(a1 + 16));
}

_DWORD *qmi::MutableMessageBase::TlvWrapper<sft::tlv::EARFCN>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _DWORD *result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<sft::tlv::EARFCN>((_BYTE **)a2, (_DWORD *)(a1 + 16));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::EARFCN>::clone(uint64_t a1)
{
  uint64_t v2;

  v2 = operator new();
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)v2 = &off_24D5E0B70;
  *(_QWORD *)(v2 + 16) = 0;
  *(_QWORD *)(v2 + 24) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  std::vector<unsigned int>::__init_with_size[abi:ne180100]<unsigned int *,unsigned int *>((_QWORD *)(v2 + 16), *(const void **)(a1 + 16), *(_QWORD *)(a1 + 24), (uint64_t)(*(_QWORD *)(a1 + 24) - *(_QWORD *)(a1 + 16)) >> 2);
  *(_QWORD *)(v2 + 40) = 0;
  *(_QWORD *)(v2 + 48) = 0;
  *(_QWORD *)(v2 + 56) = 0;
  std::vector<unsigned int>::__init_with_size[abi:ne180100]<unsigned int *,unsigned int *>((_QWORD *)(v2 + 40), *(const void **)(a1 + 40), *(_QWORD *)(a1 + 48), (uint64_t)(*(_QWORD *)(a1 + 48) - *(_QWORD *)(a1 + 40)) >> 2);
  return v2;
}

void sub_216A2412C(_Unwind_Exception *a1)
{
  uint64_t v1;
  void **v2;
  void *v4;

  v4 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 24) = v4;
    operator delete(v4);
  }
  MEMORY[0x2199FEAC4](v1, 0x1091C4035291CF6);
  _Unwind_Resume(a1);
}

char *qmi::MutableMessageBase::getTLV<sft::tlv::LocationData>(_QWORD *a1, int a2)
{
  char v2;
  const void **v4;
  const void **v5;
  char **v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t *v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  char *v17;
  uint64_t *v18;
  char *v19;
  char *v20;
  char *v21;
  uint64_t v22;

  v2 = a2;
  v4 = (const void **)a1[1];
  v5 = (const void **)a1[2];
  v6 = (char **)(a1 + 1);
  if (v4 != v5)
  {
    while (*((unsigned __int8 *)*v4 + 8) != a2)
    {
      if (++v4 == v5)
        goto LABEL_8;
    }
  }
  if (v4 == v5)
  {
LABEL_8:
    v9 = operator new();
    *(_BYTE *)(v9 + 8) = v2;
    *(_QWORD *)v9 = &off_24D5E0BC0;
    *(_OWORD *)(v9 + 16) = 0u;
    v8 = v9 + 16;
    *(_QWORD *)(v9 + 88) = 0;
    *(_DWORD *)(v9 + 96) = 0;
    *(_DWORD *)(v9 + 144) = 0;
    *(_QWORD *)(v9 + 152) = 0;
    *(_BYTE *)(v9 + 160) = 0;
    *(_QWORD *)(v9 + 168) = 0;
    *(_OWORD *)(v9 + 32) = 0u;
    *(_OWORD *)(v9 + 48) = 0u;
    *(_OWORD *)(v9 + 64) = 0u;
    *(_DWORD *)(v9 + 80) = 0;
    *(_OWORD *)(v9 + 104) = 0u;
    *(_OWORD *)(v9 + 120) = 0u;
    *(_QWORD *)(v9 + 133) = 0;
    v10 = a1[3];
    v11 = (uint64_t *)a1[2];
    if ((unint64_t)v11 >= v10)
    {
      v13 = ((char *)v11 - *v6) >> 3;
      if ((unint64_t)(v13 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v14 = v10 - (_QWORD)*v6;
      v15 = v14 >> 2;
      if (v14 >> 2 <= (unint64_t)(v13 + 1))
        v15 = v13 + 1;
      if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8)
        v16 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v16 = v15;
      if (v16)
        v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v16);
      else
        v17 = 0;
      v18 = (uint64_t *)&v17[8 * v13];
      v19 = &v17[8 * v16];
      *v18 = v9;
      v12 = v18 + 1;
      v21 = (char *)a1[1];
      v20 = (char *)a1[2];
      if (v20 != v21)
      {
        do
        {
          v22 = *((_QWORD *)v20 - 1);
          v20 -= 8;
          *--v18 = v22;
        }
        while (v20 != v21);
        v20 = *v6;
      }
      a1[1] = v18;
      a1[2] = v12;
      a1[3] = v19;
      if (v20)
        operator delete(v20);
    }
    else
    {
      *v11 = v9;
      v12 = v11 + 1;
    }
    a1[2] = v12;
  }
  else
  {
    if (!v7)
      __cxa_bad_cast();
    return v7 + 16;
  }
  return (char *)v8;
}

_QWORD *qmi::MutableMessageBase::TlvWrapper<sft::tlv::LocationData>::~TlvWrapper(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24D5E0BC0;
  v2 = (void *)a1[14];
  if (v2)
  {
    a1[15] = v2;
    operator delete(v2);
  }
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::LocationData>::~TlvWrapper(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24D5E0BC0;
  v2 = (void *)a1[14];
  if (v2)
  {
    a1[15] = v2;
    operator delete(v2);
  }
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::LocationData>::getSize(uint64_t a1)
{
  return tlv::size<sft::tlv::LocationData>(a1 + 16);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::LocationData>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  uint64_t v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = *a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<sft::tlv::LocationData>(a2, a1 + 16);
  v7 = *a2 - v5;
  *(_BYTE *)v4 = v3;
  *(_WORD *)(v4 + 1) = v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::LocationData>::clone(uint64_t a1)
{
  uint64_t v2;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  const void *v6;
  uint64_t v7;

  v2 = operator new();
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)v2 = &off_24D5E0BC0;
  v3 = *(_OWORD *)(a1 + 64);
  *(_OWORD *)(v2 + 48) = *(_OWORD *)(a1 + 48);
  *(_OWORD *)(v2 + 64) = v3;
  v4 = *(_OWORD *)(a1 + 96);
  *(_OWORD *)(v2 + 80) = *(_OWORD *)(a1 + 80);
  *(_OWORD *)(v2 + 96) = v4;
  v5 = *(_OWORD *)(a1 + 32);
  *(_OWORD *)(v2 + 16) = *(_OWORD *)(a1 + 16);
  *(_OWORD *)(v2 + 32) = v5;
  *(_QWORD *)(v2 + 120) = 0;
  *(_QWORD *)(v2 + 128) = 0;
  v6 = *(const void **)(a1 + 112);
  v7 = *(_QWORD *)(a1 + 120);
  *(_QWORD *)(v2 + 112) = 0;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>((_QWORD *)(v2 + 112), v6, v7, v7 - (_QWORD)v6);
  *(_OWORD *)(v2 + 136) = *(_OWORD *)(a1 + 136);
  *(_OWORD *)(v2 + 152) = *(_OWORD *)(a1 + 152);
  *(_QWORD *)(v2 + 168) = *(_QWORD *)(a1 + 168);
  return v2;
}

void sub_216A24494(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199FEAC4](v1, 0x1091C40F7E97885);
  _Unwind_Resume(a1);
}

_QWORD *`anonymous namespace'::sToSftTlvLocationData(uint64_t a1, uint64_t a2, char **a3, uint64_t a4)
{
  _QWORD *result;

  *(_OWORD *)a4 = *(_OWORD *)(a2 + 8);
  *(_QWORD *)(a4 + 16) = *(_QWORD *)(a2 + 24);
  *(_OWORD *)(a4 + 24) = *(_OWORD *)(a2 + 40);
  *(_QWORD *)(a4 + 40) = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a4 + 48) = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a4 + 56) = *(_QWORD *)(a1 + 32);
  *(_DWORD *)(a4 + 64) = *(_DWORD *)(a1 + 40);
  *(_QWORD *)(a4 + 72) = *(_QWORD *)(a1 + 48);
  *(_DWORD *)(a4 + 80) = *(_DWORD *)(a1 + 56);
  *(_QWORD *)(a4 + 88) = *(_QWORD *)(a1 + 64);
  result = (_QWORD *)(a4 + 96);
  if ((char **)(a4 + 96) != a3)
    result = std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(result, *a3, a3[1], a3[1] - *a3);
  *(_DWORD *)(a4 + 120) = *(_DWORD *)(a1 + 72);
  *(_BYTE *)(a4 + 124) = *(_BYTE *)(a1 + 76);
  *(_DWORD *)(a4 + 128) = *(_DWORD *)(a1 + 80);
  *(_QWORD *)(a4 + 136) = *(_QWORD *)(a1 + 88);
  *(_BYTE *)(a4 + 144) = *(_BYTE *)(a1 + 96);
  *(_QWORD *)(a4 + 152) = *(_QWORD *)(a1 + 104);
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::CellSearch>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::CellSearch>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<sft::tlv::CellSearch>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::CellSearch>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E0C10;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::AutoInitiateRegistration>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::AutoInitiateRegistration>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<sft::tlv::AutoInitiateRegistration>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::AutoInitiateRegistration>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E0C60;
  return result;
}

char *qmi::MutableMessageBase::getTLV<sft::tlv::HeatMapData>(_QWORD *a1, int a2)
{
  char v2;
  const void **v4;
  const void **v5;
  char **v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t *v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  char *v17;
  uint64_t *v18;
  char *v19;
  char *v20;
  char *v21;
  uint64_t v22;

  v2 = a2;
  v4 = (const void **)a1[1];
  v5 = (const void **)a1[2];
  v6 = (char **)(a1 + 1);
  if (v4 != v5)
  {
    while (*((unsigned __int8 *)*v4 + 8) != a2)
    {
      if (++v4 == v5)
        goto LABEL_8;
    }
  }
  if (v4 == v5)
  {
LABEL_8:
    v9 = operator new();
    *(_BYTE *)(v9 + 8) = v2;
    *(_QWORD *)(v9 + 16) = 0;
    v8 = v9 + 16;
    *(_QWORD *)v9 = &off_24D5E0CB0;
    *(_QWORD *)(v9 + 56) = 0;
    *(_QWORD *)(v9 + 64) = 0;
    *(_QWORD *)(v9 + 48) = 0;
    *(_QWORD *)(v9 + 24) = 0;
    *(_QWORD *)(v9 + 32) = 0;
    *(_DWORD *)(v9 + 40) = 0;
    v10 = a1[3];
    v11 = (uint64_t *)a1[2];
    if ((unint64_t)v11 >= v10)
    {
      v13 = ((char *)v11 - *v6) >> 3;
      if ((unint64_t)(v13 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v14 = v10 - (_QWORD)*v6;
      v15 = v14 >> 2;
      if (v14 >> 2 <= (unint64_t)(v13 + 1))
        v15 = v13 + 1;
      if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8)
        v16 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v16 = v15;
      if (v16)
        v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v16);
      else
        v17 = 0;
      v18 = (uint64_t *)&v17[8 * v13];
      v19 = &v17[8 * v16];
      *v18 = v9;
      v12 = v18 + 1;
      v21 = (char *)a1[1];
      v20 = (char *)a1[2];
      if (v20 != v21)
      {
        do
        {
          v22 = *((_QWORD *)v20 - 1);
          v20 -= 8;
          *--v18 = v22;
        }
        while (v20 != v21);
        v20 = *v6;
      }
      a1[1] = v18;
      a1[2] = v12;
      a1[3] = v19;
      if (v20)
        operator delete(v20);
    }
    else
    {
      *v11 = v9;
      v12 = v11 + 1;
    }
    a1[2] = v12;
  }
  else
  {
    if (!v7)
      __cxa_bad_cast();
    return v7 + 16;
  }
  return (char *)v8;
}

_QWORD *qmi::MutableMessageBase::TlvWrapper<sft::tlv::HeatMapData>::~TlvWrapper(_QWORD *a1)
{
  void *v2;
  void *v3;

  *a1 = &off_24D5E0CB0;
  v2 = (void *)a1[6];
  if (v2)
  {
    a1[7] = v2;
    operator delete(v2);
  }
  v3 = (void *)a1[2];
  if (v3)
  {
    a1[3] = v3;
    operator delete(v3);
  }
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::HeatMapData>::~TlvWrapper(_QWORD *a1)
{
  void *v2;
  void *v3;

  *a1 = &off_24D5E0CB0;
  v2 = (void *)a1[6];
  if (v2)
  {
    a1[7] = v2;
    operator delete(v2);
  }
  v3 = (void *)a1[2];
  if (v3)
  {
    a1[3] = v3;
    operator delete(v3);
  }
  JUMPOUT(0x2199FEAC4);
}

unint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::HeatMapData>::getSize(uint64_t a1)
{
  return tlv::size<sft::tlv::HeatMapData>((_QWORD *)(a1 + 16));
}

_BYTE *qmi::MutableMessageBase::TlvWrapper<sft::tlv::HeatMapData>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE *result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<sft::tlv::HeatMapData>((_BYTE **)a2, (_DWORD *)(a1 + 16));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::HeatMapData>::clone(uint64_t a1)
{
  uint64_t v2;
  int v3;
  _BYTE *v4;
  _BYTE *v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;

  v2 = operator new();
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)v2 = &off_24D5E0CB0;
  *(_QWORD *)(v2 + 16) = 0;
  *(_QWORD *)(v2 + 24) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  std::vector<unsigned int>::__init_with_size[abi:ne180100]<unsigned int *,unsigned int *>((_QWORD *)(v2 + 16), *(const void **)(a1 + 16), *(_QWORD *)(a1 + 24), (uint64_t)(*(_QWORD *)(a1 + 24) - *(_QWORD *)(a1 + 16)) >> 2);
  v3 = *(_DWORD *)(a1 + 40);
  *(_QWORD *)(v2 + 48) = 0;
  *(_DWORD *)(v2 + 40) = v3;
  *(_QWORD *)(v2 + 56) = 0;
  *(_QWORD *)(v2 + 64) = 0;
  v5 = *(_BYTE **)(a1 + 48);
  v4 = *(_BYTE **)(a1 + 56);
  v6 = v4 - v5;
  if (v4 != v5)
  {
    if (0xAAAAAAAAAAAAAAABLL * (v6 >> 2) >= 0x1555555555555556)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v7 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::CurrentDataSystem>>(v2 + 64, 0xAAAAAAAAAAAAAAABLL * (v6 >> 2));
    *(_QWORD *)(v2 + 48) = v7;
    *(_QWORD *)(v2 + 56) = v7;
    *(_QWORD *)(v2 + 64) = &v7[12 * v8];
    memmove(v7, v5, v6 - 3);
    *(_QWORD *)(v2 + 56) = &v7[4 * (v6 >> 2)];
  }
  return v2;
}

void sub_216A24A90(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199FEAC4](v1, 0x10B1C4082A65931);
  _Unwind_Resume(a1);
}

void `anonymous namespace'::sToSftTlvHeatMapData(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  int v7;
  int v8;
  unsigned int v9;
  char v10;
  unint64_t v11;
  unint64_t v12;
  char *v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  char *v18;
  char *v19;
  _BYTE *v20;
  _BYTE *v21;
  char *v22;
  uint64_t v23;
  char v24;
  _QWORD *v25;
  _QWORD *v26;
  BOOL v27;
  _QWORD *v28;
  _QWORD *v29;
  _QWORD *v30;

  if (a1 + 8 != a2)
    std::vector<wds::tlv::DestPortRangeInfo>::__assign_with_size[abi:ne180100]<wds::tlv::DestPortRangeInfo*,wds::tlv::DestPortRangeInfo*>((char *)a2, *(char **)(a1 + 8), *(_QWORD *)(a1 + 16), (uint64_t)(*(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8)) >> 2);
  *(_DWORD *)(a2 + 24) = *(_DWORD *)(a1 + 32);
  v4 = *(_QWORD **)(a1 + 40);
  v30 = (_QWORD *)(a1 + 48);
  if (v4 != (_QWORD *)(a1 + 48))
  {
    v5 = (_QWORD *)(a2 + 32);
    do
    {
      v6 = (_QWORD *)v4[5];
      if (v6 != v4 + 6)
      {
        do
        {
          v7 = *((_DWORD *)v4 + 8);
          v8 = *((_DWORD *)v6 + 7);
          v9 = *((unsigned __int8 *)v6 + 32);
          if (v9 >= 5)
            v10 = 0;
          else
            v10 = v9 - 1;
          v11 = *(_QWORD *)(a2 + 40);
          v12 = *(_QWORD *)(a2 + 48);
          if (v11 >= v12)
          {
            v14 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v11 - *v5) >> 2);
            v15 = v14 + 1;
            if (v14 + 1 > 0x1555555555555555)
              std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
            v16 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v12 - *v5) >> 2);
            if (2 * v16 > v15)
              v15 = 2 * v16;
            if (v16 >= 0xAAAAAAAAAAAAAAALL)
              v17 = 0x1555555555555555;
            else
              v17 = v15;
            if (v17)
              v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::CurrentDataSystem>>(a2 + 48, v17);
            else
              v18 = 0;
            v19 = &v18[12 * v14];
            *(_DWORD *)v19 = v7;
            *((_DWORD *)v19 + 1) = v8;
            v19[8] = v10;
            *(_WORD *)(v19 + 9) = 0;
            v19[11] = 0;
            v21 = *(_BYTE **)(a2 + 32);
            v20 = *(_BYTE **)(a2 + 40);
            v22 = v19;
            if (v20 != v21)
            {
              do
              {
                v23 = *(_QWORD *)(v20 - 12);
                v20 -= 12;
                v24 = v20[8];
                *(_QWORD *)(v22 - 12) = v23;
                v22 -= 12;
                v22[8] = v24;
              }
              while (v20 != v21);
              v20 = (_BYTE *)*v5;
            }
            v13 = v19 + 12;
            *(_QWORD *)(a2 + 32) = v22;
            *(_QWORD *)(a2 + 40) = v19 + 12;
            *(_QWORD *)(a2 + 48) = &v18[12 * v17];
            if (v20)
              operator delete(v20);
          }
          else
          {
            *(_DWORD *)v11 = v7;
            *(_DWORD *)(v11 + 4) = v8;
            *(_BYTE *)(v11 + 8) = v10;
            *(_WORD *)(v11 + 9) = 0;
            v13 = (char *)(v11 + 12);
            *(_BYTE *)(v11 + 11) = 0;
          }
          *(_QWORD *)(a2 + 40) = v13;
          v25 = (_QWORD *)v6[1];
          if (v25)
          {
            do
            {
              v26 = v25;
              v25 = (_QWORD *)*v25;
            }
            while (v25);
          }
          else
          {
            do
            {
              v26 = (_QWORD *)v6[2];
              v27 = *v26 == (_QWORD)v6;
              v6 = v26;
            }
            while (!v27);
          }
          v6 = v26;
        }
        while (v26 != v4 + 6);
      }
      v28 = (_QWORD *)v4[1];
      if (v28)
      {
        do
        {
          v29 = v28;
          v28 = (_QWORD *)*v28;
        }
        while (v28);
      }
      else
      {
        do
        {
          v29 = (_QWORD *)v4[2];
          v27 = *v29 == (_QWORD)v4;
          v4 = v29;
        }
        while (!v27);
      }
      v4 = v29;
    }
    while (v29 != v30);
  }
}

uint64_t ___ZN22QMIStewieCommandDriver4sendIN3sft10Activation7RequestEZNS_8activateE19StewieRequestReason24StewieSPSEnvironmentTypeRK22StewieProvisioningDataRK18StewieTimeFreqDataRK18StewieLocationDataRK25StewieSecurityCredentialsRKNSt3__110shared_ptrIK13StewieHeatMapEEbONSI_8functionIFvbONSI_8optionalINSI_6chrono8durationIxNSI_5ratioILl1ELl1000EEEEEEEEEEE4__10EEvRKT_OT0__block_invoke(uint64_t a1, qmi::MessageBase *this)
{
  uint64_t *v2;
  uint64_t v3;
  int v4;
  uint64_t TlvValue;
  int v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  NSObject *v11;
  uint64_t v12;
  NSObject *v14;
  unint64_t v15[2];
  uint8_t buf[8];
  _QWORD v17[3];

  v17[2] = *MEMORY[0x24BDAC8D0];
  v2 = *(uint64_t **)(a1 + 32);
  v3 = *v2;
  v4 = *((_DWORD *)this + 1);
  if (v4)
  {
    v14 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109378;
      *(_DWORD *)&buf[4] = v4;
      LOWORD(v17[0]) = 2080;
      *(_QWORD *)((char *)v17 + 2) = qmi::asString();
      _os_log_error_impl(&dword_216897000, v14, OS_LOG_TYPE_ERROR, "Failed to execute Activation request. Error code:0x%x (%s)", buf, 0x12u);
    }
    buf[0] = 0;
    LOBYTE(v17[0]) = 0;
    LOBYTE(v15[0]) = 0;
  }
  else
  {
    *(_QWORD *)buf = 0;
    v17[0] = 0;
    TlvValue = qmi::MessageBase::findTlvValue(this);
    if (TlvValue)
    {
      v8 = TlvValue;
      v9 = v7;
      v15[0] = TlvValue;
      v10 = tlv::parseV<sft::tlv::SftTxDeferTime>(v15, v7);
      if (v15[0])
      {
        LOBYTE(v17[0]) = 1;
        *(_QWORD *)buf = v10;
      }
      else
      {
        ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)this, 16, v8, v9);
      }
    }
    v11 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v15[0]) = 0;
      _os_log_impl(&dword_216897000, v11, OS_LOG_TYPE_DEFAULT, "#I Activation request succeeded. Waiting for indication", (uint8_t *)v15, 2u);
    }
    LOBYTE(v15[0]) = 1;
  }
  v12 = v2[4];
  if (!v12)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, unint64_t *, uint8_t *))(*(_QWORD *)v12 + 48))(v12, v15, buf);
}

uint64_t __copy_helper_block_e8_32c322_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver8activateE19StewieRequestReason24StewieSPSEnvironmentTypeRK22StewieProvisioningDataRK18StewieTimeFreqDataRK18StewieLocationDataRK25StewieSecurityCredentialsRKNS0_IK13StewieHeatMapEEbONS_8functionIFvbONS_8optionalINS_6chrono8durationIxNS_5ratioILl1ELl1000EEEEEEEEEEE4__10EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c322_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver8activateE19StewieRequestReason24StewieSPSEnvironmentTypeRK22StewieProvisioningDataRK18StewieTimeFreqDataRK18StewieLocationDataRK25StewieSecurityCredentialsRKNS0_IK13StewieHeatMapEEbONS_8functionIFvbONS_8optionalINS_6chrono8durationIxNS_5ratioILl1ELl1000EEEEEEEEEEE4__10EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::activate(StewieRequestReason,StewieSPSEnvironmentType,StewieProvisioningData const&,StewieTimeFreqData const&,StewieLocationData const&,StewieSecurityCredentials const&,std::shared_ptr<StewieHeatMap const> const&,BOOL,std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &&)::$_10,std::allocator<std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E0D18;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::activate(StewieRequestReason,StewieSPSEnvironmentType,StewieProvisioningData const&,StewieTimeFreqData const&,StewieLocationData const&,StewieSecurityCredentials const&,std::shared_ptr<StewieHeatMap const> const&,BOOL,std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &&)::$_10,std::allocator<std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E0D18;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__shared_ptr_emplace<QMIStewieCommandDriver::activate(StewieRequestReason,StewieSPSEnvironmentType,StewieProvisioningData const&,StewieTimeFreqData const&,StewieLocationData const&,StewieSecurityCredentials const&,std::shared_ptr<StewieHeatMap const> const&,BOOL,std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &&)::$_10,std::allocator<std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &>>::__on_zero_shared(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *result;
  uint64_t v3;

  v1 = (_QWORD *)(a1 + 32);
  result = *(_QWORD **)(a1 + 56);
  if (result == v1)
  {
    v3 = 4;
    result = v1;
  }
  else
  {
    if (!result)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3sft10Activation8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A25014(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute_wrapped<QMIStewieCommandDriver::deactivate(StewieExitReason,std::function<void ()(BOOL)> &&)::$_0>(QMIStewieCommandDriver::deactivate(StewieExitReason,std::function<void ()(BOOL)> &&)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIStewieCommandDriver::deactivate(StewieExitReason,std::function<void ()(BOOL)> &&)::$_0,std::default_delete<QMIStewieCommandDriver::deactivate(StewieExitReason,std::function<void ()(BOOL)> &&)::$_0>>)::{lambda(void *)#1}::__invoke(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  _QWORD *v4;
  uint64_t v5;
  char v6;

  v1 = *a1;
  v4 = a1;
  v5 = v1;
  v6 = 0;
  v2 = *(_QWORD *)(v1 + 24);
  if (!v2)
    std::__throw_bad_function_call[abi:ne180100]();
  (*(void (**)(uint64_t, char *))(*(_QWORD *)v2 + 48))(v2, &v6);
  std::unique_ptr<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0,std::default_delete<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0>>::~unique_ptr[abi:ne180100](&v5);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v4);
}

void sub_216A250B0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3;
  va_list va;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  std::unique_ptr<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0,std::default_delete<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0>>::~unique_ptr[abi:ne180100]((uint64_t *)va1);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::DeactivationReason>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::DeactivationReason>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<sft::tlv::DeactivationReason>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::DeactivationReason>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E0DA8;
  return result;
}

uint64_t ___ZN22QMIStewieCommandDriver4sendIN3sft12Deactivation7RequestEZNS_10deactivateE16StewieExitReasonONSt3__18functionIFvbEEEE3__2EEvRKT_OT0__block_invoke(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  int v3;
  NSObject *v4;
  uint64_t v5;
  _DWORD v7[2];
  __int16 v8;
  uint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD **)(a1 + 32);
  v3 = *(_DWORD *)(a2 + 4);
  v4 = *(NSObject **)(*v2 + 40);
  if (v3)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v7[0] = 67109378;
      v7[1] = v3;
      v8 = 2080;
      v9 = qmi::asString();
      _os_log_error_impl(&dword_216897000, v4, OS_LOG_TYPE_ERROR, "Failed to execute Deactivation request. Error code:0x%x (%s)", (uint8_t *)v7, 0x12u);
    }
    LOBYTE(v7[0]) = 0;
  }
  else
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v7[0]) = 0;
      _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I Deactivation request succeeded. Waiting for indication", (uint8_t *)v7, 2u);
    }
    LOBYTE(v7[0]) = 1;
  }
  v5 = v2[4];
  if (!v5)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, _DWORD *))(*(_QWORD *)v5 + 48))(v5, v7);
}

uint64_t __copy_helper_block_e8_32c108_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver10deactivateE16StewieExitReasonONS_8functionIFvbEEEE3__2EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c108_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver10deactivateE16StewieExitReasonONS_8functionIFvbEEEE3__2EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::deactivate(StewieExitReason,std::function<void ()(BOOL)> &&)::$_2,std::allocator<std::function<void ()(BOOL)> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E0E10;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::deactivate(StewieExitReason,std::function<void ()(BOOL)> &&)::$_2,std::allocator<std::function<void ()(BOOL)> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E0E10;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__shared_ptr_emplace<QMIStewieCommandDriver::deactivate(StewieExitReason,std::function<void ()(BOOL)> &&)::$_2,std::allocator<std::function<void ()(BOOL)> &&>>::__on_zero_shared(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *result;
  uint64_t v3;

  v1 = (_QWORD *)(a1 + 32);
  result = *(_QWORD **)(a1 + 56);
  if (result == v1)
  {
    v3 = 4;
    result = v1;
  }
  else
  {
    if (!result)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute_wrapped<QMIStewieCommandDriver::setConcurrencyConfig(BOOL,std::function<void ()(BOOL)> &&)::$_0>(QMIStewieCommandDriver::setConcurrencyConfig(BOOL,std::function<void ()(BOOL)> &&)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIStewieCommandDriver::setConcurrencyConfig(BOOL,std::function<void ()(BOOL)> &&)::$_0,std::default_delete<QMIStewieCommandDriver::setConcurrencyConfig(BOOL,std::function<void ()(BOOL)> &&)::$_0>>)::{lambda(void *)#1}::__invoke(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  _QWORD *v4;
  uint64_t v5;
  char v6;

  v1 = *a1;
  v4 = a1;
  v5 = v1;
  v6 = 0;
  v2 = *(_QWORD *)(v1 + 24);
  if (!v2)
    std::__throw_bad_function_call[abi:ne180100]();
  (*(void (**)(uint64_t, char *))(*(_QWORD *)v2 + 48))(v2, &v6);
  std::unique_ptr<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0,std::default_delete<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0>>::~unique_ptr[abi:ne180100](&v5);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v4);
}

void sub_216A253B0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3;
  va_list va;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  std::unique_ptr<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0,std::default_delete<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0>>::~unique_ptr[abi:ne180100]((uint64_t *)va1);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::ProvisioningStatus>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::ProvisioningStatus>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<sft::tlv::ProvisioningStatus>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::ProvisioningStatus>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E0E78;
  return result;
}

uint64_t ___ZN22QMIStewieCommandDriver4sendIN3sft20SetConcurrencyConfig7RequestEZNS_20setConcurrencyConfigEbONSt3__18functionIFvbEEEE3__2EEvRKT_OT0__block_invoke(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  int v3;
  NSObject *v4;
  uint64_t v5;
  _DWORD v7[2];
  __int16 v8;
  uint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD **)(a1 + 32);
  v3 = *(_DWORD *)(a2 + 4);
  v4 = *(NSObject **)(*v2 + 40);
  if (v3)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v7[0] = 67109378;
      v7[1] = v3;
      v8 = 2080;
      v9 = qmi::asString();
      _os_log_error_impl(&dword_216897000, v4, OS_LOG_TYPE_ERROR, "Failed to execute SetConcurrencyConfig. Error code:0x%x (%s)", (uint8_t *)v7, 0x12u);
    }
    LOBYTE(v7[0]) = 0;
  }
  else
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v7[0]) = 0;
      _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I SetConcurrencyConfig succeeded", (uint8_t *)v7, 2u);
    }
    LOBYTE(v7[0]) = 1;
  }
  v5 = v2[4];
  if (!v5)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, _DWORD *))(*(_QWORD *)v5 + 48))(v5, v7);
}

uint64_t __copy_helper_block_e8_32c101_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver20setConcurrencyConfigEbONS_8functionIFvbEEEE3__2EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c101_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver20setConcurrencyConfigEbONS_8functionIFvbEEEE3__2EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::setConcurrencyConfig(BOOL,std::function<void ()(BOOL)> &&)::$_2,std::allocator<std::function<void ()(BOOL)> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E0EE0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::setConcurrencyConfig(BOOL,std::function<void ()(BOOL)> &&)::$_2,std::allocator<std::function<void ()(BOOL)> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E0EE0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__shared_ptr_emplace<QMIStewieCommandDriver::setConcurrencyConfig(BOOL,std::function<void ()(BOOL)> &&)::$_2,std::allocator<std::function<void ()(BOOL)> &&>>::__on_zero_shared(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *result;
  uint64_t v3;

  v1 = (_QWORD *)(a1 + 32);
  result = *(_QWORD **)(a1 + 56);
  if (result == v1)
  {
    v3 = 4;
    result = v1;
  }
  else
  {
    if (!result)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute_wrapped<QMIStewieCommandDriver::suspend(StewieSuspendReason,std::function<void ()(BOOL)> &&)::$_0>(QMIStewieCommandDriver::suspend(StewieSuspendReason,std::function<void ()(BOOL)> &&)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIStewieCommandDriver::suspend(StewieSuspendReason,std::function<void ()(BOOL)> &&)::$_0,std::default_delete<QMIStewieCommandDriver::suspend(StewieSuspendReason,std::function<void ()(BOOL)> &&)::$_0>>)::{lambda(void *)#1}::__invoke(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  _QWORD *v4;
  uint64_t v5;
  char v6;

  v1 = *a1;
  v4 = a1;
  v5 = v1;
  v6 = 0;
  v2 = *(_QWORD *)(v1 + 24);
  if (!v2)
    std::__throw_bad_function_call[abi:ne180100]();
  (*(void (**)(uint64_t, char *))(*(_QWORD *)v2 + 48))(v2, &v6);
  std::unique_ptr<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0,std::default_delete<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0>>::~unique_ptr[abi:ne180100](&v5);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v4);
}

void sub_216A256B0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3;
  va_list va;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  std::unique_ptr<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0,std::default_delete<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0>>::~unique_ptr[abi:ne180100]((uint64_t *)va1);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::SuspendReason>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::SuspendReason>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<sft::tlv::SuspendReason>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::SuspendReason>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E0F48;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::ServiceDomainPref>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::ServiceDomainPref>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<sft::tlv::ServiceDomainPref>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::ServiceDomainPref>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E0F98;
  return result;
}

uint64_t ___ZN22QMIStewieCommandDriver4sendIN3sft7Suspend7RequestEZNS_7suspendE19StewieSuspendReasonONSt3__18functionIFvbEEEE3__3EEvRKT_OT0__block_invoke(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  int v3;
  NSObject *v4;
  uint64_t v5;
  _DWORD v7[2];
  __int16 v8;
  uint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD **)(a1 + 32);
  v3 = *(_DWORD *)(a2 + 4);
  v4 = *(NSObject **)(*v2 + 40);
  if (v3)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v7[0] = 67109378;
      v7[1] = v3;
      v8 = 2080;
      v9 = qmi::asString();
      _os_log_error_impl(&dword_216897000, v4, OS_LOG_TYPE_ERROR, "Failed to execute Suspend. Error code:0x%x (%s)", (uint8_t *)v7, 0x12u);
    }
    LOBYTE(v7[0]) = 0;
  }
  else
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v7[0]) = 0;
      _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I Suspend succeeded", (uint8_t *)v7, 2u);
    }
    LOBYTE(v7[0]) = 1;
  }
  v5 = v2[4];
  if (!v5)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, _DWORD *))(*(_QWORD *)v5 + 48))(v5, v7);
}

uint64_t __copy_helper_block_e8_32c107_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver7suspendE19StewieSuspendReasonONS_8functionIFvbEEEE3__3EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c107_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver7suspendE19StewieSuspendReasonONS_8functionIFvbEEEE3__3EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::suspend(StewieSuspendReason,std::function<void ()(BOOL)> &&)::$_3,std::allocator<std::function<void ()(BOOL)> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E1000;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::suspend(StewieSuspendReason,std::function<void ()(BOOL)> &&)::$_3,std::allocator<std::function<void ()(BOOL)> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E1000;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__shared_ptr_emplace<QMIStewieCommandDriver::suspend(StewieSuspendReason,std::function<void ()(BOOL)> &&)::$_3,std::allocator<std::function<void ()(BOOL)> &&>>::__on_zero_shared(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *result;
  uint64_t v3;

  v1 = (_QWORD *)(a1 + 32);
  result = *(_QWORD **)(a1 + 56);
  if (result == v1)
  {
    v3 = 4;
    result = v1;
  }
  else
  {
    if (!result)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute_wrapped<QMIStewieCommandDriver::resume(StewieTimeFreqData const&,StewieLocationData const&,StewieEARFCN const&,std::vector<unsigned char> const&,std::shared_ptr<StewieHeatMap const> const&,std::function<void ()(BOOL)> &&)::$_0>(QMIStewieCommandDriver::resume(StewieTimeFreqData const&,StewieLocationData const&,StewieEARFCN const&,std::vector<unsigned char> const&,std::shared_ptr<StewieHeatMap const> const&,std::function<void ()(BOOL)> &&)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIStewieCommandDriver::resume(StewieTimeFreqData const&,StewieLocationData const&,StewieEARFCN const&,std::vector<unsigned char> const&,std::shared_ptr<StewieHeatMap const> const&,std::function<void ()(BOOL)> &&)::$_0,std::default_delete<QMIStewieCommandDriver::resume(StewieTimeFreqData const&,StewieLocationData const&,StewieEARFCN const&,std::vector<unsigned char> const&,std::shared_ptr<StewieHeatMap const> const&,std::function<void ()(BOOL)> &&)::$_0>>)::{lambda(void *)#1}::__invoke(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  _QWORD *v4;
  uint64_t v5;
  char v6;

  v1 = *a1;
  v4 = a1;
  v5 = v1;
  v6 = 0;
  v2 = *(_QWORD *)(v1 + 24);
  if (!v2)
    std::__throw_bad_function_call[abi:ne180100]();
  (*(void (**)(uint64_t, char *))(*(_QWORD *)v2 + 48))(v2, &v6);
  std::unique_ptr<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0,std::default_delete<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0>>::~unique_ptr[abi:ne180100](&v5);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v4);
}

void sub_216A25A70(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3;
  va_list va;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  std::unique_ptr<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0,std::default_delete<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0>>::~unique_ptr[abi:ne180100]((uint64_t *)va1);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN22QMIStewieCommandDriver4sendIN3sft6Resume7RequestEZNS_6resumeERK18StewieTimeFreqDataRK18StewieLocationDataRK12StewieEARFCNRKNSt3__16vectorIhNSD_9allocatorIhEEEERKNSD_10shared_ptrIK13StewieHeatMapEEONSD_8functionIFvbEEEE3__4EEvRKT_OT0__block_invoke(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  int v3;
  NSObject *v4;
  uint64_t v5;
  _DWORD v7[2];
  __int16 v8;
  uint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD **)(a1 + 32);
  v3 = *(_DWORD *)(a2 + 4);
  v4 = *(NSObject **)(*v2 + 40);
  if (v3)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v7[0] = 67109378;
      v7[1] = v3;
      v8 = 2080;
      v9 = qmi::asString();
      _os_log_error_impl(&dword_216897000, v4, OS_LOG_TYPE_ERROR, "Failed to execute Resume. Error code:0x%x (%s)", (uint8_t *)v7, 0x12u);
    }
    LOBYTE(v7[0]) = 0;
  }
  else
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v7[0]) = 0;
      _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I Resume succeeded", (uint8_t *)v7, 2u);
    }
    LOBYTE(v7[0]) = 1;
  }
  v5 = v2[4];
  if (!v5)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, _DWORD *))(*(_QWORD *)v5 + 48))(v5, v7);
}

uint64_t __copy_helper_block_e8_32c203_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver6resumeERK18StewieTimeFreqDataRK18StewieLocationDataRK12StewieEARFCNRKNS_6vectorIhNS_9allocatorIhEEEERKNS0_IK13StewieHeatMapEEONS_8functionIFvbEEEE3__4EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c203_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver6resumeERK18StewieTimeFreqDataRK18StewieLocationDataRK12StewieEARFCNRKNS_6vectorIhNS_9allocatorIhEEEERKNS0_IK13StewieHeatMapEEONS_8functionIFvbEEEE3__4EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::resume(StewieTimeFreqData const&,StewieLocationData const&,StewieEARFCN const&,std::vector<unsigned char> const&,std::shared_ptr<StewieHeatMap const> const&,std::function<void ()(BOOL)> &&)::$_4,std::allocator<std::function<void ()(BOOL)> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E1080;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::resume(StewieTimeFreqData const&,StewieLocationData const&,StewieEARFCN const&,std::vector<unsigned char> const&,std::shared_ptr<StewieHeatMap const> const&,std::function<void ()(BOOL)> &&)::$_4,std::allocator<std::function<void ()(BOOL)> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E1080;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__shared_ptr_emplace<QMIStewieCommandDriver::resume(StewieTimeFreqData const&,StewieLocationData const&,StewieEARFCN const&,std::vector<unsigned char> const&,std::shared_ptr<StewieHeatMap const> const&,std::function<void ()(BOOL)> &&)::$_4,std::allocator<std::function<void ()(BOOL)> &&>>::__on_zero_shared(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *result;
  uint64_t v3;

  v1 = (_QWORD *)(a1 + 32);
  result = *(_QWORD **)(a1 + 56);
  if (result == v1)
  {
    v3 = 4;
    result = v1;
  }
  else
  {
    if (!result)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute_wrapped<QMIStewieCommandDriver::initiateRegistration(std::function<void ()(BOOL)> &&)::$_0>(QMIStewieCommandDriver::initiateRegistration(std::function<void ()(BOOL)> &&)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIStewieCommandDriver::initiateRegistration(std::function<void ()(BOOL)> &&)::$_0,std::default_delete<QMIStewieCommandDriver::initiateRegistration(std::function<void ()(BOOL)> &&)::$_0>>)::{lambda(void *)#1}::__invoke(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  _QWORD *v4;
  uint64_t v5;
  char v6;

  v1 = *a1;
  v4 = a1;
  v5 = v1;
  v6 = 0;
  v2 = *(_QWORD *)(v1 + 24);
  if (!v2)
    std::__throw_bad_function_call[abi:ne180100]();
  (*(void (**)(uint64_t, char *))(*(_QWORD *)v2 + 48))(v2, &v6);
  std::unique_ptr<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0,std::default_delete<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0>>::~unique_ptr[abi:ne180100](&v5);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v4);
}

void sub_216A25CB0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3;
  va_list va;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  std::unique_ptr<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0,std::default_delete<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0>>::~unique_ptr[abi:ne180100]((uint64_t *)va1);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN22QMIStewieCommandDriver4sendIN3sft20InitiateRegistration7RequestEZNS_20initiateRegistrationEONSt3__18functionIFvbEEEE3__1EEvRKT_OT0__block_invoke(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  int v3;
  NSObject *v4;
  uint64_t v5;
  _DWORD v7[2];
  __int16 v8;
  uint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD **)(a1 + 32);
  v3 = *(_DWORD *)(a2 + 4);
  v4 = *(NSObject **)(*v2 + 40);
  if (v3)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v7[0] = 67109378;
      v7[1] = v3;
      v8 = 2080;
      v9 = qmi::asString();
      _os_log_error_impl(&dword_216897000, v4, OS_LOG_TYPE_ERROR, "Failed to execute InitiateRegistration. Error code:0x%x (%s)", (uint8_t *)v7, 0x12u);
    }
    LOBYTE(v7[0]) = 0;
  }
  else
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v7[0]) = 0;
      _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I InitiateRegistration succeeded", (uint8_t *)v7, 2u);
    }
    LOBYTE(v7[0]) = 1;
  }
  v5 = v2[4];
  if (!v5)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, _DWORD *))(*(_QWORD *)v5 + 48))(v5, v7);
}

uint64_t __copy_helper_block_e8_32c100_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver20initiateRegistrationEONS_8functionIFvbEEEE3__1EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c100_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver20initiateRegistrationEONS_8functionIFvbEEEE3__1EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::initiateRegistration(std::function<void ()(BOOL)> &&)::$_1,std::allocator<std::function<void ()(BOOL)> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E1100;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::initiateRegistration(std::function<void ()(BOOL)> &&)::$_1,std::allocator<std::function<void ()(BOOL)> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E1100;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__shared_ptr_emplace<QMIStewieCommandDriver::initiateRegistration(std::function<void ()(BOOL)> &&)::$_1,std::allocator<std::function<void ()(BOOL)> &&>>::__on_zero_shared(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *result;
  uint64_t v3;

  v1 = (_QWORD *)(a1 + 32);
  result = *(_QWORD **)(a1 + 56);
  if (result == v1)
  {
    v3 = 4;
    result = v1;
  }
  else
  {
    if (!result)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute_wrapped<QMIStewieCommandDriver::requestServiceInfo(std::function<void ()(BOOL)> &&)::$_0>(QMIStewieCommandDriver::requestServiceInfo(std::function<void ()(BOOL)> &&)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIStewieCommandDriver::requestServiceInfo(std::function<void ()(BOOL)> &&)::$_0,std::default_delete<QMIStewieCommandDriver::requestServiceInfo(std::function<void ()(BOOL)> &&)::$_0>>)::{lambda(void *)#1}::__invoke(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  _QWORD *v4;
  uint64_t v5;
  char v6;

  v1 = *a1;
  v4 = a1;
  v5 = v1;
  v6 = 0;
  v2 = *(_QWORD *)(v1 + 24);
  if (!v2)
    std::__throw_bad_function_call[abi:ne180100]();
  (*(void (**)(uint64_t, char *))(*(_QWORD *)v2 + 48))(v2, &v6);
  std::unique_ptr<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0,std::default_delete<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0>>::~unique_ptr[abi:ne180100](&v5);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v4);
}

void sub_216A25EF0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3;
  va_list va;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  std::unique_ptr<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0,std::default_delete<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0>>::~unique_ptr[abi:ne180100]((uint64_t *)va1);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN22QMIStewieCommandDriver4sendIN3sft14GetServiceInfo7RequestEZNS_18requestServiceInfoEONSt3__18functionIFvbEEEE3__1EEvRKT_OT0__block_invoke(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  int v3;
  NSObject *v4;
  uint64_t v5;
  _DWORD v7[2];
  __int16 v8;
  uint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD **)(a1 + 32);
  v3 = *(_DWORD *)(a2 + 4);
  v4 = *(NSObject **)(*v2 + 40);
  if (v3)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v7[0] = 67109378;
      v7[1] = v3;
      v8 = 2080;
      v9 = qmi::asString();
      _os_log_error_impl(&dword_216897000, v4, OS_LOG_TYPE_ERROR, "Failed to execute GetServiceInfo. Error code:0x%x (%s)", (uint8_t *)v7, 0x12u);
    }
    LOBYTE(v7[0]) = 0;
  }
  else
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v7[0]) = 0;
      _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I GetServiceInfo succeeded", (uint8_t *)v7, 2u);
    }
    LOBYTE(v7[0]) = 1;
  }
  v5 = v2[4];
  if (!v5)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, _DWORD *))(*(_QWORD *)v5 + 48))(v5, v7);
}

uint64_t __copy_helper_block_e8_32c98_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver18requestServiceInfoEONS_8functionIFvbEEEE3__1EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c98_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver18requestServiceInfoEONS_8functionIFvbEEEE3__1EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::requestServiceInfo(std::function<void ()(BOOL)> &&)::$_1,std::allocator<std::function<void ()(BOOL)> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E1180;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::requestServiceInfo(std::function<void ()(BOOL)> &&)::$_1,std::allocator<std::function<void ()(BOOL)> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E1180;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__shared_ptr_emplace<QMIStewieCommandDriver::requestServiceInfo(std::function<void ()(BOOL)> &&)::$_1,std::allocator<std::function<void ()(BOOL)> &&>>::__on_zero_shared(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *result;
  uint64_t v3;

  v1 = (_QWORD *)(a1 + 32);
  result = *(_QWORD **)(a1 + 56);
  if (result == v1)
  {
    v3 = 4;
    result = v1;
  }
  else
  {
    if (!result)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute_wrapped<QMIStewieCommandDriver::setSecurityConfig(StewieSecurityCredentials const&,std::function<void ()(BOOL)> &&)::$_0>(QMIStewieCommandDriver::setSecurityConfig(StewieSecurityCredentials const&,std::function<void ()(BOOL)> &&)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIStewieCommandDriver::setSecurityConfig(StewieSecurityCredentials const&,std::function<void ()(BOOL)> &&)::$_0,std::default_delete<QMIStewieCommandDriver::setSecurityConfig(StewieSecurityCredentials const&,std::function<void ()(BOOL)> &&)::$_0>>)::{lambda(void *)#1}::__invoke(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  _QWORD *v4;
  uint64_t v5;
  char v6;

  v1 = *a1;
  v4 = a1;
  v5 = v1;
  v6 = 0;
  v2 = *(_QWORD *)(v1 + 24);
  if (!v2)
    std::__throw_bad_function_call[abi:ne180100]();
  (*(void (**)(uint64_t, char *))(*(_QWORD *)v2 + 48))(v2, &v6);
  std::unique_ptr<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0,std::default_delete<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0>>::~unique_ptr[abi:ne180100](&v5);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v4);
}

void sub_216A26130(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3;
  va_list va;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  std::unique_ptr<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0,std::default_delete<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0>>::~unique_ptr[abi:ne180100]((uint64_t *)va1);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN22QMIStewieCommandDriver4sendIN3sft17SetSecurityConfig7RequestEZNS_17setSecurityConfigERK25StewieSecurityCredentialsONSt3__18functionIFvbEEEE3__2EEvRKT_OT0__block_invoke(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  int v3;
  NSObject *v4;
  uint64_t v5;
  _DWORD v7[2];
  __int16 v8;
  uint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD **)(a1 + 32);
  v3 = *(_DWORD *)(a2 + 4);
  v4 = *(NSObject **)(*v2 + 40);
  if (v3)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v7[0] = 67109378;
      v7[1] = v3;
      v8 = 2080;
      v9 = qmi::asString();
      _os_log_error_impl(&dword_216897000, v4, OS_LOG_TYPE_ERROR, "Failed to execute SetSecurityConfig. Error code:0x%x (%s)", (uint8_t *)v7, 0x12u);
    }
    LOBYTE(v7[0]) = 0;
  }
  else
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v7[0]) = 0;
      _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I SetSecurityConfig succeeded", (uint8_t *)v7, 2u);
    }
    LOBYTE(v7[0]) = 1;
  }
  v5 = v2[4];
  if (!v5)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, _DWORD *))(*(_QWORD *)v5 + 48))(v5, v7);
}

uint64_t __copy_helper_block_e8_32c126_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver17setSecurityConfigERK25StewieSecurityCredentialsONS_8functionIFvbEEEE3__2EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c126_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver17setSecurityConfigERK25StewieSecurityCredentialsONS_8functionIFvbEEEE3__2EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::setSecurityConfig(StewieSecurityCredentials const&,std::function<void ()(BOOL)> &&)::$_2,std::allocator<std::function<void ()(BOOL)> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E1200;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::setSecurityConfig(StewieSecurityCredentials const&,std::function<void ()(BOOL)> &&)::$_2,std::allocator<std::function<void ()(BOOL)> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E1200;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__shared_ptr_emplace<QMIStewieCommandDriver::setSecurityConfig(StewieSecurityCredentials const&,std::function<void ()(BOOL)> &&)::$_2,std::allocator<std::function<void ()(BOOL)> &&>>::__on_zero_shared(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *result;
  uint64_t v3;

  v1 = (_QWORD *)(a1 + 32);
  result = *(_QWORD **)(a1 + 56);
  if (result == v1)
  {
    v3 = 4;
    result = v1;
  }
  else
  {
    if (!result)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute_wrapped<QMIStewieCommandDriver::updateOrientation(StewieDeviceOrientationData const&,std::function<void ()(BOOL)> &&)::$_0>(QMIStewieCommandDriver::updateOrientation(StewieDeviceOrientationData const&,std::function<void ()(BOOL)> &&)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIStewieCommandDriver::updateOrientation(StewieDeviceOrientationData const&,std::function<void ()(BOOL)> &&)::$_0,std::default_delete<QMIStewieCommandDriver::updateOrientation(StewieDeviceOrientationData const&,std::function<void ()(BOOL)> &&)::$_0>>)::{lambda(void *)#1}::__invoke(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  _QWORD *v4;
  uint64_t v5;
  char v6;

  v1 = *a1;
  v4 = a1;
  v5 = v1;
  v6 = 0;
  v2 = *(_QWORD *)(v1 + 24);
  if (!v2)
    std::__throw_bad_function_call[abi:ne180100]();
  (*(void (**)(uint64_t, char *))(*(_QWORD *)v2 + 48))(v2, &v6);
  std::unique_ptr<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0,std::default_delete<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0>>::~unique_ptr[abi:ne180100](&v5);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v4);
}

void sub_216A26370(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3;
  va_list va;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  std::unique_ptr<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0,std::default_delete<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0>>::~unique_ptr[abi:ne180100]((uint64_t *)va1);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::TargetLocked>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::TargetLocked>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<sft::tlv::TargetLocked>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::TargetLocked>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E1268;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::DeviceStationary>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::DeviceStationary>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<sft::tlv::DeviceStationary>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::DeviceStationary>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E12B8;
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::Orientation>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::Orientation>::getSize()
{
  return tlv::size<wds::tlv::PktDataHandle>();
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::Orientation>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _DWORD *v4;
  uint64_t v5;
  char *v6;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_DWORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  tlv::writeV<sft::tlv::Orientation>((_DWORD **)a2, (float *)(a1 + 12));
  v6 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v6;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::Orientation>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E1308;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a1 + 12);
  return result;
}

uint64_t ___ZN22QMIStewieCommandDriver4sendIN3sft23UpdateDeviceOrientation7RequestEZNS_17updateOrientationERK27StewieDeviceOrientationDataONSt3__18functionIFvbEEEE3__4EEvRKT_OT0__block_invoke(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  int v3;
  NSObject *v4;
  uint64_t v5;
  _DWORD v7[2];
  __int16 v8;
  uint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD **)(a1 + 32);
  v3 = *(_DWORD *)(a2 + 4);
  v4 = *(NSObject **)(*v2 + 40);
  if (v3)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v7[0] = 67109378;
      v7[1] = v3;
      v8 = 2080;
      v9 = qmi::asString();
      _os_log_error_impl(&dword_216897000, v4, OS_LOG_TYPE_ERROR, "Failed to execute UpdateDeviceOrientation. Error code:0x%x (%s)", (uint8_t *)v7, 0x12u);
    }
    LOBYTE(v7[0]) = 0;
  }
  else
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v7[0]) = 0;
      _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I UpdateDeviceOrientation succeeded", (uint8_t *)v7, 2u);
    }
    LOBYTE(v7[0]) = 1;
  }
  v5 = v2[4];
  if (!v5)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, _DWORD *))(*(_QWORD *)v5 + 48))(v5, v7);
}

uint64_t __copy_helper_block_e8_32c128_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver17updateOrientationERK27StewieDeviceOrientationDataONS_8functionIFvbEEEE3__4EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c128_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver17updateOrientationERK27StewieDeviceOrientationDataONS_8functionIFvbEEEE3__4EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::updateOrientation(StewieDeviceOrientationData const&,std::function<void ()(BOOL)> &&)::$_4,std::allocator<std::function<void ()(BOOL)> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E1370;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::updateOrientation(StewieDeviceOrientationData const&,std::function<void ()(BOOL)> &&)::$_4,std::allocator<std::function<void ()(BOOL)> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E1370;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__shared_ptr_emplace<QMIStewieCommandDriver::updateOrientation(StewieDeviceOrientationData const&,std::function<void ()(BOOL)> &&)::$_4,std::allocator<std::function<void ()(BOOL)> &&>>::__on_zero_shared(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *result;
  uint64_t v3;

  v1 = (_QWORD *)(a1 + 32);
  result = *(_QWORD **)(a1 + 56);
  if (result == v1)
  {
    v3 = 4;
    result = v1;
  }
  else
  {
    if (!result)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute_wrapped<QMIStewieCommandDriver::sendMessage(ctu::cf::CFSharedRef<__CFUUID const> const&,std::vector<unsigned char> const&,StewieTrafficQosPriority,std::function<void ()(BOOL)> &&)::$_0>(QMIStewieCommandDriver::sendMessage(ctu::cf::CFSharedRef<__CFUUID const> const&,std::vector<unsigned char> const&,StewieTrafficQosPriority,std::function<void ()(BOOL)> &&)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIStewieCommandDriver::sendMessage(ctu::cf::CFSharedRef<__CFUUID const> const&,std::vector<unsigned char> const&,StewieTrafficQosPriority,std::function<void ()(BOOL)> &&)::$_0,std::default_delete<QMIStewieCommandDriver::sendMessage(ctu::cf::CFSharedRef<__CFUUID const> const&,std::vector<unsigned char> const&,StewieTrafficQosPriority,std::function<void ()(BOOL)> &&)::$_0>>)::{lambda(void *)#1}::__invoke(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  _QWORD *v4;
  uint64_t v5;
  char v6;

  v1 = *a1;
  v4 = a1;
  v5 = v1;
  v6 = 0;
  v2 = *(_QWORD *)(v1 + 24);
  if (!v2)
    std::__throw_bad_function_call[abi:ne180100]();
  (*(void (**)(uint64_t, char *))(*(_QWORD *)v2 + 48))(v2, &v6);
  std::unique_ptr<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0,std::default_delete<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0>>::~unique_ptr[abi:ne180100](&v5);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v4);
}

void sub_216A267F8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3;
  va_list va;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  std::unique_ptr<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0,std::default_delete<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0>>::~unique_ptr[abi:ne180100]((uint64_t *)va1);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

char *qmi::MutableMessageBase::getTLV<sft::tlv::GUID>(_QWORD *a1, int a2)
{
  char v2;
  const void **v4;
  const void **v5;
  char **v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t *v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  char *v17;
  uint64_t *v18;
  char *v19;
  char *v20;
  char *v21;
  uint64_t v22;

  v2 = a2;
  v4 = (const void **)a1[1];
  v5 = (const void **)a1[2];
  v6 = (char **)(a1 + 1);
  if (v4 != v5)
  {
    while (*((unsigned __int8 *)*v4 + 8) != a2)
    {
      if (++v4 == v5)
        goto LABEL_8;
    }
  }
  if (v4 == v5)
  {
LABEL_8:
    v9 = operator new();
    *(_BYTE *)(v9 + 8) = v2;
    *(_QWORD *)v9 = &off_24D5E13D8;
    *(_QWORD *)(v9 + 9) = 0;
    v8 = v9 + 9;
    *(_QWORD *)(v9 + 17) = 0;
    v10 = a1[3];
    v11 = (uint64_t *)a1[2];
    if ((unint64_t)v11 >= v10)
    {
      v13 = ((char *)v11 - *v6) >> 3;
      if ((unint64_t)(v13 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v14 = v10 - (_QWORD)*v6;
      v15 = v14 >> 2;
      if (v14 >> 2 <= (unint64_t)(v13 + 1))
        v15 = v13 + 1;
      if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8)
        v16 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v16 = v15;
      if (v16)
        v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v16);
      else
        v17 = 0;
      v18 = (uint64_t *)&v17[8 * v13];
      v19 = &v17[8 * v16];
      *v18 = v9;
      v12 = v18 + 1;
      v21 = (char *)a1[1];
      v20 = (char *)a1[2];
      if (v20 != v21)
      {
        do
        {
          v22 = *((_QWORD *)v20 - 1);
          v20 -= 8;
          *--v18 = v22;
        }
        while (v20 != v21);
        v20 = *v6;
      }
      a1[1] = v18;
      a1[2] = v12;
      a1[3] = v19;
      if (v20)
        operator delete(v20);
    }
    else
    {
      *v11 = v9;
      v12 = v11 + 1;
    }
    a1[2] = v12;
  }
  else
  {
    if (!v7)
      __cxa_bad_cast();
    return v7 + 9;
  }
  return (char *)v8;
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::GUID>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::GUID>::getSize()
{
  return tlv::size<wds::tlv::Ipv4AddressExtended>();
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::GUID>::write(uint64_t a1, __n128 **a2)
{
  unsigned __int8 v3;
  __n128 *v4;
  uint64_t v5;
  char *v6;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = *a2;
  v5 = (uint64_t)(*a2)->n128_i64 + 3;
  *a2 = (__n128 *)v5;
  tlv::writeV<vinyl::tlv::ReqProfileId>(a2, (__n128 *)(a1 + 9));
  v6 = (char *)*a2 - v5;
  v4->n128_u8[0] = v3;
  *(unsigned __int16 *)((char *)v4->n128_u16 + 1) = (unsigned __int16)v6;
}

__n128 qmi::MutableMessageBase::TlvWrapper<sft::tlv::GUID>::clone(uint64_t a1)
{
  uint64_t v2;
  __n128 result;

  v2 = operator new();
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)v2 = &off_24D5E13D8;
  result = *(__n128 *)(a1 + 9);
  *(__n128 *)(v2 + 9) = result;
  return result;
}

uint64_t ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::get(uint64_t a1)
{
  return *(_QWORD *)a1;
}

_QWORD *qmi::MutableMessageBase::TlvWrapper<sft::tlv::Message>::~TlvWrapper(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24D5E1428;
  v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::Message>::~TlvWrapper(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24D5E1428;
  v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::Message>::getSize(uint64_t a1)
{
  return tlv::size<vs::tlv::CallingNumber>((_QWORD *)(a1 + 16));
}

void *qmi::MutableMessageBase::TlvWrapper<sft::tlv::Message>::write(uint64_t a1, void **a2)
{
  char v3;
  char *v4;
  uint64_t v5;
  void *result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (char *)*a2;
  v5 = (uint64_t)*a2 + 3;
  *a2 = (void *)v5;
  result = tlv::writeV<vs::tlv::CallingNumber>(a2, a1 + 16);
  v7 = (char *)*a2 - v5;
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::Message>::clone(uint64_t a1)
{
  uint64_t v2;

  v2 = operator new();
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)v2 = &off_24D5E1428;
  *(_QWORD *)(v2 + 24) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 16) = 0;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>((_QWORD *)(v2 + 16), *(const void **)(a1 + 16), *(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 24) - *(_QWORD *)(a1 + 16));
  return v2;
}

void sub_216A26BB0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199FEAC4](v1, 0x1091C40A3A4EB6ALL);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::TrafficQosPriority>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::TrafficQosPriority>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<sft::tlv::TrafficQosPriority>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::IPPref>((_BYTE **)a2, (_DWORD *)(a1 + 12));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::TrafficQosPriority>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E1478;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a1 + 12);
  return result;
}

uint64_t ___ZN22QMIStewieCommandDriver4sendIN3sft9MessageTX7RequestEZNS_11sendMessageERKN3ctu2cf11CFSharedRefIK8__CFUUIDEERKNSt3__16vectorIhNSC_9allocatorIhEEEE24StewieTrafficQosPriorityONSC_8functionIFvbEEEE3__4EEvRKT_OT0__block_invoke(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  int v3;
  NSObject *v4;
  uint64_t v5;
  _DWORD v7[2];
  __int16 v8;
  uint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD **)(a1 + 32);
  v3 = *(_DWORD *)(a2 + 4);
  v4 = *(NSObject **)(*v2 + 40);
  if (v3)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v7[0] = 67109378;
      v7[1] = v3;
      v8 = 2080;
      v9 = qmi::asString();
      _os_log_error_impl(&dword_216897000, v4, OS_LOG_TYPE_ERROR, "Failed to execute MessageTX. Error code:0x%x (%s)", (uint8_t *)v7, 0x12u);
    }
    LOBYTE(v7[0]) = 0;
  }
  else
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v7[0]) = 0;
      _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I MessageTX request succeeded. Waiting for indication", (uint8_t *)v7, 2u);
    }
    LOBYTE(v7[0]) = 1;
  }
  v5 = v2[4];
  if (!v5)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, _DWORD *))(*(_QWORD *)v5 + 48))(v5, v7);
}

uint64_t __copy_helper_block_e8_32c186_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver11sendMessageERKN3ctu2cf11CFSharedRefIK8__CFUUIDEERKNS_6vectorIhNS_9allocatorIhEEEE24StewieTrafficQosPriorityONS_8functionIFvbEEEE3__4EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c186_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver11sendMessageERKN3ctu2cf11CFSharedRefIK8__CFUUIDEERKNS_6vectorIhNS_9allocatorIhEEEE24StewieTrafficQosPriorityONS_8functionIFvbEEEE3__4EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::sendMessage(ctu::cf::CFSharedRef<__CFUUID const> const&,std::vector<unsigned char> const&,StewieTrafficQosPriority,std::function<void ()(BOOL)> &&)::$_4,std::allocator<std::function<void ()(BOOL)> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E14E0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::sendMessage(ctu::cf::CFSharedRef<__CFUUID const> const&,std::vector<unsigned char> const&,StewieTrafficQosPriority,std::function<void ()(BOOL)> &&)::$_4,std::allocator<std::function<void ()(BOOL)> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E14E0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__shared_ptr_emplace<QMIStewieCommandDriver::sendMessage(ctu::cf::CFSharedRef<__CFUUID const> const&,std::vector<unsigned char> const&,StewieTrafficQosPriority,std::function<void ()(BOOL)> &&)::$_4,std::allocator<std::function<void ()(BOOL)> &&>>::__on_zero_shared(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *result;
  uint64_t v3;

  v1 = (_QWORD *)(a1 + 32);
  result = *(_QWORD **)(a1 + 56);
  if (result == v1)
  {
    v3 = 4;
    result = v1;
  }
  else
  {
    if (!result)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute_wrapped<QMIStewieCommandDriver::cancelMessageTx(ctu::cf::CFSharedRef<__CFUUID const> const&,std::function<void ()(BOOL)> &&)::$_0>(QMIStewieCommandDriver::cancelMessageTx(ctu::cf::CFSharedRef<__CFUUID const> const&,std::function<void ()(BOOL)> &&)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIStewieCommandDriver::cancelMessageTx(ctu::cf::CFSharedRef<__CFUUID const> const&,std::function<void ()(BOOL)> &&)::$_0,std::default_delete<QMIStewieCommandDriver::cancelMessageTx(ctu::cf::CFSharedRef<__CFUUID const> const&,std::function<void ()(BOOL)> &&)::$_0>>)::{lambda(void *)#1}::__invoke(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  _QWORD *v4;
  uint64_t v5;
  char v6;

  v1 = *a1;
  v4 = a1;
  v5 = v1;
  v6 = 0;
  v2 = *(_QWORD *)(v1 + 24);
  if (!v2)
    std::__throw_bad_function_call[abi:ne180100]();
  (*(void (**)(uint64_t, char *))(*(_QWORD *)v2 + 48))(v2, &v6);
  std::unique_ptr<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0,std::default_delete<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0>>::~unique_ptr[abi:ne180100](&v5);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v4);
}

void sub_216A26EC0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3;
  va_list va;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  std::unique_ptr<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0,std::default_delete<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0>>::~unique_ptr[abi:ne180100]((uint64_t *)va1);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::CancelAllQueuedTXMessages>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::CancelAllQueuedTXMessages>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<sft::tlv::CancelAllQueuedTXMessages>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::CancelAllQueuedTXMessages>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E1548;
  return result;
}

uint64_t ___ZN22QMIStewieCommandDriver4sendIN3sft15CancelMessageTX7RequestEZNS_15cancelMessageTxERKN3ctu2cf11CFSharedRefIK8__CFUUIDEEONSt3__18functionIFvbEEEE3__3EEvRKT_OT0__block_invoke(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  int v3;
  NSObject *v4;
  uint64_t v5;
  _DWORD v7[2];
  __int16 v8;
  uint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD **)(a1 + 32);
  v3 = *(_DWORD *)(a2 + 4);
  v4 = *(NSObject **)(*v2 + 40);
  if (v3)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v7[0] = 67109378;
      v7[1] = v3;
      v8 = 2080;
      v9 = qmi::asString();
      _os_log_error_impl(&dword_216897000, v4, OS_LOG_TYPE_ERROR, "Failed to execute CancelMessageTX. Error code:0x%x (%s)", (uint8_t *)v7, 0x12u);
    }
    LOBYTE(v7[0]) = 0;
  }
  else
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v7[0]) = 0;
      _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I CancelMessageTX request succeeded. Waiting for indication", (uint8_t *)v7, 2u);
    }
    LOBYTE(v7[0]) = 1;
  }
  v5 = v2[4];
  if (!v5)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, _DWORD *))(*(_QWORD *)v5 + 48))(v5, v7);
}

uint64_t __copy_helper_block_e8_32c131_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver15cancelMessageTxERKN3ctu2cf11CFSharedRefIK8__CFUUIDEEONS_8functionIFvbEEEE3__3EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c131_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver15cancelMessageTxERKN3ctu2cf11CFSharedRefIK8__CFUUIDEEONS_8functionIFvbEEEE3__3EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::cancelMessageTx(ctu::cf::CFSharedRef<__CFUUID const> const&,std::function<void ()(BOOL)> &&)::$_3,std::allocator<std::function<void ()(BOOL)> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E15B0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::cancelMessageTx(ctu::cf::CFSharedRef<__CFUUID const> const&,std::function<void ()(BOOL)> &&)::$_3,std::allocator<std::function<void ()(BOOL)> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E15B0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__shared_ptr_emplace<QMIStewieCommandDriver::cancelMessageTx(ctu::cf::CFSharedRef<__CFUUID const> const&,std::function<void ()(BOOL)> &&)::$_3,std::allocator<std::function<void ()(BOOL)> &&>>::__on_zero_shared(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *result;
  uint64_t v3;

  v1 = (_QWORD *)(a1 + 32);
  result = *(_QWORD **)(a1 + 56);
  if (result == v1)
  {
    v3 = 4;
    result = v1;
  }
  else
  {
    if (!result)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute_wrapped<QMIStewieCommandDriver::ackReceivedMessage(unsigned short,std::function<void ()(BOOL)> &&)::$_0>(QMIStewieCommandDriver::ackReceivedMessage(unsigned short,std::function<void ()(BOOL)> &&)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIStewieCommandDriver::ackReceivedMessage(unsigned short,std::function<void ()(BOOL)> &&)::$_0,std::default_delete<QMIStewieCommandDriver::ackReceivedMessage(unsigned short,std::function<void ()(BOOL)> &&)::$_0>>)::{lambda(void *)#1}::__invoke(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  _QWORD *v4;
  uint64_t v5;
  char v6;

  v1 = *a1;
  v4 = a1;
  v5 = v1;
  v6 = 0;
  v2 = *(_QWORD *)(v1 + 24);
  if (!v2)
    std::__throw_bad_function_call[abi:ne180100]();
  (*(void (**)(uint64_t, char *))(*(_QWORD *)v2 + 48))(v2, &v6);
  std::unique_ptr<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0,std::default_delete<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0>>::~unique_ptr[abi:ne180100](&v5);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v4);
}

void sub_216A271C0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3;
  va_list va;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  std::unique_ptr<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0,std::default_delete<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0>>::~unique_ptr[abi:ne180100]((uint64_t *)va1);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::BBMessageID>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::BBMessageID>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_PcoMcc>();
}

_WORD **qmi::MutableMessageBase::TlvWrapper<sft::tlv::BBMessageID>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _WORD *v4;
  uint64_t v5;
  _WORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_WORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::Profile3GPP_PcoMcc>((_WORD **)a2, (_WORD *)(a1 + 10));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::BBMessageID>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E1618;
  *(_WORD *)(result + 10) = *(_WORD *)(a1 + 10);
  return result;
}

uint64_t ___ZN22QMIStewieCommandDriver4sendIN3sft12MessageRXAck7RequestEZNS_18ackReceivedMessageEtONSt3__18functionIFvbEEEE3__2EEvRKT_OT0__block_invoke(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  int v3;
  NSObject *v4;
  uint64_t v5;
  _DWORD v7[2];
  __int16 v8;
  uint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD **)(a1 + 32);
  v3 = *(_DWORD *)(a2 + 4);
  v4 = *(NSObject **)(*v2 + 40);
  if (v3)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v7[0] = 67109378;
      v7[1] = v3;
      v8 = 2080;
      v9 = qmi::asString();
      _os_log_error_impl(&dword_216897000, v4, OS_LOG_TYPE_ERROR, "Failed to execute MessageRXAck. Error code:0x%x (%s)", (uint8_t *)v7, 0x12u);
    }
    LOBYTE(v7[0]) = 0;
  }
  else
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v7[0]) = 0;
      _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I MessageRXAck succeeded", (uint8_t *)v7, 2u);
    }
    LOBYTE(v7[0]) = 1;
  }
  v5 = v2[4];
  if (!v5)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, _DWORD *))(*(_QWORD *)v5 + 48))(v5, v7);
}

uint64_t __copy_helper_block_e8_32c99_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver18ackReceivedMessageEtONS_8functionIFvbEEEE3__2EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c99_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver18ackReceivedMessageEtONS_8functionIFvbEEEE3__2EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::ackReceivedMessage(unsigned short,std::function<void ()(BOOL)> &&)::$_2,std::allocator<std::function<void ()(BOOL)> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E1680;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::ackReceivedMessage(unsigned short,std::function<void ()(BOOL)> &&)::$_2,std::allocator<std::function<void ()(BOOL)> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E1680;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__shared_ptr_emplace<QMIStewieCommandDriver::ackReceivedMessage(unsigned short,std::function<void ()(BOOL)> &&)::$_2,std::allocator<std::function<void ()(BOOL)> &&>>::__on_zero_shared(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *result;
  uint64_t v3;

  v1 = (_QWORD *)(a1 + 32);
  result = *(_QWORD **)(a1 + 56);
  if (result == v1)
  {
    v3 = 4;
    result = v1;
  }
  else
  {
    if (!result)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

uint64_t std::__function::__value_func<void ()(BOOL,unsigned short)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;

  v3 = (_QWORD *)(a2 + 24);
  v4 = *(_QWORD *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(_QWORD *)(a1 + 24) = a1;
      (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(_QWORD *)(a1 + 24) = v4;
  }
  else
  {
    v3 = (_QWORD *)(a1 + 24);
  }
  *v3 = 0;
  return a1;
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute_wrapped<QMIStewieCommandDriver::sendFileSegment(StewieFileType,unsigned short,unsigned short,std::vector<unsigned char> &&,std::function<void ()(BOOL,unsigned short)> &&)::$_0>(QMIStewieCommandDriver::sendFileSegment(StewieFileType,unsigned short,unsigned short,std::vector<unsigned char> &&,std::function<void ()(BOOL,unsigned short)> &&)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<std::function<void ()(BOOL,unsigned short)> &&,std::default_delete<std::function<void ()(BOOL,unsigned short)> &&>>)::{lambda(void *)#1}::__invoke(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  _QWORD *v4;
  uint64_t v5;
  __int16 v6;
  char v7;

  v1 = *a1;
  v4 = a1;
  v5 = v1;
  v2 = *(_QWORD *)(v1 + 24);
  v7 = 0;
  v6 = 0;
  if (!v2)
    std::__throw_bad_function_call[abi:ne180100]();
  (*(void (**)(uint64_t, char *, __int16 *))(*(_QWORD *)v2 + 48))(v2, &v7, &v6);
  std::unique_ptr<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0,std::default_delete<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0>>::~unique_ptr[abi:ne180100](&v5);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v4);
}

void sub_216A27534(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3;
  va_list va;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  std::unique_ptr<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0,std::default_delete<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0>>::~unique_ptr[abi:ne180100]((uint64_t *)va1);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t std::function<void ()(BOOL,unsigned short)>::operator()(uint64_t a1, char a2, __int16 a3)
{
  __int16 v4;
  char v5;

  v5 = a2;
  v4 = a3;
  if (!a1)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, char *, __int16 *))(*(_QWORD *)a1 + 48))(a1, &v5, &v4);
}

_QWORD *qmi::MutableMessageBase::TlvWrapper<sft::tlv::FileTransferInfo>::~TlvWrapper(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24D5E16E8;
  v2 = (void *)a1[3];
  if (v2)
  {
    a1[4] = v2;
    operator delete(v2);
  }
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::FileTransferInfo>::~TlvWrapper(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24D5E16E8;
  v2 = (void *)a1[3];
  if (v2)
  {
    a1[4] = v2;
    operator delete(v2);
  }
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::FileTransferInfo>::getSize(uint64_t a1)
{
  return tlv::size<sft::tlv::FileTransferInfo>(a1 + 16);
}

void *qmi::MutableMessageBase::TlvWrapper<sft::tlv::FileTransferInfo>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  uint64_t v4;
  uint64_t v5;
  void *result;
  uint64_t v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = *a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<sft::tlv::FileTransferInfo>(a2, a1 + 16);
  v7 = *a2 - v5;
  *(_BYTE *)v4 = v3;
  *(_WORD *)(v4 + 1) = v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::FileTransferInfo>::clone(uint64_t a1)
{
  uint64_t v2;
  const void *v3;
  uint64_t v4;

  v2 = operator new();
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)v2 = &off_24D5E16E8;
  *(_DWORD *)(v2 + 16) = *(_DWORD *)(a1 + 16);
  *(_WORD *)(v2 + 20) = *(_WORD *)(a1 + 20);
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 40) = 0;
  v3 = *(const void **)(a1 + 24);
  v4 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(v2 + 24) = 0;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>((_QWORD *)(v2 + 24), v3, v4, v4 - (_QWORD)v3);
  return v2;
}

void sub_216A276E8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199FEAC4](v1, 0x1091C4066207FBFLL);
  _Unwind_Resume(a1);
}

uint64_t ___ZN22QMIStewieCommandDriver4sendIN3sft8SendFile7RequestEZNS_15sendFileSegmentE14StewieFileTypettONSt3__16vectorIhNS5_9allocatorIhEEEEONS5_8functionIFvbtEEEE3__2EEvRKT_OT0__block_invoke(uint64_t a1, qmi::MessageBase *a2)
{
  unsigned __int16 *v2;
  int v3;
  NSObject *v4;
  int v6;
  int v7;
  uint64_t TlvValue;
  int v9;
  uint64_t v10;
  int v11;
  __int16 v12;
  __int16 v13;
  uint64_t v14;
  int v16;
  int v17;
  char v18;
  uint8_t buf[8];
  __int16 v20;
  int v21;
  __int16 v22;
  int v23;
  __int16 v24;
  uint64_t v25;
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  v2 = *(unsigned __int16 **)(a1 + 32);
  v3 = *((_DWORD *)a2 + 1);
  v4 = *(NSObject **)(*(_QWORD *)v2 + 40);
  if (!v3)
  {
    if (os_log_type_enabled(*(os_log_t *)(*(_QWORD *)v2 + 40), OS_LOG_TYPE_DEFAULT))
    {
      v6 = v2[4];
      v7 = v2[5] - 1;
      *(_DWORD *)buf = 67109376;
      *(_DWORD *)&buf[4] = v6;
      v20 = 1024;
      v21 = v7;
      _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I SendFile (%d/%d) succeeded", buf, 0xEu);
    }
    TlvValue = qmi::MessageBase::findTlvValue(a2);
    if (TlvValue)
    {
      v10 = TlvValue;
      v11 = v9;
      *(_QWORD *)buf = TlvValue;
      v12 = tlv::parseV<sft::tlv::ExpectedSegmentInfo>((unint64_t *)buf, v9);
      if (*(_QWORD *)buf)
      {
        v13 = v12;
LABEL_9:
        v14 = *((_QWORD *)v2 + 5);
        v18 = 1;
        *(_WORD *)buf = v13;
        if (!v14)
          std::__throw_bad_function_call[abi:ne180100]();
        return (*(uint64_t (**)(uint64_t, char *, uint8_t *))(*(_QWORD *)v14 + 48))(v14, &v18, buf);
      }
      ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 64, v10, v11);
    }
    v13 = 0;
    goto LABEL_9;
  }
  if (os_log_type_enabled(*(os_log_t *)(*(_QWORD *)v2 + 40), OS_LOG_TYPE_ERROR))
  {
    v16 = v2[4];
    v17 = v2[5] - 1;
    *(_DWORD *)buf = 67109890;
    *(_DWORD *)&buf[4] = v16;
    v20 = 1024;
    v21 = v17;
    v22 = 1024;
    v23 = v3;
    v24 = 2080;
    v25 = qmi::asString();
    _os_log_error_impl(&dword_216897000, v4, OS_LOG_TYPE_ERROR, "Failed to execute SendFile (%d/%d). Error code:0x%x (%s)", buf, 0x1Eu);
  }
  return std::function<void ()(BOOL,unsigned short)>::operator()(*((_QWORD *)v2 + 5), 0, 0);
}

uint64_t __copy_helper_block_e8_32c146_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver15sendFileSegmentE14StewieFileTypettONS_6vectorIhNS_9allocatorIhEEEEONS_8functionIFvbtEEEE3__2EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c146_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver15sendFileSegmentE14StewieFileTypettONS_6vectorIhNS_9allocatorIhEEEEONS_8functionIFvbtEEEE3__2EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::sendFileSegment(StewieFileType,unsigned short,unsigned short,std::vector<unsigned char> &&,std::function<void ()(BOOL,unsigned short)> &&)::$_2,std::allocator<std::function<void ()(BOOL,unsigned short)> &>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E1750;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::sendFileSegment(StewieFileType,unsigned short,unsigned short,std::vector<unsigned char> &&,std::function<void ()(BOOL,unsigned short)> &&)::$_2,std::allocator<std::function<void ()(BOOL,unsigned short)> &>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E1750;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__shared_ptr_emplace<QMIStewieCommandDriver::sendFileSegment(StewieFileType,unsigned short,unsigned short,std::vector<unsigned char> &&,std::function<void ()(BOOL,unsigned short)> &&)::$_2,std::allocator<std::function<void ()(BOOL,unsigned short)> &>>::__on_zero_shared(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *result;
  uint64_t v3;

  v1 = (_QWORD *)(a1 + 40);
  result = *(_QWORD **)(a1 + 64);
  if (result == v1)
  {
    v3 = 4;
    result = v1;
  }
  else
  {
    if (!result)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3sft8SendFile8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A27A50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute_wrapped<QMIStewieCommandDriver::sendGPSDataUpdate(StewieTimeFreqData const&,StewieLocationData const&,StewieEARFCN const&,std::vector<unsigned char> const&,std::shared_ptr<StewieHeatMap const> const&,std::function<void ()(BOOL)> &&)::$_0>(QMIStewieCommandDriver::sendGPSDataUpdate(StewieTimeFreqData const&,StewieLocationData const&,StewieEARFCN const&,std::vector<unsigned char> const&,std::shared_ptr<StewieHeatMap const> const&,std::function<void ()(BOOL)> &&)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIStewieCommandDriver::sendGPSDataUpdate(StewieTimeFreqData const&,StewieLocationData const&,StewieEARFCN const&,std::vector<unsigned char> const&,std::shared_ptr<StewieHeatMap const> const&,std::function<void ()(BOOL)> &&)::$_0,std::default_delete<QMIStewieCommandDriver::sendGPSDataUpdate(StewieTimeFreqData const&,StewieLocationData const&,StewieEARFCN const&,std::vector<unsigned char> const&,std::shared_ptr<StewieHeatMap const> const&,std::function<void ()(BOOL)> &&)::$_0>>)::{lambda(void *)#1}::__invoke(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  _QWORD *v4;
  uint64_t v5;
  char v6;

  v1 = *a1;
  v4 = a1;
  v5 = v1;
  v6 = 0;
  v2 = *(_QWORD *)(v1 + 24);
  if (!v2)
    std::__throw_bad_function_call[abi:ne180100]();
  (*(void (**)(uint64_t, char *))(*(_QWORD *)v2 + 48))(v2, &v6);
  std::unique_ptr<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0,std::default_delete<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0>>::~unique_ptr[abi:ne180100](&v5);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v4);
}

void sub_216A27AEC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3;
  va_list va;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  std::unique_ptr<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0,std::default_delete<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0>>::~unique_ptr[abi:ne180100]((uint64_t *)va1);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN22QMIStewieCommandDriver4sendIN3sft13GPSDataUpdate7RequestEZNS_17sendGPSDataUpdateERK18StewieTimeFreqDataRK18StewieLocationDataRK12StewieEARFCNRKNSt3__16vectorIhNSD_9allocatorIhEEEERKNSD_10shared_ptrIK13StewieHeatMapEEONSD_8functionIFvbEEEE3__4EEvRKT_OT0__block_invoke(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  int v3;
  NSObject *v4;
  uint64_t v5;
  _DWORD v7[2];
  __int16 v8;
  uint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD **)(a1 + 32);
  v3 = *(_DWORD *)(a2 + 4);
  v4 = *(NSObject **)(*v2 + 40);
  if (v3)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v7[0] = 67109378;
      v7[1] = v3;
      v8 = 2080;
      v9 = qmi::asString();
      _os_log_error_impl(&dword_216897000, v4, OS_LOG_TYPE_ERROR, "Failed to execute GPSDataUpdate. Error code:0x%x (%s)", (uint8_t *)v7, 0x12u);
    }
    LOBYTE(v7[0]) = 0;
  }
  else
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v7[0]) = 0;
      _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I GPSDataUpdate succeeded", (uint8_t *)v7, 2u);
    }
    LOBYTE(v7[0]) = 1;
  }
  v5 = v2[4];
  if (!v5)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, _DWORD *))(*(_QWORD *)v5 + 48))(v5, v7);
}

uint64_t __copy_helper_block_e8_32c215_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver17sendGPSDataUpdateERK18StewieTimeFreqDataRK18StewieLocationDataRK12StewieEARFCNRKNS_6vectorIhNS_9allocatorIhEEEERKNS0_IK13StewieHeatMapEEONS_8functionIFvbEEEE3__4EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c215_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver17sendGPSDataUpdateERK18StewieTimeFreqDataRK18StewieLocationDataRK12StewieEARFCNRKNS_6vectorIhNS_9allocatorIhEEEERKNS0_IK13StewieHeatMapEEONS_8functionIFvbEEEE3__4EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::sendGPSDataUpdate(StewieTimeFreqData const&,StewieLocationData const&,StewieEARFCN const&,std::vector<unsigned char> const&,std::shared_ptr<StewieHeatMap const> const&,std::function<void ()(BOOL)> &&)::$_4,std::allocator<std::function<void ()(BOOL)> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E17F8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::sendGPSDataUpdate(StewieTimeFreqData const&,StewieLocationData const&,StewieEARFCN const&,std::vector<unsigned char> const&,std::shared_ptr<StewieHeatMap const> const&,std::function<void ()(BOOL)> &&)::$_4,std::allocator<std::function<void ()(BOOL)> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E17F8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__shared_ptr_emplace<QMIStewieCommandDriver::sendGPSDataUpdate(StewieTimeFreqData const&,StewieLocationData const&,StewieEARFCN const&,std::vector<unsigned char> const&,std::shared_ptr<StewieHeatMap const> const&,std::function<void ()(BOOL)> &&)::$_4,std::allocator<std::function<void ()(BOOL)> &&>>::__on_zero_shared(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *result;
  uint64_t v3;

  v1 = (_QWORD *)(a1 + 32);
  result = *(_QWORD **)(a1 + 56);
  if (result == v1)
  {
    v3 = 4;
    result = v1;
  }
  else
  {
    if (!result)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute_wrapped<QMIStewieCommandDriver::getCellularTxDeferTime(std::vector<unsigned char> const&,std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &&)::$_0>(QMIStewieCommandDriver::getCellularTxDeferTime(std::vector<unsigned char> const&,std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &&)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &&,std::default_delete<std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &&>>)::{lambda(void *)#1}::__invoke(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  _QWORD *v4;
  uint64_t v5;
  _BYTE v6[23];
  char v7;

  v1 = *a1;
  v4 = a1;
  v5 = v1;
  v6[0] = 0;
  v6[8] = 0;
  v7 = 0;
  v2 = *(_QWORD *)(v1 + 24);
  if (!v2)
    std::__throw_bad_function_call[abi:ne180100]();
  (*(void (**)(uint64_t, char *, _BYTE *))(*(_QWORD *)v2 + 48))(v2, &v7, v6);
  std::unique_ptr<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0,std::default_delete<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0>>::~unique_ptr[abi:ne180100](&v5);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v4);
}

void sub_216A27D38(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3;
  va_list va;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  std::unique_ptr<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0,std::default_delete<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0>>::~unique_ptr[abi:ne180100]((uint64_t *)va1);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

_QWORD *qmi::MutableMessageBase::TlvWrapper<sft::tlv::ISO3166Alpha3>::~TlvWrapper(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24D5E1860;
  v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::ISO3166Alpha3>::~TlvWrapper(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24D5E1860;
  v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::ISO3166Alpha3>::getSize(uint64_t a1)
{
  return tlv::size<wds::tlv::NextHdrProtList>((_QWORD *)(a1 + 16));
}

void *qmi::MutableMessageBase::TlvWrapper<sft::tlv::ISO3166Alpha3>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  void *result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::NextHdrProtList>((_BYTE **)a2, a1 + 16);
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::ISO3166Alpha3>::clone(uint64_t a1)
{
  uint64_t v2;

  v2 = operator new();
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)v2 = &off_24D5E1860;
  *(_QWORD *)(v2 + 24) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 16) = 0;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>((_QWORD *)(v2 + 16), *(const void **)(a1 + 16), *(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 24) - *(_QWORD *)(a1 + 16));
  return v2;
}

void sub_216A27EA0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199FEAC4](v1, 0x1091C40A3A4EB6ALL);
  _Unwind_Resume(a1);
}

uint64_t ___ZN22QMIStewieCommandDriver4sendIN3sft22GetCellularTxDeferTime7RequestEZNS_22getCellularTxDeferTimeERKNSt3__16vectorIhNS4_9allocatorIhEEEEONS4_8functionIFvbONS4_8optionalINS4_6chrono8durationIxNS4_5ratioILl1ELl1000EEEEEEEEEEE3__2EEvRKT_OT0__block_invoke(uint64_t a1, qmi::MessageBase *this)
{
  uint64_t *v2;
  uint64_t v3;
  int v4;
  uint64_t TlvValue;
  int v7;
  uint64_t v8;
  int v9;
  unsigned int v10;
  NSObject *v11;
  uint64_t v12;
  NSObject *v14;
  uint64_t v15;
  NSObject *v16;
  uint64_t v17;
  char v18;
  char v19;
  uint8_t buf[8];
  _QWORD v21[3];

  v21[2] = *MEMORY[0x24BDAC8D0];
  v2 = *(uint64_t **)(a1 + 32);
  v3 = *v2;
  v4 = *((_DWORD *)this + 1);
  if (v4)
  {
    v16 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109378;
      *(_DWORD *)&buf[4] = v4;
      LOWORD(v21[0]) = 2080;
      *(_QWORD *)((char *)v21 + 2) = qmi::asString();
      _os_log_error_impl(&dword_216897000, v16, OS_LOG_TYPE_ERROR, "Failed to execute GetCellularTxDeferTime. Error code:0x%x (%s)", buf, 0x12u);
    }
    buf[0] = 0;
    LOBYTE(v21[0]) = 0;
    LOBYTE(v17) = 0;
LABEL_7:
    v12 = v2[4];
    if (v12)
      return (*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)v12 + 48))(v12, &v17);
LABEL_17:
    std::__throw_bad_function_call[abi:ne180100]();
  }
  v21[0] = 1;
  TlvValue = qmi::MessageBase::findTlvValue(this);
  if (TlvValue)
  {
    v8 = TlvValue;
    v9 = v7;
    v17 = TlvValue;
    v10 = tlv::parseV<sft::tlv::CellularTXDeferTime>((unint64_t *)&v17, v7);
    if (v17)
    {
      *(_QWORD *)buf = v10;
      v11 = *(NSObject **)(v3 + 40);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v17) = 0;
        _os_log_impl(&dword_216897000, v11, OS_LOG_TYPE_DEFAULT, "#I GetCellularTxDeferTime succeeded", (uint8_t *)&v17, 2u);
      }
      LOBYTE(v17) = 1;
      goto LABEL_7;
    }
    ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)this, 3, v8, v9);
  }
  v14 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v17) = 0;
    _os_log_error_impl(&dword_216897000, v14, OS_LOG_TYPE_ERROR, "Expected TLV: CellularTXDeferTime is missing", (uint8_t *)&v17, 2u);
  }
  LOBYTE(v17) = 0;
  v18 = 0;
  v19 = 0;
  v15 = v2[4];
  if (!v15)
    goto LABEL_17;
  return (*(uint64_t (**)(uint64_t, char *))(*(_QWORD *)v15 + 48))(v15, &v19);
}

uint64_t __copy_helper_block_e8_32c197_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver22getCellularTxDeferTimeERKNS_6vectorIhNS_9allocatorIhEEEEONS_8functionIFvbONS_8optionalINS_6chrono8durationIxNS_5ratioILl1ELl1000EEEEEEEEEEE3__2EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c197_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver22getCellularTxDeferTimeERKNS_6vectorIhNS_9allocatorIhEEEEONS_8functionIFvbONS_8optionalINS_6chrono8durationIxNS_5ratioILl1ELl1000EEEEEEEEEEE3__2EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::getCellularTxDeferTime(std::vector<unsigned char> const&,std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &&)::$_2,std::allocator<std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E18C8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::getCellularTxDeferTime(std::vector<unsigned char> const&,std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &&)::$_2,std::allocator<std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E18C8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__shared_ptr_emplace<QMIStewieCommandDriver::getCellularTxDeferTime(std::vector<unsigned char> const&,std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &&)::$_2,std::allocator<std::function<void ()(BOOL,std::optional<std::chrono::duration<long long,std::ratio<1l,1000l>>> &&)> &>>::__on_zero_shared(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *result;
  uint64_t v3;

  v1 = (_QWORD *)(a1 + 32);
  result = *(_QWORD **)(a1 + 56);
  if (result == v1)
  {
    v3 = 4;
    result = v1;
  }
  else
  {
    if (!result)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3sft22GetCellularTxDeferTime8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A2822C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<QMIStewieCommandDriver>::execute_wrapped<QMIStewieCommandDriver::setBroadcastInfoBlob(std::vector<unsigned char> const&,std::function<void ()(BOOL)> &&)::$_0>(QMIStewieCommandDriver::setBroadcastInfoBlob(std::vector<unsigned char> const&,std::function<void ()(BOOL)> &&)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIStewieCommandDriver::setBroadcastInfoBlob(std::vector<unsigned char> const&,std::function<void ()(BOOL)> &&)::$_0,std::default_delete<QMIStewieCommandDriver::setBroadcastInfoBlob(std::vector<unsigned char> const&,std::function<void ()(BOOL)> &&)::$_0>>)::{lambda(void *)#1}::__invoke(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  _QWORD *v4;
  uint64_t v5;
  char v6;

  v1 = *a1;
  v4 = a1;
  v5 = v1;
  v6 = 0;
  v2 = *(_QWORD *)(v1 + 24);
  if (!v2)
    std::__throw_bad_function_call[abi:ne180100]();
  (*(void (**)(uint64_t, char *))(*(_QWORD *)v2 + 48))(v2, &v6);
  std::unique_ptr<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0,std::default_delete<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0>>::~unique_ptr[abi:ne180100](&v5);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v4);
}

void sub_216A282C8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3;
  va_list va;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  std::unique_ptr<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0,std::default_delete<QMIEmbmsCommandDriver::setEMBMSSAIInterestedInfo(embms::SAIInterestedInfo const&,std::function<void ()(BOOL)>)::$_0>>::~unique_ptr[abi:ne180100]((uint64_t *)va1);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

_QWORD *qmi::MutableMessageBase::TlvWrapper<sft::tlv::BroadcastInfoBlob>::~TlvWrapper(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24D5E1958;
  v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<sft::tlv::BroadcastInfoBlob>::~TlvWrapper(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24D5E1958;
  v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::BroadcastInfoBlob>::getSize(uint64_t a1)
{
  return tlv::size<vs::tlv::CallingNumber>((_QWORD *)(a1 + 16));
}

void *qmi::MutableMessageBase::TlvWrapper<sft::tlv::BroadcastInfoBlob>::write(uint64_t a1, void **a2)
{
  char v3;
  char *v4;
  uint64_t v5;
  void *result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (char *)*a2;
  v5 = (uint64_t)*a2 + 3;
  *a2 = (void *)v5;
  result = tlv::writeV<vs::tlv::CallingNumber>(a2, a1 + 16);
  v7 = (char *)*a2 - v5;
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<sft::tlv::BroadcastInfoBlob>::clone(uint64_t a1)
{
  uint64_t v2;

  v2 = operator new();
  *(_BYTE *)(v2 + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)v2 = &off_24D5E1958;
  *(_QWORD *)(v2 + 24) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 16) = 0;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>((_QWORD *)(v2 + 16), *(const void **)(a1 + 16), *(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 24) - *(_QWORD *)(a1 + 16));
  return v2;
}

void sub_216A28430(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199FEAC4](v1, 0x1091C40A3A4EB6ALL);
  _Unwind_Resume(a1);
}

uint64_t ___ZN22QMIStewieCommandDriver4sendIN3sft20SetBroadcastInfoBlob7RequestEZNS_20setBroadcastInfoBlobERKNSt3__16vectorIhNS4_9allocatorIhEEEEONS4_8functionIFvbEEEE3__2EEvRKT_OT0__block_invoke(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  int v3;
  NSObject *v4;
  uint64_t v5;
  _DWORD v7[2];
  __int16 v8;
  uint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD **)(a1 + 32);
  v3 = *(_DWORD *)(a2 + 4);
  v4 = *(NSObject **)(*v2 + 40);
  if (v3)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v7[0] = 67109378;
      v7[1] = v3;
      v8 = 2080;
      v9 = qmi::asString();
      _os_log_error_impl(&dword_216897000, v4, OS_LOG_TYPE_ERROR, "Failed to execute SetBroadcastInfoBlob. Error code:0x%x (%s)", (uint8_t *)v7, 0x12u);
    }
    LOBYTE(v7[0]) = 0;
  }
  else
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v7[0]) = 0;
      _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I SetBroadcastInfoBlob request succeeded", (uint8_t *)v7, 2u);
    }
    LOBYTE(v7[0]) = 1;
  }
  v5 = v2[4];
  if (!v5)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, _DWORD *))(*(_QWORD *)v5 + 48))(v5, v7);
}

uint64_t __copy_helper_block_e8_32c133_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver20setBroadcastInfoBlobERKNS_6vectorIhNS_9allocatorIhEEEEONS_8functionIFvbEEEE3__2EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c133_ZTSNSt3__110shared_ptrIZN22QMIStewieCommandDriver20setBroadcastInfoBlobERKNS_6vectorIhNS_9allocatorIhEEEEONS_8functionIFvbEEEE3__2EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::setBroadcastInfoBlob(std::vector<unsigned char> const&,std::function<void ()(BOOL)> &&)::$_2,std::allocator<std::function<void ()(BOOL)> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E19C0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QMIStewieCommandDriver::setBroadcastInfoBlob(std::vector<unsigned char> const&,std::function<void ()(BOOL)> &&)::$_2,std::allocator<std::function<void ()(BOOL)> &&>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E19C0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__shared_ptr_emplace<QMIStewieCommandDriver::setBroadcastInfoBlob(std::vector<unsigned char> const&,std::function<void ()(BOOL)> &&)::$_2,std::allocator<std::function<void ()(BOOL)> &&>>::__on_zero_shared(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *result;
  uint64_t v3;

  v1 = (_QWORD *)(a1 + 32);
  result = *(_QWORD **)(a1 + 56);
  if (result == v1)
  {
    v3 = 4;
    result = v1;
  }
  else
  {
    if (!result)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

uint64_t std::optional<std::vector<unsigned char>>::operator=[abi:ne180100]<std::vector<unsigned char>,void>(uint64_t a1, __n128 *a2)
{
  if (*(_BYTE *)(a1 + 24))
  {
    std::vector<unsigned char>::__move_assign(a1, a2);
  }
  else
  {
    *(_QWORD *)a1 = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(__n128 *)a1 = *a2;
    *(_QWORD *)(a1 + 16) = a2[1].n128_u64[0];
    a2->n128_u64[0] = 0;
    a2->n128_u64[1] = 0;
    a2[1].n128_u64[0] = 0;
    *(_BYTE *)(a1 + 24) = 1;
  }
  return a1;
}

void *std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(uint64_t a1, const void *a2, uint64_t a3, size_t __sz)
{
  void *result;
  uint64_t v8;
  size_t v9;

  result = std::vector<unsigned char>::__vallocate[abi:ne180100]((_QWORD *)a1, __sz);
  v8 = *(_QWORD *)(a1 + 8);
  v9 = a3 - (_QWORD)a2;
  if (v9)
    result = memmove(*(void **)(a1 + 8), a2, v9);
  *(_QWORD *)(a1 + 8) = v8 + v9;
  return result;
}

void sub_216A286D0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void Mav20SignalStrengthCommandDriver::create(_QWORD *a1@<X0>, NSObject **a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v6;
  NSObject *v7;
  NSObject *v8;

  *a3 = 0;
  a3[1] = 0;
  v6 = operator new();
  v8 = *a2;
  v7 = v8;
  *a2 = 0;
  Mav20SignalStrengthCommandDriver::Mav20SignalStrengthCommandDriver(v6, a1, &v8);
  *a3 = 0;
  a3[1] = 0;
  std::shared_ptr<Mav20SignalStrengthCommandDriver>::shared_ptr[abi:ne180100]<Mav20SignalStrengthCommandDriver,std::shared_ptr<Mav20SignalStrengthCommandDriver> ctu::SharedSynchronizable<Mav20SignalStrengthCommandDriver>::make_shared_ptr<Mav20SignalStrengthCommandDriver>(Mav20SignalStrengthCommandDriver*)::{lambda(Mav20SignalStrengthCommandDriver*)#1},void>(a3, v6);
  if (v7)
    dispatch_release(v7);
}

void sub_216A28798(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  NSObject *v2;
  int v3;

  if (v2)
    dispatch_release(v2);
  if (v3)
    MEMORY[0x2199FEAC4](v1, 0xE1C40674E6572);
  _Unwind_Resume(exception_object);
}

uint64_t Mav20SignalStrengthCommandDriver::Mav20SignalStrengthCommandDriver(uint64_t a1, _QWORD *a2, NSObject **a3)
{
  _QWORD *v6;
  NSObject *v7;
  capabilities::ct *v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  _QWORD v23[3];
  _QWORD *v24;
  _BYTE v25[24];
  _BYTE *v26;
  _BYTE v27[24];
  _BYTE *v28;
  uint64_t v29;

  v29 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)a1 = MEMORY[0x24BDC4628] + 16;
  v6 = (_QWORD *)(a1 + 8);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)v27, (const char *)*MEMORY[0x24BDC3E90], "sig.qmi");
  *v6 = 0;
  v6[1] = 0;
  v7 = *a3;
  *(_QWORD *)(a1 + 24) = *a3;
  if (v7)
    dispatch_retain(v7);
  *(_QWORD *)(a1 + 32) = 0;
  ctu::OsLogLogger::OsLogLogger();
  ctu::OsLogLogger::OsLogLogger();
  MEMORY[0x2199FDF6C](v25);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v27);
  v23[0] = &unk_24D5CCF40;
  v24 = v23;
  v8 = (capabilities::ct *)std::__function::__value_func<char const* const ()(subscriber::SimSlot)>::__value_func[abi:ne180100]((uint64_t)v25, (uint64_t)v23);
  *(_QWORD *)(a1 + 48) = 0;
  if ((capabilities::ct::supportsGemini(v8) & 1) == 0)
  {
    v9 = (_QWORD *)operator new();
    *v9 = &off_24D5E1BA8;
    v9[1] = a1;
    v10 = *(_QWORD *)(a1 + 48);
    *(_QWORD *)(a1 + 48) = v9;
    if (!v10)
      goto LABEL_14;
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 8))(v10);
  }
  if (!*(_QWORD *)(a1 + 48))
  {
    v11 = (_QWORD *)operator new();
    std::__function::__value_func<char const* const ()(subscriber::SimSlot)>::__value_func[abi:ne180100]((uint64_t)v27, (uint64_t)v25);
    SimInstanceLoggerDefault<ctu::OsLogLogger,subscriber::SimSlot,std::function<char const* const ()(subscriber::SimSlot)>>::SimInstanceLoggerDefault(v11);
    v12 = v28;
    if (v28 == v27)
    {
      v13 = 4;
      v12 = v27;
    }
    else
    {
      if (!v28)
        goto LABEL_12;
      v13 = 5;
    }
    (*(void (**)(void))(*v12 + 8 * v13))();
LABEL_12:
    v14 = *(_QWORD *)(a1 + 48);
    *(_QWORD *)(a1 + 48) = v11;
    if (v14)
      (*(void (**)(uint64_t))(*(_QWORD *)v14 + 8))(v14);
  }
LABEL_14:
  v15 = v26;
  if (v26 == v25)
  {
    v16 = 4;
    v15 = v25;
  }
  else
  {
    if (!v26)
      goto LABEL_19;
    v16 = 5;
  }
  (*(void (**)(void))(*v15 + 8 * v16))();
LABEL_19:
  v17 = v24;
  if (v24 == v23)
  {
    v18 = 4;
    v17 = v23;
  }
  else
  {
    if (!v24)
      goto LABEL_24;
    v18 = 5;
  }
  (*(void (**)(void))(*v17 + 8 * v18))();
LABEL_24:
  *(_QWORD *)a1 = &off_24D5E1A10;
  *(_QWORD *)(a1 + 56) = *a2;
  v19 = a2[1];
  *(_QWORD *)(a1 + 64) = v19;
  if (v19)
  {
    v20 = (unint64_t *)(v19 + 8);
    do
      v21 = __ldxr(v20);
    while (__stxr(v21 + 1, v20));
  }
  qmi::ClientRouter::ClientRouter((qmi::ClientRouter *)(a1 + 72), *(os_log_s **)(a1 + 40));
  *(_QWORD *)(a1 + 88) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  return a1;
}

void sub_216A28A54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, char a14, uint64_t a15, uint64_t a16, char *a17, char a18, uint64_t a19, uint64_t a20,char *a21)
{
  SignalStrengthCommandDriver *v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;

  v27 = a21;
  if (a21 == v25)
  {
    v28 = 4;
    v27 = &a18;
  }
  else
  {
    if (!a21)
      goto LABEL_6;
    v28 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v27 + 8 * v28))();
LABEL_6:
  MEMORY[0x2199FEAC4](v24, 0x10A1C40FF1576FELL);
  v29 = *((_QWORD *)v21 + 6);
  *((_QWORD *)v21 + 6) = 0;
  if (v29)
    (*(void (**)(uint64_t))(*(_QWORD *)v29 + 8))(v29);
  v30 = a17;
  if (a17 == &a14)
  {
    v31 = 4;
    v30 = &a14;
  }
  else
  {
    if (!a17)
      goto LABEL_13;
    v31 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v30 + 8 * v31))();
LABEL_13:
  v32 = a13;
  if (a13 == &a10)
  {
    v33 = 4;
    v32 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_18;
    v33 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v32 + 8 * v33))();
LABEL_18:
  MEMORY[0x2199FDF6C](v23);
  ctu::SharedSynchronizable<QMIDataSystemDeterminationManager>::~SharedSynchronizable(v22);
  SignalStrengthCommandDriver::~SignalStrengthCommandDriver(v21);
  _Unwind_Resume(a1);
}

__int128 *Mav20SignalStrengthCommandDriver::bootstrap(uint64_t a1, uint64_t a2, uint64_t a3, __int128 *a4)
{
  NSObject *v6;
  __int128 v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  _DWORD *v11;
  char *v12;
  std::__shared_weak_count *v13;
  std::__shared_weak_count *v14;
  std::__shared_weak_count *v15;
  unint64_t *p_shared_weak_owners;
  unint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  NSObject *v20;
  std::__shared_weak_count *v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  unint64_t *v25;
  unint64_t v26;
  unint64_t *v27;
  unint64_t v28;
  _DWORD *v29;
  __int128 *p_buf;
  uint64_t v31;
  void **v32;
  uint64_t v33;
  void **v34;
  uint64_t v35;
  __int128 *result;
  uint64_t v37;
  _DWORD *v38;
  _DWORD *v39;
  uint64_t (*v40)(_QWORD);
  __int128 v41;
  std::__shared_weak_count *v42;
  std::__shared_weak_count *v43;
  NSObject *object;
  void *__p[2];
  char v46;
  void **v47;
  void *v48;
  uint64_t v49;
  __int128 v50;
  __int128 buf;
  __int128 v52;
  uint64_t v53;

  v53 = *MEMORY[0x24BDAC8D0];
  v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl(&dword_216897000, v6, OS_LOG_TYPE_DEFAULT, "#I Bootstrapping", (uint8_t *)&buf, 2u);
  }
  v7 = *a4;
  *(_QWORD *)a4 = 0;
  *((_QWORD *)a4 + 1) = 0;
  v8 = *(std::__shared_weak_count **)(a1 + 96);
  *(_OWORD *)(a1 + 88) = v7;
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v10 = __ldaxr(p_shared_owners);
    while (__stlxr(v10 - 1, p_shared_owners));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  subscriber::makeSimSlotRange();
  v11 = v38;
  if (v38 != v39)
  {
    while ((v40(*v11) & 1) == 0)
    {
      if (++v11 == v39)
      {
        v11 = v39;
        break;
      }
    }
    while (v11 != v39)
    {
      if (*v11 == 1)
      {
        v12 = "SignalStrength.1";
      }
      else if (*v11 == 2)
      {
        v12 = "SignalStrength.2";
      }
      else
      {
        v12 = 0;
      }
      v13 = *(std::__shared_weak_count **)(a1 + 16);
      if (!v13 || (v14 = std::__shared_weak_count::lock(v13)) == 0)
        std::__throw_bad_weak_ptr[abi:ne180100]();
      v15 = v14;
      p_shared_weak_owners = (unint64_t *)&v14->__shared_weak_owners_;
      do
        v17 = __ldxr(p_shared_weak_owners);
      while (__stxr(v17 + 1, p_shared_weak_owners));
      v18 = (unint64_t *)&v14->__shared_owners_;
      do
        v19 = __ldaxr(v18);
      while (__stlxr(v19 - 1, v18));
      if (!v19)
      {
        ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
        std::__shared_weak_count::__release_weak(v15);
      }
      Registry::getServerConnection(*(Registry **)(a1 + 56));
      buf = 0u;
      v52 = 0u;
      std::string::basic_string[abi:ne180100]<0>(&v48, v12);
      v20 = *(NSObject **)(a1 + 24);
      object = v20;
      if (v20)
        dispatch_retain(v20);
      std::string::basic_string[abi:ne180100]<0>(__p, "registration");
      v21 = std::__shared_weak_count::lock(v15);
      if (v21)
      {
        v22 = v21;
        v23 = (unint64_t *)&v21->__shared_weak_owners_;
        do
          v24 = __ldxr(v23);
        while (__stxr(v24 + 1, v23));
        v43 = v21;
        std::__shared_weak_count::__release_weak(v15);
        v25 = (unint64_t *)&v22->__shared_owners_;
        do
          v26 = __ldaxr(v25);
        while (__stlxr(v26 - 1, v25));
        if (v26)
          goto LABEL_37;
        ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
        v15 = v22;
      }
      else
      {
        v43 = 0;
      }
      std::__shared_weak_count::__release_weak(v15);
LABEL_37:
      v42 = (std::__shared_weak_count *)*((_QWORD *)&v41 + 1);
      v41 = 0uLL;
      qmi::Client::createWithQueueLocal();
      if (v42)
      {
        v27 = (unint64_t *)&v42->__shared_owners_;
        do
          v28 = __ldaxr(v27);
        while (__stlxr(v28 - 1, v27));
        if (!v28)
        {
          ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
          std::__shared_weak_count::__release_weak(v42);
        }
      }
      if (v43)
        std::__shared_weak_count::__release_weak(v43);
      if (v46 < 0)
        operator delete(__p[0]);
      if (object)
        dispatch_release(object);
      if (SBYTE7(v50) < 0)
        operator delete(v48);
      v48 = 0;
      v49 = 0;
      v50 = v52;
      v52 = 0uLL;
      qmi::ClientRouter::addClient();
      qmi::Client::~Client((qmi::Client *)&v48);
      qmi::ClientRouter::get();
      qmi::Client::~Client((qmi::Client *)&buf);
      v29 = v11 + 1;
      v11 = v39;
      if (v29 != v39)
      {
        v11 = v29;
        while ((v40(*v11) & 1) == 0)
        {
          if (++v11 == v39)
          {
            v11 = v39;
            break;
          }
        }
      }
    }
  }
  *(_QWORD *)&buf = &off_24D5E1BE8;
  *((_QWORD *)&buf + 1) = a1;
  *((_QWORD *)&v52 + 1) = &buf;
  qmi::ClientRouter::setHandler();
  p_buf = (__int128 *)*((_QWORD *)&v52 + 1);
  if (*((__int128 **)&v52 + 1) == &buf)
  {
    v31 = 4;
    p_buf = &buf;
  }
  else
  {
    if (!*((_QWORD *)&v52 + 1))
      goto LABEL_61;
    v31 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)p_buf + 8 * v31))();
LABEL_61:
  v48 = &off_24D5E1C68;
  v49 = a1;
  *((_QWORD *)&v50 + 1) = &v48;
  qmi::ClientRouter::setHandler();
  v32 = (void **)*((_QWORD *)&v50 + 1);
  if (*((void ***)&v50 + 1) == &v48)
  {
    v33 = 4;
    v32 = &v48;
  }
  else
  {
    if (!*((_QWORD *)&v50 + 1))
      goto LABEL_66;
    v33 = 5;
  }
  (*((void (**)(void))*v32 + v33))();
LABEL_66:
  __p[0] = &off_24D5E1CE8;
  __p[1] = (void *)a1;
  v47 = __p;
  qmi::ClientRouter::setHandler();
  v34 = v47;
  if (v47 == __p)
  {
    v35 = 4;
    v34 = __p;
  }
  else
  {
    if (!v47)
      goto LABEL_71;
    v35 = 5;
  }
  (*((void (**)(void))*v34 + v35))();
LABEL_71:
  *(_QWORD *)&buf = &off_24D5E1D68;
  *((_QWORD *)&buf + 1) = a1;
  *((_QWORD *)&v52 + 1) = &buf;
  qmi::ClientRouter::setIndHandlerInternal();
  result = (__int128 *)*((_QWORD *)&v52 + 1);
  if (*((__int128 **)&v52 + 1) == &buf)
  {
    v37 = 4;
    result = &buf;
  }
  else
  {
    if (!*((_QWORD *)&v52 + 1))
      return result;
    v37 = 5;
  }
  return (__int128 *)(*(uint64_t (**)(void))(*(_QWORD *)result + 8 * v37))();
}

void sub_216A290FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21,dispatch_object_t object,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36)
{
  _QWORD *v36;
  uint64_t v37;
  _QWORD *v39;
  uint64_t v40;

  v39 = *(_QWORD **)(v37 - 120);
  if (v39 == v36)
  {
    v40 = 4;
    v39 = (_QWORD *)(v37 - 144);
  }
  else
  {
    if (!v39)
      goto LABEL_6;
    v40 = 5;
  }
  (*(void (**)(void))(*v39 + 8 * v40))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void Mav20SignalStrengthCommandDriver::getSignalStrength_sync(uint64_t a1, int a2, char a3)
{
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  unint64_t *v9;
  uint64_t v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _OWORD v20[2];
  _QWORD v21[5];
  std::__shared_weak_count *v22;
  char *v23;
  std::__shared_weak_count *v24;
  _QWORD aBlock[5];

  memset(v20, 0, sizeof(v20));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v20);
  v6 = qmi::ClientRouter::get();
  v7 = operator new();
  *(_QWORD *)v7 = v6;
  *(_QWORD *)(v7 + 8) = QMIServiceMsg::create();
  *(_DWORD *)(v7 + 16) = 25000;
  *(_QWORD *)(v7 + 24) = 0;
  *(_QWORD *)(v7 + 32) = 0;
  v19 = v7;
  v8 = operator new(0x28uLL);
  v8[1] = 0;
  v9 = v8 + 1;
  v8[2] = 0;
  *v8 = &off_24D5E2008;
  v8[3] = a1;
  *((_DWORD *)v8 + 8) = a2;
  *((_BYTE *)v8 + 36) = a3;
  v23 = (char *)(v8 + 3);
  v24 = (std::__shared_weak_count *)v8;
  v10 = MEMORY[0x24BDAC760];
  v21[0] = MEMORY[0x24BDAC760];
  v21[1] = 1174405120;
  v21[2] = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN32Mav20SignalStrengthCommandDriver22getSignalStrength_syncENS_16SubscriptionTypeEbE3__0EEOS1_OT__block_invoke;
  v21[3] = &__block_descriptor_tmp_17_18;
  v21[4] = v8 + 3;
  v22 = (std::__shared_weak_count *)v8;
  do
    v11 = __ldxr(v9);
  while (__stxr(v11 + 1, v9));
  aBlock[0] = v10;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas10GetSigInfo8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
  aBlock[3] = &unk_24D5E2050;
  aBlock[4] = v21;
  *(_QWORD *)(v7 + 32) = _Block_copy(aBlock);
  v12 = v22;
  if (v22)
  {
    p_shared_owners = (unint64_t *)&v22->__shared_owners_;
    do
      v14 = __ldaxr(p_shared_owners);
    while (__stlxr(v14 - 1, p_shared_owners));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  v15 = v24;
  if (v24)
  {
    v16 = (unint64_t *)&v24->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  v18 = v19;
  v19 = 0;
  if (v18)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v19, v18);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v20);
}

void sub_216A2942C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;
  va_list va;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v6 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v4);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  if (a3)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v3, a3);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

uint64_t Mav20SignalStrengthCommandDriver::start(Mav20SignalStrengthCommandDriver *this)
{
  NSObject *v1;
  uint8_t v3[16];

  v1 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v3 = 0;
    _os_log_impl(&dword_216897000, v1, OS_LOG_TYPE_DEFAULT, "#I Starting", v3, 2u);
  }
  return qmi::ClientRouter::start();
}

uint64_t Mav20SignalStrengthCommandDriver::shutdown(uint64_t a1)
{
  NSObject *v1;
  uint8_t v3[16];

  v1 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v3 = 0;
    _os_log_impl(&dword_216897000, v1, OS_LOG_TYPE_DEFAULT, "#I Shutting down", v3, 2u);
  }
  return qmi::ClientRouter::stop();
}

void Mav20SignalStrengthCommandDriver::poll(uint64_t a1, int a2)
{
  NSObject *v4;
  int v5;
  uint8_t v6[16];

  v4 = *(NSObject **)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 48) + 16))(*(_QWORD *)(a1 + 48));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v6 = 0;
    _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I Polling", v6, 2u);
  }
  if ((a2 - 1) >= 3)
    v5 = 0;
  else
    v5 = a2;
  Mav20SignalStrengthCommandDriver::getSignalStrength_sync(a1, v5, 0);
}

void Mav20SignalStrengthCommandDriver::start(uint64_t a1, int a2, uint64_t *a3)
{
  int v5;
  NSObject *v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  uint64_t v13[2];
  uint8_t buf[16];

  if ((a2 - 1) >= 3)
    v5 = 0;
  else
    v5 = a2;
  v6 = *(NSObject **)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 48) + 16))(*(_QWORD *)(a1 + 48));
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_216897000, v6, OS_LOG_TYPE_DEFAULT, "#I Starting reporting", buf, 2u);
  }
  v7 = *a3;
  v8 = (std::__shared_weak_count *)a3[1];
  v13[0] = v7;
  v13[1] = (uint64_t)v8;
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
  }
  Mav20SignalStrengthCommandDriver::setThresholds_sync(a1, v5, v13, 0);
  if (v8)
  {
    v11 = (unint64_t *)&v8->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
}

void sub_216A296F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void Mav20SignalStrengthCommandDriver::setThresholds_sync(uint64_t a1, int a2, uint64_t *a3, int a4)
{
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  unint64_t *v11;
  uint64_t v12;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _OWORD v22[2];
  _QWORD v23[5];
  std::__shared_weak_count *v24;
  char *v25;
  std::__shared_weak_count *v26;
  _QWORD aBlock[5];

  memset(v22, 0, sizeof(v22));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v22);
  prepareThresholds(v22);
  populateThresholds(*a3, v22);
  *(_BYTE *)qmi::MutableMessageBase::getTLV<nas::tlv::LinkQualityIndicator>(v22, 160) = 1;
  v8 = qmi::ClientRouter::get();
  v9 = operator new();
  *(_QWORD *)v9 = v8;
  *(_QWORD *)(v9 + 8) = QMIServiceMsg::create();
  *(_DWORD *)(v9 + 16) = 25000;
  *(_QWORD *)(v9 + 24) = 0;
  *(_QWORD *)(v9 + 32) = 0;
  v21 = v9;
  v10 = operator new(0x28uLL);
  v10[1] = 0;
  v11 = v10 + 1;
  v10[2] = 0;
  *v10 = &off_24D5E2100;
  v10[3] = a1;
  *((_DWORD *)v10 + 8) = a2;
  *((_DWORD *)v10 + 9) = a4;
  v25 = (char *)(v10 + 3);
  v26 = (std::__shared_weak_count *)v10;
  v12 = MEMORY[0x24BDAC760];
  v23[0] = MEMORY[0x24BDAC760];
  v23[1] = 1174405120;
  v23[2] = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN32Mav20SignalStrengthCommandDriver18setThresholds_syncENS_16SubscriptionTypeENSt3__110shared_ptrIK15InputThresholdsEE21SignalStrengthCmdTypeE3__0EEOS1_OT__block_invoke;
  v23[3] = &__block_descriptor_tmp_19_15;
  v23[4] = v10 + 3;
  v24 = (std::__shared_weak_count *)v10;
  do
    v13 = __ldxr(v11);
  while (__stxr(v13 + 1, v11));
  aBlock[0] = v12;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas14ConfigSigInfo28ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
  aBlock[3] = &unk_24D5E2148;
  aBlock[4] = v23;
  *(_QWORD *)(v9 + 32) = _Block_copy(aBlock);
  v14 = v24;
  if (v24)
  {
    p_shared_owners = (unint64_t *)&v24->__shared_owners_;
    do
      v16 = __ldaxr(p_shared_owners);
    while (__stlxr(v16 - 1, p_shared_owners));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
  v17 = v26;
  if (v26)
  {
    v18 = (unint64_t *)&v26->__shared_owners_;
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
  v20 = v21;
  v21 = 0;
  if (v20)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v21, v20);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v22);
}

void sub_216A2991C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;
  va_list va;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v6 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v4);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  if (a3)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v3, a3);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

void Mav20SignalStrengthCommandDriver::update(uint64_t a1, int a2, uint64_t *a3)
{
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  uint64_t v8[2];

  v3 = (std::__shared_weak_count *)a3[1];
  if ((a2 - 1) >= 3)
    a2 = 0;
  v8[0] = *a3;
  v8[1] = (uint64_t)v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  Mav20SignalStrengthCommandDriver::setThresholds_sync(a1, a2, v8, 2);
  if (v3)
  {
    v6 = (unint64_t *)&v3->__shared_owners_;
    do
      v7 = __ldaxr(v6);
    while (__stlxr(v7 - 1, v6));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void sub_216A29A28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void Mav20SignalStrengthCommandDriver::stop(uint64_t a1, int a2)
{
  int v3;
  NSObject *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  uint64_t v11;
  std::__shared_weak_count *v12;
  uint64_t v13[2];

  if ((a2 - 1) >= 3)
    v3 = 0;
  else
    v3 = a2;
  v4 = *(NSObject **)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 48) + 16))(*(_QWORD *)(a1 + 48));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v11) = 0;
    _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I Stopping reporting", (uint8_t *)&v11, 2u);
  }
  v5 = (std::__shared_weak_count *)operator new(0x38uLL);
  v5->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v5->__shared_owners_;
  v5->__shared_weak_owners_ = 0;
  v5->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E1F88;
  LOBYTE(v5[1].__vftable) = 0;
  v5[1].__shared_weak_owners_ = 0;
  v5[2].__vftable = 0;
  v5[1].__shared_owners_ = (uint64_t)&v5[1].__shared_weak_owners_;
  v13[0] = (uint64_t)&v5[1];
  v13[1] = (uint64_t)v5;
  v11 = 0;
  v12 = 0;
  Mav20SignalStrengthCommandDriver::setThresholds_sync(a1, v3, v13, 1);
  do
    v7 = __ldaxr(p_shared_owners);
  while (__stlxr(v7 - 1, p_shared_owners));
  if (!v7)
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  v8 = v12;
  if (v12)
  {
    v9 = (unint64_t *)&v12->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
}

void sub_216A29B7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void Mav20SignalStrengthCommandDriver::~Mav20SignalStrengthCommandDriver(Mav20SignalStrengthCommandDriver *this)
{
  uint64_t v2;

  *(_QWORD *)this = &off_24D5E1A10;
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)this + 88);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)this + 72);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)this + 56);
  v2 = *((_QWORD *)this + 6);
  *((_QWORD *)this + 6) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  MEMORY[0x2199FDF6C]((char *)this + 40);
  ctu::SharedSynchronizable<QMIDataSystemDeterminationManager>::~SharedSynchronizable((_QWORD *)this + 1);
  SignalStrengthCommandDriver::~SignalStrengthCommandDriver(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = &off_24D5E1A10;
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)this + 88);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)this + 72);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)this + 56);
  v2 = *((_QWORD *)this + 6);
  *((_QWORD *)this + 6) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  MEMORY[0x2199FDF6C]((char *)this + 40);
  ctu::SharedSynchronizable<QMIDataSystemDeterminationManager>::~SharedSynchronizable((_QWORD *)this + 1);
  SignalStrengthCommandDriver::~SignalStrengthCommandDriver(this);
  JUMPOUT(0x2199FEAC4);
}

uint64_t *std::shared_ptr<Mav20SignalStrengthCommandDriver>::shared_ptr[abi:ne180100]<Mav20SignalStrengthCommandDriver,std::shared_ptr<Mav20SignalStrengthCommandDriver> ctu::SharedSynchronizable<Mav20SignalStrengthCommandDriver>::make_shared_ptr<Mav20SignalStrengthCommandDriver>(Mav20SignalStrengthCommandDriver*)::{lambda(Mav20SignalStrengthCommandDriver*)#1},void>(uint64_t *a1, uint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24D5E1B48;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = (uint64_t)v4;
  if (a2)
    v5 = (_QWORD *)(a2 + 8);
  else
    v5 = 0;
  std::shared_ptr<QMIDataSystemDeterminationManager>::__enable_weak_this[abi:ne180100]<QMIDataSystemDeterminationManager,QMIDataSystemDeterminationManager,void>((uint64_t)a1, v5, a2);
  return a1;
}

void sub_216A29CF0(void *a1)
{
  dispatch_queue_t *v1;

  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)std::shared_ptr<Mav20SignalStrengthCommandDriver> ctu::SharedSynchronizable<Mav20SignalStrengthCommandDriver>::make_shared_ptr<Mav20SignalStrengthCommandDriver>(Mav20SignalStrengthCommandDriver*)::{lambda(Mav20SignalStrengthCommandDriver*)#1}::operator() const(Mav20SignalStrengthCommandDriver*)::{lambda(void *)#1}::__invoke);
  __cxa_rethrow();
}

void sub_216A29D10(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<Mav20SignalStrengthCommandDriver *,std::shared_ptr<Mav20SignalStrengthCommandDriver> ctu::SharedSynchronizable<Mav20SignalStrengthCommandDriver>::make_shared_ptr<Mav20SignalStrengthCommandDriver>(Mav20SignalStrengthCommandDriver*)::{lambda(Mav20SignalStrengthCommandDriver *)#1},std::allocator<Mav20SignalStrengthCommandDriver>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void std::__shared_ptr_pointer<Mav20SignalStrengthCommandDriver *,std::shared_ptr<Mav20SignalStrengthCommandDriver> ctu::SharedSynchronizable<Mav20SignalStrengthCommandDriver>::make_shared_ptr<Mav20SignalStrengthCommandDriver>(Mav20SignalStrengthCommandDriver*)::{lambda(Mav20SignalStrengthCommandDriver *)#1},std::allocator<Mav20SignalStrengthCommandDriver>>::__on_zero_shared(uint64_t a1)
{
  dispatch_barrier_async_f(*(dispatch_queue_t *)(*(_QWORD *)(a1 + 24) + 24), *(void **)(a1 + 24), (dispatch_function_t)std::shared_ptr<Mav20SignalStrengthCommandDriver> ctu::SharedSynchronizable<Mav20SignalStrengthCommandDriver>::make_shared_ptr<Mav20SignalStrengthCommandDriver>(Mav20SignalStrengthCommandDriver*)::{lambda(Mav20SignalStrengthCommandDriver*)#1}::operator() const(Mav20SignalStrengthCommandDriver*)::{lambda(void *)#1}::__invoke);
}

uint64_t std::__shared_ptr_pointer<Mav20SignalStrengthCommandDriver *,std::shared_ptr<Mav20SignalStrengthCommandDriver> ctu::SharedSynchronizable<Mav20SignalStrengthCommandDriver>::make_shared_ptr<Mav20SignalStrengthCommandDriver>(Mav20SignalStrengthCommandDriver*)::{lambda(Mav20SignalStrengthCommandDriver *)#1},std::allocator<Mav20SignalStrengthCommandDriver>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t std::shared_ptr<Mav20SignalStrengthCommandDriver> ctu::SharedSynchronizable<Mav20SignalStrengthCommandDriver>::make_shared_ptr<Mav20SignalStrengthCommandDriver>(Mav20SignalStrengthCommandDriver*)::{lambda(Mav20SignalStrengthCommandDriver*)#1}::operator() const(Mav20SignalStrengthCommandDriver*)::{lambda(void *)#1}::__invoke(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

void SimInstanceLoggable<Mav20SignalStrengthCommandDriver,ctu::OsLogLogger,subscriber::SimSlot>::~SimInstanceLoggable()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t SimInstanceLoggable<Mav20SignalStrengthCommandDriver,ctu::OsLogLogger,subscriber::SimSlot>::getLoggerForSlot(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8) + 40;
}

void std::__function::__func<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_0,std::allocator<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_0>,void ()(qmi::SubscriptionType)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_0,std::allocator<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_0>,void ()(qmi::SubscriptionType)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5E1BE8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_0,std::allocator<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_0>,void ()(qmi::SubscriptionType)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5E1BE8;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_0,std::allocator<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_0>,void ()(qmi::SubscriptionType)>::operator()(uint64_t a1, unsigned int *a2)
{
  unsigned int v2;
  uint64_t v3;
  uint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  uint64_t v18;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v27;
  uint64_t v28;
  __int128 v29;
  __int128 v30;
  uint64_t v31;
  uint64_t v32;
  void (*v33)(uint64_t, uint64_t);
  void *v34;
  std::__shared_weak_count *v35;
  std::__shared_weak_count *v36;
  uint64_t aBlock;
  uint64_t v38;
  void (*v39)(uint64_t, uint64_t);
  void *v40;
  uint64_t *v41;

  v2 = *a2;
  v3 = *(_QWORD *)(a1 + 8);
  v29 = 0u;
  v30 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)&v29);
  *(_BYTE *)qmi::MutableMessageBase::getTLV<nas::tlv::SubType>(&v29, 1) = v2 == 2;
  v4 = qmi::ClientRouter::get();
  qmi::ClientRouter::SendProxy::SendProxy<nas::BindSubscription::Request>((uint64_t)&v27, v2, v4);
  v5 = (std::__shared_weak_count *)operator new(0x28uLL);
  v5->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v5->__shared_owners_;
  v5->__shared_weak_owners_ = 0;
  v5->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E1F10;
  v5[1].__vftable = (std::__shared_weak_count_vtbl *)v3;
  LODWORD(v5[1].__shared_owners_) = v2;
  v7 = v28;
  v8 = MEMORY[0x24BDAC760];
  v31 = MEMORY[0x24BDAC760];
  v32 = 1174405120;
  v33 = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN32Mav20SignalStrengthCommandDriver21bindSubscription_syncENS_16SubscriptionTypeEE3__0EEOS1_OT__block_invoke;
  v34 = &__block_descriptor_tmp_15_22;
  v35 = v5 + 1;
  v36 = v5;
  do
    v9 = __ldxr(p_shared_owners);
  while (__stxr(v9 + 1, p_shared_owners));
  aBlock = v8;
  v38 = 0x40000000;
  v39 = ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas16BindSubscription8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke_4;
  v40 = &unk_24D5E1F58;
  v41 = &v31;
  *(_QWORD *)(v7 + 32) = _Block_copy(&aBlock);
  v10 = v36;
  if (v36)
  {
    v11 = (unint64_t *)&v36->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  do
    v13 = __ldaxr(p_shared_owners);
  while (__stlxr(v13 - 1, p_shared_owners));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  v14 = v28;
  v28 = 0;
  if (v14)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v28, v14);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&v29);
  v29 = 0u;
  v30 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)&v29);
  *(_BYTE *)qmi::MutableMessageBase::getTLV<nas::tlv::SigInfoEvents>(&v29, 25) = 1;
  v15 = qmi::ClientRouter::get();
  qmi::ClientRouter::SendProxy::SendProxy<nas::IndicationRegister::Request>((uint64_t)&v27, v2, v15);
  v16 = (std::__shared_weak_count *)operator new(0x28uLL);
  v16->__shared_owners_ = 0;
  v17 = (unint64_t *)&v16->__shared_owners_;
  v16->__shared_weak_owners_ = 0;
  v16->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E1E68;
  v16[1].__vftable = (std::__shared_weak_count_vtbl *)v3;
  LODWORD(v16[1].__shared_owners_) = v2;
  v18 = v28;
  v31 = v8;
  v32 = 1174405120;
  v33 = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN32Mav20SignalStrengthCommandDriver27sendIndRegisterRequest_syncENS_16SubscriptionTypeEE3__0EEOS1_OT__block_invoke;
  v34 = &__block_descriptor_tmp_12_17;
  v35 = v16 + 1;
  v36 = v16;
  do
    v19 = __ldxr(v17);
  while (__stxr(v19 + 1, v17));
  aBlock = v8;
  v38 = 0x40000000;
  v39 = ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas18IndicationRegister8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke_2;
  v40 = &unk_24D5E1EB0;
  v41 = &v31;
  *(_QWORD *)(v18 + 32) = _Block_copy(&aBlock);
  v20 = v36;
  if (v36)
  {
    v21 = (unint64_t *)&v36->__shared_owners_;
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
  do
    v23 = __ldaxr(v17);
  while (__stlxr(v23 - 1, v17));
  if (!v23)
  {
    ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
    std::__shared_weak_count::__release_weak(v16);
  }
  v24 = v28;
  v28 = 0;
  if (v24)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v28, v24);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&v29);
  if (v2 - 1 >= 3)
    v25 = 0;
  else
    v25 = v2;
  return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(**(_QWORD **)(v3 + 88) + 16))(*(_QWORD *)(v3 + 88), v25, 1);
}

void sub_216A2A18C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21)
{
  std::__shared_weak_count *v21;
  unint64_t *v22;
  std::__shared_weak_count *v24;
  unint64_t *p_shared_owners;
  unint64_t v26;
  unint64_t v27;
  uint64_t v28;

  v24 = a21;
  if (a21)
  {
    p_shared_owners = (unint64_t *)&a21->__shared_owners_;
    do
      v26 = __ldaxr(p_shared_owners);
    while (__stlxr(v26 - 1, p_shared_owners));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
  }
  do
    v27 = __ldaxr(v22);
  while (__stlxr(v27 - 1, v22));
  if (!v27)
  {
    ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
    std::__shared_weak_count::__release_weak(v21);
  }
  v28 = a10;
  a10 = 0;
  if (v28)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&a10, v28);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a11);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_0,std::allocator<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_0>,void ()(qmi::SubscriptionType)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_0,std::allocator<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_0>,void ()(qmi::SubscriptionType)>::target_type()
{
}

void std::__function::__func<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_1,std::allocator<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_1>,void ()(qmi::SubscriptionType)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_1,std::allocator<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_1>,void ()(qmi::SubscriptionType)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5E1C68;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_1,std::allocator<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_1>,void ()(qmi::SubscriptionType)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5E1C68;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_1,std::allocator<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_1>,void ()(qmi::SubscriptionType)>::operator()(uint64_t a1, _DWORD *a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 88);
  if ((*a2 - 1) >= 3)
    v3 = 0;
  else
    v3 = *a2;
  return (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)v2 + 16))(v2, v3, 0);
}

uint64_t std::__function::__func<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_1,std::allocator<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_1>,void ()(qmi::SubscriptionType)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_1,std::allocator<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_1>,void ()(qmi::SubscriptionType)>::target_type()
{
}

void std::__function::__func<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_2,std::allocator<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_2>,void ()(qmi::SubscriptionType)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_2,std::allocator<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_2>,void ()(qmi::SubscriptionType)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5E1CE8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_2,std::allocator<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_2>,void ()(qmi::SubscriptionType)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5E1CE8;
  a2[1] = v2;
  return result;
}

void std::__function::__func<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_2,std::allocator<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_2>,void ()(qmi::SubscriptionType)>::operator()(uint64_t a1, int *a2)
{
  Mav20SignalStrengthCommandDriver::getSignalStrength_sync(*(_QWORD *)(a1 + 8), *a2, 0);
}

uint64_t std::__function::__func<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_2,std::allocator<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_2>,void ()(qmi::SubscriptionType)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_2,std::allocator<Mav20SignalStrengthCommandDriver::registerEvents_sync(void)::$_2>,void ()(qmi::SubscriptionType)>::target_type()
{
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<Mav20SignalStrengthCommandDriver::registerIndications_sync(void)::$_0>(unsigned short,Mav20SignalStrengthCommandDriver::registerIndications_sync(void)::$_0 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(Mav20SignalStrengthCommandDriver::registerIndications_sync(void)::$_0 &&,QMIServiceMsg const)>::~__func()
{
  JUMPOUT(0x2199FEAC4);
}

_QWORD *std::__function::__func<void qmi::ClientRouter::setIndHandler<Mav20SignalStrengthCommandDriver::registerIndications_sync(void)::$_0>(unsigned short,Mav20SignalStrengthCommandDriver::registerIndications_sync(void)::$_0 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(Mav20SignalStrengthCommandDriver::registerIndications_sync(void)::$_0 &&,QMIServiceMsg const)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D5E1D68;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<Mav20SignalStrengthCommandDriver::registerIndications_sync(void)::$_0>(unsigned short,Mav20SignalStrengthCommandDriver::registerIndications_sync(void)::$_0 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(Mav20SignalStrengthCommandDriver::registerIndications_sync(void)::$_0 &&,QMIServiceMsg const)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D5E1D68;
  a2[1] = v2;
  return result;
}

void std::__function::__func<void qmi::ClientRouter::setIndHandler<Mav20SignalStrengthCommandDriver::registerIndications_sync(void)::$_0>(unsigned short,Mav20SignalStrengthCommandDriver::registerIndications_sync(void)::$_0 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(Mav20SignalStrengthCommandDriver::registerIndications_sync(void)::$_0 &&,QMIServiceMsg const)>::operator()(uint64_t a1, unsigned int *a2, QMIServiceMsg *this)
{
  unsigned int v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  uint64_t v12;
  void *TlvValue;
  int v14;
  void *v15;
  int v16;
  char v17;
  uint64_t v18;
  void *v19;
  int v20;
  void *v21;
  int v22;
  char v23;
  unsigned int v24;
  uint64_t v25;
  char *v26;
  int v27;
  char *v28;
  int v29;
  char *v30;
  uint64_t v31;
  int v32;
  void *v33;
  int v34;
  void *v35;
  int v36;
  unsigned __int8 v37;
  uint64_t v38;
  std::__shared_weak_count *v39;
  unint64_t *v40;
  unint64_t v41;
  _WORD v42[12];
  uint64_t v43;
  std::__shared_weak_count *v44;
  uint64_t v45;
  std::__shared_weak_count *v46;
  void *__p;
  _BYTE *v48;
  uint64_t v49;
  char *v50;
  void *v51;
  void *v52;
  uint64_t v53;

  v4 = *a2;
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    v51 = 0;
    v52 = 0;
    v53 = 0;
    QMIServiceMsg::serialize(this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v42, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v42);
    if (v51)
    {
      v52 = v51;
      operator delete(v51);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v42);
  }
  v6 = *(_QWORD *)(a1 + 8);
  v45 = 0;
  v46 = 0;
  parseInputs((qmi::MessageBase *)v42, &v45);
  if (*(_QWORD *)(v45 + 16))
  {
    v7 = v4 - 1 >= 3 ? 0 : v4;
    v8 = *(_QWORD *)(v6 + 88);
    v43 = v45;
    v44 = v46;
    v45 = 0;
    v46 = 0;
    (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(_QWORD *)v8 + 32))(v8, v7, &v43);
    v9 = v44;
    if (v44)
    {
      p_shared_owners = (unint64_t *)&v44->__shared_owners_;
      do
        v11 = __ldaxr(p_shared_owners);
      while (__stlxr(v11 - 1, p_shared_owners));
      if (!v11)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
  }
  if (v4 - 1 >= 3)
    v12 = 0;
  else
    v12 = v4;
  TlvValue = (void *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)v42);
  v15 = TlvValue;
  if (TlvValue)
  {
    v16 = v14;
    v51 = TlvValue;
    v17 = tlv::parseV<nas::tlv::LinkQuality>((unint64_t *)&v51, v14);
    if (v51)
    {
      if (v17 == 1)
        v18 = 100;
      else
        v18 = 50;
      (*(void (**)(_QWORD, uint64_t, uint64_t))(**(_QWORD **)(v6 + 88) + 40))(*(_QWORD *)(v6 + 88), v12, v18);
    }
    else
    {
      ((void (*)(_QWORD, uint64_t, void *, _QWORD))*MEMORY[0x24BED8BD0])(v42[0], 160, v15, v16);
    }
  }
  v19 = (void *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)v42);
  v21 = v19;
  if (v19)
  {
    v22 = v20;
    v51 = v19;
    v23 = tlv::parseV<nas::tlv::DataLinkQuality>((unint64_t *)&v51, v20);
    if (v51)
    {
      if (v23 == 100)
        v24 = 100;
      else
        v24 = 50;
      if (v23 == 10)
        v25 = 10;
      else
        v25 = v24;
      (*(void (**)(_QWORD, uint64_t, uint64_t))(**(_QWORD **)(v6 + 88) + 40))(*(_QWORD *)(v6 + 88), v12, v25);
    }
    else
    {
      ((void (*)(_QWORD, uint64_t, void *, _QWORD))*MEMORY[0x24BED8BD0])(v42[0], 162, v21, v22);
    }
  }
  v26 = (char *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)v42);
  v28 = v26;
  if (v26)
  {
    v29 = v27;
    v49 = 0;
    v50 = v26;
    __p = 0;
    v48 = 0;
    tlv::parseV<nas::tlv::EnhancedVoiceLinkQuality>(&v50, v27, &__p);
    v30 = v50;
    if (v50)
    {
      v31 = *(_QWORD *)(v6 + 88);
      v52 = 0;
      v53 = 0;
      v51 = 0;
      std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(&v51, __p, (uint64_t)v48, v48 - (_BYTE *)__p);
      (*(void (**)(uint64_t, uint64_t, void **))(*(_QWORD *)v31 + 56))(v31, v12, &v51);
      if (v51)
      {
        v52 = v51;
        operator delete(v51);
      }
    }
    if (__p)
    {
      v48 = __p;
      operator delete(__p);
    }
    if (v30)
      v32 = 0;
    else
      v32 = ((uint64_t (*)(_QWORD, uint64_t, char *, _QWORD))*MEMORY[0x24BED8BD0])(v42[0], 164, v28, v29) ^ 1;
  }
  else
  {
    v32 = 1;
  }
  v33 = (void *)qmi::MessageBase::findTlvValue((qmi::MessageBase *)v42);
  v35 = v33;
  if (v33)
  {
    v36 = v34;
    v51 = v33;
    v37 = tlv::parseV<nas::tlv::VoiceLinkQuality>((unint64_t *)&v51, v34);
    if (v51)
    {
      if (v32)
      {
        v38 = v37;
        if (v37 != 10 && v37 != 100 && v37 != 50)
          v38 = 50;
        (*(void (**)(_QWORD, uint64_t, uint64_t))(**(_QWORD **)(v6 + 88) + 48))(*(_QWORD *)(v6 + 88), v12, v38);
      }
    }
    else
    {
      ((void (*)(_QWORD, uint64_t, void *, _QWORD))*MEMORY[0x24BED8BD0])(v42[0], 163, v35, v36);
    }
  }
  v39 = v46;
  if (v46)
  {
    v40 = (unint64_t *)&v46->__shared_owners_;
    do
      v41 = __ldaxr(v40);
    while (__stlxr(v41 - 1, v40));
    if (!v41)
    {
      ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
      std::__shared_weak_count::__release_weak(v39);
    }
  }
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v42);
}

void sub_216A2A8C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, char a14, uint64_t a15, void *__p, uint64_t a17)
{
  uint64_t v17;
  void *v19;

  v19 = *(void **)(v17 - 72);
  if (v19)
  {
    *(_QWORD *)(v17 - 64) = v19;
    operator delete(v19);
  }
  if (__p)
  {
    a17 = (uint64_t)__p;
    operator delete(__p);
  }
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a14);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<void qmi::ClientRouter::setIndHandler<Mav20SignalStrengthCommandDriver::registerIndications_sync(void)::$_0>(unsigned short,Mav20SignalStrengthCommandDriver::registerIndications_sync(void)::$_0 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(Mav20SignalStrengthCommandDriver::registerIndications_sync(void)::$_0 &&,QMIServiceMsg const)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void qmi::ClientRouter::setIndHandler<Mav20SignalStrengthCommandDriver::registerIndications_sync(void)::$_0>(unsigned short,Mav20SignalStrengthCommandDriver::registerIndications_sync(void)::$_0 &&)::{lambda(qmi::SubscriptionType,QMIServiceMsg const&)#1},std::allocator<QMIServiceMsg const&>,void ()(Mav20SignalStrengthCommandDriver::registerIndications_sync(void)::$_0 &&,QMIServiceMsg const)>::target_type()
{
}

uint64_t qmi::MutableMessageBase::getTLV<nas::tlv::SigInfoEvents>(_QWORD *a1, int a2)
{
  const void **v2;
  const void **v3;
  void *v4;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3)
        return qmi::MutableMessageBase::createTLV<nas::tlv::SigInfoEvents>(a1, a2);
    }
  }
  if (v2 == v3)
    return qmi::MutableMessageBase::createTLV<nas::tlv::SigInfoEvents>(a1, a2);
  if (!v4)
    __cxa_bad_cast();
  return (uint64_t)v4 + 9;
}

uint64_t qmi::MutableMessageBase::createTLV<nas::tlv::SigInfoEvents>(_QWORD *a1, char a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v4 = operator new();
  *(_BYTE *)(v4 + 8) = a2;
  *(_BYTE *)(v4 + 9) = 0;
  *(_QWORD *)v4 = &off_24D5E1E00;
  v5 = a1[3];
  v6 = (uint64_t *)a1[2];
  if ((unint64_t)v6 >= v5)
  {
    v8 = a1[1];
    v9 = ((uint64_t)v6 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v5 - v8;
    v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1))
      v11 = v9 + 1;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v12);
    else
      v13 = 0;
    v14 = (uint64_t *)&v13[8 * v9];
    v15 = &v13[8 * v12];
    *v14 = v4;
    v7 = v14 + 1;
    v17 = (char *)a1[1];
    v16 = (char *)a1[2];
    if (v16 != v17)
    {
      do
      {
        v18 = *((_QWORD *)v16 - 1);
        v16 -= 8;
        *--v14 = v18;
      }
      while (v16 != v17);
      v16 = (char *)a1[1];
    }
    a1[1] = v14;
    a1[2] = v7;
    a1[3] = v15;
    if (v16)
      operator delete(v16);
  }
  else
  {
    *v6 = v4;
    v7 = v6 + 1;
  }
  a1[2] = v7;
  return v4 + 9;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::SigInfoEvents>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::SigInfoEvents>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<nas::tlv::SigInfoEvents>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::SigInfoEvents>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E1E00;
  return result;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN32Mav20SignalStrengthCommandDriver27sendIndRegisterRequest_syncENS_16SubscriptionTypeEE3__0EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t *v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  __int16 v12;
  int v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)(a2 + 4))
  {
    v3 = *(uint64_t **)(a1 + 32);
    v4 = *v3;
    v5 = *((_DWORD *)v3 + 2);
    if (v5 - 1 >= 3)
      v6 = 0;
    else
      v6 = v5;
    v7 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v4 + 48) + 16))(*(_QWORD *)(v4 + 48), v6);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      v8 = qmi::asString();
      v9 = *(_DWORD *)(a2 + 4);
      v10 = 136315394;
      v11 = v8;
      v12 = 1024;
      v13 = v9;
      _os_log_error_impl(&dword_216897000, v7, OS_LOG_TYPE_ERROR, "Error registering for Sig Info events: %s (0x%x)", (uint8_t *)&v10, 0x12u);
    }
  }
}

uint64_t __copy_helper_block_e8_32c121_ZTSNSt3__110shared_ptrIZN32Mav20SignalStrengthCommandDriver27sendIndRegisterRequest_syncEN3qmi16SubscriptionTypeEE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c121_ZTSNSt3__110shared_ptrIZN32Mav20SignalStrengthCommandDriver27sendIndRegisterRequest_syncEN3qmi16SubscriptionTypeEE3__0EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<Mav20SignalStrengthCommandDriver::sendIndRegisterRequest_sync(qmi::SubscriptionType)::$_0,std::allocator<Mav20SignalStrengthCommandDriver::sendIndRegisterRequest_sync(qmi::SubscriptionType)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E1E68;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<Mav20SignalStrengthCommandDriver::sendIndRegisterRequest_sync(qmi::SubscriptionType)::$_0,std::allocator<Mav20SignalStrengthCommandDriver::sendIndRegisterRequest_sync(qmi::SubscriptionType)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E1E68;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas18IndicationRegister8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BYTE v3[24];

  v2 = *(_QWORD *)(a1 + 32);
  cast_message_type<nas::IndicationRegister::Response const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_216A2AD88(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN32Mav20SignalStrengthCommandDriver21bindSubscription_syncENS_16SubscriptionTypeEE3__0EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t *v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  __int16 v12;
  int v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)(a2 + 4))
  {
    v3 = *(uint64_t **)(a1 + 32);
    v4 = *v3;
    v5 = *((_DWORD *)v3 + 2);
    if (v5 - 1 >= 3)
      v6 = 0;
    else
      v6 = v5;
    v7 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v4 + 48) + 16))(*(_QWORD *)(v4 + 48), v6);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      v8 = qmi::asString();
      v9 = *(_DWORD *)(a2 + 4);
      v10 = 136315394;
      v11 = v8;
      v12 = 1024;
      v13 = v9;
      _os_log_error_impl(&dword_216897000, v7, OS_LOG_TYPE_ERROR, "Error binding subscription: %s (0x%x)", (uint8_t *)&v10, 0x12u);
    }
  }
}

uint64_t __copy_helper_block_e8_32c115_ZTSNSt3__110shared_ptrIZN32Mav20SignalStrengthCommandDriver21bindSubscription_syncEN3qmi16SubscriptionTypeEE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c115_ZTSNSt3__110shared_ptrIZN32Mav20SignalStrengthCommandDriver21bindSubscription_syncEN3qmi16SubscriptionTypeEE3__0EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<Mav20SignalStrengthCommandDriver::bindSubscription_sync(qmi::SubscriptionType)::$_0,std::allocator<Mav20SignalStrengthCommandDriver::bindSubscription_sync(qmi::SubscriptionType)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E1F10;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<Mav20SignalStrengthCommandDriver::bindSubscription_sync(qmi::SubscriptionType)::$_0,std::allocator<Mav20SignalStrengthCommandDriver::bindSubscription_sync(qmi::SubscriptionType)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E1F10;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas16BindSubscription8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke_4(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BYTE v3[24];

  v2 = *(_QWORD *)(a1 + 32);
  cast_message_type<nas::BindSubscription::Response const&>::cast(a2, (qmi::ResponseBase *)v3);
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v3);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v3);
}

void sub_216A2AF3C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)va);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<InputThresholds>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E1F88;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<InputThresholds>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E1F88;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void std::__shared_ptr_emplace<InputThresholds>::__on_zero_shared(uint64_t a1)
{
  std::__tree<std::__value_type<std::pair<Technology,Type>,InputThreshold>,std::__map_value_compare<std::pair<Technology,Type>,std::__value_type<std::pair<Technology,Type>,InputThreshold>,std::less<std::pair<Technology,Type>>,true>,std::allocator<std::__value_type<std::pair<Technology,Type>,InputThreshold>>>::destroy(a1 + 32, *(_QWORD **)(a1 + 40));
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN32Mav20SignalStrengthCommandDriver22getSignalStrength_syncENS_16SubscriptionTypeEbE3__0EEOS1_OT__block_invoke(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t *v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;
  NSObject *v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  uint64_t v14;
  void *TlvValue;
  int v16;
  void *v17;
  int v18;
  char v19;
  uint64_t v20;
  void *v21;
  int v22;
  void *v23;
  int v24;
  char v25;
  unsigned int v26;
  uint64_t v27;
  char *v28;
  int v29;
  char *v30;
  int v31;
  char *v32;
  uint64_t v33;
  int v34;
  void *v35;
  int v36;
  void *v37;
  int v38;
  unsigned __int8 v39;
  uint64_t v40;
  std::__shared_weak_count *v41;
  unint64_t *v42;
  unint64_t v43;
  void *v44;
  int v45;
  uint64_t v46;
  std::__shared_weak_count *v47;
  uint64_t v48;
  std::__shared_weak_count *v49;
  void *v50;
  _BYTE *v51;
  uint64_t v52;
  char *v53;
  void *__p[4];

  __p[3] = *(void **)MEMORY[0x24BDAC8D0];
  v3 = *(uint64_t **)(a1 + 32);
  v4 = *v3;
  if (*((_DWORD *)a2 + 1))
  {
    v5 = *((_DWORD *)v3 + 2);
    if (v5 - 1 >= 3)
      v6 = 0;
    else
      v6 = v5;
    v7 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v4 + 48) + 16))(*(_QWORD *)(v4 + 48), v6);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      v44 = (void *)qmi::asString();
      v45 = *((_DWORD *)a2 + 1);
      LODWORD(__p[0]) = 136315394;
      *(void **)((char *)__p + 4) = v44;
      WORD2(__p[1]) = 1024;
      *(_DWORD *)((char *)&__p[1] + 6) = v45;
      _os_log_error_impl(&dword_216897000, v7, OS_LOG_TYPE_ERROR, "getSignalStrength: Error in response with code = %s (0x%x)", (uint8_t *)__p, 0x12u);
    }
    if (!*((_BYTE *)v3 + 12) && *((_DWORD *)a2 + 1) != 74)
      (*(void (**)(_QWORD, uint64_t, uint64_t))(**(_QWORD **)(v4 + 88) + 24))(*(_QWORD *)(v4 + 88), 1, 3);
  }
  else
  {
    v8 = *((_DWORD *)v3 + 2);
    v48 = 0;
    v49 = 0;
    parseInputs(a2, &v48);
    if (*(_QWORD *)(v48 + 16))
    {
      v9 = v8 - 1 >= 3 ? 0 : v8;
      v10 = *(_QWORD *)(v4 + 88);
      v46 = v48;
      v47 = v49;
      v48 = 0;
      v49 = 0;
      (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(_QWORD *)v10 + 32))(v10, v9, &v46);
      v11 = v47;
      if (v47)
      {
        p_shared_owners = (unint64_t *)&v47->__shared_owners_;
        do
          v13 = __ldaxr(p_shared_owners);
        while (__stlxr(v13 - 1, p_shared_owners));
        if (!v13)
        {
          ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
          std::__shared_weak_count::__release_weak(v11);
        }
      }
    }
    if (v8 - 1 >= 3)
      v14 = 0;
    else
      v14 = v8;
    TlvValue = (void *)qmi::MessageBase::findTlvValue(a2);
    v17 = TlvValue;
    if (TlvValue)
    {
      v18 = v16;
      __p[0] = TlvValue;
      v19 = tlv::parseV<nas::tlv::LinkQuality>((unint64_t *)__p, v16);
      if (__p[0])
      {
        if (v19 == 1)
          v20 = 100;
        else
          v20 = 50;
        (*(void (**)(_QWORD, uint64_t, uint64_t))(**(_QWORD **)(v4 + 88) + 40))(*(_QWORD *)(v4 + 88), v14, v20);
      }
      else
      {
        ((void (*)(_QWORD, uint64_t, void *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 160, v17, v18);
      }
    }
    v21 = (void *)qmi::MessageBase::findTlvValue(a2);
    v23 = v21;
    if (v21)
    {
      v24 = v22;
      __p[0] = v21;
      v25 = tlv::parseV<nas::tlv::DataLinkQuality>((unint64_t *)__p, v22);
      if (__p[0])
      {
        if (v25 == 100)
          v26 = 100;
        else
          v26 = 50;
        if (v25 == 10)
          v27 = 10;
        else
          v27 = v26;
        (*(void (**)(_QWORD, uint64_t, uint64_t))(**(_QWORD **)(v4 + 88) + 40))(*(_QWORD *)(v4 + 88), v14, v27);
      }
      else
      {
        ((void (*)(_QWORD, uint64_t, void *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 162, v23, v24);
      }
    }
    v28 = (char *)qmi::MessageBase::findTlvValue(a2);
    v30 = v28;
    if (v28)
    {
      v31 = v29;
      v52 = 0;
      v53 = v28;
      v50 = 0;
      v51 = 0;
      tlv::parseV<nas::tlv::EnhancedVoiceLinkQuality>(&v53, v29, &v50);
      v32 = v53;
      if (v53)
      {
        v33 = *(_QWORD *)(v4 + 88);
        memset(__p, 0, 24);
        std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(__p, v50, (uint64_t)v51, v51 - (_BYTE *)v50);
        (*(void (**)(uint64_t, uint64_t, void **))(*(_QWORD *)v33 + 56))(v33, v14, __p);
        if (__p[0])
        {
          __p[1] = __p[0];
          operator delete(__p[0]);
        }
      }
      if (v50)
      {
        v51 = v50;
        operator delete(v50);
      }
      if (v32)
        v34 = 0;
      else
        v34 = ((uint64_t (*)(_QWORD, uint64_t, char *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 164, v30, v31) ^ 1;
    }
    else
    {
      v34 = 1;
    }
    v35 = (void *)qmi::MessageBase::findTlvValue(a2);
    v37 = v35;
    if (v35)
    {
      v38 = v36;
      __p[0] = v35;
      v39 = tlv::parseV<nas::tlv::VoiceLinkQuality>((unint64_t *)__p, v36);
      if (__p[0])
      {
        if (v34)
        {
          v40 = v39;
          if (v39 != 10 && v39 != 100 && v39 != 50)
            v40 = 50;
          (*(void (**)(_QWORD, uint64_t, uint64_t))(**(_QWORD **)(v4 + 88) + 48))(*(_QWORD *)(v4 + 88), v14, v40);
        }
      }
      else
      {
        ((void (*)(_QWORD, uint64_t, void *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a2, 163, v37, v38);
      }
    }
    v41 = v49;
    if (v49)
    {
      v42 = (unint64_t *)&v49->__shared_owners_;
      do
        v43 = __ldaxr(v42);
      while (__stlxr(v43 - 1, v42));
      if (!v43)
      {
        ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
        std::__shared_weak_count::__release_weak(v41);
      }
    }
  }
}

void sub_216A2B3E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18)
{
  if (__p)
  {
    a18 = (uint64_t)__p;
    operator delete(__p);
  }
  if (a13)
  {
    a14 = (uint64_t)a13;
    operator delete(a13);
  }
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_32c117_ZTSNSt3__110shared_ptrIZN32Mav20SignalStrengthCommandDriver22getSignalStrength_syncEN3qmi16SubscriptionTypeEbE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c117_ZTSNSt3__110shared_ptrIZN32Mav20SignalStrengthCommandDriver22getSignalStrength_syncEN3qmi16SubscriptionTypeEbE3__0EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<Mav20SignalStrengthCommandDriver::getSignalStrength_sync(qmi::SubscriptionType,BOOL)::$_0,std::allocator<Mav20SignalStrengthCommandDriver::getSignalStrength_sync(qmi::SubscriptionType,BOOL)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E2008;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<Mav20SignalStrengthCommandDriver::getSignalStrength_sync(qmi::SubscriptionType,BOOL)::$_0,std::allocator<Mav20SignalStrengthCommandDriver::getSignalStrength_sync(qmi::SubscriptionType,BOOL)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E2008;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas10GetSigInfo8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A2B570(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

uint64_t qmi::MutableMessageBase::getTLV<nas::tlv::LinkQualityIndicator>(_QWORD *a1, int a2)
{
  const void **v2;
  const void **v3;
  void *v4;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3)
        return qmi::MutableMessageBase::createTLV<nas::tlv::LinkQualityIndicator>(a1, a2);
    }
  }
  if (v2 == v3)
    return qmi::MutableMessageBase::createTLV<nas::tlv::LinkQualityIndicator>(a1, a2);
  if (!v4)
    __cxa_bad_cast();
  return (uint64_t)v4 + 9;
}

uint64_t qmi::MutableMessageBase::createTLV<nas::tlv::LinkQualityIndicator>(_QWORD *a1, char a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v4 = operator new();
  *(_BYTE *)(v4 + 8) = a2;
  *(_BYTE *)(v4 + 9) = 0;
  *(_QWORD *)v4 = &off_24D5E2098;
  v5 = a1[3];
  v6 = (uint64_t *)a1[2];
  if ((unint64_t)v6 >= v5)
  {
    v8 = a1[1];
    v9 = ((uint64_t)v6 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v5 - v8;
    v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1))
      v11 = v9 + 1;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v12);
    else
      v13 = 0;
    v14 = (uint64_t *)&v13[8 * v9];
    v15 = &v13[8 * v12];
    *v14 = v4;
    v7 = v14 + 1;
    v17 = (char *)a1[1];
    v16 = (char *)a1[2];
    if (v16 != v17)
    {
      do
      {
        v18 = *((_QWORD *)v16 - 1);
        v16 -= 8;
        *--v14 = v18;
      }
      while (v16 != v17);
      v16 = (char *)a1[1];
    }
    a1[1] = v14;
    a1[2] = v7;
    a1[3] = v15;
    if (v16)
      operator delete(v16);
  }
  else
  {
    *v6 = v4;
    v7 = v6 + 1;
  }
  a1[2] = v7;
  return v4 + 9;
}

void qmi::MutableMessageBase::TlvWrapper<nas::tlv::LinkQualityIndicator>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::LinkQualityIndicator>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<nas::tlv::LinkQualityIndicator>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<nas::tlv::LinkQualityIndicator>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E2098;
  return result;
}

void ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN32Mav20SignalStrengthCommandDriver18setThresholds_syncENS_16SubscriptionTypeENSt3__110shared_ptrIK15InputThresholdsEE21SignalStrengthCmdTypeE3__0EEOS1_OT__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;
  NSObject *v7;
  int v8;
  void (*v9)(void);
  uint64_t v10;
  int v11;
  int v12;
  uint64_t v13;
  __int16 v14;
  int v15;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 + 32);
  v4 = *(_QWORD *)v3;
  v5 = *(_DWORD *)(v3 + 8);
  if (v5 - 1 >= 3)
    v6 = 0;
  else
    v6 = v5;
  v7 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v4 + 48) + 16))(*(_QWORD *)(v4 + 48), v6);
  if (!*(_DWORD *)(a2 + 4))
  {
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v12) = 0;
      _os_log_impl(&dword_216897000, v7, OS_LOG_TYPE_DEFAULT, "#I sendNewThresholds: Updated thresholds", (uint8_t *)&v12, 2u);
    }
    v8 = *(_DWORD *)(v3 + 12);
    if (v8 == 1)
    {
      v9 = *(void (**)(void))(**(_QWORD **)(v4 + 88) + 16);
    }
    else
    {
      if (v8)
      {
LABEL_15:
        Mav20SignalStrengthCommandDriver::getSignalStrength_sync(v4, *(_DWORD *)(v3 + 8), 1);
        return;
      }
      v9 = *(void (**)(void))(**(_QWORD **)(v4 + 88) + 16);
    }
    v9();
    goto LABEL_15;
  }
  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    v10 = qmi::asString();
    v11 = *(_DWORD *)(a2 + 4);
    v12 = 136315394;
    v13 = v10;
    v14 = 1024;
    v15 = v11;
    _os_log_error_impl(&dword_216897000, v7, OS_LOG_TYPE_ERROR, "setThresholds: Error in response with code = %s (0x%x)", (uint8_t *)&v12, 0x12u);
  }
  (*(void (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(v4 + 88) + 24))(*(_QWORD *)(v4 + 88), v6, *(unsigned int *)(v3 + 12));
}

uint64_t __copy_helper_block_e8_32c160_ZTSNSt3__110shared_ptrIZN32Mav20SignalStrengthCommandDriver18setThresholds_syncEN3qmi16SubscriptionTypeENS0_IK15InputThresholdsEE21SignalStrengthCmdTypeE3__0EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c160_ZTSNSt3__110shared_ptrIZN32Mav20SignalStrengthCommandDriver18setThresholds_syncEN3qmi16SubscriptionTypeENS0_IK15InputThresholdsEE21SignalStrengthCmdTypeE3__0EE(uint64_t a1)
{
  return std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::__shared_ptr_emplace<Mav20SignalStrengthCommandDriver::setThresholds_sync(qmi::SubscriptionType,std::shared_ptr<InputThresholds const>,SignalStrengthCmdType)::$_0,std::allocator<Mav20SignalStrengthCommandDriver::setThresholds_sync(qmi::SubscriptionType,std::shared_ptr<InputThresholds const>,SignalStrengthCmdType)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E2100;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<Mav20SignalStrengthCommandDriver::setThresholds_sync(qmi::SubscriptionType,std::shared_ptr<InputThresholds const>,SignalStrengthCmdType)::$_0,std::allocator<Mav20SignalStrengthCommandDriver::setThresholds_sync(qmi::SubscriptionType,std::shared_ptr<InputThresholds const>,SignalStrengthCmdType)::$_0>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E2100;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void ___ZNO3qmi6Client9SendProxy8callbackIRKN3nas14ConfigSigInfo28ResponseEEEOS1_U13block_pointerFvT_E_block_invoke(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2;
  _BYTE v4[24];
  void *__p;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    __p = 0;
    v6 = 0;
    v7 = 0;
    QMIServiceMsg::serialize(this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, 0);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
    if (__p)
    {
      v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4);
  }
  (*(void (**)(uint64_t, _BYTE *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_216A2BAC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)&a9);
  _Unwind_Resume(a1);
}

uint64_t VocoderInfo::asString@<X0>(VocoderInfo *this@<X0>, _QWORD *a2@<X8>)
{
  _QWORD *v4;
  unsigned int v5;
  const char *v6;
  size_t v7;
  _QWORD *v8;
  const std::locale::facet *v9;
  _QWORD *v10;
  const std::locale::facet *v11;
  _QWORD *v12;
  const std::locale::facet *v13;
  _QWORD *v14;
  const std::locale::facet *v15;
  _QWORD *v16;
  const std::locale::facet *v17;
  _OWORD v19[4];
  void *__p[2];
  __int128 v21;
  __int128 v22;
  _OWORD v23[9];
  uint64_t v24;
  std::locale v25;

  v24 = 0;
  v22 = 0u;
  memset(v23, 0, sizeof(v23));
  *(_OWORD *)__p = 0u;
  v21 = 0u;
  memset(v19, 0, sizeof(v19));
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v19);
  v4 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)"Vocoder Type: ", 14);
  v5 = *(_DWORD *)this - 1;
  if (v5 > 0x11)
    v6 = "kAudioVocoderQCELP13";
  else
    v6 = off_24D5E2168[v5];
  v7 = strlen(v6);
  v8 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v4, (uint64_t)v6, v7);
  std::ios_base::getloc((const std::ios_base *)((char *)v8 + *(_QWORD *)(*v8 - 24)));
  v9 = std::locale::use_facet(&v25, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v9->__vftable[2].~facet_0)(v9, 10);
  std::locale::~locale(&v25);
  std::ostream::put();
  std::ostream::flush();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)"Sample Rate: ", 13);
  v10 = (_QWORD *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v10 + *(_QWORD *)(*v10 - 24)));
  v11 = std::locale::use_facet(&v25, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v11->__vftable[2].~facet_0)(v11, 10);
  std::locale::~locale(&v25);
  std::ostream::put();
  std::ostream::flush();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)"I2S Clock Rate: ", 16);
  v12 = (_QWORD *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v12 + *(_QWORD *)(*v12 - 24)));
  v13 = std::locale::use_facet(&v25, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v13->__vftable[2].~facet_0)(v13, 10);
  std::locale::~locale(&v25);
  std::ostream::put();
  std::ostream::flush();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)"EVS Downlink Bandwidth: ", 24);
  v14 = (_QWORD *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v14 + *(_QWORD *)(*v14 - 24)));
  v15 = std::locale::use_facet(&v25, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v15->__vftable[2].~facet_0)(v15, 10);
  std::locale::~locale(&v25);
  std::ostream::put();
  std::ostream::flush();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)"EVS Uplink Bandwidth: ", 22);
  v16 = (_QWORD *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v16 + *(_QWORD *)(*v16 - 24)));
  v17 = std::locale::use_facet(&v25, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v17->__vftable[2].~facet_0)(v17, 10);
  std::locale::~locale(&v25);
  std::ostream::put();
  std::ostream::flush();
  std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v19 + 8, a2);
  *(_QWORD *)&v19[0] = *MEMORY[0x24BEDB800];
  *(_QWORD *)((char *)v19 + *(_QWORD *)(*(_QWORD *)&v19[0] - 24)) = *(_QWORD *)(MEMORY[0x24BEDB800] + 24);
  *((_QWORD *)&v19[0] + 1) = MEMORY[0x24BEDB848] + 16;
  if (SHIBYTE(v21) < 0)
    operator delete(__p[1]);
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x2199FEA70](v23);
}

void sub_216A2BE64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9;

  std::locale::~locale((std::locale *)(v9 - 56));
  std::ostringstream::~ostringstream((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t subscriber::simSlotAsSubType(uint64_t result)
{
  if ((result - 1) >= 3)
    return 0;
  else
    return result;
}

uint64_t boost::bimaps::bimap<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::~bimap(uint64_t a1)
{
  uint64_t v2;
  _QWORD *v3;

  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 32);
  if ((v2 & 0xFFFFFFFFFFFFFFFELL) != 0)
    v3 = (_QWORD *)((v2 & 0xFFFFFFFFFFFFFFFELL) - 32);
  else
    v3 = 0;
  boost::multi_index::detail::ordered_index_impl<boost::multi_index::member<boost::bimaps::relation::detail::relation_storage<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,true>,QMI_ProactiveCommand,&boost::bimaps::relation::detail::relation_storage<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,true>::right>,std::less<QMI_ProactiveCommand>,boost::multi_index::detail::nth_layer<1,boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>,boost::mpl::v_item<boost::bimaps::relation::member_at::right,boost::mpl::vector0<mpl_::na>,0>,boost::multi_index::detail::ordered_unique_tag,boost::multi_index::detail::null_augment_policy>::delete_all_nodes(v3);
  operator delete(*(void **)(a1 + 24));
  return a1;
}

unint64_t *initProactiveCommandMap(void)
{
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_253DE9F78 - 16), 1, 1u);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_253DE9F78 - 16), 2, 2u);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_253DE9F78 - 16), 3, 3u);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_253DE9F78 - 16), 4, 4u);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_253DE9F78 - 16), 5, 5u);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_253DE9F78 - 16), 6, 6u);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_253DE9F78 - 16), 7, 7u);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_253DE9F78 - 16), 8, 8u);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_253DE9F78 - 16), 9, 9u);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_253DE9F78 - 16), 10, 0xAu);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_253DE9F78 - 16), 11, 0xBu);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_253DE9F78 - 16), 12, 0xCu);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_253DE9F78 - 16), 13, 0xDu);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_253DE9F78 - 16), 14, 0xEu);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_253DE9F78 - 16), 15, 0xFu);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_253DE9F78 - 16), 16, 0x10u);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_253DE9F78 - 16), 17, 0x11u);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_253DE9F78 - 16), 18, 0x12u);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_253DE9F78 - 16), 19, 0x13u);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_253DE9F78 - 16), 21, 0x14u);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_253DE9F78 - 16), 22, 0x15u);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_253DE9F78 - 16), 23, 0x16u);
  return boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_253DE9F78 - 16), 24, 0x17u);
}

uint64_t getProactiveCommand(unsigned __int8 a1)
{
  unsigned int *v2;
  unsigned __int8 v4;

  pthread_once(&proactiveCommandMapOnce, (void (*)(void))initProactiveCommandMap);
  v4 = a1;
  v2 = (unsigned int *)boost::multi_index::detail::ordered_index_impl<boost::multi_index::member<boost::bimaps::relation::detail::relation_storage<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,true>,QMI_ProactiveCommand,&boost::bimaps::relation::detail::relation_storage<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,true>::right>,std::less<QMI_ProactiveCommand>,boost::multi_index::detail::nth_layer<1,boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>,boost::mpl::v_item<boost::bimaps::relation::member_at::right,boost::mpl::vector0<mpl_::na>,0>,boost::multi_index::detail::ordered_unique_tag,boost::multi_index::detail::null_augment_policy>::find<QMI_ProactiveCommand>(qword_253DE9FA8, &v4);
  if (*(unsigned int **)(qword_253DE9FA8 - 8) == v2)
    __TUAssertTrigger();
  return *v2;
}

uint64_t std::map<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>::~map[abi:ne180100](uint64_t a1)
{
  std::__tree<std::__value_type<AQMThroughputKey,unsigned int>,std::__map_value_compare<AQMThroughputKey,std::__value_type<AQMThroughputKey,unsigned int>,std::less<AQMThroughputKey>,true>,std::allocator<std::__value_type<AQMThroughputKey,unsigned int>>>::destroy(*(_QWORD **)(a1 + 8));
  return a1;
}

uint64_t getQMI_ProactiveCommand_TerminalResponse(int a1)
{
  uint64_t v2;
  uint64_t *v3;
  int v4;
  BOOL v5;
  uint64_t *v6;

  pthread_once(&proactiveCommand_TR_MapOnce, (void (*)(void))initProactiveCommand_TR_Map);
  v2 = qword_253DE9FF8;
  if (!qword_253DE9FF8)
    goto LABEL_11;
  v3 = &qword_253DE9FF8;
  do
  {
    v4 = *(_DWORD *)(v2 + 28);
    v5 = v4 < a1;
    if (v4 >= a1)
      v6 = (uint64_t *)v2;
    else
      v6 = (uint64_t *)(v2 + 8);
    if (!v5)
      v3 = (uint64_t *)v2;
    v2 = *v6;
  }
  while (*v6);
  if (v3 == &qword_253DE9FF8 || *((_DWORD *)v3 + 7) > a1)
  {
LABEL_11:
    __TUAssertTrigger();
    v3 = &qword_253DE9FF8;
  }
  return *((unsigned __int8 *)v3 + 32);
}

uint64_t *initProactiveCommand_TR_Map(void)
{
  std::__tree<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::__map_value_compare<ProactiveCommand,std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::less<ProactiveCommand>,true>,std::allocator<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>>>::__emplace_unique_key_args<ProactiveCommand,ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>((uint64_t *)1, 1, 1);
  std::__tree<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::__map_value_compare<ProactiveCommand,std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::less<ProactiveCommand>,true>,std::allocator<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>>>::__emplace_unique_key_args<ProactiveCommand,ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>((uint64_t *)2, 2, 2);
  std::__tree<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::__map_value_compare<ProactiveCommand,std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::less<ProactiveCommand>,true>,std::allocator<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>>>::__emplace_unique_key_args<ProactiveCommand,ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>((uint64_t *)3, 3, 3);
  std::__tree<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::__map_value_compare<ProactiveCommand,std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::less<ProactiveCommand>,true>,std::allocator<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>>>::__emplace_unique_key_args<ProactiveCommand,ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>((uint64_t *)4, 4, 4);
  std::__tree<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::__map_value_compare<ProactiveCommand,std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::less<ProactiveCommand>,true>,std::allocator<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>>>::__emplace_unique_key_args<ProactiveCommand,ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>((uint64_t *)5, 5, 5);
  std::__tree<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::__map_value_compare<ProactiveCommand,std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::less<ProactiveCommand>,true>,std::allocator<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>>>::__emplace_unique_key_args<ProactiveCommand,ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>((uint64_t *)6, 6, 6);
  std::__tree<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::__map_value_compare<ProactiveCommand,std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::less<ProactiveCommand>,true>,std::allocator<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>>>::__emplace_unique_key_args<ProactiveCommand,ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>((uint64_t *)7, 7, 17);
  std::__tree<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::__map_value_compare<ProactiveCommand,std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::less<ProactiveCommand>,true>,std::allocator<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>>>::__emplace_unique_key_args<ProactiveCommand,ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>((uint64_t *)0xA, 10, 18);
  std::__tree<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::__map_value_compare<ProactiveCommand,std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::less<ProactiveCommand>,true>,std::allocator<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>>>::__emplace_unique_key_args<ProactiveCommand,ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>((uint64_t *)0xB, 11, 18);
  std::__tree<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::__map_value_compare<ProactiveCommand,std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::less<ProactiveCommand>,true>,std::allocator<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>>>::__emplace_unique_key_args<ProactiveCommand,ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>((uint64_t *)0xC, 12, 7);
  std::__tree<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::__map_value_compare<ProactiveCommand,std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::less<ProactiveCommand>,true>,std::allocator<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>>>::__emplace_unique_key_args<ProactiveCommand,ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>((uint64_t *)0xD, 13, 8);
  std::__tree<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::__map_value_compare<ProactiveCommand,std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::less<ProactiveCommand>,true>,std::allocator<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>>>::__emplace_unique_key_args<ProactiveCommand,ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>((uint64_t *)0xE, 14, 9);
  std::__tree<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::__map_value_compare<ProactiveCommand,std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::less<ProactiveCommand>,true>,std::allocator<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>>>::__emplace_unique_key_args<ProactiveCommand,ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>((uint64_t *)0x11, 17, 10);
  std::__tree<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::__map_value_compare<ProactiveCommand,std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::less<ProactiveCommand>,true>,std::allocator<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>>>::__emplace_unique_key_args<ProactiveCommand,ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>((uint64_t *)0x12, 18, 11);
  std::__tree<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::__map_value_compare<ProactiveCommand,std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::less<ProactiveCommand>,true>,std::allocator<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>>>::__emplace_unique_key_args<ProactiveCommand,ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>((uint64_t *)0x13, 19, 12);
  return std::__tree<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::__map_value_compare<ProactiveCommand,std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::less<ProactiveCommand>,true>,std::allocator<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>>>::__emplace_unique_key_args<ProactiveCommand,ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>((uint64_t *)0x10, 16, 13);
}

uint64_t boost::bimaps::bimap<NotificationResponse,tr::Response,mpl_::na,mpl_::na,mpl_::na>::~bimap(uint64_t a1)
{
  uint64_t v2;
  _QWORD *v3;

  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 32);
  if ((v2 & 0xFFFFFFFFFFFFFFFELL) != 0)
    v3 = (_QWORD *)((v2 & 0xFFFFFFFFFFFFFFFELL) - 32);
  else
    v3 = 0;
  boost::multi_index::detail::ordered_index_impl<boost::multi_index::member<boost::bimaps::relation::detail::relation_storage<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,true>,QMI_ProactiveCommand,&boost::bimaps::relation::detail::relation_storage<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,true>::right>,std::less<QMI_ProactiveCommand>,boost::multi_index::detail::nth_layer<1,boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>,boost::mpl::v_item<boost::bimaps::relation::member_at::right,boost::mpl::vector0<mpl_::na>,0>,boost::multi_index::detail::ordered_unique_tag,boost::multi_index::detail::null_augment_policy>::delete_all_nodes(v3);
  operator delete(*(void **)(a1 + 24));
  return a1;
}

uint64_t getQMINotificationResponse(int a1)
{
  _DWORD *v2;
  int v4;

  pthread_once(&notificationResponseMapOnce, (void (*)(void))initNotificationResponseMap);
  v4 = a1;
  v2 = boost::multi_index::detail::ordered_index_impl<boost::multi_index::member<boost::bimaps::relation::detail::relation_storage<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,true>,NotificationResponse,&boost::bimaps::relation::detail::relation_storage<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,true>::left>,std::less<NotificationResponse>,boost::multi_index::detail::nth_layer<2,boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<NotificationResponse,tr::Response,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>,boost::mpl::v_item<boost::bimaps::relation::member_at::left,boost::mpl::vector0<mpl_::na>,0>,boost::multi_index::detail::ordered_unique_tag,boost::multi_index::detail::null_augment_policy>::find<NotificationResponse>(qword_253DE9FE0, &v4);
  if (*(_DWORD **)(qword_253DE9FE0 - 8) == v2)
    __TUAssertTrigger();
  return v2[1];
}

unint64_t *initNotificationResponseMap(void)
{
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<NotificationResponse,tr::Response,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_253DE9FB8 - 16), 0, 0);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<NotificationResponse,tr::Response,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_253DE9FB8 - 16), 1, 4);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<NotificationResponse,tr::Response,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_253DE9FB8 - 16), 2, 16);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<NotificationResponse,tr::Response,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_253DE9FB8 - 16), 3, 17);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<NotificationResponse,tr::Response,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_253DE9FB8 - 16), 4, 18);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<NotificationResponse,tr::Response,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_253DE9FB8 - 16), 5, 19);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<NotificationResponse,tr::Response,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_253DE9FB8 - 16), 6, 32);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<NotificationResponse,tr::Response,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_253DE9FB8 - 16), 7, 33);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<NotificationResponse,tr::Response,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_253DE9FB8 - 16), 8, 34);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<NotificationResponse,tr::Response,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_253DE9FB8 - 16), 9, 48);
  return boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<NotificationResponse,tr::Response,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_253DE9FB8 - 16), 10, 53);
}

uint64_t boost::bimaps::bimap<NotificationAdditionalResponse,tr::AdditionalResponse,mpl_::na,mpl_::na,mpl_::na>::~bimap(uint64_t a1)
{
  uint64_t v2;
  _QWORD *v3;

  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 32);
  if ((v2 & 0xFFFFFFFFFFFFFFFELL) != 0)
    v3 = (_QWORD *)((v2 & 0xFFFFFFFFFFFFFFFELL) - 32);
  else
    v3 = 0;
  boost::multi_index::detail::ordered_index_impl<boost::multi_index::member<boost::bimaps::relation::detail::relation_storage<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,true>,QMI_ProactiveCommand,&boost::bimaps::relation::detail::relation_storage<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,true>::right>,std::less<QMI_ProactiveCommand>,boost::multi_index::detail::nth_layer<1,boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>,boost::mpl::v_item<boost::bimaps::relation::member_at::right,boost::mpl::vector0<mpl_::na>,0>,boost::multi_index::detail::ordered_unique_tag,boost::multi_index::detail::null_augment_policy>::delete_all_nodes(v3);
  operator delete(*(void **)(a1 + 24));
  return a1;
}

uint64_t getQMINotificationAdditionalResponse(int a1)
{
  _DWORD *v2;
  int v4;

  pthread_once(&notificationAdditionalResponseMapOnce, (void (*)(void))initNotificationAdditionalResponseMap);
  v4 = a1;
  v2 = boost::multi_index::detail::ordered_index_impl<boost::multi_index::member<boost::bimaps::relation::detail::relation_storage<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,true>,NotificationResponse,&boost::bimaps::relation::detail::relation_storage<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,true>::left>,std::less<NotificationResponse>,boost::multi_index::detail::nth_layer<2,boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<NotificationResponse,tr::Response,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>,boost::mpl::v_item<boost::bimaps::relation::member_at::left,boost::mpl::vector0<mpl_::na>,0>,boost::multi_index::detail::ordered_unique_tag,boost::multi_index::detail::null_augment_policy>::find<NotificationResponse>(qword_253DEA038, &v4);
  if (*(_DWORD **)(qword_253DEA038 - 8) == v2)
    __TUAssertTrigger();
  return v2[1];
}

unint64_t *initNotificationAdditionalResponseMap(void)
{
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<NotificationResponse,tr::Response,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_253DEA010 - 16), 0, 0);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<NotificationResponse,tr::Response,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_253DEA010 - 16), 1, 1);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<NotificationResponse,tr::Response,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_253DEA010 - 16), 2, 2);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<NotificationResponse,tr::Response,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_253DEA010 - 16), 3, 4);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<NotificationResponse,tr::Response,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_253DEA010 - 16), 4, 5);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<NotificationResponse,tr::Response,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_253DEA010 - 16), 5, 6);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<NotificationResponse,tr::Response,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_253DEA010 - 16), 6, 7);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<NotificationResponse,tr::Response,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_253DEA010 - 16), 7, 9);
  return boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<NotificationResponse,tr::Response,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_253DEA010 - 16), 8, 10);
}

uint64_t boost::bimaps::bimap<DataCodingScheme,QMI_DataCodingScheme,mpl_::na,mpl_::na,mpl_::na>::~bimap(uint64_t a1)
{
  uint64_t v2;
  _QWORD *v3;

  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 32);
  if ((v2 & 0xFFFFFFFFFFFFFFFELL) != 0)
    v3 = (_QWORD *)((v2 & 0xFFFFFFFFFFFFFFFELL) - 32);
  else
    v3 = 0;
  boost::multi_index::detail::ordered_index_impl<boost::multi_index::member<boost::bimaps::relation::detail::relation_storage<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,true>,QMI_ProactiveCommand,&boost::bimaps::relation::detail::relation_storage<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,true>::right>,std::less<QMI_ProactiveCommand>,boost::multi_index::detail::nth_layer<1,boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>,boost::mpl::v_item<boost::bimaps::relation::member_at::right,boost::mpl::vector0<mpl_::na>,0>,boost::multi_index::detail::ordered_unique_tag,boost::multi_index::detail::null_augment_policy>::delete_all_nodes(v3);
  operator delete(*(void **)(a1 + 24));
  return a1;
}

uint64_t getQMIDataCodingScheme(unsigned __int8 a1)
{
  unsigned __int8 *v2;
  unsigned __int8 v4;

  pthread_once(&dataCodingSchemeMapOnce, (void (*)(void))initDataCodingSchemeMap);
  v4 = a1;
  v2 = boost::multi_index::detail::ordered_index_impl<boost::multi_index::member<boost::bimaps::relation::detail::relation_storage<boost::bimaps::tags::tagged<DataCodingScheme const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_DataCodingScheme const,boost::bimaps::relation::member_at::right>,true>,DataCodingScheme,&boost::bimaps::relation::detail::relation_storage<boost::bimaps::tags::tagged<DataCodingScheme const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_DataCodingScheme const,boost::bimaps::relation::member_at::right>,true>::left>,std::less<DataCodingScheme>,boost::multi_index::detail::nth_layer<2,boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<DataCodingScheme const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_DataCodingScheme const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<DataCodingScheme,QMI_DataCodingScheme,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<DataCodingScheme const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_DataCodingScheme const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>,boost::mpl::v_item<boost::bimaps::relation::member_at::left,boost::mpl::vector0<mpl_::na>,0>,boost::multi_index::detail::ordered_unique_tag,boost::multi_index::detail::null_augment_policy>::find<DataCodingScheme>(qword_253DE9F60, &v4);
  if (*(unsigned __int8 **)(qword_253DE9F60 - 8) == v2)
    __TUAssertTrigger();
  return v2[1];
}

unint64_t *initDataCodingSchemeMap(void)
{
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<DataCodingScheme const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_DataCodingScheme const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<DataCodingScheme,QMI_DataCodingScheme,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<DataCodingScheme const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_DataCodingScheme const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_253DE9F38 - 16), 1u, 0);
  boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<DataCodingScheme const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_DataCodingScheme const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<DataCodingScheme,QMI_DataCodingScheme,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<DataCodingScheme const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_DataCodingScheme const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_253DE9F38 - 16), 2u, 1u);
  return boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<DataCodingScheme const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_DataCodingScheme const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<DataCodingScheme,QMI_DataCodingScheme,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<DataCodingScheme const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_DataCodingScheme const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>((unint64_t *)(qword_253DE9F38 - 16), 3u, 2u);
}

uint64_t getDataCodingScheme(unsigned __int8 a1)
{
  unsigned __int8 *v2;
  unsigned __int8 v4;

  pthread_once(&dataCodingSchemeMapOnce, (void (*)(void))initDataCodingSchemeMap);
  v4 = a1;
  v2 = (unsigned __int8 *)boost::multi_index::detail::ordered_index_impl<boost::multi_index::member<boost::bimaps::relation::detail::relation_storage<boost::bimaps::tags::tagged<DataCodingScheme const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_DataCodingScheme const,boost::bimaps::relation::member_at::right>,true>,QMI_DataCodingScheme,&boost::bimaps::relation::detail::relation_storage<boost::bimaps::tags::tagged<DataCodingScheme const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_DataCodingScheme const,boost::bimaps::relation::member_at::right>,true>::right>,std::less<QMI_DataCodingScheme>,boost::multi_index::detail::nth_layer<1,boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<DataCodingScheme const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_DataCodingScheme const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<DataCodingScheme,QMI_DataCodingScheme,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<DataCodingScheme const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_DataCodingScheme const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>,boost::mpl::v_item<boost::bimaps::relation::member_at::right,boost::mpl::vector0<mpl_::na>,0>,boost::multi_index::detail::ordered_unique_tag,boost::multi_index::detail::null_augment_policy>::find<QMI_DataCodingScheme>(qword_253DE9F68, &v4);
  if (*(unsigned __int8 **)(qword_253DE9F68 - 8) == v2)
    __TUAssertTrigger();
  return *v2;
}

void boost::multi_index::detail::ordered_index_impl<boost::multi_index::member<boost::bimaps::relation::detail::relation_storage<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,true>,QMI_ProactiveCommand,&boost::bimaps::relation::detail::relation_storage<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,true>::right>,std::less<QMI_ProactiveCommand>,boost::multi_index::detail::nth_layer<1,boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>,boost::mpl::v_item<boost::bimaps::relation::member_at::right,boost::mpl::vector0<mpl_::na>,0>,boost::multi_index::detail::ordered_unique_tag,boost::multi_index::detail::null_augment_policy>::delete_all_nodes(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  if (a1)
  {
    v2 = a1[5];
    if (v2)
      v3 = v2 - 32;
    else
      v3 = 0;
    boost::multi_index::detail::ordered_index_impl<boost::multi_index::member<boost::bimaps::relation::detail::relation_storage<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,true>,QMI_ProactiveCommand,&boost::bimaps::relation::detail::relation_storage<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,true>::right>,std::less<QMI_ProactiveCommand>,boost::multi_index::detail::nth_layer<1,boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>,boost::mpl::v_item<boost::bimaps::relation::member_at::right,boost::mpl::vector0<mpl_::na>,0>,boost::multi_index::detail::ordered_unique_tag,boost::multi_index::detail::null_augment_policy>::delete_all_nodes(v3);
    v4 = a1[6];
    if (v4)
      v5 = v4 - 32;
    else
      v5 = 0;
    boost::multi_index::detail::ordered_index_impl<boost::multi_index::member<boost::bimaps::relation::detail::relation_storage<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,true>,QMI_ProactiveCommand,&boost::bimaps::relation::detail::relation_storage<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,true>::right>,std::less<QMI_ProactiveCommand>,boost::multi_index::detail::nth_layer<1,boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>,boost::mpl::v_item<boost::bimaps::relation::member_at::right,boost::mpl::vector0<mpl_::na>,0>,boost::multi_index::detail::ordered_unique_tag,boost::multi_index::detail::null_augment_policy>::delete_all_nodes(v5);
    operator delete(a1);
  }
}

unint64_t *boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>(unint64_t *result, int a2, unsigned __int8 a3)
{
  unint64_t *v4;
  unsigned int v5;
  _QWORD *v6;
  _QWORD *v7;
  unint64_t v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  unint64_t *v13;
  int v14;
  _QWORD *v15;
  unint64_t *v16;
  _QWORD *v17;
  unint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  unint64_t *v23;
  int v24;
  void *v25;
  _QWORD *v26;

  v4 = result;
  v5 = a3;
  v6 = (_QWORD *)result[1];
  v7 = v6;
  v8 = v6[4] & 0xFFFFFFFFFFFFFFFELL;
  if (!v8)
    goto LABEL_7;
  do
  {
    v7 = (_QWORD *)(v8 - 32);
    v9 = *(unsigned __int8 *)(v8 - 28);
    if (v9 <= a3)
      v10 = 6;
    else
      v10 = 5;
    v8 = v7[v10];
  }
  while (v8);
  if (v9 <= a3)
  {
    v14 = 1;
    v15 = v7;
  }
  else
  {
LABEL_7:
    v11 = v6[5];
    if (v11)
      v12 = (_QWORD *)(v11 - 32);
    else
      v12 = 0;
    v13 = v7 + 4;
    if (v7 == v12)
    {
      v14 = 0;
      goto LABEL_18;
    }
    v26 = v7 + 4;
    result = boost::multi_index::detail::ordered_index_node_impl<boost::multi_index::detail::null_augment_policy,std::allocator<char>>::decrement((unint64_t *)&v26);
    v14 = 0;
    if (v26)
      v15 = v26 - 4;
    else
      v15 = 0;
  }
  if (*((unsigned __int8 *)v15 + 4) >= v5)
    return result;
  v13 = v7 + 4;
LABEL_18:
  v16 = v6 + 1;
  v17 = v6;
  v18 = v6[1] & 0xFFFFFFFFFFFFFFFELL;
  if (!v18)
    goto LABEL_24;
  do
  {
    v17 = (_QWORD *)(v18 - 8);
    v19 = *(_DWORD *)(v18 - 8);
    if (v19 <= a2)
      v20 = 3;
    else
      v20 = 2;
    v18 = v17[v20];
  }
  while (v18);
  if (v19 <= a2)
  {
    v24 = 1;
  }
  else
  {
LABEL_24:
    v21 = v6[2];
    if (v21)
      v22 = (_QWORD *)(v21 - 8);
    else
      v22 = 0;
    v23 = v17 + 1;
    if (v17 == v22)
    {
      v24 = 0;
      goto LABEL_33;
    }
    v26 = v17 + 1;
    result = boost::multi_index::detail::ordered_index_node_impl<boost::multi_index::detail::null_augment_policy,std::allocator<char>>::decrement((unint64_t *)&v26);
    v24 = 0;
    v19 = *((_DWORD *)v26 - 2);
  }
  if (v19 >= a2)
    return result;
  v23 = v17 + 1;
LABEL_33:
  v25 = operator new(0x38uLL);
  *(_DWORD *)v25 = a2;
  *((_BYTE *)v25 + 4) = v5;
  boost::multi_index::detail::ordered_index_node_impl<boost::multi_index::detail::null_augment_policy,std::allocator<char>>::link((unint64_t *)v25 + 1, v24, v23, v16);
  result = boost::multi_index::detail::ordered_index_node_impl<boost::multi_index::detail::null_augment_policy,std::allocator<char>>::link((unint64_t *)v25 + 4, v14, v13, (unint64_t *)(v4[1] + 32));
  ++v4[3];
  return result;
}

unint64_t *boost::multi_index::detail::ordered_index_node_impl<boost::multi_index::detail::null_augment_policy,std::allocator<char>>::link(unint64_t *result, int a2, unint64_t *a3, unint64_t *a4)
{
  unint64_t *v5;
  _QWORD *v6;
  unint64_t *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  _QWORD *v11;
  unint64_t *v12;
  unint64_t *v13;
  unint64_t *v14;
  unint64_t *v15;
  unint64_t *v16;
  unint64_t *v17;
  unint64_t *v18;
  unint64_t *v19;

  v5 = result;
  if (a2)
  {
    a3[2] = (unint64_t)result;
    v6 = a4 + 2;
    v7 = (unint64_t *)a4[2];
    goto LABEL_5;
  }
  a3[1] = (unint64_t)result;
  if (a3 != a4)
  {
    v6 = a4 + 1;
    v7 = (unint64_t *)a4[1];
LABEL_5:
    if (v7 != a3)
      goto LABEL_9;
    goto LABEL_8;
  }
  *a3 = *a3 & 1 | (unint64_t)result;
  v6 = a3 + 2;
LABEL_8:
  *v6 = result;
LABEL_9:
  result[1] = 0;
  result[2] = 0;
  v8 = (unint64_t)a3 & 0xFFFFFFFFFFFFFFFELL;
  *result = (unint64_t)a3 & 0xFFFFFFFFFFFFFFFELL;
  v9 = *a4 & 0xFFFFFFFFFFFFFFFELL;
  if ((unint64_t *)v9 == result)
    goto LABEL_29;
  while (1)
  {
    v10 = *(_QWORD *)v8;
    if ((*(_QWORD *)v8 & 1) != 0)
      break;
    v11 = *(_QWORD **)((v10 & 0xFFFFFFFFFFFFFFFELL) + 8);
    if (v11 == (_QWORD *)v8)
    {
      v11 = *(_QWORD **)((v10 & 0xFFFFFFFFFFFFFFFELL) + 16);
      if (v11 && (*(_BYTE *)v11 & 1) == 0)
      {
LABEL_18:
        *(_QWORD *)v8 = v10 | 1;
        *v11 |= 1uLL;
        *(_QWORD *)(*(_QWORD *)(*v5 & 0xFFFFFFFFFFFFFFFELL) & 0xFFFFFFFFFFFFFFFELL) &= ~1uLL;
        v5 = (unint64_t *)(*(_QWORD *)(*v5 & 0xFFFFFFFFFFFFFFFELL) & 0xFFFFFFFFFFFFFFFELL);
        goto LABEL_25;
      }
      if (v5 == *(unint64_t **)(v8 + 16))
      {
        v19 = a4;
        boost::multi_index::detail::ordered_index_node_impl<boost::multi_index::detail::null_augment_policy,std::allocator<char>>::rotate_left((unint64_t *)v8, &v19);
        v13 = (unint64_t *)(*(_QWORD *)v8 & 0xFFFFFFFFFFFFFFFELL);
        v10 = *v13;
        v5 = (unint64_t *)v8;
      }
      else
      {
        v13 = (unint64_t *)v8;
        v8 = (unint64_t)v5;
      }
      *v13 = v10 | 1;
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v8 & 0xFFFFFFFFFFFFFFFELL) & 0xFFFFFFFFFFFFFFFELL) &= ~1uLL;
      v15 = (unint64_t *)(*(_QWORD *)(*(_QWORD *)v8 & 0xFFFFFFFFFFFFFFFELL) & 0xFFFFFFFFFFFFFFFELL);
      v18 = a4;
      result = boost::multi_index::detail::ordered_index_node_impl<boost::multi_index::detail::null_augment_policy,std::allocator<char>>::rotate_right(v15, &v18);
    }
    else
    {
      if (v11 && (*(_BYTE *)v11 & 1) == 0)
        goto LABEL_18;
      if (v5 == *(unint64_t **)(v8 + 8))
      {
        v17 = a4;
        boost::multi_index::detail::ordered_index_node_impl<boost::multi_index::detail::null_augment_policy,std::allocator<char>>::rotate_right((unint64_t *)v8, &v17);
        v12 = (unint64_t *)(*(_QWORD *)v8 & 0xFFFFFFFFFFFFFFFELL);
        v10 = *v12;
        v5 = (unint64_t *)v8;
      }
      else
      {
        v12 = (unint64_t *)v8;
        v8 = (unint64_t)v5;
      }
      *v12 = v10 | 1;
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v8 & 0xFFFFFFFFFFFFFFFELL) & 0xFFFFFFFFFFFFFFFELL) &= ~1uLL;
      v14 = (unint64_t *)(*(_QWORD *)(*(_QWORD *)v8 & 0xFFFFFFFFFFFFFFFELL) & 0xFFFFFFFFFFFFFFFELL);
      v16 = a4;
      result = boost::multi_index::detail::ordered_index_node_impl<boost::multi_index::detail::null_augment_policy,std::allocator<char>>::rotate_left(v14, &v16);
    }
LABEL_25:
    v9 = *a4 & 0xFFFFFFFFFFFFFFFELL;
    if (v5 == (unint64_t *)v9)
      goto LABEL_28;
    v8 = *v5 & 0xFFFFFFFFFFFFFFFELL;
  }
  v5 = (unint64_t *)v9;
LABEL_28:
  v8 = *v5;
LABEL_29:
  *v5 = v8 | 1;
  return result;
}

unint64_t *boost::multi_index::detail::ordered_index_node_impl<boost::multi_index::detail::null_augment_policy,std::allocator<char>>::decrement(unint64_t *result)
{
  _QWORD *v1;
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  BOOL v6;

  v1 = (_QWORD *)*result;
  v2 = *(_QWORD *)*result;
  if ((v2 & 1) == 0 && v1 == (_QWORD *)(*(_QWORD *)(v2 & 0xFFFFFFFFFFFFFFFELL) & 0xFFFFFFFFFFFFFFFELL))
  {
    v4 = v1[2];
  }
  else
  {
    v3 = v1[1];
    if (v3)
    {
      do
      {
        v4 = v3;
        v3 = *(_QWORD *)(v3 + 16);
      }
      while (v3);
    }
    else
    {
      v4 = v2 & 0xFFFFFFFFFFFFFFFELL;
      if (v1 == *(_QWORD **)(v4 + 8))
      {
        v5 = (_QWORD *)v4;
        do
        {
          *result = (unint64_t)v5;
          v4 = *v5 & 0xFFFFFFFFFFFFFFFELL;
          v6 = v5 == *(_QWORD **)(v4 + 8);
          v5 = (_QWORD *)v4;
        }
        while (v6);
      }
    }
  }
  *result = v4;
  return result;
}

unint64_t *boost::multi_index::detail::ordered_index_node_impl<boost::multi_index::detail::null_augment_policy,std::allocator<char>>::rotate_left(unint64_t *result, unint64_t **a2)
{
  unint64_t v2;
  unint64_t *v3;
  uint64_t v4;
  unint64_t v5;

  v2 = result[2];
  result[2] = *(_QWORD *)(v2 + 8);
  v3 = *(unint64_t **)(v2 + 8);
  if (v3)
    *v3 = *v3 & 1 | (unint64_t)result;
  *(_QWORD *)v2 = *result & 0xFFFFFFFFFFFFFFFELL | *(_QWORD *)v2 & 1;
  if ((unint64_t *)(**a2 & 0xFFFFFFFFFFFFFFFELL) == result)
  {
    **a2 = **a2 & 1 | v2;
    v4 = *result;
  }
  else
  {
    v4 = *result;
    v5 = *result & 0xFFFFFFFFFFFFFFFELL;
    if (*(unint64_t **)(v5 + 8) == result)
      *(_QWORD *)(v5 + 8) = v2;
    else
      *(_QWORD *)(v5 + 16) = v2;
  }
  *(_QWORD *)(v2 + 8) = result;
  *result = v4 & 1 | v2;
  return result;
}

unint64_t *boost::multi_index::detail::ordered_index_node_impl<boost::multi_index::detail::null_augment_policy,std::allocator<char>>::rotate_right(unint64_t *result, unint64_t **a2)
{
  unint64_t v2;
  unint64_t *v3;
  uint64_t v4;
  unint64_t v5;

  v2 = result[1];
  result[1] = *(_QWORD *)(v2 + 16);
  v3 = *(unint64_t **)(v2 + 16);
  if (v3)
    *v3 = *v3 & 1 | (unint64_t)result;
  *(_QWORD *)v2 = *result & 0xFFFFFFFFFFFFFFFELL | *(_QWORD *)v2 & 1;
  if ((unint64_t *)(**a2 & 0xFFFFFFFFFFFFFFFELL) == result)
  {
    **a2 = **a2 & 1 | v2;
    v4 = *result;
  }
  else
  {
    v4 = *result;
    v5 = *result & 0xFFFFFFFFFFFFFFFELL;
    if (*(unint64_t **)(v5 + 16) == result)
      *(_QWORD *)(v5 + 16) = v2;
    else
      *(_QWORD *)(v5 + 8) = v2;
  }
  *(_QWORD *)(v2 + 16) = result;
  *result = v4 & 1 | v2;
  return result;
}

uint64_t *std::__tree<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::__map_value_compare<ProactiveCommand,std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>,std::less<ProactiveCommand>,true>,std::allocator<std::__value_type<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>>>::__emplace_unique_key_args<ProactiveCommand,ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>(uint64_t *result, int a2, char a3)
{
  uint64_t v5;
  uint64_t *v6;
  int v7;
  uint64_t *v8;
  _DWORD *v9;
  uint64_t *v10;

  v5 = qword_253DE9FF8;
  if (qword_253DE9FF8)
  {
    while (1)
    {
      while (1)
      {
        v6 = (uint64_t *)v5;
        v7 = *(_DWORD *)(v5 + 28);
        if (v7 <= (int)result)
          break;
        v5 = *v6;
        v8 = v6;
        if (!*v6)
          goto LABEL_9;
      }
      if (v7 >= (int)result)
        break;
      v5 = v6[1];
      if (!v5)
      {
        v8 = v6 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    v8 = &qword_253DE9FF8;
    v6 = &qword_253DE9FF8;
LABEL_9:
    v9 = operator new(0x28uLL);
    v9[7] = a2;
    *((_BYTE *)v9 + 32) = a3;
    *(_QWORD *)v9 = 0;
    *((_QWORD *)v9 + 1) = 0;
    *((_QWORD *)v9 + 2) = v6;
    *v8 = (uint64_t)v9;
    if (*(_QWORD *)sProactiveCommand_TR_Map)
    {
      sProactiveCommand_TR_Map = *(_QWORD *)sProactiveCommand_TR_Map;
      v10 = (uint64_t *)*v8;
    }
    else
    {
      v10 = (uint64_t *)v9;
    }
    result = std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>((uint64_t *)qword_253DE9FF8, v10);
    ++qword_253DEA000;
  }
  return result;
}

unint64_t *boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<NotificationResponse,tr::Response,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>(unint64_t *result, int a2, int a3)
{
  unint64_t *v5;
  _QWORD *v6;
  _QWORD *v7;
  unint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  unint64_t *v13;
  int v14;
  _QWORD *v15;
  unint64_t *v16;
  _QWORD *v17;
  unint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  unint64_t *v23;
  int v24;
  void *v25;
  _QWORD *v26;

  v5 = result;
  v6 = (_QWORD *)result[1];
  v7 = v6;
  v8 = v6[4] & 0xFFFFFFFFFFFFFFFELL;
  if (!v8)
    goto LABEL_7;
  do
  {
    v7 = (_QWORD *)(v8 - 32);
    v9 = *(_DWORD *)(v8 - 28);
    if (v9 <= a3)
      v10 = 6;
    else
      v10 = 5;
    v8 = v7[v10];
  }
  while (v8);
  if (v9 <= a3)
  {
    v14 = 1;
    v15 = v7;
  }
  else
  {
LABEL_7:
    v11 = v6[5];
    if (v11)
      v12 = (_QWORD *)(v11 - 32);
    else
      v12 = 0;
    v13 = v7 + 4;
    if (v7 == v12)
    {
      v14 = 0;
      goto LABEL_18;
    }
    v26 = v7 + 4;
    result = boost::multi_index::detail::ordered_index_node_impl<boost::multi_index::detail::null_augment_policy,std::allocator<char>>::decrement((unint64_t *)&v26);
    v14 = 0;
    if (v26)
      v15 = v26 - 4;
    else
      v15 = 0;
  }
  if (*((_DWORD *)v15 + 1) >= a3)
    return result;
  v13 = v7 + 4;
LABEL_18:
  v16 = v6 + 1;
  v17 = v6;
  v18 = v6[1] & 0xFFFFFFFFFFFFFFFELL;
  if (!v18)
    goto LABEL_24;
  do
  {
    v17 = (_QWORD *)(v18 - 8);
    v19 = *(_DWORD *)(v18 - 8);
    if (v19 <= a2)
      v20 = 3;
    else
      v20 = 2;
    v18 = v17[v20];
  }
  while (v18);
  if (v19 <= a2)
  {
    v24 = 1;
  }
  else
  {
LABEL_24:
    v21 = v6[2];
    if (v21)
      v22 = (_QWORD *)(v21 - 8);
    else
      v22 = 0;
    v23 = v17 + 1;
    if (v17 == v22)
    {
      v24 = 0;
      goto LABEL_33;
    }
    v26 = v17 + 1;
    result = boost::multi_index::detail::ordered_index_node_impl<boost::multi_index::detail::null_augment_policy,std::allocator<char>>::decrement((unint64_t *)&v26);
    v24 = 0;
    v19 = *((_DWORD *)v26 - 2);
  }
  if (v19 >= a2)
    return result;
  v23 = v17 + 1;
LABEL_33:
  v25 = operator new(0x38uLL);
  *(_DWORD *)v25 = a2;
  *((_DWORD *)v25 + 1) = a3;
  boost::multi_index::detail::ordered_index_node_impl<boost::multi_index::detail::null_augment_policy,std::allocator<char>>::link((unint64_t *)v25 + 1, v24, v23, v16);
  result = boost::multi_index::detail::ordered_index_node_impl<boost::multi_index::detail::null_augment_policy,std::allocator<char>>::link((unint64_t *)v25 + 4, v14, v13, (unint64_t *)(v5[1] + 32));
  ++v5[3];
  return result;
}

unint64_t *boost::multi_index::multi_index_container<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<DataCodingScheme const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_DataCodingScheme const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<DataCodingScheme,QMI_DataCodingScheme,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<DataCodingScheme const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_DataCodingScheme const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>::insert_<boost::multi_index::detail::lvalue_tag>(unint64_t *result, unsigned __int8 a2, unsigned __int8 a3)
{
  unint64_t *v4;
  unsigned int v5;
  _QWORD *v6;
  _QWORD *v7;
  unint64_t v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  unint64_t *v13;
  int v14;
  _QWORD *v15;
  unsigned int v16;
  unint64_t *v17;
  _QWORD *v18;
  unint64_t v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD *v23;
  unint64_t *v24;
  int v25;
  void *v26;
  _QWORD *v27;

  v4 = result;
  v5 = a3;
  v6 = (_QWORD *)result[1];
  v7 = v6;
  v8 = v6[4] & 0xFFFFFFFFFFFFFFFELL;
  if (!v8)
    goto LABEL_7;
  do
  {
    v7 = (_QWORD *)(v8 - 32);
    v9 = *(unsigned __int8 *)(v8 - 31);
    if (v9 <= a3)
      v10 = 6;
    else
      v10 = 5;
    v8 = v7[v10];
  }
  while (v8);
  if (v9 <= a3)
  {
    v14 = 1;
    v15 = v7;
  }
  else
  {
LABEL_7:
    v11 = v6[5];
    if (v11)
      v12 = (_QWORD *)(v11 - 32);
    else
      v12 = 0;
    v13 = v7 + 4;
    if (v7 == v12)
    {
      v14 = 0;
      goto LABEL_18;
    }
    v27 = v7 + 4;
    result = boost::multi_index::detail::ordered_index_node_impl<boost::multi_index::detail::null_augment_policy,std::allocator<char>>::decrement((unint64_t *)&v27);
    v14 = 0;
    if (v27)
      v15 = v27 - 4;
    else
      v15 = 0;
  }
  if (*((unsigned __int8 *)v15 + 1) >= v5)
    return result;
  v13 = v7 + 4;
LABEL_18:
  v16 = a2;
  v17 = v6 + 1;
  v18 = v6;
  v19 = v6[1] & 0xFFFFFFFFFFFFFFFELL;
  if (!v19)
    goto LABEL_24;
  do
  {
    v18 = (_QWORD *)(v19 - 8);
    v20 = *(unsigned __int8 *)(v19 - 8);
    if (v20 <= v16)
      v21 = 3;
    else
      v21 = 2;
    v19 = v18[v21];
  }
  while (v19);
  if (v20 <= v16)
  {
    v25 = 1;
  }
  else
  {
LABEL_24:
    v22 = v6[2];
    if (v22)
      v23 = (_QWORD *)(v22 - 8);
    else
      v23 = 0;
    v24 = v18 + 1;
    if (v18 == v23)
    {
      v25 = 0;
      goto LABEL_33;
    }
    v27 = v18 + 1;
    result = boost::multi_index::detail::ordered_index_node_impl<boost::multi_index::detail::null_augment_policy,std::allocator<char>>::decrement((unint64_t *)&v27);
    v25 = 0;
    v20 = *((unsigned __int8 *)v27 - 8);
  }
  if (v20 >= v16)
    return result;
  v24 = v18 + 1;
LABEL_33:
  v26 = operator new(0x38uLL);
  *(_BYTE *)v26 = v16;
  *((_BYTE *)v26 + 1) = v5;
  boost::multi_index::detail::ordered_index_node_impl<boost::multi_index::detail::null_augment_policy,std::allocator<char>>::link((unint64_t *)v26 + 1, v25, v24, v17);
  result = boost::multi_index::detail::ordered_index_node_impl<boost::multi_index::detail::null_augment_policy,std::allocator<char>>::link((unint64_t *)v26 + 4, v14, v13, (unint64_t *)(v4[1] + 32));
  ++v4[3];
  return result;
}

unint64_t boost::multi_index::detail::ordered_index_impl<boost::multi_index::member<boost::bimaps::relation::detail::relation_storage<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,true>,QMI_ProactiveCommand,&boost::bimaps::relation::detail::relation_storage<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,true>::right>,std::less<QMI_ProactiveCommand>,boost::multi_index::detail::nth_layer<1,boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<ProactiveCommand const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_ProactiveCommand const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>,boost::mpl::v_item<boost::bimaps::relation::member_at::right,boost::mpl::vector0<mpl_::na>,0>,boost::multi_index::detail::ordered_unique_tag,boost::multi_index::detail::null_augment_policy>::find<QMI_ProactiveCommand>(uint64_t a1, unsigned __int8 *a2)
{
  unint64_t result;
  unint64_t v3;
  unsigned int v4;
  unint64_t v5;

  result = *(_QWORD *)(a1 - 8);
  v3 = *(_QWORD *)(result + 32) & 0xFFFFFFFFFFFFFFFELL;
  if (v3)
  {
    v4 = *a2;
    v5 = result;
    do
    {
      while (*(unsigned __int8 *)(v3 - 28) < v4)
      {
        v3 = *(_QWORD *)(v3 + 16);
        if (!v3)
          goto LABEL_7;
      }
      v5 = v3 - 32;
      v3 = *(_QWORD *)(v3 + 8);
    }
    while (v3);
LABEL_7:
    if (v5 != result && v4 >= *(unsigned __int8 *)(v5 + 4))
      return v5;
  }
  return result;
}

_DWORD *boost::multi_index::detail::ordered_index_impl<boost::multi_index::member<boost::bimaps::relation::detail::relation_storage<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,true>,NotificationResponse,&boost::bimaps::relation::detail::relation_storage<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,true>::left>,std::less<NotificationResponse>,boost::multi_index::detail::nth_layer<2,boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<NotificationResponse,tr::Response,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<NotificationResponse const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<tr::Response const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>,boost::mpl::v_item<boost::bimaps::relation::member_at::left,boost::mpl::vector0<mpl_::na>,0>,boost::multi_index::detail::ordered_unique_tag,boost::multi_index::detail::null_augment_policy>::find<NotificationResponse>(uint64_t a1, int *a2)
{
  _DWORD *result;
  unint64_t v3;
  int v4;
  _DWORD *v5;

  result = *(_DWORD **)(a1 - 8);
  v3 = *((_QWORD *)result + 1) & 0xFFFFFFFFFFFFFFFELL;
  if (v3)
  {
    v4 = *a2;
    v5 = result;
    do
    {
      while (*(_DWORD *)(v3 - 8) < v4)
      {
        v3 = *(_QWORD *)(v3 + 16);
        if (!v3)
          goto LABEL_7;
      }
      v5 = (_DWORD *)(v3 - 8);
      v3 = *(_QWORD *)(v3 + 8);
    }
    while (v3);
LABEL_7:
    if (v5 != result && v4 >= *v5)
      return v5;
  }
  return result;
}

unsigned __int8 *boost::multi_index::detail::ordered_index_impl<boost::multi_index::member<boost::bimaps::relation::detail::relation_storage<boost::bimaps::tags::tagged<DataCodingScheme const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_DataCodingScheme const,boost::bimaps::relation::member_at::right>,true>,DataCodingScheme,&boost::bimaps::relation::detail::relation_storage<boost::bimaps::tags::tagged<DataCodingScheme const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_DataCodingScheme const,boost::bimaps::relation::member_at::right>,true>::left>,std::less<DataCodingScheme>,boost::multi_index::detail::nth_layer<2,boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<DataCodingScheme const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_DataCodingScheme const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<DataCodingScheme,QMI_DataCodingScheme,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<DataCodingScheme const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_DataCodingScheme const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>,boost::mpl::v_item<boost::bimaps::relation::member_at::left,boost::mpl::vector0<mpl_::na>,0>,boost::multi_index::detail::ordered_unique_tag,boost::multi_index::detail::null_augment_policy>::find<DataCodingScheme>(uint64_t a1, unsigned __int8 *a2)
{
  unsigned __int8 *result;
  unint64_t v3;
  unsigned int v4;
  unsigned __int8 *v5;

  result = *(unsigned __int8 **)(a1 - 8);
  v3 = *((_QWORD *)result + 1) & 0xFFFFFFFFFFFFFFFELL;
  if (v3)
  {
    v4 = *a2;
    v5 = result;
    do
    {
      while (*(unsigned __int8 *)(v3 - 8) < v4)
      {
        v3 = *(_QWORD *)(v3 + 16);
        if (!v3)
          goto LABEL_7;
      }
      v5 = (unsigned __int8 *)(v3 - 8);
      v3 = *(_QWORD *)(v3 + 8);
    }
    while (v3);
LABEL_7:
    if (v5 != result && v4 >= *v5)
      return v5;
  }
  return result;
}

unint64_t boost::multi_index::detail::ordered_index_impl<boost::multi_index::member<boost::bimaps::relation::detail::relation_storage<boost::bimaps::tags::tagged<DataCodingScheme const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_DataCodingScheme const,boost::bimaps::relation::member_at::right>,true>,QMI_DataCodingScheme,&boost::bimaps::relation::detail::relation_storage<boost::bimaps::tags::tagged<DataCodingScheme const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_DataCodingScheme const,boost::bimaps::relation::member_at::right>,true>::right>,std::less<QMI_DataCodingScheme>,boost::multi_index::detail::nth_layer<1,boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<DataCodingScheme const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_DataCodingScheme const,boost::bimaps::relation::member_at::right>,mpl_::na,true>,boost::bimaps::detail::bimap_core<DataCodingScheme,QMI_DataCodingScheme,mpl_::na,mpl_::na,mpl_::na>::core_indices,std::allocator<boost::bimaps::relation::mutant_relation<boost::bimaps::tags::tagged<DataCodingScheme const,boost::bimaps::relation::member_at::left>,boost::bimaps::tags::tagged<QMI_DataCodingScheme const,boost::bimaps::relation::member_at::right>,mpl_::na,true>>>,boost::mpl::v_item<boost::bimaps::relation::member_at::right,boost::mpl::vector0<mpl_::na>,0>,boost::multi_index::detail::ordered_unique_tag,boost::multi_index::detail::null_augment_policy>::find<QMI_DataCodingScheme>(uint64_t a1, unsigned __int8 *a2)
{
  unint64_t result;
  unint64_t v3;
  unsigned int v4;
  unint64_t v5;

  result = *(_QWORD *)(a1 - 8);
  v3 = *(_QWORD *)(result + 32) & 0xFFFFFFFFFFFFFFFELL;
  if (v3)
  {
    v4 = *a2;
    v5 = result;
    do
    {
      while (*(unsigned __int8 *)(v3 - 31) < v4)
      {
        v3 = *(_QWORD *)(v3 + 16);
        if (!v3)
          goto LABEL_7;
      }
      v5 = v3 - 32;
      v3 = *(_QWORD *)(v3 + 8);
    }
    while (v3);
LABEL_7:
    if (v5 != result && v4 >= *(unsigned __int8 *)(v5 + 1))
      return v5;
  }
  return result;
}

uint64_t _GLOBAL__sub_I_QMI_STK_Helper_cpp()
{
  _QWORD *v0;
  _QWORD *v1;
  _QWORD *v2;
  _QWORD *v3;

  qword_253DE9F78 = (uint64_t)&unk_253DE9F90;
  v0 = operator new(0x38uLL);
  qword_253DE9F88 = (uint64_t)v0;
  v0[1] = 0;
  v0[4] = 0;
  v0[2] = v0 + 1;
  v0[3] = v0 + 1;
  v0[5] = v0 + 4;
  v0[6] = v0 + 4;
  qword_253DE9F98 = 0;
  unk_253DE9FA0 = &unk_253DE9F90;
  qword_253DE9FA8 = (uint64_t)&unk_253DE9F90;
  __cxa_atexit((void (*)(void *))boost::bimaps::bimap<ProactiveCommand,QMI_ProactiveCommand,mpl_::na,mpl_::na,mpl_::na>::~bimap, &sProactiveCommandMap, &dword_216897000);
  qword_253DEA000 = 0;
  qword_253DE9FF8 = 0;
  sProactiveCommand_TR_Map = (uint64_t)&qword_253DE9FF8;
  __cxa_atexit((void (*)(void *))std::map<ProactiveCommand,QMI_ProactiveCommand_TerminalResponse>::~map[abi:ne180100], &sProactiveCommand_TR_Map, &dword_216897000);
  qword_253DE9FB8 = (uint64_t)&unk_253DE9FD0;
  v1 = operator new(0x38uLL);
  qword_253DE9FC8 = (uint64_t)v1;
  v1[1] = 0;
  v1[4] = 0;
  v1[2] = v1 + 1;
  v1[3] = v1 + 1;
  v1[5] = v1 + 4;
  v1[6] = v1 + 4;
  qword_253DE9FD8 = 0;
  qword_253DE9FE0 = (uint64_t)&unk_253DE9FD0;
  qword_253DE9FE8 = (uint64_t)&unk_253DE9FD0;
  __cxa_atexit((void (*)(void *))boost::bimaps::bimap<NotificationResponse,tr::Response,mpl_::na,mpl_::na,mpl_::na>::~bimap, &sNotificationResponseMap, &dword_216897000);
  qword_253DEA010 = (uint64_t)algn_253DEA028;
  v2 = operator new(0x38uLL);
  qword_253DEA020 = (uint64_t)v2;
  v2[1] = 0;
  v2[4] = 0;
  v2[2] = v2 + 1;
  v2[3] = v2 + 1;
  v2[5] = v2 + 4;
  v2[6] = v2 + 4;
  qword_253DEA030 = 0;
  qword_253DEA038 = (uint64_t)algn_253DEA028;
  qword_253DEA040 = (uint64_t)algn_253DEA028;
  __cxa_atexit((void (*)(void *))boost::bimaps::bimap<NotificationAdditionalResponse,tr::AdditionalResponse,mpl_::na,mpl_::na,mpl_::na>::~bimap, &sNotificationAdditionalResponseMap, &dword_216897000);
  qword_253DE9F38 = (uint64_t)&unk_253DE9F50;
  v3 = operator new(0x38uLL);
  qword_253DE9F48 = (uint64_t)v3;
  v3[1] = 0;
  v3[2] = v3 + 1;
  v3[3] = v3 + 1;
  v3[4] = 0;
  v3[5] = v3 + 4;
  v3[6] = v3 + 4;
  qword_253DE9F58 = 0;
  qword_253DE9F60 = (uint64_t)&unk_253DE9F50;
  qword_253DE9F68 = (uint64_t)&unk_253DE9F50;
  return __cxa_atexit((void (*)(void *))boost::bimaps::bimap<DataCodingScheme,QMI_DataCodingScheme,mpl_::na,mpl_::na,mpl_::na>::~bimap, &sDataCodingSchemeMap, &dword_216897000);
}

void QMIAudioRoutingCommandDriver::create(uint64_t a1@<X0>, NSObject **a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v6;
  NSObject *v7;
  dispatch_object_t v8;

  v6 = operator new();
  v7 = *a2;
  v8 = v7;
  if (v7)
    dispatch_retain(v7);
  QMIAudioRoutingCommandDriver::QMIAudioRoutingCommandDriver(v6, a1, &v8);
  *a3 = 0;
  a3[1] = 0;
  std::shared_ptr<QMIAudioRoutingCommandDriver>::shared_ptr[abi:ne180100]<QMIAudioRoutingCommandDriver,std::shared_ptr<QMIAudioRoutingCommandDriver> ctu::SharedSynchronizable<AudioRoutingCommandDriver>::make_shared_ptr<QMIAudioRoutingCommandDriver>(QMIAudioRoutingCommandDriver*)::{lambda(QMIAudioRoutingCommandDriver*)#1},void>(a3, v6);
  if (v7)
    dispatch_release(v7);
}

void sub_216A2D554(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  NSObject *v2;
  int v3;

  if (v2)
    dispatch_release(v2);
  if (v3)
    MEMORY[0x2199FEAC4](v1, 0x10F1C4034818AECLL);
  _Unwind_Resume(exception_object);
}

uint64_t QMIAudioRoutingCommandDriver::QMIAudioRoutingCommandDriver(uint64_t a1, uint64_t a2, dispatch_object_t *a3)
{
  NSObject *object;

  object = *a3;
  if (*a3)
    dispatch_retain(*a3);
  AudioRoutingCommandDriver::AudioRoutingCommandDriver();
  if (object)
    dispatch_release(object);
  *(_QWORD *)a1 = &off_24D5E2208;
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 88) = &unk_24D5E2278;
  *(_BYTE *)(a1 + 112) = 0;
  *(_QWORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 128) = 0;
  *(_BYTE *)(a1 + 136) = 0;
  return a1;
}

void sub_216A2D614(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object)
{
  if (object)
    dispatch_release(object);
  _Unwind_Resume(exception_object);
}

void QMIAudioRoutingCommandDriver::~QMIAudioRoutingCommandDriver(QMIAudioRoutingCommandDriver *this)
{
  *(_QWORD *)this = &off_24D5E2208;
  *((_QWORD *)this + 11) = &unk_24D5E2278;
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)this + 120);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)this + 96);
  AudioRoutingCommandDriver::~AudioRoutingCommandDriver(this);
}

{
  QMIAudioRoutingCommandDriver::~QMIAudioRoutingCommandDriver(this);
  JUMPOUT(0x2199FEAC4);
}

void `non-virtual thunk to'QMIAudioRoutingCommandDriver::~QMIAudioRoutingCommandDriver(QMIAudioRoutingCommandDriver *this)
{
  QMIAudioRoutingCommandDriver::~QMIAudioRoutingCommandDriver((QMIAudioRoutingCommandDriver *)((char *)this - 88));
}

{
  QMIAudioRoutingCommandDriver::~QMIAudioRoutingCommandDriver((QMIAudioRoutingCommandDriver *)((char *)this - 88));
  JUMPOUT(0x2199FEAC4);
}

void QMIAudioRoutingCommandDriver::bootstrap(_QWORD *a1, dispatch_object_t *a2, uint64_t a3, uint64_t *a4)
{
  NSObject *v7;
  xpc_object_t v8;
  xpc_object_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  std::__shared_weak_count *v14;
  uint64_t v15;
  std::__shared_weak_count *v16;
  std::__shared_weak_count *v17;
  _QWORD *v18;
  xpc_object_t v19;
  xpc_object_t v20;
  unint64_t *p_shared_owners;
  NSObject *v22;
  unint64_t v23;
  _QWORD *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;

  v7 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v7);
  }
  v8 = *(xpc_object_t *)a3;
  if (*(_QWORD *)a3)
    xpc_retain(*(xpc_object_t *)a3);
  else
    v8 = xpc_null_create();
  v9 = *(xpc_object_t *)(a3 + 8);
  if (v9)
    xpc_retain(v9);
  else
    v9 = xpc_null_create();
  v10 = *a4;
  v11 = a4[1];
  if (v11)
  {
    v12 = (unint64_t *)(v11 + 8);
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }
  v14 = (std::__shared_weak_count *)a1[2];
  if (!v14 || (v15 = a1[1], (v16 = std::__shared_weak_count::lock(v14)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v17 = v16;
  v18 = (_QWORD *)operator new();
  *v18 = a1;
  v18[1] = v7;
  v18[2] = v8;
  v19 = xpc_null_create();
  v18[3] = v9;
  v20 = xpc_null_create();
  v18[4] = v10;
  v18[5] = v11;
  p_shared_owners = (unint64_t *)&v17->__shared_owners_;
  v22 = a1[3];
  do
    v23 = __ldxr(p_shared_owners);
  while (__stxr(v23 + 1, p_shared_owners));
  v24 = (_QWORD *)operator new();
  *v24 = v18;
  v24[1] = v15;
  v24[2] = v17;
  v26 = 0;
  v27 = 0;
  dispatch_async_f(v22, v24, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<AudioRoutingCommandDriver>::execute_wrapped<QMIAudioRoutingCommandDriver::bootstrap(dispatch::group_session,AudioRoutingCommandDriver::ServerConnections,std::shared_ptr<AudioRoutingCommandDriverDelegateInterface>)::$_0>(QMIAudioRoutingCommandDriver::bootstrap(dispatch::group_session,AudioRoutingCommandDriver::ServerConnections,std::shared_ptr<AudioRoutingCommandDriverDelegateInterface>)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIAudioRoutingCommandDriver::bootstrap(dispatch::group_session,AudioRoutingCommandDriver::ServerConnections,std::shared_ptr<AudioRoutingCommandDriverDelegateInterface>)::$_0,std::default_delete<QMIAudioRoutingCommandDriver::bootstrap(dispatch::group_session,AudioRoutingCommandDriver::ServerConnections,std::shared_ptr<AudioRoutingCommandDriverDelegateInterface>)::$_0>>)::{lambda(void *)#1}::__invoke);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v26);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v27);
  do
    v25 = __ldaxr(p_shared_owners);
  while (__stlxr(v25 - 1, p_shared_owners));
  if (!v25)
  {
    ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
    std::__shared_weak_count::__release_weak(v17);
  }
  xpc_release(v20);
  xpc_release(v19);
}

void QMIAudioRoutingCommandDriver::shutdown(_QWORD *a1, dispatch_object_t *a2)
{
  NSObject *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  _QWORD *v8;
  unint64_t *p_shared_owners;
  NSObject *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
  }
  v4 = (std::__shared_weak_count *)a1[2];
  if (!v4 || (v5 = a1[1], (v6 = std::__shared_weak_count::lock(v4)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v7 = v6;
  v8 = (_QWORD *)operator new();
  *v8 = a1;
  v8[1] = v3;
  p_shared_owners = (unint64_t *)&v7->__shared_owners_;
  v10 = a1[3];
  do
    v11 = __ldxr(p_shared_owners);
  while (__stxr(v11 + 1, p_shared_owners));
  v12 = (_QWORD *)operator new();
  *v12 = v8;
  v12[1] = v5;
  v12[2] = v7;
  v14 = 0;
  v15 = 0;
  dispatch_async_f(v10, v12, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<AudioRoutingCommandDriver>::execute_wrapped<QMIAudioRoutingCommandDriver::shutdown(dispatch::group_session)::$_0>(QMIAudioRoutingCommandDriver::shutdown(dispatch::group_session)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIAudioRoutingCommandDriver::shutdown(dispatch::group_session)::$_0,dispatch_queue_s *::default_delete<QMIAudioRoutingCommandDriver::shutdown(dispatch::group_session)::$_0>>)::{lambda(void *)#1}::__invoke);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v14);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v15);
  do
    v13 = __ldaxr(p_shared_owners);
  while (__stlxr(v13 - 1, p_shared_owners));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
}

void QMIAudioRoutingCommandDriver::registered(_QWORD *a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  std::__shared_weak_count *v10;
  _QWORD *v11;
  unint64_t *p_shared_owners;
  NSObject *v13;
  unint64_t v14;
  _QWORD *v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v3 = *a2;
  v4 = a2[1];
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  v7 = (std::__shared_weak_count *)a1[2];
  if (!v7 || (v8 = a1[1], (v9 = std::__shared_weak_count::lock(v7)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v10 = v9;
  v11 = (_QWORD *)operator new();
  *v11 = v3;
  v11[1] = v4;
  v11[2] = a1;
  p_shared_owners = (unint64_t *)&v10->__shared_owners_;
  v13 = a1[3];
  do
    v14 = __ldxr(p_shared_owners);
  while (__stxr(v14 + 1, p_shared_owners));
  v15 = (_QWORD *)operator new();
  *v15 = v11;
  v15[1] = v8;
  v15[2] = v10;
  v17 = 0;
  v18 = 0;
  dispatch_async_f(v13, v15, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<AudioRoutingCommandDriver>::execute_wrapped<QMIAudioRoutingCommandDriver::registered(std::shared_ptr<QMIVirtualClient>)::$_0>(QMIAudioRoutingCommandDriver::registered(std::shared_ptr<QMIVirtualClient>)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIAudioRoutingCommandDriver::registered(std::shared_ptr<QMIVirtualClient>)::$_0,std::default_delete<QMIAudioRoutingCommandDriver::registered(std::shared_ptr<QMIVirtualClient>)::$_0>>)::{lambda(void *)#1}::__invoke);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v17);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v18);
  do
    v16 = __ldaxr(p_shared_owners);
  while (__stlxr(v16 - 1, p_shared_owners));
  if (!v16)
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
}

void `non-virtual thunk to'QMIAudioRoutingCommandDriver::registered(uint64_t a1, uint64_t *a2)
{
  QMIAudioRoutingCommandDriver::registered((_QWORD *)(a1 - 88), a2);
}

void QMIAudioRoutingCommandDriver::deregistered(_QWORD *a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  std::__shared_weak_count *v10;
  _QWORD *v11;
  unint64_t *p_shared_owners;
  NSObject *v13;
  unint64_t v14;
  _QWORD *v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v3 = *a2;
  v4 = a2[1];
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  v7 = (std::__shared_weak_count *)a1[2];
  if (!v7 || (v8 = a1[1], (v9 = std::__shared_weak_count::lock(v7)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v10 = v9;
  v11 = (_QWORD *)operator new();
  *v11 = a1;
  v11[1] = v3;
  v11[2] = v4;
  p_shared_owners = (unint64_t *)&v10->__shared_owners_;
  v13 = a1[3];
  do
    v14 = __ldxr(p_shared_owners);
  while (__stxr(v14 + 1, p_shared_owners));
  v15 = (_QWORD *)operator new();
  *v15 = v11;
  v15[1] = v8;
  v15[2] = v10;
  v17 = 0;
  v18 = 0;
  dispatch_async_f(v13, v15, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<AudioRoutingCommandDriver>::execute_wrapped<QMIAudioRoutingCommandDriver::deregistered(std::shared_ptr<QMIVirtualClient>)::$_0>(QMIAudioRoutingCommandDriver::deregistered(std::shared_ptr<QMIVirtualClient>)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIAudioRoutingCommandDriver::deregistered(std::shared_ptr<QMIVirtualClient>)::$_0,std::default_delete<QMIAudioRoutingCommandDriver::deregistered(std::shared_ptr<QMIVirtualClient>)::$_0>>)::{lambda(void *)#1}::__invoke);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v17);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&v18);
  do
    v16 = __ldaxr(p_shared_owners);
  while (__stlxr(v16 - 1, p_shared_owners));
  if (!v16)
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
}

void `non-virtual thunk to'QMIAudioRoutingCommandDriver::deregistered(uint64_t a1, uint64_t *a2)
{
  QMIAudioRoutingCommandDriver::deregistered((_QWORD *)(a1 - 88), a2);
}

void QMIAudioRoutingCommandDriver::setPath(uint64_t a1, int a2, int a3)
{
  const void **v5;
  const void **v6;
  const void **v7;
  char *v8;
  _WORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  char *v16;
  const void **v17;
  char *v18;
  char *v19;
  char *v20;
  const void *v21;
  char *v22;
  _WORD *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  char *v31;
  uint64_t *v32;
  char *v33;
  char *v34;
  char *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  void *v39;
  _QWORD v40[5];
  void *__p[2];
  __int128 v42;
  _QWORD v43[6];
  uint64_t v44;
  int v45;
  uint64_t v46;
  void *v47;
  _QWORD aBlock[5];

  *(_DWORD *)(a1 + 140) = getQmiDownLinkAudioPath(a2);
  *(_DWORD *)(a1 + 144) = getQmiUplinkAudioPath(a3);
  *(_OWORD *)__p = 0u;
  v42 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  v5 = (const void **)__p[1];
  v6 = (const void **)v42;
  v7 = (const void **)__p[1];
  if (__p[1] != (void *)v42)
  {
    v7 = (const void **)__p[1];
    while (*((_BYTE *)*v7 + 8) != 16)
    {
      if (++v7 == (const void **)v42)
        goto LABEL_9;
    }
  }
  if (v7 == (const void **)v42)
  {
LABEL_9:
    v10 = operator new();
    v11 = v10;
    *(_BYTE *)(v10 + 8) = 16;
    *(_QWORD *)v10 = &off_24D5E2408;
    *(_WORD *)(v10 + 10) = 0;
    v9 = (_WORD *)(v10 + 10);
    v12 = v42;
    if ((unint64_t)v42 >= *((_QWORD *)&v42 + 1))
    {
      v13 = (uint64_t)(v42 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v13 + 1) >> 61)
        goto LABEL_58;
      v14 = (uint64_t)(*((_QWORD *)&v42 + 1) - (unint64_t)__p[1]) >> 2;
      if (v14 <= v13 + 1)
        v14 = v13 + 1;
      if (*((_QWORD *)&v42 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v15 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v15 = v14;
      if (v15)
        v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v42 + 8, v15);
      else
        v16 = 0;
      v17 = (const void **)&v16[8 * v13];
      v18 = &v16[8 * v15];
      *v17 = (const void *)v11;
      v6 = v17 + 1;
      v20 = (char *)__p[1];
      v19 = (char *)v42;
      if ((void *)v42 != __p[1])
      {
        do
        {
          v21 = (const void *)*((_QWORD *)v19 - 1);
          v19 -= 8;
          *--v17 = v21;
        }
        while (v19 != v20);
        v19 = (char *)__p[1];
      }
      __p[1] = v17;
      *(_QWORD *)&v42 = v6;
      *((_QWORD *)&v42 + 1) = v18;
      if (v19)
        operator delete(v19);
    }
    else
    {
      *(_QWORD *)v42 = v10;
      v6 = (const void **)(v12 + 8);
    }
    *(_QWORD *)&v42 = v6;
    v5 = (const void **)__p[1];
  }
  else
  {
    if (!v8)
      goto LABEL_59;
    v9 = v8 + 10;
  }
  *v9 = *(_DWORD *)(a1 + 140);
  while (1)
  {
    if (v5 == v6)
      goto LABEL_33;
    if (*((_BYTE *)*v5 + 8) == 17)
      break;
    ++v5;
  }
  if (v5 == v6)
  {
LABEL_33:
    v24 = operator new();
    v25 = v24;
    *(_BYTE *)(v24 + 8) = 17;
    *(_QWORD *)v24 = &off_24D5E2458;
    *(_WORD *)(v24 + 10) = 0;
    v23 = (_WORD *)(v24 + 10);
    v26 = v42;
    if ((unint64_t)v42 < *((_QWORD *)&v42 + 1))
    {
      *(_QWORD *)v42 = v24;
      v27 = (_QWORD *)(v26 + 8);
LABEL_49:
      *(_QWORD *)&v42 = v27;
      goto LABEL_50;
    }
    v28 = (uint64_t)(v42 - (unint64_t)__p[1]) >> 3;
    if (!((unint64_t)(v28 + 1) >> 61))
    {
      v29 = (uint64_t)(*((_QWORD *)&v42 + 1) - (unint64_t)__p[1]) >> 2;
      if (v29 <= v28 + 1)
        v29 = v28 + 1;
      if (*((_QWORD *)&v42 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v30 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v30 = v29;
      if (v30)
        v31 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v42 + 8, v30);
      else
        v31 = 0;
      v32 = (uint64_t *)&v31[8 * v28];
      v33 = &v31[8 * v30];
      *v32 = v25;
      v27 = v32 + 1;
      v35 = (char *)__p[1];
      v34 = (char *)v42;
      if ((void *)v42 != __p[1])
      {
        do
        {
          v36 = *((_QWORD *)v34 - 1);
          v34 -= 8;
          *--v32 = v36;
        }
        while (v34 != v35);
        v34 = (char *)__p[1];
      }
      __p[1] = v32;
      *(_QWORD *)&v42 = v27;
      *((_QWORD *)&v42 + 1) = v33;
      if (v34)
        operator delete(v34);
      goto LABEL_49;
    }
LABEL_58:
    std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
  }
  if (!v22)
LABEL_59:
    __cxa_bad_cast();
  v23 = v22 + 10;
LABEL_50:
  *v23 = *(_DWORD *)(a1 + 144);
  v37 = *(_QWORD *)(a1 + 96);
  v38 = MEMORY[0x24BDAC760];
  v40[0] = MEMORY[0x24BDAC760];
  v40[1] = 0x40000000;
  v40[2] = ___ZN28QMIAudioRoutingCommandDriver7setPathEN21AudioRoutingInterface17DownlinkAudioPathENS0_15UplinkAudioPathE_block_invoke_3;
  v40[3] = &__block_descriptor_tmp_7_11;
  v40[4] = a1;
  if (!*(_BYTE *)(v37 + 72) || !*(_QWORD *)(v37 + 56))
    __TUAssertTrigger();
  v43[5] = v37 + 40;
  v44 = QMIServiceMsg::create();
  v45 = 25000;
  v46 = 0;
  v47 = 0;
  v43[0] = v38;
  v43[1] = 0x40000000;
  v43[2] = ___ZN16QMIVirtualClient4sendIN5audio12SetAudioPath7RequestEU13block_pointerFvRKN3qmi12ResponseBaseEEEEvRKT_T0__block_invoke;
  v43[3] = &unk_24D5E2488;
  v43[4] = v40;
  aBlock[0] = v38;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_25;
  aBlock[3] = &unk_24D5E24B0;
  aBlock[4] = v43;
  v39 = _Block_copy(aBlock);
  v47 = v39;
  if (v44)
  {
    qmi::Client::send();
    v39 = v47;
  }
  if (v39)
    _Block_release(v39);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
}

void sub_216A2E010(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v8;
  va_list va;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  va_list va1;

  va_start(va1, a7);
  va_start(va, a7);
  v8 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  v18 = va_arg(va1, _QWORD);
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)va1);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

void ___ZN28QMIAudioRoutingCommandDriver7setPathEN21AudioRoutingInterface17DownlinkAudioPathENS0_15UplinkAudioPathE_block_invoke_3(uint64_t a1, uint64_t a2)
{
  int v2;
  NSObject *v3;
  _DWORD v4[2];
  __int16 v5;
  uint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v2 = *(_DWORD *)(a2 + 4);
  if (v2)
  {
    v3 = *(NSObject **)(*(_QWORD *)(a1 + 32) + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      v4[0] = 67109378;
      v4[1] = v2;
      v5 = 2080;
      v6 = qmi::asString();
      _os_log_impl(&dword_216897000, v3, OS_LOG_TYPE_DEFAULT, "#N Error in set audio path response with code = 0x%x (%s)", (uint8_t *)v4, 0x12u);
    }
  }
}

void QMIAudioRoutingCommandDriver::setTtyEnabled(QMIAudioRoutingCommandDriver *this, char a2)
{
  const void **v4;
  char *v5;
  _BYTE *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  char *v14;
  uint64_t *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  void *v22;
  _QWORD v23[5];
  void *__p[2];
  __int128 v25;
  _QWORD v26[6];
  uint64_t v27;
  int v28;
  uint64_t v29;
  void *v30;
  _QWORD aBlock[5];

  *(_OWORD *)__p = 0u;
  v25 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  v4 = (const void **)__p[1];
  if (__p[1] != (void *)v25)
  {
    while (*((_BYTE *)*v4 + 8) != 1)
    {
      if (++v4 == (const void **)v25)
        goto LABEL_8;
    }
  }
  if (v4 == (const void **)v25)
  {
LABEL_8:
    v7 = operator new();
    v8 = v7;
    *(_WORD *)(v7 + 8) = 1;
    *(_QWORD *)v7 = &off_24D5E24F8;
    *(_BYTE *)(v7 + 10) = 0;
    v9 = v25;
    if ((unint64_t)v25 >= *((_QWORD *)&v25 + 1))
    {
      v11 = (uint64_t)(v25 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v11 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v12 = (uint64_t)(*((_QWORD *)&v25 + 1) - (unint64_t)__p[1]) >> 2;
      if (v12 <= v11 + 1)
        v12 = v11 + 1;
      if (*((_QWORD *)&v25 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v13 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v13 = v12;
      if (v13)
        v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v25 + 8, v13);
      else
        v14 = 0;
      v15 = (uint64_t *)&v14[8 * v11];
      v16 = &v14[8 * v13];
      *v15 = v8;
      v10 = v15 + 1;
      v18 = (char *)__p[1];
      v17 = (char *)v25;
      if ((void *)v25 != __p[1])
      {
        do
        {
          v19 = *((_QWORD *)v17 - 1);
          v17 -= 8;
          *--v15 = v19;
        }
        while (v17 != v18);
        v17 = (char *)__p[1];
      }
      __p[1] = v15;
      *(_QWORD *)&v25 = v10;
      *((_QWORD *)&v25 + 1) = v16;
      if (v17)
        operator delete(v17);
    }
    else
    {
      *(_QWORD *)v25 = v7;
      v10 = (_QWORD *)(v9 + 8);
    }
    v6 = (_BYTE *)(v8 + 9);
    *(_QWORD *)&v25 = v10;
  }
  else
  {
    if (!v5)
      __cxa_bad_cast();
    v6 = v5 + 9;
  }
  *v6 = a2;
  v6[1] = 0;
  v20 = *((_QWORD *)this + 12);
  v21 = MEMORY[0x24BDAC760];
  v23[0] = MEMORY[0x24BDAC760];
  v23[1] = 0x40000000;
  v23[2] = ___ZN28QMIAudioRoutingCommandDriver13setTtyEnabledEb_block_invoke_2;
  v23[3] = &__block_descriptor_tmp_10_12;
  v23[4] = this;
  if (!*(_BYTE *)(v20 + 72) || !*(_QWORD *)(v20 + 56))
    __TUAssertTrigger();
  v26[5] = v20 + 40;
  v27 = QMIServiceMsg::create();
  v28 = 25000;
  v29 = 0;
  v30 = 0;
  v26[0] = v21;
  v26[1] = 0x40000000;
  v26[2] = ___ZN16QMIVirtualClient4sendIN5audio6SetTTY7RequestEU13block_pointerFvRKN3qmi12ResponseBaseEEEEvRKT_T0__block_invoke;
  v26[3] = &unk_24D5E2528;
  v26[4] = v23;
  aBlock[0] = v21;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_25;
  aBlock[3] = &unk_24D5E24B0;
  aBlock[4] = v26;
  v22 = _Block_copy(aBlock);
  v30 = v22;
  if (v27)
  {
    qmi::Client::send();
    v22 = v30;
  }
  if (v22)
    _Block_release(v22);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
}

void sub_216A2E388(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v8;
  va_list va;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  va_list va1;

  va_start(va1, a7);
  va_start(va, a7);
  v8 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  v18 = va_arg(va1, _QWORD);
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)va1);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

void ___ZN28QMIAudioRoutingCommandDriver13setTtyEnabledEb_block_invoke_2(uint64_t a1, uint64_t a2)
{
  int v2;
  NSObject *v3;
  _DWORD v4[2];
  __int16 v5;
  uint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v2 = *(_DWORD *)(a2 + 4);
  if (v2)
  {
    v3 = *(NSObject **)(*(_QWORD *)(a1 + 32) + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      v4[0] = 67109378;
      v4[1] = v2;
      v5 = 2080;
      v6 = qmi::asString();
      _os_log_impl(&dword_216897000, v3, OS_LOG_TYPE_DEFAULT, "#N Error in set TTY response with code = 0x%x (%s)", (uint8_t *)v4, 0x12u);
    }
  }
}

void QMIAudioRoutingCommandDriver::setCtmMode(uint64_t a1, int a2)
{
  _BYTE *v4;
  char v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  _QWORD v9[5];
  _OWORD v10[2];
  _QWORD v11[6];
  uint64_t v12;
  int v13;
  uint64_t v14;
  void *v15;
  _QWORD aBlock[5];

  memset(v10, 0, sizeof(v10));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v10);
  v4 = (_BYTE *)qmi::MutableMessageBase::getTLV<vs::tlv::TtyMode>(v10, 19);
  if (a2 == 1)
    v5 = 0;
  else
    v5 = 3;
  *v4 = v5;
  v6 = *(_QWORD *)(a1 + 120);
  v7 = MEMORY[0x24BDAC760];
  v9[0] = MEMORY[0x24BDAC760];
  v9[1] = 0x40000000;
  v9[2] = ___ZN28QMIAudioRoutingCommandDriver10setCtmModeE7CtmMode_block_invoke_2;
  v9[3] = &__block_descriptor_tmp_13_14;
  v9[4] = a1;
  if (!*(_BYTE *)(v6 + 72) || !*(_QWORD *)(v6 + 56))
    __TUAssertTrigger();
  v11[5] = v6 + 40;
  v12 = QMIServiceMsg::create();
  v13 = 25000;
  v14 = 0;
  v15 = 0;
  v11[0] = v7;
  v11[1] = 0x40000000;
  v11[2] = ___ZN16QMIVirtualClient4sendIN2vs9SetConfig7RequestEU13block_pointerFvRKN3qmi12ResponseBaseEEEEvRKT_T0__block_invoke;
  v11[3] = &unk_24D5E25A0;
  v11[4] = v9;
  aBlock[0] = v7;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_25;
  aBlock[3] = &unk_24D5E24B0;
  aBlock[4] = v11;
  v8 = _Block_copy(aBlock);
  v15 = v8;
  if (v12)
  {
    qmi::Client::send();
    v8 = v15;
  }
  if (v8)
    _Block_release(v8);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v10);
}

void sub_216A2E5B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v8;
  va_list va;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  va_list va1;

  va_start(va1, a7);
  va_start(va, a7);
  v8 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  v18 = va_arg(va1, _QWORD);
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)va1);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

void ___ZN28QMIAudioRoutingCommandDriver10setCtmModeE7CtmMode_block_invoke_2(uint64_t a1, uint64_t a2)
{
  int v2;
  NSObject *v3;
  _DWORD v4[2];
  __int16 v5;
  uint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v2 = *(_DWORD *)(a2 + 4);
  if (v2)
  {
    v3 = *(NSObject **)(*(_QWORD *)(a1 + 32) + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      v4[0] = 67109378;
      v4[1] = v2;
      v5 = 2080;
      v6 = qmi::asString();
      _os_log_impl(&dword_216897000, v3, OS_LOG_TYPE_DEFAULT, "#N Error in set CTM mode response with code = 0x%x (%s)", (uint8_t *)v4, 0x12u);
    }
  }
}

void QMIAudioRoutingCommandDriver::setVoiceMute(QMIAudioRoutingCommandDriver *this, char a2)
{
  const void **v4;
  char *v5;
  _BYTE *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  char *v14;
  uint64_t *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  void *v22;
  _QWORD v23[5];
  void *__p[2];
  __int128 v25;
  _QWORD v26[6];
  uint64_t v27;
  int v28;
  uint64_t v29;
  void *v30;
  _QWORD aBlock[5];

  if (capabilities::ct::supportsVoiceCall(this))
  {
    *(_OWORD *)__p = 0u;
    v25 = 0u;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
    v4 = (const void **)__p[1];
    if (__p[1] != (void *)v25)
    {
      while (*((_BYTE *)*v4 + 8) != 1)
      {
        if (++v4 == (const void **)v25)
          goto LABEL_9;
      }
    }
    if (v4 == (const void **)v25)
    {
LABEL_9:
      v7 = operator new();
      v8 = v7;
      *(_WORD *)(v7 + 8) = 1;
      *(_QWORD *)v7 = &off_24D5E25E8;
      v9 = v25;
      if ((unint64_t)v25 >= *((_QWORD *)&v25 + 1))
      {
        v11 = (uint64_t)(v25 - (unint64_t)__p[1]) >> 3;
        if ((unint64_t)(v11 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v12 = (uint64_t)(*((_QWORD *)&v25 + 1) - (unint64_t)__p[1]) >> 2;
        if (v12 <= v11 + 1)
          v12 = v11 + 1;
        if (*((_QWORD *)&v25 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v13 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v13 = v12;
        if (v13)
          v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v25 + 8, v13);
        else
          v14 = 0;
        v15 = (uint64_t *)&v14[8 * v11];
        v16 = &v14[8 * v13];
        *v15 = v8;
        v10 = v15 + 1;
        v18 = (char *)__p[1];
        v17 = (char *)v25;
        if ((void *)v25 != __p[1])
        {
          do
          {
            v19 = *((_QWORD *)v17 - 1);
            v17 -= 8;
            *--v15 = v19;
          }
          while (v17 != v18);
          v17 = (char *)__p[1];
        }
        __p[1] = v15;
        *(_QWORD *)&v25 = v10;
        *((_QWORD *)&v25 + 1) = v16;
        if (v17)
          operator delete(v17);
      }
      else
      {
        *(_QWORD *)v25 = v7;
        v10 = (_QWORD *)(v9 + 8);
      }
      v6 = (_BYTE *)(v8 + 9);
      *(_QWORD *)&v25 = v10;
    }
    else
    {
      if (!v5)
        __cxa_bad_cast();
      v6 = v5 + 9;
    }
    *v6 = a2;
    v20 = *((_QWORD *)this + 12);
    v21 = MEMORY[0x24BDAC760];
    v23[0] = MEMORY[0x24BDAC760];
    v23[1] = 0x40000000;
    v23[2] = ___ZN28QMIAudioRoutingCommandDriver12setVoiceMuteEb_block_invoke_2;
    v23[3] = &__block_descriptor_tmp_16_16;
    v23[4] = this;
    if (!*(_BYTE *)(v20 + 72) || !*(_QWORD *)(v20 + 56))
      __TUAssertTrigger();
    v26[5] = v20 + 40;
    v27 = QMIServiceMsg::create();
    v28 = 25000;
    v29 = 0;
    v30 = 0;
    v26[0] = v21;
    v26[1] = 0x40000000;
    v26[2] = ___ZN16QMIVirtualClient4sendIN5audio13SetMuteStatus7RequestEU13block_pointerFvRKN3qmi12ResponseBaseEEEEvRKT_T0__block_invoke;
    v26[3] = &unk_24D5E2618;
    v26[4] = v23;
    aBlock[0] = v21;
    aBlock[1] = 0x40000000;
    aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_25;
    aBlock[3] = &unk_24D5E24B0;
    aBlock[4] = v26;
    v22 = _Block_copy(aBlock);
    v30 = v22;
    if (v27)
    {
      qmi::Client::send();
      v22 = v30;
    }
    if (v22)
      _Block_release(v22);
    qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
  }
}

void sub_216A2E930(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v8;
  va_list va;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  va_list va1;

  va_start(va1, a7);
  va_start(va, a7);
  v8 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  v18 = va_arg(va1, _QWORD);
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)va1);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

void ___ZN28QMIAudioRoutingCommandDriver12setVoiceMuteEb_block_invoke_2(uint64_t a1, uint64_t a2)
{
  int v2;
  NSObject *v3;
  _DWORD v4[2];
  __int16 v5;
  uint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v2 = *(_DWORD *)(a2 + 4);
  if (v2)
  {
    v3 = *(NSObject **)(*(_QWORD *)(a1 + 32) + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      v4[0] = 67109378;
      v4[1] = v2;
      v5 = 2080;
      v6 = qmi::asString();
      _os_log_impl(&dword_216897000, v3, OS_LOG_TYPE_DEFAULT, "#N Error in set mute response with code = 0x%x (%s)", (uint8_t *)v4, 0x12u);
    }
  }
}

void QMIAudioRoutingCommandDriver::setSourceGain(uint64_t a1, char a2, unsigned int a3)
{
  const void **v6;
  char *v7;
  _BYTE *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  char *v16;
  uint64_t *v17;
  char *v18;
  char *v19;
  char *v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  _QWORD v26[5];
  void *__p[2];
  __int128 v28;
  _QWORD v29[6];
  uint64_t v30;
  int v31;
  uint64_t v32;
  void *v33;
  _QWORD aBlock[5];

  *(_OWORD *)__p = 0u;
  v28 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  v6 = (const void **)__p[1];
  if (__p[1] != (void *)v28)
  {
    while (*((_BYTE *)*v6 + 8) != 1)
    {
      if (++v6 == (const void **)v28)
        goto LABEL_8;
    }
  }
  if (v6 == (const void **)v28)
  {
LABEL_8:
    v9 = operator new();
    v10 = v9;
    *(_WORD *)(v9 + 8) = 1;
    *(_QWORD *)v9 = &off_24D5E2660;
    *(_BYTE *)(v9 + 10) = 0;
    v11 = v28;
    if ((unint64_t)v28 >= *((_QWORD *)&v28 + 1))
    {
      v13 = (uint64_t)(v28 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v13 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v14 = (uint64_t)(*((_QWORD *)&v28 + 1) - (unint64_t)__p[1]) >> 2;
      if (v14 <= v13 + 1)
        v14 = v13 + 1;
      if (*((_QWORD *)&v28 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v15 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v15 = v14;
      if (v15)
        v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v28 + 8, v15);
      else
        v16 = 0;
      v17 = (uint64_t *)&v16[8 * v13];
      v18 = &v16[8 * v15];
      *v17 = v10;
      v12 = v17 + 1;
      v20 = (char *)__p[1];
      v19 = (char *)v28;
      if ((void *)v28 != __p[1])
      {
        do
        {
          v21 = *((_QWORD *)v19 - 1);
          v19 -= 8;
          *--v17 = v21;
        }
        while (v19 != v20);
        v19 = (char *)__p[1];
      }
      __p[1] = v17;
      *(_QWORD *)&v28 = v12;
      *((_QWORD *)&v28 + 1) = v18;
      if (v19)
        operator delete(v19);
    }
    else
    {
      *(_QWORD *)v28 = v9;
      v12 = (_QWORD *)(v11 + 8);
    }
    v8 = (_BYTE *)(v10 + 9);
    *(_QWORD *)&v28 = v12;
  }
  else
  {
    if (!v7)
      __cxa_bad_cast();
    v8 = v7 + 9;
  }
  v8[1] = a2;
  v22 = 0x2050403010100uLL >> (8 * a3);
  if (a3 >= 7)
    LOBYTE(v22) = 1;
  *v8 = v22;
  v23 = *(_QWORD *)(a1 + 96);
  v24 = MEMORY[0x24BDAC760];
  v26[0] = MEMORY[0x24BDAC760];
  v26[1] = 0x40000000;
  v26[2] = ___ZN28QMIAudioRoutingCommandDriver13setSourceGainEiN21AudioRoutingInterface12VolumeSourceE_block_invoke_2;
  v26[3] = &__block_descriptor_tmp_19_16;
  v26[4] = a1;
  if (!*(_BYTE *)(v23 + 72) || !*(_QWORD *)(v23 + 56))
    __TUAssertTrigger();
  v29[5] = v23 + 40;
  v30 = QMIServiceMsg::create();
  v31 = 25000;
  v32 = 0;
  v33 = 0;
  v29[0] = v24;
  v29[1] = 0x40000000;
  v29[2] = ___ZN16QMIVirtualClient4sendIN5audio9SetVolume7RequestEU13block_pointerFvRKN3qmi12ResponseBaseEEEEvRKT_T0__block_invoke;
  v29[3] = &unk_24D5E2690;
  v29[4] = v26;
  aBlock[0] = v24;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_25;
  aBlock[3] = &unk_24D5E24B0;
  aBlock[4] = v29;
  v25 = _Block_copy(aBlock);
  v33 = v25;
  if (v30)
  {
    qmi::Client::send();
    v25 = v33;
  }
  if (v25)
    _Block_release(v25);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
}

void sub_216A2ECD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v8;
  va_list va;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  va_list va1;

  va_start(va1, a7);
  va_start(va, a7);
  v8 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  v18 = va_arg(va1, _QWORD);
  qmi::Client::SendProxy::~SendProxy((qmi::Client::SendProxy *)va1);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

void ___ZN28QMIAudioRoutingCommandDriver13setSourceGainEiN21AudioRoutingInterface12VolumeSourceE_block_invoke_2(uint64_t a1, uint64_t a2)
{
  int v2;
  NSObject *v3;
  _DWORD v4[2];
  __int16 v5;
  uint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v2 = *(_DWORD *)(a2 + 4);
  if (v2)
  {
    v3 = *(NSObject **)(*(_QWORD *)(a1 + 32) + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      v4[0] = 67109378;
      v4[1] = v2;
      v5 = 2080;
      v6 = qmi::asString();
      _os_log_impl(&dword_216897000, v3, OS_LOG_TYPE_DEFAULT, "#N Error in set volume response  with code = 0x%x (%s)", (uint8_t *)v4, 0x12u);
    }
  }
}

uint64_t *std::shared_ptr<QMIAudioRoutingCommandDriver>::shared_ptr[abi:ne180100]<QMIAudioRoutingCommandDriver,std::shared_ptr<QMIAudioRoutingCommandDriver> ctu::SharedSynchronizable<AudioRoutingCommandDriver>::make_shared_ptr<QMIAudioRoutingCommandDriver>(QMIAudioRoutingCommandDriver*)::{lambda(QMIAudioRoutingCommandDriver*)#1},void>(uint64_t *a1, uint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24D5E2390;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = (uint64_t)v4;
  if (a2)
    v5 = (_QWORD *)(a2 + 8);
  else
    v5 = 0;
  std::shared_ptr<QMIDataSystemDeterminationManager>::__enable_weak_this[abi:ne180100]<QMIDataSystemDeterminationManager,QMIDataSystemDeterminationManager,void>((uint64_t)a1, v5, a2);
  return a1;
}

void sub_216A2EE1C(void *a1)
{
  dispatch_queue_t *v1;

  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)std::shared_ptr<QMIAudioRoutingCommandDriver> ctu::SharedSynchronizable<AudioRoutingCommandDriver>::make_shared_ptr<QMIAudioRoutingCommandDriver>(QMIAudioRoutingCommandDriver*)::{lambda(QMIAudioRoutingCommandDriver*)#1}::operator() const(QMIAudioRoutingCommandDriver*)::{lambda(void *)#1}::__invoke);
  __cxa_rethrow();
}

void sub_216A2EE3C(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<QMIAudioRoutingCommandDriver *,std::shared_ptr<QMIAudioRoutingCommandDriver> ctu::SharedSynchronizable<AudioRoutingCommandDriver>::make_shared_ptr<QMIAudioRoutingCommandDriver>(QMIAudioRoutingCommandDriver*)::{lambda(QMIAudioRoutingCommandDriver *)#1},std::allocator<QMIAudioRoutingCommandDriver>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void std::__shared_ptr_pointer<QMIAudioRoutingCommandDriver *,std::shared_ptr<QMIAudioRoutingCommandDriver> ctu::SharedSynchronizable<AudioRoutingCommandDriver>::make_shared_ptr<QMIAudioRoutingCommandDriver>(QMIAudioRoutingCommandDriver*)::{lambda(QMIAudioRoutingCommandDriver *)#1},std::allocator<QMIAudioRoutingCommandDriver>>::__on_zero_shared(uint64_t a1)
{
  dispatch_barrier_async_f(*(dispatch_queue_t *)(*(_QWORD *)(a1 + 24) + 24), *(void **)(a1 + 24), (dispatch_function_t)std::shared_ptr<QMIAudioRoutingCommandDriver> ctu::SharedSynchronizable<AudioRoutingCommandDriver>::make_shared_ptr<QMIAudioRoutingCommandDriver>(QMIAudioRoutingCommandDriver*)::{lambda(QMIAudioRoutingCommandDriver*)#1}::operator() const(QMIAudioRoutingCommandDriver*)::{lambda(void *)#1}::__invoke);
}

uint64_t std::__shared_ptr_pointer<QMIAudioRoutingCommandDriver *,std::shared_ptr<QMIAudioRoutingCommandDriver> ctu::SharedSynchronizable<AudioRoutingCommandDriver>::make_shared_ptr<QMIAudioRoutingCommandDriver>(QMIAudioRoutingCommandDriver*)::{lambda(QMIAudioRoutingCommandDriver *)#1},std::allocator<QMIAudioRoutingCommandDriver>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t std::shared_ptr<QMIAudioRoutingCommandDriver> ctu::SharedSynchronizable<AudioRoutingCommandDriver>::make_shared_ptr<QMIAudioRoutingCommandDriver>(QMIAudioRoutingCommandDriver*)::{lambda(QMIAudioRoutingCommandDriver*)#1}::operator() const(QMIAudioRoutingCommandDriver*)::{lambda(void *)#1}::__invoke(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<AudioRoutingCommandDriver>::execute_wrapped<QMIAudioRoutingCommandDriver::bootstrap(dispatch::group_session,AudioRoutingCommandDriver::ServerConnections,std::shared_ptr<AudioRoutingCommandDriverDelegateInterface>)::$_0>(QMIAudioRoutingCommandDriver::bootstrap(dispatch::group_session,AudioRoutingCommandDriver::ServerConnections,std::shared_ptr<AudioRoutingCommandDriverDelegateInterface>)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIAudioRoutingCommandDriver::bootstrap(dispatch::group_session,AudioRoutingCommandDriver::ServerConnections,std::shared_ptr<AudioRoutingCommandDriverDelegateInterface>)::$_0,std::default_delete<QMIAudioRoutingCommandDriver::bootstrap(dispatch::group_session,AudioRoutingCommandDriver::ServerConnections,std::shared_ptr<AudioRoutingCommandDriverDelegateInterface>)::$_0>>)::{lambda(void *)#1}::__invoke(uint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  std::mutex *ServiceMap;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  _QWORD *v17;
  void *v18;
  xpc_object_t v19;
  xpc_object_t v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  _QWORD *v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  _QWORD *v28;
  xpc_object_t v29;
  void *v30;
  xpc_object_t v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  std::__shared_weak_count *v35;
  unint64_t *v36;
  unint64_t v37;
  uint64_t *v39;
  uint64_t v40;
  xpc_object_t v41;
  void *v42[2];
  char v43;
  __int128 v44;
  xpc_object_t object;
  void *__p[2];
  char v47;
  _QWORD *v48;
  std::__shared_weak_count *v49;

  v1 = *a1;
  v39 = a1;
  v40 = v1;
  v2 = *(_QWORD *)v1;
  v4 = *(_QWORD *)(v1 + 32);
  v3 = *(_QWORD *)(v1 + 40);
  if (v3)
  {
    v5 = (unint64_t *)(v3 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  v7 = *(std::__shared_weak_count **)(v2 + 72);
  *(_QWORD *)(v2 + 64) = v4;
  *(_QWORD *)(v2 + 72) = v3;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  v48 = 0;
  v49 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(v2 + 48));
  ctu::shared_ptr_map_impl<ctu::indexed_by_any_map_hashing_key>::get<QMIClientPool>(ServiceMap, &v48);
  v11 = MEMORY[0x2199FEDD0](*(_QWORD *)(v1 + 16));
  v12 = MEMORY[0x24BDACFB0];
  if (v11 == MEMORY[0x24BDACFB0])
  {
    v17 = v48;
    std::string::basic_string[abi:ne180100]<0>(__p, "audio");
    object = xpc_null_create();
    if (MEMORY[0x2199FEDD0](*(_QWORD *)(v1 + 16)) == v12)
    {
      v18 = xpc_connection_create_from_endpoint(*(xpc_endpoint_t *)(v1 + 16));
      if (!v18)
        v18 = xpc_null_create();
      v19 = xpc_null_create();
      v20 = object;
      object = v18;
      xpc_release(v20);
      xpc_release(v19);
    }
    QMIClientPool::requestClient(v17, 0xE1u, (uint64_t *)__p, v2 + 88, (uint64_t)&object, v42);
    std::shared_ptr<qmi::Client::State>::operator=[abi:ne180100](v2 + 96, (__int128 *)v42);
    v21 = (std::__shared_weak_count *)v42[1];
    if (v42[1])
    {
      v22 = (unint64_t *)((char *)v42[1] + 8);
      do
        v23 = __ldaxr(v22);
      while (__stlxr(v23 - 1, v22));
      if (!v23)
      {
        ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
        std::__shared_weak_count::__release_weak(v21);
      }
    }
  }
  else
  {
    v13 = v48;
    std::string::basic_string[abi:ne180100]<0>(__p, "audio");
    object = xpc_null_create();
    QMIClientPool::requestClient(v13, 0xE1u, (uint64_t *)__p, v2 + 88, (uint64_t)&object, v42);
    std::shared_ptr<qmi::Client::State>::operator=[abi:ne180100](v2 + 96, (__int128 *)v42);
    v14 = (std::__shared_weak_count *)v42[1];
    if (v42[1])
    {
      v15 = (unint64_t *)((char *)v42[1] + 8);
      do
        v16 = __ldaxr(v15);
      while (__stlxr(v16 - 1, v15));
      if (!v16)
      {
        ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
        std::__shared_weak_count::__release_weak(v14);
      }
    }
  }
  xpc_release(object);
  object = 0;
  if (v47 < 0)
    operator delete(__p[0]);
  if (MEMORY[0x2199FEDD0](*(_QWORD *)(v1 + 24)) == v12)
  {
    v28 = v48;
    std::string::basic_string[abi:ne180100]<0>(v42, "voice");
    v29 = xpc_null_create();
    v41 = v29;
    if (MEMORY[0x2199FEDD0](*(_QWORD *)(v1 + 24)) == v12)
    {
      v30 = xpc_connection_create_from_endpoint(*(xpc_endpoint_t *)(v1 + 24));
      if (!v30)
        v30 = xpc_null_create();
      v31 = xpc_null_create();
      v41 = v30;
      xpc_release(v29);
      xpc_release(v31);
    }
    QMIClientPool::requestClient(v28, 9u, (uint64_t *)v42, v2 + 88, (uint64_t)&v41, &v44);
    std::shared_ptr<qmi::Client::State>::operator=[abi:ne180100](v2 + 120, &v44);
    v32 = (std::__shared_weak_count *)*((_QWORD *)&v44 + 1);
    if (*((_QWORD *)&v44 + 1))
    {
      v33 = (unint64_t *)(*((_QWORD *)&v44 + 1) + 8);
      do
        v34 = __ldaxr(v33);
      while (__stlxr(v34 - 1, v33));
      if (!v34)
      {
        ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
        std::__shared_weak_count::__release_weak(v32);
      }
    }
  }
  else
  {
    v24 = v48;
    std::string::basic_string[abi:ne180100]<0>(v42, "voice");
    v41 = xpc_null_create();
    QMIClientPool::requestClient(v24, 9u, (uint64_t *)v42, v2 + 88, (uint64_t)&v41, &v44);
    std::shared_ptr<qmi::Client::State>::operator=[abi:ne180100](v2 + 120, &v44);
    v25 = (std::__shared_weak_count *)*((_QWORD *)&v44 + 1);
    if (*((_QWORD *)&v44 + 1))
    {
      v26 = (unint64_t *)(*((_QWORD *)&v44 + 1) + 8);
      do
        v27 = __ldaxr(v26);
      while (__stlxr(v27 - 1, v26));
      if (!v27)
      {
        ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
        std::__shared_weak_count::__release_weak(v25);
      }
    }
  }
  xpc_release(v41);
  v41 = 0;
  if (v43 < 0)
    operator delete(v42[0]);
  v35 = v49;
  if (v49)
  {
    v36 = (unint64_t *)&v49->__shared_owners_;
    do
      v37 = __ldaxr(v36);
    while (__stlxr(v37 - 1, v36));
    if (!v37)
    {
      ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
      std::__shared_weak_count::__release_weak(v35);
    }
  }
  std::unique_ptr<QMIAudioRoutingCommandDriver::bootstrap(dispatch::group_session,AudioRoutingCommandDriver::ServerConnections,std::shared_ptr<AudioRoutingCommandDriverDelegateInterface>)::$_0,std::default_delete<QMIAudioRoutingCommandDriver::bootstrap(dispatch::group_session,AudioRoutingCommandDriver::ServerConnections,std::shared_ptr<AudioRoutingCommandDriverDelegateInterface>)::$_0>>::~unique_ptr[abi:ne180100](&v40);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v39);
}

void sub_216A2F2F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, xpc_object_t a20,uint64_t a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  uint64_t v26;
  std::__shared_weak_count *v28;
  unint64_t *p_shared_owners;
  unint64_t v30;

  xpc_release(object);
  object = 0;
  if (a17 < 0)
    operator delete(__p);
  v28 = *(std::__shared_weak_count **)(v26 - 56);
  if (v28)
  {
    p_shared_owners = (unint64_t *)&v28->__shared_owners_;
    do
      v30 = __ldaxr(p_shared_owners);
    while (__stlxr(v30 - 1, p_shared_owners));
    if (!v30)
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
  }
  std::unique_ptr<QMIAudioRoutingCommandDriver::bootstrap(dispatch::group_session,AudioRoutingCommandDriver::ServerConnections,std::shared_ptr<AudioRoutingCommandDriverDelegateInterface>)::$_0,std::default_delete<QMIAudioRoutingCommandDriver::bootstrap(dispatch::group_session,AudioRoutingCommandDriver::ServerConnections,std::shared_ptr<AudioRoutingCommandDriverDelegateInterface>)::$_0>>::~unique_ptr[abi:ne180100](&a10);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

uint64_t *std::unique_ptr<QMIAudioRoutingCommandDriver::bootstrap(dispatch::group_session,AudioRoutingCommandDriver::ServerConnections,std::shared_ptr<AudioRoutingCommandDriverDelegateInterface>)::$_0,std::default_delete<QMIAudioRoutingCommandDriver::bootstrap(dispatch::group_session,AudioRoutingCommandDriver::ServerConnections,std::shared_ptr<AudioRoutingCommandDriverDelegateInterface>)::$_0>>::~unique_ptr[abi:ne180100](uint64_t *a1)
{
  uint64_t v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  NSObject *v6;
  NSObject *v7;

  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    v3 = *(std::__shared_weak_count **)(v2 + 40);
    if (v3)
    {
      p_shared_owners = (unint64_t *)&v3->__shared_owners_;
      do
        v5 = __ldaxr(p_shared_owners);
      while (__stlxr(v5 - 1, p_shared_owners));
      if (!v5)
      {
        ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
        std::__shared_weak_count::__release_weak(v3);
      }
    }
    xpc_release(*(xpc_object_t *)(v2 + 24));
    *(_QWORD *)(v2 + 24) = 0;
    xpc_release(*(xpc_object_t *)(v2 + 16));
    *(_QWORD *)(v2 + 16) = 0;
    v6 = *(NSObject **)(v2 + 8);
    if (v6)
    {
      dispatch_group_leave(v6);
      v7 = *(NSObject **)(v2 + 8);
      if (v7)
        dispatch_release(v7);
    }
    MEMORY[0x2199FEAC4](v2, 0xA0C4059E6D2FFLL);
  }
  return a1;
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<AudioRoutingCommandDriver>::execute_wrapped<QMIAudioRoutingCommandDriver::shutdown(dispatch::group_session)::$_0>(QMIAudioRoutingCommandDriver::shutdown(dispatch::group_session)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIAudioRoutingCommandDriver::shutdown(dispatch::group_session)::$_0,dispatch_queue_s *::default_delete<QMIAudioRoutingCommandDriver::shutdown(dispatch::group_session)::$_0>>)::{lambda(void *)#1}::__invoke(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v4 = *a1;
  v9 = a1;
  v10 = v4;
  v5 = *(_QWORD *)v4;
  v6 = *(_QWORD *)(*(_QWORD *)v4 + 96);
  if (v6)
  {
    v11 = v6 + 88;
    v12 = 1;
    MEMORY[0x2199FDF3C](v6 + 88, a2, a3, a4);
    *(_BYTE *)(v6 + 74) = 0;
    std::unique_lock<ctu::UnfairLock>::~unique_lock[abi:ne180100]((uint64_t)&v11);
  }
  v7 = *(_QWORD *)(v5 + 120);
  if (v7)
  {
    v11 = v7 + 88;
    v12 = 1;
    MEMORY[0x2199FDF3C](v7 + 88, a2, a3, a4);
    *(_BYTE *)(v7 + 74) = 0;
    std::unique_lock<ctu::UnfairLock>::~unique_lock[abi:ne180100]((uint64_t)&v11);
  }
  std::unique_ptr<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0,std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>>::~unique_ptr[abi:ne180100](&v10);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v9);
}

void sub_216A2F534(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  std::unique_ptr<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0,std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>>::~unique_ptr[abi:ne180100](&a10);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<AudioRoutingCommandDriver>::execute_wrapped<QMIAudioRoutingCommandDriver::registered(std::shared_ptr<QMIVirtualClient>)::$_0>(QMIAudioRoutingCommandDriver::registered(std::shared_ptr<QMIVirtualClient>)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIAudioRoutingCommandDriver::registered(std::shared_ptr<QMIVirtualClient>)::$_0,std::default_delete<QMIAudioRoutingCommandDriver::registered(std::shared_ptr<QMIVirtualClient>)::$_0>>)::{lambda(void *)#1}::__invoke(_QWORD **a1)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  NSObject *v5;
  _QWORD **v7;
  _QWORD *v8;
  uint8_t buf[16];

  v1 = *a1;
  v7 = a1;
  v8 = v1;
  v2 = v1[2];
  v3 = *v1;
  if (v3 == *(_QWORD *)(v2 + 120))
  {
    *(_BYTE *)(v2 + 136) = 1;
    v5 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#I Voice client registered", buf, 2u);
    }
  }
  else if (v3 == *(_QWORD *)(v2 + 96))
  {
    v4 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I Audio client registered", buf, 2u);
    }
    *(_BYTE *)(v2 + 112) = 1;
  }
  if (*(_BYTE *)(v2 + 136) && *(_BYTE *)(v2 + 112))
    (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(v2 + 64) + 16))(*(_QWORD *)(v2 + 64), 1);
  std::unique_ptr<QMIPreferredNetworksCommandDriver::registered(std::shared_ptr<QMIVirtualClient>)::$_0,std::default_delete<QMIPreferredNetworksCommandDriver::registered(std::shared_ptr<QMIVirtualClient>)::$_0>>::~unique_ptr[abi:ne180100]((uint64_t *)&v8);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v7);
}

void sub_216A2F658(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  std::unique_ptr<QMIPreferredNetworksCommandDriver::registered(std::shared_ptr<QMIVirtualClient>)::$_0,std::default_delete<QMIPreferredNetworksCommandDriver::registered(std::shared_ptr<QMIVirtualClient>)::$_0>>::~unique_ptr[abi:ne180100](&a10);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

uint64_t *dispatch::async<void ctu::SharedSynchronizable<AudioRoutingCommandDriver>::execute_wrapped<QMIAudioRoutingCommandDriver::deregistered(std::shared_ptr<QMIVirtualClient>)::$_0>(QMIAudioRoutingCommandDriver::deregistered(std::shared_ptr<QMIVirtualClient>)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<QMIAudioRoutingCommandDriver::deregistered(std::shared_ptr<QMIVirtualClient>)::$_0,std::default_delete<QMIAudioRoutingCommandDriver::deregistered(std::shared_ptr<QMIVirtualClient>)::$_0>>)::{lambda(void *)#1}::__invoke(_QWORD **a1)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  NSObject *v5;
  _QWORD **v7;
  _QWORD *v8;
  uint8_t buf[16];

  v1 = *a1;
  v7 = a1;
  v8 = v1;
  v3 = *v1;
  v2 = v1[1];
  if (v2 == *(_QWORD *)(v3 + 120))
  {
    *(_BYTE *)(v3 + 136) = 0;
    v5 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_216897000, v5, OS_LOG_TYPE_DEFAULT, "#I Voice client deregistered", buf, 2u);
    }
  }
  else if (v2 == *(_QWORD *)(v3 + 96))
  {
    v4 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_216897000, v4, OS_LOG_TYPE_DEFAULT, "#I Audio client deregistered", buf, 2u);
    }
    *(_BYTE *)(v3 + 112) = 0;
  }
  if (!*(_BYTE *)(v3 + 136) && !*(_BYTE *)(v3 + 112))
    (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)(v3 + 64) + 16))(*(_QWORD *)(v3 + 64), 0);
  std::unique_ptr<QMIAudioRoutingCommandDriver::deregistered(std::shared_ptr<QMIVirtualClient>)::$_0,std::default_delete<QMIAudioRoutingCommandDriver::deregistered(std::shared_ptr<QMIVirtualClient>)::$_0>>::~unique_ptr[abi:ne180100]((uint64_t *)&v8);
  return std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v7);
}

void sub_216A2F770(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  std::unique_ptr<QMIAudioRoutingCommandDriver::deregistered(std::shared_ptr<QMIVirtualClient>)::$_0,std::default_delete<QMIAudioRoutingCommandDriver::deregistered(std::shared_ptr<QMIVirtualClient>)::$_0>>::~unique_ptr[abi:ne180100](&a10);
  std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

uint64_t *std::unique_ptr<QMIAudioRoutingCommandDriver::deregistered(std::shared_ptr<QMIVirtualClient>)::$_0,std::default_delete<QMIAudioRoutingCommandDriver::deregistered(std::shared_ptr<QMIVirtualClient>)::$_0>>::~unique_ptr[abi:ne180100](uint64_t *a1)
{
  uint64_t v2;

  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v2 + 8);
    MEMORY[0x2199FEAC4](v2, 0x20C40960023A9);
  }
  return a1;
}

void qmi::MutableMessageBase::TlvWrapper<audio::tlv::DownLinkPath>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<audio::tlv::DownLinkPath>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_PcoMcc>();
}

_WORD **qmi::MutableMessageBase::TlvWrapper<audio::tlv::DownLinkPath>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _WORD *v4;
  uint64_t v5;
  _WORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_WORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::Profile3GPP_PcoMcc>((_WORD **)a2, (_WORD *)(a1 + 10));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<audio::tlv::DownLinkPath>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E2408;
  *(_WORD *)(result + 10) = *(_WORD *)(a1 + 10);
  return result;
}

void qmi::MutableMessageBase::TlvWrapper<audio::tlv::UpLinkPath>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<audio::tlv::UpLinkPath>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_PcoMcc>();
}

_WORD **qmi::MutableMessageBase::TlvWrapper<audio::tlv::UpLinkPath>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _WORD *v4;
  uint64_t v5;
  _WORD **result;
  char *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_WORD *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::Profile3GPP_PcoMcc>((_WORD **)a2, (_WORD *)(a1 + 10));
  v7 = (char *)(*a2 - v5);
  *(_BYTE *)v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<audio::tlv::UpLinkPath>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E2458;
  *(_WORD *)(result + 10) = *(_WORD *)(a1 + 10);
  return result;
}

uint64_t ___ZN16QMIVirtualClient4sendIN5audio12SetAudioPath7RequestEU13block_pointerFvRKN3qmi12ResponseBaseEEEEvRKT_T0__block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void qmi::MutableMessageBase::TlvWrapper<audio::tlv::ttyStatus>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<audio::tlv::ttyStatus>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_PcoMcc>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<audio::tlv::ttyStatus>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::ProfileIdentifer>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<audio::tlv::ttyStatus>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E24F8;
  *(_WORD *)(result + 9) = *(_WORD *)(a1 + 9);
  return result;
}

uint64_t ___ZN16QMIVirtualClient4sendIN5audio6SetTTY7RequestEU13block_pointerFvRKN3qmi12ResponseBaseEEEEvRKT_T0__block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t qmi::MutableMessageBase::getTLV<vs::tlv::TtyMode>(_QWORD *a1, int a2)
{
  const void **v2;
  const void **v3;
  void *v4;

  v2 = (const void **)a1[1];
  v3 = (const void **)a1[2];
  if (v2 != v3)
  {
    while (*((unsigned __int8 *)*v2 + 8) != a2)
    {
      if (++v2 == v3)
        return qmi::MutableMessageBase::createTLV<vs::tlv::TtyMode>(a1, a2);
    }
  }
  if (v2 == v3)
    return qmi::MutableMessageBase::createTLV<vs::tlv::TtyMode>(a1, a2);
  if (!v4)
    __cxa_bad_cast();
  return (uint64_t)v4 + 9;
}

uint64_t qmi::MutableMessageBase::createTLV<vs::tlv::TtyMode>(_QWORD *a1, char a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v4 = operator new();
  *(_BYTE *)(v4 + 8) = a2;
  *(_BYTE *)(v4 + 9) = 0;
  *(_QWORD *)v4 = &off_24D5E2570;
  v5 = a1[3];
  v6 = (uint64_t *)a1[2];
  if ((unint64_t)v6 >= v5)
  {
    v8 = a1[1];
    v9 = ((uint64_t)v6 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61)
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    v10 = v5 - v8;
    v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1))
      v11 = v9 + 1;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)(a1 + 3), v12);
    else
      v13 = 0;
    v14 = (uint64_t *)&v13[8 * v9];
    v15 = &v13[8 * v12];
    *v14 = v4;
    v7 = v14 + 1;
    v17 = (char *)a1[1];
    v16 = (char *)a1[2];
    if (v16 != v17)
    {
      do
      {
        v18 = *((_QWORD *)v16 - 1);
        v16 -= 8;
        *--v14 = v18;
      }
      while (v16 != v17);
      v16 = (char *)a1[1];
    }
    a1[1] = v14;
    a1[2] = v7;
    a1[3] = v15;
    if (v16)
      operator delete(v16);
  }
  else
  {
    *v6 = v4;
    v7 = v6 + 1;
  }
  a1[2] = v7;
  return v4 + 9;
}

void qmi::MutableMessageBase::TlvWrapper<vs::tlv::TtyMode>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<vs::tlv::TtyMode>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<vs::tlv::TtyMode>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<vs::tlv::TtyMode>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E2570;
  return result;
}

uint64_t ___ZN16QMIVirtualClient4sendIN2vs9SetConfig7RequestEU13block_pointerFvRKN3qmi12ResponseBaseEEEEvRKT_T0__block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void qmi::MutableMessageBase::TlvWrapper<audio::tlv::MuteStatus>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<audio::tlv::MuteStatus>::getSize()
{
  return tlv::size<wds::tlv::IPPref>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<audio::tlv::MuteStatus>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::LocalAbort>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<audio::tlv::MuteStatus>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_WORD *)(result + 8) = *(_WORD *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E25E8;
  return result;
}

uint64_t ___ZN16QMIVirtualClient4sendIN5audio13SetMuteStatus7RequestEU13block_pointerFvRKN3qmi12ResponseBaseEEEEvRKT_T0__block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void qmi::MutableMessageBase::TlvWrapper<audio::tlv::VolumeInfo>::~TlvWrapper()
{
  JUMPOUT(0x2199FEAC4);
}

uint64_t qmi::MutableMessageBase::TlvWrapper<audio::tlv::VolumeInfo>::getSize()
{
  return tlv::size<wds::tlv::Profile3GPP_PcoMcc>();
}

_BYTE **qmi::MutableMessageBase::TlvWrapper<audio::tlv::VolumeInfo>::write(uint64_t a1, uint64_t *a2)
{
  char v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE **result;
  _BYTE *v7;

  v3 = *(_BYTE *)(a1 + 8);
  v4 = (_BYTE *)*a2;
  v5 = *a2 + 3;
  *a2 = v5;
  result = tlv::writeV<wds::tlv::ProfileIdentifer>((_BYTE **)a2, (_BYTE *)(a1 + 9));
  v7 = (_BYTE *)(*a2 - v5);
  *v4 = v3;
  *(_WORD *)(v4 + 1) = (_WORD)v7;
  return result;
}

uint64_t qmi::MutableMessageBase::TlvWrapper<audio::tlv::VolumeInfo>::clone(uint64_t a1)
{
  uint64_t result;

  result = operator new();
  *(_BYTE *)(result + 8) = *(_BYTE *)(a1 + 8);
  *(_QWORD *)result = &off_24D5E2660;
  *(_WORD *)(result + 9) = *(_WORD *)(a1 + 9);
  return result;
}

uint64_t ___ZN16QMIVirtualClient4sendIN5audio9SetVolume7RequestEU13block_pointerFvRKN3qmi12ResponseBaseEEEEvRKT_T0__block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void QMIDataFactoryCommandDriver::create(uint64_t *a1@<X0>, NSObject **a2@<X1>, uint64_t *a3@<X8>)
{
  _QWORD *v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  NSObject *v11;
  unint64_t *v12;
  unint64_t v13;
  dispatch_object_t object;
  _QWORD v15[2];

  v6 = (_QWORD *)operator new();
  v7 = *a1;
  v8 = (std::__shared_weak_count *)a1[1];
  v15[0] = v7;
  v15[1] = v8;
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
  }
  v11 = *a2;
  object = v11;
  if (v11)
    dispatch_retain(v11);
  QMIDataFactoryCommandDriver::QMIDataFactoryCommandDriver(v6, v15, &object);
  *a3 = 0;
  a3[1] = 0;
  std::shared_ptr<QMIDataFactoryCommandDriver>::shared_ptr[abi:ne180100]<QMIDataFactoryCommandDriver,std::shared_ptr<QMIDataFactoryCommandDriver> ctu::SharedSynchronizable<QMIDataFactoryCommandDriver>::make_shared_ptr<QMIDataFactoryCommandDriver>(QMIDataFactoryCommandDriver*)::{lambda(QMIDataFactoryCommandDriver*)#1},void>(a3, (uint64_t)v6);
  if (object)
    dispatch_release(object);
  if (v8)
  {
    v12 = (unint64_t *)&v8->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
}

void sub_216A2FF2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, char a11)
{
  uint64_t v11;
  int v12;

  if (object)
    dispatch_release(object);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  if (v12)
    MEMORY[0x2199FEAC4](v11, 0x10E1C40A35CF5D2);
  _Unwind_Resume(a1);
}

_QWORD *QMIDataFactoryCommandDriver::QMIDataFactoryCommandDriver(_QWORD *a1, _QWORD *a2, NSObject **a3)
{
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  _BYTE v10[16];

  *a1 = MEMORY[0x24BDC4618] + 16;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)v10, (const char *)*MEMORY[0x24BDC3E90], "DATA.QMIFactory");
  ctu::SharedLoggable<QMIDataFactoryCommandDriver,ctu::OsLogLogger>::SharedLoggable<ctu::OsLogContext>(a1 + 1, a3);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v10);
  a1[7] = 0;
  a1[8] = 0;
  *a1 = &off_24D5E26C0;
  a1[6] = &unk_24D5E2710;
  a1[9] = *a2;
  v6 = a2[1];
  a1[10] = v6;
  if (v6)
  {
    v7 = (unint64_t *)(v6 + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  a1[13] = 0;
  a1[12] = 0;
  a1[11] = a1 + 12;
  return a1;
}

void sub_216A30034(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  BBDataFactoryCommandDriver *v9;

  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&a9);
  BBDataFactoryCommandDriver::~BBDataFactoryCommandDriver(v9);
  _Unwind_Resume(a1);
}

_QWORD *ctu::SharedLoggable<QMIDataFactoryCommandDriver,ctu::OsLogLogger>::SharedLoggable<ctu::OsLogContext>(_QWORD *a1, NSObject **a2)
{
  NSObject *v3;
  _BYTE v5[8];

  *a1 = 0;
  a1[1] = 0;
  v3 = *a2;
  a1[2] = *a2;
  if (v3)
    dispatch_retain(v3);
  a1[3] = 0;
  ctu::OsLogLogger::OsLogLogger();
  ctu::OsLogLogger::OsLogLogger();
  MEMORY[0x2199FDF6C](v5);
  return a1;
}

void QMIDataFactoryCommandDriver::~QMIDataFactoryCommandDriver(QMIDataFactoryCommandDriver *this)
{
  BBDataCommandDriverEventHandler *v2;

  *(_QWORD *)this = &off_24D5E26C0;
  *((_QWORD *)this + 6) = &unk_24D5E2710;
  v2 = (QMIDataFactoryCommandDriver *)((char *)this + 48);
  std::__tree<std::__value_type<subscriber::SimSlot,std::shared_ptr<Mav20PreferredNetworksCommandDriver>>,std::__map_value_compare<subscriber::SimSlot,std::__value_type<subscriber::SimSlot,std::shared_ptr<Mav20PreferredNetworksCommandDriver>>,std::less<subscriber::SimSlot>,true>,std::allocator<std::__value_type<subscriber::SimSlot,std::shared_ptr<Mav20PreferredNetworksCommandDriver>>>>::destroy(*((_QWORD **)this + 12));
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)this + 72);
  BBDataCommandDriverEventHandler::~BBDataCommandDriverEventHandler(v2);
  MEMORY[0x2199FDF6C]((char *)this + 40);
  ctu::SharedSynchronizable<QMIDataSystemDeterminationManager>::~SharedSynchronizable((_QWORD *)this + 1);
  BBDataFactoryCommandDriver::~BBDataFactoryCommandDriver(this);
}

{
  QMIDataFactoryCommandDriver::~QMIDataFactoryCommandDriver(this);
  JUMPOUT(0x2199FEAC4);
}

void `non-virtual thunk to'QMIDataFactoryCommandDriver::~QMIDataFactoryCommandDriver(QMIDataFactoryCommandDriver *this)
{
  QMIDataFactoryCommandDriver::~QMIDataFactoryCommandDriver((QMIDataFactoryCommandDriver *)((char *)this - 48));
}

{
  QMIDataFactoryCommandDriver::~QMIDataFactoryCommandDriver((QMIDataFactoryCommandDriver *)((char *)this - 48));
  JUMPOUT(0x2199FEAC4);
}

void QMIDataFactoryCommandDriver::createDataCommandDriver(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t **a3@<X8>)
{
  int v6;
  uint64_t v7;
  uint64_t **v8;
  uint64_t v9;
  int v10;
  BOOL v11;
  uint64_t *v12;
  uint64_t **v13;
  uint64_t *v14;
  uint64_t *v15;
  uint64_t *v16;
  unint64_t *v17;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *p_shared_owners;
  unint64_t v21;
  NSObject *v22;
  unint64_t *v23;
  unint64_t v24;
  uint64_t *v25;
  std::__shared_weak_count *v26;
  std::__shared_weak_count *v27;
  uint64_t v28;
  unint64_t *v29;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  uint64_t **v37;
  uint64_t *v38;
  uint64_t *v39;
  unint64_t *v40;
  unint64_t v41;
  std::__shared_weak_count *v42;
  unint64_t *v43;
  unint64_t v44;
  uint64_t *v45;
  uint64_t *v46;
  uint64_t v47;
  std::__shared_weak_count *v48;
  uint64_t v49;
  std::__shared_weak_count *v50;
  NSObject *v51;
  uint64_t v52[2];
  uint64_t *v53;
  uint64_t *v54;
  int v55;

  v6 = *(_DWORD *)(*(_QWORD *)a2 + 52);
  v55 = v6;
  v7 = *(_QWORD *)(a1 + 96);
  v8 = (uint64_t **)(a1 + 88);
  if (!v7)
    goto LABEL_19;
  v9 = a1 + 96;
  do
  {
    v10 = *(_DWORD *)(v7 + 32);
    v11 = v10 < v6;
    if (v10 >= v6)
      v12 = (uint64_t *)v7;
    else
      v12 = (uint64_t *)(v7 + 8);
    if (!v11)
      v9 = v7;
    v7 = *v12;
  }
  while (*v12);
  if (v9 != a1 + 96
    && v6 >= *(_DWORD *)(v9 + 32)
    && std::__tree<std::__value_type<subscriber::SimSlot,std::shared_ptr<QMIDataCommandDriverInterface>>,std::__map_value_compare<subscriber::SimSlot,std::__value_type<subscriber::SimSlot,std::shared_ptr<QMIDataCommandDriverInterface>>,std::less<subscriber::SimSlot>,true>,std::allocator<std::__value_type<subscriber::SimSlot,std::shared_ptr<QMIDataCommandDriverInterface>>>>::__emplace_unique_key_args<subscriber::SimSlot,std::piecewise_construct_t const&,std::tuple<subscriber::SimSlot const&>,std::tuple<>>((uint64_t **)(a1 + 88), v6, &v55)[5])
  {
    v13 = std::__tree<std::__value_type<subscriber::SimSlot,std::shared_ptr<QMIDataCommandDriverInterface>>,std::__map_value_compare<subscriber::SimSlot,std::__value_type<subscriber::SimSlot,std::shared_ptr<QMIDataCommandDriverInterface>>,std::less<subscriber::SimSlot>,true>,std::allocator<std::__value_type<subscriber::SimSlot,std::shared_ptr<QMIDataCommandDriverInterface>>>>::__emplace_unique_key_args<subscriber::SimSlot,std::piecewise_construct_t const&,std::tuple<subscriber::SimSlot const&>,std::tuple<>>(v8, v6, &v55);
    v15 = v13[5];
    v14 = v13[6];
    if (v15)
      v16 = v15 + 1;
    else
      v16 = 0;
    *a3 = v16;
    a3[1] = v14;
    if (v14)
    {
      v17 = (unint64_t *)(v14 + 1);
      do
        v18 = __ldxr(v17);
      while (__stxr(v18 + 1, v17));
    }
  }
  else
  {
LABEL_19:
    v53 = 0;
    v54 = 0;
    v19 = *(std::__shared_weak_count **)(a1 + 80);
    v52[0] = *(_QWORD *)(a1 + 72);
    v52[1] = (uint64_t)v19;
    if (v19)
    {
      p_shared_owners = (unint64_t *)&v19->__shared_owners_;
      do
        v21 = __ldxr(p_shared_owners);
      while (__stxr(v21 + 1, p_shared_owners));
    }
    v22 = *(NSObject **)(a1 + 24);
    v51 = v22;
    if (v22)
      dispatch_retain(v22);
    QMIDataCommandDriverInterface::create(v52, a2, &v51, &v53);
    if (v22)
      dispatch_release(v22);
    if (v19)
    {
      v23 = (unint64_t *)&v19->__shared_owners_;
      do
        v24 = __ldaxr(v23);
      while (__stlxr(v24 - 1, v23));
      if (!v24)
      {
        ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
        std::__shared_weak_count::__release_weak(v19);
      }
    }
    v25 = v53;
    if (v53)
    {
      v49 = 0;
      v50 = 0;
      v26 = *(std::__shared_weak_count **)(a1 + 64);
      if (v26)
      {
        v27 = std::__shared_weak_count::lock(v26);
        v50 = v27;
        if (v27)
        {
          v28 = *(_QWORD *)(a1 + 56);
          v49 = v28;
          if (v28)
          {
            v47 = v28;
            v48 = v27;
            v29 = (unint64_t *)&v27->__shared_owners_;
            do
              v30 = __ldxr(v29);
            while (__stxr(v30 + 1, v29));
            (*(void (**)(uint64_t *, uint64_t *))(*v25 + 136))(v25, &v47);
            v31 = v48;
            if (v48)
            {
              v32 = (unint64_t *)&v48->__shared_owners_;
              do
                v33 = __ldaxr(v32);
              while (__stlxr(v33 - 1, v32));
              if (!v33)
              {
                ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
                std::__shared_weak_count::__release_weak(v31);
              }
            }
          }
        }
      }
      v34 = v50;
      if (v50)
      {
        v35 = (unint64_t *)&v50->__shared_owners_;
        do
          v36 = __ldaxr(v35);
        while (__stlxr(v36 - 1, v35));
        if (!v36)
        {
          ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
          std::__shared_weak_count::__release_weak(v34);
        }
      }
    }
    v37 = std::__tree<std::__value_type<subscriber::SimSlot,std::shared_ptr<QMIDataCommandDriverInterface>>,std::__map_value_compare<subscriber::SimSlot,std::__value_type<subscriber::SimSlot,std::shared_ptr<QMIDataCommandDriverInterface>>,std::less<subscriber::SimSlot>,true>,std::allocator<std::__value_type<subscriber::SimSlot,std::shared_ptr<QMIDataCommandDriverInterface>>>>::__emplace_unique_key_args<subscriber::SimSlot,std::piecewise_construct_t const&,std::tuple<subscriber::SimSlot const&>,std::tuple<>>(v8, v55, &v55);
    v39 = v53;
    v38 = v54;
    if (v54)
    {
      v40 = (unint64_t *)(v54 + 1);
      do
        v41 = __ldxr(v40);
      while (__stxr(v41 + 1, v40));
    }
    v42 = (std::__shared_weak_count *)v37[6];
    v37[5] = v39;
    v37[6] = v38;
    if (v42)
    {
      v43 = (unint64_t *)&v42->__shared_owners_;
      do
        v44 = __ldaxr(v43);
      while (__stlxr(v44 - 1, v43));
      if (!v44)
      {
        ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
        std::__shared_weak_count::__release_weak(v42);
      }
    }
    v45 = v54;
    if (v53)
      v46 = v53 + 1;
    else
      v46 = 0;
    *a3 = v46;
    a3[1] = v45;
  }
}

void sub_216A30450(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a16);
  _Unwind_Resume(a1);
}

void QMIDataFactoryCommandDriver::createContextDriver(_QWORD *a1@<X0>, uint64_t *a2@<X2>, _QWORD *a3@<X3>, _QWORD *a4@<X8>)
{
  uint64_t v8;
  int v9;
  uint64_t *v10;
  _QWORD *v11;
  uint64_t v12;
  int v13;
  BOOL v14;
  uint64_t *v15;
  int v16;
  std::__shared_weak_count *v17;
  uint64_t v18;
  unint64_t *p_shared_owners;
  unint64_t v20;
  unint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  NSObject *v25;
  uint64_t v26;
  unint64_t *v27;
  unint64_t v28;
  std::__shared_weak_count *v29;
  unint64_t *v30;
  unint64_t v31;
  unint64_t *v32;
  unint64_t v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  std::__shared_weak_count *v37;
  unint64_t *v38;
  unint64_t v39;
  std::__shared_weak_count *v40;
  unint64_t *v41;
  unint64_t v42;
  std::__shared_weak_count *v43;
  unint64_t *v44;
  unint64_t v45;
  std::__shared_weak_count *v46;
  unint64_t *v47;
  unint64_t v48;
  std::__shared_weak_count *v49;
  unint64_t *v50;
  unint64_t v51;
  uint64_t v52;
  std::__shared_weak_count *v53;
  _QWORD *v54;
  std::__shared_weak_count *v55;
  uint64_t v56;
  std::__shared_weak_count *v57;
  dispatch_object_t object;
  uint64_t v59;
  std::__shared_weak_count *v60;
  uint64_t v61;
  std::__shared_weak_count *v62;
  __int128 v63;
  uint64_t v64;
  std::__shared_weak_count *v65;

  v8 = *a3 + *(_QWORD *)(*(_QWORD *)*a3 - 56);
  v9 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v8 + 24))(v8);
  v10 = (uint64_t *)a1[12];
  if (!v10)
    goto LABEL_11;
  v11 = a1 + 12;
  v12 = a1[12];
  do
  {
    v13 = *(_DWORD *)(v12 + 32);
    v14 = v13 < v9;
    if (v13 >= v9)
      v15 = (uint64_t *)v12;
    else
      v15 = (uint64_t *)(v12 + 8);
    if (!v14)
      v11 = (_QWORD *)v12;
    v12 = *v15;
  }
  while (*v15);
  if (v11 == a1 + 12 || v9 < *((_DWORD *)v11 + 8))
    goto LABEL_11;
  while (1)
  {
    while (1)
    {
      v16 = *((_DWORD *)v10 + 8);
      if (v16 <= v9)
        break;
      v10 = (uint64_t *)*v10;
      if (!v10)
        goto LABEL_18;
    }
    if (v16 >= v9)
      break;
    v10 = (uint64_t *)v10[1];
    if (!v10)
LABEL_18:
      std::__throw_out_of_range[abi:ne180100]("map::at:  key not found");
  }
  v18 = v10[5];
  v17 = (std::__shared_weak_count *)v10[6];
  v64 = v18;
  v65 = v17;
  if (v17)
  {
    p_shared_owners = (unint64_t *)&v17->__shared_owners_;
    do
      v20 = __ldxr(p_shared_owners);
    while (__stxr(v20 + 1, p_shared_owners));
    if (!v18)
    {
      do
        v21 = __ldaxr(p_shared_owners);
      while (__stlxr(v21 - 1, p_shared_owners));
      if (!v21)
      {
        ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
        std::__shared_weak_count::__release_weak(v17);
      }
      goto LABEL_11;
    }
  }
  else if (!v18)
  {
LABEL_11:
    *a4 = 0;
    a4[1] = 0;
    return;
  }
  v22 = (std::__shared_weak_count *)a1[10];
  v61 = a1[9];
  v62 = v22;
  if (v22)
  {
    v23 = (unint64_t *)&v22->__shared_owners_;
    do
      v24 = __ldxr(v23);
    while (__stxr(v24 + 1, v23));
  }
  (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)(*a3 + *(_QWORD *)(*(_QWORD *)*a3 - 56)) + 16))(&v59);
  v25 = a1[3];
  object = v25;
  if (v25)
    dispatch_retain(v25);
  v26 = a2[1];
  v56 = *a2;
  v57 = (std::__shared_weak_count *)v26;
  if (v26)
  {
    v27 = (unint64_t *)(v26 + 8);
    do
      v28 = __ldxr(v27);
    while (__stxr(v28 + 1, v27));
  }
  v29 = (std::__shared_weak_count *)a3[1];
  v54 = (_QWORD *)*a3;
  v55 = v29;
  if (v29)
  {
    v30 = (unint64_t *)&v29->__shared_owners_;
    do
      v31 = __ldxr(v30);
    while (__stxr(v31 + 1, v30));
  }
  v52 = v18 + 8;
  v53 = v17;
  if (v17)
  {
    v32 = (unint64_t *)&v17->__shared_owners_;
    do
      v33 = __ldxr(v32);
    while (__stxr(v33 + 1, v32));
  }
  QMIDataContextDriverInterface::create(&v61, &object, &v56, (uint64_t *)&v54, (uint64_t)&v52, 0, &v63);
  *(_OWORD *)a4 = v63;
  v63 = 0uLL;
  v34 = v53;
  if (v53)
  {
    v35 = (unint64_t *)&v53->__shared_owners_;
    do
      v36 = __ldaxr(v35);
    while (__stlxr(v36 - 1, v35));
    if (!v36)
    {
      ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
      std::__shared_weak_count::__release_weak(v34);
    }
  }
  v37 = v55;
  if (v55)
  {
    v38 = (unint64_t *)&v55->__shared_owners_;
    do
      v39 = __ldaxr(v38);
    while (__stlxr(v39 - 1, v38));
    if (!v39)
    {
      ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
      std::__shared_weak_count::__release_weak(v37);
    }
  }
  v40 = v57;
  if (v57)
  {
    v41 = (unint64_t *)&v57->__shared_owners_;
    do
      v42 = __ldaxr(v41);
    while (__stlxr(v42 - 1, v41));
    if (!v42)
    {
      ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
      std::__shared_weak_count::__release_weak(v40);
    }
  }
  if (object)
    dispatch_release(object);
  v43 = v60;
  if (v60)
  {
    v44 = (unint64_t *)&v60->__shared_owners_;
    do
      v45 = __ldaxr(v44);
    while (__stlxr(v45 - 1, v44));
    if (!v45)
    {
      ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
      std::__shared_weak_count::__release_weak(v43);
    }
  }
  v46 = v62;
  if (v62)
  {
    v47 = (unint64_t *)&v62->__shared_owners_;
    do
      v48 = __ldaxr(v47);
    while (__stlxr(v48 - 1, v47));
    if (!v48)
    {
      ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
      std::__shared_weak_count::__release_weak(v46);
    }
  }
  v49 = v65;
  if (v65)
  {
    v50 = (unint64_t *)&v65->__shared_owners_;
    do
      v51 = __ldaxr(v50);
    while (__stlxr(v51 - 1, v50));
    if (!v51)
    {
      ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
      std::__shared_weak_count::__release_weak(v49);
    }
  }
}

void sub_216A30814(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12, uint64_t a13, char a14, uint64_t a15, dispatch_object_t object, char a17, uint64_t a18, char a19)
{
  uint64_t v19;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a10);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a12);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a14);
  if (object)
    dispatch_release(object);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a17);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a19);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v19 - 80);
  _Unwind_Resume(a1);
}

std::__shared_weak_count *QMIDataFactoryCommandDriver::createEventHandler@<X0>(QMIDataFactoryCommandDriver *this@<X0>, _QWORD *a2@<X8>)
{
  std::__shared_weak_count *v3;
  uint64_t v5;
  std::__shared_weak_count *result;
  uint64_t v7;

  v3 = (std::__shared_weak_count *)*((_QWORD *)this + 2);
  if (!v3 || (v5 = *((_QWORD *)this + 1), (result = std::__shared_weak_count::lock(v3)) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v7 = v5 + 48;
  if (!v5)
    v7 = 0;
  *a2 = v7;
  a2[1] = result;
  return result;
}

void QMIDataFactoryCommandDriver::bootstrapDataCommandDriverEventHandler(QMIDataFactoryCommandDriver *this)
{
  char *v1;
  char *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  char *v9;
  char *v10;
  BOOL v11;

  v1 = (char *)*((_QWORD *)this + 11);
  v2 = (char *)this + 96;
  if (v1 != (char *)this + 96)
  {
    do
    {
      v3 = *((_QWORD *)v1 + 5);
      v4 = (std::__shared_weak_count *)*((_QWORD *)v1 + 6);
      if (v4)
      {
        p_shared_owners = (unint64_t *)&v4->__shared_owners_;
        do
          v6 = __ldxr(p_shared_owners);
        while (__stxr(v6 + 1, p_shared_owners));
      }
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 80))(v3);
      if (v4)
      {
        v7 = (unint64_t *)&v4->__shared_owners_;
        do
          v8 = __ldaxr(v7);
        while (__stlxr(v8 - 1, v7));
        if (!v8)
        {
          ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
          std::__shared_weak_count::__release_weak(v4);
        }
      }
      v9 = (char *)*((_QWORD *)v1 + 1);
      if (v9)
      {
        do
        {
          v10 = v9;
          v9 = *(char **)v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          v10 = (char *)*((_QWORD *)v1 + 2);
          v11 = *(_QWORD *)v10 == (_QWORD)v1;
          v1 = v10;
        }
        while (!v11);
      }
      v1 = v10;
    }
    while (v10 != v2);
  }
}

void sub_216A30990(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'QMIDataFactoryCommandDriver::bootstrapDataCommandDriverEventHandler(QMIDataFactoryCommandDriver *this)
{
  QMIDataFactoryCommandDriver::bootstrapDataCommandDriverEventHandler((QMIDataFactoryCommandDriver *)((char *)this - 48));
}

void QMIDataFactoryCommandDriver::startDataCommandDriverEventHandler(QMIDataFactoryCommandDriver *this)
{
  char *v1;
  char *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  char *v9;
  char *v10;
  BOOL v11;

  v1 = (char *)*((_QWORD *)this + 11);
  v2 = (char *)this + 96;
  if (v1 != (char *)this + 96)
  {
    do
    {
      v3 = *((_QWORD *)v1 + 5);
      v4 = (std::__shared_weak_count *)*((_QWORD *)v1 + 6);
      if (v4)
      {
        p_shared_owners = (unint64_t *)&v4->__shared_owners_;
        do
          v6 = __ldxr(p_shared_owners);
        while (__stxr(v6 + 1, p_shared_owners));
      }
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 88))(v3);
      if (v4)
      {
        v7 = (unint64_t *)&v4->__shared_owners_;
        do
          v8 = __ldaxr(v7);
        while (__stlxr(v8 - 1, v7));
        if (!v8)
        {
          ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
          std::__shared_weak_count::__release_weak(v4);
        }
      }
      v9 = (char *)*((_QWORD *)v1 + 1);
      if (v9)
      {
        do
        {
          v10 = v9;
          v9 = *(char **)v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          v10 = (char *)*((_QWORD *)v1 + 2);
          v11 = *(_QWORD *)v10 == (_QWORD)v1;
          v1 = v10;
        }
        while (!v11);
      }
      v1 = v10;
    }
    while (v10 != v2);
  }
}

void sub_216A30A90(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'QMIDataFactoryCommandDriver::startDataCommandDriverEventHandler(QMIDataFactoryCommandDriver *this)
{
  QMIDataFactoryCommandDriver::startDataCommandDriverEventHandler((QMIDataFactoryCommandDriver *)((char *)this - 48));
}

void QMIDataFactoryCommandDriver::stopDataCommandDriverEventHandler(QMIDataFactoryCommandDriver *this)
{
  char *v1;
  char *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  char *v9;
  char *v10;
  BOOL v11;

  v1 = (char *)*((_QWORD *)this + 11);
  v2 = (char *)this + 96;
  if (v1 != (char *)this + 96)
  {
    do
    {
      v3 = *((_QWORD *)v1 + 5);
      v4 = (std::__shared_weak_count *)*((_QWORD *)v1 + 6);
      if (v4)
      {
        p_shared_owners = (unint64_t *)&v4->__shared_owners_;
        do
          v6 = __ldxr(p_shared_owners);
        while (__stxr(v6 + 1, p_shared_owners));
      }
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 96))(v3);
      if (v4)
      {
        v7 = (unint64_t *)&v4->__shared_owners_;
        do
          v8 = __ldaxr(v7);
        while (__stlxr(v8 - 1, v7));
        if (!v8)
        {
          ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
          std::__shared_weak_count::__release_weak(v4);
        }
      }
      v9 = (char *)*((_QWORD *)v1 + 1);
      if (v9)
      {
        do
        {
          v10 = v9;
          v9 = *(char **)v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          v10 = (char *)*((_QWORD *)v1 + 2);
          v11 = *(_QWORD *)v10 == (_QWORD)v1;
          v1 = v10;
        }
        while (!v11);
      }
      v1 = v10;
    }
    while (v10 != v2);
  }
}

void sub_216A30B90(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'QMIDataFactoryCommandDriver::stopDataCommandDriverEventHandler(QMIDataFactoryCommandDriver *this)
{
  QMIDataFactoryCommandDriver::stopDataCommandDriverEventHandler((QMIDataFactoryCommandDriver *)((char *)this - 48));
}

uint64_t *std::shared_ptr<QMIDataFactoryCommandDriver>::shared_ptr[abi:ne180100]<QMIDataFactoryCommandDriver,std::shared_ptr<QMIDataFactoryCommandDriver> ctu::SharedSynchronizable<QMIDataFactoryCommandDriver>::make_shared_ptr<QMIDataFactoryCommandDriver>(QMIDataFactoryCommandDriver*)::{lambda(QMIDataFactoryCommandDriver*)#1},void>(uint64_t *a1, uint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24D5E2800;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = (uint64_t)v4;
  if (a2)
    v5 = (_QWORD *)(a2 + 8);
  else
    v5 = 0;
  std::shared_ptr<QMIDataSystemDeterminationManager>::__enable_weak_this[abi:ne180100]<QMIDataSystemDeterminationManager,QMIDataSystemDeterminationManager,void>((uint64_t)a1, v5, a2);
  return a1;
}

void sub_216A30C18(void *a1)
{
  dispatch_queue_t *v1;

  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)std::shared_ptr<QMIDataFactoryCommandDriver> ctu::SharedSynchronizable<QMIDataFactoryCommandDriver>::make_shared_ptr<QMIDataFactoryCommandDriver>(QMIDataFactoryCommandDriver*)::{lambda(QMIDataFactoryCommandDriver*)#1}::operator() const(QMIDataFactoryCommandDriver*)::{lambda(void *)#1}::__invoke);
  __cxa_rethrow();
}

void sub_216A30C38(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<QMIDataFactoryCommandDriver *,std::shared_ptr<QMIDataFactoryCommandDriver> ctu::SharedSynchronizable<QMIDataFactoryCommandDriver>::make_shared_ptr<QMIDataFactoryCommandDriver>(QMIDataFactoryCommandDriver*)::{lambda(QMIDataFactoryCommandDriver *)#1},std::allocator<QMIDataFactoryCommandDriver>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199FEAC4);
}

void std::__shared_ptr_pointer<QMIDataFactoryCommandDriver *,std::shared_ptr<QMIDataFactoryCommandDriver> ctu::SharedSynchronizable<QMIDataFactoryCommandDriver>::make_shared_ptr<QMIDataFactoryCommandDriver>(QMIDataFactoryCommandDriver*)::{lambda(QMIDataFactoryCommandDriver *)#1},std::allocator<QMIDataFactoryCommandDriver>>::__on_zero_shared(uint64_t a1)
{
  dispatch_barrier_async_f(*(dispatch_queue_t *)(*(_QWORD *)(a1 + 24) + 24), *(void **)(a1 + 24), (dispatch_function_t)std::shared_ptr<QMIDataFactoryCommandDriver> ctu::SharedSynchronizable<QMIDataFactoryCommandDriver>::make_shared_ptr<QMIDataFactoryCommandDriver>(QMIDataFactoryCommandDriver*)::{lambda(QMIDataFactoryCommandDriver*)#1}::operator() const(QMIDataFactoryCommandDriver*)::{lambda(void *)#1}::__invoke);
}

uint64_t std::__shared_ptr_pointer<QMIDataFactoryCommandDriver *,std::shared_ptr<QMIDataFactoryCommandDriver> ctu::SharedSynchronizable<QMIDataFactoryCommandDriver>::make_shared_ptr<QMIDataFactoryCommandDriver>(QMIDataFactoryCommandDriver*)::{lambda(QMIDataFactoryCommandDriver *)#1},std::allocator<QMIDataFactoryCommandDriver>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t std::shared_ptr<QMIDataFactoryCommandDriver> ctu::SharedSynchronizable<QMIDataFactoryCommandDriver>::make_shared_ptr<QMIDataFactoryCommandDriver>(QMIDataFactoryCommandDriver*)::{lambda(QMIDataFactoryCommandDriver*)#1}::operator() const(QMIDataFactoryCommandDriver*)::{lambda(void *)#1}::__invoke(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t **std::__tree<std::__value_type<subscriber::SimSlot,std::shared_ptr<QMIDataCommandDriverInterface>>,std::__map_value_compare<subscriber::SimSlot,std::__value_type<subscriber::SimSlot,std::shared_ptr<QMIDataCommandDriverInterface>>,std::less<subscriber::SimSlot>,true>,std::allocator<std::__value_type<subscriber::SimSlot,std::shared_ptr<QMIDataCommandDriverInterface>>>>::__emplace_unique_key_args<subscriber::SimSlot,std::piecewise_construct_t const&,std::tuple<subscriber::SimSlot const&>,std::tuple<>>(uint64_t **a1, int a2, _DWORD *a3)
{
  uint64_t *v5;
  uint64_t **v6;
  uint64_t **v7;
  int v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t *v11;

  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v7 = (uint64_t **)v5;
        v8 = *((_DWORD *)v5 + 8);
        if (v8 <= a2)
          break;
        v5 = *v7;
        v6 = v7;
        if (!*v7)
          goto LABEL_9;
      }
      if (v8 >= a2)
        break;
      v5 = v7[1];
      if (!v5)
      {
        v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    v7 = a1 + 1;
LABEL_9:
    v9 = (uint64_t *)v7;
    v7 = (uint64_t **)operator new(0x38uLL);
    *((_DWORD *)v7 + 8) = *a3;
    v7[5] = 0;
    v7[6] = 0;
    *v7 = 0;
    v7[1] = 0;
    v7[2] = v9;
    *v6 = (uint64_t *)v7;
    v10 = (uint64_t *)**a1;
    v11 = (uint64_t *)v7;
    if (v10)
    {
      *a1 = v10;
      v11 = *v6;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

_QWORD *EurekaCallCommandDriver::EurekaCallCommandDriver(uint64_t a1, uint64_t a2, NSObject **a3, uint64_t a4, _QWORD *a5)
{
  capabilities::ct *v7;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  unsigned int **v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  uint64_t **v19;
  _QWORD *v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t **v23;
  uint64_t v24;
  uint64_t *v25;
  uint64_t *v26;
  uint64_t *v27;
  BOOL v28;
  int v29;
  uint64_t **v30;
  uint64_t **v31;
  uint64_t *v32;
  int v33;
  uint64_t *v34;
  _QWORD *v35;
  _QWORD *v36;
  uint64_t **v37;
  uint64_t *v38;
  _QWORD *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t *v42;
  uint64_t v43;
  uint64_t *v44;
  uint64_t *v45;
  uint64_t *v46;
  int v47;
  uint64_t **v48;
  uint64_t **v49;
  uint64_t *v50;
  int v51;
  uint64_t *v52;
  _QWORD *v53;
  _QWORD *v54;
  unsigned int *v55;
  unsigned int *v56;
  uint64_t (*v57)(_QWORD);
  unsigned int *v58;
  unsigned int *v59;
  _QWORD *v61;
  NSObject *object;
  _QWORD v63[3];
  _QWORD *v64;
  unsigned int *v65;
  unsigned int *v66;
  uint64_t (*v67)(_QWORD);
  unsigned int **v68;
  uint64_t v69;

  v69 = *MEMORY[0x24BDAC8D0];
  object = *a3;
  *a3 = 0;
  CallCommandDriver::CallCommandDriver();
  v7 = (capabilities::ct *)object;
  if (object)
    dispatch_release(object);
  v63[0] = &unk_24D5CCF40;
  v64 = v63;
  *(_QWORD *)(a1 + 112) = 0;
  if ((capabilities::ct::supportsGemini(v7) & 1) == 0)
  {
    v8 = (_QWORD *)operator new();
    *v8 = &off_24D5E3088;
    v8[1] = a1;
    v9 = *(_QWORD *)(a1 + 112);
    *(_QWORD *)(a1 + 112) = v8;
    if (!v9)
      goto LABEL_14;
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  }
  if (!*(_QWORD *)(a1 + 112))
  {
    v10 = (_QWORD *)operator new();
    std::__function::__value_func<char const* const ()(subscriber::SimSlot)>::__value_func[abi:ne180100]((uint64_t)&v65, (uint64_t)v63);
    SimInstanceLoggerDefault<ctu::OsLogLogger,subscriber::SimSlot,std::function<char const* const ()(subscriber::SimSlot)>>::SimInstanceLoggerDefault(v10);
    v11 = v68;
    if (v68 == &v65)
    {
      v12 = 4;
      v11 = &v65;
    }
    else
    {
      if (!v68)
        goto LABEL_12;
      v12 = 5;
    }
    (*(void (**)(void))&(*v11)[2 * v12])();
LABEL_12:
    v13 = *(_QWORD *)(a1 + 112);
    *(_QWORD *)(a1 + 112) = v10;
    if (v13)
      (*(void (**)(uint64_t))(*(_QWORD *)v13 + 8))(v13);
  }
LABEL_14:
  v14 = v64;
  if (v64 == v63)
  {
    v15 = 4;
    v14 = v63;
  }
  else
  {
    if (!v64)
      goto LABEL_19;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_19:
  *(_QWORD *)a1 = &off_24D5E2860;
  *(_QWORD *)(a1 + 120) = *a5;
  v16 = a5[1];
  *(_QWORD *)(a1 + 128) = v16;
  if (v16)
  {
    v17 = (unint64_t *)(v16 + 8);
    do
      v18 = __ldxr(v17);
    while (__stxr(v18 + 1, v17));
  }
  qmi::ClientRouter::ClientRouter((qmi::ClientRouter *)(a1 + 136), *(os_log_s **)(a1 + 40));
  qmi::ClientRouter::ClientRouter((qmi::ClientRouter *)(a1 + 152), *(os_log_s **)(a1 + 40));
  qmi::ClientRouter::ClientRouter((qmi::ClientRouter *)(a1 + 168), *(os_log_s **)(a1 + 40));
  *(_QWORD *)(a1 + 200) = 0;
  *(_QWORD *)(a1 + 192) = a1 + 200;
  *(_BYTE *)(a1 + 184) = 0;
  *(_QWORD *)(a1 + 208) = 0;
  *(_QWORD *)(a1 + 216) = 0;
  *(_QWORD *)(a1 + 240) = 0;
  *(_QWORD *)(a1 + 224) = 0;
  *(_QWORD *)(a1 + 232) = a1 + 240;
  *(_QWORD *)(a1 + 248) = 0;
  *(_QWORD *)(a1 + 264) = 0;
  v19 = (uint64_t **)(a1 + 264);
  *(_QWORD *)(a1 + 256) = a1 + 264;
  *(_QWORD *)(a1 + 272) = 0;
  v20 = (_QWORD *)*MEMORY[0x24BDC3978];
  if (*MEMORY[0x24BDC3978] != MEMORY[0x24BDC3978] + 8)
  {
    v21 = 0;
    v22 = MEMORY[0x24BDC3978] + 8;
    v23 = (uint64_t **)(a1 + 264);
    while (1)
    {
      v24 = *(_QWORD *)((char *)v20 + 28);
      v25 = (uint64_t *)(a1 + 264);
      if (v23 == v19)
        goto LABEL_30;
      v26 = v21;
      v27 = (uint64_t *)(a1 + 264);
      if (v21)
      {
        do
        {
          v25 = v26;
          v26 = (uint64_t *)v26[1];
        }
        while (v26);
      }
      else
      {
        do
        {
          v25 = (uint64_t *)v27[2];
          v28 = *v25 == (_QWORD)v27;
          v27 = v25;
        }
        while (v28);
      }
      v29 = *((_DWORD *)v20 + 7);
      if (*((_DWORD *)v25 + 7) < v29)
      {
LABEL_30:
        if (v21)
          v30 = (uint64_t **)v25;
        else
          v30 = (uint64_t **)(a1 + 264);
        if (v21)
          v31 = (uint64_t **)(v25 + 1);
        else
          v31 = (uint64_t **)(a1 + 264);
        if (!*v31)
        {
LABEL_46:
          v34 = (uint64_t *)operator new(0x28uLL);
          *(uint64_t *)((char *)v34 + 28) = v24;
          std::__tree<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::less<unsigned short>,true>,std::allocator<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>>>::__insert_node_at((uint64_t **)(a1 + 256), (uint64_t)v30, v31, v34);
        }
      }
      else
      {
        v31 = (uint64_t **)(a1 + 264);
        v30 = (uint64_t **)(a1 + 264);
        if (!v21)
          goto LABEL_46;
        v32 = v21;
        while (1)
        {
          while (1)
          {
            v30 = (uint64_t **)v32;
            v33 = *((_DWORD *)v32 + 7);
            if (v33 <= v29)
              break;
            v32 = *v30;
            v31 = v30;
            if (!*v30)
              goto LABEL_46;
          }
          if (v33 >= v29)
            break;
          v32 = v30[1];
          if (!v32)
          {
            v31 = v30 + 1;
            goto LABEL_46;
          }
        }
      }
      v35 = (_QWORD *)v20[1];
      if (v35)
      {
        do
        {
          v36 = v35;
          v35 = (_QWORD *)*v35;
        }
        while (v35);
      }
      else
      {
        do
        {
          v36 = (_QWORD *)v20[2];
          v28 = *v36 == (_QWORD)v20;
          v20 = v36;
        }
        while (!v28);
      }
      if (v36 == (_QWORD *)v22)
        break;
      v21 = *v19;
      v23 = *(uint64_t ***)(a1 + 256);
      v20 = v36;
    }
  }
  *(_QWORD *)(a1 + 288) = 0;
  *(_QWORD *)(a1 + 296) = 0;
  *(_QWORD *)(a1 + 280) = a1 + 288;
  *(_WORD *)(a1 + 304) = 0;
  v37 = (uint64_t **)(a1 + 312);
  v38 = (uint64_t *)(a1 + 320);
  *(_QWORD *)(a1 + 320) = 0;
  *(_QWORD *)(a1 + 328) = 0;
  v61 = (_QWORD *)a1;
  *(_QWORD *)(a1 + 312) = a1 + 320;
  v39 = (_QWORD *)*MEMORY[0x24BDC4418];
  if (*MEMORY[0x24BDC4418] != MEMORY[0x24BDC4418] + 8)
  {
    v40 = 0;
    v41 = MEMORY[0x24BDC4418] + 8;
    v42 = v38;
    while (1)
    {
      v43 = *(_QWORD *)((char *)v39 + 28);
      v44 = v38;
      if (v42 == v38)
        goto LABEL_62;
      v45 = (uint64_t *)v40;
      v46 = v38;
      if (v40)
      {
        do
        {
          v44 = v45;
          v45 = (uint64_t *)v45[1];
        }
        while (v45);
      }
      else
      {
        do
        {
          v44 = (uint64_t *)v46[2];
          v28 = *v44 == (_QWORD)v46;
          v46 = v44;
        }
        while (v28);
      }
      v47 = *((_DWORD *)v39 + 7);
      if (*((_DWORD *)v44 + 7) < v47)
      {
LABEL_62:
        if (v40)
          v48 = (uint64_t **)v44;
        else
          v48 = (uint64_t **)v38;
        if (v40)
          v49 = (uint64_t **)(v44 + 1);
        else
          v49 = (uint64_t **)v38;
        if (!*v49)
        {
LABEL_78:
          v52 = (uint64_t *)operator new(0x28uLL);
          *(uint64_t *)((char *)v52 + 28) = v43;
          std::__tree<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::less<unsigned short>,true>,std::allocator<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>>>::__insert_node_at(v37, (uint64_t)v48, v49, v52);
        }
      }
      else
      {
        v49 = (uint64_t **)v38;
        v48 = (uint64_t **)v38;
        if (!v40)
          goto LABEL_78;
        v50 = (uint64_t *)v40;
        while (1)
        {
          while (1)
          {
            v48 = (uint64_t **)v50;
            v51 = *((_DWORD *)v50 + 7);
            if (v51 <= v47)
              break;
            v50 = *v48;
            v49 = v48;
            if (!*v48)
              goto LABEL_78;
          }
          if (v51 >= v47)
            break;
          v50 = v48[1];
          if (!v50)
          {
            v49 = v48 + 1;
            goto LABEL_78;
          }
        }
      }
      v53 = (_QWORD *)v39[1];
      if (v53)
      {
        do
        {
          v54 = v53;
          v53 = (_QWORD *)*v53;
        }
        while (v53);
      }
      else
      {
        do
        {
          v54 = (_QWORD *)v39[2];
          v28 = *v54 == (_QWORD)v39;
          v39 = v54;
        }
        while (!v28);
      }
      if (v54 == (_QWORD *)v41)
        break;
      v40 = *v38;
      v42 = *v37;
      v39 = v54;
    }
  }
  v61[42] = v61 + 42;
  v61[43] = v61 + 42;
  v61[44] = 0;
  subscriber::makeSimSlotRange();
  v56 = v65;
  v55 = v66;
  if (v65 != v66)
  {
    v57 = v67;
    while ((v57(*v56) & 1) == 0)
    {
      if (++v56 == v55)
      {
        v56 = v55;
        break;
      }
    }
    v58 = v66;
LABEL_92:
    while (v56 != v58)
    {
      EurekaCallCommandDriver::fillUpDefaultCallCapabilities((uint64_t)v61, *v56);
      v59 = v56 + 1;
      v56 = v55;
      if (v59 != v55)
      {
        v56 = v59;
        while ((v57(*v56) & 1) == 0)
        {
          if (++v56 == v55)
          {
            v56 = v55;
            goto LABEL_92;
          }
        }
      }
    }
  }
  return v61;
}

void sub_216A31364(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,dispatch_object_t object,char a23,uint64_t a24,uint64_t a25,char *a26)
{
  _QWORD *v26;
  uint64_t v27;
  CallCommandDriver *v28;
  uint64_t v29;
  _QWORD *v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  uint64_t v34;

  v30 = *(_QWORD **)(v29 - 104);
  if (v30 == v26)
  {
    v31 = 4;
    v30 = (_QWORD *)(v29 - 128);
  }
  else
  {
    if (!v30)
      goto LABEL_6;
    v31 = 5;
  }
  (*(void (**)(void))(*v30 + 8 * v31))();
LABEL_6:
  MEMORY[0x2199FEAC4](v27, 0x10A1C40FF1576FELL);
  v32 = *((_QWORD *)v28 + 14);
  *((_QWORD *)v28 + 14) = 0;
  if (v32)
    (*(void (**)(uint64_t))(*(_QWORD *)v32 + 8))(v32);
  v33 = a26;
  if (a26 == &a23)
  {
    v34 = 4;
    v33 = &a23;
  }
  else
  {
    if (!a26)
      goto LABEL_13;
    v34 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v33 + 8 * v34))();
LABEL_13:
  CallCommandDriver::~CallCommandDriver(v28);
  _Unwind_Resume(a1);
}

uint64_t EurekaCallCommandDriver::fillUpDefaultCallCapabilities(uint64_t a1, uint64_t a2)
{
  int v4;

  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x24BDC3ED0], 1, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x24BDC3EC8], 2, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x24BDC3EF8], 0, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x24BDC3ED8], 0, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x24BDC3DB8], 0, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x24BDC3DB0], 0, a2);
  v4 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 120) + 352))(*(_QWORD *)(a1 + 120), a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x24BDC3DA0], v4 ^ 1, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x24BDC3EB0], 0, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x24BDC3EA8], 0, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x24BDC3EA0], 0, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x24BDC3EC0], 0, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x24BDC3F00], 0, a2);
  return EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x24BDC3EF0], 0, a2);
}

void EurekaCallCommandDriver::createQMIClients(EurekaCallCommandDriver *this)
{
  std::__shared_weak_count *v2;
  char *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  NSObject *v8;
  unint64_t *p_shared_weak_owners;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t *p_shared_owners;
  unint64_t v19;
  std::__shared_weak_count *v20;
  _DWORD *v21;
  _DWORD *v22;
  uint64_t (*v23)(_QWORD);
  char *v24;
  std::__shared_weak_count *v25;
  std::__shared_weak_count *v26;
  std::__shared_weak_count *v27;
  NSObject *v28;
  unint64_t *v29;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  unint64_t *v37;
  unint64_t v38;
  _DWORD *v39;
  _DWORD *v40;
  _DWORD *v41;
  uint64_t (*v42)(_QWORD);
  char *v43;
  std::__shared_weak_count *v44;
  std::__shared_weak_count *v45;
  std::__shared_weak_count *v46;
  unint64_t *v47;
  unint64_t v48;
  unint64_t *v49;
  unint64_t v50;
  NSObject *v51;
  std::__shared_weak_count *v52;
  std::__shared_weak_count *v53;
  unint64_t *v54;
  unint64_t v55;
  unint64_t *v56;
  unint64_t v57;
  std::__shared_weak_count *v58;
  unint64_t *v59;
  unint64_t v60;
  std::__shared_weak_count *v61;
  unint64_t *v62;
  unint64_t v63;
  _DWORD *v64;
  char *v65;
  _DWORD *v66;
  _DWORD *v67;
  Registry **v68;
  std::__shared_weak_count *v69;
  std::__shared_weak_count *v70;
  std::__shared_weak_count *v71;
  uint64_t (*v72)(_QWORD);
  dispatch_object_t v73[2];
  NSObject *v74;
  NSObject *v75;
  void *v76[2];
  uint64_t v77;
  uint64_t v78;
  __int128 v79;
  void *__p;
  _DWORD *v81;
  uint64_t (*v82)(_QWORD);
  dispatch_object_t object;
  void *v84;
  uint64_t v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;

  v68 = (Registry **)((char *)this + 48);
  subscriber::makeSimSlotRange();
  v2 = v69;
  if (v69 != v70)
  {
    while ((v72(LODWORD(v2->__vftable)) & 1) == 0)
    {
      v2 = (std::__shared_weak_count *)((char *)v2 + 4);
      if (v2 == v70)
      {
        v2 = v70;
        break;
      }
    }
    if (v2 != v70)
    {
      v65 = (char *)*MEMORY[0x24BED1E38];
      while (1)
      {
        if (LODWORD(v2->__vftable) == 1)
          v3 = "CallModule.Voice.Service.1";
        else
          v3 = LODWORD(v2->__vftable) == 2 ? "CallModule.Voice.Service.2" : 0;
        v4 = (std::__shared_weak_count *)*((_QWORD *)this + 2);
        if (!v4)
          break;
        v5 = *((_QWORD *)this + 1);
        v6 = std::__shared_weak_count::lock(v4);
        if (!v6)
          break;
        v7 = v6;
        Registry::getServerConnection(*v68);
        v88 = 0u;
        v89 = 0u;
        std::string::basic_string[abi:ne180100]<0>(&v84, v3);
        v8 = *((_QWORD *)this + 3);
        object = v8;
        if (v8)
          dispatch_retain(v8);
        std::string::basic_string[abi:ne180100]<0>(&__p, "voice");
        *(_QWORD *)&v87 = v5;
        *((_QWORD *)&v87 + 1) = v7;
        p_shared_weak_owners = (unint64_t *)&v7->__shared_weak_owners_;
        do
          v10 = __ldxr(p_shared_weak_owners);
        while (__stxr(v10 + 1, p_shared_weak_owners));
        v79 = *(_OWORD *)v73;
        *(_OWORD *)v73 = 0uLL;
        qmi::Client::createWithQueueLocal();
        v11 = (std::__shared_weak_count *)*((_QWORD *)&v79 + 1);
        if (*((_QWORD *)&v79 + 1))
        {
          v12 = (unint64_t *)(*((_QWORD *)&v79 + 1) + 8);
          do
            v13 = __ldaxr(v12);
          while (__stlxr(v13 - 1, v12));
          if (!v13)
          {
            ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
            std::__shared_weak_count::__release_weak(v11);
          }
        }
        if (*((_QWORD *)&v87 + 1))
          std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v87 + 1));
        if (SHIBYTE(v82) < 0)
          operator delete(__p);
        if (object)
          dispatch_release(object);
        if (SBYTE7(v86) < 0)
          operator delete(v84);
        v84 = 0;
        v85 = 0;
        v86 = v89;
        v89 = 0uLL;
        qmi::ClientRouter::addClient();
        qmi::Client::~Client((qmi::Client *)&v84);
        v14 = qmi::ClientRouter::get();
        qmi::Client::~Client((qmi::Client *)&v88);
        v76[0] = 0;
        v76[1] = 0;
        v15 = *(_QWORD *)(v14 + 24);
        v77 = *(_QWORD *)(v14 + 16);
        v78 = v15;
        if (v15)
        {
          v16 = (unint64_t *)(v15 + 8);
          do
            v17 = __ldxr(v16);
          while (__stxr(v17 + 1, v16));
        }
        p_shared_owners = (unint64_t *)&v7->__shared_owners_;
        do
          v19 = __ldaxr(p_shared_owners);
        while (__stlxr(v19 - 1, p_shared_owners));
        if (!v19)
        {
          ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
          std::__shared_weak_count::__release_weak(v7);
        }
        qmi::Client::set((qmi::Client *)v76, v65);
        qmi::Client::~Client((qmi::Client *)v76);
        v20 = (std::__shared_weak_count *)((char *)&v2->__vftable + 4);
        v2 = v70;
        if (v20 != v70)
        {
          v2 = v20;
          while ((v72(LODWORD(v2->__vftable)) & 1) == 0)
          {
            v2 = (std::__shared_weak_count *)((char *)v2 + 4);
            if (v2 == v70)
            {
              v2 = v70;
              break;
            }
          }
        }
        if (v2 == v70)
          goto LABEL_44;
      }
LABEL_142:
      std::__throw_bad_weak_ptr[abi:ne180100]();
    }
  }
LABEL_44:
  subscriber::makeSimSlotRange();
  v22 = __p;
  v21 = v81;
  if (__p != v81)
  {
    v23 = v82;
    while ((v23(*v22) & 1) == 0)
    {
      if (++v22 == v21)
      {
        v22 = v21;
        break;
      }
    }
    v66 = v81;
    while (v22 != v66)
    {
      if (*v22 == 1)
        v24 = "CallModule.USSD.Service.1";
      else
        v24 = *v22 == 2 ? "CallModule.USSD.Service.2" : 0;
      v25 = (std::__shared_weak_count *)*((_QWORD *)this + 2);
      if (!v25)
        goto LABEL_142;
      v26 = std::__shared_weak_count::lock(v25);
      if (!v26)
        goto LABEL_142;
      v27 = v26;
      Registry::getServerConnection(*v68);
      v88 = 0u;
      v89 = 0u;
      std::string::basic_string[abi:ne180100]<0>(&v84, v24);
      v28 = *((_QWORD *)this + 3);
      v74 = v28;
      if (v28)
        dispatch_retain(v28);
      std::string::basic_string[abi:ne180100]<0>(v76, "ussd");
      v29 = (unint64_t *)&v27->__shared_weak_owners_;
      do
        v30 = __ldxr(v29);
      while (__stxr(v30 + 1, v29));
      v87 = v79;
      v79 = 0uLL;
      qmi::Client::createWithQueueLocal();
      v31 = (std::__shared_weak_count *)*((_QWORD *)&v87 + 1);
      if (*((_QWORD *)&v87 + 1))
      {
        v32 = (unint64_t *)(*((_QWORD *)&v87 + 1) + 8);
        do
          v33 = __ldaxr(v32);
        while (__stlxr(v33 - 1, v32));
        if (!v33)
        {
          ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
          std::__shared_weak_count::__release_weak(v31);
        }
      }
      std::__shared_weak_count::__release_weak(v27);
      if (SHIBYTE(v77) < 0)
        operator delete(v76[0]);
      if (v74)
        dispatch_release(v74);
      if (SBYTE7(v86) < 0)
        operator delete(v84);
      v84 = 0;
      v85 = 0;
      v86 = v89;
      v89 = 0uLL;
      qmi::ClientRouter::addClient();
      qmi::Client::~Client((qmi::Client *)&v84);
      qmi::ClientRouter::get();
      qmi::Client::~Client((qmi::Client *)&v88);
      v34 = (std::__shared_weak_count *)*((_QWORD *)&v79 + 1);
      if (*((_QWORD *)&v79 + 1))
      {
        v35 = (unint64_t *)(*((_QWORD *)&v79 + 1) + 8);
        do
          v36 = __ldaxr(v35);
        while (__stlxr(v36 - 1, v35));
        if (!v36)
        {
          ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
          std::__shared_weak_count::__release_weak(v34);
        }
      }
      v37 = (unint64_t *)&v27->__shared_owners_;
      do
        v38 = __ldaxr(v37);
      while (__stlxr(v38 - 1, v37));
      if (!v38)
      {
        ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
        std::__shared_weak_count::__release_weak(v27);
      }
      v39 = v22 + 1;
      v22 = v21;
      if (v39 != v21)
      {
        v22 = v39;
        while ((v23(*v22) & 1) == 0)
        {
          if (++v22 == v21)
          {
            v22 = v21;
            break;
          }
        }
      }
    }
  }
  subscriber::makeSimSlotRange();
  v41 = __p;
  v40 = v81;
  if (__p != v81)
  {
    v42 = v82;
    while ((v42(*v41) & 1) == 0)
    {
      if (++v41 == v40)
      {
        v41 = v40;
        break;
      }
    }
    v67 = v81;
    while (v41 != v67)
    {
      if (*v41 == 1)
      {
        v43 = "CallModule.NAS.1";
      }
      else if (*v41 == 2)
      {
        v43 = "CallModule.NAS.2";
      }
      else
      {
        v43 = 0;
      }
      v44 = (std::__shared_weak_count *)*((_QWORD *)this + 2);
      if (!v44)
        goto LABEL_142;
      v45 = std::__shared_weak_count::lock(v44);
      if (!v45)
        goto LABEL_142;
      v46 = v45;
      v47 = (unint64_t *)&v45->__shared_weak_owners_;
      do
        v48 = __ldxr(v47);
      while (__stxr(v48 + 1, v47));
      v49 = (unint64_t *)&v45->__shared_owners_;
      do
        v50 = __ldaxr(v49);
      while (__stlxr(v50 - 1, v49));
      if (!v50)
      {
        ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
        std::__shared_weak_count::__release_weak(v46);
      }
      Registry::getServerConnection(*v68);
      v88 = 0u;
      v89 = 0u;
      std::string::basic_string[abi:ne180100]<0>(&v84, v43);
      v51 = *((_QWORD *)this + 3);
      v75 = v51;
      if (v51)
        dispatch_retain(v51);
      std::string::basic_string[abi:ne180100]<0>(v76, "voice");
      v52 = std::__shared_weak_count::lock(v46);
      if (v52)
      {
        v53 = v52;
        v54 = (unint64_t *)&v52->__shared_weak_owners_;
        do
          v55 = __ldxr(v54);
        while (__stxr(v55 + 1, v54));
        v71 = v52;
        std::__shared_weak_count::__release_weak(v46);
        v56 = (unint64_t *)&v53->__shared_owners_;
        do
          v57 = __ldaxr(v56);
        while (__stlxr(v57 - 1, v56));
        if (v57)
          goto LABEL_117;
        ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
        v46 = v53;
      }
      else
      {
        v71 = 0;
      }
      std::__shared_weak_count::__release_weak(v46);
LABEL_117:
      v87 = v79;
      v79 = 0uLL;
      qmi::Client::createWithQueueLocal();
      v58 = (std::__shared_weak_count *)*((_QWORD *)&v87 + 1);
      if (*((_QWORD *)&v87 + 1))
      {
        v59 = (unint64_t *)(*((_QWORD *)&v87 + 1) + 8);
        do
          v60 = __ldaxr(v59);
        while (__stlxr(v60 - 1, v59));
        if (!v60)
        {
          ((void (*)(std::__shared_weak_count *))v58->__on_zero_shared)(v58);
          std::__shared_weak_count::__release_weak(v58);
        }
      }
      if (v71)
        std::__shared_weak_count::__release_weak(v71);
      if (SHIBYTE(v77) < 0)
        operator delete(v76[0]);
      if (v75)
        dispatch_release(v75);
      if (SBYTE7(v86) < 0)
        operator delete(v84);
      v84 = 0;
      v85 = 0;
      v86 = v89;
      v89 = 0uLL;
      qmi::ClientRouter::addClient();
      qmi::Client::~Client((qmi::Client *)&v84);
      qmi::ClientRouter::get();
      qmi::Client::~Client((qmi::Client *)&v88);
      v61 = (std::__shared_weak_count *)*((_QWORD *)&v79 + 1);
      if (*((_QWORD *)&v79 + 1))
      {
        v62 = (unint64_t *)(*((_QWORD *)&v79 + 1) + 8);
        do
          v63 = __ldaxr(v62);
        while (__stlxr(v63 - 1, v62));
        if (!v63)
        {
          ((void (*)(std::__shared_weak_count *))v61->__on_zero_shared)(v61);
          std::__shared_weak_count::__release_weak(v61);
        }
      }
      v64 = v41 + 1;
      v41 = v40;
      if (v64 != v40)
      {
        v41 = v64;
        while ((v42(*v41) & 1) == 0)
        {
          if (++v41 == v40)
          {
            v41 = v40;
            break;
          }
        }
      }
    }
  }
}

void EurekaCallCommandDriver::sendSRVCCCallConfig(uint64_t a1, uint64_t a2)
{
  os_log_t *v4;
  const void **v5;
  char *v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t i;
  uint64_t v23;
  NSObject *v24;
  std::string::value_type v25;
  unsigned int v26;
  int v27;
  unint64_t v28;
  unint64_t v29;
  __int128 v30;
  __int128 v31;
  uint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  char *v37;
  std::string *v38;
  std::string::pointer data;
  char *v40;
  __int128 v41;
  __int128 v42;
  uint64_t v43;
  uint64_t v44;
  std::__shared_weak_count *v45;
  unint64_t *p_shared_owners;
  uint64_t v47;
  unint64_t v48;
  std::__shared_weak_count *v49;
  unint64_t *v50;
  unint64_t v51;
  std::__shared_weak_count *v52;
  unint64_t *v53;
  unint64_t v54;
  uint64_t v55;
  uint64_t v56;
  void *__p[2];
  __int128 v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  std::string v62[2];
  _QWORD *v63;
  std::__shared_weak_count *v64;
  __int128 buf;
  void (*v66)(uint64_t, uint64_t);
  char *v67;
  std::string *v68;
  uint64_t v69;

  v69 = *MEMORY[0x24BDAC8D0];
  v4 = (os_log_t *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 112) + 16))(*(_QWORD *)(a1 + 112));
  v59 = 0;
  v60 = 0;
  v61 = 0;
  (*(void (**)(uint64_t *__return_ptr, _QWORD, uint64_t))(**(_QWORD **)(a1 + 120) + 328))(&v59, *(_QWORD *)(a1 + 120), a2);
  *(_OWORD *)__p = 0u;
  v58 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  v5 = (const void **)__p[1];
  if (__p[1] != (void *)v58)
  {
    while (*((_BYTE *)*v5 + 8) != 1)
    {
      if (++v5 == (const void **)v58)
        goto LABEL_8;
    }
  }
  if (v5 == (const void **)v58)
  {
LABEL_8:
    v8 = operator new();
    v9 = v8;
    *(_BYTE *)(v8 + 8) = 1;
    *(_QWORD *)(v8 + 16) = 0;
    v7 = (uint64_t *)(v8 + 16);
    *(_QWORD *)v8 = off_24D5E3BC8;
    *(_QWORD *)(v8 + 24) = 0;
    *(_QWORD *)(v8 + 32) = 0;
    v10 = v58;
    if ((unint64_t)v58 >= *((_QWORD *)&v58 + 1))
    {
      v12 = (uint64_t)(v58 - (unint64_t)__p[1]) >> 3;
      if ((unint64_t)(v12 + 1) >> 61)
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      v13 = (uint64_t)(*((_QWORD *)&v58 + 1) - (unint64_t)__p[1]) >> 2;
      if (v13 <= v12 + 1)
        v13 = v12 + 1;
      if (*((_QWORD *)&v58 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
        v14 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v14 = v13;
      if (v14)
        v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v58 + 8, v14);
      else
        v15 = 0;
      v16 = (uint64_t *)&v15[8 * v12];
      v17 = &v15[8 * v14];
      *v16 = v9;
      v11 = v16 + 1;
      v19 = (char *)__p[1];
      v18 = (char *)v58;
      if ((void *)v58 != __p[1])
      {
        do
        {
          v20 = *((_QWORD *)v18 - 1);
          v18 -= 8;
          *--v16 = v20;
        }
        while (v18 != v19);
        v18 = (char *)__p[1];
      }
      __p[1] = v16;
      *(_QWORD *)&v58 = v11;
      *((_QWORD *)&v58 + 1) = v17;
      if (v18)
        operator delete(v18);
    }
    else
    {
      *(_QWORD *)v58 = v8;
      v11 = (_QWORD *)(v10 + 8);
    }
    *(_QWORD *)&v58 = v11;
  }
  else
  {
    if (!v6)
      __cxa_bad_cast();
    v7 = (uint64_t *)(v6 + 16);
  }
  v21 = v59;
  for (i = v60; v21 != i; v21 += 408)
  {
    v23 = *(int *)(v21 + 56);
    if (v23 < 9 && ((0x1F3u >> v23) & 1) != 0)
    {
      v25 = byte_216AB8BD3[v23];
      v26 = dword_216AB8BDC[v23];
      if ((CallInfo::operator BOOL() & 1) != 0)
      {
        memset(v62, 0, sizeof(v62));
        v62[0].__r_.__value_.__s.__data_[0] = *(_DWORD *)(v21 + 92);
        if ((*(_DWORD *)(v21 + 64) & 0xFFFFFFFE) == 2)
          v27 = 9;
        else
          v27 = 0;
        *(std::string::size_type *)((char *)v62[0].__r_.__value_.__r.__words + 4) = __PAIR64__(v26, v27);
        v62[0].__r_.__value_.__s.__data_[12] = v25;
        v62[0].__r_.__value_.__s.__data_[13] = *(_BYTE *)(v21 + 85);
        LODWORD(v62[0].__r_.__value_.__r.__words[2]) = *(_DWORD *)(v21 + 72);
        std::string::operator=(&v62[1], (const std::string *)(v21 + 32));
        v28 = v7[1];
        v29 = v7[2];
        if (v28 >= v29)
        {
          v33 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v28 - *v7) >> 4);
          v34 = v33 + 1;
          if (v33 + 1 > 0x555555555555555)
            std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
          v35 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v29 - *v7) >> 4);
          if (2 * v35 > v34)
            v34 = 2 * v35;
          if (v35 >= 0x2AAAAAAAAAAAAAALL)
            v36 = 0x555555555555555;
          else
            v36 = v34;
          v68 = (std::string *)(v7 + 2);
          if (v36)
            v37 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::AppInfo>>((uint64_t)(v7 + 2), v36);
          else
            v37 = 0;
          v40 = &v37[48 * v33];
          *(_QWORD *)&buf = v37;
          *((_QWORD *)&buf + 1) = v40;
          v67 = &v37[48 * v36];
          v41 = *(_OWORD *)&v62[0].__r_.__value_.__l.__data_;
          *((_DWORD *)v40 + 4) = v62[0].__r_.__value_.__r.__words[2];
          *(_OWORD *)v40 = v41;
          v42 = *(_OWORD *)&v62[1].__r_.__value_.__l.__data_;
          *((_QWORD *)v40 + 5) = *((_QWORD *)&v62[1].__r_.__value_.__l + 2);
          *(_OWORD *)(v40 + 24) = v42;
          memset(&v62[1], 0, sizeof(std::string));
          v66 = (void (*)(uint64_t, uint64_t))(v40 + 48);
          std::vector<vs::tlv::CallConfigItem>::__swap_out_circular_buffer(v7, &buf);
          v32 = v7[1];
          std::__split_buffer<vs::tlv::CallConfigItem>::~__split_buffer((uint64_t)&buf);
        }
        else
        {
          v30 = *(_OWORD *)&v62[0].__r_.__value_.__l.__data_;
          *(_DWORD *)(v28 + 16) = v62[0].__r_.__value_.__r.__words[2];
          *(_OWORD *)v28 = v30;
          v31 = *(_OWORD *)&v62[1].__r_.__value_.__l.__data_;
          *(_QWORD *)(v28 + 40) = *((_QWORD *)&v62[1].__r_.__value_.__l + 2);
          *(_OWORD *)(v28 + 24) = v31;
          memset(&v62[1], 0, sizeof(std::string));
          v32 = v28 + 48;
          v7[1] = v28 + 48;
        }
        v7[1] = v32;
        if ((SHIBYTE(v62[1].__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          continue;
        data = v62[1].__r_.__value_.__l.__data_;
        goto LABEL_54;
      }
    }
    else
    {
      CallInfo::operator BOOL();
    }
    v24 = *v4;
    if (!os_log_type_enabled(*v4, OS_LOG_TYPE_ERROR))
      continue;
    CallInfo::toString((CallInfo *)v21);
    v38 = v62;
    if ((v62[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      v38 = (std::string *)v62[0].__r_.__value_.__r.__words[0];
    LODWORD(buf) = 136315138;
    *(_QWORD *)((char *)&buf + 4) = v38;
    _os_log_error_impl(&dword_216897000, v24, OS_LOG_TYPE_ERROR, "Found call in invalid state when sending handover call context: %s", (uint8_t *)&buf, 0xCu);
    if ((SHIBYTE(v62[0].__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      continue;
    data = (std::string::pointer)v62[0].__r_.__value_.__r.__words[0];
LABEL_54:
    operator delete(data);
  }
  v43 = qmi::ClientRouter::get();
  v44 = operator new();
  *(_QWORD *)v44 = v43;
  *(_QWORD *)(v44 + 8) = QMIServiceMsg::create();
  *(_DWORD *)(v44 + 16) = 25000;
  *(_QWORD *)(v44 + 24) = 0;
  *(_QWORD *)(v44 + 32) = 0;
  v56 = v44;
  v45 = (std::__shared_weak_count *)operator new(0x20uLL);
  v45->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v45->__shared_owners_;
  v45->__shared_weak_owners_ = 0;
  v45->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E3C30;
  v45[1].__vftable = (std::__shared_weak_count_vtbl *)v4;
  v63 = &v45[1].__vftable;
  v64 = v45;
  v47 = MEMORY[0x24BDAC760];
  v62[0].__r_.__value_.__r.__words[0] = MEMORY[0x24BDAC760];
  v62[0].__r_.__value_.__l.__size_ = 1174405120;
  v62[0].__r_.__value_.__r.__words[2] = (std::string::size_type)___ZNO3qmi12ClientRouter9SendProxy8callbackIZN23EurekaCallCommandDriver19sendSRVCCCallConfigEN10subscriber7SimSlotEE3__1EEOS1_OT__block_invoke;
  v62[1].__r_.__value_.__r.__words[0] = (std::string::size_type)&__block_descriptor_tmp_140_0;
  v62[1].__r_.__value_.__l.__size_ = (std::string::size_type)&v45[1];
  v62[1].__r_.__value_.__r.__words[2] = (std::string::size_type)v45;
  do
    v48 = __ldxr(p_shared_owners);
  while (__stxr(v48 + 1, p_shared_owners));
  *(_QWORD *)&buf = v47;
  *((_QWORD *)&buf + 1) = 0x40000000;
  v66 = ___ZNO3qmi6Client9SendProxy8callbackIRKNS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke_26;
  v67 = (char *)&unk_24D5E3190;
  v68 = v62;
  *(_QWORD *)(v44 + 32) = _Block_copy(&buf);
  v49 = (std::__shared_weak_count *)v62[1].__r_.__value_.__r.__words[2];
  if (v62[1].__r_.__value_.__r.__words[2])
  {
    v50 = (unint64_t *)(v62[1].__r_.__value_.__r.__words[2] + 8);
    do
      v51 = __ldaxr(v50);
    while (__stlxr(v51 - 1, v50));
    if (!v51)
    {
      ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
      std::__shared_weak_count::__release_weak(v49);
    }
  }
  v52 = v64;
  if (v64)
  {
    v53 = (unint64_t *)&v64->__shared_owners_;
    do
      v54 = __ldaxr(v53);
    while (__stlxr(v54 - 1, v53));
    if (!v54)
    {
      ((void (*)(std::__shared_weak_count *))v52->__on_zero_shared)(v52);
      std::__shared_weak_count::__release_weak(v52);
    }
  }
  v55 = v56;
  v56 = 0;
  if (v55)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v56, v55);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
  v62[0].__r_.__value_.__r.__words[0] = (std::string::size_type)&v59;
  std::vector<CallInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)v62);
}

void sub_216A32850(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v34);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v35 - 160);
  if (a16)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v33, a16);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a17);
  a17 = &a22;
  std::vector<CallInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)&a17);
  _Unwind_Resume(a1);
}

uint64_t EurekaCallCommandDriver::handleNotRegistered(EurekaCallCommandDriver *this)
{
  NSObject *v2;
  uint8_t v4[16];

  v2 = *((_QWORD *)this + 5);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v4 = 0;
    _os_log_impl(&dword_216897000, v2, OS_LOG_TYPE_DEFAULT, "#N event::registration::not registered!", v4, 2u);
  }
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 27) + 16))(*((_QWORD *)this + 27));
}

void EurekaCallCommandDriver::handleRegistered(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v5;
  int v6;
  uint64_t v7;
  os_log_t *v8;
  int v9;
  uint64_t v10;
  int v11;
  _QWORD *v12;
  int v13;
  BOOL v14;
  uint64_t *v15;
  BOOL v16;
  NSObject *v17;
  void **p_p;
  NSObject *v19;
  int v20;
  void **v21;
  uint64_t v22;
  void **v23;
  void *v24;
  std::__shared_weak_count *v25;
  unint64_t *p_shared_owners;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  std::__shared_weak_count *v33;
  unint64_t *v34;
  unint64_t v35;
  std::__shared_weak_count *v36;
  unint64_t *v37;
  unint64_t v38;
  std::__shared_weak_count *v39;
  unint64_t *v40;
  unint64_t v41;
  _QWORD *v42;
  _QWORD *v43;
  BOOL v44;
  uint64_t v45;
  std::__shared_weak_count *v46;
  void *__p;
  std::__shared_weak_count *v48;
  char v49;
  uint64_t v50;
  std::__shared_weak_count *v51;
  uint8_t buf[4];
  void **v53;
  __int16 v54;
  uint64_t v55;
  uint64_t v56;

  v56 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD **)(a1 + 312);
  v3 = (_QWORD *)(a1 + 320);
  if (v2 != (_QWORD *)(a1 + 320))
  {
    v5 = (_QWORD *)(a2 + 8);
    do
    {
      v6 = asWirelessTechnology();
      v7 = convertWirelessTechnologyToCallTechnology();
      v50 = 0;
      v51 = 0;
      EurekaCallCommandDriver::getPreferredFormatterForSim(&v50, a1, *((unsigned int *)v2 + 7));
      v8 = (os_log_t *)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 112) + 16))(*(_QWORD *)(a1 + 112), *((unsigned int *)v2 + 7));
      if (v50)
      {
        if ((*(unsigned int (**)(uint64_t, uint64_t))(*(_QWORD *)v50 + 16))(v50, 1))
          v9 = 8;
        else
          v9 = 4;
      }
      else
      {
        v9 = 0;
      }
      v10 = *v5;
      if (!*v5)
        goto LABEL_18;
      v11 = *((_DWORD *)v2 + 7);
      v12 = v5;
      do
      {
        v13 = *(_DWORD *)(v10 + 28);
        v14 = v13 < v11;
        if (v13 >= v11)
          v15 = (uint64_t *)v10;
        else
          v15 = (uint64_t *)(v10 + 8);
        if (!v14)
          v12 = (_QWORD *)v10;
        v10 = *v15;
      }
      while (*v15);
      if (v12 != v5 && v11 >= *((_DWORD *)v12 + 7))
      {
        v16 = asWirelessTechnology() == v6;
        if (!v6)
          goto LABEL_29;
      }
      else
      {
LABEL_18:
        v16 = 0;
        if (!v6)
          goto LABEL_29;
      }
      if (v16 || v9 == 8 && isCdmaRat())
      {
        v17 = *v8;
        if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
        {
          WirelessTechnologyAsString();
          p_p = &__p;
          if (v49 < 0)
            p_p = (void **)__p;
          *(_DWORD *)buf = 136315138;
          v53 = p_p;
          _os_log_impl(&dword_216897000, v17, OS_LOG_TYPE_DEFAULT, "#I Not handling fCurrentRat update since value didn't change, %s", buf, 0xCu);
          if (v49 < 0)
            operator delete(__p);
        }
        goto LABEL_63;
      }
LABEL_29:
      v19 = *v8;
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        WirelessTechnologyAsString();
        v20 = v49;
        v21 = (void **)__p;
        v22 = callTechnologyToString();
        *(_DWORD *)buf = 136315394;
        v23 = &__p;
        if (v20 < 0)
          v23 = v21;
        v53 = v23;
        v54 = 2080;
        v55 = v22;
        _os_log_impl(&dword_216897000, v19, OS_LOG_TYPE_DEFAULT, "#N WirelessTechnology has changed to (%s) and Call Tech has changed to (%s)!", buf, 0x16u);
        if (v49 < 0)
          operator delete(__p);
      }
      EurekaCallCommandDriver::setPreferredFormatter(a1, v7, *((unsigned int *)v2 + 7));
      EurekaCallCommandDriver::getPreferredFormatterForSim(&__p, a1, *((unsigned int *)v2 + 7));
      v24 = __p;
      v25 = v48;
      if (!v48)
        goto LABEL_38;
      p_shared_owners = (unint64_t *)&v48->__shared_owners_;
      do
        v27 = __ldaxr(p_shared_owners);
      while (__stlxr(v27 - 1, p_shared_owners));
      if (!v27)
      {
        ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
        std::__shared_weak_count::__release_weak(v25);
        if (v24)
        {
LABEL_39:
          if (v6 == 8)
          {
            EurekaCallCommandDriver::fillUpC2KCallCapabilities(a1, *((unsigned int *)v2 + 7));
          }
          else if (v6 == 4)
          {
            EurekaCallCommandDriver::fillUpGSMCallCapabilities(a1, *((unsigned int *)v2 + 7));
          }
          goto LABEL_45;
        }
      }
      else
      {
LABEL_38:
        if (v24)
          goto LABEL_39;
      }
      EurekaCallCommandDriver::setPreferredFormatterBasedOnCarrierCapabilities(a1, *((unsigned int *)v2 + 7));
LABEL_45:
      __p = 0;
      v48 = 0;
      EurekaCallCommandDriver::getPreferredFormatterForSim(&__p, a1, *((unsigned int *)v2 + 7));
      if ((*(unsigned int (**)(void *, uint64_t))(*(_QWORD *)__p + 16))(__p, 1))
        v28 = 8;
      else
        v28 = 4;
      v29 = *(_QWORD *)(a1 + 216);
      if (v6)
      {
        v30 = *(std::__shared_weak_count **)(a1 + 144);
        v45 = *(_QWORD *)(a1 + 136);
        v46 = v30;
        if (v30)
        {
          v31 = (unint64_t *)&v30->__shared_owners_;
          do
            v32 = __ldxr(v31);
          while (__stxr(v32 + 1, v31));
        }
        (*(void (**)(uint64_t, uint64_t *, uint64_t, _QWORD))(*(_QWORD *)v29 + 80))(v29, &v45, v28, *((unsigned int *)v2 + 7));
        v33 = v46;
        if (v46)
        {
          v34 = (unint64_t *)&v46->__shared_owners_;
          do
            v35 = __ldaxr(v34);
          while (__stlxr(v35 - 1, v34));
          if (!v35)
          {
            ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
            std::__shared_weak_count::__release_weak(v33);
          }
        }
      }
      else
      {
        (*(void (**)(uint64_t))(*(_QWORD *)v29 + 16))(v29);
      }
      v36 = v48;
      if (v48)
      {
        v37 = (unint64_t *)&v48->__shared_owners_;
        do
          v38 = __ldaxr(v37);
        while (__stlxr(v38 - 1, v37));
        if (!v38)
        {
          ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
          std::__shared_weak_count::__release_weak(v36);
        }
      }
LABEL_63:
      v39 = v51;
      if (v51)
      {
        v40 = (unint64_t *)&v51->__shared_owners_;
        do
          v41 = __ldaxr(v40);
        while (__stlxr(v41 - 1, v40));
        if (!v41)
        {
          ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
          std::__shared_weak_count::__release_weak(v39);
        }
      }
      v42 = (_QWORD *)v2[1];
      if (v42)
      {
        do
        {
          v43 = v42;
          v42 = (_QWORD *)*v42;
        }
        while (v42);
      }
      else
      {
        do
        {
          v43 = (_QWORD *)v2[2];
          v44 = *v43 == (_QWORD)v2;
          v2 = v43;
        }
        while (!v44);
      }
      v2 = v43;
    }
    while (v43 != v3);
  }
}

void sub_216A32E08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a22);
  _Unwind_Resume(a1);
}

void EurekaCallCommandDriver::getPreferredFormatterForSim(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  BOOL v7;
  uint64_t *v8;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  uint8_t v14[16];

  v4 = *(_QWORD *)(a2 + 200);
  if (!v4)
    goto LABEL_11;
  v5 = a2 + 200;
  do
  {
    v6 = *(_DWORD *)(v4 + 32);
    v7 = v6 < (int)a3;
    if (v6 >= (int)a3)
      v8 = (uint64_t *)v4;
    else
      v8 = (uint64_t *)(v4 + 8);
    if (!v7)
      v5 = v4;
    v4 = *v8;
  }
  while (*v8);
  if (v5 != a2 + 200 && *(_DWORD *)(v5 + 32) <= (int)a3)
  {
    v11 = *(_QWORD *)(v5 + 40);
    v10 = *(_QWORD *)(v5 + 48);
    *a1 = v11;
    a1[1] = v10;
    if (v10)
    {
      v12 = (unint64_t *)(v10 + 8);
      do
        v13 = __ldxr(v12);
      while (__stxr(v13 + 1, v12));
    }
  }
  else
  {
LABEL_11:
    v9 = *(NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a2 + 112) + 16))(*(_QWORD *)(a2 + 112), a3);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v14 = 0;
      _os_log_error_impl(&dword_216897000, v9, OS_LOG_TYPE_ERROR, "Preferred formatter not found for the sim!", v14, 2u);
    }
    *a1 = 0;
    a1[1] = 0;
  }
}

void EurekaCallCommandDriver::setPreferredFormatter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  os_log_t *v6;
  NSObject *v7;
  NSObject *v8;
  NSObject *v9;
  uint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  uint64_t **v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  NSObject *v20;
  uint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *p_shared_owners;
  unint64_t v24;
  uint64_t **v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  unint64_t *v29;
  unint64_t v30;
  NSObject *v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  std::__shared_weak_count *v35;
  std::__shared_weak_count *v36;
  unsigned int v37;
  __int128 v38;
  uint8_t buf[24];
  uint64_t v40;

  v40 = *MEMORY[0x24BDAC8D0];
  v37 = a3;
  v6 = (os_log_t *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 112) + 16))(*(_QWORD *)(a1 + 112), a3);
  v7 = *v6;
  if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315138;
    *(_QWORD *)&buf[4] = callTechnologyToString();
    _os_log_impl(&dword_216897000, v7, OS_LOG_TYPE_DEFAULT, "#I Setting preferred formatter. Call Tech: %s", buf, 0xCu);
  }
  *(_OWORD *)buf = 0uLL;
  EurekaCallCommandDriver::getPreferredFormatterForSim(buf, a1, a3);
  if (*(_QWORD *)buf && (*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)buf + 16))(*(_QWORD *)buf, a2))
  {
    v8 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v38) = 0;
      _os_log_impl(&dword_216897000, v8, OS_LOG_TYPE_DEFAULT, "#I No change in preferred formatter.", (uint8_t *)&v38, 2u);
    }
    goto LABEL_44;
  }
  if ((a2 - 2) < 2)
    goto LABEL_10;
  if ((_DWORD)a2 == 1)
  {
    v20 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v38) = 0;
      _os_log_impl(&dword_216897000, v20, OS_LOG_TYPE_DEFAULT, "#I Setting preferred formatter to C2K", (uint8_t *)&v38, 2u);
    }
    v21 = *(_QWORD *)(a1 + 120);
    v22 = *(std::__shared_weak_count **)(a1 + 128);
    v35 = v22;
    if (v22)
    {
      p_shared_owners = (unint64_t *)&v22->__shared_owners_;
      do
        v24 = __ldxr(p_shared_owners);
      while (__stxr(v24 + 1, p_shared_owners));
    }
    std::allocate_shared[abi:ne180100]<EurekaC2KCallFormatter,std::allocator<EurekaC2KCallFormatter>,std::shared_ptr<Registry const> const&,dispatch::queue const&,std::shared_ptr<EurekaCallCommandDriver::DelegateBase> &,void>(&v38, (Registry **)(a1 + 48), (dispatch_object_t *)(a1 + 24), v21, v22);
    v25 = std::__tree<std::__value_type<subscriber::SimSlot,std::shared_ptr<QMIDataCommandDriverInterface>>,std::__map_value_compare<subscriber::SimSlot,std::__value_type<subscriber::SimSlot,std::shared_ptr<QMIDataCommandDriverInterface>>,std::less<subscriber::SimSlot>,true>,std::allocator<std::__value_type<subscriber::SimSlot,std::shared_ptr<QMIDataCommandDriverInterface>>>>::__emplace_unique_key_args<subscriber::SimSlot,std::piecewise_construct_t const&,std::tuple<subscriber::SimSlot const&>,std::tuple<>>((uint64_t **)(a1 + 192), a3, &v37);
    std::shared_ptr<qmi::Client::State>::operator=[abi:ne180100]((uint64_t)(v25 + 5), &v38);
    v26 = (std::__shared_weak_count *)*((_QWORD *)&v38 + 1);
    if (*((_QWORD *)&v38 + 1))
    {
      v27 = (unint64_t *)(*((_QWORD *)&v38 + 1) + 8);
      do
        v28 = __ldaxr(v27);
      while (__stlxr(v28 - 1, v27));
      if (!v28)
      {
        ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
        std::__shared_weak_count::__release_weak(v26);
      }
    }
    if (v35)
    {
      v29 = (unint64_t *)&v35->__shared_owners_;
      do
        v30 = __ldaxr(v29);
      while (__stlxr(v30 - 1, v29));
      if (!v30)
      {
        ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
        std::__shared_weak_count::__release_weak(v35);
      }
    }
    EurekaCallCommandDriver::fillUpC2KCallCapabilities(a1, v37);
  }
  else
  {
    if ((_DWORD)a2 == 5)
    {
LABEL_10:
      v9 = *v6;
      if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v38) = 0;
        _os_log_impl(&dword_216897000, v9, OS_LOG_TYPE_DEFAULT, "#I Setting preferred formatter to GSM", (uint8_t *)&v38, 2u);
      }
      v10 = *(_QWORD *)(a1 + 120);
      v11 = *(std::__shared_weak_count **)(a1 + 128);
      v36 = v11;
      if (v11)
      {
        v12 = (unint64_t *)&v11->__shared_owners_;
        do
          v13 = __ldxr(v12);
        while (__stxr(v13 + 1, v12));
      }
      std::allocate_shared[abi:ne180100]<EurekaGSMCallFormatter,std::allocator<EurekaGSMCallFormatter>,std::shared_ptr<Registry const> const&,dispatch::queue const&,std::shared_ptr<EurekaCallCommandDriver::DelegateBase> &,void>(&v38, (_QWORD *)(a1 + 48), v10, v11);
      v14 = std::__tree<std::__value_type<subscriber::SimSlot,std::shared_ptr<QMIDataCommandDriverInterface>>,std::__map_value_compare<subscriber::SimSlot,std::__value_type<subscriber::SimSlot,std::shared_ptr<QMIDataCommandDriverInterface>>,std::less<subscriber::SimSlot>,true>,std::allocator<std::__value_type<subscriber::SimSlot,std::shared_ptr<QMIDataCommandDriverInterface>>>>::__emplace_unique_key_args<subscriber::SimSlot,std::piecewise_construct_t const&,std::tuple<subscriber::SimSlot const&>,std::tuple<>>((uint64_t **)(a1 + 192), a3, &v37);
      std::shared_ptr<qmi::Client::State>::operator=[abi:ne180100]((uint64_t)(v14 + 5), &v38);
      v15 = (std::__shared_weak_count *)*((_QWORD *)&v38 + 1);
      if (*((_QWORD *)&v38 + 1))
      {
        v16 = (unint64_t *)(*((_QWORD *)&v38 + 1) + 8);
        do
          v17 = __ldaxr(v16);
        while (__stlxr(v17 - 1, v16));
        if (!v17)
        {
          ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
          std::__shared_weak_count::__release_weak(v15);
        }
      }
      if (v36)
      {
        v18 = (unint64_t *)&v36->__shared_owners_;
        do
          v19 = __ldaxr(v18);
        while (__stlxr(v19 - 1, v18));
        if (!v19)
        {
          ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
          std::__shared_weak_count::__release_weak(v36);
        }
      }
      EurekaCallCommandDriver::fillUpGSMCallCapabilities(a1, v37);
      goto LABEL_44;
    }
    v31 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
    {
      LODWORD(v38) = 136315138;
      *(_QWORD *)((char *)&v38 + 4) = callTechnologyToString();
      _os_log_error_impl(&dword_216897000, v31, OS_LOG_TYPE_ERROR, "Invalid call technology, %s. No change in preferred formatter.", (uint8_t *)&v38, 0xCu);
    }
  }
LABEL_44:
  v32 = *(std::__shared_weak_count **)&buf[8];
  if (*(_QWORD *)&buf[8])
  {
    v33 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
    do
      v34 = __ldaxr(v33);
    while (__stlxr(v34 - 1, v33));
    if (!v34)
    {
      ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
      std::__shared_weak_count::__release_weak(v32);
    }
  }
}

void sub_216A3334C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t EurekaCallCommandDriver::fillUpGSMCallCapabilities(uint64_t a1, uint64_t a2)
{
  int v4;

  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x24BDC3ED0], 6, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x24BDC3EC8], 5, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x24BDC3EF8], 1, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x24BDC3ED8], 1, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x24BDC3DB8], 0, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x24BDC3DB0], 0, a2);
  v4 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 120) + 352))(*(_QWORD *)(a1 + 120), a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x24BDC3DA0], v4 ^ 1, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x24BDC3EB0], 1, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x24BDC3EA8], 0, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x24BDC3EA0], 1, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x24BDC3EC0], 0, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x24BDC3F00], 0, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x24BDC3EF0], 0, a2);
  return (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 120) + 192))(*(_QWORD *)(a1 + 120), a2);
}

uint64_t EurekaCallCommandDriver::fillUpC2KCallCapabilities(uint64_t a1, uint64_t a2)
{
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x24BDC3ED0], 2, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x24BDC3EC8], 2, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x24BDC3EF8], 0, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x24BDC3ED8], 0, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x24BDC3DB8], 0, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x24BDC3DB0], 0, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x24BDC3DA0], 0, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x24BDC3EB0], 0, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x24BDC3EA8], 0, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x24BDC3EA0], 0, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x24BDC3EC0], 1, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x24BDC3F00], 0, a2);
  EurekaCallCommandDriver::setCallCapability(a1, *MEMORY[0x24BDC3EF0], 1, a2);
  return (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 120) + 192))(*(_QWORD *)(a1 + 120), a2);
}

void EurekaCallCommandDriver::setPreferredFormatterBasedOnCarrierCapabilities(uint64_t a1, uint64_t a2)
{
  os_log_t *v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  BOOL v8;
  uint64_t *v9;
  NSObject *v10;
  int v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *p_shared_owners;
  unint64_t v15;
  uint64_t **v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  _BOOL4 v25;
  uint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  uint64_t **v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  unint64_t *v34;
  unint64_t v35;
  std::__shared_weak_count *v36;
  std::__shared_weak_count *v37;
  uint64_t v38;
  std::__shared_weak_count *v39;
  unsigned int v40;
  uint8_t buf[24];
  uint64_t v42;

  v42 = *MEMORY[0x24BDAC8D0];
  v40 = a2;
  v38 = 0;
  v39 = 0;
  EurekaCallCommandDriver::getPreferredFormatterForSim(&v38, a1, a2);
  v4 = (os_log_t *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 112) + 16))(*(_QWORD *)(a1 + 112), a2);
  v5 = *(_QWORD *)(a1 + 264);
  if (!v5)
    goto LABEL_11;
  v6 = a1 + 264;
  do
  {
    v7 = *(_DWORD *)(v5 + 28);
    v8 = v7 < (int)a2;
    if (v7 >= (int)a2)
      v9 = (uint64_t *)v5;
    else
      v9 = (uint64_t *)(v5 + 8);
    if (!v8)
      v6 = v5;
    v5 = *v9;
  }
  while (*v9);
  if (v6 == a1 + 264 || *(_DWORD *)(v6 + 28) > (int)a2)
  {
LABEL_11:
    v10 = *v4;
    if (!os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
    {
LABEL_14:
      v12 = *(_QWORD *)(a1 + 120);
      v13 = *(std::__shared_weak_count **)(a1 + 128);
      v36 = v13;
      if (v13)
      {
        p_shared_owners = (unint64_t *)&v13->__shared_owners_;
        do
          v15 = __ldxr(p_shared_owners);
        while (__stxr(v15 + 1, p_shared_owners));
      }
      std::allocate_shared[abi:ne180100]<EurekaGSMCallFormatter,std::allocator<EurekaGSMCallFormatter>,std::shared_ptr<Registry const> const&,dispatch::queue const&,std::shared_ptr<EurekaCallCommandDriver::DelegateBase> &,void>(buf, (_QWORD *)(a1 + 48), v12, v13);
      v16 = std::__tree<std::__value_type<subscriber::SimSlot,std::shared_ptr<QMIDataCommandDriverInterface>>,std::__map_value_compare<subscriber::SimSlot,std::__value_type<subscriber::SimSlot,std::shared_ptr<QMIDataCommandDriverInterface>>,std::less<subscriber::SimSlot>,true>,std::allocator<std::__value_type<subscriber::SimSlot,std::shared_ptr<QMIDataCommandDriverInterface>>>>::__emplace_unique_key_args<subscriber::SimSlot,std::piecewise_construct_t const&,std::tuple<subscriber::SimSlot const&>,std::tuple<>>((uint64_t **)(a1 + 192), a2, &v40);
      std::shared_ptr<qmi::Client::State>::operator=[abi:ne180100]((uint64_t)(v16 + 5), (__int128 *)buf);
      v17 = *(std::__shared_weak_count **)&buf[8];
      if (*(_QWORD *)&buf[8])
      {
        v18 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
        do
          v19 = __ldaxr(v18);
        while (__stlxr(v19 - 1, v18));
        if (!v19)
        {
          ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
          std::__shared_weak_count::__release_weak(v17);
        }
      }
      if (v36)
      {
        v20 = (unint64_t *)&v36->__shared_owners_;
        do
          v21 = __ldaxr(v20);
        while (__stlxr(v21 - 1, v20));
        if (!v21)
        {
          ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
          std::__shared_weak_count::__release_weak(v36);
        }
      }
      EurekaCallCommandDriver::fillUpGSMCallCapabilities(a1, v40);
      goto LABEL_28;
    }
    v11 = 0;
LABEL_13:
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v11;
    _os_log_impl(&dword_216897000, v10, OS_LOG_TYPE_DEFAULT, "#I Device is not CDMA based type: %d", buf, 8u);
    goto LABEL_14;
  }
  v11 = *(_DWORD *)(v6 + 32);
  v10 = *v4;
  v25 = os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT);
  if (v11 != 3)
  {
    if (!v25)
      goto LABEL_14;
    goto LABEL_13;
  }
  if (v25)
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_216897000, v10, OS_LOG_TYPE_DEFAULT, "#I Device is CDMA based", buf, 2u);
  }
  if (((*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v38 + 16))(v38, 1) & 1) == 0)
  {
    v26 = *(_QWORD *)(a1 + 120);
    v27 = *(std::__shared_weak_count **)(a1 + 128);
    v37 = v27;
    if (v27)
    {
      v28 = (unint64_t *)&v27->__shared_owners_;
      do
        v29 = __ldxr(v28);
      while (__stxr(v29 + 1, v28));
    }
    std::allocate_shared[abi:ne180100]<EurekaC2KCallFormatter,std::allocator<EurekaC2KCallFormatter>,std::shared_ptr<Registry const> const&,dispatch::queue const&,std::shared_ptr<EurekaCallCommandDriver::DelegateBase> &,void>(buf, (Registry **)(a1 + 48), (dispatch_object_t *)(a1 + 24), v26, v27);
    v30 = std::__tree<std::__value_type<subscriber::SimSlot,std::shared_ptr<QMIDataCommandDriverInterface>>,std::__map_value_compare<subscriber::SimSlot,std::__value_type<subscriber::SimSlot,std::shared_ptr<QMIDataCommandDriverInterface>>,std::less<subscriber::SimSlot>,true>,std::allocator<std::__value_type<subscriber::SimSlot,std::shared_ptr<QMIDataCommandDriverInterface>>>>::__emplace_unique_key_args<subscriber::SimSlot,std::piecewise_construct_t const&,std::tuple<subscriber::SimSlot const&>,std::tuple<>>((uint64_t **)(a1 + 192), a2, &v40);
    std::shared_ptr<qmi::Client::State>::operator=[abi:ne180100]((uint64_t)(v30 + 5), (__int128 *)buf);
    v31 = *(std::__shared_weak_count **)&buf[8];
    if (*(_QWORD *)&buf[8])
    {
      v32 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
      do
        v33 = __ldaxr(v32);
      while (__stlxr(v33 - 1, v32));
      if (!v33)
      {
        ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
        std::__shared_weak_count::__release_weak(v31);
      }
    }
    if (v37)
    {
      v34 = (unint64_t *)&v37->__shared_owners_;
      do
        v35 = __ldaxr(v34);
      while (__stlxr(v35 - 1, v34));
      if (!v35)
      {
        ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
        std::__shared_weak_count::__release_weak(v37);
      }
    }
    EurekaCallCommandDriver::fillUpC2KCallCapabilities(a1, v40);
  }
LABEL_28:
  v22 = v39;
  if (v39)
  {
    v23 = (unint64_t *)&v39->__shared_owners_;
    do
      v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
  }
}

void sub_216A33A30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  uint64_t v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  va_list va1;
  uint64_t v10;
  uint64_t v11;
  va_list va2;

  va_start(va2, a4);
  va_start(va1, a4);
  va_start(va, a4);
  v5 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v8 = va_arg(va2, _QWORD);
  v10 = va_arg(va2, _QWORD);
  v11 = va_arg(va2, _QWORD);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va2);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t ___ZN23EurekaCallCommandDriver25handleVoiceUSSDIndicationEN3qmi16SubscriptionTypeEN2vs9VoiceUSSD10IndicationE_block_invoke(uint64_t result, _DWORD *a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = *a2 == 2;
  return result;
}

__n128 __Block_byref_object_copy__8(uint64_t a1, uint64_t a2)
{
  __n128 result;

  result = *(__n128 *)(a2 + 40);
  *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
  *(__n128 *)(a1 + 40) = result;
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(a2 + 56) = 0;
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__8(uint64_t a1)
{
  if (*(char *)(a1 + 63) < 0)
    operator delete(*(void **)(a1 + 40));
}

void ___ZN23EurekaCallCommandDriver25handleVoiceUSSDIndicationEN3qmi16SubscriptionTypeEN2vs9VoiceUSSD10IndicationE_block_invoke_4(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_DWORD *)a2;
  std::string::__assign_trivial[abi:ne180100]<unsigned char const*,unsigned char const*>((std::string *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), *(std::string::value_type **)(a2 + 8), *(std::string::value_type **)(a2 + 16), *(_QWORD *)(a2 + 16) - *(_QWORD *)(a2 + 8));
}

void `anonymous namespace'::sDecodeUSSDData(_QWORD *a1, uint64_t a2, int a3)
{
  const char *v6;
  __int128 v7;
  uint64_t v8;
  _QWORD v9[2];

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  v9[0] = 0;
  v9[1] = 0;
  ctu::TextConverter::TextConverter((ctu::TextConverter *)v9);
  if (a3 == 3)
  {
    ctu::TextConverter::pushConversion();
    ctu::TextConverter::pushConversion();
    if (*(char *)(a2 + 23) >= 0)
      v6 = (const char *)a2;
    else
      v6 = *(const char **)a2;
  }
  else
  {
    ctu::TextConverter::pushConversion();
    ctu::TextConverter::pushConversion();
    if (*(char *)(a2 + 23) >= 0)
      v6 = (const char *)a2;
    else
      v6 = *(const char **)a2;
  }
  ctu::TextConverter::setSource((ctu::TextConverter *)v9, v6);
  ctu::TextConverter::readChars((ctu::TextConverter *)v9);
  *(_OWORD *)a1 = v7;
  a1[2] = v8;
  ctu::TextConverter::~TextConverter((ctu::TextConverter *)v9);
}

void sub_216A33C2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  ctu::TextConverter::~TextConverter((ctu::TextConverter *)va);
  _Unwind_Resume(a1);
}

void ___ZN23EurekaCallCommandDriver25handleVoiceUSSDIndicationEN3qmi16SubscriptionTypeEN2vs9VoiceUSSD10IndicationE_block_invoke_2(uint64_t a1, __int16 **a2)
{
  NSObject *v3;
  uint64_t v4;
  _QWORD *v5;
  const __CFString *v6;
  void *__p;
  _BYTE *v8;
  uint64_t v9;
  uint8_t buf[4];
  _QWORD *v11;
  char buffer[1024];
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  __p = 0;
  v8 = 0;
  v9 = 0;
  convertTo8BitVector((unint64_t *)&__p, *a2, a2[1]);
  v6 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x24BDBD240], (const UInt8 *)__p, v8 - (_BYTE *)__p, 0x14000100u, 0);
  bzero(buffer, 0x400uLL);
  CFStringGetCString(v6, buffer, 1024, 0x8000100u);
  std::string::__assign_external((std::string *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), buffer);
  v3 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v4 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    v5 = (_QWORD *)(v4 + 40);
    if (*(char *)(v4 + 63) < 0)
      v5 = (_QWORD *)*v5;
    *(_DWORD *)buf = 136315138;
    v11 = v5;
    _os_log_impl(&dword_216897000, v3, OS_LOG_TYPE_DEFAULT, "#I String we got from UTF16 TLV: %s", buf, 0xCu);
  }
  ctu::SharedRef<__CFString const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFString const>::~SharedRef((const void **)&v6);
  if (__p)
  {
    v8 = __p;
    operator delete(__p);
  }
}

void sub_216A33D98(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void convertTo8BitVector(unint64_t *a1, __int16 *a2, __int16 *a3)
{
  __int16 *v4;
  _BYTE *v6;
  __int16 v7;
  unint64_t v8;
  _BYTE *v9;
  unint64_t v10;
  _BYTE *v11;
  unint64_t v12;
  unint64_t v13;
  size_t v14;
  char *v15;
  char *v16;
  _BYTE *v17;
  _BYTE *v18;
  char v19;
  unint64_t v20;
  unint64_t v21;
  _BYTE *v22;
  unint64_t v23;
  unint64_t v24;
  size_t v25;
  unint64_t v26;
  char *v27;
  _BYTE *v28;
  char v29;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2 != a3)
  {
    v4 = a2;
    v6 = 0;
    do
    {
      v7 = *v4;
      v8 = a1[2];
      if ((unint64_t)v6 >= v8)
      {
        v10 = *a1;
        v11 = &v6[-*a1];
        v12 = (unint64_t)(v11 + 1);
        if ((uint64_t)(v11 + 1) < 0)
          goto LABEL_40;
        v13 = v8 - v10;
        if (2 * v13 > v12)
          v12 = 2 * v13;
        if (v13 >= 0x3FFFFFFFFFFFFFFFLL)
          v14 = 0x7FFFFFFFFFFFFFFFLL;
        else
          v14 = v12;
        if (v14)
          v15 = (char *)operator new(v14);
        else
          v15 = 0;
        v16 = &v11[(_QWORD)v15];
        v17 = &v11[(_QWORD)v15];
        *v17 = v7;
        v9 = v17 + 1;
        if (v6 != (_BYTE *)v10)
        {
          v18 = &v6[~v10];
          do
          {
            v19 = *--v6;
            (v18--)[(_QWORD)v15] = v19;
          }
          while (v6 != (_BYTE *)v10);
          v6 = (_BYTE *)*a1;
          v16 = v15;
        }
        *a1 = (unint64_t)v16;
        a1[1] = (unint64_t)v9;
        a1[2] = (unint64_t)&v15[v14];
        if (v6)
          operator delete(v6);
      }
      else
      {
        *v6 = v7;
        v9 = v6 + 1;
      }
      a1[1] = (unint64_t)v9;
      v20 = a1[2];
      if ((unint64_t)v9 >= v20)
      {
        v21 = *a1;
        v22 = &v9[-*a1];
        v23 = (unint64_t)(v22 + 1);
        if ((uint64_t)(v22 + 1) < 0)
LABEL_40:
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v24 = v20 - v21;
        if (2 * v24 > v23)
          v23 = 2 * v24;
        if (v24 >= 0x3FFFFFFFFFFFFFFFLL)
          v25 = 0x7FFFFFFFFFFFFFFFLL;
        else
          v25 = v23;
        if (v25)
          v26 = (unint64_t)operator new(v25);
        else
          v26 = 0;
        v27 = (char *)(v26 + v25);
        v22[v26] = 0;
        v6 = &v22[v26 + 1];
        if (v9 == (_BYTE *)v21)
        {
          *a1 = (unint64_t)&v22[v26];
          a1[1] = (unint64_t)v6;
          a1[2] = (unint64_t)v27;
        }
        else
        {
          v28 = &v9[~v21];
          do
          {
            v29 = *--v9;
            (v28--)[v26] = v29;
          }
          while (v9 != (_BYTE *)v21);
          v9 = (_BYTE *)*a1;
          *a1 = v26;
          a1[1] = (unint64_t)v6;
          a1[2] = (unint64_t)v27;
          if (!v9)
            goto LABEL_38;
        }
        operator delete(v9);
      }
      else
      {
        *v9 = 0;
        v6 = v9 + 1;
      }
LABEL_38:
      a1[1] = (unint64_t)v6;
      ++v4;
    }
    while (v4 != a3);
  }
}

void sub_216A33FA0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v2;

  if (v2)
  {
    *(_QWORD *)(v1 + 8) = v2;
    operator delete(v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t ___ZN23EurekaCallCommandDriver35handleOriginateUSSDNoWaitIndicationEN3qmi16SubscriptionTypeEN2vs19OriginateUSSDNoWait10IndicationE_block_invoke(uint64_t result, _WORD *a2)
{
  *(_WORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = *a2;
  return result;
}

void ___ZN23EurekaCallCommandDriver35handleOriginateUSSDNoWaitIndicationEN3qmi16SubscriptionTypeEN2vs19OriginateUSSDNoWait10IndicationE_block_invoke_2(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_DWORD *)a2;
  std::string::__assign_trivial[abi:ne180100]<unsigned char const*,unsigned char const*>((std::string *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), *(std::string::value_type **)(a2 + 8), *(std::string::value_type **)(a2 + 16), *(_QWORD *)(a2 + 16) - *(_QWORD *)(a2 + 8));
}

void ___ZN23EurekaCallCommandDriver35handleOriginateUSSDNoWaitIndicationEN3qmi16SubscriptionTypeEN2vs19OriginateUSSDNoWait10IndicationE_block_invoke_3(uint64_t a1, __int16 **a2)
{
  NSObject *v3;
  uint64_t v4;
  _QWORD *v5;
  const __CFString *v6;
  void *__p;
  _BYTE *v8;
  uint64_t v9;
  uint8_t buf[4];
  _QWORD *v11;
  char buffer[1024];
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  __p = 0;
  v8 = 0;
  v9 = 0;
  convertTo8BitVector((unint64_t *)&__p, *a2, a2[1]);
  v6 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x24BDBD240], (const UInt8 *)__p, v8 - (_BYTE *)__p, 0x14000100u, 0);
  bzero(buffer, 0x400uLL);
  CFStringGetCString(v6, buffer, 1024, 0x8000100u);
  std::string::__assign_external((std::string *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), buffer);
  v3 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v4 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    v5 = (_QWORD *)(v4 + 40);
    if (*(char *)(v4 + 63) < 0)
      v5 = (_QWORD *)*v5;
    *(_DWORD *)buf = 136315138;
    v11 = v5;
    _os_log_impl(&dword_216897000, v3, OS_LOG_TYPE_DEFAULT, "#I String we got from UTF16 No Wait TLV: %s", buf, 0xCu);
  }
  ctu::SharedRef<__CFString const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFString const>::~SharedRef((const void **)&v6);
  if (__p)
  {
    v8 = __p;
    operator delete(__p);
  }
}

void sub_216A34158(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void ___ZN23EurekaCallCommandDriver35handleOriginateUSSDNoWaitIndicationEN3qmi16SubscriptionTypeEN2vs19OriginateUSSDNoWait10IndicationE_block_invoke_15(uint64_t a1, unsigned __int16 *a2)
{
  NSObject *v4;
  int v5;
  BOOL v7;
  int v8;
  _DWORD v9[2];
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v4 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    v8 = *a2;
    v9[0] = 67109120;
    v9[1] = v8;
    _os_log_error_impl(&dword_216897000, v4, OS_LOG_TYPE_ERROR, "Failure cause is present in the response with value (0x%x)", (uint8_t *)v9, 8u);
  }
  v5 = *a2;
  v7 = v5 == 25 || v5 == 29 || v5 == 145;
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v7;
}

void EurekaCallCommandDriver::cancelUssdSession(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  uint64_t v6;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _OWORD v16[2];
  _QWORD v17[5];
  std::__shared_weak_count *v18;
  _QWORD *v19;
  std::__shared_weak_count *v20;
  _QWORD aBlock[5];

  v1 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 112) + 16))(*(_QWORD *)(a1 + 112));
  memset(v16, 0, sizeof(v16));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v16);
  v2 = qmi::ClientRouter::get();
  v3 = operator new();
  *(_QWORD *)v3 = v2;
  *(_QWORD *)(v3 + 8) = QMIServiceMsg::create();
  *(_DWORD *)(v3 + 16) = 25000;
  *(_QWORD *)(v3 + 24) = 0;
  *(_QWORD *)(v3 + 32) = 0;
  v15 = v3;
  v4 = (std::__shared_weak_count *)operator new(0x20uLL);
  v4->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v4->__shared_owners_;
  v4->__shared_weak_owners_ = 0;
  v4->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E4188;
  v4[1].__vftable = (std::__shared_weak_count_vtbl *)v1;
  v19 = &v4[1].__vftable;
  v20 = v4;
  v6 = MEMORY[0x24BDAC760];
  v17[0] = MEMORY[0x24BDAC760];
  v17[1] = 1174405120;
  v17[2] = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN23EurekaCallCommandDriver17cancelUssdSessionEN10subscriber7SimSlotEE3__0EEOS1_OT__block_invoke;
  v17[3] = &__block_descriptor_tmp_165_1;
  v17[4] = v4 + 1;
  v18 = v4;
  do
    v7 = __ldxr(p_shared_owners);
  while (__stxr(v7 + 1, p_shared_owners));
  aBlock[0] = v6;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKN2vs10CancelUSSD8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
  aBlock[3] = &unk_24D5E41D0;
  aBlock[4] = v17;
  *(_QWORD *)(v3 + 32) = _Block_copy(aBlock);
  v8 = v18;
  if (v18)
  {
    v9 = (unint64_t *)&v18->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  v11 = v20;
  if (v20)
  {
    v12 = (unint64_t *)&v20->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  v14 = v15;
  v15 = 0;
  if (v14)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v15, v14);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v16);
}

void sub_216A34458(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  va_list va;

  va_start(va, a3);
  v6 = v4;
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v6);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v5 - 88);
  if (a3)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v3, a3);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va);
  _Unwind_Resume(a1);
}

void EurekaCallCommandDriver::sendUSSDProcedure(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  unint64_t *v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *p_shared_owners;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD v21[2];
  _QWORD *(*v22)(uint64_t, uint64_t);
  void *v23;
  std::string __p;
  _OWORD v25[2];
  _QWORD v26[5];
  std::__shared_weak_count *v27;
  char *v28;
  std::__shared_weak_count *v29;
  _QWORD aBlock[5];

  memset(v25, 0, sizeof(v25));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v25);
  v6 = MEMORY[0x24BDAC760];
  v21[0] = MEMORY[0x24BDAC760];
  v21[1] = 1174405120;
  v22 = ___ZN23EurekaCallCommandDriver17sendUSSDProcedureENSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEEN10subscriber7SimSlotE_block_invoke;
  v23 = &__block_descriptor_tmp_19_17;
  if (*(char *)(a2 + 23) < 0)
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
  else
    __p = *(std::string *)a2;
  v7 = qmi::MutableMessageBase::getTLV<vs::tlv::USSInfo>(v25);
  v22((uint64_t)v21, (uint64_t)v7);
  v8 = qmi::ClientRouter::get();
  v9 = operator new();
  *(_QWORD *)v9 = v8;
  *(_QWORD *)(v9 + 8) = QMIServiceMsg::create();
  *(_DWORD *)(v9 + 16) = 25000;
  *(_QWORD *)(v9 + 24) = 0;
  *(_QWORD *)(v9 + 32) = 0;
  v20 = v9;
  v10 = operator new(0x28uLL);
  v10[1] = 0;
  v11 = v10 + 1;
  v10[2] = 0;
  *v10 = &off_24D5E4280;
  v10[3] = a1;
  *((_DWORD *)v10 + 8) = a3;
  v28 = (char *)(v10 + 3);
  v29 = (std::__shared_weak_count *)v10;
  v26[0] = v6;
  v26[1] = 1174405120;
  v26[2] = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN23EurekaCallCommandDriver17sendUSSDProcedureENSt3__112basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEEN10subscriber7SimSlotEE3__0EEOS1_OT__block_invoke;
  v26[3] = &__block_descriptor_tmp_167_1;
  v26[4] = v10 + 3;
  v27 = (std::__shared_weak_count *)v10;
  do
    v12 = __ldxr(v11);
  while (__stxr(v12 + 1, v11));
  aBlock[0] = v6;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKN2vs19OriginateUSSDNoWait8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
  aBlock[3] = &unk_24D5E42C8;
  aBlock[4] = v26;
  *(_QWORD *)(v9 + 32) = _Block_copy(aBlock);
  v13 = v27;
  if (v27)
  {
    p_shared_owners = (unint64_t *)&v27->__shared_owners_;
    do
      v15 = __ldaxr(p_shared_owners);
    while (__stlxr(v15 - 1, p_shared_owners));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  v16 = v29;
  if (v29)
  {
    v17 = (unint64_t *)&v29->__shared_owners_;
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
  v19 = v20;
  v20 = 0;
  if (v19)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v20, v19);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v25);
}

void sub_216A34734(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22)
{
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a22);
  _Unwind_Resume(a1);
}

void EurekaCallCommandDriver::sendUSSDUserReply(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD v21[2];
  _QWORD *(*v22)(uint64_t, uint64_t);
  void *v23;
  std::string __p;
  _OWORD v25[2];
  _QWORD v26[5];
  std::__shared_weak_count *v27;
  _QWORD *v28;
  std::__shared_weak_count *v29;
  _QWORD aBlock[5];

  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 112) + 16))(*(_QWORD *)(a1 + 112), a3);
  memset(v25, 0, sizeof(v25));
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v25);
  v6 = MEMORY[0x24BDAC760];
  v21[0] = MEMORY[0x24BDAC760];
  v21[1] = 1174405120;
  v22 = ___ZN23EurekaCallCommandDriver17sendUSSDUserReplyENSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEEN10subscriber7SimSlotE_block_invoke;
  v23 = &__block_descriptor_tmp_20_16;
  if (*(char *)(a2 + 23) < 0)
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
  else
    __p = *(std::string *)a2;
  v7 = qmi::MutableMessageBase::getTLV<vs::tlv::USSInfo>(v25);
  v22((uint64_t)v21, (uint64_t)v7);
  v8 = qmi::ClientRouter::get();
  v9 = operator new();
  *(_QWORD *)v9 = v8;
  *(_QWORD *)(v9 + 8) = QMIServiceMsg::create();
  *(_DWORD *)(v9 + 16) = 25000;
  *(_QWORD *)(v9 + 24) = 0;
  *(_QWORD *)(v9 + 32) = 0;
  v20 = v9;
  v10 = (std::__shared_weak_count *)operator new(0x28uLL);
  v10->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v10->__shared_owners_;
  v10->__shared_weak_owners_ = 0;
  v10->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E4328;
  v10[1].__vftable = (std::__shared_weak_count_vtbl *)a1;
  v10[1].__shared_owners_ = v5;
  v28 = &v10[1].__vftable;
  v29 = v10;
  v26[0] = v6;
  v26[1] = 1174405120;
  v26[2] = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN23EurekaCallCommandDriver17sendUSSDUserReplyENSt3__112basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEEN10subscriber7SimSlotEE3__0EEOS1_OT__block_invoke;
  v26[3] = &__block_descriptor_tmp_169_1;
  v26[4] = v10 + 1;
  v27 = v10;
  do
    v12 = __ldxr(p_shared_owners);
  while (__stxr(v12 + 1, p_shared_owners));
  aBlock[0] = v6;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackIRKN2vs10AnswerUSSD8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke;
  aBlock[3] = &unk_24D5E4370;
  aBlock[4] = v26;
  *(_QWORD *)(v9 + 32) = _Block_copy(aBlock);
  v13 = v27;
  if (v27)
  {
    v14 = (unint64_t *)&v27->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  v16 = v29;
  if (v29)
  {
    v17 = (unint64_t *)&v29->__shared_owners_;
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
  v19 = v20;
  v20 = 0;
  if (v19)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v20, v19);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v25);
}

void sub_216A34A70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22)
{
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a22);
  _Unwind_Resume(a1);
}

uint64_t EurekaCallCommandDriver::setCallCapability(uint64_t a1, unint64_t a2, int a3, int a4)
{
  uint64_t result;
  uint64_t *v9;
  uint64_t **v10;
  int v11;
  uint64_t **v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t **v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t **v21;
  _QWORD *v22;

  result = subscriber::isValidSimSlot();
  if ((_DWORD)result)
  {
    v9 = *(uint64_t **)(a1 + 288);
    if (v9)
    {
      while (1)
      {
        while (1)
        {
          v10 = (uint64_t **)v9;
          v11 = *((_DWORD *)v9 + 8);
          if (v11 <= a4)
            break;
          v9 = *v10;
          v12 = v10;
          if (!*v10)
            goto LABEL_10;
        }
        if (v11 >= a4)
          break;
        v9 = v10[1];
        if (!v9)
        {
          v12 = v10 + 1;
          goto LABEL_10;
        }
      }
    }
    else
    {
      v12 = (uint64_t **)(a1 + 288);
      v10 = (uint64_t **)(a1 + 288);
LABEL_10:
      v13 = (uint64_t *)v10;
      v10 = (uint64_t **)operator new(0x40uLL);
      *((_DWORD *)v10 + 8) = a4;
      v10[7] = 0;
      v10[6] = 0;
      v10[5] = (uint64_t *)(v10 + 6);
      *v10 = 0;
      v10[1] = 0;
      v10[2] = v13;
      *v12 = (uint64_t *)v10;
      v14 = **(_QWORD **)(a1 + 280);
      v15 = (uint64_t *)v10;
      if (v14)
      {
        *(_QWORD *)(a1 + 280) = v14;
        v15 = *v12;
      }
      result = (uint64_t)std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 288), v15);
      ++*(_QWORD *)(a1 + 296);
    }
    v18 = (uint64_t)v10[6];
    v17 = v10 + 6;
    v16 = v18;
    if (v18)
    {
      while (1)
      {
        while (1)
        {
          v19 = v16;
          v20 = *(_QWORD *)(v16 + 32);
          if (v20 <= a2)
            break;
          v16 = *(_QWORD *)v19;
          v21 = (uint64_t **)v19;
          if (!*(_QWORD *)v19)
            goto LABEL_21;
        }
        if (v20 >= a2)
          break;
        v16 = *(_QWORD *)(v19 + 8);
        if (!v16)
        {
          v21 = (uint64_t **)(v19 + 8);
          goto LABEL_21;
        }
      }
    }
    else
    {
      v21 = v17;
      v19 = (uint64_t)v17;
LABEL_21:
      v22 = operator new(0x30uLL);
      v22[4] = a2;
      *((_DWORD *)v22 + 10) = 0;
      result = (uint64_t)std::__tree<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>,std::less<unsigned short>,true>,std::allocator<std::__value_type<unsigned short,dispatch::block<void({block_pointer})(qmi::IndicationBase const&)>>>>::__insert_node_at(v17 - 1, v19, v21, v22);
      v19 = (uint64_t)v22;
    }
    *(_DWORD *)(v19 + 40) = a3;
  }
  return result;
}

void EurekaCallCommandDriver::setupDefaultCallCapabilities(uint64_t a1, int a2)
{
  _QWORD v2[5];
  int v3;

  v2[0] = MEMORY[0x24BDAC760];
  v2[1] = 0x40000000;
  v2[2] = ___ZN23EurekaCallCommandDriver28setupDefaultCallCapabilitiesEN10subscriber7SimSlotE_block_invoke;
  v2[3] = &__block_descriptor_tmp_22_14;
  v2[4] = a1;
  v3 = a2;
  ctu::SharedSynchronizable<CallCommandDriver>::execute_wrapped((uint64_t *)(a1 + 8), (uint64_t)v2);
}

void ___ZN23EurekaCallCommandDriver28setupDefaultCallCapabilitiesEN10subscriber7SimSlotE_block_invoke(uint64_t a1)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  uint64_t v8;
  std::__shared_weak_count *v9;

  v2 = *(_QWORD *)(a1 + 32);
  v8 = 0;
  v9 = 0;
  EurekaCallCommandDriver::getPreferredFormatterForSim(&v8, v2, *(unsigned int *)(a1 + 40));
  if (v8)
  {
    v3 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v8 + 16))(v8, 1);
    v4 = *(unsigned int *)(a1 + 40);
    if (v3)
      EurekaCallCommandDriver::fillUpC2KCallCapabilities(v2, v4);
    else
      EurekaCallCommandDriver::fillUpGSMCallCapabilities(v2, v4);
  }
  else
  {
    EurekaCallCommandDriver::setPreferredFormatterBasedOnCarrierCapabilities(v2, *(unsigned int *)(a1 + 40));
  }
  v5 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
}

void sub_216A34DB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t EurekaCallCommandDriver::isAbleToMakeCalls(uint64_t a1, char a2, uint64_t a3)
{
  int v3;
  capabilities::ct *v6;
  uint64_t v7;
  NSObject *v8;
  NSObject *v9;
  NSObject *v10;
  uint8_t v12[16];
  uint8_t v13[16];
  uint8_t buf[16];

  v3 = a3;
  v6 = (capabilities::ct *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 112) + 16))(*(_QWORD *)(a1 + 112), a3);
  v7 = capabilities::ct::supportsVoiceCall(v6);
  if ((v7 & 1) == 0)
  {
    v8 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_216897000, v8, OS_LOG_TYPE_DEFAULT, "#E Device does not support CS voice calls. Cannot dial. Returning.", buf, 2u);
    }
  }
  if (*(_BYTE *)(a1 + 305))
  {
    v9 = *(NSObject **)v6;
    if (os_log_type_enabled(*(os_log_t *)v6, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v13 = 0;
      _os_log_error_impl(&dword_216897000, v9, OS_LOG_TYPE_ERROR, "There is a silent voice call going on in Settings Model, can't dial a call. Returning", v13, 2u);
    }
    v7 = 0;
  }
  if ((a2 & 1) == 0 && !EurekaCallCommandDriver::findCallCapability(a1, *MEMORY[0x24BDC3DA0], v3))
  {
    v10 = *(NSObject **)v6;
    if (os_log_type_enabled(*(os_log_t *)v6, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v12 = 0;
      _os_log_error_impl(&dword_216897000, v10, OS_LOG_TYPE_ERROR, "Adding a new call is not allowed yet. Returning", v12, 2u);
    }
    return 0;
  }
  return v7;
}

uint64_t EurekaCallCommandDriver::findCallCapability(uint64_t a1, unint64_t a2, int a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  BOOL v6;
  uint64_t *v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  unint64_t v12;
  BOOL v13;
  _QWORD *v14;

  v3 = *(_QWORD *)(a1 + 288);
  if (!v3)
    return 0;
  v4 = a1 + 288;
  do
  {
    v5 = *(_DWORD *)(v3 + 32);
    v6 = v5 < a3;
    if (v5 >= a3)
      v7 = (uint64_t *)v3;
    else
      v7 = (uint64_t *)(v3 + 8);
    if (!v6)
      v4 = v3;
    v3 = *v7;
  }
  while (*v7);
  if (v4 == a1 + 288)
    return 0;
  if (*(_DWORD *)(v4 + 32) > a3)
    return 0;
  v10 = *(_QWORD **)(v4 + 48);
  v8 = (_QWORD *)(v4 + 48);
  v9 = v10;
  if (!v10)
    return 0;
  v11 = v8;
  do
  {
    v12 = v9[4];
    v13 = v12 >= a2;
    if (v12 >= a2)
      v14 = v9;
    else
      v14 = v9 + 1;
    if (v13)
      v11 = v9;
    v9 = (_QWORD *)*v14;
  }
  while (*v14);
  if (v11 != v8 && v11[4] <= a2)
    return *((unsigned int *)v11 + 10);
  else
    return 0;
}

uint64_t EurekaCallCommandDriver::prepareToDial(uint64_t a1, uint64_t a2)
{
  capabilities::ct *v4;
  uint64_t v5;
  NSObject *v6;
  NSObject *v7;
  uint8_t v9[16];
  uint8_t buf[16];

  v4 = (capabilities::ct *)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 112) + 16))(*(_QWORD *)(a1 + 112), *(unsigned int *)(a2 + 252));
  v5 = capabilities::ct::supportsVoiceCall(v4);
  if ((v5 & 1) == 0)
  {
    v6 = *(NSObject **)v4;
    if (os_log_type_enabled(*(os_log_t *)v4, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_216897000, v6, OS_LOG_TYPE_ERROR, "Device does not support CS voice calls. Cannot dial. Returning.", buf, 2u);
    }
  }
  if (*(_BYTE *)(a2 + 84))
  {
    if (*(_BYTE *)(a1 + 304))
    {
      v7 = *(NSObject **)v4;
      v5 = 0;
      if (os_log_type_enabled(*(os_log_t *)v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)v9 = 0;
        _os_log_impl(&dword_216897000, v7, OS_LOG_TYPE_DEFAULT, "#I In ECBM mode. Pending dial till BB is out of ECBM mode", v9, 2u);
        return 0;
      }
    }
  }
  return v5;
}

void EurekaCallCommandDriver::dial(CallCommandDriver *a1, uint64_t a2)
{
  uint64_t v4;
  os_log_t *v5;
  NSObject *v6;
  _QWORD *v7;
  NSObject *v8;
  int v9;
  char *v10;
  uint64_t *v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  _QWORD *v23;
  uint64_t v24;
  uint64_t v25;
  __int128 v26;
  unint64_t *v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t *v30;
  unint64_t v31;
  uint64_t v32;
  unint64_t *v33;
  unint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  NSObject *v37;
  NSObject *v38;
  char *v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  _QWORD *v51;
  uint64_t v52;
  char *v53;
  __int128 v54;
  unint64_t *v55;
  uint64_t v56;
  uint64_t v57;
  unint64_t v58;
  std::__shared_weak_count *v59;
  unint64_t *p_shared_owners;
  unint64_t v61;
  std::__shared_weak_count *v62;
  unint64_t *v63;
  unint64_t v64;
  uint64_t v65;
  std::__shared_weak_count *v66;
  unint64_t *v67;
  unint64_t v68;
  uint64_t v69;
  unint64_t *v70;
  unint64_t v71;
  _QWORD *v72;
  uint64_t v73;
  std::__shared_weak_count *v74;
  unint64_t *v75;
  unint64_t v76;
  std::__shared_weak_count *v77;
  unint64_t *v78;
  unint64_t v79;
  __int128 v80;
  __int128 v81;
  uint64_t v82;
  __int128 v83;
  uint64_t v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  _BYTE v88[21];
  __int128 v89;
  uint64_t v90;
  int v91;
  __int128 v92;
  uint64_t v93;
  _OWORD v94[2];
  __int128 v95;
  uint64_t v96;
  char v97;
  __int128 v98;
  char v99;
  __int128 v100;
  uint64_t v101;
  __int128 v102;
  uint64_t v103;
  __int128 v104;
  __int128 v105;
  __int128 v106;
  __int128 v107;
  _BYTE v108[21];
  int v109;
  void *v110[51];
  __int128 v111;
  char v112[8];
  uint64_t v113;
  void *v114[51];
  uint64_t v115;
  std::__shared_weak_count *v116;
  void *v117[5];
  std::__shared_weak_count *v118;
  char *v119;
  std::__shared_weak_count *v120;
  _QWORD v121[3];
  _QWORD *v122;
  _BYTE v123[408];
  __int128 v124;
  _BYTE buf[32];
  uint64_t v126;
  __int128 v127;
  uint64_t *v128;
  __int128 v129;
  __int128 v130;
  __int128 v131;
  _BYTE v132[21];
  __int128 v133;
  uint64_t v134;
  int v135;
  __int128 v136;
  uint64_t v137;
  _OWORD v138[2];
  __int128 v139;
  uint64_t v140;
  char v141;
  __int128 v142;
  char v143;
  __int128 v144;
  uint64_t v145;
  __int128 v146;
  uint64_t v147;
  __int128 v148;
  __int128 v149;
  __int128 v150;
  __int128 v151;
  _BYTE v152[21];
  int v153;
  _QWORD aBlock[3];
  _QWORD *v155;
  void **v156;
  uint64_t v157;

  v157 = *MEMORY[0x24BDAC8D0];
  v4 = *(unsigned int *)(a2 + 252);
  v5 = (os_log_t *)(*(uint64_t (**)(_QWORD *, uint64_t))(**((_QWORD **)a1 + 14) + 16))(*((_QWORD **)a1 + 14), v4);
  v6 = *v5;
  if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
  {
    v7 = (_QWORD *)(a2 + 32);
    if (*(char *)(a2 + 55) < 0)
      v7 = (_QWORD *)*v7;
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = v7;
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = subscriber::asString();
    _os_log_impl(&dword_216897000, v6, OS_LOG_TYPE_DEFAULT, "#I Dialing call to %s on slot %s", buf, 0x16u);
  }
  if (*(_DWORD *)(a2 + 64) == 7)
  {
    v8 = *v5;
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_216897000, v8, OS_LOG_TYPE_DEFAULT, "#I Visible OTASP started", buf, 2u);
    }
    (*(void (**)(_QWORD *, uint64_t))(**((_QWORD **)a1 + 27) + 24))(*((_QWORD **)a1 + 27), 1);
  }
  if (*(_BYTE *)(a2 + 84))
  {
    v124 = 0u;
    memset(&v123[8], 0, 400);
    *(_QWORD *)v123 = a1;
    CallInfo::CallInfo((CallInfo *)&v123[8], (const CallInfo *)a2);
    DWORD2(v124) = v4;
    CallInfo::CallInfo((CallInfo *)v117, (const CallInfo *)&v123[8]);
    *(_QWORD *)buf = a1;
    CallInfo::CallInfo((CallInfo *)&buf[8], (const CallInfo *)&v123[8]);
    v9 = DWORD2(v124);
    v153 = DWORD2(v124);
    v155 = 0;
    v10 = (char *)operator new(0x1B0uLL);
    *(_QWORD *)v10 = &off_24D5E2FF8;
    v11 = v128;
    *((_QWORD *)v10 + 5) = v126;
    v12 = *(_OWORD *)&buf[16];
    *(_OWORD *)(v10 + 8) = *(_OWORD *)buf;
    *(_QWORD *)&buf[16] = 0;
    *(_QWORD *)&buf[8] = 0;
    *(_OWORD *)(v10 + 24) = v12;
    *(_QWORD *)&buf[24] = 0;
    v126 = 0;
    *((_OWORD *)v10 + 3) = v127;
    *((_QWORD *)v10 + 8) = v11;
    v127 = 0uLL;
    v13 = v130;
    *(_OWORD *)(v10 + 72) = v129;
    v14 = v131;
    v15 = *(_OWORD *)v132;
    *(_QWORD *)(v10 + 133) = *(_QWORD *)&v132[13];
    *(_OWORD *)(v10 + 120) = v15;
    *(_OWORD *)(v10 + 104) = v14;
    *(_OWORD *)(v10 + 88) = v13;
    v16 = v133;
    *((_QWORD *)v10 + 20) = v134;
    *((_OWORD *)v10 + 9) = v16;
    v128 = 0;
    v133 = 0uLL;
    v134 = 0;
    *((_DWORD *)v10 + 42) = v135;
    v17 = v136;
    *((_QWORD *)v10 + 24) = v137;
    *((_OWORD *)v10 + 11) = v17;
    v136 = 0uLL;
    v137 = 0;
    v18 = v138[0];
    *(_OWORD *)(v10 + 209) = *(_OWORD *)((char *)v138 + 9);
    *(_OWORD *)(v10 + 200) = v18;
    v10[232] = 0;
    v10[256] = 0;
    if (v141)
    {
      *(_OWORD *)(v10 + 232) = v139;
      *((_QWORD *)v10 + 31) = v140;
      v140 = 0;
      v139 = 0uLL;
      v10[256] = 1;
    }
    v10[280] = v143;
    *(_OWORD *)(v10 + 264) = v142;
    *((_QWORD *)v10 + 38) = v145;
    *((_OWORD *)v10 + 18) = v144;
    v144 = 0uLL;
    *((_QWORD *)v10 + 41) = v147;
    *(_OWORD *)(v10 + 312) = v146;
    v145 = 0;
    v146 = 0uLL;
    v147 = 0;
    v19 = v149;
    *((_OWORD *)v10 + 21) = v148;
    *((_OWORD *)v10 + 22) = v19;
    v20 = v150;
    v21 = v151;
    v22 = *(_OWORD *)v152;
    *(_QWORD *)(v10 + 413) = *(_QWORD *)&v152[13];
    *((_OWORD *)v10 + 24) = v21;
    *((_OWORD *)v10 + 25) = v22;
    *((_OWORD *)v10 + 23) = v20;
    *((_DWORD *)v10 + 106) = v9;
    v155 = v10;
    EurekaCallCommandDriver::sendDialReq(a1, (uint64_t)v117, aBlock);
    v23 = v155;
    if (v155 == aBlock)
    {
      v24 = 4;
      v23 = aBlock;
    }
    else
    {
      if (!v155)
      {
LABEL_36:
        CallInfo::~CallInfo((void **)&buf[8]);
        CallInfo::~CallInfo(v117);
        CallInfo::~CallInfo((void **)&v123[8]);
        return;
      }
      v24 = 5;
    }
    (*(void (**)(void))(*v23 + 8 * v24))();
    goto LABEL_36;
  }
  v116 = 0;
  v115 = 0;
  EurekaCallCommandDriver::getPreferredFormatterForSim(&v115, (uint64_t)a1, v4);
  v25 = v115;
  if (!v115)
  {
    v37 = *v5;
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_216897000, v37, OS_LOG_TYPE_ERROR, "Second call cannot be dialed out if preferred formatter is not set. Not dialing.", buf, 2u);
    }
    goto LABEL_91;
  }
  memset(v123, 0, 64);
  CallInfo::CallInfo((CallInfo *)v114, (const CallInfo *)a2);
  (*(void (**)(_BYTE *__return_ptr, uint64_t, void **, _QWORD **))(*(_QWORD *)v25 + 24))(v123, v25, v114, (_QWORD **)a1 + 17);
  CallInfo::~CallInfo(v114);
  v26 = *(_OWORD *)v123;
  if (!*(_QWORD *)&v123[8])
    goto LABEL_21;
  v27 = (unint64_t *)(*(_QWORD *)&v123[8] + 8);
  do
    v28 = __ldxr(v27);
  while (__stxr(v28 + 1, v27));
  do
    v29 = __ldaxr(v27);
  while (__stlxr(v29 - 1, v27));
  if (v29)
  {
LABEL_21:
    if ((_QWORD)v26)
      goto LABEL_22;
LABEL_41:
    v38 = *v5;
    if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_216897000, v38, OS_LOG_TYPE_DEFAULT, "#I Formatter requires a normal dial", buf, 2u);
    }
    CallInfo::CallInfo((CallInfo *)v110, (const CallInfo *)a2);
    *(_QWORD *)&v80 = a1;
    CallInfo::CallInfo((CallInfo *)((char *)&v80 + 8), (const CallInfo *)a2);
    v109 = v4;
    v122 = 0;
    v39 = (char *)operator new(0x1B0uLL);
    *(_QWORD *)v39 = &off_24D5E4690;
    v40 = v81;
    *(_OWORD *)(v39 + 8) = v80;
    *((_QWORD *)&v80 + 1) = 0;
    *(_QWORD *)&v81 = 0;
    *(_OWORD *)(v39 + 24) = v40;
    *((_QWORD *)v39 + 5) = v82;
    *((_QWORD *)&v81 + 1) = 0;
    v82 = 0;
    *((_OWORD *)v39 + 3) = v83;
    *((_QWORD *)v39 + 8) = v84;
    v83 = 0uLL;
    v41 = v86;
    *(_OWORD *)(v39 + 72) = v85;
    v42 = v87;
    v43 = *(_OWORD *)v88;
    *(_QWORD *)(v39 + 133) = *(_QWORD *)&v88[13];
    *(_OWORD *)(v39 + 120) = v43;
    *(_OWORD *)(v39 + 104) = v42;
    *(_OWORD *)(v39 + 88) = v41;
    v44 = v89;
    *((_QWORD *)v39 + 20) = v90;
    *((_OWORD *)v39 + 9) = v44;
    v84 = 0;
    v89 = 0uLL;
    v90 = 0;
    *((_DWORD *)v39 + 42) = v91;
    v45 = v92;
    *((_QWORD *)v39 + 24) = v93;
    *((_OWORD *)v39 + 11) = v45;
    v92 = 0uLL;
    v93 = 0;
    v46 = v94[0];
    *(_OWORD *)(v39 + 209) = *(_OWORD *)((char *)v94 + 9);
    *(_OWORD *)(v39 + 200) = v46;
    v39[232] = 0;
    v39[256] = 0;
    if (v97)
    {
      *(_OWORD *)(v39 + 232) = v95;
      *((_QWORD *)v39 + 31) = v96;
      v96 = 0;
      v95 = 0uLL;
      v39[256] = 1;
    }
    v39[280] = v99;
    *(_OWORD *)(v39 + 264) = v98;
    *((_QWORD *)v39 + 38) = v101;
    *((_OWORD *)v39 + 18) = v100;
    v100 = 0uLL;
    *((_QWORD *)v39 + 41) = v103;
    *(_OWORD *)(v39 + 312) = v102;
    v101 = 0;
    v102 = 0uLL;
    v103 = 0;
    v47 = v105;
    *((_OWORD *)v39 + 21) = v104;
    *((_OWORD *)v39 + 22) = v47;
    v48 = v106;
    v49 = v107;
    v50 = *(_OWORD *)v108;
    *(_QWORD *)(v39 + 413) = *(_QWORD *)&v108[13];
    *((_OWORD *)v39 + 24) = v49;
    *((_OWORD *)v39 + 25) = v50;
    *((_OWORD *)v39 + 23) = v48;
    *((_DWORD *)v39 + 106) = v4;
    v122 = v39;
    EurekaCallCommandDriver::sendDialReq(a1, (uint64_t)v110, v121);
    v51 = v122;
    if (v122 == v121)
    {
      v52 = 4;
      v51 = v121;
    }
    else
    {
      if (!v122)
      {
LABEL_80:
        CallInfo::~CallInfo((void **)&v80 + 1);
        CallInfo::~CallInfo(v110);
        goto LABEL_81;
      }
      v52 = 5;
    }
    (*(void (**)(void))(*v51 + 8 * v52))();
    goto LABEL_80;
  }
  (*(void (**)(_QWORD))(**((_QWORD **)&v26 + 1) + 16))(*((_QWORD *)&v26 + 1));
  std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v26 + 1));
  if (!(_QWORD)v26)
    goto LABEL_41;
LABEL_22:
  if ((v4 - 1) >= 3)
    LODWORD(v4) = 0;
  v111 = *(_OWORD *)v123;
  if (*(_QWORD *)&v123[8])
  {
    v30 = (unint64_t *)(*(_QWORD *)&v123[8] + 8);
    do
      v31 = __ldxr(v30);
    while (__stxr(v31 + 1, v30));
  }
  v32 = qmi::ClientRouter::get();
  qmi::ClientRouter::SendProxy::SendProxy<qmi::MutableMessageBase>((uint64_t)v112, v4, v32);
  *(_QWORD *)buf = a1;
  *(_QWORD *)&buf[8] = v5;
  *(_OWORD *)&buf[16] = *(_OWORD *)v123;
  if (*(_QWORD *)&v123[8])
  {
    v33 = (unint64_t *)(*(_QWORD *)&v123[8] + 8);
    do
      v34 = __ldxr(v33);
    while (__stxr(v34 + 1, v33));
  }
  v35 = &v126;
  v36 = *(_QWORD *)&v123[40];
  if (*(_QWORD *)&v123[40])
  {
    if (*(_BYTE **)&v123[40] == &v123[16])
    {
      v128 = &v126;
      (*(void (**)(void))(**(_QWORD **)&v123[40] + 24))();
      goto LABEL_49;
    }
    v36 = (*(uint64_t (**)(void))(**(_QWORD **)&v123[40] + 16))();
  }
  v128 = (uint64_t *)v36;
LABEL_49:
  v129 = *(_OWORD *)&v123[48];
  v53 = (char *)operator new(0x68uLL);
  v54 = *(_OWORD *)&buf[16];
  *(_OWORD *)(v53 + 24) = *(_OWORD *)buf;
  *((_QWORD *)v53 + 1) = 0;
  v55 = (unint64_t *)(v53 + 8);
  *((_QWORD *)v53 + 2) = 0;
  *(_QWORD *)v53 = &off_24D5E45E8;
  *(_OWORD *)(v53 + 40) = v54;
  *(_OWORD *)&buf[16] = 0uLL;
  std::__function::__value_func<void ()(qmi::ResponseBase const&)>::__value_func[abi:ne180100]((uint64_t)(v53 + 56), (uint64_t)&v126);
  *(_OWORD *)(v53 + 88) = v129;
  v119 = v53 + 24;
  v120 = (std::__shared_weak_count *)v53;
  v56 = v113;
  v57 = MEMORY[0x24BDAC760];
  v117[0] = (void *)MEMORY[0x24BDAC760];
  v117[1] = (void *)1174405120;
  v117[2] = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN23EurekaCallCommandDriver4dialE8CallInfoE3__1EEOS1_OT__block_invoke;
  v117[3] = &__block_descriptor_tmp_175_2;
  v117[4] = v53 + 24;
  v118 = (std::__shared_weak_count *)v53;
  do
    v58 = __ldxr(v55);
  while (__stxr(v58 + 1, v55));
  aBlock[0] = v57;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZNO3qmi6Client9SendProxy8callbackINS_12ResponseBaseEEEOS1_U13block_pointerFvT_E_block_invoke;
  v155 = &unk_24D5E4630;
  v156 = v117;
  *(_QWORD *)(v56 + 32) = _Block_copy(aBlock);
  v59 = v118;
  if (v118)
  {
    p_shared_owners = (unint64_t *)&v118->__shared_owners_;
    do
      v61 = __ldaxr(p_shared_owners);
    while (__stlxr(v61 - 1, p_shared_owners));
    if (!v61)
    {
      ((void (*)(std::__shared_weak_count *))v59->__on_zero_shared)(v59);
      std::__shared_weak_count::__release_weak(v59);
    }
  }
  v62 = v120;
  if (v120)
  {
    v63 = (unint64_t *)&v120->__shared_owners_;
    do
      v64 = __ldaxr(v63);
    while (__stlxr(v64 - 1, v63));
    if (!v64)
    {
      ((void (*)(std::__shared_weak_count *))v62->__on_zero_shared)(v62);
      std::__shared_weak_count::__release_weak(v62);
    }
  }
  if (v128 == &v126)
  {
    v65 = 4;
  }
  else
  {
    if (!v128)
      goto LABEL_66;
    v65 = 5;
    v35 = v128;
  }
  (*(void (**)(uint64_t *))(*v35 + 8 * v65))(v35);
LABEL_66:
  v66 = *(std::__shared_weak_count **)&buf[24];
  if (*(_QWORD *)&buf[24])
  {
    v67 = (unint64_t *)(*(_QWORD *)&buf[24] + 8);
    do
      v68 = __ldaxr(v67);
    while (__stlxr(v68 - 1, v67));
    if (!v68)
    {
      ((void (*)(std::__shared_weak_count *))v66->__on_zero_shared)(v66);
      std::__shared_weak_count::__release_weak(v66);
    }
  }
  v69 = v113;
  v113 = 0;
  if (v69)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v113, v69);
  if (*((_QWORD *)&v111 + 1))
  {
    v70 = (unint64_t *)(*((_QWORD *)&v111 + 1) + 8);
    do
      v71 = __ldaxr(v70);
    while (__stlxr(v71 - 1, v70));
    if (!v71)
    {
      (*(void (**)(_QWORD))(**((_QWORD **)&v111 + 1) + 16))(*((_QWORD *)&v111 + 1));
      std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v111 + 1));
    }
  }
LABEL_81:
  v72 = *(_QWORD **)&v123[40];
  if (*(_BYTE **)&v123[40] == &v123[16])
  {
    v73 = 4;
    v72 = &v123[16];
    goto LABEL_85;
  }
  if (*(_QWORD *)&v123[40])
  {
    v73 = 5;
LABEL_85:
    (*(void (**)(void))(*v72 + 8 * v73))();
  }
  v74 = *(std::__shared_weak_count **)&v123[8];
  if (*(_QWORD *)&v123[8])
  {
    v75 = (unint64_t *)(*(_QWORD *)&v123[8] + 8);
    do
      v76 = __ldaxr(v75);
    while (__stlxr(v76 - 1, v75));
    if (!v76)
    {
      ((void (*)(std::__shared_weak_count *))v74->__on_zero_shared)(v74);
      std::__shared_weak_count::__release_weak(v74);
    }
  }
LABEL_91:
  v77 = v116;
  if (v116)
  {
    v78 = (unint64_t *)&v116->__shared_owners_;
    do
      v79 = __ldaxr(v78);
    while (__stlxr(v79 - 1, v78));
    if (!v79)
    {
      ((void (*)(std::__shared_weak_count *))v77->__on_zero_shared)(v77);
      std::__shared_weak_count::__release_weak(v77);
    }
  }
}

void sub_216A35B60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,void *a62)
{
  uint64_t v62;
  void **v63;
  unint64_t *v65;
  uint64_t v66;

  v65 = (unint64_t *)STACK[0x6C8];
  if (STACK[0x6C8] == v62)
  {
    v66 = 4;
    v65 = &STACK[0x6B0];
  }
  else
  {
    if (!v65)
      goto LABEL_6;
    v66 = 5;
  }
  (*(void (**)(void))(*v65 + 8 * v66))();
LABEL_6:
  CallInfo::~CallInfo(v63);
  CallInfo::~CallInfo(&a62);
  EurekaVoiceRequestMessage::~EurekaVoiceRequestMessage((EurekaVoiceRequestMessage *)&STACK[0x6D0]);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&STACK[0x4F8]);
  _Unwind_Resume(a1);
}

uint64_t EurekaCallCommandDriver::dial(CallInfo)::$_1::~$_1(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  v2 = (_QWORD *)(a1 + 32);
  v3 = *(_QWORD **)(a1 + 56);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](a1 + 16);
  return a1;
}

void EurekaCallCommandDriver::sendDialReq(CallCommandDriver *a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v6;
  os_log_t *v7;
  uint64_t v8;
  _QWORD *v9;
  int v10;
  int v11;
  NSObject *v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  NSObject *v16;
  _QWORD *v17;
  int v18;
  NSObject *v19;
  _QWORD *v20;
  const void **v21;
  char *v22;
  _BYTE *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  char *v31;
  uint64_t *v32;
  char *v33;
  char *v34;
  char *v35;
  uint64_t v36;
  unsigned int v37;
  char v38;
  NSObject *v39;
  uint64_t v40;
  const void **v41;
  char *v42;
  char *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  _QWORD *v47;
  uint64_t v48;
  unint64_t v49;
  unint64_t v50;
  char *v51;
  uint64_t *v52;
  char *v53;
  char *v54;
  char *v55;
  uint64_t v56;
  _BYTE *v57;
  uint64_t v58;
  std::__shared_weak_count *v59;
  unint64_t *p_shared_owners;
  std::__shared_weak_count_vtbl *v61;
  uint64_t v62;
  uint64_t v63;
  unint64_t v64;
  std::__shared_weak_count *v65;
  unint64_t *v66;
  unint64_t v67;
  std::__shared_weak_count *v68;
  unint64_t *v69;
  unint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  _QWORD v74[5];
  _QWORD v75[4];
  void *v76[51];
  void *__p[2];
  __int128 v78;
  _QWORD *v79;
  std::__shared_weak_count *v80;
  uint8_t buf[8];
  uint64_t v82;
  void (*v83)(uint64_t, uint64_t);
  void *v84;
  _BYTE *v85;
  _BYTE v86[24];
  void *v87;
  _QWORD *v88;
  std::__shared_weak_count *v89;
  uint64_t v90;

  v90 = *MEMORY[0x24BDAC8D0];
  *(_OWORD *)__p = 0u;
  v78 = 0u;
  qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p);
  v6 = *(unsigned int *)(a2 + 252);
  v7 = (os_log_t *)(*(uint64_t (**)(_QWORD *, uint64_t))(**((_QWORD **)a1 + 14) + 16))(*((_QWORD **)a1 + 14), v6);
  v8 = MEMORY[0x24BDAC760];
  v75[0] = MEMORY[0x24BDAC760];
  v75[1] = 1174405120;
  v75[2] = ___ZN23EurekaCallCommandDriver11sendDialReqE8CallInfoNSt3__18functionIFvRKN2vs13VoiceDialCall8ResponseEEEE_block_invoke;
  v75[3] = &__block_descriptor_tmp_23_9;
  CallInfo::CallInfo((CallInfo *)v76, (const CallInfo *)a2);
  v9 = (_QWORD *)qmi::MutableMessageBase::getTLV<vs::tlv::CallingNumber>(__p, 1);
  ___ZN23EurekaCallCommandDriver11sendDialReqE8CallInfoNSt3__18functionIFvRKN2vs13VoiceDialCall8ResponseEEEE_block_invoke((uint64_t)v75, v9);
  v10 = *(_DWORD *)(a2 + 64);
  if (v10 == 3)
  {
    *(_QWORD *)v86 = 0;
    *(_QWORD *)&v86[8] = 0;
    EurekaCallCommandDriver::getPreferredFormatterForSim(v86, (uint64_t)a1, v6);
    if (*(_QWORD *)v86)
    {
      if ((*(unsigned int (**)(_QWORD))(**(_QWORD **)v86 + 144))(*(_QWORD *)v86))
        v11 = 2;
      else
        v11 = 1;
    }
    else
    {
      v12 = *v7;
      if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_216897000, v12, OS_LOG_TYPE_DEFAULT, "#I Dialing test emergency number but not registered to a network as yet, so don't know if it's okay to dial test number. Dialing as normal call to BB", buf, 2u);
      }
      v11 = 1;
    }
    *(_DWORD *)(a2 + 64) = v11;
    v13 = *(std::__shared_weak_count **)&v86[8];
    if (*(_QWORD *)&v86[8])
    {
      v14 = (unint64_t *)(*(_QWORD *)&v86[8] + 8);
      do
        v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }
    v10 = *(_DWORD *)(a2 + 64);
  }
  if (v10 == 2)
  {
    v18 = *(_DWORD *)(a2 + 96);
    v19 = *v7;
    if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
    {
      v20 = (_QWORD *)(a2 + 32);
      if (*(char *)(a2 + 55) < 0)
        v20 = (_QWORD *)*v20;
      *(_DWORD *)v86 = 136315394;
      *(_QWORD *)&v86[4] = v20;
      *(_WORD *)&v86[12] = 1024;
      *(_DWORD *)&v86[14] = v18;
      _os_log_impl(&dword_216897000, v19, OS_LOG_TYPE_DEFAULT, "#I Dialing emergency call, %s, with category, %d", v86, 0x12u);
    }
    v21 = (const void **)__p[1];
    if (__p[1] != (void *)v78)
    {
      while (*((_BYTE *)*v21 + 8) != 20)
      {
        if (++v21 == (const void **)v78)
          goto LABEL_33;
      }
    }
    if (v21 == (const void **)v78)
    {
LABEL_33:
      v24 = operator new();
      v25 = v24;
      *(_WORD *)(v24 + 8) = 20;
      *(_QWORD *)v24 = &off_24D5E4728;
      v26 = v78;
      if ((unint64_t)v78 >= *((_QWORD *)&v78 + 1))
      {
        v28 = (uint64_t)(v78 - (unint64_t)__p[1]) >> 3;
        if ((unint64_t)(v28 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v29 = (uint64_t)(*((_QWORD *)&v78 + 1) - (unint64_t)__p[1]) >> 2;
        if (v29 <= v28 + 1)
          v29 = v28 + 1;
        if (*((_QWORD *)&v78 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v30 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v30 = v29;
        if (v30)
          v31 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v78 + 8, v30);
        else
          v31 = 0;
        v32 = (uint64_t *)&v31[8 * v28];
        v33 = &v31[8 * v30];
        *v32 = v25;
        v27 = v32 + 1;
        v35 = (char *)__p[1];
        v34 = (char *)v78;
        if ((void *)v78 != __p[1])
        {
          do
          {
            v36 = *((_QWORD *)v34 - 1);
            v34 -= 8;
            *--v32 = v36;
          }
          while (v34 != v35);
          v34 = (char *)__p[1];
        }
        __p[1] = v32;
        *(_QWORD *)&v78 = v27;
        *((_QWORD *)&v78 + 1) = v33;
        if (v34)
          operator delete(v34);
      }
      else
      {
        *(_QWORD *)v78 = v24;
        v27 = (_QWORD *)(v26 + 8);
      }
      v23 = (_BYTE *)(v25 + 9);
      *(_QWORD *)&v78 = v27;
    }
    else
    {
      if (!v22)
        __cxa_bad_cast();
      v23 = v22 + 9;
    }
    *v23 = v18;
    *(_BYTE *)qmi::MutableMessageBase::getTLV<vs::tlv::CallType>(__p, 16) = 9;
  }
  else if (v10 == 1)
  {
    v16 = *v7;
    if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
    {
      v17 = (_QWORD *)(a2 + 32);
      if (*(char *)(a2 + 55) < 0)
        v17 = (_QWORD *)*v17;
      *(_DWORD *)v86 = 136315138;
      *(_QWORD *)&v86[4] = v17;
      _os_log_impl(&dword_216897000, v16, OS_LOG_TYPE_DEFAULT, "#I Dialing Normal Voice Call(%s)", v86, 0xCu);
    }
    *(_BYTE *)qmi::MutableMessageBase::getTLV<vs::tlv::CallType>(__p, 16) = 0;
  }
  v37 = CallCommandDriver::computeClirValue_sync(a1, (const CallInfo *)a2);
  if (v37 <= 1)
  {
    if (v37 == 1)
      v38 = 2;
    else
      v38 = 1;
    v39 = *v7;
    if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
    {
      v40 = asString();
      *(_DWORD *)v86 = 136315138;
      *(_QWORD *)&v86[4] = v40;
      _os_log_impl(&dword_216897000, v39, OS_LOG_TYPE_DEFAULT, "#I Setting CLIR - %s", v86, 0xCu);
    }
    v41 = (const void **)__p[1];
    if (__p[1] != (void *)v78)
    {
      while (*((_BYTE *)*v41 + 8) != 17)
      {
        if (++v41 == (const void **)v78)
          goto LABEL_64;
      }
    }
    if (v41 == (const void **)v78)
    {
LABEL_64:
      v44 = operator new();
      v45 = v44;
      *(_WORD *)(v44 + 8) = 17;
      *(_QWORD *)v44 = &off_24D5E4778;
      v46 = v78;
      if ((unint64_t)v78 >= *((_QWORD *)&v78 + 1))
      {
        v48 = (uint64_t)(v78 - (unint64_t)__p[1]) >> 3;
        if ((unint64_t)(v48 + 1) >> 61)
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        v49 = (uint64_t)(*((_QWORD *)&v78 + 1) - (unint64_t)__p[1]) >> 2;
        if (v49 <= v48 + 1)
          v49 = v48 + 1;
        if (*((_QWORD *)&v78 + 1) - (unint64_t)__p[1] >= 0x7FFFFFFFFFFFFFF8)
          v50 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v50 = v49;
        if (v50)
          v51 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<wds::tlv::Ipv4AddrInfo>>((uint64_t)&v78 + 8, v50);
        else
          v51 = 0;
        v52 = (uint64_t *)&v51[8 * v48];
        v53 = &v51[8 * v50];
        *v52 = v45;
        v47 = v52 + 1;
        v55 = (char *)__p[1];
        v54 = (char *)v78;
        if ((void *)v78 != __p[1])
        {
          do
          {
            v56 = *((_QWORD *)v54 - 1);
            v54 -= 8;
            *--v52 = v56;
          }
          while (v54 != v55);
          v54 = (char *)__p[1];
        }
        __p[1] = v52;
        *(_QWORD *)&v78 = v47;
        *((_QWORD *)&v78 + 1) = v53;
        if (v54)
          operator delete(v54);
      }
      else
      {
        *(_QWORD *)v78 = v44;
        v47 = (_QWORD *)(v46 + 8);
      }
      v43 = (char *)(v45 + 9);
      *(_QWORD *)&v78 = v47;
    }
    else
    {
      if (!v42)
        __cxa_bad_cast();
      v43 = v42 + 9;
    }
    *v43 = v38;
  }
  if ((*(unsigned int (**)(_QWORD *, uint64_t))(**((_QWORD **)a1 + 15) + 360))(*((_QWORD **)a1 + 15), a2))
  {
    v74[0] = v8;
    v74[1] = 0x40000000;
    v74[2] = ___ZN23EurekaCallCommandDriver11sendDialReqE8CallInfoNSt3__18functionIFvRKN2vs13VoiceDialCall8ResponseEEEE_block_invoke_2_36;
    v74[3] = &__block_descriptor_tmp_38_9;
    v74[4] = v7;
    v57 = (_BYTE *)qmi::MutableMessageBase::getTLV<vs::tlv::TtyMode>(__p, 96);
    ___ZN23EurekaCallCommandDriver11sendDialReqE8CallInfoNSt3__18functionIFvRKN2vs13VoiceDialCall8ResponseEEEE_block_invoke_2_36((uint64_t)v74, v57);
  }
  if ((v6 - 1) >= 3)
    LODWORD(v6) = 0;
  v58 = qmi::ClientRouter::get();
  qmi::ClientRouter::SendProxy::SendProxy<vs::VoiceDialCall::Request>((uint64_t)&v72, v6, v58);
  *(_DWORD *)(v73 + 16) = 45000;
  v59 = (std::__shared_weak_count *)operator new(0x38uLL);
  v59->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v59->__shared_owners_;
  v59->__shared_weak_owners_ = 0;
  v59->__vftable = (std::__shared_weak_count_vtbl *)&off_24D5E47E0;
  v61 = (std::__shared_weak_count_vtbl *)&v59[1];
  v62 = a3[3];
  if (v62)
  {
    if ((_QWORD *)v62 == a3)
    {
      v59[2].__vftable = v61;
      (*(void (**)(_QWORD *, std::__shared_weak_count_vtbl *))(*a3 + 24))(a3, v61);
      goto LABEL_91;
    }
    v62 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v62 + 16))(v62);
  }
  v59[2].__vftable = (std::__shared_weak_count_vtbl *)v62;
LABEL_91:
  v79 = &v59[1].__vftable;
  v80 = v59;
  v63 = v73;
  *(_QWORD *)v86 = v8;
  *(_QWORD *)&v86[8] = 1174405120;
  *(_QWORD *)&v86[16] = ___ZNO3qmi12ClientRouter9SendProxy8callbackIRNSt3__18functionIFvRKN2vs13VoiceDialCall8ResponseEEEEEEOS1_OT__block_invoke;
  v87 = &__block_descriptor_tmp_178_2;
  v88 = &v59[1].__vftable;
  v89 = v59;
  do
    v64 = __ldxr(p_shared_owners);
  while (__stxr(v64 + 1, p_shared_owners));
  *(_QWORD *)buf = v8;
  v82 = 0x40000000;
  v83 = ___ZNO3qmi6Client9SendProxy8callbackIRKN2vs13VoiceDialCall8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke_0;
  v84 = &unk_24D5E4828;
  v85 = v86;
  *(_QWORD *)(v63 + 32) = _Block_copy(buf);
  v65 = v89;
  if (v89)
  {
    v66 = (unint64_t *)&v89->__shared_owners_;
    do
      v67 = __ldaxr(v66);
    while (__stlxr(v67 - 1, v66));
    if (!v67)
    {
      ((void (*)(std::__shared_weak_count *))v65->__on_zero_shared)(v65);
      std::__shared_weak_count::__release_weak(v65);
    }
  }
  v68 = v80;
  if (v80)
  {
    v69 = (unint64_t *)&v80->__shared_owners_;
    do
      v70 = __ldaxr(v69);
    while (__stlxr(v70 - 1, v69));
    if (!v70)
    {
      ((void (*)(std::__shared_weak_count *))v68->__on_zero_shared)(v68);
      std::__shared_weak_count::__release_weak(v68);
    }
  }
  v71 = v73;
  v73 = 0;
  if (v71)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v73, v71);
  CallInfo::~CallInfo(v76);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
}

void sub_216A364FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  char a71;
  void **v71;

  CallInfo::~CallInfo(v71);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)&a71);
  _Unwind_Resume(a1);
}

void __copy_helper_block_e8_32c13_ZTS8CallInfo(uint64_t a1, uint64_t a2)
{
  CallInfo::CallInfo((CallInfo *)(a1 + 32), (const CallInfo *)(a2 + 32));
}

void __destroy_helper_block_e8_32c13_ZTS8CallInfo(uint64_t a1)
{
  CallInfo::~CallInfo((void **)(a1 + 32));
}

void ___ZN23EurekaCallCommandDriver11sendDialReqE8CallInfoNSt3__18functionIFvRKN2vs13VoiceDialCall8ResponseEEEE_block_invoke_2_36(uint64_t a1, _BYTE *a2)
{
  NSObject *v3;
  uint8_t v4[16];

  v3 = **(NSObject ***)(a1 + 32);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v4 = 0;
    _os_log_impl(&dword_216897000, v3, OS_LOG_TYPE_DEFAULT, "#I Setting TTY to On, Full", v4, 2u);
  }
  *a2 = 0;
}

void EurekaCallCommandDriver::handleNormalVoiceDialResp(uint64_t a1, qmi::MessageBase *a2, const void **a3, uint64_t a4)
{
  os_log_t *v8;
  NSObject **v9;
  int v10;
  NSObject *v11;
  int v12;
  char v13;
  NSObject *v14;
  int v15;
  std::mutex *ServiceMap;
  std::mutex *v17;
  unint64_t v18;
  unsigned __int8 *v19;
  uint64_t v20;
  unsigned int v21;
  _QWORD *v22;
  std::__shared_weak_count *v23;
  uint64_t v24;
  unint64_t *p_shared_owners;
  unint64_t v26;
  unint64_t *v27;
  unint64_t v28;
  unint64_t v29;
  NSObject *v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  uint64_t v34;
  int v35;
  _QWORD v36[5];
  void *__p;
  char v38;
  _OWORD v39[5];
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  uint64_t v60;
  unint64_t v61;
  _BYTE v62[24];
  int v63;
  uint8_t buf[8];
  std::__shared_weak_count *v65;
  uint64_t v66;

  v66 = *MEMORY[0x24BDAC8D0];
  v60 = 0;
  v58 = 0u;
  v59 = 0u;
  v56 = 0u;
  v57 = 0u;
  v54 = 0u;
  v55 = 0u;
  v52 = 0u;
  v53 = 0u;
  v50 = 0u;
  v51 = 0u;
  v48 = 0u;
  v49 = 0u;
  v46 = 0u;
  v47 = 0u;
  v44 = 0u;
  v45 = 0u;
  v42 = 0u;
  v43 = 0u;
  v40 = 0u;
  v41 = 0u;
  memset(v39, 0, sizeof(v39));
  CallInfo::CallInfo((CallInfo *)v39);
  ctu::SharedRef<__CFUUID const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUUID const>::operator=((const void **)v39, a3);
  HIDWORD(v50) = a4;
  v8 = (os_log_t *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 112) + 16))(*(_QWORD *)(a1 + 112), a4);
  v9 = v8;
  v10 = *((_DWORD *)a2 + 1);
  if (v10)
  {
    v11 = *v8;
    if (os_log_type_enabled(*v8, OS_LOG_TYPE_ERROR))
    {
      v34 = qmi::asString();
      v35 = *((_DWORD *)a2 + 1);
      *(_DWORD *)v62 = 136315394;
      *(_QWORD *)&v62[4] = v34;
      *(_WORD *)&v62[12] = 1024;
      *(_DWORD *)&v62[14] = v35;
      _os_log_error_impl(&dword_216897000, v11, OS_LOG_TYPE_ERROR, "Error in voice dial response with %s (0x%x)", v62, 0x12u);
      v10 = *((_DWORD *)a2 + 1);
    }
    v12 = (unsigned __int16)v10;
    if ((unsigned __int16)v10 <= 0x5Au)
    {
      if (!(_WORD)v10)
        goto LABEL_22;
      if ((unsigned __int16)v10 == 35)
      {
        v12 = 36;
        goto LABEL_22;
      }
    }
    else
    {
      switch((unsigned __int16)v10)
      {
        case '[':
          v12 = 41;
          goto LABEL_22;
        case 'j':
          v12 = 37;
          goto LABEL_22;
        case 'f':
          v12 = 35;
          goto LABEL_22;
      }
    }
    v12 = 1;
LABEL_22:
    *(_QWORD *)buf = 0;
    v65 = 0;
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
    v17 = ServiceMap;
    v18 = *(_QWORD *)(MEMORY[0x24BDC3CC0] + 8);
    if ((v18 & 0x8000000000000000) != 0)
    {
      v19 = (unsigned __int8 *)(v18 & 0x7FFFFFFFFFFFFFFFLL);
      v20 = 5381;
      do
      {
        v18 = v20;
        v21 = *v19++;
        v20 = (33 * v20) ^ v21;
      }
      while (v21);
    }
    *(_QWORD *)v62 = 0;
    *(_QWORD *)&v62[8] = 0;
    std::mutex::lock(ServiceMap);
    v61 = v18;
    v22 = std::__hash_table<std::__hash_value_type<unsigned long,std::shared_ptr<void>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::shared_ptr<void>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::shared_ptr<void>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::shared_ptr<void>>>>::find<unsigned long>(&v17[1].__m_.__sig, &v61);
    if (v22)
    {
      v24 = v22[3];
      v23 = (std::__shared_weak_count *)v22[4];
      if (v23)
      {
        p_shared_owners = (unint64_t *)&v23->__shared_owners_;
        do
          v26 = __ldxr(p_shared_owners);
        while (__stxr(v26 + 1, p_shared_owners));
      }
    }
    else
    {
      v24 = 0;
      v23 = 0;
    }
    *(_QWORD *)v62 = v24;
    *(_QWORD *)&v62[8] = v23;
    std::mutex::unlock(v17);
    *(_QWORD *)buf = v24;
    v65 = v23;
    if (v23)
    {
      v27 = (unint64_t *)&v23->__shared_owners_;
      do
        v28 = __ldxr(v27);
      while (__stxr(v28 + 1, v27));
      do
        v29 = __ldaxr(v27);
      while (__stlxr(v29 - 1, v27));
      if (!v29)
      {
        ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
        std::__shared_weak_count::__release_weak(v23);
      }
    }
    if (v10 <= 89)
    {
      if (v10 <= 0x30 && ((1 << v10) & 0x1040001826010) != 0)
        goto LABEL_44;
    }
    else
    {
      if (v10 <= 241)
      {
        switch(v10)
        {
          case 'Z':
            goto LABEL_44;
          case '[':
            (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)buf + 240))(*(_QWORD *)buf, a4);
            v30 = *v9;
            if (!os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
              goto LABEL_45;
            *(_WORD *)v62 = 0;
            break;
          case '\\':
          case ']':
          case '^':
            goto LABEL_61;
          case '_':
            if (((*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)buf + 248))(*(_QWORD *)buf, a4) & 1) == 0)
              goto LABEL_66;
            goto LABEL_45;
            goto LABEL_59;
          default:
            if (v10 != 228)
              goto LABEL_61;
            goto LABEL_44;
        }
        goto LABEL_68;
      }
      if (v10 <= 513)
      {
        if (v10 == 242)
        {
LABEL_59:
          (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)buf + 248))(*(_QWORD *)buf, a4);
          goto LABEL_45;
        }
        if (v10 != 243)
          goto LABEL_61;
LABEL_44:
        v30 = *v9;
        if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)v62 = 0;
LABEL_68:
          _os_log_error_impl(&dword_216897000, v30, OS_LOG_TYPE_ERROR, "Accepted this error. Don't do anything besides ending the call.", v62, 2u);
        }
LABEL_45:
        v31 = v65;
        if (v65)
        {
          v32 = (unint64_t *)&v65->__shared_owners_;
          do
            v33 = __ldaxr(v32);
          while (__stlxr(v33 - 1, v32));
          if (!v33)
          {
            ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
            std::__shared_weak_count::__release_weak(v31);
          }
        }
LABEL_50:
        (*(void (**)(_QWORD, _OWORD *))(**(_QWORD **)(a1 + 120) + 16))(*(_QWORD *)(a1 + 120), v39);
        goto LABEL_51;
      }
      if (v10 == 514 || v10 == 65537)
        goto LABEL_44;
    }
LABEL_61:
    std::string::basic_string[abi:ne180100]<0>(&__p, "Error in Dial Response");
    rest::ResetPayload::ResetPayload();
    ctu::rest::event_t<rest::reset_request,rest::ResetPayload>::send();
    if ((v62[23] & 0x80000000) != 0)
      operator delete(*(void **)v62);
    if (v38 < 0)
      operator delete(__p);
LABEL_66:
    WORD2(v42) = v10;
    DWORD2(v42) = v12;
    BYTE12(v42) = 1;
    goto LABEL_45;
  }
  *(_QWORD *)v62 = 0;
  *(_QWORD *)&v62[8] = v62;
  *(_QWORD *)&v62[16] = 0x2000000000;
  v63 = -1;
  v36[0] = MEMORY[0x24BDAC760];
  v36[1] = 0x40000000;
  v36[2] = ___ZN23EurekaCallCommandDriver25handleNormalVoiceDialRespERKN2vs13VoiceDialCall8ResponseEN3ctu2cf11CFSharedRefIK8__CFUUIDEEN10subscriber7SimSlotE_block_invoke;
  v36[3] = &unk_24D5E2C50;
  v36[4] = v62;
  *(_QWORD *)buf = v36;
  v13 = qmi::MessageBase::applyTlv<vs::tlv::CallIdentifier,void({block_pointer})(vs::tlv::CallIdentifier const&)>(a2, 16, (uint64_t)buf);
  v14 = *v9;
  if ((v13 & 1) != 0)
  {
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      v15 = *(_DWORD *)(*(_QWORD *)&v62[8] + 24);
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&buf[4] = v15;
      _os_log_impl(&dword_216897000, v14, OS_LOG_TYPE_DEFAULT, "#I The dialed call got a call ID: %d", buf, 8u);
    }
    HIDWORD(v40) = *(_DWORD *)(*(_QWORD *)&v62[8] + 24);
    _Block_object_dispose(v62, 8);
    goto LABEL_50;
  }
  if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl(&dword_216897000, v14, OS_LOG_TYPE_ERROR, "Mandatory TLV, callId, (0x01) not present. Ignoring response.", buf, 2u);
  }
  _Block_object_dispose(v62, 8);
LABEL_51:
  CallInfo::~CallInfo((void **)v39);
}

void sub_216A36BEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20)
{
  uint64_t v20;

  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100](v20 - 112);
  CallInfo::~CallInfo(&a20);
  _Unwind_Resume(a1);
}

uint64_t ___ZN23EurekaCallCommandDriver25handleNormalVoiceDialRespERKN2vs13VoiceDialCall8ResponseEN3ctu2cf11CFSharedRefIK8__CFUUIDEEN10subscriber7SimSlotE_block_invoke(uint64_t result, unsigned __int8 *a2)
{
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = *a2;
  return result;
}

uint64_t ___ZN23EurekaCallCommandDriver28handleVoiceInfoRecIndicationEN3qmi16SubscriptionTypeERKN2vs12VoiceInfoRec10IndicationE_block_invoke(uint64_t result, _BYTE *a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = *a2;
  return result;
}

uint64_t ___ZN23EurekaCallCommandDriver28handleVoiceInfoRecIndicationEN3qmi16SubscriptionTypeERKN2vs12VoiceInfoRec10IndicationE_block_invoke_43(uint64_t result, unsigned __int8 *a2)
{
  *(_WORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = *a2;
  return result;
}

double ___ZN23EurekaCallCommandDriver28handleVoiceInfoRecIndicationEN3qmi16SubscriptionTypeERKN2vs12VoiceInfoRec10IndicationE_block_invoke_2(uint64_t a1, char **a2)
{
  uint64_t v3;
  uint64_t v4;
  double result;
  __int128 v6;
  uint64_t v7;

  std::string::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned char const*>,std::__wrap_iter<unsigned char const*>>(&v6, *a2, a2[1], a2[1] - *a2);
  v3 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v4 = v3 + 40;
  if (*(char *)(v3 + 63) < 0)
    operator delete(*(void **)v4);
  result = *(double *)&v6;
  *(_OWORD *)v4 = v6;
  *(_QWORD *)(v4 + 16) = v7;
  return result;
}

double ___ZN23EurekaCallCommandDriver28handleVoiceInfoRecIndicationEN3qmi16SubscriptionTypeERKN2vs12VoiceInfoRec10IndicationE_block_invoke_3(uint64_t a1, char **a2)
{
  uint64_t v3;
  uint64_t v4;
  double result;
  __int128 v6;
  uint64_t v7;

  std::string::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned char const*>,std::__wrap_iter<unsigned char const*>>(&v6, *a2, a2[1], a2[1] - *a2);
  v3 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v4 = v3 + 40;
  if (*(char *)(v3 + 63) < 0)
    operator delete(*(void **)v4);
  result = *(double *)&v6;
  *(_OWORD *)v4 = v6;
  *(_QWORD *)(v4 + 16) = v7;
  return result;
}

uint64_t ___ZN23EurekaCallCommandDriver28handleVoiceInfoRecIndicationEN3qmi16SubscriptionTypeERKN2vs12VoiceInfoRec10IndicationE_block_invoke_4(uint64_t result, _BYTE *a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = *a2;
  return result;
}

uint64_t ___ZN23EurekaCallCommandDriver28handleVoiceInfoRecIndicationEN3qmi16SubscriptionTypeERKN2vs12VoiceInfoRec10IndicationE_block_invoke_52(uint64_t result, _BYTE *a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = *a2;
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 40) + 8) + 24) = a2[2];
  return result;
}

void ___ZN23EurekaCallCommandDriver29handleVoiceHandoverIndicationEN3qmi16SubscriptionTypeEN2vs13VoiceHandover10IndicationE_block_invoke(uint64_t a1)
{
  uint64_t v2;
  int v3;
  uint64_t (*v4)(void);
  uint64_t v5;
  os_log_t *v6;
  int v7;
  NSObject *v8;
  qmi::MessageBase *v9;
  uint64_t TlvValue;
  int v11;
  uint64_t v12;
  int v13;
  int v14;
  uint64_t v15;
  NSObject *v16;
  int v17;
  const char *v18;
  int v19;
  uint64_t v20;
  _BYTE v21[12];
  uint8_t buf[8];
  __int128 v23;
  int v24;
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(_DWORD *)(a1 + 64);
  switch(v3)
  {
    case 3:
      v4 = *(uint64_t (**)(void))(**(_QWORD **)(v2 + 112) + 16);
      v5 = 3;
      goto LABEL_7;
    case 2:
      v4 = *(uint64_t (**)(void))(**(_QWORD **)(v2 + 112) + 16);
      v5 = 2;
      goto LABEL_7;
    case 1:
      v4 = *(uint64_t (**)(void))(**(_QWORD **)(v2 + 112) + 16);
      v5 = 1;
LABEL_7:
      v6 = (os_log_t *)v4();
      goto LABEL_9;
  }
  v6 = (os_log_t *)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(v2 + 112) + 16))(*(_QWORD *)(v2 + 112), 0);
  v5 = 0;
LABEL_9:
  v7 = *(_DWORD *)(a1 + 44);
  if (!v7)
  {
    v9 = (qmi::MessageBase *)(a1 + 40);
    *(_QWORD *)buf = 0;
    *(_QWORD *)&v23 = buf;
    *((_QWORD *)&v23 + 1) = 0x2000000000;
    v24 = 4;
    TlvValue = qmi::MessageBase::findTlvValue(v9);
    v12 = TlvValue;
    if (TlvValue)
    {
      v13 = v11;
      *(_QWORD *)v21 = TlvValue;
      v14 = tlv::parseV<vs::tlv::HandoverState>((unint64_t *)v21, v11);
      if (*(_QWORD *)v21)
      {
        v15 = v23;
        *(_DWORD *)(v23 + 24) = v14;
        v16 = *v6;
LABEL_18:
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          v18 = vs::callList::asString(*(_DWORD *)(v15 + 24));
          *(_DWORD *)v21 = 136315138;
          *(_QWORD *)&v21[4] = v18;
          _os_log_impl(&dword_216897000, v16, OS_LOG_TYPE_DEFAULT, "#I HO state: %s", v21, 0xCu);
          v15 = v23;
        }
        v19 = 1;
        v20 = 1;
        switch(*(_DWORD *)(v15 + 24))
        {
          case 2:
            v19 = 0;
            v20 = 2;
            break;
          case 3:
            v19 = 0;
            v20 = 3;
            break;
          case 4:
            v19 = 0;
            v20 = 4;
            break;
          case 5:
          case 6:
          case 7:
          case 8:
          case 9:
            break;
          case 0xA:
            v19 = 0;
            v20 = 5;
            break;
          default:
            v20 = 1;
            break;
        }
        (*(void (**)(_QWORD, uint64_t, uint64_t))(**(_QWORD **)(v2 + 120) + 160))(*(_QWORD *)(v2 + 120), v20, v5);
        if (v19)
          (*(void (**)(_QWORD, uint64_t, uint64_t))(**(_QWORD **)(v2 + 120) + 160))(*(_QWORD *)(v2 + 120), 6, v5);
LABEL_30:
        _Block_object_dispose(buf, 8);
        return;
      }
      v17 = ((uint64_t (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)v9, 1, v12, v13);
      v16 = *v6;
      if (v17)
      {
        v15 = v23;
        goto LABEL_18;
      }
    }
    else
    {
      v16 = *v6;
    }
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v21 = 0;
      _os_log_error_impl(&dword_216897000, v16, OS_LOG_TYPE_ERROR, "handleVoiceHandoverIndication_sync did not receive the mandatory state TLV", v21, 2u);
    }
    goto LABEL_30;
  }
  v8 = *v6;
  if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 67109378;
    *(_DWORD *)&buf[4] = v7;
    LOWORD(v23) = 2080;
    *(_QWORD *)((char *)&v23 + 2) = qmi::asString();
    _os_log_error_impl(&dword_216897000, v8, OS_LOG_TYPE_ERROR, "handleVoiceHandoverIndication_sync: Error in indication with code = 0x%x (%s)", buf, 0x12u);
  }
}

void sub_216A370F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

_QWORD *__copy_helper_block_e8_40c36_ZTSN2vs13VoiceHandover10IndicationE(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  result[5] = a2[5];
  v2 = a2[7];
  result[6] = a2[6];
  result[7] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void __destroy_helper_block_e8_40c36_ZTSN2vs13VoiceHandover10IndicationE(uint64_t a1)
{
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)(a1 + 40));
}

__n128 __Block_byref_object_copy__58(_QWORD *a1, uint64_t a2)
{
  __n128 result;

  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 5) = result;
  a1[7] = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a2 + 40) = 0;
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(a2 + 56) = 0;
  return result;
}

void __Block_byref_object_dispose__59(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 40);
  if (v2)
  {
    *(_QWORD *)(a1 + 48) = v2;
    operator delete(v2);
  }
}

void EurekaCallCommandDriver::endThisCall(uint64_t a1, unsigned int *a2)
{
  uint64_t v4;
  os_log_t *v5;
  NSObject *v6;
  uint64_t v7;
  _BYTE *v8;
  uint64_t v9;
  char *v10;
  unint64_t *v11;
  uint64_t v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;
  unint64_t v25;
  std::__shared_weak_count *v26;
  unint64_t *p_shared_owners;
  unint64_t v28;
  std::__shared_weak_count *v29;
  unint64_t *v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t v33;
  NSObject *v34;
  uint64_t v35;
  std::__shared_weak_count *v36;
  unint64_t *v37;
  unint64_t v38;
  unint64_t v39;
  std::__shared_weak_count *v40;
  int v41;
  unint64_t *v42;
  unint64_t v43;
  uint64_t v44;
  uint64_t v45;
  _QWORD *v46;
  uint64_t v47;
  uint64_t v48;
  unint64_t *v49;
  unint64_t v50;
  _QWORD *v51;
  uint64_t v52;
  std::__shared_weak_count *v53;
  unint64_t *v54;
  unint64_t v55;
  std::__shared_weak_count *v56;
  unint64_t *v57;
  unint64_t v58;
  void *v59[51];
  char v60[8];
  uint64_t v61;
  _QWORD v62[4];
  void *v63[51];
  _OWORD v64[2];
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  char *v68;
  std::__shared_weak_count *v69;
  uint64_t aBlock;
  uint64_t v71;
  void (*v72)(uint64_t, uint64_t);
  void *v73;
  _QWORD *v74;
  uint8_t buf[16];
  _OWORD v76[6];
  _BYTE v77[21];
  __int128 v78;
  uint64_t v79;
  int v80;
  __int128 v81;
  uint64_t v82;
  _OWORD v83[2];
  __int128 v84;
  uint64_t v85;
  char v86;
  __int128 v87;
  char v88;
  __int128 v89;
  uint64_t v90;
  __int128 v91;
  uint64_t v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  _BYTE v97[21];
  os_log_t *v98;
  _QWORD v99[3];
  _QWORD *v100;
  char *v101;
  std::__shared_weak_count *v102;
  uint64_t v103;

  v103 = *MEMORY[0x24BDAC8D0];
  v4 = a2[63];
  v5 = (os_log_t *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 112) + 16))(*(_QWORD *)(a1 + 112), v4);
  v66 = 0;
  v65 = 0;
  v67 = 0;
  (*(void (**)(uint64_t *__return_ptr, _QWORD, _QWORD))(**(_QWORD **)(a1 + 120) + 328))(&v65, *(_QWORD *)(a1 + 120), a2[63]);
  if (v66 - v65 == 408)
  {
    v6 = *v5;
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_216897000, v6, OS_LOG_TYPE_DEFAULT, "#I There is one call. End this call generically. EndCall request.", buf, 2u);
    }
    memset(v64, 0, sizeof(v64));
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)v64);
    v7 = MEMORY[0x24BDAC760];
    v62[0] = MEMORY[0x24BDAC760];
    v62[1] = 1174405120;
    v62[2] = ___ZN23EurekaCallCommandDriver11endThisCallE8CallInfo_block_invoke;
    v62[3] = &__block_descriptor_tmp_89_0;
    CallInfo::CallInfo((CallInfo *)v63, (const CallInfo *)a2);
    v8 = (_BYTE *)qmi::MutableMessageBase::getTLV<vs::tlv::CallIdentifier>(v64, 1);
    ___ZN23EurekaCallCommandDriver11endThisCallE8CallInfo_block_invoke((uint64_t)v62, v8);
    if ((v4 - 1) >= 3)
      LODWORD(v4) = 0;
    v9 = qmi::ClientRouter::get();
    qmi::ClientRouter::SendProxy::SendProxy<vs::EndCall::Request>((uint64_t)v60, v4, v9);
    *(_QWORD *)buf = a1;
    CallInfo::CallInfo((CallInfo *)&buf[8], (const CallInfo *)a2);
    v98 = v5;
    v10 = (char *)operator new(0x1C0uLL);
    *((_QWORD *)v10 + 1) = 0;
    v11 = (unint64_t *)(v10 + 8);
    *((_QWORD *)v10 + 2) = 0;
    *(_QWORD *)v10 = &off_24D5E4930;
    v12 = *((_QWORD *)&v76[2] + 1);
    *((_QWORD *)v10 + 7) = *(_QWORD *)&v76[1];
    v13 = v76[0];
    *(_OWORD *)(v10 + 24) = *(_OWORD *)buf;
    *(_QWORD *)&v76[0] = 0;
    *(_QWORD *)&buf[8] = 0;
    *(_OWORD *)(v10 + 40) = v13;
    *((_QWORD *)&v76[0] + 1) = 0;
    *(_QWORD *)&v76[1] = 0;
    *((_OWORD *)v10 + 4) = *(_OWORD *)((char *)&v76[1] + 8);
    *((_QWORD *)v10 + 10) = v12;
    *((_QWORD *)&v76[1] + 1) = 0;
    *(_QWORD *)&v76[2] = 0;
    v14 = v76[4];
    *(_OWORD *)(v10 + 88) = v76[3];
    v15 = v76[5];
    v16 = *(_OWORD *)v77;
    *(_QWORD *)(v10 + 149) = *(_QWORD *)&v77[13];
    *(_OWORD *)(v10 + 136) = v16;
    *(_OWORD *)(v10 + 120) = v15;
    *(_OWORD *)(v10 + 104) = v14;
    v17 = v78;
    *((_QWORD *)v10 + 22) = v79;
    *((_OWORD *)v10 + 10) = v17;
    *((_QWORD *)&v76[2] + 1) = 0;
    v78 = 0uLL;
    v79 = 0;
    *((_DWORD *)v10 + 46) = v80;
    v18 = v81;
    *((_QWORD *)v10 + 26) = v82;
    *((_OWORD *)v10 + 12) = v18;
    v81 = 0uLL;
    v82 = 0;
    v19 = v83[0];
    *(_OWORD *)(v10 + 225) = *(_OWORD *)((char *)v83 + 9);
    *(_OWORD *)(v10 + 216) = v19;
    v10[248] = 0;
    v10[272] = 0;
    if (v86)
    {
      *(_OWORD *)(v10 + 248) = v84;
      *((_QWORD *)v10 + 33) = v85;
      v85 = 0;
      v84 = 0uLL;
      v10[272] = 1;
    }
    v10[296] = v88;
    *(_OWORD *)(v10 + 280) = v87;
    *((_QWORD *)v10 + 40) = v90;
    *((_OWORD *)v10 + 19) = v89;
    v89 = 0uLL;
    *((_QWORD *)v10 + 43) = v92;
    *(_OWORD *)(v10 + 328) = v91;
    v90 = 0;
    v91 = 0uLL;
    v92 = 0;
    v20 = v94;
    *((_OWORD *)v10 + 22) = v93;
    *((_OWORD *)v10 + 23) = v20;
    v21 = v95;
    v22 = v96;
    v23 = *(_OWORD *)v97;
    *(_QWORD *)(v10 + 429) = *(_QWORD *)&v97[13];
    *((_OWORD *)v10 + 25) = v22;
    *((_OWORD *)v10 + 26) = v23;
    *((_OWORD *)v10 + 24) = v21;
    *((_QWORD *)v10 + 55) = v5;
    v68 = v10 + 24;
    v69 = (std::__shared_weak_count *)v10;
    v24 = v61;
    v99[0] = v7;
    v99[1] = 1174405120;
    v99[2] = ___ZNO3qmi12ClientRouter9SendProxy8callbackIZN23EurekaCallCommandDriver11endThisCallE8CallInfoE3__0EEOS1_OT__block_invoke;
    v100 = &__block_descriptor_tmp_184_1;
    v101 = v10 + 24;
    v102 = (std::__shared_weak_count *)v10;
    do
      v25 = __ldxr(v11);
    while (__stxr(v25 + 1, v11));
    aBlock = v7;
    v71 = 0x40000000;
    v72 = ___ZNO3qmi6Client9SendProxy8callbackIRKN2vs7EndCall8ResponseEEEOS1_U13block_pointerFvT_E_block_invoke_0;
    v73 = &unk_24D5E48D0;
    v74 = v99;
    *(_QWORD *)(v24 + 32) = _Block_copy(&aBlock);
    v26 = v102;
    if (v102)
    {
      p_shared_owners = (unint64_t *)&v102->__shared_owners_;
      do
        v28 = __ldaxr(p_shared_owners);
      while (__stlxr(v28 - 1, p_shared_owners));
      if (!v28)
      {
        ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
        std::__shared_weak_count::__release_weak(v26);
      }
    }
    v29 = v69;
    if (v69)
    {
      v30 = (unint64_t *)&v69->__shared_owners_;
      do
        v31 = __ldaxr(v30);
      while (__stlxr(v31 - 1, v30));
      if (!v31)
      {
        ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
        std::__shared_weak_count::__release_weak(v29);
      }
    }
    CallInfo::~CallInfo((void **)&buf[8]);
    v32 = v61;
    v61 = 0;
    if (v32)
      std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)&v61, v32);
    CallInfo::~CallInfo(v63);
    qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)v64);
    goto LABEL_74;
  }
  v71 = 0;
  aBlock = 0;
  EurekaCallCommandDriver::getPreferredFormatterForSim(&aBlock, a1, v4);
  v33 = aBlock;
  v34 = *v5;
  if (!aBlock)
  {
    if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_216897000, v34, OS_LOG_TYPE_ERROR, "Preferred Formatter is NULL in endThisCall", buf, 2u);
    }
    goto LABEL_69;
  }
  if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_216897000, v34, OS_LOG_TYPE_DEFAULT, "#I There is more than one call when trying to end this call. Ask the formatter how to end.", buf, 2u);
  }
  *(_OWORD *)buf = 0u;
  memset(v76, 0, 48);
  CallInfo::CallInfo((CallInfo *)v59, (const CallInfo *)a2);
  (*(void (**)(uint8_t *__return_ptr, uint64_t, void **))(*(_QWORD *)v33 + 56))(buf, v33, v59);
  CallInfo::~CallInfo(v59);
  v35 = *(_QWORD *)buf;
  v36 = *(std::__shared_weak_count **)&buf[8];
  if (!*(_QWORD *)&buf[8])
    goto LABEL_31;
  v37 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
  do
    v38 = __ldxr(v37);
  while (__stxr(v38 + 1, v37));
  do
    v39 = __ldaxr(v37);
  while (__stlxr(v39 - 1, v37));
  if (!v39)
  {
    ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
    std::__shared_weak_count::__release_weak(v36);
    if (!v35)
      goto LABEL_59;
  }
  else
  {
LABEL_31:
    if (!v35)
      goto LABEL_59;
  }
  v40 = *(std::__shared_weak_count **)&buf[8];
  if ((v4 - 1) >= 3)
    v41 = 0;
  else
    v41 = v4;
  v68 = *(char **)buf;
  v69 = *(std::__shared_weak_count **)&buf[8];
  if (*(_QWORD *)&buf[8])
  {
    v42 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
    do
      v43 = __ldxr(v42);
    while (__stxr(v43 + 1, v42));
  }
  v44 = qmi::ClientRouter::get();
  qmi::ClientRouter::SendProxy::SendProxy<qmi::MutableMessageBase>((uint64_t)v64, v41, v44);
  *(_DWORD *)(*((_QWORD *)&v64[0] + 1) + 16) = v76[2];
  v45 = *((_QWORD *)&v76[1] + 1);
  if (!*((_QWORD *)&v76[1] + 1))
    goto LABEL_41;
  if (*((_OWORD **)&v76[1] + 1) != v76)
  {
    v45 = (*(uint64_t (**)(void))(**((_QWORD **)&v76[1] + 1) + 16))();
LABEL_41:
    v100 = (_QWORD *)v45;
    goto LABEL_47;
  }
  v100 = v99;
  (*(void (**)(void))(**((_QWORD **)&v76[1] + 1) + 24))();
LABEL_47:
  qmi::ClientRouter::SendProxy::callback<std::function<void ()(qmi::ResponseBase const&)>>((uint64_t)v64, (uint64_t)v99);
  v46 = v100;
  if (v100 == v99)
  {
    v47 = 4;
    v46 = v99;
    goto LABEL_51;
  }
  if (v100)
  {
    v47 = 5;
LABEL_51:
    (*(void (**)(void))(*v46 + 8 * v47))();
  }
  v48 = *((_QWORD *)&v64[0] + 1);
  *((_QWORD *)&v64[0] + 1) = 0;
  if (v48)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100]((uint64_t)v64 + 8, v48);
  if (v40)
  {
    v49 = (unint64_t *)&v40->__shared_owners_;
    do
      v50 = __ldaxr(v49);
    while (__stlxr(v50 - 1, v49));
    if (!v50)
    {
      ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
      std::__shared_weak_count::__release_weak(v40);
    }
  }
LABEL_59:
  v51 = (_QWORD *)*((_QWORD *)&v76[1] + 1);
  if (*((_OWORD **)&v76[1] + 1) == v76)
  {
    v52 = 4;
    v51 = v76;
    goto LABEL_63;
  }
  if (*((_QWORD *)&v76[1] + 1))
  {
    v52 = 5;
LABEL_63:
    (*(void (**)(void))(*v51 + 8 * v52))();
  }
  v53 = *(std::__shared_weak_count **)&buf[8];
  if (*(_QWORD *)&buf[8])
  {
    v54 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
    do
      v55 = __ldaxr(v54);
    while (__stlxr(v55 - 1, v54));
    if (!v55)
    {
      ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
      std::__shared_weak_count::__release_weak(v53);
    }
  }
LABEL_69:
  v56 = (std::__shared_weak_count *)v71;
  if (v71)
  {
    v57 = (unint64_t *)(v71 + 8);
    do
      v58 = __ldaxr(v57);
    while (__stlxr(v58 - 1, v57));
    if (!v58)
    {
      ((void (*)(std::__shared_weak_count *))v56->__on_zero_shared)(v56);
      std::__shared_weak_count::__release_weak(v56);
    }
  }
LABEL_74:
  *(_QWORD *)buf = &v65;
  std::vector<CallInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
}

void sub_216A37A88(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v3;

  v3 = STACK[0x368];
  STACK[0x368] = 0;
  if (v3)
    std::default_delete<qmi::Client::SendProxy>::operator()[abi:ne180100](v1, v3);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&STACK[0x398]);
  EurekaVoiceRequestMessage::~EurekaVoiceRequestMessage((EurekaVoiceRequestMessage *)&STACK[0x3D0]);
  std::shared_ptr<QMIDataContextIPObserver>::~shared_ptr[abi:ne180100]((uint64_t)&STACK[0x3A8]);
  STACK[0x3D0] = (unint64_t)&STACK[0x380];
  std::vector<CallInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)&STACK[0x3D0]);
  _Unwind_Resume(a1);
}

void sub_216A37B9C()
{
  JUMPOUT(0x216A37B94);
}

void EurekaCallCommandDriver::handleVoiceAllCallStatusIndication(uint64_t a1, uint64_t a2, qmi::MessageBase *a3)
{
  unsigned int v4;
  uint64_t v5;
  unsigned int v6;
  os_log_t *v7;
  os_log_t *v8;
  int v9;
  NSObject *v10;
  NSObject *v11;
  uint64_t v12;
  void *v13;
  char v14;
  uint64_t v15;
  os_log_t *v16;
  uint64_t TlvValue;
  int v18;
  uint64_t v19;
  int v20;
  NSObject *v21;
  char v22;
  uint64_t v23;
  uint64_t v24;
  __int128 *v25;
  uint64_t v26;
  unsigned __int8 v27;
  int v28;
  int v29;
  __int128 v30;
  NSObject *v31;
  std::string *p_str;
  int v33;
  uint64_t **v34;
  uint64_t **v35;
  uint64_t *v36;
  uint64_t **v37;
  _QWORD *v38;
  uint64_t v39;
  uint64_t **v40;
  uint64_t *v41;
  uint64_t **v42;
  BOOL v43;
  unsigned int v44;
  uint64_t **v45;
  uint64_t **v46;
  uint64_t *v47;
  unsigned int v48;
  char *v49;
  _QWORD *v50;
  _QWORD *v51;
  std::__shared_weak_count *v52;
  uint64_t v53;
  unint64_t *p_shared_owners;
  unint64_t v55;
  NSObject **v56;
  void *v57;
  int v58;
  void *v59;
  int v60;
  void *v61;
  _WORD *v62;
  _WORD *i;
  NSObject *v64;
  NSObject **v65;
  void *v66;
  int v67;
  void *v68;
  int v69;
  void *v70;
  NSObject *v71;
  char *v72;
  char *v73;
  char v74;
  unsigned int v75;
  uint64_t **v76;
  uint64_t **v77;
  uint64_t *v78;
  unsigned int v79;
  _BYTE *v80;
  uint64_t *v81;
  unsigned __int8 *v82;
  os_log_t *v83;
  int v84;
  uint64_t v85;
  uint64_t v86;
  int v87;
  int v88;
  NSObject *v89;
  const char *v90;
  char *v91;
  uint8_t *v92;
  int v93;
  NSObject *v94;
  uint64_t v95;
  std::string::size_type size;
  std::string *v97;
  std::string::size_type v98;
  std::string *v99;
  unsigned int v100;
  _BOOL4 v101;
  int v102;
  int v103;
  NSObject *v104;
  uint64_t **v105;
  uint64_t **v106;
  uint64_t *v107;
  NSObject *v108;
  uint64_t **v109;
  os_log_t *v110;
  os_log_t v111;
  const char *v112;
  int v113;
  NSObject *v114;
  const char *v115;
  uint32_t v116;
  NSObject *v117;
  os_log_t v118;
  NSObject *v119;
  const char *v120;
  int v121;
  uint64_t v122;
  NSObject **v123;
  std::__shared_weak_count *v124;
  uint64_t v125;
  std::__shared_weak_count *v126;
  std::__shared_weak_count *v127;
  _QWORD *v128;
  NSObject *v129;
  unint64_t *v130;
  unint64_t v131;
  _QWORD *v132;
  unint64_t v133;
  uint8_t *v134;
  os_log_t v135;
  NSObject *v136;
  const char *v137;
  os_log_t v138;
  const char *v139;
  int v140;
  NSObject *v141;
  NSObject *v142;
  _QWORD *v143;
  uint64_t **v144;
  uint64_t v145;
  os_log_t v146;
  NSObject *v147;
  uint64_t **v148;
  uint64_t **v149;
  NSObject *v150;
  os_log_t v151;
  os_log_t v152;
  uint32_t v153;
  NSObject *v154;
  uint64_t **v155;
  uint64_t v156;
  NSObject *v157;
  NSObject *v158;
  uint64_t **v159;
  NSObject *v160;
  os_log_t *v161;
  void *v162;
  int v163;
  void *v164;
  int v165;
  void *v166;
  unsigned __int8 *v167;
  unsigned __int8 *v168;
  int v169;
  int v170;
  NSObject *v171;
  void **v172;
  void *v173;
  int v174;
  uint64_t v175;
  uint64_t **v176;
  NSObject *v177;
  os_log_t *v178;
  int v179;
  void **v180;
  void **v181;
  void **v182;
  os_log_t v183;
  NSObject *v184;
  NSObject *v185;
  int v186;
  int v187;
  os_log_t v188;
  NSObject *v189;
  const char *v190;
  uint64_t v191;
  uint64_t **v192;
  os_log_t v193;
  uint64_t **v194;
  NSObject *v195;
  _QWORD *v196;
  uint64_t v197;
  std::__shared_weak_count *v198;
  unint64_t *v199;
  unint64_t v200;
  char *v201;
  unsigned __int8 *v202;
  std::string::value_type *__s;
  qmi::MessageBase *v204;
  unsigned __int8 *v205;
  os_log_t *v206;
  unsigned int v207;
  uint64_t v208;
  void *v209[51];
  uint64_t **v210;
  uint64_t *v211;
  uint64_t v212;
  void *__p;
  void *v214;
  uint64_t v215;
  uint64_t v216;
  std::__shared_weak_count *v217;
  _QWORD v218[5];
  uint64_t v219;
  uint64_t *v220;
  uint64_t v221;
  __n128 (*v222)(_QWORD *, uint64_t);
  void (*v223)(uint64_t);
  void *v224;
  void *v225;
  uint64_t v226;
  std::string __str;
  unsigned __int8 v228;
  void *v229[2];
  void (*v230)(uint64_t, __int16 **);
  void *v231;
  __int128 *v232;
  uint64_t v233;
  std::__shared_weak_count *v234;
  void *v235;
  uint64_t v236;
  void (*v237)(uint64_t, _QWORD *);
  void *v238;
  uint8_t *v239;
  int v240;
  std::string v241;
  uint8_t v242[8];
  __int16 v243;
  std::string *v244;
  __int128 v245;
  uint64_t v246;
  __n128 (*v247)(_QWORD *, uint64_t);
  uint8_t *v248;
  _QWORD v249[3];
  _BYTE v250[40];
  os_log_t *v251;
  int v252;
  uint8_t buf[32];
  __int128 v254;
  __int128 v255;
  __int128 v256;
  __int128 v257;
  __int128 v258;
  __int128 v259;
  __int128 v260;
  __int128 v261;
  __int128 v262;
  __int128 v263;
  __int128 v264;
  __int128 v265;
  __int128 v266;
  __int128 v267;
  __int128 v268;
  __int128 v269;
  __int128 v270;
  __int128 v271;
  __int128 v272;
  __int128 v273;
  __int128 v274;
  __int128 v275;
  __int128 v276;
  uint64_t v277;
  uint64_t v278;

  v4 = a2;
  v5 = a1;
  v278 = *MEMORY[0x24BDAC8D0];
  v6 = a2 - 1;
  if ((a2 - 1) >= 3)
    a2 = 0;
  else
    a2 = a2;
  v7 = (os_log_t *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 112) + 16))(*(_QWORD *)(a1 + 112), a2);
  v8 = v7;
  v9 = *((_DWORD *)a3 + 1);
  if (v9)
  {
    v10 = *v7;
    if (os_log_type_enabled(*v7, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109378;
      *(_DWORD *)&buf[4] = v9;
      *(_WORD *)&buf[8] = 2080;
      *(_QWORD *)&buf[10] = qmi::asString();
      _os_log_error_impl(&dword_216897000, v10, OS_LOG_TYPE_ERROR, "handleVoiceAllCallStatusIndication: Error in indication with code = 0x%x (%s)", buf, 0x12u);
    }
    return;
  }
  if (*(_BYTE *)(v5 + 305))
  {
    v11 = *v7;
    if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_216897000, v11, OS_LOG_TYPE_DEFAULT, "#N Active call in Settings, ignoring the Call Status Indication", buf, 2u);
    }
    return;
  }
  if (v6 >= 3)
    v12 = 0;
  else
    v12 = v4;
  v219 = 0;
  v220 = &v219;
  v221 = 0x4002000000;
  v222 = __Block_byref_object_copy__61;
  v223 = __Block_byref_object_dispose__62;
  v226 = 0;
  v224 = 0;
  v225 = 0;
  v13 = (void *)MEMORY[0x24BDAC760];
  v218[0] = MEMORY[0x24BDAC760];
  v218[1] = 0x40000000;
  v218[2] = ___ZN23EurekaCallCommandDriver34handleVoiceAllCallStatusIndicationEN3qmi16SubscriptionTypeERKN2vs15VoiceCallStatus10IndicationE_block_invoke;
  v218[3] = &unk_24D5E2DE8;
  v218[4] = &v219;
  *(_QWORD *)buf = v218;
  v14 = qmi::MessageBase::applyTlv<vs::tlv::CallList,void({block_pointer})(vs::tlv::CallList const&)>(a3, 1, (uint64_t)buf);
  v15 = v220[5];
  if (v15 != v220[6])
    EurekaCallCommandDriver::setPreferredFormatter(v5, *(unsigned __int8 *)(v15 + 4), v12);
  if ((v14 & 1) == 0)
  {
    v21 = *v8;
    if (os_log_type_enabled(*v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_216897000, v21, OS_LOG_TYPE_ERROR, "Mandatory TLV, Array of Call Information (0x01), is not present!", buf, 2u);
    }
    goto LABEL_312;
  }
  v217 = 0;
  v216 = 0;
  EurekaCallCommandDriver::getPreferredFormatterForSim(&v216, v5, v12);
  if (*(_BYTE *)(v5 + 305) || !v216 || !(*(unsigned int (**)(uint64_t))(*(_QWORD *)v216 + 128))(v216))
    goto LABEL_18;
  v215 = 0;
  __p = 0;
  v214 = 0;
  std::vector<vs::tlv::CallListItem>::__init_with_size[abi:ne180100]<vs::tlv::CallListItem*,vs::tlv::CallListItem*>(&__p, (const void *)v220[5], v220[6], 0x6DB6DB6DB6DB6DB7 * (v220[6] - v220[5]));
  v22 = EurekaCallCommandDriver::validateCallCollisionScenario(v5, (unsigned __int8 *)__p, (uint64_t)v214);
  if (__p)
  {
    v214 = __p;
    operator delete(__p);
  }
  if ((v22 & 1) != 0)
  {
LABEL_18:
    v211 = 0;
    v210 = 0;
    v212 = 0;
    v16 = (os_log_t *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v5 + 112) + 16))(*(_QWORD *)(v5 + 112), v12);
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x4002000000;
    *(_QWORD *)&buf[24] = __Block_byref_object_copy__66;
    *(_QWORD *)&v254 = __Block_byref_object_dispose__67;
    v255 = 0uLL;
    *((_QWORD *)&v254 + 1) = &v255;
    v235 = v13;
    v236 = 0x40000000;
    v237 = ___ZN23EurekaCallCommandDriver26parseRemotePartyNumberNameERKN2vs15VoiceCallStatus10IndicationEN10subscriber7SimSlotE_block_invoke;
    v238 = &unk_24D5E2E10;
    v239 = buf;
    v240 = v12;
    *(_QWORD *)&v245 = &v235;
    qmi::MessageBase::applyTlv<vs::tlv::RemoteNumberList,void({block_pointer})(vs::tlv::RemoteNumberList const&)>(a3, 16, (uint64_t)&v245);
    v234 = 0;
    v233 = 0;
    EurekaCallCommandDriver::getPreferredFormatterForSim(&v233, v5, v12);
    if (v233 && ((*(uint64_t (**)(uint64_t))(*(_QWORD *)v233 + 152))(v233) & 1) == 0)
    {
      *(_QWORD *)v250 = v13;
      *(_QWORD *)&v250[8] = 0x40000000;
      *(_QWORD *)&v250[16] = ___ZN23EurekaCallCommandDriver26parseRemotePartyNumberNameERKN2vs15VoiceCallStatus10IndicationEN10subscriber7SimSlotE_block_invoke_2;
      *(_QWORD *)&v250[24] = &unk_24D5E2E38;
      *(_QWORD *)&v250[32] = buf;
      v251 = v16;
      v252 = v12;
      *(_QWORD *)&v245 = v250;
      qmi::MessageBase::applyTlv<vs::tlv::CallList,void({block_pointer})(vs::tlv::CallList const&)>(a3, 1, (uint64_t)&v245);
    }
    v207 = v12;
    v206 = v8;
    *(_QWORD *)&v245 = 0;
    *((_QWORD *)&v245 + 1) = &v245;
    v246 = 0x4002000000;
    v247 = __Block_byref_object_copy__70;
    v248 = (uint8_t *)__Block_byref_object_dispose__71;
    v204 = a3;
    memset(v249, 0, sizeof(v249));
    v229[0] = v13;
    v229[1] = (void *)0x40000000;
    v230 = ___ZN23EurekaCallCommandDriver26parseRemotePartyNumberNameERKN2vs15VoiceCallStatus10IndicationEN10subscriber7SimSlotE_block_invoke_72;
    v231 = &unk_24D5E2E60;
    v232 = &v245;
    TlvValue = qmi::MessageBase::findTlvValue(a3);
    v19 = TlvValue;
    v208 = v5;
    if (!TlvValue)
      goto LABEL_56;
    v20 = v18;
    *(_QWORD *)v242 = TlvValue;
    memset(&v241, 0, sizeof(v241));
    tlv::parseV<vs::tlv::RemoteNameList>((unsigned __int8 **)v242, v18, (uint64_t *)&v241);
    if (*(_QWORD *)v242)
    {
      v230((uint64_t)v229, (__int16 **)&v241);
      __str.__r_.__value_.__r.__words[0] = (std::string::size_type)&v241;
      std::vector<vs::tlv::RemoteNumberListItem>::__destroy_vector::operator()[abi:ne180100]((void ***)&__str);
    }
    else
    {
      __str.__r_.__value_.__r.__words[0] = (std::string::size_type)&v241;
      std::vector<vs::tlv::RemoteNumberListItem>::__destroy_vector::operator()[abi:ne180100]((void ***)&__str);
      if (!((unsigned int (*)(_QWORD, uint64_t, uint64_t, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)a3, 17, v19, v20))
      {
LABEL_56:
        v212 = 0;
        v211 = 0;
        v210 = &v211;
        v38 = *(_QWORD **)(*(_QWORD *)&buf[8] + 40);
        v39 = *(_QWORD *)&buf[8] + 48;
        if (v38 != (_QWORD *)(*(_QWORD *)&buf[8] + 48))
        {
          while (1)
          {
            v40 = &v211;
            if (v210 != &v211)
            {
              v41 = v211;
              v42 = &v211;
              if (v211)
              {
                do
                {
                  v40 = (uint64_t **)v41;
                  v41 = (uint64_t *)v41[1];
                }
                while (v41);
              }
              else
              {
                do
                {
                  v40 = (uint64_t **)v42[2];
                  v43 = *v40 == (uint64_t *)v42;
                  v42 = v40;
                }
                while (v43);
              }
              v44 = *((unsigned __int8 *)v38 + 32);
              if (*((unsigned __int8 *)v40 + 32) >= v44)
                break;
            }
            if (v211)
              v45 = v40;
            else
              v45 = &v211;
            if (v211)
            {
              v46 = v40 + 1;
            }
            else
            {
              v40 = (uint64_t **)&v210;
              v46 = &v211;
            }
            if (!v40[1])
              goto LABEL_79;
LABEL_82:
            v50 = (_QWORD *)v38[1];
            if (v50)
            {
              do
              {
                v51 = v50;
                v50 = (_QWORD *)*v50;
              }
              while (v50);
            }
            else
            {
              do
              {
                v51 = (_QWORD *)v38[2];
                v43 = *v51 == (_QWORD)v38;
                v38 = v51;
              }
              while (!v43);
            }
            v38 = v51;
            if (v51 == (_QWORD *)v39)
              goto LABEL_88;
          }
          v46 = &v211;
          v45 = &v211;
          if (v211)
          {
            v47 = v211;
            while (1)
            {
              while (1)
              {
                v45 = (uint64_t **)v47;
                v48 = *((unsigned __int8 *)v47 + 32);
                if (v48 <= v44)
                  break;
                v47 = *v45;
                v46 = v45;
                if (!*v45)
                  goto LABEL_79;
              }
              if (v48 >= v44)
                goto LABEL_82;
              v47 = v45[1];
              if (!v47)
              {
                v46 = v45 + 1;
                break;
              }
            }
          }
LABEL_79:
          v241.__r_.__value_.__r.__words[2] = 0;
          v49 = (char *)operator new(0x1C0uLL);
          v241.__r_.__value_.__r.__words[0] = (std::string::size_type)v49;
          v241.__r_.__value_.__l.__size_ = (std::string::size_type)&v211;
          v49[32] = *((_BYTE *)v38 + 32);
          CallInfo::CallInfo((CallInfo *)(v49 + 40), (const CallInfo *)(v38 + 5));
          v241.__r_.__value_.__s.__data_[16] = 1;
          *(_QWORD *)v49 = 0;
          *((_QWORD *)v49 + 1) = 0;
          *((_QWORD *)v49 + 2) = v45;
          *v46 = (uint64_t *)v49;
          if (*v210)
          {
            v210 = (uint64_t **)*v210;
            v49 = (char *)*v46;
          }
          std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v211, (uint64_t *)v49);
          ++v212;
          v241.__r_.__value_.__r.__words[0] = 0;
          std::unique_ptr<std::__tree_node<std::__value_type<unsigned char,CallInfo>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<unsigned char,CallInfo>,void *>>>>::reset[abi:ne180100]((uint64_t)&v241);
          goto LABEL_82;
        }
LABEL_88:
        _Block_object_dispose(&v245, 8);
        v241.__r_.__value_.__r.__words[0] = (std::string::size_type)v249;
        std::vector<vs::tlv::RemoteNumberListItem>::__destroy_vector::operator()[abi:ne180100]((void ***)&v241);
        v52 = v234;
        v53 = MEMORY[0x24BDAC760];
        if (v234)
        {
          p_shared_owners = (unint64_t *)&v234->__shared_owners_;
          do
            v55 = __ldaxr(p_shared_owners);
          while (__stlxr(v55 - 1, p_shared_owners));
          if (!v55)
          {
            ((void (*)(std::__shared_weak_count *))v52->__on_zero_shared)(v52);
            std::__shared_weak_count::__release_weak(v52);
          }
        }
        _Block_object_dispose(buf, 8);
        std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::destroy((void **)v255);
        memset(&v241, 0, sizeof(v241));
        v56 = (NSObject **)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(v5 + 112) + 16))(*(_QWORD *)(v5 + 112), v207);
        *(_OWORD *)&v241.__r_.__value_.__r.__words[1] = 0uLL;
        v241.__r_.__value_.__r.__words[0] = (std::string::size_type)&v241.__r_.__value_.__l.__size_;
        *(_QWORD *)buf = 0;
        *(_QWORD *)&buf[8] = buf;
        *(_QWORD *)&buf[16] = 0x4002000000;
        *(_QWORD *)&buf[24] = __Block_byref_object_copy__74;
        *(_QWORD *)&v254 = __Block_byref_object_dispose__75;
        *((_QWORD *)&v254 + 1) = 0;
        v255 = 0uLL;
        *(_QWORD *)&v245 = v53;
        *((_QWORD *)&v245 + 1) = 0x40000000;
        v246 = (uint64_t)___ZN23EurekaCallCommandDriver20parseSRVCCCalls_syncERKN2vs15VoiceCallStatus10IndicationEN10subscriber7SimSlotE_block_invoke;
        v247 = (__n128 (*)(_QWORD *, uint64_t))&unk_24D5E2E88;
        v248 = buf;
        v57 = (void *)qmi::MessageBase::findTlvValue(v204);
        v59 = v57;
        if (v57)
        {
          v60 = v58;
          v235 = v57;
          memset(v250, 0, 24);
          tlv::parseV<vs::tlv::IsHandoverCallList>((unsigned __int8 **)&v235, v58, v250);
          v61 = v235;
          if (v235)
            ___ZN23EurekaCallCommandDriver20parseSRVCCCalls_syncERKN2vs15VoiceCallStatus10IndicationEN10subscriber7SimSlotE_block_invoke((char *)&v245, (const void **)v250);
          if (*(_QWORD *)v250)
          {
            *(_QWORD *)&v250[8] = *(_QWORD *)v250;
            operator delete(*(void **)v250);
          }
          if (v61
            || (((uint64_t (*)(_QWORD, uint64_t, void *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)v204, 31, v59, v60) & 1) != 0)
          {
            v62 = *(_WORD **)(*(_QWORD *)&buf[8] + 40);
            for (i = *(_WORD **)(*(_QWORD *)&buf[8] + 48); v62 != i; ++v62)
            {
              *(_WORD *)v250 = *v62;
              if (*(unsigned __int16 *)v250 >= 0x100u)
                *((_BYTE *)std::__tree<std::__value_type<unsigned char,BOOL>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,BOOL>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,BOOL>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t **)&v241, v250[0], v250)+ 26) = 1;
            }
            if (v241.__r_.__value_.__r.__words[2] > 1)
            {
              v64 = *v56;
              if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)v250 = 0;
                _os_log_error_impl(&dword_216897000, v64, OS_LOG_TYPE_ERROR, "Received multiple calls with handover status set to true", v250, 2u);
              }
            }
          }
        }
        _Block_object_dispose(buf, 8);
        if (*((_QWORD *)&v254 + 1))
        {
          *(_QWORD *)&v255 = *((_QWORD *)&v254 + 1);
          operator delete(*((void **)&v254 + 1));
        }
        v65 = (NSObject **)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(v5 + 112) + 16))(*(_QWORD *)(v5 + 112), v207);
        *(_QWORD *)buf = 0;
        *(_QWORD *)&buf[8] = buf;
        *(_QWORD *)&buf[16] = 0x4002000000;
        *(_QWORD *)&buf[24] = __Block_byref_object_copy__58;
        *(_QWORD *)&v254 = __Block_byref_object_dispose__59;
        *((_QWORD *)&v254 + 1) = 0;
        v255 = 0uLL;
        *(_QWORD *)&v245 = MEMORY[0x24BDAC760];
        *((_QWORD *)&v245 + 1) = 0x40000000;
        v246 = (uint64_t)___ZN23EurekaCallCommandDriver32parseAndUpdateParentCallIds_syncERKN2vs15VoiceCallStatus10IndicationEN10subscriber7SimSlotE_block_invoke;
        v247 = (__n128 (*)(_QWORD *, uint64_t))&unk_24D5E2DC0;
        v248 = buf;
        v66 = (void *)qmi::MessageBase::findTlvValue(v204);
        v68 = v66;
        if (v66)
        {
          v69 = v67;
          v235 = v66;
          memset(v250, 0, 24);
          tlv::parseV<vs::tlv::ParentCallInfo>((unsigned __int8 **)&v235, v67, v250);
          v70 = v235;
          if (v235)
            ((void (*)(char *, const void **))v246)((char *)&v245, (const void **)v250);
          if (*(_QWORD *)v250)
          {
            *(_QWORD *)&v250[8] = *(_QWORD *)v250;
            operator delete(*(void **)v250);
          }
          if (v70
            || ((unsigned int (*)(_QWORD, uint64_t, void *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)v204, 32, v68, v69))
          {
            v71 = *v65;
            if (os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)v250 = 0;
              _os_log_impl(&dword_216897000, v71, OS_LOG_TYPE_DEFAULT, "#I Indication has parent call info. Need to update our call's ids with BB call ids!", v250, 2u);
            }
            *(_QWORD *)&v250[16] = 0;
            *(_QWORD *)&v250[8] = 0;
            *(_QWORD *)v250 = &v250[8];
            v72 = *(char **)(*(_QWORD *)&buf[8] + 40);
            v73 = *(char **)(*(_QWORD *)&buf[8] + 48);
            while (v72 != v73)
            {
              v74 = *v72;
              v75 = v72[1];
              v76 = (uint64_t **)&v250[8];
              v77 = (uint64_t **)&v250[8];
              if (*(_QWORD *)&v250[8])
              {
                v78 = *(uint64_t **)&v250[8];
                while (1)
                {
                  while (1)
                  {
                    v77 = (uint64_t **)v78;
                    v79 = *((unsigned __int8 *)v78 + 25);
                    if (v79 <= v75)
                      break;
                    v78 = *v77;
                    v76 = v77;
                    if (!*v77)
                      goto LABEL_128;
                  }
                  if (v79 >= v75)
                    break;
                  v78 = v77[1];
                  if (!v78)
                  {
                    v76 = v77 + 1;
                    goto LABEL_128;
                  }
                }
                v80 = v77;
              }
              else
              {
LABEL_128:
                v80 = operator new(0x20uLL);
                v80[25] = v75;
                v80[26] = 0;
                *(_QWORD *)v80 = 0;
                *((_QWORD *)v80 + 1) = 0;
                *((_QWORD *)v80 + 2) = v77;
                *v76 = (uint64_t *)v80;
                v81 = (uint64_t *)v80;
                if (**(_QWORD **)v250)
                {
                  *(_QWORD *)v250 = **(_QWORD **)v250;
                  v81 = *v76;
                }
                std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)&v250[8], v81);
                ++*(_QWORD *)&v250[16];
              }
              v80[26] = v74;
              v72 += 3;
            }
            (*(void (**)(_QWORD, _BYTE *, _QWORD))(**(_QWORD **)(v5 + 120) + 336))(*(_QWORD *)(v5 + 120), v250, v207);
            std::__tree<std::__value_type<AQMThroughputKey,unsigned int>,std::__map_value_compare<AQMThroughputKey,std::__value_type<AQMThroughputKey,unsigned int>,std::less<AQMThroughputKey>,true>,std::allocator<std::__value_type<AQMThroughputKey,unsigned int>>>::destroy(*(_QWORD **)&v250[8]);
          }
        }
        _Block_object_dispose(buf, 8);
        if (*((_QWORD *)&v254 + 1))
        {
          *(_QWORD *)&v255 = *((_QWORD *)&v254 + 1);
          operator delete(*((void **)&v254 + 1));
        }
        v82 = (unsigned __int8 *)v220[5];
        v205 = (unsigned __int8 *)v220[6];
        v83 = v206;
        if (v82 == v205)
        {
LABEL_306:
          std::__tree<std::__value_type<AQMThroughputKey,unsigned int>,std::__map_value_compare<AQMThroughputKey,std::__value_type<AQMThroughputKey,unsigned int>,std::less<AQMThroughputKey>,true>,std::allocator<std::__value_type<AQMThroughputKey,unsigned int>>>::destroy((_QWORD *)v241.__r_.__value_.__l.__size_);
          std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::destroy((void **)v211);
          goto LABEL_307;
        }
        __s = (std::string::value_type *)*MEMORY[0x24BDC3E80];
        v201 = (char *)*MEMORY[0x24BDC3DA0];
        while (1)
        {
          v84 = v82[2];
          v85 = *v82;
          v86 = v82[1];
          v87 = v82[3];
          v88 = v82[5];
          switch(v82[2])
          {
            case 0u:
            case 9u:
              goto LABEL_154;
            case 6u:
              (*(void (**)(_QWORD, _QWORD, _QWORD, _QWORD))(**(_QWORD **)(v208 + 216) + 56))(*(_QWORD *)(v208 + 216), v82[1], *v82, v207);
              goto LABEL_174;
            case 7u:
              goto LABEL_151;
            case 8u:
              (*(void (**)(_QWORD, qmi::MessageBase *, _QWORD))(**(_QWORD **)(v208 + 216) + 48))(*(_QWORD *)(v208 + 216), v204, v207);
LABEL_151:
              v93 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, _QWORD))(**(_QWORD **)(v208 + 216) + 56))(*(_QWORD *)(v208 + 216), v86, v85, v207);
              v94 = *v83;
              if (os_log_type_enabled(*v83, OS_LOG_TYPE_DEFAULT))
              {
                v95 = CSIBOOLAsString();
                *(_DWORD *)buf = 136315138;
                *(_QWORD *)&buf[4] = v95;
                _os_log_impl(&dword_216897000, v94, OS_LOG_TYPE_DEFAULT, "#I OTASP type of call; handled as OTASP: %s",
                  buf,
                  0xCu);
              }
              v83 = v206;
              if (!v93)
                goto LABEL_174;
LABEL_154:
              v242[0] = v85;
              *((_DWORD *)std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t **)&v210, v85, (char *)v242)+ 33) = v85;
              *((_DWORD *)std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t **)&v210, v85, (char *)v242)+ 73) = v207;
              *((_DWORD *)std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t **)&v210, v85, (char *)v242)+ 28) = v87;
              size = v241.__r_.__value_.__l.__size_;
              if (!v241.__r_.__value_.__l.__size_)
                goto LABEL_164;
              v97 = (std::string *)&v241.__r_.__value_.__r.__words[1];
              do
              {
                v98 = size;
                v99 = v97;
                v100 = *(unsigned __int8 *)(size + 25);
                if (v100 >= v85)
                  v97 = (std::string *)size;
                else
                  size += 8;
                size = *(_QWORD *)size;
              }
              while (size);
              if (v97 == (std::string *)&v241.__r_.__value_.__r.__words[1])
                goto LABEL_164;
              if (v100 < v85)
                v98 = (std::string::size_type)v99;
              if (v85 >= *(unsigned __int8 *)(v98 + 25))
                v101 = *((_BYTE *)std::__tree<std::__value_type<unsigned char,BOOL>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,BOOL>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,BOOL>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t **)&v241, v85, v242)+ 26) != 0;
              else
LABEL_164:
                v101 = 0;
              if (v216)
              {
                v102 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v216 + 152))(v216);
                v103 = (_DWORD)v86 == 1 ? 0 : v102;
                v83 = v206;
                if (v103 == 1)
                {
                  v104 = *v206;
                  if (os_log_type_enabled(*v206, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_WORD *)buf = 0;
                    _os_log_impl(&dword_216897000, v104, OS_LOG_TYPE_DEFAULT, "#I Resetting RPN (if needed) since this is a technology that gets caller id later", buf, 2u);
                  }
                  v105 = std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t **)&v210, v85, (char *)v242);
                  std::string::__assign_external((std::string *)v105 + 3, __s);
                  v106 = std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t **)&v210, v85, (char *)v242);
                  if (*((char *)v106 + 71) < 0)
                  {
                    v106[7] = 0;
                    v107 = v106[6];
                  }
                  else
                  {
                    v107 = (uint64_t *)(v106 + 6);
                    *((_BYTE *)v106 + 71) = 0;
                  }
                  *(_BYTE *)v107 = 0;
                  *((_DWORD *)std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t **)&v210, v85, (char *)v242)+ 30) = 2;
                  *((_DWORD *)std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t **)&v210, v85, (char *)v242)+ 73) = v207;
                  v83 = v206;
                }
              }
              if (v101)
              {
                v109 = std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t **)&v210, v85, (char *)v242);
                v110 = (os_log_t *)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(v208 + 112) + 16))(*(_QWORD *)(v208 + 112), *((unsigned int *)v109 + 73));
                if (v86 <= 0xA)
                {
                  if (((1 << v86) & 0xEC) != 0)
                  {
                    v119 = *v110;
                    if (os_log_type_enabled(*v110, OS_LOG_TYPE_DEFAULT))
                    {
                      v120 = vs::callList::asString(v86);
                      v121 = *((_DWORD *)v109 + 33);
                      *(_DWORD *)buf = 136315394;
                      *(_QWORD *)&buf[4] = v120;
                      *(_WORD *)&buf[12] = 1024;
                      *(_DWORD *)&buf[14] = v121;
                      _os_log_impl(&dword_216897000, v119, OS_LOG_TYPE_DEFAULT, "#I --->BB Incoming SRVCC Indication: %s, for: %d", buf, 0x12u);
                    }
                    v122 = *((unsigned int *)v109 + 73);
                    v123 = (NSObject **)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v208 + 112) + 16))(*(_QWORD *)(v208 + 112), v122);
                    v245 = 0uLL;
                    v246 = 0;
                    (*(void (**)(__int128 *__return_ptr, _QWORD, uint64_t))(**(_QWORD **)(v208 + 120) + 328))(&v245, *(_QWORD *)(v208 + 120), v122);
                    if (*((_QWORD *)&v245 + 1) == (_QWORD)v245)
                    {
                      v141 = *v123;
                      if (os_log_type_enabled(v141, OS_LOG_TYPE_DEFAULT))
                      {
                        *(_WORD *)buf = 0;
                        _os_log_impl(&dword_216897000, v141, OS_LOG_TYPE_DEFAULT, "#N No VoLTE call around but BB gave us a SRVCC call. End this BB call and ignore the indication.", buf, 2u);
                      }
                      CallInfo::CallInfo((CallInfo *)buf, (const CallInfo *)(v109 + 5));
                      EurekaCallCommandDriver::endThisCall(v208, (unsigned int *)buf);
                      v134 = buf;
                    }
                    else
                    {
                      *(_QWORD *)buf = v208;
                      CallInfo::CallInfo((CallInfo *)&buf[8], (const CallInfo *)(v109 + 5));
                      v124 = *(std::__shared_weak_count **)(v208 + 16);
                      if (!v124 || (v125 = *(_QWORD *)(v208 + 8), (v126 = std::__shared_weak_count::lock(v124)) == 0))
                        std::__throw_bad_weak_ptr[abi:ne180100]();
                      v127 = v126;
                      v128 = (_QWORD *)operator new();
                      *v128 = *(_QWORD *)buf;
                      CallInfo::CallInfo((CallInfo *)(v128 + 1), (const CallInfo *)&buf[8]);
                      v129 = *(NSObject **)(v208 + 24);
                      v130 = (unint64_t *)&v127->__shared_owners_;
                      do
                        v131 = __ldxr(v130);
                      while (__stxr(v131 + 1, v130));
                      v132 = (_QWORD *)operator new();
                      *v132 = v128;
                      v132[1] = v125;
                      v132[2] = v127;
                      *(_QWORD *)v250 = 0;
                      v235 = 0;
                      dispatch_async_f(v129, v132, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<CallCommandDriver>::execute_wrapped<EurekaCallCommandDriver::updateCallInfoFromSRVCC(CallInfo const&)::$_0>(EurekaCallCommandDriver::updateCallInfoFromSRVCC(CallInfo const&)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<EurekaCallCommandDriver::updateCallInfoFromSRVCC(CallInfo const&)::$_0,dispatch_queue_s *::default_delete<EurekaCallCommandDriver::updateCallInfoFromSRVCC(CallInfo const&)::$_0>>)::{lambda(void *)#1}::__invoke);
                      std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v235);
                      std::unique_ptr<void ctu::SharedSynchronizable<CSISMSCommandDriver>::execute_wrapped<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0>(QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&)::{lambda(void)#1},std::default_delete<QMISMSCommandDriver::bootstrap(dispatch::group_session)::$_0 &&>>::~unique_ptr[abi:ne180100]((uint64_t *)v250);
                      do
                        v133 = __ldaxr(v130);
                      while (__stlxr(v133 - 1, v130));
                      if (!v133)
                      {
                        ((void (*)(std::__shared_weak_count *))v127->__on_zero_shared)(v127);
                        std::__shared_weak_count::__release_weak(v127);
                      }
                      v134 = &buf[8];
                    }
                    CallInfo::~CallInfo((void **)v134);
                    *(_QWORD *)v250 = &v245;
                    std::vector<CallInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)v250);
                    goto LABEL_301;
                  }
                  if (((1 << v86) & 0x712) != 0)
                    goto LABEL_183;
                }
                if ((_DWORD)v86 == 104)
                {
LABEL_183:
                  v111 = *v110;
                  if (!os_log_type_enabled(*v110, OS_LOG_TYPE_ERROR))
                    goto LABEL_301;
                  v112 = vs::callList::asString(v86);
                  v113 = *((_DWORD *)v109 + 33);
                  *(_DWORD *)buf = 136315394;
                  *(_QWORD *)&buf[4] = v112;
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v113;
                  v114 = v111;
                  v115 = "Got unhandled call state for handover: %s, call ID: %d";
                }
                else
                {
                  v138 = *v110;
                  if (!os_log_type_enabled(*v110, OS_LOG_TYPE_ERROR))
                    goto LABEL_301;
                  v139 = vs::callList::asString(v86);
                  v140 = *((_DWORD *)v109 + 33);
                  *(_DWORD *)buf = 136315394;
                  *(_QWORD *)&buf[4] = v139;
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v140;
                  v114 = v138;
                  v115 = "Uknown call state for handover: %s, call ID: %d";
                }
                v116 = 18;
LABEL_186:
                _os_log_error_impl(&dword_216897000, v114, OS_LOG_TYPE_ERROR, v115, buf, v116);
              }
              else
              {
                switch((int)v86)
                {
                  case 1:
                    v117 = *v83;
                    if (os_log_type_enabled(*v83, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)buf = 67109120;
                      *(_DWORD *)&buf[4] = v85;
                      _os_log_impl(&dword_216897000, v117, OS_LOG_TYPE_DEFAULT, "#I --->BB Incoming Indication: ORIGINATION for %d", buf, 8u);
                    }
                    if (!*(_BYTE *)(v208 + 305))
                    {
                      v191 = *(_QWORD *)(v208 + 120);
                      v192 = std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t **)&v210, v85, (char *)v242);
                      (*(void (**)(uint64_t, uint64_t **))(*(_QWORD *)v191 + 24))(v191, v192 + 5);
                      v143 = *(_QWORD **)(v208 + 120);
                      v144 = std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t **)&v210, v85, (char *)v242);
                      v145 = 4;
                      goto LABEL_291;
                    }
                    v118 = *v83;
                    if (os_log_type_enabled(*v83, OS_LOG_TYPE_ERROR))
                    {
                      *(_WORD *)buf = 0;
                      v114 = v118;
                      v115 = "Got ORIGINATION for a silent call that's happening in Settings Model, ignoring";
                      v116 = 2;
                      goto LABEL_186;
                    }
                    break;
                  case 2:
                    v154 = *v83;
                    if (os_log_type_enabled(*v83, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)buf = 67109120;
                      *(_DWORD *)&buf[4] = v85;
                      _os_log_impl(&dword_216897000, v154, OS_LOG_TYPE_DEFAULT, "#I --->BB Incoming Indication: INCOMING for %d", buf, 8u);
                    }
                    v277 = 0;
                    v275 = 0u;
                    v276 = 0u;
                    v273 = 0u;
                    v274 = 0u;
                    v271 = 0u;
                    v272 = 0u;
                    v269 = 0u;
                    v270 = 0u;
                    v267 = 0u;
                    v268 = 0u;
                    v265 = 0u;
                    v266 = 0u;
                    v263 = 0u;
                    v264 = 0u;
                    v261 = 0u;
                    v262 = 0u;
                    v259 = 0u;
                    v260 = 0u;
                    v257 = 0u;
                    v258 = 0u;
                    v255 = 0u;
                    v256 = 0u;
                    v254 = 0u;
                    memset(buf, 0, sizeof(buf));
                    v155 = std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t **)&v210, v85, (char *)v242);
                    CallInfo::CallInfo((CallInfo *)buf, (const CallInfo *)(v155 + 5));
                    if (CallCommandDriver::shouldMTCallContinue((CallCommandDriver *)v208, 0, (const CallInfo *)buf)&& (*(unsigned int (**)(_QWORD, uint8_t *, uint64_t))(**(_QWORD **)(v208 + 120) + 184))(*(_QWORD *)(v208 + 120), buf, 1))
                    {
                      v156 = *(_QWORD *)(v208 + 120);
                      LODWORD(v245) = 0;
                      (*(void (**)(uint64_t, uint8_t *, __int128 *))(*(_QWORD *)v156 + 72))(v156, buf, &v245);
                    }
                    goto LABEL_281;
                  case 3:
                    v147 = *v83;
                    if (os_log_type_enabled(*v83, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)buf = 67109120;
                      *(_DWORD *)&buf[4] = v85;
                      _os_log_impl(&dword_216897000, v147, OS_LOG_TYPE_DEFAULT, "#I --->BB Incoming Indication: CONVERSATION for %d", buf, 8u);
                    }
                    v148 = std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t **)&v210, v85, (char *)v242);
                    v149 = v148 + 5;
                    if (v87 == 2 || v87 == 1 && (CallCommandDriver::carrierSupportsCallingTimewithFWIM() & 1) == 0)
                    {
                      *((_BYTE *)v148 + 125) = v88 != 0;
                      (*(void (**)(_QWORD, uint64_t **, uint64_t))(**(_QWORD **)(v208 + 120) + 48))(*(_QWORD *)(v208 + 120), v149, 1);
                    }
                    else
                    {
                      v150 = *v206;
                      if (os_log_type_enabled(*v206, OS_LOG_TYPE_DEFAULT))
                      {
                        *(_WORD *)buf = 0;
                        _os_log_impl(&dword_216897000, v150, OS_LOG_TYPE_DEFAULT, "#I Delaying setting call to active because carrier supports FWIM, but fake the call to go to Alerting state", buf, 2u);
                      }
                      (*(void (**)(_QWORD, uint64_t **))(**(_QWORD **)(v208 + 120) + 40))(*(_QWORD *)(v208 + 120), v149);
                    }
                    v185 = *v206;
                    if (os_log_type_enabled(*v206, OS_LOG_TYPE_DEFAULT))
                    {
                      v186 = (*(uint64_t (**)(_QWORD, uint64_t **))(**(_QWORD **)(v208 + 120) + 360))(*(_QWORD *)(v208 + 120), v149);
                      v187 = EurekaCallCommandDriver::findCallCapability(v208, (unint64_t)v201, *((_DWORD *)v148 + 73));
                      *(_DWORD *)buf = 67109376;
                      *(_DWORD *)&buf[4] = v186;
                      *(_WORD *)&buf[8] = 1024;
                      *(_DWORD *)&buf[10] = v187;
                      _os_log_impl(&dword_216897000, v185, OS_LOG_TYPE_DEFAULT, "#I Call went to active. Normally we would turn on Add call. Sould we do so now? TTY: %d. AddCallKey: %d", buf, 0xEu);
                    }
                    if (!EurekaCallCommandDriver::findCallCapability(v208, (unint64_t)v201, *((_DWORD *)v148 + 73))&& ((*(uint64_t (**)(_QWORD, uint64_t **))(**(_QWORD **)(v208 + 120) + 360))(*(_QWORD *)(v208 + 120), v149) & 1) == 0)
                    {
                      EurekaCallCommandDriver::setCallCapability(v208, v201, v87 != 2, 1, *((unsigned int *)v148 + 73));
                    }
                    break;
                  case 4:
                    v151 = *v83;
                    if (!os_log_type_enabled(*v83, OS_LOG_TYPE_DEFAULT))
                      break;
                    *(_DWORD *)buf = 67109120;
                    *(_DWORD *)&buf[4] = v85;
                    v136 = v151;
                    v137 = "#I --->BB Incoming Indication: CC_IN_PROGRESS for %d";
                    goto LABEL_232;
                  case 5:
                    v142 = *v83;
                    if (os_log_type_enabled(*v83, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)buf = 67109120;
                      *(_DWORD *)&buf[4] = v85;
                      _os_log_impl(&dword_216897000, v142, OS_LOG_TYPE_DEFAULT, "#I --->BB Incoming Indication: ALERTING for %d", buf, 8u);
                    }
                    v143 = *(_QWORD **)(v208 + 120);
                    v144 = std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t **)&v210, v85, (char *)v242);
                    v145 = 5;
                    goto LABEL_291;
                  case 6:
                    v157 = *v83;
                    if (os_log_type_enabled(*v83, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)buf = 67109120;
                      *(_DWORD *)&buf[4] = v85;
                      _os_log_impl(&dword_216897000, v157, OS_LOG_TYPE_DEFAULT, "#I --->BB Incoming Indication: HOLD for %d", buf, 8u);
                    }
                    *((_BYTE *)std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t **)&v210, v85, (char *)v242)+ 125) = v88 != 0;
                    v143 = *(_QWORD **)(v208 + 120);
                    v144 = std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t **)&v210, v85, (char *)v242);
                    v145 = 13;
LABEL_291:
                    (*(void (**)(_QWORD *, uint64_t **))(*v143 + 8 * v145))(v143, v144 + 5);
                    break;
                  case 7:
                    v158 = *v83;
                    if (os_log_type_enabled(*v83, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)buf = 67109120;
                      *(_DWORD *)&buf[4] = v85;
                      _os_log_impl(&dword_216897000, v158, OS_LOG_TYPE_DEFAULT, "#I --->BB Incoming Indication: WAITING for %d", buf, 8u);
                    }
                    v277 = 0;
                    v275 = 0u;
                    v276 = 0u;
                    v273 = 0u;
                    v274 = 0u;
                    v271 = 0u;
                    v272 = 0u;
                    v269 = 0u;
                    v270 = 0u;
                    v267 = 0u;
                    v268 = 0u;
                    v265 = 0u;
                    v266 = 0u;
                    v263 = 0u;
                    v264 = 0u;
                    v261 = 0u;
                    v262 = 0u;
                    v259 = 0u;
                    v260 = 0u;
                    v257 = 0u;
                    v258 = 0u;
                    v255 = 0u;
                    v256 = 0u;
                    v254 = 0u;
                    memset(buf, 0, sizeof(buf));
                    v159 = std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t **)&v210, v85, (char *)v242);
                    CallInfo::CallInfo((CallInfo *)buf, (const CallInfo *)(v159 + 5));
                    if (CallCommandDriver::shouldMTCallContinue((CallCommandDriver *)v208, 1, (const CallInfo *)buf)&& (*(unsigned int (**)(_QWORD, uint8_t *, uint64_t))(**(_QWORD **)(v208 + 120) + 184))(*(_QWORD *)(v208 + 120), buf, 1))
                    {
                      (*(void (**)(_QWORD, uint8_t *))(**(_QWORD **)(v208 + 120) + 88))(*(_QWORD *)(v208 + 120), buf);
                    }
                    else
                    {
                      v184 = *v83;
                      if (os_log_type_enabled(*v83, OS_LOG_TYPE_ERROR))
                      {
                        LOWORD(v245) = 0;
                        _os_log_error_impl(&dword_216897000, v184, OS_LOG_TYPE_ERROR, "Waiting call is not allowed, sending to voicemail.", (uint8_t *)&v245, 2u);
                      }
                      CallInfo::CallInfo((CallInfo *)v209, (const CallInfo *)buf);
                      EurekaCallCommandDriver::sendToVoicemail(v208, (uint64_t)v209);
                      CallInfo::~CallInfo(v209);
                    }
LABEL_281:
                    CallInfo::~CallInfo((void **)buf);
                    break;
                  case 8:
                    v152 = *v83;
                    if (!os_log_type_enabled(*v83, OS_LOG_TYPE_DEFAULT))
                      break;
                    *(_DWORD *)buf = 67109120;
                    *(_DWORD *)&buf[4] = v85;
                    v136 = v152;
                    v137 = "#I --->BB Incoming Indication: DISCONNECTING for %d";
                    goto LABEL_232;
                  case 9:
                    v160 = *v83;
                    if (os_log_type_enabled(*v83, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)buf = 67109120;
                      *(_DWORD *)&buf[4] = v85;
                      _os_log_impl(&dword_216897000, v160, OS_LOG_TYPE_DEFAULT, "#I --->BB Incoming Indication: END for %d", buf, 8u);
                    }
                    v161 = (os_log_t *)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(v208 + 112) + 16))(*(_QWORD *)(v208 + 112), v207);
                    *(_QWORD *)buf = 0;
                    *(_QWORD *)&buf[8] = buf;
                    *(_QWORD *)&buf[16] = 0x4002000000;
                    *(_QWORD *)&buf[24] = __Block_byref_object_copy__77;
                    *(_QWORD *)&v254 = __Block_byref_object_dispose__78;
                    v255 = 0uLL;
                    *((_QWORD *)&v254 + 1) = 0;
                    *(_QWORD *)&v245 = MEMORY[0x24BDAC760];
                    *((_QWORD *)&v245 + 1) = 0x40000000;
                    v246 = (uint64_t)___ZN23EurekaCallCommandDriver18parseEndIndicationERKN2vs15VoiceCallStatus10IndicationERNSt3__13mapIh8CallInfoNS5_4lessIhEENS5_9allocatorINS5_4pairIKhS7_EEEEEEN10subscriber7SimSlotE_block_invoke;
                    v247 = (__n128 (*)(_QWORD *, uint64_t))&unk_24D5E2EB0;
                    v248 = buf;
                    v162 = (void *)qmi::MessageBase::findTlvValue(v204);
                    v164 = v162;
                    if (!v162)
                      goto LABEL_288;
                    v165 = v163;
                    v235 = v162;
                    memset(v250, 0, 24);
                    tlv::parseV<vs::tlv::CallEndReasonList>((unsigned __int8 **)&v235, v163, (uint64_t *)v250);
                    v166 = v235;
                    if (v235)
                      ((void (*)(char *, const void **))v246)((char *)&v245, (const void **)v250);
                    if (*(_QWORD *)v250)
                    {
                      *(_QWORD *)&v250[8] = *(_QWORD *)v250;
                      operator delete(*(void **)v250);
                    }
                    if (!v166
                      && (((uint64_t (*)(_QWORD, uint64_t, void *, _QWORD))*MEMORY[0x24BED8BD0])(*(unsigned __int16 *)v204, 20, v164, v165) & 1) == 0)
                    {
LABEL_288:
                      v188 = *v161;
                      if (!os_log_type_enabled(*v161, OS_LOG_TYPE_ERROR))
                        goto LABEL_293;
                      *(_WORD *)v250 = 0;
                      v189 = v188;
                      v190 = "In END indication, CallEndReason TLV is not present. Ending all the calls with no error reason";
LABEL_305:
                      _os_log_error_impl(&dword_216897000, v189, OS_LOG_TYPE_ERROR, v190, v250, 2u);
                      goto LABEL_293;
                    }
                    v167 = *(unsigned __int8 **)(*(_QWORD *)&buf[8] + 40);
                    v168 = *(unsigned __int8 **)(*(_QWORD *)&buf[8] + 48);
                    v202 = v82;
                    if (v168 == v167)
                    {
                      v193 = *v161;
                      if (!os_log_type_enabled(*v161, OS_LOG_TYPE_ERROR))
                        goto LABEL_293;
                      *(_WORD *)v250 = 0;
                      v189 = v193;
                      v190 = "In END indication, number of call instances are 0";
                      goto LABEL_305;
                    }
                    do
                    {
                      v169 = *v167;
                      __str.__r_.__value_.__s.__data_[0] = *v167;
                      v170 = *((unsigned __int16 *)v167 + 1);
                      v236 = 0;
                      v235 = 0;
                      v237 = 0;
                      convertCallEndReasonToString(v170, &v235);
                      v171 = *v161;
                      if (os_log_type_enabled(*v161, OS_LOG_TYPE_DEFAULT))
                      {
                        convertCallEndReasonToString(v170, v229);
                        v172 = v229;
                        if (SHIBYTE(v230) < 0)
                          v172 = (void **)v229[0];
                        v173 = &v235;
                        if (SHIBYTE(v237) < 0)
                          v173 = v235;
                        *(_DWORD *)v250 = 136315650;
                        *(_QWORD *)&v250[4] = v172;
                        *(_WORD *)&v250[12] = 2080;
                        *(_QWORD *)&v250[14] = v173;
                        *(_WORD *)&v250[22] = 1024;
                        *(_DWORD *)&v250[24] = v169;
                        _os_log_impl(&dword_216897000, v171, OS_LOG_TYPE_DEFAULT, "#I BB Call End Reason: %s. As String: %s. Call id: %d", v250, 0x1Cu);
                        if (SHIBYTE(v230) < 0)
                          operator delete(v229[0]);
                      }
                      v174 = convertCallEndBBCodeToCSIError(v170);
                      v175 = CSIErrorString();
                      *((_WORD *)std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t **)&v210, v169, (char *)&__str)+ 78) = v170;
                      v176 = std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t **)&v210, v169, (char *)&__str);
                      *((_DWORD *)v176 + 40) = v174;
                      *((_BYTE *)v176 + 164) = 1;
                      v177 = *v161;
                      if (os_log_type_enabled(*v161, OS_LOG_TYPE_DEFAULT))
                      {
                        v178 = v161;
                        v179 = SHIBYTE(v237);
                        v180 = (void **)v235;
                        convertCallEndReasonToString(v170, v229);
                        v181 = &v235;
                        if (v179 < 0)
                          v181 = v180;
                        v182 = v229;
                        if (SHIBYTE(v230) < 0)
                          v182 = (void **)v229[0];
                        *(_DWORD *)v250 = 136315906;
                        *(_QWORD *)&v250[4] = v175;
                        *(_WORD *)&v250[12] = 1024;
                        *(_DWORD *)&v250[14] = v174;
                        *(_WORD *)&v250[18] = 2080;
                        *(_QWORD *)&v250[20] = v181;
                        *(_WORD *)&v250[28] = 2080;
                        *(_QWORD *)&v250[30] = v182;
                        _os_log_impl(&dword_216897000, v177, OS_LOG_TYPE_DEFAULT, "#I Call End Reason: %s, %d (BB Reason: %s(%s))", v250, 0x26u);
                        if (SHIBYTE(v230) < 0)
                          operator delete(v229[0]);
                        v161 = v178;
                        v82 = v202;
                      }
                      if (SHIBYTE(v237) < 0)
                        operator delete(v235);
                      v167 += 4;
                    }
                    while (v167 != v168);
LABEL_293:
                    _Block_object_dispose(buf, 8);
                    if (*((_QWORD *)&v254 + 1))
                    {
                      *(_QWORD *)&v255 = *((_QWORD *)&v254 + 1);
                      operator delete(*((void **)&v254 + 1));
                    }
                    v194 = std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t **)&v210, v85, (char *)v242);
                    if ((*((_WORD *)v194 + 78) & 0xFFFE) == 0x17A)
                    {
                      v195 = *v206;
                      if (os_log_type_enabled(*v206, OS_LOG_TYPE_DEFAULT))
                      {
                        *(_WORD *)buf = 0;
                        _os_log_impl(&dword_216897000, v195, OS_LOG_TYPE_DEFAULT, "#I --->BB Incoming Indication: END with REDIAL OVER PS", buf, 2u);
                      }
                      v196 = *(_QWORD **)(v208 + 120);
                      v197 = 27;
                    }
                    else
                    {
                      v196 = *(_QWORD **)(v208 + 120);
                      v194 = std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t **)&v210, v85, (char *)v242);
                      v197 = 8;
                    }
                    (*(void (**)(_QWORD *, uint64_t **, _QWORD))(*v196 + 8 * v197))(v196, v194 + 5, 0);
                    break;
                  case 10:
                    v146 = *v83;
                    if (!os_log_type_enabled(*v83, OS_LOG_TYPE_DEFAULT))
                      break;
                    *(_DWORD *)buf = 67109120;
                    *(_DWORD *)&buf[4] = v85;
                    v136 = v146;
                    v137 = "#I --->BB Incoming Indication: CALL_STATE_SETUP for %d";
                    goto LABEL_232;
                  default:
                    if ((_DWORD)v86 == 104)
                    {
                      v135 = *v83;
                      if (!os_log_type_enabled(*v83, OS_LOG_TYPE_DEFAULT))
                        break;
                      *(_DWORD *)buf = 67109120;
                      *(_DWORD *)&buf[4] = v85;
                      v136 = v135;
                      v137 = "#I --->BB Incoming Indication: SILENT_REDIAL for %d";
LABEL_232:
                      v153 = 8;
                      goto LABEL_233;
                    }
                    v183 = *v83;
                    if (os_log_type_enabled(*v83, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)buf = 67109376;
                      *(_DWORD *)&buf[4] = v86;
                      *(_WORD *)&buf[8] = 1024;
                      *(_DWORD *)&buf[10] = v85;
                      v136 = v183;
                      v137 = "#I --->BB Incoming Indication: %d Unknown. For call %d. Ignoring.";
                      v153 = 14;
LABEL_233:
                      _os_log_impl(&dword_216897000, v136, OS_LOG_TYPE_DEFAULT, v137, buf, v153);
                      break;
                    }
                    break;
                }
              }
LABEL_301:
              v83 = v206;
LABEL_302:
              v82 += 7;
              if (v82 == v205)
                goto LABEL_306;
              break;
            default:
              v89 = *v83;
              if (os_log_type_enabled(*v83, OS_LOG_TYPE_DEFAULT))
              {
                v90 = "Call Type Other";
                if (v84 == 10)
                  v90 = "Call Type Supplementary Service";
                if (v84)
                  v91 = (char *)v90;
                else
                  v91 = "Call Type Voice";
                std::string::basic_string[abi:ne180100]<0>(buf, v91);
                v92 = buf;
                if ((buf[23] & 0x80u) != 0)
                  v92 = *(uint8_t **)buf;
                LODWORD(v245) = 136315138;
                *(_QWORD *)((char *)&v245 + 4) = v92;
                _os_log_impl(&dword_216897000, v89, OS_LOG_TYPE_DEFAULT, "#I Ignoring the indication for %s", (uint8_t *)&v245, 0xCu);
                if ((char)buf[23] < 0)
                  operator delete(*(void **)buf);
              }
LABEL_174:
              v108 = *v83;
              if (os_log_type_enabled(*v83, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)buf = 0;
                _os_log_impl(&dword_216897000, v108, OS_LOG_TYPE_DEFAULT, "#I Ignoring BB Incoming Indication due to it getting processed earlier as OTASP call or other", buf, 2u);
              }
              goto LABEL_302;
          }
        }
      }
    }
    v23 = *(_QWORD *)(*((_QWORD *)&v245 + 1) + 40);
    v24 = *(_QWORD *)(*((_QWORD *)&v245 + 1) + 48);
    if (v23 != v24)
    {
      v25 = (__int128 *)(v23 + 8);
      do
      {
        v26 = (uint64_t)v25 - 8;
        v27 = *((_BYTE *)v25 - 8);
        v228 = v27;
        v28 = *((unsigned __int8 *)v25 - 7);
        v29 = *((unsigned __int8 *)v25 - 6);
        memset(&v241, 0, sizeof(v241));
        if (*((char *)v25 + 23) < 0)
        {
          std::string::__init_copy_ctor_external(&v241, *(const std::string::value_type **)v25, *((_QWORD *)v25 + 1));
        }
        else
        {
          v30 = *v25;
          v241.__r_.__value_.__r.__words[2] = *((_QWORD *)v25 + 2);
          *(_OWORD *)&v241.__r_.__value_.__l.__data_ = v30;
        }
        memset(&__str, 0, sizeof(__str));
        std::string::basic_string[abi:ne180100]<0>(&__str, (char *)&unk_216AC4FCA);
        decodeString();
        v31 = *v16;
        if (os_log_type_enabled(*v16, OS_LOG_TYPE_DEFAULT))
        {
          p_str = &__str;
          if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
            p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
          *(_DWORD *)v242 = 67109378;
          *(_DWORD *)&v242[4] = v29;
          v243 = 2080;
          v244 = p_str;
          _os_log_impl(&dword_216897000, v31, OS_LOG_TYPE_DEFAULT, "#I Got RemoteNameArray. Codeing_Scheme is: %d. Parsed Name is: %s", v242, 0x12u);
        }
        if (v28 == 1)
          v33 = 1;
        else
          v33 = 2 * (v28 == 2);
        v34 = (uint64_t **)(*(_QWORD *)&buf[8] + 40);
        v5 = v208;
        if (v33)
        {
          v35 = std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>(v34, v27, (char *)&v228);
          if (*((char *)v35 + 71) < 0)
          {
            v35[7] = 0;
            v36 = v35[6];
          }
          else
          {
            v36 = (uint64_t *)(v35 + 6);
            *((_BYTE *)v35 + 71) = 0;
          }
          *(_BYTE *)v36 = 0;
        }
        else
        {
          v37 = std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>(v34, v27, (char *)&v228);
          std::string::operator=((std::string *)v37 + 2, &__str);
        }
        *((_DWORD *)std::__tree<std::__value_type<unsigned char,CallInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,CallInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,CallInfo>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t **)(*(_QWORD *)&buf[8] + 40), v27, (char *)&v228)+ 30) = v33;
        if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__str.__r_.__value_.__l.__data_);
        if (SHIBYTE(v241.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v241.__r_.__value_.__l.__data_);
        v25 += 2;
      }
      while (v26 + 32 != v24);
    }
    goto LABEL_56;
  }
LABEL_307:
  v198 = v217;
  if (v217)
  {
    v199 = (unint64_t *)&v217->__shared_owners_;
    do
      v200 = __ldaxr(v199);
    while (__stlxr(v200 - 1, v199));
    if (!v200)
    {
      ((void (*)(std::__shared_weak_count *))v198->__on_zero_shared)(v198);
      std::__shared_weak_count::__release_weak(v198);
    }
  }
LABEL_312:
  _Block_object_dispose(&v219, 8);
  if (v224)
  {
    v225 = v224;
    operator delete(v224);
  }
}

