@implementation NEIKEv2Session

- (void)reportPrivateNotifiesInPacket:(id *)a1
{
  id v3;
  const char *v4;
  id Property;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t i;
  _QWORD *v10;
  uint64_t v11;
  NSObject *v12;
  const char *v13;
  id v14;
  NEIKEv2PrivateNotify *v15;
  SEL v16;
  id v17;
  NEIKEv2PrivateNotify *v18;
  NSObject *v19;
  const char *v20;
  id v21;
  const char *v22;
  _QWORD *v23;
  uint64_t v24;
  id *v25;
  id v26;
  id v27;
  id v28;
  id v29;
  id *self;
  id v31;
  id obj;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  uint8_t buf[4];
  _BYTE v38[14];
  __int16 v39;
  id v40;
  _BYTE v41[128];
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  self = a1;
  if (a1)
  {
    v33 = 0u;
    v34 = 0u;
    v35 = 0u;
    v36 = 0u;
    v29 = v3;
    v31 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
    if (v3)
      Property = objc_getProperty(v3, v4, 64, 1);
    else
      Property = 0;
    obj = Property;
    v6 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v33, v41, 16);
    if (v6)
    {
      v7 = v6;
      v8 = *(_QWORD *)v34;
      do
      {
        for (i = 0; i != v7; ++i)
        {
          if (*(_QWORD *)v34 != v8)
            objc_enumerationMutation(obj);
          v10 = *(_QWORD **)(*((_QWORD *)&v33 + 1) + 8 * i);
          if (v10)
          {
            v11 = v10[3];
            if ((unsigned __int16)v11 >= 0xA000u)
            {
              ne_log_obj();
              v12 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
              {
                v14 = objc_getProperty(v10, v13, 32, 1);
                *(_DWORD *)buf = 138412802;
                *(_QWORD *)v38 = self;
                *(_WORD *)&v38[8] = 1024;
                *(_DWORD *)&v38[10] = (unsigned __int16)v11;
                v39 = 2112;
                v40 = v14;
                _os_log_impl(&dword_19BD16000, v12, OS_LOG_TYPE_INFO, "%@ Received private notify status %u %@", buf, 0x1Cu);

              }
              v15 = [NEIKEv2PrivateNotify alloc];
              v17 = objc_getProperty(v10, v16, 32, 1);
              v18 = -[NEIKEv2PrivateNotify initWithNotifyStatus:notifyData:](v15, "initWithNotifyStatus:notifyData:", (unsigned __int16)v11, v17);

              if (v18)
              {
                objc_msgSend(v31, "addObject:", v18);
              }
              else
              {
                ne_log_obj();
                v19 = objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT))
                {
                  v21 = objc_getProperty(v10, v20, 32, 1);
                  *(_DWORD *)buf = 67109378;
                  *(_DWORD *)v38 = (unsigned __int16)v11;
                  *(_WORD *)&v38[4] = 2112;
                  *(_QWORD *)&v38[6] = v21;
                  _os_log_fault_impl(&dword_19BD16000, v19, OS_LOG_TYPE_FAULT, "NEIKEv2PrivateNotify init %u %@ failed", buf, 0x12u);

                }
              }

            }
          }
        }
        v7 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v33, v41, 16);
      }
      while (v7);
    }

    v3 = v29;
    if (objc_msgSend(v31, "count"))
    {
      v23 = objc_getProperty(self, v22, 336, 1);
      if (v23 && (v24 = v23[6], v23, v24 == 2))
      {
        -[NEIKEv2Session reportPrivateNotifies:](self, v31);
      }
      else
      {
        v25 = self + 49;
        v26 = self[49];

        if (!v26)
        {
          v27 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
          objc_storeStrong(v25, v27);

        }
        v28 = *v25;
        objc_msgSend(v28, "addObjectsFromArray:", v31);

      }
    }

  }
}

- (void)initiateDelete:(_QWORD *)a1
{
  const char *v3;
  _BYTE *v4;
  NSObject *v5;
  NSObject *v6;
  NEIKEv2DeletePayload *v7;
  NSObject *p_super;
  void *v9;
  SEL v10;
  NSObject *v11;
  _BYTE *v12;
  SEL v13;
  id v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  void *ErrorFailedToSend;
  const char *v23;
  const char *v24;
  void *v25;
  NSObject *v26;
  _BYTE *v27;
  void *v28;
  id v29;
  SEL v30;
  _BYTE *Property;
  int v32;
  void *Error;
  int v34;
  SEL v35;
  id v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  void *v44;
  const char *v45;
  const char *v46;
  NSObject *v47;
  uint64_t v48;
  uint64_t v49;
  _QWORD aBlock[4];
  id v51;
  _QWORD *v52;
  _QWORD v53[5];
  id v54;
  uint8_t buf[24];
  uint64_t v56;

  v56 = *MEMORY[0x1E0C80C00];
  v4 = a2;
  if (a1)
  {
    v5 = objc_getProperty(a1, v3, 368, 1);
    dispatch_assert_queue_V2(v5);

    if (!v4)
    {
      ne_log_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136315138;
        *(_QWORD *)&buf[4] = "-[NEIKEv2Session(Exchange) initiateDelete:]";
        _os_log_fault_impl(&dword_19BD16000, v11, OS_LOG_TYPE_FAULT, "%s called with null deleteIKEContext", buf, 0xCu);
      }
      goto LABEL_27;
    }
    objc_opt_self();
    v6 = -[NEIKEv2Packet initOutbound]([NEIKEv2InformationalPacket alloc]);
    if (v6)
    {
      v7 = objc_alloc_init(NEIKEv2DeletePayload);
      p_super = &v7->super.super;
      if (v7)
        v7->_protocol = 1;
      if ((-[NEIKEv2Payload isValid]((uint64_t)v7) & 1) != 0)
      {
        *(_QWORD *)buf = p_super;
        objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", buf, 1);
        v9 = (void *)objc_claimAutoreleasedReturnValue();
        objc_setProperty_atomic(v6, v10, v9, 88);

        v11 = v6;
        goto LABEL_11;
      }
      ne_log_obj();
      v47 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v47, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136315138;
        *(_QWORD *)&buf[4] = "+[NEIKEv2InformationalPacket(Exchange) createDeleteIKE]";
        _os_log_fault_impl(&dword_19BD16000, v47, OS_LOG_TYPE_FAULT, "%s called with null delete.isValid", buf, 0xCu);
      }

    }
    else
    {
      ne_log_obj();
      p_super = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(p_super, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_fault_impl(&dword_19BD16000, p_super, OS_LOG_TYPE_FAULT, "[[NEIKEv2InformationalPacket alloc] initOutbound:] failed", buf, 2u);
      }
    }
    v11 = 0;
LABEL_11:

    if (v11)
    {
      if (v4[24])
      {
        v53[0] = MEMORY[0x1E0C809B0];
        v53[1] = 3221225472;
        v53[2] = __43__NEIKEv2Session_Exchange__initiateDelete___block_invoke;
        v53[3] = &unk_1E3CC0E88;
        v53[4] = a1;
        v12 = v4;
        v54 = v12;
        if (-[NEIKEv2Session sendRequest:retry:replyHandler:]((uint64_t)a1, v11, v53) == -1)
        {
          objc_msgSend(v12, "sendCallbackSuccess:session:", 0, a1);
          v14 = objc_getProperty(a1, v13, 336, 1);
          ErrorFailedToSend = (void *)NEIKEv2CreateErrorFailedToSend(CFSTR("delete with reply"), v15, v16, v17, v18, v19, v20, v21, v48);
          -[NEIKEv2IKESA setState:error:]((uint64_t)v14, 3uLL, ErrorFailedToSend);

          -[NEIKEv2Session reportState](a1, v23);
          -[NEIKEv2Session resetAll]((uint64_t)a1, v24);
        }
        v25 = v54;
      }
      else
      {
        aBlock[0] = MEMORY[0x1E0C809B0];
        aBlock[1] = 3221225472;
        aBlock[2] = __43__NEIKEv2Session_Exchange__initiateDelete___block_invoke_4;
        aBlock[3] = &unk_1E3CC0EB0;
        v27 = v4;
        v51 = v27;
        v52 = a1;
        v28 = _Block_copy(aBlock);
        v11 = v11;
        v29 = v28;
        Property = objc_getProperty(a1, v30, 336, 1);
        v32 = 4;
        if (Property)
        {
          if ((Property[17] & 1) != 0)
            v32 = 12;
          else
            v32 = 4;
        }
        Error = (void *)NEIKEv2CreateError(3);
        v34 = -[NEIKEv2Session sendRequest:retryIntervalInMilliseconds:maxRetries:timeoutError:resend:sendMessageID:sendCompletionHandler:replyHandler:]((uint64_t)a1, v11, 0, v32, Error, 0, 0xFFFFFFFFLL, v29, 0);

        if (v34 == -1)
        {
          objc_msgSend(v27, "sendCallbackSuccess:session:", 0, a1);
          v36 = objc_getProperty(a1, v35, 336, 1);
          v44 = (void *)NEIKEv2CreateErrorFailedToSend(CFSTR("delete with send complete"), v37, v38, v39, v40, v41, v42, v43, v49);
          -[NEIKEv2IKESA setState:error:]((uint64_t)v36, 3uLL, v44);

          -[NEIKEv2Session reportState](a1, v45);
          -[NEIKEv2Session resetAll]((uint64_t)a1, v46);
        }

        v25 = v51;
      }

    }
    else
    {
      ne_log_obj();
      v26 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138412290;
        *(_QWORD *)&buf[4] = a1;
        _os_log_error_impl(&dword_19BD16000, v26, OS_LOG_TYPE_ERROR, "%@ Failed to create Delete packet", buf, 0xCu);
      }

      objc_msgSend(v4, "sendCallbackSuccess:session:", 0, a1);
      v11 = 0;
    }
LABEL_27:

  }
}

void __43__NEIKEv2Session_Exchange__initiateDelete___block_invoke(uint64_t a1, void *a2)
{
  id v3;
  const char *v4;
  NSObject *v5;
  uint64_t v6;
  const char *v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint8_t v12[24];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    if (v3 && !-[NEIKEv2Packet hasErrors](v3, v4))
    {
      v9 = *(_QWORD *)(a1 + 32);
      v8 = *(void **)(a1 + 40);
      v10 = 1;
      goto LABEL_9;
    }
    ne_log_obj();
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v6 = *(_QWORD *)(a1 + 32);
      *(_DWORD *)v12 = 138412290;
      *(_QWORD *)&v12[4] = v6;
      v7 = "%@ Failed to process packet";
LABEL_11:
      _os_log_error_impl(&dword_19BD16000, v5, OS_LOG_TYPE_ERROR, v7, v12, 0xCu);
    }
  }
  else
  {
    ne_log_obj();
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v11 = *(_QWORD *)(a1 + 32);
      *(_DWORD *)v12 = 138412290;
      *(_QWORD *)&v12[4] = v11;
      v7 = "%@ Failed to receive Delete packet";
      goto LABEL_11;
    }
  }

  v9 = *(_QWORD *)(a1 + 32);
  v8 = *(void **)(a1 + 40);
  v10 = 0;
LABEL_9:
  objc_msgSend(v8, "sendCallbackSuccess:session:", v10, v9, *(_OWORD *)v12);

}

uint64_t __43__NEIKEv2Session_Exchange__initiateDelete___block_invoke_4(uint64_t a1, uint64_t a2)
{
  return objc_msgSend(*(id *)(a1 + 32), "sendCallbackSuccess:session:", a2, *(_QWORD *)(a1 + 40));
}

- (void)initiateDeleteChildSPI:(void *)a3 remoteSPI:(void *)a4 deleteCompletionCallback:
{
  id v7;
  id v8;
  id v9;
  SEL v10;
  NSObject *v11;
  id v12;
  NSObject *v13;
  NEIKEv2DeletePayload *v14;
  NSObject *p_super;
  const char *v16;
  void *v17;
  void *v18;
  SEL v19;
  NSObject *v20;
  id v21;
  SEL v22;
  id v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  void *ErrorFailedToSend;
  const char *v32;
  const char *v33;
  NSObject *v34;
  NSObject *v35;
  uint64_t v36[5];
  id v37;
  id v38;
  id v39;
  uint8_t buf[24];
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  v7 = a3;
  v8 = a4;
  if (!a1)
    goto LABEL_22;
  v9 = a2;
  v11 = objc_getProperty(a1, v10, 368, 1);
  dispatch_assert_queue_V2(v11);

  v12 = v9;
  objc_opt_self();
  if (!v12)
  {
    ne_log_obj();
    v13 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = "+[NEIKEv2InformationalPacket(Exchange) createDeleteChild:]";
      _os_log_fault_impl(&dword_19BD16000, v13, OS_LOG_TYPE_FAULT, "%s called with null childSPI", buf, 0xCu);
    }
    v20 = 0;
    goto LABEL_14;
  }
  v13 = -[NEIKEv2Packet initOutbound]([NEIKEv2InformationalPacket alloc]);
  if (!v13)
  {
    ne_log_obj();
    p_super = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(p_super, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_fault_impl(&dword_19BD16000, p_super, OS_LOG_TYPE_FAULT, "[[NEIKEv2InformationalPacket alloc] initOutbound:] failed", buf, 2u);
    }
    goto LABEL_12;
  }
  v14 = objc_alloc_init(NEIKEv2DeletePayload);
  p_super = &v14->super.super;
  if (v14)
    v14->_protocol = 3;
  v39 = v12;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", &v39, 1);
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  if (p_super)
    objc_setProperty_atomic(p_super, v16, v17, 32);

  if ((-[NEIKEv2Payload isValid]((uint64_t)p_super) & 1) == 0)
  {
    ne_log_obj();
    v35 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v35, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = "+[NEIKEv2InformationalPacket(Exchange) createDeleteChild:]";
      _os_log_fault_impl(&dword_19BD16000, v35, OS_LOG_TYPE_FAULT, "%s called with null delete.isValid", buf, 0xCu);
    }

LABEL_12:
    v20 = 0;
    goto LABEL_13;
  }
  *(_QWORD *)buf = p_super;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", buf, 1);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  objc_setProperty_atomic(v13, v19, v18, 88);

  v20 = v13;
LABEL_13:

LABEL_14:
  if (v20)
  {
    v36[0] = MEMORY[0x1E0C809B0];
    v36[1] = 3221225472;
    v36[2] = (uint64_t)__86__NEIKEv2Session_Exchange__initiateDeleteChildSPI_remoteSPI_deleteCompletionCallback___block_invoke;
    v36[3] = (uint64_t)&unk_1E3CC0F00;
    v36[4] = (uint64_t)a1;
    v21 = v8;
    v38 = v21;
    v37 = v7;
    if (-[NEIKEv2Session sendRequest:retry:replyHandler:]((uint64_t)a1, v20, v36) == -1)
    {
      (*((void (**)(id, _QWORD))v21 + 2))(v21, 0);
      v23 = objc_getProperty(a1, v22, 336, 1);
      ErrorFailedToSend = (void *)NEIKEv2CreateErrorFailedToSend(CFSTR("delete child"), v24, v25, v26, v27, v28, v29, v30, v36[0]);
      -[NEIKEv2IKESA setState:error:]((uint64_t)v23, 3uLL, ErrorFailedToSend);

      -[NEIKEv2Session reportState](a1, v32);
      -[NEIKEv2Session resetAll]((uint64_t)a1, v33);
    }

  }
  else
  {
    ne_log_obj();
    v34 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      *(_QWORD *)&buf[4] = a1;
      _os_log_error_impl(&dword_19BD16000, v34, OS_LOG_TYPE_ERROR, "%@ Failed to create Delete packet", buf, 0xCu);
    }

    (*((void (**)(id, _QWORD))v8 + 2))(v8, 0);
  }

LABEL_22:
}

void __86__NEIKEv2Session_Exchange__initiateDeleteChildSPI_remoteSPI_deleteCompletionCallback___block_invoke(uint64_t a1, void *a2)
{
  id v3;
  NSObject *v4;
  uint64_t v5;
  const char *v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    ne_log_obj();
    v4 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
LABEL_7:

      (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)(a1 + 48) + 16))(*(_QWORD *)(a1 + 48), 0);
      goto LABEL_8;
    }
    v5 = *(_QWORD *)(a1 + 32);
    v8 = 138412290;
    v9 = v5;
    v6 = "%@ Failed to receive Delete packet";
LABEL_10:
    _os_log_error_impl(&dword_19BD16000, v4, OS_LOG_TYPE_ERROR, v6, (uint8_t *)&v8, 0xCu);
    goto LABEL_7;
  }
  if ((-[NEIKEv2InformationalPacket validateDeleteChild:]((uint64_t)v3, *(void **)(a1 + 40)) & 1) == 0)
  {
    ne_log_obj();
    v4 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      goto LABEL_7;
    v7 = *(_QWORD *)(a1 + 32);
    v8 = 138412290;
    v9 = v7;
    v6 = "%@ Failed to process Delete packet";
    goto LABEL_10;
  }
  (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)(a1 + 48) + 16))(*(_QWORD *)(a1 + 48), 1);
LABEL_8:

}

- (uint64_t)receiveDeleteChildSPI:(void *)a3 remoteSPI:(void *)a4 packet:
{
  id v7;
  id v8;
  const char *v9;
  id v10;
  id Property;
  NSObject *v12;
  NSObject *v13;
  const char *v14;
  const char *v15;
  uint64_t v16;
  NSObject *v17;
  id v18;
  id v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  void *ErrorFailedToSend;
  const char *v28;
  const char *v29;
  _BYTE v31[24];
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v7 = a2;
  v8 = a3;
  v10 = a4;
  if (a1)
    Property = objc_getProperty(a1, v9, 368, 1);
  else
    Property = 0;
  v12 = Property;
  dispatch_assert_queue_V2(v12);

  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    ne_log_obj();
    v13 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v31 = 138412290;
      *(_QWORD *)&v31[4] = a1;
      v14 = "%@ Failed to receive Delete packet";
LABEL_11:
      _os_log_error_impl(&dword_19BD16000, v13, OS_LOG_TYPE_ERROR, v14, v31, 0xCu);
    }
LABEL_22:
    v16 = 0;
    goto LABEL_23;
  }
  if ((-[NEIKEv2InformationalPacket validateDeleteChild:]((uint64_t)v10, v8) & 1) == 0)
  {
    ne_log_obj();
    v13 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v31 = 138412290;
      *(_QWORD *)&v31[4] = a1;
      v14 = "%@ Failed to process Delete packet";
      goto LABEL_11;
    }
    goto LABEL_22;
  }
  if (v7)
    +[NEIKEv2InformationalPacket createDeleteResponse:child:]((uint64_t)NEIKEv2InformationalPacket, v10, v7);
  else
    +[NEIKEv2InformationalPacket createInformationalResponse:ikeSA:]((uint64_t)NEIKEv2InformationalPacket, v10, 0);
  v13 = objc_claimAutoreleasedReturnValue();
  if (!v13)
  {
    ne_log_obj();
    v17 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v31 = 138412290;
      *(_QWORD *)&v31[4] = a1;
      _os_log_error_impl(&dword_19BD16000, v17, OS_LOG_TYPE_ERROR, "%@ Failed to create Delete packet", v31, 0xCu);
    }

    v13 = 0;
    goto LABEL_22;
  }
  if ((-[NEIKEv2Session sendReply:replyHandler:]((uint64_t)a1, v13, 0) & 1) == 0)
  {
    if (a1)
      v18 = objc_getProperty(a1, v15, 336, 1);
    else
      v18 = 0;
    v19 = v18;
    ErrorFailedToSend = (void *)NEIKEv2CreateErrorFailedToSend(CFSTR("delete child reply"), v20, v21, v22, v23, v24, v25, v26, *(uint64_t *)v31);
    -[NEIKEv2IKESA setState:error:]((uint64_t)v19, 3uLL, ErrorFailedToSend);

    -[NEIKEv2Session reportState](a1, v28);
    -[NEIKEv2Session resetAll]((uint64_t)a1, v29);
    goto LABEL_22;
  }
  v16 = 1;
LABEL_23:

  return v16;
}

- (void)initiateInformational:(_BYTE *)a1
{
  const char *v3;
  id v4;
  id Property;
  NSObject *v6;
  NSObject *v7;
  const char *v8;
  _QWORD *v9;
  uint64_t v10;
  const char *v11;
  _BYTE *v12;
  char v13;
  const char *v14;
  NSObject *v15;
  NSObject *v16;
  NSObject *v17;
  const char *v18;
  NSObject *v19;
  void *v20;
  const char *v21;
  const char *v22;
  void *v23;
  id v24;
  id v25;
  NSObject *v26;
  const char *v27;
  void *v28;
  const char *v29;
  const char *v30;
  void *v31;
  id v32;
  id v33;
  NSObject *v34;
  NSObject *v35;
  NSObject *v36;
  NSObject *v37;
  id v38;
  uint64_t v39;
  NSObject *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  void *v45;
  NEIKEv2NotifyPayload *v46;
  unsigned int v47;
  void *v48;
  SEL v49;
  uint64_t v50;
  unint64_t v51;
  int v52;
  void *Error;
  id v54;
  int v55;
  NSObject *v56;
  NSObject *v57;
  SEL v58;
  id v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  void *v67;
  const char *v68;
  const char *v69;
  NSObject *v70;
  const char *v71;
  id v72;
  id v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  void *ErrorInternal;
  const char *v82;
  const char *v83;
  void *v84;
  const char *v85;
  id v86;
  id v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  void *ErrorFailedToSend;
  const char *v96;
  const char *v97;
  uint64_t v98;
  uint64_t v99;
  id obj;
  _QWORD v101[5];
  id v102;
  __int128 v103;
  __int128 v104;
  __int128 v105;
  __int128 v106;
  uint8_t buf[4];
  _BYTE *v108;
  __int16 v109;
  id v110;
  __int16 v111;
  int v112;
  _BYTE v113[128];
  uint64_t v114;

  v114 = *MEMORY[0x1E0C80C00];
  v4 = a2;
  if (a1)
    Property = objc_getProperty(a1, v3, 368, 1);
  else
    Property = 0;
  v6 = Property;
  dispatch_assert_queue_V2(v6);

  if (!a1[15])
    __assert_rtn("-[NEIKEv2Session(Exchange) initiateInformational:]", "NEIKEv2Exchange.m", 318, "self.hasOutboundRequestInFlight");
  ne_log_obj();
  v7 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 138412546;
    v108 = a1;
    v109 = 2112;
    v110 = v4;
    _os_log_impl(&dword_19BD16000, v7, OS_LOG_TYPE_INFO, "%@ Sending %@", buf, 0x16u);
  }

  if (!*((_DWORD *)v4 + 6)
    || (v9 = objc_getProperty(a1, v8, 336, 1)) == 0
    || (v10 = v9[6], v9, v10 != 2))
  {
    objc_msgSend(v4, "sendCallbackSuccess:session:", 0, a1);
    goto LABEL_72;
  }
  v12 = objc_getProperty(a1, v11, 336, 1);
  if (!v12 || (v13 = v12[11], v12, (v13 & 1) == 0))
  {
    objc_opt_self();
    v15 = -[NEIKEv2Packet initOutbound]([NEIKEv2InformationalPacket alloc]);
    v16 = v15;
    if (v15)
    {
      v17 = v15;
    }
    else
    {
      ne_log_obj();
      v36 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v36, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_fault_impl(&dword_19BD16000, v36, OS_LOG_TYPE_FAULT, "[[NEIKEv2InformationalPacket alloc] initOutbound:] failed", buf, 2u);
      }

    }
    v35 = v16;
    goto LABEL_36;
  }
  v16 = objc_getProperty(a1, v14, 336, 1);
  objc_opt_self();
  v19 = -[NEIKEv2Packet initOutbound]([NEIKEv2InformationalPacket alloc]);
  if (!v19)
  {
    ne_log_obj();
    v26 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_fault_impl(&dword_19BD16000, v26, OS_LOG_TYPE_FAULT, "[[NEIKEv2InformationalPacket alloc] initOutbound:] failed", buf, 2u);
    }
    v35 = 0;
    goto LABEL_35;
  }
  -[NEIKEv2IKESA initiatorSPI](v16, v18);
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  -[NEIKEv2IKESA responderSPI](v16, v21);
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    v24 = objc_getProperty(v16, v22, 64, 1);
  else
    v24 = 0;
  v25 = v24;
  v26 = +[NEIKEv2Crypto createNATDetectionHashForInitiatorSPI:responderSPI:address:]((uint64_t)NEIKEv2Crypto, v20, v23, v25);

  if (!-[NEIKEv2Packet addNotification:data:](v19, 0x4004uLL, v26))
  {
    ne_log_obj();
    v34 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v34, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_fault_impl(&dword_19BD16000, v34, OS_LOG_TYPE_FAULT, "[packet addNotification:NEIKEv2NotifyTypeNATDetectionSourceIP] failed", buf, 2u);
    }
    goto LABEL_33;
  }
  -[NEIKEv2IKESA initiatorSPI](v16, v27);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  -[NEIKEv2IKESA responderSPI](v16, v29);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    v32 = objc_getProperty(v16, v30, 72, 1);
  else
    v32 = 0;
  v33 = v32;
  v34 = +[NEIKEv2Crypto createNATDetectionHashForInitiatorSPI:responderSPI:address:]((uint64_t)NEIKEv2Crypto, v28, v31, v33);

  if (!-[NEIKEv2Packet addNotification:data:](v19, 0x4005uLL, v34))
  {
    ne_log_obj();
    v37 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v37, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_fault_impl(&dword_19BD16000, v37, OS_LOG_TYPE_FAULT, "[packet addNotification:NEIKEv2NotifyTypeNATDetectionDestinationIP] failed", buf, 2u);
    }

LABEL_33:
    v35 = 0;
    goto LABEL_34;
  }
  v35 = v19;
LABEL_34:

LABEL_35:
LABEL_36:

  if (v35)
  {
    v38 = *((id *)v4 + 4);
    v39 = objc_msgSend(v38, "count");

    if (v39)
    {
      v40 = v35;
      v105 = 0u;
      v106 = 0u;
      v103 = 0u;
      v104 = 0u;
      obj = *((id *)v4 + 4);
      v41 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v103, v113, 16);
      if (v41)
      {
        v42 = v41;
        v43 = *(_QWORD *)v104;
        while (2)
        {
          v44 = 0;
          do
          {
            if (*(_QWORD *)v104 != v43)
              objc_enumerationMutation(obj);
            v45 = *(void **)(*((_QWORD *)&v103 + 1) + 8 * v44);
            v46 = objc_alloc_init(NEIKEv2NotifyPayload);
            v47 = objc_msgSend(v45, "notifyStatus");
            if (v46)
            {
              v46->_notifyType = v47;
              objc_msgSend(v45, "notifyData");
              v48 = (void *)objc_claimAutoreleasedReturnValue();
              objc_setProperty_atomic(v46, v49, v48, 32);
            }
            else
            {
              objc_msgSend(v45, "notifyData");
              v48 = (void *)objc_claimAutoreleasedReturnValue();
            }

            if (!-[NEIKEv2Packet addNotifyPayload:](v40, v46))
            {
              ne_log_obj();
              v70 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v70, OS_LOG_TYPE_FAULT))
              {
                *(_WORD *)buf = 0;
                _os_log_fault_impl(&dword_19BD16000, v70, OS_LOG_TYPE_FAULT, "[sendKeepalive addNotifyPayload:notifyPayload] failed", buf, 2u);
              }

              objc_msgSend(v4, "sendCallbackSuccess:session:", 0, a1);
              v35 = v40;
              if (a1)
                v72 = objc_getProperty(a1, v71, 336, 1);
              else
                v72 = 0;
              v73 = v72;
              ErrorInternal = (void *)NEIKEv2CreateErrorInternal(CFSTR("[sendKeepalive addNotifyPayload:notifyPayload] failed"), v74, v75, v76, v77, v78, v79, v80, v98);
              -[NEIKEv2IKESA setState:error:]((uint64_t)v73, 3uLL, ErrorInternal);

              -[NEIKEv2Session reportState](a1, v82);
              -[NEIKEv2Session resetAll]((uint64_t)a1, v83);

              v84 = obj;
              goto LABEL_67;
            }

            ++v44;
          }
          while (v42 != v44);
          v50 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v103, v113, 16);
          v42 = v50;
          if (v50)
            continue;
          break;
        }
      }

      v35 = v40;
    }
    v51 = *((_QWORD *)v4 + 5);
    v52 = *((_DWORD *)v4 + 6);
    Error = (void *)NEIKEv2CreateError(3);
    v101[0] = MEMORY[0x1E0C809B0];
    v101[1] = 3221225472;
    v101[2] = __50__NEIKEv2Session_Exchange__initiateInformational___block_invoke;
    v101[3] = &unk_1E3CC0E88;
    v101[4] = a1;
    v54 = v4;
    v102 = v54;
    v55 = -[NEIKEv2Session sendRequest:retryIntervalInMilliseconds:maxRetries:timeoutError:resend:sendMessageID:sendCompletionHandler:replyHandler:]((uint64_t)a1, v35, v51, v52, Error, 0, 0xFFFFFFFFLL, 0, v101);

    if (v55 == -1)
    {
      objc_msgSend(v54, "sendCallbackSuccess:session:", 0, a1);
      if (a1)
        v86 = objc_getProperty(a1, v85, 336, 1);
      else
        v86 = 0;
      v87 = v86;
      ErrorFailedToSend = (void *)NEIKEv2CreateErrorFailedToSend(CFSTR("informational packet"), v88, v89, v90, v91, v92, v93, v94, v99);
      -[NEIKEv2IKESA setState:error:]((uint64_t)v87, 3uLL, ErrorFailedToSend);

      -[NEIKEv2Session reportState](a1, v96);
      -[NEIKEv2Session resetAll]((uint64_t)a1, v97);
    }
    else
    {
      ne_log_obj();
      v56 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v56, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 138412802;
        v108 = a1;
        v109 = 2112;
        v110 = v54;
        v111 = 1024;
        v112 = v55;
        _os_log_impl(&dword_19BD16000, v56, OS_LOG_TYPE_INFO, "%@ Sent %@ with message ID %d", buf, 0x1Cu);
      }

    }
    v84 = v102;
LABEL_67:

  }
  else
  {
    ne_log_obj();
    v57 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      v108 = a1;
      _os_log_error_impl(&dword_19BD16000, v57, OS_LOG_TYPE_ERROR, "%@ Failed to create informational packet", buf, 0xCu);
    }

    objc_msgSend(v4, "sendCallbackSuccess:session:", 0, a1);
    v59 = objc_getProperty(a1, v58, 336, 1);
    v67 = (void *)NEIKEv2CreateErrorInternal(CFSTR("Failed to create informational packet"), v60, v61, v62, v63, v64, v65, v66, v98);
    -[NEIKEv2IKESA setState:error:]((uint64_t)v59, 3uLL, v67);

    -[NEIKEv2Session reportState](a1, v68);
    -[NEIKEv2Session resetAll]((uint64_t)a1, v69);
  }

LABEL_72:
}

void __50__NEIKEv2Session_Exchange__initiateInformational___block_invoke(uint64_t a1, void *a2)
{
  id v3;
  const char *v4;
  const char *v5;
  NSObject *v6;
  uint64_t v7;
  const char *v8;
  uint64_t v9;
  NSObject *v10;
  uint32_t v11;
  const char *v12;
  id Property;
  id v14;
  void *Error;
  const char *v16;
  const char *v17;
  void *v18;
  _BYTE *v19;
  char v20;
  void *v21;
  const char *v22;
  void *v23;
  const char *v24;
  id v25;
  void *v26;
  id v27;
  const char *v28;
  void *v29;
  id v30;
  char v31;
  NSObject *v32;
  uint64_t v33;
  NSObject *v34;
  uint64_t v35;
  const char *v36;
  NEIKEv2MOBIKEContext *v37;
  id v38;
  id v39;
  void *v40;
  id *v41;
  uint64_t v42;
  _QWORD v43[5];
  id v44;
  uint8_t buf[4];
  uint64_t v46;
  __int16 v47;
  id v48;
  uint64_t v49;

  v49 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  if (!v3)
  {
    ne_log_obj();
    v6 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      v9 = *(_QWORD *)(a1 + 32);
      *(_DWORD *)buf = 138412290;
      v46 = v9;
      v8 = "%@ Failed to receive informational packet";
      v10 = v6;
      v11 = 12;
LABEL_32:
      _os_log_error_impl(&dword_19BD16000, v10, OS_LOG_TYPE_ERROR, v8, buf, v11);
      goto LABEL_9;
    }
    goto LABEL_9;
  }
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    ne_log_large_obj();
    v6 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      v42 = *(_QWORD *)(a1 + 32);
      *(_DWORD *)buf = 138412546;
      v46 = v42;
      v47 = 2112;
      v48 = v3;
      v8 = "%@ Received packet was not informational as expected %@";
      goto LABEL_31;
    }
LABEL_9:

    objc_msgSend(*(id *)(a1 + 40), "sendCallbackSuccess:session:", 0, *(_QWORD *)(a1 + 32));
    Property = *(id *)(a1 + 32);
    if (Property)
      Property = objc_getProperty(Property, v12, 336, 1);
    v14 = Property;
    Error = (void *)NEIKEv2CreateError(4);
    -[NEIKEv2IKESA setState:error:]((uint64_t)v14, 3uLL, Error);

    -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 32), v16);
    -[NEIKEv2Session resetAll](*(_QWORD *)(a1 + 32), v17);
    goto LABEL_12;
  }
  if (-[NEIKEv2Packet hasErrors](v3, v4))
  {
    ne_log_large_obj();
    v6 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      v7 = *(_QWORD *)(a1 + 32);
      *(_DWORD *)buf = 138412546;
      v46 = v7;
      v47 = 2112;
      v48 = v3;
      v8 = "%@ Failed to process informational packet %@";
LABEL_31:
      v10 = v6;
      v11 = 22;
      goto LABEL_32;
    }
    goto LABEL_9;
  }
  v18 = *(void **)(a1 + 32);
  if (!v18)
    goto LABEL_22;
  v19 = objc_getProperty(v18, v5, 336, 1);
  if (!v19)
    goto LABEL_22;
  v20 = v19[11];

  if ((v20 & 1) == 0)
    goto LABEL_22;
  v21 = -[NEIKEv2Packet copyNotification:](v3, (const char *)0x4005);
  v23 = v21;
  if (v21)
    v21 = objc_getProperty(v21, v22, 32, 1);
  v25 = v21;
  v26 = *(void **)(a1 + 32);
  if (v26)
  {
    v27 = objc_getProperty(v26, v24, 336, 1);
    v29 = v27;
    if (v27)
      v27 = objc_getProperty(v27, v28, 496, 1);
  }
  else
  {
    v29 = 0;
    v27 = 0;
  }
  v30 = v27;
  v31 = objc_msgSend(v25, "isEqualToData:", v30);

  if ((v31 & 1) == 0)
  {
    ne_log_obj();
    v34 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v34, OS_LOG_TYPE_INFO))
    {
      v35 = *(_QWORD *)(a1 + 32);
      *(_DWORD *)buf = 138412290;
      v46 = v35;
      _os_log_impl(&dword_19BD16000, v34, OS_LOG_TYPE_INFO, "%@ Successfully received informational packet, need SA update", buf, 0xCu);
    }

    v37 = [NEIKEv2MOBIKEContext alloc];
    v38 = *(id *)(a1 + 32);
    if (v38)
      v38 = objc_getProperty(v38, v36, 368, 1);
    v39 = v38;
    v43[0] = MEMORY[0x1E0C809B0];
    v43[1] = 3221225472;
    v43[2] = __50__NEIKEv2Session_Exchange__initiateInformational___block_invoke_22;
    v43[3] = &unk_1E3CC0ED8;
    v40 = *(void **)(a1 + 40);
    v43[4] = *(_QWORD *)(a1 + 32);
    v44 = v40;
    v41 = -[NEIKEv2MOBIKEContext initWithMOBIKEInterface:mobikeEndpoint:invalidateTransport:maxRetries:retryIntervalMilliseconds:callbackQueue:callback:]((id *)&v37->super.super.isa, 0, 0, 0, 4, 0, v39, v43);

    -[NEIKEv2Session initiateMOBIKE:](*(_BYTE **)(a1 + 32), v41);
  }
  else
  {
LABEL_22:
    ne_log_obj();
    v32 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v32, OS_LOG_TYPE_INFO))
    {
      v33 = *(_QWORD *)(a1 + 32);
      *(_DWORD *)buf = 138412290;
      v46 = v33;
      _os_log_impl(&dword_19BD16000, v32, OS_LOG_TYPE_INFO, "%@ Successfully received informational packet", buf, 0xCu);
    }

    objc_msgSend(*(id *)(a1 + 40), "sendCallbackSuccess:session:", 1, *(_QWORD *)(a1 + 32));
  }
LABEL_12:

}

void __50__NEIKEv2Session_Exchange__initiateInformational___block_invoke_22(uint64_t a1, void *a2, int a3, void *a4)
{
  id v7;
  _QWORD *v8;
  NSObject *v9;
  NSObject *v10;
  uint64_t v11;
  const char *v12;
  id Property;
  id v14;
  const char *v15;
  const char *v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v7 = a4;
  v8 = a2;
  ne_log_obj();
  v9 = objc_claimAutoreleasedReturnValue();
  v10 = v9;
  if (a3)
  {
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      v11 = *(_QWORD *)(a1 + 32);
      v18 = 138412290;
      v19 = v11;
      _os_log_impl(&dword_19BD16000, v10, OS_LOG_TYPE_INFO, "%@ Updated remote SA successfully", (uint8_t *)&v18, 0xCu);
    }

    objc_msgSend(*(id *)(a1 + 40), "sendCallbackSuccess:session:", 1, v8);
  }
  else
  {
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      v17 = *(_QWORD *)(a1 + 32);
      v18 = 138412290;
      v19 = v17;
      _os_log_error_impl(&dword_19BD16000, v10, OS_LOG_TYPE_ERROR, "%@ Failed to remote SA", (uint8_t *)&v18, 0xCu);
    }

    objc_msgSend(*(id *)(a1 + 40), "sendCallbackSuccess:session:", 0, *(_QWORD *)(a1 + 32));
    if (v8)
      Property = objc_getProperty(v8, v12, 336, 1);
    else
      Property = 0;
    v14 = Property;
    -[NEIKEv2IKESA setState:error:]((uint64_t)v14, 3uLL, v7);

    -[NEIKEv2Session reportState](v8, v15);
    -[NEIKEv2Session resetAll]((uint64_t)v8, v16);
  }

}

- (void)initiateMOBIKE:(_BYTE *)a1
{
  const char *v3;
  id *v4;
  NSObject *v5;
  const char *v6;
  _BYTE *v7;
  uint64_t v8;
  NSObject *v9;
  void *Error;
  id v11;
  SEL v12;
  id v13;
  char isKindOfClass;
  id v15;
  void *v16;
  NSObject *v17;
  void *v18;
  SEL v19;
  SEL v20;
  const char *v21;
  char v22;
  uint64_t v23;
  __int16 v24;
  SEL v25;
  id v26;
  SEL v27;
  id Property;
  SEL v29;
  id v30;
  SEL v31;
  id v32;
  SEL v33;
  id v34;
  SEL v35;
  id v36;
  SEL v37;
  SEL v38;
  SEL v39;
  const char *v40;
  const char *v41;
  SEL v42;
  uint64_t v43;
  NSObject *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  void *ErrorInternal;
  NSObject *v53;
  NSObject *v54;
  const char *v55;
  uint64_t v56[5];
  id *v57;
  uint8_t buf[4];
  const char *v59;
  __int16 v60;
  void *v61;
  uint64_t v62;

  v62 = *MEMORY[0x1E0C80C00];
  v4 = a2;
  if (a1)
  {
    v5 = objc_getProperty(a1, v3, 368, 1);
    dispatch_assert_queue_V2(v5);

    if (!a1[15])
      __assert_rtn("-[NEIKEv2Session(Exchange) initiateMOBIKE:]", "NEIKEv2Exchange.m", 2899, "self.hasOutboundRequestInFlight");
    if (!v4)
    {
      ne_log_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled((os_log_t)v8, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136315138;
        v59 = "-[NEIKEv2Session(Exchange) initiateMOBIKE:]";
        _os_log_fault_impl(&dword_19BD16000, (os_log_t)v8, OS_LOG_TYPE_FAULT, "%s called with null mobikeContext", buf, 0xCu);
      }
      goto LABEL_33;
    }
    v7 = objc_getProperty(a1, v6, 336, 1);
    if (!v7)
    {
      ne_log_obj();
      v53 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v53, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136315138;
        v59 = "-[NEIKEv2Session(Exchange) initiateMOBIKE:]";
        _os_log_fault_impl(&dword_19BD16000, v53, OS_LOG_TYPE_FAULT, "%s called with null ikeSA", buf, 0xCu);
      }

      objc_msgSend(v4, "sendCallbackSuccess:session:", 0, a1);
      v8 = 0;
      goto LABEL_33;
    }
    v8 = (uint64_t)v7;
    if ((v7[11] & 1) == 0)
    {
      ne_log_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_19BD16000, v9, OS_LOG_TYPE_ERROR, "MOBIKE not supported for this IKE SA. Ignoring request", buf, 2u);
      }

      Error = (void *)NEIKEv2CreateError(9);
      -[NEIKEv2MOBIKEContext sendCallbackSuccess:session:error:](v4, 0, a1, Error);
LABEL_32:

LABEL_33:
      goto LABEL_34;
    }
    v11 = v4[4];
    objc_setProperty_atomic((id)v8, v12, v11, 304);

    v13 = v4[5];
    objc_opt_class();
    isKindOfClass = objc_opt_isKindOfClass();

    if ((isKindOfClass & 1) == 0)
    {
LABEL_23:
      -[NEIKEv2IKESA setState:error:](v8, 4uLL, 0);
      -[NEIKEv2Session reportState](a1, v40);
      if (*((_BYTE *)v4 + 24))
      {
        -[NEIKEv2IKESA detachTransportWithShouldInvalidate:]((void *)v8, 1);
        objc_getProperty(a1, v42, 360, 1);
        v43 = objc_claimAutoreleasedReturnValue();
        if (v43)
        {
          *(_QWORD *)(v43 + 64) = 1000;
          *(_DWORD *)(v43 + 12) = -1;
          *(_QWORD *)(v43 + 16) = 0;
          *(_QWORD *)(v43 + 24) = 0;
          *(_OWORD *)(v43 + 32) = xmmword_19BED74B0;
          *(_OWORD *)(v43 + 48) = xmmword_19BED74C0;
          *(_WORD *)(v43 + 8) = 0;
        }

      }
      Error = -[NEIKEv2IKESA copyTransport]((id *)v8, v41);
      if (Error)
      {
        v56[0] = MEMORY[0x1E0C809B0];
        v56[1] = 3221225472;
        v56[2] = (uint64_t)__43__NEIKEv2Session_Exchange__initiateMOBIKE___block_invoke;
        v56[3] = (uint64_t)&unk_1E3CC2F98;
        v56[4] = (uint64_t)a1;
        v57 = v4;
        -[NEIKEv2Transport waitForTransport:]((uint64_t)Error, v56);

      }
      else
      {
        ne_log_obj();
        v44 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)buf = 0;
          _os_log_error_impl(&dword_19BD16000, v44, OS_LOG_TYPE_ERROR, "Initiate MOBIKE failed to create a new transport for IKE SA", buf, 2u);
        }

        ErrorInternal = (void *)NEIKEv2CreateErrorInternal(CFSTR("Initiate MOBIKE failed to create a new transport for IKE SA"), v45, v46, v47, v48, v49, v50, v51, v56[0]);
        -[NEIKEv2MOBIKEContext sendCallbackSuccess:session:error:](v4, 0, a1, ErrorInternal);

      }
      goto LABEL_32;
    }
    v15 = v4[5];
    v16 = v15;
    if (v15)
    {
      if (objc_msgSend(v15, "address"))
      {
        if (nelog_is_debug_logging_enabled())
        {
          ne_log_obj();
          v17 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 138412546;
            v59 = (const char *)v8;
            v60 = 2112;
            v61 = v16;
            _os_log_debug_impl(&dword_19BD16000, v17, OS_LOG_TYPE_DEBUG, "Setting remote address of %@ to %@", buf, 0x16u);
          }

        }
        objc_msgSend(MEMORY[0x1E0CCEC58], "endpointWithAddress:", objc_msgSend(v16, "address"));
        v18 = (void *)objc_claimAutoreleasedReturnValue();
        objc_setProperty_atomic((id)v8, v19, v18, 72);

        if (!*(_WORD *)(objc_msgSend(objc_getProperty((id)v8, v20, 72, 1), "address") + 2))
        {
          v22 = *(_BYTE *)(v8 + 12);
          v23 = objc_msgSend(objc_getProperty((id)v8, v21, 72, 1), "address");
          if ((v22 & 1) != 0)
            v24 = -27631;
          else
            v24 = -3071;
          *(_WORD *)(v23 + 2) = v24;
        }
        objc_setProperty_atomic((id)v8, v21, 0, 64);
        v26 = objc_getProperty((id)v8, v25, 464, 1);
        Property = objc_getProperty((id)v8, v27, 32, 1);
        -[NEIKEv2Transport cancelClient:shouldInvalidate:]((uint64_t)v26, Property, 0);

        v30 = objc_getProperty((id)v8, v29, 472, 1);
        v32 = objc_getProperty((id)v8, v31, 32, 1);
        -[NEIKEv2Transport cancelClient:shouldInvalidate:]((uint64_t)v30, v32, 0);

        v34 = objc_getProperty((id)v8, v33, 480, 1);
        v36 = objc_getProperty((id)v8, v35, 32, 1);
        -[NEIKEv2Transport cancelClient:shouldInvalidate:]((uint64_t)v34, v36, 0);

        objc_setProperty_atomic((id)v8, v37, 0, 464);
        objc_setProperty_atomic((id)v8, v38, 0, 472);
        objc_setProperty_atomic((id)v8, v39, 0, 480);
        goto LABEL_22;
      }
      ne_log_obj();
      v54 = objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v54, OS_LOG_TYPE_FAULT))
      {
LABEL_44:

LABEL_22:
        goto LABEL_23;
      }
      *(_DWORD *)buf = 136315138;
      v59 = "-[NEIKEv2IKESA resetRemoteAddress:]";
      v55 = "%s called with null remoteAddress.address";
    }
    else
    {
      ne_log_obj();
      v54 = objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v54, OS_LOG_TYPE_FAULT))
        goto LABEL_44;
      *(_DWORD *)buf = 136315138;
      v59 = "-[NEIKEv2IKESA resetRemoteAddress:]";
      v55 = "%s called with null remoteAddress";
    }
    _os_log_fault_impl(&dword_19BD16000, v54, OS_LOG_TYPE_FAULT, v55, buf, 0xCu);
    goto LABEL_44;
  }
LABEL_34:

}

void __43__NEIKEv2Session_Exchange__initiateMOBIKE___block_invoke(uint64_t a1, const char *a2)
{
  id Property;
  id *v4;
  const char *v5;
  unsigned int *v6;
  const char *v7;
  id v8;
  NSObject *v9;
  SEL v10;
  id v11;
  const char *v12;
  void *v13;
  id v14;
  int v15;
  unint64_t v16;
  __int128 *v17;
  SEL v18;
  NSObject *v19;
  SEL v20;
  id v21;
  uint64_t v22;
  SEL v23;
  uint64_t v24;
  void *v25;
  NSObject *v26;
  __int128 *v27;
  NSObject *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  void *ErrorFailedToSend;
  NSObject *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  __CFString *v45;
  void *ErrorInternal;
  NSObject *v47;
  uint64_t v48;
  uint64_t v49;
  uint8_t v50[16];
  uint8_t buf[8];
  uint64_t v52;
  void (*v53)(uint64_t, void *);
  void *v54;
  id v55;
  __int128 *v56;
  __int128 v57;
  void (*v58)(uint64_t, void *);
  void *v59;
  id v60;
  unsigned int *v61;
  id v62;
  uint64_t v63;

  v63 = *MEMORY[0x1E0C80C00];
  Property = *(id *)(a1 + 32);
  if (Property)
    Property = objc_getProperty(Property, a2, 336, 1);
  v4 = (id *)Property;
  -[NEIKEv2IKESA resyncAddress](v4, v5);

  v6 = *(unsigned int **)(a1 + 32);
  v8 = *(id *)(a1 + 40);
  if (v6)
  {
    v9 = objc_getProperty(v6, v7, 368, 1);
    dispatch_assert_queue_V2(v9);

    v11 = objc_getProperty(v6, v10, 336, 1);
    v13 = v11;
    if (v11)
    {
      v14 = objc_getProperty(v11, v12, 64, 1);

      if (v14)
      {
        if (v8)
        {
          v15 = *((_DWORD *)v8 + 7);
          v16 = *((_QWORD *)v8 + 6);
        }
        else
        {
          v15 = 0;
          v16 = 0;
        }
        *(_QWORD *)&v57 = MEMORY[0x1E0C809B0];
        *((_QWORD *)&v57 + 1) = 3221225472;
        v58 = __48__NEIKEv2Session_Exchange__initiateMOBIKEInner___block_invoke;
        v59 = &unk_1E3CC1068;
        v60 = v8;
        v61 = v6;
        v62 = v13;
        v17 = &v57;
        v19 = objc_getProperty(v6, v18, 368, 1);
        dispatch_assert_queue_V2(v19);

        v21 = objc_getProperty(v6, v20, 336, 1);
        v22 = v6[6];
        objc_getProperty(v6, v23, 376, 1);
        v24 = objc_claimAutoreleasedReturnValue();
        v25 = (void *)v24;
        if ((_DWORD)v22 == -1 || !v24)
        {
          v58((uint64_t)v17, 0);
        }
        else
        {
          ne_log_obj();
          v26 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v26, OS_LOG_TYPE_INFO))
          {
            *(_WORD *)buf = 0;
            _os_log_impl(&dword_19BD16000, v26, OS_LOG_TYPE_INFO, "Re-sending previous MOBIKE request", buf, 2u);
          }

          *(_QWORD *)buf = MEMORY[0x1E0C809B0];
          v52 = 3221225472;
          v53 = __87__NEIKEv2Session_Exchange__resendPreviousMOBIKEInnerWithRetries_retryInterval_handler___block_invoke;
          v54 = &unk_1E3CC1270;
          v27 = v17;
          v56 = v27;
          v55 = v21;
          if (-[NEIKEv2Session sendRequest:retryIntervalInMilliseconds:maxRetries:timeoutError:resend:sendMessageID:sendCompletionHandler:replyHandler:]((uint64_t)v6, v25, v16, v15, 0, 1, v22, 0, buf) == -1)
          {
            ne_log_obj();
            v28 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)v50 = 0;
              _os_log_error_impl(&dword_19BD16000, v28, OS_LOG_TYPE_ERROR, "Resend previous MOBIKE, failed to send Informational packet", v50, 2u);
            }

            ErrorFailedToSend = (void *)NEIKEv2CreateErrorFailedToSend(CFSTR("resend previous MOBIKE, failed to send Informational packet"), v29, v30, v31, v32, v33, v34, v35, v49);
            v58((uint64_t)v27, ErrorFailedToSend);

          }
        }

        ErrorInternal = v60;
        goto LABEL_23;
      }
      ne_log_obj();
      v37 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v57) = 0;
        _os_log_error_impl(&dword_19BD16000, v37, OS_LOG_TYPE_ERROR, "Initiate MOBIKE failed to fetch new local address for IKE SA", (uint8_t *)&v57, 2u);
      }

      v45 = CFSTR("Initiate MOBIKE failed to fetch new local address for IKE SA");
    }
    else
    {
      ne_log_obj();
      v47 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v47, OS_LOG_TYPE_FAULT))
      {
        LODWORD(v57) = 136315138;
        *(_QWORD *)((char *)&v57 + 4) = "-[NEIKEv2Session(Exchange) initiateMOBIKEInner:]";
        _os_log_fault_impl(&dword_19BD16000, v47, OS_LOG_TYPE_FAULT, "%s called with null ikeSA", (uint8_t *)&v57, 0xCu);
      }

      v45 = CFSTR("Initiate MOBIKE failed, no IKE SA");
    }
    ErrorInternal = (void *)NEIKEv2CreateErrorInternal(v45, v38, v39, v40, v41, v42, v43, v44, v48);
    -[NEIKEv2MOBIKEContext sendCallbackSuccess:session:error:]((id *)v8, 0, v6, ErrorInternal);
LABEL_23:

  }
}

void __48__NEIKEv2Session_Exchange__initiateMOBIKEInner___block_invoke(uint64_t a1, void *a2)
{
  _BYTE *v3;
  NSObject *v4;
  NSObject *v5;
  const char *v6;
  void *v7;
  const char *v8;
  void *v9;
  SEL v10;
  id v11;
  NSObject *v12;
  const char *v13;
  void *v14;
  const char *v15;
  void *v16;
  SEL v17;
  id v18;
  NSObject *v19;
  NSObject *v20;
  const char *v21;
  NSObject *v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  int v26;
  void *Error;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  id *v36;
  void *v37;
  void *ErrorFailedToSend;
  const char *v39;
  id Property;
  id v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  void *v49;
  const char *v50;
  const char *v51;
  NSObject *v52;
  id *v53;
  void *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  void *ErrorInternal;
  const char *v63;
  id v64;
  id v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  void *v73;
  const char *v74;
  const char *v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  _QWORD v80[5];
  NSObject *v81;
  id v82;
  id v83;
  uint8_t buf[4];
  const char *v85;
  uint64_t v86;

  v86 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    -[NEIKEv2MOBIKEContext sendCallbackSuccess:session:error:](*(id **)(a1 + 32), 0, *(void **)(a1 + 40), a2);
    return;
  }
  v3 = *(id *)(a1 + 48);
  objc_opt_self();
  if (!v3)
  {
    ne_log_obj();
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136315138;
      v85 = "+[NEIKEv2InformationalPacket(Exchange) createUpdateAddressInitiator:]";
      _os_log_fault_impl(&dword_19BD16000, v5, OS_LOG_TYPE_FAULT, "%s called with null ikeSA", buf, 0xCu);
    }
    v20 = 0;
    goto LABEL_21;
  }
  v4 = -[NEIKEv2Packet initOutbound]([NEIKEv2InformationalPacket alloc]);
  v5 = v4;
  if (!v4)
  {
    ne_log_obj();
    v12 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
      goto LABEL_12;
    *(_WORD *)buf = 0;
    v21 = "[[NEIKEv2InformationalPacket alloc] initOutbound:] failed";
LABEL_36:
    _os_log_fault_impl(&dword_19BD16000, v12, OS_LOG_TYPE_FAULT, v21, buf, 2u);
    goto LABEL_12;
  }
  if (-[NEIKEv2Packet addNotification:data:](v4, 0x4010uLL, 0))
  {
    -[NEIKEv2IKESA initiatorSPI](v3, v6);
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEIKEv2IKESA responderSPI](v3, v8);
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    v11 = objc_getProperty(v3, v10, 64, 1);
    v12 = +[NEIKEv2Crypto createNATDetectionHashForInitiatorSPI:responderSPI:address:]((uint64_t)NEIKEv2Crypto, v7, v9, v11);

    if (-[NEIKEv2Packet addNotification:data:](v5, 0x4004uLL, v12))
    {
      -[NEIKEv2IKESA initiatorSPI](v3, v13);
      v14 = (void *)objc_claimAutoreleasedReturnValue();
      -[NEIKEv2IKESA responderSPI](v3, v15);
      v16 = (void *)objc_claimAutoreleasedReturnValue();
      v18 = objc_getProperty(v3, v17, 72, 1);
      v19 = +[NEIKEv2Crypto createNATDetectionHashForInitiatorSPI:responderSPI:address:]((uint64_t)NEIKEv2Crypto, v14, v16, v18);

      if (-[NEIKEv2Packet addNotification:data:](v5, 0x4005uLL, v19))
      {
        v20 = v5;
LABEL_19:

        goto LABEL_20;
      }
      ne_log_obj();
      v22 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_fault_impl(&dword_19BD16000, v22, OS_LOG_TYPE_FAULT, "[packet addNotification:NEIKEv2NotifyTypeNATDetectionDestinationIP] failed", buf, 2u);
      }

    }
    else
    {
      ne_log_obj();
      v19 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_fault_impl(&dword_19BD16000, v19, OS_LOG_TYPE_FAULT, "[packet addNotification:NEIKEv2NotifyTypeNATDetectionSourceIP] failed", buf, 2u);
      }
    }
    v20 = 0;
    goto LABEL_19;
  }
  ne_log_obj();
  v12 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)buf = 0;
    v21 = "[packet addNotification:NEIKEv2NotifyTypeUpdateSAAddresses] failed";
    goto LABEL_36;
  }
LABEL_12:
  v20 = 0;
LABEL_20:

LABEL_21:
  if (v20)
  {
    v23 = *(_QWORD *)(a1 + 32);
    v24 = *(_QWORD *)(a1 + 40);
    if (v23)
    {
      v25 = *(_QWORD *)(v23 + 48);
      v26 = *(_DWORD *)(v23 + 28);
    }
    else
    {
      v25 = 0;
      v26 = 0;
    }
    Error = (void *)NEIKEv2CreateError(3);
    v80[0] = MEMORY[0x1E0C809B0];
    v80[1] = 3221225472;
    v80[2] = __48__NEIKEv2Session_Exchange__initiateMOBIKEInner___block_invoke_459;
    v80[3] = &unk_1E3CC1220;
    v80[4] = *(_QWORD *)(a1 + 40);
    v81 = v20;
    v82 = *(id *)(a1 + 32);
    v83 = *(id *)(a1 + 48);
    v28 = -[NEIKEv2Session sendRequest:retryIntervalInMilliseconds:maxRetries:timeoutError:resend:sendMessageID:sendCompletionHandler:replyHandler:](v24, v81, v25, v26, Error, 0, 0xFFFFFFFFLL, 0, v80);

    if (v28 == -1)
    {
      v36 = *(id **)(a1 + 32);
      v37 = *(void **)(a1 + 40);
      ErrorFailedToSend = (void *)NEIKEv2CreateErrorFailedToSend(CFSTR("initiator update addresses"), v29, v30, v31, v32, v33, v34, v35, v77);
      -[NEIKEv2MOBIKEContext sendCallbackSuccess:session:error:](v36, 0, v37, ErrorFailedToSend);

      Property = *(id *)(a1 + 40);
      if (Property)
        Property = objc_getProperty(Property, v39, 336, 1);
      v41 = Property;
      v49 = (void *)NEIKEv2CreateErrorFailedToSend(CFSTR("initiator update addresses"), v42, v43, v44, v45, v46, v47, v48, v78);
      -[NEIKEv2IKESA setState:error:]((uint64_t)v41, 3uLL, v49);

      -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 40), v50);
      -[NEIKEv2Session resetAll](*(_QWORD *)(a1 + 40), v51);
    }

  }
  else
  {
    ne_log_obj();
    v52 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_19BD16000, v52, OS_LOG_TYPE_ERROR, "Initiate MOBIKE failed to create Update Addresses packet", buf, 2u);
    }

    v53 = *(id **)(a1 + 32);
    v54 = *(void **)(a1 + 40);
    ErrorInternal = (void *)NEIKEv2CreateErrorInternal(CFSTR("Initiate MOBIKE failed to create Update Addresses packet"), v55, v56, v57, v58, v59, v60, v61, v76);
    -[NEIKEv2MOBIKEContext sendCallbackSuccess:session:error:](v53, 0, v54, ErrorInternal);

    v64 = *(id *)(a1 + 40);
    if (v64)
      v64 = objc_getProperty(v64, v63, 336, 1);
    v65 = v64;
    v73 = (void *)NEIKEv2CreateErrorInternal(CFSTR("Initiate MOBIKE failed to create Update Addresses packet"), v66, v67, v68, v69, v70, v71, v72, v79);
    -[NEIKEv2IKESA setState:error:]((uint64_t)v65, 3uLL, v73);

    -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 40), v74);
    -[NEIKEv2Session resetAll](*(_QWORD *)(a1 + 40), v75);
  }

}

void __87__NEIKEv2Session_Exchange__resendPreviousMOBIKEInnerWithRetries_retryInterval_handler___block_invoke(uint64_t a1, void *a2)
{
  id v3;
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  __CFString *v13;
  NSObject *v14;
  void *ErrorPeerInvalidSyntax;
  uint64_t v16;
  uint8_t buf[16];

  v3 = a2;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    ne_log_obj();
    v4 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_19BD16000, v4, OS_LOG_TYPE_ERROR, "Resend previous MOBIKE, failed to receive Informational packet again", buf, 2u);
    }

    v12 = *(_QWORD *)(a1 + 40);
    v13 = CFSTR("Resend previous MOBIKE, failed to receive Informational packet again");
    goto LABEL_10;
  }
  if ((-[NEIKEv2InformationalPacket validateUpdateAddresses:](v3, *(void **)(a1 + 32)) & 1) == 0)
  {
    ne_log_obj();
    v14 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v16) = 0;
      _os_log_error_impl(&dword_19BD16000, v14, OS_LOG_TYPE_ERROR, "Resend previous MOBIKE, failed to process Informational packet", (uint8_t *)&v16, 2u);
    }

    v12 = *(_QWORD *)(a1 + 40);
    v13 = CFSTR("Resend previous MOBIKE, failed to process Informational packet");
LABEL_10:
    ErrorPeerInvalidSyntax = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(v13, v5, v6, v7, v8, v9, v10, v11, v16);
    (*(void (**)(uint64_t, void *))(v12 + 16))(v12, ErrorPeerInvalidSyntax);

    goto LABEL_11;
  }
  (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
LABEL_11:

}

void __48__NEIKEv2Session_Exchange__initiateMOBIKEInner___block_invoke_459(uint64_t a1, void *a2)
{
  id v3;
  const char *v4;
  const char *v5;
  uint64_t v6;
  uint64_t v7;
  const char *v8;
  NSObject *v9;
  NSObject *v10;
  _DWORD *v11;
  int v12;
  id *v13;
  void *v14;
  void *Error;
  NSObject *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  void *ErrorPeerInvalidSyntax;
  const char *v25;
  id v26;
  id v27;
  const char *v28;
  const char *v29;
  NSObject *v30;
  id *v31;
  void *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  void *ErrorInternal;
  const char *v41;
  id Property;
  id v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  void *v51;
  const char *v52;
  const char *v53;
  uint64_t v54;
  uint8_t v55[16];
  uint8_t v56[16];
  uint8_t buf[16];

  v3 = a2;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    -[NEIKEv2Session setSentMOBIKERequest:messageID:](*(_QWORD *)(a1 + 32), 0, -1);
    if ((-[NEIKEv2InformationalPacket validateUpdateAddresses:](v3, *(void **)(a1 + 56)) & 1) != 0)
    {
      if ((-[NEIKEv2Session migrateAllChildSAs](*(_QWORD *)(a1 + 32), v4) & 1) != 0)
      {
        -[NEIKEv2Session reportConfiguration](*(void **)(a1 + 32), v5);
        v6 = *(_QWORD *)(a1 + 56);
        if (v6)
        {
          *(_WORD *)(v6 + 26) = 0;
          *(_QWORD *)(v6 + 120) = 0;
          *(_BYTE *)(v6 + 21) = 0;
          v7 = *(_QWORD *)(a1 + 56);
        }
        else
        {
          v7 = 0;
        }
        -[NEIKEv2IKESA setState:error:](v7, 2uLL, 0);
        -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 32), v8);
        ne_log_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
        {
          LOWORD(v54) = 0;
          _os_log_impl(&dword_19BD16000, v9, OS_LOG_TYPE_INFO, "Initiate MOBIKE switched IKE SA addresses", (uint8_t *)&v54, 2u);
        }

        -[NEIKEv2MOBIKEContext sendCallbackSuccess:session:error:](*(id **)(a1 + 48), 1, *(void **)(a1 + 32), 0);
      }
      else
      {
        ne_log_obj();
        v30 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)v55 = 0;
          _os_log_error_impl(&dword_19BD16000, v30, OS_LOG_TYPE_ERROR, "Initiate MOBIKE failed to migrate child SAs", v55, 2u);
        }

        v31 = *(id **)(a1 + 48);
        v32 = *(void **)(a1 + 32);
        ErrorInternal = (void *)NEIKEv2CreateErrorInternal(CFSTR("Initiate MOBIKE failed to migrate child SAs"), v33, v34, v35, v36, v37, v38, v39, v54);
        -[NEIKEv2MOBIKEContext sendCallbackSuccess:session:error:](v31, 0, v32, ErrorInternal);

        Property = *(id *)(a1 + 32);
        if (Property)
          Property = objc_getProperty(Property, v41, 336, 1);
        v43 = Property;
        v51 = (void *)NEIKEv2CreateErrorInternal(CFSTR("Initiate MOBIKE failed to migrate child SAs"), v44, v45, v46, v47, v48, v49, v50, v54);
        -[NEIKEv2IKESA setState:error:]((uint64_t)v43, 3uLL, v51);

        -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 32), v52);
        -[NEIKEv2Session resetAll](*(_QWORD *)(a1 + 32), v53);
      }
    }
    else
    {
      ne_log_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)v56 = 0;
        _os_log_error_impl(&dword_19BD16000, v16, OS_LOG_TYPE_ERROR, "Initiate MOBIKE failed to process Informational packet", v56, 2u);
      }

      ErrorPeerInvalidSyntax = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("Initiate MOBIKE failed to process Informational packet"), v17, v18, v19, v20, v21, v22, v23, v54);
      -[NEIKEv2MOBIKEContext sendCallbackSuccess:session:error:](*(id **)(a1 + 48), 0, *(void **)(a1 + 32), ErrorPeerInvalidSyntax);
      v26 = *(id *)(a1 + 32);
      if (v26)
        v26 = objc_getProperty(v26, v25, 336, 1);
      v27 = v26;
      -[NEIKEv2IKESA setState:error:]((uint64_t)v27, 3uLL, ErrorPeerInvalidSyntax);

      -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 32), v28);
      -[NEIKEv2Session resetAll](*(_QWORD *)(a1 + 32), v29);

    }
  }
  else
  {
    ne_log_obj();
    v10 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_19BD16000, v10, OS_LOG_TYPE_ERROR, "Initiate MOBIKE failed to receive Informational packet", buf, 2u);
    }

    v11 = *(_DWORD **)(a1 + 40);
    if (v11)
      v12 = v11[6];
    else
      v12 = 0;
    -[NEIKEv2Session setSentMOBIKERequest:messageID:](*(_QWORD *)(a1 + 32), v11, v12);
    v13 = *(id **)(a1 + 48);
    v14 = *(void **)(a1 + 32);
    Error = (void *)NEIKEv2CreateError(3);
    -[NEIKEv2MOBIKEContext sendCallbackSuccess:session:error:](v13, 0, v14, Error);

  }
}

- (void)receiveInformational:(_BYTE *)a1
{
  const char *v3;
  id v4;
  NSObject *v5;
  SEL v6;
  id v7;
  const char *v8;
  const char *v9;
  NSObject *v10;
  const char *v11;
  double *v12;
  const char *v13;
  double *v14;
  uint64_t v15;
  unint64_t v16;
  const char *v17;
  double Current;
  double v19;
  unsigned __int16 v20;
  SEL v21;
  void *v22;
  NSObject *v23;
  SEL v24;
  id v25;
  const char *v26;
  id v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  void *ErrorFailedToSend;
  const char *v36;
  const char *v37;
  NSObject *v38;
  __int128 v39;
  uint64_t (*v40)(uint64_t);
  void *v41;
  _BYTE *v42;
  double *v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  v4 = a2;
  if (a1)
  {
    v5 = objc_getProperty(a1, v3, 368, 1);
    dispatch_assert_queue_V2(v5);

    v7 = objc_getProperty(a1, v6, 336, 1);
    if (!v7)
    {
      ne_log_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT))
      {
        LODWORD(v39) = 136315138;
        *(_QWORD *)((char *)&v39 + 4) = "-[NEIKEv2Session(Exchange) receiveInformational:]";
        _os_log_fault_impl(&dword_19BD16000, v10, OS_LOG_TYPE_FAULT, "%s called with null self.ikeSA", (uint8_t *)&v39, 0xCu);
      }
      goto LABEL_11;
    }
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      if (v4 && !-[NEIKEv2Packet hasErrors](v4, v8))
      {
        if ((a1[11] & 1) == 0)
        {
          v12 = (double *)objc_getProperty(a1, v9, 336, 1);
          v14 = v12;
          if (v12)
          {
            v15 = objc_msgSend(objc_getProperty(v12, v13, 88, 1), "deadPeerDetectionReceiveIntervalTriggerReporting");
            if (v15)
            {
              v16 = v15;
              Current = CFAbsoluteTimeGetCurrent();
              v19 = v14[15];
              if (v19 == 0.0
                || Current - v19 > (double)v16
                || (v20 = *((_WORD *)v14 + 13) + 1,
                    *((_WORD *)v14 + 13) = v20,
                    objc_msgSend(objc_getProperty(v14, v17, 88, 1), "deadPeerDetectionReceiveMaxShortDPDBeforeReporting") > v20)|| (*((_BYTE *)v14 + 21) & 1) != 0)
              {
                v14[15] = Current;
              }
              else
              {
                *((_BYTE *)v14 + 21) = 1;
                v14[15] = Current;

                if (objc_getProperty(a1, v21, 336, 1))
                {
                  objc_msgSend(a1, "shortDPDEventBlock");
                  v14 = (double *)objc_claimAutoreleasedReturnValue();
                  objc_msgSend(a1, "clientQueue");
                  v22 = (void *)objc_claimAutoreleasedReturnValue();

                  if (v22 && v14)
                  {
                    objc_msgSend(a1, "clientQueue");
                    v23 = objc_claimAutoreleasedReturnValue();
                    *(_QWORD *)&v39 = MEMORY[0x1E0C809B0];
                    *((_QWORD *)&v39 + 1) = 3221225472;
                    v40 = __32__NEIKEv2Session_reportShortDPD__block_invoke;
                    v41 = &unk_1E3CC46A8;
                    v42 = a1;
                    v14 = v14;
                    v43 = v14;
                    dispatch_async(v23, &v39);

                  }
                }
                else
                {
                  ne_log_obj();
                  v14 = (double *)objc_claimAutoreleasedReturnValue();
                  if (os_log_type_enabled((os_log_t)v14, OS_LOG_TYPE_FAULT))
                  {
                    LODWORD(v39) = 136315138;
                    *(_QWORD *)((char *)&v39 + 4) = "-[NEIKEv2Session reportShortDPD]";
                    _os_log_fault_impl(&dword_19BD16000, (os_log_t)v14, OS_LOG_TYPE_FAULT, "%s called with null self.ikeSA", (uint8_t *)&v39, 0xCu);
                  }
                }
              }
            }
          }

          -[NEIKEv2Session reportPrivateNotifiesInPacket:]((id *)a1, v4);
          v25 = objc_getProperty(a1, v24, 336, 1);
          +[NEIKEv2InformationalPacket createInformationalResponse:ikeSA:]((uint64_t)NEIKEv2InformationalPacket, v4, v25);
          v10 = objc_claimAutoreleasedReturnValue();

          if (v10)
          {
            if ((-[NEIKEv2Session sendReply:replyHandler:]((uint64_t)a1, v10, 0) & 1) == 0)
            {
              v27 = objc_getProperty(a1, v26, 336, 1);
              ErrorFailedToSend = (void *)NEIKEv2CreateErrorFailedToSend(CFSTR("informational reply"), v28, v29, v30, v31, v32, v33, v34, v39);
              -[NEIKEv2IKESA setState:error:]((uint64_t)v27, 3uLL, ErrorFailedToSend);

              -[NEIKEv2Session reportState](a1, v36);
              -[NEIKEv2Session resetAll]((uint64_t)a1, v37);
            }
          }
          else
          {
            ne_log_obj();
            v38 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
            {
              LODWORD(v39) = 138412290;
              *(_QWORD *)((char *)&v39 + 4) = a1;
              _os_log_error_impl(&dword_19BD16000, v38, OS_LOG_TYPE_ERROR, "%@ Failed to create Keepalive packet", (uint8_t *)&v39, 0xCu);
            }

            v10 = 0;
          }
          goto LABEL_11;
        }
        ne_log_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        {
          LODWORD(v39) = 138412290;
          *(_QWORD *)((char *)&v39 + 4) = a1;
          v11 = "%@ Session has been aborted, cannot process informational";
          goto LABEL_34;
        }
      }
      else
      {
        ne_log_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        {
          LODWORD(v39) = 138412290;
          *(_QWORD *)((char *)&v39 + 4) = a1;
          v11 = "%@ Failed to process informational packet";
LABEL_34:
          _os_log_error_impl(&dword_19BD16000, v10, OS_LOG_TYPE_ERROR, v11, (uint8_t *)&v39, 0xCu);
        }
      }
    }
    else
    {
      ne_log_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        LODWORD(v39) = 138412290;
        *(_QWORD *)((char *)&v39 + 4) = a1;
        v11 = "%@ Failed to receive informational packet";
        goto LABEL_34;
      }
    }
LABEL_11:

  }
}

- (void)retryCookieForIKESA:(uint64_t)a3 validated:(void *)a4 handler:
{
  id v7;
  const char *v8;
  void (**v9)(id, _QWORD);
  NSObject *v10;
  const char *v11;
  id Property;
  id v13;
  const char *v14;
  NSObject *v15;
  void *v16;
  const char *v17;
  id v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  void *ErrorFailedToSend;
  const char *v27;
  const char *v28;
  NSObject *v29;
  SEL v30;
  id v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  void *ErrorInternal;
  const char *v40;
  const char *v41;
  uint64_t v42;
  _QWORD v43[5];
  id v44;
  void (**v45)(id, _QWORD);
  uint8_t buf[4];
  _QWORD *v47;
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  v7 = a2;
  v9 = a4;
  if (a1)
  {
    v10 = objc_getProperty(a1, v8, 368, 1);
    dispatch_assert_queue_V2(v10);

    if ((a3 & 1) != 0
      || (!v7 ? (Property = 0) : (Property = objc_getProperty(v7, v11, 280, 1)),
          v13 = Property,
          v13,
          !v13))
    {
      v9[2](v9, a3);
    }
    else
    {
      -[NEIKEv2Session resetMessages](a1, v14);
      ne_log_obj();
      v15 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 138412290;
        v47 = a1;
        _os_log_debug_impl(&dword_19BD16000, v15, OS_LOG_TYPE_DEBUG, "%@ Received cookie notification, retrying IKE SA Init with cookie (connect retry cookie)", buf, 0xCu);
      }

      +[NEIKEv2IKESAInitPacket createIKESAInitForInitiatorIKESA:]((uint64_t)NEIKEv2IKESAInitPacket, v7);
      v16 = (void *)objc_claimAutoreleasedReturnValue();
      if (v16)
      {
        v43[0] = MEMORY[0x1E0C809B0];
        v43[1] = 3221225472;
        v43[2] = __66__NEIKEv2Session_Exchange__retryCookieForIKESA_validated_handler___block_invoke;
        v43[3] = &unk_1E3CC0F00;
        v43[4] = a1;
        v44 = v7;
        v45 = v9;
        if (-[NEIKEv2Session sendRequest:retry:replyHandler:]((uint64_t)a1, v16, v43) == -1)
        {
          v18 = objc_getProperty(a1, v17, 336, 1);
          ErrorFailedToSend = (void *)NEIKEv2CreateErrorFailedToSend(CFSTR("retry SA INIT cookie"), v19, v20, v21, v22, v23, v24, v25, v42);
          -[NEIKEv2IKESA setState:error:]((uint64_t)v18, 3uLL, ErrorFailedToSend);

          -[NEIKEv2Session reportState](a1, v27);
          -[NEIKEv2Session resetAll]((uint64_t)a1, v28);
        }

      }
      else
      {
        ne_log_obj();
        v29 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 138412290;
          v47 = a1;
          _os_log_error_impl(&dword_19BD16000, v29, OS_LOG_TYPE_ERROR, "%@ Failed to create IKE SA Init retry packet (connect retry cookie)", buf, 0xCu);
        }

        v31 = objc_getProperty(a1, v30, 336, 1);
        ErrorInternal = (void *)NEIKEv2CreateErrorInternal(CFSTR("Failed to create IKE SA Init retry packet (connect retry cookie)"), v32, v33, v34, v35, v36, v37, v38, v42);
        -[NEIKEv2IKESA setState:error:]((uint64_t)v31, 3uLL, ErrorInternal);

        -[NEIKEv2Session reportState](a1, v40);
        -[NEIKEv2Session resetAll]((uint64_t)a1, v41);
      }

    }
  }

}

void __66__NEIKEv2Session_Exchange__retryCookieForIKESA_validated_handler___block_invoke(uint64_t a1, void *a2)
{
  id v3;
  void (*v4)(void);
  NSObject *v5;
  const char *v6;
  id Property;
  id v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *ErrorPeerInvalidSyntax;
  const char *v17;
  const char *v18;
  NSObject *v19;
  uint64_t v20;
  uint64_t v21;
  _BYTE v22[24];
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    if ((-[NEIKEv2IKESAInitPacket validateSAInitAsInitiator:]((uint64_t)v3, *(void **)(a1 + 40)) & 1) != 0)
    {
      v4 = *(void (**)(void))(*(_QWORD *)(a1 + 48) + 16);
    }
    else
    {
      ne_log_obj();
      v19 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        v21 = *(_QWORD *)(a1 + 32);
        *(_DWORD *)v22 = 138412290;
        *(_QWORD *)&v22[4] = v21;
        _os_log_error_impl(&dword_19BD16000, v19, OS_LOG_TYPE_ERROR, "%@ Failed to parse IKE SA Init retry reply (connect retry cookie)", v22, 0xCu);
      }

      v4 = *(void (**)(void))(*(_QWORD *)(a1 + 48) + 16);
    }
    v4();
  }
  else
  {
    ne_log_obj();
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v20 = *(_QWORD *)(a1 + 32);
      *(_DWORD *)v22 = 138412290;
      *(_QWORD *)&v22[4] = v20;
      _os_log_error_impl(&dword_19BD16000, v5, OS_LOG_TYPE_ERROR, "%@ Failed to receive IKE SA Init retry reply (connect retry cookie)", v22, 0xCu);
    }

    Property = *(id *)(a1 + 32);
    if (Property)
      Property = objc_getProperty(Property, v6, 336, 1);
    v8 = Property;
    ErrorPeerInvalidSyntax = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("Failed to receive IKE SA Init retry reply (connect retry cookie)"), v9, v10, v11, v12, v13, v14, v15, *(uint64_t *)v22);
    -[NEIKEv2IKESA setState:error:]((uint64_t)v8, 3uLL, ErrorPeerInvalidSyntax);

    -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 32), v17);
    -[NEIKEv2Session resetAll](*(_QWORD *)(a1 + 32), v18);
  }

}

void __62__NEIKEv2Session_Exchange__retryKEForIKESA_validated_handler___block_invoke(uint64_t a1, void *a2)
{
  id v3;
  void (*v4)(void);
  NSObject *v5;
  const char *v6;
  id Property;
  id v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *ErrorPeerInvalidSyntax;
  const char *v17;
  const char *v18;
  NSObject *v19;
  uint64_t v20;
  uint64_t v21;
  _BYTE v22[24];
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    if ((-[NEIKEv2IKESAInitPacket validateSAInitAsInitiator:]((uint64_t)v3, *(void **)(a1 + 40)) & 1) != 0)
    {
      v4 = *(void (**)(void))(*(_QWORD *)(a1 + 48) + 16);
    }
    else
    {
      ne_log_obj();
      v19 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        v21 = *(_QWORD *)(a1 + 32);
        *(_DWORD *)v22 = 138412290;
        *(_QWORD *)&v22[4] = v21;
        _os_log_error_impl(&dword_19BD16000, v19, OS_LOG_TYPE_ERROR, "%@ Failed to parse IKE SA Init retry reply (connect retry KE)", v22, 0xCu);
      }

      v4 = *(void (**)(void))(*(_QWORD *)(a1 + 48) + 16);
    }
    v4();
  }
  else
  {
    ne_log_obj();
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v20 = *(_QWORD *)(a1 + 32);
      *(_DWORD *)v22 = 138412290;
      *(_QWORD *)&v22[4] = v20;
      _os_log_error_impl(&dword_19BD16000, v5, OS_LOG_TYPE_ERROR, "%@ Failed to receive IKE SA Init retry reply (connect retry KE)", v22, 0xCu);
    }

    Property = *(id *)(a1 + 32);
    if (Property)
      Property = objc_getProperty(Property, v6, 336, 1);
    v8 = Property;
    ErrorPeerInvalidSyntax = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("Failed to receive IKE SA Init retry reply (connect retry KE)"), v9, v10, v11, v12, v13, v14, v15, *(uint64_t *)v22);
    -[NEIKEv2IKESA setState:error:]((uint64_t)v8, 3uLL, ErrorPeerInvalidSyntax);

    -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 32), v17);
    -[NEIKEv2Session resetAll](*(_QWORD *)(a1 + 32), v18);
  }

}

- (void)handleIKEIntermediateForInitiatorIKESA:(unint64_t)a3 iteration:(void *)a4 handler:
{
  id v7;
  const char *v8;
  void (**v9)(_QWORD);
  NSObject *v10;
  const char *v11;
  id Property;
  const char *v13;
  void *v14;
  id v15;
  unint64_t v16;
  const char *v17;
  id v18;
  const char *v19;
  void *v20;
  id v21;
  void *v22;
  const char *v23;
  id v24;
  id v25;
  void *v26;
  void *v27;
  NSObject *v28;
  NEIKEv2KeyExchangePayload *v29;
  const char *v30;
  NEIKEv2KeyExchangePayload *v31;
  SEL v32;
  id v33;
  const char *v34;
  void *v35;
  const char *v36;
  id v37;
  void *v38;
  void *v39;
  id v40;
  const char *v41;
  void *v42;
  id v43;
  const char *v44;
  void *v45;
  SEL v46;
  id v47;
  id v48;
  char v49;
  _DWORD *v50;
  const char *v51;
  int v52;
  NSObject *v53;
  SEL v54;
  id v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  void *ErrorFailedToSend;
  NSObject *v64;
  SEL v65;
  id v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  void *ErrorInternal;
  const char *v75;
  const char *v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  const char *v84;
  const char *v85;
  NSObject *v86;
  SEL v87;
  id v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  void *v96;
  NSObject *v97;
  SEL v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  void *v106;
  const char *v107;
  const char *v108;
  uint64_t v109;
  void *v110;
  _QWORD v111[5];
  id v112;
  id v113;
  void (**v114)(_QWORD);
  unint64_t v115;
  uint8_t buf[4];
  _QWORD *v117;
  __int16 v118;
  void *v119;
  uint64_t v120;

  v120 = *MEMORY[0x1E0C80C00];
  v7 = a2;
  v9 = a4;
  if (a1)
  {
    v10 = objc_getProperty(a1, v8, 368, 1);
    dispatch_assert_queue_V2(v10);

    if (v7)
    {
      Property = objc_getProperty(v7, v11, 96, 1);
      v14 = Property;
      if (Property)
        Property = objc_getProperty(Property, v13, 120, 1);
    }
    else
    {
      v14 = 0;
      Property = 0;
    }
    v15 = Property;
    v16 = objc_msgSend(v15, "count");

    if (v16 > a3)
    {
      if (v7)
      {
        v18 = objc_getProperty(v7, v17, 96, 1);
        v20 = v18;
        if (v18)
          v18 = objc_getProperty(v18, v19, 120, 1);
      }
      else
      {
        v20 = 0;
        v18 = 0;
      }
      v21 = v18;
      objc_msgSend(v21, "objectAtIndexedSubscript:", a3);
      v22 = (void *)objc_claimAutoreleasedReturnValue();

      if (v7)
        v24 = objc_getProperty(v7, v23, 96, 1);
      else
        v24 = 0;
      v25 = v24;
      -[NEIKEv2IKESAProposal chosenAdditionalKEMProtocols](v25);
      v26 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v26, "objectForKeyedSubscript:", v22);
      v27 = (void *)objc_claimAutoreleasedReturnValue();

      if (v27)
      {
        if ((-[NEIKEv2IKESA generateLocalValuesForKEMProtocol:](v7, v27) & 1) != 0)
        {
          v28 = -[NEIKEv2Packet initOutbound]([NEIKEv2IntermediatePacket alloc]);
          v29 = objc_alloc_init(NEIKEv2KeyExchangePayload);
          v31 = v29;
          if (v28)
          {
            objc_setProperty_atomic(v28, v30, v29, 88);

            v33 = objc_getProperty(v28, v32, 88, 1);
            v35 = v33;
            if (v33)
              objc_setProperty_atomic(v33, v34, v27, 24);
          }
          else
          {

            v35 = 0;
          }

          v110 = v22;
          if (v7)
          {
            v37 = objc_getProperty(v7, v36, 160, 1);
            v38 = v37;
            if (v37)
            {
              v39 = (void *)*((_QWORD *)v37 + 2);
              goto LABEL_19;
            }
          }
          else
          {
            v38 = 0;
          }
          v39 = 0;
LABEL_19:
          v40 = v39;
          v42 = v40;
          if (v28)
          {
            v43 = objc_getProperty(v28, v41, 88, 1);
            v45 = v43;
            if (v43)
              objc_setProperty_atomic(v43, v44, v42, 32);

            v47 = objc_getProperty(v28, v46, 88, 1);
          }
          else
          {

            v47 = 0;
          }
          v48 = v47;
          v49 = -[NEIKEv2Payload isValid]((uint64_t)v48);

          if ((v49 & 1) == 0)
          {
            ne_log_obj();
            v64 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 138412290;
              v117 = a1;
              _os_log_error_impl(&dword_19BD16000, v64, OS_LOG_TYPE_ERROR, "%@ Failed to create IKE_INTERMEDIATE packet (connect intermediate)", buf, 0xCu);
            }

            v66 = objc_getProperty(a1, v65, 336, 1);
            ErrorInternal = (void *)NEIKEv2CreateErrorInternal(CFSTR("Failed to create IKE_INTERMEDIATE packet (connect intermediate)"), v67, v68, v69, v70, v71, v72, v73, v109);
            -[NEIKEv2IKESA setState:error:]((uint64_t)v66, 3uLL, ErrorInternal);

            -[NEIKEv2Session reportState](a1, v75);
            -[NEIKEv2Session resetAll]((uint64_t)a1, v76);
            v22 = v110;
            goto LABEL_40;
          }
          v111[0] = MEMORY[0x1E0C809B0];
          v111[1] = 3221225472;
          v111[2] = __85__NEIKEv2Session_Exchange__handleIKEIntermediateForInitiatorIKESA_iteration_handler___block_invoke;
          v111[3] = &unk_1E3CC0F28;
          v111[4] = a1;
          v112 = v27;
          v50 = v7;
          v113 = v50;
          v115 = a3;
          v114 = v9;
          if (-[NEIKEv2Session sendRequest:retry:replyHandler:]((uint64_t)a1, v28, v111) == -1)
          {
            v55 = objc_getProperty(a1, v51, 336, 1);
            ErrorFailedToSend = (void *)NEIKEv2CreateErrorFailedToSend(CFSTR("initiator IKE_INTERMEDIATE #%zu"), v77, v78, v79, v80, v81, v82, v83, a3 + 1);
            -[NEIKEv2IKESA setState:error:]((uint64_t)v55, 3uLL, ErrorFailedToSend);
            v22 = v110;
          }
          else
          {
            if (v28)
              v52 = LODWORD(v28[3].isa) + 1;
            else
              v52 = 1;
            v22 = v110;
            if (v7)
              v50[7] = v52;
            if ((-[NEIKEv2IKESA updateIntAuthWithPacket:]((uint64_t)v50, v28) & 1) != 0)
              goto LABEL_39;
            ne_log_obj();
            v53 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 138412290;
              v117 = a1;
              _os_log_error_impl(&dword_19BD16000, v53, OS_LOG_TYPE_ERROR, "%@ Failed to process IKE_INTERMEDIATE request packet for AUTH (connect intermediate)", buf, 0xCu);
            }

            v55 = objc_getProperty(a1, v54, 336, 1);
            ErrorFailedToSend = (void *)NEIKEv2CreateErrorCrypto(CFSTR("Failed to process IKE_INTERMEDIATE request packet for AUTH (connect intermediate)"), v56, v57, v58, v59, v60, v61, v62, v109);
            -[NEIKEv2IKESA setState:error:]((uint64_t)v55, 3uLL, ErrorFailedToSend);
          }

          -[NEIKEv2Session reportState](a1, v84);
          -[NEIKEv2Session resetAll]((uint64_t)a1, v85);
LABEL_39:

LABEL_40:
LABEL_41:

          goto LABEL_42;
        }
        ne_log_obj();
        v97 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v97, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 138412546;
          v117 = a1;
          v118 = 2112;
          v119 = v27;
          _os_log_error_impl(&dword_19BD16000, v97, OS_LOG_TYPE_ERROR, "%@ Failed to generate values for KEM %@ (connect intermediate)", buf, 0x16u);
        }

        v88 = objc_getProperty(a1, v98, 336, 1);
        v96 = (void *)NEIKEv2CreateErrorInternal(CFSTR("Failed to generate values for KEM %@ (connect intermediate)"), v99, v100, v101, v102, v103, v104, v105, (uint64_t)v27);
      }
      else
      {
        ne_log_obj();
        v86 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v86, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 138412546;
          v117 = a1;
          v118 = 2112;
          v119 = v22;
          _os_log_error_impl(&dword_19BD16000, v86, OS_LOG_TYPE_ERROR, "%@ No chosen KEM found for transform type %@ (connect intermediate)", buf, 0x16u);
        }

        v88 = objc_getProperty(a1, v87, 336, 1);
        v96 = (void *)NEIKEv2CreateErrorInternal(CFSTR("No chosen KEM found for transform type %@ (connect intermediate)"), v89, v90, v91, v92, v93, v94, v95, (uint64_t)v22);
      }
      v106 = v96;
      -[NEIKEv2IKESA setState:error:]((uint64_t)v88, 3uLL, v96);

      -[NEIKEv2Session reportState](a1, v107);
      -[NEIKEv2Session resetAll]((uint64_t)a1, v108);
      goto LABEL_41;
    }
    v9[2](v9);
  }
LABEL_42:

}

void __85__NEIKEv2Session_Exchange__handleIKEIntermediateForInitiatorIKESA_iteration_handler___block_invoke(uint64_t a1, void *a2)
{
  id v3;
  id Property;
  const char *v5;
  void *v6;
  id v7;
  const char *v8;
  id v9;
  const char *v10;
  void *v11;
  id v12;
  const char *v13;
  id v14;
  const char *v15;
  void *v16;
  id v17;
  const char *v18;
  id v19;
  const char *v20;
  void *v21;
  id v22;
  uint64_t v23;
  uint64_t v24;
  const char *v25;
  id v26;
  const char *v27;
  void *v28;
  const char *v29;
  id v30;
  void *v31;
  const char *v32;
  _BYTE *v33;
  NSObject *v34;
  const char *v35;
  id v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  id v44;
  __CFString *v45;
  NSObject *v46;
  const char *v47;
  id v48;
  NSObject *v49;
  const char *v50;
  id v51;
  void *ErrorCrypto;
  void *v53;
  const char *v54;
  const char *v55;
  NSObject *v56;
  const char *v57;
  const char *v58;
  id v59;
  const char *v60;
  id v61;
  const char *v62;
  id v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  void *ErrorPeerInvalidSyntax;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  id v77;
  const char *v78;
  void *v79;
  id v80;
  uint64_t v81;
  uint64_t v82;
  NSObject *v83;
  const char *v84;
  id v85;
  id v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  void *v94;
  const char *v95;
  const char *v96;
  NSObject *v97;
  const char *v98;
  id v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  __CFString *v107;
  NSObject *v108;
  const char *v109;
  id v110;
  NSObject *v111;
  const char *v112;
  id v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint8_t buf[4];
  uint64_t v119;
  __int16 v120;
  uint64_t v121;
  __int16 v122;
  uint64_t v123;
  uint64_t v124;

  v124 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    Property = v3;
    v6 = Property;
    if (Property)
      Property = objc_getProperty(Property, v5, 88, 1);
    v7 = Property;

    if (v7)
    {
      if (v6)
      {
        v9 = objc_getProperty(v6, v8, 88, 1);
        v11 = v9;
        if (v9)
          v9 = objc_getProperty(v9, v10, 24, 1);
      }
      else
      {
        v11 = 0;
        v9 = 0;
      }
      v12 = v9;

      if (v12)
      {
        if (v6)
        {
          v14 = objc_getProperty(v6, v13, 88, 1);
          v16 = v14;
          if (v14)
            v14 = objc_getProperty(v14, v15, 32, 1);
        }
        else
        {
          v16 = 0;
          v14 = 0;
        }
        v17 = v14;

        if (v17)
        {
          if (v6)
          {
            v19 = objc_getProperty(v6, v18, 88, 1);
            v21 = v19;
            if (v19)
              v19 = objc_getProperty(v19, v20, 24, 1);
          }
          else
          {
            v21 = 0;
            v19 = 0;
          }
          v22 = v19;
          v23 = objc_msgSend(v22, "method");
          v24 = objc_msgSend(*(id *)(a1 + 40), "method");

          if (v23 != v24)
          {
            ne_log_obj();
            v56 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
            {
              v76 = *(_QWORD *)(a1 + 32);
              if (v6)
              {
                v77 = objc_getProperty(v6, v57, 88, 1);
                v79 = v77;
                if (v77)
                  v77 = objc_getProperty(v77, v78, 24, 1);
              }
              else
              {
                v79 = 0;
                v77 = 0;
              }
              v80 = v77;
              v81 = objc_msgSend(v80, "method");
              v82 = objc_msgSend(*(id *)(a1 + 40), "method");
              *(_DWORD *)buf = 138412802;
              v119 = v76;
              v120 = 2048;
              v121 = v81;
              v122 = 2048;
              v123 = v82;
              _os_log_error_impl(&dword_19BD16000, v56, OS_LOG_TYPE_ERROR, "%@ Did not receive matching method from KE payload (%zu != %zu) (connect intermediate)", buf, 0x20u);

            }
            v59 = *(id *)(a1 + 32);
            if (v59)
              v59 = objc_getProperty(v59, v58, 336, 1);
            v44 = v59;
            if (v6)
            {
              v61 = objc_getProperty(v6, v60, 88, 1);
              v53 = v61;
              if (v61)
                v61 = objc_getProperty(v61, v62, 24, 1);
            }
            else
            {
              v53 = 0;
              v61 = 0;
            }
            v63 = v61;
            v64 = objc_msgSend(v63, "method");
            objc_msgSend(*(id *)(a1 + 40), "method");
            ErrorPeerInvalidSyntax = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("Did not receive matching method from KE payload (%zu != %zu) (connect intermediate)"), v65, v66, v67, v68, v69, v70, v71, v64);
            -[NEIKEv2IKESA setState:error:]((uint64_t)v44, 3uLL, ErrorPeerInvalidSyntax);

            goto LABEL_44;
          }
          if (v6)
          {
            v26 = objc_getProperty(v6, v25, 88, 1);
            v28 = v26;
            if (v26)
              v26 = objc_getProperty(v26, v27, 32, 1);
          }
          else
          {
            v28 = 0;
            v26 = 0;
          }
          v30 = v26;
          v31 = *(void **)(a1 + 48);
          if (v31)
            objc_setProperty_atomic(v31, v29, v30, 152);

          if ((-[NEIKEv2IKESA processPrimaryKeyExchange](*(_QWORD *)(a1 + 48), v32) & 1) != 0)
          {
            if ((-[NEIKEv2IKESA updateIntAuthWithPacket:](*(_QWORD *)(a1 + 48), v6) & 1) != 0)
            {
              v33 = *(_BYTE **)(a1 + 48);
              if (v33 && (-[NEIKEv2IKESA generateAllValuesUsingSA:](v33, *(void **)(a1 + 48)) & 1) != 0)
              {
                -[NEIKEv2Session handleIKEIntermediateForInitiatorIKESA:iteration:handler:](*(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 64) + 1, *(_QWORD *)(a1 + 56));
LABEL_45:

                goto LABEL_46;
              }
              ne_log_obj();
              v97 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v97, OS_LOG_TYPE_ERROR))
              {
                v115 = *(_QWORD *)(a1 + 32);
                *(_DWORD *)buf = 138412290;
                v119 = v115;
                _os_log_error_impl(&dword_19BD16000, v97, OS_LOG_TYPE_ERROR, "%@ Failed to generate crypto values (connect intermediate)", buf, 0xCu);
              }

              v99 = *(id *)(a1 + 32);
              if (v99)
                v99 = objc_getProperty(v99, v98, 336, 1);
              v44 = v99;
              v107 = CFSTR("Failed to generate crypto values (connect intermediate)");
            }
            else
            {
              ne_log_obj();
              v111 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v111, OS_LOG_TYPE_ERROR))
              {
                v116 = *(_QWORD *)(a1 + 32);
                *(_DWORD *)buf = 138412290;
                v119 = v116;
                _os_log_error_impl(&dword_19BD16000, v111, OS_LOG_TYPE_ERROR, "%@ Failed to process IKE_INTERMEDIATE reply packet for AUTH (connect intermediate)", buf, 0xCu);
              }

              v113 = *(id *)(a1 + 32);
              if (v113)
                v113 = objc_getProperty(v113, v112, 336, 1);
              v44 = v113;
              v107 = CFSTR("Failed to process IKE_INTERMEDIATE reply packet for AUTH (connect intermediate)");
            }
          }
          else
          {
            ne_log_obj();
            v108 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v108, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)buf = 0;
              _os_log_error_impl(&dword_19BD16000, v108, OS_LOG_TYPE_ERROR, "Failed to process KE data (connect intermediate)", buf, 2u);
            }

            v110 = *(id *)(a1 + 32);
            if (v110)
              v110 = objc_getProperty(v110, v109, 336, 1);
            v44 = v110;
            v107 = CFSTR("Failed to process KE data (connect intermediate)");
          }
          ErrorCrypto = (void *)NEIKEv2CreateErrorCrypto(v107, v100, v101, v102, v103, v104, v105, v106, v117);
LABEL_43:
          v53 = ErrorCrypto;
          -[NEIKEv2IKESA setState:error:]((uint64_t)v44, 3uLL, ErrorCrypto);
LABEL_44:

          -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 32), v54);
          -[NEIKEv2Session resetAll](*(_QWORD *)(a1 + 32), v55);
          goto LABEL_45;
        }
        ne_log_obj();
        v49 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
        {
          v75 = *(_QWORD *)(a1 + 32);
          *(_DWORD *)buf = 138412290;
          v119 = v75;
          _os_log_error_impl(&dword_19BD16000, v49, OS_LOG_TYPE_ERROR, "%@ Did not receive data in KE payload (connect intermediate)", buf, 0xCu);
        }

        v51 = *(id *)(a1 + 32);
        if (v51)
          v51 = objc_getProperty(v51, v50, 336, 1);
        v44 = v51;
        v45 = CFSTR("Did not receive data in KE payload (connect intermediate)");
      }
      else
      {
        ne_log_obj();
        v46 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
        {
          v74 = *(_QWORD *)(a1 + 32);
          *(_DWORD *)buf = 138412290;
          v119 = v74;
          _os_log_error_impl(&dword_19BD16000, v46, OS_LOG_TYPE_ERROR, "%@ Did not receive method in KE payload (connect intermediate)", buf, 0xCu);
        }

        v48 = *(id *)(a1 + 32);
        if (v48)
          v48 = objc_getProperty(v48, v47, 336, 1);
        v44 = v48;
        v45 = CFSTR("Did not receive method in KE payload (connect intermediate)");
      }
    }
    else
    {
      ne_log_obj();
      v34 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
      {
        v73 = *(_QWORD *)(a1 + 32);
        *(_DWORD *)buf = 138412290;
        v119 = v73;
        _os_log_error_impl(&dword_19BD16000, v34, OS_LOG_TYPE_ERROR, "%@ Did not receive KE payload (connect intermediate)", buf, 0xCu);
      }

      v36 = *(id *)(a1 + 32);
      if (v36)
        v36 = objc_getProperty(v36, v35, 336, 1);
      v44 = v36;
      v45 = CFSTR("Did not receive KE payload (connect intermediate)");
    }
    ErrorCrypto = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(v45, v37, v38, v39, v40, v41, v42, v43, v117);
    goto LABEL_43;
  }
  ne_log_obj();
  v83 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v83, OS_LOG_TYPE_ERROR))
  {
    v114 = *(_QWORD *)(a1 + 32);
    *(_DWORD *)buf = 138412290;
    v119 = v114;
    _os_log_error_impl(&dword_19BD16000, v83, OS_LOG_TYPE_ERROR, "%@ Failed to receive IKE_INTERMEDIATE reply (connect intermediate)", buf, 0xCu);
  }

  v85 = *(id *)(a1 + 32);
  if (v85)
    v85 = objc_getProperty(v85, v84, 336, 1);
  v86 = v85;
  v94 = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("Failed to receive IKE_INTERMEDIATE reply (connect intermediate)"), v87, v88, v89, v90, v91, v92, v93, v117);
  -[NEIKEv2IKESA setState:error:]((uint64_t)v86, 3uLL, v94);

  -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 32), v95);
  -[NEIKEv2Session resetAll](*(_QWORD *)(a1 + 32), v96);
LABEL_46:

}

- (uint64_t)handleIKEIntermediateForResponderIKESA:(uint64_t)a3 iteration:(void *)a4 replyPacket:(void *)a5 replyPacketDescription:(void *)a6 handler:
{
  id v11;
  id v12;
  id v13;
  id v14;
  SEL v15;
  NSObject *v16;
  uint64_t v17;
  const char *v18;
  id v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  void *ErrorFailedToSend;
  const char *v28;
  const char *v29;
  _QWORD v31[4];
  id v32;
  _QWORD *v33;
  id v34;
  uint64_t v35;

  v11 = a2;
  v12 = a5;
  v13 = a6;
  if (a1)
  {
    v14 = a4;
    v16 = objc_getProperty(a1, v15, 368, 1);
    dispatch_assert_queue_V2(v16);

    v31[0] = MEMORY[0x1E0C809B0];
    v31[1] = 3221225472;
    v31[2] = __120__NEIKEv2Session_Exchange__handleIKEIntermediateForResponderIKESA_iteration_replyPacket_replyPacketDescription_handler___block_invoke;
    v31[3] = &unk_1E3CC0F50;
    v35 = a3;
    v32 = v11;
    v33 = a1;
    v34 = v13;
    v17 = -[NEIKEv2Session sendReply:replyHandler:]((uint64_t)a1, v14, v31);

    if ((v17 & 1) == 0)
    {
      v19 = objc_getProperty(a1, v18, 336, 1);
      ErrorFailedToSend = (void *)NEIKEv2CreateErrorFailedToSend(CFSTR("%@"), v20, v21, v22, v23, v24, v25, v26, (uint64_t)v12);
      -[NEIKEv2IKESA setState:error:]((uint64_t)v19, 3uLL, ErrorFailedToSend);

      -[NEIKEv2Session reportState](a1, v28);
      -[NEIKEv2Session resetAll]((uint64_t)a1, v29);
    }

  }
  else
  {
    v17 = 0;
  }

  return v17;
}

void __120__NEIKEv2Session_Exchange__handleIKEIntermediateForResponderIKESA_iteration_replyPacket_replyPacketDescription_handler___block_invoke(uint64_t a1, void *a2)
{
  const char *v3;
  _DWORD *v4;
  unint64_t v5;
  void *v6;
  id Property;
  const char *v8;
  void *v9;
  id v10;
  unint64_t v11;
  const char *v12;
  _DWORD *v13;
  void *v14;
  id v15;
  const char *v16;
  void *v17;
  id v18;
  void *v19;
  const char *v20;
  id v21;
  id v22;
  void *v23;
  void *v24;
  const char *v25;
  id v26;
  id v27;
  const char *v28;
  id v29;
  const char *v30;
  void *v31;
  id v32;
  const char *v33;
  id v34;
  const char *v35;
  void *v36;
  id v37;
  const char *v38;
  id v39;
  const char *v40;
  void *v41;
  id v42;
  uint64_t v43;
  uint64_t v44;
  const char *v45;
  void *v46;
  id v47;
  const char *v48;
  void *v49;
  id v50;
  char v51;
  void *v52;
  NEIKEv2KeyExchangePayload *v53;
  const char *v54;
  NEIKEv2KeyExchangePayload *v55;
  SEL v56;
  id v57;
  const char *v58;
  void *v59;
  const char *v60;
  void *v61;
  id v62;
  void *v63;
  void *v64;
  const char *v65;
  id v66;
  id v67;
  const char *v68;
  void *v69;
  const char *v70;
  id v71;
  id v72;
  char v73;
  const char *v74;
  void *v75;
  id v76;
  void *v77;
  void *v78;
  const char *v79;
  id v80;
  void *v81;
  const char *v82;
  void *v83;
  uint64_t v84;
  uint64_t *v85;
  uint64_t v86;
  uint64_t v87;
  id v88;
  void *v89;
  int v90;
  _BYTE *v91;
  NSObject *v92;
  const char *v93;
  id v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  id v102;
  __CFString *v103;
  int v104;
  uint64_t v105;
  NSObject *v106;
  const char *v107;
  id v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  id v116;
  __CFString *v117;
  NSObject *v118;
  const char *v119;
  id v120;
  NSObject *v121;
  const char *v122;
  id v123;
  void *ErrorInternal;
  void *v125;
  const char *v126;
  const char *v127;
  NSObject *v128;
  const char *v129;
  const char *v130;
  id v131;
  const char *v132;
  id v133;
  id v134;
  const char *v135;
  void *v136;
  id v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  void *ErrorPeerInvalidSyntax;
  const char *v147;
  const char *v148;
  NSObject *v149;
  const char *v150;
  id v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  NSObject *v159;
  const char *v160;
  id v161;
  uint64_t *v162;
  void *v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  void *ErrorCrypto;
  const char *v172;
  const char *v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  id v178;
  const char *v179;
  void *v180;
  id v181;
  uint64_t v182;
  uint64_t v183;
  NSObject *v184;
  const char *v185;
  id v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  id v194;
  __CFString *v195;
  NSObject *v196;
  const char *v197;
  id v198;
  void *v199;
  const char *v200;
  const char *v201;
  NSObject *v202;
  const char *v203;
  id v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  NSObject *v215;
  const char *v216;
  id v217;
  NSObject *v218;
  const char *v219;
  id v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  void *v226;
  uint8_t buf[4];
  uint64_t v228;
  __int16 v229;
  uint64_t v230;
  __int16 v231;
  uint64_t v232;
  uint64_t v233;

  v233 = *MEMORY[0x1E0C80C00];
  v4 = a2;
  v5 = *(_QWORD *)(a1 + 56);
  v6 = *(void **)(a1 + 32);
  if (v6)
  {
    Property = objc_getProperty(v6, v3, 96, 1);
    v9 = Property;
    if (Property)
      Property = objc_getProperty(Property, v8, 120, 1);
  }
  else
  {
    v9 = 0;
    Property = 0;
  }
  v10 = Property;
  v11 = objc_msgSend(v10, "count");

  if (v5 < v11)
  {
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      v13 = v4;
      v14 = *(void **)(a1 + 32);
      if (v14)
      {
        v15 = objc_getProperty(v14, v12, 96, 1);
        v17 = v15;
        if (v15)
          v15 = objc_getProperty(v15, v16, 120, 1);
      }
      else
      {
        v17 = 0;
        v15 = 0;
      }
      v18 = v15;
      objc_msgSend(v18, "objectAtIndexedSubscript:", *(_QWORD *)(a1 + 56));
      v19 = (void *)objc_claimAutoreleasedReturnValue();

      v21 = *(id *)(a1 + 32);
      if (v21)
        v21 = objc_getProperty(v21, v20, 96, 1);
      v22 = v21;
      -[NEIKEv2IKESAProposal chosenAdditionalKEMProtocols](v22);
      v23 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v23, "objectForKeyedSubscript:", v19);
      v24 = (void *)objc_claimAutoreleasedReturnValue();

      if (!v24)
      {
        ne_log_obj();
        v202 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v202, OS_LOG_TYPE_ERROR))
        {
          v214 = *(_QWORD *)(a1 + 40);
          *(_DWORD *)buf = 138412546;
          v228 = v214;
          v229 = 2112;
          v230 = (uint64_t)v19;
          _os_log_error_impl(&dword_19BD16000, v202, OS_LOG_TYPE_ERROR, "%@ No chosen KEM found for transform type %@ (receive intermediate)", buf, 0x16u);
        }

        v204 = *(id *)(a1 + 40);
        if (v204)
          v204 = objc_getProperty(v204, v203, 336, 1);
        v116 = v204;
        ErrorInternal = (void *)NEIKEv2CreateErrorInternal(CFSTR("No chosen KEM found for transform type %@ (receive intermediate)"), v205, v206, v207, v208, v209, v210, v211, (uint64_t)v19);
        goto LABEL_82;
      }
      if (v13)
        v26 = objc_getProperty(v13, v25, 88, 1);
      else
        v26 = 0;
      v27 = v26;

      if (v27)
      {
        if (v13)
        {
          v29 = objc_getProperty(v13, v28, 88, 1);
          v31 = v29;
          if (v29)
            v29 = objc_getProperty(v29, v30, 24, 1);
        }
        else
        {
          v31 = 0;
          v29 = 0;
        }
        v32 = v29;

        if (v32)
        {
          if (v13)
          {
            v34 = objc_getProperty(v13, v33, 88, 1);
            v36 = v34;
            if (v34)
              v34 = objc_getProperty(v34, v35, 32, 1);
          }
          else
          {
            v36 = 0;
            v34 = 0;
          }
          v37 = v34;

          if (v37)
          {
            v226 = v19;
            if (v13)
            {
              v39 = objc_getProperty(v13, v38, 88, 1);
              v41 = v39;
              if (v39)
                v39 = objc_getProperty(v39, v40, 24, 1);
            }
            else
            {
              v41 = 0;
              v39 = 0;
            }
            v42 = v39;
            v43 = objc_msgSend(v42, "method");
            v44 = objc_msgSend(v24, "method");

            if (v43 != v44)
            {
              ne_log_obj();
              v128 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v128, OS_LOG_TYPE_ERROR))
              {
                v177 = *(_QWORD *)(a1 + 40);
                if (v13)
                {
                  v178 = objc_getProperty(v13, v129, 88, 1);
                  v180 = v178;
                  if (v178)
                    v178 = objc_getProperty(v178, v179, 24, 1);
                }
                else
                {
                  v180 = 0;
                  v178 = 0;
                }
                v181 = v178;
                *(_DWORD *)buf = 138412802;
                v228 = v177;
                v229 = 2048;
                v230 = objc_msgSend(v181, "method");
                v231 = 2048;
                v232 = objc_msgSend(v24, "method");
                _os_log_error_impl(&dword_19BD16000, v128, OS_LOG_TYPE_ERROR, "%@ Did not receive matching method from KE payload (%zu != %zu) (receive intermediate)", buf, 0x20u);

              }
              v131 = *(id *)(a1 + 40);
              if (v131)
                v131 = objc_getProperty(v131, v130, 336, 1);
              v133 = v131;
              if (v13)
              {
                v134 = objc_getProperty(v13, v132, 88, 1);
                v136 = v134;
                if (v134)
                  v134 = objc_getProperty(v134, v135, 24, 1);
              }
              else
              {
                v136 = 0;
                v134 = 0;
              }
              v137 = v134;
              v138 = objc_msgSend(v137, "method");
              objc_msgSend(v24, "method");
              ErrorPeerInvalidSyntax = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("Did not receive matching method from KE payload (%zu != %zu) (receive intermediate)"), v139, v140, v141, v142, v143, v144, v145, v138);
              -[NEIKEv2IKESA setState:error:]((uint64_t)v133, 3uLL, ErrorPeerInvalidSyntax);

              -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 40), v147);
              -[NEIKEv2Session resetAll](*(_QWORD *)(a1 + 40), v148);
              v19 = v226;
              goto LABEL_83;
            }
            v46 = *(void **)(a1 + 32);
            if (v13)
            {
              v47 = objc_getProperty(v13, v45, 88, 1);
              v49 = v47;
              if (v47)
                v47 = objc_getProperty(v47, v48, 32, 1);
            }
            else
            {
              v49 = 0;
              v47 = 0;
            }
            v50 = v47;
            v51 = -[NEIKEv2IKESA generateLocalValuesForKEMProtocol:peerPayload:](v46, v24, v50);

            if ((v51 & 1) != 0)
            {
              v52 = (void *)-[NEIKEv2Packet initResponse:]((uint64_t)[NEIKEv2IntermediatePacket alloc], v13);
              v53 = objc_alloc_init(NEIKEv2KeyExchangePayload);
              v55 = v53;
              if (v52)
              {
                objc_setProperty_atomic(v52, v54, v53, 88);

                v57 = objc_getProperty(v52, v56, 88, 1);
                v59 = v57;
                if (v57)
                  objc_setProperty_atomic(v57, v58, v24, 24);
              }
              else
              {

                v59 = 0;
              }

              v61 = *(void **)(a1 + 32);
              if (v61)
              {
                v62 = objc_getProperty(v61, v60, 160, 1);
                v63 = v62;
                if (v62)
                {
                  v64 = (void *)*((_QWORD *)v62 + 2);
                  goto LABEL_37;
                }
              }
              else
              {
                v63 = 0;
              }
              v64 = 0;
LABEL_37:
              v66 = v64;
              if (v52)
              {
                v67 = objc_getProperty(v52, v65, 88, 1);
                v69 = v67;
                if (v67)
                  objc_setProperty_atomic(v67, v68, v66, 32);
              }
              else
              {
                v69 = 0;
              }

              if (v13)
                v71 = objc_getProperty(v13, v70, 88, 1);
              else
                v71 = 0;
              v72 = v71;
              v73 = -[NEIKEv2Payload isValid]((uint64_t)v72);

              if ((v73 & 1) == 0)
              {
                ne_log_obj();
                v159 = objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v159, OS_LOG_TYPE_ERROR))
                {
                  v183 = *(_QWORD *)(a1 + 40);
                  *(_DWORD *)buf = 138412290;
                  v228 = v183;
                  _os_log_error_impl(&dword_19BD16000, v159, OS_LOG_TYPE_ERROR, "%@ Failed to create IKE_INTERMEDIATE packet (receive intermediate)", buf, 0xCu);
                }

                v163 = *(void **)(a1 + 40);
                v162 = (uint64_t *)(a1 + 40);
                v161 = v163;
                if (v163)
                  v161 = objc_getProperty(v161, v160, 336, 1);
                v102 = v161;
                ErrorCrypto = (void *)NEIKEv2CreateErrorInternal(CFSTR("Failed to create IKE_INTERMEDIATE packet (receive intermediate)"), v164, v165, v166, v167, v168, v169, v170, v224);
                -[NEIKEv2IKESA setState:error:]((uint64_t)v102, 3uLL, ErrorCrypto);
                v85 = v162;
                goto LABEL_102;
              }
              v75 = *(void **)(a1 + 32);
              if (v75)
              {
                v76 = objc_getProperty(v75, v74, 160, 1);
                v77 = v76;
                if (v76)
                {
                  v78 = (void *)*((_QWORD *)v76 + 3);
LABEL_46:
                  v80 = v78;
                  v81 = *(void **)(a1 + 32);
                  if (v81)
                    objc_setProperty_atomic(v81, v79, v80, 168);

                  v83 = *(void **)(a1 + 32);
                  if (v83)
                  {
                    objc_setProperty_atomic(v83, v82, 0, 160);
                    v84 = *(_QWORD *)(a1 + 32);
                  }
                  else
                  {
                    v84 = 0;
                  }
                  v85 = (uint64_t *)(a1 + 40);
                  v86 = *(_QWORD *)(a1 + 40);
                  v87 = *(_QWORD *)(a1 + 56) + 1;
                  v88 = objc_alloc(MEMORY[0x1E0CB3940]);
                  v225 = *(_QWORD *)(a1 + 56) + 1;
                  v89 = (void *)objc_msgSend(v88, "initWithFormat:", CFSTR("responder IKE_INTERMEDIATE #%zu"));
                  v90 = -[NEIKEv2Session handleIKEIntermediateForResponderIKESA:iteration:replyPacket:replyPacketDescription:handler:](v86, v84, v87, v52, v89, *(_QWORD *)(a1 + 48));

                  v19 = v226;
                  if (!v90)
                    goto LABEL_103;
                  if ((-[NEIKEv2IKESA updateIntAuthWithPacket:](*(_QWORD *)(a1 + 32), v13) & 1) != 0)
                  {
                    if ((-[NEIKEv2IKESA updateIntAuthWithPacket:](*(_QWORD *)(a1 + 32), v52) & 1) != 0)
                    {
                      v91 = *(_BYTE **)(a1 + 32);
                      if (v91 && (-[NEIKEv2IKESA generateAllValuesUsingSA:](v91, *(void **)(a1 + 32)) & 1) != 0)
                        goto LABEL_103;
                      ne_log_obj();
                      v92 = objc_claimAutoreleasedReturnValue();
                      if (os_log_type_enabled(v92, OS_LOG_TYPE_ERROR))
                      {
                        v221 = *v85;
                        *(_DWORD *)buf = 138412290;
                        v228 = v221;
                        _os_log_error_impl(&dword_19BD16000, v92, OS_LOG_TYPE_ERROR, "%@ Failed to generate crypto values (receive intermediate)", buf, 0xCu);
                      }

                      v94 = (id)*v85;
                      if (*v85)
                        v94 = objc_getProperty(v94, v93, 336, 1);
                      v102 = v94;
                      v103 = CFSTR("Failed to generate crypto values (receive intermediate)");
                    }
                    else
                    {
                      ne_log_obj();
                      v218 = objc_claimAutoreleasedReturnValue();
                      if (os_log_type_enabled(v218, OS_LOG_TYPE_ERROR))
                      {
                        v223 = *v85;
                        *(_DWORD *)buf = 138412290;
                        v228 = v223;
                        _os_log_error_impl(&dword_19BD16000, v218, OS_LOG_TYPE_ERROR, "%@ Failed to process IKE_INTERMEDIATE reply packet for AUTH (receive intermediate)", buf, 0xCu);
                      }

                      v220 = (id)*v85;
                      if (*v85)
                        v220 = objc_getProperty(v220, v219, 336, 1);
                      v102 = v220;
                      v103 = CFSTR("Failed to process IKE_INTERMEDIATE reply packet for AUTH (receive intermediate)");
                    }
                  }
                  else
                  {
                    ne_log_obj();
                    v215 = objc_claimAutoreleasedReturnValue();
                    if (os_log_type_enabled(v215, OS_LOG_TYPE_ERROR))
                    {
                      v222 = *v85;
                      *(_DWORD *)buf = 138412290;
                      v228 = v222;
                      _os_log_error_impl(&dword_19BD16000, v215, OS_LOG_TYPE_ERROR, "%@ Failed to process IKE_INTERMEDIATE request packet for AUTH (receive intermediate)", buf, 0xCu);
                    }

                    v217 = (id)*v85;
                    if (*v85)
                      v217 = objc_getProperty(v217, v216, 336, 1);
                    v102 = v217;
                    v103 = CFSTR("Failed to process IKE_INTERMEDIATE request packet for AUTH (receive intermediate)");
                  }
                  ErrorCrypto = (void *)NEIKEv2CreateErrorCrypto(v103, v95, v96, v97, v98, v99, v100, v101, v225);
                  -[NEIKEv2IKESA setState:error:]((uint64_t)v102, 3uLL, ErrorCrypto);
LABEL_102:

                  -[NEIKEv2Session reportState]((_QWORD *)*v85, v172);
                  -[NEIKEv2Session resetAll](*v85, v173);
                  v19 = v226;
LABEL_103:

                  goto LABEL_83;
                }
              }
              else
              {
                v77 = 0;
              }
              v78 = 0;
              goto LABEL_46;
            }
            ne_log_obj();
            v149 = objc_claimAutoreleasedReturnValue();
            v19 = v226;
            if (os_log_type_enabled(v149, OS_LOG_TYPE_ERROR))
            {
              v182 = *(_QWORD *)(a1 + 40);
              *(_DWORD *)buf = 138412546;
              v228 = v182;
              v229 = 2112;
              v230 = (uint64_t)v24;
              _os_log_error_impl(&dword_19BD16000, v149, OS_LOG_TYPE_ERROR, "%@ Failed to generate values for KEM %@ (receive intermediate)", buf, 0x16u);
            }

            v151 = *(id *)(a1 + 40);
            if (v151)
              v151 = objc_getProperty(v151, v150, 336, 1);
            v116 = v151;
            ErrorInternal = (void *)NEIKEv2CreateErrorInternal(CFSTR("Failed to generate values for KEM %@ (receive intermediate)"), v152, v153, v154, v155, v156, v157, v158, (uint64_t)v24);
LABEL_82:
            v125 = ErrorInternal;
            -[NEIKEv2IKESA setState:error:]((uint64_t)v116, 3uLL, ErrorInternal);

            -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 40), v126);
            -[NEIKEv2Session resetAll](*(_QWORD *)(a1 + 40), v127);
LABEL_83:

            goto LABEL_84;
          }
          ne_log_obj();
          v121 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v121, OS_LOG_TYPE_ERROR))
          {
            v176 = *(_QWORD *)(a1 + 40);
            *(_DWORD *)buf = 138412290;
            v228 = v176;
            _os_log_error_impl(&dword_19BD16000, v121, OS_LOG_TYPE_ERROR, "%@ Did not receive data in KE payload (receive intermediate)", buf, 0xCu);
          }

          v123 = *(id *)(a1 + 40);
          if (v123)
            v123 = objc_getProperty(v123, v122, 336, 1);
          v116 = v123;
          v117 = CFSTR("Did not receive data in KE payload (receive intermediate)");
        }
        else
        {
          ne_log_obj();
          v118 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v118, OS_LOG_TYPE_ERROR))
          {
            v175 = *(_QWORD *)(a1 + 40);
            *(_DWORD *)buf = 138412290;
            v228 = v175;
            _os_log_error_impl(&dword_19BD16000, v118, OS_LOG_TYPE_ERROR, "%@ Did not receive method in KE payload (receive intermediate)", buf, 0xCu);
          }

          v120 = *(id *)(a1 + 40);
          if (v120)
            v120 = objc_getProperty(v120, v119, 336, 1);
          v116 = v120;
          v117 = CFSTR("Did not receive method in KE payload (receive intermediate)");
        }
      }
      else
      {
        ne_log_obj();
        v106 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v106, OS_LOG_TYPE_ERROR))
        {
          v174 = *(_QWORD *)(a1 + 40);
          *(_DWORD *)buf = 138412290;
          v228 = v174;
          _os_log_error_impl(&dword_19BD16000, v106, OS_LOG_TYPE_ERROR, "%@ Did not receive KE payload (receive intermediate)", buf, 0xCu);
        }

        v108 = *(id *)(a1 + 40);
        if (v108)
          v108 = objc_getProperty(v108, v107, 336, 1);
        v116 = v108;
        v117 = CFSTR("Did not receive KE payload (receive intermediate)");
      }
      ErrorInternal = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(v117, v109, v110, v111, v112, v113, v114, v115, v224);
      goto LABEL_82;
    }
    ne_log_obj();
    v184 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v184, OS_LOG_TYPE_ERROR))
    {
      v212 = *(_QWORD *)(a1 + 40);
      *(_DWORD *)buf = 138412290;
      v228 = v212;
      _os_log_error_impl(&dword_19BD16000, v184, OS_LOG_TYPE_ERROR, "%@ Failed to receive IKE_INTERMEDIATE packet (receive intermediate)", buf, 0xCu);
    }

    v186 = *(id *)(a1 + 40);
    if (v186)
      v186 = objc_getProperty(v186, v185, 336, 1);
    v194 = v186;
    v195 = CFSTR("Failed to receive IKE_INTERMEDIATE packet (receive intermediate)");
LABEL_118:
    v199 = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(v195, v187, v188, v189, v190, v191, v192, v193, v224);
    -[NEIKEv2IKESA setState:error:]((uint64_t)v194, 3uLL, v199);

    -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 40), v200);
    -[NEIKEv2Session resetAll](*(_QWORD *)(a1 + 40), v201);
    goto LABEL_84;
  }
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    ne_log_obj();
    v196 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v196, OS_LOG_TYPE_ERROR))
    {
      v213 = *(_QWORD *)(a1 + 40);
      *(_DWORD *)buf = 138412290;
      v228 = v213;
      _os_log_error_impl(&dword_19BD16000, v196, OS_LOG_TYPE_ERROR, "%@ Failed to receive IKE Auth packet (receive)", buf, 0xCu);
    }

    v198 = *(id *)(a1 + 40);
    if (v198)
      v198 = objc_getProperty(v198, v197, 336, 1);
    v194 = v198;
    v195 = CFSTR("Failed to receive IKE Auth packet (receive)");
    goto LABEL_118;
  }
  if (v4)
    v104 = v4[6];
  else
    v104 = 0;
  v105 = *(_QWORD *)(a1 + 32);
  if (v105)
    *(_DWORD *)(v105 + 28) = v104;
  (*(void (**)(void))(*(_QWORD *)(a1 + 48) + 16))();
LABEL_84:

}

- (void)handleEAPAndGSPMForIKESA:(void *)a3 authPacket:(void *)a4 handler:
{
  _BYTE *v7;
  id v8;
  const char *v9;
  void (**v10)(id, id);
  NSObject *v11;
  const char *v12;
  id v13;
  const char *v14;
  const char *v15;
  id v16;
  id v17;
  id Property;
  id v19;
  const char *v20;
  NSObject *v21;
  id v22;
  uint64_t v23;
  const char *v24;
  const char *v25;
  uint64_t v26;
  uint64_t v27;
  __CFString *v28;
  uint64_t v29;
  uint64_t i;
  uint64_t v31;
  __CFString *v32;
  NSObject *v33;
  const char *v34;
  uint64_t v35;
  const char *v36;
  void *v37;
  id v38;
  id v39;
  const char *v40;
  void *v41;
  id v42;
  void *v43;
  id v44;
  id v45;
  NSObject *v46;
  id v47;
  const char *v48;
  const char *v49;
  id v50;
  uint64_t v51;
  uint64_t v52;
  NSObject *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  __CFString *v57;
  NSObject *v58;
  const char *v59;
  uint64_t v60;
  const char *v61;
  void *v62;
  id v63;
  id v64;
  void *v65;
  void *v66;
  id v67;
  void *v68;
  uint64_t v69;
  NSObject *v70;
  NSObject *v71;
  const char *v72;
  id v73;
  const char *v74;
  void *v75;
  id v76;
  const char *v77;
  const char *v78;
  id v79;
  const char *v80;
  void *v81;
  id v82;
  void *v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  NSObject *v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  void *ErrorAuthentication;
  __CFString *ErrorPeerInvalidSyntax;
  id *v101;
  id v102;
  void *v103;
  void *v104;
  id v105;
  const char *v106;
  id *v107;
  const char *v108;
  id *v109;
  const char *v110;
  id v111;
  NSObject *v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t Error;
  NSObject *v128;
  NEIKEv2EAPPayload *v129;
  SEL v130;
  SEL v131;
  id v132;
  const char *v133;
  void *v134;
  NSObject *v135;
  SEL v136;
  void *v137;
  SEL v138;
  id v139;
  void *v140;
  uint64_t v141;
  void *v142;
  NEIKEv2NotifyPayload *v143;
  BOOL v144;
  id v145;
  void *v146;
  void *v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  id v155;
  __CFString *ErrorInternal;
  id v157;
  id v158;
  void *v159;
  SEL v160;
  id v161;
  id v162;
  uint64_t v163;
  id v164;
  id v165;
  void *v166;
  NSObject *v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  void *v175;
  void *v176;
  NEIKEv2AuthPayload *v177;
  SEL v178;
  NEIKEv2AuthenticationProtocol *v179;
  SEL v180;
  void *v181;
  NSObject *v182;
  SEL v183;
  uint64_t v184;
  SEL v185;
  void *v186;
  const char *v187;
  id v188;
  char v189;
  const char *v190;
  id v191;
  void *v192;
  void *v193;
  const char *v194;
  id v195;
  char v196;
  NSObject *v197;
  char v198;
  id v199;
  NEIKEv2IKEAuthPacket *v200;
  NSObject *v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  __CFString *v209;
  NEIKEv2GSPMPayload *v210;
  SEL v211;
  SEL v212;
  id v213;
  NSObject *v214;
  NEIKEv2AuthPayload *v215;
  SEL v216;
  NEIKEv2AuthenticationProtocol *v217;
  SEL v218;
  NSObject *v219;
  void *v220;
  NSObject *v221;
  SEL v222;
  uint64_t v223;
  SEL v224;
  void *v225;
  const char *v226;
  NSObject *v227;
  id v228;
  unsigned __int8 v229;
  int v230;
  const char *v231;
  id v232;
  void *v233;
  BOOL v234;
  NSObject *v235;
  void *v236;
  BOOL v237;
  const char *v238;
  id v239;
  char v240;
  NSObject *v241;
  NSObject *v242;
  void *v243;
  NSObject *v244;
  uint64_t v245;
  uint64_t v246;
  uint64_t v247;
  uint64_t v248;
  uint64_t v249;
  uint64_t v250;
  uint64_t v251;
  void *v252;
  const char *v253;
  const char *v254;
  id v255;
  uint64_t v256;
  uint64_t v257;
  uint64_t v258;
  uint64_t v259;
  uint64_t v260;
  uint64_t v261;
  uint64_t v262;
  void *v263;
  const char *v264;
  const char *v265;
  void *v266;
  const char *v267;
  id v268;
  uint64_t v269;
  uint64_t v270;
  uint64_t v271;
  uint64_t v272;
  uint64_t v273;
  uint64_t v274;
  uint64_t v275;
  void *v276;
  const char *v277;
  const char *v278;
  NSObject *v279;
  uint64_t v280;
  uint64_t v281;
  uint64_t v282;
  uint64_t v283;
  uint64_t v284;
  uint64_t v285;
  uint64_t v286;
  void *v287;
  NSObject *v288;
  id v289;
  const char *v290;
  uint64_t v291;
  uint64_t v292;
  uint64_t v293;
  uint64_t v294;
  uint64_t v295;
  uint64_t v296;
  void *v297;
  const char *v298;
  const char *v299;
  id v300;
  NSObject *v301;
  void *v302;
  const char *v303;
  id v304;
  void (**v305)(id, id);
  uint64_t v306;
  NSObject *v307;
  const char *v308;
  NSObject *v309;
  uint64_t v310;
  uint64_t v311;
  uint64_t v312;
  uint64_t v313;
  uint64_t v314;
  uint64_t v315;
  uint64_t v316;
  void *v317;
  void *v318;
  id v319;
  uint64_t v320;
  uint64_t v321;
  uint64_t v322;
  uint64_t v323;
  uint64_t v324;
  uint64_t v325;
  uint64_t v326;
  void *v327;
  const char *v328;
  const char *v329;
  const char *v330;
  NSObject *v331;
  id v332;
  const char *v333;
  const char *v334;
  NSObject *v335;
  SEL v336;
  id v337;
  uint64_t v338;
  uint64_t v339;
  uint64_t v340;
  uint64_t v341;
  uint64_t v342;
  uint64_t v343;
  uint64_t v344;
  void *v345;
  const char *v346;
  const char *v347;
  void *v348;
  uint64_t v349;
  NSObject *v350;
  const char *v351;
  NSObject *v352;
  uint64_t v353;
  uint64_t v354;
  uint64_t v355;
  uint64_t v356;
  uint64_t v357;
  uint64_t v358;
  uint64_t v359;
  id v360;
  uint64_t v361;
  uint64_t v362;
  uint64_t v363;
  uint64_t v364;
  uint64_t v365;
  uint64_t v366;
  uint64_t v367;
  void *ErrorFailedToSend;
  const char *v369;
  const char *v370;
  NSObject *v371;
  SEL v372;
  id v373;
  const char *v374;
  const char *v375;
  NSObject *v376;
  uint64_t v377;
  uint64_t v378;
  uint64_t v379;
  uint64_t v380;
  uint64_t v381;
  uint64_t v382;
  uint64_t v383;
  __CFString *v384;
  NSObject *v385;
  NSObject *v386;
  NSObject *v387;
  const char *v388;
  NSObject *v389;
  uint64_t v390;
  uint64_t v391;
  uint64_t v392;
  uint64_t v393;
  uint64_t v394;
  uint64_t v395;
  uint64_t v396;
  void *v397;
  NSObject *v398;
  uint64_t v399;
  uint64_t v400;
  uint64_t v401;
  uint64_t v402;
  uint64_t v403;
  uint64_t v404;
  uint64_t v405;
  void *v406;
  NSObject *v407;
  void *v408;
  NSObject *v409;
  uint64_t v410;
  void *v411;
  uint64_t v412;
  void *v413;
  id v414;
  id v415;
  void *v416;
  id *v417;
  NSObject *v418;
  _BYTE *v419;
  _BYTE *v420;
  NSObject *v421;
  id v422;
  __CFString *v423;
  __CFString *v424;
  NSObject *log;
  NSObject *loga;
  void (**v427)(id, id);
  _QWORD *v428;
  _QWORD *v429;
  _QWORD *v430;
  id self;
  NSObject *selfa;
  NEIKEv2EAP *obj;
  id obja;
  _QWORD v435[5];
  _BYTE *v436;
  void (**v437)(id, id);
  const char *v438;
  _QWORD v439[5];
  _BYTE *v440;
  void (**v441)(id, id);
  const char *v442;
  char v443;
  __int16 v444;
  __int128 v445;
  __int128 v446;
  __int128 v447;
  __int128 v448;
  _BYTE buf[12];
  __int16 v450;
  __CFString *v451;
  uint8_t v452[4];
  const char *v453;
  uint64_t v454;

  v454 = *MEMORY[0x1E0C80C00];
  v7 = a2;
  v8 = a3;
  v10 = a4;
  if (!a1)
    goto LABEL_210;
  v11 = objc_getProperty(a1, v9, 368, 1);
  dispatch_assert_queue_V2(v11);

  if (v8)
  {
    v13 = objc_getProperty(v8, v12, 136, 1);
    if (v13)
    {

LABEL_8:
      Property = objc_getProperty(v8, v15, 136, 1);
      goto LABEL_9;
    }
    v16 = objc_getProperty(v8, v14, 144, 1);
  }
  else
  {
    v16 = 0;
  }
  v17 = v16;

  if (!v17)
  {
    v10[2](v10, v8);
    goto LABEL_210;
  }
  if (v8)
    goto LABEL_8;
  Property = 0;
LABEL_9:
  v19 = Property;

  if (!v19)
  {
    if (v8)
      v44 = objc_getProperty(v8, v20, 144, 1);
    else
      v44 = 0;
    v45 = v44;

    if (!v45)
    {
      v71 = 0;
      v72 = "";
      goto LABEL_201;
    }
    v427 = v10;
    v46 = v7;
    v47 = v8;
    objc_opt_self();
    selfa = v46;
    obja = v47;
    if (v46)
    {
      if (v8)
      {
        if (-[NEIKEv2Packet hasErrors](v47, v48))
        {
          v420 = v7;
          v447 = 0u;
          v448 = 0u;
          v445 = 0u;
          v446 = 0u;
          v50 = objc_getProperty(v47, v49, 64, 1);
          v51 = objc_msgSend(v50, "countByEnumeratingWithState:objects:count:", &v445, v452, 16);
          if (v51)
          {
            v52 = v51;
            v53 = 0;
            v54 = *(_QWORD *)v446;
            v429 = a1;
            do
            {
              v55 = 0;
              do
              {
                if (*(_QWORD *)v446 != v54)
                  objc_enumerationMutation(v50);
                v56 = *(_QWORD *)(*((_QWORD *)&v445 + 1) + 8 * v55);
                if (v56 && (unint64_t)(*(_QWORD *)(v56 + 24) - 1) <= 0x3FFE)
                {
                  v57 = (__CFString *)-[NEIKEv2NotifyPayload copyError](*(const __CFString **)(*((_QWORD *)&v445 + 1)
                                                                                             + 8 * v55));

                  ne_log_obj();
                  v58 = objc_claimAutoreleasedReturnValue();
                  if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
                  {
                    v68 = (void *)objc_msgSend(obja, "copyShortDescription");
                    *(_DWORD *)buf = 138412546;
                    *(_QWORD *)&buf[4] = v68;
                    v450 = 2112;
                    v451 = v57;
                    _os_log_error_impl(&dword_19BD16000, v58, OS_LOG_TYPE_ERROR, "%@ Initiator auth GSPM received notify error: %@", buf, 0x16u);

                  }
                  if ((*(_QWORD *)(v56 + 24) & 0xFFFFFFFFFFFFE000) != 0x2000 || (BYTE2(selfa[2].isa) & 1) != 0)
                  {
LABEL_91:
                    ErrorPeerInvalidSyntax = v57;
                    v71 = 0;
                    loga = ErrorPeerInvalidSyntax;
                    v7 = v420;
                    a1 = v429;
                    v46 = selfa;
                    v47 = obja;
                    v101 = (id *)v50;
                    goto LABEL_184;
                  }
                  v47 = obja;
                  objc_getProperty(obja, v59, 128, 1);
                  v60 = objc_claimAutoreleasedReturnValue();
                  v62 = (void *)v60;
                  if (v60 && (v63 = *(id *)(v60 + 32)) != 0)
                  {

                    v53 = v57;
                  }
                  else
                  {
                    v64 = objc_getProperty(obja, v61, 144, 1);
                    v65 = v64;
                    if (v64)
                      v66 = (void *)*((_QWORD *)v64 + 3);
                    else
                      v66 = 0;
                    v67 = v66;

                    if (!v67)
                      goto LABEL_91;
                    v53 = v57;
                    v47 = obja;
                  }
                }
                ++v55;
              }
              while (v52 != v55);
              v69 = objc_msgSend(v50, "countByEnumeratingWithState:objects:count:", &v445, v452, 16);
              v52 = v69;
              a1 = v429;
            }
            while (v69);
          }
          else
          {
            v53 = 0;
          }

          v7 = v420;
        }
        else
        {
          v53 = 0;
        }
        v102 = objc_getProperty(v47, v49, 144, 1);
        v103 = v102;
        loga = v53;
        if (v102)
          v104 = (void *)*((_QWORD *)v102 + 3);
        else
          v104 = 0;
        v105 = v104;

        if (!v105)
        {
          ne_log_obj();
          v112 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v112, OS_LOG_TYPE_ERROR))
          {
            v243 = (void *)objc_msgSend(v47, "copyShortDescription");
            *(_DWORD *)buf = 138412290;
            *(_QWORD *)&buf[4] = v243;
            _os_log_error_impl(&dword_19BD16000, v112, OS_LOG_TYPE_ERROR, "%@ No GSPM data received", buf, 0xCu);

          }
          ErrorPeerInvalidSyntax = (__CFString *)NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("No GSPM data received"), v113, v114, v115, v116, v117, v118, v119, v410);
          v101 = 0;
          v71 = 0;
          v46 = selfa;
          goto LABEL_184;
        }
        v46 = selfa;
        v107 = (id *)objc_getProperty(selfa, v106, 456, 1);
        v101 = v107;
        if ((BYTE1(selfa[1].isa) & 1) == 0)
        {
          if (v107)
          {
LABEL_102:
            v111 = v101[2];
            goto LABEL_123;
          }
          v109 = -[NEIKEv2GSPM initWithIKESA:]((id *)[NEIKEv2GSPM alloc], selfa);
          if (v109)
          {
            v101 = v109;
            objc_setProperty_atomic(selfa, v110, v109, 456);
            goto LABEL_102;
          }
          ne_log_obj();
          v386 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v386, OS_LOG_TYPE_ERROR))
          {
            v408 = (void *)objc_msgSend(obja, "copyShortDescription");
            *(_DWORD *)buf = 138412290;
            *(_QWORD *)&buf[4] = v408;
            _os_log_error_impl(&dword_19BD16000, v386, OS_LOG_TYPE_ERROR, "%@ Failed to create GSPM handler", buf, 0xCu);

          }
          v384 = CFSTR("Failed to create GSPM handler");
LABEL_277:
          ErrorPeerInvalidSyntax = (__CFString *)NEIKEv2CreateErrorInternal(v384, v377, v378, v379, v380, v381, v382, v383, v410);
          v101 = 0;
          v71 = 0;
          v46 = selfa;
          v47 = obja;
          goto LABEL_184;
        }
        if (!v107)
        {
          ne_log_obj();
          v376 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v376, OS_LOG_TYPE_ERROR))
          {
            v406 = (void *)objc_msgSend(obja, "copyShortDescription");
            *(_DWORD *)buf = 138412290;
            *(_QWORD *)&buf[4] = v406;
            _os_log_error_impl(&dword_19BD16000, v376, OS_LOG_TYPE_ERROR, "%@ Initiator is missing GSPM handler", buf, 0xCu);

          }
          v384 = CFSTR("Initiator is missing GSPM handler");
          goto LABEL_277;
        }
        if ((BYTE1(selfa[2].isa) & 1) == 0)
        {
          if ((-[NEIKEv2IKEAuthPacket validateFirstAuthPayloadsForInitiator:](v47, selfa) & 1) == 0)
          {
            Error = NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("Initial AUTH payload validation failed"), v120, v121, v122, v123, v124, v125, v126, v410);
            goto LABEL_141;
          }
          if (-[NEIKEv2Packet hasNotification:](v47, (const char *)0x4017))
          {
            Error = NEIKEv2CreateError(5);
LABEL_141:
            ErrorPeerInvalidSyntax = (__CFString *)Error;
            v71 = 0;
LABEL_184:

            goto LABEL_185;
          }
        }
        v111 = 0;
LABEL_123:
        v416 = v111;
        BYTE1(selfa[2].isa) = 1;
        v145 = objc_getProperty(v47, v108, 144, 1);
        v146 = v145;
        if (v145)
          v147 = (void *)*((_QWORD *)v145 + 3);
        else
          v147 = 0;
        v155 = v147;
        if (v101[5])
        {
          if (v101[1])
          {
            ErrorInternal = (__CFString *)NEIKEv2CreateErrorInternal(CFSTR("Failed to process extraneous peer message"), v148, v149, v150, v151, v152, v153, v154, v410);
          }
          else
          {
            v161 = v101[3];
            *(_QWORD *)buf = 0;
            v162 = v161;
            objc_msgSend(v162, "processSecondPeerMessage:error:", v155, buf);
            v163 = objc_claimAutoreleasedReturnValue();
            v423 = (__CFString *)*(id *)buf;
            v164 = v101[1];
            v101[1] = (id)v163;

            if (v101[1])
            {
              v165 = v101[2];
              v101[2] = 0;

              ErrorInternal = 0;
              v46 = selfa;
            }
            else
            {
              v46 = selfa;
              ErrorInternal = v423;
            }
          }
        }
        else
        {
          v157 = v101[3];
          *(_QWORD *)buf = 0;
          v158 = v157;
          objc_msgSend(v158, "processFirstPeerMessage:error:", v155, buf);
          v159 = (void *)objc_claimAutoreleasedReturnValue();
          v422 = *(id *)buf;

          if (v159)
          {
            objc_storeStrong(v101 + 2, v159);
            objc_storeStrong(v101 + 5, v147);
            ErrorInternal = 0;
          }
          else
          {
            ErrorInternal = (__CFString *)v422;
          }
          v46 = selfa;

          v47 = obja;
        }

        v424 = ErrorInternal;
        if (ErrorInternal)
        {
          ne_log_obj();
          v352 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v352, OS_LOG_TYPE_ERROR))
          {
            v397 = (void *)objc_msgSend(obja, "copyShortDescription");
            *(_DWORD *)buf = 138412546;
            *(_QWORD *)&buf[4] = v397;
            v450 = 2112;
            v451 = v424;
            _os_log_error_impl(&dword_19BD16000, v352, OS_LOG_TYPE_ERROR, "%@ Failed to process GSPM message: %@", buf, 0x16u);

          }
          ErrorPeerInvalidSyntax = (__CFString *)NEIKEv2CreateErrorCrypto(CFSTR("Failed to process GSPM message"), v353, v354, v355, v356, v357, v358, v359, v410);
          v214 = 0;
          v71 = 0;
          v46 = selfa;
          v47 = obja;
          v199 = v416;
          goto LABEL_183;
        }
        v198 = BYTE1(v46[1].isa);
        if ((v198 & 1) != 0)
        {
          v199 = v101[2];

          v198 = BYTE1(v46[1].isa);
        }
        else
        {
          v199 = v416;
        }
        v200 = [NEIKEv2IKEAuthPacket alloc];
        if ((v198 & 1) != 0)
        {
          v71 = -[NEIKEv2Packet initOutbound](v200);
          if (!v71)
          {
            ne_log_obj();
            v385 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v385, OS_LOG_TYPE_FAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_fault_impl(&dword_19BD16000, v385, OS_LOG_TYPE_FAULT, "[[NEIKEv2IKEAuthPacket alloc] initOutbound] failed", buf, 2u);
            }

            v209 = CFSTR("[[NEIKEv2IKEAuthPacket alloc] initOutbound] failed");
            goto LABEL_270;
          }
        }
        else
        {
          v71 = -[NEIKEv2Packet initResponse:]((uint64_t)v200, v47);
          if (!v71)
          {
            ne_log_obj();
            v201 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v201, OS_LOG_TYPE_FAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_fault_impl(&dword_19BD16000, v201, OS_LOG_TYPE_FAULT, "[[NEIKEv2IKEAuthPacket alloc] initResponse:] failed", buf, 2u);
            }

            v209 = CFSTR("[[NEIKEv2IKEAuthPacket alloc] initResponse:] failed");
LABEL_270:
            ErrorPeerInvalidSyntax = (__CFString *)NEIKEv2CreateErrorInternal(v209, v202, v203, v204, v205, v206, v207, v208, v410);
            v214 = 0;
LABEL_173:
            v71 = 0;
            v46 = selfa;
            v47 = obja;
            goto LABEL_183;
          }
        }
        if (v199)
        {
          v210 = objc_alloc_init(NEIKEv2GSPMPayload);
          objc_setProperty_atomic(v71, v211, v210, 144);

          v213 = objc_getProperty(v71, v212, 144, 1);
          -[NEIKEv2GSPMPayload setGspmData:]((uint64_t)v213, v199);

          ErrorPeerInvalidSyntax = 0;
          v214 = 0;
LABEL_183:

          goto LABEL_184;
        }
        v417 = v101;
        v215 = objc_alloc_init(NEIKEv2AuthPayload);
        objc_setProperty_atomic(v71, v216, v215, 128);

        v217 = -[NEIKEv2AuthenticationProtocol initWithSecurePassword:]([NEIKEv2AuthenticationProtocol alloc], "initWithSecurePassword:", -1);
        objc_getProperty(v71, v218, 128, 1);
        v219 = v46;
        v220 = (void *)objc_claimAutoreleasedReturnValue();
        -[NEIKEv2AuthPayload setAuthProtocol:]((uint64_t)v220, v217);

        v221 = -[NEIKEv2IKESA createInitiatorGSPMAuthenticationDataUsingPrimeKey:](v219, 0);
        objc_getProperty(v71, v222, 128, 1);
        v223 = objc_claimAutoreleasedReturnValue();
        -[NEIKEv2AuthPayload setAuthenticationData:](v223, v221);

        objc_getProperty(v71, v224, 128, 1);
        v225 = (void *)objc_claimAutoreleasedReturnValue();
        LOBYTE(v223) = -[NEIKEv2Payload isValid]((uint64_t)v225);

        if ((v223 & 1) == 0)
        {
          ne_log_obj();
          v227 = objc_claimAutoreleasedReturnValue();
          v101 = v417;
          if (os_log_type_enabled(v227, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)buf = 136315138;
            *(_QWORD *)&buf[4] = "+[NEIKEv2IKEAuthPacket(Exchange) createGSPMForIKESA:lastPacket:refusalError:]";
            _os_log_fault_impl(&dword_19BD16000, v227, OS_LOG_TYPE_FAULT, "%s called with null responsePacket.auth.isValid", buf, 0xCu);
          }

          ErrorPeerInvalidSyntax = 0;
          v199 = 0;
          v214 = v71;
          goto LABEL_173;
        }
        v46 = v219;
        if (((uint64_t)v219[3].isa & 1) == 0)
        {
          ErrorPeerInvalidSyntax = 0;
          v214 = 0;
LABEL_169:
          v47 = obja;
          v101 = v417;
          goto LABEL_183;
        }
        v228 = objc_getProperty(v219, v226, 88, 1);
        v229 = objc_msgSend(v228, "ppkIDType");
        v230 = v229;

        HIBYTE(v444) = v229;
        if (v229)
        {
          v232 = objc_getProperty(v219, v231, 88, 1);
          objc_msgSend(v232, "ppkID");
          v233 = (void *)objc_claimAutoreleasedReturnValue();

          v234 = v230 == 2;
          v235 = v219;
          if (!v234 || v233)
          {
            v236 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99DF0]), "initWithCapacity:", objc_msgSend(v233, "length") + 1);
            objc_msgSend(v236, "appendBytes:length:", (char *)&v444 + 1, 1);
            v413 = v233;
            objc_msgSend(v236, "appendData:", v233);
            v411 = v236;
            v237 = -[NEIKEv2Packet addNotification:data:](v71, 0x4034uLL, v236);
            v101 = v417;
            if (v237)
            {
              v239 = objc_getProperty(v235, v238, 88, 1);
              v240 = objc_msgSend(v239, "ppkMandatory");

              v47 = obja;
              if ((v240 & 1) != 0)
              {
LABEL_182:

                ErrorPeerInvalidSyntax = 0;
                v214 = 0;
                v46 = selfa;
                goto LABEL_183;
              }
              v241 = -[NEIKEv2IKESA createInitiatorGSPMAuthenticationDataUsingPrimeKey:](selfa, (const char *)1);
              if (-[NEIKEv2Packet addNotification:data:](v71, 0x4035uLL, v241))
              {

                goto LABEL_182;
              }
              ne_log_obj();
              v398 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v398, OS_LOG_TYPE_FAULT))
              {
                *(_WORD *)buf = 0;
                _os_log_fault_impl(&dword_19BD16000, v398, OS_LOG_TYPE_FAULT, "[responsePacket addNotification:NEIKEv2NotifyTypeNoPPKAuth] failed", buf, 2u);
              }

              ErrorPeerInvalidSyntax = (__CFString *)NEIKEv2CreateErrorInternal(CFSTR("[responsePacket addNotification:NEIKEv2NotifyTypeNoPPKAuth] failed"), v399, v400, v401, v402, v403, v404, v405, v410);
            }
            else
            {
              ne_log_obj();
              v389 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v389, OS_LOG_TYPE_FAULT))
              {
                *(_WORD *)buf = 0;
                _os_log_fault_impl(&dword_19BD16000, v389, OS_LOG_TYPE_FAULT, "[responsePacket addNotification:NEIKEv2NotifyTypePPKIdentity] failed", buf, 2u);
              }

              ErrorPeerInvalidSyntax = (__CFString *)NEIKEv2CreateErrorInternal(CFSTR("[responsePacket addNotification:NEIKEv2NotifyTypePPKIdentity] failed"), v390, v391, v392, v393, v394, v395, v396, v410);
              v241 = 0;
            }

LABEL_291:
            v199 = 0;
            v214 = v71;
            v71 = 0;
            v46 = selfa;
            goto LABEL_169;
          }
          ne_log_obj();
          v387 = objc_claimAutoreleasedReturnValue();
          if (!os_log_type_enabled(v387, OS_LOG_TYPE_FAULT))
          {
LABEL_286:

            ErrorPeerInvalidSyntax = 0;
            goto LABEL_291;
          }
          *(_DWORD *)buf = 136315138;
          *(_QWORD *)&buf[4] = "+[NEIKEv2IKEAuthPacket(Exchange) createGSPMForIKESA:lastPacket:refusalError:]";
          v388 = "%s called with null ppkID";
        }
        else
        {
          ne_log_obj();
          v387 = objc_claimAutoreleasedReturnValue();
          if (!os_log_type_enabled(v387, OS_LOG_TYPE_FAULT))
            goto LABEL_286;
          *(_DWORD *)buf = 136315138;
          *(_QWORD *)&buf[4] = "+[NEIKEv2IKEAuthPacket(Exchange) createGSPMForIKESA:lastPacket:refusalError:]";
          v388 = "%s called with null ppkIDType";
        }
        _os_log_fault_impl(&dword_19BD16000, v387, OS_LOG_TYPE_FAULT, v388, buf, 0xCu);
        goto LABEL_286;
      }
      ne_log_obj();
      loga = objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(loga, OS_LOG_TYPE_FAULT))
      {
LABEL_244:
        ErrorPeerInvalidSyntax = 0;
        v71 = 0;
LABEL_185:

        if (v71)
        {

          v72 = "GSPM";
          v10 = v427;
          goto LABEL_201;
        }
        if (!v46 || (BYTE1(v46[1].isa) & 1) == 0)
        {
          ne_log_obj();
          v331 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v331, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)v452 = 138412290;
            v453 = (const char *)a1;
            _os_log_error_impl(&dword_19BD16000, v331, OS_LOG_TYPE_ERROR, "%@ Failed to process IKE Auth (GSPM) packet (receive)", v452, 0xCu);
          }

          v332 = +[NEIKEv2IKEAuthPacket createIKEAuthResponse:refusalError:]((uint64_t)NEIKEv2IKEAuthPacket, obja, 0x18uLL);
          if ((-[NEIKEv2Session sendReply:replyHandler:]((uint64_t)a1, v332, 0) & 1) != 0)
          {
            -[NEIKEv2IKESA setState:error:]((uint64_t)selfa, 3uLL, ErrorPeerInvalidSyntax);
            -[NEIKEv2Session reportState](a1, v334);
          }
          else
          {
            v360 = objc_getProperty(a1, v333, 336, 1);
            ErrorFailedToSend = (void *)NEIKEv2CreateErrorFailedToSend(CFSTR("GSPM refusal (receive) %@"), v361, v362, v363, v364, v365, v366, v367, (uint64_t)ErrorPeerInvalidSyntax);
            -[NEIKEv2IKESA setState:error:]((uint64_t)v360, 3uLL, ErrorFailedToSend);

            -[NEIKEv2Session reportState](a1, v369);
            -[NEIKEv2Session resetAll]((uint64_t)a1, v370);
          }

LABEL_263:
          v10 = v427;
          goto LABEL_210;
        }
        -[__CFString domain](ErrorPeerInvalidSyntax, "domain");
        v348 = (void *)objc_claimAutoreleasedReturnValue();
        if (objc_msgSend(v348, "isEqual:", CFSTR("NEIKEv2ErrorDomain")))
        {
          v349 = -[__CFString code](ErrorPeerInvalidSyntax, "code");

          if (v349 == 5)
          {
            ne_log_obj();
            v350 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v350, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)v452 = 138412290;
              v453 = (const char *)a1;
              _os_log_impl(&dword_19BD16000, v350, OS_LOG_TYPE_DEFAULT, "%@ Received server redirect in IKE Auth (GSPM) (connect)", v452, 0xCu);
            }

            -[NEIKEv2IKESA setState:error:]((uint64_t)selfa, 3uLL, ErrorPeerInvalidSyntax);
            -[NEIKEv2Session reportServerRedirect:](a1, obja);
            -[NEIKEv2Session resetAll]((uint64_t)a1, v351);
            v427[2](v427, 0);
            goto LABEL_263;
          }
        }
        else
        {

        }
        ne_log_obj();
        v371 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v371, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)v452 = 138412290;
          v453 = (const char *)a1;
          _os_log_error_impl(&dword_19BD16000, v371, OS_LOG_TYPE_ERROR, "%@ Failed to process IKE Auth (GSPM) packet (connect)", v452, 0xCu);
        }

        v373 = objc_getProperty(a1, v372, 336, 1);
        -[NEIKEv2IKESA setState:error:]((uint64_t)v373, 3uLL, ErrorPeerInvalidSyntax);

        -[NEIKEv2Session reportState](a1, v374);
        -[NEIKEv2Session resetAll]((uint64_t)a1, v375);
        goto LABEL_263;
      }
      *(_DWORD *)v452 = 136315138;
      v453 = "+[NEIKEv2IKEAuthPacket(Exchange) createGSPMForIKESA:lastPacket:refusalError:]";
      v330 = "%s called with null lastPacket";
    }
    else
    {
      ne_log_obj();
      loga = objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(loga, OS_LOG_TYPE_FAULT))
        goto LABEL_244;
      *(_DWORD *)v452 = 136315138;
      v453 = "+[NEIKEv2IKEAuthPacket(Exchange) createGSPMForIKESA:lastPacket:refusalError:]";
      v330 = "%s called with null ikeSA";
    }
    _os_log_fault_impl(&dword_19BD16000, loga, OS_LOG_TYPE_FAULT, v330, v452, 0xCu);
    goto LABEL_244;
  }
  if (!v7 || (v7[9] & 1) == 0)
  {
    ne_log_obj();
    v288 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v288, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)v452 = 138412290;
      v453 = (const char *)a1;
      _os_log_fault_impl(&dword_19BD16000, v288, OS_LOG_TYPE_FAULT, "%@ EAP is not supported by responder (receive)", v452, 0xCu);
    }

    v289 = +[NEIKEv2IKEAuthPacket createIKEAuthResponse:refusalError:]((uint64_t)NEIKEv2IKEAuthPacket, v8, 0x18uLL);
    if ((-[NEIKEv2Session sendReply:replyHandler:]((uint64_t)a1, v289, 0) & 1) != 0)
    {
      v297 = (void *)NEIKEv2CreateErrorInternal(CFSTR("EAP is not supported by responder (receive)"), (uint64_t)v290, v291, v292, v293, v294, v295, v296, v410);
      -[NEIKEv2IKESA setState:error:]((uint64_t)v7, 3uLL, v297);

      -[NEIKEv2Session reportState](a1, v298);
    }
    else
    {
      v319 = objc_getProperty(a1, v290, 336, 1);
      v327 = (void *)NEIKEv2CreateErrorFailedToSend(CFSTR("EAP unsupported refusal (receive)"), v320, v321, v322, v323, v324, v325, v326, v410);
      -[NEIKEv2IKESA setState:error:]((uint64_t)v319, 3uLL, v327);

      -[NEIKEv2Session reportState](a1, v328);
      -[NEIKEv2Session resetAll]((uint64_t)a1, v329);
    }

    goto LABEL_210;
  }
  v21 = v7;
  v22 = v8;
  v23 = objc_opt_self();
  self = v22;
  if ((v7[9] & 1) == 0)
  {
    ne_log_obj();
    v70 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v70, OS_LOG_TYPE_FAULT))
    {
LABEL_229:
      v71 = 0;
      goto LABEL_199;
    }
    *(_DWORD *)v452 = 136315138;
    v453 = "+[NEIKEv2IKEAuthPacket(Exchange) createEAPForInitiatorIKESA:lastResponderPacket:]";
    v299 = "%s called with null ikeSA.isInitiator";
LABEL_272:
    _os_log_fault_impl(&dword_19BD16000, v70, OS_LOG_TYPE_FAULT, v299, v452, 0xCu);
    goto LABEL_229;
  }
  if (!v8)
  {
    ne_log_obj();
    v70 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v70, OS_LOG_TYPE_FAULT))
      goto LABEL_229;
    *(_DWORD *)v452 = 136315138;
    v453 = "+[NEIKEv2IKEAuthPacket(Exchange) createEAPForInitiatorIKESA:lastResponderPacket:]";
    v299 = "%s called with null lastResponderPacket";
    goto LABEL_272;
  }
  v412 = v23;
  if (-[NEIKEv2Packet hasErrors](v22, v24))
  {
    v428 = a1;
    v414 = v8;
    v419 = v7;
    v447 = 0u;
    v448 = 0u;
    v445 = 0u;
    v446 = 0u;
    obj = (NEIKEv2EAP *)objc_getProperty(v22, v25, 64, 1);
    v26 = -[NEIKEv2EAP countByEnumeratingWithState:objects:count:](obj, "countByEnumeratingWithState:objects:count:", &v445, v452, 16);
    if (v26)
    {
      v27 = v26;
      v28 = 0;
      v29 = *(_QWORD *)v446;
      while (2)
      {
        for (i = 0; i != v27; ++i)
        {
          if (*(_QWORD *)v446 != v29)
            objc_enumerationMutation(obj);
          v31 = *(_QWORD *)(*((_QWORD *)&v445 + 1) + 8 * i);
          if (v31 && (unint64_t)(*(_QWORD *)(v31 + 24) - 1) <= 0x3FFE)
          {
            v32 = (__CFString *)-[NEIKEv2NotifyPayload copyError](*(const __CFString **)(*((_QWORD *)&v445 + 1) + 8 * i));

            ne_log_obj();
            v33 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
            {
              v43 = (void *)objc_msgSend(self, "copyShortDescription");
              *(_DWORD *)buf = 138412546;
              *(_QWORD *)&buf[4] = v43;
              v450 = 2112;
              v451 = v32;
              _os_log_error_impl(&dword_19BD16000, v33, OS_LOG_TYPE_ERROR, "%@ Initiator auth EAP received notify error: %@", buf, 0x16u);

            }
            if ((*(_QWORD *)(v31 + 24) & 0xFFFFFFFFFFFFE000) != 0x2000 || (BYTE2(v21[2].isa) & 1) != 0)
            {
LABEL_66:
              v70 = v32;
              -[NEIKEv2IKESA setState:error:]((uint64_t)v21, 3uLL, v32);
              v71 = 0;
              v8 = v414;
              v7 = v419;
              a1 = v428;
              v22 = self;
              goto LABEL_198;
            }
            objc_getProperty(self, v34, 128, 1);
            v35 = objc_claimAutoreleasedReturnValue();
            v37 = (void *)v35;
            if (v35 && (v38 = *(id *)(v35 + 32)) != 0)
            {

            }
            else
            {
              v39 = objc_getProperty(self, v36, 136, 1);
              v41 = v39;
              if (v39)
                v39 = objc_getProperty(v39, v40, 24, 1);
              v42 = v39;

              if (!v42)
                goto LABEL_66;
            }
            v28 = v32;
          }
        }
        v27 = -[NEIKEv2EAP countByEnumeratingWithState:objects:count:](obj, "countByEnumeratingWithState:objects:count:", &v445, v452, 16);
        if (v27)
          continue;
        break;
      }
    }
    else
    {
      v28 = 0;
    }

    log = v28;
    v8 = v414;
    v7 = v419;
    a1 = v428;
    v22 = self;
  }
  else
  {
    log = 0;
  }
  v73 = objc_getProperty(v22, v25, 136, 1);
  v75 = v73;
  if (v73)
    v73 = objc_getProperty(v73, v74, 24, 1);
  v76 = v73;

  if (!v76)
  {
    ne_log_obj();
    v91 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v91, OS_LOG_TYPE_ERROR))
    {
      v176 = (void *)objc_msgSend(self, "copyShortDescription");
      *(_DWORD *)buf = 138412290;
      *(_QWORD *)&buf[4] = v176;
      _os_log_error_impl(&dword_19BD16000, v91, OS_LOG_TYPE_ERROR, "%@ No EAP data received", buf, 0xCu);

    }
    obj = (NEIKEv2EAP *)NEIKEv2CreateErrorAuthentication(CFSTR("No EAP data received"), v92, v93, v94, v95, v96, v97, v98, v410);
    -[NEIKEv2IKESA setState:error:]((uint64_t)v21, 3uLL, obj);
    v71 = 0;
    v22 = self;
    goto LABEL_83;
  }
  v22 = self;
  obj = (NEIKEv2EAP *)objc_getProperty(v21, v77, 448, 1);
  if (obj)
    goto LABEL_76;
  if (-[NEIKEv2IKEAuthPacket validateFirstAuthPayloadsForInitiator:](self, v21))
  {
    if (!-[NEIKEv2Packet hasNotification:](self, (const char *)0x4017))
    {
      obj = objc_alloc_init(NEIKEv2EAP);
      objc_setProperty_atomic(v21, v160, obj, 448);
      BYTE1(v21[2].isa) = 1;
LABEL_76:
      v444 = 0;
      v79 = objc_getProperty(self, v78, 136, 1);
      v81 = v79;
      v430 = a1;
      if (v79)
        v79 = objc_getProperty(v79, v80, 24, 1);
      v82 = v79;
      -[NEIKEv2EAP createPayloadResponseForRequest:ikeSA:success:reportEAPError:]((uint64_t)obj, v82, v21, (BOOL *)&v444 + 1, (BOOL *)&v444);
      v83 = (void *)objc_claimAutoreleasedReturnValue();

      v70 = log;
      if (log)
      {
        -[NEIKEv2IKESA setState:error:]((uint64_t)v21, 3uLL, log);
        v71 = 0;
        v22 = self;
LABEL_197:

        a1 = v430;
        goto LABEL_198;
      }
      if (!HIBYTE(v444) && !v83)
      {
        v22 = self;
        if ((_BYTE)v444)
          ErrorAuthentication = (void *)NEIKEv2CreateError(10);
        else
          ErrorAuthentication = (void *)NEIKEv2CreateErrorAuthentication(CFSTR("EAP error"), v84, v85, v86, v87, v88, v89, v90, v410);
        v166 = ErrorAuthentication;
        -[NEIKEv2IKESA setState:error:]((uint64_t)v21, 3uLL, ErrorAuthentication);

        v71 = 0;
        v70 = 0;
        goto LABEL_197;
      }
      v128 = -[NEIKEv2Packet initOutbound]([NEIKEv2IKEAuthPacket alloc]);
      v22 = self;
      if (v128)
      {
        if (v83)
        {
          v129 = objc_alloc_init(NEIKEv2EAPPayload);
          objc_setProperty_atomic(v128, v130, v129, 136);

          v132 = objc_getProperty(v128, v131, 136, 1);
          v134 = v132;
          if (v132)
            objc_setProperty_atomic(v132, v133, v83, 24);

          if ((BYTE2(v21[2].isa) & 1) == 0
            || !-[NEIKEv2Packet hasNotification:](self, (const char *)0xA08D))
          {
            goto LABEL_152;
          }
          v421 = v128;
          ne_log_obj();
          v135 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v135, OS_LOG_TYPE_DEBUG))
          {
            v318 = (void *)objc_msgSend(self, "copyShortDescription");
            *(_DWORD *)buf = 138412290;
            *(_QWORD *)&buf[4] = v318;
            _os_log_debug_impl(&dword_19BD16000, v135, OS_LOG_TYPE_DEBUG, "%@ Received request for device identity notify payload.", buf, 0xCu);

          }
          v415 = objc_getProperty(v21, v136, 88, 1);
          objc_msgSend(v415, "IMEI");
          v137 = (void *)objc_claimAutoreleasedReturnValue();
          v139 = objc_getProperty(v21, v138, 88, 1);
          objc_msgSend(v139, "IMEISV");
          v140 = (void *)objc_claimAutoreleasedReturnValue();
          +[NEIKEv2IKEAuthPacket prepareDeviceIdentityNotifyPayload:IMEISV:lastResponderPacket:](v412, v137, v140, self);
          v141 = objc_claimAutoreleasedReturnValue();

          v142 = (void *)v141;
          v128 = v421;
          if (!v142
            || (v143 = +[NEIKEv2NotifyPayload createNotifyPayloadType:data:]((uint64_t)NEIKEv2NotifyPayload, 0xA08DuLL, v142), v144 = -[NEIKEv2Packet addNotifyPayload:](v421, v143), v143, v144))
          {

            v22 = self;
LABEL_152:
            v71 = v128;
            v70 = 0;
LABEL_196:

            goto LABEL_197;
          }
          ne_log_obj();
          v244 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v244, OS_LOG_TYPE_FAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_fault_impl(&dword_19BD16000, v244, OS_LOG_TYPE_FAULT, "[responsePacket addNotifyPayload:notifyPayload] failed", buf, 2u);
          }

          v252 = (void *)NEIKEv2CreateErrorInternal(CFSTR("[responsePacket addNotifyPayload:notifyPayload] failed"), v245, v246, v247, v248, v249, v250, v251, v410);
          -[NEIKEv2IKESA setState:error:]((uint64_t)v21, 3uLL, v252);

          goto LABEL_193;
        }
        v177 = objc_alloc_init(NEIKEv2AuthPayload);
        objc_setProperty_atomic(v128, v178, v177, 128);

        v179 = -[NEIKEv2AuthenticationProtocol initWithMethod:]([NEIKEv2AuthenticationProtocol alloc], "initWithMethod:", 2);
        objc_getProperty(v128, v180, 128, 1);
        v181 = (void *)objc_claimAutoreleasedReturnValue();
        -[NEIKEv2AuthPayload setAuthProtocol:]((uint64_t)v181, v179);

        v182 = -[NEIKEv2IKESA createInitiatorEAPAuthenticationDataUsingPrimeKey:](v21, 0);
        objc_getProperty(v128, v183, 128, 1);
        v184 = objc_claimAutoreleasedReturnValue();
        -[NEIKEv2AuthPayload setAuthenticationData:](v184, v182);

        objc_getProperty(v128, v185, 128, 1);
        v186 = (void *)objc_claimAutoreleasedReturnValue();
        LOBYTE(v184) = -[NEIKEv2Payload isValid]((uint64_t)v186);

        if ((v184 & 1) == 0)
        {
          v421 = v128;
          ne_log_obj();
          v242 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v242, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)buf = 136315138;
            *(_QWORD *)&buf[4] = "+[NEIKEv2IKEAuthPacket(Exchange) createEAPForInitiatorIKESA:lastResponderPacket:]";
            _os_log_fault_impl(&dword_19BD16000, v242, OS_LOG_TYPE_FAULT, "%s called with null responsePacket.auth.isValid", buf, 0xCu);
          }

LABEL_193:
          v71 = 0;
LABEL_194:
          v22 = self;
          goto LABEL_195;
        }
        v22 = self;
        if (((uint64_t)v21[3].isa & 1) == 0)
          goto LABEL_152;
        v421 = v128;
        v188 = objc_getProperty(v21, v187, 88, 1);
        v189 = objc_msgSend(v188, "ppkIDType");

        v443 = v189;
        if (!v189)
        {
          ne_log_obj();
          v407 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v407, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)buf = 136315138;
            *(_QWORD *)&buf[4] = "+[NEIKEv2IKEAuthPacket(Exchange) createEAPForInitiatorIKESA:lastResponderPacket:]";
            _os_log_fault_impl(&dword_19BD16000, v407, OS_LOG_TYPE_FAULT, "%s called with null ppkIDType", buf, 0xCu);
          }

          v71 = 0;
          v22 = self;
          goto LABEL_195;
        }
        v191 = objc_getProperty(v21, v190, 88, 1);
        objc_msgSend(v191, "ppkID");
        v192 = (void *)objc_claimAutoreleasedReturnValue();

        if (v189 == 2 && !v192)
        {
          ne_log_obj();
          v409 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v409, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)buf = 136315138;
            *(_QWORD *)&buf[4] = "+[NEIKEv2IKEAuthPacket(Exchange) createEAPForInitiatorIKESA:lastResponderPacket:]";
            _os_log_fault_impl(&dword_19BD16000, v409, OS_LOG_TYPE_FAULT, "%s called with null ppkID", buf, 0xCu);
          }

          v71 = 0;
          goto LABEL_194;
        }
        v193 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99DF0]), "initWithCapacity:", objc_msgSend(v192, "length") + 1);
        objc_msgSend(v193, "appendBytes:length:", &v443, 1);
        objc_msgSend(v193, "appendData:", v192);
        if (-[NEIKEv2Packet addNotification:data:](v421, 0x4034uLL, v193))
        {
          v195 = objc_getProperty(v21, v194, 88, 1);
          v196 = objc_msgSend(v195, "ppkMandatory");

          if ((v196 & 1) != 0)
          {
LABEL_151:

            v22 = self;
            v128 = v421;
            goto LABEL_152;
          }
          v197 = -[NEIKEv2IKESA createInitiatorEAPAuthenticationDataUsingPrimeKey:](v21, (const char *)1);
          if (-[NEIKEv2Packet addNotification:data:](v421, 0x4035uLL, v197))
          {

            goto LABEL_151;
          }
          v418 = v197;
          ne_log_obj();
          v309 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v309, OS_LOG_TYPE_FAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_fault_impl(&dword_19BD16000, v309, OS_LOG_TYPE_FAULT, "[responsePacket addNotification:NEIKEv2NotifyTypeNoPPKAuth] failed", buf, 2u);
          }

          v317 = (void *)NEIKEv2CreateErrorInternal(CFSTR("[responsePacket addNotification:NEIKEv2NotifyTypeNoPPKAuth] failed"), v310, v311, v312, v313, v314, v315, v316, v410);
          -[NEIKEv2IKESA setState:error:]((uint64_t)v21, 3uLL, v317);

          v22 = self;
          v287 = v418;
        }
        else
        {
          ne_log_obj();
          v279 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v279, OS_LOG_TYPE_FAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_fault_impl(&dword_19BD16000, v279, OS_LOG_TYPE_FAULT, "[responsePacket addNotification:NEIKEv2NotifyTypePPKIdentity] failed", buf, 2u);
          }

          v287 = (void *)NEIKEv2CreateErrorInternal(CFSTR("[responsePacket addNotification:NEIKEv2NotifyTypePPKIdentity] failed"), v280, v281, v282, v283, v284, v285, v286, v410);
          -[NEIKEv2IKESA setState:error:]((uint64_t)v21, 3uLL, v287);
          v22 = self;
        }

      }
      else
      {
        v421 = 0;
        ne_log_obj();
        v167 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v167, OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_fault_impl(&dword_19BD16000, v167, OS_LOG_TYPE_FAULT, "[[NEIKEv2IKEAuthPacket alloc] initOutbound:] failed", buf, 2u);
        }

        v175 = (void *)NEIKEv2CreateErrorInternal(CFSTR("[[NEIKEv2IKEAuthPacket alloc] initOutbound:] failed"), v168, v169, v170, v171, v172, v173, v174, v410);
        -[NEIKEv2IKESA setState:error:]((uint64_t)v21, 3uLL, v175);

      }
      v71 = 0;
LABEL_195:
      v128 = v421;
      v70 = 0;
      goto LABEL_196;
    }
    obj = (NEIKEv2EAP *)NEIKEv2CreateError(5);
    -[NEIKEv2IKESA setState:error:]((uint64_t)v21, 3uLL, obj);
    v71 = 0;
LABEL_83:
    v70 = log;
LABEL_198:

    goto LABEL_199;
  }
  v71 = 0;
  v70 = log;
LABEL_199:

  if (v71)
  {
    v72 = "EAP";
LABEL_201:
    if (v7 && (v7[9] & 1) != 0)
    {
      v439[0] = MEMORY[0x1E0C809B0];
      v439[1] = 3221225472;
      v439[2] = __72__NEIKEv2Session_Exchange__handleEAPAndGSPMForIKESA_authPacket_handler___block_invoke;
      v439[3] = &unk_1E3CC0F50;
      v439[4] = a1;
      v442 = v72;
      v440 = v7;
      v441 = v10;
      if (-[NEIKEv2Session sendRequest:retry:replyHandler:]((uint64_t)a1, v71, v439) == -1)
      {
        v268 = objc_getProperty(a1, v267, 336, 1);
        v276 = (void *)NEIKEv2CreateErrorFailedToSend(CFSTR("%s response (connect)"), v269, v270, v271, v272, v273, v274, v275, (uint64_t)v72);
        -[NEIKEv2IKESA setState:error:]((uint64_t)v268, 3uLL, v276);

        -[NEIKEv2Session reportState](a1, v277);
        -[NEIKEv2Session resetAll]((uint64_t)a1, v278);
      }

      v266 = v440;
    }
    else
    {
      v435[0] = MEMORY[0x1E0C809B0];
      v435[1] = 3221225472;
      v435[2] = __72__NEIKEv2Session_Exchange__handleEAPAndGSPMForIKESA_authPacket_handler___block_invoke_119;
      v435[3] = &unk_1E3CC0F50;
      v435[4] = a1;
      v438 = v72;
      v436 = v7;
      v437 = v10;
      if ((-[NEIKEv2Session sendReply:replyHandler:]((uint64_t)a1, v71, v435) & 1) == 0)
      {
        v255 = objc_getProperty(a1, v254, 336, 1);
        v263 = (void *)NEIKEv2CreateErrorFailedToSend(CFSTR("%s response (receive)"), v256, v257, v258, v259, v260, v261, v262, (uint64_t)v72);
        -[NEIKEv2IKESA setState:error:]((uint64_t)v255, 3uLL, v263);

        -[NEIKEv2Session reportState](a1, v264);
        -[NEIKEv2Session resetAll]((uint64_t)a1, v265);
      }

      v266 = v436;
    }

    goto LABEL_210;
  }
  if (v21[6].isa != (Class)3)
    goto LABEL_246;
  v300 = objc_getProperty(v21, v253, 56, 1);
  objc_msgSend(v300, "domain");
  v301 = v21;
  v302 = (void *)objc_claimAutoreleasedReturnValue();
  if ((objc_msgSend(v302, "isEqual:", CFSTR("NEIKEv2ErrorDomain")) & 1) == 0)
  {

LABEL_246:
    ne_log_obj();
    v335 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v335, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v452 = 138412290;
      v453 = (const char *)a1;
      _os_log_error_impl(&dword_19BD16000, v335, OS_LOG_TYPE_ERROR, "%@ Failed to process IKE Auth (EAP) packet (connect)", v452, 0xCu);
    }

    v337 = objc_getProperty(a1, v336, 336, 1);
    v345 = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("Failed to process IKE Auth (EAP) packet (connect)"), v338, v339, v340, v341, v342, v343, v344, v410);
    -[NEIKEv2IKESA setState:error:]((uint64_t)v337, 3uLL, v345);

    -[NEIKEv2Session reportState](a1, v346);
    -[NEIKEv2Session resetAll]((uint64_t)a1, v347);
    goto LABEL_210;
  }
  v304 = objc_getProperty(v301, v303, 56, 1);
  v305 = v10;
  v306 = objc_msgSend(v304, "code");

  v234 = v306 == 5;
  v10 = v305;
  if (!v234)
    goto LABEL_246;
  ne_log_obj();
  v307 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v307, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)v452 = 138412290;
    v453 = (const char *)a1;
    _os_log_impl(&dword_19BD16000, v307, OS_LOG_TYPE_DEFAULT, "%@ Received server redirect in IKE Auth (EAP) (connect)", v452, 0xCu);
  }

  -[NEIKEv2Session reportServerRedirect:](a1, self);
  -[NEIKEv2Session resetAll]((uint64_t)a1, v308);
  v305[2](v305, 0);
LABEL_210:

}

void __72__NEIKEv2Session_Exchange__handleEAPAndGSPMForIKESA_authPacket_handler___block_invoke(uint64_t *a1, void *a2)
{
  id v3;
  NSObject *v4;
  const char *v5;
  id Property;
  id v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void *ErrorPeerInvalidSyntax;
  const char *v16;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  uint8_t buf[4];
  uint64_t v21;
  __int16 v22;
  uint64_t v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    -[NEIKEv2Session handleEAPAndGSPMForIKESA:authPacket:handler:](a1[4], a1[5], v3, a1[6]);
  }
  else
  {
    ne_log_obj();
    v4 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v18 = a1[4];
      v19 = a1[7];
      *(_DWORD *)buf = 138412546;
      v21 = v18;
      v22 = 2080;
      v23 = v19;
      _os_log_error_impl(&dword_19BD16000, v4, OS_LOG_TYPE_ERROR, "%@ Failed to receive IKE Auth (%s) reply (connect)", buf, 0x16u);
    }

    Property = (id)a1[4];
    if (Property)
      Property = objc_getProperty(Property, v5, 336, 1);
    v7 = Property;
    ErrorPeerInvalidSyntax = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("Failed to receive IKE Auth (%s) reply (connect)"), v8, v9, v10, v11, v12, v13, v14, a1[7]);
    -[NEIKEv2IKESA setState:error:]((uint64_t)v7, 3uLL, ErrorPeerInvalidSyntax);

    -[NEIKEv2Session reportState]((_QWORD *)a1[4], v16);
    -[NEIKEv2Session resetAll](a1[4], v17);
  }

}

void __72__NEIKEv2Session_Exchange__handleEAPAndGSPMForIKESA_authPacket_handler___block_invoke_119(uint64_t *a1, void *a2)
{
  id v3;
  NSObject *v4;
  const char *v5;
  id Property;
  id v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void *ErrorPeerInvalidSyntax;
  const char *v16;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  uint8_t buf[4];
  uint64_t v21;
  __int16 v22;
  uint64_t v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    -[NEIKEv2Session handleEAPAndGSPMForIKESA:authPacket:handler:](a1[4], a1[5], v3, a1[6]);
  }
  else
  {
    ne_log_obj();
    v4 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v18 = a1[4];
      v19 = a1[7];
      *(_DWORD *)buf = 138412546;
      v21 = v18;
      v22 = 2080;
      v23 = v19;
      _os_log_error_impl(&dword_19BD16000, v4, OS_LOG_TYPE_ERROR, "%@ Failed to receive IKE Auth (%s) reply (receive)", buf, 0x16u);
    }

    Property = (id)a1[4];
    if (Property)
      Property = objc_getProperty(Property, v5, 336, 1);
    v7 = Property;
    ErrorPeerInvalidSyntax = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("Failed to receive IKE Auth (%s) reply (receive)"), v8, v9, v10, v11, v12, v13, v14, a1[7]);
    -[NEIKEv2IKESA setState:error:]((uint64_t)v7, 3uLL, ErrorPeerInvalidSyntax);

    -[NEIKEv2Session reportState]((_QWORD *)a1[4], v16);
    -[NEIKEv2Session resetAll](a1[4], v17);
  }

}

void __43__NEIKEv2Session_Exchange__initiateConnect__block_invoke(uint64_t a1, void *a2)
{
  id v3;
  const char *v4;
  uint64_t v5;
  _QWORD *v6;
  id v7;
  void *v8;
  const char *v9;
  id v10;
  id v11;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  const char *v15;
  NSObject *v16;
  const char *v17;
  id Property;
  id v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  void *ErrorPeerInvalidSyntax;
  const char *v28;
  void *v29;
  _QWORD *v30;
  id v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  _QWORD v35[5];
  id v36;
  uint64_t v37;
  uint8_t buf[4];
  uint64_t v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    ne_log_obj();
    v16 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      v33 = *(_QWORD *)(a1 + 32);
      *(_DWORD *)buf = 138412290;
      v39 = v33;
      _os_log_error_impl(&dword_19BD16000, v16, OS_LOG_TYPE_ERROR, "%@ Failed to receive IKE SA Init reply (connect)", buf, 0xCu);
    }

    Property = *(id *)(a1 + 32);
    if (Property)
      Property = objc_getProperty(Property, v17, 336, 1);
    v19 = Property;
    ErrorPeerInvalidSyntax = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("Failed to receive IKE SA Init reply (connect)"), v20, v21, v22, v23, v24, v25, v26, v34);
    -[NEIKEv2IKESA setState:error:]((uint64_t)v19, 3uLL, ErrorPeerInvalidSyntax);

    -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 32), v28);
    goto LABEL_17;
  }
  v5 = -[NEIKEv2IKESAInitPacket validateSAInitAsInitiator:]((uint64_t)v3, *(void **)(a1 + 40));
  if ((v5 & 1) != 0 || (v6 = *(_QWORD **)(a1 + 40)) == 0 || v6[6] != 3)
  {
LABEL_19:
    v30 = *(_QWORD **)(a1 + 32);
    v29 = *(void **)(a1 + 40);
    v35[0] = MEMORY[0x1E0C809B0];
    v35[1] = 3221225472;
    v35[2] = __43__NEIKEv2Session_Exchange__initiateConnect__block_invoke_136;
    v35[3] = &unk_1E3CC0FF0;
    v35[4] = v30;
    v31 = v29;
    v32 = *(_QWORD *)(a1 + 48);
    v36 = v31;
    v37 = v32;
    -[NEIKEv2Session retryCookieForIKESA:validated:handler:](v30, v31, v5, v35);

    goto LABEL_20;
  }
  v7 = objc_getProperty(v6, v4, 56, 1);
  objc_msgSend(v7, "domain");
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  if ((objc_msgSend(v8, "isEqual:", CFSTR("NEIKEv2ErrorDomain")) & 1) == 0)
  {

    goto LABEL_19;
  }
  v10 = *(id *)(a1 + 40);
  if (v10)
    v10 = objc_getProperty(v10, v9, 56, 1);
  v11 = v10;
  v12 = objc_msgSend(v11, "code");

  if (v12 != 5)
    goto LABEL_19;
  ne_log_obj();
  v13 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    v14 = *(_QWORD *)(a1 + 32);
    *(_DWORD *)buf = 138412290;
    v39 = v14;
    _os_log_impl(&dword_19BD16000, v13, OS_LOG_TYPE_DEFAULT, "%@ Received server redirect in IKE SA Init (connect)", buf, 0xCu);
  }

  -[NEIKEv2Session reportServerRedirect:](*(void **)(a1 + 32), v3);
LABEL_17:
  -[NEIKEv2Session resetAll](*(_QWORD *)(a1 + 32), v15);
LABEL_20:

}

void __43__NEIKEv2Session_Exchange__initiateConnect__block_invoke_136(_QWORD *a1, uint64_t a2)
{
  void *v4;
  _QWORD *v5;
  id v6;
  uint64_t v7;
  id v8;
  const char *v9;
  _QWORD *v10;
  NSObject *v11;
  const char *v12;
  id v13;
  id v14;
  const char *v15;
  const char *v16;
  NSObject *v17;
  const char *v18;
  id Property;
  id v20;
  uint64_t v21;
  const char *v22;
  id v23;
  id v24;
  const char *v25;
  uint64_t v26;
  id v27;
  id v28;
  id v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t i;
  void *v34;
  void *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  NSObject *v40;
  const char *v41;
  SEL v42;
  const char *v43;
  id v44;
  id v45;
  id ErrorCrypto;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  void *ErrorPeerInvalidSyntax;
  const char *v56;
  void *v57;
  const char *v58;
  id v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  void *ErrorFailedToSend;
  const char *v68;
  const char *v69;
  NSObject *v70;
  SEL v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  const char *v79;
  const char *v80;
  NSObject *v81;
  SEL v82;
  id v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  void *ErrorInternal;
  const char *v92;
  const char *v93;
  id v94;
  id v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  _QWORD *v99;
  id v100;
  void *v101;
  _QWORD v102[2];
  void (*v103)(_QWORD *, uint64_t);
  void *v104;
  _QWORD *v105;
  id v106;
  uint64_t v107;
  __int128 v108;
  __int128 v109;
  __int128 v110;
  __int128 v111;
  __int128 v112;
  __int128 v113;
  __int128 v114;
  __int128 v115;
  uint8_t v116[128];
  _BYTE buf[24];
  void *v118;
  _QWORD *v119;
  id v120;
  _QWORD *v121;
  uint64_t v122;

  v122 = *MEMORY[0x1E0C80C00];
  v5 = (_QWORD *)a1[4];
  v4 = (void *)a1[5];
  v102[0] = MEMORY[0x1E0C809B0];
  v102[1] = 3221225472;
  v103 = __43__NEIKEv2Session_Exchange__initiateConnect__block_invoke_2;
  v104 = &unk_1E3CC0FF0;
  v105 = v5;
  v6 = v4;
  v7 = a1[6];
  v106 = v6;
  v107 = v7;
  v8 = v6;
  v10 = v102;
  if (v5)
  {
    v11 = objc_getProperty(v5, v9, 368, 1);
    dispatch_assert_queue_V2(v11);

    if ((a2 & 1) != 0
      || (!v8 ? (v13 = 0) : (v13 = objc_getProperty(v8, v12, 144, 1)),
          v14 = v13,
          v14,
          !v14))
    {
      v103(v10, a2);
    }
    else
    {
      -[NEIKEv2Session resetMessages](v5, v15);
      if (v8)
        objc_setProperty_atomic(v8, v16, 0, 160);
      ne_log_obj();
      v17 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
      {
        if (v8)
          Property = objc_getProperty(v8, v18, 144, 1);
        else
          Property = 0;
        v20 = Property;
        v21 = objc_msgSend(v20, "method");
        *(_DWORD *)buf = 138412546;
        *(_QWORD *)&buf[4] = v5;
        *(_WORD *)&buf[12] = 2048;
        *(_QWORD *)&buf[14] = v21;
        _os_log_impl(&dword_19BD16000, v17, OS_LOG_TYPE_INFO, "%@ Received KE method preference %tu, retrying IKE SA Init (connect retry KE)", buf, 0x16u);

      }
      if (v8)
        v23 = objc_getProperty(v8, v22, 144, 1);
      else
        v23 = 0;
      v24 = v23;
      v26 = objc_msgSend(v24, "method");
      v101 = v24;
      if (v8)
        v27 = objc_getProperty(v8, v25, 80, 1);
      else
        v27 = 0;
      v100 = v27;
      objc_msgSend(v100, "proposals");
      v28 = (id)objc_claimAutoreleasedReturnValue();
      objc_opt_self();
      v112 = 0u;
      v113 = 0u;
      v114 = 0u;
      v115 = 0u;
      v29 = v28;
      v30 = objc_msgSend(v29, "countByEnumeratingWithState:objects:count:", &v112, buf, 16);
      if (v30)
      {
        v31 = v30;
        v32 = *(_QWORD *)v113;
        v98 = *(_QWORD *)v113;
        v99 = v10;
        while (2)
        {
          for (i = 0; i != v31; ++i)
          {
            if (*(_QWORD *)v113 != v32)
              objc_enumerationMutation(v29);
            v34 = *(void **)(*((_QWORD *)&v112 + 1) + 8 * i);
            v108 = 0u;
            v109 = 0u;
            v110 = 0u;
            v111 = 0u;
            objc_msgSend(v34, "kemProtocols");
            v35 = (void *)objc_claimAutoreleasedReturnValue();
            v36 = objc_msgSend(v35, "countByEnumeratingWithState:objects:count:", &v108, v116, 16);
            if (v36)
            {
              v37 = v36;
              v38 = *(_QWORD *)v109;
LABEL_23:
              v39 = 0;
              while (1)
              {
                if (*(_QWORD *)v109 != v38)
                  objc_enumerationMutation(v35);
                if (objc_msgSend(*(id *)(*((_QWORD *)&v108 + 1) + 8 * v39), "method") == v26)
                  break;
                if (v37 == ++v39)
                {
                  v37 = objc_msgSend(v35, "countByEnumeratingWithState:objects:count:", &v108, v116, 16);
                  if (v37)
                    goto LABEL_23;
                  goto LABEL_29;
                }
              }

              if ((-[NEIKEv2IKESA generateInitialValues](v8, v56) & 1) != 0)
              {
                +[NEIKEv2IKESAInitPacket createIKESAInitForInitiatorIKESA:]((uint64_t)NEIKEv2IKESAInitPacket, v8);
                v57 = (void *)objc_claimAutoreleasedReturnValue();
                v10 = v99;
                if (v57)
                {
                  *(_QWORD *)buf = MEMORY[0x1E0C809B0];
                  *(_QWORD *)&buf[8] = 3221225472;
                  *(_QWORD *)&buf[16] = __62__NEIKEv2Session_Exchange__retryKEForIKESA_validated_handler___block_invoke;
                  v118 = &unk_1E3CC0F00;
                  v119 = v5;
                  v120 = v8;
                  v121 = v99;
                  if (-[NEIKEv2Session sendRequest:retry:replyHandler:]((uint64_t)v5, v57, buf) == -1)
                  {
                    v59 = objc_getProperty(v5, v58, 336, 1);
                    ErrorFailedToSend = (void *)NEIKEv2CreateErrorFailedToSend(CFSTR("retry SA INIT KE"), v60, v61, v62, v63, v64, v65, v66, v97);
                    -[NEIKEv2IKESA setState:error:]((uint64_t)v59, 3uLL, ErrorFailedToSend);

                    -[NEIKEv2Session reportState](v5, v68);
                    -[NEIKEv2Session resetAll]((uint64_t)v5, v69);
                  }

                }
                else
                {
                  ne_log_obj();
                  v81 = objc_claimAutoreleasedReturnValue();
                  if (os_log_type_enabled(v81, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)buf = 138412290;
                    *(_QWORD *)&buf[4] = v5;
                    _os_log_error_impl(&dword_19BD16000, v81, OS_LOG_TYPE_ERROR, "%@ Failed to create IKE SA Init retry packet (connect retry KE)", buf, 0xCu);
                  }

                  v83 = objc_getProperty(v5, v82, 336, 1);
                  ErrorInternal = (void *)NEIKEv2CreateErrorInternal(CFSTR("Failed to create IKE SA Init retry packet (connect retry KE)"), v84, v85, v86, v87, v88, v89, v90, v97);
                  -[NEIKEv2IKESA setState:error:]((uint64_t)v83, 3uLL, ErrorInternal);

                  -[NEIKEv2Session reportState](v5, v92);
                  -[NEIKEv2Session resetAll]((uint64_t)v5, v93);
                }

                goto LABEL_49;
              }
              ne_log_obj();
              v70 = objc_claimAutoreleasedReturnValue();
              v10 = v99;
              if (os_log_type_enabled(v70, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 138412290;
                *(_QWORD *)&buf[4] = v5;
                _os_log_error_impl(&dword_19BD16000, v70, OS_LOG_TYPE_ERROR, "%@ Failed to generate local crypto values (connect retry KE)", buf, 0xCu);
              }

              v44 = objc_getProperty(v5, v71, 336, 1);
              ErrorCrypto = (id)NEIKEv2CreateErrorCrypto(CFSTR("Failed to generate local crypto values (connect retry KE)"), v72, v73, v74, v75, v76, v77, v78, v97);
              -[NEIKEv2IKESA setState:error:]((uint64_t)v44, 3uLL, ErrorCrypto);
              goto LABEL_44;
            }
LABEL_29:

            v32 = v98;
          }
          v31 = objc_msgSend(v29, "countByEnumeratingWithState:objects:count:", &v112, buf, 16);
          v10 = v99;
          if (v31)
            continue;
          break;
        }
      }

      ne_log_obj();
      v40 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
      {
        if (v8)
          v94 = objc_getProperty(v8, v41, 144, 1);
        else
          v94 = 0;
        v95 = v94;
        v96 = objc_msgSend(v95, "method");
        *(_DWORD *)buf = 138412546;
        *(_QWORD *)&buf[4] = v5;
        *(_WORD *)&buf[12] = 2048;
        *(_QWORD *)&buf[14] = v96;
        _os_log_error_impl(&dword_19BD16000, v40, OS_LOG_TYPE_ERROR, "%@ Received KE method preference %tu is not in config (connect retry KE)", buf, 0x16u);

      }
      v44 = objc_getProperty(v5, v42, 336, 1);
      if (v8)
        v45 = objc_getProperty(v8, v43, 144, 1);
      else
        v45 = 0;
      ErrorCrypto = v45;
      v47 = objc_msgSend(ErrorCrypto, "method");
      ErrorPeerInvalidSyntax = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("Received KE method preference %tu is not in config (connect retry KE)"), v48, v49, v50, v51, v52, v53, v54, v47);
      -[NEIKEv2IKESA setState:error:]((uint64_t)v44, 3uLL, ErrorPeerInvalidSyntax);

LABEL_44:
      -[NEIKEv2Session reportState](v5, v79);
      -[NEIKEv2Session resetAll]((uint64_t)v5, v80);
    }
  }
LABEL_49:

}

void __43__NEIKEv2Session_Exchange__initiateConnect__block_invoke_2(_QWORD *a1, uint64_t a2)
{
  void *v4;
  _QWORD *v5;
  id v6;
  uint64_t v7;
  _QWORD v8[5];
  id v9;
  uint64_t v10;

  v5 = (_QWORD *)a1[4];
  v4 = (void *)a1[5];
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 3221225472;
  v8[2] = __43__NEIKEv2Session_Exchange__initiateConnect__block_invoke_3;
  v8[3] = &unk_1E3CC0FF0;
  v8[4] = v5;
  v6 = v4;
  v7 = a1[6];
  v9 = v6;
  v10 = v7;
  -[NEIKEv2Session retryCookieForIKESA:validated:handler:](v5, v6, a2, v8);

}

void __43__NEIKEv2Session_Exchange__initiateConnect__block_invoke_3(uint64_t *a1, const char *a2)
{
  void *v3;
  const char *v4;
  uint64_t v5;
  uint64_t v6;
  char v7;
  const char *v8;
  NSObject *v9;
  const char *v10;
  id Property;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  id v19;
  __CFString *v20;
  void *ErrorPeerInvalidSyntax;
  NSObject *v22;
  const char *v23;
  id v24;
  uint64_t v25;
  void *v26;
  void *v27;
  _QWORD *v28;
  id v29;
  uint64_t v30;
  NSObject *v31;
  const char *v32;
  id v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  void *v41;
  const char *v42;
  const char *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  _QWORD v48[4];
  id v49;
  uint64_t v50;
  uint64_t v51;
  uint8_t buf[4];
  uint64_t v53;
  uint64_t v54;

  v54 = *MEMORY[0x1E0C80C00];
  if ((a2 & 1) == 0)
  {
    ne_log_obj();
    v9 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      v44 = a1[4];
      *(_DWORD *)buf = 138412290;
      v53 = v44;
      _os_log_error_impl(&dword_19BD16000, v9, OS_LOG_TYPE_ERROR, "%@ Failed to process IKE SA Init packet (connect)", buf, 0xCu);
    }

    Property = (id)a1[4];
    if (Property)
      Property = objc_getProperty(Property, v10, 336, 1);
    v19 = Property;
    v20 = CFSTR("Failed to process IKE SA Init packet (connect)");
    goto LABEL_12;
  }
  v3 = (void *)a1[5];
  if (v3)
  {
    objc_setProperty_atomic(v3, a2, 0, 280);
    v5 = a1[5];
    v6 = *(_QWORD *)(*(_QWORD *)(a1[6] + 8) + 40);
    if (v5)
    {
      v7 = *(_BYTE *)(v5 + 23);
      if (v6)
      {
        if ((v7 & 1) != 0)
        {
          -[NEIKEv2Session removeFirstChild](a1[4], v4);
          v25 = *(_QWORD *)(a1[6] + 8);
          v26 = *(void **)(v25 + 40);
          *(_QWORD *)(v25 + 40) = 0;

          goto LABEL_20;
        }
        goto LABEL_6;
      }
      if ((v7 & 1) != 0)
        goto LABEL_20;
      goto LABEL_14;
    }
  }
  else
  {
    v6 = *(_QWORD *)(*(_QWORD *)(a1[6] + 8) + 40);
  }
  if (!v6)
  {
LABEL_14:
    ne_log_obj();
    v22 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      v46 = a1[4];
      *(_DWORD *)buf = 138412290;
      v53 = v46;
      _os_log_error_impl(&dword_19BD16000, v22, OS_LOG_TYPE_ERROR, "%@ Failed to negotiate Childless SA (connect)", buf, 0xCu);
    }

    v24 = (id)a1[4];
    if (v24)
      v24 = objc_getProperty(v24, v23, 336, 1);
    v19 = v24;
    v20 = CFSTR("Failed to negotiate Childless SA (connect)");
LABEL_12:
    ErrorPeerInvalidSyntax = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(v20, v12, v13, v14, v15, v16, v17, v18, v47);
    goto LABEL_27;
  }
LABEL_6:
  -[NEIKEv2ChildSA setState:error:](v6, 1uLL, 0);
  -[NEIKEv2Session reportState]((_QWORD *)a1[4], v8);
LABEL_20:
  if ((-[NEIKEv2IKESA generateAllValuesForSAInit]((_BYTE *)a1[5], v4) & 1) != 0)
  {
    v28 = (_QWORD *)a1[4];
    v27 = (void *)a1[5];
    v48[0] = MEMORY[0x1E0C809B0];
    v48[1] = 3221225472;
    v48[2] = __43__NEIKEv2Session_Exchange__initiateConnect__block_invoke_143;
    v48[3] = &unk_1E3CC0FC8;
    v29 = v27;
    v30 = a1[4];
    v49 = v29;
    v50 = v30;
    v51 = a1[6];
    -[NEIKEv2Session handleIKEIntermediateForInitiatorIKESA:iteration:handler:](v28, v29, 0, v48);

    return;
  }
  ne_log_obj();
  v31 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
  {
    v45 = a1[4];
    *(_DWORD *)buf = 138412290;
    v53 = v45;
    _os_log_error_impl(&dword_19BD16000, v31, OS_LOG_TYPE_ERROR, "%@ Failed to generate crypto values (connect)", buf, 0xCu);
  }

  v33 = (id)a1[4];
  if (v33)
    v33 = objc_getProperty(v33, v32, 336, 1);
  v19 = v33;
  ErrorPeerInvalidSyntax = (void *)NEIKEv2CreateErrorCrypto(CFSTR("Failed to generate crypto values (connect)"), v34, v35, v36, v37, v38, v39, v40, v47);
LABEL_27:
  v41 = ErrorPeerInvalidSyntax;
  -[NEIKEv2IKESA setState:error:]((uint64_t)v19, 3uLL, ErrorPeerInvalidSyntax);

  -[NEIKEv2Session reportState]((_QWORD *)a1[4], v42);
  -[NEIKEv2Session resetAll](a1[4], v43);
}

void __43__NEIKEv2Session_Exchange__initiateConnect__block_invoke_143(uint64_t a1, const char *a2)
{
  _BYTE *v3;
  void *v4;
  int v5;
  const char *v6;
  NSObject *v7;
  id Property;
  id v9;
  const char *v10;
  void *v11;
  int v12;
  const char *v13;
  id v14;
  id v15;
  const char *v16;
  id v17;
  const char *v18;
  NSObject *v19;
  const char *v20;
  id v21;
  id v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  void *ErrorInternal;
  const char *v31;
  const char *v32;
  NSObject *v33;
  const char *v34;
  id v35;
  id v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  void *ErrorCrypto;
  const char *v45;
  const char *v46;
  uint64_t v47;
  void *v48;
  void *v49;
  id v50;
  id v51;
  void *v52;
  id v53;
  uint64_t v54;
  const char *v55;
  id v56;
  id v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  void *ErrorFailedToSend;
  const char *v66;
  const char *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  _QWORD v71[4];
  uint64_t v72;
  id v73;
  uint64_t v74;
  uint8_t buf[4];
  uint64_t v76;
  uint64_t v77;

  v77 = *MEMORY[0x1E0C80C00];
  v3 = *(_BYTE **)(a1 + 32);
  if (!v3 || (v3[24] & 1) == 0)
    goto LABEL_5;
  -[NEIKEv2IKESA ppk](*(id *)(a1 + 32), a2);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v5 = -[NEIKEv2IKESA generateDerivativesFromPPK:]((uint64_t)v3, v4);

  if (v5)
  {
    v3 = *(_BYTE **)(a1 + 32);
LABEL_5:
    v7 = +[NEIKEv2IKEAuthPacket createIKEAuthForInitiatorIKESA:childSA:]((uint64_t)NEIKEv2IKEAuthPacket, v3, *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40));
    if (v7)
    {
      Property = *(id *)(a1 + 40);
      if (Property)
        Property = objc_getProperty(Property, v6, 336, 1);
      v9 = Property;
      -[NEIKEv2IKESA authenticationProtocol](v9, v10);
      v11 = (void *)objc_claimAutoreleasedReturnValue();
      v12 = objc_msgSend(v11, "isSecurePassword");

      if (v12)
      {
        v14 = *(id *)(a1 + 40);
        if (v14)
          v14 = objc_getProperty(v14, v13, 336, 1);
        v15 = v14;
        -[NEIKEv2IKESA authenticationProtocol](v15, v16);
        v17 = (id)objc_claimAutoreleasedReturnValue();
      }
      else
      {
        objc_getProperty(v7, v13, 128, 1);
        v47 = objc_claimAutoreleasedReturnValue();
        v15 = (id)v47;
        if (v47)
          v48 = *(void **)(v47 + 24);
        else
          v48 = 0;
        v17 = v48;
      }
      v49 = v17;
      v50 = *(id *)(a1 + 40);
      if (v50)
        v50 = objc_getProperty(v50, v18, 336, 1);
      v51 = v50;
      -[NEIKEv2IKESA setLocalAuthProtocolUsed:]((uint64_t)v51, v49);

      v71[0] = MEMORY[0x1E0C809B0];
      v71[1] = 3221225472;
      v71[2] = __43__NEIKEv2Session_Exchange__initiateConnect__block_invoke_148;
      v71[3] = &unk_1E3CC0FA0;
      v52 = *(void **)(a1 + 32);
      v72 = *(_QWORD *)(a1 + 40);
      v53 = v52;
      v54 = *(_QWORD *)(a1 + 48);
      v73 = v53;
      v74 = v54;
      if (-[NEIKEv2Session sendRequest:retry:replyHandler:](v72, v7, v71) == -1)
      {
        v56 = *(id *)(a1 + 40);
        if (v56)
          v56 = objc_getProperty(v56, v55, 336, 1);
        v57 = v56;
        ErrorFailedToSend = (void *)NEIKEv2CreateErrorFailedToSend(CFSTR("initiator AUTH"), v58, v59, v60, v61, v62, v63, v64, v70);
        -[NEIKEv2IKESA setState:error:]((uint64_t)v57, 3uLL, ErrorFailedToSend);

        -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 40), v66);
        -[NEIKEv2Session resetAll](*(_QWORD *)(a1 + 40), v67);
      }

    }
    else
    {
      ne_log_obj();
      v19 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        v68 = *(_QWORD *)(a1 + 40);
        *(_DWORD *)buf = 138412290;
        v76 = v68;
        _os_log_error_impl(&dword_19BD16000, v19, OS_LOG_TYPE_ERROR, "%@ Failed to create IKE Auth packet (connect)", buf, 0xCu);
      }

      v21 = *(id *)(a1 + 40);
      if (v21)
        v21 = objc_getProperty(v21, v20, 336, 1);
      v22 = v21;
      ErrorInternal = (void *)NEIKEv2CreateErrorInternal(CFSTR("Failed to create IKE Auth packet (connect)"), v23, v24, v25, v26, v27, v28, v29, v70);
      -[NEIKEv2IKESA setState:error:]((uint64_t)v22, 3uLL, ErrorInternal);

      -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 40), v31);
      -[NEIKEv2Session resetAll](*(_QWORD *)(a1 + 40), v32);
    }

    return;
  }
  ne_log_obj();
  v33 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
  {
    v69 = *(_QWORD *)(a1 + 40);
    *(_DWORD *)buf = 138412290;
    v76 = v69;
    _os_log_error_impl(&dword_19BD16000, v33, OS_LOG_TYPE_ERROR, "%@ Failed to generate PPK-derived keys (connect)", buf, 0xCu);
  }

  v35 = *(id *)(a1 + 40);
  if (v35)
    v35 = objc_getProperty(v35, v34, 336, 1);
  v36 = v35;
  ErrorCrypto = (void *)NEIKEv2CreateErrorCrypto(CFSTR("Failed to generate PPK-derived keys (connect)"), v37, v38, v39, v40, v41, v42, v43, v70);
  -[NEIKEv2IKESA setState:error:]((uint64_t)v36, 3uLL, ErrorCrypto);

  -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 40), v45);
  -[NEIKEv2Session resetAll](*(_QWORD *)(a1 + 40), v46);
}

void __43__NEIKEv2Session_Exchange__initiateConnect__block_invoke_148(uint64_t a1, void *a2)
{
  id v3;
  id v4;
  const char *v5;
  void *v6;
  const char *v7;
  id v8;
  const char *v9;
  _QWORD *v10;
  void *v11;
  id v12;
  uint64_t v13;
  __CFString *v14;
  NSObject *v15;
  const char *v16;
  id v17;
  id v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  void *v26;
  const char *v27;
  const char *v28;
  const char *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  id v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t i;
  const __CFString *v41;
  uint64_t ErrorPeerInvalidSyntax;
  uint64_t v43;
  NSObject *v44;
  const char *v45;
  id Property;
  id v47;
  const char *v48;
  const char *v49;
  char *v50;
  NSObject *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59[4];
  id v60;
  uint64_t v61;
  id v62;
  uint64_t v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  uint8_t v68[4];
  const char *v69;
  __int16 v70;
  __CFString *v71;
  uint8_t buf[4];
  uint64_t v73;
  uint64_t v74;

  v74 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    v4 = *(id *)(a1 + 40);
    v6 = v4;
    if (v3)
    {
      if (v4)
      {
        if (!-[NEIKEv2IKESA usesEAPOnlyAuthentication](v4, v5))
          goto LABEL_6;
        v8 = objc_getProperty(v3, v7, 136, 1);

        if (v8)
          goto LABEL_6;
        if (-[NEIKEv2Packet hasErrors](v3, v9))
        {
          v66 = 0u;
          v67 = 0u;
          v64 = 0u;
          v65 = 0u;
          v36 = objc_getProperty(v3, v29, 64, 1);
          v37 = objc_msgSend(v36, "countByEnumeratingWithState:objects:count:", &v64, buf, 16);
          if (v37)
          {
            v38 = v37;
            v39 = *(_QWORD *)v65;
            while (2)
            {
              for (i = 0; i != v38; ++i)
              {
                if (*(_QWORD *)v65 != v39)
                  objc_enumerationMutation(v36);
                v41 = *(const __CFString **)(*((_QWORD *)&v64 + 1) + 8 * i);
                if (v41 && (unint64_t)(v41->length - 1) <= 0x3FFE)
                {
                  v14 = (__CFString *)-[NEIKEv2NotifyPayload copyError](v41);
                  ne_log_obj();
                  v44 = objc_claimAutoreleasedReturnValue();
                  if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
                  {
                    v50 = (char *)objc_msgSend(v3, "copyShortDescription");
                    *(_DWORD *)v68 = 138412546;
                    v69 = v50;
                    v70 = 2112;
                    v71 = v14;
                    _os_log_error_impl(&dword_19BD16000, v44, OS_LOG_TYPE_ERROR, "%@ EAP only authentication, received notify error %@", v68, 0x16u);

                  }
                  goto LABEL_31;
                }
              }
              v38 = objc_msgSend(v36, "countByEnumeratingWithState:objects:count:", &v64, buf, 16);
              if (v38)
                continue;
              break;
            }
          }

          goto LABEL_6;
        }
        ErrorPeerInvalidSyntax = NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("EAP only mode, IKE Auth packet does not contain EAP (connect)"), (uint64_t)v29, v30, v31, v32, v33, v34, v35, v59[0]);
      }
      else
      {
        ne_log_obj();
        v51 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v51, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)v68 = 136315138;
          v69 = "-[NEIKEv2IKEAuthPacket(Exchange) validateEAPOnlyAuthentication:]";
          _os_log_fault_impl(&dword_19BD16000, v51, OS_LOG_TYPE_FAULT, "%s called with null ikeSA", v68, 0xCu);
        }

        ErrorPeerInvalidSyntax = NEIKEv2CreateErrorInternal(CFSTR("IKE SA is nil"), v52, v53, v54, v55, v56, v57, v58, v59[0]);
      }
      v14 = (__CFString *)ErrorPeerInvalidSyntax;
LABEL_31:

      v10 = *(_QWORD **)(a1 + 32);
      if (v14)
      {
        if (v10)
          Property = objc_getProperty(*(id *)(a1 + 32), v45, 336, 1);
        else
          Property = 0;
        v47 = Property;
        -[NEIKEv2IKESA setState:error:]((uint64_t)v47, 3uLL, v14);

        -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 32), v48);
        -[NEIKEv2Session resetAll](*(_QWORD *)(a1 + 32), v49);
        goto LABEL_8;
      }
LABEL_7:
      v11 = *(void **)(a1 + 40);
      v59[0] = MEMORY[0x1E0C809B0];
      v59[1] = 3221225472;
      v59[2] = (uint64_t)__43__NEIKEv2Session_Exchange__initiateConnect__block_invoke_151;
      v59[3] = (uint64_t)&unk_1E3CC0F78;
      v12 = v11;
      v63 = *(_QWORD *)(a1 + 48);
      v13 = *(_QWORD *)(a1 + 32);
      v60 = v12;
      v61 = v13;
      v62 = v3;
      -[NEIKEv2Session handleEAPAndGSPMForIKESA:authPacket:handler:](v10, v12, v62, v59);

      v14 = 0;
LABEL_8:

      goto LABEL_14;
    }
LABEL_6:

    v10 = *(_QWORD **)(a1 + 32);
    goto LABEL_7;
  }
  ne_log_obj();
  v15 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    v43 = *(_QWORD *)(a1 + 32);
    *(_DWORD *)buf = 138412290;
    v73 = v43;
    _os_log_error_impl(&dword_19BD16000, v15, OS_LOG_TYPE_ERROR, "%@ Failed to receive IKE Auth packet (connect)", buf, 0xCu);
  }

  v17 = *(id *)(a1 + 32);
  if (v17)
    v17 = objc_getProperty(v17, v16, 336, 1);
  v18 = v17;
  v26 = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("Failed to receive IKE Auth packet (connect)"), v19, v20, v21, v22, v23, v24, v25, v59[0]);
  -[NEIKEv2IKESA setState:error:]((uint64_t)v18, 3uLL, v26);

  -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 32), v27);
  -[NEIKEv2Session resetAll](*(_QWORD *)(a1 + 32), v28);
LABEL_14:

}

void __43__NEIKEv2Session_Exchange__initiateConnect__block_invoke_151(uint64_t *a1, void *a2)
{
  id v3;
  void *v4;
  uint64_t v5;
  void *v6;
  const char *v7;
  void *v8;
  id v9;
  const char *v10;
  id v11;
  id v12;
  id v13;
  uint64_t v14;
  const char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  id v21;
  void *v22;
  char *v23;
  uint64_t v24;
  void *v25;
  NSObject *v26;
  uint64_t v27;
  NSObject *v28;
  const char *v29;
  uint64_t v30;
  uint64_t v31;
  const char *v32;
  id v33;
  NSObject *v34;
  void *v35;
  NSObject *v36;
  _QWORD *v37;
  id v38;
  void *v39;
  const char *v40;
  id Property;
  id v42;
  uint64_t v43;
  NSObject *v44;
  uint64_t v45;
  const char *v46;
  NEIKEv2DeleteIKEContext *v47;
  id v48;
  id v49;
  id *v50;
  NSObject *v51;
  const char *v52;
  uint64_t v53;
  _QWORD *v54;
  id v55;
  const char *v56;
  NEIKEv2DeleteIKEContext *v57;
  id v58;
  id v59;
  _QWORD *v60;
  id v61;
  id v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  void *ErrorPeerInvalidSyntax;
  const char *v71;
  const char *v72;
  _QWORD *v73;
  _QWORD *v74;
  uint64_t v75;
  const char *v76;
  _QWORD *v77;
  void *v78;
  id v79;
  uint64_t v80;
  const char *v81;
  void *v82;
  void *v83;
  void *v84;
  const char *v85;
  id v86;
  const char *v87;
  id v88;
  const char *v89;
  void *v90;
  id v91;
  void *v92;
  SEL v93;
  id v94;
  const char *v95;
  id v96;
  const char *v97;
  void *v98;
  id v99;
  uint64_t v100;
  SEL v101;
  id v102;
  const char *v103;
  id v104;
  const char *v105;
  void *v106;
  id v107;
  uint64_t v108;
  SEL v109;
  id v110;
  const char *v111;
  id v112;
  const char *v113;
  void *v114;
  id v115;
  SEL v116;
  id v117;
  const char *v118;
  id v119;
  void *v120;
  void *v121;
  void *v122;
  SEL v123;
  id v124;
  const char *v125;
  id v126;
  void *v127;
  id v128;
  const char *v129;
  void *v130;
  const char *v131;
  void *v132;
  id v133;
  const char *v134;
  void *v135;
  id v136;
  const char *v137;
  void *v138;
  const char *v139;
  void *v140;
  id v141;
  const char *v142;
  void *v143;
  id v144;
  SEL v145;
  _QWORD *v146;
  void *v147;
  id v148;
  SEL v149;
  _QWORD *v150;
  void *v151;
  id v152;
  SEL v153;
  id v154;
  const char *v155;
  id v156;
  const char *v157;
  void *v158;
  void *v159;
  void *v160;
  SEL v161;
  id v162;
  const char *v163;
  id v164;
  void *v165;
  SEL v166;
  id v167;
  const char *v168;
  id v169;
  void *v170;
  id v171;
  id v172;
  id v173;
  id v174;
  id v175;
  id v176;
  id v177;
  id v178;
  const char *v179;
  void *v180;
  uint64_t v181;
  id WeakRetained;
  const char *v183;
  void *v184;
  id v185;
  const char *v186;
  void *v187;
  id v188;
  const char *v189;
  void *v190;
  id v191;
  uint64_t v192;
  uint64_t v193;
  char v194;
  uint64_t v195;
  uint64_t v196;
  void *v197;
  const char *v198;
  void *v199;
  void *v200;
  id v201;
  const char *v202;
  void *v203;
  void *v204;
  ptrdiff_t v205;
  const char *v206;
  void *v207;
  uint64_t v208;
  NSObject *v209;
  uint64_t v210;
  const char *v211;
  NSObject *v212;
  const char *v213;
  id v214;
  NSObject *v215;
  const char *v216;
  id v217;
  id *v218;
  NSObject *v219;
  uint64_t v220;
  void *v221;
  uint64_t v222;
  uint64_t v223;
  const char *v224;
  uint64_t v225;
  uint64_t v226;
  void *v227;
  id v228;
  id v229;
  void *v230;
  void *v231;
  id v232;
  void *v233;
  id v234;
  void *v235;
  id v236;
  id self;
  id selfa;
  void *v239;
  uint64_t *v240;
  void *v241;
  void *v242;
  void *v243;
  void *v244;
  __int128 v245;
  __int128 v246;
  __int128 v247;
  __int128 v248;
  _QWORD v249[5];
  _QWORD v250[5];
  _QWORD v251[5];
  _QWORD v252[5];
  id v253;
  __int128 v254;
  __int128 v255;
  __int128 v256;
  __int128 v257;
  uint8_t v258[128];
  uint8_t buf[4];
  uint64_t v260;
  __int128 block;
  _QWORD *(*v262)(_QWORD *);
  void *v263;
  id v264;
  id v265;
  NSObject *v266;
  __int128 v267;
  id (*v268)(_QWORD *);
  void *v269;
  id v270;
  id v271;
  id v272;
  id v273;
  id v274;
  id v275;
  id v276;
  id v277;
  id v278;
  id v279;
  id v280;
  id v281;
  id v282;
  id v283;
  uint64_t v284;

  v284 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  v4 = v3;
  v5 = a1[4];
  if (v5)
  {
    *(_BYTE *)(v5 + 17) = 0;
    v6 = (void *)a1[4];
  }
  else
  {
    v6 = 0;
  }
  if (!-[NEIKEv2IKEAuthPacket validateAuthAsInitiator:childSA:](v3, v6, *(void **)(*(_QWORD *)(a1[7] + 8) + 40)))
  {
    v37 = (_QWORD *)a1[4];
    if (v37 && v37[6] == 3)
    {
      v38 = objc_getProperty(v37, v7, 56, 1);
      objc_msgSend(v38, "domain");
      v39 = (void *)objc_claimAutoreleasedReturnValue();
      if ((objc_msgSend(v39, "isEqual:", CFSTR("NEIKEv2ErrorDomain")) & 1) != 0)
      {
        Property = (id)a1[4];
        if (Property)
          Property = objc_getProperty(Property, v40, 56, 1);
        v42 = Property;
        v43 = objc_msgSend(v42, "code");

        if (v43 == 5)
        {
          ne_log_obj();
          v44 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
          {
            v45 = a1[5];
            LODWORD(v267) = 138412290;
            *(_QWORD *)((char *)&v267 + 4) = v45;
            _os_log_impl(&dword_19BD16000, v44, OS_LOG_TYPE_DEFAULT, "%@ Received server redirect in IKE Auth (connect)", (uint8_t *)&v267, 0xCu);
          }

          v47 = [NEIKEv2DeleteIKEContext alloc];
          v48 = (id)a1[5];
          if (v48)
            v48 = objc_getProperty(v48, v46, 368, 1);
          v49 = v48;
          v252[0] = MEMORY[0x1E0C809B0];
          v252[1] = 3221225472;
          v252[2] = __43__NEIKEv2Session_Exchange__initiateConnect__block_invoke_153;
          v252[3] = &unk_1E3CC0EB0;
          v252[4] = a1[5];
          v253 = v4;
          v50 = -[NEIKEv2DeleteIKEContext initDeleteIKEWithResponse:callbackQueue:callback:]((id *)&v47->super.super.isa, 0, v49, v252);

          -[NEIKEv2Session initiateDelete:]((_QWORD *)a1[5], v50);
          goto LABEL_165;
        }
      }
      else
      {

      }
    }
    ne_log_obj();
    v51 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
    {
      v222 = a1[5];
      LODWORD(v267) = 138412290;
      *(_QWORD *)((char *)&v267 + 4) = v222;
      _os_log_error_impl(&dword_19BD16000, v51, OS_LOG_TYPE_ERROR, "%@ Failed to process IKE Auth packet (connect)", (uint8_t *)&v267, 0xCu);
    }

    v53 = a1[4];
    if (!v53 || *(_QWORD *)(v53 + 48) != 1)
    {
      v61 = (id)a1[5];
      if (v61)
        v61 = objc_getProperty(v61, v52, 336, 1);
      v62 = v61;
      ErrorPeerInvalidSyntax = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("Failed to process IKE Auth packet (connect)"), v63, v64, v65, v66, v67, v68, v69, v226);
      -[NEIKEv2IKESA setState:error:]((uint64_t)v62, 3uLL, ErrorPeerInvalidSyntax);

      -[NEIKEv2Session reportState]((_QWORD *)a1[5], v71);
      -[NEIKEv2Session resetAll](a1[5], v72);
      goto LABEL_165;
    }
    v54 = *(_QWORD **)(*(_QWORD *)(a1[7] + 8) + 40);
    if (v54 && v54[4] == 3)
    {
      v55 = objc_getProperty(v54, v52, 40, 1);
      -[NEIKEv2IKESA setState:error:](v53, 3uLL, v55);

    }
    v57 = [NEIKEv2DeleteIKEContext alloc];
    v58 = (id)a1[5];
    if (v58)
      v58 = objc_getProperty(v58, v56, 368, 1);
    v59 = v58;
    v251[0] = MEMORY[0x1E0C809B0];
    v251[1] = 3221225472;
    v251[2] = __43__NEIKEv2Session_Exchange__initiateConnect__block_invoke_154;
    v251[3] = &unk_1E3CC1408;
    v251[4] = a1[5];
    v60 = v251;
LABEL_158:
    v218 = -[NEIKEv2DeleteIKEContext initDeleteIKEWithResponse:callbackQueue:callback:]((id *)&v57->super.super.isa, 0, v59, v60);

    -[NEIKEv2Session initiateDelete:]((_QWORD *)a1[5], v218);
    goto LABEL_165;
  }
  v8 = (void *)a1[5];
  v9 = v4;
  v240 = a1;
  v241 = v4;
  if (v8)
  {
    v254 = 0u;
    v255 = 0u;
    v256 = 0u;
    v257 = 0u;
    self = v8;
    v11 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
    if (v9)
      v12 = objc_getProperty(v9, v10, 64, 1);
    else
      v12 = 0;
    v13 = v12;
    v14 = objc_msgSend(v13, "countByEnumeratingWithState:objects:count:", &v254, &v267, 16);
    if (v14)
    {
      v16 = v14;
      v17 = *(_QWORD *)v255;
      do
      {
        v18 = 0;
        do
        {
          if (*(_QWORD *)v255 != v17)
            objc_enumerationMutation(v13);
          v19 = *(_QWORD **)(*((_QWORD *)&v254 + 1) + 8 * v18);
          if (v19)
          {
            v20 = v19[3];
            if (v20 != 16398)
            {
              if (v20 != 16397)
                goto LABEL_27;
              block = 0uLL;
              v21 = objc_getProperty(v19, v15, 32, 1);
              if (objc_msgSend(v21, "length") == 4)
              {
                LOWORD(block) = 528;
                v22 = v21;
                v23 = (char *)&block + 4;
                v24 = 4;
                goto LABEL_19;
              }
              ne_log_obj();
              v26 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
              {
                v27 = objc_msgSend(v21, "length");
                *(_DWORD *)buf = 134217984;
                v260 = v27;
                v28 = v26;
                v29 = "Additional IPv4 address has invalid length %llu";
                goto LABEL_30;
              }
              goto LABEL_23;
            }
            block = 0uLL;
            LODWORD(v263) = 0;
            v262 = 0;
            v21 = objc_getProperty(v19, v15, 32, 1);
            if (objc_msgSend(v21, "length") == 16)
            {
              LOWORD(block) = 7708;
              v22 = v21;
              v23 = (char *)&block + 8;
              v24 = 16;
LABEL_19:
              objc_msgSend(v22, "getBytes:length:", v23, v24);
              objc_msgSend(MEMORY[0x1E0CCEC58], "endpointWithAddress:", &block);
              v25 = (void *)objc_claimAutoreleasedReturnValue();
            }
            else
            {
              ne_log_obj();
              v26 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
              {
                v30 = objc_msgSend(v21, "length");
                *(_DWORD *)buf = 134217984;
                v260 = v30;
                v28 = v26;
                v29 = "Additional IPv6 address has invalid length %llu";
LABEL_30:
                _os_log_error_impl(&dword_19BD16000, v28, OS_LOG_TYPE_ERROR, v29, buf, 0xCu);
              }
LABEL_23:

              v25 = 0;
            }

            if (v25)
              objc_msgSend(v11, "addObject:", v25);

          }
LABEL_27:
          ++v18;
        }
        while (v16 != v18);
        v31 = objc_msgSend(v13, "countByEnumeratingWithState:objects:count:", &v254, &v267, 16);
        v16 = v31;
      }
      while (v31);
    }

    if (!objc_msgSend(v11, "count"))
      goto LABEL_65;
    v33 = v11;
    if (v33)
    {
      if (objc_getProperty(self, v32, 336, 1))
      {
        objc_msgSend(self, "additionalAddressesUpdateBlock");
        v34 = objc_claimAutoreleasedReturnValue();
        objc_msgSend(self, "clientQueue");
        v35 = (void *)objc_claimAutoreleasedReturnValue();

        if (v35 && v34)
        {
          objc_msgSend(self, "clientQueue");
          v36 = objc_claimAutoreleasedReturnValue();
          *(_QWORD *)&block = MEMORY[0x1E0C809B0];
          *((_QWORD *)&block + 1) = 3221225472;
          v262 = __50__NEIKEv2Session_reportServerAdditionalAddresses___block_invoke;
          v263 = &unk_1E3CC3A30;
          v264 = self;
          v34 = v34;
          v266 = v34;
          v265 = v33;
          dispatch_async(v36, &block);

        }
        goto LABEL_64;
      }
      ne_log_obj();
      v34 = objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v34, OS_LOG_TYPE_FAULT))
      {
LABEL_64:

LABEL_65:
        goto LABEL_66;
      }
      LODWORD(block) = 136315138;
      *(_QWORD *)((char *)&block + 4) = "-[NEIKEv2Session reportServerAdditionalAddresses:]";
      v224 = "%s called with null self.ikeSA";
    }
    else
    {
      ne_log_obj();
      v34 = objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v34, OS_LOG_TYPE_FAULT))
        goto LABEL_64;
      LODWORD(block) = 136315138;
      *(_QWORD *)((char *)&block + 4) = "-[NEIKEv2Session reportServerAdditionalAddresses:]";
      v224 = "%s called with null additionalAddresses";
    }
    _os_log_fault_impl(&dword_19BD16000, v34, OS_LOG_TYPE_FAULT, v224, (uint8_t *)&block, 0xCu);
    goto LABEL_64;
  }
LABEL_66:

  -[NEIKEv2Session reportPrivateNotifiesInPacket:]((id *)a1[5], v9);
  v73 = (_QWORD *)a1[5];
  if (v73)
    v73 = (_QWORD *)v73[49];
  v74 = v73;
  v75 = objc_msgSend(v74, "count");

  if (v75)
  {
    v77 = (_QWORD *)a1[5];
    if (v77)
      v78 = (void *)v77[49];
    else
      v78 = 0;
    v79 = v78;
    -[NEIKEv2Session reportPrivateNotifies:](v77, v79);

    -[NEIKEv2Session setPendingPrivateNotifies:](a1[5], 0);
  }
  v80 = *(_QWORD *)(*(_QWORD *)(a1[7] + 8) + 40);
  if (v80 && (-[NEIKEv2ChildSA generateAllValues](v80) & 1) == 0)
  {
    ne_log_obj();
    v212 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v212, OS_LOG_TYPE_ERROR))
    {
      v223 = a1[5];
      LODWORD(v267) = 138412290;
      *(_QWORD *)((char *)&v267 + 4) = v223;
      _os_log_error_impl(&dword_19BD16000, v212, OS_LOG_TYPE_ERROR, "%@ Failed to generate Child SA crypto values (connect)", (uint8_t *)&v267, 0xCu);
    }

    v57 = [NEIKEv2DeleteIKEContext alloc];
    v214 = (id)a1[5];
    if (v214)
      v214 = objc_getProperty(v214, v213, 368, 1);
    v59 = v214;
    v250[0] = MEMORY[0x1E0C809B0];
    v250[1] = 3221225472;
    v250[2] = __43__NEIKEv2Session_Exchange__initiateConnect__block_invoke_157;
    v250[3] = &unk_1E3CC1408;
    v250[4] = a1[5];
    v60 = v250;
    goto LABEL_158;
  }
  -[NEIKEv2Session finishConfigurationEstablishment]((_BYTE *)a1[5], v76);
  -[NEIKEv2Session reportConfiguration]((void *)a1[5], v81);
  v82 = (void *)a1[5];
  if (v82)
  {
    objc_msgSend(MEMORY[0x1E0CB3898], "processInfo");
    v83 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v83, "processName");
    v84 = (void *)objc_claimAutoreleasedReturnValue();

    if ((objc_msgSend(&unk_1E3D03AA0, "containsObject:", v84) & 1) != 0)
    {
LABEL_116:

      goto LABEL_117;
    }
    v86 = objc_getProperty(v82, v85, 336, 1);
    if (v86)
    {
      v88 = objc_getProperty(v86, v87, 96, 1);
      v90 = v88;
      if (v88)
        v88 = objc_getProperty(v88, v89, 88, 1);
    }
    else
    {
      v90 = 0;
      v88 = 0;
    }
    v91 = v88;
    objc_msgSend(v91, "description");
    v92 = (void *)objc_claimAutoreleasedReturnValue();

    v94 = objc_getProperty(v82, v93, 336, 1);
    if (v94)
    {
      v96 = objc_getProperty(v94, v95, 96, 1);
      v98 = v96;
      if (v96)
        v96 = objc_getProperty(v96, v97, 96, 1);
    }
    else
    {
      v98 = 0;
      v96 = 0;
    }
    v99 = v96;
    objc_msgSend(v99, "description");
    v100 = objc_claimAutoreleasedReturnValue();

    v102 = objc_getProperty(v82, v101, 336, 1);
    if (v102)
    {
      v104 = objc_getProperty(v102, v103, 96, 1);
      v106 = v104;
      if (v104)
        v104 = objc_getProperty(v104, v105, 104, 1);
    }
    else
    {
      v106 = 0;
      v104 = 0;
    }
    v107 = v104;
    objc_msgSend(v107, "description");
    v108 = objc_claimAutoreleasedReturnValue();

    v110 = objc_getProperty(v82, v109, 336, 1);
    if (v110)
    {
      v112 = objc_getProperty(v110, v111, 96, 1);
      v114 = v112;
      if (v112)
        v112 = objc_getProperty(v112, v113, 112, 1);
    }
    else
    {
      v114 = 0;
      v112 = 0;
    }
    v115 = v112;
    objc_msgSend(v115, "description");
    v239 = (void *)objc_claimAutoreleasedReturnValue();

    v117 = objc_getProperty(v82, v116, 336, 1);
    v244 = v84;
    if (v117)
      v117 = objc_getProperty(v117, v118, 144, 1);
    v119 = v117;
    v120 = (void *)MEMORY[0x1E0C9AAB0];
    v121 = (void *)MEMORY[0x1E0C9AAA0];
    if (v119)
      v122 = (void *)MEMORY[0x1E0C9AAB0];
    else
      v122 = (void *)MEMORY[0x1E0C9AAA0];
    selfa = v122;

    v124 = objc_getProperty(v82, v123, 336, 1);
    if (v124)
      v124 = objc_getProperty(v124, v125, 280, 1);
    v126 = v124;
    if (v126)
      v127 = v120;
    else
      v127 = v121;
    v128 = v127;

    -[NEIKEv2Session firstChildSA](v82, v129);
    v130 = (void *)objc_claimAutoreleasedReturnValue();
    v132 = v130;
    v243 = (void *)v100;
    if (v130)
    {
      v133 = objc_getProperty(v130, v131, 56, 1);
      v135 = v133;
      if (v133)
        v133 = objc_getProperty(v133, v134, 96, 1);
    }
    else
    {
      v135 = 0;
      v133 = 0;
    }
    v136 = v133;
    objc_msgSend(v136, "description");
    v235 = (void *)objc_claimAutoreleasedReturnValue();

    -[NEIKEv2Session firstChildSA](v82, v137);
    v138 = (void *)objc_claimAutoreleasedReturnValue();
    v140 = v138;
    v242 = (void *)v108;
    if (v138)
    {
      v141 = objc_getProperty(v138, v139, 56, 1);
      v143 = v141;
      if (v141)
        v141 = objc_getProperty(v141, v142, 104, 1);
    }
    else
    {
      v143 = 0;
      v141 = 0;
    }
    v144 = v141;
    objc_msgSend(v144, "description");
    v233 = (void *)objc_claimAutoreleasedReturnValue();

    v146 = objc_getProperty(v82, v145, 336, 1);
    if (v146)
      v147 = (void *)v146[54];
    else
      v147 = 0;
    v148 = v147;
    objc_msgSend(v148, "description");
    v231 = (void *)objc_claimAutoreleasedReturnValue();

    v150 = objc_getProperty(v82, v149, 336, 1);
    if (v150)
      v151 = (void *)v150[55];
    else
      v151 = 0;
    v152 = v151;
    objc_msgSend(v152, "description");
    v230 = (void *)objc_claimAutoreleasedReturnValue();

    v154 = objc_getProperty(v82, v153, 336, 1);
    if (v154)
    {
      v156 = objc_getProperty(v154, v155, 448, 1);
      v158 = v156;
      if (v156)
      {
        objc_msgSend(objc_getProperty(v156, v157, 160, 1), "description");
        v159 = (void *)objc_claimAutoreleasedReturnValue();
LABEL_111:

        v160 = (void *)MEMORY[0x1E0CB37E8];
        v162 = objc_getProperty(v82, v161, 336, 1);
        if (v162)
          v162 = objc_getProperty(v162, v163, 128, 1);
        v164 = v162;
        objc_msgSend(v160, "numberWithUnsignedInteger:", objc_msgSend(v164, "length"));
        v227 = (void *)objc_claimAutoreleasedReturnValue();

        v165 = (void *)MEMORY[0x1E0CB37E8];
        v167 = objc_getProperty(v82, v166, 336, 1);
        if (v167)
          v167 = objc_getProperty(v167, v168, 136, 1);
        v169 = v167;
        objc_msgSend(v165, "numberWithUnsignedInteger:", objc_msgSend(v169, "length"));
        v170 = (void *)objc_claimAutoreleasedReturnValue();

        *(_QWORD *)&v267 = MEMORY[0x1E0C809B0];
        *((_QWORD *)&v267 + 1) = 3221225472;
        v268 = __48__NEIKEv2Session_sendAnalyticsOfChosenProtocols__block_invoke;
        v269 = &unk_1E3CC1860;
        v270 = v92;
        v271 = v243;
        v272 = v242;
        v273 = v239;
        v274 = selfa;
        v275 = v128;
        v276 = v235;
        v277 = v233;
        v278 = v231;
        v279 = v230;
        v280 = v159;
        v281 = v227;
        v282 = v170;
        v283 = v244;
        v229 = v170;
        v228 = v227;
        v171 = v159;
        v172 = v230;
        v232 = v231;
        v234 = v233;
        v236 = v235;
        v173 = v128;
        v174 = selfa;
        v175 = v239;
        v176 = v242;
        v177 = v243;
        v178 = v92;
        AnalyticsSendEventLazy();

        a1 = v240;
        v4 = v241;
        v84 = v244;
        goto LABEL_116;
      }
    }
    else
    {
      v158 = 0;
    }
    v159 = 0;
    goto LABEL_111;
  }
LABEL_117:
  -[NEIKEv2IKESA setLocalAuthProtocolUsed:](a1[4], 0);
  -[NEIKEv2IKESA setRemoteAuthProtocolUsed:](a1[4], 0);
  -[NEIKEv2IKESA clearAuthenticationSecrets]((void *)a1[4], v179);
  v180 = *(void **)(*(_QWORD *)(a1[7] + 8) + 40);
  if (v180 && (-[NEIKEv2Session installChildSA:](a1[5], v180) & 1) == 0)
  {
    ne_log_obj();
    v215 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v215, OS_LOG_TYPE_ERROR))
    {
      v225 = a1[5];
      LODWORD(v267) = 138412290;
      *(_QWORD *)((char *)&v267 + 4) = v225;
      _os_log_error_impl(&dword_19BD16000, v215, OS_LOG_TYPE_ERROR, "%@ Failed to install Child SA (connect)", (uint8_t *)&v267, 0xCu);
    }

    v57 = [NEIKEv2DeleteIKEContext alloc];
    v217 = (id)a1[5];
    if (v217)
      v217 = objc_getProperty(v217, v216, 368, 1);
    v59 = v217;
    v249[0] = MEMORY[0x1E0C809B0];
    v249[1] = 3221225472;
    v249[2] = __43__NEIKEv2Session_Exchange__initiateConnect__block_invoke_160;
    v249[3] = &unk_1E3CC1408;
    v249[4] = a1[5];
    v60 = v249;
    goto LABEL_158;
  }
  v181 = a1[5];
  if (!v181)
    goto LABEL_160;
  WeakRetained = objc_loadWeakRetained((id *)(v181 + 352));

  if (!WeakRetained)
    goto LABEL_160;
  v247 = 0u;
  v248 = 0u;
  v245 = 0u;
  v246 = 0u;
  v184 = (void *)a1[6];
  if (v184 && (v185 = objc_getProperty(v184, v183, 152, 1)) != 0)
  {
    v187 = v185;
    v188 = objc_getProperty(v185, v186, 24, 1);
    v190 = v188;
    if (v188)
      v188 = objc_getProperty(v188, v189, 16, 1);
  }
  else
  {
    v190 = 0;
    v187 = 0;
    v188 = 0;
  }
  v191 = v188;

  v192 = objc_msgSend(v191, "countByEnumeratingWithState:objects:count:", &v245, v258, 16);
  if (!v192)
  {

    goto LABEL_160;
  }
  v193 = v192;
  v194 = 0;
  v195 = *(_QWORD *)v246;
  do
  {
    v196 = 0;
    do
    {
      if (*(_QWORD *)v246 != v195)
        objc_enumerationMutation(v191);
      v197 = *(void **)(*((_QWORD *)&v245 + 1) + 8 * v196);
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0)
      {
        objc_msgSend(v197, "address");
        v199 = (void *)objc_claimAutoreleasedReturnValue();
        v200 = (void *)a1[5];
        if (!v200)
          goto LABEL_142;
        v201 = objc_getProperty(v200, v198, 336, 1);
        v203 = v201;
        if (v201)
        {
          v204 = v199;
          v205 = 64;
LABEL_138:
          objc_setProperty_atomic(v201, v202, v204, v205);
        }
      }
      else
      {
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) == 0)
          goto LABEL_140;
        objc_msgSend(v197, "address");
        v199 = (void *)objc_claimAutoreleasedReturnValue();
        v207 = (void *)a1[5];
        if (!v207)
        {
LABEL_142:
          v203 = 0;
          goto LABEL_139;
        }
        v201 = objc_getProperty(v207, v206, 336, 1);
        v203 = v201;
        if (v201)
        {
          v204 = v199;
          v205 = 72;
          goto LABEL_138;
        }
      }
LABEL_139:

      v194 = 1;
LABEL_140:
      ++v196;
    }
    while (v193 != v196);
    v208 = objc_msgSend(v191, "countByEnumeratingWithState:objects:count:", &v245, v258, 16);
    v193 = v208;
  }
  while (v208);

  if ((v194 & 1) != 0)
  {
    ne_log_obj();
    v209 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v209, OS_LOG_TYPE_INFO))
    {
      v210 = a1[5];
      LODWORD(v267) = 138412290;
      *(_QWORD *)((char *)&v267 + 4) = v210;
      _os_log_impl(&dword_19BD16000, v209, OS_LOG_TYPE_INFO, "%@ Changing addresses and migrating (connect)", (uint8_t *)&v267, 0xCu);
    }

    -[NEIKEv2Session migrateAllChildSAs](a1[5], v211);
  }
LABEL_160:
  ne_log_obj();
  v219 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v219, OS_LOG_TYPE_DEFAULT))
  {
    v220 = a1[5];
    LODWORD(v267) = 138412290;
    *(_QWORD *)((char *)&v267 + 4) = v220;
    _os_log_impl(&dword_19BD16000, v219, OS_LOG_TYPE_DEFAULT, "%@ Completed connection (connect)", (uint8_t *)&v267, 0xCu);
  }

  -[NEIKEv2IKESA setState:error:](a1[4], 2uLL, 0);
  v221 = *(void **)(*(_QWORD *)(a1[7] + 8) + 40);
  if (v221)
  {
    -[NEIKEv2Session reportTrafficSelectorsForChildSA:]((void *)a1[5], v221);
    -[NEIKEv2ChildSA setState:error:](*(_QWORD *)(*(_QWORD *)(a1[7] + 8) + 40), 2uLL, 0);
  }
  -[NEIKEv2Session reportState]((_QWORD *)a1[5], (const char *)v221);
LABEL_165:

}

void __43__NEIKEv2Session_Exchange__initiateConnect__block_invoke_153(uint64_t a1)
{
  const char *v2;

  -[NEIKEv2Session reportServerRedirect:](*(void **)(a1 + 32), *(void **)(a1 + 40));
  -[NEIKEv2Session resetAll](*(_QWORD *)(a1 + 32), v2);
}

void __43__NEIKEv2Session_Exchange__initiateConnect__block_invoke_154(uint64_t a1, const char *a2)
{
  -[NEIKEv2Session resetAll](*(_QWORD *)(a1 + 32), a2);
}

void __43__NEIKEv2Session_Exchange__initiateConnect__block_invoke_157(uint64_t a1, const char *a2)
{
  id Property;
  id v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *ErrorCrypto;
  const char *v13;
  const char *v14;
  uint64_t v15;

  Property = *(id *)(a1 + 32);
  if (Property)
    Property = objc_getProperty(Property, a2, 336, 1);
  v4 = Property;
  ErrorCrypto = (void *)NEIKEv2CreateErrorCrypto(CFSTR("Failed to generate Child SA crypto values (connect)"), v5, v6, v7, v8, v9, v10, v11, v15);
  -[NEIKEv2IKESA setState:error:]((uint64_t)v4, 3uLL, ErrorCrypto);

  -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 32), v13);
  -[NEIKEv2Session resetAll](*(_QWORD *)(a1 + 32), v14);
}

void __43__NEIKEv2Session_Exchange__initiateConnect__block_invoke_160(uint64_t a1, const char *a2)
{
  id Property;
  id v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *ErrorInternal;
  const char *v13;
  const char *v14;
  uint64_t v15;

  Property = *(id *)(a1 + 32);
  if (Property)
    Property = objc_getProperty(Property, a2, 336, 1);
  v4 = Property;
  ErrorInternal = (void *)NEIKEv2CreateErrorInternal(CFSTR("Failed to install Child SA (connect)"), v5, v6, v7, v8, v9, v10, v11, v15);
  -[NEIKEv2IKESA setState:error:]((uint64_t)v4, 3uLL, ErrorInternal);

  -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 32), v13);
  -[NEIKEv2Session resetAll](*(_QWORD *)(a1 + 32), v14);
}

- (uint64_t)setupReceivedChildCopyError
{
  NSObject *v3;
  const char *v4;
  uint64_t v5;
  const char *v6;
  void *v7;
  const char *v8;
  SEL v9;
  id v10;
  void *v11;
  char v12;
  uint64_t ErrorInternal;
  NSObject *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  __CFString *v22;
  _BYTE *v23;
  char v24;
  const char *v25;
  NSObject *v26;
  _BYTE v28[24];
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 0;
  v3 = objc_getProperty(a1, a2, 368, 1);
  dispatch_assert_queue_V2(v3);

  -[NEIKEv2Session firstChildSA](a1, v4);
  v5 = objc_claimAutoreleasedReturnValue();
  v7 = (void *)v5;
  if (!v5)
  {
    v23 = objc_getProperty(a1, v6, 336, 1);
    if (v23)
    {
      v24 = v23[23];

      if ((v24 & 1) != 0)
      {
        -[NEIKEv2Session reportState](a1, v25);
        ErrorInternal = 0;
        goto LABEL_14;
      }
    }
    ne_log_obj();
    v26 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v28 = 138412290;
      *(_QWORD *)&v28[4] = a1;
      _os_log_error_impl(&dword_19BD16000, v26, OS_LOG_TYPE_ERROR, "%@ Failed to get childSA receiver", v28, 0xCu);
    }

    v22 = CFSTR("Failed to get childSA receiver");
    goto LABEL_12;
  }
  *(_BYTE *)(v5 + 9) = 0;
  -[NEIKEv2ChildSA setState:error:](v5, 1uLL, 0);
  -[NEIKEv2Session reportState](a1, v8);
  v10 = objc_getProperty(v7, v9, 48, 1);
  objc_msgSend(v10, "proposals");
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  v12 = -[NEIKEv2Session generateSPIForChild:proposals:](a1, v7, v11);

  ErrorInternal = 0;
  if ((v12 & 1) == 0)
  {
    ne_log_obj();
    v14 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v28 = 138412290;
      *(_QWORD *)&v28[4] = a1;
      _os_log_error_impl(&dword_19BD16000, v14, OS_LOG_TYPE_ERROR, "%@ Failed to generate Child SA SPI (receive)", v28, 0xCu);
    }

    v22 = CFSTR("Failed to generate Child SA SPI (receive)");
LABEL_12:
    ErrorInternal = NEIKEv2CreateErrorInternal(v22, v15, v16, v17, v18, v19, v20, v21, *(uint64_t *)v28);
  }
LABEL_14:

  return ErrorInternal;
}

void __58__NEIKEv2Session_Exchange__setupReceivedChildWithHandler___block_invoke(uint64_t a1, void *a2, void *a3, const void *a4)
{
  id v7;
  const char *v8;
  id v9;
  id Property;
  NSObject *v11;
  const char *v12;
  uint64_t v13;
  void *v14;
  _BYTE *v15;
  char v16;
  const char *v17;
  NSObject *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  __CFString *v27;
  NSObject *ErrorInternal;
  uint64_t v29;
  NSObject *v30;
  void *v31;
  _BYTE *v32;
  char v33;
  NSObject *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  NSObject *v39;
  CFTypeRef v40;
  uint64_t v41;
  NSObject *v42;
  uint64_t v43;
  const char *v44;
  void *v45;
  id v46;
  const char *v47;
  void *v48;
  const char *v49;
  uint64_t v50;
  _BYTE v51[12];
  __int16 v52;
  id v53;
  __int16 v54;
  id v55;
  uint64_t v56;

  v56 = *MEMORY[0x1E0C80C00];
  v7 = a2;
  v9 = a3;
  Property = *(id *)(a1 + 32);
  if (Property)
    Property = objc_getProperty(Property, v8, 368, 1);
  v11 = Property;
  dispatch_assert_queue_V2(v11);

  v13 = *(_QWORD *)(a1 + 32);
  if (!v13 || !*(_BYTE *)(v13 + 13))
  {
    ne_log_obj();
    ErrorInternal = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(ErrorInternal, OS_LOG_TYPE_FAULT))
    {
      v29 = *(_QWORD *)(a1 + 32);
      *(_DWORD *)v51 = 138412290;
      *(_QWORD *)&v51[4] = v29;
      _os_log_fault_impl(&dword_19BD16000, ErrorInternal, OS_LOG_TYPE_FAULT, "%@ already received config block", v51, 0xCu);
    }
    goto LABEL_35;
  }
  *(_BYTE *)(v13 + 13) = 0;
  if (!v7)
  {
    ne_log_obj();
    v30 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
    {
      v35 = *(_QWORD *)(a1 + 32);
      *(_DWORD *)v51 = 138412290;
      *(_QWORD *)&v51[4] = v35;
      _os_log_error_impl(&dword_19BD16000, v30, OS_LOG_TYPE_ERROR, "%@ Listener rejected this IKEv2 inbound connection by sending back nil sessionConfig", v51, 0xCu);
    }

    v26 = *(_QWORD *)(a1 + 40);
    v27 = CFSTR("Listener rejected this IKEv2 inbound connection by sending back nil sessionConfig");
    goto LABEL_34;
  }
  v14 = *(void **)(a1 + 32);
  if (v14)
  {
    v15 = objc_getProperty(v14, v12, 336, 1);
    if (v15)
    {
      v16 = v15[23] & 1;
      goto LABEL_9;
    }
  }
  else
  {
    v15 = 0;
  }
  v16 = 0;
LABEL_9:

  if (!v9 && (v16 & 1) == 0)
  {
    ne_log_obj();
    v18 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      v36 = *(_QWORD *)(a1 + 32);
      *(_DWORD *)v51 = 138412290;
      *(_QWORD *)&v51[4] = v36;
      _os_log_error_impl(&dword_19BD16000, v18, OS_LOG_TYPE_ERROR, "%@ Listener rejected this IKEv2 inbound connection by sending back nil childConfig", v51, 0xCu);
    }

    v26 = *(_QWORD *)(a1 + 40);
    v27 = CFSTR("Listener rejected this IKEv2 inbound connection by sending back nil childConfig");
LABEL_34:
    ErrorInternal = NEIKEv2CreateErrorInternal(v27, v19, v20, v21, v22, v23, v24, v25, *(uint64_t *)v51);
    (*(void (**)(uint64_t, NSObject *))(v26 + 16))(v26, ErrorInternal);
    goto LABEL_35;
  }
  v31 = *(void **)(a1 + 32);
  if (v31)
  {
    v32 = objc_getProperty(v31, v17, 336, 1);
    if (v32)
    {
      v33 = v32[23];

      if (v9)
      {
        if ((v33 & 1) != 0)
        {
          ne_log_obj();
          v34 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v34, OS_LOG_TYPE_FAULT))
          {
            v37 = *(_QWORD *)(a1 + 32);
            *(_DWORD *)v51 = 138412290;
            *(_QWORD *)&v51[4] = v37;
            _os_log_fault_impl(&dword_19BD16000, v34, OS_LOG_TYPE_FAULT, "%@ Listener sent back non-nil childConfig for childless SA connection", v51, 0xCu);
          }

          v26 = *(_QWORD *)(a1 + 40);
          v27 = CFSTR("Listener sent back non-nil childConfig for childless SA connection");
          goto LABEL_34;
        }
      }
    }
  }
  if (a4)
  {
    v38 = *(_QWORD *)(a1 + 32);
    if (v38 && *(_QWORD *)(v38 + 328))
    {
      ne_log_obj();
      v39 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v39, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)v51 = 0;
        _os_log_fault_impl(&dword_19BD16000, v39, OS_LOG_TYPE_FAULT, "Tried to set ipsecInterface when already set", v51, 2u);
      }

      v26 = *(_QWORD *)(a1 + 40);
      v27 = CFSTR("Tried to set ipsecInterface when already set");
      goto LABEL_34;
    }
    v40 = CFRetain(a4);
    v41 = *(_QWORD *)(a1 + 32);
    if (v41)
      *(_QWORD *)(v41 + 328) = v40;
  }
  ne_log_large_obj();
  v42 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v42, OS_LOG_TYPE_INFO))
  {
    v43 = *(_QWORD *)(a1 + 32);
    *(_DWORD *)v51 = 138412802;
    *(_QWORD *)&v51[4] = v43;
    v52 = 2112;
    v53 = v7;
    v54 = 2112;
    v55 = v9;
    _os_log_impl(&dword_19BD16000, v42, OS_LOG_TYPE_INFO, "%@ Received responseSessionConfig %@ responseChildConfig %@", v51, 0x20u);
  }

  v45 = *(void **)(a1 + 32);
  if (v45)
  {
    v46 = objc_getProperty(v45, v44, 336, 1);
    v48 = v46;
    if (v46)
      objc_setProperty_atomic(v46, v47, v7, 88);
  }
  else
  {
    v48 = 0;
  }

  if (v9)
    -[NEIKEv2Session addFirstChild:](*(void **)(a1 + 32), v9);
  v50 = *(_QWORD *)(a1 + 40);
  ErrorInternal = -[NEIKEv2Session setupReceivedChildCopyError](*(_QWORD **)(a1 + 32), v49);
  (*(void (**)(uint64_t, NSObject *))(v50 + 16))(v50, ErrorInternal);
LABEL_35:

}

- (void)receiveConnection:(_QWORD *)a1
{
  const char *v3;
  _DWORD *v4;
  NSObject *v5;
  SEL v6;
  _BYTE *v7;
  const char *v8;
  _BYTE *v9;
  int v10;
  id v11;
  char v12;
  NSObject *v13;
  NSObject *v14;
  const char *v15;
  void *v16;
  SEL v17;
  const char *v18;
  SEL v19;
  id v20;
  void *v21;
  SEL v22;
  const char *v23;
  _DWORD *v24;
  id *v25;
  SEL v26;
  id v27;
  NSObject *v28;
  NEIKEv2IKESAPayload *v29;
  SEL v30;
  SEL v31;
  id v32;
  void *v33;
  SEL v34;
  void *v35;
  const char *v36;
  void *v37;
  SEL v38;
  void *v39;
  char v40;
  NEIKEv2KeyExchangePayload *v41;
  SEL v42;
  SEL v43;
  id v44;
  const char *v45;
  void *v46;
  SEL v47;
  void *v48;
  const char *v49;
  void *v50;
  SEL v51;
  id v52;
  void *v53;
  void *v54;
  id v55;
  SEL v56;
  void *v57;
  const char *v58;
  void *v59;
  SEL v60;
  void *v61;
  char v62;
  NEIKEv2NoncePayload *v63;
  SEL v64;
  SEL v65;
  id v66;
  SEL v67;
  void *v68;
  const char *v69;
  void *v70;
  SEL v71;
  void *v72;
  char v73;
  const char *v74;
  void *v75;
  const char *v76;
  void *v77;
  SEL v78;
  id v79;
  NSObject *v80;
  const char *v81;
  void *v82;
  const char *v83;
  void *v84;
  SEL v85;
  id v86;
  NSObject *v87;
  const char *v88;
  id v89;
  void *v90;
  const char *v91;
  void *v92;
  NSObject *v93;
  const char *v94;
  id v95;
  int v96;
  const char *v97;
  id Property;
  const char *v99;
  void *v100;
  id v101;
  id *v102;
  id v103;
  const char *v104;
  id v105;
  unsigned int v106;
  void *v107;
  id v108;
  void *v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t i;
  void *v113;
  NEIKEv2VendorIDPayload *v114;
  const char *v115;
  void *v116;
  SEL v117;
  void *v118;
  const char *v119;
  void *v120;
  void *v121;
  SEL v122;
  SEL v123;
  SEL v124;
  id v125;
  void *v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  void *v131;
  NEIKEv2CustomPayload *v132;
  uint64_t v133;
  void *v134;
  SEL v135;
  SEL v136;
  void *v137;
  const char *v138;
  void *v139;
  void *v140;
  SEL v141;
  SEL v142;
  uint64_t v143;
  NSObject *v144;
  NSObject *v145;
  SEL v146;
  id v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  void *ErrorPeerInvalidSyntax;
  void *v156;
  const char *v157;
  const char *v158;
  void *v159;
  const char *v160;
  void *v161;
  SEL v162;
  id v163;
  const char *v164;
  void *v165;
  void *v166;
  void *v167;
  char v168;
  SEL v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  id v177;
  void *ErrorFailedToSend;
  NSObject *v179;
  SEL v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  NSObject *v188;
  char v189;
  SEL v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  id v198;
  void *ErrorInternal;
  const char *v200;
  NSObject *v201;
  uint32_t v202;
  NSObject *v203;
  SEL v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  NSObject *v212;
  SEL v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  void *v221;
  const char *v222;
  const char *v223;
  void *v224;
  const char *v225;
  const char *v226;
  const char *v227;
  const char *v228;
  char v229;
  NSObject *v230;
  NSObject *v231;
  NSObject *v232;
  SEL v233;
  id v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  void *ErrorCrypto;
  SEL v243;
  uint64_t v244;
  uint64_t v245;
  uint64_t v246;
  uint64_t v247;
  uint64_t v248;
  uint64_t v249;
  uint64_t v250;
  void *v251;
  const char *v252;
  const char *v253;
  NSObject *v254;
  NSObject *v255;
  const char *v256;
  NSObject *v257;
  uint64_t v258;
  NSObject *v259;
  NSObject *v260;
  NSObject *log;
  id v262;
  id v263;
  _DWORD *v264;
  id *self;
  _QWORD v266[4];
  id *v267;
  _QWORD *v268;
  unint64_t v269;
  __int128 v270;
  __int128 v271;
  __int128 v272;
  __int128 v273;
  __int128 v274;
  __int128 v275;
  __int128 v276;
  __int128 v277;
  NEIKEv2CustomPayload *v278;
  uint8_t v279[136];
  NEIKEv2VendorIDPayload *v280;
  uint8_t buf[4];
  const char *v282;
  __int16 v283;
  int v284;
  _QWORD v285[4];

  v285[1] = *MEMORY[0x1E0C80C00];
  v4 = a2;
  if (a1)
  {
    v5 = objc_getProperty(a1, v3, 368, 1);
    dispatch_assert_queue_V2(v5);

    v7 = objc_getProperty(a1, v6, 336, 1);
    v9 = v7;
    if (!v7)
    {
      ne_log_obj();
      v254 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v254, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136315138;
        v282 = "-[NEIKEv2Session(Exchange) receiveConnection:]";
        _os_log_fault_impl(&dword_19BD16000, v254, OS_LOG_TYPE_FAULT, "%s called with null ikeSA", buf, 0xCu);
      }

      goto LABEL_77;
    }
    if (v4 && (v10 = v4[6]) != 0)
    {
      ne_log_obj();
      v14 = objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        goto LABEL_72;
      *(_DWORD *)buf = 138412546;
      v282 = (const char *)a1;
      v283 = 1024;
      v284 = v10;
      v200 = "%@ Dropping IKE SA Init with wrong message ID %d";
      v201 = v14;
      v202 = 18;
    }
    else
    {
      v11 = objc_getProperty(v7, v8, 80, 1);
      v12 = objc_msgSend(v11, "serverMode");

      ne_log_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v14 = v13;
      if ((v12 & 1) != 0)
      {
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138412290;
          v282 = (const char *)a1;
          _os_log_impl(&dword_19BD16000, v14, OS_LOG_TYPE_DEFAULT, "%@ Starting IKEv2 responder from SA_INIT", buf, 0xCu);
        }

        v9[9] = 0;
        v16 = (void *)-[NEIKEv2Packet copyUnifiedData](v4, v15);
        objc_setProperty_atomic(v9, v17, v16, 320);

        -[NEIKEv2IKESA setState:error:]((uint64_t)v9, 1uLL, 0);
        -[NEIKEv2Session reportState](a1, v18);
        v20 = objc_getProperty(v9, v19, 304, 1);

        if (!v20)
        {
          objc_msgSend(a1, "ikeInterfaceName");
          v21 = (void *)objc_claimAutoreleasedReturnValue();
          objc_setProperty_atomic(v9, v22, v21, 304);

        }
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) == 0)
        {
          ne_log_obj();
          v145 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v145, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 138412290;
            v282 = (const char *)a1;
            _os_log_error_impl(&dword_19BD16000, v145, OS_LOG_TYPE_ERROR, "%@ Failed to receive IKE SA Init packet (receive)", buf, 0xCu);
          }

          v147 = objc_getProperty(a1, v146, 336, 1);
          ErrorPeerInvalidSyntax = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("Failed to receive IKE SA Init packet (receive)"), v148, v149, v150, v151, v152, v153, v154, v258);
LABEL_76:
          v156 = ErrorPeerInvalidSyntax;
          -[NEIKEv2IKESA setState:error:]((uint64_t)v147, 3uLL, ErrorPeerInvalidSyntax);

          -[NEIKEv2Session reportState](a1, v157);
          -[NEIKEv2Session resetAll]((uint64_t)a1, v158);
          goto LABEL_77;
        }
        v269 = 7;
        if ((-[NEIKEv2IKESAInitPacket validateSAInitAsResponder:errorCodeToSend:](v4, v9, &v269) & 1) != 0)
        {
          if ((-[NEIKEv2IKESA generateInitialValues](v9, v23) & 1) != 0)
          {
            v24 = v4;
            v25 = v9;
            objc_opt_self();
            v27 = objc_getProperty(v25, v26, 96, 1);

            if (!v27)
            {
              ne_log_obj();
              v28 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v28, OS_LOG_TYPE_FAULT))
              {
                *(_DWORD *)buf = 136315138;
                v282 = "+[NEIKEv2IKESAInitPacket(Exchange) createIKESAInitResponse:ikeSA:]";
                _os_log_fault_impl(&dword_19BD16000, v28, OS_LOG_TYPE_FAULT, "%s called with null ikeSA.chosenProposal", buf, 0xCu);
              }
              v144 = 0;
LABEL_120:

              if (v144)
              {
                v229 = -[NEIKEv2IKESA generateAllValuesForSAInit](v25, v228);
                ne_log_obj();
                v230 = objc_claimAutoreleasedReturnValue();
                v231 = v230;
                if ((v229 & 1) != 0)
                {
                  if (os_log_type_enabled(v230, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)buf = 138412290;
                    v282 = (const char *)a1;
                    _os_log_impl(&dword_19BD16000, v231, OS_LOG_TYPE_DEFAULT, "%@ Sending SA_INIT reply", buf, 0xCu);
                  }

                  v266[0] = MEMORY[0x1E0C809B0];
                  v266[1] = 3221225472;
                  v266[2] = __46__NEIKEv2Session_Exchange__receiveConnection___block_invoke;
                  v266[3] = &unk_1E3CC1090;
                  v267 = v25;
                  v268 = a1;
                  -[NEIKEv2Session handleIKEIntermediateForResponderIKESA:iteration:replyPacket:replyPacketDescription:handler:](a1, v267, 0, v144, CFSTR("responder SA INIT"), v266);

                  goto LABEL_132;
                }
                if (os_log_type_enabled(v230, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 138412290;
                  v282 = (const char *)a1;
                  _os_log_error_impl(&dword_19BD16000, v231, OS_LOG_TYPE_ERROR, "%@ Failed to generate crypto values (receive)", buf, 0xCu);
                }

                v234 = objc_getProperty(a1, v243, 336, 1);
                ErrorCrypto = (void *)NEIKEv2CreateErrorCrypto(CFSTR("Failed to generate crypto values (receive)"), v244, v245, v246, v247, v248, v249, v250, v258);
              }
              else
              {
                ne_log_obj();
                v232 = objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v232, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 138412290;
                  v282 = (const char *)a1;
                  _os_log_error_impl(&dword_19BD16000, v232, OS_LOG_TYPE_ERROR, "%@ Failed to create IKE SA Init packet (receive)", buf, 0xCu);
                }

                v234 = objc_getProperty(a1, v233, 336, 1);
                ErrorCrypto = (void *)NEIKEv2CreateErrorInternal(CFSTR("Failed to create IKE SA Init packet (receive)"), v235, v236, v237, v238, v239, v240, v241, v258);
              }
              v251 = ErrorCrypto;
              -[NEIKEv2IKESA setState:error:]((uint64_t)v234, 3uLL, ErrorCrypto);

              -[NEIKEv2Session reportState](a1, v252);
              -[NEIKEv2Session resetAll]((uint64_t)a1, v253);
LABEL_132:

              goto LABEL_77;
            }
            v28 = -[NEIKEv2Packet initResponse:]((uint64_t)[NEIKEv2IKESAInitPacket alloc], v24);
            if (!v28)
            {
              ne_log_obj();
              v80 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v80, OS_LOG_TYPE_FAULT))
              {
                *(_WORD *)buf = 0;
                _os_log_fault_impl(&dword_19BD16000, v80, OS_LOG_TYPE_FAULT, "[[NEIKEv2IKESAInitPacket alloc] initResponse:] failed", buf, 2u);
              }
              v144 = 0;
              goto LABEL_119;
            }
            v264 = v24;
            v29 = objc_alloc_init(NEIKEv2IKESAPayload);
            objc_setProperty_atomic(v28, v30, v29, 96);

            self = v25;
            v32 = objc_getProperty(v25, v31, 96, 1);
            v285[0] = v32;
            objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v285, 1);
            v33 = (void *)objc_claimAutoreleasedReturnValue();
            objc_getProperty(v28, v34, 96, 1);
            v35 = (void *)objc_claimAutoreleasedReturnValue();
            v37 = v35;
            if (v35)
              objc_setProperty_atomic(v35, v36, v33, 24);

            objc_getProperty(v28, v38, 96, 1);
            v39 = (void *)objc_claimAutoreleasedReturnValue();
            v40 = -[NEIKEv2Payload isValid]((uint64_t)v39);

            if ((v40 & 1) != 0)
            {
              v41 = objc_alloc_init(NEIKEv2KeyExchangePayload);
              objc_setProperty_atomic(v28, v42, v41, 104);

              v44 = objc_getProperty(self, v43, 96, 1);
              -[NEIKEv2IKESAProposal kemProtocol](v44, v45);
              v46 = (void *)objc_claimAutoreleasedReturnValue();
              objc_getProperty(v28, v47, 104, 1);
              v48 = (void *)objc_claimAutoreleasedReturnValue();
              v50 = v48;
              if (v48)
                objc_setProperty_atomic(v48, v49, v46, 24);

              v52 = objc_getProperty(self, v51, 160, 1);
              v53 = v52;
              if (v52)
                v54 = (void *)*((_QWORD *)v52 + 2);
              else
                v54 = 0;
              v55 = v54;
              objc_getProperty(v28, v56, 104, 1);
              v57 = (void *)objc_claimAutoreleasedReturnValue();
              v59 = v57;
              if (v57)
                objc_setProperty_atomic(v57, v58, v55, 32);

              objc_getProperty(v28, v60, 104, 1);
              v61 = (void *)objc_claimAutoreleasedReturnValue();
              v62 = -[NEIKEv2Payload isValid]((uint64_t)v61);

              if ((v62 & 1) != 0)
              {
                v63 = objc_alloc_init(NEIKEv2NoncePayload);
                objc_setProperty_atomic(v28, v64, v63, 112);

                v25 = self;
                v66 = objc_getProperty(self, v65, 128, 1);
                objc_getProperty(v28, v67, 112, 1);
                v68 = (void *)objc_claimAutoreleasedReturnValue();
                v70 = v68;
                if (v68)
                  objc_setProperty_atomic(v68, v69, v66, 24);

                objc_getProperty(v28, v71, 112, 1);
                v72 = (void *)objc_claimAutoreleasedReturnValue();
                v73 = -[NEIKEv2Payload isValid]((uint64_t)v72);

                if ((v73 & 1) != 0)
                {
                  -[NEIKEv2IKESA initiatorSPI](self, v74);
                  v75 = (void *)objc_claimAutoreleasedReturnValue();
                  -[NEIKEv2IKESA responderSPI](self, v76);
                  v77 = (void *)objc_claimAutoreleasedReturnValue();
                  v79 = objc_getProperty(self, v78, 64, 1);
                  v80 = +[NEIKEv2Crypto createNATDetectionHashForInitiatorSPI:responderSPI:address:]((uint64_t)NEIKEv2Crypto, v75, v77, v79);

                  if (!-[NEIKEv2Packet addNotification:data:](v28, 0x4004uLL, v80))
                  {
                    ne_log_obj();
                    v87 = objc_claimAutoreleasedReturnValue();
                    if (os_log_type_enabled(v87, OS_LOG_TYPE_FAULT))
                    {
                      *(_WORD *)buf = 0;
                      _os_log_fault_impl(&dword_19BD16000, v87, OS_LOG_TYPE_FAULT, "[packet addNotification:NEIKEv2NotifyTypeNATDetectionSourceIP] failed", buf, 2u);
                    }
                    v144 = 0;
                    v25 = self;
                    goto LABEL_160;
                  }
                  v260 = v80;
                  -[NEIKEv2IKESA initiatorSPI](self, v81);
                  v82 = (void *)objc_claimAutoreleasedReturnValue();
                  -[NEIKEv2IKESA responderSPI](self, v83);
                  v84 = (void *)objc_claimAutoreleasedReturnValue();
                  v86 = objc_getProperty(self, v85, 72, 1);
                  v87 = +[NEIKEv2Crypto createNATDetectionHashForInitiatorSPI:responderSPI:address:]((uint64_t)NEIKEv2Crypto, v82, v84, v86);

                  if (!-[NEIKEv2Packet addNotification:data:](v28, 0x4005uLL, v87))
                  {
                    ne_log_obj();
                    log = objc_claimAutoreleasedReturnValue();
                    if (os_log_type_enabled(log, OS_LOG_TYPE_FAULT))
                    {
                      *(_WORD *)buf = 0;
                      _os_log_fault_impl(&dword_19BD16000, log, OS_LOG_TYPE_FAULT, "[packet addNotification:NEIKEv2NotifyTypeNATDetectionDestinationIP] failed", buf, 2u);
                    }
                    v144 = 0;
                    goto LABEL_157;
                  }
                  if (!-[NEIKEv2Packet addNotification:data:](v28, 0x402EuLL, 0))
                  {
                    ne_log_obj();
                    log = objc_claimAutoreleasedReturnValue();
                    v25 = self;
                    if (os_log_type_enabled(log, OS_LOG_TYPE_FAULT))
                    {
                      *(_WORD *)buf = 0;
                      _os_log_fault_impl(&dword_19BD16000, log, OS_LOG_TYPE_FAULT, "[packet addNotification:NEIKEv2NotifyTypeIKEv2FragmentationSupported] failed", buf, 2u);
                    }
                    v144 = 0;
                    goto LABEL_158;
                  }
                  v89 = objc_getProperty(self, v88, 80, 1);
                  objc_msgSend(v89, "extraSupportedSignatureHashes");
                  v90 = (void *)objc_claimAutoreleasedReturnValue();
                  -[NEIKEv2IKESA remoteAuthentication](self, v91);
                  v92 = (void *)objc_claimAutoreleasedReturnValue();
                  v93 = +[NEIKEv2Crypto copySignHashDataForSet:authentication:]((uint64_t)NEIKEv2Crypto, v90, v92);

                  log = v93;
                  if (v93 && !-[NEIKEv2Packet addNotification:data:](v28, 0x402FuLL, v93))
                  {
                    ne_log_obj();
                    v255 = objc_claimAutoreleasedReturnValue();
                    if (!os_log_type_enabled(v255, OS_LOG_TYPE_FAULT))
                      goto LABEL_156;
                    *(_WORD *)buf = 0;
                    v256 = "[packet addNotification:NEIKEv2NotifyTypeSignatureHashAlgorithms] failed";
                  }
                  else
                  {
                    v95 = objc_getProperty(self, v94, 80, 1);
                    v96 = objc_msgSend(v95, "requestChildlessSA");

                    if (!v96 || -[NEIKEv2Packet addNotification:data:](v28, 0x4022uLL, 0))
                    {
                      if (((_BYTE)self[3] & 1) == 0 || -[NEIKEv2Packet addNotification:data:](v28, 0x4033uLL, 0))
                      {
                        Property = objc_getProperty(self, v97, 96, 1);
                        v100 = Property;
                        if (Property)
                          Property = objc_getProperty(Property, v99, 120, 1);
                        v101 = Property;

                        if (!v101 || -[NEIKEv2Packet addNotification:data:](v28, 0x4036uLL, 0))
                        {
                          v259 = v87;
                          v102 = self;
                          v103 = self[13];

                          if (v103)
                          {
                            v105 = self[13];
                            v106 = bswap32(objc_msgSend(v105, "securePasswordMethod")) >> 16;

                            *(_WORD *)buf = v106;
                            v107 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99D50]), "initWithBytes:length:", buf, 2);
                            if (!-[NEIKEv2Packet addNotification:data:](v28, 0x4028uLL, v107))
                            {
                              ne_log_obj();
                              v257 = objc_claimAutoreleasedReturnValue();
                              if (os_log_type_enabled(v257, OS_LOG_TYPE_FAULT))
                              {
                                *(_WORD *)v279 = 0;
                                _os_log_fault_impl(&dword_19BD16000, v257, OS_LOG_TYPE_FAULT, "[packet addNotification:NEIKEv2NotifyTypeSecurePasswordMethods] failed", v279, 2u);
                              }

                              v144 = 0;
                              goto LABEL_164;
                            }

                            v102 = self;
                          }
                          v276 = 0u;
                          v277 = 0u;
                          v275 = 0u;
                          v274 = 0u;
                          v108 = objc_getProperty(v102, v104, 80, 1);
                          objc_msgSend(v108, "customIKESAInitVendorPayloads");
                          v109 = (void *)objc_claimAutoreleasedReturnValue();

                          v110 = objc_msgSend(v109, "countByEnumeratingWithState:objects:count:", &v274, buf, 16);
                          if (v110)
                          {
                            v111 = v110;
                            v262 = *(id *)v275;
                            do
                            {
                              for (i = 0; i != v111; ++i)
                              {
                                if (*(id *)v275 != v262)
                                  objc_enumerationMutation(v109);
                                v113 = *(void **)(*((_QWORD *)&v274 + 1) + 8 * i);
                                v114 = objc_alloc_init(NEIKEv2VendorIDPayload);
                                objc_msgSend(v113, "vendorData");
                                v116 = (void *)objc_claimAutoreleasedReturnValue();
                                if (v114)
                                  objc_setProperty_atomic(v114, v115, v116, 24);

                                objc_getProperty(v28, v117, 120, 1);
                                v118 = (void *)objc_claimAutoreleasedReturnValue();

                                if (v118)
                                {
                                  objc_getProperty(v28, v119, 120, 1);
                                  v120 = (void *)objc_claimAutoreleasedReturnValue();
                                  objc_msgSend(v120, "arrayByAddingObject:", v114);
                                  v121 = (void *)objc_claimAutoreleasedReturnValue();
                                  objc_setProperty_atomic(v28, v122, v121, 120);

                                }
                                else
                                {
                                  v280 = v114;
                                  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", &v280, 1);
                                  v120 = (void *)objc_claimAutoreleasedReturnValue();
                                  objc_setProperty_atomic(v28, v123, v120, 120);
                                }

                              }
                              v111 = objc_msgSend(v109, "countByEnumeratingWithState:objects:count:", &v274, buf, 16);
                            }
                            while (v111);
                          }

                          v272 = 0u;
                          v273 = 0u;
                          v270 = 0u;
                          v271 = 0u;
                          v125 = objc_getProperty(self, v124, 80, 1);
                          objc_msgSend(v125, "customIKESAInitPayloads");
                          v126 = (void *)objc_claimAutoreleasedReturnValue();

                          v263 = v126;
                          v127 = objc_msgSend(v126, "countByEnumeratingWithState:objects:count:", &v270, v279, 16);
                          if (v127)
                          {
                            v128 = v127;
                            v129 = *(_QWORD *)v271;
                            do
                            {
                              v130 = 0;
                              do
                              {
                                if (*(_QWORD *)v271 != v129)
                                  objc_enumerationMutation(v263);
                                v131 = *(void **)(*((_QWORD *)&v270 + 1) + 8 * v130);
                                v132 = objc_alloc_init(NEIKEv2CustomPayload);
                                v133 = objc_msgSend(v131, "customType");
                                if (v132)
                                {
                                  v132->_customType = v133;
                                  objc_msgSend(v131, "customData");
                                  v134 = (void *)objc_claimAutoreleasedReturnValue();
                                  objc_setProperty_atomic(v132, v135, v134, 32);
                                }
                                else
                                {
                                  objc_msgSend(v131, "customData");
                                  v134 = (void *)objc_claimAutoreleasedReturnValue();
                                }

                                objc_getProperty(v28, v136, 56, 1);
                                v137 = (void *)objc_claimAutoreleasedReturnValue();

                                if (v137)
                                {
                                  objc_getProperty(v28, v138, 56, 1);
                                  v139 = (void *)objc_claimAutoreleasedReturnValue();
                                  objc_msgSend(v139, "arrayByAddingObject:", v132);
                                  v140 = (void *)objc_claimAutoreleasedReturnValue();
                                  objc_setProperty_atomic(v28, v141, v140, 56);

                                }
                                else
                                {
                                  v278 = v132;
                                  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", &v278, 1);
                                  v139 = (void *)objc_claimAutoreleasedReturnValue();
                                  objc_setProperty_atomic(v28, v142, v139, 56);
                                }

                                ++v130;
                              }
                              while (v128 != v130);
                              v143 = objc_msgSend(v263, "countByEnumeratingWithState:objects:count:", &v270, v279, 16);
                              v128 = v143;
                            }
                            while (v143);
                          }

                          v144 = v28;
LABEL_164:
                          v24 = v264;
                          v25 = self;
                          v87 = v259;
                          v80 = v260;
                          goto LABEL_159;
                        }
                        ne_log_obj();
                        v255 = objc_claimAutoreleasedReturnValue();
                        if (!os_log_type_enabled(v255, OS_LOG_TYPE_FAULT))
                          goto LABEL_156;
                        *(_WORD *)buf = 0;
                        v256 = "[packet addNotification:NEIKEv2NotifyTypeIntermediateExchangeSupported] failed";
                        goto LABEL_155;
                      }
                      ne_log_obj();
                      v255 = objc_claimAutoreleasedReturnValue();
                      if (os_log_type_enabled(v255, OS_LOG_TYPE_FAULT))
                      {
                        *(_WORD *)buf = 0;
                        v256 = "[packet addNotification:NEIKEv2NotifyTypeUsePPK] failed";
                        goto LABEL_155;
                      }
LABEL_156:

                      v144 = 0;
LABEL_157:
                      v25 = self;
LABEL_158:
                      v24 = v264;
                      v80 = v260;
LABEL_159:

LABEL_160:
                      goto LABEL_119;
                    }
                    ne_log_obj();
                    v255 = objc_claimAutoreleasedReturnValue();
                    if (!os_log_type_enabled(v255, OS_LOG_TYPE_FAULT))
                      goto LABEL_156;
                    *(_WORD *)buf = 0;
                    v256 = "[packet addNotification:NEIKEv2NotifyTypeChildlessIKEv2Supported] failed";
                  }
LABEL_155:
                  _os_log_fault_impl(&dword_19BD16000, v255, OS_LOG_TYPE_FAULT, v256, buf, 2u);
                  goto LABEL_156;
                }
                ne_log_obj();
                v80 = objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v80, OS_LOG_TYPE_FAULT))
                {
                  *(_DWORD *)buf = 136315138;
                  v282 = "+[NEIKEv2IKESAInitPacket(Exchange) createIKESAInitResponse:ikeSA:]";
                  v227 = "%s called with null packet.nonce.isValid";
                  goto LABEL_117;
                }
LABEL_118:
                v144 = 0;
LABEL_119:

                goto LABEL_120;
              }
              ne_log_obj();
              v80 = objc_claimAutoreleasedReturnValue();
              v25 = self;
              if (!os_log_type_enabled(v80, OS_LOG_TYPE_FAULT))
                goto LABEL_118;
              *(_DWORD *)buf = 136315138;
              v282 = "+[NEIKEv2IKESAInitPacket(Exchange) createIKESAInitResponse:ikeSA:]";
              v227 = "%s called with null packet.ke.isValid";
            }
            else
            {
              ne_log_obj();
              v80 = objc_claimAutoreleasedReturnValue();
              v25 = self;
              if (!os_log_type_enabled(v80, OS_LOG_TYPE_FAULT))
                goto LABEL_118;
              *(_DWORD *)buf = 136315138;
              v282 = "+[NEIKEv2IKESAInitPacket(Exchange) createIKESAInitResponse:ikeSA:]";
              v227 = "%s called with null packet.sa.isValid";
            }
LABEL_117:
            _os_log_fault_impl(&dword_19BD16000, v80, OS_LOG_TYPE_FAULT, v227, buf, 0xCu);
            goto LABEL_118;
          }
          ne_log_obj();
          v179 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v179, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 138412290;
            v282 = (const char *)a1;
            _os_log_error_impl(&dword_19BD16000, v179, OS_LOG_TYPE_ERROR, "%@ Failed to generate local crypto values (receive)", buf, 0xCu);
          }

          v147 = objc_getProperty(a1, v180, 336, 1);
          ErrorPeerInvalidSyntax = (void *)NEIKEv2CreateErrorCrypto(CFSTR("Failed to generate local crypto values (receive)"), v181, v182, v183, v184, v185, v186, v187, v258);
          goto LABEL_76;
        }
        if (v269 == 17)
        {
          objc_getProperty(v4, v23, 104, 1);
          v159 = (void *)objc_claimAutoreleasedReturnValue();
          v161 = v159;
          if (v159)
            v159 = objc_getProperty(v159, v160, 24, 1);
          v14 = v159;

          v163 = objc_getProperty(v9, v162, 96, 1);
          -[NEIKEv2IKESAProposal kemProtocol](v163, v164);
          v165 = (void *)objc_claimAutoreleasedReturnValue();

          *(_WORD *)v279 = bswap32(objc_msgSend(v165, "method")) >> 16;
          v166 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99D50]), "initWithBytes:length:", v279, 2);
          +[NEIKEv2IKESAInitPacket createIKESAInitResponse:errorCode:errorData:]((uint64_t)NEIKEv2IKESAInitPacket, v4, 0x11uLL, v166);
          v167 = (void *)objc_claimAutoreleasedReturnValue();

          if (v167)
          {
            v168 = -[NEIKEv2Session sendReply:replyHandler:]((uint64_t)a1, v167, 0);
            v177 = objc_getProperty(a1, v169, 336, 1);
            if ((v168 & 1) != 0)
              ErrorFailedToSend = (void *)NEIKEv2CreateErrorCrypto(CFSTR("KE method received in IKE SA Init packet (%@) doesn't match selected (%@) (receive)"), v170, v171, v172, v173, v174, v175, v176, (uint64_t)v14);
            else
              ErrorFailedToSend = (void *)NEIKEv2CreateErrorFailedToSend(CFSTR("SA INIT INVALID KE"), v170, v171, v172, v173, v174, v175, v176, v258);
          }
          else
          {
            ne_log_obj();
            v203 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v203, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 138412290;
              v282 = (const char *)a1;
              _os_log_error_impl(&dword_19BD16000, v203, OS_LOG_TYPE_ERROR, "%@ Failed to create IKE SA Init Invalid KE packet", buf, 0xCu);
            }

            v177 = objc_getProperty(a1, v204, 336, 1);
            ErrorFailedToSend = (void *)NEIKEv2CreateErrorInternal(CFSTR("Failed to create IKE SA Init Invalid KE packet"), v205, v206, v207, v208, v209, v210, v211, v258);
          }
          v221 = ErrorFailedToSend;
          -[NEIKEv2IKESA setState:error:]((uint64_t)v177, 3uLL, ErrorFailedToSend);

          -[NEIKEv2Session reportState](a1, v222);
          -[NEIKEv2Session resetAll]((uint64_t)a1, v223);

        }
        else
        {
          ne_log_obj();
          v188 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v188, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 138412290;
            v282 = (const char *)a1;
            _os_log_error_impl(&dword_19BD16000, v188, OS_LOG_TYPE_ERROR, "%@ Failed to process IKE SA Init packet (receive)", buf, 0xCu);
          }

          +[NEIKEv2IKESAInitPacket createIKESAInitResponse:errorCode:errorData:]((uint64_t)NEIKEv2IKESAInitPacket, v4, v269, 0);
          v14 = objc_claimAutoreleasedReturnValue();
          if (v14)
          {
            v189 = -[NEIKEv2Session sendReply:replyHandler:]((uint64_t)a1, v14, 0);
            v198 = objc_getProperty(a1, v190, 336, 1);
            if ((v189 & 1) != 0)
              ErrorInternal = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("Failed to process IKE SA Init packet (receive)"), v191, v192, v193, v194, v195, v196, v197, v258);
            else
              ErrorInternal = (void *)NEIKEv2CreateErrorFailedToSend(CFSTR("SA INIT refusal"), v191, v192, v193, v194, v195, v196, v197, v258);
          }
          else
          {
            ne_log_obj();
            v212 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v212, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 138412290;
              v282 = (const char *)a1;
              _os_log_error_impl(&dword_19BD16000, v212, OS_LOG_TYPE_ERROR, "%@ Failed to create IKE SA Init refusal packet", buf, 0xCu);
            }

            v198 = objc_getProperty(a1, v213, 336, 1);
            ErrorInternal = (void *)NEIKEv2CreateErrorInternal(CFSTR("Failed to create IKE SA Init refusal packet"), v214, v215, v216, v217, v218, v219, v220, v258);
          }
          v224 = ErrorInternal;
          -[NEIKEv2IKESA setState:error:]((uint64_t)v198, 3uLL, ErrorInternal);

          -[NEIKEv2Session reportState](a1, v225);
          -[NEIKEv2Session resetAll]((uint64_t)a1, v226);
        }
LABEL_72:

LABEL_77:
        goto LABEL_78;
      }
      if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        goto LABEL_72;
      *(_DWORD *)buf = 138412290;
      v282 = (const char *)a1;
      v200 = "%@ Dropping IKE SA Init sent to non-server session";
      v201 = v14;
      v202 = 12;
    }
    _os_log_error_impl(&dword_19BD16000, v201, OS_LOG_TYPE_ERROR, v200, buf, v202);
    goto LABEL_72;
  }
LABEL_78:

}

void __46__NEIKEv2Session_Exchange__receiveConnection___block_invoke(uint64_t a1, void *a2)
{
  id v3;
  _BYTE *v4;
  const char *v5;
  uint64_t v6;
  const char *v7;
  id v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t i;
  const __CFString *v13;
  unint64_t length;
  void *Property;
  const char *v16;
  void *v17;
  id v18;
  const char *v19;
  id v20;
  id v21;
  const char *v22;
  void *v23;
  const char *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  void *ErrorPeerInvalidSyntax;
  NSObject *v33;
  NSObject *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  __CFString *v42;
  void *v43;
  const char *v44;
  void *v45;
  id v46;
  void *v47;
  const char *v48;
  void *v49;
  id v50;
  id v51;
  SEL v52;
  void *v53;
  const char *v54;
  void *v55;
  id v56;
  id v57;
  int v58;
  const char *v59;
  uint64_t v60;
  void *v61;
  const char *v62;
  void *v63;
  id v64;
  id v65;
  SEL v66;
  id v67;
  const char *v68;
  void *v69;
  id v70;
  id v71;
  SEL v72;
  void *v73;
  const char *v74;
  void *v75;
  id v76;
  id v77;
  SEL v78;
  void *v79;
  const char *v80;
  void *v81;
  id v82;
  id v83;
  void *v84;
  void *v85;
  id v86;
  SEL v87;
  uint64_t v88;
  void *v89;
  void *v90;
  id v91;
  void *v92;
  const char *v93;
  NSObject *v94;
  SEL v95;
  uint64_t v96;
  void *v97;
  void *v98;
  id v99;
  void *v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  SEL v108;
  uint64_t v109;
  id v110;
  void *v111;
  id v112;
  id v113;
  void *v114;
  _QWORD *v115;
  const char *v116;
  _QWORD *v117;
  uint64_t v118;
  const char *v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  void *v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  void *v136;
  const char *v137;
  void *v138;
  id v139;
  NSObject *v140;
  NSObject *v141;
  id v142;
  const char *v143;
  const char *v144;
  uint64_t v145;
  void *v146;
  uint64_t v147;
  const char *v148;
  void **v149;
  NSObject *v150;
  id WeakRetained;
  const char *v152;
  void *v153;
  const char *v154;
  NEIKEv2SessionConfiguration *v155;
  id v156;
  id v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  void *ErrorFailedToSend;
  const char *v166;
  const char *v167;
  _BYTE *v168;
  const char *v169;
  void *v170;
  const char *v171;
  void *v172;
  id *v173;
  const char *v174;
  id *v175;
  const char *v176;
  void *v177;
  void *v178;
  void *v179;
  void *v180;
  void *v181;
  SEL v182;
  id v183;
  const char *v184;
  void *v185;
  _QWORD *v186;
  NEIKEv2ChildSAConfiguration *v187;
  void *v188;
  uint64_t v189;
  NSObject *v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t ErrorInternal;
  uint64_t v199;
  NSObject *v200;
  void *v201;
  void *v202;
  SEL v203;
  id v204;
  void *v205;
  char *v206;
  char *v207;
  char *v208;
  SEL v209;
  uint64_t v210;
  void *v211;
  void *v212;
  id v213;
  void *v214;
  id v215;
  char *v216;
  char *v217;
  NSObject *v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  id v227;
  uint64_t v228;
  _QWORD v229[2];
  void (*v230)(void **, void *);
  void *v231;
  uint64_t v232;
  id v233;
  id v234;
  id location[2];
  __int128 v236;
  __int128 v237;
  __int128 v238;
  uint8_t v239[4];
  const char *v240;
  __int16 v241;
  id v242;
  __int16 v243;
  id v244;
  _BYTE buf[24];
  void *v246;
  uint64_t v247;
  id v248[15];

  v248[12] = *(id *)MEMORY[0x1E0C80C00];
  v3 = a2;
  v4 = *(id *)(a1 + 32);
  v6 = (uint64_t)v4;
  if (!v3)
    goto LABEL_96;
  if (v4 && (v4[9] & 1) != 0)
  {
    ne_log_obj();
    v218 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v218, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)v239 = 136315138;
      v240 = "-[NEIKEv2IKEAuthPacket(Exchange) validateAuthPart1AsResponderCopyErrorForIKESA:errorCodeToSend:]";
      _os_log_fault_impl(&dword_19BD16000, v218, OS_LOG_TYPE_FAULT, "%s called with null !ikeSA.isInitiator", v239, 0xCu);
    }

    ErrorInternal = NEIKEv2CreateErrorInternal(CFSTR("validateAuthPart1AsResponder called as initiator"), v219, v220, v221, v222, v223, v224, v225, v226);
    goto LABEL_136;
  }
  if (-[NEIKEv2Packet hasErrors](v3, v5))
  {
    v237 = 0u;
    v238 = 0u;
    *(_OWORD *)location = 0u;
    v236 = 0u;
    v8 = objc_getProperty(v3, v7, 64, 1);
    v9 = objc_msgSend(v8, "countByEnumeratingWithState:objects:count:", location, buf, 16);
    if (v9)
    {
      v10 = v9;
      v11 = *(_QWORD *)v236;
      while (2)
      {
        for (i = 0; i != v10; ++i)
        {
          if (*(_QWORD *)v236 != v11)
            objc_enumerationMutation(v8);
          v13 = (const __CFString *)*((_QWORD *)location[1] + i);
          if (v13)
          {
            length = v13->length;
            if (length - 1 <= 0x3FFE)
            {
              ErrorPeerInvalidSyntax = (void *)-[NEIKEv2NotifyPayload copyError](v13);
              if (!ErrorPeerInvalidSyntax)
                ErrorPeerInvalidSyntax = (void *)NEIKEv2CreateErrorInternal(CFSTR("Failed to copy notify error"), v25, v26, v27, v28, v29, v30, v31, v226);
              ne_log_obj();
              v33 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
              {
                v206 = (char *)objc_msgSend(v3, "copyShortDescription");
                *(_DWORD *)v239 = 138412546;
                v240 = v206;
                v241 = 2112;
                v242 = ErrorPeerInvalidSyntax;
                _os_log_error_impl(&dword_19BD16000, v33, OS_LOG_TYPE_ERROR, "%@ Responder auth received notify error %@", v239, 0x16u);

              }
              goto LABEL_102;
            }
          }
        }
        v10 = objc_msgSend(v8, "countByEnumeratingWithState:objects:count:", location, buf, 16);
        if (v10)
          continue;
        break;
      }
    }

  }
  objc_getProperty(v3, v7, 96, 1);
  Property = (void *)objc_claimAutoreleasedReturnValue();
  v17 = Property;
  if (Property)
    Property = objc_getProperty(Property, v16, 24, 1);
  v18 = Property;

  if (!v18)
  {
    ne_log_obj();
    v34 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
    {
      v207 = (char *)objc_msgSend(v3, "copyShortDescription");
      *(_DWORD *)v239 = 138412290;
      v240 = v207;
      _os_log_error_impl(&dword_19BD16000, v34, OS_LOG_TYPE_ERROR, "%@ Initiator ID missing", v239, 0xCu);

    }
    v42 = CFSTR("Initiator ID missing");
    goto LABEL_100;
  }
  if (v6)
    v20 = objc_getProperty((id)v6, v19, 80, 1);
  else
    v20 = 0;
  v21 = v20;
  if ((objc_msgSend(v21, "requestChildlessSA") & 1) == 0)
  {

    goto LABEL_33;
  }
  objc_getProperty(v3, v22, 88, 1);
  v23 = (void *)objc_claimAutoreleasedReturnValue();

  if (v23)
  {
LABEL_33:
    if (v6 && (*(_BYTE *)(v6 + 23) & 1) != 0)
      goto LABEL_38;
    goto LABEL_35;
  }
  if (v6)
  {
    *(_BYTE *)(v6 + 23) = 1;
    goto LABEL_38;
  }
LABEL_35:
  objc_getProperty(v3, v24, 88, 1);
  v43 = (void *)objc_claimAutoreleasedReturnValue();
  v45 = v43;
  if (v43)
    v43 = objc_getProperty(v43, v44, 24, 1);
  v46 = v43;

  if (!v46)
  {
    ne_log_obj();
    v140 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v140, OS_LOG_TYPE_ERROR))
    {
      v216 = (char *)objc_msgSend(v3, "copyShortDescription");
      *(_DWORD *)v239 = 138412290;
      v240 = v216;
      _os_log_error_impl(&dword_19BD16000, v140, OS_LOG_TYPE_ERROR, "%@ Received no SA proposals", v239, 0xCu);

    }
    v42 = CFSTR("Received no SA proposals");
LABEL_100:
    ErrorPeerInvalidSyntax = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(v42, v35, v36, v37, v38, v39, v40, v41, v226);
    goto LABEL_101;
  }
LABEL_38:
  objc_getProperty(v3, v24, 96, 1);
  v47 = (void *)objc_claimAutoreleasedReturnValue();
  v49 = v47;
  if (v47)
    v50 = objc_getProperty(v47, v48, 24, 1);
  else
    v50 = 0;
  v51 = v50;
  if (v6)
    objc_storeStrong((id *)(v6 + 344), v50);

  objc_getProperty(v3, v52, 104, 1);
  v53 = (void *)objc_claimAutoreleasedReturnValue();
  v55 = v53;
  if (v53)
    v56 = objc_getProperty(v53, v54, 24, 1);
  else
    v56 = 0;
  v57 = v56;
  if (v6)
    objc_storeStrong((id *)(v6 + 336), v56);

  v58 = -[NEIKEv2Packet hasNotification:](v3, (const char *)0x4007);
  if (v6)
  {
    v60 = 1;
    if (!v58)
      v60 = 2;
    *(_QWORD *)(v6 + 352) = v60;
  }
  objc_getProperty(v3, v59, 88, 1);
  v61 = (void *)objc_claimAutoreleasedReturnValue();
  v63 = v61;
  if (v61)
    v64 = objc_getProperty(v61, v62, 24, 1);
  else
    v64 = 0;
  v65 = v64;
  if (v6)
    objc_storeStrong((id *)(v6 + 360), v64);

  v67 = objc_getProperty(v3, v66, 152, 1);
  v69 = v67;
  if (v67)
    v70 = objc_getProperty(v67, v68, 24, 1);
  else
    v70 = 0;
  v71 = v70;
  if (v6)
    objc_storeStrong((id *)(v6 + 392), v70);

  objc_getProperty(v3, v72, 160, 1);
  v73 = (void *)objc_claimAutoreleasedReturnValue();
  v75 = v73;
  if (v73)
    v76 = objc_getProperty(v73, v74, 24, 1);
  else
    v76 = 0;
  v77 = v76;
  if (v6)
    objc_storeStrong((id *)(v6 + 400), v76);

  objc_getProperty(v3, v78, 168, 1);
  v79 = (void *)objc_claimAutoreleasedReturnValue();
  v81 = v79;
  if (v79)
    v82 = objc_getProperty(v79, v80, 24, 1);
  else
    v82 = 0;
  v83 = v82;
  v84 = v83;
  if (v6)
  {
    objc_storeStrong((id *)(v6 + 408), v82);

    v85 = *(void **)(v6 + 104);
  }
  else
  {

    v85 = 0;
  }
  v86 = v85;

  objc_getProperty(v3, v87, 128, 1);
  v88 = objc_claimAutoreleasedReturnValue();
  v89 = (void *)v88;
  if (v88)
    v90 = *(void **)(v88 + 24);
  else
    v90 = 0;
  v91 = v90;
  v92 = v91;
  if (!v86)
  {
    -[NEIKEv2IKESA setAuthProtocolFromPacket:](v6, v91);

    objc_getProperty(v3, v108, 128, 1);
    v109 = objc_claimAutoreleasedReturnValue();
    v110 = (id)v109;
    if (v109)
      v111 = *(void **)(v109 + 32);
    else
      v111 = 0;
    v112 = v111;
    if (v6)
      objc_storeStrong((id *)(v6 + 376), v111);

    goto LABEL_86;
  }

  if (v92)
  {
    ne_log_obj();
    v94 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v94, OS_LOG_TYPE_ERROR))
    {
      v208 = (char *)objc_msgSend(v3, "copyShortDescription");
      objc_getProperty(v3, v209, 128, 1);
      v210 = objc_claimAutoreleasedReturnValue();
      v211 = (void *)v210;
      if (v210)
        v212 = *(void **)(v210 + 24);
      else
        v212 = 0;
      v213 = v212;
      if (v6)
        v214 = *(void **)(v6 + 104);
      else
        v214 = 0;
      v215 = v214;
      *(_DWORD *)v239 = 138412802;
      v240 = v208;
      v241 = 2112;
      v242 = v213;
      v243 = 2112;
      v244 = v215;
      _os_log_error_impl(&dword_19BD16000, v94, OS_LOG_TYPE_ERROR, "%@ Responder packet authentication method %@ is not compatible with configuration %@", v239, 0x20u);

    }
    objc_getProperty(v3, v95, 128, 1);
    v96 = objc_claimAutoreleasedReturnValue();
    v97 = (void *)v96;
    if (v96)
      v98 = *(void **)(v96 + 24);
    else
      v98 = 0;
    v99 = v98;
    if (v6)
      v100 = *(void **)(v6 + 104);
    else
      v100 = 0;
    v227 = v100;
    ErrorPeerInvalidSyntax = (void *)NEIKEv2CreateErrorAuthentication(CFSTR("Responder packet authentication method %@ is not compatible with configuration %@"), v101, v102, v103, v104, v105, v106, v107, (uint64_t)v99);

    goto LABEL_76;
  }
  v113 = objc_getProperty(v3, v93, 144, 1);

  if (!v113)
  {
    ne_log_obj();
    v190 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v190, OS_LOG_TYPE_ERROR))
    {
      v217 = (char *)objc_msgSend(v3, "copyShortDescription");
      *(_DWORD *)v239 = 138412290;
      v240 = v217;
      _os_log_error_impl(&dword_19BD16000, v190, OS_LOG_TYPE_ERROR, "%@ Packet missing GSPM payload", v239, 0xCu);

    }
    ErrorInternal = NEIKEv2CreateErrorAuthentication(CFSTR("Packet missing GSPM payload"), v191, v192, v193, v194, v195, v196, v197, v226);
LABEL_136:
    ErrorPeerInvalidSyntax = (void *)ErrorInternal;
LABEL_76:
    length = 24;
    goto LABEL_102;
  }
  if (v6)
    v114 = *(void **)(v6 + 104);
  else
    v114 = 0;
  v110 = v114;
  -[NEIKEv2IKESA setAuthProtocolFromPacket:](v6, v110);
LABEL_86:

  if (!v6 || (*(_BYTE *)(v6 + 24) & 1) == 0)
    goto LABEL_96;
  v115 = -[NEIKEv2Packet copyNotification:](v3, (const char *)0x4034);
  v117 = v115;
  if (!v115)
  {
LABEL_95:

LABEL_96:
    goto LABEL_107;
  }
  v118 = -[NEIKEv2NotifyPayload getPPKIDType](v115, v116);
  v126 = v118;
  if ((unint64_t)(v118 - 3) <= 0xFFFFFFFFFFFFFFFDLL)
  {
    ErrorPeerInvalidSyntax = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("PPK ID type %zu is invalid"), (uint64_t)v119, v120, v121, v122, v123, v124, v125, v118);
  }
  else
  {
    v127 = (void *)-[NEIKEv2NotifyPayload copyPPKID](v117, v119);
    v128 = objc_msgSend(v127, "length");
    if (v126 != 2 || v128)
    {
      -[NEIKEv2IKESA setPpkIDFromPacket:](v6, v127);
      *(_QWORD *)(v6 + 416) = v126;
      v136 = -[NEIKEv2Packet copyNotification:](v3, (const char *)0x4035);
      v138 = v136;
      if (v136)
        v136 = objc_getProperty(v136, v137, 32, 1);
      v139 = v136;
      -[NEIKEv2IKESA setPrimeAuthenticationDataFromPacket:](v6, v139);

      goto LABEL_95;
    }
    ErrorPeerInvalidSyntax = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("PPK ID missing from payload"), v129, v130, v131, v132, v133, v134, v135, v226);

  }
LABEL_101:
  length = 7;
LABEL_102:

  if (ErrorPeerInvalidSyntax)
  {
    ne_log_obj();
    v141 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v141, OS_LOG_TYPE_ERROR))
    {
      v199 = *(_QWORD *)(a1 + 40);
      *(_DWORD *)buf = 138412546;
      *(_QWORD *)&buf[4] = v199;
      *(_WORD *)&buf[12] = 2112;
      *(_QWORD *)&buf[14] = ErrorPeerInvalidSyntax;
      _os_log_error_impl(&dword_19BD16000, v141, OS_LOG_TYPE_ERROR, "%@ Failed to process IKE Auth packet (receive p1) %@", buf, 0x16u);
    }

    v142 = +[NEIKEv2IKEAuthPacket createIKEAuthResponse:refusalError:]((uint64_t)NEIKEv2IKEAuthPacket, v3, length);
    if ((-[NEIKEv2Session sendReply:replyHandler:](*(_QWORD *)(a1 + 40), v142, 0) & 1) != 0)
    {
      -[NEIKEv2IKESA setState:error:](*(_QWORD *)(a1 + 32), 3uLL, ErrorPeerInvalidSyntax);
      -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 40), v144);
    }
    else
    {
      v156 = *(id *)(a1 + 40);
      if (v156)
        v156 = objc_getProperty(v156, v143, 336, 1);
      v157 = v156;
      ErrorFailedToSend = (void *)NEIKEv2CreateErrorFailedToSend(CFSTR("AUTH refusal p1 %@"), v158, v159, v160, v161, v162, v163, v164, (uint64_t)ErrorPeerInvalidSyntax);
      -[NEIKEv2IKESA setState:error:]((uint64_t)v157, 3uLL, ErrorFailedToSend);

      -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 40), v166);
      -[NEIKEv2Session resetAll](*(_QWORD *)(a1 + 40), v167);
    }

    goto LABEL_147;
  }
LABEL_107:
  v145 = MEMORY[0x1E0C809B0];
  v229[0] = MEMORY[0x1E0C809B0];
  v229[1] = 3221225472;
  v230 = __46__NEIKEv2Session_Exchange__receiveConnection___block_invoke_209;
  v231 = &unk_1E3CC1068;
  v146 = *(void **)(a1 + 32);
  v232 = *(_QWORD *)(a1 + 40);
  v147 = v232;
  v233 = v146;
  v234 = v3;
  v149 = v229;
  if (v147)
  {
    v150 = objc_getProperty((id)v147, v148, 368, 1);
    dispatch_assert_queue_V2(v150);

    WeakRetained = objc_loadWeakRetained((id *)(v147 + 344));
    -[NEIKEv2Session firstChildSA]((void *)v147, v152);
    v153 = (void *)objc_claimAutoreleasedReturnValue();

    if (v153 || !WeakRetained)
    {
      v168 = objc_getProperty((id)v147, v154, 336, 1);
      v170 = v168;
      if (v168 && (v168[23] & 1) != 0)
      {
        -[NEIKEv2Session firstChildSA]((void *)v147, v169);
        v172 = (void *)objc_claimAutoreleasedReturnValue();

        if (v172)
          -[NEIKEv2Session removeFirstChild](v147, v171);
      }
      else
      {

      }
      v155 = (NEIKEv2SessionConfiguration *)-[NEIKEv2Session setupReceivedChildCopyError]((_QWORD *)v147, v171);
      v230(v149, v155);
    }
    else if (*(_BYTE *)(v147 + 13))
    {
      ne_log_obj();
      v155 = (NEIKEv2SessionConfiguration *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(&v155->super, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 138412290;
        *(_QWORD *)&buf[4] = v147;
        _os_log_fault_impl(&dword_19BD16000, &v155->super, OS_LOG_TYPE_FAULT, "%@ already expecting config block", buf, 0xCu);
      }
    }
    else
    {
      *(_WORD *)(v147 + 13) = 257;
      v173 = (id *)objc_getProperty((id)v147, v154, 336, 1);
      v175 = v173;
      if (v173)
      {
        if (objc_getProperty(v173, v174, 88, 1))
        {
          v155 = (NEIKEv2SessionConfiguration *)objc_msgSend(objc_getProperty(v175, v176, 88, 1), "copy");
        }
        else
        {
          v155 = objc_alloc_init(NEIKEv2SessionConfiguration);
          v177 = (void *)objc_msgSend(v175[42], "copy");
          -[NEIKEv2SessionConfiguration setLocalIdentifier:](v155, "setLocalIdentifier:", v177);

          v178 = (void *)objc_msgSend(v175[43], "copy");
          -[NEIKEv2SessionConfiguration setRemoteIdentifier:](v155, "setRemoteIdentifier:", v178);

          v179 = (void *)objc_msgSend(v175[46], "copy");
          -[NEIKEv2SessionConfiguration setRemoteAuthentication:](v155, "setRemoteAuthentication:", v179);

          v180 = (void *)objc_msgSend(v175[49], "copy");
          -[NEIKEv2SessionConfiguration setConfigurationRequest:](v155, "setConfigurationRequest:", v180);

          v181 = (void *)objc_msgSend(v175[53], "copy");
          -[NEIKEv2SessionConfiguration setPpkID:](v155, "setPpkID:", v181);

          -[NEIKEv2SessionConfiguration setPpkIDType:](v155, "setPpkIDType:", v175[52]);
        }
      }
      else
      {
        v155 = 0;
      }

      v183 = objc_getProperty((id)v147, v182, 336, 1);
      v185 = v183;
      if (v183 && (*((_BYTE *)v183 + 23) & 1) != 0)
      {
        v187 = 0;
      }
      else
      {
        v186 = objc_getProperty((id)v147, v184, 336, 1);
        if (v186)
        {
          v187 = objc_alloc_init(NEIKEv2ChildSAConfiguration);
          -[NEIKEv2ChildSAConfiguration setMode:](v187, "setMode:", v186[44]);
          v188 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99D20]), "initWithArray:copyItems:", v186[45], 1);
          -[NEIKEv2ChildSAConfiguration setProposals:](v187, "setProposals:", v188);

          if ((*((_BYTE *)v186 + 9) & 1) != 0)
          {
            ne_log_obj();
            v200 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v200, OS_LOG_TYPE_FAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_fault_impl(&dword_19BD16000, v200, OS_LOG_TYPE_FAULT, "copyChildConfig called on initiator", buf, 2u);
            }

            v228 = 50;
            v189 = 51;
          }
          else
          {
            v228 = 51;
            v189 = 50;
          }
          v201 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99D20]), "initWithArray:copyItems:", v186[v189], 1);
          -[NEIKEv2ChildSAConfiguration setRemoteTrafficSelectors:](v187, "setRemoteTrafficSelectors:", v201);

          v202 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99D20]), "initWithArray:copyItems:", v186[v228], 1);
          -[NEIKEv2ChildSAConfiguration setLocalTrafficSelectors:](v187, "setLocalTrafficSelectors:", v202);

        }
        else
        {
          v187 = 0;
        }

        v145 = MEMORY[0x1E0C809B0];
      }

      v204 = objc_getProperty((id)v147, v203, 336, 1);
      if (v204)
      {
        objc_initWeak(location, v204);
        *(_QWORD *)buf = v145;
        *(_QWORD *)&buf[8] = 3221225472;
        *(_QWORD *)&buf[16] = __45__NEIKEv2IKESA_Crypto__copyValidateAuthBlock__block_invoke;
        v246 = &unk_1E3CC0DB0;
        objc_copyWeak(v248, location);
        v247 = (uint64_t)v204;
        v205 = _Block_copy(buf);
        objc_destroyWeak(v248);
        objc_destroyWeak(location);
      }
      else
      {
        v205 = 0;
      }

      *(_QWORD *)buf = v145;
      *(_QWORD *)&buf[8] = 3221225472;
      *(_QWORD *)&buf[16] = __58__NEIKEv2Session_Exchange__setupReceivedChildWithHandler___block_invoke;
      v246 = &unk_1E3CC1018;
      v247 = v147;
      v248[0] = v149;
      objc_msgSend(WeakRetained, "requestConfigurationForSession:sessionConfig:childConfig:validateAuthBlock:responseBlock:", v147, v155, v187, v205, buf);

    }
  }

  ErrorPeerInvalidSyntax = 0;
LABEL_147:

}

void __46__NEIKEv2Session_Exchange__receiveConnection___block_invoke_209(void **a1, void *a2)
{
  id v3;
  const char *v4;
  uint64_t v5;
  __CFString *v6;
  unint64_t v7;
  NSObject *v8;
  id v9;
  const char *v10;
  const char *v11;
  id v12;
  id v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  void *ErrorFailedToSend;
  const char *v22;
  const char *v23;
  NSObject *v24;
  const char *v25;
  _BYTE *v26;
  NSObject *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t ErrorInternal;
  void *v36;
  _BYTE *v37;
  __CFString *v38;
  const char *v39;
  __CFString *v40;
  char v41;
  _BYTE *v42;
  const char *v43;
  void *Property;
  const char *v45;
  void *v46;
  id v47;
  const char *v48;
  _BYTE *v49;
  char v50;
  void *v51;
  const char *v52;
  void *v53;
  const char *v54;
  id v55;
  SEL v56;
  void *v57;
  const char *v58;
  void *v59;
  id v60;
  const char *v61;
  void *v62;
  _BYTE *v63;
  const char *v64;
  void *v65;
  const char *v66;
  void *v67;
  id v68;
  const char *v69;
  _BYTE *v70;
  char v71;
  void *v72;
  const char *v73;
  void *v74;
  id v75;
  __CFString *v76;
  const char *v77;
  _BYTE *v78;
  __CFString *v79;
  NSObject *v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t ErrorPeerInvalidSyntax;
  void *v89;
  const char *v90;
  void *v91;
  id v92;
  const char *v93;
  _BYTE *v94;
  NSObject *v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  void *v103;
  id v104;
  const char *v105;
  void *v106;
  _QWORD *v107;
  uint64_t v108;
  const char *v109;
  id v110;
  const char *v111;
  id v112;
  const char *v113;
  id v114;
  id v115;
  id v116;
  void *v117;
  _QWORD *v118;
  _QWORD *v119;
  NEIKEv2ConfigurationMessage *v120;
  NSObject *v121;
  SEL v122;
  uint64_t v123;
  const char *v124;
  uint64_t v125;
  uint64_t i;
  _QWORD *v127;
  id v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t j;
  void *v133;
  const char *v134;
  NEIKEv2ConfigurationMessage *v135;
  void *v136;
  const char *v137;
  const char *v138;
  unint64_t v139;
  id v140;
  id v141;
  uint64_t v142;
  const char *v143;
  id v144;
  void *v145;
  id v146;
  int v147;
  const char *v148;
  NSObject *v149;
  const char *v150;
  NSObject *v151;
  const char *v152;
  __CFString *v153;
  id v154;
  id v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  void *v163;
  const char *v164;
  void *v165;
  id v166;
  const char *v167;
  id v168;
  id v169;
  void *v170;
  const char *v171;
  id v172;
  id v173;
  NSObject *v174;
  const char *v175;
  NSObject *v176;
  SEL v177;
  id v178;
  id v179;
  NSObject *v180;
  NSObject *v181;
  const char *v182;
  __CFString *v183;
  id v184;
  __CFString *v185;
  SEL v186;
  void *v187;
  const char *v188;
  void *v189;
  _BYTE *v190;
  const char *v191;
  id v192;
  __CFString *v193;
  id v194;
  id v195;
  void *v196;
  id v197;
  SEL v198;
  void *v199;
  const char *v200;
  void *v201;
  const char *v202;
  id v203;
  id v204;
  id v205;
  void *v206;
  id v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  void *v215;
  _QWORD *v216;
  void *v217;
  id v218;
  void *v219;
  char *v220;
  const char *v221;
  char *v222;
  const char *v223;
  __CFString *ChildSAModeString;
  _BYTE *v225;
  id v226;
  id v227;
  __CFString *v228;
  char *v229;
  char *v230;
  char *v231;
  NSObject *v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  __CFString *v240;
  NSObject *v241;
  const char *v242;
  uint64_t v243;
  __CFString *v244;
  NEIKEv2ConfigurationMessage *v245;
  id v246;
  _QWORD *v247;
  void *v248;
  _BYTE *v249;
  __CFString *v250;
  __CFString *v251;
  void **v252;
  void **v253;
  void *v254;
  id self;
  id obj;
  uint64_t v257;
  void *v258;
  _QWORD v259[4];
  id v260;
  void *v261;
  id v262;
  __CFString *v263;
  __int128 v264;
  __int128 v265;
  __int128 v266;
  __int128 v267;
  __int128 v268;
  __int128 v269;
  __int128 v270;
  __int128 v271;
  uint8_t v272[128];
  uint8_t buf[4];
  const char *v274;
  __int16 v275;
  __CFString *v276;
  __int16 v277;
  __CFString *v278;
  uint64_t v279;

  v279 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  -[NEIKEv2Session firstChildSA](a1[4], v4);
  v5 = objc_claimAutoreleasedReturnValue();
  v6 = (__CFString *)v5;
  if (v3)
    goto LABEL_2;
  if (v5)
  {
    ne_log_obj();
    v24 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      v25 = (const char *)a1[4];
      *(_DWORD *)buf = 138412546;
      v274 = v25;
      v275 = 2112;
      v276 = v6;
      _os_log_impl(&dword_19BD16000, v24, OS_LOG_TYPE_DEFAULT, "%@ Set up Child SA %@", buf, 0x16u);
    }

    goto LABEL_22;
  }
  v26 = a1[5];
  if (v26 && (v26[23] & 1) != 0)
    goto LABEL_22;
  ne_log_obj();
  v27 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
  {
    v221 = (const char *)a1[4];
    *(_DWORD *)buf = 138412290;
    v274 = v221;
    _os_log_error_impl(&dword_19BD16000, v27, OS_LOG_TYPE_ERROR, "%@ Failed to set up Child SA", buf, 0xCu);
  }

  ErrorInternal = NEIKEv2CreateErrorInternal(CFSTR("Failed to set up Child SA"), v28, v29, v30, v31, v32, v33, v34, v243);
  if (!ErrorInternal)
  {
LABEL_22:
    v36 = a1[6];
    v37 = a1[5];
    v38 = v6;
    v40 = v38;
    if (!v36)
      goto LABEL_133;
    if (v37)
    {
      if ((v37[9] & 1) != 0)
      {
        ne_log_obj();
        v232 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v232, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 136315138;
          v274 = "-[NEIKEv2IKEAuthPacket(Exchange) validateAuthPart2AsResponderCopyErrorForIKESA:childSA:errorCodeToSend:]";
          _os_log_fault_impl(&dword_19BD16000, v232, OS_LOG_TYPE_FAULT, "%s called with null !ikeSA.isInitiator", buf, 0xCu);
        }

        v240 = CFSTR("validateAuthPart2AsResponder called as initiator");
        goto LABEL_149;
      }
      v41 = v37[23] & 1;
      if (v38)
      {
LABEL_27:
        v42 = -[NEIKEv2IKESA copyInitiatorIdentifier](v37, v39);

        self = v36;
        if (v42)
        {
          objc_getProperty(v36, v43, 96, 1);
          Property = (void *)objc_claimAutoreleasedReturnValue();
          v46 = Property;
          if (Property)
            Property = objc_getProperty(Property, v45, 24, 1);
          v47 = Property;
          v49 = -[NEIKEv2IKESA copyInitiatorIdentifier](v37, v48);
          v50 = objc_msgSend(v47, "isEqual:", v49);

          v36 = self;
          if ((v50 & 1) == 0)
          {
            objc_getProperty(self, v43, 96, 1);
            v89 = (void *)objc_claimAutoreleasedReturnValue();
            v91 = v89;
            if (v89)
              v89 = objc_getProperty(v89, v90, 24, 1);
            v92 = v89;
            v76 = (__CFString *)objc_msgSend(v92, "copyShortDescription");

            v94 = -[NEIKEv2IKESA copyInitiatorIdentifier](v37, v93);
            v79 = (__CFString *)objc_msgSend(v94, "copyShortDescription");

            ne_log_obj();
            v95 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v95, OS_LOG_TYPE_ERROR))
            {
              v220 = (char *)objc_msgSend(self, "copyShortDescription");
              *(_DWORD *)buf = 138412802;
              v274 = v220;
              v275 = 2112;
              v276 = v76;
              v277 = 2112;
              v278 = v79;
              _os_log_error_impl(&dword_19BD16000, v95, OS_LOG_TYPE_ERROR, "%@ Initiator ID could not be verified (%@ != %@)", buf, 0x20u);

            }
            ErrorPeerInvalidSyntax = NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("Initiator ID could not be verified (%@ != %@)"), v96, v97, v98, v99, v100, v101, v102, (uint64_t)v76);
            goto LABEL_51;
          }
        }
        objc_getProperty(v36, v43, 96, 1);
        v51 = (void *)objc_claimAutoreleasedReturnValue();
        v53 = v51;
        if (v51)
          v51 = objc_getProperty(v51, v52, 24, 1);
        v55 = v51;
        if (v37)
          objc_setProperty_atomic(v37, v54, v55, 504);

        objc_getProperty(v36, v56, 104, 1);
        v57 = (void *)objc_claimAutoreleasedReturnValue();
        v59 = v57;
        if (v57 && (v60 = objc_getProperty(v57, v58, 24, 1)) != 0)
        {
          v62 = v60;
          v63 = -[NEIKEv2IKESA copyResponderIdentifier](v37, v61);

          if (v63)
          {
            objc_getProperty(self, v64, 104, 1);
            v65 = (void *)objc_claimAutoreleasedReturnValue();
            v67 = v65;
            if (v65)
              v65 = objc_getProperty(v65, v66, 24, 1);
            v68 = v65;
            v70 = -[NEIKEv2IKESA copyResponderIdentifier](v37, v69);
            v71 = objc_msgSend(v68, "isEqual:", v70);

            if ((v71 & 1) == 0)
            {
              objc_getProperty(self, v64, 104, 1);
              v72 = (void *)objc_claimAutoreleasedReturnValue();
              v74 = v72;
              if (v72)
                v72 = objc_getProperty(v72, v73, 24, 1);
              v75 = v72;
              v76 = (__CFString *)objc_msgSend(v75, "copyShortDescription");

              v78 = -[NEIKEv2IKESA copyResponderIdentifier](v37, v77);
              v79 = (__CFString *)objc_msgSend(v78, "copyShortDescription");

              ne_log_obj();
              v80 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v80, OS_LOG_TYPE_ERROR))
              {
                v229 = (char *)objc_msgSend(self, "copyShortDescription");
                *(_DWORD *)buf = 138412802;
                v274 = v229;
                v275 = 2112;
                v276 = v76;
                v277 = 2112;
                v278 = v79;
                _os_log_error_impl(&dword_19BD16000, v80, OS_LOG_TYPE_ERROR, "%@ Responder ID could not be verified (%@ != %@)", buf, 0x20u);

              }
              ErrorPeerInvalidSyntax = NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("Responder ID could not be verified (%@ != %@)"), v81, v82, v83, v84, v85, v86, v87, (uint64_t)v76);
LABEL_51:
              v3 = (id)ErrorPeerInvalidSyntax;

LABEL_52:
              v7 = 24;
              goto LABEL_138;
            }
          }
        }
        else
        {

        }
        v103 = self;
        v104 = objc_getProperty(self, v64, 152, 1);
        v106 = v104;
        if (!v104 || (v107 = objc_getProperty(v104, v105, 24, 1)) == 0)
        {
          v118 = 0;
LABEL_89:

          goto LABEL_90;
        }
        v108 = v107[1];

        if (v108 != 1)
        {
LABEL_90:
          if (!v37 || (v37[23] & 1) == 0)
          {
            if (-[NEIKEv2Packet hasNotification:](v103, (const char *)0x4007))
              v139 = 1;
            else
              v139 = 2;
            if (v6)
              v140 = objc_getProperty(v40, v138, 48, 1);
            else
              v140 = 0;
            v141 = v140;
            v142 = objc_msgSend(v141, "mode");

            if (v139 == v142)
            {
              if (v6)
                v144 = objc_getProperty(v40, v143, 48, 1);
              else
                v144 = 0;
              v145 = self;
              v146 = v144;
              if (objc_msgSend(v146, "sequencePerTrafficClass"))
              {
                v147 = -[NEIKEv2Packet hasNotification:](self, (const char *)0xC350);

                if (v147)
                {
                  ne_log_obj();
                  v149 = objc_claimAutoreleasedReturnValue();
                  if (os_log_type_enabled(v149, OS_LOG_TYPE_DEBUG))
                  {
                    v231 = (char *)objc_msgSend(self, "copyShortDescription");
                    *(_DWORD *)buf = 138412290;
                    v274 = v231;
                    _os_log_debug_impl(&dword_19BD16000, v149, OS_LOG_TYPE_DEBUG, "%@ Sequence Per Traffic Class supported", buf, 0xCu);

                  }
                  if (v6)
                    BYTE2(v40->info) = 1;
                }
              }
              else
              {

              }
              objc_getProperty(self, v148, 88, 1);
              v163 = (void *)objc_claimAutoreleasedReturnValue();
              v165 = v163;
              if (v163)
                v163 = objc_getProperty(v163, v164, 24, 1);
              v166 = v163;

              if (v6)
                v168 = objc_getProperty(v40, v167, 48, 1);
              else
                v168 = 0;
              v169 = v168;
              objc_msgSend(v169, "proposals");
              v170 = (void *)objc_claimAutoreleasedReturnValue();

              if (v6)
                v172 = objc_getProperty(v40, v171, 48, 1);
              else
                v172 = 0;
              v173 = v172;
              v174 = +[NEIKEv2ChildSAProposal chooseChildSAProposalFromLocalProposals:remoteProposals:preferRemoteProposals:checkKEMethod:]((uint64_t)NEIKEv2ChildSAProposal, v170, v166, objc_msgSend(v173, "preferInitiatorProposalOrder"), 0);
              v176 = v174;
              if (v6)
              {
                objc_setProperty_atomic(v40, v175, v174, 56);

                v178 = objc_getProperty(v40, v177, 56, 1);
              }
              else
              {

                v178 = 0;
              }
              v179 = v178;

              ne_log_obj();
              v180 = objc_claimAutoreleasedReturnValue();
              v181 = v180;
              if (v179)
              {
                v258 = v170;
                if (os_log_type_enabled(v180, OS_LOG_TYPE_DEFAULT))
                {
                  v183 = (__CFString *)objc_msgSend(self, "copyShortDescription");
                  if (v6)
                    v184 = objc_getProperty(v40, v182, 56, 1);
                  else
                    v184 = 0;
                  v185 = (__CFString *)v184;
                  *(_DWORD *)buf = 138412802;
                  v274 = (const char *)v40;
                  v275 = 2112;
                  v276 = v183;
                  v277 = 2112;
                  v278 = v185;
                  _os_log_impl(&dword_19BD16000, v181, OS_LOG_TYPE_DEFAULT, "%@ %@ Chose initiator auth child proposal %@", buf, 0x20u);

                  v145 = self;
                }

                objc_getProperty(v145, v186, 160, 1);
                v187 = (void *)objc_claimAutoreleasedReturnValue();
                v189 = v187;
                if (v187)
                  v187 = objc_getProperty(v187, v188, 24, 1);
                v190 = v37;
                v192 = v187;
                v253 = a1;
                if (v6)
                {
                  v193 = v40;
                  v194 = objc_getProperty(v40, v191, 48, 1);
                }
                else
                {
                  v194 = 0;
                  v193 = v40;
                }
                v195 = v194;
                objc_msgSend(v195, "remoteTrafficSelectors");
                v196 = (void *)objc_claimAutoreleasedReturnValue();
                v197 = +[NEIKEv2TrafficSelector copyConstrainedTrafficSelectorsForRequest:reply:]((uint64_t)NEIKEv2TrafficSelector, (uint64_t)v192, v196);
                -[NEIKEv2ChildSA setInitiatorTrafficSelectors:](v193, v197);

                objc_getProperty(self, v198, 168, 1);
                v199 = (void *)objc_claimAutoreleasedReturnValue();
                v201 = v199;
                if (v199)
                  v199 = objc_getProperty(v199, v200, 24, 1);
                v37 = v190;
                v203 = v199;
                if (v6)
                  v204 = objc_getProperty(v40, v202, 48, 1);
                else
                  v204 = 0;
                v205 = v204;
                objc_msgSend(v205, "localTrafficSelectors");
                v206 = (void *)objc_claimAutoreleasedReturnValue();
                v207 = +[NEIKEv2TrafficSelector copyConstrainedTrafficSelectorsForRequest:reply:]((uint64_t)NEIKEv2TrafficSelector, (uint64_t)v203, v206);
                -[NEIKEv2ChildSA setResponderTrafficSelectors:](v40, v207);

                a1 = v253;
                goto LABEL_133;
              }
              if (os_log_type_enabled(v180, OS_LOG_TYPE_ERROR))
              {
                v230 = (char *)objc_msgSend(self, "copyShortDescription");
                *(_DWORD *)buf = 138412290;
                v274 = v230;
                _os_log_error_impl(&dword_19BD16000, v181, OS_LOG_TYPE_ERROR, "%@ No matching proposal found", buf, 0xCu);

              }
              v3 = (id)NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("No matching proposal found"), v208, v209, v210, v211, v212, v213, v214, v243);

            }
            else
            {
              ne_log_obj();
              v151 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v151, OS_LOG_TYPE_ERROR))
              {
                v222 = (char *)objc_msgSend(self, "copyShortDescription");
                ChildSAModeString = NEIKEv2CreateChildSAModeString(v139);
                v225 = v37;
                if (v6)
                  v226 = objc_getProperty(v40, v223, 48, 1);
                else
                  v226 = 0;
                v227 = v226;
                v228 = NEIKEv2CreateChildSAModeString(objc_msgSend(v227, "mode"));
                *(_DWORD *)buf = 138412802;
                v274 = v222;
                v275 = 2112;
                v276 = ChildSAModeString;
                v277 = 2112;
                v278 = v228;
                _os_log_error_impl(&dword_19BD16000, v151, OS_LOG_TYPE_ERROR, "%@ Transport mode Child SA did not match (packet had %@ but config expected %@)", buf, 0x20u);

                v37 = v225;
              }

              v153 = NEIKEv2CreateChildSAModeString(v139);
              if (v6)
                v154 = objc_getProperty(v40, v152, 48, 1);
              else
                v154 = 0;
              v155 = v154;
              v244 = NEIKEv2CreateChildSAModeString(objc_msgSend(v155, "mode"));
              v3 = (id)NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("Transport mode Child SA did not match (packet had %@ but config expected %@)"), v156, v157, v158, v159, v160, v161, v162, (uint64_t)v153);

            }
            v7 = 14;
LABEL_138:

            if (v3)
              goto LABEL_3;
LABEL_139:
            v216 = a1[4];
            v215 = a1[5];
            v217 = a1[6];
            v259[0] = MEMORY[0x1E0C809B0];
            v259[1] = 3221225472;
            v259[2] = __46__NEIKEv2Session_Exchange__receiveConnection___block_invoke_214;
            v259[3] = &unk_1E3CC1040;
            v218 = v215;
            v219 = a1[4];
            v260 = v218;
            v261 = v219;
            v262 = a1[6];
            v263 = v40;
            -[NEIKEv2Session handleEAPAndGSPMForIKESA:authPacket:handler:](v216, v218, v217, v259);

            v3 = v260;
            goto LABEL_11;
          }
LABEL_133:

          goto LABEL_139;
        }
        v110 = objc_getProperty(self, v109, 152, 1);
        v112 = v110;
        if (v110)
          v110 = objc_getProperty(v110, v111, 24, 1);
        v114 = v110;
        if (v37)
          v115 = objc_getProperty(v37, v113, 88, 1);
        else
          v115 = 0;
        v116 = v115;
        objc_msgSend(v116, "configurationReply");
        v117 = (void *)objc_claimAutoreleasedReturnValue();
        v118 = v114;
        v119 = v117;
        objc_opt_self();
        v251 = v6;
        v254 = v119;
        if (v118 && v118[1] == 1)
        {
          if (v119 && v119[1] == 2)
          {
            v246 = v116;
            v248 = v112;
            v249 = v37;
            v250 = v40;
            v252 = a1;
            v120 = objc_alloc_init(NEIKEv2ConfigurationMessage);
            if (v120)
              v120->_configurationType = 2;
            v245 = v120;
            v121 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
            v268 = 0u;
            v269 = 0u;
            v270 = 0u;
            v271 = 0u;
            v247 = v118;
            obj = objc_getProperty(v118, v122, 16, 1);
            v123 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v268, buf, 16);
            if (v123)
            {
              v125 = v123;
              v257 = *(_QWORD *)v269;
              do
              {
                for (i = 0; i != v125; ++i)
                {
                  if (*(_QWORD *)v269 != v257)
                    objc_enumerationMutation(obj);
                  v264 = 0u;
                  v265 = 0u;
                  v266 = 0u;
                  v267 = 0u;
                  v127 = v119;
                  v128 = objc_getProperty(v119, v124, 16, 1);
                  v129 = objc_msgSend(v128, "countByEnumeratingWithState:objects:count:", &v264, v272, 16);
                  if (v129)
                  {
                    v130 = v129;
                    v131 = *(_QWORD *)v265;
                    do
                    {
                      for (j = 0; j != v130; ++j)
                      {
                        if (*(_QWORD *)v265 != v131)
                          objc_enumerationMutation(v128);
                        v133 = *(void **)(*((_QWORD *)&v264 + 1) + 8 * j);
                        if (objc_msgSend(v133, "isMemberOfClass:", objc_opt_class()))
                          -[NSObject addObject:](v121, "addObject:", v133);
                      }
                      v130 = objc_msgSend(v128, "countByEnumeratingWithState:objects:count:", &v264, v272, 16);
                    }
                    while (v130);
                  }

                  v119 = v127;
                }
                v125 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v268, buf, 16);
              }
              while (v125);
            }

            v135 = v245;
            if (v245)
              objc_setProperty_atomic(v245, v134, v121, 16);
            a1 = v252;
            v37 = v249;
            v40 = v250;
            v103 = self;
            v118 = v247;
            v106 = v248;
            v136 = v246;
            goto LABEL_86;
          }
          v136 = v116;
          ne_log_obj();
          v121 = objc_claimAutoreleasedReturnValue();
          if (!os_log_type_enabled(v121, OS_LOG_TYPE_FAULT))
          {
LABEL_153:
            v103 = self;
            v106 = v112;
            v135 = 0;
LABEL_86:

            if (v37)
              objc_setProperty_atomic(v37, v137, v135, 488);

            v6 = v251;
            goto LABEL_89;
          }
          *(_DWORD *)buf = 136315138;
          v274 = "+[NEIKEv2ConfigurationMessage copyConfigurationForRequest:reply:]";
          v242 = "%s called with null (reply.configurationType == NEIKEv2ConfigurationTypeReply)";
        }
        else
        {
          v136 = v116;
          ne_log_obj();
          v121 = objc_claimAutoreleasedReturnValue();
          if (!os_log_type_enabled(v121, OS_LOG_TYPE_FAULT))
            goto LABEL_153;
          *(_DWORD *)buf = 136315138;
          v274 = "+[NEIKEv2ConfigurationMessage copyConfigurationForRequest:reply:]";
          v242 = "%s called with null (request.configurationType == NEIKEv2ConfigurationTypeRequest)";
        }
        _os_log_fault_impl(&dword_19BD16000, v121, OS_LOG_TYPE_FAULT, v242, buf, 0xCu);
        goto LABEL_153;
      }
    }
    else
    {
      v41 = 0;
      if (v38)
        goto LABEL_27;
    }
    if ((v41 & 1) != 0)
      goto LABEL_27;
    ne_log_obj();
    v241 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v241, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136315138;
      v274 = "-[NEIKEv2IKEAuthPacket(Exchange) validateAuthPart2AsResponderCopyErrorForIKESA:childSA:errorCodeToSend:]";
      _os_log_fault_impl(&dword_19BD16000, v241, OS_LOG_TYPE_FAULT, "%s called with null childSA", buf, 0xCu);
    }

    v240 = CFSTR("validateAuthPart2AsResponder called with nil childSA");
LABEL_149:
    v3 = (id)NEIKEv2CreateErrorInternal(v240, v233, v234, v235, v236, v237, v238, v239, v243);
    goto LABEL_52;
  }
  v3 = (id)ErrorInternal;
LABEL_2:
  v7 = 24;
LABEL_3:
  ne_log_obj();
  v8 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
  {
    v150 = (const char *)a1[4];
    *(_DWORD *)buf = 138412290;
    v274 = v150;
    _os_log_error_impl(&dword_19BD16000, v8, OS_LOG_TYPE_ERROR, "%@ Failed to process IKE Auth packet (receive p2)", buf, 0xCu);
  }

  v9 = +[NEIKEv2IKEAuthPacket createIKEAuthResponse:refusalError:]((uint64_t)NEIKEv2IKEAuthPacket, a1[6], v7);
  if ((-[NEIKEv2Session sendReply:replyHandler:]((uint64_t)a1[4], v9, 0) & 1) != 0)
  {
    -[NEIKEv2IKESA setState:error:]((uint64_t)a1[5], 3uLL, v3);
    -[NEIKEv2Session reportState](a1[4], v11);
  }
  else
  {
    v12 = a1[4];
    if (v12)
      v12 = objc_getProperty(v12, v10, 336, 1);
    v13 = v12;
    ErrorFailedToSend = (void *)NEIKEv2CreateErrorFailedToSend(CFSTR("AUTH refusal p2 %@"), v14, v15, v16, v17, v18, v19, v20, (uint64_t)v3);
    -[NEIKEv2IKESA setState:error:]((uint64_t)v13, 3uLL, ErrorFailedToSend);

    -[NEIKEv2Session reportState](a1[4], v22);
    -[NEIKEv2Session resetAll]((uint64_t)a1[4], v23);
  }

LABEL_11:
}

void __46__NEIKEv2Session_Exchange__receiveConnection___block_invoke_214(uint64_t a1, void *a2)
{
  id v3;
  const char *v4;
  void *v5;
  uint64_t v6;
  _BYTE *v7;
  uint64_t v8;
  _BOOL4 v9;
  void *v10;
  char v11;
  const char *v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  void *v16;
  id v17;
  SEL v18;
  uint64_t v19;
  void *v20;
  void *v21;
  id v22;
  const char *v23;
  void *v24;
  int v25;
  uint64_t v26;
  const char *v27;
  _QWORD *v28;
  _QWORD *v29;
  uint64_t v30;
  _QWORD *v31;
  void *v32;
  id v33;
  void *v34;
  void *v35;
  id v36;
  _BYTE *v37;
  _BYTE *v38;
  const char *v39;
  id v40;
  uint64_t v41;
  const char *v42;
  NSObject *v43;
  _BYTE *v44;
  const char *v45;
  NEIKEv2ResponderIdentifierPayload *v46;
  SEL v47;
  const char *v48;
  _BYTE *v49;
  SEL v50;
  void *v51;
  const char *v52;
  void *v53;
  SEL v54;
  void *v55;
  char v56;
  id v57;
  const char *v58;
  const char *v59;
  const char *v60;
  void *v61;
  char v62;
  int v63;
  id v64;
  const char *v65;
  void *v66;
  int v67;
  const char *v68;
  void *v69;
  id Property;
  id v71;
  NSObject *v72;
  NSObject *v73;
  NSObject *v74;
  const char *v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  void *ErrorAuthentication;
  void *v84;
  uint64_t v85;
  void *v86;
  int v87;
  NEIKEv2AuthPayload *v88;
  SEL v89;
  const char *v90;
  void *v91;
  SEL v92;
  void *v93;
  NEIKEv2AuthPayload *v94;
  SEL v95;
  void *v96;
  NSObject *v97;
  const char *v98;
  id v99;
  const char *v100;
  uint64_t v101;
  _QWORD *v102;
  const char *v103;
  _QWORD *v104;
  uint64_t v105;
  const char *v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  void *v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  void *v123;
  const char *v124;
  void *v125;
  void *v126;
  id v127;
  uint64_t v128;
  id v129;
  void *v130;
  uint64_t v131;
  const char *v132;
  id v133;
  void *v134;
  id v135;
  uint64_t v136;
  SEL v137;
  id v138;
  void *v139;
  void *v140;
  id v141;
  id v142;
  char v143;
  const char *v144;
  NSObject *v145;
  const char *v146;
  id v147;
  id v148;
  __SecKey *v149;
  void *v150;
  char v151;
  NSObject *v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  int v161;
  NSObject *v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t ErrorInternal;
  SEL v171;
  SEL v172;
  void *v173;
  char v174;
  const char *v175;
  void *v176;
  id v177;
  void *v178;
  const char *v179;
  NEIKEv2ConfigPayload *v180;
  SEL v181;
  SEL v182;
  id v183;
  void *v184;
  SEL v185;
  id v186;
  const char *v187;
  void *v188;
  SEL v189;
  id v190;
  char v191;
  NEIKEv2ChildSAPayload *v192;
  SEL v193;
  const char *v194;
  id v195;
  id v196;
  void *v197;
  void *v198;
  SEL v199;
  void *v200;
  const char *v201;
  void *v202;
  SEL v203;
  void *v204;
  char v205;
  NEIKEv2InitiatorTrafficSelectorPayload *v206;
  SEL v207;
  const char *v208;
  void *v209;
  SEL v210;
  void *v211;
  const char *v212;
  void *v213;
  SEL v214;
  void *v215;
  char v216;
  NEIKEv2ResponderTrafficSelectorPayload *v217;
  SEL v218;
  const char *v219;
  void *v220;
  SEL v221;
  void *v222;
  const char *v223;
  void *v224;
  SEL v225;
  void *v226;
  char v227;
  const char *v228;
  id v229;
  id v230;
  uint64_t v231;
  const char *v232;
  id v233;
  id v234;
  int v235;
  NEIKEv2NotifyPayload *v236;
  BOOL v237;
  NSObject *v238;
  id v239;
  NSObject *v240;
  uint32_t v241;
  NSObject *v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t v245;
  uint64_t v246;
  uint64_t v247;
  uint64_t v248;
  uint64_t v249;
  SEL v250;
  id v251;
  int v252;
  NSObject *v253;
  uint64_t v254;
  uint64_t v255;
  uint64_t v256;
  uint64_t v257;
  uint64_t v258;
  uint64_t v259;
  uint64_t v260;
  __CFString *v261;
  id v262;
  NSObject *v263;
  NSObject *v264;
  void *v265;
  id v266;
  NSObject *v267;
  NSObject *v268;
  uint64_t v269;
  uint64_t v270;
  uint64_t v271;
  uint64_t v272;
  uint64_t v273;
  uint64_t v274;
  uint64_t v275;
  unint64_t v276;
  NSObject *v277;
  uint64_t v278;
  uint64_t v279;
  uint64_t v280;
  uint64_t v281;
  uint64_t v282;
  uint64_t v283;
  uint64_t v284;
  NSObject *v285;
  uint64_t v286;
  uint64_t v287;
  uint64_t v288;
  uint64_t v289;
  uint64_t v290;
  uint64_t v291;
  uint64_t v292;
  const char *v293;
  NSObject *v294;
  uint32_t v295;
  char *v296;
  const char *v297;
  void *v298;
  uint64_t ErrorCrypto;
  void *v300;
  char v301;
  NSObject *v302;
  uint64_t v303;
  uint64_t v304;
  uint64_t v305;
  uint64_t v306;
  uint64_t v307;
  uint64_t v308;
  uint64_t v309;
  NSObject *v310;
  const char *v311;
  const char *v312;
  id v313;
  id v314;
  uint64_t v315;
  uint64_t v316;
  uint64_t v317;
  uint64_t v318;
  uint64_t v319;
  uint64_t v320;
  uint64_t v321;
  void *ErrorFailedToSend;
  const char *v323;
  const char *v324;
  const char *v325;
  char *v326;
  void *v327;
  char *v328;
  const char *v329;
  char *v330;
  char *v331;
  id v332;
  char v333;
  const char *v334;
  id v335;
  int v336;
  const char *v337;
  id v338;
  void *v339;
  uint64_t v340;
  uint64_t v341;
  uint64_t v342;
  uint64_t v343;
  void *v344;
  NEIKEv2NotifyPayload *v345;
  unsigned int v346;
  void *v347;
  SEL v348;
  uint64_t v349;
  SEL v350;
  id v351;
  void *v352;
  uint64_t v353;
  uint64_t v354;
  uint64_t v355;
  uint64_t i;
  void *v357;
  NEIKEv2VendorIDPayload *v358;
  const char *v359;
  void *v360;
  SEL v361;
  void *v362;
  const char *v363;
  void *v364;
  void *v365;
  SEL v366;
  SEL v367;
  SEL v368;
  id v369;
  void *v370;
  uint64_t v371;
  uint64_t v372;
  uint64_t v373;
  uint64_t v374;
  void *v375;
  NEIKEv2CustomPayload *v376;
  uint64_t v377;
  void *v378;
  SEL v379;
  SEL v380;
  void *v381;
  const char *v382;
  void *v383;
  void *v384;
  SEL v385;
  SEL v386;
  uint64_t v387;
  NSObject *v388;
  NSObject *v389;
  NSObject *v390;
  const char *v391;
  const char *v392;
  uint64_t v393;
  const char *v394;
  const char *v395;
  void *v396;
  NSObject *v397;
  const char *v398;
  uint64_t v399;
  uint64_t v400;
  id WeakRetained;
  const char *v402;
  void *v403;
  id v404;
  const char *v405;
  void *v406;
  uint64_t v407;
  id v408;
  void *v409;
  const char *v410;
  void *v411;
  id v412;
  uint64_t v413;
  uint64_t v414;
  char v415;
  uint64_t v416;
  uint64_t v417;
  void *v418;
  const char *v419;
  void *v420;
  void *v421;
  id v422;
  const char *v423;
  void *v424;
  void *v425;
  ptrdiff_t v426;
  const char *v427;
  void *v428;
  uint64_t v429;
  NSObject *v430;
  const char *v431;
  const char *v432;
  const char *v433;
  id v434;
  id v435;
  uint64_t v436;
  uint64_t v437;
  uint64_t v438;
  uint64_t v439;
  uint64_t v440;
  uint64_t v441;
  uint64_t v442;
  void *v443;
  const char *v444;
  const char *v445;
  id v446;
  id v447;
  uint64_t v448;
  uint64_t v449;
  uint64_t v450;
  uint64_t v451;
  uint64_t v452;
  uint64_t v453;
  uint64_t v454;
  void *v455;
  NSObject *v456;
  const char *v457;
  id v458;
  uint64_t v459;
  uint64_t v460;
  uint64_t v461;
  uint64_t v462;
  uint64_t v463;
  uint64_t v464;
  uint64_t v465;
  NSObject *v466;
  const char *v467;
  id v468;
  uint64_t v469;
  uint64_t v470;
  uint64_t v471;
  uint64_t v472;
  uint64_t v473;
  uint64_t v474;
  uint64_t v475;
  void *v476;
  const char *v477;
  const char *v478;
  NSObject *v479;
  const char *v480;
  void *v481;
  const char *v482;
  const char *v483;
  const char *v484;
  char *v485;
  NSObject *v486;
  uint64_t v487;
  uint64_t v488;
  uint64_t v489;
  uint64_t v490;
  uint64_t v491;
  uint64_t v492;
  uint64_t v493;
  NSObject *v494;
  uint64_t v495;
  uint64_t v496;
  uint64_t v497;
  uint64_t v498;
  uint64_t v499;
  uint64_t v500;
  uint64_t v501;
  uint64_t v502;
  void *v503;
  id v504;
  uint64_t v505;
  void *v506;
  void *v507;
  id obj;
  NSObject *self;
  id selfa;
  __int128 v511;
  __int128 v512;
  __int128 v513;
  __int128 v514;
  __int128 v515;
  __int128 v516;
  __int128 v517;
  __int128 v518;
  __int128 v519;
  __int128 v520;
  __int128 v521;
  __int128 v522;
  __int128 v523;
  __int128 v524;
  __int128 v525;
  __int128 v526;
  _BYTE v527[128];
  NEIKEv2CustomPayload *v528;
  _BYTE v529[128];
  NEIKEv2VendorIDPayload *v530;
  uint8_t v531[128];
  uint8_t buf[4];
  const char *v533;
  __int16 v534;
  uint64_t v535;
  __int16 v536;
  void *v537;
  _QWORD v538[4];

  v538[1] = *MEMORY[0x1E0C80C00];
  v3 = a2;
  v5 = v3;
  v6 = *(_QWORD *)(a1 + 32);
  if (!v6)
  {
    v8 = 0;
    if (!v3)
    {
      v5 = 0;
      goto LABEL_16;
    }
    v9 = 1;
    goto LABEL_5;
  }
  *(_BYTE *)(v6 + 17) = 0;
  v7 = *(id *)(a1 + 32);
  v8 = (uint64_t)v7;
  if (!v5)
    goto LABEL_16;
  v9 = v7 == 0;
  if (!v7 || (v7[9] & 1) == 0)
  {
LABEL_5:
    -[NEIKEv2IKESA remoteAuthentication]((id)v8, v4);
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    if (objc_msgSend(v10, "method"))
    {
      if (v9)
      {

LABEL_8:
        objc_getProperty(v5, v12, 128, 1);
        v13 = objc_claimAutoreleasedReturnValue();
        v14 = (void *)v13;
        v15 = a1;
        if (v13)
          v16 = *(void **)(v13 + 24);
        else
          v16 = 0;
        v17 = v16;

        objc_getProperty(v5, v18, 128, 1);
        v19 = objc_claimAutoreleasedReturnValue();
        v20 = (void *)v19;
        if (v19)
          v21 = *(void **)(v19 + 32);
        else
          v21 = 0;
        v22 = v21;

        if (objc_msgSend(v17, "isSecurePassword")
          && (-[NEIKEv2IKESA remoteAuthentication]((id)v8, v23),
              v24 = (void *)objc_claimAutoreleasedReturnValue(),
              v25 = objc_msgSend(v24, "isSecurePassword"),
              v24,
              v25))
        {
          -[NEIKEv2IKESA remoteAuthentication]((id)v8, v23);
          v26 = objc_claimAutoreleasedReturnValue();

          v17 = (id)v26;
        }
        else
        {
          -[NEIKEv2IKESA remoteAuthentication]((id)v8, v23);
          v61 = (void *)objc_claimAutoreleasedReturnValue();
          v62 = +[NEIKEv2Crypto isRemoteAuthenticationPacketProtocol:compatibleWithConfiguredProtocol:]((uint64_t)NEIKEv2Crypto, v17, v61);

          if ((v62 & 1) == 0)
          {
            ne_log_obj();
            v74 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v74, OS_LOG_TYPE_ERROR))
            {
              v296 = (char *)objc_msgSend(v5, "copyShortDescription");
              -[NEIKEv2IKESA remoteAuthentication]((id)v8, v297);
              v298 = (void *)objc_claimAutoreleasedReturnValue();
              *(_DWORD *)buf = 138412802;
              v533 = v296;
              v534 = 2112;
              v535 = (uint64_t)v17;
              v536 = 2112;
              v537 = v298;
              _os_log_error_impl(&dword_19BD16000, v74, OS_LOG_TYPE_ERROR, "%@ Responder packet authentication method %@ is not compatible with configuration %@", buf, 0x20u);

            }
            -[NEIKEv2IKESA remoteAuthentication]((id)v8, v75);
            v503 = (void *)objc_claimAutoreleasedReturnValue();
            ErrorAuthentication = (void *)NEIKEv2CreateErrorAuthentication(CFSTR("Packet authentication method %@ is not compatible with configuration %@"), v76, v77, v78, v79, v80, v81, v82, (uint64_t)v17);

            goto LABEL_194;
          }
        }
        if (v9 || (*(_BYTE *)(v8 + 24) & 1) == 0)
          goto LABEL_42;
        v99 = objc_getProperty((id)v8, v27, 456, 1);
        if (!v99 || (v101 = *(_QWORD *)(v8 + 416), v99, v101))
        {
LABEL_76:
          v128 = *(_QWORD *)(v8 + 416);
          v129 = objc_getProperty((id)v8, v100, 88, 1);
          v130 = v129;
          if (v128)
          {
            v131 = objc_msgSend(v129, "ppkIDType");

            if (v131 != 2
              || (v133 = objc_getProperty((id)v8, v132, 88, 1),
                  objc_msgSend(v133, "ppkID"),
                  v134 = (void *)objc_claimAutoreleasedReturnValue(),
                  v134,
                  v133,
                  v134))
            {
              v135 = objc_getProperty((id)v8, v132, 88, 1);
              v136 = objc_msgSend(v135, "ppkIDType");

              v138 = objc_getProperty((id)v8, v137, 88, 1);
              objc_msgSend(v138, "ppkID");
              v139 = (void *)objc_claimAutoreleasedReturnValue();

              if (*(_QWORD *)(v8 + 416) == v136)
              {
                v140 = v5;
                v141 = *(id *)(v8 + 424);
                if (objc_msgSend(v141, "length") || objc_msgSend(v139, "length"))
                {
                  v142 = *(id *)(v8 + 424);
                  v143 = objc_msgSend(v142, "isEqualToData:", v139);

                  if ((v143 & 1) == 0)
                  {
                    ne_log_obj();
                    v145 = objc_claimAutoreleasedReturnValue();
                    if (os_log_type_enabled(v145, OS_LOG_TYPE_ERROR))
                    {
                      v485 = (char *)*(id *)(v8 + 424);
                      *(_DWORD *)buf = 138412546;
                      v533 = v485;
                      v534 = 2112;
                      v535 = (uint64_t)v139;
                      _os_log_error_impl(&dword_19BD16000, v145, OS_LOG_TYPE_ERROR, "PPK ID %@ != Expected %@", buf, 0x16u);

                    }
                    v5 = v140;
LABEL_153:

                    v251 = objc_getProperty((id)v8, v250, 88, 1);
                    v252 = objc_msgSend(v251, "ppkMandatory");

                    if (v252)
                    {
                      ne_log_obj();
                      v253 = objc_claimAutoreleasedReturnValue();
                      if (os_log_type_enabled(v253, OS_LOG_TYPE_ERROR))
                      {
                        *(_WORD *)buf = 0;
                        _os_log_error_impl(&dword_19BD16000, v253, OS_LOG_TYPE_ERROR, "Wrong PPK ID received with mandatory PPK auth", buf, 2u);
                      }

                      v261 = CFSTR("Wrong PPK ID received with mandatory PPK auth");
LABEL_185:
                      ErrorCrypto = NEIKEv2CreateErrorAuthentication(v261, v254, v255, v256, v257, v258, v259, v260, v502);
LABEL_193:
                      ErrorAuthentication = (void *)ErrorCrypto;

                      goto LABEL_194;
                    }
                    v262 = *(id *)(v8 + 384);

                    ne_log_obj();
                    v263 = objc_claimAutoreleasedReturnValue();
                    v264 = v263;
                    if (!v262)
                    {
                      if (os_log_type_enabled(v263, OS_LOG_TYPE_ERROR))
                      {
                        *(_WORD *)buf = 0;
                        _os_log_error_impl(&dword_19BD16000, v264, OS_LOG_TYPE_ERROR, "Wrong PPK ID received and no non-PPK AUTH data received", buf, 2u);
                      }

                      v261 = CFSTR("Wrong PPK ID received and no non-PPK AUTH data received");
                      goto LABEL_185;
                    }
                    v265 = v139;
                    if (os_log_type_enabled(v263, OS_LOG_TYPE_INFO))
                    {
                      *(_WORD *)buf = 0;
                      _os_log_impl(&dword_19BD16000, v264, OS_LOG_TYPE_INFO, "Wrong PPK ID received, falling back to non-PPK AUTH data", buf, 2u);
                    }

                    v266 = *(id *)(v8 + 384);
                    v63 = 0;
                    v22 = v266;
LABEL_189:

LABEL_43:
                    v64 = v17;
                    -[NEIKEv2IKESA remoteAuthentication]((id)v8, v65);
                    v66 = (void *)objc_claimAutoreleasedReturnValue();
                    v67 = objc_msgSend(v66, "isNonStandard");

                    v69 = v64;
                    if (v67)
                    {
                      -[NEIKEv2IKESA remoteAuthentication]((id)v8, v68);
                      v69 = (void *)objc_claimAutoreleasedReturnValue();

                    }
                    if (v9)
                      Property = 0;
                    else
                      Property = objc_getProperty((id)v8, v68, 456, 1);
                    v71 = Property;

                    if (v71)
                    {
                      if (objc_msgSend(v69, "method") == 12)
                      {
                        v72 = -[NEIKEv2IKESA createInitiatorGSPMAuthenticationDataUsingPrimeKey:](v8, 0);
                        if (v72
                          && +[NEIKEv2Crypto validateCalculatedSharedKeyAuthData:remoteAuthData:]((uint64_t)NEIKEv2Crypto, v72, v22))
                        {
                          if (!v9)
                          {
                            *(_BYTE *)(v8 + 18) = 1;
                            if (v63)
                              *(_BYTE *)(v8 + 19) = 1;
                          }

LABEL_150:
                          a1 = v15;
                          goto LABEL_16;
                        }
                        ne_log_obj();
                        v242 = objc_claimAutoreleasedReturnValue();
                        if (os_log_type_enabled(v242, OS_LOG_TYPE_ERROR))
                        {
                          v327 = v5;
                          v328 = (char *)objc_msgSend(v5, "copyShortDescription");
                          *(_DWORD *)buf = 138412290;
                          v533 = v328;
                          _os_log_error_impl(&dword_19BD16000, v242, OS_LOG_TYPE_ERROR, "%@ GSPM authentication data could not be verified", buf, 0xCu);

                          v5 = v327;
                        }

                        ErrorAuthentication = (void *)NEIKEv2CreateErrorAuthentication(CFSTR("GSPM authentication data could not be verified"), v243, v244, v245, v246, v247, v248, v249, v502);
                        goto LABEL_168;
                      }
                      ne_log_obj();
                      v152 = objc_claimAutoreleasedReturnValue();
                      if (os_log_type_enabled(v152, OS_LOG_TYPE_ERROR))
                      {
                        v326 = (char *)objc_msgSend(v5, "copyShortDescription");
                        *(_DWORD *)buf = 138412546;
                        v533 = v326;
                        v534 = 2112;
                        v535 = (uint64_t)v69;
                        _os_log_error_impl(&dword_19BD16000, v152, OS_LOG_TYPE_ERROR, "%@ Wrong authentication method %@ for GSPM", buf, 0x16u);

                      }
                      v160 = NEIKEv2CreateErrorAuthentication(CFSTR("Wrong authentication method $@ for GSPM"), v153, v154, v155, v156, v157, v158, v159, (uint64_t)v69);
                    }
                    else
                    {
                      if (objc_msgSend(v69, "isSignature"))
                      {
                        if (v9)
                          v147 = 0;
                        else
                          v147 = objc_getProperty((id)v8, v146, 88, 1);
                        v507 = v5;
                        v148 = v147;
                        v149 = (__SecKey *)-[NEIKEv2SessionConfiguration copyRemoteAuthKey](v148);

                        if (v149)
                        {
                          v150 = (void *)-[NEIKEv2IKESA createRemoteSignedOctetsUsingPrimeKey:](v8, 0);
                          v151 = +[NEIKEv2Crypto validateSignature:signedData:authProtocol:publicKey:]((uint64_t)NEIKEv2Crypto, v22, v150, v69, v149);
                          CFRelease(v149);
                          if ((v151 & 1) != 0)
                          {
                            if (!v9)
                            {
                              *(_BYTE *)(v8 + 18) = 1;
                              if (v63)
                                *(_BYTE *)(v8 + 19) = 1;
                            }

                            v5 = v507;
                            goto LABEL_150;
                          }
                          ne_log_obj();
                          v277 = objc_claimAutoreleasedReturnValue();
                          if (os_log_type_enabled(v277, OS_LOG_TYPE_ERROR))
                          {
                            v331 = (char *)objc_msgSend(v507, "copyShortDescription");
                            *(_DWORD *)buf = 138412546;
                            v533 = v331;
                            v534 = 2112;
                            v535 = (uint64_t)v69;
                            _os_log_error_impl(&dword_19BD16000, v277, OS_LOG_TYPE_ERROR, "%@ Responder failed to validate remote authentication data %@", buf, 0x16u);

                          }
                          ErrorAuthentication = (void *)NEIKEv2CreateErrorAuthentication(CFSTR("Failed to validate remote authentication data %@"), v278, v279, v280, v281, v282, v283, v284, (uint64_t)v69);

                        }
                        else
                        {
                          ne_log_obj();
                          v494 = objc_claimAutoreleasedReturnValue();
                          if (os_log_type_enabled(v494, OS_LOG_TYPE_FAULT))
                          {
                            *(_WORD *)buf = 0;
                            _os_log_fault_impl(&dword_19BD16000, v494, OS_LOG_TYPE_FAULT, "Responder configuration is missing remote public key", buf, 2u);
                          }

                          ErrorAuthentication = (void *)NEIKEv2CreateErrorInternal(CFSTR("Responder configuration is missing remote public key"), v495, v496, v497, v498, v499, v500, v501, v502);
                        }
                        v5 = v507;
                        goto LABEL_168;
                      }
                      if ((-[NEIKEv2IKESA checkSharedKeyAuthData:usingPrimeKey:](v8, v22, 0) & 1) != 0)
                      {
                        if (!v9)
                        {
                          *(_BYTE *)(v8 + 18) = 1;
                          if (v63)
                            *(_BYTE *)(v8 + 19) = 1;
                        }
                        goto LABEL_150;
                      }
                      ne_log_obj();
                      v268 = objc_claimAutoreleasedReturnValue();
                      if (os_log_type_enabled(v268, OS_LOG_TYPE_ERROR))
                      {
                        v330 = (char *)objc_msgSend(v5, "copyShortDescription");
                        *(_DWORD *)buf = 138412546;
                        v533 = v330;
                        v534 = 2112;
                        v535 = (uint64_t)v69;
                        _os_log_error_impl(&dword_19BD16000, v268, OS_LOG_TYPE_ERROR, "%@ Responder failed to validate remote authentication data %@", buf, 0x16u);

                      }
                      v160 = NEIKEv2CreateErrorAuthentication(CFSTR("Failed to validate remote authentication data %@"), v269, v270, v271, v272, v273, v274, v275, (uint64_t)v69);
                    }
                    ErrorAuthentication = (void *)v160;
LABEL_168:

                    v276 = 24;
LABEL_196:
                    a1 = v15;
                    goto LABEL_197;
                  }
                }
                else
                {

                }
                -[NEIKEv2IKESA ppk]((id)v8, v144);
                v300 = (void *)objc_claimAutoreleasedReturnValue();
                v301 = -[NEIKEv2IKESA generateDerivativesFromPPK:](v8, v300);

                if ((v301 & 1) == 0)
                {
                  ne_log_obj();
                  v302 = objc_claimAutoreleasedReturnValue();
                  v5 = v140;
                  if (os_log_type_enabled(v302, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)buf = 138412290;
                    v533 = (const char *)v140;
                    _os_log_error_impl(&dword_19BD16000, v302, OS_LOG_TYPE_ERROR, "%@ Failed to generate PPK-derived keys", buf, 0xCu);
                  }

                  ErrorCrypto = NEIKEv2CreateErrorCrypto(CFSTR("Failed to generate PPK-derived keys"), v303, v304, v305, v306, v307, v308, v309, v502);
                  goto LABEL_193;
                }
                v265 = v139;
                v63 = 1;
                v5 = v140;
                goto LABEL_189;
              }
              ne_log_obj();
              v145 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v145, OS_LOG_TYPE_ERROR))
              {
                v329 = *(const char **)(v8 + 416);
                *(_DWORD *)buf = 134218240;
                v533 = v329;
                v534 = 2048;
                v535 = v136;
                _os_log_error_impl(&dword_19BD16000, v145, OS_LOG_TYPE_ERROR, "PPK Type %zu != Expected Type %zu", buf, 0x16u);
              }
              goto LABEL_153;
            }
            ne_log_obj();
            v285 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v285, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)buf = 136315138;
              v533 = "-[NEIKEv2IKEAuthPacket(Exchange) validateAuthFinalAsResponderCopyErrorForIKESA:errorCodeToSend:]";
              _os_log_fault_impl(&dword_19BD16000, v285, OS_LOG_TYPE_FAULT, "%s called with null ikeSA.sessionConfiguration.ppkID", buf, 0xCu);
            }

            ErrorInternal = NEIKEv2CreateErrorInternal(CFSTR("PPK use negotiated but PPK ID is not present in configuration"), v286, v287, v288, v289, v290, v291, v292, v502);
          }
          else
          {
            v161 = objc_msgSend(v129, "ppkMandatory");

            if (!v161)
            {
LABEL_42:
              v63 = 0;
              goto LABEL_43;
            }
            ne_log_obj();
            v162 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v162, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)buf = 0;
              _os_log_error_impl(&dword_19BD16000, v162, OS_LOG_TYPE_ERROR, "No PPK ID received with mandatory PPK auth", buf, 2u);
            }

            ErrorInternal = NEIKEv2CreateErrorAuthentication(CFSTR("No PPK ID received with mandatory PPK auth"), v163, v164, v165, v166, v167, v168, v169, v502);
          }
          ErrorAuthentication = (void *)ErrorInternal;
LABEL_194:
          v276 = 24;
LABEL_195:

          goto LABEL_196;
        }
        v102 = -[NEIKEv2Packet copyNotification:](v5, (const char *)0x4034);
        v104 = v102;
        if (v102)
        {
          v105 = -[NEIKEv2NotifyPayload getPPKIDType](v102, v103);
          v113 = v105;
          if ((unint64_t)(v105 - 3) <= 0xFFFFFFFFFFFFFFFDLL)
          {
            ErrorAuthentication = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("PPK ID type %zu is invalid"), (uint64_t)v106, v107, v108, v109, v110, v111, v112, v105);
          }
          else
          {
            v114 = (void *)-[NEIKEv2NotifyPayload copyPPKID](v104, v106);
            v115 = objc_msgSend(v114, "length");
            if (v113 != 2 || v115)
            {
              -[NEIKEv2IKESA setPpkIDFromPacket:](v8, v114);
              *(_QWORD *)(v8 + 416) = v113;
              v123 = -[NEIKEv2Packet copyNotification:](v5, (const char *)0x4035);
              v125 = v123;
              v126 = v5;
              if (v123)
                v123 = objc_getProperty(v123, v124, 32, 1);
              v127 = v123;
              -[NEIKEv2IKESA setPrimeAuthenticationDataFromPacket:](v8, v127);

              v5 = v126;
              goto LABEL_75;
            }
            ErrorAuthentication = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("PPK ID missing from payload"), v116, v117, v118, v119, v120, v121, v122, v502);

          }
          v276 = 7;
          goto LABEL_195;
        }
LABEL_75:

        goto LABEL_76;
      }
      v11 = *(_BYTE *)(v8 + 18);

      if ((v11 & 1) == 0)
        goto LABEL_8;
    }
    else
    {

    }
LABEL_16:

    goto LABEL_17;
  }
  ne_log_obj();
  v486 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v486, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)buf = 136315138;
    v533 = "-[NEIKEv2IKEAuthPacket(Exchange) validateAuthFinalAsResponderCopyErrorForIKESA:errorCodeToSend:]";
    _os_log_fault_impl(&dword_19BD16000, v486, OS_LOG_TYPE_FAULT, "%s called with null !ikeSA.isInitiator", buf, 0xCu);
  }

  ErrorAuthentication = (void *)NEIKEv2CreateErrorInternal(CFSTR("validateAuthFinalAsResponder called as initiator"), v487, v488, v489, v490, v491, v492, v493, v502);
  v276 = 24;
LABEL_197:

  if (ErrorAuthentication)
  {
    ne_log_obj();
    v310 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v310, OS_LOG_TYPE_ERROR))
    {
      v325 = *(const char **)(a1 + 40);
      *(_DWORD *)buf = 138412290;
      v533 = v325;
      _os_log_error_impl(&dword_19BD16000, v310, OS_LOG_TYPE_ERROR, "%@ Failed to process IKE Auth packet (receive final)", buf, 0xCu);
    }

    v239 = +[NEIKEv2IKEAuthPacket createIKEAuthResponse:refusalError:]((uint64_t)NEIKEv2IKEAuthPacket, v5, v276);
    if ((-[NEIKEv2Session sendReply:replyHandler:](*(_QWORD *)(a1 + 40), v239, 0) & 1) != 0)
    {
      -[NEIKEv2IKESA setState:error:](*(_QWORD *)(a1 + 32), 3uLL, ErrorAuthentication);
      -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 40), v312);
    }
    else
    {
      v313 = *(id *)(a1 + 40);
      if (v313)
        v313 = objc_getProperty(v313, v311, 336, 1);
      v314 = v313;
      ErrorFailedToSend = (void *)NEIKEv2CreateErrorFailedToSend(CFSTR("AUTH refusal final %@"), v315, v316, v317, v318, v319, v320, v321, (uint64_t)ErrorAuthentication);
      -[NEIKEv2IKESA setState:error:]((uint64_t)v314, 3uLL, ErrorFailedToSend);

      -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 40), v323);
      -[NEIKEv2Session resetAll](*(_QWORD *)(a1 + 40), v324);
    }
    goto LABEL_332;
  }
LABEL_17:
  -[NEIKEv2Session reportPrivateNotifiesInPacket:](*(id **)(a1 + 40), *(void **)(a1 + 48));
  if (*(void **)(a1 + 48) != v5)
    -[NEIKEv2Session reportPrivateNotifiesInPacket:](*(id **)(a1 + 40), v5);
  v28 = *(_QWORD **)(a1 + 40);
  if (v28)
    v28 = (_QWORD *)v28[49];
  v29 = v28;
  v30 = objc_msgSend(v29, "count");

  if (v30)
  {
    v31 = *(_QWORD **)(a1 + 40);
    if (v31)
      v32 = (void *)v31[49];
    else
      v32 = 0;
    v33 = v32;
    -[NEIKEv2Session reportPrivateNotifies:](v31, v33);

    -[NEIKEv2Session setPendingPrivateNotifies:](*(_QWORD *)(a1 + 40), 0);
  }
  v34 = *(void **)(a1 + 32);
  v35 = *(void **)(a1 + 56);
  v36 = v5;
  v37 = v34;
  v38 = v35;
  objc_opt_self();
  if (!v37)
  {
    ne_log_obj();
    v43 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v43, OS_LOG_TYPE_FAULT))
      goto LABEL_265;
    *(_DWORD *)buf = 136315138;
    v533 = "+[NEIKEv2IKEAuthPacket(Exchange) createIKEAuthResponse:ikeSA:childSA:]";
    v60 = "%s called with null ikeSA";
    goto LABEL_38;
  }
  if (!v38 && (v37[23] & 1) == 0)
  {
    ne_log_obj();
    v43 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v43, OS_LOG_TYPE_FAULT))
      goto LABEL_265;
    *(_DWORD *)buf = 136315138;
    v533 = "+[NEIKEv2IKEAuthPacket(Exchange) createIKEAuthResponse:ikeSA:childSA:]";
    v60 = "%s called with null childSA";
    goto LABEL_38;
  }
  v40 = objc_getProperty(v37, v39, 96, 1);

  if (!v40)
  {
    ne_log_obj();
    v43 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v43, OS_LOG_TYPE_FAULT))
    {
LABEL_265:
      v239 = 0;
      goto LABEL_266;
    }
    *(_DWORD *)buf = 136315138;
    v533 = "+[NEIKEv2IKEAuthPacket(Exchange) createIKEAuthResponse:ikeSA:childSA:]";
    v60 = "%s called with null ikeSA.chosenProposal";
LABEL_38:
    _os_log_fault_impl(&dword_19BD16000, v43, OS_LOG_TYPE_FAULT, v60, buf, 0xCu);
    goto LABEL_265;
  }
  v41 = -[NEIKEv2Packet initResponse:]((uint64_t)[NEIKEv2IKEAuthPacket alloc], v36);
  if (!v41)
  {
    ne_log_obj();
    v73 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v73, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_fault_impl(&dword_19BD16000, v73, OS_LOG_TYPE_FAULT, "[[NEIKEv2IKEAuthPacket alloc] initResponse:] failed", buf, 2u);
    }

    v43 = 0;
    goto LABEL_265;
  }
  v43 = v41;
  v44 = -[NEIKEv2IKESA copyResponderIdentifier](v37, v42);

  if (v44)
  {
    v46 = objc_alloc_init(NEIKEv2ResponderIdentifierPayload);
    objc_setProperty_atomic(v43, v47, v46, 104);

    v49 = -[NEIKEv2IKESA copyResponderIdentifier](v37, v48);
    objc_getProperty(v43, v50, 104, 1);
    v51 = (void *)objc_claimAutoreleasedReturnValue();
    v53 = v51;
    if (v51)
      objc_setProperty_atomic(v51, v52, v49, 24);

    objc_getProperty(v43, v54, 104, 1);
    v55 = (void *)objc_claimAutoreleasedReturnValue();
    v56 = -[NEIKEv2Payload isValid]((uint64_t)v55);

    if ((v56 & 1) == 0)
    {
      ne_log_obj();
      v97 = objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v97, OS_LOG_TYPE_FAULT))
        goto LABEL_264;
      *(_DWORD *)buf = 136315138;
      v533 = "+[NEIKEv2IKEAuthPacket(Exchange) createIKEAuthResponse:ikeSA:childSA:]";
      v98 = "%s called with null packet.idr.isValid";
LABEL_141:
      v240 = v97;
      v241 = 12;
LABEL_142:
      _os_log_fault_impl(&dword_19BD16000, v240, OS_LOG_TYPE_FAULT, v98, buf, v241);
      goto LABEL_264;
    }
  }
  v506 = v5;
  v57 = objc_getProperty(v37, v45, 96, 1);
  if (-[NEIKEv2IKESAProposal hasEAPMethods](v57))
  {

    goto LABEL_106;
  }
  -[NEIKEv2IKESA authenticationProtocol](v37, v58);
  v84 = (void *)objc_claimAutoreleasedReturnValue();
  v85 = objc_msgSend(v84, "method");

  if (!v85)
    goto LABEL_106;
  -[NEIKEv2IKESA authenticationProtocol](v37, v59);
  v86 = (void *)objc_claimAutoreleasedReturnValue();
  v87 = objc_msgSend(v86, "isSecurePassword");

  if (v87)
  {
    v88 = objc_alloc_init(NEIKEv2AuthPayload);
    objc_setProperty_atomic(v43, v89, v88, 128);

    -[NEIKEv2IKESA authenticationProtocol](v37, v90);
    v91 = (void *)objc_claimAutoreleasedReturnValue();
    objc_getProperty(v43, v92, 128, 1);
    v93 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEIKEv2AuthPayload setAuthProtocol:]((uint64_t)v93, v91);

    v94 = (NEIKEv2AuthPayload *)-[NEIKEv2IKESA createResponderGSPMAuthenticationDataUsingPrimeKey:](v37, 0);
    objc_getProperty(v43, v95, 128, 1);
    v96 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEIKEv2AuthPayload setAuthenticationData:]((uint64_t)v96, v94);

  }
  else
  {
    v94 = -[NEIKEv2IKESA copyAuthenticationPayloadUsingPrimeKey:]((id *)v37, 0);
    objc_setProperty_atomic(v43, v171, v94, 128);
  }

  objc_getProperty(v43, v172, 128, 1);
  v173 = (void *)objc_claimAutoreleasedReturnValue();
  v174 = -[NEIKEv2Payload isValid]((uint64_t)v173);

  if ((v174 & 1) == 0)
  {
    ne_log_obj();
    v97 = objc_claimAutoreleasedReturnValue();
    v5 = v506;
    if (!os_log_type_enabled(v97, OS_LOG_TYPE_FAULT))
      goto LABEL_264;
    *(_DWORD *)buf = 136315138;
    v533 = "+[NEIKEv2IKEAuthPacket(Exchange) createIKEAuthResponse:ikeSA:childSA:]";
    v98 = "%s called with null packet.auth.isValid";
    goto LABEL_141;
  }
  objc_getProperty(v37, v175, 224, 1);
  v176 = (void *)objc_claimAutoreleasedReturnValue();

  if (v176 && !-[NEIKEv2Packet addNotification:data:](v43, 0x4034uLL, 0))
  {
    ne_log_obj();
    v238 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v238, OS_LOG_TYPE_FAULT))
      goto LABEL_136;
    *(_WORD *)buf = 0;
    v293 = "[packet addNotification:NEIKEv2NotifyTypePPKIdentity] failed";
    v294 = v238;
    v295 = 2;
    goto LABEL_206;
  }
LABEL_106:
  v177 = objc_getProperty(v37, v59, 88, 1);
  objc_msgSend(v177, "configurationReply");
  v178 = (void *)objc_claimAutoreleasedReturnValue();

  if (v178)
  {
    v180 = objc_alloc_init(NEIKEv2ConfigPayload);
    objc_setProperty_atomic(v43, v181, v180, 152);

    v183 = objc_getProperty(v37, v182, 88, 1);
    objc_msgSend(v183, "configurationReply");
    v184 = (void *)objc_claimAutoreleasedReturnValue();
    v186 = objc_getProperty(v43, v185, 152, 1);
    v188 = v186;
    if (v186)
      objc_setProperty_atomic(v186, v187, v184, 24);

    v190 = objc_getProperty(v43, v189, 152, 1);
    v191 = -[NEIKEv2Payload isValid]((uint64_t)v190);

    if ((v191 & 1) == 0)
    {
      ne_log_obj();
      v238 = objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v238, OS_LOG_TYPE_FAULT))
      {
LABEL_136:

        v239 = 0;
        v5 = v506;
        goto LABEL_266;
      }
      *(_DWORD *)buf = 136315138;
      v533 = "+[NEIKEv2IKEAuthPacket(Exchange) createIKEAuthResponse:ikeSA:childSA:]";
      v293 = "%s called with null packet.config.isValid";
      v294 = v238;
      v295 = 12;
LABEL_206:
      _os_log_fault_impl(&dword_19BD16000, v294, OS_LOG_TYPE_FAULT, v293, buf, v295);
      goto LABEL_136;
    }
  }
  v5 = v506;
  self = v43;
  if ((v37[23] & 1) != 0)
    goto LABEL_214;
  v192 = objc_alloc_init(NEIKEv2ChildSAPayload);
  objc_setProperty_atomic(v43, v193, v192, 88);

  if (v38)
    v195 = objc_getProperty(v38, v194, 56, 1);
  else
    v195 = 0;
  v196 = v195;
  v197 = -[NEIKEv2ChildSAProposal copyWithoutKEM](v196);
  v538[0] = v197;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v538, 1);
  v198 = (void *)objc_claimAutoreleasedReturnValue();
  objc_getProperty(v43, v199, 88, 1);
  v200 = (void *)objc_claimAutoreleasedReturnValue();
  v202 = v200;
  if (v200)
    objc_setProperty_atomic(v200, v201, v198, 24);

  objc_getProperty(v43, v203, 88, 1);
  v204 = (void *)objc_claimAutoreleasedReturnValue();
  v205 = -[NEIKEv2Payload isValid]((uint64_t)v204);

  if ((v205 & 1) == 0)
  {
    ne_log_obj();
    v97 = objc_claimAutoreleasedReturnValue();
    v5 = v506;
    if (!os_log_type_enabled(v97, OS_LOG_TYPE_FAULT))
      goto LABEL_264;
    *(_DWORD *)buf = 136315138;
    v533 = "+[NEIKEv2IKEAuthPacket(Exchange) createIKEAuthResponse:ikeSA:childSA:]";
    v98 = "%s called with null packet.sa.isValid";
    goto LABEL_141;
  }
  v206 = objc_alloc_init(NEIKEv2InitiatorTrafficSelectorPayload);
  objc_setProperty_atomic(v43, v207, v206, 160);

  -[NEIKEv2ChildSA initiatorTrafficSelectors](v38, v208);
  v209 = (void *)objc_claimAutoreleasedReturnValue();
  objc_getProperty(v43, v210, 160, 1);
  v211 = (void *)objc_claimAutoreleasedReturnValue();
  v213 = v211;
  v5 = v506;
  if (v211)
    objc_setProperty_atomic(v211, v212, v209, 24);

  objc_getProperty(v43, v214, 160, 1);
  v215 = (void *)objc_claimAutoreleasedReturnValue();
  v216 = -[NEIKEv2Payload isValid]((uint64_t)v215);

  if ((v216 & 1) != 0)
  {
    v217 = objc_alloc_init(NEIKEv2ResponderTrafficSelectorPayload);
    objc_setProperty_atomic(v43, v218, v217, 168);

    -[NEIKEv2ChildSA responderTrafficSelectors](v38, v219);
    v220 = (void *)objc_claimAutoreleasedReturnValue();
    objc_getProperty(v43, v221, 168, 1);
    v222 = (void *)objc_claimAutoreleasedReturnValue();
    v224 = v222;
    if (v222)
      objc_setProperty_atomic(v222, v223, v220, 24);

    objc_getProperty(v43, v225, 168, 1);
    v226 = (void *)objc_claimAutoreleasedReturnValue();
    v227 = -[NEIKEv2Payload isValid]((uint64_t)v226);

    if ((v227 & 1) != 0)
    {
      if (v38)
        v229 = objc_getProperty(v38, v228, 48, 1);
      else
        v229 = 0;
      v230 = v229;
      v231 = objc_msgSend(v230, "mode");

      if (v231 == 1 && !-[NEIKEv2Packet addNotification:data:](v43, 0x4007uLL, 0))
      {
        ne_log_obj();
        v97 = objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled(v97, OS_LOG_TYPE_FAULT))
          goto LABEL_264;
        *(_WORD *)buf = 0;
        v98 = "[packet addNotification:NEIKEv2NotifyTypeUseTransportMode] failed";
        goto LABEL_334;
      }
      if (!-[NEIKEv2Packet addNotification:data:](v43, 0x400AuLL, 0))
      {
        ne_log_obj();
        v97 = objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled(v97, OS_LOG_TYPE_FAULT))
          goto LABEL_264;
        *(_WORD *)buf = 0;
        v98 = "[packet addNotification:NEIKEv2NotifyTypeESPTFCPaddingNotSupported] failed";
        goto LABEL_334;
      }
      if (!-[NEIKEv2Packet addNotification:data:](v43, 0x400BuLL, 0))
      {
        ne_log_obj();
        v97 = objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled(v97, OS_LOG_TYPE_FAULT))
          goto LABEL_264;
        *(_WORD *)buf = 0;
        v98 = "[packet addNotification:NEIKEv2NotifyTypeNonFirstFragmentsAlso] failed";
        goto LABEL_334;
      }
      if (v38)
        v233 = objc_getProperty(v38, v232, 48, 1);
      else
        v233 = 0;
      v234 = v233;
      if (objc_msgSend(v234, "sequencePerTrafficClass"))
      {
        v235 = -[NEIKEv2Packet hasNotification:](v36, (const char *)0xC350);

        if (v235)
        {
          v236 = +[NEIKEv2NotifyPayload createNotifyPayloadType:]();
          v237 = -[NEIKEv2Packet addNotifyPayload:](v43, v236);

          if (!v237)
          {
            ne_log_obj();
            v97 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v97, OS_LOG_TYPE_FAULT))
            {
              *(_WORD *)buf = 0;
              v98 = "[packet addNotifyPayload:notifyPayload] failed";
LABEL_334:
              v240 = v97;
              v241 = 2;
              goto LABEL_142;
            }
LABEL_264:

            goto LABEL_265;
          }
        }
      }
      else
      {

      }
LABEL_214:
      v332 = objc_getProperty(v37, v179, 88, 1);
      v333 = objc_msgSend(v332, "initialContactDisabled");

      if ((v333 & 1) != 0 || -[NEIKEv2Packet addNotification:data:](v43, 0x4000uLL, 0))
      {
        v335 = objc_getProperty(v37, v334, 88, 1);
        v336 = objc_msgSend(v335, "negotiateMOBIKE");

        if (!v336 || -[NEIKEv2Packet addNotification:data:](v43, 0x400CuLL, 0))
        {
          v504 = v36;
          v505 = a1;
          v525 = 0u;
          v526 = 0u;
          v523 = 0u;
          v524 = 0u;
          v338 = objc_getProperty(v37, v337, 88, 1);
          objc_msgSend(v338, "customIKEAuthPrivateNotifies");
          v339 = (void *)objc_claimAutoreleasedReturnValue();

          v340 = objc_msgSend(v339, "countByEnumeratingWithState:objects:count:", &v523, buf, 16);
          if (v340)
          {
            v341 = v340;
            v342 = *(_QWORD *)v524;
            while (2)
            {
              v343 = 0;
              do
              {
                if (*(_QWORD *)v524 != v342)
                  objc_enumerationMutation(v339);
                v344 = *(void **)(*((_QWORD *)&v523 + 1) + 8 * v343);
                v345 = objc_alloc_init(NEIKEv2NotifyPayload);
                v346 = objc_msgSend(v344, "notifyStatus");
                if (v345)
                {
                  v345->_notifyType = v346;
                  objc_msgSend(v344, "notifyData");
                  v347 = (void *)objc_claimAutoreleasedReturnValue();
                  objc_setProperty_atomic(v345, v348, v347, 32);
                }
                else
                {
                  objc_msgSend(v344, "notifyData");
                  v347 = (void *)objc_claimAutoreleasedReturnValue();
                }

                if (!-[NEIKEv2Packet addNotifyPayload:](v43, v345))
                {
                  ne_log_obj();
                  v388 = objc_claimAutoreleasedReturnValue();
                  if (os_log_type_enabled(v388, OS_LOG_TYPE_FAULT))
                  {
                    *(_WORD *)v531 = 0;
                    _os_log_fault_impl(&dword_19BD16000, v388, OS_LOG_TYPE_FAULT, "[packet addNotifyPayload:notifyPayload] failed", v531, 2u);
                  }

                  v239 = 0;
                  goto LABEL_260;
                }

                ++v343;
              }
              while (v341 != v343);
              v349 = objc_msgSend(v339, "countByEnumeratingWithState:objects:count:", &v523, buf, 16);
              v341 = v349;
              if (v349)
                continue;
              break;
            }
          }

          v521 = 0u;
          v522 = 0u;
          v519 = 0u;
          v520 = 0u;
          v351 = objc_getProperty(v37, v350, 88, 1);
          objc_msgSend(v351, "customIKEAuthVendorPayloads");
          v352 = (void *)objc_claimAutoreleasedReturnValue();

          obj = v352;
          v353 = objc_msgSend(v352, "countByEnumeratingWithState:objects:count:", &v519, v531, 16);
          if (v353)
          {
            v354 = v353;
            v355 = *(_QWORD *)v520;
            do
            {
              for (i = 0; i != v354; ++i)
              {
                if (*(_QWORD *)v520 != v355)
                  objc_enumerationMutation(obj);
                v357 = *(void **)(*((_QWORD *)&v519 + 1) + 8 * i);
                v358 = objc_alloc_init(NEIKEv2VendorIDPayload);
                objc_msgSend(v357, "vendorData");
                v360 = (void *)objc_claimAutoreleasedReturnValue();
                if (v358)
                  objc_setProperty_atomic(v358, v359, v360, 24);

                objc_getProperty(self, v361, 176, 1);
                v362 = (void *)objc_claimAutoreleasedReturnValue();

                if (v362)
                {
                  objc_getProperty(self, v363, 176, 1);
                  v364 = (void *)objc_claimAutoreleasedReturnValue();
                  objc_msgSend(v364, "arrayByAddingObject:", v358);
                  v365 = (void *)objc_claimAutoreleasedReturnValue();
                  objc_setProperty_atomic(self, v366, v365, 176);

                }
                else
                {
                  v530 = v358;
                  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", &v530, 1);
                  v364 = (void *)objc_claimAutoreleasedReturnValue();
                  objc_setProperty_atomic(self, v367, v364, 176);
                }

              }
              v354 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v519, v531, 16);
            }
            while (v354);
          }

          v517 = 0u;
          v518 = 0u;
          v515 = 0u;
          v516 = 0u;
          v369 = objc_getProperty(v37, v368, 88, 1);
          objc_msgSend(v369, "customIKEAuthPayloads");
          v370 = (void *)objc_claimAutoreleasedReturnValue();

          v371 = objc_msgSend(v370, "countByEnumeratingWithState:objects:count:", &v515, v529, 16);
          if (v371)
          {
            v372 = v371;
            v373 = *(_QWORD *)v516;
            do
            {
              v374 = 0;
              do
              {
                if (*(_QWORD *)v516 != v373)
                  objc_enumerationMutation(v370);
                v375 = *(void **)(*((_QWORD *)&v515 + 1) + 8 * v374);
                v376 = objc_alloc_init(NEIKEv2CustomPayload);
                v377 = objc_msgSend(v375, "customType");
                if (v376)
                {
                  v376->_customType = v377;
                  objc_msgSend(v375, "customData");
                  v378 = (void *)objc_claimAutoreleasedReturnValue();
                  objc_setProperty_atomic(v376, v379, v378, 32);
                }
                else
                {
                  objc_msgSend(v375, "customData");
                  v378 = (void *)objc_claimAutoreleasedReturnValue();
                }

                objc_getProperty(self, v380, 56, 1);
                v381 = (void *)objc_claimAutoreleasedReturnValue();

                if (v381)
                {
                  objc_getProperty(self, v382, 56, 1);
                  v383 = (void *)objc_claimAutoreleasedReturnValue();
                  objc_msgSend(v383, "arrayByAddingObject:", v376);
                  v384 = (void *)objc_claimAutoreleasedReturnValue();
                  objc_setProperty_atomic(self, v385, v384, 56);

                }
                else
                {
                  v528 = v376;
                  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", &v528, 1);
                  v383 = (void *)objc_claimAutoreleasedReturnValue();
                  objc_setProperty_atomic(self, v386, v383, 56);
                }

                ++v374;
              }
              while (v372 != v374);
              v387 = objc_msgSend(v370, "countByEnumeratingWithState:objects:count:", &v515, v529, 16);
              v372 = v387;
            }
            while (v387);
          }

          v43 = self;
          v239 = v43;
LABEL_260:
          v5 = v506;
          v36 = v504;
          a1 = v505;
          goto LABEL_266;
        }
        ne_log_obj();
        v97 = objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled(v97, OS_LOG_TYPE_FAULT))
          goto LABEL_264;
        *(_WORD *)buf = 0;
        v98 = "[packet addNotification:NEIKEv2NotifyTypeMOBIKESupported] failed";
      }
      else
      {
        ne_log_obj();
        v97 = objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled(v97, OS_LOG_TYPE_FAULT))
          goto LABEL_264;
        *(_WORD *)buf = 0;
        v98 = "[packet addNotification:NEIKEv2NotifyTypeInitialContact] failed";
      }
      goto LABEL_334;
    }
    ne_log_obj();
    v267 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v267, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136315138;
      v533 = "+[NEIKEv2IKEAuthPacket(Exchange) createIKEAuthResponse:ikeSA:childSA:]";
      _os_log_fault_impl(&dword_19BD16000, v267, OS_LOG_TYPE_FAULT, "%s called with null packet.tsr.isValid", buf, 0xCu);
    }
  }
  else
  {
    ne_log_obj();
    v267 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v267, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136315138;
      v533 = "+[NEIKEv2IKEAuthPacket(Exchange) createIKEAuthResponse:ikeSA:childSA:]";
      _os_log_fault_impl(&dword_19BD16000, v267, OS_LOG_TYPE_FAULT, "%s called with null packet.tsi.isValid", buf, 0xCu);
    }
  }

  v239 = 0;
LABEL_266:

  ne_log_obj();
  v389 = objc_claimAutoreleasedReturnValue();
  v390 = v389;
  if (v239)
  {
    if (os_log_type_enabled(v389, OS_LOG_TYPE_DEFAULT))
    {
      v391 = *(const char **)(a1 + 40);
      *(_DWORD *)buf = 138412290;
      v533 = v391;
      _os_log_impl(&dword_19BD16000, v390, OS_LOG_TYPE_DEFAULT, "%@ Sending AUTH reply", buf, 0xCu);
    }

    if ((-[NEIKEv2Session sendReply:replyHandler:](*(_QWORD *)(a1 + 40), v239, 0) & 1) != 0)
    {
      v393 = *(_QWORD *)(a1 + 56);
      if (v393 && (-[NEIKEv2ChildSA generateAllValues](v393) & 1) == 0)
      {
        ne_log_obj();
        v456 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v456, OS_LOG_TYPE_ERROR))
        {
          v483 = *(const char **)(a1 + 40);
          *(_DWORD *)buf = 138412290;
          v533 = v483;
          _os_log_error_impl(&dword_19BD16000, v456, OS_LOG_TYPE_ERROR, "%@ Failed to generate Child SA crypto values (receive)", buf, 0xCu);
        }

        v458 = *(id *)(a1 + 40);
        if (v458)
          v458 = objc_getProperty(v458, v457, 336, 1);
        v447 = v458;
        v455 = (void *)NEIKEv2CreateErrorCrypto(CFSTR("Failed to generate Child SA crypto values (receive)"), v459, v460, v461, v462, v463, v464, v465, v502);
      }
      else
      {
        -[NEIKEv2Session finishConfigurationEstablishment](*(_BYTE **)(a1 + 40), v392);
        -[NEIKEv2Session reportConfiguration](*(void **)(a1 + 40), v394);
        -[NEIKEv2IKESA clearAuthenticationSecrets](*(void **)(a1 + 32), v395);
        v396 = *(void **)(a1 + 56);
        if (!v396 || (-[NEIKEv2Session installChildSA:](*(_QWORD *)(a1 + 40), v396) & 1) != 0)
        {
          ne_log_obj();
          v397 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v397, OS_LOG_TYPE_DEFAULT))
          {
            v398 = *(const char **)(a1 + 40);
            v399 = *(_QWORD *)(a1 + 56);
            *(_DWORD *)buf = 138412546;
            v533 = v398;
            v534 = 2112;
            v535 = v399;
            _os_log_impl(&dword_19BD16000, v397, OS_LOG_TYPE_DEFAULT, "%@ Installed Child SA %@", buf, 0x16u);
          }

          v400 = *(_QWORD *)(a1 + 40);
          if (v400)
          {
            WeakRetained = objc_loadWeakRetained((id *)(v400 + 352));

            if (WeakRetained)
            {
              v513 = 0u;
              v514 = 0u;
              v511 = 0u;
              v512 = 0u;
              v403 = *(void **)(a1 + 40);
              if (v403)
              {
                v404 = objc_getProperty(v403, v402, 336, 1);
                v406 = v404;
                v407 = a1;
                if (v404)
                  v404 = objc_getProperty(v404, v405, 88, 1);
              }
              else
              {
                v407 = a1;
                v406 = 0;
                v404 = 0;
              }
              v408 = v404;
              objc_msgSend(v408, "configurationReply");
              v409 = (void *)objc_claimAutoreleasedReturnValue();
              v411 = v409;
              if (v409)
                v409 = objc_getProperty(v409, v410, 16, 1);
              v412 = v409;

              v413 = objc_msgSend(v412, "countByEnumeratingWithState:objects:count:", &v511, v527, 16);
              if (!v413)
              {

                a1 = v407;
                goto LABEL_326;
              }
              v414 = v413;
              selfa = v239;
              v415 = 0;
              v416 = *(_QWORD *)v512;
              while (1)
              {
                v417 = 0;
                do
                {
                  if (*(_QWORD *)v512 != v416)
                    objc_enumerationMutation(v412);
                  v418 = *(void **)(*((_QWORD *)&v511 + 1) + 8 * v417);
                  objc_opt_class();
                  if ((objc_opt_isKindOfClass() & 1) != 0)
                  {
                    objc_msgSend(v418, "address");
                    v420 = (void *)objc_claimAutoreleasedReturnValue();
                    v421 = *(void **)(v407 + 40);
                    if (!v421)
                      goto LABEL_300;
                    v422 = objc_getProperty(v421, v419, 336, 1);
                    v424 = v422;
                    if (v422)
                    {
                      v425 = v420;
                      v426 = 72;
LABEL_296:
                      objc_setProperty_atomic(v422, v423, v425, v426);
                    }
                  }
                  else
                  {
                    objc_opt_class();
                    if ((objc_opt_isKindOfClass() & 1) == 0)
                      goto LABEL_298;
                    objc_msgSend(v418, "address");
                    v420 = (void *)objc_claimAutoreleasedReturnValue();
                    v428 = *(void **)(v407 + 40);
                    if (!v428)
                    {
LABEL_300:
                      v424 = 0;
                      goto LABEL_297;
                    }
                    v422 = objc_getProperty(v428, v427, 336, 1);
                    v424 = v422;
                    if (v422)
                    {
                      v425 = v420;
                      v426 = 64;
                      goto LABEL_296;
                    }
                  }
LABEL_297:

                  v415 = 1;
LABEL_298:
                  ++v417;
                }
                while (v414 != v417);
                v429 = objc_msgSend(v412, "countByEnumeratingWithState:objects:count:", &v511, v527, 16);
                v414 = v429;
                if (!v429)
                {

                  a1 = v407;
                  v239 = selfa;
                  if ((v415 & 1) != 0)
                  {
                    ne_log_obj();
                    v430 = objc_claimAutoreleasedReturnValue();
                    if (os_log_type_enabled(v430, OS_LOG_TYPE_DEFAULT))
                    {
                      v431 = *(const char **)(v407 + 40);
                      *(_DWORD *)buf = 138412290;
                      v533 = v431;
                      _os_log_impl(&dword_19BD16000, v430, OS_LOG_TYPE_DEFAULT, "%@ Changing addresses and migrating (receive)", buf, 0xCu);
                    }

                    -[NEIKEv2Session migrateAllChildSAs](*(_QWORD *)(v407 + 40), v432);
                  }
                  break;
                }
              }
            }
          }
LABEL_326:
          ne_log_obj();
          v479 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v479, OS_LOG_TYPE_DEFAULT))
          {
            v480 = *(const char **)(a1 + 40);
            *(_DWORD *)buf = 138412290;
            v533 = v480;
            _os_log_impl(&dword_19BD16000, v479, OS_LOG_TYPE_DEFAULT, "%@ Completed connection (receive)", buf, 0xCu);
          }

          -[NEIKEv2IKESA setState:error:](*(_QWORD *)(a1 + 32), 2uLL, 0);
          v481 = *(void **)(a1 + 56);
          if (v481)
          {
            -[NEIKEv2Session reportTrafficSelectorsForChildSA:](*(void **)(a1 + 40), v481);
            -[NEIKEv2ChildSA setState:error:](*(_QWORD *)(a1 + 56), 2uLL, 0);
          }
          -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 40), (const char *)v481);
          goto LABEL_331;
        }
        ne_log_obj();
        v466 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v466, OS_LOG_TYPE_ERROR))
        {
          v484 = *(const char **)(a1 + 40);
          *(_DWORD *)buf = 138412290;
          v533 = v484;
          _os_log_error_impl(&dword_19BD16000, v466, OS_LOG_TYPE_ERROR, "%@ Failed to install Child SA (receive)", buf, 0xCu);
        }

        v468 = *(id *)(a1 + 40);
        if (v468)
          v468 = objc_getProperty(v468, v467, 336, 1);
        v447 = v468;
        v455 = (void *)NEIKEv2CreateErrorInternal(CFSTR("Failed to install Child SA (receive)"), v469, v470, v471, v472, v473, v474, v475, v502);
      }
    }
    else
    {
      v446 = *(id *)(a1 + 40);
      if (v446)
        v446 = objc_getProperty(v446, v392, 336, 1);
      v447 = v446;
      v455 = (void *)NEIKEv2CreateErrorFailedToSend(CFSTR("responder AUTH"), v448, v449, v450, v451, v452, v453, v454, v502);
    }
    v476 = v455;
    -[NEIKEv2IKESA setState:error:]((uint64_t)v447, 3uLL, v455);

    -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 40), v477);
    -[NEIKEv2Session resetAll](*(_QWORD *)(a1 + 40), v478);
LABEL_331:
    ErrorAuthentication = 0;
    goto LABEL_332;
  }
  if (os_log_type_enabled(v389, OS_LOG_TYPE_ERROR))
  {
    v482 = *(const char **)(a1 + 40);
    *(_DWORD *)buf = 138412290;
    v533 = v482;
    _os_log_error_impl(&dword_19BD16000, v390, OS_LOG_TYPE_ERROR, "%@ Failed to create IKE AUTH packet (receive)", buf, 0xCu);
  }

  v434 = *(id *)(a1 + 40);
  if (v434)
    v434 = objc_getProperty(v434, v433, 336, 1);
  v435 = v434;
  v443 = (void *)NEIKEv2CreateErrorInternal(CFSTR("Failed to create IKE AUTH packet (receive)"), v436, v437, v438, v439, v440, v441, v442, v502);
  -[NEIKEv2IKESA setState:error:]((uint64_t)v435, 3uLL, v443);

  -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 40), v444);
  -[NEIKEv2Session resetAll](*(_QWORD *)(a1 + 40), v445);
  ErrorAuthentication = 0;
  v239 = 0;
LABEL_332:

}

- (void)initiateNewChildSA:(_BYTE *)a1
{
  const char *v3;
  id *v4;
  id Property;
  NSObject *v6;
  id v7;
  SEL v8;
  id v9;
  void *v10;
  const char *v11;
  SEL v12;
  id v13;
  void *v14;
  char v15;
  _BYTE *v16;
  NSObject *v17;
  const char *v18;
  NSObject *v19;
  id v20;
  uint64_t v21;
  NEIKEv2ChildSAPayload *v22;
  SEL v23;
  SEL v24;
  id v25;
  void *v26;
  SEL v27;
  void *v28;
  const char *v29;
  void *v30;
  SEL v31;
  void *v32;
  char v33;
  const char *v34;
  NEIKEv2KeyExchangePayload *v35;
  SEL v36;
  SEL v37;
  void *v38;
  void *v39;
  const char *v40;
  void *v41;
  SEL v42;
  void *v43;
  const char *v44;
  void *v45;
  SEL v46;
  id v47;
  void *v48;
  void *v49;
  id v50;
  SEL v51;
  void *v52;
  const char *v53;
  void *v54;
  SEL v55;
  void *v56;
  char v57;
  NEIKEv2NoncePayload *v58;
  SEL v59;
  SEL v60;
  void *v61;
  SEL v62;
  void *v63;
  const char *v64;
  void *v65;
  SEL v66;
  void *v67;
  char v68;
  NEIKEv2InitiatorTrafficSelectorPayload *v69;
  SEL v70;
  const char *v71;
  void *v72;
  SEL v73;
  void *v74;
  const char *v75;
  void *v76;
  SEL v77;
  void *v78;
  char v79;
  NEIKEv2ResponderTrafficSelectorPayload *v80;
  SEL v81;
  const char *v82;
  void *v83;
  SEL v84;
  void *v85;
  const char *v86;
  void *v87;
  SEL v88;
  void *v89;
  char v90;
  NSObject *v91;
  NSObject *v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  __CFString *v100;
  NSObject *v101;
  void *ErrorCrypto;
  const char *v103;
  NSObject *v104;
  NSObject *v105;
  const char *v106;
  NSObject *v107;
  uint32_t v108;
  id *v109;
  SEL v110;
  id v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  void *ErrorFailedToSend;
  const char *v120;
  const char *v121;
  NSObject *v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  void *ErrorInternal;
  const char *v131;
  NSObject *v132;
  const char *v133;
  id v134;
  _QWORD v135[4];
  id *v136;
  _BYTE *v137;
  _BYTE *v138;
  uint8_t buf[4];
  const char *v140;
  uint64_t v141;

  v141 = *MEMORY[0x1E0C80C00];
  v4 = a2;
  if (a1)
    Property = objc_getProperty(a1, v3, 368, 1);
  else
    Property = 0;
  v6 = Property;
  dispatch_assert_queue_V2(v6);

  if (!a1[15])
    __assert_rtn("-[NEIKEv2Session(Exchange) initiateNewChildSA:]", "NEIKEv2Exchange.m", 1536, "self.hasOutboundRequestInFlight");
  v7 = v4[3];
  v9 = objc_getProperty(a1, v8, 336, 1);
  v10 = v9;
  if (!v7)
  {
    ne_log_obj();
    v132 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v132, OS_LOG_TYPE_FAULT))
    {
LABEL_72:

      objc_msgSend(v4, "sendCallbackSuccess:session:", 0, a1);
      goto LABEL_67;
    }
    *(_DWORD *)buf = 136315138;
    v140 = "-[NEIKEv2Session(Exchange) initiateNewChildSA:]";
    v133 = "%s called with null childSA";
LABEL_76:
    _os_log_fault_impl(&dword_19BD16000, v132, OS_LOG_TYPE_FAULT, v133, buf, 0xCu);
    goto LABEL_72;
  }
  if (!v9)
  {
    ne_log_obj();
    v132 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v132, OS_LOG_TYPE_FAULT))
      goto LABEL_72;
    *(_DWORD *)buf = 136315138;
    v140 = "-[NEIKEv2Session(Exchange) initiateNewChildSA:]";
    v133 = "%s called with null ikeSA";
    goto LABEL_76;
  }
  -[NEIKEv2ChildSA setState:error:]((uint64_t)v7, 1uLL, 0);
  -[NEIKEv2Session reportState](a1, v11);
  v13 = objc_getProperty(v7, v12, 48, 1);
  objc_msgSend(v13, "proposals");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  v15 = -[NEIKEv2Session generateSPIForChild:proposals:](a1, v7, v14);

  if ((v15 & 1) == 0)
  {
    ne_log_obj();
    v92 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v92, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_19BD16000, v92, OS_LOG_TYPE_ERROR, "Failed to generate Child SA SPI", buf, 2u);
    }

    objc_msgSend(v4, "sendCallbackSuccess:session:", 0, a1);
    v100 = CFSTR("Failed to generate Child SA SPI");
    goto LABEL_39;
  }
  if ((-[NEIKEv2ChildSA generateInitialValues]((id *)v7) & 1) == 0)
  {
    ne_log_obj();
    v101 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v101, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_19BD16000, v101, OS_LOG_TYPE_ERROR, "Failed to generate local Child crypto values", buf, 2u);
    }

    objc_msgSend(v4, "sendCallbackSuccess:session:", 0, a1);
    v100 = CFSTR("Failed to generate local Child crypto values");
LABEL_39:
    ErrorCrypto = (void *)NEIKEv2CreateErrorCrypto(v100, v93, v94, v95, v96, v97, v98, v99, (uint64_t)v134);
    -[NEIKEv2ChildSA setState:error:]((uint64_t)v7, 3uLL, ErrorCrypto);

    -[NEIKEv2Session reportState](a1, v103);
    -[NEIKEv2Session resetChild:](a1, v7);
    goto LABEL_67;
  }
  v16 = v7;
  objc_opt_self();
  if ((v16[9] & 1) == 0)
  {
    ne_log_obj();
    v19 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136315138;
      v140 = "+[NEIKEv2CreateChildPacket(Exchange) createChildSAForInitiatorChildSA:]";
      _os_log_fault_impl(&dword_19BD16000, v19, OS_LOG_TYPE_FAULT, "%s called with null childSA.isInitiator", buf, 0xCu);
    }
    goto LABEL_58;
  }
  v17 = -[NEIKEv2Packet initOutbound]([NEIKEv2CreateChildPacket alloc]);
  if (!v17)
  {
    ne_log_obj();
    v104 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v104, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_fault_impl(&dword_19BD16000, v104, OS_LOG_TYPE_FAULT, "[[NEIKEv2CreateChildPacket alloc] initOutbound:] failed", buf, 2u);
    }

    v19 = 0;
    goto LABEL_58;
  }
  v19 = v17;
  v20 = objc_getProperty(v16, v18, 48, 1);
  v21 = objc_msgSend(v20, "mode");

  if (v21 == 1 && !-[NEIKEv2Packet addNotification:data:](v19, 0x4007uLL, 0))
  {
    ne_log_obj();
    v105 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v105, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      v106 = "[packet addNotification:NEIKEv2NotifyTypeUseTransportMode] failed";
      v107 = v105;
      v108 = 2;
LABEL_56:
      _os_log_fault_impl(&dword_19BD16000, v107, OS_LOG_TYPE_FAULT, v106, buf, v108);
      goto LABEL_57;
    }
    goto LABEL_57;
  }
  v22 = objc_alloc_init(NEIKEv2ChildSAPayload);
  objc_setProperty_atomic(v19, v23, v22, 96);

  v25 = objc_getProperty(v16, v24, 48, 1);
  objc_msgSend(v25, "proposals");
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_getProperty(v19, v27, 96, 1);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = v28;
  if (v28)
    objc_setProperty_atomic(v28, v29, v26, 24);

  objc_getProperty(v19, v31, 96, 1);
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  v33 = -[NEIKEv2Payload isValid]((uint64_t)v32);

  if ((v33 & 1) == 0)
  {
    ne_log_obj();
    v105 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v105, OS_LOG_TYPE_FAULT))
      goto LABEL_57;
    *(_DWORD *)buf = 136315138;
    v140 = "+[NEIKEv2CreateChildPacket(Exchange) createChildSAForInitiatorChildSA:]";
    v106 = "%s called with null packet.childSA.isValid";
LABEL_55:
    v107 = v105;
    v108 = 12;
    goto LABEL_56;
  }
  if (-[NEIKEv2ChildSA shouldGenerateNewDHKeys](v16, v34))
  {
    v35 = objc_alloc_init(NEIKEv2KeyExchangePayload);
    objc_setProperty_atomic(v19, v36, v35, 104);

    v134 = objc_getProperty(v16, v37, 48, 1);
    objc_msgSend(v134, "proposals");
    v38 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v38, "firstObject");
    v39 = (void *)objc_claimAutoreleasedReturnValue();
    -[NEIKEv2IKESAProposal kemProtocol](v39, v40);
    v41 = (void *)objc_claimAutoreleasedReturnValue();
    objc_getProperty(v19, v42, 104, 1);
    v43 = (void *)objc_claimAutoreleasedReturnValue();
    v45 = v43;
    if (v43)
      objc_setProperty_atomic(v43, v44, v41, 24);

    v47 = objc_getProperty(v16, v46, 112, 1);
    v48 = v47;
    if (v47)
      v49 = (void *)*((_QWORD *)v47 + 2);
    else
      v49 = 0;
    v50 = v49;
    objc_getProperty(v19, v51, 104, 1);
    v52 = (void *)objc_claimAutoreleasedReturnValue();
    v54 = v52;
    if (v52)
      objc_setProperty_atomic(v52, v53, v50, 32);

    objc_getProperty(v19, v55, 104, 1);
    v56 = (void *)objc_claimAutoreleasedReturnValue();
    v57 = -[NEIKEv2Payload isValid]((uint64_t)v56);

    if ((v57 & 1) == 0)
    {
      ne_log_obj();
      v105 = objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v105, OS_LOG_TYPE_FAULT))
        goto LABEL_57;
      *(_DWORD *)buf = 136315138;
      v140 = "+[NEIKEv2CreateChildPacket(Exchange) createChildSAForInitiatorChildSA:]";
      v106 = "%s called with null packet.ke.isValid";
      goto LABEL_55;
    }
  }
  v58 = objc_alloc_init(NEIKEv2NoncePayload);
  objc_setProperty_atomic(v19, v59, v58, 112);

  objc_getProperty(v16, v60, 80, 1);
  v61 = (void *)objc_claimAutoreleasedReturnValue();
  objc_getProperty(v19, v62, 112, 1);
  v63 = (void *)objc_claimAutoreleasedReturnValue();
  v65 = v63;
  if (v63)
    objc_setProperty_atomic(v63, v64, v61, 24);

  objc_getProperty(v19, v66, 112, 1);
  v67 = (void *)objc_claimAutoreleasedReturnValue();
  v68 = -[NEIKEv2Payload isValid]((uint64_t)v67);

  if ((v68 & 1) == 0)
  {
    ne_log_obj();
    v105 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v105, OS_LOG_TYPE_FAULT))
      goto LABEL_57;
    *(_DWORD *)buf = 136315138;
    v140 = "+[NEIKEv2CreateChildPacket(Exchange) createChildSAForInitiatorChildSA:]";
    v106 = "%s called with null packet.nonce.isValid";
    goto LABEL_55;
  }
  v69 = objc_alloc_init(NEIKEv2InitiatorTrafficSelectorPayload);
  objc_setProperty_atomic(v19, v70, v69, 128);

  -[NEIKEv2ChildSA configuredInitiatorTrafficSelectors](v16, v71);
  v72 = (void *)objc_claimAutoreleasedReturnValue();
  objc_getProperty(v19, v73, 128, 1);
  v74 = (void *)objc_claimAutoreleasedReturnValue();
  v76 = v74;
  if (v74)
    objc_setProperty_atomic(v74, v75, v72, 24);

  objc_getProperty(v19, v77, 128, 1);
  v78 = (void *)objc_claimAutoreleasedReturnValue();
  v79 = -[NEIKEv2Payload isValid]((uint64_t)v78);

  if ((v79 & 1) == 0)
  {
    ne_log_obj();
    v105 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v105, OS_LOG_TYPE_FAULT))
      goto LABEL_57;
    *(_DWORD *)buf = 136315138;
    v140 = "+[NEIKEv2CreateChildPacket(Exchange) createChildSAForInitiatorChildSA:]";
    v106 = "%s called with null packet.tsi.isValid";
    goto LABEL_55;
  }
  v80 = objc_alloc_init(NEIKEv2ResponderTrafficSelectorPayload);
  objc_setProperty_atomic(v19, v81, v80, 136);

  -[NEIKEv2ChildSA configuredResponderTrafficSelectors](v16, v82);
  v83 = (void *)objc_claimAutoreleasedReturnValue();
  objc_getProperty(v19, v84, 136, 1);
  v85 = (void *)objc_claimAutoreleasedReturnValue();
  v87 = v85;
  if (v85)
    objc_setProperty_atomic(v85, v86, v83, 24);

  objc_getProperty(v19, v88, 136, 1);
  v89 = (void *)objc_claimAutoreleasedReturnValue();
  v90 = -[NEIKEv2Payload isValid]((uint64_t)v89);

  if ((v90 & 1) == 0)
  {
    ne_log_obj();
    v105 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v105, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136315138;
      v140 = "+[NEIKEv2CreateChildPacket(Exchange) createChildSAForInitiatorChildSA:]";
      v106 = "%s called with null packet.tsr.isValid";
      goto LABEL_55;
    }
LABEL_57:

LABEL_58:
    v91 = 0;
    goto LABEL_59;
  }
  v19 = v19;
  v91 = v19;
LABEL_59:

  if (v91)
  {
    v135[0] = MEMORY[0x1E0C809B0];
    v135[1] = 3221225472;
    v135[2] = __47__NEIKEv2Session_Exchange__initiateNewChildSA___block_invoke;
    v135[3] = &unk_1E3CC10E0;
    v109 = v4;
    v136 = v109;
    v137 = a1;
    v138 = v16;
    if (-[NEIKEv2Session sendRequest:retry:replyHandler:]((uint64_t)a1, v91, v135) == -1)
    {
      objc_msgSend(v109, "sendCallbackSuccess:session:", 0, a1);
      v111 = objc_getProperty(a1, v110, 336, 1);
      ErrorFailedToSend = (void *)NEIKEv2CreateErrorFailedToSend(CFSTR("create child SA"), v112, v113, v114, v115, v116, v117, v118, (uint64_t)v134);
      -[NEIKEv2IKESA setState:error:]((uint64_t)v111, 3uLL, ErrorFailedToSend);

      -[NEIKEv2Session reportState](a1, v120);
      -[NEIKEv2Session resetAll]((uint64_t)a1, v121);
    }

  }
  else
  {
    ne_log_obj();
    v122 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v122, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_19BD16000, v122, OS_LOG_TYPE_ERROR, "Failed to create Create Child SA packet", buf, 2u);
    }

    objc_msgSend(v4, "sendCallbackSuccess:session:", 0, a1);
    ErrorInternal = (void *)NEIKEv2CreateErrorInternal(CFSTR("Failed to create Create Child SA packet"), v123, v124, v125, v126, v127, v128, v129, (uint64_t)v134);
    -[NEIKEv2ChildSA setState:error:]((uint64_t)v16, 3uLL, ErrorInternal);

    -[NEIKEv2Session reportState](a1, v131);
    -[NEIKEv2Session resetChild:](a1, v16);
  }

LABEL_67:
}

void __47__NEIKEv2Session_Exchange__initiateNewChildSA___block_invoke(id *a1, void *a2)
{
  id v3;
  char *v4;
  const char *v5;
  char *v6;
  const char *v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t i;
  const __CFString *v13;
  id v14;
  char v15;
  const char *v16;
  NSObject *v17;
  NSObject *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  __CFString *v27;
  void *Property;
  const char *v29;
  void *v30;
  const char *v31;
  const char *v32;
  id v33;
  id v34;
  const char *v35;
  id v36;
  void *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  void *v42;
  NSObject *v43;
  NSObject *v44;
  const char *v45;
  NSObject *v46;
  int v47;
  uint32_t v48;
  NSObject *v49;
  SEL v50;
  SEL v51;
  id v52;
  NSObject *v53;
  void *v54;
  SEL v55;
  id v56;
  SEL v57;
  void *v58;
  const char *v59;
  void *v60;
  const char *v61;
  void *v62;
  id v63;
  void *v64;
  const char *v65;
  id v66;
  int v67;
  const char *v68;
  void *v69;
  const char *v70;
  void *v71;
  id v72;
  uint64_t v73;
  const char *v74;
  NSObject *v75;
  void *v76;
  const char *v77;
  NSObject *v78;
  uint32_t v79;
  SEL v80;
  id v81;
  void *v82;
  const char *v83;
  NSObject *v84;
  void *ErrorCrypto;
  void *v86;
  const char *v87;
  id v88;
  id v89;
  const char *v90;
  void *v91;
  unsigned int v92;
  const char *v93;
  void *v94;
  id v95;
  id v96;
  const char *v97;
  void *v98;
  void *v99;
  const char *v100;
  void *v101;
  id v102;
  SEL v103;
  const char *v104;
  const char *v105;
  void *v106;
  const char *v107;
  void *v108;
  const char *v109;
  void *v110;
  id v111;
  const char *v112;
  void *v113;
  const char *v114;
  void *v115;
  id v116;
  const char *v117;
  void *v118;
  const char *v119;
  void *v120;
  SEL v121;
  id v122;
  const char *v123;
  void *v124;
  uint64_t v125;
  const char *v126;
  void *v127;
  const char *v128;
  void *v129;
  id v130;
  SEL v131;
  void *v132;
  const char *v133;
  void *v134;
  id v135;
  const char *v136;
  void *v137;
  const char *v138;
  void *v139;
  const char *v140;
  void *v141;
  id v142;
  const char *v143;
  void *v144;
  const char *v145;
  id v146;
  id v147;
  const char *v148;
  void *v149;
  id v150;
  const char *v151;
  NSObject *v152;
  const char *v153;
  NSObject *v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  __CFString *v162;
  SEL v163;
  void *v164;
  const char *v165;
  SEL v166;
  id v167;
  const char *v168;
  void *v169;
  uint64_t v170;
  NSObject *v171;
  const char *v172;
  id v173;
  _QWORD *v174;
  id v175;
  const char *v176;
  void *v177;
  const char *v178;
  id v179;
  id v180;
  id v181;
  const char *v182;
  void *v183;
  id v184;
  id v185;
  id v186;
  id v187;
  NSObject *v188;
  uint64_t v189;
  id v190;
  id v191;
  uint64_t v192;
  id v193;
  id v194;
  id v195;
  id self;
  _QWORD v197[4];
  id v198;
  id v199;
  id v200;
  __int128 v201;
  __int128 v202;
  __int128 v203;
  __int128 v204;
  __int128 v205;
  __int128 v206;
  __int128 v207;
  __int128 v208;
  uint8_t buf[4];
  const char *v210;
  __int16 v211;
  uint64_t v212;
  __int16 v213;
  uint64_t v214;
  __int16 v215;
  uint64_t v216;
  uint8_t v217[128];
  uint8_t v218[136];
  uint64_t v219;

  v219 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    ne_log_obj();
    v18 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v218 = 0;
      _os_log_error_impl(&dword_19BD16000, v18, OS_LOG_TYPE_ERROR, "Failed to receive Create Child SA packet", v218, 2u);
    }

    objc_msgSend(a1[4], "sendCallbackSuccess:session:", 0, a1[5]);
    v26 = (uint64_t)a1[6];
    v27 = CFSTR("Failed to receive Create Child SA packet");
    goto LABEL_83;
  }
  v4 = (char *)a1[6];
  v6 = v4;
  if (!v3)
    goto LABEL_80;
  if (!v4 || (v4[9] & 1) == 0)
  {
    ne_log_obj();
    v8 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136315138;
      v210 = "-[NEIKEv2CreateChildPacket(Exchange) validateCreateChildAsInitiator:]";
      _os_log_fault_impl(&dword_19BD16000, v8, OS_LOG_TYPE_FAULT, "%s called with null childSA.isInitiator", buf, 0xCu);
    }
    goto LABEL_79;
  }
  if (!-[NEIKEv2Packet hasErrors](v3, v5))
    goto LABEL_16;
  v207 = 0u;
  v208 = 0u;
  v206 = 0u;
  v205 = 0u;
  v8 = objc_getProperty(v3, v7, 64, 1);
  v9 = -[NSObject countByEnumeratingWithState:objects:count:](v8, "countByEnumeratingWithState:objects:count:", &v205, v218, 16);
  if (!v9)
    goto LABEL_15;
  v10 = v9;
  v11 = *(_QWORD *)v206;
  do
  {
    for (i = 0; i != v10; ++i)
    {
      if (*(_QWORD *)v206 != v11)
        objc_enumerationMutation(v8);
      v13 = *(const __CFString **)(*((_QWORD *)&v205 + 1) + 8 * i);
      if (v13 && (unint64_t)(v13->length - 1) <= 0x3FFE)
      {
        ne_log_obj();
        v17 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        {
          v43 = objc_msgSend(v3, "copyShortDescription");
          v44 = -[NEIKEv2NotifyPayload copyError](v13);
          *(_DWORD *)buf = 138412802;
          v210 = v6;
          v211 = 2112;
          v212 = (uint64_t)v43;
          v213 = 2112;
          v214 = (uint64_t)v44;
          v45 = "%@ %@ Initiator create child received notify error %@";
          v46 = v17;
          goto LABEL_46;
        }
LABEL_78:

        goto LABEL_79;
      }
    }
    v10 = -[NSObject countByEnumeratingWithState:objects:count:](v8, "countByEnumeratingWithState:objects:count:", &v205, v218, 16);
  }
  while (v10);
LABEL_15:

LABEL_16:
  v14 = objc_getProperty(v6, v7, 48, 1);
  if (objc_msgSend(v14, "mode") != 1)
  {

LABEL_24:
    objc_getProperty(v3, v16, 96, 1);
    Property = (void *)objc_claimAutoreleasedReturnValue();
    v30 = Property;
    if (Property)
      Property = objc_getProperty(Property, v29, 24, 1);
    v8 = Property;

    if (-[NSObject count](v8, "count") == 1)
    {
      -[NSObject firstObject](v8, "firstObject");
      v17 = objc_claimAutoreleasedReturnValue();
      if ((-[NEIKEv2ChildSAProposal isAValidResponse](v17, v31) & 1) != 0)
      {
        if (v17)
          v33 = objc_getProperty(v17, v32, 80, 1);
        else
          v33 = 0;
        v34 = v33;

        if (v34)
        {
          v203 = 0u;
          v204 = 0u;
          v201 = 0u;
          v202 = 0u;
          v36 = objc_getProperty(v6, v35, 48, 1);
          objc_msgSend(v36, "proposals");
          v37 = (void *)objc_claimAutoreleasedReturnValue();

          v38 = objc_msgSend(v37, "countByEnumeratingWithState:objects:count:", &v201, v217, 16);
          if (v38)
          {
            v39 = v38;
            v40 = *(_QWORD *)v202;
LABEL_33:
            v41 = 0;
            while (1)
            {
              if (*(_QWORD *)v202 != v40)
                objc_enumerationMutation(v37);
              v42 = *(void **)(*((_QWORD *)&v201 + 1) + 8 * v41);
              if ((-[NEIKEv2ChildSAProposal matchesLocalProposal:preferRemoteProposal:checkKEMethod:]((uint64_t)v42, v17, 0, 0) & 1) != 0)break;
              if (v39 == ++v41)
              {
                v39 = objc_msgSend(v37, "countByEnumeratingWithState:objects:count:", &v201, v217, 16);
                if (v39)
                  goto LABEL_33;
                goto LABEL_39;
              }
            }
            v44 = v42;

            if (!v44)
              goto LABEL_64;
            v49 = -[NEIKEv2ChildSAProposal copyFromRemote:preferRemoteProposal:checkKEMethod:](v44, v17, 0, 0);
            objc_setProperty_atomic(v6, v50, v49, 56);

            v52 = objc_getProperty(v6, v51, 56, 1);
            ne_log_obj();
            v53 = objc_claimAutoreleasedReturnValue();
            v43 = v53;
            if (v52)
            {
              if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
              {
                v54 = (void *)objc_msgSend(v3, "copyShortDescription");
                v56 = objc_getProperty(v6, v55, 56, 1);
                *(_DWORD *)buf = 138412802;
                v210 = v6;
                v211 = 2112;
                v212 = (uint64_t)v54;
                v213 = 2112;
                v214 = (uint64_t)v56;
                _os_log_impl(&dword_19BD16000, v43, OS_LOG_TYPE_DEFAULT, "%@ %@ Chose responder new child proposal %@", buf, 0x20u);

              }
              objc_getProperty(v3, v57, 112, 1);
              v58 = (void *)objc_claimAutoreleasedReturnValue();

              if (v58)
              {
                objc_getProperty(v3, v59, 112, 1);
                v60 = (void *)objc_claimAutoreleasedReturnValue();
                v62 = v60;
                if (v60)
                  v60 = objc_getProperty(v60, v61, 24, 1);
                v63 = v60;

                if (v63)
                {
                  -[NEIKEv2ChildSA ikeSA]((id *)v6);
                  v64 = (void *)objc_claimAutoreleasedReturnValue();
                  self = v64;
                  if (v64)
                    v64 = objc_getProperty(v64, v65, 80, 1);
                  v66 = v64;
                  v67 = objc_msgSend(v66, "strictNonceSizeChecks");

                  if (v67)
                  {
                    objc_getProperty(v3, v68, 112, 1);
                    v69 = (void *)objc_claimAutoreleasedReturnValue();
                    v71 = v69;
                    if (v69)
                      v69 = objc_getProperty(v69, v70, 24, 1);
                    v72 = v69;
                    v73 = objc_msgSend(v72, "length");

                    if ((unint64_t)(v73 - 257) <= 0xFFFFFFFFFFFFFF0ELL)
                    {
                      ne_log_obj();
                      v75 = objc_claimAutoreleasedReturnValue();
                      if (os_log_type_enabled(v75, OS_LOG_TYPE_ERROR))
                      {
                        v76 = (void *)objc_msgSend(v3, "copyShortDescription");
                        *(_DWORD *)buf = 138412802;
                        v210 = v6;
                        v211 = 2112;
                        v212 = (uint64_t)v76;
                        v213 = 2048;
                        v214 = v73;
                        v77 = "%@ %@ NONCE data length %zu is out of bounds";
                        v78 = v75;
                        v79 = 32;
LABEL_142:
                        _os_log_error_impl(&dword_19BD16000, v78, OS_LOG_TYPE_ERROR, v77, buf, v79);

                      }
LABEL_148:

                      goto LABEL_77;
                    }
                    v88 = self;
                    v193 = (id)v73;
                    if (self)
                      v88 = objc_getProperty(self, v74, 96, 1);
                    v89 = v88;
                    -[NEIKEv2IKESAProposal prfProtocol](v89, v90);
                    v91 = (void *)objc_claimAutoreleasedReturnValue();
                    v92 = objc_msgSend(v91, "nonceSize");

                    if ((unint64_t)v193 < v92)
                    {
                      ne_log_obj();
                      v75 = objc_claimAutoreleasedReturnValue();
                      if (!os_log_type_enabled(v75, OS_LOG_TYPE_ERROR))
                        goto LABEL_148;
                      v94 = (void *)objc_msgSend(v3, "copyShortDescription");
                      if (self)
                        v95 = objc_getProperty(self, v93, 96, 1);
                      else
                        v95 = 0;
                      v96 = v95;
                      -[NEIKEv2IKESAProposal prfProtocol](v96, v97);
                      v98 = (void *)objc_claimAutoreleasedReturnValue();
                      *(_DWORD *)buf = 138413058;
                      v210 = v6;
                      v211 = 2112;
                      v212 = (uint64_t)v94;
                      v213 = 2048;
                      v214 = (uint64_t)v193;
                      v215 = 2112;
                      v216 = (uint64_t)v98;
                      _os_log_error_impl(&dword_19BD16000, v75, OS_LOG_TYPE_ERROR, "%@ %@ NONCE data length %zu is shorter than the minimum for PRF protocol %@", buf, 0x2Au);

LABEL_147:
                      goto LABEL_148;
                    }
                  }
                  objc_getProperty(v3, v68, 112, 1);
                  v99 = (void *)objc_claimAutoreleasedReturnValue();
                  v101 = v99;
                  if (v99)
                    v99 = objc_getProperty(v99, v100, 24, 1);
                  v102 = v99;
                  objc_setProperty_atomic(v6, v103, v102, 88);

                  if (-[NEIKEv2ChildSA shouldGenerateNewDHKeys](v6, v104))
                  {
                    objc_getProperty(v3, v105, 104, 1);
                    v106 = (void *)objc_claimAutoreleasedReturnValue();

                    if (!v106)
                    {
                      ne_log_obj();
                      v75 = objc_claimAutoreleasedReturnValue();
                      if (!os_log_type_enabled(v75, OS_LOG_TYPE_ERROR))
                        goto LABEL_148;
                      v76 = (void *)objc_msgSend(v3, "copyShortDescription");
                      *(_DWORD *)buf = 138412546;
                      v210 = v6;
                      v211 = 2112;
                      v212 = (uint64_t)v76;
                      v77 = "%@ %@ Did not receive KE payload";
                      goto LABEL_141;
                    }
                    objc_getProperty(v3, v107, 104, 1);
                    v108 = (void *)objc_claimAutoreleasedReturnValue();
                    v110 = v108;
                    if (v108)
                      v108 = objc_getProperty(v108, v109, 24, 1);
                    v111 = v108;

                    if (!v111)
                    {
                      ne_log_obj();
                      v75 = objc_claimAutoreleasedReturnValue();
                      if (!os_log_type_enabled(v75, OS_LOG_TYPE_ERROR))
                        goto LABEL_148;
                      v76 = (void *)objc_msgSend(v3, "copyShortDescription");
                      *(_DWORD *)buf = 138412546;
                      v210 = v6;
                      v211 = 2112;
                      v212 = (uint64_t)v76;
                      v77 = "%@ %@ Did not receive method in KE payload";
                      goto LABEL_141;
                    }
                    objc_getProperty(v3, v112, 104, 1);
                    v113 = (void *)objc_claimAutoreleasedReturnValue();
                    v115 = v113;
                    if (v113)
                      v113 = objc_getProperty(v113, v114, 32, 1);
                    v116 = v113;

                    if (!v116)
                    {
                      ne_log_obj();
                      v75 = objc_claimAutoreleasedReturnValue();
                      if (!os_log_type_enabled(v75, OS_LOG_TYPE_ERROR))
                        goto LABEL_148;
                      v76 = (void *)objc_msgSend(v3, "copyShortDescription");
                      *(_DWORD *)buf = 138412546;
                      v210 = v6;
                      v211 = 2112;
                      v212 = (uint64_t)v76;
                      v77 = "%@ %@ Did not receive data in KE payload";
                      goto LABEL_141;
                    }
                    objc_getProperty(v3, v117, 104, 1);
                    v118 = (void *)objc_claimAutoreleasedReturnValue();
                    if (v118)
                    {
                      v120 = v118;
                      v118 = objc_getProperty(v118, v119, 24, 1);
                    }
                    else
                    {
                      v120 = 0;
                    }
                    v191 = v118;
                    v194 = (id)objc_msgSend(v191, "method");
                    v122 = objc_getProperty(v6, v121, 56, 1);
                    -[NEIKEv2IKESAProposal kemProtocol](v122, v123);
                    v124 = (void *)objc_claimAutoreleasedReturnValue();
                    v125 = objc_msgSend(v124, "method");

                    if (v194 != (id)v125)
                    {
                      ne_log_obj();
                      v75 = objc_claimAutoreleasedReturnValue();
                      if (!os_log_type_enabled(v75, OS_LOG_TYPE_ERROR))
                        goto LABEL_148;
                      v192 = objc_msgSend(v3, "copyShortDescription");
                      objc_getProperty(v3, v163, 104, 1);
                      v164 = (void *)objc_claimAutoreleasedReturnValue();
                      v195 = v164;
                      if (v164)
                        v164 = objc_getProperty(v164, v165, 24, 1);
                      v190 = v164;
                      v189 = objc_msgSend(v190, "method");
                      v167 = objc_getProperty(v6, v166, 56, 1);
                      -[NEIKEv2IKESAProposal kemProtocol](v167, v168);
                      v169 = (void *)objc_claimAutoreleasedReturnValue();
                      v170 = objc_msgSend(v169, "method");
                      *(_DWORD *)buf = 138413058;
                      v210 = v6;
                      v211 = 2112;
                      v94 = (void *)v192;
                      v212 = v192;
                      v213 = 2048;
                      v214 = v189;
                      v215 = 2048;
                      v216 = v170;
                      _os_log_error_impl(&dword_19BD16000, v75, OS_LOG_TYPE_ERROR, "%@ %@ Did not receive matching method from KE payload (%zu != %zu)", buf, 0x2Au);

                      goto LABEL_147;
                    }
                    objc_getProperty(v3, v126, 104, 1);
                    v127 = (void *)objc_claimAutoreleasedReturnValue();
                    v129 = v127;
                    if (v127)
                      v127 = objc_getProperty(v127, v128, 32, 1);
                    v130 = v127;
                    objc_setProperty_atomic(v6, v131, v130, 104);

                  }
                  objc_getProperty(v3, v105, 128, 1);
                  v132 = (void *)objc_claimAutoreleasedReturnValue();
                  v134 = v132;
                  if (v132)
                    v132 = objc_getProperty(v132, v133, 24, 1);
                  v135 = v132;
                  -[NEIKEv2ChildSA setInitiatorTrafficSelectors:](v6, v135);

                  -[NEIKEv2ChildSA initiatorTrafficSelectors](v6, v136);
                  v137 = (void *)objc_claimAutoreleasedReturnValue();

                  if (v137)
                  {
                    objc_getProperty(v3, v138, 136, 1);
                    v139 = (void *)objc_claimAutoreleasedReturnValue();
                    v141 = v139;
                    if (v139)
                      v139 = objc_getProperty(v139, v140, 24, 1);
                    v142 = v139;
                    -[NEIKEv2ChildSA setResponderTrafficSelectors:](v6, v142);

                    -[NEIKEv2ChildSA responderTrafficSelectors](v6, v143);
                    v144 = (void *)objc_claimAutoreleasedReturnValue();

                    if (v144)
                    {

                      v146 = a1[6];
                      if (v146)
                      {
                        v147 = objc_getProperty(v146, v145, 56, 1);
                        v149 = v147;
                        if (v147)
                          v147 = objc_getProperty(v147, v148, 112, 1);
                      }
                      else
                      {
                        v149 = 0;
                        v147 = 0;
                      }
                      v150 = v147;

                      if (v150 && (-[NEIKEv2ChildSA processPrimaryKeyExchange]((uint64_t)a1[6], v151) & 1) == 0)
                      {
                        ne_log_obj();
                        v188 = objc_claimAutoreleasedReturnValue();
                        if (os_log_type_enabled(v188, OS_LOG_TYPE_ERROR))
                        {
                          *(_WORD *)v218 = 0;
                          _os_log_error_impl(&dword_19BD16000, v188, OS_LOG_TYPE_ERROR, "Failed to process KE data", v218, 2u);
                        }

                        objc_msgSend(a1[4], "sendCallbackSuccess:session:", 0, a1[5]);
                        v26 = (uint64_t)a1[6];
                        v162 = CFSTR("Failed to process KE data");
                      }
                      else
                      {
                        if ((-[NEIKEv2ChildSA generateAllValues]((uint64_t)a1[6]) & 1) != 0)
                        {
                          if ((-[NEIKEv2Session installChildSA:]((uint64_t)a1[5], a1[6]) & 1) != 0)
                          {
                            -[NEIKEv2Session reportTrafficSelectorsForChildSA:](a1[5], a1[6]);
                            ne_log_obj();
                            v152 = objc_claimAutoreleasedReturnValue();
                            if (os_log_type_enabled(v152, OS_LOG_TYPE_INFO))
                            {
                              *(_WORD *)v218 = 0;
                              _os_log_impl(&dword_19BD16000, v152, OS_LOG_TYPE_INFO, "Completed new child SA connection", v218, 2u);
                            }

                            -[NEIKEv2ChildSA setState:error:]((uint64_t)a1[6], 2uLL, 0);
                            -[NEIKEv2Session reportState](a1[5], v153);
                            objc_msgSend(a1[4], "sendCallbackSuccess:session:", 1, a1[5]);
                          }
                          else
                          {
                            ne_log_obj();
                            v171 = objc_claimAutoreleasedReturnValue();
                            if (os_log_type_enabled(v171, OS_LOG_TYPE_ERROR))
                            {
                              *(_WORD *)v218 = 0;
                              _os_log_error_impl(&dword_19BD16000, v171, OS_LOG_TYPE_ERROR, "Failed to install Child SA", v218, 2u);
                            }

                            v174 = a1[5];
                            v173 = a1[6];
                            if (v173)
                            {
                              v175 = objc_getProperty(v173, v172, 56, 1);
                              v177 = v175;
                              if (v175)
                                v175 = objc_getProperty(v175, v176, 80, 1);
                            }
                            else
                            {
                              v177 = 0;
                              v175 = 0;
                            }
                            v179 = v175;
                            v180 = a1[6];
                            if (v180)
                            {
                              v181 = objc_getProperty(v180, v178, 56, 1);
                              v183 = v181;
                              if (v181)
                                v181 = objc_getProperty(v181, v182, 88, 1);
                            }
                            else
                            {
                              v183 = 0;
                              v181 = 0;
                            }
                            v184 = v181;
                            v197[0] = MEMORY[0x1E0C809B0];
                            v197[1] = 3221225472;
                            v197[2] = __47__NEIKEv2Session_Exchange__initiateNewChildSA___block_invoke_241;
                            v197[3] = &unk_1E3CC10B8;
                            v185 = a1[4];
                            v186 = a1[5];
                            v187 = a1[6];
                            v198 = v185;
                            v199 = v186;
                            v200 = v187;
                            -[NEIKEv2Session initiateDeleteChildSPI:remoteSPI:deleteCompletionCallback:](v174, v179, v184, v197);

                          }
                          goto LABEL_85;
                        }
                        ne_log_obj();
                        v154 = objc_claimAutoreleasedReturnValue();
                        if (os_log_type_enabled(v154, OS_LOG_TYPE_ERROR))
                        {
                          *(_WORD *)v218 = 0;
                          _os_log_error_impl(&dword_19BD16000, v154, OS_LOG_TYPE_ERROR, "Failed to generate Child SA crypto values", v218, 2u);
                        }

                        objc_msgSend(a1[4], "sendCallbackSuccess:session:", 0, a1[5]);
                        v26 = (uint64_t)a1[6];
                        v162 = CFSTR("Failed to generate Child SA crypto values");
                      }
                      ErrorCrypto = (void *)NEIKEv2CreateErrorCrypto(v162, v155, v156, v157, v158, v159, v160, v161, v189);
                      goto LABEL_84;
                    }
                    ne_log_obj();
                    v75 = objc_claimAutoreleasedReturnValue();
                    if (!os_log_type_enabled(v75, OS_LOG_TYPE_ERROR))
                      goto LABEL_148;
                    v76 = (void *)objc_msgSend(v3, "copyShortDescription");
                    *(_DWORD *)buf = 138412546;
                    v210 = v6;
                    v211 = 2112;
                    v212 = (uint64_t)v76;
                    v77 = "%@ %@ Could not set responder traffic selectors";
                  }
                  else
                  {
                    ne_log_obj();
                    v75 = objc_claimAutoreleasedReturnValue();
                    if (!os_log_type_enabled(v75, OS_LOG_TYPE_ERROR))
                      goto LABEL_148;
                    v76 = (void *)objc_msgSend(v3, "copyShortDescription");
                    *(_DWORD *)buf = 138412546;
                    v210 = v6;
                    v211 = 2112;
                    v212 = (uint64_t)v76;
                    v77 = "%@ %@ Could not set initiator traffic selectors";
                  }
LABEL_141:
                  v78 = v75;
                  v79 = 22;
                  goto LABEL_142;
                }
                ne_log_obj();
                v43 = objc_claimAutoreleasedReturnValue();
                if (!os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
                  goto LABEL_76;
                v81 = (id)objc_msgSend(v3, "copyShortDescription");
                *(_DWORD *)buf = 138412546;
                v210 = v6;
                v211 = 2112;
                v212 = (uint64_t)v81;
                v83 = "%@ %@ Did not receive NONCE data";
              }
              else
              {
                ne_log_obj();
                v43 = objc_claimAutoreleasedReturnValue();
                if (!os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
                  goto LABEL_76;
                v81 = (id)objc_msgSend(v3, "copyShortDescription");
                *(_DWORD *)buf = 138412546;
                v210 = v6;
                v211 = 2112;
                v212 = (uint64_t)v81;
                v83 = "%@ %@ Did not receive NONCE payload";
              }
            }
            else
            {
              if (!os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
                goto LABEL_76;
              v81 = (id)objc_msgSend(v3, "copyShortDescription");
              *(_DWORD *)buf = 138412546;
              v210 = v6;
              v211 = 2112;
              v212 = (uint64_t)v81;
              v83 = "%@ %@ Could not set chosen proposal values";
            }
            _os_log_error_impl(&dword_19BD16000, v43, OS_LOG_TYPE_ERROR, v83, buf, 0x16u);
            goto LABEL_75;
          }
LABEL_39:

LABEL_64:
          ne_log_obj();
          v44 = objc_claimAutoreleasedReturnValue();
          if (!os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
            goto LABEL_77;
          v43 = objc_msgSend(v3, "copyShortDescription");
          v81 = objc_getProperty(v6, v80, 48, 1);
          objc_msgSend(v81, "proposals");
          v82 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 138413058;
          v210 = v6;
          v211 = 2112;
          v212 = (uint64_t)v43;
          v213 = 2112;
          v214 = (uint64_t)v17;
          v215 = 2112;
          v216 = (uint64_t)v82;
          _os_log_error_impl(&dword_19BD16000, v44, OS_LOG_TYPE_ERROR, "%@ %@ Received proposal %@ does not match config %@", buf, 0x2Au);

LABEL_75:
          goto LABEL_76;
        }
        ne_log_obj();
        v44 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
        {
          v43 = objc_msgSend(v3, "copyShortDescription");
          *(_DWORD *)buf = 138412546;
          v210 = v6;
          v211 = 2112;
          v212 = (uint64_t)v43;
          v45 = "%@ %@ Child SA proposal missing SPI";
          v46 = v44;
          v48 = 22;
LABEL_47:
          _os_log_error_impl(&dword_19BD16000, v46, OS_LOG_TYPE_ERROR, v45, buf, v48);
LABEL_76:

        }
      }
      else
      {
        ne_log_obj();
        v44 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
        {
          v43 = objc_msgSend(v3, "copyShortDescription");
          *(_DWORD *)buf = 138412802;
          v210 = v6;
          v211 = 2112;
          v212 = (uint64_t)v43;
          v213 = 2112;
          v214 = (uint64_t)v17;
          v45 = "%@ %@ Received invalid child proposal %@";
          v46 = v44;
LABEL_46:
          v48 = 32;
          goto LABEL_47;
        }
      }
    }
    else
    {
      ne_log_obj();
      v17 = objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        goto LABEL_78;
      v44 = objc_msgSend(v3, "copyShortDescription");
      v47 = -[NSObject count](v8, "count");
      *(_DWORD *)buf = 138412802;
      v210 = v6;
      v211 = 2112;
      v212 = (uint64_t)v44;
      v213 = 1024;
      LODWORD(v214) = v47;
      _os_log_error_impl(&dword_19BD16000, v17, OS_LOG_TYPE_ERROR, "%@ %@ Received %u child SA proposals, require 1", buf, 0x1Cu);
    }
LABEL_77:

    goto LABEL_78;
  }
  v15 = -[NEIKEv2Packet hasNotification:](v3, (const char *)0x4007);

  if ((v15 & 1) != 0)
    goto LABEL_24;
  ne_log_obj();
  v8 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
  {
    v17 = objc_msgSend(v3, "copyShortDescription");
    *(_DWORD *)buf = 138412546;
    v210 = v6;
    v211 = 2112;
    v212 = (uint64_t)v17;
    _os_log_error_impl(&dword_19BD16000, v8, OS_LOG_TYPE_ERROR, "%@ %@ Transport mode Child SA was not accepted", buf, 0x16u);
    goto LABEL_78;
  }
LABEL_79:

LABEL_80:
  ne_log_obj();
  v84 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v84, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)v218 = 0;
    _os_log_error_impl(&dword_19BD16000, v84, OS_LOG_TYPE_ERROR, "Failed to process Create Child SA packet", v218, 2u);
  }

  objc_msgSend(a1[4], "sendCallbackSuccess:session:", 0, a1[5]);
  v26 = (uint64_t)a1[6];
  v27 = CFSTR("Failed to process Create Child SA packet");
LABEL_83:
  ErrorCrypto = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(v27, v19, v20, v21, v22, v23, v24, v25, v189);
LABEL_84:
  v86 = ErrorCrypto;
  -[NEIKEv2ChildSA setState:error:](v26, 3uLL, ErrorCrypto);

  -[NEIKEv2Session reportState](a1[5], v87);
  -[NEIKEv2Session resetChild:]((char *)a1[5], a1[6]);
LABEL_85:

}

void __47__NEIKEv2Session_Exchange__initiateNewChildSA___block_invoke_241(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *ErrorInternal;
  const char *v11;
  uint64_t v12;

  objc_msgSend(*(id *)(a1 + 32), "sendCallbackSuccess:session:", 0, *(_QWORD *)(a1 + 40));
  v2 = *(_QWORD *)(a1 + 48);
  ErrorInternal = (void *)NEIKEv2CreateErrorInternal(CFSTR("Failed to install Child SA"), v3, v4, v5, v6, v7, v8, v9, v12);
  -[NEIKEv2ChildSA setState:error:](v2, 3uLL, ErrorInternal);

  -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 40), v11);
  -[NEIKEv2Session resetChild:](*(char **)(a1 + 40), *(void **)(a1 + 48));
}

- (void)receiveNewChildSA:(void *)a3 packet:
{
  id v5;
  const char *v6;
  id v7;
  NSObject *v8;
  SEL v9;
  const char *v10;
  id v11;
  id v12;
  void *v13;
  char v14;
  const char *v15;
  _BYTE *v16;
  const char *v17;
  void *v18;
  id Property;
  NSObject *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t i;
  const __CFString *v25;
  const char *v26;
  uint64_t v27;
  id v28;
  uint64_t v29;
  const char *v30;
  void *v31;
  const char *v32;
  void *v33;
  SEL v34;
  id v35;
  void *v36;
  const char *v37;
  id v38;
  NSObject *v39;
  SEL v40;
  SEL v41;
  id v42;
  NSObject *v43;
  NSObject *v44;
  void *v45;
  SEL v46;
  id v47;
  id v48;
  SEL v49;
  void *v50;
  const char *v51;
  void *v52;
  const char *v53;
  void *v54;
  id v55;
  id WeakRetained;
  const char *v57;
  id v58;
  id v59;
  int v60;
  const char *v61;
  void *v62;
  const char *v63;
  void *v64;
  id v65;
  uint64_t v66;
  const char *v67;
  char v68;
  NSObject *v69;
  void *v70;
  NSObject *v71;
  void *v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  id v80;
  NSObject *v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  __CFString *v89;
  NSObject *v90;
  void *ErrorCrypto;
  const char *v92;
  NSObject *v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  void *v101;
  const char *v102;
  NSObject *v103;
  id v104;
  void *v105;
  const char *v106;
  void *v107;
  NSObject *v108;
  SEL v109;
  id v110;
  void *v111;
  int v112;
  const char *v113;
  id v114;
  uint64_t v115;
  unint64_t v116;
  void *v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  const char *v125;
  NSObject *v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  void *ErrorInternal;
  void *v135;
  void *v136;
  __CFString *v137;
  id v138;
  id v139;
  const char *v140;
  void *v141;
  unsigned int v142;
  void *v143;
  const char *v144;
  void *v145;
  id v146;
  SEL v147;
  const char *v148;
  const char *v149;
  void *v150;
  const char *v151;
  void *v152;
  const char *v153;
  void *v154;
  id v155;
  const char *v156;
  void *v157;
  const char *v158;
  void *v159;
  id v160;
  const char *v161;
  void *v162;
  const char *v163;
  void *v164;
  id v165;
  SEL v166;
  id v167;
  const char *v168;
  void *v169;
  uint64_t v170;
  const char *v171;
  void *v172;
  const char *v173;
  void *v174;
  id v175;
  SEL v176;
  void *v177;
  const char *v178;
  void *v179;
  id v180;
  SEL v181;
  id v182;
  void *v183;
  id v184;
  SEL v185;
  void *v186;
  const char *v187;
  void *v188;
  id v189;
  SEL v190;
  id v191;
  void *v192;
  id v193;
  id v194;
  _BYTE *v195;
  const char *v196;
  id v197;
  uint64_t v198;
  const char *v199;
  NSObject *v200;
  id v201;
  uint64_t v202;
  NEIKEv2ChildSAPayload *v203;
  SEL v204;
  SEL v205;
  id v206;
  void *v207;
  SEL v208;
  void *v209;
  const char *v210;
  void *v211;
  SEL v212;
  void *v213;
  char v214;
  const char *v215;
  NEIKEv2KeyExchangePayload *v216;
  SEL v217;
  SEL v218;
  id v219;
  const char *v220;
  void *v221;
  SEL v222;
  void *v223;
  const char *v224;
  void *v225;
  SEL v226;
  id v227;
  void *v228;
  void *v229;
  id v230;
  SEL v231;
  void *v232;
  const char *v233;
  void *v234;
  SEL v235;
  void *v236;
  char v237;
  NEIKEv2NoncePayload *v238;
  SEL v239;
  SEL v240;
  void *v241;
  SEL v242;
  void *v243;
  const char *v244;
  void *v245;
  SEL v246;
  void *v247;
  char v248;
  NEIKEv2InitiatorTrafficSelectorPayload *v249;
  SEL v250;
  const char *v251;
  void *v252;
  SEL v253;
  void *v254;
  const char *v255;
  void *v256;
  SEL v257;
  void *v258;
  char v259;
  NEIKEv2ResponderTrafficSelectorPayload *v260;
  SEL v261;
  const char *v262;
  void *v263;
  SEL v264;
  void *v265;
  const char *v266;
  void *v267;
  SEL v268;
  void *v269;
  char v270;
  NSObject *v271;
  void *v272;
  const char *v273;
  NSObject *v274;
  NSObject *v275;
  NSObject *v276;
  const char *v277;
  NSObject *v278;
  uint32_t v279;
  NSObject *v280;
  const char *v281;
  const char *v282;
  uint64_t v283;
  uint64_t v284;
  uint64_t v285;
  uint64_t v286;
  uint64_t v287;
  uint64_t v288;
  id v289;
  const char *v290;
  void *v291;
  id v292;
  const char *v293;
  const char *v294;
  NSObject *v295;
  uint64_t v296;
  uint64_t v297;
  uint64_t v298;
  uint64_t v299;
  uint64_t v300;
  uint64_t v301;
  uint64_t v302;
  void *ErrorFailedToSend;
  void *v304;
  const char *v305;
  NSObject *v306;
  SEL v307;
  id v308;
  const char *v309;
  void *v310;
  id v311;
  SEL v312;
  id v313;
  const char *v314;
  void *v315;
  id v316;
  id v317;
  void *v318;
  NSObject *v319;
  SEL v320;
  id v321;
  const char *v322;
  void *v323;
  id v324;
  SEL v325;
  id v326;
  const char *v327;
  void *v328;
  id v329;
  const char *v330;
  void *v331;
  id v332;
  id v333;
  const char *v334;
  void *v335;
  void *v336;
  SEL v337;
  void *v338;
  const char *v339;
  void *v340;
  id v341;
  SEL v342;
  id v343;
  const char *v344;
  void *v345;
  uint64_t v346;
  NSObject *v347;
  SEL v348;
  id v349;
  const char *v350;
  void *v351;
  id v352;
  SEL v353;
  id v354;
  const char *v355;
  void *v356;
  id v357;
  unint64_t v358;
  void *v359;
  id v360;
  id self;
  id v362;
  id v363;
  _QWORD v364[4];
  _BYTE *v365;
  _QWORD *v366;
  _QWORD v367[4];
  _BYTE *v368;
  _QWORD *v369;
  _QWORD v370[4];
  _BYTE *v371;
  _QWORD *v372;
  __int128 v373;
  __int128 v374;
  __int128 v375;
  __int128 v376;
  uint8_t buf[4];
  const char *v378;
  __int16 v379;
  void *v380;
  __int16 v381;
  unint64_t v382;
  __int16 v383;
  uint64_t v384;
  uint8_t v385[4];
  const char *v386;
  uint64_t v387;

  v387 = *MEMORY[0x1E0C80C00];
  v5 = a2;
  v7 = a3;
  if (a1)
  {
    v8 = objc_getProperty(a1, v6, 368, 1);
    dispatch_assert_queue_V2(v8);

    v11 = objc_getProperty(a1, v9, 336, 1);
    if (!v11)
    {
      ne_log_obj();
      v275 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v275, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)v385 = 136315138;
        v386 = "-[NEIKEv2Session(Exchange) receiveNewChildSA:packet:]";
        _os_log_fault_impl(&dword_19BD16000, v275, OS_LOG_TYPE_FAULT, "%s called with null ikeSA", v385, 0xCu);
      }

      goto LABEL_92;
    }
    if (v5)
    {
      v12 = objc_getProperty(v5, v10, 48, 1);
      objc_msgSend(v12, "proposals");
      v13 = (void *)objc_claimAutoreleasedReturnValue();
      v14 = -[NEIKEv2Session generateSPIForChild:proposals:](a1, v5, v13);

      if ((v14 & 1) != 0)
      {
        if ((-[NEIKEv2ChildSA generateInitialValues]((id *)v5) & 1) != 0)
        {
          v16 = v5;
          if ((v16[9] & 1) != 0)
          {
            ne_log_obj();
            v20 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v20, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)buf = 136315138;
              v378 = "-[NEIKEv2CreateChildPacket(Exchange) validateCreateChildAsResponder:]";
              _os_log_fault_impl(&dword_19BD16000, v20, OS_LOG_TYPE_FAULT, "%s called with null !childSA.isInitiator", buf, 0xCu);
            }
            goto LABEL_75;
          }
          if (-[NEIKEv2Packet hasErrors](v7, v15))
          {
            v375 = 0u;
            v376 = 0u;
            v373 = 0u;
            v374 = 0u;
            if (v7)
            {
              v18 = v7;
              Property = objc_getProperty(v7, v17, 64, 1);
            }
            else
            {
              v18 = 0;
              Property = 0;
            }
            v20 = Property;
            v21 = -[NSObject countByEnumeratingWithState:objects:count:](v20, "countByEnumeratingWithState:objects:count:", &v373, v385, 16);
            if (v21)
            {
              v22 = v21;
              v23 = *(_QWORD *)v374;
              while (2)
              {
                for (i = 0; i != v22; ++i)
                {
                  if (*(_QWORD *)v374 != v23)
                    objc_enumerationMutation(v20);
                  v25 = *(const __CFString **)(*((_QWORD *)&v373 + 1) + 8 * i);
                  if (v25 && (unint64_t)(v25->length - 1) <= 0x3FFE)
                  {
                    ne_log_obj();
                    v103 = objc_claimAutoreleasedReturnValue();
                    if (os_log_type_enabled(v103, OS_LOG_TYPE_ERROR))
                    {
                      v136 = (void *)objc_msgSend(v18, "copyShortDescription");
                      v137 = (__CFString *)-[NEIKEv2NotifyPayload copyError](v25);
                      *(_DWORD *)buf = 138412802;
                      v378 = v16;
                      v379 = 2112;
                      v380 = v136;
                      v381 = 2112;
                      v382 = (unint64_t)v137;
                      _os_log_error_impl(&dword_19BD16000, v103, OS_LOG_TYPE_ERROR, "%@ %@ Responder create child received notify error %@", buf, 0x20u);

                    }
                    v7 = v18;
                    goto LABEL_75;
                  }
                }
                v22 = -[NSObject countByEnumeratingWithState:objects:count:](v20, "countByEnumeratingWithState:objects:count:", &v373, v385, 16);
                if (v22)
                  continue;
                break;
              }
            }

            v7 = v18;
          }
          if (-[NEIKEv2Packet hasNotification:](v7, (const char *)0x4007))
            v27 = 1;
          else
            v27 = 2;
          v28 = objc_getProperty(v16, v26, 48, 1);
          v29 = objc_msgSend(v28, "mode");

          if (v27 != v29)
          {
            ne_log_obj();
            v20 = objc_claimAutoreleasedReturnValue();
            if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
            {
LABEL_75:

              goto LABEL_76;
            }
            v36 = (void *)objc_msgSend(v7, "copyShortDescription");
            *(_DWORD *)buf = 138412546;
            v378 = v16;
            v379 = 2112;
            v380 = v36;
            _os_log_error_impl(&dword_19BD16000, v20, OS_LOG_TYPE_ERROR, "%@ %@ Transport mode Child SA did not match", buf, 0x16u);
LABEL_74:

            goto LABEL_75;
          }
          objc_getProperty(v7, v30, 96, 1);
          v31 = (void *)objc_claimAutoreleasedReturnValue();
          v33 = v31;
          if (v31)
            v31 = objc_getProperty(v31, v32, 24, 1);
          v20 = v31;

          v35 = objc_getProperty(v16, v34, 48, 1);
          objc_msgSend(v35, "proposals");
          v36 = (void *)objc_claimAutoreleasedReturnValue();

          if (-[NSObject count](v20, "count"))
          {
            self = v7;
            v38 = objc_getProperty(v16, v37, 48, 1);
            v39 = +[NEIKEv2ChildSAProposal chooseChildSAProposalFromLocalProposals:remoteProposals:preferRemoteProposals:checkKEMethod:]((uint64_t)NEIKEv2ChildSAProposal, v36, v20, objc_msgSend(v38, "preferInitiatorProposalOrder"), 0);
            objc_setProperty_atomic(v16, v40, v39, 56);

            v42 = objc_getProperty(v16, v41, 56, 1);
            ne_log_obj();
            v43 = objc_claimAutoreleasedReturnValue();
            v44 = v43;
            if (!v42)
            {
              if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
              {
                v104 = self;
                v105 = (void *)objc_msgSend(self, "copyShortDescription");
                *(_DWORD *)buf = 138412546;
                v378 = v16;
                v379 = 2112;
                v380 = v105;
                v106 = "%@ %@ No matching proposal found";
                goto LABEL_167;
              }
LABEL_72:
              v7 = self;
              goto LABEL_73;
            }
            if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
            {
              v45 = (void *)objc_msgSend(self, "copyShortDescription");
              v47 = v11;
              v48 = objc_getProperty(v16, v46, 56, 1);
              *(_DWORD *)buf = 138412802;
              v378 = v16;
              v379 = 2112;
              v380 = v45;
              v381 = 2112;
              v382 = (unint64_t)v48;
              _os_log_impl(&dword_19BD16000, v44, OS_LOG_TYPE_DEFAULT, "%@ %@ Chose initiator new child proposal %@", buf, 0x20u);

              v11 = v47;
            }

            v7 = self;
            objc_getProperty(self, v49, 112, 1);
            v50 = (void *)objc_claimAutoreleasedReturnValue();

            if (v50)
            {
              objc_getProperty(self, v51, 112, 1);
              v52 = (void *)objc_claimAutoreleasedReturnValue();
              v54 = v52;
              if (v52)
                v52 = objc_getProperty(v52, v53, 24, 1);
              v55 = v52;

              if (v55)
              {
                WeakRetained = objc_loadWeakRetained((id *)v16 + 3);
                v360 = WeakRetained;
                v58 = v11;
                if (WeakRetained)
                  WeakRetained = objc_getProperty(WeakRetained, v57, 80, 1);
                v59 = WeakRetained;
                v60 = objc_msgSend(v59, "strictNonceSizeChecks");

                if (v60)
                {
                  objc_getProperty(self, v61, 112, 1);
                  v62 = (void *)objc_claimAutoreleasedReturnValue();
                  v64 = v62;
                  if (v62)
                    v62 = objc_getProperty(v62, v63, 24, 1);
                  v65 = v62;
                  v66 = objc_msgSend(v65, "length");

                  v358 = v66;
                  v68 = (v66 != 15) & __CFADD__(v66 - 257, 242);
                  v11 = v58;
                  if (!v68)
                  {
                    ne_log_obj();
                    v69 = objc_claimAutoreleasedReturnValue();
                    if (os_log_type_enabled(v69, OS_LOG_TYPE_ERROR))
                    {
                      v70 = (void *)objc_msgSend(self, "copyShortDescription");
                      *(_DWORD *)buf = 138412802;
                      v378 = v16;
                      v379 = 2112;
                      v380 = v70;
                      v381 = 2048;
                      v382 = v358;
                      _os_log_error_impl(&dword_19BD16000, v69, OS_LOG_TYPE_ERROR, "%@ %@ NONCE data length %zu is out of bounds", buf, 0x20u);

                    }
                    goto LABEL_165;
                  }
                  v138 = v360;
                  if (v360)
                    v138 = objc_getProperty(v360, v67, 96, 1);
                  v139 = v138;
                  -[NEIKEv2IKESAProposal prfProtocol](v139, v140);
                  v141 = (void *)objc_claimAutoreleasedReturnValue();
                  v142 = objc_msgSend(v141, "nonceSize");

                  if (v358 < v142)
                  {
                    ne_log_obj();
                    v69 = objc_claimAutoreleasedReturnValue();
                    if (os_log_type_enabled(v69, OS_LOG_TYPE_ERROR))
                    {
                      v331 = (void *)objc_msgSend(self, "copyShortDescription");
                      if (v360)
                        v332 = objc_getProperty(v360, v330, 96, 1);
                      else
                        v332 = 0;
                      v333 = v332;
                      -[NEIKEv2IKESAProposal prfProtocol](v333, v334);
                      v335 = (void *)objc_claimAutoreleasedReturnValue();
                      *(_DWORD *)buf = 138413058;
                      v378 = v16;
                      v379 = 2112;
                      v380 = v331;
                      v381 = 2048;
                      v382 = v358;
                      v383 = 2112;
                      v384 = (uint64_t)v335;
                      _os_log_error_impl(&dword_19BD16000, v69, OS_LOG_TYPE_ERROR, "%@ %@ NONCE data length %zu is shorter than the minimum for PRF protocol %@", buf, 0x2Au);

                    }
                    v11 = v58;
                    goto LABEL_165;
                  }
                }
                objc_getProperty(self, v61, 112, 1);
                v143 = (void *)objc_claimAutoreleasedReturnValue();
                v145 = v143;
                if (v143)
                  v143 = objc_getProperty(v143, v144, 24, 1);
                v146 = v143;
                objc_setProperty_atomic(v16, v147, v146, 88);

                v11 = v58;
                v359 = v36;
                if (!-[NEIKEv2ChildSA shouldGenerateNewDHKeys](v16, v148))
                {
LABEL_115:
                  objc_getProperty(self, v149, 128, 1);
                  v177 = (void *)objc_claimAutoreleasedReturnValue();
                  v363 = v11;
                  if (v177)
                  {
                    v179 = v177;
                    v177 = objc_getProperty(v177, v178, 24, 1);
                  }
                  else
                  {
                    v179 = 0;
                  }
                  v180 = v177;
                  v182 = objc_getProperty(v16, v181, 48, 1);
                  objc_msgSend(v182, "remoteTrafficSelectors");
                  v183 = (void *)objc_claimAutoreleasedReturnValue();
                  v184 = +[NEIKEv2TrafficSelector copyConstrainedTrafficSelectorsForRequest:reply:]((uint64_t)NEIKEv2TrafficSelector, (uint64_t)v180, v183);
                  -[NEIKEv2ChildSA setInitiatorTrafficSelectors:](v16, v184);

                  objc_getProperty(self, v185, 136, 1);
                  v186 = (void *)objc_claimAutoreleasedReturnValue();
                  v188 = v186;
                  if (v186)
                    v186 = objc_getProperty(v186, v187, 24, 1);
                  v189 = v186;
                  v191 = objc_getProperty(v16, v190, 48, 1);
                  objc_msgSend(v191, "localTrafficSelectors");
                  v192 = (void *)objc_claimAutoreleasedReturnValue();
                  v193 = +[NEIKEv2TrafficSelector copyConstrainedTrafficSelectorsForRequest:reply:]((uint64_t)NEIKEv2TrafficSelector, (uint64_t)v189, v192);
                  -[NEIKEv2ChildSA setResponderTrafficSelectors:](v16, v193);

                  v7 = self;
                  v194 = self;
                  v195 = v16;
                  objc_opt_self();
                  if ((v16[9] & 1) != 0)
                  {
                    ne_log_obj();
                    v200 = objc_claimAutoreleasedReturnValue();
                    if (os_log_type_enabled(v200, OS_LOG_TYPE_FAULT))
                    {
                      *(_DWORD *)v385 = 136315138;
                      v386 = "+[NEIKEv2CreateChildPacket(Exchange) createChildSAResponse:childSA:]";
                      _os_log_fault_impl(&dword_19BD16000, v200, OS_LOG_TYPE_FAULT, "%s called with null !childSA.isInitiator", v385, 0xCu);
                    }
                    v271 = 0;
                    v11 = v363;
                    goto LABEL_179;
                  }
                  v197 = objc_getProperty(v195, v196, 56, 1);

                  v11 = v363;
                  if (v197)
                  {
                    v198 = -[NEIKEv2Packet initResponse:]((uint64_t)[NEIKEv2CreateChildPacket alloc], v194);
                    if (v198)
                    {
                      v200 = v198;
                      v201 = objc_getProperty(v195, v199, 48, 1);
                      v202 = objc_msgSend(v201, "mode");

                      if (v202 != 1 || -[NEIKEv2Packet addNotification:data:](v200, 0x4007uLL, 0))
                      {
                        v203 = objc_alloc_init(NEIKEv2ChildSAPayload);
                        objc_setProperty_atomic(v200, v204, v203, 96);

                        v206 = objc_getProperty(v195, v205, 48, 1);
                        objc_msgSend(v206, "proposals");
                        v207 = (void *)objc_claimAutoreleasedReturnValue();
                        objc_getProperty(v200, v208, 96, 1);
                        v209 = (void *)objc_claimAutoreleasedReturnValue();
                        v211 = v209;
                        if (v209)
                          objc_setProperty_atomic(v209, v210, v207, 24);

                        objc_getProperty(v200, v212, 96, 1);
                        v213 = (void *)objc_claimAutoreleasedReturnValue();
                        v214 = -[NEIKEv2Payload isValid]((uint64_t)v213);

                        if ((v214 & 1) != 0)
                        {
                          if (-[NEIKEv2ChildSA shouldGenerateNewDHKeys](v195, v215))
                          {
                            v216 = objc_alloc_init(NEIKEv2KeyExchangePayload);
                            objc_setProperty_atomic(v200, v217, v216, 104);

                            v219 = objc_getProperty(v195, v218, 56, 1);
                            -[NEIKEv2IKESAProposal kemProtocol](v219, v220);
                            v221 = (void *)objc_claimAutoreleasedReturnValue();
                            objc_getProperty(v200, v222, 104, 1);
                            v223 = (void *)objc_claimAutoreleasedReturnValue();
                            v225 = v223;
                            if (v223)
                              objc_setProperty_atomic(v223, v224, v221, 24);

                            v227 = objc_getProperty(v195, v226, 112, 1);
                            v228 = v227;
                            if (v227)
                              v229 = (void *)*((_QWORD *)v227 + 2);
                            else
                              v229 = 0;
                            v230 = v229;
                            objc_getProperty(v200, v231, 104, 1);
                            v232 = (void *)objc_claimAutoreleasedReturnValue();
                            v234 = v232;
                            if (v232)
                              objc_setProperty_atomic(v232, v233, v230, 32);

                            objc_getProperty(v200, v235, 104, 1);
                            v236 = (void *)objc_claimAutoreleasedReturnValue();
                            v237 = -[NEIKEv2Payload isValid]((uint64_t)v236);

                            if ((v237 & 1) == 0)
                            {
                              ne_log_obj();
                              v280 = objc_claimAutoreleasedReturnValue();
                              if (!os_log_type_enabled(v280, OS_LOG_TYPE_FAULT))
                                goto LABEL_216;
                              *(_DWORD *)v385 = 136315138;
                              v386 = "+[NEIKEv2CreateChildPacket(Exchange) createChildSAResponse:childSA:]";
                              v281 = "%s called with null packet.ke.isValid";
                              goto LABEL_222;
                            }
                          }
                          v238 = objc_alloc_init(NEIKEv2NoncePayload);
                          objc_setProperty_atomic(v200, v239, v238, 112);

                          objc_getProperty(v195, v240, 80, 1);
                          v241 = (void *)objc_claimAutoreleasedReturnValue();
                          objc_getProperty(v200, v242, 112, 1);
                          v243 = (void *)objc_claimAutoreleasedReturnValue();
                          v245 = v243;
                          v11 = v363;
                          if (v243)
                            objc_setProperty_atomic(v243, v244, v241, 24);

                          objc_getProperty(v200, v246, 112, 1);
                          v247 = (void *)objc_claimAutoreleasedReturnValue();
                          v248 = -[NEIKEv2Payload isValid]((uint64_t)v247);

                          if ((v248 & 1) != 0)
                          {
                            v249 = objc_alloc_init(NEIKEv2InitiatorTrafficSelectorPayload);
                            objc_setProperty_atomic(v200, v250, v249, 128);

                            -[NEIKEv2ChildSA initiatorTrafficSelectors](v195, v251);
                            v252 = (void *)objc_claimAutoreleasedReturnValue();
                            objc_getProperty(v200, v253, 128, 1);
                            v254 = (void *)objc_claimAutoreleasedReturnValue();
                            v256 = v254;
                            if (v254)
                              objc_setProperty_atomic(v254, v255, v252, 24);

                            objc_getProperty(v200, v257, 128, 1);
                            v258 = (void *)objc_claimAutoreleasedReturnValue();
                            v259 = -[NEIKEv2Payload isValid]((uint64_t)v258);

                            if ((v259 & 1) != 0)
                            {
                              v260 = objc_alloc_init(NEIKEv2ResponderTrafficSelectorPayload);
                              objc_setProperty_atomic(v200, v261, v260, 136);

                              -[NEIKEv2ChildSA responderTrafficSelectors](v195, v262);
                              v263 = (void *)objc_claimAutoreleasedReturnValue();
                              objc_getProperty(v200, v264, 136, 1);
                              v265 = (void *)objc_claimAutoreleasedReturnValue();
                              v267 = v265;
                              if (v265)
                                objc_setProperty_atomic(v265, v266, v263, 24);

                              objc_getProperty(v200, v268, 136, 1);
                              v269 = (void *)objc_claimAutoreleasedReturnValue();
                              v270 = -[NEIKEv2Payload isValid]((uint64_t)v269);

                              if ((v270 & 1) != 0)
                              {
                                v200 = v200;
                                v271 = v200;
LABEL_217:
                                v11 = v363;
                                goto LABEL_179;
                              }
                              ne_log_obj();
                              v280 = objc_claimAutoreleasedReturnValue();
                              if (!os_log_type_enabled(v280, OS_LOG_TYPE_FAULT))
                              {
LABEL_216:

                                v271 = 0;
                                goto LABEL_217;
                              }
                              *(_DWORD *)v385 = 136315138;
                              v386 = "+[NEIKEv2CreateChildPacket(Exchange) createChildSAResponse:childSA:]";
                              v281 = "%s called with null packet.tsr.isValid";
LABEL_222:
                              _os_log_fault_impl(&dword_19BD16000, v280, OS_LOG_TYPE_FAULT, v281, v385, 0xCu);
                              goto LABEL_216;
                            }
                            ne_log_obj();
                            v276 = objc_claimAutoreleasedReturnValue();
                            if (os_log_type_enabled(v276, OS_LOG_TYPE_FAULT))
                            {
                              *(_DWORD *)v385 = 136315138;
                              v386 = "+[NEIKEv2CreateChildPacket(Exchange) createChildSAResponse:childSA:]";
                              v277 = "%s called with null packet.tsi.isValid";
                              goto LABEL_176;
                            }
LABEL_178:

                            v271 = 0;
LABEL_179:
                            v7 = self;
LABEL_180:

                            if (v271)
                            {
                              if ((-[NEIKEv2Session sendReply:replyHandler:]((uint64_t)a1, v271, 0) & 1) != 0)
                              {
                                v289 = objc_getProperty(v195, v282, 56, 1);
                                v291 = v289;
                                if (v289)
                                  v289 = objc_getProperty(v289, v290, 112, 1);
                                v292 = v289;

                                if (v292 && (-[NEIKEv2ChildSA processPrimaryKeyExchange]((uint64_t)v195, v293) & 1) == 0)
                                {
                                  v316 = v11;
                                  ne_log_obj();
                                  v347 = objc_claimAutoreleasedReturnValue();
                                  if (os_log_type_enabled(v347, OS_LOG_TYPE_ERROR))
                                  {
                                    *(_WORD *)v385 = 0;
                                    _os_log_error_impl(&dword_19BD16000, v347, OS_LOG_TYPE_ERROR, "Failed to process KE data", v385, 2u);
                                  }

                                  v349 = objc_getProperty(v195, v348, 56, 1);
                                  v351 = v349;
                                  if (v349)
                                    v349 = objc_getProperty(v349, v350, 80, 1);
                                  v352 = v349;
                                  v354 = objc_getProperty(v195, v353, 56, 1);
                                  v356 = v354;
                                  if (v354)
                                    v354 = objc_getProperty(v354, v355, 88, 1);
                                  v357 = v354;
                                  v370[0] = MEMORY[0x1E0C809B0];
                                  v370[1] = 3221225472;
                                  v370[2] = __53__NEIKEv2Session_Exchange__receiveNewChildSA_packet___block_invoke;
                                  v370[3] = &unk_1E3CC0EB0;
                                  v371 = v195;
                                  v372 = a1;
                                  -[NEIKEv2Session initiateDeleteChildSPI:remoteSPI:deleteCompletionCallback:](a1, v352, v357, v370);

                                  v318 = v371;
                                }
                                else if ((-[NEIKEv2ChildSA generateAllValues]((uint64_t)v195) & 1) != 0)
                                {
                                  if ((-[NEIKEv2Session installChildSA:]((uint64_t)a1, v195) & 1) != 0)
                                  {
                                    -[NEIKEv2ChildSA setState:error:]((uint64_t)v195, 2uLL, 0);
                                    -[NEIKEv2Session reportState](a1, v294);
LABEL_209:

                                    goto LABEL_92;
                                  }
                                  ne_log_obj();
                                  v319 = objc_claimAutoreleasedReturnValue();
                                  if (os_log_type_enabled(v319, OS_LOG_TYPE_ERROR))
                                  {
                                    *(_WORD *)v385 = 0;
                                    _os_log_error_impl(&dword_19BD16000, v319, OS_LOG_TYPE_ERROR, "Failed to install Child SA", v385, 2u);
                                  }

                                  v321 = objc_getProperty(v195, v320, 56, 1);
                                  v323 = v321;
                                  if (v321)
                                    v321 = objc_getProperty(v321, v322, 80, 1);
                                  v324 = v321;
                                  v326 = objc_getProperty(v195, v325, 56, 1);
                                  v328 = v326;
                                  v316 = v11;
                                  if (v326)
                                    v326 = objc_getProperty(v326, v327, 88, 1);
                                  v329 = v326;
                                  v364[0] = MEMORY[0x1E0C809B0];
                                  v364[1] = 3221225472;
                                  v364[2] = __53__NEIKEv2Session_Exchange__receiveNewChildSA_packet___block_invoke_253;
                                  v364[3] = &unk_1E3CC0EB0;
                                  v365 = v195;
                                  v366 = a1;
                                  -[NEIKEv2Session initiateDeleteChildSPI:remoteSPI:deleteCompletionCallback:](a1, v324, v329, v364);

                                  v318 = v365;
                                }
                                else
                                {
                                  ne_log_obj();
                                  v306 = objc_claimAutoreleasedReturnValue();
                                  if (os_log_type_enabled(v306, OS_LOG_TYPE_ERROR))
                                  {
                                    *(_WORD *)v385 = 0;
                                    _os_log_error_impl(&dword_19BD16000, v306, OS_LOG_TYPE_ERROR, "Failed to generate Child SA crypto values", v385, 2u);
                                  }

                                  v308 = objc_getProperty(v195, v307, 56, 1);
                                  v310 = v308;
                                  if (v308)
                                    v308 = objc_getProperty(v308, v309, 80, 1);
                                  v311 = v308;
                                  v313 = objc_getProperty(v195, v312, 56, 1);
                                  v315 = v313;
                                  v316 = v11;
                                  if (v313)
                                    v313 = objc_getProperty(v313, v314, 88, 1);
                                  v317 = v313;
                                  v367[0] = MEMORY[0x1E0C809B0];
                                  v367[1] = 3221225472;
                                  v367[2] = __53__NEIKEv2Session_Exchange__receiveNewChildSA_packet___block_invoke_252;
                                  v367[3] = &unk_1E3CC0EB0;
                                  v368 = v195;
                                  v369 = a1;
                                  -[NEIKEv2Session initiateDeleteChildSPI:remoteSPI:deleteCompletionCallback:](a1, v311, v317, v367);

                                  v318 = v368;
                                }

                                v11 = v316;
                                v7 = self;
                                goto LABEL_209;
                              }
                              ErrorFailedToSend = (void *)NEIKEv2CreateErrorFailedToSend(CFSTR("create child SA reply"), (uint64_t)v282, v283, v284, v285, v286, v287, v288, v358);
                            }
                            else
                            {
                              ne_log_obj();
                              v295 = objc_claimAutoreleasedReturnValue();
                              if (os_log_type_enabled(v295, OS_LOG_TYPE_ERROR))
                              {
                                *(_WORD *)v385 = 0;
                                _os_log_error_impl(&dword_19BD16000, v295, OS_LOG_TYPE_ERROR, "Failed to create Create Child SA packet", v385, 2u);
                              }

                              ErrorFailedToSend = (void *)NEIKEv2CreateErrorInternal(CFSTR("Failed to create Create Child SA packet"), v296, v297, v298, v299, v300, v301, v302, v358);
                            }
                            v304 = ErrorFailedToSend;
                            -[NEIKEv2ChildSA setState:error:]((uint64_t)v195, 3uLL, ErrorFailedToSend);

                            -[NEIKEv2Session reportState](a1, v305);
                            -[NEIKEv2Session resetChild:]((char *)a1, v195);
                            goto LABEL_209;
                          }
                          ne_log_obj();
                          v276 = objc_claimAutoreleasedReturnValue();
                          if (!os_log_type_enabled(v276, OS_LOG_TYPE_FAULT))
                            goto LABEL_178;
                          *(_DWORD *)v385 = 136315138;
                          v386 = "+[NEIKEv2CreateChildPacket(Exchange) createChildSAResponse:childSA:]";
                          v277 = "%s called with null packet.nonce.isValid";
                        }
                        else
                        {
                          ne_log_obj();
                          v276 = objc_claimAutoreleasedReturnValue();
                          v11 = v363;
                          if (!os_log_type_enabled(v276, OS_LOG_TYPE_FAULT))
                            goto LABEL_178;
                          *(_DWORD *)v385 = 136315138;
                          v386 = "+[NEIKEv2CreateChildPacket(Exchange) createChildSAResponse:childSA:]";
                          v277 = "%s called with null packet.childSA.isValid";
                        }
LABEL_176:
                        v278 = v276;
                        v279 = 12;
                        goto LABEL_177;
                      }
                      ne_log_obj();
                      v276 = objc_claimAutoreleasedReturnValue();
                      if (os_log_type_enabled(v276, OS_LOG_TYPE_FAULT))
                      {
                        *(_WORD *)v385 = 0;
                        v277 = "[packet addNotification:NEIKEv2NotifyTypeUseTransportMode] failed";
                        v278 = v276;
                        v279 = 2;
LABEL_177:
                        _os_log_fault_impl(&dword_19BD16000, v278, OS_LOG_TYPE_FAULT, v277, v385, v279);
                        goto LABEL_178;
                      }
                      goto LABEL_178;
                    }
                    ne_log_obj();
                    v274 = objc_claimAutoreleasedReturnValue();
                    if (os_log_type_enabled(v274, OS_LOG_TYPE_FAULT))
                    {
                      *(_WORD *)v385 = 0;
                      _os_log_fault_impl(&dword_19BD16000, v274, OS_LOG_TYPE_FAULT, "[[NEIKEv2CreateChildPacket alloc] initResponse:] failed", v385, 2u);
                    }

                    v200 = 0;
                  }
                  else
                  {
                    ne_log_obj();
                    v200 = objc_claimAutoreleasedReturnValue();
                    if (os_log_type_enabled(v200, OS_LOG_TYPE_FAULT))
                    {
                      *(_DWORD *)v385 = 136315138;
                      v386 = "+[NEIKEv2CreateChildPacket(Exchange) createChildSAResponse:childSA:]";
                      _os_log_fault_impl(&dword_19BD16000, v200, OS_LOG_TYPE_FAULT, "%s called with null childSA.chosenProposal", v385, 0xCu);
                    }
                  }
                  v271 = 0;
                  goto LABEL_180;
                }
                objc_getProperty(self, v149, 104, 1);
                v150 = (void *)objc_claimAutoreleasedReturnValue();

                if (v150)
                {
                  objc_getProperty(self, v151, 104, 1);
                  v152 = (void *)objc_claimAutoreleasedReturnValue();
                  v154 = v152;
                  if (v152)
                    v152 = objc_getProperty(v152, v153, 24, 1);
                  v155 = v152;

                  if (v155)
                  {
                    objc_getProperty(self, v156, 104, 1);
                    v157 = (void *)objc_claimAutoreleasedReturnValue();
                    v159 = v157;
                    if (v157)
                      v157 = objc_getProperty(v157, v158, 32, 1);
                    v160 = v157;

                    if (v160)
                    {
                      objc_getProperty(self, v161, 104, 1);
                      v162 = (void *)objc_claimAutoreleasedReturnValue();
                      v164 = v162;
                      v362 = v11;
                      if (v162)
                        v162 = objc_getProperty(v162, v163, 24, 1);
                      v165 = v162;
                      v358 = objc_msgSend(v165, "method");
                      v167 = objc_getProperty(v16, v166, 56, 1);
                      -[NEIKEv2IKESAProposal kemProtocol](v167, v168);
                      v169 = (void *)objc_claimAutoreleasedReturnValue();
                      v170 = objc_msgSend(v169, "method");

                      if (v358 == v170)
                      {
                        objc_getProperty(self, v171, 104, 1);
                        v172 = (void *)objc_claimAutoreleasedReturnValue();
                        v174 = v172;
                        v11 = v362;
                        if (v172)
                          v172 = objc_getProperty(v172, v173, 32, 1);
                        v175 = v172;
                        objc_setProperty_atomic(v16, v176, v175, 104);

                        goto LABEL_115;
                      }
                      ne_log_obj();
                      v69 = objc_claimAutoreleasedReturnValue();
                      v11 = v362;
                      if (os_log_type_enabled(v69, OS_LOG_TYPE_ERROR))
                      {
                        v336 = (void *)objc_msgSend(self, "copyShortDescription");
                        objc_getProperty(self, v337, 104, 1);
                        v338 = (void *)objc_claimAutoreleasedReturnValue();
                        v340 = v338;
                        if (v338)
                          v338 = objc_getProperty(v338, v339, 24, 1);
                        v341 = v338;
                        v358 = objc_msgSend(v341, "method");
                        v343 = objc_getProperty(v16, v342, 56, 1);
                        -[NEIKEv2IKESAProposal kemProtocol](v343, v344);
                        v345 = (void *)objc_claimAutoreleasedReturnValue();
                        v346 = objc_msgSend(v345, "method");
                        *(_DWORD *)buf = 138413058;
                        v378 = v16;
                        v379 = 2112;
                        v380 = v336;
                        v381 = 2048;
                        v382 = v358;
                        v383 = 2048;
                        v384 = v346;
                        _os_log_error_impl(&dword_19BD16000, v69, OS_LOG_TYPE_ERROR, "%@ %@ Did not receive matching method from KE payload (%zu != %zu)", buf, 0x2Au);

                        v11 = v362;
                      }
LABEL_164:
                      v36 = v359;
LABEL_165:

                      v7 = self;
LABEL_76:
                      ne_log_obj();
                      v108 = objc_claimAutoreleasedReturnValue();
                      if (os_log_type_enabled(v108, OS_LOG_TYPE_ERROR))
                      {
                        *(_WORD *)v385 = 0;
                        _os_log_error_impl(&dword_19BD16000, v108, OS_LOG_TYPE_ERROR, "Failed to process Create Child SA", v385, 2u);
                      }

                      v110 = objc_getProperty(v16, v109, 40, 1);
                      objc_msgSend(v110, "domain");
                      v111 = (void *)objc_claimAutoreleasedReturnValue();
                      v112 = objc_msgSend(v111, "isEqual:", CFSTR("NEIKEv2ErrorDomain"));

                      if (v112)
                      {
                        v114 = objc_getProperty(v16, v113, 40, 1);
                        v115 = objc_msgSend(v114, "code");

                        if (v115 == 8)
                          v116 = 24;
                        else
                          v116 = 7;
                      }
                      else
                      {
                        v116 = 7;
                      }
                      +[NEIKEv2CreateChildPacket createChildSAResponse:errorCode:errorData:]((uint64_t)NEIKEv2CreateChildPacket, v7, v116, 0);
                      v117 = (void *)objc_claimAutoreleasedReturnValue();
                      if (v117)
                      {
                        if ((-[NEIKEv2Session sendReply:replyHandler:]((uint64_t)a1, v117, 0) & 1) != 0)
                        {
                          -[NEIKEv2ChildSA setState:error:]((uint64_t)v16, 3uLL, 0);
LABEL_91:
                          -[NEIKEv2Session reportState](a1, v125);
                          -[NEIKEv2Session resetChild:]((char *)a1, v16);

                          goto LABEL_92;
                        }
                        ErrorInternal = (void *)NEIKEv2CreateErrorFailedToSend(CFSTR("create child SA refusal (failed to create response packet)"), v118, v119, v120, v121, v122, v123, v124, v358);
                      }
                      else
                      {
                        ne_log_obj();
                        v126 = objc_claimAutoreleasedReturnValue();
                        if (os_log_type_enabled(v126, OS_LOG_TYPE_ERROR))
                        {
                          *(_WORD *)v385 = 0;
                          _os_log_error_impl(&dword_19BD16000, v126, OS_LOG_TYPE_ERROR, "Failed to create Create Child SA packet", v385, 2u);
                        }

                        ErrorInternal = (void *)NEIKEv2CreateErrorInternal(CFSTR("Failed to create Create Child SA packet"), v127, v128, v129, v130, v131, v132, v133, v358);
                      }
                      v135 = ErrorInternal;
                      -[NEIKEv2ChildSA setState:error:]((uint64_t)v16, 3uLL, ErrorInternal);

                      goto LABEL_91;
                    }
                    ne_log_obj();
                    v69 = objc_claimAutoreleasedReturnValue();
                    if (!os_log_type_enabled(v69, OS_LOG_TYPE_ERROR))
                      goto LABEL_164;
                    v272 = (void *)objc_msgSend(self, "copyShortDescription");
                    *(_DWORD *)buf = 138412546;
                    v378 = v16;
                    v379 = 2112;
                    v380 = v272;
                    v273 = "%@ %@ Did not receive KE data";
                  }
                  else
                  {
                    ne_log_obj();
                    v69 = objc_claimAutoreleasedReturnValue();
                    if (!os_log_type_enabled(v69, OS_LOG_TYPE_ERROR))
                      goto LABEL_164;
                    v272 = (void *)objc_msgSend(self, "copyShortDescription");
                    *(_DWORD *)buf = 138412546;
                    v378 = v16;
                    v379 = 2112;
                    v380 = v272;
                    v273 = "%@ %@ Did not receive method in KE payload";
                  }
                }
                else
                {
                  ne_log_obj();
                  v69 = objc_claimAutoreleasedReturnValue();
                  if (!os_log_type_enabled(v69, OS_LOG_TYPE_ERROR))
                    goto LABEL_164;
                  v272 = (void *)objc_msgSend(self, "copyShortDescription");
                  *(_DWORD *)buf = 138412546;
                  v378 = v16;
                  v379 = 2112;
                  v380 = v272;
                  v273 = "%@ %@ Did not receive KE payload";
                }
                _os_log_error_impl(&dword_19BD16000, v69, OS_LOG_TYPE_ERROR, v273, buf, 0x16u);

                goto LABEL_164;
              }
              ne_log_obj();
              v44 = objc_claimAutoreleasedReturnValue();
              if (!os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
                goto LABEL_72;
              v104 = self;
              v105 = (void *)objc_msgSend(self, "copyShortDescription");
              *(_DWORD *)buf = 138412546;
              v378 = v16;
              v379 = 2112;
              v380 = v105;
              v106 = "%@ %@ Did not receive NONCE data";
LABEL_167:
              _os_log_error_impl(&dword_19BD16000, v44, OS_LOG_TYPE_ERROR, v106, buf, 0x16u);

              v7 = v104;
              goto LABEL_73;
            }
            ne_log_obj();
            v44 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
            {
              v107 = (void *)objc_msgSend(self, "copyShortDescription");
              *(_DWORD *)buf = 138412546;
              v378 = v16;
              v379 = 2112;
              v380 = v107;
              _os_log_error_impl(&dword_19BD16000, v44, OS_LOG_TYPE_ERROR, "%@ %@ Did not receive NONCE payload", buf, 0x16u);

              goto LABEL_72;
            }
          }
          else
          {
            ne_log_obj();
            v44 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
            {
              v104 = v7;
              v105 = (void *)objc_msgSend(v7, "copyShortDescription");
              *(_DWORD *)buf = 138412546;
              v378 = v16;
              v379 = 2112;
              v380 = v105;
              v106 = "%@ %@ Received no SA proposals";
              goto LABEL_167;
            }
          }
LABEL_73:

          goto LABEL_74;
        }
        ne_log_obj();
        v90 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v90, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)v385 = 0;
          _os_log_error_impl(&dword_19BD16000, v90, OS_LOG_TYPE_ERROR, "Failed to generate local Child crypto values", v385, 2u);
        }

        v89 = CFSTR("Failed to generate local Child crypto values");
      }
      else
      {
        ne_log_obj();
        v81 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v81, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)v385 = 0;
          _os_log_error_impl(&dword_19BD16000, v81, OS_LOG_TYPE_ERROR, "Failed to generate Child SA SPI", v385, 2u);
        }

        v89 = CFSTR("Failed to generate Child SA SPI");
      }
      ErrorCrypto = (void *)NEIKEv2CreateErrorCrypto(v89, v82, v83, v84, v85, v86, v87, v88, v358);
      -[NEIKEv2ChildSA setState:error:]((uint64_t)v5, 3uLL, ErrorCrypto);

      -[NEIKEv2Session reportState](a1, v92);
      -[NEIKEv2Session resetChild:]((char *)a1, v5);
LABEL_92:

      goto LABEL_93;
    }
    ne_log_obj();
    v71 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v71, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)v385 = 0;
      _os_log_debug_impl(&dword_19BD16000, v71, OS_LOG_TYPE_DEBUG, "No eligible configuration for new Child SAs", v385, 2u);
    }

    +[NEIKEv2CreateChildPacket createChildSAResponse:errorCode:errorData:]((uint64_t)NEIKEv2CreateChildPacket, v7, 0x23uLL, 0);
    v72 = (void *)objc_claimAutoreleasedReturnValue();
    if (v72)
    {
      if ((-[NEIKEv2Session sendReply:replyHandler:]((uint64_t)a1, v72, 0) & 1) != 0)
      {
        v80 = 0;
LABEL_59:

        -[NEIKEv2Session reportState](a1, v102);
        -[NEIKEv2Session resetChild:]((char *)a1, 0);

        goto LABEL_92;
      }
      v101 = (void *)NEIKEv2CreateErrorFailedToSend(CFSTR("create child SA refusal (no eligible configuration)"), v73, v74, v75, v76, v77, v78, v79, v358);
    }
    else
    {
      ne_log_obj();
      v93 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v93, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)v385 = 0;
        _os_log_error_impl(&dword_19BD16000, v93, OS_LOG_TYPE_ERROR, "Failed to create Create Child SA packet", v385, 2u);
      }

      v101 = (void *)NEIKEv2CreateErrorInternal(CFSTR("Failed to create Create Child SA packet"), v94, v95, v96, v97, v98, v99, v100, v358);
    }
    v80 = v101;

    goto LABEL_59;
  }
LABEL_93:

}

void __53__NEIKEv2Session_Exchange__receiveNewChildSA_packet___block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  void *ErrorCrypto;
  const char *v11;
  uint64_t v12;

  v9 = *(_QWORD *)(a1 + 32);
  ErrorCrypto = (void *)NEIKEv2CreateErrorCrypto(CFSTR("Failed to process KE data"), a2, a3, a4, a5, a6, a7, a8, v12);
  -[NEIKEv2ChildSA setState:error:](v9, 3uLL, ErrorCrypto);

  -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 40), v11);
  -[NEIKEv2Session resetChild:](*(char **)(a1 + 40), *(void **)(a1 + 32));
}

void __53__NEIKEv2Session_Exchange__receiveNewChildSA_packet___block_invoke_252(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  void *ErrorCrypto;
  const char *v11;
  uint64_t v12;

  v9 = *(_QWORD *)(a1 + 32);
  ErrorCrypto = (void *)NEIKEv2CreateErrorCrypto(CFSTR("Failed to generate Child SA crypto values"), a2, a3, a4, a5, a6, a7, a8, v12);
  -[NEIKEv2ChildSA setState:error:](v9, 3uLL, ErrorCrypto);

  -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 40), v11);
  -[NEIKEv2Session resetChild:](*(char **)(a1 + 40), *(void **)(a1 + 32));
}

void __53__NEIKEv2Session_Exchange__receiveNewChildSA_packet___block_invoke_253(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  void *ErrorInternal;
  const char *v11;
  uint64_t v12;

  v9 = *(_QWORD *)(a1 + 32);
  ErrorInternal = (void *)NEIKEv2CreateErrorInternal(CFSTR("Failed to install Child SA"), a2, a3, a4, a5, a6, a7, a8, v12);
  -[NEIKEv2ChildSA setState:error:](v9, 3uLL, ErrorInternal);

  -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 40), v11);
  -[NEIKEv2Session resetChild:](*(char **)(a1 + 40), *(void **)(a1 + 32));
}

void __69__NEIKEv2Session_Exchange__retryKEForRekeyChildSA_validated_handler___block_invoke(uint64_t a1, void *a2)
{
  id v3;
  void (*v4)(void);
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *ErrorPeerInvalidSyntax;
  const char *v15;
  NSObject *v16;
  uint64_t v17;
  uint64_t v18;
  _BYTE v19[24];
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    if ((-[NEIKEv2CreateChildPacket validateRekeyResponseChildSA:]((uint64_t)v3, *(void **)(a1 + 48)) & 1) != 0)
    {
      v4 = *(void (**)(void))(*(_QWORD *)(a1 + 56) + 16);
    }
    else
    {
      ne_log_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        v18 = *(_QWORD *)(a1 + 32);
        *(_DWORD *)v19 = 138412290;
        *(_QWORD *)&v19[4] = v18;
        _os_log_error_impl(&dword_19BD16000, v16, OS_LOG_TYPE_ERROR, "%@ Failed to process Create Child SA packet (child rekey retry KE)", v19, 0xCu);
      }

      v4 = *(void (**)(void))(*(_QWORD *)(a1 + 56) + 16);
    }
    v4();
  }
  else
  {
    ne_log_obj();
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v17 = *(_QWORD *)(a1 + 32);
      *(_DWORD *)v19 = 138412290;
      *(_QWORD *)&v19[4] = v17;
      _os_log_error_impl(&dword_19BD16000, v5, OS_LOG_TYPE_ERROR, "%@ Failed to receive Create Child SA packet (child rekey retry KE)", v19, 0xCu);
    }

    objc_msgSend(*(id *)(a1 + 40), "sendCallbackSuccess:session:", 0, *(_QWORD *)(a1 + 32));
    v6 = *(_QWORD *)(a1 + 48);
    ErrorPeerInvalidSyntax = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("Failed to receive Create Child SA packet (child rekey retry KE)"), v7, v8, v9, v10, v11, v12, v13, *(uint64_t *)v19);
    -[NEIKEv2ChildSA setState:error:](v6, 3uLL, ErrorPeerInvalidSyntax);

    -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 32), v15);
    -[NEIKEv2Session resetChild:](*(char **)(a1 + 32), *(void **)(a1 + 48));
  }

}

- (void)handleFollowupKEForRekeyChildSAInitiator:(unint64_t)a3 iteration:(void *)a4 handler:
{
  unsigned int *v7;
  const char *v8;
  void (**v9)(_QWORD);
  NSObject *v10;
  const char *v11;
  _DWORD *v12;
  const char *v13;
  void *v14;
  id Property;
  const char *v16;
  void *v17;
  id v18;
  unint64_t v19;
  const char *v20;
  const char *v21;
  id v22;
  id v23;
  const char *v24;
  void *v25;
  id v26;
  const char *v27;
  void *v28;
  id v29;
  const char *v30;
  void *v31;
  id v32;
  void *v33;
  const char *v34;
  id v35;
  id v36;
  void *v37;
  void *v38;
  NSObject *v39;
  NEIKEv2KeyExchangePayload *v40;
  const char *v41;
  NEIKEv2KeyExchangePayload *v42;
  SEL v43;
  id v44;
  const char *v45;
  void *v46;
  const char *v47;
  id v48;
  void *v49;
  void *v50;
  const char *v51;
  id v52;
  id v53;
  const char *v54;
  void *v55;
  const char *v56;
  id v57;
  id v58;
  const char *v59;
  void *v60;
  SEL v61;
  id v62;
  id v63;
  char v64;
  unsigned int *v65;
  SEL v66;
  id v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  void *ErrorFailedToSend;
  const char *v76;
  const char *v77;
  NSObject *v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  void *ErrorInternal;
  const char *v87;
  NSObject *v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  void *v96;
  NSObject *v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  void *v105;
  const char *v106;
  uint64_t v107;
  void *v108;
  _QWORD v109[5];
  unsigned int *v110;
  id v111;
  id v112;
  void (**v113)(_QWORD);
  unint64_t v114;
  uint8_t buf[4];
  _QWORD *v116;
  __int16 v117;
  void *v118;
  uint64_t v119;

  v119 = *MEMORY[0x1E0C80C00];
  v7 = a2;
  v9 = a4;
  if (a1)
  {
    v10 = objc_getProperty(a1, v8, 368, 1);
    dispatch_assert_queue_V2(v10);

    if (v7)
      v11 = (const char *)v7[6];
    else
      v11 = 0;
    v12 = -[NEIKEv2Session copyChildWithID:](a1, v11);
    v14 = v12;
    if (v12)
    {
      Property = objc_getProperty(v12, v13, 56, 1);
      v17 = Property;
      if (Property)
        Property = objc_getProperty(Property, v16, 120, 1);
    }
    else
    {
      v17 = 0;
      Property = 0;
    }
    v18 = Property;
    v19 = objc_msgSend(v18, "count");

    if (v19 <= a3)
    {
      if (v14)
        objc_setProperty_atomic(v14, v20, 0, 128);
      v9[2](v9);
      goto LABEL_47;
    }
    if (!a3)
    {
      v22 = objc_alloc(MEMORY[0x1E0C99DE8]);
      if (v14)
      {
        v23 = objc_getProperty(v14, v21, 56, 1);
        v25 = v23;
        if (v23)
          v23 = objc_getProperty(v23, v24, 120, 1);
      }
      else
      {
        v25 = 0;
        v23 = 0;
      }
      v26 = v23;
      v28 = (void *)objc_msgSend(v22, "initWithCapacity:", objc_msgSend(v26, "count"));
      if (v14)
        objc_setProperty_atomic(v14, v27, v28, 136);

    }
    if (v14)
    {
      v29 = objc_getProperty(v14, v20, 56, 1);
      v31 = v29;
      if (v29)
        v29 = objc_getProperty(v29, v30, 120, 1);
    }
    else
    {
      v31 = 0;
      v29 = 0;
    }
    v32 = v29;
    objc_msgSend(v32, "objectAtIndexedSubscript:", a3);
    v33 = (void *)objc_claimAutoreleasedReturnValue();

    if (v14)
      v35 = objc_getProperty(v14, v34, 56, 1);
    else
      v35 = 0;
    v36 = v35;
    -[NEIKEv2IKESAProposal chosenAdditionalKEMProtocols](v36);
    v37 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v37, "objectForKeyedSubscript:", v33);
    v38 = (void *)objc_claimAutoreleasedReturnValue();

    if (v38)
    {
      if ((-[NEIKEv2ChildSA generateLocalValuesForKEMProtocol:](v14, v38) & 1) != 0)
      {
        v108 = v33;
        v39 = -[NEIKEv2Packet initOutbound]([NEIKEv2FollowupKEPacket alloc]);
        v40 = objc_alloc_init(NEIKEv2KeyExchangePayload);
        v42 = v40;
        if (v39)
        {
          objc_setProperty_atomic(v39, v41, v40, 88);

          v44 = objc_getProperty(v39, v43, 88, 1);
          v46 = v44;
          if (v44)
            objc_setProperty_atomic(v44, v45, v38, 24);
        }
        else
        {

          v46 = 0;
        }

        if (v14)
        {
          v48 = objc_getProperty(v14, v47, 112, 1);
          v49 = v48;
          if (v48)
          {
            v50 = (void *)*((_QWORD *)v48 + 2);
LABEL_28:
            v52 = v50;
            if (v39)
            {
              v53 = objc_getProperty(v39, v51, 88, 1);
              v55 = v53;
              if (v53)
                objc_setProperty_atomic(v53, v54, v52, 32);
            }
            else
            {
              v55 = 0;
            }

            if (v14)
              v57 = objc_getProperty(v14, v56, 128, 1);
            else
              v57 = 0;
            v58 = v57;
            v60 = v58;
            if (v39)
            {
              objc_setProperty_atomic(v39, v59, v58, 96);

              v62 = objc_getProperty(v39, v61, 88, 1);
            }
            else
            {

              v62 = 0;
            }
            v63 = v62;
            v64 = -[NEIKEv2Payload isValid]((uint64_t)v63);

            if ((v64 & 1) != 0)
            {
              v109[0] = MEMORY[0x1E0C809B0];
              v109[1] = 3221225472;
              v109[2] = __87__NEIKEv2Session_Exchange__handleFollowupKEForRekeyChildSAInitiator_iteration_handler___block_invoke;
              v109[3] = &unk_1E3CC1130;
              v109[4] = a1;
              v65 = v7;
              v110 = v65;
              v111 = v14;
              v112 = v38;
              v114 = a3;
              v113 = v9;
              if (-[NEIKEv2Session sendRequest:retry:replyHandler:]((uint64_t)a1, v39, v109) == -1)
              {
                objc_msgSend(v65, "sendCallbackSuccess:session:", 0, a1);
                v67 = objc_getProperty(a1, v66, 336, 1);
                ErrorFailedToSend = (void *)NEIKEv2CreateErrorFailedToSend(CFSTR("initiator rekey child FOLLOWUP_KE #%zu"), v68, v69, v70, v71, v72, v73, v74, a3 + 1);
                -[NEIKEv2IKESA setState:error:]((uint64_t)v67, 3uLL, ErrorFailedToSend);

                -[NEIKEv2Session reportState](a1, v76);
                -[NEIKEv2Session resetAll]((uint64_t)a1, v77);
              }

              v33 = v108;
            }
            else
            {
              ne_log_obj();
              v78 = objc_claimAutoreleasedReturnValue();
              v33 = v108;
              if (os_log_type_enabled(v78, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 138412290;
                v116 = a1;
                _os_log_error_impl(&dword_19BD16000, v78, OS_LOG_TYPE_ERROR, "%@ Failed to create FOLLOWUP_KE packet (initiator rekey child followup KE)", buf, 0xCu);
              }

              objc_msgSend(v7, "sendCallbackSuccess:session:", 0, a1);
              ErrorInternal = (void *)NEIKEv2CreateErrorInternal(CFSTR("Failed to create FOLLOWUP_KE packet (initiator rekey child followup KE)"), v79, v80, v81, v82, v83, v84, v85, v107);
              -[NEIKEv2ChildSA setState:error:]((uint64_t)v14, 3uLL, ErrorInternal);

              -[NEIKEv2Session reportState](a1, v87);
              -[NEIKEv2Session resetChild:]((char *)a1, v14);
            }

            goto LABEL_46;
          }
        }
        else
        {
          v49 = 0;
        }
        v50 = 0;
        goto LABEL_28;
      }
      ne_log_obj();
      v97 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v97, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138412546;
        v116 = a1;
        v117 = 2112;
        v118 = v38;
        _os_log_error_impl(&dword_19BD16000, v97, OS_LOG_TYPE_ERROR, "%@ Failed to generate values for KEM %@ (initiator rekey child followup KE)", buf, 0x16u);
      }

      objc_msgSend(v7, "sendCallbackSuccess:session:", 0, a1);
      v96 = (void *)NEIKEv2CreateErrorInternal(CFSTR("Failed to generate values for KEM %@ (initiator rekey child followup KE)"), v98, v99, v100, v101, v102, v103, v104, (uint64_t)v38);
    }
    else
    {
      ne_log_obj();
      v88 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v88, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138412546;
        v116 = a1;
        v117 = 2112;
        v118 = v33;
        _os_log_error_impl(&dword_19BD16000, v88, OS_LOG_TYPE_ERROR, "%@ No chosen KEM found for transform type %@ (initiator rekey child followup KE)", buf, 0x16u);
      }

      objc_msgSend(v7, "sendCallbackSuccess:session:", 0, a1);
      v96 = (void *)NEIKEv2CreateErrorInternal(CFSTR("No chosen KEM found for transform type %@ (initiator rekey child followup KE)"), v89, v90, v91, v92, v93, v94, v95, (uint64_t)v33);
    }
    v105 = v96;
    -[NEIKEv2ChildSA setState:error:]((uint64_t)v14, 3uLL, v96);

    -[NEIKEv2Session reportState](a1, v106);
    -[NEIKEv2Session resetChild:]((char *)a1, v14);
LABEL_46:

LABEL_47:
  }

}

void __87__NEIKEv2Session_Exchange__handleFollowupKEForRekeyChildSAInitiator_iteration_handler___block_invoke(uint64_t a1, void *a2)
{
  id v3;
  id Property;
  const char *v5;
  void *v6;
  id v7;
  const char *v8;
  id v9;
  const char *v10;
  void *v11;
  id v12;
  const char *v13;
  id v14;
  const char *v15;
  void *v16;
  id v17;
  const char *v18;
  id v19;
  const char *v20;
  void *v21;
  id v22;
  uint64_t v23;
  uint64_t v24;
  const char *v25;
  id v26;
  const char *v27;
  void *v28;
  const char *v29;
  id v30;
  void *v31;
  const char *v32;
  void *v33;
  id v34;
  const char *v35;
  const char *v36;
  id v37;
  SEL v38;
  uint64_t *v39;
  uint64_t *v40;
  uint64_t v41;
  SEL v42;
  const char *v43;
  id v44;
  const char *v45;
  id v46;
  void *v47;
  NSObject *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  __CFString *v57;
  NSObject *v58;
  NSObject *v59;
  void *ErrorCrypto;
  void *v61;
  const char *v62;
  NSObject *v63;
  const char *v64;
  const char *v65;
  uint64_t v66;
  id v67;
  const char *v68;
  id v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  void *ErrorPeerInvalidSyntax;
  NSObject *v79;
  NSObject *v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  const char *v88;
  const char *v89;
  const char *v90;
  const char *v91;
  id v92;
  const char *v93;
  void *v94;
  id v95;
  uint64_t v96;
  uint64_t v97;
  NSObject *v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  void *v107;
  const char *v108;
  const char *v109;
  uint64_t v110;
  uint8_t buf[4];
  const char *v112;
  __int16 v113;
  uint64_t v114;
  __int16 v115;
  uint64_t v116;
  uint64_t v117;

  v117 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    Property = v3;
    v6 = Property;
    if (Property)
      Property = objc_getProperty(Property, v5, 88, 1);
    v7 = Property;

    if (v7)
    {
      if (v6)
      {
        v9 = objc_getProperty(v6, v8, 88, 1);
        v11 = v9;
        if (v9)
          v9 = objc_getProperty(v9, v10, 24, 1);
      }
      else
      {
        v11 = 0;
        v9 = 0;
      }
      v12 = v9;

      if (v12)
      {
        if (v6)
        {
          v14 = objc_getProperty(v6, v13, 88, 1);
          v16 = v14;
          if (v14)
            v14 = objc_getProperty(v14, v15, 32, 1);
        }
        else
        {
          v16 = 0;
          v14 = 0;
        }
        v17 = v14;

        if (v17)
        {
          if (v6)
          {
            v19 = objc_getProperty(v6, v18, 88, 1);
            v21 = v19;
            if (v19)
              v19 = objc_getProperty(v19, v20, 24, 1);
          }
          else
          {
            v21 = 0;
            v19 = 0;
          }
          v22 = v19;
          v23 = objc_msgSend(v22, "method");
          v24 = objc_msgSend(*(id *)(a1 + 56), "method");

          if (v23 != v24)
          {
            ne_log_obj();
            v63 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
            {
              v91 = *(const char **)(a1 + 32);
              if (v6)
              {
                v92 = objc_getProperty(v6, v64, 88, 1);
                v94 = v92;
                if (v92)
                  v92 = objc_getProperty(v92, v93, 24, 1);
              }
              else
              {
                v94 = 0;
                v92 = 0;
              }
              v95 = v92;
              v96 = objc_msgSend(v95, "method");
              v97 = objc_msgSend(*(id *)(a1 + 56), "method");
              *(_DWORD *)buf = 138412802;
              v112 = v91;
              v113 = 2048;
              v114 = v96;
              v115 = 2048;
              v116 = v97;
              _os_log_error_impl(&dword_19BD16000, v63, OS_LOG_TYPE_ERROR, "%@ Did not receive matching method from KE payload (%zu != %zu) (initiator rekey child followup KE)", buf, 0x20u);

            }
            objc_msgSend(*(id *)(a1 + 40), "sendCallbackSuccess:session:", 0, *(_QWORD *)(a1 + 32));
            v66 = *(_QWORD *)(a1 + 48);
            if (v6)
            {
              v67 = objc_getProperty(v6, v65, 88, 1);
              v61 = v67;
              if (v67)
                v67 = objc_getProperty(v67, v68, 24, 1);
            }
            else
            {
              v61 = 0;
              v67 = 0;
            }
            v69 = v67;
            v70 = objc_msgSend(v69, "method");
            objc_msgSend(*(id *)(a1 + 56), "method");
            ErrorPeerInvalidSyntax = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("Did not receive matching method from KE payload (%zu != %zu) (initiator rekey child followup KE)"), v71, v72, v73, v74, v75, v76, v77, v70);
            -[NEIKEv2ChildSA setState:error:](v66, 3uLL, ErrorPeerInvalidSyntax);

            goto LABEL_43;
          }
          if (v6)
          {
            v26 = objc_getProperty(v6, v25, 88, 1);
            v28 = v26;
            if (v26)
              v26 = objc_getProperty(v26, v27, 32, 1);
          }
          else
          {
            v28 = 0;
            v26 = 0;
          }
          v30 = v26;
          v31 = *(void **)(a1 + 48);
          if (v31)
            objc_setProperty_atomic(v31, v29, v30, 104);

          v33 = *(void **)(a1 + 48);
          if (v33)
          {
            v34 = objc_getProperty(*(id *)(a1 + 48), v32, 136, 1);

            if (v34)
            {
              if (-[NEIKEv2ChildSA processCurrentKeyExchange](v33, v35))
              {
                v37 = objc_getProperty(v33, v36, 136, 1);
                v39 = (uint64_t *)objc_getProperty(v33, v38, 112, 1);
                v40 = v39;
                if (v39)
                  v41 = v39[3];
                else
                  v41 = 0;
                objc_msgSend(v37, "addObject:", v41);

                objc_setProperty_atomic(v33, v42, 0, 112);
                if (v6)
                  v44 = objc_getProperty(v6, v43, 96, 1);
                else
                  v44 = 0;
                v46 = v44;
                v47 = *(void **)(a1 + 48);
                if (v47)
                  objc_setProperty_atomic(v47, v45, v46, 128);

                -[NEIKEv2Session handleFollowupKEForRekeyChildSAInitiator:iteration:handler:](*(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 72) + 1, *(_QWORD *)(a1 + 64));
                goto LABEL_44;
              }
            }
            else
            {
              ne_log_obj();
              v79 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v79, OS_LOG_TYPE_FAULT))
              {
                *(_DWORD *)buf = 136315138;
                v112 = "-[NEIKEv2ChildSA(Crypto) processFollowupKeyExchange]";
                _os_log_fault_impl(&dword_19BD16000, v79, OS_LOG_TYPE_FAULT, "%s called with null self.followupSharedSecrets", buf, 0xCu);
              }

            }
          }
          ne_log_obj();
          v80 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v80, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)buf = 0;
            _os_log_error_impl(&dword_19BD16000, v80, OS_LOG_TYPE_ERROR, "Failed to process KE data (initiator rekey child followup KE)", buf, 2u);
          }

          objc_msgSend(*(id *)(a1 + 40), "sendCallbackSuccess:session:", 0, *(_QWORD *)(a1 + 32));
          v56 = *(_QWORD *)(a1 + 48);
          ErrorCrypto = (void *)NEIKEv2CreateErrorCrypto(CFSTR("Failed to process KE data (initiator rekey child followup KE)"), v81, v82, v83, v84, v85, v86, v87, v110);
LABEL_42:
          v61 = ErrorCrypto;
          -[NEIKEv2ChildSA setState:error:](v56, 3uLL, ErrorCrypto);
LABEL_43:

          -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 32), v62);
          -[NEIKEv2Session resetChild:](*(char **)(a1 + 32), *(void **)(a1 + 48));
LABEL_44:

          goto LABEL_45;
        }
        ne_log_obj();
        v59 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
        {
          v90 = *(const char **)(a1 + 32);
          *(_DWORD *)buf = 138412290;
          v112 = v90;
          _os_log_error_impl(&dword_19BD16000, v59, OS_LOG_TYPE_ERROR, "%@ Did not receive data in KE payload (initiator rekey child followup KE)", buf, 0xCu);
        }

        objc_msgSend(*(id *)(a1 + 40), "sendCallbackSuccess:session:", 0, *(_QWORD *)(a1 + 32));
        v56 = *(_QWORD *)(a1 + 48);
        v57 = CFSTR("Did not receive data in KE payload (initiator rekey child followup KE)");
      }
      else
      {
        ne_log_obj();
        v58 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
        {
          v89 = *(const char **)(a1 + 32);
          *(_DWORD *)buf = 138412290;
          v112 = v89;
          _os_log_error_impl(&dword_19BD16000, v58, OS_LOG_TYPE_ERROR, "%@ Did not receive method in KE payload (initiator rekey child followup KE)", buf, 0xCu);
        }

        objc_msgSend(*(id *)(a1 + 40), "sendCallbackSuccess:session:", 0, *(_QWORD *)(a1 + 32));
        v56 = *(_QWORD *)(a1 + 48);
        v57 = CFSTR("Did not receive method in KE payload (initiator rekey child followup KE)");
      }
    }
    else
    {
      ne_log_obj();
      v48 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
      {
        v88 = *(const char **)(a1 + 32);
        *(_DWORD *)buf = 138412290;
        v112 = v88;
        _os_log_error_impl(&dword_19BD16000, v48, OS_LOG_TYPE_ERROR, "%@ Did not receive KE payload (initiator rekey child followup KE)", buf, 0xCu);
      }

      objc_msgSend(*(id *)(a1 + 40), "sendCallbackSuccess:session:", 0, *(_QWORD *)(a1 + 32));
      v56 = *(_QWORD *)(a1 + 48);
      v57 = CFSTR("Did not receive KE payload (initiator rekey child followup KE)");
    }
    ErrorCrypto = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(v57, v49, v50, v51, v52, v53, v54, v55, v110);
    goto LABEL_42;
  }
  ne_log_obj();
  v98 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v98, OS_LOG_TYPE_ERROR))
  {
    v109 = *(const char **)(a1 + 32);
    *(_DWORD *)buf = 138412290;
    v112 = v109;
    _os_log_error_impl(&dword_19BD16000, v98, OS_LOG_TYPE_ERROR, "%@ Failed to receive FOLLOWUP_KE reply (initiator rekey child followup KE)", buf, 0xCu);
  }

  objc_msgSend(*(id *)(a1 + 40), "sendCallbackSuccess:session:", 0, *(_QWORD *)(a1 + 32));
  v99 = *(_QWORD *)(a1 + 48);
  v107 = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("Failed to receive FOLLOWUP_KE reply (initiator rekey child followup KE)"), v100, v101, v102, v103, v104, v105, v106, v110);
  -[NEIKEv2ChildSA setState:error:](v99, 3uLL, v107);

  -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 32), v108);
  -[NEIKEv2Session resetChild:](*(char **)(a1 + 32), *(void **)(a1 + 48));
LABEL_45:

}

- (void)handleFollowupKEForRekeyChildSAResponder:(uint64_t)a3 iteration:(void *)a4 replyPacket:(void *)a5 replyPacketDescription:(void *)a6 handler:
{
  id v11;
  id v12;
  id v13;
  id v14;
  SEL v15;
  NSObject *v16;
  id v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  void *ErrorFailedToSend;
  const char *v26;
  _QWORD v27[4];
  id v28;
  _QWORD *v29;
  id v30;
  uint64_t v31;

  v11 = a2;
  v12 = a5;
  v13 = a6;
  if (a1)
  {
    v14 = a4;
    v16 = objc_getProperty(a1, v15, 368, 1);
    dispatch_assert_queue_V2(v16);

    v27[0] = MEMORY[0x1E0C809B0];
    v27[1] = 3221225472;
    v27[2] = __122__NEIKEv2Session_Exchange__handleFollowupKEForRekeyChildSAResponder_iteration_replyPacket_replyPacketDescription_handler___block_invoke;
    v27[3] = &unk_1E3CC0F50;
    v31 = a3;
    v17 = v11;
    v28 = v17;
    v29 = a1;
    v30 = v13;
    LOBYTE(v16) = -[NEIKEv2Session sendReply:replyHandler:]((uint64_t)a1, v14, v27);

    if ((v16 & 1) == 0)
    {
      ErrorFailedToSend = (void *)NEIKEv2CreateErrorFailedToSend(CFSTR("%@"), v18, v19, v20, v21, v22, v23, v24, (uint64_t)v12);
      -[NEIKEv2ChildSA setState:error:]((uint64_t)v17, 3uLL, ErrorFailedToSend);

      -[NEIKEv2Session reportState](a1, v26);
      -[NEIKEv2Session resetChild:]((char *)a1, v17);
    }

  }
}

void __122__NEIKEv2Session_Exchange__handleFollowupKEForRekeyChildSAResponder_iteration_replyPacket_replyPacketDescription_handler___block_invoke(uint64_t *a1, void *a2)
{
  const char *v3;
  id v4;
  unint64_t v5;
  void *v6;
  id Property;
  const char *v8;
  void *v9;
  id v10;
  unint64_t v11;
  const char *v12;
  id v13;
  void *v14;
  id v15;
  const char *v16;
  void *v17;
  id v18;
  const char *v19;
  void *v20;
  void *v21;
  const char *v22;
  id v23;
  void *v24;
  id v25;
  const char *v26;
  void *v27;
  id v28;
  void *v29;
  const char *v30;
  id v31;
  id v32;
  void *v33;
  void *v34;
  const char *v35;
  id v36;
  id v37;
  const char *v38;
  id v39;
  const char *v40;
  void *v41;
  id v42;
  const char *v43;
  id v44;
  const char *v45;
  void *v46;
  id v47;
  const char *v48;
  id v49;
  const char *v50;
  void *v51;
  id v52;
  uint64_t v53;
  uint64_t v54;
  const char *v55;
  id v56;
  const char *v57;
  void *v58;
  const char *v59;
  id v60;
  void *v61;
  id v62;
  const char *v63;
  void *v64;
  id v65;
  char v66;
  const char *v67;
  void *v68;
  id v69;
  const char *v70;
  void *v71;
  id v72;
  id v73;
  const char *v74;
  id v75;
  id v76;
  NSObject *v77;
  NSObject *v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  void *ErrorInternal;
  NSObject *v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  __CFString *v97;
  void *v98;
  const char *v99;
  NSObject *v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  __CFString *v108;
  NSObject *v109;
  NSObject *v110;
  void *v111;
  const char *v112;
  NSObject *v113;
  const char *v114;
  const char *v115;
  uint64_t v116;
  id v117;
  const char *v118;
  id v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  void *ErrorPeerInvalidSyntax;
  NSObject *v129;
  const char *v130;
  _UNKNOWN **v131;
  void *v132;
  void *v133;
  char v134;
  const char *v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  id v143;
  const char *v144;
  void *ErrorFailedToSend;
  const char *v146;
  id v147;
  void *v148;
  id v149;
  const char *v150;
  void *v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  void *v159;
  uint64_t v160;
  const char *v161;
  NEIKEv2KeyExchangeHandlerKyber *v162;
  SEL v163;
  SEL v164;
  id v165;
  const char *v166;
  unint64_t v167;
  void *v168;
  id v169;
  const char *v170;
  void *v171;
  id v172;
  unint64_t v173;
  const char *v174;
  void *v175;
  void *v176;
  const char *v177;
  NEIKEv2NotifyPayload *v178;
  void *v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  id v184;
  const char *v185;
  void *v186;
  id v187;
  void *v188;
  NEIKEv2KeyExchangePayload *v189;
  const char *v190;
  NEIKEv2KeyExchangePayload *v191;
  SEL v192;
  id v193;
  const char *v194;
  void *v195;
  const char *v196;
  void *v197;
  id v198;
  void *v199;
  void *v200;
  const char *v201;
  id v202;
  id v203;
  const char *v204;
  void *v205;
  const char *v206;
  id v207;
  id v208;
  const char *v209;
  void *v210;
  SEL v211;
  id v212;
  id v213;
  char v214;
  const char *v215;
  id v216;
  const char *v217;
  id v218;
  void *v219;
  id v220;
  void *v221;
  void *v222;
  id v223;
  const char *v224;
  void *v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  void *v229;
  NSObject *v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  id v240;
  const char *v241;
  void *v242;
  const char *v243;
  id v244;
  void *v245;
  id v246;
  const char *v247;
  void *v248;
  id v249;
  uint64_t v250;
  NSObject *v251;
  NSObject *v252;
  uint64_t v253;
  uint64_t v254;
  uint64_t v255;
  uint64_t v256;
  uint64_t v257;
  uint64_t v258;
  uint64_t v259;
  uint64_t v260;
  uint64_t v261;
  uint64_t v262;
  uint64_t v263;
  id v264;
  uint64_t v265;
  void *v266;
  void *v267;
  _BYTE buf[22];
  __int16 v269;
  uint64_t v270;
  uint64_t v271;

  v271 = *MEMORY[0x1E0C80C00];
  v4 = a2;
  v5 = a1[7];
  v6 = (void *)a1[4];
  if (v6)
  {
    Property = objc_getProperty(v6, v3, 184, 1);
    v9 = Property;
    if (Property)
      Property = objc_getProperty(Property, v8, 120, 1);
  }
  else
  {
    v9 = 0;
    Property = 0;
  }
  v10 = Property;
  v11 = objc_msgSend(v10, "count");

  if (v5 < v11)
  {
    if (!a1[7])
    {
      v13 = objc_alloc(MEMORY[0x1E0C99DE8]);
      v14 = (void *)a1[4];
      if (v14)
      {
        v15 = objc_getProperty(v14, v12, 184, 1);
        v17 = v15;
        if (v15)
          v15 = objc_getProperty(v15, v16, 120, 1);
      }
      else
      {
        v17 = 0;
        v15 = 0;
      }
      v18 = v15;
      v20 = (void *)objc_msgSend(v13, "initWithCapacity:", objc_msgSend(v18, "count"));
      v21 = (void *)a1[4];
      if (v21)
        objc_setProperty_atomic(v21, v19, v20, 136);

    }
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      v23 = v4;
      v24 = (void *)a1[4];
      if (v24)
      {
        v25 = objc_getProperty(v24, v22, 184, 1);
        v27 = v25;
        if (v25)
          v25 = objc_getProperty(v25, v26, 120, 1);
      }
      else
      {
        v27 = 0;
        v25 = 0;
      }
      v28 = v25;
      objc_msgSend(v28, "objectAtIndexedSubscript:", a1[7]);
      v29 = (void *)objc_claimAutoreleasedReturnValue();

      v31 = (id)a1[4];
      if (v31)
        v31 = objc_getProperty(v31, v30, 184, 1);
      v32 = v31;
      -[NEIKEv2IKESAProposal chosenAdditionalKEMProtocols](v32);
      v33 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v33, "objectForKeyedSubscript:", v29);
      v34 = (void *)objc_claimAutoreleasedReturnValue();

      if (!v34)
      {
        ne_log_obj();
        v252 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v252, OS_LOG_TYPE_ERROR))
        {
          v262 = a1[5];
          *(_DWORD *)buf = 138412546;
          *(_QWORD *)&buf[4] = v262;
          *(_WORD *)&buf[12] = 2112;
          *(_QWORD *)&buf[14] = v29;
          _os_log_error_impl(&dword_19BD16000, v252, OS_LOG_TYPE_ERROR, "%@ No chosen KEM found for transform type %@ (responder rekey child followup KE)", buf, 0x16u);
        }

        v79 = a1[4];
        ErrorInternal = (void *)NEIKEv2CreateErrorInternal(CFSTR("No chosen KEM found for transform type %@ (responder rekey child followup KE)"), v253, v254, v255, v256, v257, v258, v259, (uint64_t)v29);
        goto LABEL_68;
      }
      if (v23)
        v36 = objc_getProperty(v23, v35, 88, 1);
      else
        v36 = 0;
      v37 = v36;

      if (v37)
      {
        if (v23)
        {
          v39 = objc_getProperty(v23, v38, 88, 1);
          v41 = v39;
          if (v39)
            v39 = objc_getProperty(v39, v40, 24, 1);
        }
        else
        {
          v41 = 0;
          v39 = 0;
        }
        v42 = v39;

        if (v42)
        {
          if (v23)
          {
            v44 = objc_getProperty(v23, v43, 88, 1);
            v46 = v44;
            if (v44)
              v44 = objc_getProperty(v44, v45, 32, 1);
          }
          else
          {
            v46 = 0;
            v44 = 0;
          }
          v47 = v44;

          if (v47)
          {
            if (v23)
            {
              v49 = objc_getProperty(v23, v48, 88, 1);
              v51 = v49;
              if (v49)
                v49 = objc_getProperty(v49, v50, 24, 1);
            }
            else
            {
              v51 = 0;
              v49 = 0;
            }
            v52 = v49;
            v53 = objc_msgSend(v52, "method");
            v54 = objc_msgSend(v34, "method");

            if (v53 != v54)
            {
              ne_log_obj();
              v113 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v113, OS_LOG_TYPE_ERROR))
              {
                v267 = v29;
                v183 = a1[5];
                if (v23)
                {
                  v184 = objc_getProperty(v23, v114, 88, 1);
                  v186 = v184;
                  if (v184)
                    v184 = objc_getProperty(v184, v185, 24, 1);
                }
                else
                {
                  v186 = 0;
                  v184 = 0;
                }
                v187 = v184;
                *(_DWORD *)buf = 138412802;
                *(_QWORD *)&buf[4] = v183;
                *(_WORD *)&buf[12] = 2048;
                *(_QWORD *)&buf[14] = objc_msgSend(v187, "method");
                v269 = 2048;
                v270 = objc_msgSend(v34, "method");
                _os_log_error_impl(&dword_19BD16000, v113, OS_LOG_TYPE_ERROR, "%@ Did not receive matching method from KE payload (%zu != %zu) (responder rekey child followup KE)", buf, 0x20u);

                v29 = v267;
              }

              v116 = a1[4];
              if (v23)
              {
                v117 = objc_getProperty(v23, v115, 88, 1);
                v111 = v117;
                if (v117)
                  v117 = objc_getProperty(v117, v118, 24, 1);
              }
              else
              {
                v111 = 0;
                v117 = 0;
              }
              v119 = v117;
              v120 = objc_msgSend(v119, "method");
              objc_msgSend(v34, "method");
              ErrorPeerInvalidSyntax = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("Did not receive matching method from KE payload (%zu != %zu) (responder rekey child followup KE)"), v121, v122, v123, v124, v125, v126, v127, v120);
              -[NEIKEv2ChildSA setState:error:](v116, 3uLL, ErrorPeerInvalidSyntax);

              goto LABEL_69;
            }
            if (v23)
            {
              v56 = objc_getProperty(v23, v55, 96, 1);
              v58 = v56;
              if (v56)
                v56 = objc_getProperty(v56, v57, 32, 1);
            }
            else
            {
              v58 = 0;
              v56 = 0;
            }
            v60 = v56;
            v61 = (void *)a1[4];
            v266 = v29;
            if (v61)
            {
              v62 = objc_getProperty(v61, v59, 128, 1);
              v64 = v62;
              if (v62)
                v62 = objc_getProperty(v62, v63, 32, 1);
            }
            else
            {
              v64 = 0;
              v62 = 0;
            }
            v65 = v62;
            v66 = objc_msgSend(v60, "isEqualToData:", v65);

            if ((v66 & 1) == 0)
            {
              ne_log_obj();
              v129 = objc_claimAutoreleasedReturnValue();
              v131 = &off_1E3CBB000;
              if (os_log_type_enabled(v129, OS_LOG_TYPE_ERROR))
              {
                v239 = a1[5];
                if (v23)
                {
                  v240 = objc_getProperty(v23, v130, 96, 1);
                  v242 = v240;
                  if (v240)
                    v240 = objc_getProperty(v240, v241, 32, 1);
                }
                else
                {
                  v242 = 0;
                  v240 = 0;
                }
                v244 = v240;
                v245 = (void *)a1[4];
                if (v245)
                {
                  v246 = objc_getProperty(v245, v243, 128, 1);
                  v248 = v246;
                  if (v246)
                    v246 = objc_getProperty(v246, v247, 32, 1);
                }
                else
                {
                  v248 = 0;
                  v246 = 0;
                }
                v249 = v246;
                *(_DWORD *)buf = 138412802;
                *(_QWORD *)&buf[4] = v239;
                *(_WORD *)&buf[12] = 2112;
                *(_QWORD *)&buf[14] = v244;
                v269 = 2112;
                v270 = (uint64_t)v249;
                _os_log_error_impl(&dword_19BD16000, v129, OS_LOG_TYPE_ERROR, "%@ ADDITIONAL_KEY_EXCHANGE in FOLLOWUP_KE request doesn't match expected (%@ != %@) (responder rekey child followup KE)", buf, 0x20u);

                v131 = &off_1E3CBB000;
              }

              v132 = (void *)-[NEIKEv2Packet initResponse:]((uint64_t)objc_alloc((Class)v131[320]), v23);
              v133 = v132;
              v29 = v266;
              if (v132)
                -[NEIKEv2Packet addNotification:data:](v132, 0x2FuLL, 0);
              v134 = -[NEIKEv2Session sendReply:replyHandler:](a1[5], v133, 0);
              v142 = a1[4];
              if ((v134 & 1) != 0)
              {
                v265 = a1[4];
                if (v23)
                {
                  v143 = objc_getProperty(v23, v135, 96, 1);
                  ErrorFailedToSend = v143;
                  if (v143)
                    v143 = objc_getProperty(v143, v144, 32, 1);
                }
                else
                {
                  ErrorFailedToSend = 0;
                  v143 = 0;
                }
                v147 = v143;
                v148 = (void *)a1[4];
                if (v148)
                {
                  v149 = objc_getProperty(v148, v146, 128, 1);
                  v151 = v149;
                  if (v149)
                    v149 = objc_getProperty(v149, v150, 32, 1);
                }
                else
                {
                  v151 = 0;
                  v149 = 0;
                }
                v264 = v149;
                v159 = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("ADDITIONAL_KEY_EXCHANGE in FOLLOWUP_KE request doesn't match expected (%@ != %@) (responder rekey child followup KE)"), v152, v153, v154, v155, v156, v157, v158, (uint64_t)v147);
                -[NEIKEv2ChildSA setState:error:](v265, 3uLL, v159);

                v29 = v266;
                goto LABEL_90;
              }
              ErrorFailedToSend = (void *)NEIKEv2CreateErrorFailedToSend(CFSTR("responder rekey child followup KE mismatched link"), (uint64_t)v135, v136, v137, v138, v139, v140, v141, v263);
              v160 = v142;
LABEL_89:
              -[NEIKEv2ChildSA setState:error:](v160, 3uLL, ErrorFailedToSend);
LABEL_90:

              -[NEIKEv2Session reportState]((_QWORD *)a1[5], v161);
              -[NEIKEv2Session resetChild:]((char *)a1[5], (void *)a1[4]);
LABEL_91:

              goto LABEL_70;
            }
            v68 = (void *)a1[4];
            if (v23)
            {
              v69 = objc_getProperty(v23, v67, 88, 1);
              v71 = v69;
              v29 = v266;
              if (v69)
                v69 = objc_getProperty(v69, v70, 32, 1);
            }
            else
            {
              v71 = 0;
              v69 = 0;
              v29 = v266;
            }
            v72 = v69;
            v73 = v34;
            v75 = v72;
            if (!v68)
              goto LABEL_49;
            v76 = objc_getProperty(v68, v74, 112, 1);

            if (v76)
            {
              ne_log_obj();
              v77 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v77, OS_LOG_TYPE_FAULT))
              {
                *(_DWORD *)buf = 136315138;
                *(_QWORD *)&buf[4] = "-[NEIKEv2ChildSA(Crypto) generateLocalValuesForKEMProtocol:peerPayload:]";
                _os_log_fault_impl(&dword_19BD16000, v77, OS_LOG_TYPE_FAULT, "%s called with null !self.currentKEHandler", buf, 0xCu);
              }
LABEL_48:
              v29 = v266;

LABEL_49:
              ne_log_obj();
              v78 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v78, OS_LOG_TYPE_ERROR))
              {
                v250 = a1[5];
                *(_DWORD *)buf = 138412546;
                *(_QWORD *)&buf[4] = v250;
                *(_WORD *)&buf[12] = 2112;
                *(_QWORD *)&buf[14] = v73;
                _os_log_error_impl(&dword_19BD16000, v78, OS_LOG_TYPE_ERROR, "%@ Failed to generate values for KEM %@ (responder rekey child followup KE)", buf, 0x16u);
              }

              v79 = a1[4];
              ErrorInternal = (void *)NEIKEv2CreateErrorInternal(CFSTR("Failed to generate values for KEM %@ (responder rekey child followup KE)"), v80, v81, v82, v83, v84, v85, v86, (uint64_t)v73);
              goto LABEL_68;
            }
            v162 = +[NEIKEv2KeyExchangeHandler handlerForKEMethod:peerPayload:]((uint64_t)NEIKEv2KeyExchangeHandler, objc_msgSend(v73, "method"), v75);
            objc_setProperty_atomic(v68, v163, v162, 112);

            v165 = objc_getProperty(v68, v164, 112, 1);
            if (!v165)
            {
              ne_log_obj();
              v77 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v77, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 138412290;
                *(_QWORD *)&buf[4] = v73;
                _os_log_error_impl(&dword_19BD16000, v77, OS_LOG_TYPE_ERROR, "Failed to get handler for KE method %@", buf, 0xCu);
              }
              goto LABEL_48;
            }

            v167 = a1[7] + 1;
            v168 = (void *)a1[4];
            if (v168)
            {
              v169 = objc_getProperty(v168, v166, 184, 1);
              v171 = v169;
              if (v169)
                v169 = objc_getProperty(v169, v170, 120, 1);
            }
            else
            {
              v171 = 0;
              v169 = 0;
            }
            v172 = v169;
            v173 = objc_msgSend(v172, "count");

            if (v167 >= v173)
            {
              v188 = (void *)a1[4];
              v29 = v266;
              if (v188)
                objc_setProperty_atomic(v188, v174, 0, 128);
            }
            else
            {
              objc_msgSend(MEMORY[0x1E0CB3A28], "UUID");
              v175 = (void *)objc_claimAutoreleasedReturnValue();
              *(_QWORD *)buf = 0;
              *(_QWORD *)&buf[8] = 0;
              objc_msgSend(v175, "getUUIDBytes:", buf);
              v176 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99D50]), "initWithBytes:length:", buf, 16);
              v178 = +[NEIKEv2NotifyPayload createNotifyPayloadType:data:]((uint64_t)NEIKEv2NotifyPayload, 0x4039uLL, v176);
              v179 = (void *)a1[4];
              v29 = v266;
              if (v179)
                objc_setProperty_atomic(v179, v177, v178, 128);

            }
            v133 = (void *)-[NEIKEv2Packet initResponse:]((uint64_t)[NEIKEv2FollowupKEPacket alloc], v23);
            v189 = objc_alloc_init(NEIKEv2KeyExchangePayload);
            v191 = v189;
            if (v133)
            {
              objc_setProperty_atomic(v133, v190, v189, 88);

              v193 = objc_getProperty(v133, v192, 88, 1);
              v195 = v193;
              if (v193)
                objc_setProperty_atomic(v193, v194, v73, 24);
            }
            else
            {

              v195 = 0;
            }

            v197 = (void *)a1[4];
            if (v197)
            {
              v198 = objc_getProperty(v197, v196, 112, 1);
              v199 = v198;
              if (v198)
              {
                v200 = (void *)*((_QWORD *)v198 + 2);
LABEL_114:
                v202 = v200;
                if (v133)
                {
                  v203 = objc_getProperty(v133, v201, 88, 1);
                  v205 = v203;
                  if (v203)
                    objc_setProperty_atomic(v203, v204, v202, 32);
                }
                else
                {
                  v205 = 0;
                }

                v207 = (id)a1[4];
                if (v207)
                  v207 = objc_getProperty(v207, v206, 128, 1);
                v208 = v207;
                v210 = v208;
                if (v133)
                {
                  objc_setProperty_atomic(v133, v209, v208, 96);

                  v212 = objc_getProperty(v133, v211, 88, 1);
                }
                else
                {

                  v212 = 0;
                }
                v213 = v212;
                v214 = -[NEIKEv2Payload isValid]((uint64_t)v213);

                if ((v214 & 1) != 0)
                {
                  v216 = (id)a1[4];
                  if (v216)
                    v216 = objc_getProperty(v216, v215, 136, 1);
                  v218 = v216;
                  v219 = (void *)a1[4];
                  if (v219)
                  {
                    v220 = objc_getProperty(v219, v217, 112, 1);
                    v221 = v220;
                    if (v220)
                    {
                      v222 = (void *)*((_QWORD *)v220 + 3);
LABEL_127:
                      v223 = v222;
                      objc_msgSend(v218, "addObject:", v223);

                      v225 = (void *)a1[4];
                      if (v225)
                      {
                        objc_setProperty_atomic(v225, v224, 0, 112);
                        v226 = a1[4];
                      }
                      else
                      {
                        v226 = 0;
                      }
                      v227 = a1[5];
                      v228 = a1[7] + 1;
                      v229 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3940]), "initWithFormat:", CFSTR("responder rekey child FOLLOWUP_KE #%zu"), a1[7]);
                      -[NEIKEv2Session handleFollowupKEForRekeyChildSAResponder:iteration:replyPacket:replyPacketDescription:handler:](v227, v226, v228, v133, v229, a1[6]);

                      v29 = v266;
                      goto LABEL_91;
                    }
                  }
                  else
                  {
                    v221 = 0;
                  }
                  v222 = 0;
                  goto LABEL_127;
                }
                ne_log_obj();
                v230 = objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v230, OS_LOG_TYPE_ERROR))
                {
                  v260 = a1[5];
                  *(_DWORD *)buf = 138412290;
                  *(_QWORD *)&buf[4] = v260;
                  _os_log_error_impl(&dword_19BD16000, v230, OS_LOG_TYPE_ERROR, "%@ Failed to create FOLLOWUP_KE packet (responder rekey child followup KE)", buf, 0xCu);
                }

                v231 = a1[4];
                ErrorFailedToSend = (void *)NEIKEv2CreateErrorInternal(CFSTR("Failed to create FOLLOWUP_KE packet (responder rekey child followup KE)"), v232, v233, v234, v235, v236, v237, v238, v263);
                v160 = v231;
                goto LABEL_89;
              }
            }
            else
            {
              v199 = 0;
            }
            v200 = 0;
            goto LABEL_114;
          }
          ne_log_obj();
          v110 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v110, OS_LOG_TYPE_ERROR))
          {
            v182 = a1[5];
            *(_DWORD *)buf = 138412290;
            *(_QWORD *)&buf[4] = v182;
            _os_log_error_impl(&dword_19BD16000, v110, OS_LOG_TYPE_ERROR, "%@ Did not receive data in KE payload (responder rekey child followup KE)", buf, 0xCu);
          }

          v79 = a1[4];
          v108 = CFSTR("Did not receive data in KE payload (responder rekey child followup KE)");
        }
        else
        {
          ne_log_obj();
          v109 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v109, OS_LOG_TYPE_ERROR))
          {
            v181 = a1[5];
            *(_DWORD *)buf = 138412290;
            *(_QWORD *)&buf[4] = v181;
            _os_log_error_impl(&dword_19BD16000, v109, OS_LOG_TYPE_ERROR, "%@ Did not receive method in KE payload (responder rekey child followup KE)", buf, 0xCu);
          }

          v79 = a1[4];
          v108 = CFSTR("Did not receive method in KE payload (responder rekey child followup KE)");
        }
      }
      else
      {
        ne_log_obj();
        v100 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v100, OS_LOG_TYPE_ERROR))
        {
          v180 = a1[5];
          *(_DWORD *)buf = 138412290;
          *(_QWORD *)&buf[4] = v180;
          _os_log_error_impl(&dword_19BD16000, v100, OS_LOG_TYPE_ERROR, "%@ Did not receive KE payload (responder rekey child followup KE)", buf, 0xCu);
        }

        v79 = a1[4];
        v108 = CFSTR("Did not receive KE payload (responder rekey child followup KE)");
      }
      ErrorInternal = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(v108, v101, v102, v103, v104, v105, v106, v107, v263);
LABEL_68:
      v111 = ErrorInternal;
      -[NEIKEv2ChildSA setState:error:](v79, 3uLL, ErrorInternal);
LABEL_69:

      -[NEIKEv2Session reportState]((_QWORD *)a1[5], v112);
      -[NEIKEv2Session resetChild:]((char *)a1[5], (void *)a1[4]);
LABEL_70:

      goto LABEL_71;
    }
    ne_log_obj();
    v251 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v251, OS_LOG_TYPE_ERROR))
    {
      v261 = a1[5];
      *(_DWORD *)buf = 138412290;
      *(_QWORD *)&buf[4] = v261;
      _os_log_error_impl(&dword_19BD16000, v251, OS_LOG_TYPE_ERROR, "%@ Failed to receive FOLLOWUP_KE packet (responder rekey child followup KE)", buf, 0xCu);
    }

    v96 = a1[4];
    v97 = CFSTR("Failed to receive FOLLOWUP_KE packet (responder rekey child followup KE)");
    goto LABEL_57;
  }
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    ne_log_obj();
    v88 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v88, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_19BD16000, v88, OS_LOG_TYPE_ERROR, "Failed to receive Rekey Child SA Delete packet", buf, 2u);
    }

    v96 = a1[4];
    v97 = CFSTR("Failed to receive Rekey Child SA Delete packet");
LABEL_57:
    v98 = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(v97, v89, v90, v91, v92, v93, v94, v95, v263);
    -[NEIKEv2ChildSA setState:error:](v96, 3uLL, v98);

    -[NEIKEv2Session reportState]((_QWORD *)a1[5], v99);
    -[NEIKEv2Session resetChild:]((char *)a1[5], (void *)a1[4]);
    goto LABEL_71;
  }
  (*(void (**)(void))(a1[6] + 16))();
LABEL_71:

}

- (void)initiateRekeyChildSA:(_BYTE *)a1
{
  const char *v3;
  unsigned int *v4;
  id Property;
  NSObject *v6;
  const char *v7;
  id v8;
  const char *v9;
  _DWORD *v10;
  const char *v11;
  void *v12;
  _BOOL4 v13;
  NSObject *v14;
  NSObject *v15;
  unsigned int *v16;
  uint64_t v17;
  SEL v18;
  id v19;
  const char *v20;
  id v21;
  const char *v22;
  void *v23;
  id v24;
  SEL v25;
  id v26;
  const char *v27;
  void *v28;
  SEL v29;
  id v30;
  void *v31;
  _BYTE *v32;
  id v33;
  SEL v34;
  id v35;
  void *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t i;
  _BYTE *v41;
  void *v42;
  char v43;
  SEL v44;
  id v45;
  int v46;
  char v47;
  const char *v48;
  void *v49;
  void *v50;
  SEL v51;
  id v52;
  const char *v53;
  id v54;
  char v55;
  void *v56;
  void *v57;
  unsigned int *v58;
  const char *v59;
  id v60;
  id v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  void *ErrorFailedToSend;
  const char *v70;
  const char *v71;
  NSObject *v72;
  NSObject *v73;
  NSObject *v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  void *v82;
  const char *v83;
  NSObject *v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  void *ErrorCrypto;
  const char *v93;
  NSObject *v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  void *ErrorInternal;
  const char *v103;
  const char *v104;
  uint64_t v105;
  void *v106;
  id v107;
  unsigned int *v108;
  id v109;
  _QWORD v110[4];
  unsigned int *v111;
  _BYTE *v112;
  id v113;
  id v114;
  id v115;
  __int128 v116;
  __int128 v117;
  __int128 v118;
  __int128 v119;
  uint8_t v120[128];
  uint8_t buf[4];
  const char *v122;
  __int16 v123;
  void *v124;
  uint64_t v125;

  v125 = *MEMORY[0x1E0C80C00];
  v4 = a2;
  if (a1)
    Property = objc_getProperty(a1, v3, 368, 1);
  else
    Property = 0;
  v6 = Property;
  dispatch_assert_queue_V2(v6);

  if (!a1[15])
    __assert_rtn("-[NEIKEv2Session(Exchange) initiateRekeyChildSA:]", "NEIKEv2Exchange.m", 2014, "self.hasOutboundRequestInFlight");
  v8 = objc_getProperty(a1, v7, 336, 1);
  if (v4)
    v9 = (const char *)v4[6];
  else
    v9 = 0;
  v10 = -[NEIKEv2Session copyChildWithID:](a1, v9);
  v12 = v10;
  if (!v8)
  {
    ne_log_obj();
    v72 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v72, OS_LOG_TYPE_FAULT))
      goto LABEL_46;
    *(_DWORD *)buf = 136315138;
    v122 = "-[NEIKEv2Session(Exchange) initiateRekeyChildSA:]";
    v104 = "%s called with null ikeSA";
    goto LABEL_65;
  }
  if (!v10)
  {
    ne_log_obj();
    v72 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v72, OS_LOG_TYPE_FAULT))
      goto LABEL_46;
    *(_DWORD *)buf = 136315138;
    v122 = "-[NEIKEv2Session(Exchange) initiateRekeyChildSA:]";
    v104 = "%s called with null childSA";
    goto LABEL_65;
  }
  v13 = -[NEIKEv2ChildSA isRekeying](v10, v11);
  ne_log_large_obj();
  v14 = objc_claimAutoreleasedReturnValue();
  v15 = v14;
  if (v13)
  {
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412546;
      v122 = a1;
      v123 = 2112;
      v124 = v12;
      _os_log_debug_impl(&dword_19BD16000, v15, OS_LOG_TYPE_DEBUG, "%@ Child SA %@ already rekeying, skipping", buf, 0x16u);
    }

    v16 = v4;
    v17 = 1;
    goto LABEL_47;
  }
  if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 138412546;
    v122 = a1;
    v123 = 2112;
    v124 = v12;
    _os_log_impl(&dword_19BD16000, v15, OS_LOG_TYPE_INFO, "%@ Rekey Child SA %@", buf, 0x16u);
  }

  v19 = objc_getProperty(v12, v18, 56, 1);
  if (v19)
  {
    v21 = objc_getProperty(v12, v20, 56, 1);
    v23 = v21;
    if (v21)
      v21 = objc_getProperty(v21, v22, 80, 1);
    v24 = v21;

    v26 = objc_getProperty(v12, v25, 56, 1);
    v28 = v26;
    v107 = v8;
    v108 = v4;
    v106 = v24;
    if (v26)
      v26 = objc_getProperty(v26, v27, 88, 1);
    v109 = v26;

    v30 = objc_getProperty(v12, v29, 56, 1);
    v31 = -[NEIKEv2ChildSAProposal copyForRekey](v30);
    v32 = -[NEIKEv2ChildSAProposal copyWithoutKEM](v31);

    v33 = objc_alloc_init(MEMORY[0x1E0C99E10]);
    v116 = 0u;
    v117 = 0u;
    v118 = 0u;
    v119 = 0u;
    v35 = objc_getProperty(v12, v34, 48, 1);
    objc_msgSend(v35, "proposals");
    v36 = (void *)objc_claimAutoreleasedReturnValue();

    v37 = objc_msgSend(v36, "countByEnumeratingWithState:objects:count:", &v116, v120, 16);
    if (v37)
    {
      v38 = v37;
      v39 = *(_QWORD *)v117;
      do
      {
        for (i = 0; i != v38; ++i)
        {
          if (*(_QWORD *)v117 != v39)
            objc_enumerationMutation(v36);
          v41 = -[NEIKEv2ChildSAProposal copyForRekey](*(void **)(*((_QWORD *)&v116 + 1) + 8 * i));
          v42 = -[NEIKEv2ChildSAProposal copyWithoutKEM](v41);
          if (objc_msgSend(v42, "isEqual:", v32))
          {
            v43 = objc_msgSend(v33, "count");
            if (v41)
              v41[8] = v43 + 1;
            objc_msgSend(v33, "addObject:", v41);
          }

        }
        v38 = objc_msgSend(v36, "countByEnumeratingWithState:objects:count:", &v116, v120, 16);
      }
      while (v38);
    }

    v45 = objc_getProperty(v12, v44, 48, 1);
    v46 = objc_msgSend(v45, "opportunisticPFS");

    v8 = v107;
    v4 = v108;
    if (v46)
    {
      v47 = objc_msgSend(v33, "count");
      if (v32)
        v32[8] = v47 + 1;
      objc_msgSend(v33, "addObject:", v32);
    }
    if (objc_msgSend(v33, "count"))
    {
      objc_msgSend(v33, "array");
      v49 = (void *)objc_claimAutoreleasedReturnValue();
      v50 = (void *)objc_msgSend(v49, "copy");
      objc_setProperty_atomic(v12, v51, v50, 176);

    }
    v52 = objc_getProperty(v12, v48, 176, 1);

    if (v52)
    {
      v54 = objc_getProperty(v12, v53, 176, 1);
      v55 = -[NEIKEv2Session generateSPIForChild:proposals:](a1, v12, v54);

      if ((v55 & 1) != 0)
      {
        if ((-[NEIKEv2ChildSA generateInitialValues]((id *)v12) & 1) != 0)
        {
          +[NEIKEv2CreateChildPacket createRekeyRequestChildSA:]((uint64_t)NEIKEv2CreateChildPacket, v12);
          v56 = (void *)objc_claimAutoreleasedReturnValue();
          v57 = v109;
          if (v56)
          {
            v110[0] = MEMORY[0x1E0C809B0];
            v110[1] = 3221225472;
            v110[2] = __49__NEIKEv2Session_Exchange__initiateRekeyChildSA___block_invoke;
            v110[3] = &unk_1E3CC11D0;
            v58 = v108;
            v111 = v58;
            v112 = a1;
            v113 = v12;
            v114 = v106;
            v115 = v109;
            if (-[NEIKEv2Session sendRequest:retry:replyHandler:]((uint64_t)a1, v56, v110) == -1)
            {
              objc_msgSend(v58, "sendCallbackSuccess:session:", 0, a1);
              if (a1)
                v60 = objc_getProperty(a1, v59, 336, 1);
              else
                v60 = 0;
              v61 = v60;
              ErrorFailedToSend = (void *)NEIKEv2CreateErrorFailedToSend(CFSTR("initiator rekey child SA"), v62, v63, v64, v65, v66, v67, v68, v105);
              -[NEIKEv2IKESA setState:error:]((uint64_t)v61, 3uLL, ErrorFailedToSend);

              -[NEIKEv2Session reportState](a1, v70);
              -[NEIKEv2Session resetAll]((uint64_t)a1, v71);
              v57 = v109;
            }

          }
          else
          {
            ne_log_obj();
            v94 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v94, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)buf = 0;
              _os_log_error_impl(&dword_19BD16000, v94, OS_LOG_TYPE_ERROR, "Failed to create Create Child SA packet", buf, 2u);
            }

            objc_msgSend(v108, "sendCallbackSuccess:session:", 0, a1);
            ErrorInternal = (void *)NEIKEv2CreateErrorInternal(CFSTR("Failed to create Create Child SA packet"), v95, v96, v97, v98, v99, v100, v101, v105);
            -[NEIKEv2ChildSA setState:error:]((uint64_t)v12, 3uLL, ErrorInternal);

            -[NEIKEv2Session reportState](a1, v103);
            -[NEIKEv2Session resetChild:](a1, v12);
          }

        }
        else
        {
          ne_log_obj();
          v84 = objc_claimAutoreleasedReturnValue();
          v57 = v109;
          if (os_log_type_enabled(v84, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)buf = 0;
            _os_log_error_impl(&dword_19BD16000, v84, OS_LOG_TYPE_ERROR, "Failed to generate local Child crypto values", buf, 2u);
          }

          objc_msgSend(v108, "sendCallbackSuccess:session:", 0, a1);
          ErrorCrypto = (void *)NEIKEv2CreateErrorCrypto(CFSTR("Failed to generate local Child crypto values"), v85, v86, v87, v88, v89, v90, v91, v105);
          -[NEIKEv2ChildSA setState:error:]((uint64_t)v12, 3uLL, ErrorCrypto);

          -[NEIKEv2Session reportState](a1, v93);
          -[NEIKEv2Session resetChild:](a1, v12);
        }
        goto LABEL_55;
      }
      ne_log_obj();
      v74 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v74, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_19BD16000, v74, OS_LOG_TYPE_ERROR, "Failed to generate Child SA SPI", buf, 2u);
      }

      objc_msgSend(v108, "sendCallbackSuccess:session:", 0, a1);
      v82 = (void *)NEIKEv2CreateErrorCrypto(CFSTR("Failed to generate Child SA SPI"), v75, v76, v77, v78, v79, v80, v81, v105);
      -[NEIKEv2ChildSA setState:error:]((uint64_t)v12, 3uLL, v82);

      -[NEIKEv2Session reportState](a1, v83);
      -[NEIKEv2Session resetChild:](a1, v12);
    }
    else
    {
      ne_log_obj();
      v73 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v73, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136315138;
        v122 = "-[NEIKEv2Session(Exchange) initiateRekeyChildSA:]";
        _os_log_fault_impl(&dword_19BD16000, v73, OS_LOG_TYPE_FAULT, "%s called with null childSA.rekeyRequestProposals", buf, 0xCu);
      }

      objc_msgSend(v108, "sendCallbackSuccess:session:", 0, a1);
    }
    v57 = v109;
LABEL_55:

    goto LABEL_56;
  }
  ne_log_obj();
  v72 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v72, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)buf = 136315138;
    v122 = "-[NEIKEv2Session(Exchange) initiateRekeyChildSA:]";
    v104 = "%s called with null childSA.chosenProposal";
LABEL_65:
    _os_log_fault_impl(&dword_19BD16000, v72, OS_LOG_TYPE_FAULT, v104, buf, 0xCu);
  }
LABEL_46:

  v16 = v4;
  v17 = 0;
LABEL_47:
  objc_msgSend(v16, "sendCallbackSuccess:session:", v17, a1);
LABEL_56:

}

void __49__NEIKEv2Session_Exchange__initiateRekeyChildSA___block_invoke(uint64_t a1, void *a2)
{
  id v3;
  uint64_t v4;
  void *v5;
  _QWORD *v6;
  unsigned int *v7;
  const char *v8;
  _QWORD *v9;
  NSObject *v10;
  const char *v11;
  _DWORD *v12;
  const char *v13;
  void *v14;
  id v15;
  id v16;
  const char *v17;
  NSObject *v18;
  const char *v19;
  id Property;
  id v21;
  uint64_t v22;
  const char *v23;
  id v24;
  id v25;
  const char *v26;
  uint64_t v27;
  id v28;
  id v29;
  id v30;
  uint64_t v31;
  uint64_t i;
  void *v33;
  void *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  NSObject *v39;
  const char *v40;
  const char *v41;
  id v42;
  id ErrorCrypto;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  void *ErrorPeerInvalidSyntax;
  NSObject *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  void *v62;
  const char *v63;
  void *v64;
  const char *v65;
  id v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  void *ErrorFailedToSend;
  const char *v75;
  const char *v76;
  NSObject *v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  const char *v85;
  NSObject *v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  void *ErrorInternal;
  const char *v95;
  id v96;
  id v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  void *v101;
  uint64_t v102;
  _QWORD *v103;
  unsigned int *v104;
  _QWORD v105[2];
  void (*v106)(uint64_t, const char *);
  void *v107;
  _QWORD *v108;
  id v109;
  id v110;
  id v111;
  id v112;
  __int128 v113;
  __int128 v114;
  __int128 v115;
  __int128 v116;
  __int128 v117;
  __int128 v118;
  __int128 v119;
  __int128 v120;
  uint8_t v121[128];
  _BYTE buf[24];
  void *v123;
  _QWORD *v124;
  unsigned int *v125;
  id v126;
  _QWORD *v127;
  uint64_t v128;

  v128 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    v4 = -[NEIKEv2CreateChildPacket validateRekeyResponseChildSA:]((uint64_t)v3, *(void **)(a1 + 48));
    v5 = *(void **)(a1 + 32);
    v6 = *(_QWORD **)(a1 + 40);
    v105[0] = MEMORY[0x1E0C809B0];
    v105[1] = 3221225472;
    v106 = __49__NEIKEv2Session_Exchange__initiateRekeyChildSA___block_invoke_312;
    v107 = &unk_1E3CC11A8;
    v108 = v6;
    v109 = *(id *)(a1 + 48);
    v110 = *(id *)(a1 + 32);
    v111 = *(id *)(a1 + 56);
    v112 = *(id *)(a1 + 64);
    v7 = v5;
    v9 = v105;
    if (v6)
    {
      v10 = objc_getProperty(v6, v8, 368, 1);
      dispatch_assert_queue_V2(v10);

      if (v7)
        v11 = (const char *)v7[6];
      else
        v11 = 0;
      v12 = -[NEIKEv2Session copyChildWithID:](v6, v11);
      v14 = v12;
      if ((v4 & 1) != 0
        || (!v12 ? (v15 = 0) : (v15 = objc_getProperty(v12, v13, 96, 1)),
            v16 = v15,
            v16,
            !v16))
      {
        v106((uint64_t)v9, (const char *)v4);
      }
      else
      {
        if (v14)
          objc_setProperty_atomic(v14, v17, 0, 112);
        ne_log_obj();
        v18 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
        {
          if (v14)
            Property = objc_getProperty(v14, v19, 96, 1);
          else
            Property = 0;
          v21 = Property;
          v22 = objc_msgSend(v21, "method");
          *(_DWORD *)buf = 138412546;
          *(_QWORD *)&buf[4] = v6;
          *(_WORD *)&buf[12] = 2048;
          *(_QWORD *)&buf[14] = v22;
          _os_log_impl(&dword_19BD16000, v18, OS_LOG_TYPE_INFO, "%@ Received KE method preference %tu, retrying rekey Child SA (child rekey retry KE)", buf, 0x16u);

        }
        v103 = v9;
        v104 = v7;

        if (v14)
          v24 = objc_getProperty(v14, v23, 96, 1);
        else
          v24 = 0;
        v25 = v24;
        v27 = objc_msgSend(v25, "method");
        if (v14)
          v28 = objc_getProperty(v14, v26, 176, 1);
        else
          v28 = 0;
        v29 = v28;
        objc_opt_self();
        v117 = 0u;
        v118 = 0u;
        v119 = 0u;
        v120 = 0u;
        v30 = v29;
        v102 = objc_msgSend(v30, "countByEnumeratingWithState:objects:count:", &v117, buf, 16);
        if (v102)
        {
          v31 = *(_QWORD *)v118;
          v100 = *(_QWORD *)v118;
          v101 = v25;
          while (2)
          {
            for (i = 0; i != v102; ++i)
            {
              if (*(_QWORD *)v118 != v31)
                objc_enumerationMutation(v30);
              v33 = *(void **)(*((_QWORD *)&v117 + 1) + 8 * i);
              v113 = 0u;
              v114 = 0u;
              v115 = 0u;
              v116 = 0u;
              objc_msgSend(v33, "kemProtocols");
              v34 = (void *)objc_claimAutoreleasedReturnValue();
              v35 = objc_msgSend(v34, "countByEnumeratingWithState:objects:count:", &v113, v121, 16);
              if (v35)
              {
                v36 = v35;
                v37 = *(_QWORD *)v114;
LABEL_26:
                v38 = 0;
                while (1)
                {
                  if (*(_QWORD *)v114 != v37)
                    objc_enumerationMutation(v34);
                  if (objc_msgSend(*(id *)(*((_QWORD *)&v113 + 1) + 8 * v38), "method") == v27)
                    break;
                  if (v36 == ++v38)
                  {
                    v36 = objc_msgSend(v34, "countByEnumeratingWithState:objects:count:", &v113, v121, 16);
                    if (v36)
                      goto LABEL_26;
                    goto LABEL_32;
                  }
                }

                if ((-[NEIKEv2ChildSA generateInitialValues]((id *)v14) & 1) != 0)
                {
                  +[NEIKEv2CreateChildPacket createRekeyRequestChildSA:]((uint64_t)NEIKEv2CreateChildPacket, v14);
                  v64 = (void *)objc_claimAutoreleasedReturnValue();
                  v9 = v103;
                  v7 = v104;
                  if (v64)
                  {
                    *(_QWORD *)buf = MEMORY[0x1E0C809B0];
                    *(_QWORD *)&buf[8] = 3221225472;
                    *(_QWORD *)&buf[16] = __69__NEIKEv2Session_Exchange__retryKEForRekeyChildSA_validated_handler___block_invoke;
                    v123 = &unk_1E3CC1108;
                    v124 = v6;
                    v125 = v104;
                    v126 = v14;
                    v127 = v103;
                    if (-[NEIKEv2Session sendRequest:retry:replyHandler:]((uint64_t)v6, v64, buf) == -1)
                    {
                      v66 = objc_getProperty(v6, v65, 336, 1);
                      ErrorFailedToSend = (void *)NEIKEv2CreateErrorFailedToSend(CFSTR("child rekey retry KE"), v67, v68, v69, v70, v71, v72, v73, v99);
                      -[NEIKEv2IKESA setState:error:]((uint64_t)v66, 3uLL, ErrorFailedToSend);

                      -[NEIKEv2Session reportState](v6, v75);
                      -[NEIKEv2Session resetAll]((uint64_t)v6, v76);
                    }

                  }
                  else
                  {
                    ne_log_obj();
                    v86 = objc_claimAutoreleasedReturnValue();
                    if (os_log_type_enabled(v86, OS_LOG_TYPE_ERROR))
                    {
                      *(_DWORD *)buf = 138412290;
                      *(_QWORD *)&buf[4] = v6;
                      _os_log_error_impl(&dword_19BD16000, v86, OS_LOG_TYPE_ERROR, "%@ Failed to create Create Child SA packet (child rekey retry KE)", buf, 0xCu);
                    }

                    objc_msgSend(v104, "sendCallbackSuccess:session:", 0, v6);
                    ErrorInternal = (void *)NEIKEv2CreateErrorInternal(CFSTR("Failed to create Create Child SA packet (child rekey retry KE)"), v87, v88, v89, v90, v91, v92, v93, v99);
                    -[NEIKEv2ChildSA setState:error:]((uint64_t)v14, 3uLL, ErrorInternal);

                    -[NEIKEv2Session reportState](v6, v95);
                    -[NEIKEv2Session resetChild:]((char *)v6, v14);
                  }

                  goto LABEL_55;
                }
                ne_log_obj();
                v77 = objc_claimAutoreleasedReturnValue();
                v9 = v103;
                v7 = v104;
                if (os_log_type_enabled(v77, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 138412290;
                  *(_QWORD *)&buf[4] = v6;
                  _os_log_error_impl(&dword_19BD16000, v77, OS_LOG_TYPE_ERROR, "%@ Failed to generate local Child crypto values (child rekey retry KE)", buf, 0xCu);
                }

                objc_msgSend(v104, "sendCallbackSuccess:session:", 0, v6);
                ErrorCrypto = (id)NEIKEv2CreateErrorCrypto(CFSTR("Failed to generate local Child crypto values (child rekey retry KE)"), v78, v79, v80, v81, v82, v83, v84, v99);
                -[NEIKEv2ChildSA setState:error:]((uint64_t)v14, 3uLL, ErrorCrypto);
                goto LABEL_50;
              }
LABEL_32:

              v31 = v100;
            }
            v25 = v101;
            v102 = objc_msgSend(v30, "countByEnumeratingWithState:objects:count:", &v117, buf, 16);
            if (v102)
              continue;
            break;
          }
        }

        ne_log_obj();
        v39 = objc_claimAutoreleasedReturnValue();
        v9 = v103;
        v7 = v104;
        if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
        {
          if (v14)
            v96 = objc_getProperty(v14, v40, 96, 1);
          else
            v96 = 0;
          v97 = v96;
          v98 = objc_msgSend(v97, "method");
          *(_DWORD *)buf = 138412546;
          *(_QWORD *)&buf[4] = v6;
          *(_WORD *)&buf[12] = 2048;
          *(_QWORD *)&buf[14] = v98;
          _os_log_error_impl(&dword_19BD16000, v39, OS_LOG_TYPE_ERROR, "%@ Received KE method preference %tu is not in Child rekey proposal (child rekey retry KE)", buf, 0x16u);

        }
        objc_msgSend(v104, "sendCallbackSuccess:session:", 0, v6);
        if (v14)
          v42 = objc_getProperty(v14, v41, 96, 1);
        else
          v42 = 0;
        ErrorCrypto = v42;
        v44 = objc_msgSend(ErrorCrypto, "method");
        ErrorPeerInvalidSyntax = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("Received KE method preference %tu is not in Child rekey proposal (child rekey retry KE)"), v45, v46, v47, v48, v49, v50, v51, v44);
        -[NEIKEv2ChildSA setState:error:]((uint64_t)v14, 3uLL, ErrorPeerInvalidSyntax);

LABEL_50:
        -[NEIKEv2Session reportState](v6, v85);
        -[NEIKEv2Session resetChild:]((char *)v6, v14);
      }
LABEL_55:

    }
  }
  else
  {
    ne_log_obj();
    v53 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_19BD16000, v53, OS_LOG_TYPE_ERROR, "Failed to receive Create Child SA packet", buf, 2u);
    }

    objc_msgSend(*(id *)(a1 + 32), "sendCallbackSuccess:session:", 0, *(_QWORD *)(a1 + 40));
    v54 = *(_QWORD *)(a1 + 48);
    v62 = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("Failed to receive Create Child SA packet"), v55, v56, v57, v58, v59, v60, v61, v99);
    -[NEIKEv2ChildSA setState:error:](v54, 3uLL, v62);

    -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 40), v63);
    -[NEIKEv2Session resetChild:](*(char **)(a1 + 40), *(void **)(a1 + 48));
  }

}

void __49__NEIKEv2Session_Exchange__initiateRekeyChildSA___block_invoke_312(uint64_t a1, const char *a2)
{
  void *v3;
  id v4;
  const char *v5;
  void *v6;
  id v7;
  uint64_t v8;
  const char *v9;
  id *v10;
  _QWORD *v11;
  void *v12;
  id v13;
  uint64_t v14;
  id *v15;
  void *v16;
  NSObject *v17;
  const char *v18;
  void *v19;
  _QWORD *v20;
  id Property;
  const char *v22;
  const char *v23;
  id v24;
  void *v25;
  id v26;
  const char *v27;
  void *v28;
  id v29;
  id v30;
  uint64_t v31;
  void *v32;
  _QWORD *v33;
  NSObject *v34;
  const char *v35;
  void *v36;
  id v37;
  const char *v38;
  const char *v39;
  void *v40;
  id v41;
  const char *v42;
  id v43;
  uint64_t v44;
  void *v45;
  _QWORD v46[4];
  _QWORD v47[2];
  id v48;
  id v49;
  id v50;
  _QWORD v51[4];
  _QWORD v52[2];
  id v53;
  _QWORD v54[4];
  _QWORD v55[2];
  id v56;
  uint8_t buf[16];

  if ((a2 & 1) == 0)
  {
    ne_log_obj();
    v17 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_19BD16000, v17, OS_LOG_TYPE_ERROR, "Failed to process Create Child SA packet", buf, 2u);
    }

    v20 = *(_QWORD **)(a1 + 32);
    v19 = *(void **)(a1 + 40);
    if (v19)
    {
      Property = objc_getProperty(v19, v18, 56, 1);
      v16 = Property;
      if (Property)
        Property = objc_getProperty(Property, v22, 80, 1);
    }
    else
    {
      v16 = 0;
      Property = 0;
    }
    v24 = Property;
    v25 = *(void **)(a1 + 40);
    if (v25)
    {
      v26 = objc_getProperty(v25, v23, 56, 1);
      v28 = v26;
      if (v26)
        v26 = objc_getProperty(v26, v27, 88, 1);
    }
    else
    {
      v28 = 0;
      v26 = 0;
    }
    v29 = v26;
    v54[0] = MEMORY[0x1E0C809B0];
    v54[1] = 3221225472;
    v54[2] = __49__NEIKEv2Session_Exchange__initiateRekeyChildSA___block_invoke_313;
    v54[3] = &unk_1E3CC10B8;
    v10 = (id *)v55;
    v30 = *(id *)(a1 + 48);
    v31 = *(_QWORD *)(a1 + 32);
    v32 = *(void **)(a1 + 40);
    v55[0] = v30;
    v55[1] = v31;
    v15 = &v56;
    v56 = v32;
    v33 = v54;
    goto LABEL_17;
  }
  v3 = *(void **)(a1 + 40);
  if (v3)
  {
    v4 = objc_getProperty(v3, a2, 56, 1);
    v6 = v4;
    if (v4)
      v4 = objc_getProperty(v4, v5, 112, 1);
  }
  else
  {
    v6 = 0;
    v4 = 0;
  }
  v7 = v4;
  v8 = objc_msgSend(v7, "method");

  if (v8 && (-[NEIKEv2ChildSA processPrimaryKeyExchange](*(_QWORD *)(a1 + 40), v9) & 1) == 0)
  {
    ne_log_obj();
    v34 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_19BD16000, v34, OS_LOG_TYPE_ERROR, "Failed to process KE data", buf, 2u);
    }

    v20 = *(_QWORD **)(a1 + 32);
    v36 = *(void **)(a1 + 40);
    if (v36)
    {
      v37 = objc_getProperty(v36, v35, 56, 1);
      v16 = v37;
      if (v37)
        v37 = objc_getProperty(v37, v38, 80, 1);
    }
    else
    {
      v16 = 0;
      v37 = 0;
    }
    v24 = v37;
    v40 = *(void **)(a1 + 40);
    if (v40)
    {
      v41 = objc_getProperty(v40, v39, 56, 1);
      v28 = v41;
      if (v41)
        v41 = objc_getProperty(v41, v42, 88, 1);
    }
    else
    {
      v28 = 0;
      v41 = 0;
    }
    v29 = v41;
    v51[0] = MEMORY[0x1E0C809B0];
    v51[1] = 3221225472;
    v51[2] = __49__NEIKEv2Session_Exchange__initiateRekeyChildSA___block_invoke_314;
    v51[3] = &unk_1E3CC10B8;
    v10 = (id *)v52;
    v43 = *(id *)(a1 + 48);
    v44 = *(_QWORD *)(a1 + 32);
    v45 = *(void **)(a1 + 40);
    v52[0] = v43;
    v52[1] = v44;
    v15 = &v53;
    v53 = v45;
    v33 = v51;
LABEL_17:
    -[NEIKEv2Session initiateDeleteChildSPI:remoteSPI:deleteCompletionCallback:](v20, v24, v29, v33);

    goto LABEL_18;
  }
  v46[0] = MEMORY[0x1E0C809B0];
  v46[1] = 3221225472;
  v46[2] = __49__NEIKEv2Session_Exchange__initiateRekeyChildSA___block_invoke_2;
  v46[3] = &unk_1E3CC1180;
  v10 = (id *)v47;
  v11 = *(_QWORD **)(a1 + 32);
  v12 = *(void **)(a1 + 48);
  v13 = *(id *)(a1 + 40);
  v14 = *(_QWORD *)(a1 + 32);
  v47[0] = v13;
  v47[1] = v14;
  v15 = &v48;
  v48 = *(id *)(a1 + 48);
  v49 = *(id *)(a1 + 56);
  v50 = *(id *)(a1 + 64);
  -[NEIKEv2Session handleFollowupKEForRekeyChildSAInitiator:iteration:handler:](v11, v12, 0, v46);

  v16 = v49;
LABEL_18:

}

void __49__NEIKEv2Session_Exchange__initiateRekeyChildSA___block_invoke_313(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *ErrorPeerInvalidSyntax;
  const char *v11;
  uint64_t v12;

  objc_msgSend(*(id *)(a1 + 32), "sendCallbackSuccess:session:", 0, *(_QWORD *)(a1 + 40));
  v2 = *(_QWORD *)(a1 + 48);
  ErrorPeerInvalidSyntax = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("Failed to process Create Child SA packet"), v3, v4, v5, v6, v7, v8, v9, v12);
  -[NEIKEv2ChildSA setState:error:](v2, 3uLL, ErrorPeerInvalidSyntax);

  -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 40), v11);
  -[NEIKEv2Session resetChild:](*(char **)(a1 + 40), *(void **)(a1 + 48));
}

void __49__NEIKEv2Session_Exchange__initiateRekeyChildSA___block_invoke_314(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *ErrorCrypto;
  const char *v11;
  uint64_t v12;

  objc_msgSend(*(id *)(a1 + 32), "sendCallbackSuccess:session:", 0, *(_QWORD *)(a1 + 40));
  v2 = *(_QWORD *)(a1 + 48);
  ErrorCrypto = (void *)NEIKEv2CreateErrorCrypto(CFSTR("Failed to process KE data"), v3, v4, v5, v6, v7, v8, v9, v12);
  -[NEIKEv2ChildSA setState:error:](v2, 3uLL, ErrorCrypto);

  -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 40), v11);
  -[NEIKEv2Session resetChild:](*(char **)(a1 + 40), *(void **)(a1 + 48));
}

void __49__NEIKEv2Session_Exchange__initiateRekeyChildSA___block_invoke_2(void **a1)
{
  id v2;
  const char *v3;
  void *v4;
  void *v5;
  const char *v6;
  void *v7;
  _QWORD *v8;
  void *v9;
  void *v10;
  id v11;
  NSObject *v12;
  const char *v13;
  void *v14;
  _QWORD *v15;
  id v16;
  const char *v17;
  void *v18;
  const char *v19;
  id v20;
  void *v21;
  id v22;
  const char *v23;
  void *v24;
  id v25;
  id v26;
  NSObject *v27;
  const char *v28;
  void *v29;
  _QWORD *v30;
  id Property;
  const char *v32;
  void *v33;
  const char *v34;
  id v35;
  void *v36;
  id v37;
  const char *v38;
  void *v39;
  id v40;
  id v41;
  int8x16_t v42;
  int8x16_t v43;
  _QWORD v44[5];
  id v45;
  id v46;
  id v47;
  _QWORD v48[4];
  id v49;
  int8x16_t v50;
  _QWORD v51[4];
  id v52;
  int8x16_t v53;
  uint8_t buf[16];

  if ((-[NEIKEv2ChildSA generateAllValues]((uint64_t)a1[4]) & 1) != 0)
  {
    v2 = -[NEIKEv2Session copySAsToDeleteAndInstallRekeyedChildSA:](a1[5], a1[4]);
    if (v2)
    {
      v4 = v2;
      v5 = a1[4];
      if (v5)
      {
        objc_setProperty_atomic(v5, v3, a1[7], 192);
        v7 = a1[4];
        if (v7)
          objc_setProperty_atomic(v7, v6, a1[8], 200);
      }
      v8 = a1[5];
      v9 = a1[7];
      v10 = a1[8];
      v44[0] = MEMORY[0x1E0C809B0];
      v44[1] = 3221225472;
      v44[2] = __49__NEIKEv2Session_Exchange__initiateRekeyChildSA___block_invoke_2_317;
      v44[3] = &unk_1E3CC1158;
      v44[4] = v8;
      v11 = v4;
      v45 = v11;
      v46 = a1[4];
      v47 = a1[6];
      -[NEIKEv2Session initiateDeleteChildSPI:remoteSPI:deleteCompletionCallback:](v8, v9, v10, v44);

    }
    else
    {
      ne_log_obj();
      v27 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_19BD16000, v27, OS_LOG_TYPE_ERROR, "Failed to install Child SA", buf, 2u);
      }

      v29 = a1[4];
      v30 = a1[5];
      if (v29)
      {
        Property = objc_getProperty(v29, v28, 56, 1);
        v33 = Property;
        if (Property)
          Property = objc_getProperty(Property, v32, 80, 1);
      }
      else
      {
        v33 = 0;
        Property = 0;
      }
      v35 = Property;
      v36 = a1[4];
      if (v36)
      {
        v37 = objc_getProperty(v36, v34, 56, 1);
        v39 = v37;
        if (v37)
          v37 = objc_getProperty(v37, v38, 88, 1);
      }
      else
      {
        v39 = 0;
        v37 = 0;
      }
      v40 = v37;
      v48[0] = MEMORY[0x1E0C809B0];
      v48[1] = 3221225472;
      v48[2] = __49__NEIKEv2Session_Exchange__initiateRekeyChildSA___block_invoke_316;
      v48[3] = &unk_1E3CC10B8;
      v49 = a1[6];
      v43 = *((int8x16_t *)a1 + 2);
      v41 = (id)v43.i64[0];
      v50 = vextq_s8(v43, v43, 8uLL);
      -[NEIKEv2Session initiateDeleteChildSPI:remoteSPI:deleteCompletionCallback:](v30, v35, v40, v48);

      v11 = 0;
    }
  }
  else
  {
    ne_log_obj();
    v12 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_19BD16000, v12, OS_LOG_TYPE_ERROR, "Failed to generate Child SA crypto values", buf, 2u);
    }

    v14 = a1[4];
    v15 = a1[5];
    if (v14)
    {
      v16 = objc_getProperty(v14, v13, 56, 1);
      v18 = v16;
      if (v16)
        v16 = objc_getProperty(v16, v17, 80, 1);
    }
    else
    {
      v18 = 0;
      v16 = 0;
    }
    v20 = v16;
    v21 = a1[4];
    if (v21)
    {
      v22 = objc_getProperty(v21, v19, 56, 1);
      v24 = v22;
      if (v22)
        v22 = objc_getProperty(v22, v23, 88, 1);
    }
    else
    {
      v24 = 0;
      v22 = 0;
    }
    v25 = v22;
    v51[0] = MEMORY[0x1E0C809B0];
    v51[1] = 3221225472;
    v51[2] = __49__NEIKEv2Session_Exchange__initiateRekeyChildSA___block_invoke_315;
    v51[3] = &unk_1E3CC10B8;
    v52 = a1[6];
    v42 = *((int8x16_t *)a1 + 2);
    v26 = (id)v42.i64[0];
    v53 = vextq_s8(v42, v42, 8uLL);
    -[NEIKEv2Session initiateDeleteChildSPI:remoteSPI:deleteCompletionCallback:](v15, v20, v25, v51);

    v11 = v52;
  }

}

void __49__NEIKEv2Session_Exchange__initiateRekeyChildSA___block_invoke_315(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *ErrorCrypto;
  const char *v11;
  uint64_t v12;

  objc_msgSend(*(id *)(a1 + 32), "sendCallbackSuccess:session:", 0, *(_QWORD *)(a1 + 40));
  v2 = *(_QWORD *)(a1 + 48);
  ErrorCrypto = (void *)NEIKEv2CreateErrorCrypto(CFSTR("Failed to generate Child SA crypto values"), v3, v4, v5, v6, v7, v8, v9, v12);
  -[NEIKEv2ChildSA setState:error:](v2, 3uLL, ErrorCrypto);

  -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 40), v11);
  -[NEIKEv2Session resetChild:](*(char **)(a1 + 40), *(void **)(a1 + 48));
}

void __49__NEIKEv2Session_Exchange__initiateRekeyChildSA___block_invoke_316(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *ErrorInternal;
  const char *v11;
  uint64_t v12;

  objc_msgSend(*(id *)(a1 + 32), "sendCallbackSuccess:session:", 0, *(_QWORD *)(a1 + 40));
  v2 = *(_QWORD *)(a1 + 48);
  ErrorInternal = (void *)NEIKEv2CreateErrorInternal(CFSTR("Failed to install Child SA"), v3, v4, v5, v6, v7, v8, v9, v12);
  -[NEIKEv2ChildSA setState:error:](v2, 3uLL, ErrorInternal);

  -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 40), v11);
  -[NEIKEv2Session resetChild:](*(char **)(a1 + 40), *(void **)(a1 + 48));
}

void __49__NEIKEv2Session_Exchange__initiateRekeyChildSA___block_invoke_2_317(uint64_t a1, int a2)
{
  const char *v3;
  void *v4;
  const char *v5;
  void *v6;
  NSObject *v7;
  const char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void *ErrorInternal;
  const char *v18;
  uint64_t v19;

  if (a2)
  {
    -[NEIKEv2Session uninstallOldRekeyedChildSAs:](*(void **)(a1 + 32), *(void **)(a1 + 40));
    v4 = *(void **)(a1 + 48);
    if (v4)
    {
      objc_setProperty_atomic(v4, v3, 0, 192);
      v6 = *(void **)(a1 + 48);
      if (v6)
        objc_setProperty_atomic(v6, v5, 0, 200);
    }
    ne_log_obj();
    v7 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      LOWORD(v19) = 0;
      _os_log_impl(&dword_19BD16000, v7, OS_LOG_TYPE_INFO, "Rekeyed Child SA", (uint8_t *)&v19, 2u);
    }

    -[NEIKEv2ChildSA setState:error:](*(_QWORD *)(a1 + 48), 2uLL, 0);
    -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 32), v8);
    objc_msgSend(*(id *)(a1 + 56), "sendCallbackSuccess:session:", 1, *(_QWORD *)(a1 + 32));
  }
  else
  {
    objc_msgSend(*(id *)(a1 + 56), "sendCallbackSuccess:session:", 0, *(_QWORD *)(a1 + 32));
    v9 = *(_QWORD *)(a1 + 48);
    ErrorInternal = (void *)NEIKEv2CreateErrorInternal(CFSTR("Failed to delete old Child SA"), v10, v11, v12, v13, v14, v15, v16, v19);
    -[NEIKEv2ChildSA setState:error:](v9, 3uLL, ErrorInternal);

    -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 32), v18);
    -[NEIKEv2Session resetChild:](*(char **)(a1 + 32), *(void **)(a1 + 48));
  }
}

- (void)receiveRekeyChildSA:(void *)a3 packet:
{
  id v5;
  const char *v6;
  id v7;
  NSObject *v8;
  SEL v9;
  const char *v10;
  id v11;
  const char *v12;
  NSObject *v13;
  id v14;
  const char *v15;
  id Property;
  const char *v17;
  void *v18;
  SEL v19;
  id v20;
  const char *v21;
  void *v22;
  SEL v23;
  id *v24;
  const char *v25;
  uint64_t v26;
  id v27;
  uint64_t v28;
  const char *v29;
  void *v30;
  const char *v31;
  void *v32;
  id v33;
  SEL v34;
  id v35;
  id v36;
  const char *v37;
  id v38;
  int v39;
  const char *v40;
  void *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t i;
  _BYTE *v46;
  char v47;
  uint64_t v48;
  uint64_t v49;
  id v50;
  NSObject *v51;
  SEL v52;
  SEL v53;
  id v54;
  const char *v55;
  int *v56;
  void *v57;
  const char *v58;
  void *v59;
  const char *v60;
  void *v61;
  id v62;
  id WeakRetained;
  const char *v64;
  id v65;
  int v66;
  const char *v67;
  void *v68;
  const char *v69;
  void *v70;
  id v71;
  uint64_t v72;
  const char *v73;
  NSObject *v74;
  void *v75;
  const char *v76;
  NSObject *v77;
  uint32_t v78;
  const char *v79;
  NSObject *v80;
  unint64_t v81;
  void *v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  const char *v90;
  NSObject *v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t ErrorPeerInvalidSyntax;
  NSObject *v100;
  NSObject *v101;
  void *v102;
  const char *v103;
  NSObject *v104;
  void *v105;
  const char *v106;
  void *v107;
  id v108;
  id v109;
  const char *v110;
  void *v111;
  const char *v112;
  id v113;
  const char *v114;
  void *v115;
  void *v116;
  const char *v117;
  void *v118;
  id v119;
  SEL v120;
  SEL v121;
  id v122;
  const char *v123;
  void *v124;
  id v125;
  uint64_t v126;
  const char *v127;
  void *v128;
  const char *v129;
  void *v130;
  const char *v131;
  void *v132;
  id v133;
  const char *v134;
  void *v135;
  const char *v136;
  void *v137;
  id v138;
  const char *v139;
  void *v140;
  const char *v141;
  id v142;
  uint64_t v143;
  SEL v144;
  id v145;
  const char *v146;
  void *v147;
  id v148;
  uint64_t v149;
  const char *v150;
  void *v151;
  const char *v152;
  void *v153;
  id v154;
  SEL v155;
  NSObject *v156;
  void *v157;
  void *v158;
  NSObject *v159;
  uint64_t v160;
  SEL v161;
  void *v162;
  const char *v163;
  void *v164;
  SEL v165;
  id v166;
  const char *v167;
  void *v168;
  const char *v169;
  const char *v170;
  id v171;
  const char *v172;
  void *v173;
  id v174;
  uint64_t v175;
  const char *v176;
  id v177;
  void *v178;
  char v179;
  id v180;
  id *v181;
  uint64_t v182;
  const char *v183;
  id v184;
  id v185;
  uint64_t v186;
  NEIKEv2ChildSAPayload *v187;
  SEL v188;
  SEL v189;
  id v190;
  void *v191;
  SEL v192;
  void *v193;
  const char *v194;
  void *v195;
  SEL v196;
  id v197;
  const char *v198;
  void *v199;
  uint64_t v200;
  const char *v201;
  NEIKEv2KeyExchangePayload *v202;
  SEL v203;
  SEL v204;
  id v205;
  const char *v206;
  void *v207;
  SEL v208;
  void *v209;
  const char *v210;
  void *v211;
  SEL v212;
  id v213;
  void *v214;
  void *v215;
  id v216;
  SEL v217;
  void *v218;
  const char *v219;
  void *v220;
  SEL v221;
  void *v222;
  char v223;
  void *v224;
  char v225;
  NEIKEv2NoncePayload *v226;
  SEL v227;
  SEL v228;
  void *v229;
  SEL v230;
  void *v231;
  const char *v232;
  void *v233;
  SEL v234;
  void *v235;
  char v236;
  NEIKEv2InitiatorTrafficSelectorPayload *v237;
  SEL v238;
  SEL v239;
  void *v240;
  SEL v241;
  void *v242;
  const char *v243;
  void *v244;
  SEL v245;
  void *v246;
  char v247;
  NEIKEv2ResponderTrafficSelectorPayload *v248;
  SEL v249;
  SEL v250;
  void *v251;
  SEL v252;
  void *v253;
  const char *v254;
  void *v255;
  SEL v256;
  void *v257;
  char v258;
  const char *v259;
  id v260;
  const char *v261;
  void *v262;
  id v263;
  void *v264;
  void *v265;
  NEIKEv2NotifyPayload *v266;
  SEL v267;
  SEL v268;
  id v269;
  void *v270;
  id v271;
  const char *v272;
  void *v273;
  id v274;
  unsigned int v275;
  void *v276;
  uint64_t v277;
  uint64_t v278;
  uint64_t v279;
  uint64_t v280;
  uint64_t v281;
  uint64_t v282;
  uint64_t v283;
  NSObject *v284;
  uint64_t v285;
  uint64_t v286;
  uint64_t v287;
  uint64_t v288;
  uint64_t v289;
  uint64_t v290;
  uint64_t v291;
  void *ErrorCrypto;
  const char *v293;
  NSObject *v294;
  uint64_t v295;
  uint64_t v296;
  uint64_t v297;
  uint64_t v298;
  uint64_t v299;
  uint64_t v300;
  uint64_t v301;
  __CFString *v302;
  void *v303;
  const char *v304;
  NSObject *v305;
  uint64_t v306;
  uint64_t v307;
  uint64_t v308;
  uint64_t v309;
  uint64_t v310;
  uint64_t v311;
  uint64_t v312;
  uint64_t ErrorFailedToSend;
  NSObject *v314;
  NSObject *v315;
  const char *v316;
  NSObject *v317;
  uint32_t v318;
  const char *v319;
  id v320;
  void *v321;
  void *v322;
  id v323;
  SEL v324;
  SEL v325;
  NSObject *v326;
  uint64_t v327;
  uint64_t v328;
  uint64_t v329;
  uint64_t v330;
  uint64_t v331;
  uint64_t v332;
  uint64_t v333;
  void *ErrorInternal;
  const char *v335;
  const char *v336;
  void *v337;
  NSObject *v338;
  uint64_t v339;
  id v340;
  void *v341;
  uint64_t v342;
  unsigned int v343;
  uint64_t v344;
  id v345;
  unint64_t v346;
  void *v347;
  void *v348;
  NSObject *v349;
  id v350;
  id v351;
  id self;
  id v353;
  _QWORD v354[4];
  id v355;
  id *v356;
  _QWORD *v357;
  NSObject *v358;
  char v359;
  id v360;
  uint8_t v361[4];
  void *v362;
  __int16 v363;
  unint64_t v364;
  __int16 v365;
  uint64_t v366;
  uint8_t buf[128];
  uint8_t v368[16];
  __int128 v369;
  __int128 v370;
  __int128 v371;
  uint64_t v372;

  v372 = *MEMORY[0x1E0C80C00];
  v5 = a2;
  v7 = a3;
  if (a1)
  {
    v8 = objc_getProperty(a1, v6, 368, 1);
    dispatch_assert_queue_V2(v8);

    v11 = objc_getProperty(a1, v9, 336, 1);
    if (v11)
    {
      if (v5)
      {
        if (-[NEIKEv2ChildSA isRekeying](v5, v10))
        {
          ne_log_obj();
          v13 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
          {
            *(_WORD *)buf = 0;
            _os_log_debug_impl(&dword_19BD16000, v13, OS_LOG_TYPE_DEBUG, "Child SA already rekeying, skipping", buf, 2u);
          }
          goto LABEL_68;
        }
        v14 = objc_getProperty(v5, v12, 56, 1);

        if (v14)
        {
          Property = objc_getProperty(v5, v15, 56, 1);
          v18 = Property;
          if (Property)
            Property = objc_getProperty(Property, v17, 80, 1);
          v13 = Property;

          v20 = objc_getProperty(v5, v19, 56, 1);
          v22 = v20;
          if (v20)
            v20 = objc_getProperty(v20, v21, 88, 1);
          v353 = v20;

          objc_setProperty_atomic(v5, v23, 0, 184);
          v24 = (id *)v5;
          if (-[NEIKEv2Packet hasNotification:](v7, (const char *)0x4007))
            v26 = 1;
          else
            v26 = 2;
          v27 = objc_getProperty(v24, v25, 48, 1);
          v28 = objc_msgSend(v27, "mode");

          if (v26 != v28)
          {
            ne_log_obj();
            v80 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v80, OS_LOG_TYPE_ERROR))
            {
              v107 = (void *)objc_msgSend(v7, "copyShortDescription");
              *(_DWORD *)v361 = 138412290;
              v362 = v107;
              _os_log_error_impl(&dword_19BD16000, v80, OS_LOG_TYPE_ERROR, "%@ Transport mode Child SA did not match", v361, 0xCu);

            }
            v81 = 7;
            goto LABEL_51;
          }
          objc_getProperty(v7, v29, 96, 1);
          v30 = (void *)objc_claimAutoreleasedReturnValue();
          v32 = v30;
          self = v7;
          if (v30)
            v30 = objc_getProperty(v30, v31, 24, 1);
          v33 = v30;

          v35 = objc_getProperty(v24, v34, 48, 1);
          objc_msgSend(v35, "proposals");
          v36 = (id)objc_claimAutoreleasedReturnValue();

          if (objc_msgSend(v33, "count"))
          {
            v38 = objc_getProperty(v24, v37, 48, 1);
            v39 = objc_msgSend(v38, "opportunisticPFS");

            v351 = v33;
            if (v39)
            {
              v349 = v13;
              v41 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99E10]), "initWithArray:", v36);
              *(_OWORD *)v368 = 0u;
              v369 = 0u;
              v370 = 0u;
              v371 = 0u;
              v36 = v36;
              v42 = objc_msgSend(v36, "countByEnumeratingWithState:objects:count:", v368, buf, 16);
              if (v42)
              {
                v43 = v42;
                v44 = *(_QWORD *)v369;
                do
                {
                  for (i = 0; i != v43; ++i)
                  {
                    if (*(_QWORD *)v369 != v44)
                      objc_enumerationMutation(v36);
                    v46 = -[NEIKEv2ChildSAProposal copyWithoutKEM](*(void **)(*(_QWORD *)&v368[8] + 8 * i));
                    v47 = objc_msgSend(v41, "count");
                    if (v46)
                      v46[8] = v47 + 1;
                    objc_msgSend(v41, "addObject:", v46);

                  }
                  v43 = objc_msgSend(v36, "countByEnumeratingWithState:objects:count:", v368, buf, 16);
                }
                while (v43);
              }

              v48 = objc_msgSend(v36, "count");
              if (v48 != objc_msgSend(v41, "count"))
              {
                objc_msgSend(v41, "array");
                v49 = objc_claimAutoreleasedReturnValue();

                v36 = (id)v49;
              }
              v33 = v351;

              v13 = v349;
            }
            v50 = objc_getProperty(v24, v40, 48, 1);
            v51 = +[NEIKEv2ChildSAProposal chooseChildSAProposalFromLocalProposals:remoteProposals:preferRemoteProposals:checkKEMethod:]((uint64_t)NEIKEv2ChildSAProposal, v36, v33, objc_msgSend(v50, "preferInitiatorProposalOrder"), 1);
            objc_setProperty_atomic(v24, v52, v51, 184);

            v54 = objc_getProperty(v24, v53, 184, 1);
            if (v54)
            {
              v56 = &OBJC_IVAR___NEIKEv2SessionConfiguration__ppkMandatory;
              objc_getProperty(self, v55, 112, 1);
              v57 = (void *)objc_claimAutoreleasedReturnValue();

              if (v57)
              {
                objc_getProperty(self, v58, 112, 1);
                v59 = (void *)objc_claimAutoreleasedReturnValue();
                v61 = v59;
                if (v59)
                  v59 = objc_getProperty(v59, v60, 24, 1);
                v33 = v351;
                v62 = v59;

                if (v62)
                {
                  WeakRetained = objc_loadWeakRetained(v24 + 3);
                  v350 = WeakRetained;
                  if (WeakRetained)
                    WeakRetained = objc_getProperty(WeakRetained, v64, 80, 1);
                  v65 = WeakRetained;
                  v66 = objc_msgSend(v65, "strictNonceSizeChecks");

                  if (v66)
                  {
                    objc_getProperty(self, v67, 112, 1);
                    v68 = (void *)objc_claimAutoreleasedReturnValue();
                    v70 = v68;
                    if (v68)
                      v68 = objc_getProperty(v68, v69, 24, 1);
                    v71 = v68;
                    v72 = objc_msgSend(v71, "length");

                    v346 = v72;
                    if ((unint64_t)(v72 - 257) <= 0xFFFFFFFFFFFFFF0ELL)
                    {
                      ne_log_obj();
                      v74 = objc_claimAutoreleasedReturnValue();
                      if (os_log_type_enabled(v74, OS_LOG_TYPE_ERROR))
                      {
                        v75 = (void *)objc_msgSend(self, "copyShortDescription");
                        *(_DWORD *)v361 = 138412546;
                        v362 = v75;
                        v363 = 2048;
                        v364 = v72;
                        v76 = "%@ NONCE data length %zu is out of bounds";
                        v77 = v74;
                        v78 = 22;
LABEL_113:
                        _os_log_error_impl(&dword_19BD16000, v77, OS_LOG_TYPE_ERROR, v76, v361, v78);
LABEL_114:

                      }
LABEL_115:

                      v359 = 0;
                      v81 = 7;
                      goto LABEL_122;
                    }
                    v108 = v350;
                    if (v350)
                      v108 = objc_getProperty(v350, v73, 96, 1);
                    v56 = &OBJC_IVAR___NEIKEv2SessionConfiguration__ppkMandatory;
                    v109 = v108;
                    -[NEIKEv2IKESAProposal prfProtocol](v109, v110);
                    v111 = (void *)objc_claimAutoreleasedReturnValue();
                    v343 = objc_msgSend(v111, "nonceSize");

                    if (v346 < v343)
                    {
                      ne_log_obj();
                      v74 = objc_claimAutoreleasedReturnValue();
                      if (os_log_type_enabled(v74, OS_LOG_TYPE_ERROR))
                      {
                        v75 = (void *)objc_msgSend(self, "copyShortDescription");
                        v113 = v350;
                        if (v350)
                          v113 = objc_getProperty(v350, v112, 96, 1);
                        v340 = v113;
                        -[NEIKEv2IKESAProposal prfProtocol](v340, v114);
                        v115 = (void *)objc_claimAutoreleasedReturnValue();
                        *(_DWORD *)v361 = 138412802;
                        v362 = v75;
                        v363 = 2048;
                        v364 = v346;
                        v365 = 2112;
                        v366 = (uint64_t)v115;
                        _os_log_error_impl(&dword_19BD16000, v74, OS_LOG_TYPE_ERROR, "%@ NONCE data length %zu is shorter than the minimum for PRF protocol %@", v361, 0x20u);

                        goto LABEL_114;
                      }
                      goto LABEL_115;
                    }
                  }
                  objc_getProperty(self, v67, v56[289], 1);
                  v116 = (void *)objc_claimAutoreleasedReturnValue();
                  v118 = v116;
                  if (v116)
                    v116 = objc_getProperty(v116, v117, 24, 1);
                  v119 = v116;
                  objc_setProperty_atomic(v24, v120, v119, 88);

                  v122 = objc_getProperty(v24, v121, 184, 1);
                  v124 = v122;
                  if (v122)
                    v122 = objc_getProperty(v122, v123, 112, 1);
                  v125 = v122;
                  v126 = objc_msgSend(v125, "method");

                  if (!v126)
                  {
LABEL_102:
                    v359 = 1;
                    v81 = 7;
                    v33 = v351;
LABEL_122:

                    goto LABEL_123;
                  }
                  objc_getProperty(self, v127, 104, 1);
                  v128 = (void *)objc_claimAutoreleasedReturnValue();

                  if (v128)
                  {
                    objc_getProperty(self, v129, 104, 1);
                    v130 = (void *)objc_claimAutoreleasedReturnValue();
                    v132 = v130;
                    if (v130)
                      v130 = objc_getProperty(v130, v131, 24, 1);
                    v33 = v351;
                    v133 = v130;

                    if (v133)
                    {
                      objc_getProperty(self, v134, 104, 1);
                      v135 = (void *)objc_claimAutoreleasedReturnValue();
                      v137 = v135;
                      if (v135)
                        v135 = objc_getProperty(v135, v136, 32, 1);
                      v138 = v135;

                      if (v138)
                      {
                        objc_getProperty(self, v139, 104, 1);
                        v140 = (void *)objc_claimAutoreleasedReturnValue();
                        v347 = v140;
                        if (v140)
                          v140 = objc_getProperty(v140, v141, 24, 1);
                        v142 = v140;
                        v143 = objc_msgSend(v142, "method");
                        v145 = objc_getProperty(v24, v144, 184, 1);
                        v147 = v145;
                        v341 = v142;
                        v344 = v143;
                        if (v145)
                          v145 = objc_getProperty(v145, v146, 112, 1);
                        v148 = v145;
                        v149 = objc_msgSend(v148, "method");

                        if (v344 == v149)
                        {
                          objc_getProperty(self, v150, 104, 1);
                          v151 = (void *)objc_claimAutoreleasedReturnValue();
                          v153 = v151;
                          if (v151)
                            v151 = objc_getProperty(v151, v152, 32, 1);
                          v154 = v151;
                          objc_setProperty_atomic(v24, v155, v154, 104);

                          goto LABEL_102;
                        }
                        ne_log_obj();
                        v159 = objc_claimAutoreleasedReturnValue();
                        if (os_log_type_enabled(v159, OS_LOG_TYPE_INFO))
                        {
                          v160 = objc_msgSend(self, "copyShortDescription");
                          objc_getProperty(self, v161, 104, 1);
                          v162 = (void *)objc_claimAutoreleasedReturnValue();
                          v348 = v162;
                          v164 = (void *)v160;
                          if (v162)
                            v162 = objc_getProperty(v162, v163, 24, 1);
                          v345 = v162;
                          v342 = objc_msgSend(v345, "method");
                          v166 = objc_getProperty(v24, v165, 184, 1);
                          -[NEIKEv2IKESAProposal kemProtocol](v166, v167);
                          v168 = (void *)objc_claimAutoreleasedReturnValue();
                          *(_DWORD *)v361 = 138412802;
                          v362 = v164;
                          v363 = 2048;
                          v364 = v342;
                          v365 = 2048;
                          v366 = objc_msgSend(v168, "method");
                          _os_log_impl(&dword_19BD16000, v159, OS_LOG_TYPE_INFO, "%@ Received KE method %zu does not match KE method %zu in CHILD SA rekey proposal", v361, 0x20u);

                          v33 = v351;
                        }

LABEL_121:
                        v359 = 0;
                        v81 = 17;
                        goto LABEL_122;
                      }
                      ne_log_obj();
                      v74 = objc_claimAutoreleasedReturnValue();
                      if (!os_log_type_enabled(v74, OS_LOG_TYPE_ERROR))
                        goto LABEL_115;
                      v75 = (void *)objc_msgSend(self, "copyShortDescription");
                      *(_DWORD *)v361 = 138412290;
                      v362 = v75;
                      v76 = "%@ Did not receive data in KE payload";
                    }
                    else
                    {
                      ne_log_obj();
                      v74 = objc_claimAutoreleasedReturnValue();
                      if (!os_log_type_enabled(v74, OS_LOG_TYPE_ERROR))
                        goto LABEL_115;
                      v75 = (void *)objc_msgSend(self, "copyShortDescription");
                      *(_DWORD *)v361 = 138412290;
                      v362 = v75;
                      v76 = "%@ Did not receive method in KE payload";
                    }
                    v77 = v74;
                    v78 = 12;
                    goto LABEL_113;
                  }
                  ne_log_obj();
                  v156 = objc_claimAutoreleasedReturnValue();
                  v33 = v351;
                  if (os_log_type_enabled(v156, OS_LOG_TYPE_ERROR))
                  {
                    v337 = (void *)objc_msgSend(self, "copyShortDescription");
                    *(_DWORD *)v361 = 138412290;
                    v362 = v337;
                    _os_log_error_impl(&dword_19BD16000, v156, OS_LOG_TYPE_ERROR, "%@ Did not receive KE payload", v361, 0xCu);

                  }
                  goto LABEL_121;
                }
                ne_log_obj();
                v100 = objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v100, OS_LOG_TYPE_ERROR))
                {
                  v105 = (void *)objc_msgSend(self, "copyShortDescription");
                  *(_DWORD *)v361 = 138412290;
                  v362 = v105;
                  v106 = "%@ Did not receive NONCE data";
LABEL_107:
                  _os_log_error_impl(&dword_19BD16000, v100, OS_LOG_TYPE_ERROR, v106, v361, 0xCu);

                  goto LABEL_60;
                }
                goto LABEL_60;
              }
              ne_log_obj();
              v104 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v104, OS_LOG_TYPE_ERROR))
              {
                v158 = (void *)objc_msgSend(self, "copyShortDescription");
                *(_DWORD *)v361 = 138412290;
                v362 = v158;
                _os_log_error_impl(&dword_19BD16000, v104, OS_LOG_TYPE_ERROR, "%@ Did not receive NONCE payload", v361, 0xCu);

              }
              v359 = 0;
              v81 = 7;
              v33 = v351;
            }
            else
            {
              ne_log_obj();
              v101 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v101, OS_LOG_TYPE_ERROR))
              {
                v157 = (void *)objc_msgSend(self, "copyShortDescription");
                *(_DWORD *)v361 = 138412290;
                v362 = v157;
                _os_log_error_impl(&dword_19BD16000, v101, OS_LOG_TYPE_ERROR, "%@ No matching rekey proposal found", v361, 0xCu);

              }
              v359 = 0;
              v81 = 14;
            }
LABEL_123:

            if ((v359 & 1) != 0)
            {
              v7 = self;
              if ((-[NEIKEv2ChildSA generateInitialValues](v24) & 1) == 0)
              {
                ne_log_obj();
                v284 = objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v284, OS_LOG_TYPE_ERROR))
                {
                  *(_WORD *)buf = 0;
                  _os_log_error_impl(&dword_19BD16000, v284, OS_LOG_TYPE_ERROR, "Failed to generate local Child crypto values", buf, 2u);
                }

                ErrorCrypto = (void *)NEIKEv2CreateErrorCrypto(CFSTR("Failed to generate local Child crypto values"), v285, v286, v287, v288, v289, v290, v291, v339);
                -[NEIKEv2ChildSA setState:error:]((uint64_t)v24, 3uLL, ErrorCrypto);

                -[NEIKEv2Session reportState](a1, v293);
                -[NEIKEv2Session resetChild:]((char *)a1, v24);
                goto LABEL_67;
              }
              v171 = objc_getProperty(v24, v170, 184, 1);
              v173 = v171;
              if (v171)
                v171 = objc_getProperty(v171, v172, 112, 1);
              v174 = v171;
              v175 = objc_msgSend(v174, "method");

              if (v175 && (-[NEIKEv2ChildSA processCurrentKeyExchange](v24, v176) & 1) == 0)
              {
                ne_log_obj();
                v338 = objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v338, OS_LOG_TYPE_ERROR))
                {
                  *(_WORD *)buf = 0;
                  _os_log_error_impl(&dword_19BD16000, v338, OS_LOG_TYPE_ERROR, "Failed to process KE data", buf, 2u);
                }

                v302 = CFSTR("ailed to process KE data");
              }
              else
              {
                v177 = objc_getProperty(v24, v176, 184, 1);
                v360 = v177;
                objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", &v360, 1);
                v178 = (void *)objc_claimAutoreleasedReturnValue();
                v179 = -[NEIKEv2Session generateSPIForChild:proposals:](a1, v24, v178);

                if ((v179 & 1) != 0)
                {
                  v180 = self;
                  v181 = v24;
                  objc_opt_self();
                  v182 = -[NEIKEv2Packet initResponse:]((uint64_t)[NEIKEv2CreateChildPacket alloc], v180);
                  if (!v182)
                  {
                    ne_log_obj();
                    v314 = objc_claimAutoreleasedReturnValue();
                    if (os_log_type_enabled(v314, OS_LOG_TYPE_FAULT))
                    {
                      *(_WORD *)buf = 0;
                      _os_log_fault_impl(&dword_19BD16000, v314, OS_LOG_TYPE_FAULT, "[[NEIKEv2CreateChildPacket alloc] initResponse:] failed", buf, 2u);
                    }

                    v184 = 0;
                    v270 = 0;
                    goto LABEL_186;
                  }
                  v184 = (id)v182;
                  v185 = objc_getProperty(v181, v183, 48, 1);
                  v186 = objc_msgSend(v185, "mode");

                  if (v186 == 1 && !-[NEIKEv2Packet addNotification:data:](v184, 0x4007uLL, 0))
                  {
                    ne_log_obj();
                    v315 = objc_claimAutoreleasedReturnValue();
                    if (os_log_type_enabled(v315, OS_LOG_TYPE_FAULT))
                    {
                      *(_WORD *)buf = 0;
                      v316 = "[packet addNotification:NEIKEv2NotifyTypeUseTransportMode] failed";
                      v317 = v315;
                      v318 = 2;
LABEL_206:
                      _os_log_fault_impl(&dword_19BD16000, v317, OS_LOG_TYPE_FAULT, v316, buf, v318);
                      goto LABEL_185;
                    }
                    goto LABEL_185;
                  }
                  v187 = objc_alloc_init(NEIKEv2ChildSAPayload);
                  objc_setProperty_atomic(v184, v188, v187, 96);

                  v190 = objc_getProperty(v181, v189, 184, 1);
                  *(_QWORD *)v368 = v190;
                  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v368, 1);
                  v191 = (void *)objc_claimAutoreleasedReturnValue();
                  objc_getProperty(v184, v192, 96, 1);
                  v193 = (void *)objc_claimAutoreleasedReturnValue();
                  v195 = v193;
                  if (v193)
                    objc_setProperty_atomic(v193, v194, v191, 24);

                  v197 = objc_getProperty(v181, v196, 184, 1);
                  -[NEIKEv2IKESAProposal kemProtocol](v197, v198);
                  v199 = (void *)objc_claimAutoreleasedReturnValue();
                  v200 = objc_msgSend(v199, "method");

                  if (v200)
                  {
                    v202 = objc_alloc_init(NEIKEv2KeyExchangePayload);
                    objc_setProperty_atomic(v184, v203, v202, 104);

                    v205 = objc_getProperty(v181, v204, 184, 1);
                    -[NEIKEv2IKESAProposal kemProtocol](v205, v206);
                    v207 = (void *)objc_claimAutoreleasedReturnValue();
                    objc_getProperty(v184, v208, 104, 1);
                    v209 = (void *)objc_claimAutoreleasedReturnValue();
                    v211 = v209;
                    if (v209)
                      objc_setProperty_atomic(v209, v210, v207, 24);

                    v213 = objc_getProperty(v181, v212, 112, 1);
                    v214 = v213;
                    if (v213)
                      v215 = (void *)*((_QWORD *)v213 + 2);
                    else
                      v215 = 0;
                    v216 = v215;
                    objc_getProperty(v184, v217, 104, 1);
                    v218 = (void *)objc_claimAutoreleasedReturnValue();
                    v220 = v218;
                    if (v218)
                      objc_setProperty_atomic(v218, v219, v216, 32);

                    objc_getProperty(v184, v221, 104, 1);
                    v222 = (void *)objc_claimAutoreleasedReturnValue();
                    v223 = -[NEIKEv2Payload isValid]((uint64_t)v222);

                    if ((v223 & 1) == 0)
                    {
                      ne_log_obj();
                      v315 = objc_claimAutoreleasedReturnValue();
                      if (os_log_type_enabled(v315, OS_LOG_TYPE_FAULT))
                      {
                        *(_DWORD *)buf = 136315138;
                        *(_QWORD *)&buf[4] = "+[NEIKEv2CreateChildPacket(Exchange) createRekeyResponse:childSA:]";
                        v316 = "%s called with null packet.ke.isValid";
                        goto LABEL_205;
                      }
                      goto LABEL_185;
                    }
                  }
                  objc_getProperty(v184, v201, 96, 1);
                  v224 = (void *)objc_claimAutoreleasedReturnValue();
                  v225 = -[NEIKEv2Payload isValid]((uint64_t)v224);

                  if ((v225 & 1) != 0)
                  {
                    v226 = objc_alloc_init(NEIKEv2NoncePayload);
                    objc_setProperty_atomic(v184, v227, v226, 112);

                    objc_getProperty(v181, v228, 80, 1);
                    v229 = (void *)objc_claimAutoreleasedReturnValue();
                    objc_getProperty(v184, v230, 112, 1);
                    v231 = (void *)objc_claimAutoreleasedReturnValue();
                    v233 = v231;
                    if (v231)
                      objc_setProperty_atomic(v231, v232, v229, 24);

                    objc_getProperty(v184, v234, 112, 1);
                    v235 = (void *)objc_claimAutoreleasedReturnValue();
                    v236 = -[NEIKEv2Payload isValid]((uint64_t)v235);

                    if ((v236 & 1) != 0)
                    {
                      v237 = objc_alloc_init(NEIKEv2InitiatorTrafficSelectorPayload);
                      objc_setProperty_atomic(v184, v238, v237, 128);

                      objc_getProperty(v181, v239, 72, 1);
                      v240 = (void *)objc_claimAutoreleasedReturnValue();
                      objc_getProperty(v184, v241, 128, 1);
                      v242 = (void *)objc_claimAutoreleasedReturnValue();
                      v244 = v242;
                      if (v242)
                        objc_setProperty_atomic(v242, v243, v240, 24);

                      objc_getProperty(v184, v245, 128, 1);
                      v246 = (void *)objc_claimAutoreleasedReturnValue();
                      v247 = -[NEIKEv2Payload isValid]((uint64_t)v246);

                      if ((v247 & 1) != 0)
                      {
                        v248 = objc_alloc_init(NEIKEv2ResponderTrafficSelectorPayload);
                        objc_setProperty_atomic(v184, v249, v248, 136);

                        objc_getProperty(v181, v250, 64, 1);
                        v251 = (void *)objc_claimAutoreleasedReturnValue();
                        objc_getProperty(v184, v252, 136, 1);
                        v253 = (void *)objc_claimAutoreleasedReturnValue();
                        v255 = v253;
                        if (v253)
                          objc_setProperty_atomic(v253, v254, v251, 24);

                        objc_getProperty(v184, v256, 136, 1);
                        v257 = (void *)objc_claimAutoreleasedReturnValue();
                        v258 = -[NEIKEv2Payload isValid]((uint64_t)v257);

                        if ((v258 & 1) != 0)
                        {
                          v260 = objc_getProperty(v181, v259, 184, 1);
                          v262 = v260;
                          if (v260)
                            v260 = objc_getProperty(v260, v261, 120, 1);
                          v263 = v260;

                          if (v263)
                          {
                            objc_msgSend(MEMORY[0x1E0CB3A28], "UUID");
                            v264 = (void *)objc_claimAutoreleasedReturnValue();
                            *(_OWORD *)buf = 0uLL;
                            objc_msgSend(v264, "getUUIDBytes:", buf);
                            v265 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99D50]), "initWithBytes:length:", buf, 16);
                            v266 = +[NEIKEv2NotifyPayload createNotifyPayloadType:data:]((uint64_t)NEIKEv2NotifyPayload, 0x4039uLL, v265);
                            objc_setProperty_atomic(v181, v267, v266, 128);

                            v269 = objc_getProperty(v181, v268, 128, 1);
                            -[NEIKEv2Packet addNotifyPayload:](v184, v269);

                          }
                          v184 = v184;
                          v270 = v184;
                          goto LABEL_186;
                        }
                        ne_log_obj();
                        v315 = objc_claimAutoreleasedReturnValue();
                        if (os_log_type_enabled(v315, OS_LOG_TYPE_FAULT))
                        {
                          *(_DWORD *)buf = 136315138;
                          *(_QWORD *)&buf[4] = "+[NEIKEv2CreateChildPacket(Exchange) createRekeyResponse:childSA:]";
                          v316 = "%s called with null packet.tsr.isValid";
                          goto LABEL_205;
                        }
                        goto LABEL_185;
                      }
                      ne_log_obj();
                      v315 = objc_claimAutoreleasedReturnValue();
                      if (!os_log_type_enabled(v315, OS_LOG_TYPE_FAULT))
                        goto LABEL_185;
                      *(_DWORD *)buf = 136315138;
                      *(_QWORD *)&buf[4] = "+[NEIKEv2CreateChildPacket(Exchange) createRekeyResponse:childSA:]";
                      v336 = "%s called with null packet.tsi.isValid";
                    }
                    else
                    {
                      ne_log_obj();
                      v315 = objc_claimAutoreleasedReturnValue();
                      if (!os_log_type_enabled(v315, OS_LOG_TYPE_FAULT))
                        goto LABEL_185;
                      *(_DWORD *)buf = 136315138;
                      *(_QWORD *)&buf[4] = "+[NEIKEv2CreateChildPacket(Exchange) createRekeyResponse:childSA:]";
                      v336 = "%s called with null packet.nonce.isValid";
                    }
                    _os_log_fault_impl(&dword_19BD16000, v315, OS_LOG_TYPE_FAULT, v336, buf, 0xCu);
                    goto LABEL_185;
                  }
                  ne_log_obj();
                  v315 = objc_claimAutoreleasedReturnValue();
                  if (os_log_type_enabled(v315, OS_LOG_TYPE_FAULT))
                  {
                    *(_DWORD *)buf = 136315138;
                    *(_QWORD *)&buf[4] = "+[NEIKEv2CreateChildPacket(Exchange) createRekeyResponse:childSA:]";
                    v316 = "%s called with null packet.childSA.isValid";
LABEL_205:
                    v317 = v315;
                    v318 = 12;
                    goto LABEL_206;
                  }
LABEL_185:

                  v270 = 0;
LABEL_186:

                  if (v270)
                  {
                    v320 = objc_getProperty(v181, v319, 112, 1);
                    v321 = v320;
                    v7 = self;
                    if (v320)
                      v322 = (void *)*((_QWORD *)v320 + 3);
                    else
                      v322 = 0;
                    v323 = v322;
                    objc_setProperty_atomic(v181, v324, v323, 120);

                    objc_setProperty_atomic(v181, v325, 0, 112);
                    v354[0] = MEMORY[0x1E0C809B0];
                    v354[1] = 3221225472;
                    v354[2] = __55__NEIKEv2Session_Exchange__receiveRekeyChildSA_packet___block_invoke;
                    v354[3] = &unk_1E3CC11F8;
                    v355 = v353;
                    v356 = v181;
                    v357 = a1;
                    v358 = v13;
                    -[NEIKEv2Session handleFollowupKEForRekeyChildSAResponder:iteration:replyPacket:replyPacketDescription:handler:](a1, v356, 0, v270, CFSTR("responder rekey child SA reply"), v354);

                  }
                  else
                  {
                    ne_log_obj();
                    v326 = objc_claimAutoreleasedReturnValue();
                    v7 = self;
                    if (os_log_type_enabled(v326, OS_LOG_TYPE_ERROR))
                    {
                      *(_WORD *)buf = 0;
                      _os_log_error_impl(&dword_19BD16000, v326, OS_LOG_TYPE_ERROR, "Failed to create Create Child SA packet", buf, 2u);
                    }

                    ErrorInternal = (void *)NEIKEv2CreateErrorInternal(CFSTR("Failed to create Create Child SA packet"), v327, v328, v329, v330, v331, v332, v333, v339);
                    -[NEIKEv2ChildSA setState:error:]((uint64_t)v181, 3uLL, ErrorInternal);

                    -[NEIKEv2Session reportState](a1, v335);
                    -[NEIKEv2Session resetChild:]((char *)a1, v181);
                  }

                  goto LABEL_67;
                }
                ne_log_obj();
                v294 = objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v294, OS_LOG_TYPE_ERROR))
                {
                  *(_WORD *)buf = 0;
                  _os_log_error_impl(&dword_19BD16000, v294, OS_LOG_TYPE_ERROR, "Failed to generate Child SA SPI", buf, 2u);
                }

                v302 = CFSTR("Failed to generate Child SA SPI");
              }
              v303 = (void *)NEIKEv2CreateErrorCrypto(v302, v295, v296, v297, v298, v299, v300, v301, v339);
              -[NEIKEv2ChildSA setState:error:]((uint64_t)v24, 3uLL, v303);

              -[NEIKEv2Session reportState](a1, v304);
              -[NEIKEv2Session resetChild:]((char *)a1, v24);
              v7 = self;
LABEL_67:

              goto LABEL_68;
            }
            v7 = self;
            if (v81 == 17)
            {
              v271 = objc_getProperty(v24, v169, 184, 1);
              v273 = v271;
              if (v271)
                v271 = objc_getProperty(v271, v272, 112, 1);
              v274 = v271;
              v275 = bswap32(objc_msgSend(v274, "method")) >> 16;

              *(_WORD *)buf = v275;
              v276 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99D50]), "initWithBytes:length:", buf, 2);
              +[NEIKEv2CreateChildPacket createChildSAResponse:errorCode:errorData:]((uint64_t)NEIKEv2CreateChildPacket, self, 0x11uLL, v276);
              v82 = (void *)objc_claimAutoreleasedReturnValue();

              if (v82)
              {
                if ((-[NEIKEv2Session sendReply:replyHandler:]((uint64_t)a1, v82, 0) & 1) != 0)
                {

                  v7 = self;
                  goto LABEL_164;
                }
                ErrorFailedToSend = NEIKEv2CreateErrorFailedToSend(CFSTR("rekey child SA refusal"), v277, v278, v279, v280, v281, v282, v283, v339);
              }
              else
              {
                ne_log_obj();
                v305 = objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v305, OS_LOG_TYPE_ERROR))
                {
                  *(_WORD *)v368 = 0;
                  _os_log_error_impl(&dword_19BD16000, v305, OS_LOG_TYPE_ERROR, "Failed to create Create Child SA packet", v368, 2u);
                }

                ErrorFailedToSend = NEIKEv2CreateErrorInternal(CFSTR("Failed to create Create Child SA packet"), v306, v307, v308, v309, v310, v311, v312, v339);
              }
              v102 = (void *)ErrorFailedToSend;
              v7 = self;
              goto LABEL_66;
            }
LABEL_51:
            +[NEIKEv2CreateChildPacket createChildSAResponse:errorCode:errorData:]((uint64_t)NEIKEv2CreateChildPacket, v7, v81, 0);
            v82 = (void *)objc_claimAutoreleasedReturnValue();
            if (v82)
            {
              if ((-[NEIKEv2Session sendReply:replyHandler:]((uint64_t)a1, v82, 0) & 1) != 0)
              {
                if (v81 == 14)
                {

LABEL_164:
                  objc_setProperty_atomic(v24, v90, 0, 184);
                  goto LABEL_67;
                }
                ErrorPeerInvalidSyntax = NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("Failed to process Create Child SA packet"), v83, v84, v85, v86, v87, v88, v89, v339);
              }
              else
              {
                ErrorPeerInvalidSyntax = NEIKEv2CreateErrorFailedToSend(CFSTR("rekey child SA refusal"), v83, v84, v85, v86, v87, v88, v89, v339);
              }
            }
            else
            {
              ne_log_obj();
              v91 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v91, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)buf = 0;
                _os_log_error_impl(&dword_19BD16000, v91, OS_LOG_TYPE_ERROR, "Failed to create Create Child SA packet", buf, 2u);
              }

              ErrorPeerInvalidSyntax = NEIKEv2CreateErrorInternal(CFSTR("Failed to create Create Child SA packet"), v92, v93, v94, v95, v96, v97, v98, v339);
            }
            v102 = (void *)ErrorPeerInvalidSyntax;
LABEL_66:
            -[NEIKEv2ChildSA setState:error:]((uint64_t)v24, 3uLL, v102);

            -[NEIKEv2Session reportState](a1, v103);
            -[NEIKEv2Session resetChild:]((char *)a1, v24);

            goto LABEL_67;
          }
          ne_log_obj();
          v100 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v100, OS_LOG_TYPE_ERROR))
          {
            v105 = (void *)objc_msgSend(self, "copyShortDescription");
            *(_DWORD *)v361 = 138412290;
            v362 = v105;
            v106 = "%@ Received no SA proposals";
            goto LABEL_107;
          }
LABEL_60:

          v359 = 0;
          v81 = 7;
          goto LABEL_123;
        }
        ne_log_obj();
        v13 = objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled(v13, OS_LOG_TYPE_FAULT))
        {
LABEL_68:

          goto LABEL_69;
        }
        *(_DWORD *)buf = 136315138;
        *(_QWORD *)&buf[4] = "-[NEIKEv2Session(Exchange) receiveRekeyChildSA:packet:]";
        v79 = "%s called with null childSA.chosenProposal";
      }
      else
      {
        ne_log_obj();
        v13 = objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled(v13, OS_LOG_TYPE_FAULT))
          goto LABEL_68;
        *(_DWORD *)buf = 136315138;
        *(_QWORD *)&buf[4] = "-[NEIKEv2Session(Exchange) receiveRekeyChildSA:packet:]";
        v79 = "%s called with null childSA";
      }
    }
    else
    {
      ne_log_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v13, OS_LOG_TYPE_FAULT))
        goto LABEL_68;
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = "-[NEIKEv2Session(Exchange) receiveRekeyChildSA:packet:]";
      v79 = "%s called with null ikeSA";
    }
    _os_log_fault_impl(&dword_19BD16000, v13, OS_LOG_TYPE_FAULT, v79, buf, 0xCu);
    goto LABEL_68;
  }
LABEL_69:

}

void __55__NEIKEv2Session_Exchange__receiveRekeyChildSA_packet___block_invoke(uint64_t a1, void *a2)
{
  id v3;
  const char *v4;
  id Property;
  const char *v6;
  id v7;
  void *v8;
  const char *v9;
  void *v10;
  uint64_t v11;
  id v12;
  void *v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void *ErrorFailedToSend;
  const char *v24;
  NSObject *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  void *ErrorPeerInvalidSyntax;
  NSObject *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  void *v43;
  const char *v44;
  NSObject *v45;
  const char *v46;
  void *v47;
  _QWORD *v48;
  id v49;
  const char *v50;
  void *v51;
  const char *v52;
  id v53;
  void *v54;
  id v55;
  const char *v56;
  void *v57;
  id v58;
  id v59;
  uint64_t v60;
  NSObject *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  void *ErrorInternal;
  const char *v71;
  uint64_t v72[4];
  id v73;
  uint64_t v74;
  uint8_t buf[16];

  v3 = a2;
  if ((-[NEIKEv2InformationalPacket validateDeleteChild:]((uint64_t)v3, *(void **)(a1 + 32)) & 1) == 0)
  {
    ne_log_obj();
    v25 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_19BD16000, v25, OS_LOG_TYPE_ERROR, "Failed to process Rekey Child SA Delete packet", buf, 2u);
    }

    v26 = *(_QWORD *)(a1 + 40);
    ErrorPeerInvalidSyntax = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("Failed to process Rekey Child SA Delete packet"), v27, v28, v29, v30, v31, v32, v33, v72[0]);
    goto LABEL_20;
  }
  Property = *(id *)(a1 + 40);
  if (Property)
    Property = objc_getProperty(Property, v4, 184, 1);
  v7 = Property;
  v8 = *(void **)(a1 + 40);
  if (v8)
    objc_setProperty_atomic(v8, v6, v7, 56);

  v10 = *(void **)(a1 + 40);
  if (v10)
  {
    objc_setProperty_atomic(v10, v9, 0, 184);
    v11 = *(_QWORD *)(a1 + 40);
    if (v11)
    {
      *(_BYTE *)(v11 + 9) = 0;
      v10 = *(void **)(a1 + 40);
    }
    else
    {
      v10 = 0;
    }
  }
  if ((-[NEIKEv2ChildSA generateAllValues]((uint64_t)v10) & 1) == 0)
  {
    ne_log_obj();
    v35 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_19BD16000, v35, OS_LOG_TYPE_ERROR, "Failed to generate Child SA crypto values", buf, 2u);
    }

    v26 = *(_QWORD *)(a1 + 40);
    ErrorPeerInvalidSyntax = (void *)NEIKEv2CreateErrorCrypto(CFSTR("Failed to generate Child SA crypto values"), v36, v37, v38, v39, v40, v41, v42, v72[0]);
LABEL_20:
    v43 = ErrorPeerInvalidSyntax;
    -[NEIKEv2ChildSA setState:error:](v26, 3uLL, ErrorPeerInvalidSyntax);

    -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 48), v44);
    -[NEIKEv2Session resetChild:](*(char **)(a1 + 48), *(void **)(a1 + 40));
    goto LABEL_34;
  }
  v12 = -[NEIKEv2Session copySAsToDeleteAndInstallRekeyedChildSA:](*(id *)(a1 + 48), *(void **)(a1 + 40));
  if (v12)
  {
    -[NEIKEv2Session uninstallOldRekeyedChildSAs:](*(void **)(a1 + 48), v12);
    +[NEIKEv2InformationalPacket createDeleteResponse:child:]((uint64_t)NEIKEv2InformationalPacket, v3, *(void **)(a1 + 56));
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    if (v13)
    {
      v14 = v13;
      if ((-[NEIKEv2Session sendReply:replyHandler:](*(_QWORD *)(a1 + 48), v13, 0) & 1) == 0)
      {
        v22 = *(_QWORD *)(a1 + 40);
        ErrorFailedToSend = (void *)NEIKEv2CreateErrorFailedToSend(CFSTR("delete child SA for rekey"), v15, v16, v17, v18, v19, v20, v21, v72[0]);
        -[NEIKEv2ChildSA setState:error:](v22, 3uLL, ErrorFailedToSend);

        -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 48), v24);
        -[NEIKEv2Session resetChild:](*(char **)(a1 + 48), *(void **)(a1 + 40));
      }
    }
    else
    {
      ne_log_obj();
      v61 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_19BD16000, v61, OS_LOG_TYPE_ERROR, "Failed to create Child SA Delete packet", buf, 2u);
      }

      v62 = *(_QWORD *)(a1 + 40);
      ErrorInternal = (void *)NEIKEv2CreateErrorInternal(CFSTR("Failed to create Child SA Delete packet"), v63, v64, v65, v66, v67, v68, v69, v72[0]);
      -[NEIKEv2ChildSA setState:error:](v62, 3uLL, ErrorInternal);

      -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 48), v71);
      -[NEIKEv2Session resetChild:](*(char **)(a1 + 48), *(void **)(a1 + 40));
      v14 = 0;
    }
  }
  else
  {
    ne_log_obj();
    v45 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_19BD16000, v45, OS_LOG_TYPE_ERROR, "Failed to install Child SA", buf, 2u);
    }

    v47 = *(void **)(a1 + 40);
    v48 = *(_QWORD **)(a1 + 48);
    if (v47)
    {
      v49 = objc_getProperty(v47, v46, 56, 1);
      v51 = v49;
      if (v49)
        v49 = objc_getProperty(v49, v50, 80, 1);
    }
    else
    {
      v51 = 0;
      v49 = 0;
    }
    v53 = v49;
    v54 = *(void **)(a1 + 40);
    if (v54)
    {
      v55 = objc_getProperty(v54, v52, 56, 1);
      v57 = v55;
      if (v55)
        v55 = objc_getProperty(v55, v56, 88, 1);
    }
    else
    {
      v57 = 0;
      v55 = 0;
    }
    v58 = v55;
    v72[0] = MEMORY[0x1E0C809B0];
    v72[1] = 3221225472;
    v72[2] = (uint64_t)__55__NEIKEv2Session_Exchange__receiveRekeyChildSA_packet___block_invoke_331;
    v72[3] = (uint64_t)&unk_1E3CC0EB0;
    v59 = *(id *)(a1 + 40);
    v60 = *(_QWORD *)(a1 + 48);
    v73 = v59;
    v74 = v60;
    -[NEIKEv2Session initiateDeleteChildSPI:remoteSPI:deleteCompletionCallback:](v48, v53, v58, v72);

    v14 = v73;
  }

LABEL_34:
}

void __55__NEIKEv2Session_Exchange__receiveRekeyChildSA_packet___block_invoke_331(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  void *ErrorInternal;
  const char *v11;
  uint64_t v12;

  v9 = *(_QWORD *)(a1 + 32);
  ErrorInternal = (void *)NEIKEv2CreateErrorInternal(CFSTR("Failed to install Child SA"), a2, a3, a4, a5, a6, a7, a8, v12);
  -[NEIKEv2ChildSA setState:error:](v9, 3uLL, ErrorInternal);

  -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 40), v11);
  -[NEIKEv2Session resetChild:](*(char **)(a1 + 40), *(void **)(a1 + 32));
}

- (void)handleFollowupKEForRekeyIKESAInitiator:(void *)a3 rekeyIKEContext:(unint64_t)a4 iteration:(void *)a5 handler:
{
  id v9;
  id v10;
  const char *v11;
  void (**v12)(_QWORD);
  NSObject *v13;
  const char *v14;
  id Property;
  const char *v16;
  void *v17;
  id v18;
  unint64_t v19;
  const char *v20;
  const char *v21;
  id v22;
  id v23;
  const char *v24;
  void *v25;
  id v26;
  const char *v27;
  void *v28;
  id v29;
  const char *v30;
  void *v31;
  id v32;
  void *v33;
  const char *v34;
  id v35;
  id v36;
  void *v37;
  void *v38;
  NSObject *v39;
  NEIKEv2KeyExchangePayload *v40;
  const char *v41;
  NEIKEv2KeyExchangePayload *v42;
  SEL v43;
  id v44;
  const char *v45;
  void *v46;
  const char *v47;
  id v48;
  void *v49;
  void *v50;
  const char *v51;
  id v52;
  id v53;
  const char *v54;
  void *v55;
  const char *v56;
  id v57;
  id v58;
  const char *v59;
  void *v60;
  SEL v61;
  id v62;
  id v63;
  char v64;
  id v65;
  SEL v66;
  id v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  void *ErrorFailedToSend;
  const char *v76;
  const char *v77;
  NSObject *v78;
  NEIKEv2DeleteIKEContext *v79;
  SEL v80;
  id v81;
  id *v82;
  NSObject *v83;
  NEIKEv2DeleteIKEContext *v84;
  SEL v85;
  id v86;
  id *v87;
  NSObject *v88;
  NEIKEv2DeleteIKEContext *v89;
  SEL v90;
  id v91;
  id *v92;
  void *v93;
  _QWORD v94[5];
  id v95;
  id v96;
  id v97;
  void (**v98)(_QWORD);
  unint64_t v99;
  _QWORD v100[4];
  id v101;
  _QWORD *v102;
  _QWORD v103[4];
  NSObject *v104;
  _QWORD *v105;
  id v106;
  _QWORD v107[4];
  NSObject *v108;
  _QWORD *v109;
  id v110;
  uint8_t buf[4];
  _QWORD *v112;
  __int16 v113;
  void *v114;
  uint64_t v115;

  v115 = *MEMORY[0x1E0C80C00];
  v9 = a2;
  v10 = a3;
  v12 = a5;
  if (a1)
  {
    v13 = objc_getProperty(a1, v11, 368, 1);
    dispatch_assert_queue_V2(v13);

    if (v9)
    {
      Property = objc_getProperty(v9, v14, 96, 1);
      v17 = Property;
      if (Property)
        Property = objc_getProperty(Property, v16, 120, 1);
    }
    else
    {
      v17 = 0;
      Property = 0;
    }
    v18 = Property;
    v19 = objc_msgSend(v18, "count");

    if (v19 > a4)
    {
      if (!a4)
      {
        v22 = objc_alloc(MEMORY[0x1E0C99DE8]);
        if (v9)
        {
          v23 = objc_getProperty(v9, v21, 96, 1);
          v25 = v23;
          if (v23)
            v23 = objc_getProperty(v23, v24, 120, 1);
        }
        else
        {
          v25 = 0;
          v23 = 0;
        }
        v26 = v23;
        v28 = (void *)objc_msgSend(v22, "initWithCapacity:", objc_msgSend(v26, "count"));
        if (v9)
          objc_setProperty_atomic(v9, v27, v28, 184);

      }
      if (v9)
      {
        v29 = objc_getProperty(v9, v20, 96, 1);
        v31 = v29;
        if (v29)
          v29 = objc_getProperty(v29, v30, 120, 1);
      }
      else
      {
        v31 = 0;
        v29 = 0;
      }
      v32 = v29;
      objc_msgSend(v32, "objectAtIndexedSubscript:", a4);
      v33 = (void *)objc_claimAutoreleasedReturnValue();

      if (v9)
        v35 = objc_getProperty(v9, v34, 96, 1);
      else
        v35 = 0;
      v36 = v35;
      -[NEIKEv2IKESAProposal chosenAdditionalKEMProtocols](v36);
      v37 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v37, "objectForKeyedSubscript:", v33);
      v38 = (void *)objc_claimAutoreleasedReturnValue();

      if (!v38)
      {
        ne_log_obj();
        v83 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v83, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 138412546;
          v112 = a1;
          v113 = 2112;
          v114 = v33;
          _os_log_error_impl(&dword_19BD16000, v83, OS_LOG_TYPE_ERROR, "%@ No chosen KEM found for transform type %@ (initiator rekey followup KE)", buf, 0x16u);
        }

        v84 = [NEIKEv2DeleteIKEContext alloc];
        v86 = objc_getProperty(a1, v85, 368, 1);
        v107[0] = MEMORY[0x1E0C809B0];
        v107[1] = 3221225472;
        v107[2] = __101__NEIKEv2Session_Exchange__handleFollowupKEForRekeyIKESAInitiator_rekeyIKEContext_iteration_handler___block_invoke;
        v107[3] = &unk_1E3CC10B8;
        v108 = v10;
        v109 = a1;
        v110 = v33;
        v87 = -[NEIKEv2DeleteIKEContext initDeleteIKEWithResponse:callbackQueue:callback:]((id *)&v84->super.super.isa, 0, v86, v107);

        -[NEIKEv2Session initiateDelete:](a1, v87);
        v39 = v108;
        goto LABEL_43;
      }
      if ((-[NEIKEv2IKESA generateLocalValuesForKEMProtocol:](v9, v38) & 1) == 0)
      {
        ne_log_obj();
        v88 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v88, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 138412546;
          v112 = a1;
          v113 = 2112;
          v114 = v38;
          _os_log_error_impl(&dword_19BD16000, v88, OS_LOG_TYPE_ERROR, "%@ Failed to generate values for KEM %@ (initiator rekey followup KE)", buf, 0x16u);
        }

        v89 = [NEIKEv2DeleteIKEContext alloc];
        v91 = objc_getProperty(a1, v90, 368, 1);
        v103[0] = MEMORY[0x1E0C809B0];
        v103[1] = 3221225472;
        v103[2] = __101__NEIKEv2Session_Exchange__handleFollowupKEForRekeyIKESAInitiator_rekeyIKEContext_iteration_handler___block_invoke_339;
        v103[3] = &unk_1E3CC10B8;
        v104 = v10;
        v105 = a1;
        v106 = v38;
        v92 = -[NEIKEv2DeleteIKEContext initDeleteIKEWithResponse:callbackQueue:callback:]((id *)&v89->super.super.isa, 0, v91, v103);

        -[NEIKEv2Session initiateDelete:](a1, v92);
        v39 = v104;
        goto LABEL_43;
      }
      v93 = v33;
      v39 = -[NEIKEv2Packet initOutbound]([NEIKEv2FollowupKEPacket alloc]);
      v40 = objc_alloc_init(NEIKEv2KeyExchangePayload);
      v42 = v40;
      if (v39)
      {
        objc_setProperty_atomic(v39, v41, v40, 88);

        v44 = objc_getProperty(v39, v43, 88, 1);
        v46 = v44;
        if (v44)
          objc_setProperty_atomic(v44, v45, v38, 24);
      }
      else
      {

        v46 = 0;
      }

      if (v9)
      {
        v48 = objc_getProperty(v9, v47, 160, 1);
        v49 = v48;
        if (v48)
        {
          v50 = (void *)*((_QWORD *)v48 + 2);
LABEL_26:
          v52 = v50;
          if (v39)
          {
            v53 = objc_getProperty(v39, v51, 88, 1);
            v55 = v53;
            if (v53)
              objc_setProperty_atomic(v53, v54, v52, 32);
          }
          else
          {
            v55 = 0;
          }

          if (v9)
            v57 = objc_getProperty(v9, v56, 176, 1);
          else
            v57 = 0;
          v58 = v57;
          v60 = v58;
          if (v39)
          {
            objc_setProperty_atomic(v39, v59, v58, 96);

            v62 = objc_getProperty(v39, v61, 88, 1);
          }
          else
          {

            v62 = 0;
          }
          v63 = v62;
          v64 = -[NEIKEv2Payload isValid]((uint64_t)v63);

          if ((v64 & 1) != 0)
          {
            v94[0] = MEMORY[0x1E0C809B0];
            v94[1] = 3221225472;
            v94[2] = __101__NEIKEv2Session_Exchange__handleFollowupKEForRekeyIKESAInitiator_rekeyIKEContext_iteration_handler___block_invoke_2;
            v94[3] = &unk_1E3CC1130;
            v94[4] = a1;
            v65 = v10;
            v95 = v65;
            v96 = v38;
            v97 = v9;
            v99 = a4;
            v98 = v12;
            if (-[NEIKEv2Session sendRequest:retry:replyHandler:]((uint64_t)a1, v39, v94) == -1)
            {
              objc_msgSend(v65, "sendCallbackSuccess:session:", 0, a1);
              v67 = objc_getProperty(a1, v66, 336, 1);
              ErrorFailedToSend = (void *)NEIKEv2CreateErrorFailedToSend(CFSTR("initiator rekey FOLLOWUP_KE #%zu"), v68, v69, v70, v71, v72, v73, v74, a4 + 1);
              -[NEIKEv2IKESA setState:error:]((uint64_t)v67, 3uLL, ErrorFailedToSend);

              -[NEIKEv2Session reportState](a1, v76);
              -[NEIKEv2Session resetAll]((uint64_t)a1, v77);
            }

            v33 = v93;
          }
          else
          {
            ne_log_obj();
            v78 = objc_claimAutoreleasedReturnValue();
            v33 = v93;
            if (os_log_type_enabled(v78, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 138412290;
              v112 = a1;
              _os_log_error_impl(&dword_19BD16000, v78, OS_LOG_TYPE_ERROR, "%@ Failed to create FOLLOWUP_KE packet (initiator rekey followup KE)", buf, 0xCu);
            }

            v79 = [NEIKEv2DeleteIKEContext alloc];
            v81 = objc_getProperty(a1, v80, 368, 1);
            v100[0] = MEMORY[0x1E0C809B0];
            v100[1] = 3221225472;
            v100[2] = __101__NEIKEv2Session_Exchange__handleFollowupKEForRekeyIKESAInitiator_rekeyIKEContext_iteration_handler___block_invoke_342;
            v100[3] = &unk_1E3CC0EB0;
            v101 = v10;
            v102 = a1;
            v82 = -[NEIKEv2DeleteIKEContext initDeleteIKEWithResponse:callbackQueue:callback:]((id *)&v79->super.super.isa, 0, v81, v100);

            -[NEIKEv2Session initiateDelete:](a1, v82);
          }
LABEL_43:

          goto LABEL_44;
        }
      }
      else
      {
        v49 = 0;
      }
      v50 = 0;
      goto LABEL_26;
    }
    if (v9)
      objc_setProperty_atomic(v9, v20, 0, 176);
    v12[2](v12);
  }
LABEL_44:

}

void __101__NEIKEv2Session_Exchange__handleFollowupKEForRekeyIKESAInitiator_rekeyIKEContext_iteration_handler___block_invoke(uint64_t a1)
{
  const char *v2;
  id Property;
  id v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *ErrorInternal;
  const char *v13;
  const char *v14;

  objc_msgSend(*(id *)(a1 + 32), "sendCallbackSuccess:session:", 0, *(_QWORD *)(a1 + 40));
  Property = *(id *)(a1 + 40);
  if (Property)
    Property = objc_getProperty(Property, v2, 336, 1);
  v4 = Property;
  ErrorInternal = (void *)NEIKEv2CreateErrorInternal(CFSTR("No chosen KEM found for transform type %@ (initiator rekey followup KE)"), v5, v6, v7, v8, v9, v10, v11, *(_QWORD *)(a1 + 48));
  -[NEIKEv2IKESA setState:error:]((uint64_t)v4, 3uLL, ErrorInternal);

  -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 40), v13);
  -[NEIKEv2Session resetAll](*(_QWORD *)(a1 + 40), v14);
}

void __101__NEIKEv2Session_Exchange__handleFollowupKEForRekeyIKESAInitiator_rekeyIKEContext_iteration_handler___block_invoke_339(uint64_t a1)
{
  const char *v2;
  id Property;
  id v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *ErrorInternal;
  const char *v13;
  const char *v14;

  objc_msgSend(*(id *)(a1 + 32), "sendCallbackSuccess:session:", 0, *(_QWORD *)(a1 + 40));
  Property = *(id *)(a1 + 40);
  if (Property)
    Property = objc_getProperty(Property, v2, 336, 1);
  v4 = Property;
  ErrorInternal = (void *)NEIKEv2CreateErrorInternal(CFSTR("Failed to generate values for KEM %@ (initiator rekey followup KE)"), v5, v6, v7, v8, v9, v10, v11, *(_QWORD *)(a1 + 48));
  -[NEIKEv2IKESA setState:error:]((uint64_t)v4, 3uLL, ErrorInternal);

  -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 40), v13);
  -[NEIKEv2Session resetAll](*(_QWORD *)(a1 + 40), v14);
}

void __101__NEIKEv2Session_Exchange__handleFollowupKEForRekeyIKESAInitiator_rekeyIKEContext_iteration_handler___block_invoke_342(uint64_t a1)
{
  const char *v2;
  id Property;
  id v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *ErrorInternal;
  const char *v13;
  const char *v14;
  uint64_t v15;

  objc_msgSend(*(id *)(a1 + 32), "sendCallbackSuccess:session:", 0, *(_QWORD *)(a1 + 40));
  Property = *(id *)(a1 + 40);
  if (Property)
    Property = objc_getProperty(Property, v2, 336, 1);
  v4 = Property;
  ErrorInternal = (void *)NEIKEv2CreateErrorInternal(CFSTR("Failed to create FOLLOWUP_KE packet (initiator rekey followup KE)"), v5, v6, v7, v8, v9, v10, v11, v15);
  -[NEIKEv2IKESA setState:error:]((uint64_t)v4, 3uLL, ErrorInternal);

  -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 40), v13);
  -[NEIKEv2Session resetAll](*(_QWORD *)(a1 + 40), v14);
}

void __101__NEIKEv2Session_Exchange__handleFollowupKEForRekeyIKESAInitiator_rekeyIKEContext_iteration_handler___block_invoke_2(uint64_t a1, void *a2)
{
  id v3;
  id Property;
  const char *v5;
  id v6;
  id v7;
  const char *v8;
  id v9;
  const char *v10;
  void *v11;
  id v12;
  const char *v13;
  id v14;
  const char *v15;
  void *v16;
  id v17;
  const char *v18;
  id v19;
  const char *v20;
  void *v21;
  id v22;
  uint64_t v23;
  uint64_t v24;
  const char *v25;
  id v26;
  const char *v27;
  void *v28;
  const char *v29;
  id v30;
  void *v31;
  const char *v32;
  void *v33;
  id v34;
  const char *v35;
  const char *v36;
  id v37;
  SEL v38;
  uint64_t *v39;
  uint64_t *v40;
  uint64_t v41;
  SEL v42;
  const char *v43;
  id v44;
  const char *v45;
  id v46;
  void *v47;
  NSObject *v48;
  const char *v49;
  NEIKEv2DeleteIKEContext *v50;
  id v51;
  id v52;
  id v53;
  uint64_t v54;
  id *v55;
  void *v56;
  NSObject *v57;
  const char *v58;
  NEIKEv2DeleteIKEContext *v59;
  id v60;
  id v61;
  id v62;
  uint64_t v63;
  id *v64;
  NSObject *v65;
  const char *v66;
  NEIKEv2DeleteIKEContext *v67;
  id v68;
  id v69;
  id v70;
  uint64_t v71;
  id *v72;
  NSObject *v73;
  const char *v74;
  const char *v75;
  NEIKEv2DeleteIKEContext *v76;
  id v77;
  id v78;
  id v79;
  uint64_t v80;
  id *v81;
  NSObject *v82;
  NSObject *v83;
  const char *v84;
  NEIKEv2DeleteIKEContext *v85;
  id v86;
  id v87;
  id v88;
  uint64_t v89;
  id *v90;
  const char *v91;
  const char *v92;
  const char *v93;
  const char *v94;
  id v95;
  const char *v96;
  void *v97;
  id v98;
  uint64_t v99;
  uint64_t v100;
  NSObject *v101;
  const char *v102;
  NEIKEv2DeleteIKEContext *v103;
  id v104;
  id v105;
  id v106;
  uint64_t v107;
  id *v108;
  const char *v109;
  _QWORD v110[4];
  id v111;
  uint64_t v112;
  _QWORD v113[4];
  id v114;
  uint64_t v115;
  id v116;
  id v117;
  _QWORD v118[4];
  id v119;
  uint64_t v120;
  _QWORD v121[4];
  id v122;
  uint64_t v123;
  _QWORD v124[4];
  id v125;
  uint64_t v126;
  _QWORD v127[4];
  id v128;
  uint64_t v129;
  uint8_t buf[4];
  const char *v131;
  __int16 v132;
  uint64_t v133;
  __int16 v134;
  uint64_t v135;
  uint64_t v136;

  v136 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    Property = v3;
    v6 = Property;
    if (Property)
      Property = objc_getProperty(Property, v5, 88, 1);
    v7 = Property;

    if (v7)
    {
      if (v6)
      {
        v9 = objc_getProperty(v6, v8, 88, 1);
        v11 = v9;
        if (v9)
          v9 = objc_getProperty(v9, v10, 24, 1);
      }
      else
      {
        v11 = 0;
        v9 = 0;
      }
      v12 = v9;

      if (v12)
      {
        if (v6)
        {
          v14 = objc_getProperty(v6, v13, 88, 1);
          v16 = v14;
          if (v14)
            v14 = objc_getProperty(v14, v15, 32, 1);
        }
        else
        {
          v16 = 0;
          v14 = 0;
        }
        v17 = v14;

        if (v17)
        {
          if (v6)
          {
            v19 = objc_getProperty(v6, v18, 88, 1);
            v21 = v19;
            if (v19)
              v19 = objc_getProperty(v19, v20, 24, 1);
          }
          else
          {
            v21 = 0;
            v19 = 0;
          }
          v22 = v19;
          v23 = objc_msgSend(v22, "method");
          v24 = objc_msgSend(*(id *)(a1 + 48), "method");

          if (v23 == v24)
          {
            if (v6)
            {
              v26 = objc_getProperty(v6, v25, 88, 1);
              v28 = v26;
              if (v26)
                v26 = objc_getProperty(v26, v27, 32, 1);
            }
            else
            {
              v28 = 0;
              v26 = 0;
            }
            v30 = v26;
            v31 = *(void **)(a1 + 56);
            if (v31)
              objc_setProperty_atomic(v31, v29, v30, 152);

            v33 = *(void **)(a1 + 56);
            if (v33)
            {
              v34 = objc_getProperty(*(id *)(a1 + 56), v32, 184, 1);

              if (v34)
              {
                if (-[NEIKEv2IKESA processCurrentKeyExchange](v33, v35))
                {
                  v37 = objc_getProperty(v33, v36, 184, 1);
                  v39 = (uint64_t *)objc_getProperty(v33, v38, 160, 1);
                  v40 = v39;
                  if (v39)
                    v41 = v39[3];
                  else
                    v41 = 0;
                  objc_msgSend(v37, "addObject:", v41);

                  objc_setProperty_atomic(v33, v42, 0, 160);
                  if (v6)
                    v44 = objc_getProperty(v6, v43, 96, 1);
                  else
                    v44 = 0;
                  v46 = v44;
                  v47 = *(void **)(a1 + 56);
                  if (v47)
                    objc_setProperty_atomic(v47, v45, v46, 176);

                  -[NEIKEv2Session handleFollowupKEForRekeyIKESAInitiator:rekeyIKEContext:iteration:handler:](*(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 72) + 1, *(_QWORD *)(a1 + 64));
                  goto LABEL_60;
                }
              }
              else
              {
                ne_log_obj();
                v82 = objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v82, OS_LOG_TYPE_FAULT))
                {
                  *(_DWORD *)buf = 136315138;
                  v131 = "-[NEIKEv2IKESA(Crypto) processFollowupKeyExchange]";
                  _os_log_fault_impl(&dword_19BD16000, v82, OS_LOG_TYPE_FAULT, "%s called with null self.followupSharedSecrets", buf, 0xCu);
                }

              }
            }
            ne_log_obj();
            v83 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v83, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)buf = 0;
              _os_log_error_impl(&dword_19BD16000, v83, OS_LOG_TYPE_ERROR, "Failed to process KE data (initiator rekey followup KE)", buf, 2u);
            }

            v85 = [NEIKEv2DeleteIKEContext alloc];
            v86 = *(id *)(a1 + 32);
            if (v86)
              v86 = objc_getProperty(v86, v84, 368, 1);
            v87 = v86;
            v110[0] = MEMORY[0x1E0C809B0];
            v110[1] = 3221225472;
            v110[2] = __101__NEIKEv2Session_Exchange__handleFollowupKEForRekeyIKESAInitiator_rekeyIKEContext_iteration_handler___block_invoke_360;
            v110[3] = &unk_1E3CC0EB0;
            v88 = *(id *)(a1 + 40);
            v89 = *(_QWORD *)(a1 + 32);
            v111 = v88;
            v112 = v89;
            v90 = -[NEIKEv2DeleteIKEContext initDeleteIKEWithResponse:callbackQueue:callback:]((id *)&v85->super.super.isa, 0, v87, v110);

            -[NEIKEv2Session initiateDelete:](*(_QWORD **)(a1 + 32), v90);
            v56 = v111;
          }
          else
          {
            ne_log_obj();
            v73 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v73, OS_LOG_TYPE_ERROR))
            {
              v94 = *(const char **)(a1 + 32);
              if (v6)
              {
                v95 = objc_getProperty(v6, v74, 88, 1);
                v97 = v95;
                if (v95)
                  v95 = objc_getProperty(v95, v96, 24, 1);
              }
              else
              {
                v97 = 0;
                v95 = 0;
              }
              v98 = v95;
              v99 = objc_msgSend(v98, "method");
              v100 = objc_msgSend(*(id *)(a1 + 48), "method");
              *(_DWORD *)buf = 138412802;
              v131 = v94;
              v132 = 2048;
              v133 = v99;
              v134 = 2048;
              v135 = v100;
              _os_log_error_impl(&dword_19BD16000, v73, OS_LOG_TYPE_ERROR, "%@ Did not receive matching method from KE payload (%zu != %zu) (initiator rekey followup KE)", buf, 0x20u);

            }
            v76 = [NEIKEv2DeleteIKEContext alloc];
            v77 = *(id *)(a1 + 32);
            if (v77)
              v77 = objc_getProperty(v77, v75, 368, 1);
            v78 = v77;
            v113[0] = MEMORY[0x1E0C809B0];
            v113[1] = 3221225472;
            v113[2] = __101__NEIKEv2Session_Exchange__handleFollowupKEForRekeyIKESAInitiator_rekeyIKEContext_iteration_handler___block_invoke_357;
            v113[3] = &unk_1E3CC1158;
            v79 = *(id *)(a1 + 40);
            v80 = *(_QWORD *)(a1 + 32);
            v114 = v79;
            v115 = v80;
            v6 = v6;
            v116 = v6;
            v117 = *(id *)(a1 + 48);
            v81 = -[NEIKEv2DeleteIKEContext initDeleteIKEWithResponse:callbackQueue:callback:]((id *)&v76->super.super.isa, 0, v78, v113);

            -[NEIKEv2Session initiateDelete:](*(_QWORD **)(a1 + 32), v81);
            v56 = v114;
          }
        }
        else
        {
          ne_log_obj();
          v65 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
          {
            v93 = *(const char **)(a1 + 32);
            *(_DWORD *)buf = 138412290;
            v131 = v93;
            _os_log_error_impl(&dword_19BD16000, v65, OS_LOG_TYPE_ERROR, "%@ Did not receive data in KE payload (initiator rekey followup KE)", buf, 0xCu);
          }

          v67 = [NEIKEv2DeleteIKEContext alloc];
          v68 = *(id *)(a1 + 32);
          if (v68)
            v68 = objc_getProperty(v68, v66, 368, 1);
          v69 = v68;
          v118[0] = MEMORY[0x1E0C809B0];
          v118[1] = 3221225472;
          v118[2] = __101__NEIKEv2Session_Exchange__handleFollowupKEForRekeyIKESAInitiator_rekeyIKEContext_iteration_handler___block_invoke_354;
          v118[3] = &unk_1E3CC0EB0;
          v70 = *(id *)(a1 + 40);
          v71 = *(_QWORD *)(a1 + 32);
          v119 = v70;
          v120 = v71;
          v72 = -[NEIKEv2DeleteIKEContext initDeleteIKEWithResponse:callbackQueue:callback:]((id *)&v67->super.super.isa, 0, v69, v118);

          -[NEIKEv2Session initiateDelete:](*(_QWORD **)(a1 + 32), v72);
          v56 = v119;
        }
      }
      else
      {
        ne_log_obj();
        v57 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR))
        {
          v92 = *(const char **)(a1 + 32);
          *(_DWORD *)buf = 138412290;
          v131 = v92;
          _os_log_error_impl(&dword_19BD16000, v57, OS_LOG_TYPE_ERROR, "%@ Did not receive method in KE payload (initiator rekey followup KE)", buf, 0xCu);
        }

        v59 = [NEIKEv2DeleteIKEContext alloc];
        v60 = *(id *)(a1 + 32);
        if (v60)
          v60 = objc_getProperty(v60, v58, 368, 1);
        v61 = v60;
        v121[0] = MEMORY[0x1E0C809B0];
        v121[1] = 3221225472;
        v121[2] = __101__NEIKEv2Session_Exchange__handleFollowupKEForRekeyIKESAInitiator_rekeyIKEContext_iteration_handler___block_invoke_351;
        v121[3] = &unk_1E3CC0EB0;
        v62 = *(id *)(a1 + 40);
        v63 = *(_QWORD *)(a1 + 32);
        v122 = v62;
        v123 = v63;
        v64 = -[NEIKEv2DeleteIKEContext initDeleteIKEWithResponse:callbackQueue:callback:]((id *)&v59->super.super.isa, 0, v61, v121);

        -[NEIKEv2Session initiateDelete:](*(_QWORD **)(a1 + 32), v64);
        v56 = v122;
      }
    }
    else
    {
      ne_log_obj();
      v48 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
      {
        v91 = *(const char **)(a1 + 32);
        *(_DWORD *)buf = 138412290;
        v131 = v91;
        _os_log_error_impl(&dword_19BD16000, v48, OS_LOG_TYPE_ERROR, "%@ Did not receive KE payload (initiator rekey followup KE)", buf, 0xCu);
      }

      v50 = [NEIKEv2DeleteIKEContext alloc];
      v51 = *(id *)(a1 + 32);
      if (v51)
        v51 = objc_getProperty(v51, v49, 368, 1);
      v52 = v51;
      v124[0] = MEMORY[0x1E0C809B0];
      v124[1] = 3221225472;
      v124[2] = __101__NEIKEv2Session_Exchange__handleFollowupKEForRekeyIKESAInitiator_rekeyIKEContext_iteration_handler___block_invoke_348;
      v124[3] = &unk_1E3CC0EB0;
      v53 = *(id *)(a1 + 40);
      v54 = *(_QWORD *)(a1 + 32);
      v125 = v53;
      v126 = v54;
      v55 = -[NEIKEv2DeleteIKEContext initDeleteIKEWithResponse:callbackQueue:callback:]((id *)&v50->super.super.isa, 0, v52, v124);

      -[NEIKEv2Session initiateDelete:](*(_QWORD **)(a1 + 32), v55);
      v56 = v125;
    }

    goto LABEL_60;
  }
  ne_log_obj();
  v101 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v101, OS_LOG_TYPE_ERROR))
  {
    v109 = *(const char **)(a1 + 32);
    *(_DWORD *)buf = 138412290;
    v131 = v109;
    _os_log_error_impl(&dword_19BD16000, v101, OS_LOG_TYPE_ERROR, "%@ Failed to receive FOLLOWUP_KE reply (initiator rekey followup KE)", buf, 0xCu);
  }

  v103 = [NEIKEv2DeleteIKEContext alloc];
  v104 = *(id *)(a1 + 32);
  if (v104)
    v104 = objc_getProperty(v104, v102, 368, 1);
  v105 = v104;
  v127[0] = MEMORY[0x1E0C809B0];
  v127[1] = 3221225472;
  v127[2] = __101__NEIKEv2Session_Exchange__handleFollowupKEForRekeyIKESAInitiator_rekeyIKEContext_iteration_handler___block_invoke_345;
  v127[3] = &unk_1E3CC0EB0;
  v106 = *(id *)(a1 + 40);
  v107 = *(_QWORD *)(a1 + 32);
  v128 = v106;
  v129 = v107;
  v108 = -[NEIKEv2DeleteIKEContext initDeleteIKEWithResponse:callbackQueue:callback:]((id *)&v103->super.super.isa, 0, v105, v127);

  -[NEIKEv2Session initiateDelete:](*(_QWORD **)(a1 + 32), v108);
  v6 = v128;
LABEL_60:

}

void __101__NEIKEv2Session_Exchange__handleFollowupKEForRekeyIKESAInitiator_rekeyIKEContext_iteration_handler___block_invoke_345(uint64_t a1)
{
  const char *v2;
  id Property;
  id v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *ErrorPeerInvalidSyntax;
  const char *v13;
  const char *v14;
  uint64_t v15;

  objc_msgSend(*(id *)(a1 + 32), "sendCallbackSuccess:session:", 0, *(_QWORD *)(a1 + 40));
  Property = *(id *)(a1 + 40);
  if (Property)
    Property = objc_getProperty(Property, v2, 336, 1);
  v4 = Property;
  ErrorPeerInvalidSyntax = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("Failed to receive FOLLOWUP_KE reply (initiator rekey followup KE)"), v5, v6, v7, v8, v9, v10, v11, v15);
  -[NEIKEv2IKESA setState:error:]((uint64_t)v4, 3uLL, ErrorPeerInvalidSyntax);

  -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 40), v13);
  -[NEIKEv2Session resetAll](*(_QWORD *)(a1 + 40), v14);
}

void __101__NEIKEv2Session_Exchange__handleFollowupKEForRekeyIKESAInitiator_rekeyIKEContext_iteration_handler___block_invoke_348(uint64_t a1)
{
  const char *v2;
  id Property;
  id v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *ErrorPeerInvalidSyntax;
  const char *v13;
  const char *v14;
  uint64_t v15;

  objc_msgSend(*(id *)(a1 + 32), "sendCallbackSuccess:session:", 0, *(_QWORD *)(a1 + 40));
  Property = *(id *)(a1 + 40);
  if (Property)
    Property = objc_getProperty(Property, v2, 336, 1);
  v4 = Property;
  ErrorPeerInvalidSyntax = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("Did not receive KE payload (initiator rekey followup KE)"), v5, v6, v7, v8, v9, v10, v11, v15);
  -[NEIKEv2IKESA setState:error:]((uint64_t)v4, 3uLL, ErrorPeerInvalidSyntax);

  -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 40), v13);
  -[NEIKEv2Session resetAll](*(_QWORD *)(a1 + 40), v14);
}

void __101__NEIKEv2Session_Exchange__handleFollowupKEForRekeyIKESAInitiator_rekeyIKEContext_iteration_handler___block_invoke_351(uint64_t a1)
{
  const char *v2;
  id Property;
  id v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *ErrorPeerInvalidSyntax;
  const char *v13;
  const char *v14;
  uint64_t v15;

  objc_msgSend(*(id *)(a1 + 32), "sendCallbackSuccess:session:", 0, *(_QWORD *)(a1 + 40));
  Property = *(id *)(a1 + 40);
  if (Property)
    Property = objc_getProperty(Property, v2, 336, 1);
  v4 = Property;
  ErrorPeerInvalidSyntax = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("Did not receive method in KE payload (initiator rekey followup KE)"), v5, v6, v7, v8, v9, v10, v11, v15);
  -[NEIKEv2IKESA setState:error:]((uint64_t)v4, 3uLL, ErrorPeerInvalidSyntax);

  -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 40), v13);
  -[NEIKEv2Session resetAll](*(_QWORD *)(a1 + 40), v14);
}

void __101__NEIKEv2Session_Exchange__handleFollowupKEForRekeyIKESAInitiator_rekeyIKEContext_iteration_handler___block_invoke_354(uint64_t a1)
{
  const char *v2;
  id Property;
  id v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *ErrorPeerInvalidSyntax;
  const char *v13;
  const char *v14;
  uint64_t v15;

  objc_msgSend(*(id *)(a1 + 32), "sendCallbackSuccess:session:", 0, *(_QWORD *)(a1 + 40));
  Property = *(id *)(a1 + 40);
  if (Property)
    Property = objc_getProperty(Property, v2, 336, 1);
  v4 = Property;
  ErrorPeerInvalidSyntax = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("Did not receive data in KE payload (initiator rekey followup KE)"), v5, v6, v7, v8, v9, v10, v11, v15);
  -[NEIKEv2IKESA setState:error:]((uint64_t)v4, 3uLL, ErrorPeerInvalidSyntax);

  -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 40), v13);
  -[NEIKEv2Session resetAll](*(_QWORD *)(a1 + 40), v14);
}

void __101__NEIKEv2Session_Exchange__handleFollowupKEForRekeyIKESAInitiator_rekeyIKEContext_iteration_handler___block_invoke_357(uint64_t a1)
{
  const char *v2;
  id Property;
  const char *v4;
  id v5;
  void *v6;
  id v7;
  const char *v8;
  void *v9;
  id v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *ErrorPeerInvalidSyntax;
  const char *v20;
  const char *v21;

  objc_msgSend(*(id *)(a1 + 32), "sendCallbackSuccess:session:", 0, *(_QWORD *)(a1 + 40));
  Property = *(id *)(a1 + 40);
  if (Property)
    Property = objc_getProperty(Property, v2, 336, 1);
  v5 = Property;
  v6 = *(void **)(a1 + 48);
  if (v6)
  {
    v7 = objc_getProperty(v6, v4, 88, 1);
    v9 = v7;
    if (v7)
      v7 = objc_getProperty(v7, v8, 24, 1);
  }
  else
  {
    v9 = 0;
    v7 = 0;
  }
  v10 = v7;
  v11 = objc_msgSend(v10, "method");
  objc_msgSend(*(id *)(a1 + 56), "method");
  ErrorPeerInvalidSyntax = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("Did not receive matching method from KE payload (%zu != %zu) (initiator rekey followup KE)"), v12, v13, v14, v15, v16, v17, v18, v11);
  -[NEIKEv2IKESA setState:error:]((uint64_t)v5, 3uLL, ErrorPeerInvalidSyntax);

  -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 40), v20);
  -[NEIKEv2Session resetAll](*(_QWORD *)(a1 + 40), v21);
}

void __101__NEIKEv2Session_Exchange__handleFollowupKEForRekeyIKESAInitiator_rekeyIKEContext_iteration_handler___block_invoke_360(uint64_t a1)
{
  const char *v2;
  id Property;
  id v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *ErrorCrypto;
  const char *v13;
  const char *v14;
  uint64_t v15;

  objc_msgSend(*(id *)(a1 + 32), "sendCallbackSuccess:session:", 0, *(_QWORD *)(a1 + 40));
  Property = *(id *)(a1 + 40);
  if (Property)
    Property = objc_getProperty(Property, v2, 336, 1);
  v4 = Property;
  ErrorCrypto = (void *)NEIKEv2CreateErrorCrypto(CFSTR("Failed to process KE data (initiator rekey followup KE)"), v5, v6, v7, v8, v9, v10, v11, v15);
  -[NEIKEv2IKESA setState:error:]((uint64_t)v4, 3uLL, ErrorCrypto);

  -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 40), v13);
  -[NEIKEv2Session resetAll](*(_QWORD *)(a1 + 40), v14);
}

- (void)handleFollowupKEForRekeyIKESAResponder:(uint64_t)a3 iteration:(void *)a4 replyPacket:(void *)a5 replyPacketDescription:(void *)a6 handler:
{
  id v11;
  id v12;
  id v13;
  id v14;
  SEL v15;
  NSObject *v16;
  char v17;
  const char *v18;
  id v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  void *ErrorFailedToSend;
  const char *v28;
  const char *v29;
  _QWORD v30[4];
  id v31;
  _QWORD *v32;
  id v33;
  uint64_t v34;

  v11 = a2;
  v12 = a5;
  v13 = a6;
  if (a1)
  {
    v14 = a4;
    v16 = objc_getProperty(a1, v15, 368, 1);
    dispatch_assert_queue_V2(v16);

    v30[0] = MEMORY[0x1E0C809B0];
    v30[1] = 3221225472;
    v30[2] = __120__NEIKEv2Session_Exchange__handleFollowupKEForRekeyIKESAResponder_iteration_replyPacket_replyPacketDescription_handler___block_invoke;
    v30[3] = &unk_1E3CC0F50;
    v34 = a3;
    v31 = v11;
    v32 = a1;
    v33 = v13;
    v17 = -[NEIKEv2Session sendReply:replyHandler:]((uint64_t)a1, v14, v30);

    if ((v17 & 1) == 0)
    {
      v19 = objc_getProperty(a1, v18, 336, 1);
      ErrorFailedToSend = (void *)NEIKEv2CreateErrorFailedToSend(CFSTR("%@"), v20, v21, v22, v23, v24, v25, v26, (uint64_t)v12);
      -[NEIKEv2IKESA setState:error:]((uint64_t)v19, 3uLL, ErrorFailedToSend);

      -[NEIKEv2Session reportState](a1, v28);
      -[NEIKEv2Session resetAll]((uint64_t)a1, v29);
    }

  }
}

void __120__NEIKEv2Session_Exchange__handleFollowupKEForRekeyIKESAResponder_iteration_replyPacket_replyPacketDescription_handler___block_invoke(uint64_t a1, void *a2)
{
  const char *v3;
  id v4;
  unint64_t v5;
  void *v6;
  id Property;
  const char *v8;
  void *v9;
  id v10;
  unint64_t v11;
  const char *v12;
  id v13;
  void *v14;
  id v15;
  const char *v16;
  void *v17;
  id v18;
  const char *v19;
  void *v20;
  void *v21;
  const char *v22;
  id *v23;
  void *v24;
  id v25;
  const char *v26;
  void *v27;
  id v28;
  void *v29;
  const char *v30;
  id v31;
  id v32;
  void *v33;
  void *v34;
  const char *v35;
  id v36;
  id v37;
  const char *v38;
  id v39;
  const char *v40;
  void *v41;
  id v42;
  const char *v43;
  id v44;
  const char *v45;
  void *v46;
  id v47;
  const char *v48;
  id v49;
  const char *v50;
  void *v51;
  id v52;
  uint64_t v53;
  uint64_t v54;
  const char *v55;
  id v56;
  const char *v57;
  void *v58;
  const char *v59;
  id v60;
  void *v61;
  id v62;
  const char *v63;
  void *v64;
  id v65;
  char v66;
  const char *v67;
  void *v68;
  id v69;
  const char *v70;
  void *v71;
  id v72;
  char v73;
  const char *v74;
  unint64_t v75;
  void *v76;
  id v77;
  const char *v78;
  void *v79;
  id v80;
  unint64_t v81;
  const char *v82;
  void *v83;
  void *v84;
  const char *v85;
  NEIKEv2NotifyPayload *v86;
  void *v87;
  _UNKNOWN **v88;
  NSObject *v89;
  const char *v90;
  NEIKEv2DeleteIKEContext *v91;
  id v92;
  id v93;
  _QWORD *v94;
  NSObject *v95;
  const char *v96;
  NEIKEv2DeleteIKEContext *v97;
  id v98;
  id v99;
  _QWORD *v100;
  NSObject *v101;
  const char *v102;
  id v103;
  NSObject *v104;
  const char *v105;
  id v106;
  void *v107;
  NSObject *v108;
  const char *v109;
  const char *v110;
  NEIKEv2DeleteIKEContext *v111;
  id v112;
  id v113;
  id *v114;
  id *v115;
  NSObject *v116;
  const char *v117;
  void *v118;
  const char *v119;
  const char *v120;
  NEIKEv2DeleteIKEContext *v121;
  id v122;
  id v123;
  id *v124;
  NSObject *v125;
  const char *v126;
  NEIKEv2DeleteIKEContext *v127;
  id v128;
  id v129;
  id *v130;
  id v131;
  id v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  void *ErrorFailedToSend;
  const char *v141;
  const char *v142;
  uint64_t v143;
  void *v144;
  NEIKEv2KeyExchangePayload *v145;
  const char *v146;
  NEIKEv2KeyExchangePayload *v147;
  SEL v148;
  id v149;
  const char *v150;
  void *v151;
  const char *v152;
  void *v153;
  id v154;
  void *v155;
  void *v156;
  const char *v157;
  id v158;
  id v159;
  const char *v160;
  void *v161;
  const char *v162;
  id v163;
  id v164;
  const char *v165;
  void *v166;
  SEL v167;
  id v168;
  id v169;
  char v170;
  const char *v171;
  id v172;
  const char *v173;
  id v174;
  void *v175;
  id v176;
  void *v177;
  void *v178;
  id v179;
  const char *v180;
  void *v181;
  void *v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  void *v186;
  NSObject *v187;
  const char *v188;
  NEIKEv2DeleteIKEContext *v189;
  id v190;
  id v191;
  id *v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  id v196;
  const char *v197;
  void *v198;
  id v199;
  id v200;
  const char *v201;
  void *v202;
  int *v203;
  const char *v204;
  id v205;
  void *v206;
  id v207;
  const char *v208;
  void *v209;
  id v210;
  uint64_t v211;
  uint64_t v212;
  NSObject *v213;
  const char *v214;
  id v215;
  NSObject *v216;
  const char *v217;
  NEIKEv2DeleteIKEContext *v218;
  id v219;
  id v220;
  id *v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  void *v226;
  void *v227;
  _QWORD v228[5];
  _QWORD v229[5];
  _QWORD v230[5];
  id *v231;
  _QWORD v232[5];
  id *v233;
  id v234;
  _QWORD v235[5];
  id *v236;
  id v237;
  _QWORD v238[5];
  _QWORD v239[5];
  _QWORD v240[5];
  _QWORD v241[5];
  id *v242;
  _QWORD v243[5];
  _BYTE buf[22];
  __int16 v245;
  uint64_t v246;
  uint64_t v247;

  v247 = *MEMORY[0x1E0C80C00];
  v4 = a2;
  v5 = *(_QWORD *)(a1 + 56);
  v6 = *(void **)(a1 + 32);
  if (v6)
  {
    Property = objc_getProperty(v6, v3, 96, 1);
    v9 = Property;
    if (Property)
      Property = objc_getProperty(Property, v8, 120, 1);
  }
  else
  {
    v9 = 0;
    Property = 0;
  }
  v10 = Property;
  v11 = objc_msgSend(v10, "count");

  if (v5 < v11)
  {
    if (!*(_QWORD *)(a1 + 56))
    {
      v13 = objc_alloc(MEMORY[0x1E0C99DE8]);
      v14 = *(void **)(a1 + 32);
      if (v14)
      {
        v15 = objc_getProperty(v14, v12, 96, 1);
        v17 = v15;
        if (v15)
          v15 = objc_getProperty(v15, v16, 120, 1);
      }
      else
      {
        v17 = 0;
        v15 = 0;
      }
      v18 = v15;
      v20 = (void *)objc_msgSend(v13, "initWithCapacity:", objc_msgSend(v18, "count"));
      v21 = *(void **)(a1 + 32);
      if (v21)
        objc_setProperty_atomic(v21, v19, v20, 184);

    }
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      v23 = (id *)v4;
      v24 = *(void **)(a1 + 32);
      if (v24)
      {
        v25 = objc_getProperty(v24, v22, 96, 1);
        v27 = v25;
        if (v25)
          v25 = objc_getProperty(v25, v26, 120, 1);
      }
      else
      {
        v27 = 0;
        v25 = 0;
      }
      v28 = v25;
      objc_msgSend(v28, "objectAtIndexedSubscript:", *(_QWORD *)(a1 + 56));
      v29 = (void *)objc_claimAutoreleasedReturnValue();

      v31 = *(id *)(a1 + 32);
      if (v31)
        v31 = objc_getProperty(v31, v30, 96, 1);
      v32 = v31;
      -[NEIKEv2IKESAProposal chosenAdditionalKEMProtocols](v32);
      v33 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v33, "objectForKeyedSubscript:", v29);
      v34 = (void *)objc_claimAutoreleasedReturnValue();

      if (v34)
      {
        if (v23)
          v36 = objc_getProperty(v23, v35, 88, 1);
        else
          v36 = 0;
        v37 = v36;

        if (v37)
        {
          if (v23)
          {
            v39 = objc_getProperty(v23, v38, 88, 1);
            v41 = v39;
            if (v39)
              v39 = objc_getProperty(v39, v40, 24, 1);
          }
          else
          {
            v41 = 0;
            v39 = 0;
          }
          v42 = v39;

          if (v42)
          {
            if (v23)
            {
              v44 = objc_getProperty(v23, v43, 88, 1);
              v46 = v44;
              if (v44)
                v44 = objc_getProperty(v44, v45, 32, 1);
            }
            else
            {
              v46 = 0;
              v44 = 0;
            }
            v47 = v44;

            if (v47)
            {
              if (v23)
              {
                v49 = objc_getProperty(v23, v48, 88, 1);
                v51 = v49;
                if (v49)
                  v49 = objc_getProperty(v49, v50, 24, 1);
              }
              else
              {
                v51 = 0;
                v49 = 0;
              }
              v52 = v49;
              v53 = objc_msgSend(v52, "method");
              v54 = objc_msgSend(v34, "method");

              if (v53 == v54)
              {
                if (v23)
                {
                  v56 = objc_getProperty(v23, v55, 96, 1);
                  v58 = v56;
                  if (v56)
                    v56 = objc_getProperty(v56, v57, 32, 1);
                }
                else
                {
                  v58 = 0;
                  v56 = 0;
                }
                v60 = v56;
                v61 = *(void **)(a1 + 32);
                v226 = v29;
                if (v61)
                {
                  v62 = objc_getProperty(v61, v59, 176, 1);
                  v64 = v62;
                  if (v62)
                    v62 = objc_getProperty(v62, v63, 32, 1);
                }
                else
                {
                  v64 = 0;
                  v62 = 0;
                }
                v65 = v62;
                v66 = objc_msgSend(v60, "isEqualToData:", v65);

                if ((v66 & 1) == 0)
                {
                  ne_log_obj();
                  v116 = objc_claimAutoreleasedReturnValue();
                  if (os_log_type_enabled(v116, OS_LOG_TYPE_ERROR))
                  {
                    v225 = *(_QWORD *)(a1 + 40);
                    if (v23)
                    {
                      v200 = objc_getProperty(v23, v117, 96, 1);
                      v202 = v200;
                      v203 = &OBJC_IVAR___NEIKEv2SessionConfiguration__ppkMandatory;
                      if (v200)
                        v200 = objc_getProperty(v200, v201, 32, 1);
                    }
                    else
                    {
                      v202 = 0;
                      v200 = 0;
                      v203 = &OBJC_IVAR___NEIKEv2SessionConfiguration__ppkMandatory;
                    }
                    v205 = v200;
                    v206 = *(void **)(a1 + 32);
                    if (v206)
                    {
                      v207 = objc_getProperty(v206, v204, 176, 1);
                      v209 = v207;
                      if (v207)
                        v207 = objc_getProperty(v207, v208, v203[249], 1);
                    }
                    else
                    {
                      v209 = 0;
                      v207 = 0;
                    }
                    v210 = v207;
                    *(_DWORD *)buf = 138412802;
                    *(_QWORD *)&buf[4] = v225;
                    *(_WORD *)&buf[12] = 2112;
                    *(_QWORD *)&buf[14] = v205;
                    v245 = 2112;
                    v246 = (uint64_t)v210;
                    _os_log_error_impl(&dword_19BD16000, v116, OS_LOG_TYPE_ERROR, "%@ ADDITIONAL_KEY_EXCHANGE in FOLLOWUP_KE request doesn't match expected (%@ != %@) (responder rekey followup KE)", buf, 0x20u);

                  }
                  v118 = (void *)-[NEIKEv2Packet initResponse:]((uint64_t)[NEIKEv2FollowupKEPacket alloc], v23);
                  v107 = v118;
                  v29 = v226;
                  if (v118)
                    -[NEIKEv2Packet addNotification:data:](v118, 0x2FuLL, 0);
                  if ((-[NEIKEv2Session sendReply:replyHandler:](*(_QWORD *)(a1 + 40), v107, 0) & 1) != 0)
                  {
                    v121 = [NEIKEv2DeleteIKEContext alloc];
                    v122 = *(id *)(a1 + 40);
                    if (v122)
                      v122 = objc_getProperty(v122, v120, 368, 1);
                    v123 = v122;
                    v232[0] = MEMORY[0x1E0C809B0];
                    v232[1] = 3221225472;
                    v232[2] = __120__NEIKEv2Session_Exchange__handleFollowupKEForRekeyIKESAResponder_iteration_replyPacket_replyPacketDescription_handler___block_invoke_385;
                    v232[3] = &unk_1E3CC10B8;
                    v232[4] = *(_QWORD *)(a1 + 40);
                    v233 = v23;
                    v234 = *(id *)(a1 + 32);
                    v124 = -[NEIKEv2DeleteIKEContext initDeleteIKEWithResponse:callbackQueue:callback:]((id *)&v121->super.super.isa, 0, v123, v232);

                    -[NEIKEv2Session initiateDelete:](*(_QWORD **)(a1 + 40), v124);
                  }
                  else
                  {
                    v131 = *(id *)(a1 + 40);
                    if (v131)
                      v131 = objc_getProperty(v131, v119, 336, 1);
                    v132 = v131;
                    ErrorFailedToSend = (void *)NEIKEv2CreateErrorFailedToSend(CFSTR("responder rekey followup KE mismatched link"), v133, v134, v135, v136, v137, v138, v139, v224);
                    -[NEIKEv2IKESA setState:error:]((uint64_t)v132, 3uLL, ErrorFailedToSend);

                    -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 40), v141);
                    -[NEIKEv2Session resetAll](*(_QWORD *)(a1 + 40), v142);
                  }
                  goto LABEL_76;
                }
                v68 = *(void **)(a1 + 32);
                if (v23)
                {
                  v69 = objc_getProperty(v23, v67, 88, 1);
                  v71 = v69;
                  v29 = v226;
                  if (v69)
                    v69 = objc_getProperty(v69, v70, 32, 1);
                }
                else
                {
                  v71 = 0;
                  v69 = 0;
                  v29 = v226;
                }
                v72 = v69;
                v73 = -[NEIKEv2IKESA generateLocalValuesForKEMProtocol:peerPayload:](v68, v34, v72);

                if ((v73 & 1) != 0)
                {
                  v75 = *(_QWORD *)(a1 + 56) + 1;
                  v76 = *(void **)(a1 + 32);
                  if (v76)
                  {
                    v77 = objc_getProperty(v76, v74, 96, 1);
                    v79 = v77;
                    if (v77)
                      v77 = objc_getProperty(v77, v78, 120, 1);
                  }
                  else
                  {
                    v79 = 0;
                    v77 = 0;
                  }
                  v80 = v77;
                  v81 = objc_msgSend(v80, "count");

                  if (v75 >= v81)
                  {
                    v144 = *(void **)(a1 + 32);
                    v88 = &off_1E3CBB000;
                    if (v144)
                      objc_setProperty_atomic(v144, v82, 0, 176);
                  }
                  else
                  {
                    objc_msgSend(MEMORY[0x1E0CB3A28], "UUID");
                    v83 = (void *)objc_claimAutoreleasedReturnValue();
                    *(_QWORD *)buf = 0;
                    *(_QWORD *)&buf[8] = 0;
                    objc_msgSend(v83, "getUUIDBytes:", buf);
                    v84 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99D50]), "initWithBytes:length:", buf, 16);
                    v86 = +[NEIKEv2NotifyPayload createNotifyPayloadType:data:]((uint64_t)NEIKEv2NotifyPayload, 0x4039uLL, v84);
                    v87 = *(void **)(a1 + 32);
                    v88 = &off_1E3CBB000;
                    if (v87)
                      objc_setProperty_atomic(v87, v85, v86, 176);

                  }
                  v107 = (void *)-[NEIKEv2Packet initResponse:]((uint64_t)objc_alloc((Class)v88[320]), v23);
                  v145 = objc_alloc_init(NEIKEv2KeyExchangePayload);
                  v147 = v145;
                  if (v107)
                  {
                    objc_setProperty_atomic(v107, v146, v145, 88);

                    v149 = objc_getProperty(v107, v148, 88, 1);
                    v151 = v149;
                    if (v149)
                      objc_setProperty_atomic(v149, v150, v34, 24);
                  }
                  else
                  {

                    v151 = 0;
                  }

                  v153 = *(void **)(a1 + 32);
                  if (v153)
                  {
                    v154 = objc_getProperty(v153, v152, 160, 1);
                    v155 = v154;
                    if (v154)
                    {
                      v156 = (void *)*((_QWORD *)v154 + 2);
                      goto LABEL_108;
                    }
                  }
                  else
                  {
                    v155 = 0;
                  }
                  v156 = 0;
LABEL_108:
                  v158 = v156;
                  if (v107)
                  {
                    v159 = objc_getProperty(v107, v157, 88, 1);
                    v161 = v159;
                    if (v159)
                      objc_setProperty_atomic(v159, v160, v158, 32);
                  }
                  else
                  {
                    v161 = 0;
                  }

                  v163 = *(id *)(a1 + 32);
                  if (v163)
                    v163 = objc_getProperty(v163, v162, 176, 1);
                  v164 = v163;
                  v166 = v164;
                  if (v107)
                  {
                    objc_setProperty_atomic(v107, v165, v164, 96);

                    v168 = objc_getProperty(v107, v167, 88, 1);
                  }
                  else
                  {

                    v168 = 0;
                  }
                  v169 = v168;
                  v170 = -[NEIKEv2Payload isValid]((uint64_t)v169);

                  if ((v170 & 1) == 0)
                  {
                    ne_log_obj();
                    v187 = objc_claimAutoreleasedReturnValue();
                    if (os_log_type_enabled(v187, OS_LOG_TYPE_ERROR))
                    {
                      v212 = *(_QWORD *)(a1 + 40);
                      *(_DWORD *)buf = 138412290;
                      *(_QWORD *)&buf[4] = v212;
                      _os_log_error_impl(&dword_19BD16000, v187, OS_LOG_TYPE_ERROR, "%@ Failed to create FOLLOWUP_KE packet (responder rekey followup KE)", buf, 0xCu);
                    }

                    v189 = [NEIKEv2DeleteIKEContext alloc];
                    v190 = *(id *)(a1 + 40);
                    if (v190)
                      v190 = objc_getProperty(v190, v188, 368, 1);
                    v191 = v190;
                    v229[0] = MEMORY[0x1E0C809B0];
                    v229[1] = 3221225472;
                    v229[2] = __120__NEIKEv2Session_Exchange__handleFollowupKEForRekeyIKESAResponder_iteration_replyPacket_replyPacketDescription_handler___block_invoke_391;
                    v229[3] = &unk_1E3CC1408;
                    v229[4] = *(_QWORD *)(a1 + 40);
                    v192 = -[NEIKEv2DeleteIKEContext initDeleteIKEWithResponse:callbackQueue:callback:]((id *)&v189->super.super.isa, 0, v191, v229);

                    -[NEIKEv2Session initiateDelete:](*(_QWORD **)(a1 + 40), v192);
                    goto LABEL_76;
                  }
                  v172 = *(id *)(a1 + 32);
                  if (v172)
                    v172 = objc_getProperty(v172, v171, 184, 1);
                  v174 = v172;
                  v175 = *(void **)(a1 + 32);
                  if (v175)
                  {
                    v176 = objc_getProperty(v175, v173, 160, 1);
                    v177 = v176;
                    if (v176)
                    {
                      v178 = (void *)*((_QWORD *)v176 + 3);
LABEL_121:
                      v179 = v178;
                      objc_msgSend(v174, "addObject:", v179);

                      v181 = *(void **)(a1 + 32);
                      v182 = v29;
                      if (v181)
                      {
                        objc_setProperty_atomic(v181, v180, 0, 160);
                        v183 = *(_QWORD *)(a1 + 32);
                      }
                      else
                      {
                        v183 = 0;
                      }
                      v184 = *(_QWORD *)(a1 + 40);
                      v185 = *(_QWORD *)(a1 + 56) + 1;
                      v186 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3940]), "initWithFormat:", CFSTR("responder rekey FOLLOWUP_KE #%zu"), v185);
                      -[NEIKEv2Session handleFollowupKEForRekeyIKESAResponder:iteration:replyPacket:replyPacketDescription:handler:](v184, v183, v185, v107, v186, *(_QWORD *)(a1 + 48));

                      v29 = v182;
                      goto LABEL_76;
                    }
                  }
                  else
                  {
                    v177 = 0;
                  }
                  v178 = 0;
                  goto LABEL_121;
                }
                ne_log_obj();
                v125 = objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v125, OS_LOG_TYPE_ERROR))
                {
                  v211 = *(_QWORD *)(a1 + 40);
                  *(_DWORD *)buf = 138412546;
                  *(_QWORD *)&buf[4] = v211;
                  *(_WORD *)&buf[12] = 2112;
                  *(_QWORD *)&buf[14] = v34;
                  _os_log_error_impl(&dword_19BD16000, v125, OS_LOG_TYPE_ERROR, "%@ Failed to generate values for KEM %@ (responder rekey followup KE)", buf, 0x16u);
                }

                v127 = [NEIKEv2DeleteIKEContext alloc];
                v128 = *(id *)(a1 + 40);
                if (v128)
                  v128 = objc_getProperty(v128, v126, 368, 1);
                v129 = v128;
                v230[0] = MEMORY[0x1E0C809B0];
                v230[1] = 3221225472;
                v230[2] = __120__NEIKEv2Session_Exchange__handleFollowupKEForRekeyIKESAResponder_iteration_replyPacket_replyPacketDescription_handler___block_invoke_388;
                v230[3] = &unk_1E3CC0EB0;
                v230[4] = *(_QWORD *)(a1 + 40);
                v231 = v34;
                v130 = -[NEIKEv2DeleteIKEContext initDeleteIKEWithResponse:callbackQueue:callback:]((id *)&v127->super.super.isa, 0, v129, v230);

                -[NEIKEv2Session initiateDelete:](*(_QWORD **)(a1 + 40), v130);
                v115 = v231;
              }
              else
              {
                ne_log_obj();
                v108 = objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v108, OS_LOG_TYPE_ERROR))
                {
                  v227 = v29;
                  v195 = *(_QWORD *)(a1 + 40);
                  if (v23)
                  {
                    v196 = objc_getProperty(v23, v109, 88, 1);
                    v198 = v196;
                    if (v196)
                      v196 = objc_getProperty(v196, v197, 24, 1);
                  }
                  else
                  {
                    v198 = 0;
                    v196 = 0;
                  }
                  v199 = v196;
                  *(_DWORD *)buf = 138412802;
                  *(_QWORD *)&buf[4] = v195;
                  *(_WORD *)&buf[12] = 2048;
                  *(_QWORD *)&buf[14] = objc_msgSend(v199, "method");
                  v245 = 2048;
                  v246 = objc_msgSend(v34, "method");
                  _os_log_error_impl(&dword_19BD16000, v108, OS_LOG_TYPE_ERROR, "%@ Did not receive matching method from KE payload (%zu != %zu) (responder rekey followup KE)", buf, 0x20u);

                  v29 = v227;
                }

                v111 = [NEIKEv2DeleteIKEContext alloc];
                v112 = *(id *)(a1 + 40);
                if (v112)
                  v112 = objc_getProperty(v112, v110, 368, 1);
                v113 = v112;
                v235[0] = MEMORY[0x1E0C809B0];
                v235[1] = 3221225472;
                v235[2] = __120__NEIKEv2Session_Exchange__handleFollowupKEForRekeyIKESAResponder_iteration_replyPacket_replyPacketDescription_handler___block_invoke_380;
                v235[3] = &unk_1E3CC10B8;
                v235[4] = *(_QWORD *)(a1 + 40);
                v236 = v23;
                v237 = v34;
                v114 = -[NEIKEv2DeleteIKEContext initDeleteIKEWithResponse:callbackQueue:callback:]((id *)&v111->super.super.isa, 0, v113, v235);

                -[NEIKEv2Session initiateDelete:](*(_QWORD **)(a1 + 40), v114);
                v115 = v236;
              }
LABEL_84:

              goto LABEL_77;
            }
            ne_log_obj();
            v104 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v104, OS_LOG_TYPE_ERROR))
            {
              v194 = *(_QWORD *)(a1 + 40);
              *(_DWORD *)buf = 138412290;
              *(_QWORD *)&buf[4] = v194;
              _os_log_error_impl(&dword_19BD16000, v104, OS_LOG_TYPE_ERROR, "%@ Did not receive data in KE payload (responder rekey followup KE)", buf, 0xCu);
            }

            v97 = [NEIKEv2DeleteIKEContext alloc];
            v106 = *(id *)(a1 + 40);
            if (v106)
              v106 = objc_getProperty(v106, v105, 368, 1);
            v99 = v106;
            v238[0] = MEMORY[0x1E0C809B0];
            v238[1] = 3221225472;
            v238[2] = __120__NEIKEv2Session_Exchange__handleFollowupKEForRekeyIKESAResponder_iteration_replyPacket_replyPacketDescription_handler___block_invoke_377;
            v238[3] = &unk_1E3CC1408;
            v238[4] = *(_QWORD *)(a1 + 40);
            v100 = v238;
          }
          else
          {
            ne_log_obj();
            v101 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v101, OS_LOG_TYPE_ERROR))
            {
              v193 = *(_QWORD *)(a1 + 40);
              *(_DWORD *)buf = 138412290;
              *(_QWORD *)&buf[4] = v193;
              _os_log_error_impl(&dword_19BD16000, v101, OS_LOG_TYPE_ERROR, "%@ Did not receive method in KE payload (responder rekey followup KE)", buf, 0xCu);
            }

            v97 = [NEIKEv2DeleteIKEContext alloc];
            v103 = *(id *)(a1 + 40);
            if (v103)
              v103 = objc_getProperty(v103, v102, 368, 1);
            v99 = v103;
            v239[0] = MEMORY[0x1E0C809B0];
            v239[1] = 3221225472;
            v239[2] = __120__NEIKEv2Session_Exchange__handleFollowupKEForRekeyIKESAResponder_iteration_replyPacket_replyPacketDescription_handler___block_invoke_374;
            v239[3] = &unk_1E3CC1408;
            v239[4] = *(_QWORD *)(a1 + 40);
            v100 = v239;
          }
        }
        else
        {
          ne_log_obj();
          v95 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v95, OS_LOG_TYPE_ERROR))
          {
            v143 = *(_QWORD *)(a1 + 40);
            *(_DWORD *)buf = 138412290;
            *(_QWORD *)&buf[4] = v143;
            _os_log_error_impl(&dword_19BD16000, v95, OS_LOG_TYPE_ERROR, "%@ Did not receive KE payload (responder rekey followup KE)", buf, 0xCu);
          }

          v97 = [NEIKEv2DeleteIKEContext alloc];
          v98 = *(id *)(a1 + 40);
          if (v98)
            v98 = objc_getProperty(v98, v96, 368, 1);
          v99 = v98;
          v240[0] = MEMORY[0x1E0C809B0];
          v240[1] = 3221225472;
          v240[2] = __120__NEIKEv2Session_Exchange__handleFollowupKEForRekeyIKESAResponder_iteration_replyPacket_replyPacketDescription_handler___block_invoke_371;
          v240[3] = &unk_1E3CC1408;
          v240[4] = *(_QWORD *)(a1 + 40);
          v100 = v240;
        }
        v107 = -[NEIKEv2DeleteIKEContext initDeleteIKEWithResponse:callbackQueue:callback:]((id *)&v97->super.super.isa, 0, v99, v100);

        -[NEIKEv2Session initiateDelete:](*(_QWORD **)(a1 + 40), v107);
LABEL_76:

LABEL_77:
        goto LABEL_78;
      }
      ne_log_obj();
      v216 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v216, OS_LOG_TYPE_ERROR))
      {
        v223 = *(_QWORD *)(a1 + 40);
        *(_DWORD *)buf = 138412546;
        *(_QWORD *)&buf[4] = v223;
        *(_WORD *)&buf[12] = 2112;
        *(_QWORD *)&buf[14] = v29;
        _os_log_error_impl(&dword_19BD16000, v216, OS_LOG_TYPE_ERROR, "%@ No chosen KEM found for transform type %@ (responder rekey followup KE)", buf, 0x16u);
      }

      v218 = [NEIKEv2DeleteIKEContext alloc];
      v219 = *(id *)(a1 + 40);
      if (v219)
        v219 = objc_getProperty(v219, v217, 368, 1);
      v220 = v219;
      v241[0] = MEMORY[0x1E0C809B0];
      v241[1] = 3221225472;
      v241[2] = __120__NEIKEv2Session_Exchange__handleFollowupKEForRekeyIKESAResponder_iteration_replyPacket_replyPacketDescription_handler___block_invoke_368;
      v241[3] = &unk_1E3CC0EB0;
      v241[4] = *(_QWORD *)(a1 + 40);
      v242 = v29;
      v221 = -[NEIKEv2DeleteIKEContext initDeleteIKEWithResponse:callbackQueue:callback:]((id *)&v218->super.super.isa, 0, v220, v241);

      -[NEIKEv2Session initiateDelete:](*(_QWORD **)(a1 + 40), v221);
      v115 = v242;
      goto LABEL_84;
    }
    ne_log_obj();
    v213 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v213, OS_LOG_TYPE_ERROR))
    {
      v222 = *(_QWORD *)(a1 + 40);
      *(_DWORD *)buf = 138412290;
      *(_QWORD *)&buf[4] = v222;
      _os_log_error_impl(&dword_19BD16000, v213, OS_LOG_TYPE_ERROR, "%@ Failed to receive FOLLOWUP_KE packet (responder rekey followup KE)", buf, 0xCu);
    }

    v91 = [NEIKEv2DeleteIKEContext alloc];
    v215 = *(id *)(a1 + 40);
    if (v215)
      v215 = objc_getProperty(v215, v214, 368, 1);
    v93 = v215;
    v243[0] = MEMORY[0x1E0C809B0];
    v243[1] = 3221225472;
    v243[2] = __120__NEIKEv2Session_Exchange__handleFollowupKEForRekeyIKESAResponder_iteration_replyPacket_replyPacketDescription_handler___block_invoke_365;
    v243[3] = &unk_1E3CC1408;
    v243[4] = *(_QWORD *)(a1 + 40);
    v94 = v243;
LABEL_59:
    v23 = -[NEIKEv2DeleteIKEContext initDeleteIKEWithResponse:callbackQueue:callback:]((id *)&v91->super.super.isa, 0, v93, v94);

    -[NEIKEv2Session initiateDelete:](*(_QWORD **)(a1 + 40), v23);
LABEL_78:

    goto LABEL_79;
  }
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    ne_log_obj();
    v89 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v89, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_19BD16000, v89, OS_LOG_TYPE_ERROR, "Failed to receive Rekey IKE Delete packet (receive rekey)", buf, 2u);
    }

    v91 = [NEIKEv2DeleteIKEContext alloc];
    v92 = *(id *)(a1 + 40);
    if (v92)
      v92 = objc_getProperty(v92, v90, 368, 1);
    v93 = v92;
    v228[0] = MEMORY[0x1E0C809B0];
    v228[1] = 3221225472;
    v228[2] = __120__NEIKEv2Session_Exchange__handleFollowupKEForRekeyIKESAResponder_iteration_replyPacket_replyPacketDescription_handler___block_invoke_396;
    v228[3] = &unk_1E3CC1408;
    v228[4] = *(_QWORD *)(a1 + 40);
    v94 = v228;
    goto LABEL_59;
  }
  (*(void (**)(void))(*(_QWORD *)(a1 + 48) + 16))();
LABEL_79:

}

void __120__NEIKEv2Session_Exchange__handleFollowupKEForRekeyIKESAResponder_iteration_replyPacket_replyPacketDescription_handler___block_invoke_365(uint64_t a1, const char *a2)
{
  id Property;
  id v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *ErrorPeerInvalidSyntax;
  const char *v13;
  const char *v14;
  uint64_t v15;

  Property = *(id *)(a1 + 32);
  if (Property)
    Property = objc_getProperty(Property, a2, 336, 1);
  v4 = Property;
  ErrorPeerInvalidSyntax = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("Failed to receive FOLLOWUP_KE packet (responder rekey followup KE)"), v5, v6, v7, v8, v9, v10, v11, v15);
  -[NEIKEv2IKESA setState:error:]((uint64_t)v4, 3uLL, ErrorPeerInvalidSyntax);

  -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 32), v13);
  -[NEIKEv2Session resetAll](*(_QWORD *)(a1 + 32), v14);
}

void __120__NEIKEv2Session_Exchange__handleFollowupKEForRekeyIKESAResponder_iteration_replyPacket_replyPacketDescription_handler___block_invoke_368(uint64_t a1, const char *a2)
{
  id Property;
  id v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *ErrorInternal;
  const char *v13;
  const char *v14;

  Property = *(id *)(a1 + 32);
  if (Property)
    Property = objc_getProperty(Property, a2, 336, 1);
  v4 = Property;
  ErrorInternal = (void *)NEIKEv2CreateErrorInternal(CFSTR("No chosen KEM found for transform type %@ (responder rekey followup KE)"), v5, v6, v7, v8, v9, v10, v11, *(_QWORD *)(a1 + 40));
  -[NEIKEv2IKESA setState:error:]((uint64_t)v4, 3uLL, ErrorInternal);

  -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 32), v13);
  -[NEIKEv2Session resetAll](*(_QWORD *)(a1 + 32), v14);
}

void __120__NEIKEv2Session_Exchange__handleFollowupKEForRekeyIKESAResponder_iteration_replyPacket_replyPacketDescription_handler___block_invoke_371(uint64_t a1, const char *a2)
{
  id Property;
  id v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *ErrorPeerInvalidSyntax;
  const char *v13;
  const char *v14;
  uint64_t v15;

  Property = *(id *)(a1 + 32);
  if (Property)
    Property = objc_getProperty(Property, a2, 336, 1);
  v4 = Property;
  ErrorPeerInvalidSyntax = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("Did not receive KE payload (responder rekey followup KE)"), v5, v6, v7, v8, v9, v10, v11, v15);
  -[NEIKEv2IKESA setState:error:]((uint64_t)v4, 3uLL, ErrorPeerInvalidSyntax);

  -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 32), v13);
  -[NEIKEv2Session resetAll](*(_QWORD *)(a1 + 32), v14);
}

void __120__NEIKEv2Session_Exchange__handleFollowupKEForRekeyIKESAResponder_iteration_replyPacket_replyPacketDescription_handler___block_invoke_374(uint64_t a1, const char *a2)
{
  id Property;
  id v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *ErrorPeerInvalidSyntax;
  const char *v13;
  const char *v14;
  uint64_t v15;

  Property = *(id *)(a1 + 32);
  if (Property)
    Property = objc_getProperty(Property, a2, 336, 1);
  v4 = Property;
  ErrorPeerInvalidSyntax = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("Did not receive method in KE payload (responder rekey followup KE)"), v5, v6, v7, v8, v9, v10, v11, v15);
  -[NEIKEv2IKESA setState:error:]((uint64_t)v4, 3uLL, ErrorPeerInvalidSyntax);

  -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 32), v13);
  -[NEIKEv2Session resetAll](*(_QWORD *)(a1 + 32), v14);
}

void __120__NEIKEv2Session_Exchange__handleFollowupKEForRekeyIKESAResponder_iteration_replyPacket_replyPacketDescription_handler___block_invoke_377(uint64_t a1, const char *a2)
{
  id Property;
  id v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *ErrorPeerInvalidSyntax;
  const char *v13;
  const char *v14;
  uint64_t v15;

  Property = *(id *)(a1 + 32);
  if (Property)
    Property = objc_getProperty(Property, a2, 336, 1);
  v4 = Property;
  ErrorPeerInvalidSyntax = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("Did not receive data in KE payload (responder rekey followup KE)"), v5, v6, v7, v8, v9, v10, v11, v15);
  -[NEIKEv2IKESA setState:error:]((uint64_t)v4, 3uLL, ErrorPeerInvalidSyntax);

  -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 32), v13);
  -[NEIKEv2Session resetAll](*(_QWORD *)(a1 + 32), v14);
}

void __120__NEIKEv2Session_Exchange__handleFollowupKEForRekeyIKESAResponder_iteration_replyPacket_replyPacketDescription_handler___block_invoke_380(uint64_t a1, const char *a2)
{
  id Property;
  const char *v4;
  id v5;
  void *v6;
  id v7;
  const char *v8;
  void *v9;
  id v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *ErrorPeerInvalidSyntax;
  const char *v20;
  const char *v21;

  Property = *(id *)(a1 + 32);
  if (Property)
    Property = objc_getProperty(Property, a2, 336, 1);
  v5 = Property;
  v6 = *(void **)(a1 + 40);
  if (v6)
  {
    v7 = objc_getProperty(v6, v4, 88, 1);
    v9 = v7;
    if (v7)
      v7 = objc_getProperty(v7, v8, 24, 1);
  }
  else
  {
    v9 = 0;
    v7 = 0;
  }
  v10 = v7;
  v11 = objc_msgSend(v10, "method");
  objc_msgSend(*(id *)(a1 + 48), "method");
  ErrorPeerInvalidSyntax = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("Did not receive matching method from KE payload (%zu != %zu) (responder rekey followup KE)"), v12, v13, v14, v15, v16, v17, v18, v11);
  -[NEIKEv2IKESA setState:error:]((uint64_t)v5, 3uLL, ErrorPeerInvalidSyntax);

  -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 32), v20);
  -[NEIKEv2Session resetAll](*(_QWORD *)(a1 + 32), v21);
}

void __120__NEIKEv2Session_Exchange__handleFollowupKEForRekeyIKESAResponder_iteration_replyPacket_replyPacketDescription_handler___block_invoke_385(uint64_t *a1, const char *a2)
{
  id Property;
  const char *v4;
  id v5;
  void *v6;
  id v7;
  const char *v8;
  void *v9;
  const char *v10;
  id v11;
  void *v12;
  id v13;
  const char *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void *ErrorPeerInvalidSyntax;
  const char *v24;
  const char *v25;
  id v26;

  Property = (id)a1[4];
  if (Property)
    Property = objc_getProperty(Property, a2, 336, 1);
  v5 = Property;
  v6 = (void *)a1[5];
  if (v6)
  {
    v7 = objc_getProperty(v6, v4, 96, 1);
    v9 = v7;
    if (v7)
      v7 = objc_getProperty(v7, v8, 32, 1);
  }
  else
  {
    v9 = 0;
    v7 = 0;
  }
  v11 = v7;
  v12 = (void *)a1[6];
  if (v12)
  {
    v13 = objc_getProperty(v12, v10, 176, 1);
    v15 = v13;
    if (v13)
      v13 = objc_getProperty(v13, v14, 32, 1);
  }
  else
  {
    v15 = 0;
    v13 = 0;
  }
  v26 = v13;
  ErrorPeerInvalidSyntax = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("ADDITIONAL_KEY_EXCHANGE in FOLLOWUP_KE request doesn't match expected (%@ != %@) (responder rekey followup KE)"), v16, v17, v18, v19, v20, v21, v22, (uint64_t)v11);
  -[NEIKEv2IKESA setState:error:]((uint64_t)v5, 3uLL, ErrorPeerInvalidSyntax);

  -[NEIKEv2Session reportState]((_QWORD *)a1[4], v24);
  -[NEIKEv2Session resetAll](a1[4], v25);
}

void __120__NEIKEv2Session_Exchange__handleFollowupKEForRekeyIKESAResponder_iteration_replyPacket_replyPacketDescription_handler___block_invoke_388(uint64_t a1, const char *a2)
{
  id Property;
  id v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *ErrorInternal;
  const char *v13;
  const char *v14;

  Property = *(id *)(a1 + 32);
  if (Property)
    Property = objc_getProperty(Property, a2, 336, 1);
  v4 = Property;
  ErrorInternal = (void *)NEIKEv2CreateErrorInternal(CFSTR("Failed to generate values for KEM %@ (responder rekey followup KE)"), v5, v6, v7, v8, v9, v10, v11, *(_QWORD *)(a1 + 40));
  -[NEIKEv2IKESA setState:error:]((uint64_t)v4, 3uLL, ErrorInternal);

  -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 32), v13);
  -[NEIKEv2Session resetAll](*(_QWORD *)(a1 + 32), v14);
}

void __120__NEIKEv2Session_Exchange__handleFollowupKEForRekeyIKESAResponder_iteration_replyPacket_replyPacketDescription_handler___block_invoke_391(uint64_t a1, const char *a2)
{
  id Property;
  id v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *ErrorInternal;
  const char *v13;
  const char *v14;
  uint64_t v15;

  Property = *(id *)(a1 + 32);
  if (Property)
    Property = objc_getProperty(Property, a2, 336, 1);
  v4 = Property;
  ErrorInternal = (void *)NEIKEv2CreateErrorInternal(CFSTR("Failed to create FOLLOWUP_KE packet (responder rekey followup KE)"), v5, v6, v7, v8, v9, v10, v11, v15);
  -[NEIKEv2IKESA setState:error:]((uint64_t)v4, 3uLL, ErrorInternal);

  -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 32), v13);
  -[NEIKEv2Session resetAll](*(_QWORD *)(a1 + 32), v14);
}

void __120__NEIKEv2Session_Exchange__handleFollowupKEForRekeyIKESAResponder_iteration_replyPacket_replyPacketDescription_handler___block_invoke_396(uint64_t a1, const char *a2)
{
  id Property;
  id v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *ErrorPeerInvalidSyntax;
  const char *v13;
  const char *v14;
  uint64_t v15;

  Property = *(id *)(a1 + 32);
  if (Property)
    Property = objc_getProperty(Property, a2, 336, 1);
  v4 = Property;
  ErrorPeerInvalidSyntax = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("Failed to receive Rekey IKE Delete packet (receive rekey)"), v5, v6, v7, v8, v9, v10, v11, v15);
  -[NEIKEv2IKESA setState:error:]((uint64_t)v4, 3uLL, ErrorPeerInvalidSyntax);

  -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 32), v13);
  -[NEIKEv2Session resetAll](*(_QWORD *)(a1 + 32), v14);
}

- (void)initiateRekeyIKESA:(_BYTE *)a1
{
  const char *v3;
  id v4;
  id Property;
  NSObject *v6;
  const char *v7;
  id v8;
  void *v9;
  NSObject *v10;
  const char *v11;
  NSObject *v12;
  NSObject *v13;
  SEL v14;
  id v15;
  NSObject *v16;
  NSObject *v17;
  NEIKEv2IKESAPayload *v18;
  SEL v19;
  SEL v20;
  id *v21;
  NEIKEv2IKESAProposal *v22;
  const char *v23;
  NEIKEv2IKESAProposal *v24;
  const char *v25;
  void *v26;
  SEL v27;
  const char *v28;
  void *v29;
  SEL v30;
  const char *v31;
  void *v32;
  SEL v33;
  const char *v34;
  void *v35;
  void *v36;
  void *v37;
  uint64_t v38;
  SEL v39;
  uint64_t v40;
  const char *v41;
  id v42;
  void *v43;
  void *v44;
  NSObject *v45;
  void *v46;
  uint64_t v47;
  NSObject *v48;
  NEIKEv2DeleteIKEContext *v49;
  SEL v50;
  id v51;
  id *v52;
  NSObject *v53;
  NSObject *v54;
  NEIKEv2DeleteIKEContext *v55;
  SEL v56;
  id v57;
  id *v58;
  NSObject *v59;
  NSObject *v60;
  id v61;
  SEL v62;
  id v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t i;
  uint64_t v68;
  void *v69;
  void *v70;
  void *v71;
  void *v72;
  NEIKEv2IKESAProposal *v73;
  void *v74;
  SEL v75;
  void *v76;
  const char *v77;
  void *v78;
  SEL v79;
  id v80;
  SEL v81;
  void *v82;
  const char *v83;
  void *v84;
  SEL v85;
  void *v86;
  char v87;
  NEIKEv2NoncePayload *v88;
  SEL v89;
  SEL v90;
  id v91;
  SEL v92;
  void *v93;
  const char *v94;
  void *v95;
  SEL v96;
  void *v97;
  char v98;
  void *v99;
  id v100;
  NEIKEv2KeyExchangePayload *v101;
  SEL v102;
  SEL v103;
  id v104;
  const char *v105;
  void *v106;
  SEL v107;
  void *v108;
  const char *v109;
  void *v110;
  SEL v111;
  id v112;
  void *v113;
  void *v114;
  id v115;
  SEL v116;
  void *v117;
  const char *v118;
  void *v119;
  SEL v120;
  void *v121;
  char v122;
  NSObject *v123;
  const char *v124;
  id v125;
  const char *v126;
  id v127;
  id v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  void *ErrorFailedToSend;
  const char *v137;
  const char *v138;
  NSObject *v139;
  const char *v140;
  NEIKEv2DeleteIKEContext *v141;
  id v142;
  id v143;
  id *v144;
  NSObject *v145;
  NSObject *v146;
  uint64_t v147;
  id v148;
  NEIKEv2IKESAProposal *v149;
  NSObject *v150;
  NSObject *self;
  NSObject *v152;
  _QWORD v153[5];
  id v154;
  NSObject *v155;
  id v156;
  _QWORD v157[4];
  id v158;
  _BYTE *v159;
  _QWORD v160[4];
  NSObject *v161;
  _BYTE *v162;
  _QWORD v163[4];
  NSObject *v164;
  _BYTE *v165;
  uint8_t buf[4];
  const char *v167;
  __int128 v168;
  __int128 v169;
  __int128 v170;
  __int128 v171;
  uint64_t v172;

  v172 = *MEMORY[0x1E0C80C00];
  v4 = a2;
  if (a1)
    Property = objc_getProperty(a1, v3, 368, 1);
  else
    Property = 0;
  v6 = Property;
  dispatch_assert_queue_V2(v6);

  if (!a1[15])
    __assert_rtn("-[NEIKEv2Session(Exchange) initiateRekeyIKESA:]", "NEIKEv2Exchange.m", 2550, "self.hasOutboundRequestInFlight");
  v8 = objc_getProperty(a1, v7, 336, 1);
  v9 = v8;
  if (v8)
  {
    if ((*((_BYTE *)v8 + 16) & 1) == 0)
    {
      *((_BYTE *)v8 + 16) = 1;
      v10 = -[NEIKEv2IKESA copyForRekey]((uint64_t)v8);
      v12 = v10;
      if (!v10)
      {
        ne_log_obj();
        v48 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)buf = 0;
          _os_log_error_impl(&dword_19BD16000, v48, OS_LOG_TYPE_ERROR, "Failed to create valid IKE SA (initiate rekey)", buf, 2u);
        }

        v49 = [NEIKEv2DeleteIKEContext alloc];
        v51 = objc_getProperty(a1, v50, 368, 1);
        v163[0] = MEMORY[0x1E0C809B0];
        v163[1] = 3221225472;
        v163[2] = __47__NEIKEv2Session_Exchange__initiateRekeyIKESA___block_invoke;
        v163[3] = &unk_1E3CC0EB0;
        v164 = v4;
        v165 = a1;
        v52 = -[NEIKEv2DeleteIKEContext initDeleteIKEWithResponse:callbackQueue:callback:]((id *)&v49->super.super.isa, 0, v51, v163);

        -[NEIKEv2Session initiateDelete:](a1, v52);
        v53 = v164;
        goto LABEL_82;
      }
      BYTE1(v10[1].isa) = 1;
      if ((-[NEIKEv2IKESA generateInitialValues](v10, v11) & 1) == 0)
      {
        ne_log_obj();
        v54 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)buf = 0;
          _os_log_error_impl(&dword_19BD16000, v54, OS_LOG_TYPE_ERROR, "Failed to generate local IKE crypto values", buf, 2u);
        }

        v55 = [NEIKEv2DeleteIKEContext alloc];
        v57 = objc_getProperty(a1, v56, 368, 1);
        v160[0] = MEMORY[0x1E0C809B0];
        v160[1] = 3221225472;
        v160[2] = __47__NEIKEv2Session_Exchange__initiateRekeyIKESA___block_invoke_401;
        v160[3] = &unk_1E3CC0EB0;
        v161 = v4;
        v162 = a1;
        v58 = -[NEIKEv2DeleteIKEContext initDeleteIKEWithResponse:callbackQueue:callback:]((id *)&v55->super.super.isa, 0, v57, v160);

        -[NEIKEv2Session initiateDelete:](a1, v58);
        v53 = v161;
        goto LABEL_82;
      }
      v13 = v12;
      objc_opt_self();
      v15 = objc_getProperty(v13, v14, 96, 1);

      if (!v15)
      {
        ne_log_obj();
        v59 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v59, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 136315138;
          v167 = "+[NEIKEv2CreateChildPacket(Exchange) createRekeyIKESAForInitiator:]";
          _os_log_fault_impl(&dword_19BD16000, v59, OS_LOG_TYPE_FAULT, "%s called with null ikeSA.chosenProposal", buf, 0xCu);
        }
        goto LABEL_70;
      }
      v16 = -[NEIKEv2Packet initOutbound]([NEIKEv2CreateChildPacket alloc]);
      if (!v16)
      {
        ne_log_obj();
        v60 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v60, OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_fault_impl(&dword_19BD16000, v60, OS_LOG_TYPE_FAULT, "[[NEIKEv2CreateChildPacket alloc] initOutbound:] failed", buf, 2u);
        }

        v59 = 0;
        goto LABEL_70;
      }
      v17 = v16;
      v18 = objc_alloc_init(NEIKEv2IKESAPayload);
      objc_setProperty_atomic(v17, v19, v18, 88);

      v21 = (id *)objc_getProperty(v13, v20, 96, 1);
      self = v13;
      v152 = v17;
      if (!v21)
      {
        v24 = 0;
LABEL_50:
        v73 = v24;
        *(_QWORD *)&v168 = v24;
        objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", &v168, 1);
        v74 = (void *)objc_claimAutoreleasedReturnValue();
        objc_getProperty(v17, v75, 88, 1);
        v76 = (void *)objc_claimAutoreleasedReturnValue();
        v78 = v76;
        if (v76)
          objc_setProperty_atomic(v76, v77, v74, 24);

        v13 = self;
        v80 = objc_getProperty(self, v79, 32, 1);
        v59 = v152;
        objc_getProperty(v152, v81, 88, 1);
        v82 = (void *)objc_claimAutoreleasedReturnValue();
        v84 = v82;
        if (v82)
          objc_setProperty_atomic(v82, v83, v80, 32);

        objc_getProperty(v152, v85, 88, 1);
        v86 = (void *)objc_claimAutoreleasedReturnValue();
        v87 = -[NEIKEv2Payload isValid]((uint64_t)v86);

        if ((v87 & 1) != 0)
        {
          v88 = objc_alloc_init(NEIKEv2NoncePayload);
          objc_setProperty_atomic(v152, v89, v88, 112);

          v91 = objc_getProperty(self, v90, 128, 1);
          objc_getProperty(v152, v92, 112, 1);
          v93 = (void *)objc_claimAutoreleasedReturnValue();
          v95 = v93;
          if (v93)
            objc_setProperty_atomic(v93, v94, v91, 24);

          objc_getProperty(v152, v96, 112, 1);
          v97 = (void *)objc_claimAutoreleasedReturnValue();
          v98 = -[NEIKEv2Payload isValid]((uint64_t)v97);

          if ((v98 & 1) != 0)
          {
            v99 = v9;
            v100 = v4;
            v101 = objc_alloc_init(NEIKEv2KeyExchangePayload);
            objc_setProperty_atomic(v152, v102, v101, 104);

            v104 = objc_getProperty(self, v103, 96, 1);
            -[NEIKEv2IKESAProposal kemProtocol](v104, v105);
            v106 = (void *)objc_claimAutoreleasedReturnValue();
            objc_getProperty(v152, v107, 104, 1);
            v108 = (void *)objc_claimAutoreleasedReturnValue();
            v110 = v108;
            if (v108)
              objc_setProperty_atomic(v108, v109, v106, 24);

            v112 = objc_getProperty(self, v111, 160, 1);
            v113 = v112;
            if (v112)
              v114 = (void *)*((_QWORD *)v112 + 2);
            else
              v114 = 0;
            v115 = v114;
            objc_getProperty(v152, v116, 104, 1);
            v117 = (void *)objc_claimAutoreleasedReturnValue();
            v119 = v117;
            if (v117)
              objc_setProperty_atomic(v117, v118, v115, 32);

            objc_getProperty(v152, v120, 104, 1);
            v121 = (void *)objc_claimAutoreleasedReturnValue();
            v122 = -[NEIKEv2Payload isValid]((uint64_t)v121);

            if ((v122 & 1) != 0)
            {
              v53 = v152;
              v4 = v100;
              v9 = v99;
              v13 = self;
              v59 = v53;
            }
            else
            {
              ne_log_obj();
              v145 = objc_claimAutoreleasedReturnValue();
              v4 = v100;
              if (os_log_type_enabled(v145, OS_LOG_TYPE_FAULT))
              {
                *(_DWORD *)buf = 136315138;
                v167 = "+[NEIKEv2CreateChildPacket(Exchange) createRekeyIKESAForInitiator:]";
                _os_log_fault_impl(&dword_19BD16000, v145, OS_LOG_TYPE_FAULT, "%s called with null packet.ke.isValid", buf, 0xCu);
              }

              v53 = 0;
              v9 = v99;
              v13 = self;
              v59 = v152;
            }
            goto LABEL_71;
          }
          ne_log_obj();
          v123 = objc_claimAutoreleasedReturnValue();
          if (!os_log_type_enabled(v123, OS_LOG_TYPE_FAULT))
            goto LABEL_69;
          *(_DWORD *)buf = 136315138;
          v167 = "+[NEIKEv2CreateChildPacket(Exchange) createRekeyIKESAForInitiator:]";
          v124 = "%s called with null packet.nonce.isValid";
        }
        else
        {
          ne_log_obj();
          v123 = objc_claimAutoreleasedReturnValue();
          if (!os_log_type_enabled(v123, OS_LOG_TYPE_FAULT))
          {
LABEL_69:

LABEL_70:
            v53 = 0;
LABEL_71:

            if (v53)
            {
              v153[0] = MEMORY[0x1E0C809B0];
              v153[1] = 3221225472;
              v153[2] = __47__NEIKEv2Session_Exchange__initiateRekeyIKESA___block_invoke_2;
              v153[3] = &unk_1E3CC1220;
              v153[4] = a1;
              v125 = v4;
              v154 = v125;
              v155 = v13;
              v156 = v9;
              if (-[NEIKEv2Session sendRequest:retry:replyHandler:]((uint64_t)a1, v53, v153) == -1)
              {
                objc_msgSend(v125, "sendCallbackSuccess:session:", 0, a1);
                if (a1)
                  v127 = objc_getProperty(a1, v126, 336, 1);
                else
                  v127 = 0;
                v128 = v127;
                ErrorFailedToSend = (void *)NEIKEv2CreateErrorFailedToSend(CFSTR("initiator rekey IKE SA"), v129, v130, v131, v132, v133, v134, v135, v147);
                -[NEIKEv2IKESA setState:error:]((uint64_t)v128, 3uLL, ErrorFailedToSend);

                -[NEIKEv2Session reportState](a1, v137);
                -[NEIKEv2Session resetAll]((uint64_t)a1, v138);
              }

            }
            else
            {
              ne_log_obj();
              v139 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v139, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)buf = 0;
                _os_log_error_impl(&dword_19BD16000, v139, OS_LOG_TYPE_ERROR, "Failed to create Create Child SA packet (initiate rekey)", buf, 2u);
              }

              v141 = [NEIKEv2DeleteIKEContext alloc];
              if (a1)
                v142 = objc_getProperty(a1, v140, 368, 1);
              else
                v142 = 0;
              v143 = v142;
              v157[0] = MEMORY[0x1E0C809B0];
              v157[1] = 3221225472;
              v157[2] = __47__NEIKEv2Session_Exchange__initiateRekeyIKESA___block_invoke_404;
              v157[3] = &unk_1E3CC0EB0;
              v158 = v4;
              v159 = a1;
              v144 = -[NEIKEv2DeleteIKEContext initDeleteIKEWithResponse:callbackQueue:callback:]((id *)&v141->super.super.isa, 0, v143, v157);

              -[NEIKEv2Session initiateDelete:](a1, v144);
              v53 = 0;
            }
LABEL_82:

            goto LABEL_83;
          }
          *(_DWORD *)buf = 136315138;
          v167 = "+[NEIKEv2CreateChildPacket(Exchange) createRekeyIKESAForInitiator:]";
          v124 = "%s called with null packet.ikeSA.isValid";
        }
        _os_log_fault_impl(&dword_19BD16000, v123, OS_LOG_TYPE_FAULT, v124, buf, 0xCu);
        goto LABEL_69;
      }
      v22 = objc_alloc_init(NEIKEv2IKESAProposal);
      v24 = v22;
      if (v22)
        v22->_proposalNumber = 1;
      v26 = (void *)objc_msgSend(objc_getProperty(v21, v23, 88, 1), "copy");
      if (v24)
        objc_setProperty_atomic(v24, v25, v26, 88);

      v29 = (void *)objc_msgSend(objc_getProperty(v21, v27, 96, 1), "copy");
      if (v24)
        objc_setProperty_atomic(v24, v28, v29, 96);

      v32 = (void *)objc_msgSend(objc_getProperty(v21, v30, 104, 1), "copy");
      if (v24)
        objc_setProperty_atomic(v24, v31, v32, 104);

      v35 = (void *)objc_msgSend(objc_getProperty(v21, v33, 112, 1), "copy");
      if (v24)
        objc_setProperty_atomic(v24, v34, v35, 112);

      -[NEIKEv2IKESAProposal chosenAdditionalKEMProtocols](v21);
      v36 = (void *)objc_claimAutoreleasedReturnValue();

      if (v36)
      {
        v149 = v24;
        v150 = v12;
        -[NEIKEv2IKESAProposal chosenAdditionalKEMProtocols](v21);
        v37 = (void *)objc_claimAutoreleasedReturnValue();
        v38 = objc_msgSend(v37, "count");
        v40 = objc_msgSend(objc_getProperty(v21, v39, 120, 1), "count");

        if (v38 == v40)
        {
          v42 = objc_alloc(MEMORY[0x1E0C99D80]);
          -[NEIKEv2IKESAProposal chosenAdditionalKEMProtocols](v21);
          v43 = (void *)objc_claimAutoreleasedReturnValue();
          v44 = (void *)objc_msgSend(v42, "initWithDictionary:copyItems:", v43, 1);
          -[NEIKEv2IKESAProposal setChosenAdditionalKEMProtocols:](v149, v44);

          v24 = v149;
LABEL_48:
          v12 = v150;
          v17 = v152;
          goto LABEL_49;
        }
        v24 = v149;
        v12 = v150;
        if (objc_getProperty(v21, v41, 120, 1))
        {
          v147 = (uint64_t)v9;
          v148 = v4;
          v61 = objc_alloc_init(MEMORY[0x1E0C99E08]);
          v168 = 0u;
          v169 = 0u;
          v170 = 0u;
          v171 = 0u;
          v63 = objc_getProperty(v21, v62, 120, 1);
          v64 = objc_msgSend(v63, "countByEnumeratingWithState:objects:count:", &v168, buf, 16);
          if (v64)
          {
            v65 = v64;
            v66 = *(_QWORD *)v169;
            do
            {
              for (i = 0; i != v65; ++i)
              {
                if (*(_QWORD *)v169 != v66)
                  objc_enumerationMutation(v63);
                v68 = *(_QWORD *)(*((_QWORD *)&v168 + 1) + 8 * i);
                -[NEIKEv2IKESAProposal chosenAdditionalKEMProtocols](v21);
                v69 = (void *)objc_claimAutoreleasedReturnValue();
                objc_msgSend(v69, "objectForKeyedSubscript:", v68);
                v70 = (void *)objc_claimAutoreleasedReturnValue();
                objc_msgSend(v61, "setObject:forKeyedSubscript:", v70, v68);

              }
              v65 = objc_msgSend(v63, "countByEnumeratingWithState:objects:count:", &v168, buf, 16);
            }
            while (v65);
          }

          v71 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99D80]), "initWithDictionary:copyItems:", v61, 1);
          -[NEIKEv2IKESAProposal setChosenAdditionalKEMProtocols:](v149, v71);

          v24 = v149;
          v9 = (void *)v147;
          v4 = v148;
          goto LABEL_48;
        }
      }
LABEL_49:
      v72 = (void *)objc_msgSend(v21[16], "copy", v147);
      -[NEConfigurationManager setAppGroupMap:]((uint64_t)v24, v72);

      goto LABEL_50;
    }
    ne_log_obj();
    v45 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      _os_log_debug_impl(&dword_19BD16000, v45, OS_LOG_TYPE_DEBUG, "IKE SA already rekeying, skipping (initiate rekey)", buf, 2u);
    }

    v46 = v4;
    v47 = 1;
  }
  else
  {
    ne_log_obj();
    v146 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v146, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136315138;
      v167 = "-[NEIKEv2Session(Exchange) initiateRekeyIKESA:]";
      _os_log_fault_impl(&dword_19BD16000, v146, OS_LOG_TYPE_FAULT, "%s called with null oldIKESA", buf, 0xCu);
    }

    v46 = v4;
    v47 = 0;
  }
  objc_msgSend(v46, "sendCallbackSuccess:session:", v47, a1);
LABEL_83:

}

void __47__NEIKEv2Session_Exchange__initiateRekeyIKESA___block_invoke(uint64_t a1)
{
  const char *v2;
  id Property;
  id v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *ErrorInternal;
  const char *v13;
  const char *v14;
  uint64_t v15;

  objc_msgSend(*(id *)(a1 + 32), "sendCallbackSuccess:session:", 0, *(_QWORD *)(a1 + 40));
  Property = *(id *)(a1 + 40);
  if (Property)
    Property = objc_getProperty(Property, v2, 336, 1);
  v4 = Property;
  ErrorInternal = (void *)NEIKEv2CreateErrorInternal(CFSTR("Failed to create valid IKE SA (initiate rekey)"), v5, v6, v7, v8, v9, v10, v11, v15);
  -[NEIKEv2IKESA setState:error:]((uint64_t)v4, 3uLL, ErrorInternal);

  -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 40), v13);
  -[NEIKEv2Session resetAll](*(_QWORD *)(a1 + 40), v14);
}

void __47__NEIKEv2Session_Exchange__initiateRekeyIKESA___block_invoke_401(uint64_t a1)
{
  const char *v2;
  id Property;
  id v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *ErrorCrypto;
  const char *v13;
  const char *v14;
  uint64_t v15;

  objc_msgSend(*(id *)(a1 + 32), "sendCallbackSuccess:session:", 0, *(_QWORD *)(a1 + 40));
  Property = *(id *)(a1 + 40);
  if (Property)
    Property = objc_getProperty(Property, v2, 336, 1);
  v4 = Property;
  ErrorCrypto = (void *)NEIKEv2CreateErrorCrypto(CFSTR("Failed to generate local IKE crypto values (initiate rekey)"), v5, v6, v7, v8, v9, v10, v11, v15);
  -[NEIKEv2IKESA setState:error:]((uint64_t)v4, 3uLL, ErrorCrypto);

  -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 40), v13);
  -[NEIKEv2Session resetAll](*(_QWORD *)(a1 + 40), v14);
}

void __47__NEIKEv2Session_Exchange__initiateRekeyIKESA___block_invoke_404(uint64_t a1)
{
  const char *v2;
  id Property;
  id v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *ErrorInternal;
  const char *v13;
  const char *v14;
  uint64_t v15;

  objc_msgSend(*(id *)(a1 + 32), "sendCallbackSuccess:session:", 0, *(_QWORD *)(a1 + 40));
  Property = *(id *)(a1 + 40);
  if (Property)
    Property = objc_getProperty(Property, v2, 336, 1);
  v4 = Property;
  ErrorInternal = (void *)NEIKEv2CreateErrorInternal(CFSTR("Failed to create Create Child SA packet (initiate rekey)"), v5, v6, v7, v8, v9, v10, v11, v15);
  -[NEIKEv2IKESA setState:error:]((uint64_t)v4, 3uLL, ErrorInternal);

  -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 40), v13);
  -[NEIKEv2Session resetAll](*(_QWORD *)(a1 + 40), v14);
}

void __47__NEIKEv2Session_Exchange__initiateRekeyIKESA___block_invoke_2(uint64_t a1, void *a2)
{
  id v3;
  id v4;
  const char *v5;
  void *v6;
  const char *v7;
  NSObject *ErrorPeerInvalidSyntax;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t i;
  const __CFString *v13;
  void *v14;
  const char *v15;
  void *v16;
  id v17;
  uint64_t v18;
  const char *v19;
  void *v20;
  const char *v21;
  void *v22;
  id v23;
  SEL v24;
  void *v25;
  const char *v26;
  void *v27;
  _BYTE *v28;
  const char *v29;
  const char *v30;
  id v31;
  void *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  void *v37;
  NSObject *v38;
  const char *v39;
  NEIKEv2DeleteIKEContext *v40;
  id Property;
  id v42;
  id *v43;
  id v44;
  uint64_t v45;
  _QWORD *v46;
  NSObject *v47;
  NSObject *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  NSObject *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  NSObject *v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  id v73;
  NSObject *v74;
  SEL v75;
  SEL v76;
  id v77;
  const char *v78;
  void *v79;
  const char *v80;
  void *v81;
  const char *v82;
  void *v83;
  id v84;
  const char *v85;
  void *v86;
  const char *v87;
  void *v88;
  id v89;
  const char *v90;
  void *v91;
  const char *v92;
  id v93;
  SEL v94;
  id v95;
  const char *v96;
  void *v97;
  uint64_t v98;
  const char *v99;
  void *v100;
  const char *v101;
  void *v102;
  id v103;
  SEL v104;
  _QWORD *v105;
  SEL v106;
  int *v107;
  SEL v108;
  void *v109;
  const char *v110;
  void *v111;
  const char *v112;
  void *v113;
  int *v114;
  id v115;
  const char *v116;
  id v117;
  int v118;
  const char *v119;
  void *v120;
  const char *v121;
  void *v122;
  id v123;
  unint64_t v124;
  const char *v125;
  id v126;
  const char *v127;
  void *v128;
  unsigned int v129;
  BOOL v130;
  NSObject *v131;
  SEL v132;
  id v133;
  const char *v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  void *v142;
  NSObject *v143;
  SEL v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  void *v152;
  char *v153;
  NSObject *v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  __CFString *v162;
  char *v163;
  char *v164;
  uint64_t v165;
  NSObject *v166;
  char *v167;
  NSObject *v168;
  char *v169;
  SEL v170;
  id v171;
  void *v172;
  NSObject *v173;
  NSObject *v174;
  int *v175;
  SEL v176;
  void *v177;
  const char *v178;
  uint64_t v179;
  SEL v180;
  id v181;
  const char *v182;
  void *v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  void *v191;
  NSObject *v192;
  void *v193;
  const char *v194;
  void *v195;
  id v196;
  SEL v197;
  const char *v198;
  void *v199;
  void *v200;
  _QWORD *v201;
  id v202;
  id v203;
  uint64_t v204;
  void *v205;
  char *v206;
  NSObject *v207;
  void *v208;
  NSObject *v209;
  const char *v210;
  id v211;
  id v212;
  uint64_t v213;
  id *v214;
  char *v215;
  char *v216;
  char *v217;
  SEL v218;
  void *v219;
  const char *v220;
  SEL v221;
  id v222;
  const char *v223;
  void *v224;
  uint64_t v225;
  char *v226;
  char *v227;
  char *v228;
  SEL v229;
  id v230;
  const char *v231;
  void *v232;
  NSObject *v233;
  const char *v234;
  id v235;
  id v236;
  uint64_t v237;
  NSObject *v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t v245;
  char *v246;
  uint64_t v247;
  void *v248;
  uint64_t v249;
  id v250;
  uint64_t v251;
  char *v252;
  void *v253;
  id v254;
  void *v255;
  unint64_t v256;
  _QWORD v257[4];
  id v258;
  id v259;
  uint64_t v260;
  id v261;
  _QWORD v262[4];
  _QWORD v263[2];
  _QWORD v264[4];
  _QWORD v265[2];
  _QWORD v266[4];
  _QWORD v267[2];
  __int128 v268;
  __int128 v269;
  __int128 v270;
  __int128 v271;
  __int128 v272;
  __int128 v273;
  __int128 v274;
  __int128 v275;
  uint8_t v276[4];
  const char *v277;
  __int16 v278;
  _BYTE *v279;
  __int16 v280;
  uint64_t v281;
  uint8_t v282[128];
  uint8_t buf[136];
  uint64_t v284;

  v284 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    ne_log_obj();
    v38 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_19BD16000, v38, OS_LOG_TYPE_ERROR, "Failed to receive Create Child SA packet (initiate rekey)", buf, 2u);
    }

    v40 = [NEIKEv2DeleteIKEContext alloc];
    Property = *(id *)(a1 + 32);
    if (Property)
      Property = objc_getProperty(Property, v39, 368, 1);
    v42 = Property;
    v266[0] = MEMORY[0x1E0C809B0];
    v266[1] = 3221225472;
    v266[2] = __47__NEIKEv2Session_Exchange__initiateRekeyIKESA___block_invoke_407;
    v266[3] = &unk_1E3CC0EB0;
    v43 = (id *)v267;
    v44 = *(id *)(a1 + 40);
    v45 = *(_QWORD *)(a1 + 32);
    v267[0] = v44;
    v267[1] = v45;
    v46 = v266;
    goto LABEL_117;
  }
  v4 = *(id *)(a1 + 48);
  v6 = v4;
  if (!v3)
    goto LABEL_112;
  if (!v4)
  {
    ne_log_obj();
    ErrorPeerInvalidSyntax = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(ErrorPeerInvalidSyntax, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)v276 = 136315138;
      v277 = "-[NEIKEv2CreateChildPacket(Exchange) validateRekeyIKESA:]";
      _os_log_fault_impl(&dword_19BD16000, ErrorPeerInvalidSyntax, OS_LOG_TYPE_FAULT, "%s called with null ikeSA", v276, 0xCu);
    }
    goto LABEL_111;
  }
  if (!-[NEIKEv2Packet hasErrors](v3, v5))
    goto LABEL_15;
  v274 = 0u;
  v275 = 0u;
  v272 = 0u;
  v273 = 0u;
  ErrorPeerInvalidSyntax = objc_getProperty(v3, v7, 64, 1);
  v9 = -[NSObject countByEnumeratingWithState:objects:count:](ErrorPeerInvalidSyntax, "countByEnumeratingWithState:objects:count:", &v272, buf, 16);
  if (!v9)
    goto LABEL_14;
  v10 = v9;
  v11 = *(_QWORD *)v273;
  do
  {
    for (i = 0; i != v10; ++i)
    {
      if (*(_QWORD *)v273 != v11)
        objc_enumerationMutation(ErrorPeerInvalidSyntax);
      v13 = *(const __CFString **)(*((_QWORD *)&v272 + 1) + 8 * i);
      if (v13 && (unint64_t)(v13->length - 1) <= 0x3FFE)
      {
        v28 = -[NEIKEv2NotifyPayload copyError](v13);
        ne_log_obj();
        v47 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
        {
          v153 = (char *)objc_msgSend(v3, "copyShortDescription");
          *(_DWORD *)v276 = 138412546;
          v277 = v153;
          v278 = 2112;
          v279 = v28;
          _os_log_error_impl(&dword_19BD16000, v47, OS_LOG_TYPE_ERROR, "%@ Rekey IKE received notify error %@", v276, 0x16u);

        }
LABEL_47:
        -[NEIKEv2IKESA setState:error:]((uint64_t)v6, 3uLL, v28);
LABEL_110:

LABEL_111:
LABEL_112:

        ne_log_obj();
        v209 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v209, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)buf = 0;
          _os_log_error_impl(&dword_19BD16000, v209, OS_LOG_TYPE_ERROR, "Failed to process Create Child SA packet (initiate rekey)", buf, 2u);
        }

        v40 = [NEIKEv2DeleteIKEContext alloc];
        v211 = *(id *)(a1 + 32);
        if (v211)
          v211 = objc_getProperty(v211, v210, 368, 1);
        v42 = v211;
        v264[0] = MEMORY[0x1E0C809B0];
        v264[1] = 3221225472;
        v264[2] = __47__NEIKEv2Session_Exchange__initiateRekeyIKESA___block_invoke_410;
        v264[3] = &unk_1E3CC0EB0;
        v43 = (id *)v265;
        v212 = *(id *)(a1 + 40);
        v213 = *(_QWORD *)(a1 + 32);
        v265[0] = v212;
        v265[1] = v213;
        v46 = v264;
        goto LABEL_117;
      }
    }
    v10 = -[NSObject countByEnumeratingWithState:objects:count:](ErrorPeerInvalidSyntax, "countByEnumeratingWithState:objects:count:", &v272, buf, 16);
  }
  while (v10);
LABEL_14:

LABEL_15:
  objc_getProperty(v3, v7, 88, 1);
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  v16 = v14;
  if (v14)
    v14 = objc_getProperty(v14, v15, 32, 1);
  v17 = v14;
  v18 = objc_msgSend(v17, "value");

  if (!v18)
  {
    ne_log_obj();
    v48 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
    {
      v163 = (char *)objc_msgSend(v3, "copyShortDescription");
      *(_DWORD *)v276 = 138412290;
      v277 = v163;
      _os_log_error_impl(&dword_19BD16000, v48, OS_LOG_TYPE_ERROR, "%@ SA proposal missing rekey SPI", v276, 0xCu);

    }
    ErrorPeerInvalidSyntax = NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("SA proposal missing rekey SPI"), v49, v50, v51, v52, v53, v54, v55, v247);
    -[NEIKEv2IKESA setState:error:]((uint64_t)v6, 3uLL, ErrorPeerInvalidSyntax);
    goto LABEL_111;
  }
  objc_getProperty(v3, v19, 88, 1);
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  v22 = v20;
  if (v20)
    v20 = objc_getProperty(v20, v21, 32, 1);
  v23 = v20;
  -[NEIKEv2IKESA assignRemoteSPI:](v6, v23);

  objc_getProperty(v3, v24, 88, 1);
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  v27 = v25;
  if (v25)
    v25 = objc_getProperty(v25, v26, 24, 1);
  ErrorPeerInvalidSyntax = v25;

  if (-[NSObject count](ErrorPeerInvalidSyntax, "count") != 1)
  {
    ne_log_obj();
    v56 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
    {
      v164 = (char *)objc_msgSend(v3, "copyShortDescription");
      v165 = -[NSObject count](ErrorPeerInvalidSyntax, "count");
      *(_DWORD *)v276 = 138412546;
      v277 = v164;
      v278 = 2048;
      v279 = (_BYTE *)v165;
      _os_log_error_impl(&dword_19BD16000, v56, OS_LOG_TYPE_ERROR, "%@ Received %zu SA proposals, require 1", v276, 0x16u);

    }
    v57 = -[NSObject count](ErrorPeerInvalidSyntax, "count");
    v28 = (_BYTE *)NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("Received %zu SA proposals, require 1"), v58, v59, v60, v61, v62, v63, v64, v57);
    goto LABEL_47;
  }
  -[NSObject firstObject](ErrorPeerInvalidSyntax, "firstObject");
  v28 = (_BYTE *)objc_claimAutoreleasedReturnValue();
  if ((-[NEIKEv2IKESAProposal isAValidResponse](v28, v29) & 1) == 0)
  {
    ne_log_obj();
    v65 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
    {
      v167 = (char *)objc_msgSend(v3, "copyShortDescription");
      *(_DWORD *)v276 = 138412546;
      v277 = v167;
      v278 = 2112;
      v279 = v28;
      _os_log_error_impl(&dword_19BD16000, v65, OS_LOG_TYPE_ERROR, "%@ Received invalid SA proposal for rekey %@", v276, 0x16u);

    }
    v73 = (id)NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("Received invalid SA proposal for rekey"), v66, v67, v68, v69, v70, v71, v72, v247);
    -[NEIKEv2IKESA setState:error:]((uint64_t)v6, 3uLL, v73);
    goto LABEL_109;
  }
  v270 = 0u;
  v271 = 0u;
  v268 = 0u;
  v269 = 0u;
  v31 = objc_getProperty(v6, v30, 80, 1);
  objc_msgSend(v31, "proposals");
  v32 = (void *)objc_claimAutoreleasedReturnValue();

  v33 = objc_msgSend(v32, "countByEnumeratingWithState:objects:count:", &v268, v282, 16);
  if (!v33)
  {
LABEL_32:

LABEL_77:
    ne_log_obj();
    v143 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v143, OS_LOG_TYPE_ERROR))
    {
      v169 = (char *)objc_msgSend(v3, "copyShortDescription");
      v171 = objc_getProperty(v6, v170, 80, 1);
      objc_msgSend(v171, "proposals");
      v172 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)v276 = 138412802;
      v277 = v169;
      v278 = 2112;
      v279 = v28;
      v280 = 2112;
      v281 = (uint64_t)v172;
      _os_log_error_impl(&dword_19BD16000, v143, OS_LOG_TYPE_ERROR, "%@ Received proposal for rekey %@ does not match config %@", v276, 0x20u);

    }
    v73 = objc_getProperty(v6, v144, 80, 1);
    objc_msgSend(v73, "proposals");
    v133 = (id)objc_claimAutoreleasedReturnValue();
    v152 = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("Received proposal for rekey %@ does not match config %@"), v145, v146, v147, v148, v149, v150, v151, (uint64_t)v28);
    -[NEIKEv2IKESA setState:error:]((uint64_t)v6, 3uLL, v152);

    goto LABEL_108;
  }
  v34 = v33;
  v35 = *(_QWORD *)v269;
LABEL_26:
  v36 = 0;
  while (1)
  {
    if (*(_QWORD *)v269 != v35)
      objc_enumerationMutation(v32);
    v37 = *(void **)(*((_QWORD *)&v268 + 1) + 8 * v36);
    if ((-[NEIKEv2IKESAProposal matchesLocalProposal:preferRemoteProposal:](v37, v28, 0) & 1) != 0)
      break;
    if (v34 == ++v36)
    {
      v34 = objc_msgSend(v32, "countByEnumeratingWithState:objects:count:", &v268, v282, 16);
      if (v34)
        goto LABEL_26;
      goto LABEL_32;
    }
  }
  v73 = v37;

  if (!v73)
    goto LABEL_77;
  v74 = -[NEIKEv2IKESAProposal copyFromRemote:preferRemoteProposal:](v73, v28, 0);
  objc_setProperty_atomic(v6, v75, v74, 96);

  v77 = objc_getProperty(v6, v76, 96, 1);
  if (!v77)
  {
    ne_log_obj();
    v154 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v154, OS_LOG_TYPE_ERROR))
    {
      v206 = (char *)objc_msgSend(v3, "copyShortDescription");
      *(_DWORD *)v276 = 138412290;
      v277 = v206;
      _os_log_error_impl(&dword_19BD16000, v154, OS_LOG_TYPE_ERROR, "%@ Could not set chosen proposal values", v276, 0xCu);

    }
    v162 = CFSTR("Could not set chosen proposal values");
    goto LABEL_106;
  }
  objc_getProperty(v3, v78, 104, 1);
  v79 = (void *)objc_claimAutoreleasedReturnValue();

  if (!v79)
  {
    ne_log_obj();
    v166 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v166, OS_LOG_TYPE_ERROR))
    {
      v215 = (char *)objc_msgSend(v3, "copyShortDescription");
      *(_DWORD *)v276 = 138412290;
      v277 = v215;
      _os_log_error_impl(&dword_19BD16000, v166, OS_LOG_TYPE_ERROR, "%@ Did not receive KE payload", v276, 0xCu);

    }
    v162 = CFSTR("Did not receive KE payload");
    goto LABEL_106;
  }
  objc_getProperty(v3, v80, 104, 1);
  v81 = (void *)objc_claimAutoreleasedReturnValue();
  v83 = v81;
  if (v81)
    v81 = objc_getProperty(v81, v82, 24, 1);
  v84 = v81;

  if (!v84)
  {
    ne_log_obj();
    v168 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v168, OS_LOG_TYPE_ERROR))
    {
      v216 = (char *)objc_msgSend(v3, "copyShortDescription");
      *(_DWORD *)v276 = 138412290;
      v277 = v216;
      _os_log_error_impl(&dword_19BD16000, v168, OS_LOG_TYPE_ERROR, "%@ Did not receive method in KE payload", v276, 0xCu);

    }
    v162 = CFSTR("Did not receive method in KE payload");
    goto LABEL_106;
  }
  objc_getProperty(v3, v85, 104, 1);
  v86 = (void *)objc_claimAutoreleasedReturnValue();
  v88 = v86;
  if (v86)
    v86 = objc_getProperty(v86, v87, 32, 1);
  v89 = v86;

  if (!v89)
  {
    ne_log_obj();
    v173 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v173, OS_LOG_TYPE_ERROR))
    {
      v217 = (char *)objc_msgSend(v3, "copyShortDescription");
      *(_DWORD *)v276 = 138412290;
      v277 = v217;
      _os_log_error_impl(&dword_19BD16000, v173, OS_LOG_TYPE_ERROR, "%@ Did not receive data in KE payload", v276, 0xCu);

    }
    v162 = CFSTR("Did not receive data in KE payload");
    goto LABEL_106;
  }
  objc_getProperty(v3, v90, 104, 1);
  v91 = (void *)objc_claimAutoreleasedReturnValue();
  v253 = v91;
  if (v91)
    v91 = objc_getProperty(v91, v92, 24, 1);
  v93 = v91;
  v251 = objc_msgSend(v93, "method");
  v95 = objc_getProperty(v6, v94, 96, 1);
  -[NEIKEv2IKESAProposal kemProtocol](v95, v96);
  v97 = (void *)objc_claimAutoreleasedReturnValue();
  v98 = objc_msgSend(v97, "method");

  if (v251 != v98)
  {
    ne_log_obj();
    v174 = objc_claimAutoreleasedReturnValue();
    v175 = &OBJC_IVAR___NEIKEv2SessionConfiguration__ppkMandatory;
    if (os_log_type_enabled(v174, OS_LOG_TYPE_ERROR))
    {
      v252 = (char *)objc_msgSend(v3, "copyShortDescription");
      objc_getProperty(v3, v218, 104, 1);
      v219 = (void *)objc_claimAutoreleasedReturnValue();
      v255 = v219;
      if (v219)
        v219 = objc_getProperty(v219, v220, 24, 1);
      v250 = v219;
      v249 = objc_msgSend(v250, "method");
      v222 = objc_getProperty(v6, v221, 96, 1);
      -[NEIKEv2IKESAProposal kemProtocol](v222, v223);
      v224 = (void *)objc_claimAutoreleasedReturnValue();
      v225 = objc_msgSend(v224, "method");
      *(_DWORD *)v276 = 138412802;
      v277 = v252;
      v278 = 2048;
      v279 = (_BYTE *)v249;
      v280 = 2048;
      v281 = v225;
      _os_log_error_impl(&dword_19BD16000, v174, OS_LOG_TYPE_ERROR, "%@ Did not receive matching method from KE payload (%zu != %zu)", v276, 0x20u);

      v175 = &OBJC_IVAR___NEIKEv2SessionConfiguration__ppkMandatory;
    }

    objc_getProperty(v3, v176, v175[288], 1);
    v177 = (void *)objc_claimAutoreleasedReturnValue();
    v133 = v177;
    if (v177)
      v177 = objc_getProperty(v177, v178, 24, 1);
    v254 = v177;
    v179 = objc_msgSend(v254, "method");
    v181 = objc_getProperty(v6, v180, 96, 1);
    -[NEIKEv2IKESAProposal kemProtocol](v181, v182);
    v183 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v183, "method");
    v191 = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("Did not receive matching method from KE payload (%zu != %zu)"), v184, v185, v186, v187, v188, v189, v190, v179);
    -[NEIKEv2IKESA setState:error:]((uint64_t)v6, 3uLL, v191);

LABEL_108:
LABEL_109:

    goto LABEL_110;
  }
  objc_getProperty(v3, v99, 104, 1);
  v100 = (void *)objc_claimAutoreleasedReturnValue();
  v102 = v100;
  if (v100)
    v100 = objc_getProperty(v100, v101, 32, 1);
  v103 = v100;
  objc_setProperty_atomic(v6, v104, v103, 152);

  v105 = -[NEIKEv2Packet copyNotification:](v3, (const char *)0x4039);
  objc_setProperty_atomic(v6, v106, v105, 176);

  v107 = &OBJC_IVAR___NEIKEv2SessionConfiguration__ppkMandatory;
  objc_getProperty(v3, v108, 112, 1);
  v109 = (void *)objc_claimAutoreleasedReturnValue();

  if (!v109)
  {
    ne_log_obj();
    v192 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v192, OS_LOG_TYPE_ERROR))
    {
      v226 = (char *)objc_msgSend(v3, "copyShortDescription");
      *(_DWORD *)v276 = 138412290;
      v277 = v226;
      _os_log_error_impl(&dword_19BD16000, v192, OS_LOG_TYPE_ERROR, "%@ Did not receive NONCE payload", v276, 0xCu);

    }
    v162 = CFSTR("Did not receive NONCE payload");
    goto LABEL_106;
  }
  objc_getProperty(v3, v110, 112, 1);
  v111 = (void *)objc_claimAutoreleasedReturnValue();
  v113 = v111;
  v114 = &OBJC_IVAR___NEIKEv2SessionConfiguration__ppkMandatory;
  if (v111)
    v111 = objc_getProperty(v111, v112, 24, 1);
  v115 = v111;

  if (!v115)
  {
    ne_log_obj();
    v207 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v207, OS_LOG_TYPE_ERROR))
    {
      v227 = (char *)objc_msgSend(v3, "copyShortDescription");
      *(_DWORD *)v276 = 138412290;
      v277 = v227;
      _os_log_error_impl(&dword_19BD16000, v207, OS_LOG_TYPE_ERROR, "%@ Did not receive NONCE data", v276, 0xCu);

    }
    v162 = CFSTR("Did not receive NONCE data");
LABEL_106:
    v208 = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(v162, v155, v156, v157, v158, v159, v160, v161, v247);
LABEL_107:
    v133 = v208;
    -[NEIKEv2IKESA setState:error:]((uint64_t)v6, 3uLL, v208);
    goto LABEL_108;
  }
  v117 = objc_getProperty(v6, v116, 80, 1);
  v118 = objc_msgSend(v117, "strictNonceSizeChecks");

  if (!v118)
    goto LABEL_99;
  objc_getProperty(v3, v119, 112, 1);
  v120 = (void *)objc_claimAutoreleasedReturnValue();
  v122 = v120;
  if (v120)
    v120 = objc_getProperty(v120, v121, 24, 1);
  v123 = v120;
  v124 = objc_msgSend(v123, "length");

  if (v124 - 257 <= 0xFFFFFFFFFFFFFF0ELL)
  {
    ne_log_obj();
    v238 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v238, OS_LOG_TYPE_ERROR))
    {
      v246 = (char *)objc_msgSend(v3, "copyShortDescription");
      *(_DWORD *)v276 = 138412546;
      v277 = v246;
      v278 = 2048;
      v279 = (_BYTE *)v124;
      _os_log_error_impl(&dword_19BD16000, v238, OS_LOG_TYPE_ERROR, "%@ NONCE data length %zu is out of bounds", v276, 0x16u);

    }
    v208 = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("NONCE data length %zu is out of bounds"), v239, v240, v241, v242, v243, v244, v245, v124);
    goto LABEL_107;
  }
  v126 = objc_getProperty(v6, v125, 96, 1);
  -[NEIKEv2IKESAProposal prfProtocol](v126, v127);
  v128 = (void *)objc_claimAutoreleasedReturnValue();
  v129 = objc_msgSend(v128, "nonceSize");

  v130 = v124 >= v129;
  v107 = &OBJC_IVAR___NEIKEv2SessionConfiguration__ppkMandatory;
  v114 = &OBJC_IVAR___NEIKEv2SessionConfiguration__ppkMandatory;
  if (!v130)
  {
    ne_log_obj();
    v131 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v131, OS_LOG_TYPE_ERROR))
    {
      v228 = (char *)objc_msgSend(v3, "copyShortDescription");
      v256 = v124;
      v230 = objc_getProperty(v6, v229, 96, 1);
      -[NEIKEv2IKESAProposal prfProtocol](v230, v231);
      v232 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)v276 = 138412802;
      v277 = v228;
      v278 = 2048;
      v279 = (_BYTE *)v256;
      v280 = 2112;
      v281 = (uint64_t)v232;
      _os_log_error_impl(&dword_19BD16000, v131, OS_LOG_TYPE_ERROR, "%@ NONCE data length %zu is shorter than the minimum for PRF protocol %@", v276, 0x20u);

      v124 = v256;
    }

    v133 = objc_getProperty(v6, v132, 96, 1);
    -[NEIKEv2IKESAProposal prfProtocol](v133, v134);
    v248 = (void *)objc_claimAutoreleasedReturnValue();
    v142 = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("NONCE data length %zu is shorter than the minimum for PRF protocol %@"), v135, v136, v137, v138, v139, v140, v141, v124);
    -[NEIKEv2IKESA setState:error:]((uint64_t)v6, 3uLL, v142);

    goto LABEL_108;
  }
LABEL_99:
  objc_getProperty(v3, v119, v107[289], 1);
  v193 = (void *)objc_claimAutoreleasedReturnValue();
  v195 = v193;
  if (v193)
    v193 = objc_getProperty(v193, v194, v114[236], 1);
  v196 = v193;
  objc_setProperty_atomic(v6, v197, v196, 136);

  if ((-[NEIKEv2IKESA processPrimaryKeyExchange](*(_QWORD *)(a1 + 48), v198) & 1) != 0)
  {
    v200 = *(void **)(a1 + 40);
    v199 = *(void **)(a1 + 48);
    v201 = *(_QWORD **)(a1 + 32);
    v257[0] = MEMORY[0x1E0C809B0];
    v257[1] = 3221225472;
    v257[2] = __47__NEIKEv2Session_Exchange__initiateRekeyIKESA___block_invoke_2_416;
    v257[3] = &unk_1E3CC2690;
    v43 = &v258;
    v202 = v199;
    v258 = v202;
    v203 = *(id *)(a1 + 56);
    v204 = *(_QWORD *)(a1 + 32);
    v205 = *(void **)(a1 + 40);
    v259 = v203;
    v260 = v204;
    v261 = v205;
    -[NEIKEv2Session handleFollowupKEForRekeyIKESAInitiator:rekeyIKEContext:iteration:handler:](v201, v202, v200, 0, v257);

    goto LABEL_118;
  }
  ne_log_obj();
  v233 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v233, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl(&dword_19BD16000, v233, OS_LOG_TYPE_ERROR, "Failed to process KE data (initiate rekey)", buf, 2u);
  }

  v40 = [NEIKEv2DeleteIKEContext alloc];
  v235 = *(id *)(a1 + 32);
  if (v235)
    v235 = objc_getProperty(v235, v234, 368, 1);
  v42 = v235;
  v262[0] = MEMORY[0x1E0C809B0];
  v262[1] = 3221225472;
  v262[2] = __47__NEIKEv2Session_Exchange__initiateRekeyIKESA___block_invoke_413;
  v262[3] = &unk_1E3CC0EB0;
  v43 = (id *)v263;
  v236 = *(id *)(a1 + 40);
  v237 = *(_QWORD *)(a1 + 32);
  v263[0] = v236;
  v263[1] = v237;
  v46 = v262;
LABEL_117:
  v214 = -[NEIKEv2DeleteIKEContext initDeleteIKEWithResponse:callbackQueue:callback:]((id *)&v40->super.super.isa, 0, v42, v46);

  -[NEIKEv2Session initiateDelete:](*(_QWORD **)(a1 + 32), v214);
LABEL_118:

}

void __47__NEIKEv2Session_Exchange__initiateRekeyIKESA___block_invoke_407(uint64_t a1)
{
  const char *v2;
  id Property;
  id v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *ErrorPeerInvalidSyntax;
  const char *v13;
  const char *v14;
  uint64_t v15;

  objc_msgSend(*(id *)(a1 + 32), "sendCallbackSuccess:session:", 0, *(_QWORD *)(a1 + 40));
  Property = *(id *)(a1 + 40);
  if (Property)
    Property = objc_getProperty(Property, v2, 336, 1);
  v4 = Property;
  ErrorPeerInvalidSyntax = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("Failed to receive Create Child SA packet (initiate rekey)"), v5, v6, v7, v8, v9, v10, v11, v15);
  -[NEIKEv2IKESA setState:error:]((uint64_t)v4, 3uLL, ErrorPeerInvalidSyntax);

  -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 40), v13);
  -[NEIKEv2Session resetAll](*(_QWORD *)(a1 + 40), v14);
}

void __47__NEIKEv2Session_Exchange__initiateRekeyIKESA___block_invoke_410(uint64_t a1)
{
  const char *v2;
  id Property;
  id v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *ErrorPeerInvalidSyntax;
  const char *v13;
  const char *v14;
  uint64_t v15;

  objc_msgSend(*(id *)(a1 + 32), "sendCallbackSuccess:session:", 0, *(_QWORD *)(a1 + 40));
  Property = *(id *)(a1 + 40);
  if (Property)
    Property = objc_getProperty(Property, v2, 336, 1);
  v4 = Property;
  ErrorPeerInvalidSyntax = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("Failed to process Create Child SA packet (initiate rekey)"), v5, v6, v7, v8, v9, v10, v11, v15);
  -[NEIKEv2IKESA setState:error:]((uint64_t)v4, 3uLL, ErrorPeerInvalidSyntax);

  -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 40), v13);
  -[NEIKEv2Session resetAll](*(_QWORD *)(a1 + 40), v14);
}

void __47__NEIKEv2Session_Exchange__initiateRekeyIKESA___block_invoke_413(uint64_t a1)
{
  const char *v2;
  id Property;
  id v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *ErrorCrypto;
  const char *v13;
  const char *v14;
  uint64_t v15;

  objc_msgSend(*(id *)(a1 + 32), "sendCallbackSuccess:session:", 0, *(_QWORD *)(a1 + 40));
  Property = *(id *)(a1 + 40);
  if (Property)
    Property = objc_getProperty(Property, v2, 336, 1);
  v4 = Property;
  ErrorCrypto = (void *)NEIKEv2CreateErrorCrypto(CFSTR("Failed to process KE data (initiate rekey)"), v5, v6, v7, v8, v9, v10, v11, v15);
  -[NEIKEv2IKESA setState:error:]((uint64_t)v4, 3uLL, ErrorCrypto);

  -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 40), v13);
  -[NEIKEv2Session resetAll](*(_QWORD *)(a1 + 40), v14);
}

void __47__NEIKEv2Session_Exchange__initiateRekeyIKESA___block_invoke_2_416(uint64_t a1)
{
  _BYTE *v2;
  const char *v3;
  NEIKEv2DeleteIKEContext *v4;
  id Property;
  id v6;
  id *v7;
  id v8;
  uint64_t v9;
  void *v10;
  id *v11;
  id *v12;
  NSObject *v13;
  const char *v14;
  NEIKEv2DeleteIKEContext *v15;
  id v16;
  id v17;
  id v18;
  uint64_t v19;
  _QWORD v20[4];
  _QWORD v21[2];
  id *v22;
  _QWORD v23[4];
  _QWORD v24[2];
  uint8_t buf[16];

  v2 = *(_BYTE **)(a1 + 32);
  if (v2 && (-[NEIKEv2IKESA generateAllValuesUsingSA:](v2, *(void **)(a1 + 40)) & 1) != 0)
  {
    v4 = [NEIKEv2DeleteIKEContext alloc];
    Property = *(id *)(a1 + 48);
    if (Property)
      Property = objc_getProperty(Property, v3, 368, 1);
    v6 = Property;
    v20[0] = MEMORY[0x1E0C809B0];
    v20[1] = 3221225472;
    v20[2] = __47__NEIKEv2Session_Exchange__initiateRekeyIKESA___block_invoke_2_420;
    v20[3] = &unk_1E3CC10B8;
    v7 = (id *)v21;
    v8 = *(id *)(a1 + 32);
    v9 = *(_QWORD *)(a1 + 48);
    v10 = *(void **)(a1 + 56);
    v21[0] = v8;
    v21[1] = v9;
    v22 = v10;
    v11 = -[NEIKEv2DeleteIKEContext initDeleteIKEWithResponse:callbackQueue:callback:]((id *)&v4->super.super.isa, 1, v6, v20);

    -[NEIKEv2Session initiateDelete:](*(_QWORD **)(a1 + 48), v11);
    v12 = v22;
  }
  else
  {
    ne_log_obj();
    v13 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_19BD16000, v13, OS_LOG_TYPE_ERROR, "Failed to generate IKE SA crypto values (initiate rekey)", buf, 2u);
    }

    v15 = [NEIKEv2DeleteIKEContext alloc];
    v16 = *(id *)(a1 + 48);
    if (v16)
      v16 = objc_getProperty(v16, v14, 368, 1);
    v17 = v16;
    v23[0] = MEMORY[0x1E0C809B0];
    v23[1] = 3221225472;
    v23[2] = __47__NEIKEv2Session_Exchange__initiateRekeyIKESA___block_invoke_417;
    v23[3] = &unk_1E3CC0EB0;
    v7 = (id *)v24;
    v18 = *(id *)(a1 + 56);
    v19 = *(_QWORD *)(a1 + 48);
    v24[0] = v18;
    v24[1] = v19;
    v12 = -[NEIKEv2DeleteIKEContext initDeleteIKEWithResponse:callbackQueue:callback:]((id *)&v15->super.super.isa, 0, v17, v23);

    -[NEIKEv2Session initiateDelete:](*(_QWORD **)(a1 + 48), v12);
  }

}

void __47__NEIKEv2Session_Exchange__initiateRekeyIKESA___block_invoke_417(uint64_t a1)
{
  const char *v2;
  id Property;
  id v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *ErrorCrypto;
  const char *v13;
  const char *v14;
  uint64_t v15;

  objc_msgSend(*(id *)(a1 + 32), "sendCallbackSuccess:session:", 0, *(_QWORD *)(a1 + 40));
  Property = *(id *)(a1 + 40);
  if (Property)
    Property = objc_getProperty(Property, v2, 336, 1);
  v4 = Property;
  ErrorCrypto = (void *)NEIKEv2CreateErrorCrypto(CFSTR("Failed to generate IKE SA crypto values (initiate rekey)"), v5, v6, v7, v8, v9, v10, v11, v15);
  -[NEIKEv2IKESA setState:error:]((uint64_t)v4, 3uLL, ErrorCrypto);

  -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 40), v13);
  -[NEIKEv2Session resetAll](*(_QWORD *)(a1 + 40), v14);
}

void __47__NEIKEv2Session_Exchange__initiateRekeyIKESA___block_invoke_2_420(uint64_t a1, int a2)
{
  NSObject *v3;
  NSObject *v4;
  const char *v5;
  id Property;
  id v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void *ErrorPeerInvalidSyntax;
  const char *v16;
  const char *v17;
  uint64_t v18;
  uint8_t buf[16];

  if (a2)
  {
    -[NEIKEv2IKESA setState:error:](*(_QWORD *)(a1 + 32), 2uLL, 0);
    -[NEIKEv2Session setIKESA:](*(_QWORD *)(a1 + 40), *(void **)(a1 + 32));
    objc_msgSend(*(id *)(a1 + 48), "sendCallbackSuccess:session:", 1, *(_QWORD *)(a1 + 40));
    ne_log_obj();
    v3 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_19BD16000, v3, OS_LOG_TYPE_INFO, "Rekeyed IKE SA", buf, 2u);
    }

  }
  else
  {
    ne_log_obj();
    v4 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v18) = 0;
      _os_log_error_impl(&dword_19BD16000, v4, OS_LOG_TYPE_ERROR, "Failed to process Create Child SA Delete packet response (initiate rekey)", (uint8_t *)&v18, 2u);
    }

    objc_msgSend(*(id *)(a1 + 48), "sendCallbackSuccess:session:", 0, *(_QWORD *)(a1 + 40));
    Property = *(id *)(a1 + 40);
    if (Property)
      Property = objc_getProperty(Property, v5, 336, 1);
    v7 = Property;
    ErrorPeerInvalidSyntax = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("Failed to process Create Child SA Delete packet response (initiate rekey)"), v8, v9, v10, v11, v12, v13, v14, v18);
    -[NEIKEv2IKESA setState:error:]((uint64_t)v7, 3uLL, ErrorPeerInvalidSyntax);

    -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 40), v16);
    -[NEIKEv2Session resetAll](*(_QWORD *)(a1 + 40), v17);
  }
}

- (void)receiveRekeyIKESA:(_QWORD *)a1
{
  const char *v3;
  id v4;
  NSObject *v5;
  SEL v6;
  _BYTE *v7;
  _BYTE *v8;
  NSObject *v9;
  NSObject *v10;
  const char *v11;
  const char *v12;
  id Property;
  id ErrorPeerInvalidSyntax;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t i;
  const __CFString *v19;
  int *v20;
  void *v21;
  const char *v22;
  void *v23;
  id v24;
  uint64_t v25;
  const char *v26;
  void *v27;
  const char *v28;
  void *v29;
  id v30;
  SEL v31;
  void *v32;
  const char *v33;
  void *v34;
  id v35;
  void *v36;
  SEL v37;
  id v38;
  void *v39;
  const char *v40;
  id v41;
  NSObject *v42;
  SEL v43;
  SEL v44;
  id v45;
  const char *v46;
  void *v47;
  const char *v48;
  void *v49;
  const char *v50;
  void *v51;
  id v52;
  const char *v53;
  void *v54;
  const char *v55;
  void *v56;
  id v57;
  const char *v58;
  void *v59;
  const char *v60;
  void *v61;
  id v62;
  uint64_t v63;
  SEL v64;
  id v65;
  const char *v66;
  void *v67;
  uint64_t v68;
  const char *v69;
  void *v70;
  const char *v71;
  void *v72;
  id v73;
  SEL v74;
  SEL v75;
  void *v76;
  const char *v77;
  void *v78;
  const char *v79;
  void *v80;
  id v81;
  const char *v82;
  id v83;
  int v84;
  const char *v85;
  void *v86;
  const char *v87;
  void *v88;
  id v89;
  unint64_t v90;
  const char *v91;
  NSObject *v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  id v100;
  char v101;
  unint64_t v102;
  NSObject *v103;
  NEIKEv2DeleteIKEContext *v104;
  SEL v105;
  id v106;
  id *v107;
  __CFString *v108;
  NSObject *v109;
  NSObject *v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  void *v118;
  const char *v119;
  id v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  void *ErrorFailedToSend;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  void *v136;
  const char *v137;
  const char *v138;
  NSObject *v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  __CFString *v147;
  NSObject *v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  NSObject *v156;
  NSObject *v157;
  NSObject *v158;
  const char *v159;
  const char *v160;
  id v161;
  SEL v162;
  id v163;
  uint64_t v164;
  NSObject *v165;
  NEIKEv2IKESAPayload *v166;
  SEL v167;
  SEL v168;
  id v169;
  void *v170;
  int *v171;
  SEL v172;
  void *v173;
  const char *v174;
  void *v175;
  SEL v176;
  id v177;
  SEL v178;
  void *v179;
  const char *v180;
  void *v181;
  SEL v182;
  void *v183;
  char v184;
  NEIKEv2NoncePayload *v185;
  SEL v186;
  SEL v187;
  id v188;
  SEL v189;
  void *v190;
  const char *v191;
  void *v192;
  SEL v193;
  void *v194;
  char v195;
  NEIKEv2KeyExchangePayload *v196;
  SEL v197;
  SEL v198;
  id v199;
  const char *v200;
  void *v201;
  SEL v202;
  void *v203;
  const char *v204;
  void *v205;
  SEL v206;
  id v207;
  void *v208;
  void *v209;
  id v210;
  SEL v211;
  void *v212;
  const char *v213;
  void *v214;
  SEL v215;
  void *v216;
  char v217;
  const char *v218;
  id v219;
  const char *v220;
  void *v221;
  id v222;
  void *v223;
  void *v224;
  NEIKEv2NotifyPayload *v225;
  SEL v226;
  SEL v227;
  id v228;
  NSObject *v229;
  id v230;
  const char *v231;
  void *v232;
  unsigned int v233;
  void *v234;
  NSObject *v235;
  SEL v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  id v244;
  __CFString *v245;
  void *ErrorCrypto;
  const char *v247;
  const char *v248;
  NSObject *v249;
  NSObject *v250;
  const char *v251;
  NSObject *v252;
  int *v253;
  SEL v254;
  void *v255;
  const char *v256;
  void *v257;
  id v258;
  SEL v259;
  id v260;
  const char *v261;
  void *v262;
  uint64_t v263;
  uint64_t v264;
  uint64_t v265;
  uint64_t v266;
  uint64_t v267;
  uint64_t v268;
  uint64_t v269;
  void *v270;
  void *v271;
  void *v272;
  void *v273;
  NSObject *v274;
  uint64_t v275;
  uint64_t v276;
  uint64_t v277;
  uint64_t v278;
  uint64_t v279;
  uint64_t v280;
  uint64_t v281;
  void *v282;
  const char *v283;
  id v284;
  void *v285;
  void *v286;
  id v287;
  SEL v288;
  SEL v289;
  NSObject *v290;
  SEL v291;
  id v292;
  uint64_t v293;
  uint64_t v294;
  uint64_t v295;
  uint64_t v296;
  uint64_t v297;
  uint64_t v298;
  uint64_t v299;
  void *ErrorInternal;
  const char *v301;
  const char *v302;
  NSObject *v303;
  uint64_t v304;
  uint64_t v305;
  uint64_t v306;
  uint64_t v307;
  uint64_t v308;
  uint64_t v309;
  uint64_t v310;
  void *v311;
  void *v312;
  id v313;
  const char *v314;
  void *v315;
  unsigned int v316;
  NSObject *v317;
  SEL v318;
  const char *v319;
  uint64_t v320;
  uint64_t v321;
  uint64_t v322;
  uint64_t v323;
  uint64_t v324;
  uint64_t v325;
  uint64_t v326;
  void *v327;
  void *v328;
  const char *v329;
  id v330;
  SEL v331;
  void *v332;
  SEL v333;
  void *v334;
  const char *v335;
  void *v336;
  uint64_t v337;
  SEL v338;
  id v339;
  const char *v340;
  void *v341;
  void *v342;
  NSObject *v343;
  SEL v344;
  uint64_t v345;
  uint64_t v346;
  uint64_t v347;
  uint64_t v348;
  uint64_t v349;
  uint64_t v350;
  uint64_t v351;
  void *v352;
  void *v353;
  void *v354;
  SEL v355;
  id v356;
  const char *v357;
  void *v358;
  NSObject *v359;
  SEL v360;
  uint64_t v361;
  void *v362;
  id v363;
  void *v364;
  void *v365;
  void *v366;
  id v367;
  _QWORD v368[4];
  NSObject *v369;
  _BYTE *v370;
  _QWORD *v371;
  _QWORD v372[5];
  uint8_t v373[4];
  void *v374;
  __int16 v375;
  unint64_t v376;
  __int16 v377;
  uint64_t v378;
  uint8_t buf[128];
  uint8_t v380[16];
  __int128 v381;
  __int128 v382;
  __int128 v383;
  uint64_t v384;

  v384 = *MEMORY[0x1E0C80C00];
  v4 = a2;
  if (a1)
  {
    v5 = objc_getProperty(a1, v3, 368, 1);
    dispatch_assert_queue_V2(v5);

    v7 = objc_getProperty(a1, v6, 336, 1);
    v8 = v7;
    if (!v7)
    {
      ne_log_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136315138;
        *(_QWORD *)&buf[4] = "-[NEIKEv2Session(Exchange) receiveRekeyIKESA:]";
        _os_log_fault_impl(&dword_19BD16000, v10, OS_LOG_TYPE_FAULT, "%s called with null oldIKESA", buf, 0xCu);
      }
      goto LABEL_69;
    }
    if ((v7[16] & 1) != 0)
    {
      ne_log_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)buf = 0;
        _os_log_debug_impl(&dword_19BD16000, v10, OS_LOG_TYPE_DEBUG, "IKE SA already rekeying, skipping (receive rekey)", buf, 2u);
      }
      goto LABEL_69;
    }
    v7[16] = 1;
    v9 = -[NEIKEv2IKESA copyForRekey]((uint64_t)v7);
    if (!v9)
    {
      ne_log_obj();
      v103 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v103, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_19BD16000, v103, OS_LOG_TYPE_ERROR, "Failed to create valid IKE SA (receive rekey)", buf, 2u);
      }

      v104 = [NEIKEv2DeleteIKEContext alloc];
      v106 = objc_getProperty(a1, v105, 368, 1);
      v372[0] = MEMORY[0x1E0C809B0];
      v372[1] = 3221225472;
      v372[2] = __46__NEIKEv2Session_Exchange__receiveRekeyIKESA___block_invoke;
      v372[3] = &unk_1E3CC1408;
      v372[4] = a1;
      v107 = -[NEIKEv2DeleteIKEContext initDeleteIKEWithResponse:callbackQueue:callback:]((id *)&v104->super.super.isa, 0, v106, v372);

      -[NEIKEv2Session initiateDelete:](a1, v107);
      v10 = 0;
      goto LABEL_69;
    }
    BYTE1(v9[1].isa) = 0;
    v10 = v9;
    if (-[NEIKEv2Packet hasErrors](v4, v11))
    {
      v382 = 0u;
      v383 = 0u;
      *(_OWORD *)v380 = 0u;
      v381 = 0u;
      if (v4)
        Property = objc_getProperty(v4, v12, 64, 1);
      else
        Property = 0;
      ErrorPeerInvalidSyntax = Property;
      v15 = objc_msgSend(ErrorPeerInvalidSyntax, "countByEnumeratingWithState:objects:count:", v380, buf, 16);
      if (v15)
      {
        v16 = v15;
        v17 = *(_QWORD *)v381;
        while (2)
        {
          for (i = 0; i != v16; ++i)
          {
            if (*(_QWORD *)v381 != v17)
              objc_enumerationMutation(ErrorPeerInvalidSyntax);
            v19 = *(const __CFString **)(*(_QWORD *)&v380[8] + 8 * i);
            if (v19 && (unint64_t)(v19->length - 1) <= 0x3FFE)
            {
              v108 = (__CFString *)-[NEIKEv2NotifyPayload copyError](v19);
              ne_log_obj();
              v109 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v109, OS_LOG_TYPE_ERROR))
              {
                v271 = (void *)objc_msgSend(v4, "copyShortDescription");
                *(_DWORD *)v373 = 138412546;
                v374 = v271;
                v375 = 2112;
                v376 = (unint64_t)v108;
                _os_log_error_impl(&dword_19BD16000, v109, OS_LOG_TYPE_ERROR, "%@ Responder rekey IKE received notify error %@", v373, 0x16u);

              }
              -[NEIKEv2IKESA setState:error:]((uint64_t)v10, 3uLL, v108);

              goto LABEL_61;
            }
          }
          v16 = objc_msgSend(ErrorPeerInvalidSyntax, "countByEnumeratingWithState:objects:count:", v380, buf, 16);
          if (v16)
            continue;
          break;
        }
      }

    }
    v20 = &OBJC_IVAR___NEIKEv2SessionConfiguration__ppkMandatory;
    objc_getProperty(v4, v12, 88, 1);
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v23 = v21;
    if (v21)
      v21 = objc_getProperty(v21, v22, 32, 1);
    v24 = v21;
    v25 = objc_msgSend(v24, "value");

    if (!v25)
    {
      ne_log_obj();
      v110 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v110, OS_LOG_TYPE_ERROR))
      {
        v272 = (void *)objc_msgSend(v4, "copyShortDescription");
        *(_DWORD *)v373 = 138412290;
        v374 = v272;
        _os_log_error_impl(&dword_19BD16000, v110, OS_LOG_TYPE_ERROR, "%@ SA proposal missing rekey SPI", v373, 0xCu);

      }
      ErrorPeerInvalidSyntax = (id)NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("SA proposal missing rekey SPI"), v111, v112, v113, v114, v115, v116, v117, v361);
      -[NEIKEv2IKESA setState:error:]((uint64_t)v10, 3uLL, ErrorPeerInvalidSyntax);
LABEL_61:

      v8[16] = 0;
      v102 = 7;
      goto LABEL_62;
    }
    objc_getProperty(v4, v26, 88, 1);
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    v29 = v27;
    if (v27)
      v27 = objc_getProperty(v27, v28, 32, 1);
    v30 = v27;
    -[NEIKEv2IKESA assignRemoteSPI:](v10, v30);

    objc_getProperty(v4, v31, 88, 1);
    v32 = (void *)objc_claimAutoreleasedReturnValue();
    v34 = v32;
    if (v32)
      v32 = objc_getProperty(v32, v33, 24, 1);
    v35 = v32;

    v36 = v35;
    v38 = objc_getProperty(v10, v37, 80, 1);
    objc_msgSend(v38, "proposals");
    v39 = (void *)objc_claimAutoreleasedReturnValue();

    v366 = v39;
    if (objc_msgSend(v36, "count"))
    {
      v41 = objc_getProperty(v10, v40, 80, 1);
      v42 = +[NEIKEv2IKESAProposal chooseSAProposalFromLocalProposals:remoteProposals:preferRemoteProposals:]((uint64_t)NEIKEv2IKESAProposal, v39, v36, objc_msgSend(v41, "preferInitiatorProposalOrder"));
      objc_setProperty_atomic(v10, v43, v42, 96);

      v45 = objc_getProperty(v10, v44, 96, 1);
      if (!v45)
      {
        ne_log_obj();
        v148 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v148, OS_LOG_TYPE_ERROR))
        {
          v282 = (void *)objc_msgSend(v4, "copyShortDescription");
          *(_DWORD *)v373 = 138412290;
          v374 = v282;
          _os_log_error_impl(&dword_19BD16000, v148, OS_LOG_TYPE_ERROR, "%@ No matching proposal found", v373, 0xCu);

        }
        v100 = (id)NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("No matching proposal found"), v149, v150, v151, v152, v153, v154, v155, v361);
        -[NEIKEv2IKESA setState:error:]((uint64_t)v10, 3uLL, v100);
        v101 = 0;
        v102 = 14;
        goto LABEL_87;
      }
      objc_getProperty(v4, v46, 104, 1);
      v47 = (void *)objc_claimAutoreleasedReturnValue();

      if (v47)
      {
        objc_getProperty(v4, v48, 104, 1);
        v49 = (void *)objc_claimAutoreleasedReturnValue();
        v51 = v49;
        if (v49)
          v49 = objc_getProperty(v49, v50, 24, 1);
        v52 = v49;

        if (v52)
        {
          objc_getProperty(v4, v53, 104, 1);
          v54 = (void *)objc_claimAutoreleasedReturnValue();
          v56 = v54;
          if (v54)
            v54 = objc_getProperty(v54, v55, 32, 1);
          v57 = v54;

          if (v57)
          {
            objc_getProperty(v4, v58, 104, 1);
            v59 = (void *)objc_claimAutoreleasedReturnValue();
            v61 = v59;
            v365 = v36;
            if (v59)
              v59 = objc_getProperty(v59, v60, 24, 1);
            v62 = v59;
            v63 = objc_msgSend(v62, "method");
            v65 = objc_getProperty(v10, v64, 96, 1);
            -[NEIKEv2IKESAProposal kemProtocol](v65, v66);
            v67 = (void *)objc_claimAutoreleasedReturnValue();
            v68 = objc_msgSend(v67, "method");

            if (v63 != v68)
            {
              ne_log_obj();
              v252 = objc_claimAutoreleasedReturnValue();
              v253 = &OBJC_IVAR___NEIKEv2SessionConfiguration__ppkMandatory;
              if (os_log_type_enabled(v252, OS_LOG_TYPE_ERROR))
              {
                v364 = (void *)objc_msgSend(v4, "copyShortDescription");
                objc_getProperty(v4, v333, 104, 1);
                v334 = (void *)objc_claimAutoreleasedReturnValue();
                v336 = v334;
                if (v334)
                  v334 = objc_getProperty(v334, v335, 24, 1);
                v363 = v334;
                v337 = objc_msgSend(v363, "method");
                v339 = objc_getProperty(v10, v338, 96, 1);
                -[NEIKEv2IKESAProposal kemProtocol](v339, v340);
                v341 = (void *)objc_claimAutoreleasedReturnValue();
                *(_DWORD *)v373 = 138412802;
                v374 = v364;
                v375 = 2048;
                v376 = v337;
                v377 = 2048;
                v378 = objc_msgSend(v341, "method");
                _os_log_error_impl(&dword_19BD16000, v252, OS_LOG_TYPE_ERROR, "%@ Received KE method %zu does not match KE method %zu in SA rekey proposal", v373, 0x20u);

                v253 = &OBJC_IVAR___NEIKEv2SessionConfiguration__ppkMandatory;
              }

              v100 = (id)objc_msgSend(v4, "copyShortDescription");
              objc_getProperty(v4, v254, v253[288], 1);
              v255 = (void *)objc_claimAutoreleasedReturnValue();
              v257 = v255;
              if (v255)
                v255 = objc_getProperty(v255, v256, 24, 1);
              v258 = v255;
              objc_msgSend(v258, "method");
              v260 = objc_getProperty(v10, v259, 96, 1);
              -[NEIKEv2IKESAProposal kemProtocol](v260, v261);
              v262 = (void *)objc_claimAutoreleasedReturnValue();
              objc_msgSend(v262, "method");
              v270 = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("Received KE method %zu does not match KE method %zu in SA rekey proposal"), v263, v264, v265, v266, v267, v268, v269, (uint64_t)v100);
              -[NEIKEv2IKESA setState:error:]((uint64_t)v10, 3uLL, v270);

              v101 = 0;
              v102 = 17;
              goto LABEL_155;
            }
            objc_getProperty(v4, v69, 104, 1);
            v70 = (void *)objc_claimAutoreleasedReturnValue();
            v72 = v70;
            v36 = v365;
            if (v70)
              v70 = objc_getProperty(v70, v71, 32, 1);
            v73 = v70;
            objc_setProperty_atomic(v10, v74, v73, 152);

            objc_getProperty(v4, v75, 112, 1);
            v76 = (void *)objc_claimAutoreleasedReturnValue();

            if (!v76)
            {
              ne_log_obj();
              v274 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v274, OS_LOG_TYPE_ERROR))
              {
                v342 = (void *)objc_msgSend(v4, "copyShortDescription");
                *(_DWORD *)v373 = 138412290;
                v374 = v342;
                _os_log_error_impl(&dword_19BD16000, v274, OS_LOG_TYPE_ERROR, "%@ Did not receive NONCE payload", v373, 0xCu);

              }
              v100 = (id)NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("Did not receive NONCE payload"), v275, v276, v277, v278, v279, v280, v281, v361);
              -[NEIKEv2IKESA setState:error:]((uint64_t)v10, 3uLL, v100);
              v101 = 0;
              v102 = 7;
              goto LABEL_137;
            }
            objc_getProperty(v4, v77, 112, 1);
            v78 = (void *)objc_claimAutoreleasedReturnValue();
            v80 = v78;
            if (v78)
              v78 = objc_getProperty(v78, v79, 24, 1);
            v81 = v78;

            if (!v81)
            {
              ne_log_obj();
              v303 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v303, OS_LOG_TYPE_ERROR))
              {
                v352 = (void *)objc_msgSend(v4, "copyShortDescription");
                *(_DWORD *)v373 = 138412290;
                v374 = v352;
                _os_log_error_impl(&dword_19BD16000, v303, OS_LOG_TYPE_ERROR, "%@ Did not receive NONCE data", v373, 0xCu);

              }
              v100 = (id)NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("Did not receive NONCE data"), v304, v305, v306, v307, v308, v309, v310, v361);
              -[NEIKEv2IKESA setState:error:]((uint64_t)v10, 3uLL, v100);
              goto LABEL_154;
            }
            v83 = objc_getProperty(v10, v82, 80, 1);
            v84 = objc_msgSend(v83, "strictNonceSizeChecks");

            if (v84)
            {
              objc_getProperty(v4, v85, 112, 1);
              v86 = (void *)objc_claimAutoreleasedReturnValue();
              v88 = v86;
              if (v86)
                v86 = objc_getProperty(v86, v87, 24, 1);
              v89 = v86;
              v90 = objc_msgSend(v89, "length");

              if (v90 - 257 <= 0xFFFFFFFFFFFFFF0ELL)
              {
                ne_log_obj();
                v92 = objc_claimAutoreleasedReturnValue();
                v36 = v365;
                if (os_log_type_enabled(v92, OS_LOG_TYPE_ERROR))
                {
                  v353 = (void *)objc_msgSend(v4, "copyShortDescription");
                  *(_DWORD *)v373 = 138412546;
                  v374 = v353;
                  v375 = 2048;
                  v376 = v90;
                  _os_log_error_impl(&dword_19BD16000, v92, OS_LOG_TYPE_ERROR, "%@ NONCE data length %zu is out of bounds", v373, 0x16u);

                }
                v100 = (id)NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("NONCE data length %zu is out of bounds"), v93, v94, v95, v96, v97, v98, v99, v90);
                -[NEIKEv2IKESA setState:error:]((uint64_t)v10, 3uLL, v100);
                v101 = 0;
                v102 = 7;
LABEL_137:
                v20 = &OBJC_IVAR___NEIKEv2SessionConfiguration__ppkMandatory;
                goto LABEL_87;
              }
              v313 = objc_getProperty(v10, v91, 96, 1);
              -[NEIKEv2IKESAProposal prfProtocol](v313, v314);
              v315 = (void *)objc_claimAutoreleasedReturnValue();
              v316 = objc_msgSend(v315, "nonceSize");

              if (v90 < v316)
              {
                ne_log_obj();
                v317 = objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v317, OS_LOG_TYPE_ERROR))
                {
                  v354 = (void *)objc_msgSend(v4, "copyShortDescription");
                  v356 = objc_getProperty(v10, v355, 96, 1);
                  -[NEIKEv2IKESAProposal prfProtocol](v356, v357);
                  v358 = (void *)objc_claimAutoreleasedReturnValue();
                  *(_DWORD *)v373 = 138412802;
                  v374 = v354;
                  v375 = 2048;
                  v376 = v90;
                  v377 = 2112;
                  v378 = (uint64_t)v358;
                  _os_log_error_impl(&dword_19BD16000, v317, OS_LOG_TYPE_ERROR, "%@ NONCE data length %zu is shorter than the minimum for PRF protocol %@", v373, 0x20u);

                }
                v100 = objc_getProperty(v10, v318, 96, 1);
                -[NEIKEv2IKESAProposal prfProtocol](v100, v319);
                v362 = (void *)objc_claimAutoreleasedReturnValue();
                v327 = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("NONCE data length %zu is shorter than the minimum for PRF protocol %@"), v320, v321, v322, v323, v324, v325, v326, v90);
                -[NEIKEv2IKESA setState:error:]((uint64_t)v10, 3uLL, v327);

LABEL_154:
                v101 = 0;
                v102 = 7;
LABEL_155:
                v20 = &OBJC_IVAR___NEIKEv2SessionConfiguration__ppkMandatory;
                v36 = v365;
                goto LABEL_87;
              }
            }
            objc_getProperty(v4, v85, 112, 1);
            v328 = (void *)objc_claimAutoreleasedReturnValue();
            v100 = v328;
            v36 = v365;
            if (v328)
              v328 = objc_getProperty(v328, v329, 24, 1);
            v20 = &OBJC_IVAR___NEIKEv2SessionConfiguration__ppkMandatory;
            v330 = v328;
            objc_setProperty_atomic(v10, v331, v330, 136);

            v101 = 1;
            v102 = 7;
LABEL_87:

            if ((v101 & 1) != 0)
            {
              if ((-[NEIKEv2IKESA generateInitialValues](v10, v159) & 1) != 0)
              {
                if ((-[NEIKEv2IKESA processCurrentKeyExchange](v10, v160) & 1) != 0)
                {
                  v161 = v4;
                  v10 = v10;
                  objc_opt_self();
                  v163 = objc_getProperty(v10, v162, 96, 1);

                  if (v163)
                  {
                    v164 = -[NEIKEv2Packet initResponse:]((uint64_t)[NEIKEv2CreateChildPacket alloc], v161);
                    if (v164)
                    {
                      v165 = v164;
                      v367 = v161;
                      v166 = objc_alloc_init(NEIKEv2IKESAPayload);
                      objc_setProperty_atomic(v165, v167, v166, v20[286]);

                      v169 = objc_getProperty(v10, v168, 96, 1);
                      *(_QWORD *)v380 = v169;
                      objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v380, 1);
                      v170 = (void *)objc_claimAutoreleasedReturnValue();
                      v171 = v20;
                      objc_getProperty(v165, v172, v20[286], 1);
                      v173 = (void *)objc_claimAutoreleasedReturnValue();
                      v175 = v173;
                      if (v173)
                        objc_setProperty_atomic(v173, v174, v170, 24);

                      v177 = objc_getProperty(v10, v176, 32, 1);
                      objc_getProperty(v165, v178, v171[286], 1);
                      v179 = (void *)objc_claimAutoreleasedReturnValue();
                      v181 = v179;
                      if (v179)
                        objc_setProperty_atomic(v179, v180, v177, 32);

                      objc_getProperty(v165, v182, v171[286], 1);
                      v183 = (void *)objc_claimAutoreleasedReturnValue();
                      v184 = -[NEIKEv2Payload isValid]((uint64_t)v183);

                      if ((v184 & 1) != 0)
                      {
                        v185 = objc_alloc_init(NEIKEv2NoncePayload);
                        objc_setProperty_atomic(v165, v186, v185, 112);

                        v188 = objc_getProperty(v10, v187, 128, 1);
                        objc_getProperty(v165, v189, 112, 1);
                        v190 = (void *)objc_claimAutoreleasedReturnValue();
                        v192 = v190;
                        if (v190)
                          objc_setProperty_atomic(v190, v191, v188, 24);

                        objc_getProperty(v165, v193, 112, 1);
                        v194 = (void *)objc_claimAutoreleasedReturnValue();
                        v195 = -[NEIKEv2Payload isValid]((uint64_t)v194);

                        if ((v195 & 1) != 0)
                        {
                          v196 = objc_alloc_init(NEIKEv2KeyExchangePayload);
                          objc_setProperty_atomic(v165, v197, v196, 104);

                          v199 = objc_getProperty(v10, v198, 96, 1);
                          -[NEIKEv2IKESAProposal kemProtocol](v199, v200);
                          v201 = (void *)objc_claimAutoreleasedReturnValue();
                          objc_getProperty(v165, v202, 104, 1);
                          v203 = (void *)objc_claimAutoreleasedReturnValue();
                          v205 = v203;
                          if (v203)
                            objc_setProperty_atomic(v203, v204, v201, 24);

                          v207 = objc_getProperty(v10, v206, 160, 1);
                          v208 = v207;
                          if (v207)
                            v209 = (void *)*((_QWORD *)v207 + 2);
                          else
                            v209 = 0;
                          v210 = v209;
                          objc_getProperty(v165, v211, 104, 1);
                          v212 = (void *)objc_claimAutoreleasedReturnValue();
                          v214 = v212;
                          if (v212)
                            objc_setProperty_atomic(v212, v213, v210, 32);

                          objc_getProperty(v165, v215, 104, 1);
                          v216 = (void *)objc_claimAutoreleasedReturnValue();
                          v217 = -[NEIKEv2Payload isValid]((uint64_t)v216);

                          if ((v217 & 1) != 0)
                          {
                            v219 = objc_getProperty(v10, v218, 96, 1);
                            v221 = v219;
                            if (v219)
                              v219 = objc_getProperty(v219, v220, 120, 1);
                            v222 = v219;

                            if (v222)
                            {
                              objc_msgSend(MEMORY[0x1E0CB3A28], "UUID");
                              v223 = (void *)objc_claimAutoreleasedReturnValue();
                              *(_OWORD *)buf = 0uLL;
                              objc_msgSend(v223, "getUUIDBytes:", buf);
                              v224 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99D50]), "initWithBytes:length:", buf, 16);
                              v225 = +[NEIKEv2NotifyPayload createNotifyPayloadType:data:]((uint64_t)NEIKEv2NotifyPayload, 0x4039uLL, v224);
                              objc_setProperty_atomic(v10, v226, v225, 176);

                              v228 = objc_getProperty(v10, v227, 176, 1);
                              -[NEIKEv2Packet addNotifyPayload:](v165, v228);

                            }
                            v165 = v165;
                            v229 = v165;
                            goto LABEL_142;
                          }
                          ne_log_obj();
                          v250 = objc_claimAutoreleasedReturnValue();
                          if (os_log_type_enabled(v250, OS_LOG_TYPE_FAULT))
                          {
                            *(_DWORD *)buf = 136315138;
                            *(_QWORD *)&buf[4] = "+[NEIKEv2CreateChildPacket(Exchange) createRekeyResponse:ikeSA:]";
                            v251 = "%s called with null packet.ke.isValid";
                            goto LABEL_140;
                          }
LABEL_141:

                          v229 = 0;
LABEL_142:
                          v161 = v367;
                          goto LABEL_143;
                        }
                        ne_log_obj();
                        v250 = objc_claimAutoreleasedReturnValue();
                        if (!os_log_type_enabled(v250, OS_LOG_TYPE_FAULT))
                          goto LABEL_141;
                        *(_DWORD *)buf = 136315138;
                        *(_QWORD *)&buf[4] = "+[NEIKEv2CreateChildPacket(Exchange) createRekeyResponse:ikeSA:]";
                        v251 = "%s called with null packet.nonce.isValid";
                      }
                      else
                      {
                        ne_log_obj();
                        v250 = objc_claimAutoreleasedReturnValue();
                        if (!os_log_type_enabled(v250, OS_LOG_TYPE_FAULT))
                          goto LABEL_141;
                        *(_DWORD *)buf = 136315138;
                        *(_QWORD *)&buf[4] = "+[NEIKEv2CreateChildPacket(Exchange) createRekeyResponse:ikeSA:]";
                        v251 = "%s called with null packet.ikeSA.isValid";
                      }
LABEL_140:
                      _os_log_fault_impl(&dword_19BD16000, v250, OS_LOG_TYPE_FAULT, v251, buf, 0xCu);
                      goto LABEL_141;
                    }
                    ne_log_obj();
                    v249 = objc_claimAutoreleasedReturnValue();
                    if (os_log_type_enabled(v249, OS_LOG_TYPE_FAULT))
                    {
                      *(_WORD *)buf = 0;
                      _os_log_fault_impl(&dword_19BD16000, v249, OS_LOG_TYPE_FAULT, "[[NEIKEv2CreateChildPacket alloc] initResponse:] failed", buf, 2u);
                    }

                    v165 = 0;
                  }
                  else
                  {
                    ne_log_obj();
                    v165 = objc_claimAutoreleasedReturnValue();
                    if (os_log_type_enabled(v165, OS_LOG_TYPE_FAULT))
                    {
                      *(_DWORD *)buf = 136315138;
                      *(_QWORD *)&buf[4] = "+[NEIKEv2CreateChildPacket(Exchange) createRekeyResponse:ikeSA:]";
                      _os_log_fault_impl(&dword_19BD16000, v165, OS_LOG_TYPE_FAULT, "%s called with null ikeSA.chosenProposal", buf, 0xCu);
                    }
                  }
                  v229 = 0;
LABEL_143:

                  if (v229)
                  {
                    v284 = objc_getProperty(v10, v283, 160, 1);
                    v285 = v284;
                    if (v284)
                      v286 = (void *)*((_QWORD *)v284 + 3);
                    else
                      v286 = 0;
                    v287 = v286;
                    objc_setProperty_atomic(v10, v288, v287, 168);

                    objc_setProperty_atomic(v10, v289, 0, 160);
                    v368[0] = MEMORY[0x1E0C809B0];
                    v368[1] = 3221225472;
                    v368[2] = __46__NEIKEv2Session_Exchange__receiveRekeyIKESA___block_invoke_439;
                    v368[3] = &unk_1E3CC1248;
                    v369 = v10;
                    v370 = v8;
                    v371 = a1;
                    -[NEIKEv2Session handleFollowupKEForRekeyIKESAResponder:iteration:replyPacket:replyPacketDescription:handler:](a1, v369, 0, v229, CFSTR("rekey IKE SA reply"), v368);

                  }
                  else
                  {
                    ne_log_obj();
                    v290 = objc_claimAutoreleasedReturnValue();
                    if (os_log_type_enabled(v290, OS_LOG_TYPE_ERROR))
                    {
                      *(_WORD *)buf = 0;
                      _os_log_error_impl(&dword_19BD16000, v290, OS_LOG_TYPE_ERROR, "Failed to create Create Child SA packet (receive rekey)", buf, 2u);
                    }

                    v292 = objc_getProperty(a1, v291, 336, 1);
                    ErrorInternal = (void *)NEIKEv2CreateErrorInternal(CFSTR("Failed to create Create Child SA packet (receive rekey)"), v293, v294, v295, v296, v297, v298, v299, v361);
                    -[NEIKEv2IKESA setState:error:]((uint64_t)v292, 3uLL, ErrorInternal);

                    -[NEIKEv2Session reportState](a1, v301);
                    -[NEIKEv2Session resetAll]((uint64_t)a1, v302);
                  }

                  goto LABEL_69;
                }
                ne_log_obj();
                v359 = objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v359, OS_LOG_TYPE_ERROR))
                {
                  *(_WORD *)buf = 0;
                  _os_log_error_impl(&dword_19BD16000, v359, OS_LOG_TYPE_ERROR, "Failed to process KE data (receive rekey)", buf, 2u);
                }

                v244 = objc_getProperty(a1, v360, 336, 1);
                v245 = CFSTR("Failed to process KE data (receive rekey)");
              }
              else
              {
                ne_log_obj();
                v235 = objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v235, OS_LOG_TYPE_ERROR))
                {
                  *(_WORD *)buf = 0;
                  _os_log_error_impl(&dword_19BD16000, v235, OS_LOG_TYPE_ERROR, "Failed to generate local IKE crypto values (receive rekey)", buf, 2u);
                }

                v244 = objc_getProperty(a1, v236, 336, 1);
                v245 = CFSTR("Failed to generate local IKE crypto values (receive rekey)");
              }
              ErrorCrypto = (void *)NEIKEv2CreateErrorCrypto(v245, v237, v238, v239, v240, v241, v242, v243, v361);
              -[NEIKEv2IKESA setState:error:]((uint64_t)v244, 3uLL, ErrorCrypto);

              -[NEIKEv2Session reportState](a1, v247);
              -[NEIKEv2Session resetAll]((uint64_t)a1, v248);
LABEL_69:

              goto LABEL_70;
            }
            v8[16] = 0;
            if (v102 == 17)
            {
              v230 = objc_getProperty(v10, v159, 96, 1);
              -[NEIKEv2IKESAProposal kemProtocol](v230, v231);
              v232 = (void *)objc_claimAutoreleasedReturnValue();
              v233 = bswap32(objc_msgSend(v232, "method")) >> 16;

              *(_WORD *)buf = v233;
              v234 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99D50]), "initWithBytes:length:", buf, 2);
              +[NEIKEv2CreateChildPacket createChildSAResponse:errorCode:errorData:]((uint64_t)NEIKEv2CreateChildPacket, v4, 0x11uLL, v234);
              v118 = (void *)objc_claimAutoreleasedReturnValue();

              if (v118)
              {
                if ((-[NEIKEv2Session sendReply:replyHandler:]((uint64_t)a1, v118, 0) & 1) != 0)
                  goto LABEL_68;
                goto LABEL_66;
              }
              ne_log_obj();
              v343 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v343, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)v380 = 0;
                _os_log_error_impl(&dword_19BD16000, v343, OS_LOG_TYPE_ERROR, "Failed to create Create Child SA packet (receive rekey)", v380, 2u);
              }
              goto LABEL_170;
            }
LABEL_62:
            +[NEIKEv2CreateChildPacket createChildSAResponse:errorCode:errorData:]((uint64_t)NEIKEv2CreateChildPacket, v4, v102, 0);
            v118 = (void *)objc_claimAutoreleasedReturnValue();
            if (v118)
            {
              if ((-[NEIKEv2Session sendReply:replyHandler:]((uint64_t)a1, v118, 0) & 1) != 0)
              {
                if (v102 == 14)
                {
LABEL_68:

                  goto LABEL_69;
                }
                v120 = objc_getProperty(a1, v119, 336, 1);
                ErrorFailedToSend = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("Failed to process Create Child SA packet (receive rekey)"), v121, v122, v123, v124, v125, v126, v127, v361);
LABEL_67:
                v136 = ErrorFailedToSend;
                -[NEIKEv2IKESA setState:error:]((uint64_t)v120, 3uLL, ErrorFailedToSend);

                -[NEIKEv2Session reportState](a1, v137);
                -[NEIKEv2Session resetAll]((uint64_t)a1, v138);
                goto LABEL_68;
              }
LABEL_66:
              v120 = objc_getProperty(a1, v119, 336, 1);
              ErrorFailedToSend = (void *)NEIKEv2CreateErrorFailedToSend(CFSTR("rekey IKE SA refusal"), v129, v130, v131, v132, v133, v134, v135, v361);
              goto LABEL_67;
            }
            ne_log_obj();
            v343 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v343, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)buf = 0;
              _os_log_error_impl(&dword_19BD16000, v343, OS_LOG_TYPE_ERROR, "Failed to create Create Child SA packet (receive rekey)", buf, 2u);
            }
LABEL_170:

            v120 = objc_getProperty(a1, v344, 336, 1);
            ErrorFailedToSend = (void *)NEIKEv2CreateErrorInternal(CFSTR("Failed to create Create Child SA packet (receive rekey)"), v345, v346, v347, v348, v349, v350, v351, v361);
            goto LABEL_67;
          }
          ne_log_obj();
          v158 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v158, OS_LOG_TYPE_ERROR))
          {
            v332 = (void *)objc_msgSend(v4, "copyShortDescription");
            *(_DWORD *)v373 = 138412290;
            v374 = v332;
            _os_log_error_impl(&dword_19BD16000, v158, OS_LOG_TYPE_ERROR, "%@ Did not receive data in KE payload", v373, 0xCu);

          }
          v147 = CFSTR("Did not receive data in KE payload");
        }
        else
        {
          ne_log_obj();
          v157 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v157, OS_LOG_TYPE_ERROR))
          {
            v312 = (void *)objc_msgSend(v4, "copyShortDescription");
            *(_DWORD *)v373 = 138412290;
            v374 = v312;
            _os_log_error_impl(&dword_19BD16000, v157, OS_LOG_TYPE_ERROR, "%@ Did not receive method in KE payload", v373, 0xCu);

          }
          v147 = CFSTR("Did not receive method in KE payload");
        }
      }
      else
      {
        ne_log_obj();
        v156 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v156, OS_LOG_TYPE_ERROR))
        {
          v311 = (void *)objc_msgSend(v4, "copyShortDescription");
          *(_DWORD *)v373 = 138412290;
          v374 = v311;
          _os_log_error_impl(&dword_19BD16000, v156, OS_LOG_TYPE_ERROR, "%@ Did not receive KE payload", v373, 0xCu);

        }
        v147 = CFSTR("Did not receive KE payload");
      }
    }
    else
    {
      ne_log_obj();
      v139 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v139, OS_LOG_TYPE_ERROR))
      {
        v273 = (void *)objc_msgSend(v4, "copyShortDescription");
        *(_DWORD *)v373 = 138412290;
        v374 = v273;
        _os_log_error_impl(&dword_19BD16000, v139, OS_LOG_TYPE_ERROR, "%@ Received no SA proposals", v373, 0xCu);

      }
      v147 = CFSTR("Received no SA proposals");
    }
    v100 = (id)NEIKEv2CreateErrorPeerInvalidSyntax(v147, v140, v141, v142, v143, v144, v145, v146, v361);
    -[NEIKEv2IKESA setState:error:]((uint64_t)v10, 3uLL, v100);
    v101 = 0;
    v102 = 7;
    goto LABEL_87;
  }
LABEL_70:

}

void __46__NEIKEv2Session_Exchange__receiveRekeyIKESA___block_invoke(uint64_t a1, const char *a2)
{
  id Property;
  id v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *ErrorInternal;
  const char *v13;
  const char *v14;
  uint64_t v15;

  Property = *(id *)(a1 + 32);
  if (Property)
    Property = objc_getProperty(Property, a2, 336, 1);
  v4 = Property;
  ErrorInternal = (void *)NEIKEv2CreateErrorInternal(CFSTR("Failed to create valid IKE SA (receive rekey)"), v5, v6, v7, v8, v9, v10, v11, v15);
  -[NEIKEv2IKESA setState:error:]((uint64_t)v4, 3uLL, ErrorInternal);

  -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 32), v13);
  -[NEIKEv2Session resetAll](*(_QWORD *)(a1 + 32), v14);
}

void __46__NEIKEv2Session_Exchange__receiveRekeyIKESA___block_invoke_439(uint64_t a1, void *a2)
{
  id v3;
  _BYTE *v4;
  const char *v5;
  void *v6;
  const char *v7;
  NSObject *v8;
  NSObject *v9;
  const char *v10;
  NEIKEv2DeleteIKEContext *v11;
  id Property;
  id v13;
  NSObject *v14;
  const char *v15;
  id v16;
  id v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  void *ErrorPeerInvalidSyntax;
  const char *v26;
  const char *v27;
  NSObject *v28;
  const char *v29;
  id v30;
  id v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  void *ErrorFailedToSend;
  id v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  void *v48;
  const char *v49;
  const char *v50;
  uint64_t v51;
  uint64_t v52;
  _QWORD v53[5];
  uint8_t buf[4];
  uint64_t v55;
  uint64_t v56;

  v56 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  v4 = *(_BYTE **)(a1 + 32);
  if (!v4 || (-[NEIKEv2IKESA generateAllValuesUsingSA:](v4, *(void **)(a1 + 40)) & 1) == 0)
  {
    ne_log_obj();
    v9 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_19BD16000, v9, OS_LOG_TYPE_ERROR, "Failed to generate IKE SA crypto values (receive rekey)", buf, 2u);
    }

    v11 = [NEIKEv2DeleteIKEContext alloc];
    Property = *(id *)(a1 + 48);
    if (Property)
      Property = objc_getProperty(Property, v10, 368, 1);
    v13 = Property;
    v53[0] = MEMORY[0x1E0C809B0];
    v53[1] = 3221225472;
    v53[2] = __46__NEIKEv2Session_Exchange__receiveRekeyIKESA___block_invoke_440;
    v53[3] = &unk_1E3CC1408;
    v53[4] = *(_QWORD *)(a1 + 48);
    v6 = -[NEIKEv2DeleteIKEContext initDeleteIKEWithResponse:callbackQueue:callback:]((id *)&v11->super.super.isa, 0, v13, v53);

    -[NEIKEv2Session initiateDelete:](*(_QWORD **)(a1 + 48), v6);
    goto LABEL_29;
  }
  if (v3 && (-[NEIKEv2InformationalPacket isDeleteIKE](v3, v5) & 1) != 0)
  {
    +[NEIKEv2InformationalPacket createInformationalResponse:ikeSA:]((uint64_t)NEIKEv2InformationalPacket, v3, 0);
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    if (v6)
    {
      if ((-[NEIKEv2Session sendReply:replyHandler:](*(_QWORD *)(a1 + 48), v6, 0) & 1) != 0)
      {
        -[NEIKEv2IKESA setState:error:](*(_QWORD *)(a1 + 32), 2uLL, 0);
        -[NEIKEv2Session setIKESA:](*(_QWORD *)(a1 + 48), *(void **)(a1 + 32));
        ne_log_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_19BD16000, v8, OS_LOG_TYPE_INFO, "Rekeyed IKE SA", buf, 2u);
        }

        goto LABEL_29;
      }
      v40 = *(id *)(a1 + 48);
      if (v40)
        v40 = objc_getProperty(v40, v7, 336, 1);
      v31 = v40;
      ErrorFailedToSend = (void *)NEIKEv2CreateErrorFailedToSend(CFSTR("delete reply"), v41, v42, v43, v44, v45, v46, v47, v52);
    }
    else
    {
      ne_log_obj();
      v28 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
      {
        v51 = *(_QWORD *)(a1 + 48);
        *(_DWORD *)buf = 138412290;
        v55 = v51;
        _os_log_error_impl(&dword_19BD16000, v28, OS_LOG_TYPE_ERROR, "%@ Failed to create IKE Delete response packet", buf, 0xCu);
      }

      v30 = *(id *)(a1 + 48);
      if (v30)
        v30 = objc_getProperty(v30, v29, 336, 1);
      v31 = v30;
      ErrorFailedToSend = (void *)NEIKEv2CreateErrorInternal(CFSTR("Failed to create IKE Delete response packet (receive rekey)"), v32, v33, v34, v35, v36, v37, v38, v52);
    }
    v48 = ErrorFailedToSend;
    -[NEIKEv2IKESA setState:error:]((uint64_t)v31, 3uLL, ErrorFailedToSend);

    -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 48), v49);
    -[NEIKEv2Session resetAll](*(_QWORD *)(a1 + 48), v50);
LABEL_29:

    goto LABEL_30;
  }
  ne_log_obj();
  v14 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl(&dword_19BD16000, v14, OS_LOG_TYPE_ERROR, "Failed to process Rekey IKE Delete packet (receive rekey)", buf, 2u);
  }

  v16 = *(id *)(a1 + 48);
  if (v16)
    v16 = objc_getProperty(v16, v15, 336, 1);
  v17 = v16;
  ErrorPeerInvalidSyntax = (void *)NEIKEv2CreateErrorPeerInvalidSyntax(CFSTR("Failed to process Rekey IKE Delete packet (receive rekey)"), v18, v19, v20, v21, v22, v23, v24, v52);
  -[NEIKEv2IKESA setState:error:]((uint64_t)v17, 3uLL, ErrorPeerInvalidSyntax);

  -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 48), v26);
  -[NEIKEv2Session resetAll](*(_QWORD *)(a1 + 48), v27);
LABEL_30:

}

void __46__NEIKEv2Session_Exchange__receiveRekeyIKESA___block_invoke_440(uint64_t a1, const char *a2)
{
  id Property;
  id v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *ErrorCrypto;
  const char *v13;
  const char *v14;
  uint64_t v15;

  Property = *(id *)(a1 + 32);
  if (Property)
    Property = objc_getProperty(Property, a2, 336, 1);
  v4 = Property;
  ErrorCrypto = (void *)NEIKEv2CreateErrorCrypto(CFSTR("Failed to generate IKE SA crypto values (receive rekey)"), v5, v6, v7, v8, v9, v10, v11, v15);
  -[NEIKEv2IKESA setState:error:]((uint64_t)v4, 3uLL, ErrorCrypto);

  -[NEIKEv2Session reportState](*(_QWORD **)(a1 + 32), v13);
  -[NEIKEv2Session resetAll](*(_QWORD *)(a1 + 32), v14);
}

- (void)receiveMOBIKE:(_QWORD *)a1
{
  const char *v3;
  id v4;
  NSObject *v5;
  SEL v6;
  id v7;
  id v8;
  const char *v9;
  const char *v10;
  id Property;
  id v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  const char *v19;
  void *v20;
  id v21;
  const char *v22;
  id v23;
  id v24;
  SEL v25;
  id v26;
  id v27;
  uint64_t v28;
  const char *v29;
  NSObject *v30;
  void *v31;
  const char *v32;
  void *v33;
  BOOL v34;
  NSObject *v35;
  NSObject *v36;
  const char *v37;
  NSObject *v38;
  NSObject *v39;
  const char *v40;
  id v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  void *ErrorFailedToSend;
  const char *v50;
  const char *v51;
  NSObject *v52;
  void *v53;
  uint64_t v54;
  void *v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  uint8_t v60[4];
  void *v61;
  __int16 v62;
  uint64_t v63;
  uint8_t buf[4];
  const char *v65;
  uint64_t v66;

  v66 = *MEMORY[0x1E0C80C00];
  v4 = a2;
  if (a1)
  {
    v5 = objc_getProperty(a1, v3, 368, 1);
    dispatch_assert_queue_V2(v5);

    v7 = objc_getProperty(a1, v6, 336, 1);
    if (!v7)
    {
      ne_log_obj();
      v35 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v35, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136315138;
        v65 = "-[NEIKEv2Session(Exchange) receiveMOBIKE:]";
        _os_log_fault_impl(&dword_19BD16000, v35, OS_LOG_TYPE_FAULT, "%s called with null ikeSA", buf, 0xCu);
      }
      goto LABEL_29;
    }
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) == 0 || (-[NEIKEv2InformationalPacket isMOBIKE](v4) & 1) == 0)
    {
      ne_log_obj();
      v35 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        v37 = "Failed to receive MOBIKE packet";
LABEL_39:
        _os_log_error_impl(&dword_19BD16000, v35, OS_LOG_TYPE_ERROR, v37, buf, 2u);
      }
      goto LABEL_29;
    }
    v8 = v7;
    if (-[NEIKEv2Packet hasErrors](v4, v9))
    {
      v58 = 0u;
      v59 = 0u;
      v56 = 0u;
      v57 = 0u;
      v55 = v8;
      if (v4)
        Property = objc_getProperty(v4, v10, 64, 1);
      else
        Property = 0;
      v12 = Property;
      v13 = objc_msgSend(v12, "countByEnumeratingWithState:objects:count:", &v56, buf, 16);
      if (v13)
      {
        v14 = v13;
        v15 = *(_QWORD *)v57;
LABEL_10:
        v16 = 0;
        while (1)
        {
          if (*(_QWORD *)v57 != v15)
            objc_enumerationMutation(v12);
          v17 = *(_QWORD *)(*((_QWORD *)&v56 + 1) + 8 * v16);
          if (v17)
          {
            if ((unint64_t)(*(_QWORD *)(v17 + 24) - 1) <= 0x3FFE)
              break;
          }
          if (v14 == ++v16)
          {
            v14 = objc_msgSend(v12, "countByEnumeratingWithState:objects:count:", &v56, buf, 16);
            if (v14)
              goto LABEL_10;
            goto LABEL_17;
          }
        }
        ne_log_obj();
        v36 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
        {
          v53 = (void *)objc_msgSend(v4, "copyShortDescription");
          *(_DWORD *)v60 = 138412546;
          v61 = v53;
          v62 = 2112;
          v63 = v17;
          _os_log_error_impl(&dword_19BD16000, v36, OS_LOG_TYPE_ERROR, "%@ MOBIKE received notify error %@", v60, 0x16u);

        }
        ne_log_obj();
        v35 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)buf = 0;
          v37 = "Failed to process MOBIKE packet";
          goto LABEL_39;
        }
        goto LABEL_29;
      }
LABEL_17:

      v8 = v55;
    }
    v18 = -[NEIKEv2Packet copyNotification:](v4, (const char *)0x4011);
    v20 = v18;
    if (v18)
      v18 = objc_getProperty(v18, v19, 32, 1);
    v21 = v18;

    if (v21)
    {
      if (v20)
        v23 = objc_getProperty(v20, v22, 32, 1);
      else
        v23 = 0;
      v24 = v23;
      objc_setProperty_atomic(v8, v25, v24, 288);

    }
    v26 = v4;
    v27 = v8;
    objc_opt_self();
    v28 = -[NEIKEv2Packet initResponse:]((uint64_t)[NEIKEv2InformationalPacket alloc], v26);
    if (v28)
    {
      v30 = v28;
      objc_getProperty(v27, v29, 288, 1);
      v31 = (void *)objc_claimAutoreleasedReturnValue();

      if (!v31
        || (objc_getProperty(v27, v32, 288, 1),
            v33 = (void *)objc_claimAutoreleasedReturnValue(),
            v34 = -[NEIKEv2Packet addNotification:data:](v30, 0x4011uLL, v33),
            v33,
            v34))
      {
        v30 = v30;
        v35 = v30;
        goto LABEL_44;
      }
      ne_log_obj();
      v39 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v39, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_fault_impl(&dword_19BD16000, v39, OS_LOG_TYPE_FAULT, "[packet addNotification:NEIKEv2NotifyTypeCookie2] failed", buf, 2u);
      }

    }
    else
    {
      ne_log_obj();
      v38 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v38, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_fault_impl(&dword_19BD16000, v38, OS_LOG_TYPE_FAULT, "[[NEIKEv2InformationalPacket alloc] initOutbound:] failed", buf, 2u);
      }

      v30 = 0;
    }
    v35 = 0;
LABEL_44:

    if (v35)
    {
      if ((-[NEIKEv2Session sendReply:replyHandler:]((uint64_t)a1, v35, 0) & 1) == 0)
      {
        v41 = objc_getProperty(a1, v40, 336, 1);
        ErrorFailedToSend = (void *)NEIKEv2CreateErrorFailedToSend(CFSTR("MOBIKE reply"), v42, v43, v44, v45, v46, v47, v48, v54);
        -[NEIKEv2IKESA setState:error:]((uint64_t)v41, 3uLL, ErrorFailedToSend);

        -[NEIKEv2Session reportState](a1, v50);
        -[NEIKEv2Session resetAll]((uint64_t)a1, v51);
      }
    }
    else
    {
      ne_log_obj();
      v52 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_19BD16000, v52, OS_LOG_TYPE_ERROR, "Failed to create MOBIKE packet", buf, 2u);
      }

      v35 = 0;
    }
LABEL_29:

  }
}

- (void)receiveRedirect:(_QWORD *)a1
{
  const char *v3;
  id v4;
  NSObject *v5;
  const char *v6;
  int v7;
  NSObject *v8;
  NSObject *v9;
  const char *v10;
  uint8_t *v11;
  NSObject *v12;
  const char *v13;
  id v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  void *ErrorFailedToSend;
  const char *v23;
  const char *v24;
  NSObject *v25;
  uint64_t v26;
  uint8_t buf[16];
  __int16 v28;
  uint8_t v29[2];

  v4 = a2;
  if (a1)
  {
    v5 = objc_getProperty(a1, v3, 368, 1);
    dispatch_assert_queue_V2(v5);

    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0 && (-[NEIKEv2Packet hasNotification:](v4, (const char *)0x4017) & 1) != 0)
    {
      if (v4)
      {
        v7 = -[NEIKEv2Packet hasErrors](v4, v6);
        ne_log_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v9 = v8;
        if (!v7)
        {
          if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl(&dword_19BD16000, v9, OS_LOG_TYPE_DEFAULT, "Received server redirect", buf, 2u);
          }

          -[NEIKEv2Session reportServerRedirect:](a1, v4);
          +[NEIKEv2InformationalPacket createInformationalResponse:ikeSA:]((uint64_t)NEIKEv2InformationalPacket, v4, 0);
          v12 = objc_claimAutoreleasedReturnValue();
          if (v12)
          {
            v9 = v12;
            if ((-[NEIKEv2Session sendReply:replyHandler:]((uint64_t)a1, v12, 0) & 1) == 0)
            {
              v14 = objc_getProperty(a1, v13, 336, 1);
              ErrorFailedToSend = (void *)NEIKEv2CreateErrorFailedToSend(CFSTR("redirect reply"), v15, v16, v17, v18, v19, v20, v21, v26);
              -[NEIKEv2IKESA setState:error:]((uint64_t)v14, 3uLL, ErrorFailedToSend);

              -[NEIKEv2Session reportState](a1, v23);
              -[NEIKEv2Session resetAll]((uint64_t)a1, v24);
            }
          }
          else
          {
            ne_log_obj();
            v25 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
            {
              LOWORD(v26) = 0;
              _os_log_error_impl(&dword_19BD16000, v25, OS_LOG_TYPE_ERROR, "Failed to create REDIRECT response packet", (uint8_t *)&v26, 2u);
            }

            v9 = 0;
          }
          goto LABEL_9;
        }
      }
      else
      {
        ne_log_obj();
        v9 = objc_claimAutoreleasedReturnValue();
      }
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        v28 = 0;
        v10 = "Failed to process redirect packet";
        v11 = (uint8_t *)&v28;
LABEL_20:
        _os_log_error_impl(&dword_19BD16000, v9, OS_LOG_TYPE_ERROR, v10, v11, 2u);
      }
    }
    else
    {
      ne_log_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)v29 = 0;
        v10 = "Failed to receive redirect packet";
        v11 = v29;
        goto LABEL_20;
      }
    }
LABEL_9:

  }
}

- (void)receiveDeleteIKESA:(_QWORD *)a1
{
  const char *v3;
  id v4;
  NSObject *v5;
  SEL v6;
  id v7;
  id v8;
  const char *v9;
  NSObject *v10;
  const char *v11;
  char v12;
  NSObject *v13;
  NSObject *v14;
  SEL v15;
  id v16;
  void *Error;
  const char *v18;
  const char *v19;
  NSObject *v20;
  const char *v21;
  NSObject *v22;
  id v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  void *ErrorFailedToSend;
  const char *v32;
  const char *v33;
  NSObject *v34;
  _BYTE v35[12];
  __int16 v36;
  id v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v4 = a2;
  if (a1)
  {
    v5 = objc_getProperty(a1, v3, 368, 1);
    dispatch_assert_queue_V2(v5);

    v7 = objc_getProperty(a1, v6, 336, 1);
    if (!v7)
    {
      ne_log_obj();
      v34 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v34, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)v35 = 136315138;
        *(_QWORD *)&v35[4] = "-[NEIKEv2Session(Exchange) receiveDeleteIKESA:]";
        _os_log_fault_impl(&dword_19BD16000, v34, OS_LOG_TYPE_FAULT, "%s called with null ikeSA", v35, 0xCu);
      }

      goto LABEL_17;
    }
    v8 = v4;
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      if (v8 && !-[NEIKEv2Packet hasErrors](v8, v9))
      {
        +[NEIKEv2InformationalPacket createInformationalResponse:ikeSA:]((uint64_t)NEIKEv2InformationalPacket, v8, 0);
        v20 = objc_claimAutoreleasedReturnValue();
        if (v20)
        {
          v10 = v20;
          if ((-[NEIKEv2Session sendReply:replyHandler:]((uint64_t)a1, v20, 0) & 1) != 0)
          {
            v12 = 1;
LABEL_10:

            ne_log_large_obj();
            v13 = objc_claimAutoreleasedReturnValue();
            v14 = v13;
            if ((v12 & 1) != 0)
            {
              if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)v35 = 138412546;
                *(_QWORD *)&v35[4] = a1;
                v36 = 2112;
                v37 = v7;
                _os_log_impl(&dword_19BD16000, v14, OS_LOG_TYPE_DEFAULT, "%@ Received IKE SA Delete %@", v35, 0x16u);
              }

              v16 = objc_getProperty(a1, v15, 336, 1);
              Error = (void *)NEIKEv2CreateError(14);
              -[NEIKEv2IKESA setState:error:]((uint64_t)v16, 3uLL, Error);

              -[NEIKEv2Session reportState](a1, v18);
              -[NEIKEv2Session resetAll]((uint64_t)a1, v19);
            }
            else
            {
              if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)v35 = 138412546;
                *(_QWORD *)&v35[4] = a1;
                v36 = 2112;
                v37 = v7;
                _os_log_error_impl(&dword_19BD16000, v14, OS_LOG_TYPE_ERROR, "%@ Failed to process received IKE SA Delete %@", v35, 0x16u);
              }

            }
LABEL_17:

            goto LABEL_18;
          }
          v23 = objc_getProperty(a1, v21, 336, 1);
          ErrorFailedToSend = (void *)NEIKEv2CreateErrorFailedToSend(CFSTR("delete reply"), v24, v25, v26, v27, v28, v29, v30, *(uint64_t *)v35);
          -[NEIKEv2IKESA setState:error:]((uint64_t)v23, 3uLL, ErrorFailedToSend);

          -[NEIKEv2Session reportState](a1, v32);
          -[NEIKEv2Session resetAll]((uint64_t)a1, v33);
        }
        else
        {
          ne_log_obj();
          v22 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)v35 = 138412290;
            *(_QWORD *)&v35[4] = a1;
            _os_log_error_impl(&dword_19BD16000, v22, OS_LOG_TYPE_ERROR, "%@ Failed to create Delete packet", v35, 0xCu);
          }

          v10 = 0;
        }
      }
      else
      {
        ne_log_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)v35 = 138412290;
          *(_QWORD *)&v35[4] = a1;
          v11 = "%@ Failed to process Delete packet";
LABEL_27:
          _os_log_error_impl(&dword_19BD16000, v10, OS_LOG_TYPE_ERROR, v11, v35, 0xCu);
        }
      }
    }
    else
    {
      ne_log_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)v35 = 138412290;
        *(_QWORD *)&v35[4] = a1;
        v11 = "%@ Failed to receive Delete packet";
        goto LABEL_27;
      }
    }
    v12 = 0;
    goto LABEL_10;
  }
LABEL_18:

}

- (void)receiveDeleteChildSA:(_QWORD *)a1
{
  const char *v3;
  id v4;
  NSObject *v5;
  SEL v6;
  const char *v7;
  id v8;
  void *v9;
  NSObject *v10;
  const char *v11;
  NSObject *v12;
  id Property;
  id v14;
  void *v15;
  NSObject *v16;
  const char *v17;
  NSObject *v18;
  id v19;
  const char *v20;
  void *v21;
  id v22;
  SEL v23;
  id v24;
  const char *v25;
  void *v26;
  id v27;
  char v28;
  NSObject *v29;
  NSObject *v30;
  const char *v31;
  void *v32;
  id v33;
  const char *v34;
  void *v35;
  NSObject *v36;
  const char *v37;
  NSObject *v38;
  SEL v39;
  id v40;
  uint64_t v41;
  const char *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  void *v46;
  id v47;
  id v48;
  const char *v49;
  id v50;
  id v51;
  char v52;
  uint64_t v53;
  const char *v54;
  id v55;
  char v56;
  NSObject *v57;
  const char *v58;
  NSObject *v59;
  void *v60;
  void *v61;
  NSObject *v62;
  id v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  uint8_t buf[4];
  const char *v69;
  __int16 v70;
  NSObject *v71;
  uint64_t v72;

  v72 = *MEMORY[0x1E0C80C00];
  v4 = a2;
  if (a1)
  {
    v5 = objc_getProperty(a1, v3, 368, 1);
    dispatch_assert_queue_V2(v5);

    v8 = objc_getProperty(a1, v6, 336, 1);
    if (!v8)
    {
      ne_log_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136315138;
        v69 = "-[NEIKEv2Session(Exchange) receiveDeleteChildSA:]";
        _os_log_fault_impl(&dword_19BD16000, v12, OS_LOG_TYPE_FAULT, "%s called with null ikeSA", buf, 0xCu);
      }
      goto LABEL_44;
    }
    objc_getProperty(v4, v7, 88, 1);
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v9, "firstObject");
    v10 = objc_claimAutoreleasedReturnValue();

    v12 = v10;
    if (v10)
      Property = objc_getProperty(v10, v11, 32, 1);
    else
      Property = 0;
    v14 = Property;
    objc_msgSend(v14, "firstObject");
    v15 = (void *)objc_claimAutoreleasedReturnValue();

    v16 = -[NEIKEv2Session copyChildWithSPI:](a1, v15);
    v63 = v8;
    if (v16)
    {
      v18 = v16;
      v19 = objc_getProperty(v16, v17, 56, 1);
      v21 = v19;
      if (v19)
        v19 = objc_getProperty(v19, v20, 80, 1);
      v22 = v19;
      v24 = objc_getProperty(v18, v23, 56, 1);
      v26 = v24;
      if (v24)
        v24 = objc_getProperty(v24, v25, 88, 1);
      v27 = v24;
      v28 = -[NEIKEv2Session receiveDeleteChildSPI:remoteSPI:packet:](a1, v22, v27, v4);

      ne_log_large_obj();
      v29 = objc_claimAutoreleasedReturnValue();
      v30 = v29;
      if ((v28 & 1) != 0)
      {
        v32 = v15;
        if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
        {
          v33 = objc_getProperty(v18, v31, 56, 1);
          v35 = v33;
          if (v33)
            v33 = objc_getProperty(v33, v34, 88, 1);
          v36 = v33;
          *(_DWORD *)buf = 138412546;
          v69 = (const char *)a1;
          v70 = 2112;
          v71 = v36;
          _os_log_impl(&dword_19BD16000, v30, OS_LOG_TYPE_DEFAULT, "%@ Received Child SA Delete for remote SPI %@", buf, 0x16u);

        }
        -[NEIKEv2ChildSA setState:error:]((uint64_t)v18, 3uLL, 0);
        -[NEIKEv2Session reportState](a1, v37);
        -[NEIKEv2Session resetChild:]((char *)a1, v18);
        v8 = v63;
        goto LABEL_43;
      }
      v8 = v63;
      v32 = v15;
      if (!os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
      {
LABEL_34:

LABEL_43:
LABEL_44:

        goto LABEL_45;
      }
    }
    else
    {
      v61 = v15;
      v62 = v12;
      v38 = v15;
      v64 = 0u;
      v65 = 0u;
      v66 = 0u;
      v67 = 0u;
      v40 = objc_getProperty(a1, v39, 288, 1);
      v41 = objc_msgSend(v40, "countByEnumeratingWithState:objects:count:", &v64, buf, 16);
      if (!v41)
      {
LABEL_32:

LABEL_40:
        ne_log_obj();
        v18 = objc_claimAutoreleasedReturnValue();
        v12 = v62;
        v8 = v63;
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 138412546;
          v69 = (const char *)a1;
          v70 = 2112;
          v71 = v38;
          _os_log_error_impl(&dword_19BD16000, v18, OS_LOG_TYPE_ERROR, "%@ Failed to find child SA for spi %@", buf, 0x16u);
        }
        v32 = v61;
        goto LABEL_43;
      }
      v43 = v41;
      v44 = *(_QWORD *)v65;
      v60 = v4;
LABEL_18:
      v45 = 0;
      while (1)
      {
        if (*(_QWORD *)v65 != v44)
          objc_enumerationMutation(v40);
        v46 = *(void **)(*((_QWORD *)&v64 + 1) + 8 * v45);
        v47 = v46 ? objc_getProperty(*(id *)(*((_QWORD *)&v64 + 1) + 8 * v45), v42, 192, 1) : 0;
        v48 = v47;
        if (objc_msgSend(v48, "isEqual:", v38))
          break;
        if (v46)
          v50 = objc_getProperty(v46, v49, 200, 1);
        else
          v50 = 0;
        v51 = v50;
        v52 = objc_msgSend(v51, "isEqual:", v38);

        if ((v52 & 1) != 0)
          goto LABEL_36;
        if (v43 == ++v45)
        {
          v53 = objc_msgSend(v40, "countByEnumeratingWithState:objects:count:", &v64, buf, 16);
          v43 = v53;
          v4 = v60;
          if (v53)
            goto LABEL_18;
          goto LABEL_32;
        }
      }

LABEL_36:
      v18 = v46;

      v4 = v60;
      if (!v46)
        goto LABEL_40;
      v12 = v62;
      v8 = v63;
      v55 = objc_getProperty(v18, v54, 200, 1);
      v56 = -[NEIKEv2Session receiveDeleteChildSPI:remoteSPI:packet:](a1, 0, v55, v60);

      ne_log_large_obj();
      v57 = objc_claimAutoreleasedReturnValue();
      v30 = v57;
      if ((v56 & 1) != 0)
      {
        v32 = v61;
        if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT))
        {
          v59 = objc_getProperty(v18, v58, 200, 1);
          *(_DWORD *)buf = 138412546;
          v69 = (const char *)a1;
          v70 = 2112;
          v71 = v59;
          _os_log_impl(&dword_19BD16000, v30, OS_LOG_TYPE_DEFAULT, "%@ Received Child SA Delete for remote SPI %@", buf, 0x16u);

        }
        goto LABEL_34;
      }
      v32 = v61;
      if (!os_log_type_enabled(v57, OS_LOG_TYPE_ERROR))
        goto LABEL_34;
    }
    *(_DWORD *)buf = 138412546;
    v69 = (const char *)a1;
    v70 = 2112;
    v71 = v18;
    _os_log_error_impl(&dword_19BD16000, v30, OS_LOG_TYPE_ERROR, "%@ Failed to process received Child SA Delete %@", buf, 0x16u);
    goto LABEL_34;
  }
LABEL_45:

}

- (void)initiateDeleteChildSA:(_QWORD *)a1
{
  const char *v3;
  id *v4;
  id Property;
  NSObject *v6;
  _DWORD *v7;
  id v8;
  NSObject *v9;
  id v10;
  const char *v11;
  SEL v12;
  id v13;
  const char *v14;
  void *v15;
  id v16;
  SEL v17;
  id v18;
  const char *v19;
  void *v20;
  id v21;
  NSObject *v22;
  _QWORD v23[5];
  id v24;
  id *v25;
  uint8_t buf[4];
  const char *v27;
  __int16 v28;
  id v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v4 = a2;
  if (a1)
    Property = objc_getProperty(a1, v3, 368, 1);
  else
    Property = 0;
  v6 = Property;
  dispatch_assert_queue_V2(v6);

  v7 = -[NEIKEv2Session copyChildWithID:](a1, (const char *)*((unsigned int *)v4 + 6));
  if (v7)
  {
    v8 = v7;
    if (*((_QWORD *)v7 + 4) == 3)
    {
      objc_msgSend(v4, "sendCallbackSuccess:session:", 1, a1);
    }
    else
    {
      ne_log_large_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412546;
        v27 = (const char *)a1;
        v28 = 2112;
        v29 = v8;
        _os_log_impl(&dword_19BD16000, v9, OS_LOG_TYPE_DEFAULT, "%@ initiate delete Child SA %@", buf, 0x16u);
      }

      v10 = v4[4];
      -[NEIKEv2ChildSA setState:error:]((uint64_t)v8, 3uLL, v10);

      -[NEIKEv2Session reportState](a1, v11);
      v13 = objc_getProperty(v8, v12, 56, 1);
      v15 = v13;
      if (v13)
        v13 = objc_getProperty(v13, v14, 80, 1);
      v16 = v13;
      v18 = objc_getProperty(v8, v17, 56, 1);
      v20 = v18;
      if (v18)
        v18 = objc_getProperty(v18, v19, 88, 1);
      v21 = v18;
      v23[0] = MEMORY[0x1E0C809B0];
      v23[1] = 3221225472;
      v23[2] = __50__NEIKEv2Session_Exchange__initiateDeleteChildSA___block_invoke;
      v23[3] = &unk_1E3CC10B8;
      v23[4] = a1;
      v8 = v8;
      v24 = v8;
      v25 = v4;
      -[NEIKEv2Session initiateDeleteChildSPI:remoteSPI:deleteCompletionCallback:](a1, v16, v21, v23);

    }
  }
  else
  {
    ne_log_obj();
    v22 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136315138;
      v27 = "-[NEIKEv2Session(Exchange) initiateDeleteChildSA:]";
      _os_log_fault_impl(&dword_19BD16000, v22, OS_LOG_TYPE_FAULT, "%s called with null childSA", buf, 0xCu);
    }

    objc_msgSend(v4, "sendCallbackSuccess:session:", 0, a1);
    v8 = 0;
  }

}

uint64_t __50__NEIKEv2Session_Exchange__initiateDeleteChildSA___block_invoke(uint64_t a1, uint64_t a2)
{
  -[NEIKEv2Session resetChild:](*(char **)(a1 + 32), *(void **)(a1 + 40));
  return objc_msgSend(*(id *)(a1 + 48), "sendCallbackSuccess:session:", a2, *(_QWORD *)(a1 + 32));
}

- (void)dealloc
{
  NSObject *v3;
  const char *v4;
  const char *v5;
  NEVirtualInterface_s *ipsecInterface;
  const char *v7;
  NSObject *Property;
  SEL v9;
  const char *v10;
  SEL v11;
  const char *v12;
  NSObject *v13;
  SEL v14;
  const char *v15;
  NSObject *v16;
  SEL v17;
  objc_super v18;
  uint8_t buf[4];
  NEIKEv2Session *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  ne_log_obj();
  v3 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 138412290;
    v20 = self;
    _os_log_impl(&dword_19BD16000, v3, OS_LOG_TYPE_INFO, "Dealloc %@", buf, 0xCu);
  }

  -[NEIKEv2Session uninstallAllChildSAs]((uint64_t)self);
  if (self)
  {
    if (objc_getProperty(self, v4, 176, 1))
    {
      if (self->_ownsDatabaseSession)
        objc_msgSend(objc_getProperty(self, v5, 176, 1), "invalidate");
      objc_setProperty_atomic(self, v5, 0, 176);
    }
    ipsecInterface = self->_ipsecInterface;
    if (ipsecInterface)
    {
      CFRelease(ipsecInterface);
      self->_ipsecInterface = 0;
    }
    if (objc_getProperty(self, v5, 264, 1))
    {
      Property = objc_getProperty(self, v7, 264, 1);
      dispatch_source_cancel(Property);
      objc_setProperty_atomic(self, v9, 0, 264);
    }
    if (objc_getProperty(self, v7, 272, 1))
    {
      objc_msgSend(objc_getProperty(self, v10, 272, 1), "invalidate");
      objc_setProperty_atomic(self, v11, 0, 272);
    }
    if (objc_getProperty(self, v10, 280, 1))
    {
      v13 = objc_getProperty(self, v12, 280, 1);
      dispatch_source_cancel(v13);
      objc_setProperty_atomic(self, v14, 0, 280);
    }
    if (objc_getProperty(self, v12, 296, 1))
    {
      v16 = objc_getProperty(self, v15, 296, 1);
      dispatch_source_cancel(v16);
      objc_setProperty_atomic(self, v17, 0, 296);
    }
  }
  v18.receiver = self;
  v18.super_class = (Class)NEIKEv2Session;
  -[NEIKEv2Session dealloc](&v18, sel_dealloc);
}

- (void)expireSA:(id)a3
{
  const char *v4;
  id v5;
  id Property;
  unsigned int *v7;
  NSObject *v8;
  const char *v9;
  id v10;
  int v11;
  NEIKEv2Session *v12;
  __int16 v13;
  id v14;
  __int16 v15;
  id v16;
  __int16 v17;
  unsigned int *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v5 = a3;
  if (self)
    Property = objc_getProperty(self, v4, 192, 1);
  else
    Property = 0;
  objc_msgSend(Property, "objectForKeyedSubscript:", v5);
  v7 = (unsigned int *)objc_claimAutoreleasedReturnValue();
  ne_log_large_obj();
  v8 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    if (self)
      v10 = objc_getProperty(self, v9, 176, 1);
    else
      v10 = 0;
    v11 = 138413058;
    v12 = self;
    v13 = 2112;
    v14 = v10;
    v15 = 2112;
    v16 = v5;
    v17 = 2112;
    v18 = v7;
    _os_log_impl(&dword_19BD16000, v8, OS_LOG_TYPE_DEFAULT, "%@ %@ expire SA %@ childSA %@", (uint8_t *)&v11, 0x2Au);
  }

  if (v7 && objc_msgSend(v5, "direction") == 2)
    -[NEIKEv2Session forceRekeyChild:](self, "forceRekeyChild:", v7[4]);
  objc_msgSend(v5, "invalidate");

}

- (void)deleteSA:(id)a3
{
  const char *v4;
  id v5;
  id Property;
  unsigned int *v7;
  NSObject *v8;
  const char *v9;
  id v10;
  const char *v11;
  id v12;
  int v13;
  NEIKEv2Session *v14;
  __int16 v15;
  id v16;
  __int16 v17;
  id v18;
  __int16 v19;
  unsigned int *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v5 = a3;
  if (self)
    Property = objc_getProperty(self, v4, 192, 1);
  else
    Property = 0;
  objc_msgSend(Property, "objectForKeyedSubscript:", v5);
  v7 = (unsigned int *)objc_claimAutoreleasedReturnValue();
  ne_log_large_obj();
  v8 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    if (self)
      v10 = objc_getProperty(self, v9, 176, 1);
    else
      v10 = 0;
    v13 = 138413058;
    v14 = self;
    v15 = 2112;
    v16 = v10;
    v17 = 2112;
    v18 = v5;
    v19 = 2112;
    v20 = v7;
    _os_log_impl(&dword_19BD16000, v8, OS_LOG_TYPE_DEFAULT, "%@ %@ delete SA %@ childSA %@", (uint8_t *)&v13, 0x2Au);
  }

  if (v7)
    -[NEIKEv2Session removeChild:](self, "removeChild:", v7[4]);
  if (self)
    v12 = objc_getProperty(self, v11, 192, 1);
  else
    v12 = 0;
  objc_msgSend(v12, "setObject:forKeyedSubscript:", 0, v5);
  objc_msgSend(v5, "invalidate");

}

- (void)idleTimeoutSA:(id)a3
{
  const char *v4;
  id v5;
  id Property;
  _DWORD *v7;
  NSObject *v8;
  const char *v9;
  id v10;
  unsigned int v11;
  void *Error;
  int v13;
  NEIKEv2Session *v14;
  __int16 v15;
  id v16;
  __int16 v17;
  id v18;
  __int16 v19;
  _DWORD *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v5 = a3;
  if (self)
    Property = objc_getProperty(self, v4, 192, 1);
  else
    Property = 0;
  objc_msgSend(Property, "objectForKeyedSubscript:", v5);
  v7 = (_DWORD *)objc_claimAutoreleasedReturnValue();
  ne_log_large_obj();
  v8 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    if (self)
      v10 = objc_getProperty(self, v9, 176, 1);
    else
      v10 = 0;
    v13 = 138413058;
    v14 = self;
    v15 = 2112;
    v16 = v10;
    v17 = 2112;
    v18 = v5;
    v19 = 2112;
    v20 = v7;
    _os_log_impl(&dword_19BD16000, v8, OS_LOG_TYPE_DEFAULT, "%@ %@ idle timeout SA %@ childSA %@", (uint8_t *)&v13, 0x2Au);
  }

  if (v7)
  {
    v11 = v7[4];
    Error = (void *)NEIKEv2CreateError(15);
    -[NEIKEv2Session removeChild:withReason:](self, v11, Error);

  }
  objc_msgSend(v5, "invalidate");

}

- (void)blackholeDetectedSA:(id)a3
{
  const char *v4;
  id v5;
  id Property;
  void *v7;
  NSObject *v8;
  const char *v9;
  id v10;
  int v11;
  NEIKEv2Session *v12;
  __int16 v13;
  id v14;
  __int16 v15;
  id v16;
  __int16 v17;
  void *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v5 = a3;
  if (self)
    Property = objc_getProperty(self, v4, 192, 1);
  else
    Property = 0;
  objc_msgSend(Property, "objectForKeyedSubscript:", v5);
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  ne_log_large_obj();
  v8 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    if (self)
      v10 = objc_getProperty(self, v9, 176, 1);
    else
      v10 = 0;
    v11 = 138413058;
    v12 = self;
    v13 = 2112;
    v14 = v10;
    v15 = 2112;
    v16 = v5;
    v17 = 2112;
    v18 = v7;
    _os_log_impl(&dword_19BD16000, v8, OS_LOG_TYPE_DEFAULT, "%@ %@ blackhole detected SA %@ childSA %@", (uint8_t *)&v11, 0x2Au);
  }

  if (v7)
    -[NEIKEv2Session sendKeepaliveWithRetries:retryIntervalInMilliseconds:callbackQueue:callback:](self, "sendKeepaliveWithRetries:retryIntervalInMilliseconds:callbackQueue:callback:", 4, 0, 0, 0);

}

- (void)reportError:(int)a3
{
  uint64_t v3;
  NEIKEv2Session *v4;
  BOOL isInvalidated;
  _BYTE *v6;
  NSObject *v7;
  const char *v8;
  id Property;
  id v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void *ErrorFailedToSend;
  const char *v19;
  _QWORD *v20;
  const char *v21;
  id v22;
  void *v23;
  void *v24;
  NSObject *v25;
  SEL v26;
  id v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  NSObject *v36;
  const char *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  id v44;
  SEL v45;
  id v46;
  unint64_t v47;
  void *ErrorInternal;
  uint8_t buf[4];
  NEIKEv2Session *v50;
  __int16 v51;
  int v52;
  uint64_t v53;

  v3 = *(_QWORD *)&a3;
  v4 = self;
  v53 = *MEMORY[0x1E0C80C00];
  if (self)
  {
    isInvalidated = self->_isInvalidated;
    if (!a3)
      return;
  }
  else
  {
    isInvalidated = 0;
    if (!a3)
      return;
  }
  if (isInvalidated)
    return;
  if (a3 == 49)
  {
    if (!self || (v6 = objc_getProperty(self, a2, 336, 1)) == 0 || (v6[11] & 1) == 0)
    {
      ne_log_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138412546;
        v50 = v4;
        v51 = 1024;
        v52 = 49;
        _os_log_error_impl(&dword_19BD16000, v7, OS_LOG_TYPE_ERROR, "%@ Reporting transport error %d", buf, 0x12u);
      }

      if (v4)
        Property = objc_getProperty(v4, v8, 336, 1);
      else
        Property = 0;
      v10 = Property;
      ErrorFailedToSend = (void *)NEIKEv2CreateErrorFailedToSend(CFSTR("Transport error %d"), v11, v12, v13, v14, v15, v16, v17, 49);
      -[NEIKEv2IKESA setState:error:]((uint64_t)v10, 3uLL, ErrorFailedToSend);

      -[NEIKEv2Session reportState](v4, v19);
      return;
    }
  }
  else if (!self)
  {
    goto LABEL_21;
  }
  v20 = objc_getProperty(v4, a2, 336, 1);
  if (!v20)
    goto LABEL_21;
  if (v20[6] != 2)
    goto LABEL_21;
  if (v4->_lastRequestMessageID == -1)
    goto LABEL_21;
  v22 = objc_getProperty(v4, v21, 240, 1);
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v4->_lastRequestMessageID);
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v22, "objectForKeyedSubscript:", v23);
  v24 = (void *)objc_claimAutoreleasedReturnValue();

  if (!v24)
  {
LABEL_21:
    ne_log_obj();
    v36 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412546;
      v50 = v4;
      v51 = 1024;
      v52 = v3;
      _os_log_error_impl(&dword_19BD16000, v36, OS_LOG_TYPE_ERROR, "%@ Reporting transport error %d", buf, 0x12u);
    }

    if (v4)
    {
      v44 = objc_getProperty(v4, v37, 336, 1);
      v46 = objc_getProperty(v4, v45, 336, 1);
      v4 = (NEIKEv2Session *)v46;
      if (v46)
      {
        v47 = *((_QWORD *)v46 + 6);
LABEL_26:
        ErrorInternal = (void *)NEIKEv2CreateErrorInternal(CFSTR("Transport error %d"), (uint64_t)v37, v38, v39, v40, v41, v42, v43, v3);
        -[NEIKEv2IKESA setState:error:]((uint64_t)v44, v47, ErrorInternal);

        return;
      }
    }
    else
    {
      v44 = 0;
    }
    v47 = 0;
    goto LABEL_26;
  }
  ne_log_obj();
  v25 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 138412546;
    v50 = v4;
    v51 = 1024;
    v52 = v3;
    _os_log_error_impl(&dword_19BD16000, v25, OS_LOG_TYPE_ERROR, "%@ Reporting transport error %d while connected", buf, 0x12u);
  }

  v27 = objc_getProperty(v4, v26, 336, 1);
  v35 = (void *)NEIKEv2CreateErrorInternal(CFSTR("Transport error %d"), v28, v29, v30, v31, v32, v33, v34, v3);
  -[NEIKEv2IKESA setState:error:]((uint64_t)v27, 2uLL, v35);

}

- (NSString)description
{
  NEIKEv2Session *v2;
  const char *v3;
  __CFString *v4;
  _BYTE *Property;
  __CFString *v6;
  id v7;
  unint64_t uniqueIndex;
  const __CFString *v9;
  const __CFString *v10;
  void *v11;

  v2 = self;
  if (self)
    self = (NEIKEv2Session *)objc_getProperty(self, a2, 336, 1);
  -[NEIKEv2IKESA initiatorSPI](self, a2);
  v4 = (__CFString *)objc_claimAutoreleasedReturnValue();
  if (v2)
    Property = objc_getProperty(v2, v3, 336, 1);
  else
    Property = 0;
  -[NEIKEv2IKESA responderSPI](Property, v3);
  v6 = (__CFString *)objc_claimAutoreleasedReturnValue();
  v7 = objc_alloc(MEMORY[0x1E0CB3940]);
  if (v2)
    uniqueIndex = v2->_uniqueIndex;
  else
    uniqueIndex = 0;
  v9 = CFSTR("0000000000000000");
  if (v4)
    v10 = v4;
  else
    v10 = CFSTR("0000000000000000");
  if (v6)
    v9 = v6;
  v11 = (void *)objc_msgSend(v7, "initWithFormat:", CFSTR("IKEv2Session[%llu, %@-%@]"), uniqueIndex, v10, v9);

  return (NSString *)v11;
}

- (NEIKEv2Session)initWithIKEConfig:(id)a3 firstChildConfig:(id)a4 sessionConfig:(id)a5 queue:(id)a6 ipsecInterface:(NEVirtualInterface_s *)a7 ikeSocketHandler:(id)a8 saSession:(id)a9 packetDelegate:(id)a10
{
  id v16;
  id v17;
  id v18;
  id v19;
  id v20;
  id v21;
  id v22;
  void *v23;
  NEIKEv2Session *v24;
  NSObject *v26;
  const char *v27;
  uint8_t buf[4];
  const char *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v16 = a3;
  v17 = a4;
  v18 = a5;
  v19 = a6;
  v20 = a8;
  v21 = a9;
  v22 = a10;
  v23 = v22;
  if (!v16)
  {
    ne_log_obj();
    v26 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136315138;
      v29 = "-[NEIKEv2Session initWithIKEConfig:firstChildConfig:sessionConfig:queue:ipsecInterface:ikeSocketHandler:saSe"
            "ssion:packetDelegate:]";
      v27 = "%s called with null ikeConfig";
      goto LABEL_13;
    }
LABEL_11:

    v24 = 0;
    goto LABEL_5;
  }
  if (!v21)
  {
    ne_log_obj();
    v26 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136315138;
      v29 = "-[NEIKEv2Session initWithIKEConfig:firstChildConfig:sessionConfig:queue:ipsecInterface:ikeSocketHandler:saSe"
            "ssion:packetDelegate:]";
      v27 = "%s called with null saSession";
      goto LABEL_13;
    }
    goto LABEL_11;
  }
  if (!v19)
  {
    ne_log_obj();
    v26 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v26, OS_LOG_TYPE_FAULT))
      goto LABEL_11;
    *(_DWORD *)buf = 136315138;
    v29 = "-[NEIKEv2Session initWithIKEConfig:firstChildConfig:sessionConfig:queue:ipsecInterface:ikeSocketHandler:saSess"
          "ion:packetDelegate:]";
    v27 = "%s called with null queue";
LABEL_13:
    _os_log_fault_impl(&dword_19BD16000, v26, OS_LOG_TYPE_FAULT, v27, buf, 0xCu);
    goto LABEL_11;
  }
  self = -[NEIKEv2Session initWithIKEConfig:firstChildConfig:sessionConfig:queue:ipsecInterface:ikeSocketHandler:saSession:shouldOwnSASession:packetDelegate:transport:configurationDelegate:](&self->super, v16, v17, v18, v19, (id *)a7, v20, v21, 0, v22, 0, 0);
  v24 = self;
LABEL_5:

  return v24;
}

- (NEIKEv2Session)initWithIKEConfig:(id)a3 firstChildConfig:(id)a4 sessionConfig:(id)a5 queue:(id)a6 ipsecInterface:(NEVirtualInterface_s *)a7 ikeSocketHandler:(id)a8 kernelSASessionName:(id)a9 packetDelegate:(id)a10
{
  id v16;
  id v17;
  id v18;
  id v19;
  id v20;
  id v21;
  id v22;
  NEIPSecSAKernelSession *v23;
  NEIKEv2Session *v24;
  NSObject *v26;
  const char *v27;
  uint8_t buf[4];
  const char *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v16 = a3;
  v17 = a4;
  v18 = a5;
  v19 = a6;
  v20 = a8;
  v21 = a9;
  v22 = a10;
  if (!v16)
  {
    ne_log_obj();
    v26 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136315138;
      v29 = "-[NEIKEv2Session initWithIKEConfig:firstChildConfig:sessionConfig:queue:ipsecInterface:ikeSocketHandler:kern"
            "elSASessionName:packetDelegate:]";
      v27 = "%s called with null ikeConfig";
      goto LABEL_13;
    }
LABEL_11:

    v24 = 0;
    goto LABEL_5;
  }
  if (!v21)
  {
    ne_log_obj();
    v26 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136315138;
      v29 = "-[NEIKEv2Session initWithIKEConfig:firstChildConfig:sessionConfig:queue:ipsecInterface:ikeSocketHandler:kern"
            "elSASessionName:packetDelegate:]";
      v27 = "%s called with null kernelSASessionName";
      goto LABEL_13;
    }
    goto LABEL_11;
  }
  if (!v19)
  {
    ne_log_obj();
    v26 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v26, OS_LOG_TYPE_FAULT))
      goto LABEL_11;
    *(_DWORD *)buf = 136315138;
    v29 = "-[NEIKEv2Session initWithIKEConfig:firstChildConfig:sessionConfig:queue:ipsecInterface:ikeSocketHandler:kernel"
          "SASessionName:packetDelegate:]";
    v27 = "%s called with null queue";
LABEL_13:
    _os_log_fault_impl(&dword_19BD16000, v26, OS_LOG_TYPE_FAULT, v27, buf, 0xCu);
    goto LABEL_11;
  }
  v23 = -[NEIPSecSAKernelSession initWithName:delegate:]([NEIPSecSAKernelSession alloc], "initWithName:delegate:", v21, 0);
  self = -[NEIKEv2Session initWithIKEConfig:firstChildConfig:sessionConfig:queue:ipsecInterface:ikeSocketHandler:saSession:shouldOwnSASession:packetDelegate:transport:configurationDelegate:](&self->super, v16, v17, v18, v19, (id *)a7, v20, v23, 1, v22, 0, 0);

  v24 = self;
LABEL_5:

  return v24;
}

- (void)connect
{
  NEIKEv2Session *v2;
  _QWORD block[5];

  v2 = self;
  if (self)
    self = (NEIKEv2Session *)objc_getProperty(self, a2, 368, 1);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = __25__NEIKEv2Session_connect__block_invoke;
  block[3] = &unk_1E3CC41F0;
  block[4] = v2;
  dispatch_async(&self->super, block);
}

- (void)disconnect
{
  NEIKEv2Session *v2;
  _QWORD block[5];

  v2 = self;
  if (self)
    self = (NEIKEv2Session *)objc_getProperty(self, a2, 368, 1);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = __28__NEIKEv2Session_disconnect__block_invoke;
  block[3] = &unk_1E3CC41F0;
  block[4] = v2;
  dispatch_async(&self->super, block);
}

- (void)forceRekeyIKE
{
  const char *v3;
  NEIKEv2RekeyIKEContext *v4;
  NSObject *Property;
  NEIKEv2RekeyIKEContext *v6;
  _QWORD v7[5];
  NEIKEv2RekeyIKEContext *v8;

  v4 = -[NEIKEv2RequestContext initWithRequestType:]([NEIKEv2RekeyIKEContext alloc], "initWithRequestType:", 1);
  if (self)
    Property = objc_getProperty(self, v3, 368, 1);
  else
    Property = 0;
  v7[0] = MEMORY[0x1E0C809B0];
  v7[1] = 3221225472;
  v7[2] = __31__NEIKEv2Session_forceRekeyIKE__block_invoke;
  v7[3] = &unk_1E3CC2F98;
  v7[4] = self;
  v8 = v4;
  v6 = v4;
  dispatch_async(Property, v7);

}

- (void)forceRekeyChild:(unsigned int)a3
{
  NEIKEv2RekeyChildContext *v5;
  const char *v6;
  NEIKEv2Session *v7;
  NEIKEv2Session *v8;
  NSObject *Property;
  NEIKEv2Session *v10;
  _QWORD v11[5];
  NEIKEv2Session *v12;
  objc_super v13;

  v5 = [NEIKEv2RekeyChildContext alloc];
  if (v5)
  {
    v13.receiver = v5;
    v13.super_class = (Class)NEIKEv2RekeyChildContext;
    v7 = -[NEIKEv2Session initWithRequestType:](&v13, sel_initWithRequestType_, 2);
    v8 = v7;
    if (v7)
      v7->_previousMOBIKEMessageID = a3;
    if (self)
      goto LABEL_5;
LABEL_8:
    Property = 0;
    goto LABEL_6;
  }
  v8 = 0;
  if (!self)
    goto LABEL_8;
LABEL_5:
  Property = objc_getProperty(self, v6, 368, 1);
LABEL_6:
  v11[0] = MEMORY[0x1E0C809B0];
  v11[1] = 3221225472;
  v11[2] = __34__NEIKEv2Session_forceRekeyChild___block_invoke;
  v11[3] = &unk_1E3CC2F98;
  v11[4] = self;
  v12 = v8;
  v10 = v8;
  dispatch_async(Property, v11);

}

- (void)removeChild:(unsigned int)a3
{
  -[NEIKEv2Session removeChild:withReason:](self, a3, 0);
}

- (BOOL)updateConfiguration:(id)a3
{
  const char *v4;
  id v5;
  NSObject *Property;
  NSObject *v8;
  _QWORD v9[5];
  id v10;
  uint8_t buf[4];
  const char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v5 = a3;
  if (v5)
  {
    if (self)
      Property = objc_getProperty(self, v4, 368, 1);
    else
      Property = 0;
    v9[0] = MEMORY[0x1E0C809B0];
    v9[1] = 3221225472;
    v9[2] = __38__NEIKEv2Session_updateConfiguration___block_invoke;
    v9[3] = &unk_1E3CC2F98;
    v9[4] = self;
    v10 = v5;
    dispatch_async(Property, v9);

  }
  else
  {
    ne_log_obj();
    v8 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136315138;
      v12 = "-[NEIKEv2Session updateConfiguration:]";
      _os_log_fault_impl(&dword_19BD16000, v8, OS_LOG_TYPE_FAULT, "%s called with null sessionConfig", buf, 0xCu);
    }

  }
  return v5 != 0;
}

- (void)sendKeepaliveWithRetries:(unsigned int)a3 retryIntervalInMilliseconds:(unint64_t)a4 callbackQueue:(id)a5 callback:(id)a6
{
  id v10;
  id v11;
  id *v12;
  const char *v13;
  NSObject *Property;
  id *v15;
  _QWORD v16[5];
  id *v17;

  v10 = a6;
  v11 = a5;
  v12 = -[NEIKEv2InformationalContext initWithPrivateNotifies:maxRetries:retryIntervalMilliseconds:callbackQueue:callback:]((id *)[NEIKEv2InformationalContext alloc], 0, a3, (void *)a4, v11, v10);

  if (v12)
    *((_BYTE *)v12 + 9) = 1;
  if (self)
    Property = objc_getProperty(self, v13, 368, 1);
  else
    Property = 0;
  v16[0] = MEMORY[0x1E0C809B0];
  v16[1] = 3221225472;
  v16[2] = __94__NEIKEv2Session_sendKeepaliveWithRetries_retryIntervalInMilliseconds_callbackQueue_callback___block_invoke;
  v16[3] = &unk_1E3CC2F98;
  v16[4] = self;
  v17 = v12;
  v15 = v12;
  dispatch_async(Property, v16);

}

- (void)sendPrivateNotifies:(id)a3 maxRetries:(unsigned int)a4 retryIntervalInMilliseconds:(unint64_t)a5 callbackQueue:(id)a6 callback:(id)a7
{
  objc_class *v12;
  id v13;
  id v14;
  id v15;
  void *v16;
  id *v17;
  const char *v18;
  NSObject *Property;
  id *v20;
  _QWORD v21[5];
  id *v22;

  v12 = (objc_class *)MEMORY[0x1E0C99D20];
  v13 = a7;
  v14 = a6;
  v15 = a3;
  v16 = (void *)objc_msgSend([v12 alloc], "initWithArray:copyItems:", v15, 1);

  v17 = -[NEIKEv2InformationalContext initWithPrivateNotifies:maxRetries:retryIntervalMilliseconds:callbackQueue:callback:]((id *)[NEIKEv2InformationalContext alloc], v16, a4, (void *)a5, v14, v13);
  if (self)
    Property = objc_getProperty(self, v18, 368, 1);
  else
    Property = 0;
  v21[0] = MEMORY[0x1E0C809B0];
  v21[1] = 3221225472;
  v21[2] = __100__NEIKEv2Session_sendPrivateNotifies_maxRetries_retryIntervalInMilliseconds_callbackQueue_callback___block_invoke;
  v21[3] = &unk_1E3CC2F98;
  v21[4] = self;
  v22 = v17;
  v20 = v17;
  dispatch_async(Property, v21);

}

- (void)sendMOBIKEWithRetries:(unsigned int)a3 retryInterval:(unint64_t)a4 interfaceName:(id)a5 invalidateTransport:(BOOL)a6 resetEndpoint:(id)a7 callbackQueue:(id)a8 callback:(id)a9
{
  id v15;
  id v16;
  id v17;
  id v18;
  const char *v19;
  id *v20;
  NSObject *Property;
  NSObject *v22;
  _QWORD v23[5];
  id *v24;
  uint8_t buf[4];
  const char *v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v15 = a5;
  v16 = a7;
  v17 = a8;
  v18 = a9;
  if (v15)
  {
    v20 = -[NEIKEv2MOBIKEContext initWithMOBIKEInterface:mobikeEndpoint:invalidateTransport:maxRetries:retryIntervalMilliseconds:callbackQueue:callback:]((id *)[NEIKEv2MOBIKEContext alloc], v15, v16, a6, a3, (void *)a4, v17, v18);
    if (self)
      Property = objc_getProperty(self, v19, 368, 1);
    else
      Property = 0;
    v23[0] = MEMORY[0x1E0C809B0];
    v23[1] = 3221225472;
    v23[2] = __125__NEIKEv2Session_sendMOBIKEWithRetries_retryInterval_interfaceName_invalidateTransport_resetEndpoint_callbackQueue_callback___block_invoke;
    v23[3] = &unk_1E3CC2F98;
    v23[4] = self;
    v24 = v20;
    v22 = v20;
    dispatch_async(Property, v23);

  }
  else
  {
    ne_log_obj();
    v22 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136315138;
      v26 = "-[NEIKEv2Session sendMOBIKEWithRetries:retryInterval:interfaceName:invalidateTransport:resetEndpoint:callbac"
            "kQueue:callback:]";
      _os_log_fault_impl(&dword_19BD16000, v22, OS_LOG_TYPE_FAULT, "%s called with null interfaceName", buf, 0xCu);
    }
  }

}

- (unsigned)addChild:(id)a3
{
  id v4;
  unsigned int v5;
  unsigned int v6;
  const char *v7;
  NEIKEv2ChildSA *v8;
  id Property;
  id v10;
  NEIKEv2NewChildContext *v11;
  id v12;
  id v13;
  const char *v14;
  NSObject *v15;
  NEIKEv2NewChildContext *v16;
  NSObject *v17;
  _QWORD block[5];
  id v20;
  NEIKEv2NewChildContext *v21;
  objc_super v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v4 = a3;
  if (v4)
  {
    objc_opt_self();
    do
      v5 = __ldxr((unsigned int *)&getNewChildSAID_nextChildSAID);
    while (__stxr(v5 + 1, (unsigned int *)&getNewChildSAID_nextChildSAID));
    v6 = v5;
    if (!v5)
    {
      do
        v6 = __ldxr((unsigned int *)&getNewChildSAID_nextChildSAID);
      while (__stxr(v6 + 1, (unsigned int *)&getNewChildSAID_nextChildSAID));
    }
    v8 = [NEIKEv2ChildSA alloc];
    if (self)
      Property = objc_getProperty(self, v7, 336, 1);
    else
      Property = 0;
    v10 = -[NEIKEv2ChildSA initWithConfiguration:childID:ikeSA:](&v8->super, v4, v6, Property);
    v11 = [NEIKEv2NewChildContext alloc];
    v12 = v10;
    if (v11)
    {
      v22.receiver = v11;
      v22.super_class = (Class)NEIKEv2NewChildContext;
      v13 = -[NEIKEv2Session initWithRequestType:](&v22, sel_initWithRequestType_, 5);
      v11 = (NEIKEv2NewChildContext *)v13;
      if (v13)
        objc_storeStrong((id *)v13 + 3, v10);
    }

    if (self)
      v15 = objc_getProperty(self, v14, 368, 1);
    else
      v15 = 0;
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = __27__NEIKEv2Session_addChild___block_invoke;
    block[3] = &unk_1E3CC36A0;
    block[4] = self;
    v20 = v12;
    v21 = v11;
    v16 = v11;
    v17 = v12;
    dispatch_async(v15, block);

  }
  else
  {
    ne_log_obj();
    v17 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_FAULT))
    {
      LODWORD(v22.receiver) = 136315138;
      *(id *)((char *)&v22.receiver + 4) = "-[NEIKEv2Session addChild:]";
      _os_log_fault_impl(&dword_19BD16000, v17, OS_LOG_TYPE_FAULT, "%s called with null configuration", (uint8_t *)&v22, 0xCu);
    }
    v6 = 0;
  }

  return v6;
}

- (BOOL)peerAuthenticated
{
  if (self)
  {
    self = (NEIKEv2Session *)objc_getProperty(self, a2, 336, 1);
    if (self)
      LOBYTE(self) = BYTE2(self->_lastRequestMessageID) & 1;
  }
  return (char)self;
}

- (BOOL)ppkAuthenticated
{
  if (self)
  {
    self = (NEIKEv2Session *)objc_getProperty(self, a2, 336, 1);
    if (self)
      LOBYTE(self) = HIBYTE(self->_lastRequestMessageID) & 1;
  }
  return (char)self;
}

- (void)receivePacket:(id)a3
{
  NEIKEv2Session *v3;
  NEIKEv2Session *v4;
  const char *v6;
  _BYTE *v7;
  NSObject *Property;
  const char *v9;
  ptrdiff_t v10;
  id v11;
  NSObject *v12;
  NSObject *v13;
  void *v14;
  id v15;
  const char *v16;
  const char *v17;
  const char *v18;
  void *v19;
  int v20;
  SEL v21;
  void *v22;
  SEL v23;
  id v24;
  const char *v25;
  id v26;
  void *v27;
  const char *v28;
  uint64_t v29;
  NEIKEv2Session *v30;
  const char *v31;
  const char *v32;
  id v33;
  const char *v34;
  id v35;
  char v36;
  id v37;
  const char *v38;
  id v39;
  NSObject *v40;
  int v41;
  int v42;
  char v43;
  id v44;
  void *v45;
  id v46;
  void *v47;
  void *v48;
  id v49;
  void *v50;
  id v51;
  void *v52;
  void *v53;
  id v54;
  void *v55;
  id v56;
  void *v57;
  void *v58;
  NSObject *v59;
  NSObject *v60;
  const char *v61;
  NSObject *v62;
  const char *v63;
  id v64;
  _QWORD *v65;
  const char *v66;
  const char *v67;
  _QWORD *v68;
  id v69;
  const char *v70;
  id v71;
  char v72;
  NSObject *v73;
  const char *v74;
  void *v75;
  SEL v76;
  id v77;
  const char *v78;
  SEL v79;
  id v80;
  int lastRequestMessageID;
  NSObject *v82;
  int v83;
  SEL v84;
  id v85;
  SEL v86;
  void (**v87)(id, id);
  SEL v88;
  const char *v89;
  const char *v90;
  id v91;
  NSObject *v92;
  _BYTE *v93;
  const char *v94;
  void *v95;
  int lastReceivedMessageID;
  int v97;
  id v98;
  void *v99;
  id v100;
  void *v101;
  SEL v102;
  id v103;
  SEL v104;
  id v105;
  SEL v106;
  id v107;
  id v108;
  const char *v109;
  id v110;
  const char *v111;
  const char *v112;
  id v113;
  const char *v114;
  NSObject *v115;
  id v116;
  SEL v117;
  id v118;
  const char *v119;
  id v120;
  char *v121;
  id v122;
  void *v123;
  id v124;
  void *v125;
  const char *v126;
  const char *v127;
  const char *v128;
  NSObject *v129;
  const char *v130;
  void *v131;
  const char *v132;
  id v133;
  id v134;
  const char *v135;
  id v136;
  id v137;
  NEIKEv2ChildSA *v138;
  SEL v139;
  id v140;
  const char *v141;
  unsigned int v142;
  int v143;
  id v144;
  id v145;
  const char *v146;
  id v147;
  const char *v148;
  id v149;
  const char *v150;
  _QWORD *v151;
  int v152;
  uint64_t v153;
  void *v154;
  void *v155;
  void *v156;
  NSObject *v157;
  unsigned int v158;
  uint8_t buf[4];
  NEIKEv2Session *v160;
  __int16 v161;
  _BYTE v162[10];
  _BYTE v163[10];
  const char *v164;
  __int16 v165;
  _BYTE v166[10];
  __int16 v167;
  void *v168;
  __int16 v169;
  id v170;
  uint64_t v171;

  v171 = *MEMORY[0x1E0C80C00];
  v7 = a3;
  if (self)
    Property = objc_getProperty(self, v6, 368, 1);
  else
    Property = 0;
  dispatch_assert_queue_V2(Property);
  if (v7)
  {
    v158 = *((_DWORD *)v7 + 6);
    if (self)
    {
      if ((v7[10] & 1) != 0)
        v10 = 240;
      else
        v10 = 232;
      v11 = objc_getProperty(self, v9, v10, 1);
    }
    else
    {
      v11 = 0;
    }
    v12 = v11;
    ne_log_large_obj();
    v13 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
    {
      v3 = self;
      v14 = (void *)objc_msgSend((id)objc_opt_class(), "copyTypeDescription");
      v15 = v14;
      v156 = v15;
      if ((v7[10] & 1) != 0)
        v16 = "Reply";
      else
        v16 = "Request";
      v4 = (NEIKEv2Session *)v158;
      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v158, v16);
      v155 = (void *)objc_claimAutoreleasedReturnValue();

      -[NSObject objectForKeyedSubscript:](v12, "objectForKeyedSubscript:", v155);
      v154 = (void *)objc_claimAutoreleasedReturnValue();
      if (v154)
        v18 = " retransmission";
      else
        v18 = "";
      v157 = v12;
      v19 = (void *)-[NEIKEv2Packet copyUnifiedData](v7, v17);
      v20 = objc_msgSend(v19, "length");
      objc_getProperty(v7, v21, 32, 1);
      v22 = (void *)objc_claimAutoreleasedReturnValue();
      v24 = objc_getProperty(v7, v23, 40, 1);
      *(_DWORD *)buf = 138414082;
      v160 = v3;
      v161 = 2112;
      *(_QWORD *)v162 = v14;
      self = v3;
      *(_WORD *)&v162[8] = 2080;
      *(_QWORD *)v163 = v153;
      *(_WORD *)&v163[8] = 2080;
      v164 = v18;
      v165 = 1024;
      *(_DWORD *)v166 = v20;
      *(_WORD *)&v166[4] = 1024;
      *(_DWORD *)&v166[6] = v158;
      v167 = 2112;
      v168 = v22;
      v169 = 2112;
      v170 = v24;
      _os_log_impl(&dword_19BD16000, v13, OS_LOG_TYPE_INFO, "%@ Receiving %@ %s%s, length %u, ID %u (%@->%@)", buf, 0x4Au);

      v12 = v157;
    }

    if ((v7[11] & 1) != 0)
    {
      v26 = objc_getProperty(v7, v25, 40, 1);
    }
    else
    {
      objc_getProperty(v7, v25, 32, 1);
      v26 = (id)objc_claimAutoreleasedReturnValue();
    }
    v27 = v26;
    v29 = objc_msgSend(v26, "value");
    if (!v29)
    {
      if (self)
      {
        v30 = (NEIKEv2Session *)objc_getProperty(self, v28, 336, 1);
        v3 = v30;
        if (v30)
          v30 = (NEIKEv2Session *)objc_getProperty(v30, v31, 80, 1);
      }
      else
      {
        v3 = 0;
        v30 = 0;
      }
      v4 = v30;
      if (-[NEIKEv2Session serverMode](v4, "serverMode"))
      {

        goto LABEL_31;
      }
    }
    if (self)
    {
      v33 = objc_getProperty(self, v28, 336, 1);
      if (v33)
        v33 = objc_getProperty(v33, v34, 32, 1);
    }
    else
    {
      v33 = 0;
    }
    v35 = v33;
    v36 = objc_msgSend(v35, "isEqual:", v27);

    if (v29)
    {
      if ((v36 & 1) != 0)
        goto LABEL_31;
    }
    else
    {

      if ((v36 & 1) != 0)
      {
LABEL_31:
        if ((v7[9] & 1) != 0)
        {
          if (self)
          {
            v37 = objc_getProperty(self, v32, 336, 1);
            if (v37)
              v37 = objc_getProperty(v37, v38, 96, 1);
          }
          else
          {
            v37 = 0;
          }
          v39 = v37;

          if (!v39)
          {
            ne_log_obj();
            v62 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 138412290;
              v160 = self;
              _os_log_error_impl(&dword_19BD16000, v62, OS_LOG_TYPE_ERROR, "%@ Ignoring fragment received before security established", buf, 0xCu);
            }
            goto LABEL_63;
          }
          ne_log_large_obj();
          v40 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v40, OS_LOG_TYPE_INFO))
          {
            v41 = *((_DWORD *)v7 + 4);
            v42 = *((_DWORD *)v7 + 5);
            *(_DWORD *)buf = 138413058;
            v160 = self;
            v161 = 1024;
            *(_DWORD *)v162 = v41;
            *(_WORD *)&v162[4] = 1024;
            *(_DWORD *)&v162[6] = v42;
            *(_WORD *)v163 = 2112;
            *(_QWORD *)&v163[2] = v7;
            _os_log_impl(&dword_19BD16000, v40, OS_LOG_TYPE_INFO, "%@ Received fragment %u/%u: %@", buf, 0x22u);
          }

        }
        v43 = v7[10];
        if ((v43 & 1) != 0)
        {
          if (self)
            v44 = objc_getProperty(self, v32, 240, 1);
          else
            v44 = 0;
          v45 = (void *)MEMORY[0x1E0CB37E8];
          v46 = v44;
          objc_msgSend(v45, "numberWithInt:", v158);
          v47 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v46, "objectForKeyedSubscript:", v47);
          v48 = (void *)objc_claimAutoreleasedReturnValue();

          if (!v48)
          {
            if ((v7[9] & 1) == 0)
            {
              if (self && objc_getProperty(self, v32, 336, 1))
              {
                v64 = objc_getProperty(self, v63, 336, 1);
                if (!-[NEIKEv2Packet processReceivedPacketForIKESA:](v7, v64))
                  goto LABEL_100;
                objc_opt_class();
                if ((objc_opt_isKindOfClass() & 1) != 0
                  && -[NEIKEv2Packet hasNotification:](v7, (const char *)0x4017))
                {
                  v65 = -[NEIKEv2Packet copyNotification:](v7, (const char *)0x4017);
                  v68 = -[NEIKEv2NotifyPayload copyServerRedirectNonce](v65, v66);
                  if (!v68)
                    goto LABEL_125;
                  v69 = objc_getProperty(self, v67, 336, 1);
                  if (v69)
                    v69 = objc_getProperty(v69, v70, 128, 1);
                  v71 = v69;
                  v72 = objc_msgSend(v68, "isEqualToData:", v71);

                  if ((v72 & 1) == 0)
                  {
LABEL_125:
                    ne_log_large_obj();
                    v129 = objc_claimAutoreleasedReturnValue();
                    if (os_log_type_enabled(v129, OS_LOG_TYPE_ERROR))
                    {
                      *(_DWORD *)buf = 138412546;
                      v160 = self;
                      v161 = 2112;
                      *(_QWORD *)v162 = v7;
                      _os_log_error_impl(&dword_19BD16000, v129, OS_LOG_TYPE_ERROR, "%@ Ignoring received packet (nonce check failed): %@", buf, 0x16u);
                    }

                    goto LABEL_100;
                  }

                }
              }
              ne_log_large_obj();
              v73 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v73, OS_LOG_TYPE_INFO))
              {
                *(_DWORD *)buf = 138412546;
                v160 = self;
                v161 = 2112;
                *(_QWORD *)v162 = v7;
                _os_log_impl(&dword_19BD16000, v73, OS_LOG_TYPE_INFO, "%@ Received response: %@", buf, 0x16u);
              }

              if (self)
              {
                if (!self->_lastRequestMessageID)
                {
                  v75 = (void *)-[NEIKEv2Packet copyUnifiedData](v7, v74);
                  v77 = objc_getProperty(self, v76, 336, 1);
                  if (v77)
                    objc_setProperty_atomic(v77, v78, v75, 320);

                }
                -[NEIKEv2Session setReceivedReply:messageID:](self, v7, v158);
                v80 = objc_getProperty(self, v79, 200, 1);
                if (v80)
                {
                  lastRequestMessageID = self->_lastRequestMessageID;

                  if (lastRequestMessageID == v158)
                  {
                    ne_log_obj();
                    v82 = objc_claimAutoreleasedReturnValue();
                    if (os_log_type_enabled(v82, OS_LOG_TYPE_INFO))
                    {
                      v83 = self->_lastRequestMessageID;
                      *(_DWORD *)buf = 138412546;
                      v160 = self;
                      v161 = 1024;
                      *(_DWORD *)v162 = v83;
                      _os_log_impl(&dword_19BD16000, v82, OS_LOG_TYPE_INFO, "%@ Processing response for message %u", buf, 0x12u);
                    }

                    v85 = objc_getProperty(self, v84, 360, 1);
                    -[NEIKEv2RTT updateRTT:responseMessageID:]((uint64_t)v85, self, v158);
                    v87 = (void (**)(id, id))objc_getProperty(self, v86, 200, 1);
                    objc_setProperty_atomic_copy(self, v88, 0, 200);
                    -[NEIKEv2Session cancelSendTimer](self, v89);
                    v87[2](v87, v7);

                  }
                }
              }
              else
              {

                -[NEIKEv2Session setReceivedReply:messageID:](0, v7, v158);
              }
              goto LABEL_100;
            }
            goto LABEL_99;
          }
          v43 = v7[10];
        }
        if ((v43 & 1) != 0)
        {
LABEL_49:
          if ((v43 & 1) == 0)
          {
            v54 = self ? objc_getProperty(self, v32, 224, 1) : 0;
            v55 = (void *)MEMORY[0x1E0CB37E8];
            v56 = v54;
            objc_msgSend(v55, "numberWithInt:", v158);
            v57 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v56, "objectForKeyedSubscript:", v57);
            v58 = (void *)objc_claimAutoreleasedReturnValue();

            if (v58)
            {
              if ((v7[9] & 1) == 0 || *((_DWORD *)v7 + 4) == 1)
              {
                ne_log_obj();
                v59 = objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v59, OS_LOG_TYPE_DEBUG))
                {
                  *(_DWORD *)buf = 138412546;
                  v160 = self;
                  v161 = 1024;
                  *(_DWORD *)v162 = v158;
                  _os_log_debug_impl(&dword_19BD16000, v59, OS_LOG_TYPE_DEBUG, "%@ Received duplicate for message %d, re-sending reply", buf, 0x12u);
                }

                -[NEIKEv2Session sendReplyForMessageID:](self, (const char *)v158);
              }
            }
          }
          goto LABEL_100;
        }
        if (self)
          v49 = objc_getProperty(self, v32, 232, 1);
        else
          v49 = 0;
        v50 = (void *)MEMORY[0x1E0CB37E8];
        v51 = v49;
        objc_msgSend(v50, "numberWithInt:", v158);
        v52 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v51, "objectForKeyedSubscript:", v52);
        v53 = (void *)objc_claimAutoreleasedReturnValue();

        if (v53)
        {
          v43 = v7[10];
          goto LABEL_49;
        }
        if ((v7[9] & 1) == 0)
        {
          if (self)
          {
            if (objc_getProperty(self, v32, 336, 1))
            {
              v91 = objc_getProperty(self, v90, 336, 1);
              if (!-[NEIKEv2Packet processReceivedPacketForIKESA:](v7, v91))
                goto LABEL_100;
            }
          }
          ne_log_large_obj();
          v92 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v92, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)buf = 138412546;
            v160 = self;
            v161 = 2112;
            *(_QWORD *)v162 = v7;
            _os_log_impl(&dword_19BD16000, v92, OS_LOG_TYPE_INFO, "%@ Received request: %@", buf, 0x16u);
          }

          v93 = v7;
          v95 = v93;
          if (self)
          {
            lastReceivedMessageID = self->_lastReceivedMessageID;
            if (lastReceivedMessageID < (int)v158)
            {
              lastReceivedMessageID = v158;
              self->_lastReceivedMessageID = v158;
            }
            v97 = lastReceivedMessageID - 4;
            if (lastReceivedMessageID < 4)
            {
              v122 = objc_getProperty(self, v94, 232, 1);
              v123 = (void *)MEMORY[0x1E0CB37E8];
              v124 = v122;
              objc_msgSend(v123, "numberWithInt:", v158);
              v125 = (void *)objc_claimAutoreleasedReturnValue();
              objc_msgSend(v124, "setObject:forKeyedSubscript:", v95, v125);

LABEL_116:
              if ((-[NEIKEv2Session fireWaitingRequestHandlerWithPacket:](self, v95) & 1) != 0)
                goto LABEL_100;
              objc_opt_class();
              if ((objc_opt_isKindOfClass() & 1) != 0)
              {
                v60 = v95;
                if (-[NEIKEv2CreateChildPacket isRekeyIKE](v60, v126))
                {
                  -[NEIKEv2Session receiveRekeyIKESA:](self, v60);
                }
                else
                {
                  if (-[NEIKEv2Packet hasNotification:](v60, (const char *)0x4009))
                  {
                    v131 = -[NEIKEv2Packet copyNotification:](v60, (const char *)0x4009);
                    v133 = v131;
                    if (v131)
                      v131 = objc_getProperty(v131, v132, 40, 1);
                    v134 = v131;
                    objc_opt_class();
                    if ((objc_opt_isKindOfClass() & 1) != 0)
                    {
                      if (v133)
                        v136 = objc_getProperty(v133, v135, 40, 1);
                      else
                        v136 = 0;
                      v137 = v136;
                    }
                    else
                    {
                      v137 = 0;
                    }

                    v145 = -[NEIKEv2Session copyChildWithSPI:](self, v137);
                    -[NEIKEv2Session receiveRekeyChildSA:packet:](self, v145, v60);

                  }
                  else
                  {
                    if (objc_getProperty(self, v130, 168, 1))
                    {
                      v138 = [NEIKEv2ChildSA alloc];
                      v140 = objc_getProperty(self, v139, 168, 1);
                      objc_opt_self();
                      do
                        v142 = __ldxr((unsigned int *)&getNewChildSAID_nextChildSAID);
                      while (__stxr(v142 + 1, (unsigned int *)&getNewChildSAID_nextChildSAID));
                      v143 = v142;
                      if (!v142)
                      {
                        do
                          v143 = __ldxr((unsigned int *)&getNewChildSAID_nextChildSAID);
                        while (__stxr(v143 + 1, (unsigned int *)&getNewChildSAID_nextChildSAID));
                      }
                      v144 = objc_getProperty(self, v141, 336, 1);
                      v133 = -[NEIKEv2ChildSA initWithConfiguration:childID:ikeSA:](&v138->super, v140, v143, v144);

                    }
                    else
                    {
                      v133 = 0;
                    }
                    -[NEIKEv2Session receiveNewChildSA:packet:](self, v133, v60);
                  }

                }
                goto LABEL_60;
              }
              objc_opt_class();
              if ((objc_opt_isKindOfClass() & 1) == 0)
              {
                objc_opt_class();
                if ((objc_opt_isKindOfClass() & 1) != 0)
                  -[NEIKEv2Session receiveConnection:](self, v95);
                goto LABEL_100;
              }
              v60 = v95;
              if (-[NEIKEv2InformationalPacket isDeleteIKE](v60, v127))
              {
                -[NEIKEv2Session receiveDeleteIKESA:](self, v60);
              }
              else if (-[NEIKEv2InformationalPacket isDeleteChild](v60, v128))
              {
                -[NEIKEv2Session receiveDeleteChildSA:](self, v60);
              }
              else
              {
                if (!-[NEIKEv2InformationalPacket isMOBIKE](v60))
                {
                  v147 = objc_getProperty(self, v146, 336, 1);
                  if (v147)
                    v147 = objc_getProperty(v147, v148, 80, 1);
                  v149 = v147;
                  if (objc_msgSend(v149, "allowRedirect")
                    && (v151 = objc_getProperty(self, v150, 336, 1)) != 0
                    && v151[6] == 2)
                  {
                    v152 = -[NEIKEv2Packet hasNotification:](v60, (const char *)0x4017);

                    if (v152)
                    {
                      -[NEIKEv2Session receiveRedirect:](self, v60);
                      goto LABEL_60;
                    }
                  }
                  else
                  {

                  }
                  -[NEIKEv2Session receiveInformational:](self, v60);
                  goto LABEL_60;
                }
                -[NEIKEv2Session receiveMOBIKE:](self, v60);
              }
LABEL_60:

LABEL_100:
              goto LABEL_101;
            }
            if (v97 < (int)v158)
            {
              v98 = objc_getProperty(self, v94, 232, 1);
              v99 = (void *)MEMORY[0x1E0CB37E8];
              v100 = v98;
              objc_msgSend(v99, "numberWithInt:", v158);
              v101 = (void *)objc_claimAutoreleasedReturnValue();
              objc_msgSend(v100, "setObject:forKeyedSubscript:", v95, v101);

              v103 = objc_getProperty(self, v102, 232, 1);
              +[NEIKEv2Session removeItemsFromDictionary:lowerEdge:]((uint64_t)NEIKEv2Session, v103, v97);
              v105 = objc_getProperty(self, v104, 224, 1);
              +[NEIKEv2Session removeItemsFromDictionary:lowerEdge:]((uint64_t)NEIKEv2Session, v105, v97);
              v107 = objc_getProperty(self, v106, 248, 1);
              +[NEIKEv2Session removeItemsFromDictionary:lowerEdge:]((uint64_t)NEIKEv2Session, v107, v97);
              goto LABEL_116;
            }
          }

          ne_log_obj();
          v62 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v62, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)buf = 138412290;
            v160 = self;
            _os_log_impl(&dword_19BD16000, v62, OS_LOG_TYPE_INFO, "%@ Discarding stale request", buf, 0xCu);
          }
LABEL_63:

          goto LABEL_100;
        }
LABEL_99:
        -[NEIKEv2Session processFragment:](self, v7);
        goto LABEL_100;
      }
    }
    ne_log_large_obj();
    v60 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
    {
      if (self)
      {
        v108 = objc_getProperty(self, v61, 336, 1);
        if (v108)
          v108 = objc_getProperty(v108, v109, 80, 1);
      }
      else
      {
        v108 = 0;
      }
      v110 = v108;
      if (objc_msgSend(v110, "serverMode"))
        v112 = "Responder";
      else
        v112 = "Initiator";
      if (self)
      {
        v113 = objc_getProperty(self, v111, 336, 1);
        if (v113)
          v113 = objc_getProperty(v113, v114, 32, 1);
        v115 = v12;
        v116 = v113;
        v118 = objc_getProperty(self, v117, 336, 1);
        if (v118)
          v118 = objc_getProperty(v118, v119, 40, 1);
        v120 = v116;
      }
      else
      {
        v115 = v12;
        v116 = 0;
        v120 = 0;
        v118 = 0;
      }
      v121 = (char *)v118;
      *(_DWORD *)buf = 138413314;
      v160 = self;
      v161 = 2080;
      *(_QWORD *)v162 = v112;
      *(_WORD *)&v162[8] = 2112;
      *(_QWORD *)v163 = v120;
      *(_WORD *)&v163[8] = 2112;
      v164 = v121;
      v165 = 2112;
      *(_QWORD *)v166 = v7;
      _os_log_error_impl(&dword_19BD16000, v60, OS_LOG_TYPE_ERROR, "%@ %s ignoring received packet: (Local %@, Remote %@): %@", buf, 0x34u);

      v12 = v115;
    }
    goto LABEL_60;
  }
  ne_log_obj();
  v12 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)buf = 136315138;
    v160 = (NEIKEv2Session *)"-[NEIKEv2Session receivePacket:]";
    _os_log_fault_impl(&dword_19BD16000, v12, OS_LOG_TYPE_FAULT, "%s called with null packet", buf, 0xCu);
  }
LABEL_101:

}

- (void)invalidateWithCompletionHandler:(BOOL)a3 completionHandler:(id)a4
{
  id v6;
  NSObject *v7;
  const char *v8;
  NSObject *Property;
  id v10;
  _QWORD block[5];
  id v12;
  BOOL v13;
  uint8_t buf[4];
  NEIKEv2Session *v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v6 = a4;
  ne_log_obj();
  v7 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    v15 = self;
    _os_log_impl(&dword_19BD16000, v7, OS_LOG_TYPE_DEFAULT, "Invalidating %@", buf, 0xCu);
  }

  if (self)
  {
    self->_isInvalidated = 1;
    Property = objc_getProperty(self, v8, 368, 1);
  }
  else
  {
    Property = 0;
  }
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = __68__NEIKEv2Session_invalidateWithCompletionHandler_completionHandler___block_invoke;
  block[3] = &unk_1E3CC2F48;
  v13 = a3;
  block[4] = self;
  v12 = v6;
  v10 = v6;
  dispatch_async(Property, block);

}

- (void)invalidate
{
  -[NEIKEv2Session invalidateWithCompletionHandler:completionHandler:](self, "invalidateWithCompletionHandler:completionHandler:", 0, 0);
}

- (BOOL)checkSelectedIKEProposal:(id)a3
{
  const char *v4;
  id v5;
  id Property;
  const char *v7;
  id v8;
  void *v9;
  _QWORD *v10;
  const char *v11;
  id v12;
  id v13;
  char v14;
  const char *v15;
  unint64_t v16;
  void *v17;
  NSObject *v18;
  const char *v19;
  id v20;
  id v21;
  char v22;
  void *v23;
  const char *v24;
  id v25;
  id v26;
  char v27;
  void *v28;
  NSObject *v29;
  const char *v30;
  id v31;
  id v32;
  char v33;
  BOOL v34;
  const char *v35;
  uint8_t *v36;
  NSObject *v37;
  NSObject *v38;
  id v40;
  id v41;
  uint8_t v42[16];
  uint8_t v43[16];
  __int16 v44;
  uint8_t v45[16];
  uint8_t buf[2];

  v5 = a3;
  if (self)
  {
    Property = objc_getProperty(self, v4, 336, 1);
    if (Property)
      Property = objc_getProperty(Property, v7, 96, 1);
  }
  else
  {
    Property = 0;
  }
  v8 = Property;
  objc_msgSend(v5, "encryptionProtocols");
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v9, "firstObject");
  v10 = (_QWORD *)objc_claimAutoreleasedReturnValue();

  if (!v10)
    goto LABEL_10;
  if (v8)
    v12 = objc_getProperty(v8, v11, 88, 1);
  else
    v12 = 0;
  v13 = v12;
  v14 = objc_msgSend(v10, "isEqual:", v13);

  if ((v14 & 1) == 0)
  {
    ne_log_obj();
    v18 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      goto LABEL_30;
    *(_WORD *)buf = 0;
    v35 = "Incorrect encryption algorithm chosen";
    v36 = buf;
LABEL_26:
    _os_log_error_impl(&dword_19BD16000, v18, OS_LOG_TYPE_ERROR, v35, v36, 2u);
    goto LABEL_30;
  }
  v16 = v10[2];
  if (v16 > 0x1F || ((0xD01C0000 >> v16) & 1) == 0)
  {
LABEL_10:
    objc_msgSend(v5, "integrityProtocols");
    v17 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v17, "firstObject");
    v18 = objc_claimAutoreleasedReturnValue();

    if (!v18
      || (!v8 ? (v20 = 0) : (v20 = objc_getProperty(v8, v19, 96, 1)),
          v21 = v20,
          v22 = -[NSObject isEqual:](v18, "isEqual:", v21),
          v21,
          (v22 & 1) != 0))
    {

      goto LABEL_15;
    }
    ne_log_obj();
    v37 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v45 = 0;
      _os_log_error_impl(&dword_19BD16000, v37, OS_LOG_TYPE_ERROR, "Incorrect integrity algorithm chosen", v45, 2u);
    }

    goto LABEL_30;
  }
  if (v8)
    v40 = objc_getProperty(v8, v15, 96, 1);
  else
    v40 = 0;
  v41 = v40;

  if (!v41)
  {
LABEL_15:
    objc_msgSend(v5, "prfProtocols");
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v23, "firstObject");
    v18 = objc_claimAutoreleasedReturnValue();

    if (v18
      && (!v8 ? (v25 = 0) : (v25 = objc_getProperty(v8, v24, 104, 1)),
          v26 = v25,
          v27 = -[NSObject isEqual:](v18, "isEqual:", v26),
          v26,
          (v27 & 1) == 0))
    {
      ne_log_obj();
      v29 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)v43 = 0;
        _os_log_error_impl(&dword_19BD16000, v29, OS_LOG_TYPE_ERROR, "Incorrect PRF algorithm chosen", v43, 2u);
      }
    }
    else
    {
      objc_msgSend(v5, "kemProtocols");
      v28 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v28, "firstObject");
      v29 = objc_claimAutoreleasedReturnValue();

      if (!v29
        || (!v8 ? (v31 = 0) : (v31 = objc_getProperty(v8, v30, 112, 1)),
            v32 = v31,
            v33 = -[NSObject isEqual:](v29, "isEqual:", v32),
            v32,
            (v33 & 1) != 0))
      {
        v34 = 1;
LABEL_37:

        goto LABEL_38;
      }
      ne_log_obj();
      v38 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)v42 = 0;
        _os_log_error_impl(&dword_19BD16000, v38, OS_LOG_TYPE_ERROR, "Incorrect KE method chosen", v42, 2u);
      }

    }
    v34 = 0;
    goto LABEL_37;
  }
  ne_log_obj();
  v18 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    v44 = 0;
    v35 = "Integrity algorithm chosen with authenticated encryption";
    v36 = (uint8_t *)&v44;
    goto LABEL_26;
  }
LABEL_30:
  v34 = 0;
LABEL_38:

  return v34;
}

- (BOOL)checkSelectedChildSAProposal:(id)a3
{
  id v4;
  const char *v5;
  void *Property;
  const char *v7;
  void *v8;
  id v9;
  void *v10;
  _QWORD *v11;
  const char *v12;
  id v13;
  id v14;
  char v15;
  const char *v16;
  unint64_t v17;
  void *v18;
  NSObject *v19;
  const char *v20;
  id v21;
  id v22;
  char v23;
  void *v24;
  const char *v25;
  id v26;
  id v27;
  char v28;
  BOOL v29;
  const char *v30;
  uint8_t *v31;
  NSObject *v32;
  const char *v33;
  uint8_t *v34;
  id v36;
  id v37;
  __int16 v38;
  __int16 v39;
  __int16 v40;
  uint8_t buf[2];

  v4 = a3;
  -[NEIKEv2Session firstChildSA](self, v5);
  Property = (void *)objc_claimAutoreleasedReturnValue();
  v8 = Property;
  if (Property)
    Property = objc_getProperty(Property, v7, 56, 1);
  v9 = Property;

  objc_msgSend(v4, "encryptionProtocols");
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v10, "firstObject");
  v11 = (_QWORD *)objc_claimAutoreleasedReturnValue();

  if (!v11)
    goto LABEL_9;
  if (v9)
    v13 = objc_getProperty(v9, v12, 96, 1);
  else
    v13 = 0;
  v14 = v13;
  v15 = objc_msgSend(v11, "isEqual:", v14);

  if ((v15 & 1) == 0)
  {
    ne_log_obj();
    v19 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
LABEL_26:
      v29 = 0;
      goto LABEL_27;
    }
    *(_WORD *)buf = 0;
    v30 = "Incorrect encryption algorithm chosen";
    v31 = buf;
LABEL_21:
    _os_log_error_impl(&dword_19BD16000, v19, OS_LOG_TYPE_ERROR, v30, v31, 2u);
    goto LABEL_26;
  }
  v17 = v11[2];
  if (v17 <= 0x1F && ((0xD01C0000 >> v17) & 1) != 0)
  {
    if (v9)
      v36 = objc_getProperty(v9, v16, 104, 1);
    else
      v36 = 0;
    v37 = v36;

    if (!v37)
      goto LABEL_14;
    ne_log_obj();
    v19 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      goto LABEL_26;
    v39 = 0;
    v30 = "Integrity algorithm chosen with authenticated encryption";
    v31 = (uint8_t *)&v39;
    goto LABEL_21;
  }
LABEL_9:
  objc_msgSend(v4, "integrityProtocols");
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v18, "firstObject");
  v19 = objc_claimAutoreleasedReturnValue();

  if (v19)
  {
    v21 = v9 ? objc_getProperty(v9, v20, 104, 1) : 0;
    v22 = v21;
    v23 = -[NSObject isEqual:](v19, "isEqual:", v22);

    if ((v23 & 1) == 0)
    {
      ne_log_obj();
      v32 = objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
      {
LABEL_25:

        goto LABEL_26;
      }
      v40 = 0;
      v33 = "Incorrect integrity algorithm chosen";
      v34 = (uint8_t *)&v40;
LABEL_34:
      _os_log_error_impl(&dword_19BD16000, v32, OS_LOG_TYPE_ERROR, v33, v34, 2u);
      goto LABEL_25;
    }
  }

LABEL_14:
  objc_msgSend(v4, "kemProtocols");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v24, "firstObject");
  v19 = objc_claimAutoreleasedReturnValue();

  if (v19)
  {
    v26 = v9 ? objc_getProperty(v9, v25, 112, 1) : 0;
    v27 = v26;
    v28 = -[NSObject isEqual:](v19, "isEqual:", v27);

    if ((v28 & 1) == 0)
    {
      ne_log_obj();
      v32 = objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
        goto LABEL_25;
      v38 = 0;
      v33 = "Incorrect KE method chosen";
      v34 = (uint8_t *)&v38;
      goto LABEL_34;
    }
  }
  v29 = 1;
LABEL_27:

  return v29;
}

- (OS_dispatch_queue)clientQueue
{
  return (OS_dispatch_queue *)objc_getProperty(self, a2, 32, 1);
}

- (void)setClientQueue:(id)a3
{
  objc_setProperty_atomic(self, a2, a3, 32);
}

- (unint64_t)state
{
  return self->_state;
}

- (NEIKEv2ConfigurationMessage)assignedConfiguration
{
  return (NEIKEv2ConfigurationMessage *)objc_getProperty(self, a2, 48, 1);
}

- (NWEndpoint)localEndpoint
{
  return (NWEndpoint *)objc_getProperty(self, a2, 56, 1);
}

- (NWEndpoint)remoteEndpoint
{
  return (NWEndpoint *)objc_getProperty(self, a2, 64, 1);
}

- (NSString)ikeInterfaceName
{
  return (NSString *)objc_getProperty(self, a2, 72, 1);
}

- (void)clientCallback
{
  return self->_clientCallback;
}

- (void)setClientCallback:(void *)a3
{
  self->_clientCallback = a3;
}

- (void)clientCallbackInfo
{
  return self->_clientCallbackInfo;
}

- (void)setClientCallbackInfo:(void *)a3
{
  self->_clientCallbackInfo = a3;
}

- (id)stateUpdateBlock
{
  return objc_getProperty(self, a2, 96, 1);
}

- (void)setStateUpdateBlock:(id)a3
{
  objc_setProperty_atomic_copy(self, a2, a3, 96);
}

- (id)childStateUpdateBlock
{
  return objc_getProperty(self, a2, 104, 1);
}

- (void)setChildStateUpdateBlock:(id)a3
{
  objc_setProperty_atomic_copy(self, a2, a3, 104);
}

- (id)configurationUpdateBlock
{
  return objc_getProperty(self, a2, 112, 1);
}

- (void)setConfigurationUpdateBlock:(id)a3
{
  objc_setProperty_atomic_copy(self, a2, a3, 112);
}

- (id)trafficSelectorUpdateBlock
{
  return objc_getProperty(self, a2, 120, 1);
}

- (void)setTrafficSelectorUpdateBlock:(id)a3
{
  objc_setProperty_atomic_copy(self, a2, a3, 120);
}

- (id)additionalAddressesUpdateBlock
{
  return objc_getProperty(self, a2, 128, 1);
}

- (void)setAdditionalAddressesUpdateBlock:(id)a3
{
  objc_setProperty_atomic_copy(self, a2, a3, 128);
}

- (id)shortDPDEventBlock
{
  return objc_getProperty(self, a2, 136, 1);
}

- (void)setShortDPDEventBlock:(id)a3
{
  objc_setProperty_atomic_copy(self, a2, a3, 136);
}

- (id)redirectEventBlock
{
  return objc_getProperty(self, a2, 144, 1);
}

- (void)setRedirectEventBlock:(id)a3
{
  objc_setProperty_atomic_copy(self, a2, a3, 144);
}

- (id)privateNotifyStatusEvent
{
  return objc_getProperty(self, a2, 152, 1);
}

- (void)setPrivateNotifyStatusEvent:(id)a3
{
  objc_setProperty_atomic_copy(self, a2, a3, 152);
}

- (void).cxx_destruct
{
  objc_storeStrong((id *)&self->_pendingPrivateNotifies, 0);
  objc_storeStrong((id *)&self->_ikeConfig, 0);
  objc_storeStrong((id *)&self->_previousMOBIKERequest, 0);
  objc_storeStrong((id *)&self->_queue, 0);
  objc_storeStrong((id *)&self->_rttState, 0);
  objc_destroyWeak((id *)&self->_packetDelegate);
  objc_destroyWeak((id *)&self->_configurationDelegate);
  objc_storeStrong((id *)&self->_ikeSA, 0);
  objc_storeStrong((id *)&self->_pendingRequestContexts, 0);
  objc_storeStrong((id *)&self->_receiveTimer, 0);
  objc_storeStrong((id *)&self->_sendTimer, 0);
  objc_storeStrong((id *)&self->_childSAs, 0);
  objc_storeStrong((id *)&self->_dpdDispatchTimer, 0);
  objc_storeStrong((id *)&self->_dpdTimer, 0);
  objc_storeStrong((id *)&self->_ikeLifetimeTimer, 0);
  objc_storeStrong((id *)&self->_replyFragmentMaps, 0);
  objc_storeStrong((id *)&self->_requestFragmentMaps, 0);
  objc_storeStrong((id *)&self->_receivedReplies, 0);
  objc_storeStrong((id *)&self->_receivedRequests, 0);
  objc_storeStrong((id *)&self->_sentReplies, 0);
  objc_storeStrong((id *)&self->_sentRequests, 0);
  objc_storeStrong(&self->_waitingRequestHandler, 0);
  objc_storeStrong(&self->_lastRequestReplyHandler, 0);
  objc_storeStrong((id *)&self->_databaseSAs, 0);
  objc_storeStrong((id *)&self->_databaseLarvalSAs, 0);
  objc_storeStrong((id *)&self->_databaseSession, 0);
  objc_storeStrong((id *)&self->_listenChildSAUserConfig, 0);
  objc_storeStrong(&self->_ikeSocketHandler, 0);
  objc_storeStrong(&self->_privateNotifyStatusEvent, 0);
  objc_storeStrong(&self->_redirectEventBlock, 0);
  objc_storeStrong(&self->_shortDPDEventBlock, 0);
  objc_storeStrong(&self->_additionalAddressesUpdateBlock, 0);
  objc_storeStrong(&self->_trafficSelectorUpdateBlock, 0);
  objc_storeStrong(&self->_configurationUpdateBlock, 0);
  objc_storeStrong(&self->_childStateUpdateBlock, 0);
  objc_storeStrong(&self->_stateUpdateBlock, 0);
  objc_storeStrong((id *)&self->_ikeInterfaceName, 0);
  objc_storeStrong((id *)&self->_remoteEndpoint, 0);
  objc_storeStrong((id *)&self->_localEndpoint, 0);
  objc_storeStrong((id *)&self->_assignedConfiguration, 0);
  objc_storeStrong((id *)&self->_clientQueue, 0);
}

- (id)firstChildSA
{
  if (a1)
  {
    objc_msgSend(objc_getProperty(a1, a2, 288, 1), "firstObject");
    a1 = (void *)objc_claimAutoreleasedReturnValue();
  }
  return a1;
}

void __68__NEIKEv2Session_invalidateWithCompletionHandler_completionHandler___block_invoke(uint64_t a1, const char *a2)
{
  uint64_t v3;
  NSObject *Property;
  NSObject *v5;
  const char *v6;
  NEIKEv2DeleteIKEContext *v7;
  int v8;
  id v9;
  id v10;
  id *v11;
  const char *v12;
  _QWORD v13[4];
  id v14;
  id v15;
  uint8_t buf[4];
  uint64_t v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a1 + 48))
  {
    v3 = *(_QWORD *)(a1 + 32);
    if (v3)
    {
      Property = objc_getProperty(*(id *)(a1 + 32), a2, 368, 1);
      dispatch_assert_queue_V2(Property);
      if (objc_msgSend(*(id *)(v3 + 320), "count"))
      {
        ne_log_obj();
        v5 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 138412290;
          v17 = v3;
          _os_log_impl(&dword_19BD16000, v5, OS_LOG_TYPE_INFO, "%@ flushed all pending requests", buf, 0xCu);
        }

        objc_msgSend(*(id *)(v3 + 320), "removeAllObjects");
      }
    }
  }
  objc_initWeak((id *)buf, *(id *)(a1 + 32));
  v7 = [NEIKEv2DeleteIKEContext alloc];
  v8 = *(unsigned __int8 *)(a1 + 48);
  v9 = *(id *)(a1 + 32);
  if (v9)
    v9 = objc_getProperty(v9, v6, 368, 1);
  v10 = v9;
  v13[0] = MEMORY[0x1E0C809B0];
  v13[1] = 3221225472;
  v13[2] = __68__NEIKEv2Session_invalidateWithCompletionHandler_completionHandler___block_invoke_2;
  v13[3] = &unk_1E3CC18B0;
  objc_copyWeak(&v15, (id *)buf);
  v14 = *(id *)(a1 + 40);
  v11 = -[NEIKEv2DeleteIKEContext initDeleteIKEWithResponse:callbackQueue:callback:]((id *)&v7->super.super.isa, v8 == 0, v10, v13);

  -[NEIKEv2Session abort](*(_BYTE **)(a1 + 32), v12);
  -[NEIKEv2Session enqueuePendingRequestContext:](*(_QWORD **)(a1 + 32), v11);

  objc_destroyWeak(&v15);
  objc_destroyWeak((id *)buf);
}

void __68__NEIKEv2Session_invalidateWithCompletionHandler_completionHandler___block_invoke_2(uint64_t a1)
{
  const char *WeakRetained;
  char *v3;
  SEL v4;
  _QWORD *Property;
  const char *v6;
  id v7;
  const char *v8;
  char *v9;
  uint64_t v10;
  char *self;

  WeakRetained = (const char *)objc_loadWeakRetained((id *)(a1 + 40));
  v3 = (char *)WeakRetained;
  if (WeakRetained)
  {
    self = (char *)WeakRetained;
    -[NEIKEv2Session resetAll]((uint64_t)WeakRetained, WeakRetained);
    Property = objc_getProperty(self, v4, 336, 1);
    if (Property && Property[6] == 2)
    {
      v7 = objc_getProperty(self, v6, 336, 1);
      -[NEIKEv2IKESA setState:error:]((uint64_t)v7, 3uLL, 0);
    }
    if (objc_getProperty(self, v6, 176, 1))
    {
      v9 = self;
      if (self[9])
      {
        objc_msgSend(objc_getProperty(self, v8, 176, 1), "invalidate");
        v9 = self;
      }
      objc_setProperty_atomic(v9, v8, 0, 176);
    }
    v10 = *(_QWORD *)(a1 + 32);
    v3 = self;
    if (v10)
    {
      (*(void (**)(uint64_t, char *))(v10 + 16))(v10, self);
      v3 = self;
    }
  }

}

- (_BYTE)abort
{
  _BYTE *v2;
  NSObject *Property;
  NSObject *v4;
  const char *v5;
  const char *v6;
  int v7;
  _BYTE *v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (result)
  {
    v2 = result;
    Property = objc_getProperty(result, a2, 368, 1);
    dispatch_assert_queue_V2(Property);
    ne_log_obj();
    v4 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      v7 = 138412290;
      v8 = v2;
      _os_log_impl(&dword_19BD16000, v4, OS_LOG_TYPE_DEFAULT, "Aborting session %@", (uint8_t *)&v7, 0xCu);
    }

    v2[11] = 1;
    objc_msgSend(v2, "setConfigurationUpdateBlock:", 0);
    objc_msgSend(v2, "setTrafficSelectorUpdateBlock:", 0);
    -[NEIKEv2Session cancelSendTimer](v2, v5);
    -[NEIKEv2Session invalidateDPDTimer](v2, v6);
    return (_BYTE *)-[NEIKEv2Session fireWaitingRequestHandlerWithPacket:](v2, 0);
  }
  return result;
}

- (void)enqueuePendingRequestContext:(_QWORD *)a1
{
  const char *v3;
  id *v4;
  NSObject *Property;
  NSObject *v6;
  NSObject *v7;
  void *v8;
  id v9;
  void *v10;
  _BYTE *v11;
  id v12;
  void *v13;
  void *v14;
  void *v15;
  uint64_t v16;
  id v17;
  NSObject *v18;
  const char *v19;
  const char *v20;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  id *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v4 = a2;
  if (a1)
  {
    Property = objc_getProperty(a1, v3, 368, 1);
    dispatch_assert_queue_V2(Property);
    ne_log_obj();
    v6 = objc_claimAutoreleasedReturnValue();
    v7 = v6;
    if (v4)
    {
      if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 138412546;
        v22 = (const char *)a1;
        v23 = 2112;
        v24 = v4;
        _os_log_impl(&dword_19BD16000, v7, OS_LOG_TYPE_INFO, "%@ Enqueueing %@", buf, 0x16u);
      }

      v8 = (void *)a1[40];
      if (!v8)
      {
        v9 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
        v10 = (void *)a1[40];
        a1[40] = v9;

        v8 = (void *)a1[40];
      }
      objc_msgSend(v8, "addObject:", v4);
      v11 = a1;
      if (*((_BYTE *)v4 + 9) && objc_opt_class())
      {
        v12 = objc_alloc(MEMORY[0x1E0CB3940]);
        objc_msgSend(v11, "description");
        v13 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v4, "description");
        v14 = (void *)objc_claimAutoreleasedReturnValue();
        v15 = (void *)objc_msgSend(v12, "initWithFormat:", CFSTR("com.apple.networkextension[%@ %@]"), v13, v14);

        v16 = objc_msgSend(objc_alloc(MEMORY[0x1E0DB0F68]), "initWithIdentifier:", v15);
        v17 = v4[2];
        v4[2] = (id)v16;

        objc_msgSend(v4[2], "acquireWithTimeout:handler:", 0, 0.0);
        ne_log_obj();
        v18 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          v19 = (const char *)v4[2];
          *(_DWORD *)buf = 138412290;
          v22 = v19;
          _os_log_impl(&dword_19BD16000, v18, OS_LOG_TYPE_DEFAULT, "Took power assertion %@", buf, 0xCu);
        }

      }
      if (!v11[15])
        -[NEIKEv2Session sendPendingRequestContext]((uint64_t)v11, v20);
    }
    else
    {
      if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136315138;
        v22 = "-[NEIKEv2Session enqueuePendingRequestContext:]";
        _os_log_fault_impl(&dword_19BD16000, v7, OS_LOG_TYPE_FAULT, "%s called with null requestContext", buf, 0xCu);
      }

    }
  }

}

- (void)sendPendingRequestContext
{
  NSObject *Property;
  id v4;
  uint64_t v5;
  id *v6;
  NSObject *v7;
  const char *v8;
  int v9;
  _QWORD *v10;
  NSObject *v11;
  NSObject *v12;
  __CFString *v13;
  int v14;
  __CFString *v15;
  __int16 v16;
  uint64_t v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    Property = objc_getProperty((id)a1, a2, 368, 1);
    dispatch_assert_queue_V2(Property);
    if (!*(_BYTE *)(a1 + 15))
    {
      v4 = *(id *)(a1 + 320);
      objc_msgSend(v4, "firstObject");
      v5 = objc_claimAutoreleasedReturnValue();

      if (v5)
      {
        v6 = (id *)(a1 + 320);
        ne_log_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
        {
          v14 = 138412546;
          v15 = (__CFString *)a1;
          v16 = 2112;
          v17 = v5;
          _os_log_impl(&dword_19BD16000, v7, OS_LOG_TYPE_INFO, "%@ Dequeueing %@", (uint8_t *)&v14, 0x16u);
        }

        objc_msgSend(*v6, "removeObjectAtIndex:", 0);
        if (!objc_msgSend(*v6, "count"))
          objc_storeStrong((id *)(a1 + 320), 0);
        *(_BYTE *)(v5 + 8) = 1;
        *(_BYTE *)(a1 + 15) = 1;
        v9 = *(_DWORD *)(v5 + 12);
        if ((*(_BYTE *)(a1 + 11) & 1) != 0)
        {
          if (v9 == 7)
          {
LABEL_12:
            v10 = objc_getProperty((id)a1, v8, 336, 1);
            if (v10 && v10[6] == 2)
              -[NEIKEv2Session initiateDelete:]((_QWORD *)a1, (void *)v5);
            else
              objc_msgSend((id)v5, "sendCallbackSuccess:session:", 0, a1);
          }
          else
          {
            ne_log_obj();
            v11 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
            {
              v14 = 138412546;
              v15 = (__CFString *)a1;
              v16 = 2112;
              v17 = v5;
              _os_log_impl(&dword_19BD16000, v11, OS_LOG_TYPE_INFO, "%@ Session aborted, skip request %@", (uint8_t *)&v14, 0x16u);
            }

            objc_msgSend((id)v5, "sendCallbackSuccess:session:", 0, a1);
            -[NEIKEv2Session sendPendingRequestContext](a1);
          }
        }
        else
        {
          switch(v9)
          {
            case 1:
              -[NEIKEv2Session initiateRekeyIKESA:]((_BYTE *)a1, (void *)v5);
              break;
            case 2:
              -[NEIKEv2Session initiateRekeyChildSA:]((_BYTE *)a1, (void *)v5);
              break;
            case 3:
              -[NEIKEv2Session initiateInformational:]((_BYTE *)a1, (void *)v5);
              break;
            case 4:
              -[NEIKEv2Session initiateMOBIKE:]((_BYTE *)a1, (void *)v5);
              break;
            case 5:
              -[NEIKEv2Session initiateNewChildSA:]((_BYTE *)a1, (void *)v5);
              break;
            case 6:
              -[NEIKEv2Session initiateDeleteChildSA:]((_QWORD *)a1, (void *)v5);
              break;
            case 7:
              goto LABEL_12;
            default:
              ne_log_obj();
              v12 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
              {
                v13 = NEIKEv2RequestContextTypeString(*(_DWORD *)(v5 + 12));
                v14 = 138412290;
                v15 = v13;
                _os_log_fault_impl(&dword_19BD16000, v12, OS_LOG_TYPE_FAULT, "bad request type %@", (uint8_t *)&v14, 0xCu);

              }
              break;
          }
        }
      }

    }
  }
}

- (void)cancelSendTimer
{
  const char *v3;
  NSObject *Property;
  SEL v5;
  const char *v6;
  _QWORD *v7;
  const char *v8;
  SEL v9;
  void (**v10)(id, _QWORD);

  if (a1)
  {
    if (objc_getProperty(a1, a2, 296, 1))
    {
      Property = objc_getProperty(a1, v3, 296, 1);
      dispatch_source_cancel(Property);
      objc_setProperty_atomic(a1, v5, 0, 296);
    }
    if (objc_getProperty(a1, v3, 360, 1))
    {
      v7 = objc_getProperty(a1, v6, 360, 1);
      if (v7)
      {
        v7[8] = 1000;
        *((_DWORD *)v7 + 3) = -1;
        v7[2] = 0;
        v7[3] = 0;
        *((_OWORD *)v7 + 2) = xmmword_19BED74B0;
        *((_OWORD *)v7 + 3) = xmmword_19BED74C0;
        *((_WORD *)v7 + 4) = 0;
      }
    }
    if (objc_getProperty(a1, v6, 200, 1))
    {
      v10 = (void (**)(id, _QWORD))objc_getProperty(a1, v8, 200, 1);
      objc_setProperty_atomic_copy(a1, v9, 0, 200);
      v10[2](v10, 0);

    }
  }
}

- (void)invalidateDPDTimer
{
  const char *v3;
  SEL v4;
  const char *v5;
  NSObject *Property;
  SEL v7;

  if (objc_getProperty(a1, a2, 272, 1))
  {
    objc_msgSend(objc_getProperty(a1, v3, 272, 1), "invalidate");
    objc_setProperty_atomic(a1, v4, 0, 272);
  }
  if (objc_getProperty(a1, v3, 280, 1))
  {
    Property = objc_getProperty(a1, v5, 280, 1);
    dispatch_source_cancel(Property);
    objc_setProperty_atomic(a1, v7, 0, 280);
  }
}

- (uint64_t)fireWaitingRequestHandlerWithPacket:(_QWORD *)a1
{
  const char *v3;
  id v4;
  NSObject *v5;
  void *v6;
  const char *v7;
  uint64_t v8;
  void (**v9)(id, id);
  SEL v10;

  v4 = a2;
  if (!a1)
    goto LABEL_6;
  v5 = a1[38];
  if (v5)
  {
    dispatch_source_cancel(v5);
    v6 = (void *)a1[38];
    a1[38] = 0;

  }
  if (objc_getProperty(a1, v3, 208, 1))
  {
    v8 = 1;
    v9 = (void (**)(id, id))objc_getProperty(a1, v7, 208, 1);
    objc_setProperty_atomic_copy(a1, v10, 0, 208);
    v9[2](v9, v4);

  }
  else
  {
LABEL_6:
    v8 = 0;
  }

  return v8;
}

- (void)resetAll
{
  NSObject *Property;
  NSObject *v4;
  const char *v5;
  SEL v6;
  const char *v7;
  NSObject *v8;
  SEL v9;
  const char *v10;
  const void *v11;
  SEL v12;
  id v13;
  const char *v14;
  id v15;
  NEIKEv2IKESPI *v16;
  SEL v17;
  SEL v18;
  SEL v19;
  SEL v20;
  SEL v21;
  SEL v22;
  SEL v23;
  SEL v24;
  SEL v25;
  SEL v26;
  SEL v27;
  SEL v28;
  SEL v29;
  SEL v30;
  SEL v31;
  SEL v32;
  SEL v33;
  SEL v34;
  SEL v35;
  SEL v36;
  SEL v37;
  SEL v38;
  SEL v39;
  SEL v40;
  SEL v41;
  SEL v42;
  SEL v43;
  SEL v44;
  SEL v45;
  _QWORD *v46;
  const char *v47;
  const char *v48;
  _BYTE *v49;
  SEL v50;
  const char *v51;
  SEL v52;
  int v53;
  uint64_t v54;
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    Property = objc_getProperty((id)a1, a2, 368, 1);
    dispatch_assert_queue_V2(Property);
    ne_log_obj();
    v4 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      v53 = 138412290;
      v54 = a1;
      _os_log_impl(&dword_19BD16000, v4, OS_LOG_TYPE_DEFAULT, "Resetting %@", (uint8_t *)&v53, 0xCu);
    }

    -[NEIKEv2Session abort]((_BYTE *)a1, v5);
    -[NEIKEv2Session uninstallAllChildSAs](a1);
    if (objc_getProperty((id)a1, v6, 264, 1))
    {
      v8 = objc_getProperty((id)a1, v7, 264, 1);
      dispatch_source_cancel(v8);
      objc_setProperty_atomic((id)a1, v9, 0, 264);
    }
    -[NEIKEv2Session invalidateDPDTimer]((void *)a1, v7);
    if ((*(_BYTE *)(a1 + 10) & 1) != 0)
    {
      v11 = *(const void **)(a1 + 328);
      if (v11)
      {
        CFRelease(v11);
        *(_QWORD *)(a1 + 328) = 0;
      }
    }
    -[NEIKEv2Session resetMessages]((_DWORD *)a1, v10);
    v13 = objc_getProperty((id)a1, v12, 336, 1);
    if (v13)
    {
      v15 = v13;
      -[NEIKEv2IKESA detachTransportWithShouldInvalidate:](v13, 0);
      *((_BYTE *)v15 + 9) = 1;
      *((_BYTE *)v15 + 16) = 0;
      v16 = objc_alloc_init(NEIKEv2IKESPI);
      objc_setProperty_atomic(v15, v17, v16, 32);

      objc_setProperty_atomic(v15, v18, 0, 40);
      objc_setProperty_atomic(v15, v19, 0, 152);
      objc_setProperty_atomic(v15, v20, 0, 160);
      objc_setProperty_atomic(v15, v21, 0, 168);
      objc_setProperty_atomic(v15, v22, 0, 176);
      objc_setProperty_atomic(v15, v23, 0, 184);
      objc_setProperty_atomic(v15, v24, 0, 128);
      objc_setProperty_atomic(v15, v25, 0, 136);
      objc_setProperty_atomic(v15, v26, 0, 192);
      objc_setProperty_atomic(v15, v27, 0, 200);
      objc_setProperty_atomic(v15, v28, 0, 208);
      objc_setProperty_atomic(v15, v29, 0, 216);
      objc_setProperty_atomic(v15, v30, 0, 224);
      objc_setProperty_atomic(v15, v31, 0, 232);
      objc_setProperty_atomic(v15, v32, 0, 240);
      objc_setProperty_atomic(v15, v33, 0, 248);
      objc_setProperty_atomic(v15, v34, 0, 256);
      objc_setProperty_atomic(v15, v35, 0, 264);
      objc_setProperty_atomic(v15, v36, 0, 512);
      objc_setProperty_atomic(v15, v37, 0, 520);
      objc_setProperty_atomic(v15, v38, 0, 528);
      objc_setProperty_atomic(v15, v39, 0, 488);
      objc_setProperty_atomic(v15, v40, 0, 96);
      objc_setProperty_atomic(v15, v41, 0, 312);
      objc_setProperty_atomic(v15, v42, 0, 320);
      objc_setProperty_atomic(v15, v43, 0, 504);
      objc_setProperty_atomic(v15, v44, 0, 448);
      objc_setProperty_atomic(v15, v45, 0, 456);
      objc_storeStrong((id *)v15 + 14, 0);
    }
    v46 = objc_getProperty((id)a1, v14, 360, 1);
    if (v46)
    {
      v46[8] = 1000;
      *((_DWORD *)v46 + 3) = -1;
      v46[2] = 0;
      v46[3] = 0;
      *((_OWORD *)v46 + 2) = xmmword_19BED74B0;
      *((_OWORD *)v46 + 3) = xmmword_19BED74C0;
      *((_WORD *)v46 + 4) = 0;
    }
    if (objc_msgSend(objc_getProperty((id)a1, v47, 288, 1), "count"))
    {
      objc_msgSend(objc_getProperty((id)a1, v48, 288, 1), "firstObject");
      v49 = (_BYTE *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(objc_getProperty((id)a1, v50, 288, 1), "removeAllObjects");
      if (v49)
      {
        -[NEIKEv2ChildSA reset](v49, v51);
        objc_msgSend(objc_getProperty((id)a1, v52, 288, 1), "addObject:", v49);
      }

    }
  }
}

- (uint64_t)uninstallAllChildSAs
{
  void *v1;
  NSObject *v2;
  const char *v3;
  SEL v4;
  SEL v5;
  id v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  SEL v11;
  SEL v12;
  id v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  SEL v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  _BYTE v27[128];
  uint8_t v28[128];
  uint8_t buf[4];
  void *v30;
  __int16 v31;
  id Property;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  if (result)
  {
    v1 = (void *)result;
    ne_log_obj();
    v2 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412546;
      v30 = v1;
      v31 = 2112;
      Property = objc_getProperty(v1, v3, 176, 1);
      _os_log_impl(&dword_19BD16000, v2, OS_LOG_TYPE_DEFAULT, "%@ %@ Uninstalling all child SAs", buf, 0x16u);
    }

    objc_msgSend(objc_getProperty(v1, v4, 176, 1), "removeAllSAs");
    v25 = 0u;
    v26 = 0u;
    v23 = 0u;
    v24 = 0u;
    v6 = objc_getProperty(v1, v5, 184, 1);
    v7 = objc_msgSend(v6, "countByEnumeratingWithState:objects:count:", &v23, v28, 16);
    if (v7)
    {
      v8 = v7;
      v9 = *(_QWORD *)v24;
      do
      {
        v10 = 0;
        do
        {
          if (*(_QWORD *)v24 != v9)
            objc_enumerationMutation(v6);
          objc_msgSend(*(id *)(*((_QWORD *)&v23 + 1) + 8 * v10++), "invalidate");
        }
        while (v8 != v10);
        v8 = objc_msgSend(v6, "countByEnumeratingWithState:objects:count:", &v23, v28, 16);
      }
      while (v8);
    }

    objc_msgSend(objc_getProperty(v1, v11, 184, 1), "removeAllObjects");
    v21 = 0u;
    v22 = 0u;
    v19 = 0u;
    v20 = 0u;
    v13 = objc_getProperty(v1, v12, 192, 1);
    v14 = objc_msgSend(v13, "countByEnumeratingWithState:objects:count:", &v19, v27, 16);
    if (v14)
    {
      v15 = v14;
      v16 = *(_QWORD *)v20;
      do
      {
        v17 = 0;
        do
        {
          if (*(_QWORD *)v20 != v16)
            objc_enumerationMutation(v13);
          objc_msgSend(*(id *)(*((_QWORD *)&v19 + 1) + 8 * v17++), "invalidate", (_QWORD)v19);
        }
        while (v15 != v17);
        v15 = objc_msgSend(v13, "countByEnumeratingWithState:objects:count:", &v19, v27, 16);
      }
      while (v15);
    }

    return objc_msgSend(objc_getProperty(v1, v18, 192, 1), "removeAllObjects");
  }
  return result;
}

- (void)resetMessages
{
  SEL v3;
  SEL v4;
  SEL v5;
  SEL v6;
  SEL v7;
  SEL v8;
  SEL v9;

  -[NEIKEv2Session cancelSendTimer](a1, a2);
  -[NEIKEv2Session fireWaitingRequestHandlerWithPacket:](a1, 0);
  a1[4] = -1;
  a1[5] = -1;
  a1[6] = -1;
  objc_msgSend(objc_getProperty(a1, v3, 216, 1), "removeAllObjects");
  objc_msgSend(objc_getProperty(a1, v4, 224, 1), "removeAllObjects");
  objc_msgSend(objc_getProperty(a1, v5, 232, 1), "removeAllObjects");
  objc_msgSend(objc_getProperty(a1, v6, 240, 1), "removeAllObjects");
  objc_msgSend(objc_getProperty(a1, v7, 248, 1), "removeAllObjects");
  objc_msgSend(objc_getProperty(a1, v8, 256, 1), "removeAllObjects");
  objc_setProperty_atomic(a1, v9, 0, 376);
}

- (void)processFragment:(_DWORD *)a1
{
  const char *v3;
  _BYTE *v4;
  NSObject *Property;
  const char *v6;
  uint64_t v7;
  int v8;
  ptrdiff_t v9;
  _BYTE *v10;
  int v11;
  int v12;
  BOOL v13;
  NSObject *v14;
  const char *v15;
  void *v16;
  NEIKEv2FragmentMap *v17;
  const char *v18;
  char v19;
  unsigned int expectedCount;
  int v21;
  int v22;
  unsigned int v23;
  char v24;
  void *v25;
  void *v26;
  NSObject *v27;
  const char *v28;
  id v29;
  NSObject *v30;
  const char *v31;
  id v32;
  void *v33;
  void *v34;
  void *v35;
  void *v36;
  uint64_t v37;
  uint64_t v38;
  NSObject *v39;
  uint64_t v40;
  void *v41;
  void *v42;
  void *v43;
  SEL v44;
  id v45;
  id v46;
  NSObject *v47;
  id v48;
  uint64_t v49;
  const char *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  void *v54;
  id v55;
  id v56;
  char isKindOfClass;
  const char *v58;
  id v59;
  const char *v60;
  void *v61;
  id v62;
  const char *v63;
  id v64;
  const char *v65;
  void *v66;
  id v67;
  uint64_t v68;
  const char *v69;
  id v70;
  const char *v71;
  void *v72;
  NSObject *v73;
  NSObject *v74;
  const char *v75;
  const char *v76;
  NSObject *v77;
  id v78;
  unsigned int obj;
  NSObject *obja;
  NSObject *v81;
  NEIKEv2FragmentMap *self;
  id v83;
  uint8_t v84[16];
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  uint8_t buf[4];
  const char *v90;
  __int16 v91;
  int v92;
  __int16 v93;
  unsigned int v94;
  uint64_t v95;

  v95 = *MEMORY[0x1E0C80C00];
  v4 = a2;
  if (a1)
  {
    Property = objc_getProperty(a1, v3, 368, 1);
    dispatch_assert_queue_V2(Property);
    if ((v4[9] & 1) == 0)
    {
      ne_log_obj();
      v14 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136315138;
        v90 = "-[NEIKEv2Session processFragment:]";
        _os_log_fault_impl(&dword_19BD16000, v14, OS_LOG_TYPE_FAULT, "%s called with null fragment.isFragmented", buf, 0xCu);
      }
      goto LABEL_37;
    }
    v7 = *((unsigned int *)v4 + 6);
    if ((v4[10] & 1) != 0)
    {
      v10 = objc_getProperty(a1, v6, 336, 1);
      v11 = 4;
      if (v10)
      {
        if ((v10[17] & 1) != 0)
          v11 = 6;
        else
          v11 = 4;
      }
      v12 = a1[4];
      v13 = __OFSUB__(v12, v11);
      v8 = v12 - v11;
      if (v8 < 0 != v13)
      {
        if ((int)v7 > v12)
        {
          ne_log_obj();
          v14 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)buf = 138412290;
            v90 = (const char *)a1;
            v15 = "%@ Discarding too new fragment";
LABEL_20:
            _os_log_impl(&dword_19BD16000, v14, OS_LOG_TYPE_INFO, v15, buf, 0xCu);
          }
LABEL_37:

          goto LABEL_38;
        }
        v9 = 256;
LABEL_22:
        v81 = objc_getProperty(a1, v6, v9, 1);
        objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v7);
        v16 = (void *)objc_claimAutoreleasedReturnValue();
        -[NSObject objectForKeyedSubscript:](v81, "objectForKeyedSubscript:", v16);
        v17 = (NEIKEv2FragmentMap *)objc_claimAutoreleasedReturnValue();

        if (v17 || (v17 = objc_alloc_init(NEIKEv2FragmentMap)) != 0)
        {
          self = v17;
          v83 = objc_getProperty(v17, v18, 16, 1);
          v19 = 0;
          expectedCount = v17->_expectedCount;
        }
        else
        {
          self = 0;
          v83 = 0;
          expectedCount = 0;
          v19 = 1;
        }
        v21 = *((_DWORD *)v4 + 4);
        v22 = *((_DWORD *)v4 + 5);
        v23 = (unsigned __int16)v22;
        if ((_WORD)v22
          && (unsigned __int16)*((_DWORD *)v4 + 4)
          && (unsigned __int16)v21 <= (unsigned __int16)v22)
        {
          obj = v7;
          if (!expectedCount)
            goto LABEL_42;
          v24 = v19;
          if ((unsigned __int16)v22 == expectedCount)
          {
            objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedShort:", (unsigned __int16)v21);
            v25 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v83, "objectForKeyedSubscript:", v25);
            v26 = (void *)objc_claimAutoreleasedReturnValue();

            if (v26)
            {
              ne_log_obj();
              v27 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)buf = 138412802;
                v90 = (const char *)a1;
                v91 = 1024;
                v92 = (unsigned __int16)v21;
                v93 = 1024;
                v94 = obj;
                _os_log_debug_impl(&dword_19BD16000, v27, OS_LOG_TYPE_DEBUG, "%@ Received duplicate fragment %u for message %d", buf, 0x18u);
              }
              goto LABEL_34;
            }
          }
          v19 = v24;
          if ((unsigned __int16)v22 >= expectedCount)
          {
LABEL_42:
            v29 = objc_getProperty(a1, v18, 336, 1);
            if ((-[NEIKEv2Packet processReceivedPacketForIKESA:](v4, v29) & 1) != 0)
            {
              v14 = v81;
              if (expectedCount && (unsigned __int16)v22 > expectedCount)
              {
                ne_log_obj();
                v30 = objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v30, OS_LOG_TYPE_INFO))
                {
                  *(_DWORD *)buf = 138412802;
                  v90 = (const char *)a1;
                  v91 = 1024;
                  v92 = (unsigned __int16)v22;
                  v93 = 1024;
                  v94 = expectedCount;
                  _os_log_impl(&dword_19BD16000, v30, OS_LOG_TYPE_INFO, "%@ Fragment count %u > last received count %u, discarding stored fragments", buf, 0x18u);
                }

                if ((v19 & 1) != 0)
                  v32 = 0;
                else
                  v32 = objc_getProperty(self, v31, 16, 1);
                objc_msgSend(v32, "removeAllObjects");
              }
              objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedShort:", (unsigned __int16)v21);
              v33 = (void *)objc_claimAutoreleasedReturnValue();
              objc_msgSend(v83, "setObject:forKeyedSubscript:", v4, v33);

              if (objc_msgSend(v83, "count") == 1)
              {
                if ((v19 & 1) == 0)
                  self->_expectedCount = v22;
                objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", obj);
                v34 = (void *)objc_claimAutoreleasedReturnValue();
                -[NSObject objectForKeyedSubscript:](v81, "objectForKeyedSubscript:", v34);
                v35 = (void *)objc_claimAutoreleasedReturnValue();

                if (!v35)
                {
                  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", obj);
                  v36 = (void *)objc_claimAutoreleasedReturnValue();
                  -[NSObject setObject:forKeyedSubscript:](v81, "setObject:forKeyedSubscript:", self, v36);

                }
              }
              v37 = objc_msgSend(v83, "count");
              if (v37 != (unsigned __int16)v22)
                goto LABEL_36;
              v38 = v37;
              ne_log_obj();
              v39 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v39, OS_LOG_TYPE_INFO))
              {
                *(_DWORD *)buf = 138412546;
                v90 = (const char *)a1;
                v91 = 1024;
                v92 = (unsigned __int16)v22;
                _os_log_impl(&dword_19BD16000, v39, OS_LOG_TYPE_INFO, "%@ Received all %u fragments", buf, 0x12u);
              }

              v27 = objc_msgSend(objc_alloc(MEMORY[0x1E0C99DE8]), "initWithCapacity:", v38);
              v40 = 0;
              while (1)
              {
                objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInteger:", ++v40);
                v41 = (void *)objc_claimAutoreleasedReturnValue();
                objc_msgSend(v83, "objectForKeyedSubscript:", v41);
                v42 = (void *)objc_claimAutoreleasedReturnValue();

                if (!v42)
                  break;
                -[NSObject addObject:](v27, "addObject:", v42);

                if (v38 == v40)
                {
                  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", obj);
                  v43 = (void *)objc_claimAutoreleasedReturnValue();
                  -[NSObject setObject:forKeyedSubscript:](v81, "setObject:forKeyedSubscript:", 0, v43);

                  v45 = objc_getProperty(a1, v44, 336, 1);
                  v27 = v27;
                  v46 = v45;
                  objc_opt_self();
                  if (v27)
                  {
                    if (v46)
                    {
                      -[NSObject firstObject](v27, "firstObject");
                      v47 = objc_claimAutoreleasedReturnValue();
                      v48 = objc_alloc_init(MEMORY[0x1E0C99DF0]);
                      v85 = 0u;
                      v86 = 0u;
                      v87 = 0u;
                      v88 = 0u;
                      obja = v27;
                      v49 = -[NSObject countByEnumeratingWithState:objects:count:](obja, "countByEnumeratingWithState:objects:count:", &v85, buf, 16);
                      if (v49)
                      {
                        v51 = v49;
                        v52 = *(_QWORD *)v86;
                        v77 = v47;
                        v78 = v46;
                        do
                        {
                          v53 = 0;
                          do
                          {
                            if (*(_QWORD *)v86 != v52)
                              objc_enumerationMutation(obja);
                            v54 = *(void **)(*((_QWORD *)&v85 + 1) + 8 * v53);
                            if (v54)
                              v55 = objc_getProperty(*(id *)(*((_QWORD *)&v85 + 1) + 8 * v53), v50, 48, 1);
                            else
                              v55 = 0;
                            v56 = v55;
                            objc_opt_class();
                            isKindOfClass = objc_opt_isKindOfClass();

                            if ((isKindOfClass & 1) == 0)
                            {
                              ne_log_obj();
                              v74 = objc_claimAutoreleasedReturnValue();
                              if (os_log_type_enabled(v74, OS_LOG_TYPE_FAULT))
                              {
                                *(_WORD *)v84 = 0;
                                v75 = "Attempted to process non-fragment payload";
                                goto LABEL_110;
                              }
LABEL_105:
                              v14 = v81;
                              v47 = v77;
                              v46 = v78;

                              v73 = 0;
                              goto LABEL_106;
                            }
                            if (!v54
                              || (v59 = objc_getProperty(v54, v58, 48, 1)) == 0
                              || (v61 = v59, v62 = objc_getProperty(v59, v60, 16, 1), v61, !v62))
                            {
                              ne_log_obj();
                              v74 = objc_claimAutoreleasedReturnValue();
                              if (os_log_type_enabled(v74, OS_LOG_TYPE_FAULT))
                              {
                                *(_WORD *)v84 = 0;
                                v75 = "Fragment missing decrypted data";
LABEL_110:
                                _os_log_fault_impl(&dword_19BD16000, v74, OS_LOG_TYPE_FAULT, v75, v84, 2u);
                              }
                              goto LABEL_105;
                            }
                            v64 = objc_getProperty(v54, v63, 48, 1);
                            v66 = v64;
                            if (v64)
                              v67 = objc_getProperty(v64, v65, 16, 1);
                            else
                              v67 = 0;
                            objc_msgSend(v48, "appendData:", v67, v77, v78);

                            ++v53;
                          }
                          while (v51 != v53);
                          v68 = -[NSObject countByEnumeratingWithState:objects:count:](obja, "countByEnumeratingWithState:objects:count:", &v85, buf, 16);
                          v51 = v68;
                          v47 = v77;
                          v46 = v78;
                        }
                        while (v68);
                      }

                      if (v47)
                      {
                        v70 = objc_getProperty(v47, v69, 48, 1);
                        if (v70)
                        {
                          v72 = v70;
                          objc_setProperty_atomic(v70, v71, v48, 16);

                        }
                      }
                      if (-[NEIKEv2Packet processDecryptedPacketForIKESA:](v47, v46))
                        v73 = v47;
                      else
                        v73 = 0;
                      v14 = v81;
LABEL_106:

                      goto LABEL_107;
                    }
                    ne_log_obj();
                    v47 = objc_claimAutoreleasedReturnValue();
                    if (!os_log_type_enabled(v47, OS_LOG_TYPE_FAULT))
                    {
LABEL_101:
                      v73 = 0;
                      v14 = v81;
LABEL_107:

                      objc_msgSend(a1, "receivePacket:", v73);
                      goto LABEL_108;
                    }
                    *(_DWORD *)buf = 136315138;
                    v90 = "+[NEIKEv2Packet createPacketFromReceivedFragments:ikeSA:]";
                    v76 = "%s called with null ikeSA";
                  }
                  else
                  {
                    ne_log_obj();
                    v47 = objc_claimAutoreleasedReturnValue();
                    if (!os_log_type_enabled(v47, OS_LOG_TYPE_FAULT))
                      goto LABEL_101;
                    *(_DWORD *)buf = 136315138;
                    v90 = "+[NEIKEv2Packet createPacketFromReceivedFragments:ikeSA:]";
                    v76 = "%s called with null receivedFragments";
                  }
                  _os_log_fault_impl(&dword_19BD16000, v47, OS_LOG_TYPE_FAULT, v76, buf, 0xCu);
                  goto LABEL_101;
                }
              }
              ne_log_obj();
              v73 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v73, OS_LOG_TYPE_FAULT))
              {
                *(_DWORD *)buf = 138412802;
                v90 = (const char *)a1;
                v91 = 1024;
                v92 = (unsigned __int16)v40;
                v93 = 1024;
                v94 = v23;
                _os_log_fault_impl(&dword_19BD16000, v73, OS_LOG_TYPE_FAULT, "%@ Missing fragment %u/%u, skipping reassembly", buf, 0x18u);
              }
LABEL_108:

            }
            else
            {
              ne_log_obj();
              v27 = objc_claimAutoreleasedReturnValue();
              v14 = v81;
              if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 138412290;
                v90 = (const char *)a1;
                _os_log_error_impl(&dword_19BD16000, v27, OS_LOG_TYPE_ERROR, "%@ Discarding undecrypted fragment", buf, 0xCu);
              }
            }
LABEL_35:

LABEL_36:
            goto LABEL_37;
          }
          ne_log_obj();
          v27 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 138412802;
            v90 = (const char *)a1;
            v91 = 1024;
            v92 = (unsigned __int16)v22;
            v93 = 1024;
            v94 = expectedCount;
            v28 = "%@ Fragment count %u < last received count %u";
LABEL_89:
            _os_log_error_impl(&dword_19BD16000, v27, OS_LOG_TYPE_ERROR, v28, buf, 0x18u);
          }
        }
        else
        {
          ne_log_obj();
          v27 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 138412802;
            v90 = (const char *)a1;
            v91 = 1024;
            v92 = (unsigned __int16)v21;
            v93 = 1024;
            v94 = (unsigned __int16)v22;
            v28 = "%@ Invalid fragment numbers %u/%u";
            goto LABEL_89;
          }
        }
LABEL_34:
        v14 = v81;
        goto LABEL_35;
      }
      v9 = 256;
    }
    else
    {
      if ((int)a1[5] <= 3)
      {
        v9 = 248;
        goto LABEL_22;
      }
      v8 = a1[4] - 4;
      v9 = 248;
    }
    if (v8 != -1 && (int)v7 <= v8)
    {
      ne_log_obj();
      v14 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 138412290;
        v90 = (const char *)a1;
        v15 = "%@ Discarding stale fragment";
        goto LABEL_20;
      }
      goto LABEL_37;
    }
    goto LABEL_22;
  }
LABEL_38:

}

- (void)setReceivedReply:(uint64_t)a3 messageID:
{
  id v5;
  SEL v6;
  id Property;
  void *v8;
  id v9;
  id v10;

  if (a1)
  {
    v5 = a2;
    Property = objc_getProperty(a1, v6, 240, 1);
    v8 = (void *)MEMORY[0x1E0CB37E8];
    v9 = Property;
    objc_msgSend(v8, "numberWithInt:", a3);
    v10 = (id)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v9, "setObject:forKeyedSubscript:", v5, v10);

  }
}

- (id)copyChildWithSPI:(void *)a1
{
  const char *v3;
  id v4;
  uint64_t v5;
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  id Property;
  const char *v12;
  void *v13;
  id v14;
  const char *v15;
  id v16;
  const char *v17;
  void *v18;
  id v19;
  char v20;
  uint64_t v21;
  id v22;
  id obj;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  _BYTE v29[128];
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v4 = a2;
  if (a1)
  {
    v27 = 0u;
    v28 = 0u;
    v25 = 0u;
    v26 = 0u;
    obj = objc_getProperty(a1, v3, 288, 1);
    v5 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v25, v29, 16);
    if (v5)
    {
      v7 = v5;
      v8 = *(_QWORD *)v26;
      do
      {
        v9 = 0;
        do
        {
          if (*(_QWORD *)v26 != v8)
            objc_enumerationMutation(obj);
          v10 = *(void **)(*((_QWORD *)&v25 + 1) + 8 * v9);
          if (v10)
          {
            Property = objc_getProperty(*(id *)(*((_QWORD *)&v25 + 1) + 8 * v9), v6, 56, 1);
            v13 = Property;
            if (Property)
              Property = objc_getProperty(Property, v12, 80, 1);
          }
          else
          {
            v13 = 0;
            Property = 0;
          }
          v14 = Property;
          if (objc_msgSend(v14, "isEqual:", v4))
          {

LABEL_23:
            v22 = v10;
            goto LABEL_24;
          }
          if (v10)
          {
            v16 = objc_getProperty(v10, v15, 56, 1);
            v18 = v16;
            if (v16)
              v16 = objc_getProperty(v16, v17, 88, 1);
          }
          else
          {
            v18 = 0;
            v16 = 0;
          }
          v19 = v16;
          v20 = objc_msgSend(v19, "isEqual:", v4);

          if ((v20 & 1) != 0)
            goto LABEL_23;
          ++v9;
        }
        while (v7 != v9);
        v21 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v25, v29, 16);
        v7 = v21;
        v22 = 0;
      }
      while (v21);
    }
    else
    {
      v22 = 0;
    }
LABEL_24:

  }
  else
  {
    v22 = 0;
  }

  return v22;
}

- (uint64_t)sendReplyForMessageID:(_BYTE *)a1
{
  NSObject *Property;
  const char *v5;
  const char *v6;
  _BYTE *v7;
  const char *v8;
  const char *v9;
  id *v10;
  const char *v11;
  NSObject *v12;
  SEL v13;
  id v14;
  void *v15;
  id v16;
  void *v17;
  void *v18;
  NSObject *v19;
  void *v20;
  char v21;
  NSObject *v22;
  SEL v23;
  id v24;
  uint64_t v25;
  const char *v26;
  id v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  void *v34;
  NSObject *v35;
  int v36;
  NSObject *v37;
  SEL v38;
  id v39;
  NSObject *v40;
  void *v41;
  id v42;
  void *v43;
  int v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  uint8_t buf[4];
  const char *v50;
  __int16 v51;
  _BYTE v52[10];
  __int16 v53;
  _BYTE v54[10];
  __int16 v55;
  NSObject *v56;
  _BYTE v57[128];
  uint64_t v58;

  v58 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 0;
  Property = objc_getProperty(a1, a2, 368, 1);
  dispatch_assert_queue_V2(Property);
  if ((a1[12] & 1) != 0)
  {
    ne_log_obj();
    v12 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412546;
      v50 = a1;
      v51 = 1024;
      *(_DWORD *)v52 = (_DWORD)a2;
      _os_log_impl(&dword_19BD16000, v12, OS_LOG_TYPE_DEFAULT, "%@ Skipping sending reply %d on invalidated session", buf, 0x12u);
    }
    goto LABEL_17;
  }
  if (!objc_getProperty(a1, v5, 336, 1))
  {
    ne_log_obj();
    v12 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
      goto LABEL_17;
    *(_DWORD *)buf = 136315138;
    v50 = "-[NEIKEv2Session sendReplyForMessageID:]";
    v26 = "%s called with null self.ikeSA";
LABEL_42:
    _os_log_fault_impl(&dword_19BD16000, v12, OS_LOG_TYPE_FAULT, v26, buf, 0xCu);
    goto LABEL_17;
  }
  v7 = objc_getProperty(a1, v6, 336, 1);
  if ((-[NEIKEv2IKESA hasTransport](v7, v8) & 1) != 0)
  {
    v10 = (id *)objc_getProperty(a1, v9, 336, 1);
    v12 = -[NEIKEv2IKESA copyTransport](v10, v11);
    v14 = objc_getProperty(a1, v13, 224, 1);
    v15 = (void *)MEMORY[0x1E0CB37E8];
    v16 = v14;
    objc_msgSend(v15, "numberWithInt:", a2);
    v17 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v16, "objectForKeyedSubscript:", v17);
    v18 = (void *)objc_claimAutoreleasedReturnValue();

    if (objc_msgSend(v18, "count") == 1)
    {
      ne_log_obj();
      v19 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
      {
        objc_msgSend(v18, "firstObject");
        v41 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 138413058;
        v50 = a1;
        v51 = 1024;
        *(_DWORD *)v52 = objc_msgSend(v41, "length");
        *(_WORD *)&v52[4] = 1024;
        *(_DWORD *)&v52[6] = (_DWORD)a2;
        v53 = 2112;
        *(_QWORD *)v54 = v12;
        _os_log_debug_impl(&dword_19BD16000, v19, OS_LOG_TYPE_DEBUG, "%@ Sending reply of length %u with ID %u on %@\n", buf, 0x22u);

      }
      objc_msgSend(v18, "firstObject");
      v20 = (void *)objc_claimAutoreleasedReturnValue();
      v21 = -[NEIKEv2Transport sendData:sendCompletionHandler:]((id *)&v12->isa, v20, 0);

      if ((v21 & 1) == 0)
      {
        ne_log_obj();
        v22 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)buf = 0;
          _os_log_error_impl(&dword_19BD16000, v22, OS_LOG_TYPE_ERROR, "Sending reply data failed", buf, 2u);
        }

        v24 = objc_getProperty(a1, v23, 336, 1);
        -[NEIKEv2IKESA detachTransportWithShouldInvalidate:](v24, 1);
        v25 = 0;
        goto LABEL_40;
      }
    }
    else
    {
      if (objc_msgSend(v18, "count"))
      {
        v43 = v18;
        v44 = objc_msgSend(v18, "count");
        v45 = 0u;
        v46 = 0u;
        v47 = 0u;
        v48 = 0u;
        v28 = v18;
        v29 = objc_msgSend(v28, "countByEnumeratingWithState:objects:count:", &v45, v57, 16);
        if (v29)
        {
          v30 = v29;
          v31 = *(_QWORD *)v46;
          v32 = 1;
          v42 = v28;
          while (2)
          {
            v33 = 0;
            do
            {
              if (*(_QWORD *)v46 != v31)
                objc_enumerationMutation(v28);
              v34 = *(void **)(*((_QWORD *)&v45 + 1) + 8 * v33);
              ne_log_obj();
              v35 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
              {
                v36 = objc_msgSend(v34, "length");
                *(_DWORD *)buf = 138413570;
                v50 = a1;
                v51 = 1024;
                *(_DWORD *)v52 = v32 + v33;
                v28 = v42;
                *(_WORD *)&v52[4] = 1024;
                *(_DWORD *)&v52[6] = v44;
                v53 = 1024;
                *(_DWORD *)v54 = v36;
                *(_WORD *)&v54[4] = 1024;
                *(_DWORD *)&v54[6] = (_DWORD)a2;
                v55 = 2112;
                v56 = v12;
                _os_log_debug_impl(&dword_19BD16000, v35, OS_LOG_TYPE_DEBUG, "%@ Sending reply fragment %u/%u of length %u with ID %u on %@\n", buf, 0x2Eu);
              }

              if ((-[NEIKEv2Transport sendData:sendCompletionHandler:]((id *)&v12->isa, v34, 0) & 1) == 0)
              {
                ne_log_obj();
                v37 = objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 138412290;
                  v50 = a1;
                  _os_log_error_impl(&dword_19BD16000, v37, OS_LOG_TYPE_ERROR, "%@ Sending fragment reply data failed", buf, 0xCu);
                }

                v39 = objc_getProperty(a1, v38, 336, 1);
                -[NEIKEv2IKESA detachTransportWithShouldInvalidate:](v39, 1);

                v25 = 0;
                goto LABEL_35;
              }
              ++v33;
            }
            while (v30 != v33);
            v32 += v33;
            v30 = objc_msgSend(v28, "countByEnumeratingWithState:objects:count:", &v45, v57, 16);
            if (v30)
              continue;
            break;
          }
        }

        v25 = 1;
LABEL_35:
        v18 = v43;
        goto LABEL_40;
      }
      ne_log_obj();
      v40 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138412546;
        v50 = a1;
        v51 = 2112;
        *(_QWORD *)v52 = v18;
        _os_log_error_impl(&dword_19BD16000, v40, OS_LOG_TYPE_ERROR, "%@ Sending reply had unexpected sendValue %@", buf, 0x16u);
      }

    }
    v25 = 1;
LABEL_40:

    goto LABEL_18;
  }
  ne_log_obj();
  v12 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)buf = 136315138;
    v50 = "-[NEIKEv2Session sendReplyForMessageID:]";
    v26 = "%s called with null self.ikeSA.hasTransport";
    goto LABEL_42;
  }
LABEL_17:
  v25 = 0;
LABEL_18:

  return v25;
}

+ (void)removeItemsFromDictionary:(int)a3 lowerEdge:
{
  id v4;
  void *v5;
  void *v6;
  id v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t i;
  void *v13;
  NSObject *v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  uint8_t buf[4];
  void *v20;
  _BYTE v21[128];
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v4 = a2;
  objc_opt_self();
  objc_msgSend(v4, "allKeys");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v5, "sortedArrayUsingSelector:", sel_compare_);
  v6 = (void *)objc_claimAutoreleasedReturnValue();

  v17 = 0u;
  v18 = 0u;
  v15 = 0u;
  v16 = 0u;
  v7 = v6;
  v8 = objc_msgSend(v7, "countByEnumeratingWithState:objects:count:", &v15, v21, 16);
  if (v8)
  {
    v9 = v8;
    v10 = *(_QWORD *)v16;
    v11 = a3;
    while (2)
    {
      for (i = 0; i != v9; ++i)
      {
        if (*(_QWORD *)v16 != v10)
          objc_enumerationMutation(v7);
        v13 = *(void **)(*((_QWORD *)&v15 + 1) + 8 * i);
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) == 0)
        {
          ne_log_obj();
          v14 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)buf = 138412290;
            v20 = v13;
            _os_log_fault_impl(&dword_19BD16000, v14, OS_LOG_TYPE_FAULT, "Key %@ is not NSNumber", buf, 0xCu);
          }
LABEL_13:

          goto LABEL_14;
        }
        v14 = v13;
        if (-[NSObject integerValue](v14, "integerValue", (_QWORD)v15) > v11)
          goto LABEL_13;
        objc_msgSend(v4, "setObject:forKeyedSubscript:", 0, v14);

      }
      v9 = objc_msgSend(v7, "countByEnumeratingWithState:objects:count:", &v15, v21, 16);
      if (v9)
        continue;
      break;
    }
  }
LABEL_14:

}

void __27__NEIKEv2Session_addChild___block_invoke(uint64_t a1, const char *a2)
{
  _BYTE *Property;

  Property = *(_BYTE **)(a1 + 32);
  if (Property)
  {
    if ((Property[11] & 1) != 0)
      return;
    Property = objc_getProperty(Property, a2, 288, 1);
  }
  objc_msgSend(Property, "addObject:", *(_QWORD *)(a1 + 40));
  -[NEIKEv2Session enqueuePendingRequestContext:](*(_QWORD **)(a1 + 32), *(void **)(a1 + 48));
}

void __125__NEIKEv2Session_sendMOBIKEWithRetries_retryInterval_interfaceName_invalidateTransport_resetEndpoint_callbackQueue_callback___block_invoke(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 32);
  if (v1)
  {
    if ((*(_BYTE *)(v1 + 11) & 1) == 0)
      -[NEIKEv2Session enqueuePendingRequestContext:](*(_QWORD **)(a1 + 32), *(void **)(a1 + 40));
  }
  else
  {
    -[NEIKEv2Session enqueuePendingRequestContext:](0, *(void **)(a1 + 40));
  }
}

void __100__NEIKEv2Session_sendPrivateNotifies_maxRetries_retryIntervalInMilliseconds_callbackQueue_callback___block_invoke(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 32);
  if (v1)
  {
    if ((*(_BYTE *)(v1 + 11) & 1) == 0)
      -[NEIKEv2Session enqueuePendingRequestContext:](*(_QWORD **)(a1 + 32), *(void **)(a1 + 40));
  }
  else
  {
    -[NEIKEv2Session enqueuePendingRequestContext:](0, *(void **)(a1 + 40));
  }
}

void __94__NEIKEv2Session_sendKeepaliveWithRetries_retryIntervalInMilliseconds_callbackQueue_callback___block_invoke(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 32);
  if (v1)
  {
    if ((*(_BYTE *)(v1 + 11) & 1) == 0)
      -[NEIKEv2Session enqueuePendingRequestContext:](*(_QWORD **)(a1 + 32), *(void **)(a1 + 40));
  }
  else
  {
    -[NEIKEv2Session enqueuePendingRequestContext:](0, *(void **)(a1 + 40));
  }
}

void __38__NEIKEv2Session_updateConfiguration___block_invoke(uint64_t a1, const char *a2)
{
  _BYTE *v3;
  const char *v4;
  void *v5;
  id Property;
  NSObject *v7;
  int v8;
  const char *v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v3 = *(_BYTE **)(a1 + 32);
  if (!v3)
    goto LABEL_8;
  if ((v3[11] & 1) != 0)
    return;
  if (objc_getProperty(v3, a2, 336, 1))
  {
    v5 = *(void **)(a1 + 32);
    if (v5)
    {
      Property = objc_getProperty(v5, v4, 336, 1);
      if (Property)
        objc_setProperty_atomic(Property, v4, *(id *)(a1 + 40), 88);
    }
    -[NEIKEv2Session startDPDTimer](*(void **)(a1 + 32), v4);
  }
  else
  {
LABEL_8:
    ne_log_obj();
    v7 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
    {
      v8 = 136315138;
      v9 = "-[NEIKEv2Session updateConfiguration:]_block_invoke";
      _os_log_fault_impl(&dword_19BD16000, v7, OS_LOG_TYPE_FAULT, "%s called with null self.ikeSA", (uint8_t *)&v8, 0xCu);
    }

  }
}

- (void)startDPDTimer
{
  const char *v3;
  id Property;
  const char *v5;
  NSObject *v6;
  unint64_t v7;
  unint64_t v8;
  double v9;
  const char *v10;
  const char *v11;
  id v12;
  void *v13;
  void *v14;
  void *v15;
  SEL v16;
  NSObject *v17;
  void *v18;
  SEL v19;
  id v20;
  SEL v21;
  id v22;
  const char *v23;
  NSObject *v24;
  SEL v25;
  NSObject *v26;
  SEL v27;
  NSObject *v28;
  dispatch_source_t v29;
  SEL v30;
  SEL v31;
  const char *v32;
  NSObject *v33;
  dispatch_time_t v34;
  SEL v35;
  id v36;
  NSObject *v37;
  SEL v38;
  NSObject *v39;
  NSObject *v40;
  _QWORD handler[4];
  id v42;
  _QWORD v43[4];
  id v44;
  uint8_t buf[4];
  const char *v46;
  __int16 v47;
  unint64_t v48;
  __int16 v49;
  double v50;
  __int16 v51;
  void *v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (objc_getProperty(a1, a2, 336, 1))
    {
      Property = objc_getProperty(a1, v3, 336, 1);
      if (Property)
        Property = objc_getProperty(Property, v5, 88, 1);
      v6 = Property;
      if (-[NSObject deadPeerDetectionEnabled](v6, "deadPeerDetectionEnabled")
        && -[NSObject deadPeerDetectionInterval](v6, "deadPeerDetectionInterval"))
      {
        v7 = -[NSObject deadPeerDetectionInterval](v6, "deadPeerDetectionInterval");
        v8 = v7;
        v9 = 5.0;
        if (v7 >= 0x12D)
        {
          v9 = 15.0;
          if (v7 <= 0x383)
            v9 = (double)v7 / 60.0;
        }
        if (objc_opt_class())
        {
          if (objc_getProperty(a1, v10, 272, 1))
          {
            objc_msgSend(objc_getProperty(a1, v11, 272, 1), "cancel");
          }
          else
          {
            v12 = objc_alloc(MEMORY[0x1E0CB3940]);
            objc_msgSend(a1, "description");
            v13 = (void *)objc_claimAutoreleasedReturnValue();
            v14 = (void *)objc_msgSend(v12, "initWithFormat:", CFSTR("com.apple.networkextension[%@ Periodic Dead Peer Detection]"), v13);

            v15 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0DB0F80]), "initWithIdentifier:", v14);
            objc_setProperty_atomic(a1, v16, v15, 272);

          }
          ne_log_obj();
          v17 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
          {
            v18 = (void *)NEGetSystemWakeTime();
            *(_DWORD *)buf = 138413058;
            v46 = (const char *)a1;
            v47 = 2048;
            v48 = v8;
            v49 = 2048;
            v50 = v9;
            v51 = 2112;
            v52 = v18;
            _os_log_impl(&dword_19BD16000, v17, OS_LOG_TYPE_INFO, "%@: Setting DPD timer for %llu seconds, leeway %f seconds, last wake date %@", buf, 0x2Au);

          }
          objc_initWeak((id *)buf, a1);
          v20 = objc_getProperty(a1, v19, 272, 1);
          v22 = objc_getProperty(a1, v21, 368, 1);
          v43[0] = MEMORY[0x1E0C809B0];
          v43[1] = 3221225472;
          v43[2] = __31__NEIKEv2Session_startDPDTimer__block_invoke;
          v43[3] = &unk_1E3CC1798;
          objc_copyWeak(&v44, (id *)buf);
          objc_msgSend(v20, "scheduleWithFireInterval:leewayInterval:queue:handler:", v22, v43, (double)v8, v9);

          objc_destroyWeak(&v44);
          objc_destroyWeak((id *)buf);
        }
        else
        {
          if (objc_getProperty(a1, v10, 280, 1))
          {
            v24 = objc_getProperty(a1, v23, 280, 1);
            dispatch_source_cancel(v24);
            objc_setProperty_atomic(a1, v25, 0, 280);
          }
          ne_log_obj();
          v26 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v26, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)buf = 138412802;
            v46 = (const char *)a1;
            v47 = 2048;
            v48 = v8;
            v49 = 2048;
            v50 = v9;
            _os_log_impl(&dword_19BD16000, v26, OS_LOG_TYPE_INFO, "%@: Setting DPD timer for %llu seconds, leeway %f seconds", buf, 0x20u);
          }

          v28 = objc_getProperty(a1, v27, 368, 1);
          v29 = dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, v28);
          objc_setProperty_atomic(a1, v30, v29, 280);

          if (objc_getProperty(a1, v31, 280, 1))
          {
            v33 = objc_getProperty(a1, v32, 280, 1);
            v34 = dispatch_time(0x8000000000000000, 1000000000 * v8);
            dispatch_source_set_timer(v33, v34, 0xFFFFFFFFFFFFFFFFLL, (unint64_t)(v9 * 1000000000.0));

            objc_initWeak((id *)buf, a1);
            v36 = objc_getProperty(a1, v35, 280, 1);
            handler[0] = MEMORY[0x1E0C809B0];
            handler[1] = 3221225472;
            handler[2] = __31__NEIKEv2Session_startDPDTimer__block_invoke_53;
            handler[3] = &unk_1E3CC39A8;
            v37 = v36;
            objc_copyWeak(&v42, (id *)buf);
            dispatch_source_set_event_handler(v37, handler);

            v39 = objc_getProperty(a1, v38, 280, 1);
            dispatch_activate(v39);
            objc_destroyWeak(&v42);
            objc_destroyWeak((id *)buf);
          }
          else
          {
            ne_log_obj();
            v40 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v40, OS_LOG_TYPE_FAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_fault_impl(&dword_19BD16000, v40, OS_LOG_TYPE_FAULT, "dispatch_source_create failed", buf, 2u);
            }

          }
        }
      }
    }
    else
    {
      ne_log_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136315138;
        v46 = "-[NEIKEv2Session startDPDTimer]";
        _os_log_fault_impl(&dword_19BD16000, v6, OS_LOG_TYPE_FAULT, "%s called with null self.ikeSA", buf, 0xCu);
      }
    }

  }
}

void __31__NEIKEv2Session_startDPDTimer__block_invoke(uint64_t a1)
{
  _BYTE *WeakRetained;
  const char *v2;
  _BYTE *v3;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained && (WeakRetained[11] & 1) == 0)
  {
    v3 = WeakRetained;
    -[NEIKEv2Session dpdTimerFired](WeakRetained, v2);
    WeakRetained = v3;
  }

}

void __31__NEIKEv2Session_startDPDTimer__block_invoke_53(uint64_t a1)
{
  _BYTE *WeakRetained;
  const char *v2;
  _BYTE *v3;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained && (WeakRetained[11] & 1) == 0)
  {
    v3 = WeakRetained;
    -[NEIKEv2Session dpdTimerFired](WeakRetained, v2);
    WeakRetained = v3;
  }

}

- (void)dpdTimerFired
{
  id Property;
  const char *v4;
  id v5;

  Property = objc_getProperty(a1, a2, 336, 1);
  if (Property)
    Property = objc_getProperty(Property, v4, 88, 1);
  v5 = Property;
  objc_msgSend(a1, "sendKeepaliveWithRetries:retryIntervalInMilliseconds:callbackQueue:callback:", objc_msgSend(v5, "deadPeerDetectionMaxRetryCount"), objc_msgSend(v5, "deadPeerDetectionRetryIntervalMilliseconds"), 0, 0);
  -[NEIKEv2Session startDPDTimer](a1);

}

- (void)removeChild:(void *)a3 withReason:
{
  id v6;
  NEIKEv2DeleteChildContext *v7;
  id v8;
  NEIKEv2DeleteChildContext *v9;
  SEL v10;
  NSObject *Property;
  NEIKEv2DeleteChildContext *v12;
  _QWORD v13[5];
  NEIKEv2DeleteChildContext *v14;
  objc_super v15;

  if (a1)
  {
    v6 = a3;
    v7 = [NEIKEv2DeleteChildContext alloc];
    v8 = v6;
    if (v7)
    {
      v15.receiver = v7;
      v15.super_class = (Class)NEIKEv2DeleteChildContext;
      v9 = (NEIKEv2DeleteChildContext *)objc_msgSendSuper2(&v15, sel_initWithRequestType_, 6);
      v7 = v9;
      if (v9)
      {
        v9->_childID = a2;
        objc_storeStrong((id *)&v9->_reasonError, a3);
      }
    }

    Property = objc_getProperty(a1, v10, 368, 1);
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 3221225472;
    v13[2] = __41__NEIKEv2Session_removeChild_withReason___block_invoke;
    v13[3] = &unk_1E3CC2F98;
    v13[4] = a1;
    v14 = v7;
    v12 = v7;
    dispatch_async(Property, v13);

  }
}

void __41__NEIKEv2Session_removeChild_withReason___block_invoke(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 32);
  if (v1)
  {
    if ((*(_BYTE *)(v1 + 11) & 1) == 0)
      -[NEIKEv2Session enqueuePendingRequestContext:](*(_QWORD **)(a1 + 32), *(void **)(a1 + 40));
  }
  else
  {
    -[NEIKEv2Session enqueuePendingRequestContext:](0, *(void **)(a1 + 40));
  }
}

void __34__NEIKEv2Session_forceRekeyChild___block_invoke(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 32);
  if (v1)
  {
    if ((*(_BYTE *)(v1 + 11) & 1) == 0)
      -[NEIKEv2Session enqueuePendingRequestContext:](*(_QWORD **)(a1 + 32), *(void **)(a1 + 40));
  }
  else
  {
    -[NEIKEv2Session enqueuePendingRequestContext:](0, *(void **)(a1 + 40));
  }
}

void __31__NEIKEv2Session_forceRekeyIKE__block_invoke(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 32);
  if (v1)
  {
    if ((*(_BYTE *)(v1 + 11) & 1) == 0)
      -[NEIKEv2Session enqueuePendingRequestContext:](*(_QWORD **)(a1 + 32), *(void **)(a1 + 40));
  }
  else
  {
    -[NEIKEv2Session enqueuePendingRequestContext:](0, *(void **)(a1 + 40));
  }
}

void __28__NEIKEv2Session_disconnect__block_invoke(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  _BYTE *v4;
  const char *v5;
  NEIKEv2DeleteIKEContext *v6;
  id Property;
  id v8;
  id *v9;
  const char *v10;
  _QWORD v11[4];
  id v12;
  uint8_t buf[4];
  uint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  ne_log_obj();
  v2 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v3 = *(_QWORD *)(a1 + 32);
    *(_DWORD *)buf = 138412290;
    v14 = v3;
    _os_log_impl(&dword_19BD16000, v2, OS_LOG_TYPE_DEFAULT, "Disconnect %@", buf, 0xCu);
  }

  v4 = *(_BYTE **)(a1 + 32);
  if (!v4 || (v4[11] & 1) == 0)
  {
    objc_initWeak((id *)buf, v4);
    v6 = [NEIKEv2DeleteIKEContext alloc];
    Property = *(id *)(a1 + 32);
    if (Property)
      Property = objc_getProperty(Property, v5, 368, 1);
    v8 = Property;
    v11[0] = MEMORY[0x1E0C809B0];
    v11[1] = 3221225472;
    v11[2] = __28__NEIKEv2Session_disconnect__block_invoke_38;
    v11[3] = &unk_1E3CC1770;
    objc_copyWeak(&v12, (id *)buf);
    v9 = -[NEIKEv2DeleteIKEContext initDeleteIKEWithResponse:callbackQueue:callback:]((id *)&v6->super.super.isa, 1, v8, v11);

    -[NEIKEv2Session abort](*(_BYTE **)(a1 + 32), v10);
    -[NEIKEv2Session enqueuePendingRequestContext:](*(_QWORD **)(a1 + 32), v9);

    objc_destroyWeak(&v12);
    objc_destroyWeak((id *)buf);
  }
}

void __28__NEIKEv2Session_disconnect__block_invoke_38(uint64_t a1)
{
  _QWORD *WeakRetained;
  const char *v2;
  _QWORD *v3;
  SEL v4;
  _QWORD *Property;
  const char *v6;
  id v7;
  const char *v8;
  NSObject *v9;
  int v10;
  _QWORD *v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v3 = WeakRetained;
  if (WeakRetained)
  {
    -[NEIKEv2Session resetAll]((uint64_t)WeakRetained, v2);
    Property = objc_getProperty(v3, v4, 336, 1);
    if (Property && Property[6] == 2)
    {
      v7 = objc_getProperty(v3, v6, 336, 1);
      -[NEIKEv2IKESA setState:error:]((uint64_t)v7, 3uLL, 0);
      -[NEIKEv2Session reportState](v3, v8);
    }
    ne_log_obj();
    v9 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      v10 = 138412290;
      v11 = v3;
      _os_log_impl(&dword_19BD16000, v9, OS_LOG_TYPE_DEFAULT, "Disconnected %@", (uint8_t *)&v10, 0xCu);
    }

  }
}

- (void)reportState
{
  _QWORD *Property;
  const char *v4;
  unint64_t v5;
  id v6;
  const char *v7;
  id v8;
  NSObject *v9;
  _BOOL4 v10;
  __CFString *SessionStateString;
  const char *v12;
  NSObject *v13;
  uint32_t v14;
  id *v15;
  const char *v16;
  void *v17;
  void *v18;
  const char *v19;
  NSObject *v20;
  SEL v21;
  _BYTE *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t i;
  uint64_t v27;
  int v28;
  unint64_t v29;
  BOOL v30;
  unint64_t v31;
  void *v32;
  void *v33;
  const char *v34;
  id v35;
  NSObject *v36;
  id v37;
  id v38;
  id WeakRetained;
  void *v40;
  void *v41;
  void *v42;
  id *v43;
  id obj;
  _QWORD v45[5];
  id v46;
  id v47;
  unint64_t v48;
  int v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  _QWORD block[5];
  id v55;
  id v56;
  unint64_t v57;
  uint8_t v58[128];
  uint8_t buf[4];
  _QWORD *v60;
  __int16 v61;
  __CFString *v62;
  __int16 v63;
  id v64;
  uint64_t v65;

  v65 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return;
  Property = objc_getProperty(a1, a2, 336, 1);
  if (Property)
    v5 = Property[6];
  else
    v5 = 0;
  v6 = objc_getProperty(a1, v4, 336, 1);
  v43 = (id *)a1;
  if (v6)
    v6 = objc_getProperty(v6, v7, 56, 1);
  v8 = v6;
  ne_log_obj();
  v9 = objc_claimAutoreleasedReturnValue();
  v10 = os_log_type_enabled(v9, OS_LOG_TYPE_INFO);
  v42 = v8;
  if (v8)
  {
    if (!v10)
      goto LABEL_12;
    SessionStateString = NEIKEv2CreateSessionStateString(v5);
    *(_DWORD *)buf = 138412802;
    v60 = a1;
    v61 = 2112;
    v62 = SessionStateString;
    v63 = 2112;
    v64 = v8;
    v12 = "%@ Reporting state %@ error %@";
    v13 = v9;
    v14 = 32;
  }
  else
  {
    if (!v10)
      goto LABEL_12;
    SessionStateString = NEIKEv2CreateSessionStateString(v5);
    *(_DWORD *)buf = 138412546;
    v60 = a1;
    v61 = 2112;
    v62 = SessionStateString;
    v12 = "%@ Reporting state %@";
    v13 = v9;
    v14 = 22;
  }
  _os_log_impl(&dword_19BD16000, v13, OS_LOG_TYPE_INFO, v12, buf, v14);

LABEL_12:
  v15 = (id *)a1;
  a1[5] = v5;
  -[NEIKEv2Session updateEndpointState](a1, v16);
  objc_msgSend(a1, "stateUpdateBlock");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(a1, "clientQueue");
  v18 = (void *)objc_claimAutoreleasedReturnValue();

  if (v18 && v17)
  {
    objc_msgSend(a1, "clientQueue");
    v20 = objc_claimAutoreleasedReturnValue();
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = __29__NEIKEv2Session_reportState__block_invoke;
    block[3] = &unk_1E3CC2018;
    block[4] = a1;
    v56 = v17;
    v57 = v5;
    v55 = v42;
    dispatch_async(v20, block);

    v22 = objc_getProperty(a1, v21, 336, 1);
    if (v22)
      v22[8] = 0;

  }
  v41 = v17;
  v52 = 0u;
  v53 = 0u;
  v50 = 0u;
  v51 = 0u;
  obj = objc_getProperty(a1, v19, 288, 1);
  v23 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v50, v58, 16);
  if (v23)
  {
    v24 = v23;
    v25 = *(_QWORD *)v51;
    do
    {
      for (i = 0; i != v24; ++i)
      {
        if (*(_QWORD *)v51 != v25)
          objc_enumerationMutation(obj);
        v27 = *(_QWORD *)(*((_QWORD *)&v50 + 1) + 8 * i);
        if (v27)
        {
          v28 = *(_DWORD *)(v27 + 16);
          if (v28)
          {
            v29 = *(_QWORD *)(v27 + 32);
            if (v5 == 3)
            {
              if (v29)
                v30 = v29 == 3;
              else
                v30 = 1;
              if (!v30)
              {
                v29 = 3;
                goto LABEL_33;
              }
            }
            else if (!v5 && v29)
            {
              v29 = 0;
LABEL_33:
              -[NEIKEv2ChildSA setState:error:](*(_QWORD *)(*((_QWORD *)&v50 + 1) + 8 * i), v29, v42);
            }
            if ((*(_BYTE *)(v27 + 8) & 1) != 0)
            {
              v31 = v5;
              objc_msgSend(v15, "childStateUpdateBlock");
              v32 = (void *)objc_claimAutoreleasedReturnValue();
              objc_msgSend(v15, "clientQueue");
              v33 = (void *)objc_claimAutoreleasedReturnValue();

              if (v33 && v32)
              {
                v35 = objc_getProperty((id)v27, v34, 40, 1);
                objc_msgSend(v15, "clientQueue");
                v36 = objc_claimAutoreleasedReturnValue();
                v45[0] = MEMORY[0x1E0C809B0];
                v45[1] = 3221225472;
                v45[2] = __29__NEIKEv2Session_reportState__block_invoke_2;
                v45[3] = &unk_1E3CC1838;
                v45[4] = v43;
                v37 = v32;
                v49 = v28;
                v47 = v37;
                v48 = v29;
                v46 = v35;
                v38 = v35;
                dispatch_async(v36, v45);

                v15 = v43;
                *(_BYTE *)(v27 + 8) = 0;

              }
              v5 = v31;
            }
            continue;
          }
        }
      }
      v24 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v50, v58, 16);
    }
    while (v24);
  }

  WeakRetained = objc_loadWeakRetained(v15 + 43);
  v40 = WeakRetained;
  if (WeakRetained && v5 == 3 && !*((_BYTE *)v15 + 14))
  {
    *((_BYTE *)v15 + 14) = 1;
    objc_msgSend(WeakRetained, "sessionFailedBeforeRequestingConfiguration:", v15);
  }

}

- (void)updateEndpointState
{
  id *Property;
  const char *v4;
  id v5;
  const char *v6;
  id v7;
  SEL v8;
  SEL v9;
  id v10;
  id v11;
  SEL v12;
  const char *v13;
  id v14;
  id v15;
  void *v16;
  SEL v17;
  id self;

  if (a1)
  {
    Property = (id *)objc_getProperty(a1, a2, 336, 1);
    v5 = -[NEIKEv2IKESA copyTransport](Property, v4);
    self = v5;
    if (v5)
    {
      v7 = objc_getProperty(v5, v6, 16, 1);
      objc_setProperty_atomic(a1, v8, v7, 56);

      v10 = objc_getProperty(self, v9, 24, 1);
    }
    else
    {
      objc_setProperty_atomic(a1, v6, 0, 56);
      v10 = 0;
    }
    v11 = v10;
    objc_setProperty_atomic(a1, v12, v11, 64);

    v14 = self;
    if (self)
      v14 = objc_getProperty(self, v13, 32, 1);
    v15 = v14;
    objc_msgSend(v15, "interfaceName");
    v16 = (void *)objc_claimAutoreleasedReturnValue();
    objc_setProperty_atomic(a1, v17, v16, 72);

  }
}

_QWORD *__29__NEIKEv2Session_reportState__block_invoke(_QWORD *result)
{
  uint64_t v1;

  v1 = result[4];
  if (!v1 || (*(_BYTE *)(v1 + 12) & 1) == 0)
    return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(result[6] + 16))(result[6], result[7], result[5]);
  return result;
}

uint64_t __29__NEIKEv2Session_reportState__block_invoke_2(uint64_t result)
{
  uint64_t v1;

  v1 = *(_QWORD *)(result + 32);
  if (!v1 || (*(_BYTE *)(v1 + 12) & 1) == 0)
    return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)(result + 48) + 16))(*(_QWORD *)(result + 48), *(unsigned int *)(result + 64), *(_QWORD *)(result + 56), *(_QWORD *)(result + 40));
  return result;
}

void __25__NEIKEv2Session_connect__block_invoke(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  const char *v4;
  _BYTE *Property;
  id v6;
  _QWORD v7[5];
  uint8_t buf[4];
  uint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  ne_log_obj();
  v2 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v3 = *(_QWORD *)(a1 + 32);
    *(_DWORD *)buf = 138412290;
    v9 = v3;
    _os_log_impl(&dword_19BD16000, v2, OS_LOG_TYPE_DEFAULT, "Connect %@", buf, 0xCu);
  }

  Property = *(_BYTE **)(a1 + 32);
  if (Property)
  {
    if ((Property[11] & 1) != 0)
      return;
    Property = objc_getProperty(Property, v4, 336, 1);
  }
  v6 = -[NEIKEv2IKESA copyTransport]((id *)Property, v4);
  v7[0] = MEMORY[0x1E0C809B0];
  v7[1] = 3221225472;
  v7[2] = __25__NEIKEv2Session_connect__block_invoke_36;
  v7[3] = &unk_1E3CC41F0;
  v7[4] = *(_QWORD *)(a1 + 32);
  -[NEIKEv2Transport waitForTransport:]((uint64_t)v6, v7);

}

void __25__NEIKEv2Session_connect__block_invoke_36(uint64_t a1, const char *a2)
{
  id Property;
  const char *v4;
  _QWORD *v5;
  NSObject *v6;
  SEL v7;
  _BYTE *v8;
  const char *v9;
  const char *v10;
  id v11;
  char v12;
  const char *v13;
  void *v14;
  id v15;
  _BOOL4 v16;
  const char *v17;
  void *v18;
  _BOOL4 v19;
  NSObject *v20;
  SEL v21;
  id v22;
  int v23;
  const char *v24;
  NSObject *v25;
  SEL v26;
  id v27;
  id Error;
  NSObject *v29;
  const char *v30;
  ptrdiff_t v31;
  _BYTE *v32;
  NSObject *v33;
  SEL v34;
  SEL v35;
  const char *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  id ErrorInternal;
  const char *v44;
  const char *v45;
  void *v46;
  void *v47;
  char v48;
  const char *v49;
  id v50;
  void *v51;
  SEL v52;
  id v53;
  SEL v54;
  id v55;
  NSObject *v56;
  const char *v57;
  CFDataRef v58;
  CFDataRef v59;
  __SecIdentity *v60;
  __SecIdentity *v61;
  OSStatus v62;
  const char *v63;
  int IsValid;
  NSObject *v65;
  void *v66;
  void *v67;
  NSObject *v68;
  SEL v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  NSObject *v77;
  SEL v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  id v86;
  void *v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  const __CFDictionary *v93;
  OSStatus v94;
  void *v95;
  NSObject *v96;
  NSObject *v97;
  NSObject *v98;
  NSObject *v99;
  char v100;
  NSObject *v101;
  SEL v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  const char *v110;
  const char *v111;
  id v112;
  id v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  __SecIdentity *v117;
  const __CFArray *v118;
  const __CFArray *v119;
  const __CFDictionary *v120;
  OSStatus v121;
  void *v122;
  NSObject *v123;
  uint64_t v124;
  SEL v125;
  const char *v126;
  id v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  void *ErrorFailedToSend;
  const char *v136;
  const char *v137;
  NSObject *v138;
  SEL v139;
  id v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  void *v148;
  const char *v149;
  const char *v150;
  NSObject *v151;
  void *v152;
  NSObject *v153;
  void *v154;
  char *v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  id value;
  int v162;
  void *v163;
  uint64_t v164;
  uint64_t *v165;
  uint64_t v166;
  uint64_t (*v167)(uint64_t, uint64_t);
  void (*v168)(uint64_t);
  id v169;
  char v170;
  SecCertificateRef certificateRef[2];
  __int128 v172;
  __int128 v173;
  __int128 v174;
  uint8_t v175[8];
  CFTypeRef result;
  __int128 buf;
  void (*v178)(uint64_t, void *);
  void *v179;
  _QWORD *v180;
  _BYTE *v181;
  uint64_t *v182;
  SecCertificateRef v183[2];
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  __int128 v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  CFRange v192;

  v191 = *MEMORY[0x1E0C80C00];
  Property = *(id *)(a1 + 32);
  if (Property)
    Property = objc_getProperty(Property, a2, 336, 1);
  -[NEIKEv2IKESA resyncAddress]((id *)Property, a2);
  v5 = *(_QWORD **)(a1 + 32);
  if (v5)
  {
    v6 = objc_getProperty(*(id *)(a1 + 32), v4, 368, 1);
    dispatch_assert_queue_V2(v6);

    v8 = objc_getProperty(v5, v7, 336, 1);
    v164 = 0;
    v165 = &v164;
    v166 = 0x3032000000;
    v167 = __Block_byref_object_copy__8858;
    v168 = __Block_byref_object_dispose__8859;
    -[NEIKEv2Session firstChildSA](v5, v9);
    v169 = (id)objc_claimAutoreleasedReturnValue();
    if (!v8)
    {
      ne_log_obj();
      v29 = objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v29, OS_LOG_TYPE_FAULT))
        goto LABEL_24;
      LODWORD(buf) = 136315138;
      *(_QWORD *)((char *)&buf + 4) = "-[NEIKEv2Session(Exchange) initiateConnect]";
      v30 = "%s called with null ikeSA";
      goto LABEL_69;
    }
    v11 = objc_getProperty(v8, v10, 80, 1);
    v12 = objc_msgSend(v11, "requestChildlessSA");

    v14 = (void *)v165[5];
    if ((v12 & 1) != 0)
    {
      if (!v14)
      {
LABEL_11:
        ne_log_obj();
        v20 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf) = 138412290;
          *(_QWORD *)((char *)&buf + 4) = v5;
          _os_log_impl(&dword_19BD16000, v20, OS_LOG_TYPE_DEFAULT, "%@ Initiating IKEv2 connection", (uint8_t *)&buf, 0xCu);
        }

        v22 = objc_getProperty(v8, v21, 80, 1);
        v23 = objc_msgSend(v22, "serverMode");

        if (v23)
        {
          ne_log_obj();
          v25 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
          {
            LODWORD(buf) = 138412290;
            *(_QWORD *)((char *)&buf + 4) = v5;
            _os_log_error_impl(&dword_19BD16000, v25, OS_LOG_TYPE_ERROR, "%@ Cannot initiate connection while in server mode (connect)", (uint8_t *)&buf, 0xCu);
          }

          v27 = objc_getProperty(v5, v26, 336, 1);
          Error = (id)NEIKEv2CreateError(9);
          -[NEIKEv2IKESA setState:error:]((uint64_t)v27, 3uLL, Error);
LABEL_82:

          -[NEIKEv2Session reportState](v5, v110);
          -[NEIKEv2Session resetAll]((uint64_t)v5, v111);
          goto LABEL_83;
        }
        if ((v8[13] & 1) != 0)
        {
          v31 = 480;
        }
        else if ((v8[12] & 1) != 0)
        {
          v31 = 472;
        }
        else
        {
          v31 = 464;
        }
        v32 = objc_getProperty(v8, v24, v31, 1);
        if (!v32 || (v32[8] & 1) == 0)
        {
          ne_log_obj();
          v33 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
          {
            LODWORD(buf) = 138412290;
            *(_QWORD *)((char *)&buf + 4) = v5;
            _os_log_error_impl(&dword_19BD16000, v33, OS_LOG_TYPE_ERROR, "%@ Cannot initiate connection as transport is not connected (connect)", (uint8_t *)&buf, 0xCu);
          }

          v27 = objc_getProperty(v5, v34, 336, 1);
          Error = objc_getProperty(v8, v35, 56, 1);
          if (Error)
            ErrorInternal = objc_getProperty(v8, v36, 56, 1);
          else
            ErrorInternal = (id)NEIKEv2CreateErrorInternal(CFSTR("Transport is not connected (connect)"), (uint64_t)v36, v37, v38, v39, v40, v41, v42, v156);
          v67 = ErrorInternal;
          -[NEIKEv2IKESA setState:error:]((uint64_t)v27, 3uLL, ErrorInternal);

          goto LABEL_82;
        }
        -[NEIKEv2IKESA setState:error:]((uint64_t)v8, 1uLL, 0);
        -[NEIKEv2Session reportState](v5, v44);
        v46 = (void *)v165[5];
        if (v46)
        {
          -[NEIKEv2ChildSA configProposalsWithoutKEM]((id)v165[5], v45);
          v47 = (void *)objc_claimAutoreleasedReturnValue();
          v48 = -[NEIKEv2Session generateSPIForChild:proposals:](v5, v46, v47);

          if ((v48 & 1) == 0)
          {
            ne_log_obj();
            v77 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v77, OS_LOG_TYPE_ERROR))
            {
              LODWORD(buf) = 138412290;
              *(_QWORD *)((char *)&buf + 4) = v5;
              _os_log_error_impl(&dword_19BD16000, v77, OS_LOG_TYPE_ERROR, "%@ Failed to generate Child SA SPI (connect)", (uint8_t *)&buf, 0xCu);
            }

            v27 = objc_getProperty(v5, v78, 336, 1);
            Error = (id)NEIKEv2CreateErrorCrypto(CFSTR("Failed to generate Child SA SPI (connect)"), v79, v80, v81, v82, v83, v84, v85, v156);
            -[NEIKEv2IKESA setState:error:]((uint64_t)v27, 3uLL, Error);
            goto LABEL_82;
          }
        }
        if ((-[NEIKEv2IKESA generateInitialValues](v8, v45) & 1) == 0)
        {
          ne_log_obj();
          v68 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
          {
            LODWORD(buf) = 138412290;
            *(_QWORD *)((char *)&buf + 4) = v5;
            _os_log_error_impl(&dword_19BD16000, v68, OS_LOG_TYPE_ERROR, "%@ Failed to generate local crypto values (connect)", (uint8_t *)&buf, 0xCu);
          }

          v27 = objc_getProperty(v5, v69, 336, 1);
          Error = (id)NEIKEv2CreateErrorCrypto(CFSTR("Failed to generate local crypto values (connect)"), v70, v71, v72, v73, v74, v75, v76, v156);
          -[NEIKEv2IKESA setState:error:]((uint64_t)v27, 3uLL, Error);
          goto LABEL_82;
        }
        v50 = objc_getProperty(v8, v49, 88, 1);
        objc_msgSend(v50, "localCertificateReference");
        v51 = (void *)objc_claimAutoreleasedReturnValue();

        v53 = objc_getProperty(v8, v52, 88, 1);
        objc_msgSend(v53, "localCertificateKeyReference");
        v163 = (void *)objc_claimAutoreleasedReturnValue();

        v55 = objc_getProperty(v8, v54, 88, 1);
        v162 = objc_msgSend(v55, "localCertificateIsModernSystem");

        ne_log_obj();
        v56 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v56, OS_LOG_TYPE_DEBUG))
        {
          LODWORD(buf) = 138412290;
          *(_QWORD *)((char *)&buf + 4) = v51;
          _os_log_debug_impl(&dword_19BD16000, v56, OS_LOG_TYPE_DEBUG, "fetchLocalCertificateIdentity: certIdentityPersistentData %@", (uint8_t *)&buf, 0xCu);
        }

        if (v51)
        {
LABEL_38:
          v58 = +[NSData sensitiveDataWithData:](MEMORY[0x1E0C99D50], v51);
          v59 = +[NSData sensitiveDataWithData:](MEMORY[0x1E0C99D50], v163);
          v60 = (__SecIdentity *)+[NEIKEv2Crypto copySecIdentity:keyData:isModernSystem:]((uint64_t)NEIKEv2Crypto, v58, v59, v162);
          v61 = v60;
          if (v60)
          {
            certificateRef[0] = 0;
            v62 = SecIdentityCopyCertificate(v60, certificateRef);
            CFRelease(v61);
            if (!v62 && certificateRef[0])
            {
              IsValid = NECertificateDateIsValid((uint64_t)certificateRef[0]);
              if (certificateRef[0])
              {
                CFRelease(certificateRef[0]);
                certificateRef[0] = 0;
              }
              if (IsValid != 1)
              {
                if (IsValid == 3)
                {
                  ne_log_obj();
                  v151 = objc_claimAutoreleasedReturnValue();
                  if (os_log_type_enabled(v151, OS_LOG_TYPE_ERROR))
                  {
                    LOWORD(buf) = 0;
                    _os_log_error_impl(&dword_19BD16000, v151, OS_LOG_TYPE_ERROR, "local certificate is expired", (uint8_t *)&buf, 2u);
                  }

                  v152 = (void *)NEIKEv2CreateError(12);
                  -[NEIKEv2IKESA setState:error:]((uint64_t)v8, 3uLL, v152);

                }
                else if (IsValid == 2)
                {
                  ne_log_obj();
                  v65 = objc_claimAutoreleasedReturnValue();
                  if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
                  {
                    LOWORD(buf) = 0;
                    _os_log_error_impl(&dword_19BD16000, v65, OS_LOG_TYPE_ERROR, "local certificate is not yet valid", (uint8_t *)&buf, 2u);
                  }

                  v66 = (void *)NEIKEv2CreateError(11);
                  -[NEIKEv2IKESA setState:error:]((uint64_t)v8, 3uLL, v66);

                }
                else
                {
                  ne_log_obj();
                  v153 = objc_claimAutoreleasedReturnValue();
                  if (os_log_type_enabled(v153, OS_LOG_TYPE_ERROR))
                  {
                    v155 = off_1E3CC3DF8[IsValid - 1];
                    LODWORD(buf) = 136315138;
                    *(_QWORD *)((char *)&buf + 4) = v155;
                    _os_log_error_impl(&dword_19BD16000, v153, OS_LOG_TYPE_ERROR, "local certificate status %s", (uint8_t *)&buf, 0xCu);
                  }

                  v154 = (void *)NEIKEv2CreateError(13);
                  -[NEIKEv2IKESA setState:error:]((uint64_t)v8, 3uLL, v154);

                }
LABEL_78:
                v170 = 0;

                v100 = v170;
                if ((v100 & 1) == 0)
                {
LABEL_79:
                  ne_log_obj();
                  v101 = objc_claimAutoreleasedReturnValue();
                  if (os_log_type_enabled(v101, OS_LOG_TYPE_ERROR))
                  {
                    LODWORD(buf) = 138412290;
                    *(_QWORD *)((char *)&buf + 4) = v5;
                    _os_log_error_impl(&dword_19BD16000, v101, OS_LOG_TYPE_ERROR, "%@ Failed to fetch local certificate identity (connect)", (uint8_t *)&buf, 0xCu);
                  }

                  v27 = objc_getProperty(v5, v102, 336, 1);
                  Error = (id)NEIKEv2CreateErrorInternal(CFSTR("Failed to fetch local certificate identity (connect)"), v103, v104, v105, v106, v107, v108, v109, v156);
                  -[NEIKEv2IKESA setState:error:]((uint64_t)v27, 3uLL, Error);
                  goto LABEL_82;
                }
                goto LABEL_122;
              }
              objc_setProperty_atomic(v8, v63, v58, 264);
              objc_setProperty_atomic(v8, v125, v59, 272);
              v8[22] = v162;

LABEL_121:
LABEL_122:
              +[NEIKEv2IKESAInitPacket createIKESAInitForInitiatorIKESA:]((uint64_t)NEIKEv2IKESAInitPacket, v8);
              v29 = objc_claimAutoreleasedReturnValue();
              if (v29)
              {
                *(_QWORD *)&buf = MEMORY[0x1E0C809B0];
                *((_QWORD *)&buf + 1) = 3221225472;
                v178 = __43__NEIKEv2Session_Exchange__initiateConnect__block_invoke;
                v179 = &unk_1E3CC0FA0;
                v180 = v5;
                v181 = v8;
                v182 = &v164;
                if (-[NEIKEv2Session sendRequest:retry:replyHandler:]((uint64_t)v5, v29, &buf) == -1)
                {
                  v127 = objc_getProperty(v5, v126, 336, 1);
                  ErrorFailedToSend = (void *)NEIKEv2CreateErrorFailedToSend(CFSTR("initiator SA INIT"), v128, v129, v130, v131, v132, v133, v134, v156);
                  -[NEIKEv2IKESA setState:error:]((uint64_t)v127, 3uLL, ErrorFailedToSend);

                  -[NEIKEv2Session reportState](v5, v136);
                  -[NEIKEv2Session resetAll]((uint64_t)v5, v137);
                }

              }
              else
              {
                ne_log_obj();
                v138 = objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v138, OS_LOG_TYPE_ERROR))
                {
                  LODWORD(buf) = 138412290;
                  *(_QWORD *)((char *)&buf + 4) = v5;
                  _os_log_error_impl(&dword_19BD16000, v138, OS_LOG_TYPE_ERROR, "%@ Failed to create IKE SA Init packet (connect)", (uint8_t *)&buf, 0xCu);
                }

                v140 = objc_getProperty(v5, v139, 336, 1);
                v148 = (void *)NEIKEv2CreateErrorInternal(CFSTR("Failed to create IKE SA Init packet (connect)"), v141, v142, v143, v144, v145, v146, v147, v156);
                -[NEIKEv2IKESA setState:error:]((uint64_t)v140, 3uLL, v148);

                -[NEIKEv2Session reportState](v5, v149);
                -[NEIKEv2Session resetAll]((uint64_t)v5, v150);
                v29 = 0;
              }
              goto LABEL_24;
            }
            if (certificateRef[0])
            {
              CFRelease(certificateRef[0]);
              certificateRef[0] = 0;
            }
            ne_log_obj();
            v99 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v99, OS_LOG_TYPE_FAULT))
            {
              LOWORD(buf) = 0;
              _os_log_fault_impl(&dword_19BD16000, v99, OS_LOG_TYPE_FAULT, "SecIdentityCopyCertificate failed", (uint8_t *)&buf, 2u);
            }
          }
          else
          {
            ne_log_obj();
            v99 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v99, OS_LOG_TYPE_ERROR))
            {
              LOWORD(buf) = 0;
              _os_log_error_impl(&dword_19BD16000, v99, OS_LOG_TYPE_ERROR, "failed to get identity from persistent reference", (uint8_t *)&buf, 2u);
            }
          }

          goto LABEL_78;
        }
        v86 = objc_getProperty(v8, v57, 88, 1);
        objc_msgSend(v86, "localCertificateName");
        v87 = (void *)objc_claimAutoreleasedReturnValue();

        if (!v87)
          goto LABEL_121;
        value = v87;
        objc_opt_self();
        objc_opt_self();
        v88 = *MEMORY[0x1E0CD6CB0];
        v89 = *MEMORY[0x1E0CD7028];
        v184 = *MEMORY[0x1E0CD6C98];
        v185 = v89;
        v90 = *MEMORY[0x1E0C9AE50];
        *(_QWORD *)&v188 = v88;
        *((_QWORD *)&v188 + 1) = v90;
        v91 = *MEMORY[0x1E0CD6F38];
        v92 = *MEMORY[0x1E0CD70C0];
        v186 = *MEMORY[0x1E0CD6F30];
        v187 = v92;
        v159 = v92;
        v160 = v90;
        v189 = v91;
        v190 = v90;
        objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v188, &v184, 4);
        v93 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue();
        result = 0;
        v94 = SecItemCopyMatching(v93, &result);
        v95 = (void *)result;
        if (v94 || !objc_msgSend((id)result, "count"))
        {
          ne_log_obj();
          v96 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v96, OS_LOG_TYPE_ERROR))
          {
            LODWORD(v183[0]) = 67109120;
            HIDWORD(v183[0]) = v94;
            _os_log_error_impl(&dword_19BD16000, v96, OS_LOG_TYPE_ERROR, "failed to retrieve all certificate identities (%d)", (uint8_t *)v183, 8u);
          }

        }
        else
        {
          v112 = v95;

          if (v112)
          {
            v173 = 0u;
            v174 = 0u;
            *(_OWORD *)certificateRef = 0u;
            v172 = 0u;
            v113 = v112;
            v114 = objc_msgSend(v113, "countByEnumeratingWithState:objects:count:", certificateRef, &buf, 16);
            if (v114)
            {
              v115 = *(_QWORD *)v172;
              v157 = *MEMORY[0x1E0CD70E8];
              v158 = *MEMORY[0x1E0CD7020];
              v156 = 136315138;
              do
              {
                v116 = 0;
                do
                {
                  if (*(_QWORD *)v172 != v115)
                    objc_enumerationMutation(v113);
                  v117 = (__SecIdentity *)*((_QWORD *)certificateRef[1] + v116);
                  v183[0] = 0;
                  if (SecIdentityCopyCertificate(v117, v183))
                  {
                    if (v183[0])
                      CFRelease(v183[0]);
                  }
                  else
                  {
                    v118 = (const __CFArray *)SecCertificateCopyCommonNames();
                    v119 = v118;
                    if (v118)
                    {
                      v192.length = CFArrayGetCount(v118);
                      v192.location = 0;
                      if (CFArrayContainsValue(v119, v192, value))
                      {
                        objc_opt_self();
                        if (v117)
                        {
                          v184 = v158;
                          v185 = v157;
                          *(_QWORD *)&v188 = v160;
                          *((_QWORD *)&v188 + 1) = v117;
                          v186 = v159;
                          v189 = v160;
                          objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v188, &v184, 3);
                          v120 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue();
                          result = 0;
                          v121 = SecItemCopyMatching(v120, &result);
                          v122 = (void *)result;
                          if (v121)
                          {
                            ne_log_obj();
                            v123 = objc_claimAutoreleasedReturnValue();
                            if (os_log_type_enabled(v123, OS_LOG_TYPE_FAULT))
                            {
                              *(_WORD *)v175 = 0;
                              _os_log_fault_impl(&dword_19BD16000, v123, OS_LOG_TYPE_FAULT, "SecItemCopyMatching failed", v175, 2u);
                            }

                            v51 = 0;
                          }
                          else
                          {
                            v51 = (id)result;
                          }

                        }
                        else
                        {
                          ne_log_obj();
                          v120 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue();
                          if (os_log_type_enabled((os_log_t)v120, OS_LOG_TYPE_FAULT))
                          {
                            LODWORD(v188) = 136315138;
                            *(_QWORD *)((char *)&v188 + 4) = "+[NEIKEv2Crypto copyPersistentDataForIdentity:]";
                            _os_log_fault_impl(&dword_19BD16000, (os_log_t)v120, OS_LOG_TYPE_FAULT, "%s called with null identity", (uint8_t *)&v188, 0xCu);
                          }
                          v51 = 0;
                        }

                      }
                      else
                      {
                        v51 = 0;
                      }
                      CFRelease(v119);
                    }
                    else
                    {
                      v51 = 0;
                    }
                    if (v183[0])
                      CFRelease(v183[0]);
                    if (v51)
                      goto LABEL_118;
                  }
                  ++v116;
                }
                while (v114 != v116);
                v124 = objc_msgSend(v113, "countByEnumeratingWithState:objects:count:", certificateRef, &buf, 16);
                v114 = v124;
              }
              while (v124);
            }
            v51 = 0;
LABEL_118:

            if (v51)
            {

              goto LABEL_38;
            }
LABEL_65:
            ne_log_obj();
            v98 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v98, OS_LOG_TYPE_ERROR))
            {
              LODWORD(buf) = 138412290;
              *(_QWORD *)((char *)&buf + 4) = value;
              _os_log_error_impl(&dword_19BD16000, v98, OS_LOG_TYPE_ERROR, "failed to fetch persistent reference for Cert %@", (uint8_t *)&buf, 0xCu);
            }

            goto LABEL_79;
          }
        }
        ne_log_obj();
        v97 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v97, OS_LOG_TYPE_FAULT))
        {
          LOWORD(v188) = 0;
          _os_log_fault_impl(&dword_19BD16000, v97, OS_LOG_TYPE_FAULT, "ikev2_crypto_copy_all_cert_identities failed", (uint8_t *)&v188, 2u);
        }

        goto LABEL_65;
      }
    }
    else if (!v14)
    {
      ne_log_obj();
      v29 = objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v29, OS_LOG_TYPE_FAULT))
        goto LABEL_24;
      LODWORD(buf) = 136315138;
      *(_QWORD *)((char *)&buf + 4) = "-[NEIKEv2Session(Exchange) initiateConnect]";
      v30 = "%s called with null childSA";
      goto LABEL_69;
    }
    v15 = objc_getProperty(v14, v13, 48, 1);
    v16 = v15 == 0;

    if (v16)
    {
      ne_log_obj();
      v29 = objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v29, OS_LOG_TYPE_FAULT))
        goto LABEL_24;
      LODWORD(buf) = 136315138;
      *(_QWORD *)((char *)&buf + 4) = "-[NEIKEv2Session(Exchange) initiateConnect]";
      v30 = "%s called with null childSA.configuration";
    }
    else
    {
      -[NEIKEv2ChildSA configProposalsWithoutKEM]((id)v165[5], v17);
      v18 = (void *)objc_claimAutoreleasedReturnValue();
      v19 = v18 == 0;

      if (!v19)
        goto LABEL_11;
      ne_log_obj();
      v29 = objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v29, OS_LOG_TYPE_FAULT))
      {
LABEL_24:

LABEL_83:
        _Block_object_dispose(&v164, 8);

        return;
      }
      LODWORD(buf) = 136315138;
      *(_QWORD *)((char *)&buf + 4) = "-[NEIKEv2Session(Exchange) initiateConnect]";
      v30 = "%s called with null childSA.configProposalsWithoutKEM";
    }
LABEL_69:
    _os_log_fault_impl(&dword_19BD16000, v29, OS_LOG_TYPE_FAULT, v30, (uint8_t *)&buf, 0xCu);
    goto LABEL_24;
  }
}

- (NSObject)initWithIKEConfig:(void *)a3 firstChildConfig:(void *)a4 sessionConfig:(void *)a5 queue:(id *)a6 ipsecInterface:(void *)a7 ikeSocketHandler:(void *)a8 saSession:(char)a9 shouldOwnSASession:(void *)a10 packetDelegate:(void *)a11 transport:(void *)a12 configurationDelegate:
{
  id v18;
  id v19;
  id v20;
  id v21;
  id v22;
  NSObject *v23;
  const char *v24;
  NSObject *v25;
  unint64_t v26;
  NSObject *v27;
  objc_class *v28;
  NSObject *v29;
  SEL v30;
  NEIKEv2IKESA *v31;
  SEL v32;
  id v33;
  uint64_t v34;
  _QWORD *v35;
  NSObject *v36;
  SEL v37;
  SEL v38;
  const char *v39;
  id *v40;
  const char *v41;
  id v42;
  NSObject *v43;
  int v44;
  const char *v45;
  id v46;
  SEL v47;
  SEL v48;
  const char *v49;
  void *v50;
  _BOOL4 v51;
  id v52;
  SEL v53;
  SEL v54;
  id v55;
  SEL v56;
  SEL v57;
  id v58;
  SEL v59;
  SEL v60;
  id v61;
  SEL v62;
  SEL v63;
  id v64;
  SEL v65;
  SEL v66;
  id v67;
  SEL v68;
  SEL v69;
  id v70;
  SEL v71;
  SEL v72;
  id v73;
  SEL v74;
  SEL v75;
  const char *v76;
  SEL v77;
  id v78;
  SEL v79;
  id v80;
  SEL v81;
  id v82;
  NEIKEv2RTT *v83;
  SEL v84;
  NSObject *v85;
  NSObject *v86;
  const char *v87;
  NSObject *v89;
  id v92;
  id v93;
  id v94;
  id v95;
  id newValue;
  void *v97;
  _QWORD v98[4];
  NSObject *v99;
  _QWORD v100[4];
  id v101;
  id location;
  objc_super v103;
  uint8_t buf[4];
  const char *v105;
  uint64_t v106;

  v106 = *MEMORY[0x1E0C80C00];
  v18 = a2;
  v93 = a3;
  v94 = a4;
  v19 = a5;
  newValue = a7;
  v20 = a8;
  v21 = a10;
  v95 = a11;
  v22 = a12;
  v92 = v20;
  v97 = v18;
  if (a1)
  {
    if (v20)
    {
      v103.receiver = a1;
      v103.super_class = (Class)NEIKEv2Session;
      v23 = -[NSObject init](&v103, sel_init);
      v25 = v23;
      if (v23)
      {
        LODWORD(v23[2].isa) = -1;
        HIDWORD(v23[2].isa) = -1;
        LODWORD(v23[3].isa) = -1;
        do
          v26 = __ldxr(&sNEIKEv2SessionIndex);
        while (__stxr(v26 + 1, &sNEIKEv2SessionIndex));
        v23[39].isa = (Class)v26;
        objc_setProperty_atomic_copy(v23, v24, newValue, 160);
        if (v22)
          objc_storeWeak((id *)&v25[43].isa, v22);
        v27 = v25;
        if (v21)
        {
          objc_storeWeak((id *)&v25[44].isa, v21);
          v27 = v25;
        }
        if (a6)
        {
          if (a6[32] == (id)2)
          {
            v28 = (objc_class *)CFRetain(a6);
            v27 = v25;
            v25[41].isa = v28;
          }
          else
          {
            ne_log_obj();
            v29 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v29, OS_LOG_TYPE_FAULT))
            {
              v87 = (const char *)a6[32];
              *(_DWORD *)buf = 134217984;
              v105 = v87;
              _os_log_fault_impl(&dword_19BD16000, v29, OS_LOG_TYPE_FAULT, "Passed in virtual interface of bad type %lld", buf, 0xCu);
            }

            v27 = v25;
          }
        }
        objc_storeStrong((id *)&v27[48].isa, a2);
        objc_setProperty_atomic(v25, v30, v19, 368);
        objc_initWeak(&location, v25);
        v31 = [NEIKEv2IKESA alloc];
        v33 = objc_getProperty(v25, v32, 160, 1);
        v34 = MEMORY[0x1E0C809B0];
        if (v33)
        {
          v100[0] = MEMORY[0x1E0C809B0];
          v100[1] = 3221225472;
          v100[2] = __181__NEIKEv2Session_initWithIKEConfig_firstChildConfig_sessionConfig_queue_ipsecInterface_ikeSocketHandler_saSession_shouldOwnSASession_packetDelegate_transport_configurationDelegate___block_invoke;
          v100[3] = &unk_1E3CC1748;
          a6 = &v101;
          objc_copyWeak(&v101, &location);
          v35 = v100;
        }
        else
        {
          v35 = 0;
        }
        v36 = -[NEIKEv2IKESA initIKESAWithConfiguration:sessionConfiguration:queue:initialTransport:transportDelegate:socketGetBlock:packetDelegate:configurationDelegate:ikeSessionUniqueIndex:](&v31->super, v97, v94, v19, v95, v25, v35, v21, v22, v25[39].isa);
        objc_setProperty_atomic(v25, v37, v36, 336);

        if (!objc_getProperty(v25, v38, 336, 1))
        {
          ne_log_obj();
          v85 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v85, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 138412290;
            v105 = (const char *)v25;
            _os_log_error_impl(&dword_19BD16000, v85, OS_LOG_TYPE_ERROR, "%@ failed to create IKE SA", buf, 0xCu);
          }
          a1 = 0;
          goto LABEL_68;
        }
        v40 = (id *)objc_getProperty(v25, v39, 336, 1);
        v42 = -[NEIKEv2IKESA copyTransport](v40, v41);
        v98[0] = v34;
        v98[1] = 3221225472;
        v98[2] = __181__NEIKEv2Session_initWithIKEConfig_firstChildConfig_sessionConfig_queue_ipsecInterface_ikeSocketHandler_saSession_shouldOwnSASession_packetDelegate_transport_configurationDelegate___block_invoke_31;
        v98[3] = &unk_1E3CC41F0;
        v43 = v25;
        v99 = v43;
        -[NEIKEv2Transport waitForTransport:]((uint64_t)v42, v98);

        v44 = objc_msgSend(v97, "serverMode");
        LOBYTE(v43[1].isa) = v44;
        if (v44)
          objc_setProperty_atomic(v43, v45, v93, 168);
        v46 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
        objc_setProperty_atomic(v43, v47, v46, 288);

        if (objc_getProperty(v43, v48, 288, 1))
        {
          if (v93
            && (-[NEIKEv2Session addFirstChild:](v43, v93),
                -[NEIKEv2Session firstChildSA](v43, v49),
                v50 = (void *)objc_claimAutoreleasedReturnValue(),
                v51 = v50 == 0,
                v50,
                v51))
          {
            ne_log_obj();
            v86 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v86, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)buf = 136315138;
              v105 = "-[NEIKEv2Session initWithIKEConfig:firstChildConfig:sessionConfig:queue:ipsecInterface:ikeSocketHan"
                     "dler:saSession:shouldOwnSASession:packetDelegate:transport:configurationDelegate:]";
              _os_log_fault_impl(&dword_19BD16000, v86, OS_LOG_TYPE_FAULT, "%s called with null self.firstChildSA", buf, 0xCu);
            }
          }
          else
          {
            v52 = objc_alloc_init(MEMORY[0x1E0C99E08]);
            objc_setProperty_atomic(v43, v53, v52, 184);

            if (objc_getProperty(v43, v54, 184, 1))
            {
              v55 = objc_alloc_init(MEMORY[0x1E0C99E08]);
              objc_setProperty_atomic(v43, v56, v55, 192);

              if (objc_getProperty(v43, v57, 192, 1))
              {
                v58 = objc_alloc_init(MEMORY[0x1E0C99E08]);
                objc_setProperty_atomic(v43, v59, v58, 216);

                if (objc_getProperty(v43, v60, 216, 1))
                {
                  v61 = objc_alloc_init(MEMORY[0x1E0C99E08]);
                  objc_setProperty_atomic(v43, v62, v61, 224);

                  if (objc_getProperty(v43, v63, 224, 1))
                  {
                    v64 = objc_alloc_init(MEMORY[0x1E0C99E08]);
                    objc_setProperty_atomic(v43, v65, v64, 232);

                    if (objc_getProperty(v43, v66, 232, 1))
                    {
                      v67 = objc_alloc_init(MEMORY[0x1E0C99E08]);
                      objc_setProperty_atomic(v43, v68, v67, 240);

                      if (objc_getProperty(v43, v69, 240, 1))
                      {
                        v70 = objc_alloc_init(MEMORY[0x1E0C99E08]);
                        objc_setProperty_atomic(v43, v71, v70, 248);

                        if (objc_getProperty(v43, v72, 248, 1))
                        {
                          v73 = objc_alloc_init(MEMORY[0x1E0C99E08]);
                          objc_setProperty_atomic(v43, v74, v73, 256);

                          if (objc_getProperty(v43, v75, 256, 1))
                          {
                            BYTE1(v43[1].isa) = a9;
                            objc_setProperty_atomic(v43, v76, v92, 176);
                            v78 = objc_getProperty(v43, v77, 176, 1);
                            objc_msgSend(v78, "setDelegate:", v43);

                            v80 = objc_getProperty(v43, v79, 368, 1);
                            v82 = objc_getProperty(v43, v81, 176, 1);
                            objc_msgSend(v82, "setDelegateQueue:", v80);

                            v83 = objc_alloc_init(NEIKEv2RTT);
                            objc_setProperty_atomic(v43, v84, v83, 360);

                            a1 = v43;
LABEL_67:
                            v85 = v99;
LABEL_68:

                            if (v33)
                              objc_destroyWeak(a6);
                            objc_destroyWeak(&location);
                            goto LABEL_71;
                          }
                          ne_log_obj();
                          v86 = objc_claimAutoreleasedReturnValue();
                          if (os_log_type_enabled(v86, OS_LOG_TYPE_FAULT))
                          {
                            *(_DWORD *)buf = 136315138;
                            v105 = "-[NEIKEv2Session initWithIKEConfig:firstChildConfig:sessionConfig:queue:ipsecInterfac"
                                   "e:ikeSocketHandler:saSession:shouldOwnSASession:packetDelegate:transport:configurationDelegate:]";
                            _os_log_fault_impl(&dword_19BD16000, v86, OS_LOG_TYPE_FAULT, "%s called with null self.replyFragmentMaps", buf, 0xCu);
                          }
                        }
                        else
                        {
                          ne_log_obj();
                          v86 = objc_claimAutoreleasedReturnValue();
                          if (os_log_type_enabled(v86, OS_LOG_TYPE_FAULT))
                          {
                            *(_DWORD *)buf = 136315138;
                            v105 = "-[NEIKEv2Session initWithIKEConfig:firstChildConfig:sessionConfig:queue:ipsecInterfac"
                                   "e:ikeSocketHandler:saSession:shouldOwnSASession:packetDelegate:transport:configurationDelegate:]";
                            _os_log_fault_impl(&dword_19BD16000, v86, OS_LOG_TYPE_FAULT, "%s called with null self.requestFragmentMaps", buf, 0xCu);
                          }
                        }
                      }
                      else
                      {
                        ne_log_obj();
                        v86 = objc_claimAutoreleasedReturnValue();
                        if (os_log_type_enabled(v86, OS_LOG_TYPE_FAULT))
                        {
                          *(_DWORD *)buf = 136315138;
                          v105 = "-[NEIKEv2Session initWithIKEConfig:firstChildConfig:sessionConfig:queue:ipsecInterface:"
                                 "ikeSocketHandler:saSession:shouldOwnSASession:packetDelegate:transport:configurationDelegate:]";
                          _os_log_fault_impl(&dword_19BD16000, v86, OS_LOG_TYPE_FAULT, "%s called with null self.receivedReplies", buf, 0xCu);
                        }
                      }
                    }
                    else
                    {
                      ne_log_obj();
                      v86 = objc_claimAutoreleasedReturnValue();
                      if (os_log_type_enabled(v86, OS_LOG_TYPE_FAULT))
                      {
                        *(_DWORD *)buf = 136315138;
                        v105 = "-[NEIKEv2Session initWithIKEConfig:firstChildConfig:sessionConfig:queue:ipsecInterface:ik"
                               "eSocketHandler:saSession:shouldOwnSASession:packetDelegate:transport:configurationDelegate:]";
                        _os_log_fault_impl(&dword_19BD16000, v86, OS_LOG_TYPE_FAULT, "%s called with null self.receivedRequests", buf, 0xCu);
                      }
                    }
                  }
                  else
                  {
                    ne_log_obj();
                    v86 = objc_claimAutoreleasedReturnValue();
                    if (os_log_type_enabled(v86, OS_LOG_TYPE_FAULT))
                    {
                      *(_DWORD *)buf = 136315138;
                      v105 = "-[NEIKEv2Session initWithIKEConfig:firstChildConfig:sessionConfig:queue:ipsecInterface:ikeS"
                             "ocketHandler:saSession:shouldOwnSASession:packetDelegate:transport:configurationDelegate:]";
                      _os_log_fault_impl(&dword_19BD16000, v86, OS_LOG_TYPE_FAULT, "%s called with null self.sentReplies", buf, 0xCu);
                    }
                  }
                }
                else
                {
                  ne_log_obj();
                  v86 = objc_claimAutoreleasedReturnValue();
                  if (os_log_type_enabled(v86, OS_LOG_TYPE_FAULT))
                  {
                    *(_DWORD *)buf = 136315138;
                    v105 = "-[NEIKEv2Session initWithIKEConfig:firstChildConfig:sessionConfig:queue:ipsecInterface:ikeSoc"
                           "ketHandler:saSession:shouldOwnSASession:packetDelegate:transport:configurationDelegate:]";
                    _os_log_fault_impl(&dword_19BD16000, v86, OS_LOG_TYPE_FAULT, "%s called with null self.sentRequests", buf, 0xCu);
                  }
                }
              }
              else
              {
                ne_log_obj();
                v86 = objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v86, OS_LOG_TYPE_FAULT))
                {
                  *(_DWORD *)buf = 136315138;
                  v105 = "-[NEIKEv2Session initWithIKEConfig:firstChildConfig:sessionConfig:queue:ipsecInterface:ikeSocke"
                         "tHandler:saSession:shouldOwnSASession:packetDelegate:transport:configurationDelegate:]";
                  _os_log_fault_impl(&dword_19BD16000, v86, OS_LOG_TYPE_FAULT, "%s called with null self.databaseSAs", buf, 0xCu);
                }
              }
            }
            else
            {
              ne_log_obj();
              v86 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v86, OS_LOG_TYPE_FAULT))
              {
                *(_DWORD *)buf = 136315138;
                v105 = "-[NEIKEv2Session initWithIKEConfig:firstChildConfig:sessionConfig:queue:ipsecInterface:ikeSocketH"
                       "andler:saSession:shouldOwnSASession:packetDelegate:transport:configurationDelegate:]";
                _os_log_fault_impl(&dword_19BD16000, v86, OS_LOG_TYPE_FAULT, "%s called with null self.databaseLarvalSAs", buf, 0xCu);
              }
            }
          }
        }
        else
        {
          ne_log_obj();
          v86 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v86, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)buf = 136315138;
            v105 = "-[NEIKEv2Session initWithIKEConfig:firstChildConfig:sessionConfig:queue:ipsecInterface:ikeSocketHandl"
                   "er:saSession:shouldOwnSASession:packetDelegate:transport:configurationDelegate:]";
            _os_log_fault_impl(&dword_19BD16000, v86, OS_LOG_TYPE_FAULT, "%s called with null self.childSAs", buf, 0xCu);
          }
        }

        a1 = 0;
        goto LABEL_67;
      }
      ne_log_obj();
      v25 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_fault_impl(&dword_19BD16000, v25, OS_LOG_TYPE_FAULT, "[super init] failed", buf, 2u);
      }
    }
    else
    {
      v25 = a1;
      ne_log_obj();
      v89 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v89, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136315138;
        v105 = "-[NEIKEv2Session initWithIKEConfig:firstChildConfig:sessionConfig:queue:ipsecInterface:ikeSocketHandler:s"
               "aSession:shouldOwnSASession:packetDelegate:transport:configurationDelegate:]";
        _os_log_fault_impl(&dword_19BD16000, v89, OS_LOG_TYPE_FAULT, "%s called with null saSession", buf, 0xCu);
      }

    }
    a1 = 0;
LABEL_71:

  }
  return a1;
}

void __181__NEIKEv2Session_initWithIKEConfig_firstChildConfig_sessionConfig_queue_ipsecInterface_ikeSocketHandler_saSession_shouldOwnSASession_packetDelegate_transport_configurationDelegate___block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int *a5)
{
  _BYTE *WeakRetained;
  const char *v10;
  void *v11;
  const char *v12;
  id Property;
  id v14;
  int v15;
  NSObject *v16;
  int v17;
  int v18;
  const char *v19;
  __int16 v20;
  int v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v11 = WeakRetained;
  if (WeakRetained && (WeakRetained[12] & 1) == 0 && objc_getProperty(WeakRetained, v10, 160, 1))
  {
    Property = objc_getProperty(v11, v12, 160, 1);
    v14 = Property;
    v15 = (*((uint64_t (**)(id, uint64_t, uint64_t, uint64_t, uint64_t))Property + 2))(v14, objc_msgSend(v11, "clientCallbackInfo"), a2, a3, a4);

    *a5 = v15;
    ne_log_obj();
    v16 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
    {
      v17 = *a5;
      v18 = 136315394;
      v19 = "-[NEIKEv2Session initWithIKEConfig:firstChildConfig:sessionConfig:queue:ipsecInterface:ikeSocketHandler:saSe"
            "ssion:shouldOwnSASession:packetDelegate:transport:configurationDelegate:]_block_invoke";
      v20 = 1024;
      v21 = v17;
      _os_log_debug_impl(&dword_19BD16000, v16, OS_LOG_TYPE_DEBUG, "%s: Get socket %d\n", (uint8_t *)&v18, 0x12u);
    }

  }
}

void __181__NEIKEv2Session_initWithIKEConfig_firstChildConfig_sessionConfig_queue_ipsecInterface_ikeSocketHandler_saSession_shouldOwnSASession_packetDelegate_transport_configurationDelegate___block_invoke_31(uint64_t a1, const char *a2)
{
  -[NEIKEv2Session updateEndpointState](*(void **)(a1 + 32), a2);
}

- (void)addFirstChild:(void *)a1
{
  const char *v3;
  id v4;
  void *v5;
  NSObject *v6;
  NEIKEv2ChildSA *v7;
  const char *v8;
  unsigned int v9;
  int v10;
  id Property;
  NSObject *v12;
  const char *v13;
  NSObject *v14;
  int v15;
  const char *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v4 = a2;
  if (a1)
  {
    -[NEIKEv2Session firstChildSA](a1, v3);
    v5 = (void *)objc_claimAutoreleasedReturnValue();

    if (v5)
    {
      ne_log_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        v15 = 138412290;
        v16 = (const char *)a1;
        _os_log_error_impl(&dword_19BD16000, v6, OS_LOG_TYPE_ERROR, "%@ Already have a first child SA, ignoring request", (uint8_t *)&v15, 0xCu);
      }
    }
    else
    {
      v7 = [NEIKEv2ChildSA alloc];
      objc_opt_self();
      do
        v9 = __ldxr((unsigned int *)&getNewChildSAID_nextChildSAID);
      while (__stxr(v9 + 1, (unsigned int *)&getNewChildSAID_nextChildSAID));
      v10 = v9;
      if (!v9)
      {
        do
          v10 = __ldxr((unsigned int *)&getNewChildSAID_nextChildSAID);
        while (__stxr(v10 + 1, (unsigned int *)&getNewChildSAID_nextChildSAID));
      }
      Property = objc_getProperty(a1, v8, 336, 1);
      v12 = -[NEIKEv2ChildSA initWithConfiguration:childID:ikeSA:](&v7->super, v4, v10, Property);
      if (v12)
      {
        v6 = v12;
        objc_msgSend(objc_getProperty(a1, v13, 288, 1), "addObject:", v12);
      }
      else
      {
        ne_log_obj();
        v14 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT))
        {
          v15 = 136315138;
          v16 = "-[NEIKEv2Session addFirstChild:]";
          _os_log_fault_impl(&dword_19BD16000, v14, OS_LOG_TYPE_FAULT, "%s called with null firstChildSA", (uint8_t *)&v15, 0xCu);
        }

        v6 = 0;
      }
    }

  }
}

- (NSObject)initWithIKEConfig:(NSObject *)a1 configurationDelegate:(void *)a2 queue:(void *)a3 saSession:(void *)a4 shouldCopySASession:(void *)a5 transport:(void *)a6 packetDelegate:(void *)a7
{
  id v13;
  id v14;
  id v15;
  id v16;
  id v17;
  id v18;
  void *v19;
  NSObject *v20;
  NSObject *v22;
  const char *v23;
  uint8_t buf[4];
  const char *v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v13 = a2;
  v14 = a3;
  v15 = a4;
  v16 = a5;
  v17 = a6;
  v18 = a7;
  if (!a1)
  {
    v20 = 0;
    goto LABEL_7;
  }
  if (!v13)
  {
    ne_log_obj();
    v22 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136315138;
      v25 = "-[NEIKEv2Session initWithIKEConfig:configurationDelegate:queue:saSession:shouldCopySASession:transport:packetDelegate:]";
      v23 = "%s called with null ikeConfig";
      goto LABEL_15;
    }
LABEL_13:

    v20 = 0;
    goto LABEL_6;
  }
  if (!v16)
  {
    ne_log_obj();
    v22 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136315138;
      v25 = "-[NEIKEv2Session initWithIKEConfig:configurationDelegate:queue:saSession:shouldCopySASession:transport:packetDelegate:]";
      v23 = "%s called with null saSession";
      goto LABEL_15;
    }
    goto LABEL_13;
  }
  if (!v15)
  {
    ne_log_obj();
    v22 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_FAULT))
      goto LABEL_13;
    *(_DWORD *)buf = 136315138;
    v25 = "-[NEIKEv2Session initWithIKEConfig:configurationDelegate:queue:saSession:shouldCopySASession:transport:packetDelegate:]";
    v23 = "%s called with null queue";
LABEL_15:
    _os_log_fault_impl(&dword_19BD16000, v22, OS_LOG_TYPE_FAULT, v23, buf, 0xCu);
    goto LABEL_13;
  }
  v19 = (void *)objc_msgSend(v16, "copyEmptySASession");
  a1 = -[NEIKEv2Session initWithIKEConfig:firstChildConfig:sessionConfig:queue:ipsecInterface:ikeSocketHandler:saSession:shouldOwnSASession:packetDelegate:transport:configurationDelegate:](a1, v13, 0, 0, v15, 0, 0, v19, 1, v18, v17, v14);

  v20 = a1;
LABEL_6:

LABEL_7:
  return v20;
}

- (NSObject)initWithIKEConfig:(void *)a3 configurationDelegate:(void *)a4 queue:(void *)a5 kernelSASessionName:(void *)a6 transport:(void *)a7 packetDelegate:
{
  id v13;
  id v14;
  id v15;
  id v16;
  id v17;
  id v18;
  NEIPSecSAKernelSession *v19;
  NSObject *v20;
  NSObject *v22;
  const char *v23;
  uint8_t buf[4];
  const char *v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v13 = a2;
  v14 = a3;
  v15 = a4;
  v16 = a5;
  v17 = a6;
  v18 = a7;
  if (!a1)
  {
    v20 = 0;
    goto LABEL_7;
  }
  if (!v13)
  {
    ne_log_obj();
    v22 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136315138;
      v25 = "-[NEIKEv2Session initWithIKEConfig:configurationDelegate:queue:kernelSASessionName:transport:packetDelegate:]";
      v23 = "%s called with null ikeConfig";
      goto LABEL_15;
    }
LABEL_13:

    v20 = 0;
    goto LABEL_6;
  }
  if (!v16)
  {
    ne_log_obj();
    v22 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136315138;
      v25 = "-[NEIKEv2Session initWithIKEConfig:configurationDelegate:queue:kernelSASessionName:transport:packetDelegate:]";
      v23 = "%s called with null kernelSASessionName";
      goto LABEL_15;
    }
    goto LABEL_13;
  }
  if (!v15)
  {
    ne_log_obj();
    v22 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_FAULT))
      goto LABEL_13;
    *(_DWORD *)buf = 136315138;
    v25 = "-[NEIKEv2Session initWithIKEConfig:configurationDelegate:queue:kernelSASessionName:transport:packetDelegate:]";
    v23 = "%s called with null queue";
LABEL_15:
    _os_log_fault_impl(&dword_19BD16000, v22, OS_LOG_TYPE_FAULT, v23, buf, 0xCu);
    goto LABEL_13;
  }
  v19 = -[NEIPSecSAKernelSession initWithName:delegate:]([NEIPSecSAKernelSession alloc], "initWithName:delegate:", v16, 0);
  a1 = -[NEIKEv2Session initWithIKEConfig:firstChildConfig:sessionConfig:queue:ipsecInterface:ikeSocketHandler:saSession:shouldOwnSASession:packetDelegate:transport:configurationDelegate:](a1, v13, 0, 0, v15, 0, 0, v19, 1, v18, v17, v14);

  v20 = a1;
LABEL_6:

LABEL_7:
  return v20;
}

- (void)removeFirstChild
{
  void *v3;
  SEL v4;
  const void *v5;
  NSObject *v6;
  int v7;
  uint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    -[NEIKEv2Session firstChildSA]((void *)a1, a2);
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    if (v3)
    {
      -[NEIKEv2Session resetChild:]((char *)a1, v3);
      objc_msgSend(objc_getProperty((id)a1, v4, 288, 1), "removeObject:", v3);
      if ((*(_BYTE *)(a1 + 10) & 1) != 0)
      {
        v5 = *(const void **)(a1 + 328);
        if (v5)
        {
          CFRelease(v5);
          *(_QWORD *)(a1 + 328) = 0;
        }
        *(_BYTE *)(a1 + 10) = 0;
      }
    }
    else
    {
      ne_log_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        v7 = 138412290;
        v8 = a1;
        _os_log_error_impl(&dword_19BD16000, v6, OS_LOG_TYPE_ERROR, "%@ No first child SA, ignoring request", (uint8_t *)&v7, 0xCu);
      }

    }
  }
}

- (void)resetChild:(char *)a1
{
  id v3;
  NSObject *v4;
  NSObject *v5;
  _BYTE *v6;
  NSObject *v7;
  const char *v8;
  id Property;
  SEL v10;
  id v11;
  id v12;
  const char *v13;
  void *v14;
  SEL v15;
  SEL v16;
  id v17;
  id v18;
  id v19;
  id v20;
  const char *v21;
  void *v22;
  SEL v23;
  SEL v24;
  id v25;
  id v26;
  const char *v27;
  int v28;
  const char *v29;
  __int16 v30;
  id v31;
  __int16 v32;
  _BYTE *v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  if (a1)
  {
    ne_log_obj();
    v4 = objc_claimAutoreleasedReturnValue();
    v5 = v4;
    if (v3)
    {
      if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
      {
        v28 = 138412546;
        v29 = a1;
        v30 = 2112;
        v31 = v3;
        _os_log_impl(&dword_19BD16000, v5, OS_LOG_TYPE_INFO, "%@ reset child SA %@", (uint8_t *)&v28, 0x16u);
      }

      v6 = v3;
      ne_log_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        Property = objc_getProperty(a1, v8, 176, 1);
        v28 = 138412802;
        v29 = a1;
        v30 = 2112;
        v31 = Property;
        v32 = 2112;
        v33 = v6;
        _os_log_impl(&dword_19BD16000, v7, OS_LOG_TYPE_DEFAULT, "%@ %@ Uninstalling child SA %@", (uint8_t *)&v28, 0x20u);
      }

      v11 = objc_getProperty(a1, v10, 192, 1);
      v12 = -[NEIKEv2Session copySAFromDictionary:forChild:](v11, v6);
      if (v12)
      {
        v14 = v12;
        do
        {
          objc_msgSend(objc_getProperty(a1, v13, 176, 1), "removeSA:", v14);
          objc_msgSend(objc_getProperty(a1, v15, 192, 1), "setObject:forKeyedSubscript:", 0, v14);
          v17 = objc_getProperty(a1, v16, 192, 1);
          v18 = -[NEIKEv2Session copySAFromDictionary:forChild:](v17, v6);

          v14 = v18;
        }
        while (v18);
      }
      v19 = objc_getProperty(a1, v13, 184, 1);
      v20 = -[NEIKEv2Session copySAFromDictionary:forChild:](v19, v6);
      if (v20)
      {
        v22 = v20;
        do
        {
          objc_msgSend(objc_getProperty(a1, v21, 176, 1), "removeSA:", v22);
          objc_msgSend(objc_getProperty(a1, v23, 184, 1), "setObject:forKeyedSubscript:", 0, v22);
          v25 = objc_getProperty(a1, v24, 192, 1);
          v26 = -[NEIKEv2Session copySAFromDictionary:forChild:](v25, v6);

          v22 = v26;
        }
        while (v26);
      }

      -[NEIKEv2ChildSA reset](v6, v27);
    }
    else
    {
      if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      {
        v28 = 136315138;
        v29 = "-[NEIKEv2Session resetChild:]";
        _os_log_fault_impl(&dword_19BD16000, v5, OS_LOG_TYPE_FAULT, "%s called with null childSA", (uint8_t *)&v28, 0xCu);
      }

    }
  }

}

- (id)copySAFromDictionary:(void *)a1 forChild:(void *)a2
{
  id v3;
  id v4;
  id v5;
  id v6;
  uint64_t v7;
  void *i;
  void *v9;
  id v10;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  _BYTE v16[128];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v12 = 0u;
  v13 = 0u;
  v14 = 0u;
  v15 = 0u;
  v5 = v3;
  v6 = (id)objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v12, v16, 16);
  if (v6)
  {
    v7 = *(_QWORD *)v13;
    while (2)
    {
      for (i = 0; i != v6; i = (char *)i + 1)
      {
        if (*(_QWORD *)v13 != v7)
          objc_enumerationMutation(v5);
        v9 = *(void **)(*((_QWORD *)&v12 + 1) + 8 * (_QWORD)i);
        objc_msgSend(v5, "objectForKeyedSubscript:", v9, (_QWORD)v12);
        v10 = (id)objc_claimAutoreleasedReturnValue();

        if (v10 == v4)
        {
          v6 = v9;
          goto LABEL_11;
        }
      }
      v6 = (id)objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v12, v16, 16);
      if (v6)
        continue;
      break;
    }
  }
LABEL_11:

  return v6;
}

- (void)startIKELifetimeTimer
{
  const char *v3;
  const char *v4;
  NSObject *Property;
  SEL v6;
  id v7;
  const char *v8;
  id v9;
  const char *v10;
  id v11;
  const char *v12;
  char *v13;
  SEL v14;
  _BYTE *v15;
  int v16;
  char *v17;
  const char *v18;
  NSObject *v19;
  dispatch_source_t v20;
  SEL v21;
  SEL v22;
  _BOOL4 v23;
  NSObject *v24;
  NSObject *v25;
  SEL v26;
  NSObject *v27;
  dispatch_time_t v28;
  SEL v29;
  id v30;
  NSObject *v31;
  SEL v32;
  NSObject *v33;
  NSObject *v34;
  _QWORD handler[4];
  id v36;
  uint8_t buf[4];
  const char *v38;
  __int16 v39;
  char *v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  if (objc_getProperty(a1, a2, 336, 1))
  {
    if (objc_getProperty(a1, v3, 264, 1))
    {
      Property = objc_getProperty(a1, v4, 264, 1);
      dispatch_source_cancel(Property);
      objc_setProperty_atomic(a1, v6, 0, 264);
    }
    v7 = objc_getProperty(a1, v4, 336, 1);
    if (v7)
      v7 = objc_getProperty(v7, v8, 96, 1);
    v9 = v7;

    if (v9)
    {
      v11 = objc_getProperty(a1, v10, 336, 1);
      if (v11)
        v11 = objc_getProperty(v11, v12, 96, 1);
      v13 = (char *)v11;
      v15 = objc_getProperty(a1, v14, 336, 1);
      if (v15)
        v16 = v15[9] & 1;
      else
        v16 = 0;
      v17 = -[NEIKEv2IKESAProposal softLifetimeSecondsForInitiator:](v13, v16);

      if (v17)
      {
        v19 = objc_getProperty(a1, v18, 368, 1);
        v20 = dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, v19);
        objc_setProperty_atomic(a1, v21, v20, 264);

        v23 = objc_getProperty(a1, v22, 264, 1) == 0;
        ne_log_obj();
        v24 = objc_claimAutoreleasedReturnValue();
        v25 = v24;
        if (v23)
        {
          if (os_log_type_enabled(v24, OS_LOG_TYPE_FAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_fault_impl(&dword_19BD16000, v25, OS_LOG_TYPE_FAULT, "dispatch_source_create failed", buf, 2u);
          }

        }
        else
        {
          if (os_log_type_enabled(v24, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)buf = 138412546;
            v38 = (const char *)a1;
            v39 = 2048;
            v40 = v17;
            _os_log_impl(&dword_19BD16000, v25, OS_LOG_TYPE_INFO, "%@: Setting IKE soft lifetime timer for %llu seconds", buf, 0x16u);
          }

          v27 = objc_getProperty(a1, v26, 264, 1);
          v28 = dispatch_time(0x8000000000000000, 1000000000 * (_QWORD)v17);
          dispatch_source_set_timer(v27, v28, 0xFFFFFFFFFFFFFFFFLL, 0);

          objc_initWeak((id *)buf, a1);
          v30 = objc_getProperty(a1, v29, 264, 1);
          handler[0] = MEMORY[0x1E0C809B0];
          handler[1] = 3221225472;
          handler[2] = __39__NEIKEv2Session_startIKELifetimeTimer__block_invoke;
          handler[3] = &unk_1E3CC39A8;
          v31 = v30;
          objc_copyWeak(&v36, (id *)buf);
          dispatch_source_set_event_handler(v31, handler);

          v33 = objc_getProperty(a1, v32, 264, 1);
          dispatch_activate(v33);
          objc_destroyWeak(&v36);
          objc_destroyWeak((id *)buf);
        }
      }
    }
  }
  else
  {
    ne_log_obj();
    v34 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v34, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136315138;
      v38 = "-[NEIKEv2Session startIKELifetimeTimer]";
      _os_log_fault_impl(&dword_19BD16000, v34, OS_LOG_TYPE_FAULT, "%s called with null self.ikeSA", buf, 0xCu);
    }

  }
}

void __39__NEIKEv2Session_startIKELifetimeTimer__block_invoke(uint64_t a1)
{
  id *v1;
  _BYTE *WeakRetained;
  void *v3;
  SEL v4;
  id Property;
  const char *v6;
  const char *v7;
  id v8;
  _BYTE *v9;
  int v10;
  uint64_t v11;
  char *v12;
  SEL v13;
  const char *v14;
  NSObject *v15;
  SEL v16;
  NSObject *v17;
  dispatch_source_t v18;
  SEL v19;
  SEL v20;
  _BOOL4 v21;
  NSObject *v22;
  NSObject *v23;
  uint64_t v24;
  SEL v25;
  NSObject *v26;
  dispatch_time_t v27;
  SEL v28;
  id v29;
  NSObject *v30;
  SEL v31;
  NSObject *v32;
  _QWORD handler[4];
  id v34;
  uint8_t buf[4];
  void *v36;
  __int16 v37;
  uint64_t v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  v1 = (id *)(a1 + 32);
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v3 = WeakRetained;
  if (WeakRetained && (WeakRetained[11] & 1) == 0)
  {
    objc_msgSend(WeakRetained, "forceRekeyIKE");
    Property = objc_getProperty(v3, v4, 336, 1);
    if (Property)
    {
      v8 = objc_getProperty(Property, v6, 96, 1);
      if (v8)
      {
        v9 = objc_getProperty(v3, v7, 336, 1);
        if (v9)
          v10 = v9[9] & 1;
        else
          v10 = 0;
        v11 = objc_msgSend(v8, "lifetimeSeconds");
        v12 = -[NEIKEv2IKESAProposal softLifetimeSecondsForInitiator:]((char *)v8, v10);
        if (objc_getProperty(v3, v13, 264, 1))
        {
          v15 = objc_getProperty(v3, v14, 264, 1);
          dispatch_source_cancel(v15);
          objc_setProperty_atomic(v3, v16, 0, 264);
        }
        v17 = objc_getProperty(v3, v14, 368, 1);
        v18 = dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, v17);
        objc_setProperty_atomic(v3, v19, v18, 264);

        v21 = objc_getProperty(v3, v20, 264, 1) == 0;
        ne_log_obj();
        v22 = objc_claimAutoreleasedReturnValue();
        v23 = v22;
        if (v21)
        {
          if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_fault_impl(&dword_19BD16000, v23, OS_LOG_TYPE_FAULT, "dispatch_source_create failed", buf, 2u);
          }

        }
        else
        {
          v24 = v11 - (_QWORD)v12;
          if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)buf = 138412546;
            v36 = v3;
            v37 = 2048;
            v38 = v24;
            _os_log_impl(&dword_19BD16000, v23, OS_LOG_TYPE_INFO, "%@: Setting IKE hard lifetime timer for %llu seconds", buf, 0x16u);
          }

          v26 = objc_getProperty(v3, v25, 264, 1);
          v27 = dispatch_time(0x8000000000000000, 1000000000 * v24);
          dispatch_source_set_timer(v26, v27, 0xFFFFFFFFFFFFFFFFLL, 0);

          v29 = objc_getProperty(v3, v28, 264, 1);
          handler[0] = MEMORY[0x1E0C809B0];
          handler[1] = 3221225472;
          handler[2] = __39__NEIKEv2Session_startIKELifetimeTimer__block_invoke_54;
          handler[3] = &unk_1E3CC39A8;
          v30 = v29;
          objc_copyWeak(&v34, v1);
          dispatch_source_set_event_handler(v30, handler);

          v32 = objc_getProperty(v3, v31, 264, 1);
          dispatch_activate(v32);
          objc_destroyWeak(&v34);
        }
      }
    }
    else
    {
      v8 = 0;
    }

  }
}

void __39__NEIKEv2Session_startIKELifetimeTimer__block_invoke_54(uint64_t a1)
{
  id *v1;
  _BYTE *WeakRetained;
  _BYTE *v3;
  NEIKEv2DeleteIKEContext *v4;
  SEL v5;
  id v6;
  id *v7;
  const char *v8;
  _QWORD v9[4];
  id v10;

  v1 = (id *)(a1 + 32);
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v3 = WeakRetained;
  if (WeakRetained && (WeakRetained[11] & 1) == 0)
  {
    v4 = [NEIKEv2DeleteIKEContext alloc];
    v6 = objc_getProperty(v3, v5, 368, 1);
    v9[0] = MEMORY[0x1E0C809B0];
    v9[1] = 3221225472;
    v9[2] = __39__NEIKEv2Session_startIKELifetimeTimer__block_invoke_2;
    v9[3] = &unk_1E3CC1770;
    objc_copyWeak(&v10, v1);
    v7 = -[NEIKEv2DeleteIKEContext initDeleteIKEWithResponse:callbackQueue:callback:]((id *)&v4->super.super.isa, 1, v6, v9);

    -[NEIKEv2Session abort](v3, v8);
    -[NEIKEv2Session enqueuePendingRequestContext:](v3, v7);

    objc_destroyWeak(&v10);
  }

}

void __39__NEIKEv2Session_startIKELifetimeTimer__block_invoke_2(uint64_t a1)
{
  char *WeakRetained;
  char *v2;
  _QWORD *Property;
  SEL v4;
  id v5;
  const char *v6;
  char *self;

  WeakRetained = (char *)objc_loadWeakRetained((id *)(a1 + 32));
  v2 = WeakRetained;
  if (WeakRetained)
  {
    self = WeakRetained;
    Property = objc_getProperty(WeakRetained, WeakRetained, 336, 1);
    v2 = self;
    if (Property)
    {
      if (Property[6] == 2)
      {
        -[NEIKEv2Session resetAll]((uint64_t)self, self);
        v5 = objc_getProperty(self, v4, 336, 1);
        -[NEIKEv2IKESA setState:error:]((uint64_t)v5, 3uLL, 0);
        -[NEIKEv2Session reportState](self, v6);
        v2 = self;
      }
    }
  }

}

- (void)setIKESA:(uint64_t)a1
{
  id v3;
  const char *v4;
  void *v5;
  SEL v6;
  id v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t i;
  uint64_t v12;
  SEL v13;
  const char *v14;
  const char *v15;
  const char *v16;
  NSObject *v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  uint8_t v22[128];
  uint8_t buf[4];
  const char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  v5 = v3;
  if (a1)
  {
    if (v3)
    {
      if ((*(_BYTE *)(a1 + 11) & 1) == 0)
      {
        -[NEIKEv2Session resetMessages]((_DWORD *)a1, v4);
        v20 = 0u;
        v21 = 0u;
        v18 = 0u;
        v19 = 0u;
        v7 = objc_getProperty((id)a1, v6, 288, 1);
        v8 = objc_msgSend(v7, "countByEnumeratingWithState:objects:count:", &v18, v22, 16);
        if (v8)
        {
          v9 = v8;
          v10 = *(_QWORD *)v19;
          do
          {
            for (i = 0; i != v9; ++i)
            {
              if (*(_QWORD *)v19 != v10)
                objc_enumerationMutation(v7);
              v12 = *(_QWORD *)(*((_QWORD *)&v18 + 1) + 8 * i);
              if (v12)
                objc_storeWeak((id *)(v12 + 24), v5);
            }
            v9 = objc_msgSend(v7, "countByEnumeratingWithState:objects:count:", &v18, v22, 16);
          }
          while (v9);
        }

        objc_setProperty_atomic((id)a1, v13, v5, 336);
        -[NEIKEv2Session startIKELifetimeTimer]((void *)a1, v14);
        -[NEIKEv2Session invalidateDPDTimer]((void *)a1, v15);
        -[NEIKEv2Session startDPDTimer]((void *)a1, v16);
      }
    }
    else
    {
      ne_log_obj();
      v17 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136315138;
        v24 = "-[NEIKEv2Session setIKESA:]";
        _os_log_fault_impl(&dword_19BD16000, v17, OS_LOG_TYPE_FAULT, "%s called with null newIKESA", buf, 0xCu);
      }

    }
  }

}

- (_DWORD)copyChildWithID:(void *)a1
{
  int v2;
  id v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _DWORD *v8;
  int v9;
  uint64_t v10;
  _DWORD *v11;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  _BYTE v17[128];
  uint64_t v18;

  v2 = (int)a2;
  v18 = *MEMORY[0x1E0C80C00];
  v13 = 0u;
  v14 = 0u;
  v15 = 0u;
  v16 = 0u;
  v3 = objc_getProperty(a1, a2, 288, 1);
  v4 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v13, v17, 16);
  if (v4)
  {
    v5 = v4;
    v6 = *(_QWORD *)v14;
    do
    {
      v7 = 0;
      do
      {
        if (*(_QWORD *)v14 != v6)
          objc_enumerationMutation(v3);
        v8 = *(_DWORD **)(*((_QWORD *)&v13 + 1) + 8 * v7);
        if (v8)
          v9 = v8[4];
        else
          v9 = 0;
        if (v9 == v2)
        {
          v11 = v8;
          goto LABEL_15;
        }
        ++v7;
      }
      while (v5 != v7);
      v10 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v13, v17, 16);
      v5 = v10;
    }
    while (v10);
  }
  v11 = 0;
LABEL_15:

  return v11;
}

- (_OWORD)addEmptyInterface
{
  const void *v2;
  _OWORD *result;

  v2 = *(const void **)(a1 + 328);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(a1 + 328) = 0;
  }
  result = NEVirtualInterfaceCreateNexusExtendedWithOptions((const __CFAllocator *)*MEMORY[0x1E0C9AE00], 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  *(_QWORD *)(a1 + 328) = result;
  *(_BYTE *)(a1 + 10) = 1;
  return result;
}

- (__CFString)interfaceName
{
  uint64_t v1;
  __CFString *v2;
  NSObject *v3;
  uint8_t v5[16];

  v1 = *(_QWORD *)(a1 + 328);
  if (!v1)
  {
LABEL_6:
    v2 = 0;
    return v2;
  }
  v2 = (__CFString *)CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const char *)(v1 + 265), 0x600u);
  if (!v2)
  {
    ne_log_obj();
    v3 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)v5 = 0;
      _os_log_fault_impl(&dword_19BD16000, v3, OS_LOG_TYPE_FAULT, "NEVirtualInterfaceCopyName failed", v5, 2u);
    }

    goto LABEL_6;
  }
  return v2;
}

- (uint64_t)interfaceIndex
{
  uint64_t v1;
  uint64_t v2;
  NSObject *v3;
  void *v4;
  int v5;
  void *v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  if (result)
  {
    v1 = result;
    v2 = *(_QWORD *)(result + 328);
    if (v2)
    {
      result = *(unsigned int *)(v2 + 292);
      if ((_DWORD)result)
        return result;
      ne_log_obj();
      v3 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_FAULT))
      {
        -[NEIKEv2Session interfaceName](v1);
        v4 = (void *)objc_claimAutoreleasedReturnValue();
        v5 = 138412290;
        v6 = v4;
        _os_log_fault_impl(&dword_19BD16000, v3, OS_LOG_TYPE_FAULT, "NEVirtualInterfaceGetIndex (interfaceName=%@) failed", (uint8_t *)&v5, 0xCu);

      }
    }
    return 0;
  }
  return result;
}

- (uint64_t)copyIPsecInterfaceWithMissingAllowed:(uint64_t)a1
{
  uint64_t v3;
  NSObject *v4;
  unsigned int Index;
  unsigned int v6;
  BOOL v7;
  NSObject *v8;
  NSObject *v9;
  const char *v10;
  NSObject *v11;
  uint32_t v12;
  NSObject *v14;
  uint64_t v15;
  NSObject *v16;
  NSObject *v17;
  const char *v18;
  NSObject *v19;
  uint32_t v20;
  int v22;
  _BYTE v23[24];
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v3 = *(_QWORD *)(a1 + 328);
  if (v3)
  {
    v4 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const char *)(v3 + 265), 0x600u);
    Index = NEVirtualInterfaceGetIndex(*(_QWORD *)(a1 + 328));
    v6 = Index;
    if (v4)
      v7 = Index == 0;
    else
      v7 = 1;
    if (v7)
    {
      if (!Index)
      {
        if (v4)
        {
          v15 = objc_msgSend(objc_alloc(MEMORY[0x1E0CCEC88]), "initWithInterfaceName:", v4);
          ne_log_obj();
          v17 = objc_claimAutoreleasedReturnValue();
          v9 = v17;
          if (v15)
          {
            if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
              goto LABEL_36;
            v22 = 138412546;
            *(_QWORD *)v23 = a1;
            *(_WORD *)&v23[8] = 2112;
            *(_QWORD *)&v23[10] = v4;
            v10 = "Created interface for %@ from name %@";
            v11 = v9;
            v12 = 22;
            goto LABEL_17;
          }
          if (!os_log_type_enabled(v17, OS_LOG_TYPE_FAULT))
            goto LABEL_35;
          v22 = 138412290;
          *(_QWORD *)v23 = v4;
          v18 = "[NWInterface initWithInterfaceName:%@] failed";
        }
        else
        {
          ne_log_obj();
          v9 = objc_claimAutoreleasedReturnValue();
          if (!os_log_type_enabled(v9, OS_LOG_TYPE_FAULT))
            goto LABEL_35;
          v22 = 138412290;
          *(_QWORD *)v23 = a1;
          v18 = "%@ has ipsecInterface without index or name";
        }
        v19 = v9;
        v20 = 12;
        goto LABEL_34;
      }
      v15 = objc_msgSend(objc_alloc(MEMORY[0x1E0CCEC88]), "initWithInterfaceIndex:", Index);
      ne_log_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = v8;
      if (v15)
      {
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
        {
          v22 = 138412546;
          *(_QWORD *)v23 = a1;
          *(_WORD *)&v23[8] = 1024;
          *(_DWORD *)&v23[10] = v6;
          v10 = "Created interface for %@ from index %u";
          v11 = v9;
          v12 = 18;
LABEL_17:
          _os_log_debug_impl(&dword_19BD16000, v11, OS_LOG_TYPE_DEBUG, v10, (uint8_t *)&v22, v12);
        }
LABEL_36:

        goto LABEL_37;
      }
      if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT))
      {
        v22 = 67109120;
        *(_DWORD *)v23 = v6;
        v18 = "[NWInterface initWithInterfaceIndex:%u] failed";
        v19 = v9;
        v20 = 8;
        goto LABEL_34;
      }
    }
    else
    {
      v15 = objc_msgSend(objc_alloc(MEMORY[0x1E0CCEC88]), "initWithInterfaceIndex:interfaceName:", Index, v4);
      ne_log_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      v9 = v16;
      if (v15)
      {
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
        {
          v22 = 138412802;
          *(_QWORD *)v23 = a1;
          *(_WORD *)&v23[8] = 1024;
          *(_DWORD *)&v23[10] = v6;
          *(_WORD *)&v23[14] = 2112;
          *(_QWORD *)&v23[16] = v4;
          v10 = "Created interface for %@ from index %u and name %@";
          v11 = v9;
          v12 = 28;
          goto LABEL_17;
        }
        goto LABEL_36;
      }
      if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT))
      {
        v22 = 67109378;
        *(_DWORD *)v23 = v6;
        *(_WORD *)&v23[4] = 2112;
        *(_QWORD *)&v23[6] = v4;
        v18 = "[NWInterface initWithInterfaceIndex:%u interfaceName:%@] failed";
        v19 = v9;
        v20 = 18;
LABEL_34:
        _os_log_fault_impl(&dword_19BD16000, v19, OS_LOG_TYPE_FAULT, v18, (uint8_t *)&v22, v20);
      }
    }
LABEL_35:
    v15 = 0;
    goto LABEL_36;
  }
  ne_log_obj();
  v14 = objc_claimAutoreleasedReturnValue();
  v4 = v14;
  if ((a2 & 1) != 0)
  {
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
    {
      v22 = 138412290;
      *(_QWORD *)v23 = a1;
      _os_log_debug_impl(&dword_19BD16000, v4, OS_LOG_TYPE_DEBUG, "%@ missing ipsecInterface", (uint8_t *)&v22, 0xCu);
    }
  }
  else if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT))
  {
    v22 = 138412290;
    *(_QWORD *)v23 = a1;
    _os_log_fault_impl(&dword_19BD16000, v4, OS_LOG_TYPE_FAULT, "%@ missing ipsecInterface", (uint8_t *)&v22, 0xCu);
  }
  v15 = 0;
LABEL_37:

  return v15;
}

- (uint64_t)generateSPIForChild:(void *)a3 proposals:
{
  id v5;
  const char *v6;
  id v7;
  const char *v8;
  id Property;
  const char *v10;
  id v11;
  const char *v12;
  id v13;
  const char *v14;
  id v15;
  NSObject *v16;
  NSObject *v17;
  const char *v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  void *v22;
  uint64_t v23;
  uint64_t v24;
  id v25;
  const char *v26;
  id v27;
  id v28;
  id v29;
  id v30;
  uint64_t v31;
  uint64_t v32;
  SEL v33;
  id v34;
  const char *v35;
  id v36;
  SEL v37;
  id v38;
  const char *v39;
  id v40;
  SEL v41;
  id v42;
  const char *v43;
  id v44;
  void *v45;
  void *v46;
  SEL v47;
  const char *v48;
  uint64_t v49;
  NSObject *v50;
  const char *v51;
  uint64_t v52;
  NSObject *v53;
  const char *v54;
  id v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  void *v60;
  void *v61;
  const char *v62;
  NEIKEv2ESPSPI *v63;
  NSObject *v65;
  const char *v67;
  id v68;
  id v69;
  id obj;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  unsigned __int8 v79;
  _BYTE v80[128];
  uint8_t v81[128];
  uint8_t buf[4];
  const char *v83;
  __int16 v84;
  id v85;
  uint64_t v86;

  v86 = *MEMORY[0x1E0C80C00];
  v5 = a2;
  v7 = a3;
  if (!v7)
  {
    ne_log_obj();
    v50 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v50, OS_LOG_TYPE_FAULT))
      goto LABEL_44;
    *(_DWORD *)buf = 136315138;
    v83 = "-[NEIKEv2Session generateSPIForChild:proposals:]";
    v51 = "%s called with null proposals";
    goto LABEL_71;
  }
  if (!objc_getProperty(a1, v6, 336, 1))
  {
    ne_log_obj();
    v50 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v50, OS_LOG_TYPE_FAULT))
    {
LABEL_44:

LABEL_45:
      v52 = 0;
      goto LABEL_69;
    }
    *(_DWORD *)buf = 136315138;
    v83 = "-[NEIKEv2Session generateSPIForChild:proposals:]";
    v51 = "%s called with null self.ikeSA";
LABEL_71:
    _os_log_fault_impl(&dword_19BD16000, v50, OS_LOG_TYPE_FAULT, v51, buf, 0xCu);
    goto LABEL_44;
  }
  Property = objc_getProperty(a1, v8, 336, 1);
  if (Property)
    Property = objc_getProperty(Property, v10, 64, 1);
  v11 = Property;

  if (!v11)
  {
    ne_log_obj();
    v50 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v50, OS_LOG_TYPE_FAULT))
      goto LABEL_44;
    *(_DWORD *)buf = 136315138;
    v83 = "-[NEIKEv2Session generateSPIForChild:proposals:]";
    v51 = "%s called with null self.ikeSA.localAddress";
    goto LABEL_71;
  }
  v13 = objc_getProperty(a1, v12, 336, 1);
  if (v13)
    v13 = objc_getProperty(v13, v14, 72, 1);
  v15 = v13;

  ne_log_obj();
  v16 = objc_claimAutoreleasedReturnValue();
  v17 = v16;
  if (!v15)
  {
    if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136315138;
      v83 = "-[NEIKEv2Session generateSPIForChild:proposals:]";
      _os_log_fault_impl(&dword_19BD16000, v17, OS_LOG_TYPE_FAULT, "%s called with null self.ikeSA.remoteAddress", buf, 0xCu);
    }

    goto LABEL_45;
  }
  if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 138412546;
    v83 = (const char *)a1;
    v84 = 2112;
    v85 = objc_getProperty(a1, v18, 176, 1);
    _os_log_impl(&dword_19BD16000, v17, OS_LOG_TYPE_INFO, "%@ %@ Generating SPI(s) for child", buf, 0x16u);
  }

  v77 = 0u;
  v78 = 0u;
  v75 = 0u;
  v76 = 0u;
  v69 = v7;
  obj = v7;
  v19 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v75, v81, 16);
  if (!v19)
  {
    v21 = 0;
    v22 = 0;
    goto LABEL_53;
  }
  v20 = v19;
  v21 = 0;
  v22 = 0;
  v23 = *(_QWORD *)v76;
  do
  {
    v24 = 0;
    do
    {
      if (*(_QWORD *)v76 != v23)
        objc_enumerationMutation(obj);
      if (objc_msgSend(*(id *)(*((_QWORD *)&v75 + 1) + 8 * v24), "protocol") == 2)
      {
        if (v22)
          goto LABEL_36;
        v25 = -[NEIPSecSA initInboundSA]([NEIPSecSA alloc], "initInboundSA");
        objc_msgSend(v25, "setProtocol:", 2);
        v22 = v25;
      }
      else
      {
        if (v21)
          goto LABEL_36;
        v25 = -[NEIPSecSA initInboundSA]([NEIPSecSA alloc], "initInboundSA");
        objc_msgSend(v25, "setProtocol:", 1);
        v21 = v25;
      }
      v27 = v25;
      if (v5)
      {
        v28 = v5;
        v29 = objc_getProperty(v5, v26, 48, 1);
      }
      else
      {
        v28 = 0;
        v29 = 0;
      }
      v30 = v29;
      v31 = objc_msgSend(v30, "mode");

      if (v31 == 1)
        v32 = 1;
      else
        v32 = 2;
      objc_msgSend(v27, "setMode:", v32);
      objc_msgSend(v27, "setLifetimeSeconds:", 120);
      v34 = objc_getProperty(a1, v33, 336, 1);
      if (v34)
        v34 = objc_getProperty(v34, v35, 64, 1);
      v36 = v34;
      objc_msgSend(v27, "setLocalAddress:", v36);

      v38 = objc_getProperty(a1, v37, 336, 1);
      if (v38)
        v38 = objc_getProperty(v38, v39, 72, 1);
      v40 = v38;
      objc_msgSend(v27, "setRemoteAddress:", v40);

      v42 = objc_getProperty(a1, v41, 336, 1);
      if (v42)
        v42 = objc_getProperty(v42, v43, 304, 1);
      v44 = v42;
      objc_msgSend(v27, "setBoundInterfaceName:", v44);

      if (!a1[41])
        -[NEIKEv2Session addEmptyInterface]((uint64_t)a1);
      v45 = (void *)-[NEIKEv2Session copyIPsecInterfaceWithMissingAllowed:]((uint64_t)a1, 1);
      objc_msgSend(v45, "interfaceName");
      v46 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v27, "setTunnelInterfaceName:", v46);

      if (!objc_msgSend(objc_getProperty(a1, v47, 176, 1), "addLarvalSA:", v27))
      {
        ne_log_obj();
        v53 = objc_claimAutoreleasedReturnValue();
        v5 = v28;
        if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
        {
          v68 = objc_getProperty(a1, v54, 176, 1);
          *(_DWORD *)buf = 138412546;
          v83 = (const char *)a1;
          v84 = 2112;
          v85 = v68;
          _os_log_error_impl(&dword_19BD16000, v53, OS_LOG_TYPE_ERROR, "%@ [%@ addLarvalSA:larvalSA] failed", buf, 0x16u);
        }

        v79 = 0;
        goto LABEL_67;
      }
      v5 = v28;
      objc_msgSend(objc_getProperty(a1, v48, 184, 1), "setObject:forKeyedSubscript:", v28, v27);

LABEL_36:
      ++v24;
    }
    while (v20 != v24);
    v49 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v75, v81, 16);
    v20 = v49;
  }
  while (v49);
LABEL_53:

  v73 = 0u;
  v74 = 0u;
  v71 = 0u;
  v72 = 0u;
  v55 = obj;
  v56 = objc_msgSend(v55, "countByEnumeratingWithState:objects:count:", &v71, v80, 16);
  if (!v56)
    goto LABEL_66;
  v57 = v56;
  v58 = *(_QWORD *)v72;
  while (2)
  {
    v59 = 0;
    while (2)
    {
      if (*(_QWORD *)v72 != v58)
        objc_enumerationMutation(v55);
      v60 = *(void **)(*((_QWORD *)&v71 + 1) + 8 * v59);
      if (objc_msgSend(v60, "protocol") == 2)
      {
        v61 = v22;
        if (!v22)
        {
          ne_log_obj();
          v65 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v65, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)buf = 136315138;
            v83 = "-[NEIKEv2Session generateSPIForChild:proposals:]";
            v67 = "%s called with null ahLarvalSA";
            goto LABEL_77;
          }
          goto LABEL_75;
        }
      }
      else
      {
        v61 = v21;
        if (!v21)
        {
          ne_log_obj();
          v65 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v65, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)buf = 136315138;
            v83 = "-[NEIKEv2Session generateSPIForChild:proposals:]";
            v67 = "%s called with null espLarvalSA";
LABEL_77:
            _os_log_fault_impl(&dword_19BD16000, v65, OS_LOG_TYPE_FAULT, v67, buf, 0xCu);
          }
LABEL_75:
          v7 = v69;

          v79 = 0;
          goto LABEL_68;
        }
      }
      v63 = -[NEIKEv2ESPSPI initWithValue:]([NEIKEv2ESPSPI alloc], "initWithValue:", objc_msgSend(v61, "spi"));
      if (v60)
        objc_setProperty_atomic(v60, v62, v63, 80);

      if (v57 != ++v59)
        continue;
      break;
    }
    v57 = objc_msgSend(v55, "countByEnumeratingWithState:objects:count:", &v71, v80, 16);
    if (v57)
      continue;
    break;
  }
LABEL_66:

  v79 = 1;
LABEL_67:
  v7 = v69;
LABEL_68:

  v52 = v79;
LABEL_69:

  return v52;
}

- (id)copySAFromDictionary:(void *)a1 forSPI:(void *)a2
{
  id v3;
  id v4;
  id v5;
  id v6;
  uint64_t v7;
  void *i;
  void *v9;
  int v10;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  _BYTE v16[128];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v12 = 0u;
  v13 = 0u;
  v14 = 0u;
  v15 = 0u;
  v5 = v3;
  v6 = (id)objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v12, v16, 16);
  if (v6)
  {
    v7 = *(_QWORD *)v13;
    while (2)
    {
      for (i = 0; i != v6; i = (char *)i + 1)
      {
        if (*(_QWORD *)v13 != v7)
          objc_enumerationMutation(v5);
        v9 = *(void **)(*((_QWORD *)&v12 + 1) + 8 * (_QWORD)i);
        v10 = objc_msgSend(v9, "spi", (_QWORD)v12);
        if (v10 == objc_msgSend(v4, "value"))
        {
          v6 = v9;
          goto LABEL_11;
        }
      }
      v6 = (id)objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v12, v16, 16);
      if (v6)
        continue;
      break;
    }
  }
LABEL_11:

  return v6;
}

- (uint64_t)installChildSA:(uint64_t)a1
{
  const char *v3;
  _BYTE *v4;
  const char *v5;
  id Property;
  const char *v7;
  id v8;
  const char *v9;
  id v10;
  const char *v11;
  id v12;
  const char *v13;
  id v14;
  const char *v15;
  id v16;
  SEL v17;
  id v18;
  const char *v19;
  void *v20;
  id v21;
  NSObject *v22;
  NSObject *v23;
  NSObject *v24;
  const char *v25;
  NEIPSecSA *v26;
  SEL v27;
  id v28;
  const char *v29;
  void *v30;
  id v31;
  SEL v32;
  id v33;
  uint64_t v34;
  uint64_t v35;
  SEL v36;
  id v37;
  uint64_t v38;
  uint64_t v39;
  SEL v40;
  id v41;
  const char *v42;
  id v43;
  SEL v44;
  id v45;
  const char *v46;
  id v47;
  SEL v48;
  id v49;
  const char *v50;
  _QWORD *v51;
  uint64_t v52;
  const char *v53;
  const char *v54;
  uint64_t v55;
  const char *v57;
  NSObject *v58;
  const char *v59;
  NSObject *v60;
  char *v61;
  SEL v62;
  SEL v63;
  id v64;
  const char *v65;
  _BYTE *v66;
  char v67;
  BOOL v68;
  unsigned int v69;
  id v70;
  const char *v71;
  _BYTE *v72;
  char v73;
  id v74;
  const char *v75;
  _BYTE *v76;
  char v77;
  uint64_t v78;
  id v79;
  SEL v80;
  id v81;
  SEL v82;
  void *v83;
  SEL v84;
  void *v85;
  SEL v86;
  id v87;
  SEL v88;
  id v89;
  SEL v90;
  id v91;
  const char *v92;
  void *v93;
  uint64_t v94;
  const char *v95;
  id v96;
  const char *v97;
  _QWORD *v98;
  unint64_t v99;
  unsigned int v100;
  const char *v101;
  const char *v102;
  void *v103;
  int v104;
  const char *v105;
  NSObject *v106;
  uint32_t v107;
  SEL v108;
  void *v109;
  SEL v110;
  void *v111;
  SEL v112;
  id v113;
  const char *v114;
  NSObject *v115;
  const char *v116;
  _BYTE *v117;
  const char *v118;
  _BYTE *v119;
  char v120;
  const char *v121;
  id v122;
  const char *v123;
  id v124;
  char v125;
  const char *v126;
  SEL v127;
  id v128;
  const char *v129;
  id v130;
  void *v131;
  SEL v132;
  id v133;
  const char *v134;
  id v135;
  void *v136;
  SEL v137;
  id v138;
  const char *v139;
  id v140;
  void *v141;
  SEL v142;
  id v143;
  const char *v144;
  id v145;
  void *v146;
  _BYTE *v147;
  const char *v148;
  id v149;
  const char *v150;
  id v151;
  char v152;
  SEL v153;
  id v154;
  const char *v155;
  id v156;
  int v157;
  const char *v158;
  SEL v159;
  id v160;
  const char *v161;
  id v162;
  id v163;
  const char *v164;
  id v165;
  _BYTE *v166;
  const char *v167;
  id v168;
  const char *v169;
  id v170;
  void *v171;
  void *v172;
  SEL v173;
  const char *v174;
  SEL v175;
  SEL v176;
  SEL v177;
  const char *v178;
  SEL v179;
  SEL v180;
  SEL v181;
  SEL v182;
  id v183;
  const char *v184;
  id v185;
  int v186;
  const char *v187;
  id v188;
  SEL v189;
  id v190;
  const char *v191;
  id v192;
  id v193;
  const char *v194;
  id v195;
  int v196;
  const char *v197;
  const char *v198;
  const char *v199;
  const char *v200;
  id v201;
  const char *v202;
  unint64_t v203;
  void *v204;
  __CFString *String;
  int v206;
  const char *v207;
  __int16 v208;
  id v209;
  __int16 v210;
  id v211;
  uint64_t v212;

  v212 = *MEMORY[0x1E0C80C00];
  v4 = a2;
  if (!a1)
  {
    v55 = 0;
    goto LABEL_45;
  }
  if (!objc_getProperty((id)a1, v3, 336, 1))
  {
    ne_log_obj();
    v22 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_FAULT))
      goto LABEL_43;
    v206 = 136315138;
    v207 = "-[NEIKEv2Session installChildSA:]";
    v54 = "%s called with null self.ikeSA";
LABEL_42:
    _os_log_fault_impl(&dword_19BD16000, v22, OS_LOG_TYPE_FAULT, v54, (uint8_t *)&v206, 0xCu);
    goto LABEL_43;
  }
  if (!v4)
  {
    ne_log_obj();
    v22 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_FAULT))
      goto LABEL_43;
    v206 = 136315138;
    v207 = "-[NEIKEv2Session installChildSA:]";
    v54 = "%s called with null childSA";
    goto LABEL_42;
  }
  Property = objc_getProperty((id)a1, v5, 336, 1);
  if (Property)
    Property = objc_getProperty(Property, v7, 64, 1);
  v8 = Property;

  if (!v8)
  {
    ne_log_obj();
    v22 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_FAULT))
      goto LABEL_43;
    v206 = 136315138;
    v207 = "-[NEIKEv2Session installChildSA:]";
    v54 = "%s called with null self.ikeSA.localAddress";
    goto LABEL_42;
  }
  v10 = objc_getProperty((id)a1, v9, 336, 1);
  if (v10)
    v10 = objc_getProperty(v10, v11, 72, 1);
  v12 = v10;

  if (!v12)
  {
    ne_log_obj();
    v22 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_FAULT))
      goto LABEL_43;
    v206 = 136315138;
    v207 = "-[NEIKEv2Session installChildSA:]";
    v54 = "%s called with null self.ikeSA.remoteAddress";
    goto LABEL_42;
  }
  v14 = objc_getProperty(v4, v13, 56, 1);

  if (v14)
  {
    v16 = objc_getProperty((id)a1, v15, 184, 1);
    v18 = objc_getProperty(v4, v17, 56, 1);
    v20 = v18;
    if (v18)
      v18 = objc_getProperty(v18, v19, 80, 1);
    v21 = v18;
    v22 = -[NEIKEv2Session copySAFromDictionary:forSPI:](v16, v21);

    ne_log_obj();
    v23 = objc_claimAutoreleasedReturnValue();
    v24 = v23;
    if (!v22)
    {
      if (!os_log_type_enabled(v23, OS_LOG_TYPE_FAULT))
      {
LABEL_148:
        v55 = 0;
LABEL_149:

        goto LABEL_44;
      }
      v58 = objc_getProperty(v4, v57, 56, 1);
      v60 = v58;
      if (v58)
        v58 = objc_getProperty(v58, v59, 80, 1);
      v61 = v58;
      v206 = 138412802;
      v207 = v61;
      v208 = 2112;
      v209 = objc_getProperty((id)a1, v62, 184, 1);
      v210 = 2112;
      v211 = objc_getProperty((id)a1, v63, 192, 1);
      _os_log_fault_impl(&dword_19BD16000, v24, OS_LOG_TYPE_FAULT, "copySAFromDictionary incoming %@ databaseLarvalSAs %@ databaseSAs %@ failed", (uint8_t *)&v206, 0x20u);
LABEL_141:

LABEL_147:
      goto LABEL_148;
    }
    if (os_log_type_enabled(v23, OS_LOG_TYPE_INFO))
    {
      v206 = 138412802;
      v207 = (const char *)a1;
      v208 = 2112;
      v209 = objc_getProperty((id)a1, v25, 176, 1);
      v210 = 2112;
      v211 = v4;
      _os_log_impl(&dword_19BD16000, v24, OS_LOG_TYPE_INFO, "%@ %@ Installing childSA %@", (uint8_t *)&v206, 0x20u);
    }

    v26 = [NEIPSecSA alloc];
    v28 = objc_getProperty(v4, v27, 56, 1);
    v30 = v28;
    if (v28)
      v28 = objc_getProperty(v28, v29, 88, 1);
    v31 = v28;
    v24 = -[NEIPSecSA initOutboundSAWithSPI:](v26, "initOutboundSAWithSPI:", objc_msgSend(v31, "value"));

    v33 = objc_getProperty(v4, v32, 48, 1);
    v34 = objc_msgSend(v33, "mode");

    if (v34 == 1)
      v35 = 1;
    else
      v35 = 2;
    -[NSObject setMode:](v24, "setMode:", v35);
    v37 = objc_getProperty(v4, v36, 56, 1);
    v38 = objc_msgSend(v37, "protocol");

    if (v38 == 2)
      v39 = 2;
    else
      v39 = 1;
    -[NSObject setProtocol:](v24, "setProtocol:", v39);
    v41 = objc_getProperty((id)a1, v40, 336, 1);
    if (v41)
      v41 = objc_getProperty(v41, v42, 64, 1);
    v43 = v41;
    -[NSObject setLocalAddress:](v24, "setLocalAddress:", v43);

    v45 = objc_getProperty((id)a1, v44, 336, 1);
    if (v45)
      v45 = objc_getProperty(v45, v46, 72, 1);
    v47 = v45;
    -[NSObject setRemoteAddress:](v24, "setRemoteAddress:", v47);

    v49 = objc_getProperty(v4, v48, 56, 1);
    -[NEIKEv2ChildSAProposal encryptionProtocol](v49, v50);
    v51 = (_QWORD *)objc_claimAutoreleasedReturnValue();
    if (v51)
    {
      v52 = v51[2];

      if (v52 <= 19)
      {
        if (v52 == 2 || v52 == 3)
        {
LABEL_65:
          v78 = 1;
          v79 = objc_getProperty(v4, v53, 56, 1);
          -[NSObject setLifetimeSeconds:](v22, "setLifetimeSeconds:", objc_msgSend(v79, "lifetimeSeconds"));

          v81 = objc_getProperty(v4, v80, 56, 1);
          -[NSObject setLifetimeSeconds:](v24, "setLifetimeSeconds:", objc_msgSend(v81, "lifetimeSeconds"));

          -[NSObject setEncryptionAlgorithm:](v22, "setEncryptionAlgorithm:", v52);
          -[NSObject setEncryptionAlgorithm:](v24, "setEncryptionAlgorithm:", v52);
          objc_getProperty(v4, v82, 144, 1);
          v83 = (void *)objc_claimAutoreleasedReturnValue();
          -[NSObject setEncryptionKey:](v22, "setEncryptionKey:", v83);

          objc_getProperty(v4, v84, 160, 1);
          v85 = (void *)objc_claimAutoreleasedReturnValue();
          -[NSObject setEncryptionKey:](v24, "setEncryptionKey:", v85);

          v87 = objc_getProperty(v4, v86, 48, 1);
          -[NSObject setReplayWindowSize:](v22, "setReplayWindowSize:", objc_msgSend(v87, "replayWindowSize"));

          v89 = objc_getProperty(v4, v88, 48, 1);
          -[NSObject setReplayWindowSize:](v24, "setReplayWindowSize:", objc_msgSend(v89, "replayWindowSize"));

          -[NSObject setSequencePerTrafficClass:](v22, "setSequencePerTrafficClass:", v4[10] & 1);
          -[NSObject setSequencePerTrafficClass:](v24, "setSequencePerTrafficClass:", v4[10] & 1);
          v91 = objc_getProperty(v4, v90, 56, 1);
          -[NEIKEv2ChildSAProposal integrityProtocol](v91, v92);
          v93 = (void *)objc_claimAutoreleasedReturnValue();
          v94 = objc_msgSend(v93, "type");

          switch(v94)
          {
            case 0:
              v96 = objc_getProperty(v4, v95, 56, 1);
              -[NEIKEv2ChildSAProposal encryptionProtocol](v96, v97);
              v98 = (_QWORD *)objc_claimAutoreleasedReturnValue();
              if (v98 && (v99 = v98[2], v99 < 0x20))
              {
                v100 = 0xD01C0000 >> v99;

                if ((v100 & 1) != 0)
                {
                  v78 = 0;
                  goto LABEL_76;
                }
              }
              else
              {

              }
              ne_log_obj();
              v60 = objc_claimAutoreleasedReturnValue();
              if (!os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
                goto LABEL_147;
              v61 = (char *)objc_getProperty(v4, v198, 56, 1);
              -[NEIKEv2ChildSAProposal encryptionProtocol](v61, v199);
              v103 = (void *)objc_claimAutoreleasedReturnValue();
              v206 = 138412546;
              v207 = (const char *)a1;
              v208 = 2112;
              v209 = v103;
              v105 = "%@ No integrity type selected, but encryption %@ is not authenticated";
              v106 = v60;
              v107 = 22;
              goto LABEL_140;
            case 1:
              goto LABEL_76;
            case 2:
              v78 = 2;
              goto LABEL_76;
            case 12:
              v78 = 3;
              goto LABEL_76;
            case 13:
              v78 = 4;
              goto LABEL_76;
            case 14:
              v78 = 5;
LABEL_76:
              -[NSObject setAuthenticationAlgorithm:](v22, "setAuthenticationAlgorithm:", v78);
              -[NSObject setAuthenticationAlgorithm:](v24, "setAuthenticationAlgorithm:", v78);
              objc_getProperty(v4, v108, 152, 1);
              v109 = (void *)objc_claimAutoreleasedReturnValue();
              -[NSObject setAuthenticationKey:](v22, "setAuthenticationKey:", v109);

              objc_getProperty(v4, v110, 168, 1);
              v111 = (void *)objc_claimAutoreleasedReturnValue();
              -[NSObject setAuthenticationKey:](v24, "setAuthenticationKey:", v111);

              v113 = objc_getProperty((id)a1, v112, 336, 1);
              if (v113)
                v113 = objc_getProperty(v113, v114, 80, 1);
              v115 = v113;
              if ((-[NSObject forceUDPEncapsulation](v115, "forceUDPEncapsulation") & 1) != 0
                || (v117 = objc_getProperty((id)a1, v116, 336, 1)) != 0 && (v117[14] & 1) != 0)
              {

              }
              else
              {
                v119 = objc_getProperty((id)a1, v118, 336, 1);
                if (!v119)
                  goto LABEL_103;
                v120 = v119[15];

                if ((v120 & 1) == 0)
                  goto LABEL_104;
              }
              v122 = objc_getProperty((id)a1, v121, 336, 1);
              if (v122)
                v122 = objc_getProperty(v122, v123, 80, 1);
              v124 = v122;
              if (objc_msgSend(v124, "forceUDPEncapsulation"))
              {

              }
              else
              {
                v125 = objc_msgSend(*(id *)(a1 + 384), "disableSwitchToNATTPorts");

                if ((v125 & 1) != 0)
                {
                  ne_log_obj();
                  v115 = objc_claimAutoreleasedReturnValue();
                  if (!os_log_type_enabled(v115, OS_LOG_TYPE_INFO))
                    goto LABEL_103;
                  v206 = 138412290;
                  v207 = (const char *)a1;
                  v126 = "%@ Not enabling NAT traversal (install) because disabled";
                  goto LABEL_102;
                }
              }
              -[NSObject setNatTraversalEnabled:](v22, "setNatTraversalEnabled:", 1);
              -[NSObject setNatTraversalEnabled:](v24, "setNatTraversalEnabled:", 1);
              v128 = objc_getProperty((id)a1, v127, 336, 1);
              if (v128)
                v128 = objc_getProperty(v128, v129, 64, 1);
              v130 = v128;
              objc_msgSend(v130, "port");
              v131 = (void *)objc_claimAutoreleasedReturnValue();
              -[NSObject setNatTraversalPort:](v22, "setNatTraversalPort:", (unsigned __int16)objc_msgSend(v131, "intValue"));

              v133 = objc_getProperty((id)a1, v132, 336, 1);
              if (v133)
                v133 = objc_getProperty(v133, v134, 72, 1);
              v135 = v133;
              objc_msgSend(v135, "port");
              v136 = (void *)objc_claimAutoreleasedReturnValue();
              -[NSObject setNatTraversalSrcPort:](v22, "setNatTraversalSrcPort:", (unsigned __int16)objc_msgSend(v136, "intValue"));

              v138 = objc_getProperty((id)a1, v137, 336, 1);
              if (v138)
                v138 = objc_getProperty(v138, v139, 72, 1);
              v140 = v138;
              objc_msgSend(v140, "port");
              v141 = (void *)objc_claimAutoreleasedReturnValue();
              -[NSObject setNatTraversalPort:](v24, "setNatTraversalPort:", (unsigned __int16)objc_msgSend(v141, "intValue"));

              v143 = objc_getProperty((id)a1, v142, 336, 1);
              if (v143)
                v143 = objc_getProperty(v143, v144, 64, 1);
              v145 = v143;
              objc_msgSend(v145, "port");
              v146 = (void *)objc_claimAutoreleasedReturnValue();
              -[NSObject setNatTraversalSrcPort:](v24, "setNatTraversalSrcPort:", (unsigned __int16)objc_msgSend(v146, "intValue"));

              ne_log_obj();
              v115 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v115, OS_LOG_TYPE_INFO))
              {
                v206 = 138412290;
                v207 = (const char *)a1;
                v126 = "%@ Enabling NAT traversal (install)";
LABEL_102:
                _os_log_impl(&dword_19BD16000, v115, OS_LOG_TYPE_INFO, v126, (uint8_t *)&v206, 0xCu);
              }
LABEL_103:

LABEL_104:
              v147 = objc_getProperty((id)a1, v121, 336, 1);
              if (v147 && (v147[14] & 1) != 0)
              {
                v149 = objc_getProperty((id)a1, v148, 336, 1);
                if (v149)
                  v149 = objc_getProperty(v149, v150, 88, 1);
                v151 = v149;
                v152 = objc_msgSend(v151, "natTraversalKeepaliveDisabled");

                if ((v152 & 1) == 0)
                {
                  -[NSObject setNatKeepaliveEnabled:](v24, "setNatKeepaliveEnabled:", 1);
                  v154 = objc_getProperty((id)a1, v153, 336, 1);
                  if (v154)
                    v154 = objc_getProperty(v154, v155, 88, 1);
                  v156 = v154;
                  v157 = objc_msgSend(v156, "natTraversalKeepaliveOffloadEnabled");

                  if (v157)
                  {
                    -[NSObject setNatKeepaliveOffloadEnabled:](v24, "setNatKeepaliveOffloadEnabled:", 1);
                    v160 = objc_getProperty((id)a1, v159, 336, 1);
                    if (v160)
                      v160 = objc_getProperty(v160, v161, 88, 1);
                    v162 = v160;
                    -[NSObject setNatKeepaliveOffloadIntervalSeconds:](v24, "setNatKeepaliveOffloadIntervalSeconds:", objc_msgSend(v162, "natTraversalKeepaliveOffloadInterval"));

                  }
                  v163 = objc_getProperty((id)a1, v158, 336, 1);
                  if (v163)
                    v163 = objc_getProperty(v163, v164, 88, 1);
                  v165 = v163;
                  -[NSObject setNatKeepaliveIntervalSeconds:](v24, "setNatKeepaliveIntervalSeconds:", objc_msgSend(v165, "natTraversalKeepaliveInterval"));

                }
              }
              v166 = objc_getProperty((id)a1, v148, 336, 1);
              if (v166 && (v166[15] & 1) != 0)
                -[NSObject setNatDetectedOnPeer:](v22, "setNatDetectedOnPeer:", 1);
              v168 = objc_getProperty((id)a1, v167, 336, 1);
              if (v168)
                v168 = objc_getProperty(v168, v169, 304, 1);
              v170 = v168;
              -[NSObject setBoundInterfaceName:](v24, "setBoundInterfaceName:", v170);

              if (!*(_QWORD *)(a1 + 328))
                -[NEIKEv2Session addEmptyInterface](a1);
              v171 = (void *)-[NEIKEv2Session copyIPsecInterfaceWithMissingAllowed:](a1, 0);
              objc_msgSend(v171, "interfaceName");
              v172 = (void *)objc_claimAutoreleasedReturnValue();
              -[NSObject setTunnelInterfaceName:](v24, "setTunnelInterfaceName:", v172);

              if (!objc_msgSend(objc_getProperty((id)a1, v173, 176, 1), "addSA:", v24))
                goto LABEL_148;
              objc_setProperty_atomic(v4, v174, 0, 160);
              objc_setProperty_atomic(v4, v175, 0, 168);
              -[NSObject setEncryptionKey:](v24, "setEncryptionKey:", 0);
              -[NSObject setAuthenticationKey:](v24, "setAuthenticationKey:", 0);
              objc_msgSend(objc_getProperty((id)a1, v176, 192, 1), "setObject:forKeyedSubscript:", v4, v24);
              if (!objc_msgSend(objc_getProperty((id)a1, v177, 176, 1), "updateSA:", v22))
                goto LABEL_148;
              objc_setProperty_atomic(v4, v178, 0, 144);
              objc_setProperty_atomic(v4, v179, 0, 152);
              -[NSObject setEncryptionKey:](v22, "setEncryptionKey:", 0);
              -[NSObject setAuthenticationKey:](v22, "setAuthenticationKey:", 0);
              objc_msgSend(objc_getProperty((id)a1, v180, 192, 1), "setObject:forKeyedSubscript:", v4, v22);
              objc_msgSend(objc_getProperty((id)a1, v181, 184, 1), "setObject:forKeyedSubscript:", 0, v22);
              v183 = objc_getProperty((id)a1, v182, 336, 1);
              if (v183)
                v183 = objc_getProperty(v183, v184, 88, 1);
              v185 = v183;
              v186 = objc_msgSend(v185, "idleTimeoutEnabled");

              if (v186)
              {
                v188 = objc_getProperty((id)a1, v187, 176, 1);
                v190 = objc_getProperty((id)a1, v189, 336, 1);
                if (v190)
                  v190 = objc_getProperty(v190, v191, 88, 1);
                v192 = v190;
                objc_msgSend(v188, "startIdleTimeout:incomingSA:outgoingSA:", objc_msgSend(v192, "idleTimeoutSeconds"), v22, v24);

              }
              v193 = objc_getProperty((id)a1, v187, 336, 1);
              if (v193)
                v193 = objc_getProperty(v193, v194, 88, 1);
              v195 = v193;
              v196 = objc_msgSend(v195, "blackholeDetectionEnabled");

              v55 = 1;
              if (v196)
                objc_msgSend(objc_getProperty((id)a1, v197, 176, 1), "startBlackholeDetection:incomingSA:outgoingSA:", 20, v22, v24);
              break;
            default:
              ne_log_obj();
              v60 = objc_claimAutoreleasedReturnValue();
              if (!os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
                goto LABEL_147;
              v61 = (char *)objc_getProperty(v4, v101, 56, 1);
              -[NEIKEv2ChildSAProposal integrityProtocol](v61, v102);
              v103 = (void *)objc_claimAutoreleasedReturnValue();
              v104 = objc_msgSend(v103, "type");
              v206 = 138412546;
              v207 = (const char *)a1;
              v208 = 1024;
              LODWORD(v209) = v104;
              v105 = "%@ Unsupported integrity type %u";
              v106 = v60;
              v107 = 18;
LABEL_140:
              _os_log_error_impl(&dword_19BD16000, v106, OS_LOG_TYPE_ERROR, v105, (uint8_t *)&v206, v107);

              goto LABEL_141;
          }
          goto LABEL_149;
        }
        if (v52 == 12)
        {
          v64 = objc_getProperty(v4, v53, 56, 1);
          -[NEIKEv2ChildSAProposal encryptionProtocol](v64, v65);
          v66 = (_BYTE *)objc_claimAutoreleasedReturnValue();
          if (!v66)
          {

            v52 = 4;
            goto LABEL_65;
          }
          v67 = v66[8];

          v68 = (v67 & 1) == 0;
          v69 = 4;
LABEL_62:
          if (v68)
            v52 = v69;
          else
            v52 = v69 + 1;
          goto LABEL_65;
        }
      }
      else
      {
        if (v52 <= 29)
        {
          if (v52 != 20)
          {
            if (v52 == 28)
            {
              v52 = 8;
              goto LABEL_65;
            }
            goto LABEL_146;
          }
          v70 = objc_getProperty(v4, v53, 56, 1);
          -[NEIKEv2ChildSAProposal encryptionProtocol](v70, v71);
          v72 = (_BYTE *)objc_claimAutoreleasedReturnValue();
          if (!v72)
          {

            v52 = 6;
            goto LABEL_65;
          }
          v73 = v72[8];

          v68 = (v73 & 1) == 0;
          v69 = 6;
          goto LABEL_62;
        }
        if (v52 == 30)
        {
          v74 = objc_getProperty(v4, v53, 56, 1);
          -[NEIKEv2ChildSAProposal encryptionProtocol](v74, v75);
          v76 = (_BYTE *)objc_claimAutoreleasedReturnValue();
          if (!v76)
          {

            v52 = 10;
            goto LABEL_65;
          }
          v77 = v76[8];

          v68 = (v77 & 1) == 0;
          v69 = 10;
          goto LABEL_62;
        }
        if (v52 == 31)
        {
          v52 = 9;
          goto LABEL_65;
        }
      }
    }
    else
    {

    }
LABEL_146:
    ne_log_obj();
    v60 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
    {
      v201 = objc_getProperty(v4, v200, 56, 1);
      -[NEIKEv2ChildSAProposal encryptionProtocol](v201, v202);
      v203 = objc_claimAutoreleasedReturnValue();
      v204 = (void *)v203;
      if (v203)
        v203 = *(_QWORD *)(v203 + 16);
      String = NEIKEv2EncryptionWireTypeCreateString(v203);
      v206 = 138412546;
      v207 = (const char *)a1;
      v208 = 2112;
      v209 = String;
      _os_log_error_impl(&dword_19BD16000, v60, OS_LOG_TYPE_ERROR, "%@ Unsupported encryption wire type %@", (uint8_t *)&v206, 0x16u);

    }
    goto LABEL_147;
  }
  ne_log_obj();
  v22 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT))
  {
    v206 = 136315138;
    v207 = "-[NEIKEv2Session installChildSA:]";
    v54 = "%s called with null childSA.chosenProposal";
    goto LABEL_42;
  }
LABEL_43:
  v55 = 0;
LABEL_44:

LABEL_45:
  return v55;
}

- (uint64_t)migrateAllChildSAs
{
  uint64_t v3;
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t i;
  NSObject *v9;
  SEL v10;
  const char *v11;
  id Property;
  const char *v13;
  id v14;
  const char *v15;
  id v16;
  const char *v17;
  id v18;
  const char *v19;
  id v20;
  NSObject *v21;
  NSObject *v22;
  const char *v23;
  id v24;
  SEL v25;
  id v26;
  SEL v27;
  id v28;
  const char *v29;
  void *v30;
  id v31;
  const char *v32;
  id v33;
  SEL v34;
  id v35;
  const char *v36;
  void *v37;
  id v38;
  NSObject *v39;
  const char *v40;
  id v41;
  const char *v42;
  id v43;
  SEL v44;
  id v45;
  const char *v46;
  id v47;
  SEL v48;
  id v49;
  const char *v50;
  id v51;
  SEL v52;
  id v53;
  const char *v54;
  id v55;
  void *v56;
  void *v57;
  void *v58;
  SEL v59;
  id v60;
  const char *v61;
  id v62;
  void *v63;
  SEL v64;
  _BYTE *v65;
  const char *v66;
  _BYTE *v67;
  NSObject *v68;
  NSObject *v69;
  const char *v70;
  SEL v71;
  id v72;
  const char *v73;
  id v74;
  void *v75;
  SEL v76;
  id v77;
  const char *v78;
  id v79;
  void *v80;
  SEL v81;
  id v82;
  const char *v83;
  id v84;
  void *v85;
  SEL v86;
  id v87;
  const char *v88;
  id v89;
  void *v90;
  SEL v91;
  _BYTE *v92;
  const char *v93;
  id v94;
  const char *v95;
  id v96;
  char v97;
  SEL v98;
  id v99;
  const char *v100;
  id v101;
  int v102;
  const char *v103;
  SEL v104;
  id v105;
  const char *v106;
  id v107;
  id v108;
  const char *v109;
  id v110;
  _BYTE *v111;
  const char *v112;
  const char *v113;
  int v114;
  NSObject *v115;
  const char *v116;
  id v117;
  const char *v118;
  const char *v119;
  NSObject *v120;
  const char *v121;
  const char *v122;
  id v124;
  const char *v125;
  void *v126;
  char *v127;
  SEL v128;
  id v129;
  SEL v130;
  NSObject *v131;
  id v132;
  const char *v133;
  void *v134;
  char *v135;
  SEL v136;
  id v137;
  SEL v138;
  NSObject *v139;
  id v140;
  __int128 v141;
  id obj;
  __int128 v143;
  __int128 v144;
  __int128 v145;
  __int128 v146;
  uint8_t v147[128];
  uint8_t buf[4];
  const char *v149;
  __int16 v150;
  id v151;
  __int16 v152;
  NSObject *v153;
  __int16 v154;
  NSObject *v155;
  uint64_t v156;

  v156 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 0;
  v145 = 0u;
  v146 = 0u;
  v143 = 0u;
  v144 = 0u;
  v3 = 1;
  obj = objc_getProperty((id)a1, a2, 288, 1);
  v4 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v143, v147, 16);
  if (!v4)
    goto LABEL_101;
  v6 = v4;
  v7 = *(_QWORD *)v144;
  *(_QWORD *)&v5 = 138413058;
  v141 = v5;
  while (2)
  {
    for (i = 0; i != v6; ++i)
    {
      if (*(_QWORD *)v144 != v7)
        objc_enumerationMutation(obj);
      v9 = *(id *)(*((_QWORD *)&v143 + 1) + 8 * i);
      if (!objc_getProperty((id)a1, v10, 336, 1))
      {
        ne_log_obj();
        v22 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 136315138;
          v149 = "-[NEIKEv2Session migrateChildSA:]";
          v118 = "%s called with null self.ikeSA";
          goto LABEL_90;
        }
        goto LABEL_99;
      }
      if (!v9)
      {
        ne_log_obj();
        v22 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 136315138;
          v149 = "-[NEIKEv2Session migrateChildSA:]";
          _os_log_fault_impl(&dword_19BD16000, v22, OS_LOG_TYPE_FAULT, "%s called with null childSA", buf, 0xCu);
        }
        v9 = 0;
        goto LABEL_99;
      }
      Property = objc_getProperty((id)a1, v11, 336, 1);
      if (Property)
        Property = objc_getProperty(Property, v13, 64, 1);
      v14 = Property;

      if (!v14)
      {
        ne_log_obj();
        v22 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 136315138;
          v149 = "-[NEIKEv2Session migrateChildSA:]";
          v118 = "%s called with null self.ikeSA.localAddress";
          goto LABEL_90;
        }
LABEL_99:

LABEL_100:
        v3 = 0;
        goto LABEL_101;
      }
      v16 = objc_getProperty((id)a1, v15, 336, 1);
      if (v16)
        v16 = objc_getProperty(v16, v17, 72, 1);
      v18 = v16;

      if (!v18)
      {
        ne_log_obj();
        v22 = objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled(v22, OS_LOG_TYPE_FAULT))
          goto LABEL_99;
        *(_DWORD *)buf = 136315138;
        v149 = "-[NEIKEv2Session migrateChildSA:]";
        v118 = "%s called with null self.ikeSA.remoteAddress";
LABEL_90:
        _os_log_fault_impl(&dword_19BD16000, v22, OS_LOG_TYPE_FAULT, v118, buf, 0xCu);
        goto LABEL_99;
      }
      v20 = objc_getProperty(v9, v19, 56, 1);

      ne_log_obj();
      v21 = objc_claimAutoreleasedReturnValue();
      v22 = v21;
      if (!v20)
      {
        if (!os_log_type_enabled(v21, OS_LOG_TYPE_FAULT))
          goto LABEL_99;
        *(_DWORD *)buf = 136315138;
        v149 = "-[NEIKEv2Session migrateChildSA:]";
        v118 = "%s called with null childSA.chosenProposal";
        goto LABEL_90;
      }
      if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
      {
        v24 = objc_getProperty((id)a1, v23, 176, 1);
        *(_DWORD *)buf = 138412802;
        v149 = (const char *)a1;
        v150 = 2112;
        v151 = v24;
        v152 = 2112;
        v153 = v9;
        _os_log_impl(&dword_19BD16000, v22, OS_LOG_TYPE_INFO, "%@ %@ Migrating childSA %@", buf, 0x20u);
      }

      v26 = objc_getProperty((id)a1, v25, 192, 1);
      v28 = objc_getProperty(v9, v27, 56, 1);
      v30 = v28;
      if (v28)
        v28 = objc_getProperty(v28, v29, 80, 1);
      v31 = v28;
      v22 = -[NEIKEv2Session copySAFromDictionary:forSPI:](v26, v31);

      if (!v22)
      {
        ne_log_obj();
        v39 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v39, OS_LOG_TYPE_FAULT))
        {
          v124 = objc_getProperty(v9, v119, 56, 1);
          v126 = v124;
          if (v124)
            v124 = objc_getProperty(v124, v125, 80, 1);
          v127 = (char *)v124;
          v129 = objc_getProperty((id)a1, v128, 192, 1);
          v131 = objc_getProperty((id)a1, v130, 184, 1);
          *(_DWORD *)buf = 138412802;
          v149 = v127;
          v150 = 2112;
          v151 = v129;
          v152 = 2112;
          v153 = v131;
          _os_log_fault_impl(&dword_19BD16000, v39, OS_LOG_TYPE_FAULT, "copySAFromDictionary incoming %@ databaseSAs %@ databaseLarvalSAs %@ failed", buf, 0x20u);

        }
        v22 = 0;
        goto LABEL_98;
      }
      v33 = objc_getProperty((id)a1, v32, 192, 1);
      v35 = objc_getProperty(v9, v34, 56, 1);
      v37 = v35;
      if (v35)
        v35 = objc_getProperty(v35, v36, 88, 1);
      v38 = v35;
      v39 = -[NEIKEv2Session copySAFromDictionary:forSPI:](v33, v38);

      if (!v39)
      {
        ne_log_obj();
        v120 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v120, OS_LOG_TYPE_FAULT))
        {
          v132 = objc_getProperty(v9, v121, 56, 1);
          v134 = v132;
          if (v132)
            v132 = objc_getProperty(v132, v133, 88, 1);
          v135 = (char *)v132;
          v137 = objc_getProperty((id)a1, v136, 192, 1);
          v139 = objc_getProperty((id)a1, v138, 184, 1);
          *(_DWORD *)buf = 138412802;
          v149 = v135;
          v150 = 2112;
          v151 = v137;
          v152 = 2112;
          v153 = v139;
          _os_log_fault_impl(&dword_19BD16000, v120, OS_LOG_TYPE_FAULT, "copySAFromDictionary outgoing %@ databaseSAs %@ databaseLarvalSAs %@ failed", buf, 0x20u);

        }
        v39 = 0;
        goto LABEL_97;
      }
      v41 = objc_getProperty((id)a1, v40, 336, 1);
      if (v41)
        v41 = objc_getProperty(v41, v42, 64, 1);
      v43 = v41;
      -[NSObject setLocalAddress:](v22, "setLocalAddress:", v43);

      v45 = objc_getProperty((id)a1, v44, 336, 1);
      if (v45)
        v45 = objc_getProperty(v45, v46, 72, 1);
      v47 = v45;
      -[NSObject setRemoteAddress:](v22, "setRemoteAddress:", v47);

      v49 = objc_getProperty((id)a1, v48, 336, 1);
      if (v49)
        v49 = objc_getProperty(v49, v50, 64, 1);
      v51 = v49;
      -[NSObject setLocalAddress:](v39, "setLocalAddress:", v51);

      v53 = objc_getProperty((id)a1, v52, 336, 1);
      if (v53)
        v53 = objc_getProperty(v53, v54, 72, 1);
      v55 = v53;
      -[NSObject setRemoteAddress:](v39, "setRemoteAddress:", v55);

      if (!*(_QWORD *)(a1 + 328))
        -[NEIKEv2Session addEmptyInterface](a1);
      v56 = (void *)-[NEIKEv2Session copyIPsecInterfaceWithMissingAllowed:](a1, 0);
      objc_msgSend(v56, "interfaceName");
      v57 = (void *)objc_claimAutoreleasedReturnValue();
      -[NSObject setTunnelInterfaceName:](v39, "setTunnelInterfaceName:", v57);

      -[NSObject tunnelInterfaceName](v39, "tunnelInterfaceName");
      v58 = (void *)objc_claimAutoreleasedReturnValue();
      -[NSObject setTunnelInterfaceName:](v22, "setTunnelInterfaceName:", v58);

      v60 = objc_getProperty((id)a1, v59, 336, 1);
      if (v60)
        v60 = objc_getProperty(v60, v61, 304, 1);
      v62 = v60;
      -[NSObject setBoundInterfaceName:](v39, "setBoundInterfaceName:", v62);

      -[NSObject boundInterfaceName](v39, "boundInterfaceName");
      v63 = (void *)objc_claimAutoreleasedReturnValue();
      -[NSObject setBoundInterfaceName:](v22, "setBoundInterfaceName:", v63);

      v65 = objc_getProperty((id)a1, v64, 336, 1);
      if (v65 && (v65[14] & 1) != 0 || (v67 = objc_getProperty((id)a1, v66, 336, 1)) != 0 && (v67[15] & 1) != 0)
      {
        if ((objc_msgSend(*(id *)(a1 + 384), "disableSwitchToNATTPorts", v141) & 1) != 0)
        {
          ne_log_obj();
          v68 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v68, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)buf = 138412290;
            v149 = (const char *)a1;
            v69 = v68;
            v70 = "%@ Not enabling NAT traversal (migrate) because disabled";
            goto LABEL_55;
          }
        }
        else
        {
          -[NSObject setNatTraversalEnabled:](v22, "setNatTraversalEnabled:", 1);
          -[NSObject setNatTraversalEnabled:](v39, "setNatTraversalEnabled:", 1);
          v72 = objc_getProperty((id)a1, v71, 336, 1);
          if (v72)
            v72 = objc_getProperty(v72, v73, 64, 1);
          v74 = v72;
          objc_msgSend(v74, "port");
          v75 = (void *)objc_claimAutoreleasedReturnValue();
          -[NSObject setNatTraversalPort:](v22, "setNatTraversalPort:", (unsigned __int16)objc_msgSend(v75, "intValue"));

          v77 = objc_getProperty((id)a1, v76, 336, 1);
          if (v77)
            v77 = objc_getProperty(v77, v78, 72, 1);
          v79 = v77;
          objc_msgSend(v79, "port");
          v80 = (void *)objc_claimAutoreleasedReturnValue();
          -[NSObject setNatTraversalSrcPort:](v22, "setNatTraversalSrcPort:", (unsigned __int16)objc_msgSend(v80, "intValue"));

          v82 = objc_getProperty((id)a1, v81, 336, 1);
          if (v82)
            v82 = objc_getProperty(v82, v83, 72, 1);
          v84 = v82;
          objc_msgSend(v84, "port");
          v85 = (void *)objc_claimAutoreleasedReturnValue();
          -[NSObject setNatTraversalPort:](v39, "setNatTraversalPort:", (unsigned __int16)objc_msgSend(v85, "intValue"));

          v87 = objc_getProperty((id)a1, v86, 336, 1);
          if (v87)
            v87 = objc_getProperty(v87, v88, 64, 1);
          v89 = v87;
          objc_msgSend(v89, "port");
          v90 = (void *)objc_claimAutoreleasedReturnValue();
          -[NSObject setNatTraversalSrcPort:](v39, "setNatTraversalSrcPort:", (unsigned __int16)objc_msgSend(v90, "intValue"));

          ne_log_obj();
          v68 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v68, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)buf = 138412290;
            v149 = (const char *)a1;
            v69 = v68;
            v70 = "%@ Enabling NAT traversal (migrate)";
            goto LABEL_55;
          }
        }
      }
      else
      {
        -[NSObject setNatTraversalEnabled:](v22, "setNatTraversalEnabled:", 0, v141);
        -[NSObject setNatTraversalEnabled:](v39, "setNatTraversalEnabled:", 0);
        -[NSObject setNatTraversalPort:](v22, "setNatTraversalPort:", 0);
        -[NSObject setNatTraversalSrcPort:](v22, "setNatTraversalSrcPort:", 0);
        -[NSObject setNatTraversalPort:](v39, "setNatTraversalPort:", 0);
        -[NSObject setNatTraversalSrcPort:](v39, "setNatTraversalSrcPort:", 0);
        ne_log_obj();
        v68 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v68, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 138412290;
          v149 = (const char *)a1;
          v69 = v68;
          v70 = "%@ Disabling NAT traversal (migrate)";
LABEL_55:
          _os_log_impl(&dword_19BD16000, v69, OS_LOG_TYPE_INFO, v70, buf, 0xCu);
        }
      }

      v92 = objc_getProperty((id)a1, v91, 336, 1);
      if (v92 && (v92[14] & 1) != 0)
      {
        v94 = objc_getProperty((id)a1, v93, 336, 1);
        if (v94)
          v94 = objc_getProperty(v94, v95, 88, 1);
        v96 = v94;
        v97 = objc_msgSend(v96, "natTraversalKeepaliveDisabled");

        if ((v97 & 1) == 0)
        {
          -[NSObject setNatKeepaliveEnabled:](v39, "setNatKeepaliveEnabled:", 1);
          v99 = objc_getProperty((id)a1, v98, 336, 1);
          if (v99)
            v99 = objc_getProperty(v99, v100, 88, 1);
          v101 = v99;
          v102 = objc_msgSend(v101, "natTraversalKeepaliveOffloadEnabled");

          if (v102)
          {
            -[NSObject setNatKeepaliveOffloadEnabled:](v39, "setNatKeepaliveOffloadEnabled:", 1);
            v105 = objc_getProperty((id)a1, v104, 336, 1);
            if (v105)
              v105 = objc_getProperty(v105, v106, 88, 1);
            v107 = v105;
            -[NSObject setNatKeepaliveOffloadIntervalSeconds:](v39, "setNatKeepaliveOffloadIntervalSeconds:", objc_msgSend(v107, "natTraversalKeepaliveOffloadInterval"));

          }
          v108 = objc_getProperty((id)a1, v103, 336, 1);
          if (v108)
            v108 = objc_getProperty(v108, v109, 88, 1);
          v110 = v108;
          -[NSObject setNatKeepaliveIntervalSeconds:](v39, "setNatKeepaliveIntervalSeconds:", objc_msgSend(v110, "natTraversalKeepaliveInterval"));

        }
      }
      v111 = objc_getProperty((id)a1, v93, 336, 1);
      if (v111 && (v111[15] & 1) != 0)
        -[NSObject setNatDetectedOnPeer:](v22, "setNatDetectedOnPeer:", 1);
      v114 = objc_msgSend(objc_getProperty((id)a1, v112, 176, 1), "migrateSA:", v22);
      if ((v114 & 1) == 0)
      {
        ne_log_large_obj();
        v115 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v115, OS_LOG_TYPE_ERROR))
        {
          v117 = objc_getProperty((id)a1, v116, 176, 1);
          *(_DWORD *)buf = v141;
          v149 = (const char *)a1;
          v150 = 2112;
          v151 = v117;
          v152 = 2112;
          v153 = v22;
          v154 = 2112;
          v155 = v9;
          _os_log_error_impl(&dword_19BD16000, v115, OS_LOG_TYPE_ERROR, "%@ %@ Failed to migrate incoming SA %@ for %@", buf, 0x2Au);
        }

      }
      if ((objc_msgSend(objc_getProperty((id)a1, v113, 176, 1), "migrateSA:", v39) & 1) == 0)
      {
        ne_log_large_obj();
        v120 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v120, OS_LOG_TYPE_ERROR))
        {
          v140 = objc_getProperty((id)a1, v122, 176, 1);
          *(_DWORD *)buf = v141;
          v149 = (const char *)a1;
          v150 = 2112;
          v151 = v140;
          v152 = 2112;
          v153 = v39;
          v154 = 2112;
          v155 = v9;
          _os_log_error_impl(&dword_19BD16000, v120, OS_LOG_TYPE_ERROR, "%@ %@ Failed to migrate outgoing SA %@ for %@", buf, 0x2Au);
        }
LABEL_97:

LABEL_98:
        goto LABEL_99;
      }

      if (!v114)
        goto LABEL_100;
    }
    v6 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v143, v147, 16);
    v3 = 1;
    if (v6)
      continue;
    break;
  }
LABEL_101:

  return v3;
}

- (void)setSentMOBIKERequest:(int)a3 messageID:
{
  const char *v5;
  id v6;
  SEL v7;
  NSObject *v8;
  const char *v9;
  int v10;
  uint64_t v11;
  __int16 v12;
  int v13;
  __int16 v14;
  id Property;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v6 = a2;
  if (a1)
  {
    if ((*(_BYTE *)(a1 + 11) & 1) == 0)
    {
      objc_setProperty_atomic((id)a1, v5, v6, 376);
      *(_DWORD *)(a1 + 24) = a3;
      if (objc_getProperty((id)a1, v7, 376, 1))
      {
        ne_log_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
        {
          v10 = 138412802;
          v11 = a1;
          v12 = 1024;
          v13 = a3;
          v14 = 2112;
          Property = objc_getProperty((id)a1, v9, 376, 1);
          _os_log_impl(&dword_19BD16000, v8, OS_LOG_TYPE_INFO, "%@ Saving MOBIKE request (message %u) %@\n", (uint8_t *)&v10, 0x1Cu);
        }

      }
    }
  }

}

- (uint64_t)sendCurrentRequest:(uint64_t)a1
{
  const char *v3;
  id v4;
  NSObject *Property;
  SEL v6;
  _BYTE *v7;
  const char *v8;
  const char *v9;
  id *v10;
  const char *v11;
  id *v12;
  SEL v13;
  id v14;
  void *v15;
  uint64_t v16;
  id v17;
  void *v18;
  void *v19;
  NSObject *v20;
  void *v21;
  char v22;
  NSObject *v23;
  SEL v24;
  id v25;
  NSObject *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  int v31;
  uint64_t v32;
  int v33;
  void *v34;
  NSObject *v35;
  int v36;
  int v37;
  NSObject *v38;
  const char *v40;
  NSObject *v41;
  NSObject *v42;
  id v43;
  void *v45;
  int v46;
  int v47;
  void *v48;
  int v49;
  id obj;
  _QWORD v51[4];
  NSObject *v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  _QWORD block[4];
  id *v58;
  uint8_t buf[4];
  uint64_t v60;
  __int16 v61;
  int v62;
  __int16 v63;
  int v64;
  __int16 v65;
  _BYTE v66[10];
  __int16 v67;
  id *v68;
  _BYTE v69[128];
  uint64_t v70;

  v70 = *MEMORY[0x1E0C80C00];
  v4 = a2;
  if (!a1)
    goto LABEL_41;
  Property = objc_getProperty((id)a1, v3, 368, 1);
  dispatch_assert_queue_V2(Property);
  v7 = objc_getProperty((id)a1, v6, 336, 1);
  if ((-[NEIKEv2IKESA hasTransport](v7, v8) & 1) != 0)
  {
    v10 = (id *)objc_getProperty((id)a1, v9, 336, 1);
    v12 = (id *)-[NEIKEv2IKESA copyTransport](v10, v11);
    v14 = objc_getProperty((id)a1, v13, 216, 1);
    v15 = (void *)MEMORY[0x1E0CB37E8];
    v16 = *(unsigned int *)(a1 + 16);
    v17 = v14;
    objc_msgSend(v15, "numberWithInt:", v16);
    v18 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v17, "objectForKeyedSubscript:", v18);
    v19 = (void *)objc_claimAutoreleasedReturnValue();

    if (objc_msgSend(v19, "count") == 1)
    {
      ne_log_obj();
      v20 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
      {
        objc_msgSend(v19, "firstObject");
        v45 = (void *)objc_claimAutoreleasedReturnValue();
        v46 = objc_msgSend(v45, "length");
        v47 = *(_DWORD *)(a1 + 16);
        *(_DWORD *)buf = 138413058;
        v60 = a1;
        v61 = 1024;
        v62 = v46;
        v63 = 1024;
        v64 = v47;
        v65 = 2112;
        *(_QWORD *)v66 = v12;
        _os_log_debug_impl(&dword_19BD16000, v20, OS_LOG_TYPE_DEBUG, "%@ Sending request of length %u with ID %u on %@\n", buf, 0x22u);

      }
      objc_msgSend(v19, "firstObject");
      v21 = (void *)objc_claimAutoreleasedReturnValue();
      v22 = -[NEIKEv2Transport sendData:sendCompletionHandler:](v12, v21, v4);

      if ((v22 & 1) == 0)
      {
        ne_log_obj();
        v23 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 138412290;
          v60 = a1;
          _os_log_error_impl(&dword_19BD16000, v23, OS_LOG_TYPE_ERROR, "%@ Sending request data failed", buf, 0xCu);
        }

        v25 = objc_getProperty((id)a1, v24, 336, 1);
        -[NEIKEv2IKESA detachTransportWithShouldInvalidate:](v25, 1);
LABEL_38:
        a1 = 0;
        goto LABEL_39;
      }
    }
    else if (objc_msgSend(v19, "count"))
    {
      v48 = v19;
      v49 = objc_msgSend(v19, "count");
      v53 = 0u;
      v54 = 0u;
      v55 = 0u;
      v56 = 0u;
      obj = v19;
      v27 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v53, v69, 16);
      if (!v27)
        goto LABEL_26;
      v28 = v27;
      v29 = *(_QWORD *)v54;
      v30 = -v49;
      v31 = 1;
LABEL_15:
      v32 = 0;
      v33 = v30 + v31;
      while (1)
      {
        if (*(_QWORD *)v54 != v29)
          objc_enumerationMutation(obj);
        v34 = *(void **)(*((_QWORD *)&v53 + 1) + 8 * v32);
        ne_log_obj();
        v35 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
        {
          v36 = objc_msgSend(v34, "length");
          v37 = *(_DWORD *)(a1 + 16);
          *(_DWORD *)buf = 138413570;
          v60 = a1;
          v61 = 1024;
          v62 = v31 + v32;
          v63 = 1024;
          v64 = v49;
          v65 = 1024;
          *(_DWORD *)v66 = v36;
          *(_WORD *)&v66[4] = 1024;
          *(_DWORD *)&v66[6] = v37;
          v67 = 2112;
          v68 = v12;
          _os_log_debug_impl(&dword_19BD16000, v35, OS_LOG_TYPE_DEBUG, "%@ Sending request fragment %u/%u of length %u with ID %u on %@\n", buf, 0x2Eu);
        }

        if (v33 + (_DWORD)v32)
        {
          if ((-[NEIKEv2Transport sendData:sendCompletionHandler:](v12, v34, 0) & 1) == 0)
          {
            ne_log_obj();
            v38 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 138412290;
              v60 = a1;
              _os_log_error_impl(&dword_19BD16000, v38, OS_LOG_TYPE_ERROR, "%@ Sending fragment request data failed", buf, 0xCu);
            }

            v19 = v48;
            if (v4)
            {
              v41 = objc_getProperty((id)a1, v40, 368, 1);
              v51[0] = MEMORY[0x1E0C809B0];
              v51[1] = 3221225472;
              v51[2] = __37__NEIKEv2Session_sendCurrentRequest___block_invoke_60;
              v51[3] = &unk_1E3CC4720;
              v52 = v4;
              dispatch_async(v41, v51);
              v42 = v52;
              goto LABEL_36;
            }
            goto LABEL_37;
          }
        }
        else if ((-[NEIKEv2Transport sendData:sendCompletionHandler:](v12, v34, v4) & 1) == 0)
        {
          ne_log_obj();
          v42 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 138412290;
            v60 = a1;
            _os_log_error_impl(&dword_19BD16000, v42, OS_LOG_TYPE_ERROR, "%@ Sending fragment request data failed", buf, 0xCu);
          }
          v19 = v48;
LABEL_36:

LABEL_37:
          v43 = objc_getProperty((id)a1, v40, 336, 1);
          -[NEIKEv2IKESA detachTransportWithShouldInvalidate:](v43, 1);

          goto LABEL_38;
        }
        if (v28 == ++v32)
        {
          v31 += v32;
          v28 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v53, v69, 16);
          v30 = -v49;
          if (v28)
            goto LABEL_15;
LABEL_26:

          a1 = 1;
          v19 = v48;
LABEL_39:

LABEL_40:
          goto LABEL_41;
        }
      }
    }
    a1 = 1;
    goto LABEL_39;
  }
  if (v4)
  {
    v26 = objc_getProperty((id)a1, v9, 368, 1);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = __37__NEIKEv2Session_sendCurrentRequest___block_invoke;
    block[3] = &unk_1E3CC4720;
    v58 = (id *)v4;
    dispatch_async(v26, block);
    a1 = 0;
    v12 = v58;
    goto LABEL_40;
  }
  a1 = 0;
LABEL_41:

  return a1;
}

uint64_t __37__NEIKEv2Session_sendCurrentRequest___block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t __37__NEIKEv2Session_sendCurrentRequest___block_invoke_60(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

- (uint64_t)sendRequest:(unint64_t)a3 retryIntervalInMilliseconds:(int)a4 maxRetries:(void *)a5 timeoutError:(char)a6 resend:(uint64_t)a7 sendMessageID:(void *)a8 sendCompletionHandler:(void *)a9 replyHandler:
{
  _DWORD *v14;
  id v15;
  const char *v16;
  NSObject *Property;
  SEL v18;
  const char *v19;
  const char *v20;
  NSObject *v21;
  const char *v22;
  NSObject *v23;
  NSObject *v24;
  const char *v25;
  NSObject *v26;
  SEL v27;
  SEL v28;
  id v29;
  void *v30;
  SEL v31;
  NSObject *v32;
  int v33;
  const char *v34;
  SEL v35;
  _BYTE *v36;
  const char *v37;
  int v38;
  id v39;
  void *v40;
  uint64_t v41;
  id v42;
  void *v43;
  const char *v44;
  int v45;
  int v46;
  id v47;
  SEL v48;
  id v49;
  SEL v50;
  id v51;
  SEL v52;
  _DWORD *v53;
  id v54;
  NSObject *v55;
  NSObject *v56;
  const char *v57;
  NSObject *v58;
  NSObject *v59;
  NSObject *v60;
  unint64_t v61;
  id v62;
  _BYTE *v63;
  NSObject *v64;
  dispatch_source_t v65;
  SEL v66;
  SEL v67;
  const char *v68;
  int64_t v69;
  NSObject *v70;
  dispatch_time_t v71;
  SEL v72;
  NSObject *v73;
  SEL v74;
  NSObject *v75;
  id *v76;
  const char *v77;
  const char *v78;
  NSObject *v79;
  int v81;
  id v82;
  id v83;
  id v86;
  id newValue;
  _QWORD v88[4];
  id v89;
  _QWORD v90[5];
  NSObject *v91;
  id v92;
  int v93;
  _QWORD handler[5];
  NSObject *v95;
  id v96;
  _BYTE *v97;
  unint64_t v98;
  int v99;
  int v100;
  _QWORD v101[4];
  NSObject *v102;
  _QWORD block[4];
  NSObject *v104;
  _BYTE buf[24];
  _DWORD v106[6];
  uint8_t v107[4];
  id v108;
  uint64_t v109;

  v109 = *MEMORY[0x1E0C80C00];
  v14 = a2;
  v86 = a5;
  v15 = a8;
  newValue = a9;
  if (!a1)
  {
    a7 = 0;
    goto LABEL_66;
  }
  Property = objc_getProperty((id)a1, v16, 368, 1);
  dispatch_assert_queue_V2(Property);
  if (!objc_getProperty((id)a1, v18, 336, 1))
  {
    ne_log_obj();
    v24 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = "-[NEIKEv2Session sendRequest:retryIntervalInMilliseconds:maxRetries:timeoutError:resend:sendM"
                           "essageID:sendCompletionHandler:replyHandler:]";
      _os_log_fault_impl(&dword_19BD16000, v24, OS_LOG_TYPE_FAULT, "%s called with null self.ikeSA", buf, 0xCu);
    }
    a7 = 0xFFFFFFFFLL;
    goto LABEL_65;
  }
  if (!objc_getProperty((id)a1, v19, 200, 1))
  {
    *(_BYTE *)(a1 + 11) = 0;
    v24 = objc_getProperty((id)a1, v20, 336, 1);
    if ((a6 & 1) != 0)
    {
      *(_DWORD *)(a1 + 16) = a7;
      ne_log_obj();
      v26 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v26, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 138412546;
        *(_QWORD *)&buf[4] = a1;
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = a7;
        _os_log_impl(&dword_19BD16000, v26, OS_LOG_TYPE_INFO, "%@ Re-sending message ID %u", buf, 0x12u);
      }

    }
    else
    {
      a7 = (*(_DWORD *)(a1 + 16) + 1);
      *(_DWORD *)(a1 + 16) = a7;
    }
    -[NEIKEv2Session cancelSendTimer]((void *)a1, v25);
    objc_setProperty_atomic_copy((id)a1, v27, newValue, 200);
    v14[6] = a7;
    v29 = objc_getProperty((id)a1, v28, 336, 1);
    v83 = -[NEIKEv2Packet copyPacketDatagramsForIKESA:](v14, v29);
    if (!v83)
    {
      ne_log_obj();
      v56 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138412290;
        *(_QWORD *)&buf[4] = a1;
        _os_log_error_impl(&dword_19BD16000, v56, OS_LOG_TYPE_ERROR, "%@ Failed to generate datagrams from packet", buf, 0xCu);
      }

      if (!v15)
      {
        a7 = 0xFFFFFFFFLL;
LABEL_64:

        goto LABEL_65;
      }
      v58 = objc_getProperty((id)a1, v57, 368, 1);
      v101[0] = MEMORY[0x1E0C809B0];
      v101[1] = 3221225472;
      v101[2] = __138__NEIKEv2Session_sendRequest_retryIntervalInMilliseconds_maxRetries_timeoutError_resend_sendMessageID_sendCompletionHandler_replyHandler___block_invoke_61;
      v101[3] = &unk_1E3CC4720;
      v102 = v15;
      dispatch_async(v58, v101);
      a7 = 0xFFFFFFFFLL;
      v59 = v102;
LABEL_63:

      goto LABEL_64;
    }
    if (v24 && (BYTE1(v24[1].isa) & 1) != 0 && !(_DWORD)a7 && objc_msgSend(v83, "count") == 1)
    {
      objc_msgSend(v83, "firstObject");
      v30 = (void *)objc_claimAutoreleasedReturnValue();
      objc_setProperty_atomic(v24, v31, v30, 312);

    }
    ne_log_large_obj();
    v32 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v32, OS_LOG_TYPE_INFO))
    {
      v33 = objc_msgSend(v83, "count");
      *(_DWORD *)buf = 138413058;
      *(_QWORD *)&buf[4] = a1;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v33;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = a7;
      LOWORD(v106[0]) = 2112;
      *(_QWORD *)((char *)v106 + 2) = v14;
      _os_log_impl(&dword_19BD16000, v32, OS_LOG_TYPE_INFO, "%@ Sending %u datagrams for packet (message %u): %@", buf, 0x22u);
    }

    if ((a6 & 1) == 0)
    {
      v82 = v83;
      v36 = objc_getProperty((id)a1, v35, 336, 1);
      v38 = 4;
      if (v36)
      {
        if ((v36[17] & 1) != 0)
          v38 = 6;
        else
          v38 = 4;
      }
      v39 = objc_getProperty((id)a1, v37, 216, 1);
      v40 = (void *)MEMORY[0x1E0CB37E8];
      v41 = *(unsigned int *)(a1 + 16);
      v42 = v39;
      objc_msgSend(v40, "numberWithInt:", v41);
      v43 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v42, "setObject:forKeyedSubscript:", v82, v43);

      v45 = *(_DWORD *)(a1 + 16);
      v46 = v45 - v38;
      if (v45 >= v38)
      {
        v47 = objc_getProperty((id)a1, v44, 216, 1);
        +[NEIKEv2Session removeItemsFromDictionary:lowerEdge:]((uint64_t)NEIKEv2Session, v47, v46);
        v49 = objc_getProperty((id)a1, v48, 240, 1);
        +[NEIKEv2Session removeItemsFromDictionary:lowerEdge:]((uint64_t)NEIKEv2Session, v49, v46);
        v51 = objc_getProperty((id)a1, v50, 256, 1);
        +[NEIKEv2Session removeItemsFromDictionary:lowerEdge:]((uint64_t)NEIKEv2Session, v51, v46);
      }

      v53 = objc_getProperty((id)a1, v52, 360, 1);
      v54 = (id)a1;
      if (v53)
      {
        if (v53[3] == -1)
        {
          v53[3] = a7;
          *(_QWORD *)buf = 0;
          *(_QWORD *)&buf[8] = 0;
          if (-[NEIKEv2RTT getCurrentTime:]((uint64_t)buf))
          {
            *((_QWORD *)v53 + 5) = 1000 * *(_QWORD *)buf + *(_DWORD *)&buf[8] / 1000;
          }
          else
          {
            ne_log_obj();
            v60 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)v107 = 138412290;
              v108 = v54;
              _os_log_error_impl(&dword_19BD16000, v60, OS_LOG_TYPE_ERROR, "%@, failed to start RTT measurement", v107, 0xCu);
            }

          }
        }
        else
        {
          ne_log_obj();
          v55 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
          {
            v81 = v53[3];
            *(_DWORD *)buf = 138412802;
            *(_QWORD *)&buf[4] = v54;
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v81;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = a7;
            _os_log_error_impl(&dword_19BD16000, v55, OS_LOG_TYPE_ERROR, "%@, bad request message ID old %u new %u", buf, 0x18u);
          }

        }
      }

    }
    v61 = a3;
    if (!a3)
    {
      v62 = objc_getProperty((id)a1, v34, 360, 1);
      v61 = -[NEIKEv2RTT nextRetransmissionInterval]((uint64_t)v62);
    }
    if (a4)
    {
      v63 = objc_getProperty((id)a1, v34, 336, 1);
      if (!v63 || (v63[13] & 1) == 0)
      {
        v64 = objc_getProperty((id)a1, v34, 368, 1);
        v65 = dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, v64);
        objc_setProperty_atomic((id)a1, v66, v65, 296);

        if (!objc_getProperty((id)a1, v67, 296, 1))
        {
          ne_log_obj();
          v59 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v59, OS_LOG_TYPE_FAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_fault_impl(&dword_19BD16000, v59, OS_LOG_TYPE_FAULT, "dispatch_source_create failed", buf, 2u);
          }
          goto LABEL_62;
        }
        *(_QWORD *)buf = 0;
        *(_QWORD *)&buf[8] = buf;
        *(_QWORD *)&buf[16] = 0x2020000000;
        v106[0] = a4;
        v69 = 1000000 * v61;
        v70 = objc_getProperty((id)a1, v68, 296, 1);
        v71 = dispatch_time(0x8000000000000000, v69);
        dispatch_source_set_timer(v70, v71, 0xFFFFFFFFFFFFFFFFLL, 0);

        v73 = objc_getProperty((id)a1, v72, 296, 1);
        handler[0] = MEMORY[0x1E0C809B0];
        handler[1] = 3221225472;
        handler[2] = __138__NEIKEv2Session_sendRequest_retryIntervalInMilliseconds_maxRetries_timeoutError_resend_sendMessageID_sendCompletionHandler_replyHandler___block_invoke_62;
        handler[3] = &unk_1E3CC17E8;
        v97 = buf;
        handler[4] = a1;
        v99 = a7;
        v100 = a4;
        v95 = v24;
        v98 = a3;
        v96 = v86;
        dispatch_source_set_event_handler(v73, handler);
        v75 = objc_getProperty((id)a1, v74, 296, 1);
        dispatch_activate(v75);

        _Block_object_dispose(buf, 8);
      }
    }
    v76 = (id *)objc_getProperty((id)a1, v34, 336, 1);
    v59 = -[NEIKEv2IKESA copyTransport](v76, v77);
    if (v59)
    {
      v90[0] = MEMORY[0x1E0C809B0];
      v90[1] = 3221225472;
      v90[2] = __138__NEIKEv2Session_sendRequest_retryIntervalInMilliseconds_maxRetries_timeoutError_resend_sendMessageID_sendCompletionHandler_replyHandler___block_invoke_68;
      v90[3] = &unk_1E3CC1810;
      v90[4] = a1;
      v92 = v15;
      v91 = v24;
      v93 = a7;
      -[NEIKEv2Transport waitForTransport:]((uint64_t)v59, v90);

      goto LABEL_63;
    }
    if (v15)
    {
      v79 = objc_getProperty((id)a1, v78, 368, 1);
      v88[0] = MEMORY[0x1E0C809B0];
      v88[1] = 3221225472;
      v88[2] = __138__NEIKEv2Session_sendRequest_retryIntervalInMilliseconds_maxRetries_timeoutError_resend_sendMessageID_sendCompletionHandler_replyHandler___block_invoke_2;
      v88[3] = &unk_1E3CC4720;
      v89 = v15;
      dispatch_async(v79, v88);

    }
    v59 = 0;
LABEL_62:
    a7 = 0xFFFFFFFFLL;
    goto LABEL_63;
  }
  ne_log_obj();
  v21 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 138412290;
    *(_QWORD *)&buf[4] = a1;
    _os_log_error_impl(&dword_19BD16000, v21, OS_LOG_TYPE_ERROR, "%@ last request still outstanding", buf, 0xCu);
  }

  if (v15)
  {
    v23 = objc_getProperty((id)a1, v22, 368, 1);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = __138__NEIKEv2Session_sendRequest_retryIntervalInMilliseconds_maxRetries_timeoutError_resend_sendMessageID_sendCompletionHandler_replyHandler___block_invoke;
    block[3] = &unk_1E3CC4720;
    v104 = v15;
    dispatch_async(v23, block);
    a7 = 0xFFFFFFFFLL;
    v24 = v104;
LABEL_65:

    goto LABEL_66;
  }
  a7 = 0xFFFFFFFFLL;
LABEL_66:

  return a7;
}

uint64_t __138__NEIKEv2Session_sendRequest_retryIntervalInMilliseconds_maxRetries_timeoutError_resend_sendMessageID_sendCompletionHandler_replyHandler___block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t __138__NEIKEv2Session_sendRequest_retryIntervalInMilliseconds_maxRetries_timeoutError_resend_sendMessageID_sendCompletionHandler_replyHandler___block_invoke_61(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void __138__NEIKEv2Session_sendRequest_retryIntervalInMilliseconds_maxRetries_timeoutError_resend_sendMessageID_sendCompletionHandler_replyHandler___block_invoke_62(uint64_t a1, const char *a2)
{
  NSObject *v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  const char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  id Property;
  id v17;
  NSObject *v18;
  dispatch_time_t v19;
  const char *v20;
  NSObject *v21;
  id v22;
  const char *v23;
  id v24;
  const char *v25;
  void *v26;
  _BYTE *v27;
  const char *v28;
  void *v29;
  id *v30;
  const char *v31;
  id *v32;
  unsigned __int8 *v33;
  NSObject *v34;
  SEL v35;
  __int16 v36;
  const char *v37;
  const char *v38;
  id WeakRetained;
  const char *v40;
  id v41;
  NSObject *v42;
  NSObject *v43;
  uint64_t v44;
  int v45;
  int v46;
  const char *v47;
  uint64_t v48;
  void *ErrorFailedToSend;
  const char *v50;
  unint64_t v51;
  id v52;
  SEL v53;
  id v54;
  SEL v55;
  id v56;
  NEIKEv2Transport *v57;
  SEL v58;
  SEL v59;
  id v60;
  SEL v61;
  id v62;
  SEL v63;
  id v64;
  const char *v65;
  id v66;
  SEL v67;
  SEL v68;
  id v69;
  const char *v70;
  id v71;
  SEL v72;
  SEL v73;
  id v74;
  id v75;
  NSObject *v76;
  uint64_t v77;
  int v78;
  int v79;
  const char *v80;
  id v81;
  id v82;
  void *v83;
  const char *v84;
  _QWORD v85[5];
  id v86;
  uint64_t v87;
  _BYTE buf[24];
  void *v89;
  id *v90;
  uint8_t v91[4];
  const char *v92;
  uint64_t v93;

  v93 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24))
  {
    ne_log_obj();
    v3 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
    {
      v4 = *(_QWORD *)(a1 + 32);
      v5 = *(_DWORD *)(a1 + 72);
      v6 = *(_DWORD *)(a1 + 76);
      v7 = v6 - *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24);
      *(_DWORD *)buf = 138413058;
      *(_QWORD *)&buf[4] = v4;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v5;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v7;
      LOWORD(v89) = 1024;
      *(_DWORD *)((char *)&v89 + 2) = v6;
      _os_log_impl(&dword_19BD16000, v3, OS_LOG_TYPE_INFO, "%@ Retry sending request %u (%u/%u), closing", buf, 0x1Eu);
    }

    if ((-[NEIKEv2Session sendCurrentRequest:](*(_QWORD *)(a1 + 32), 0) & 1) != 0)
    {
      v15 = *(_QWORD *)(a1 + 64);
      if (!v15)
      {
        Property = *(id *)(a1 + 32);
        if (Property)
          Property = objc_getProperty(Property, v8, 360, 1);
        v15 = -[NEIKEv2RTT nextRetransmissionInterval]((uint64_t)Property);
      }
      --*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24);
      v17 = *(id *)(a1 + 32);
      if (v17)
        v17 = objc_getProperty(v17, v8, 296, 1);
      v18 = v17;
      v19 = dispatch_time(0x8000000000000000, 1000000 * v15);
      dispatch_source_set_timer(v18, v19, 0xFFFFFFFFFFFFFFFFLL, 0);

      v21 = *(NSObject **)(a1 + 32);
      if (v21)
        v21 = objc_getProperty(v21, v20, 296, 1);
      dispatch_activate(v21);
      return;
    }
    v48 = *(_QWORD *)(a1 + 40);
    ErrorFailedToSend = (void *)NEIKEv2CreateErrorFailedToSend(CFSTR("request %u attempt %u/%u"), (uint64_t)v8, v9, v10, v11, v12, v13, v14, *(unsigned int *)(a1 + 72));
    -[NEIKEv2IKESA setState:error:](v48, 3uLL, ErrorFailedToSend);

LABEL_40:
    -[NEIKEv2Session cancelSendTimer](*(void **)(a1 + 32), v47);
    return;
  }
  if (*(_DWORD *)(a1 + 72))
  {
LABEL_36:
    ne_log_obj();
    v43 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v43, OS_LOG_TYPE_INFO))
    {
      v44 = *(_QWORD *)(a1 + 32);
      v46 = *(_DWORD *)(a1 + 72);
      v45 = *(_DWORD *)(a1 + 76);
      *(_DWORD *)buf = 138412802;
      *(_QWORD *)&buf[4] = v44;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v45;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v46;
      _os_log_impl(&dword_19BD16000, v43, OS_LOG_TYPE_INFO, "%@ Hit max send retries (%u) for request %u, closing", buf, 0x18u);
    }

    -[NEIKEv2IKESA setState:error:](*(_QWORD *)(a1 + 40), 3uLL, *(void **)(a1 + 48));
    goto LABEL_40;
  }
  v22 = *(id *)(a1 + 32);
  if (v22)
  {
    v22 = objc_getProperty(v22, a2, 336, 1);
    if (v22)
      v22 = objc_getProperty(v22, v23, 80, 1);
  }
  v24 = v22;
  if (!objc_msgSend(v24, "allowTCPEncapsulation")
    || (v26 = *(void **)(a1 + 32)) == 0
    || (v27 = objc_getProperty(v26, v25, 336, 1)) != 0 && (v27[13] & 1) != 0
    || (v29 = *(void **)(a1 + 32)) == 0
    || (v30 = (id *)objc_getProperty(v29, v28, 336, 1)) == 0)
  {
LABEL_35:

    goto LABEL_36;
  }
  v32 = v30;
  *((_BYTE *)v30 + 13) = 1;
  *((_BYTE *)v30 + 10) = 0;
  v33 = (unsigned __int8 *)objc_msgSend(objc_getProperty(v30, v31, 72, 1), "address");
  if (!v33)
  {
    ne_log_obj();
    v34 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v34, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)v91 = 136315138;
      v92 = "-[NEIKEv2IKESA switchToTCPEncapsulation]";
      v84 = "%s called with null remoteAddress";
LABEL_59:
      _os_log_fault_impl(&dword_19BD16000, v34, OS_LOG_TYPE_FAULT, v84, v91, 0xCu);
    }
LABEL_34:

    goto LABEL_35;
  }
  if (*v33 <= 0xFu)
  {
    ne_log_obj();
    v34 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v34, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)v91 = 136315138;
      v92 = "-[NEIKEv2IKESA switchToTCPEncapsulation]";
      v84 = "%s called with null (remoteAddress->sa_len >= sizeof(struct sockaddr_in))";
      goto LABEL_59;
    }
    goto LABEL_34;
  }
  objc_msgSend(MEMORY[0x1E0CCEC58], "endpointWithAddress:", v33);
  v34 = objc_claimAutoreleasedReturnValue();
  v36 = __rev16(objc_msgSend(objc_getProperty(v32, v35, 80, 1), "tcpEncapsulationPort"));
  *(_WORD *)(-[NSObject address](v34, "address") + 2) = v36;
  if (!*(_WORD *)(-[NSObject address](v34, "address") + 2))
    *(_WORD *)(-[NSObject address](v34, "address") + 2) = -27631;
  if (!objc_getProperty(v32, v37, 480, 1))
  {
    WeakRetained = objc_loadWeakRetained(v32 + 70);
    v41 = objc_loadWeakRetained(v32 + 68);
    if ((*((_BYTE *)v32 + 25) & 1) != 0 && !WeakRetained)
    {
      ne_log_obj();
      v42 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)v91 = 0;
        _os_log_error_impl(&dword_19BD16000, v42, OS_LOG_TYPE_ERROR, "Cannot create transport for packet delegate, delegate no longer valid", v91, 2u);
      }

      goto LABEL_34;
    }
    if (objc_msgSend(objc_getProperty(v32, v40, 80, 1), "useTLSForTCPEncapsulation"))
      v51 = 3;
    else
      v51 = 2;
    v52 = objc_getProperty(v32, v50, 304, 1);
    v54 = objc_getProperty(v32, v53, 536, 1);
    v56 = objc_getProperty(v32, v55, 552, 1);
    v57 = +[NEIKEv2Transport createTransport:remote:local:localPort:boundInterface:queue:socketGetBlock:packetDelegate:]((uint64_t)NEIKEv2Transport, v51, v34, 0, 0, v52, v54, v56, WeakRetained);

    objc_setProperty_atomic(v32, v58, v57, 480);
    v60 = objc_getProperty(v32, v59, 480, 1);
    v62 = objc_getProperty(v32, v61, 32, 1);
    -[NEIKEv2Transport addClient:delegate:](v60, v62, v41);

    v64 = objc_getProperty(v32, v63, 480, 1);
    if (v64)
      v64 = objc_getProperty(v64, v65, 24, 1);
    v66 = v64;
    objc_setProperty_atomic(v32, v67, v66, 72);

    v69 = objc_getProperty(v32, v68, 480, 1);
    if (v69)
      v69 = objc_getProperty(v69, v70, 16, 1);
    v71 = v69;
    objc_setProperty_atomic(v32, v72, v71, 64);

    v74 = objc_getProperty(v32, v73, 480, 1);
    *(_QWORD *)buf = MEMORY[0x1E0C809B0];
    *(_QWORD *)&buf[8] = 3221225472;
    *(_QWORD *)&buf[16] = __40__NEIKEv2IKESA_switchToTCPEncapsulation__block_invoke;
    v89 = &unk_1E3CC41F0;
    v90 = v32;
    -[NEIKEv2Transport waitForTransport:]((uint64_t)v74, buf);

  }
  v75 = objc_getProperty(v32, v38, 480, 1);

  if (!v75)
    goto LABEL_36;
  ne_log_obj();
  v76 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v76, OS_LOG_TYPE_INFO))
  {
    v77 = *(_QWORD *)(a1 + 32);
    v79 = *(_DWORD *)(a1 + 72);
    v78 = *(_DWORD *)(a1 + 76);
    *(_DWORD *)buf = 138412802;
    *(_QWORD *)&buf[4] = v77;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v78;
    *(_WORD *)&buf[18] = 1024;
    *(_DWORD *)&buf[20] = v79;
    _os_log_impl(&dword_19BD16000, v76, OS_LOG_TYPE_INFO, "%@ Hit max send retries (%u) for request %u, trying TCP encapsulation", buf, 0x18u);
  }

  v81 = *(id *)(a1 + 32);
  if (v81)
    v81 = objc_getProperty(v81, v80, 336, 1);
  v82 = -[NEIKEv2IKESA copyTransport]((id *)v81, v80);
  v85[0] = MEMORY[0x1E0C809B0];
  v85[1] = 3221225472;
  v85[2] = __138__NEIKEv2Session_sendRequest_retryIntervalInMilliseconds_maxRetries_timeoutError_resend_sendMessageID_sendCompletionHandler_replyHandler___block_invoke_65;
  v85[3] = &unk_1E3CC17C0;
  v83 = *(void **)(a1 + 40);
  v85[4] = *(_QWORD *)(a1 + 32);
  v86 = v83;
  v87 = *(_QWORD *)(a1 + 72);
  -[NEIKEv2Transport waitForTransport:]((uint64_t)v82, v85);

}

void __138__NEIKEv2Session_sendRequest_retryIntervalInMilliseconds_maxRetries_timeoutError_resend_sendMessageID_sendCompletionHandler_replyHandler___block_invoke_68(uint64_t a1, const char *a2)
{
  id Property;
  const char *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  id ErrorFailedToSend;

  Property = *(id *)(a1 + 32);
  if (Property)
    Property = objc_getProperty(Property, a2, 336, 1);
  -[NEIKEv2IKESA resyncAddress]((id *)Property, a2);
  if ((-[NEIKEv2Session sendCurrentRequest:](*(_QWORD *)(a1 + 32), *(void **)(a1 + 48)) & 1) == 0)
  {
    -[NEIKEv2Session cancelSendTimer](*(void **)(a1 + 32), v4);
    v5 = *(_QWORD *)(a1 + 40);
    ErrorFailedToSend = (id)NEIKEv2CreateErrorFailedToSend(CFSTR("request %u"), v6, v7, v8, v9, v10, v11, v12, *(unsigned int *)(a1 + 56));
    -[NEIKEv2IKESA setState:error:](v5, 3uLL, ErrorFailedToSend);

  }
}

uint64_t __138__NEIKEv2Session_sendRequest_retryIntervalInMilliseconds_maxRetries_timeoutError_resend_sendMessageID_sendCompletionHandler_replyHandler___block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void __138__NEIKEv2Session_sendRequest_retryIntervalInMilliseconds_maxRetries_timeoutError_resend_sendMessageID_sendCompletionHandler_replyHandler___block_invoke_65(uint64_t a1, const char *a2)
{
  id Property;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *ErrorFailedToSend;
  const char *v13;

  Property = *(id *)(a1 + 32);
  if (Property)
    Property = objc_getProperty(Property, a2, 336, 1);
  -[NEIKEv2IKESA resyncAddress]((id *)Property, a2);
  if ((-[NEIKEv2Session sendCurrentRequest:](*(_QWORD *)(a1 + 32), 0) & 1) == 0)
  {
    v11 = *(_QWORD *)(a1 + 40);
    ErrorFailedToSend = (void *)NEIKEv2CreateErrorFailedToSend(CFSTR("request %u attempts %u"), v4, v5, v6, v7, v8, v9, v10, *(unsigned int *)(a1 + 48));
    -[NEIKEv2IKESA setState:error:](v11, 3uLL, ErrorFailedToSend);

    -[NEIKEv2Session cancelSendTimer](*(void **)(a1 + 32), v13);
  }
}

- (uint64_t)sendRequest:(uint64_t)a1 retry:(void *)a2 replyHandler:(void *)a3
{
  id v5;
  const char *v6;
  id v7;
  _BYTE *Property;
  int v9;
  void *Error;
  NSObject *v12;
  uint8_t buf[4];
  const char *v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v5 = a2;
  v7 = a3;
  if (a1)
  {
    if (v5)
    {
      Property = objc_getProperty((id)a1, v6, 336, 1);
      v9 = 4;
      if (Property)
      {
        if ((Property[17] & 1) != 0)
          v9 = 12;
        else
          v9 = 4;
      }
      Error = (void *)NEIKEv2CreateError(3);
      a1 = -[NEIKEv2Session sendRequest:retryIntervalInMilliseconds:maxRetries:timeoutError:resend:sendMessageID:sendCompletionHandler:replyHandler:](a1, v5, 0, v9, Error, 0, 0xFFFFFFFFLL, 0, v7);

    }
    else
    {
      ne_log_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136315138;
        v14 = "-[NEIKEv2Session sendRequest:retry:replyHandler:]";
        _os_log_fault_impl(&dword_19BD16000, v12, OS_LOG_TYPE_FAULT, "%s called with null packet", buf, 0xCu);
      }

      a1 = 0xFFFFFFFFLL;
    }
  }

  return a1;
}

- (uint64_t)sendReply:(void *)a3 replyHandler:
{
  _DWORD *v5;
  const char *v6;
  void (**v7)(id, _QWORD);
  NSObject *Property;
  SEL v9;
  const char *v10;
  id v11;
  void *v12;
  id v13;
  void *v14;
  void *v15;
  const char *v16;
  NSObject *v17;
  NSObject *v18;
  uint64_t v19;
  id v20;
  id v21;
  NSObject *v22;
  SEL v23;
  _BYTE *v24;
  void *v25;
  SEL v26;
  id v27;
  const char *v28;
  SEL v29;
  SEL v30;
  const char *v31;
  NSObject *v32;
  dispatch_source_t v33;
  void *v34;
  NSObject *v35;
  dispatch_time_t v36;
  NSObject *v37;
  uint64_t v38;
  id v39;
  SEL v40;
  id v41;
  void *v42;
  id v43;
  void *v44;
  NSObject *v45;
  NSObject *v46;
  int v48;
  const char *v49;
  _QWORD handler[5];
  uint8_t buf[4];
  const char *v52;
  __int16 v53;
  _DWORD *v54;
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  v5 = a2;
  v7 = a3;
  if (!a1)
    goto LABEL_12;
  Property = objc_getProperty((id)a1, v6, 368, 1);
  dispatch_assert_queue_V2(Property);
  if (objc_getProperty((id)a1, v9, 336, 1))
  {
    if (v5)
    {
      if ((*((_BYTE *)v5 + 10) & 1) != 0)
      {
        v11 = objc_getProperty((id)a1, v10, 224, 1);
        v12 = (void *)MEMORY[0x1E0CB37E8];
        v13 = v11;
        objc_msgSend(v12, "numberWithInt:", v5[6]);
        v14 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v13, "objectForKeyedSubscript:", v14);
        v15 = (void *)objc_claimAutoreleasedReturnValue();

        if (v15)
        {
          ne_log_obj();
          v17 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
          {
            v48 = v5[6];
            *(_DWORD *)buf = 138412546;
            v52 = (const char *)a1;
            v53 = 1024;
            LODWORD(v54) = v48;
            _os_log_error_impl(&dword_19BD16000, v17, OS_LOG_TYPE_ERROR, "%@ Already sent reply %u, skipping new reply", buf, 0x12u);
          }

          if (v7)
            v7[2](v7, 0);
          goto LABEL_12;
        }
        *(_BYTE *)(a1 + 11) = 0;
        v20 = objc_getProperty((id)a1, v16, 336, 1);
        v21 = -[NEIKEv2Packet copyPacketDatagramsForIKESA:](v5, v20);
        if (!v21)
        {
          ne_log_obj();
          v45 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 138412290;
            v52 = (const char *)a1;
            _os_log_error_impl(&dword_19BD16000, v45, OS_LOG_TYPE_ERROR, "%@ Failed to generate datagrams from packet", buf, 0xCu);
          }

          if (v7)
            v7[2](v7, 0);
          goto LABEL_36;
        }
        ne_log_large_obj();
        v22 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 138412546;
          v52 = (const char *)a1;
          v53 = 2112;
          v54 = v5;
          _os_log_impl(&dword_19BD16000, v22, OS_LOG_TYPE_INFO, "%@ Sending reply: %@", buf, 0x16u);
        }

        v24 = objc_getProperty((id)a1, v23, 336, 1);
        if ((!v24 || (v24[9] & 1) == 0) && !v5[6] && objc_msgSend(v21, "count") == 1)
        {
          objc_msgSend(v21, "firstObject");
          v25 = (void *)objc_claimAutoreleasedReturnValue();
          v27 = objc_getProperty((id)a1, v26, 336, 1);
          if (v27)
            objc_setProperty_atomic(v27, v28, v25, 312);

        }
        -[NEIKEv2Session fireWaitingRequestHandlerWithPacket:]((_QWORD *)a1, 0);
        objc_setProperty_atomic_copy((id)a1, v29, v7, 208);
        if (objc_getProperty((id)a1, v30, 208, 1))
        {
          v32 = objc_getProperty((id)a1, v31, 368, 1);
          v33 = dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, v32);
          objc_storeStrong((id *)(a1 + 304), v33);

          v34 = *(void **)(a1 + 304);
          if (!v34)
          {
            ne_log_obj();
            v46 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v46, OS_LOG_TYPE_FAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_fault_impl(&dword_19BD16000, v46, OS_LOG_TYPE_FAULT, "dispatch_source_create failed", buf, 2u);
            }

LABEL_35:
            -[NEIKEv2Session fireWaitingRequestHandlerWithPacket:]((_QWORD *)a1, 0);
LABEL_36:
            v19 = 0;
LABEL_37:

            goto LABEL_38;
          }
          v35 = v34;
          v36 = dispatch_time(0x8000000000000000, 30000000000);
          dispatch_source_set_timer(v35, v36, 0xFFFFFFFFFFFFFFFFLL, 0);

          v37 = *(NSObject **)(a1 + 304);
          handler[0] = MEMORY[0x1E0C809B0];
          handler[1] = 3221225472;
          handler[2] = __41__NEIKEv2Session_sendReply_replyHandler___block_invoke;
          handler[3] = &unk_1E3CC41F0;
          handler[4] = a1;
          dispatch_source_set_event_handler(v37, handler);
          dispatch_activate(*(dispatch_object_t *)(a1 + 304));
        }
        v38 = v5[6];
        v39 = v21;
        v19 = 1;
        v41 = objc_getProperty((id)a1, v40, 224, 1);
        v42 = (void *)MEMORY[0x1E0CB37E8];
        v43 = v41;
        objc_msgSend(v42, "numberWithInt:", v38);
        v44 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v43, "setObject:forKeyedSubscript:", v39, v44);

        if ((-[NEIKEv2Session sendReplyForMessageID:]((_BYTE *)a1, (const char *)v5[6]) & 1) != 0)
          goto LABEL_37;
        goto LABEL_35;
      }
      ne_log_obj();
      v18 = objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v18, OS_LOG_TYPE_FAULT))
        goto LABEL_11;
      *(_DWORD *)buf = 136315138;
      v52 = "-[NEIKEv2Session sendReply:replyHandler:]";
      v49 = "%s called with null packet.isResponse";
    }
    else
    {
      ne_log_obj();
      v18 = objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v18, OS_LOG_TYPE_FAULT))
        goto LABEL_11;
      *(_DWORD *)buf = 136315138;
      v52 = "-[NEIKEv2Session sendReply:replyHandler:]";
      v49 = "%s called with null packet";
    }
    goto LABEL_40;
  }
  ne_log_obj();
  v18 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)buf = 136315138;
    v52 = "-[NEIKEv2Session sendReply:replyHandler:]";
    v49 = "%s called with null self.ikeSA";
LABEL_40:
    _os_log_fault_impl(&dword_19BD16000, v18, OS_LOG_TYPE_FAULT, v49, buf, 0xCu);
  }
LABEL_11:

LABEL_12:
  v19 = 0;
LABEL_38:

  return v19;
}

uint64_t __41__NEIKEv2Session_sendReply_replyHandler___block_invoke(uint64_t a1)
{
  NSObject *v2;
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  ne_log_obj();
  v2 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    v4 = *(_QWORD *)(a1 + 32);
    v5 = 138412290;
    v6 = v4;
    _os_log_error_impl(&dword_19BD16000, v2, OS_LOG_TYPE_ERROR, "%@ Timed out waiting for next request", (uint8_t *)&v5, 0xCu);
  }

  return -[NEIKEv2Session fireWaitingRequestHandlerWithPacket:](*(_QWORD **)(a1 + 32), 0);
}

- (void)finishConfigurationEstablishment
{
  const char *v3;
  const char *v4;
  NSObject *v5;
  int v6;
  const char *v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (objc_getProperty(a1, a2, 336, 1))
    {
      if ((a1[11] & 1) == 0)
      {
        -[NEIKEv2Session startIKELifetimeTimer](a1, v3);
        -[NEIKEv2Session startDPDTimer](a1, v4);
      }
    }
    else
    {
      ne_log_obj();
      v5 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT))
      {
        v6 = 136315138;
        v7 = "-[NEIKEv2Session finishConfigurationEstablishment]";
        _os_log_fault_impl(&dword_19BD16000, v5, OS_LOG_TYPE_FAULT, "%s called with null self.ikeSA", (uint8_t *)&v6, 0xCu);
      }

    }
  }
}

id __48__NEIKEv2Session_sendAnalyticsOfChosenProtocols__block_invoke(_QWORD *a1)
{
  const __CFString *v1;
  const __CFString *v2;
  const __CFString *v3;
  const __CFString *v4;
  const __CFString *v5;
  uint64_t v6;
  const __CFString *v7;
  const __CFString *v8;
  const __CFString *v9;
  const __CFString *v10;
  const __CFString *v11;
  uint64_t v12;
  _QWORD v14[14];
  _QWORD v15[15];

  v15[14] = *MEMORY[0x1E0C80C00];
  v14[0] = CFSTR("ChosenIKESAEncryptionProtocol");
  v14[1] = CFSTR("ChosenIKESAIntegrityProtocol");
  v1 = CFSTR("<unknown>");
  v2 = (const __CFString *)a1[4];
  v3 = (const __CFString *)a1[5];
  if (!v2)
    v2 = CFSTR("<unknown>");
  if (!v3)
    v3 = CFSTR("<unknown>");
  v15[0] = v2;
  v15[1] = v3;
  v14[2] = CFSTR("ChosenIKESAPRFProtocol");
  v14[3] = CFSTR("ChosenIKESADHProtocol");
  v4 = (const __CFString *)a1[6];
  v5 = (const __CFString *)a1[7];
  if (!v4)
    v4 = CFSTR("<unknown>");
  if (!v5)
    v5 = CFSTR("<unknown>");
  v15[2] = v4;
  v15[3] = v5;
  v14[4] = CFSTR("RemoteHasPreferredIKESADHProtocol");
  v14[5] = CFSTR("IsIKESACookieIncluded");
  v6 = a1[9];
  v15[4] = a1[8];
  v15[5] = v6;
  v14[6] = CFSTR("ChosenIKEChildSAEncryptionProtocol");
  v14[7] = CFSTR("ChosenIKEChildSAIntegrityProtocol");
  v7 = (const __CFString *)a1[10];
  v8 = (const __CFString *)a1[11];
  if (!v7)
    v7 = CFSTR("<unknown>");
  if (!v8)
    v8 = CFSTR("<unknown>");
  v15[6] = v7;
  v15[7] = v8;
  v14[8] = CFSTR("LocalAuthProtocolUsed");
  v14[9] = CFSTR("RemoteAuthProtocolUsed");
  v9 = (const __CFString *)a1[12];
  v10 = (const __CFString *)a1[13];
  if (!v9)
    v9 = CFSTR("<unknown>");
  if (!v10)
    v10 = CFSTR("<unknown>");
  v15[8] = v9;
  v15[9] = v10;
  v14[10] = CFSTR("EAPProtocolUsed");
  v14[11] = CFSTR("LocalNonceSize");
  v11 = (const __CFString *)a1[14];
  v12 = a1[15];
  if (!v11)
    v11 = CFSTR("<unknown>");
  v15[10] = v11;
  v15[11] = v12;
  v14[12] = CFSTR("RemoteNonceSize");
  v14[13] = CFSTR("ProcessName");
  if (a1[17])
    v1 = (const __CFString *)a1[17];
  v15[12] = a1[16];
  v15[13] = v1;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v15, v14, 14);
  return (id)objc_claimAutoreleasedReturnValue();
}

- (void)reportConfiguration
{
  id Property;
  const char *v4;
  id v5;
  SEL v6;
  void *v7;
  void *v8;
  NSObject *v9;
  _QWORD v10[5];
  id v11;

  if (a1)
  {
    Property = objc_getProperty(a1, a2, 336, 1);
    if (Property)
      Property = objc_getProperty(Property, v4, 488, 1);
    v5 = Property;
    objc_setProperty_atomic(a1, v6, v5, 48);

    objc_msgSend(a1, "configurationUpdateBlock");
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    if (v7)
    {
      objc_msgSend(a1, "clientQueue");
      v8 = (void *)objc_claimAutoreleasedReturnValue();

      if (v8)
      {
        objc_msgSend(a1, "clientQueue");
        v9 = objc_claimAutoreleasedReturnValue();
        v10[0] = MEMORY[0x1E0C809B0];
        v10[1] = 3221225472;
        v10[2] = __37__NEIKEv2Session_reportConfiguration__block_invoke;
        v10[3] = &unk_1E3CC46A8;
        v10[4] = a1;
        v11 = v7;
        dispatch_async(v9, v10);

      }
    }

  }
}

void __37__NEIKEv2Session_reportConfiguration__block_invoke(uint64_t a1)
{
  _BYTE *v2;
  uint64_t v3;
  id v4;

  v2 = *(_BYTE **)(a1 + 32);
  if (!v2 || (v2[12] & 1) == 0)
  {
    v3 = *(_QWORD *)(a1 + 40);
    objc_msgSend(v2, "assignedConfiguration");
    v4 = (id)objc_claimAutoreleasedReturnValue();
    (*(void (**)(uint64_t, id))(v3 + 16))(v3, v4);

  }
}

_QWORD *__50__NEIKEv2Session_reportServerAdditionalAddresses___block_invoke(_QWORD *result)
{
  uint64_t v1;

  v1 = result[4];
  if (!v1 || (*(_BYTE *)(v1 + 12) & 1) == 0)
    return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(result[6] + 16))(result[6], result[5]);
  return result;
}

- (void)reportServerRedirect:(void *)a1
{
  id v3;
  const char *v4;
  void *v5;
  NSObject *v6;
  const char *v7;
  NSObject *v8;
  NSObject *v9;
  NSObject *v10;
  const char *v11;
  unsigned __int8 *v12;
  uint64_t v13;
  unint64_t v14;
  NSObject *v15;
  int v16;
  int v17;
  const char *v18;
  uint8_t *v19;
  NSObject *v20;
  uint32_t v21;
  int v22;
  void *v23;
  void *v24;
  int v25;
  int v26;
  int v27;
  int v28;
  void *v29;
  void *v30;
  NSObject *v31;
  _QWORD block[5];
  id v33;
  id v34;
  uint8_t buf[24];
  int v36;
  int v37;
  int v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  v5 = v3;
  if (a1)
  {
    if (v3)
    {
      if (objc_getProperty(a1, v4, 336, 1))
      {
        v6 = -[NEIKEv2Packet copyNotification:](v5, (const char *)0x4017);
        v8 = v6;
        if (!v6)
        {
          v24 = 0;
LABEL_43:
          objc_msgSend(a1, "redirectEventBlock");
          v29 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(a1, "clientQueue");
          v30 = (void *)objc_claimAutoreleasedReturnValue();

          if (v30 && v29)
          {
            objc_msgSend(a1, "clientQueue");
            v31 = objc_claimAutoreleasedReturnValue();
            block[0] = MEMORY[0x1E0C809B0];
            block[1] = 3221225472;
            block[2] = __39__NEIKEv2Session_reportServerRedirect___block_invoke;
            block[3] = &unk_1E3CC3A30;
            block[4] = a1;
            v34 = v29;
            v33 = v24;
            dispatch_async(v31, block);

          }
          goto LABEL_47;
        }
        if (v6[3].isa != (Class)16407)
        {
          ne_log_obj();
          v9 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v9, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)buf = 138412290;
            *(_QWORD *)&buf[4] = v8;
            _os_log_fault_impl(&dword_19BD16000, v9, OS_LOG_TYPE_FAULT, "Cannot copy server redirect nonce from notification %@", buf, 0xCu);
          }
          goto LABEL_41;
        }
        v9 = objc_getProperty(v6, v7, 32, 1);
        if ((unint64_t)-[NSObject length](v9, "length") <= 1)
        {
          ne_log_obj();
          v10 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 134217984;
            *(_QWORD *)&buf[4] = -[NSObject length](v9, "length");
            _os_log_error_impl(&dword_19BD16000, v10, OS_LOG_TYPE_ERROR, "Server redirect has invalid length %llu", buf, 0xCu);
          }

          goto LABEL_41;
        }
        v12 = (unsigned __int8 *)-[NSObject bytes](v9, "bytes");
        v13 = -[NSObject length](v9, "length");
        v14 = v12[1];
        if (v13 - 2 < v14)
        {
          ne_log_obj();
          v15 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
          {
            v16 = -[NSObject length](v9, "length");
            v17 = v12[1];
            *(_DWORD *)buf = 67109376;
            *(_DWORD *)&buf[4] = v16;
            *(_WORD *)&buf[8] = 1024;
            *(_DWORD *)&buf[10] = v17;
            v18 = "Server redirect has invalid length %u (gateway length %u)";
            v19 = buf;
            v20 = v15;
            v21 = 14;
LABEL_39:
            _os_log_error_impl(&dword_19BD16000, v20, OS_LOG_TYPE_ERROR, v18, v19, v21);
          }
LABEL_40:

LABEL_41:
          v24 = 0;
          goto LABEL_42;
        }
        v22 = *v12;
        switch(v22)
        {
          case 3:
            if (v12[1])
            {
              v23 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3940]), "initWithBytes:length:encoding:", v12 + 2, v12[1], 4);
              objc_msgSend(MEMORY[0x1E0CCEC80], "endpointWithHostname:port:", v23, CFSTR("0"));
              v24 = (void *)objc_claimAutoreleasedReturnValue();

LABEL_42:
              goto LABEL_43;
            }
            ne_log_obj();
            v15 = objc_claimAutoreleasedReturnValue();
            if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
              goto LABEL_40;
            v28 = v12[1];
            *(_DWORD *)buf = 67109120;
            *(_DWORD *)&buf[4] = v28;
            v18 = "Invalid FQDN length %u";
            break;
          case 2:
            memset(buf, 0, sizeof(buf));
            v36 = 0;
            if ((_DWORD)v14 == 16)
            {
              *(_WORD *)buf = 7708;
              *(_OWORD *)&buf[8] = *(_OWORD *)(v12 + 2);
              goto LABEL_27;
            }
            ne_log_obj();
            v15 = objc_claimAutoreleasedReturnValue();
            if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
              goto LABEL_40;
            v27 = v12[1];
            v37 = 67109120;
            v38 = v27;
            v18 = "Invalid IPv6 address length %u";
            goto LABEL_34;
          case 1:
            *(_QWORD *)buf = 0;
            *(_QWORD *)&buf[8] = 0;
            if ((_DWORD)v14 == 4)
            {
              *(_WORD *)buf = 528;
              *(_DWORD *)&buf[4] = *(_DWORD *)(v12 + 2);
LABEL_27:
              objc_msgSend(MEMORY[0x1E0CCEC58], "endpointWithAddress:", buf);
              v24 = (void *)objc_claimAutoreleasedReturnValue();
              goto LABEL_42;
            }
            ne_log_obj();
            v15 = objc_claimAutoreleasedReturnValue();
            if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
              goto LABEL_40;
            v26 = v12[1];
            v37 = 67109120;
            v38 = v26;
            v18 = "Invalid IPv4 address length %u";
LABEL_34:
            v19 = (uint8_t *)&v37;
LABEL_38:
            v20 = v15;
            v21 = 8;
            goto LABEL_39;
          default:
            ne_log_obj();
            v15 = objc_claimAutoreleasedReturnValue();
            if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
              goto LABEL_40;
            v25 = *v12;
            *(_DWORD *)buf = 67109120;
            *(_DWORD *)&buf[4] = v25;
            v18 = "Server redirect has invalid type %u";
            break;
        }
        v19 = buf;
        goto LABEL_38;
      }
      ne_log_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v8, OS_LOG_TYPE_FAULT))
      {
LABEL_47:

        goto LABEL_48;
      }
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = "-[NEIKEv2Session reportServerRedirect:]";
      v11 = "%s called with null self.ikeSA";
    }
    else
    {
      ne_log_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v8, OS_LOG_TYPE_FAULT))
        goto LABEL_47;
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = "-[NEIKEv2Session reportServerRedirect:]";
      v11 = "%s called with null packet";
    }
    _os_log_fault_impl(&dword_19BD16000, v8, OS_LOG_TYPE_FAULT, v11, buf, 0xCu);
    goto LABEL_47;
  }
LABEL_48:

}

_QWORD *__39__NEIKEv2Session_reportServerRedirect___block_invoke(_QWORD *result)
{
  uint64_t v1;

  v1 = result[4];
  if (!v1 || (*(_BYTE *)(v1 + 12) & 1) == 0)
    return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(result[6] + 16))(result[6], result[5]);
  return result;
}

uint64_t __32__NEIKEv2Session_reportShortDPD__block_invoke(uint64_t result)
{
  uint64_t v1;

  v1 = *(_QWORD *)(result + 32);
  if (!v1 || (*(_BYTE *)(v1 + 12) & 1) == 0)
    return (*(uint64_t (**)(void))(*(_QWORD *)(result + 40) + 16))();
  return result;
}

- (void)reportPrivateNotifies:(void *)a1
{
  id v3;
  void *v4;
  void *v5;
  void *v6;
  NSObject *v7;
  id v8;
  _QWORD block[5];
  id v10;
  id v11;

  v3 = a2;
  if (a1)
  {
    objc_msgSend(a1, "privateNotifyStatusEvent");
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(a1, "clientQueue");
    v5 = (void *)objc_claimAutoreleasedReturnValue();

    if (v5 && v4)
    {
      v6 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99D20]), "initWithArray:copyItems:", v3, 1);
      objc_msgSend(a1, "clientQueue");
      v7 = objc_claimAutoreleasedReturnValue();
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 3221225472;
      block[2] = __40__NEIKEv2Session_reportPrivateNotifies___block_invoke;
      block[3] = &unk_1E3CC3A30;
      block[4] = a1;
      v10 = v6;
      v11 = v4;
      v8 = v6;
      dispatch_async(v7, block);

    }
  }

}

_QWORD *__40__NEIKEv2Session_reportPrivateNotifies___block_invoke(_QWORD *result)
{
  uint64_t v1;

  v1 = result[4];
  if (!v1 || (*(_BYTE *)(v1 + 12) & 1) == 0)
    return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(result[6] + 16))(result[6], result[5]);
  return result;
}

- (id)copySAsToDeleteAndInstallRekeyedChildSA:(id)a1
{
  id v3;
  void *v4;
  const char *v5;
  id v6;
  id Property;
  id v8;
  void *v9;
  SEL v10;
  SEL v11;
  id v12;
  id v13;
  NSObject *v15;
  int v16;
  const char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  v4 = v3;
  if (a1)
  {
    if (v3)
    {
      v6 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
      if (!v6)
        goto LABEL_9;
      Property = objc_getProperty(a1, v5, 192, 1);
      v8 = -[NEIKEv2Session copySAFromDictionary:forChild:](Property, v4);
      if (v8)
      {
        v9 = v8;
        do
        {
          objc_msgSend(v6, "addObject:", v9);
          objc_msgSend(objc_getProperty(a1, v10, 192, 1), "setObject:forKeyedSubscript:", 0, v9);
          v12 = objc_getProperty(a1, v11, 192, 1);
          v13 = -[NEIKEv2Session copySAFromDictionary:forChild:](v12, v4);

          v9 = v13;
        }
        while (v13);
      }
      if (-[NEIKEv2Session installChildSA:]((uint64_t)a1, v4))
        a1 = v6;
      else
LABEL_9:
        a1 = 0;

    }
    else
    {
      ne_log_obj();
      v15 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_FAULT))
      {
        v16 = 136315138;
        v17 = "-[NEIKEv2Session copySAsToDeleteAndInstallRekeyedChildSA:]";
        _os_log_fault_impl(&dword_19BD16000, v15, OS_LOG_TYPE_FAULT, "%s called with null childSA", (uint8_t *)&v16, 0xCu);
      }

      a1 = 0;
    }
  }

  return a1;
}

- (void)uninstallOldRekeyedChildSAs:(void *)a1
{
  id v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t i;
  uint64_t v9;
  NSObject *v10;
  const char *v11;
  id Property;
  SEL v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  uint8_t buf[4];
  void *v19;
  __int16 v20;
  id v21;
  __int16 v22;
  uint64_t v23;
  _BYTE v24[128];
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  v4 = v3;
  if (a1)
  {
    v16 = 0u;
    v17 = 0u;
    v14 = 0u;
    v15 = 0u;
    v5 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v14, v24, 16);
    if (v5)
    {
      v6 = v5;
      v7 = *(_QWORD *)v15;
      do
      {
        for (i = 0; i != v6; ++i)
        {
          if (*(_QWORD *)v15 != v7)
            objc_enumerationMutation(v4);
          v9 = *(_QWORD *)(*((_QWORD *)&v14 + 1) + 8 * i);
          ne_log_obj();
          v10 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
          {
            Property = objc_getProperty(a1, v11, 176, 1);
            *(_DWORD *)buf = 138412802;
            v19 = a1;
            v20 = 2112;
            v21 = Property;
            v22 = 2112;
            v23 = v9;
            _os_log_impl(&dword_19BD16000, v10, OS_LOG_TYPE_DEFAULT, "%@ %@ Uninstalling old rekeyed child SA %@", buf, 0x20u);
          }

          objc_msgSend(objc_getProperty(a1, v13, 176, 1), "removeSA:", v9);
        }
        v6 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v14, v24, 16);
      }
      while (v6);
    }
  }

}

- (void)reportTrafficSelectorsForChildSA:(void *)a1
{
  _DWORD *v3;
  const char *v4;
  void *v5;
  int v6;
  NSObject *v7;
  SEL v8;
  void *v9;
  void *v10;
  void *v11;
  NSObject *v12;
  _QWORD block[5];
  NSObject *v14;
  id v15;
  id v16;
  int v17;
  uint8_t buf[4];
  const char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  v5 = v3;
  if (a1)
  {
    if (v3)
    {
      v6 = v3[4];
      objc_getProperty(v3, v4, 64, 1);
      v7 = objc_claimAutoreleasedReturnValue();
      objc_getProperty(v5, v8, 72, 1);
      v9 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(a1, "trafficSelectorUpdateBlock");
      v10 = (void *)objc_claimAutoreleasedReturnValue();
      if (v10)
      {
        objc_msgSend(a1, "clientQueue");
        v11 = (void *)objc_claimAutoreleasedReturnValue();

        if (v11)
        {
          objc_msgSend(a1, "clientQueue");
          v12 = objc_claimAutoreleasedReturnValue();
          block[0] = MEMORY[0x1E0C809B0];
          block[1] = 3221225472;
          block[2] = __51__NEIKEv2Session_reportTrafficSelectorsForChildSA___block_invoke;
          block[3] = &unk_1E3CC1888;
          block[4] = a1;
          v16 = v10;
          v17 = v6;
          v14 = v7;
          v15 = v9;
          dispatch_async(v12, block);

        }
      }

    }
    else
    {
      ne_log_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136315138;
        v19 = "-[NEIKEv2Session reportTrafficSelectorsForChildSA:]";
        _os_log_fault_impl(&dword_19BD16000, v7, OS_LOG_TYPE_FAULT, "%s called with null childSA", buf, 0xCu);
      }
    }

  }
}

uint64_t __51__NEIKEv2Session_reportTrafficSelectorsForChildSA___block_invoke(uint64_t result)
{
  uint64_t v1;

  v1 = *(_QWORD *)(result + 32);
  if (!v1 || (*(_BYTE *)(v1 + 12) & 1) == 0)
    return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)(result + 56) + 16))(*(_QWORD *)(result + 56), *(unsigned int *)(result + 64), *(_QWORD *)(result + 40), *(_QWORD *)(result + 48));
  return result;
}

- (void)setPendingPrivateNotifies:(uint64_t)a1
{
  if (a1)
    objc_storeStrong((id *)(a1 + 392), a2);
}

@end
